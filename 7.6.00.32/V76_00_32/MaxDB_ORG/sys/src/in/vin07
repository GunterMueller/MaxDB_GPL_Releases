.CM  SCRIPT , Version - 1.1 , last edited by D.Dittmar
.pa
.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VIN07$
.tt 2 $$$
.TT 3 $$setparms$2000-01-07$
***********************************************************
.nf
 
.nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : setparms
=========
.sp
Purpose : Initialization of the SET parameters
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              i07initsetparms (
                    component  : tsp4_component );
 
        PROCEDURE
              i07setformat_and_lang;
 
        PROCEDURE
              i07showsetparms (
                    component  : tsp00_C8;
                    release_id : tsp00_C8;
                    VAR show   : tin_show_set;
                    VAR exit   : boolean );
 
        PROCEDURE
              i07readsetparm (
                    setid   : tsp00_Int2;
                    VAR buf : tsp00_Buf;
                    VAR len : tsp00_Int2);
 
        PROCEDURE
              i07nodbset (
                    component  : tsp4_component );
 
        FUNCTION
              in0730 : tsp00_Int4;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              global_variable : VIN01;
 
        VAR
              i01g : tin_global_in_vars;
 
      ------------------------------ 
 
        FROM
              messages : VIN03;
 
        PROCEDURE
              i03mfinit (
                    VAR msgnos : tin_msgnos);
 
        PROCEDURE
              i03mfset (
                    msgno      : tsp00_Int2;
                    VAR msgnos : tin_msgnos);
 
        PROCEDURE
              i03mfrange (
                    msgno1     : tsp00_Int2;
                    msgno2     : tsp00_Int2;
                    VAR msgnos : tin_msgnos);
 
        PROCEDURE
              i03mfetch (
                    VAR msg_nos  : tin_msgnos);
 
      ------------------------------ 
 
        FROM
              printersets : VIN06;
 
        PROCEDURE
              i06newattr (
                    VAR attr_name : tsp00_Name;
                    VAR ok        : boolean );
 
        PROCEDURE
              i06attrsel (
                    VAR act_attr_name : tsp00_Name;
                    from_sysdba       : boolean;
                    VAR ok            : boolean );
 
        PROCEDURE
              i06attrdefault (
                    VAR act_attr_name : tsp00_Name);
 
        PROCEDURE
              i06setattr;
 
        PROCEDURE
              i06psetsel (
                    VAR act_print_name  : tsp00_Name;
                    from_sysdba         : boolean;
                    VAR ok              : boolean );
 
        PROCEDURE
              i06psetdefault;
 
        PROCEDURE
              i06presentation (
                    component        : tsp00_C8;
                    release_id       : tsp00_C8;
                    VAR presentation : tin_attrset_type;
                    VAR attr_change  : boolean;
                    VAR exit         : boolean );
 
        PROCEDURE
              i06printerset (
                    component         : tsp00_C8;
                    release_id        : tsp00_C8;
                    VAR printformat   : tin_pset_type;
                    VAR printerchange : boolean;
                    VAR exit          : boolean );
 
      ------------------------------ 
 
        FROM
              inscreen-setparms : VIN08;
 
        PROCEDURE
              i08replacesetparms (
                    VAR show     : tin_show_set;
                    VAR input    : tin_ls_input_field;
                    VAR csr_pos  : tin_ls_position;
                    VAR msg_no   : integer;
                    VAR err_no   : integer;
                    read_screen  : boolean);
 
      ------------------------------ 
 
        FROM
              general-setprocedures : VIN09;
 
        PROCEDURE
              i09putonoff (
                    i01g         : tin_global_in_vars;
                    on_off       : boolean;
                    VAR s40      : tsp00_C40 );
 
        PROCEDURE
              i09selectsetparms (
                    i01g      : tin_global_in_vars;
                    is_sysdba : boolean;
                    VAR ok    : boolean);
 
        PROCEDURE
              i09readsetparms (
                    i01g : tin_global_in_vars);
 
        PROCEDURE
              i09setformat (
                    i01g : tin_global_in_vars);
 
        PROCEDURE
              i09setlang (
                    i01g : tin_global_in_vars);
 
        PROCEDURE
              i09getmsg (
                    i01g    : tin_global_in_vars;
                    msg_no  : integer;
                    VAR msg : tin_screenline) ;
 
        PROCEDURE
              i09execute (
                    i01g    : tin_global_in_vars;
                    msg_no  : integer );
 
        PROCEDURE
              i09itoc40 (
                    val     : tsp00_Int4;
                    VAR s40 : tsp00_C40);
 
      ------------------------------ 
 
        FROM
              SQLDB-command-interface: VIN20;
 
        FUNCTION
              i20dbok : boolean;
 
      ------------------------------ 
 
        FROM
              logical_screen : VIN50;
 
        PROCEDURE
              i50put1field (
                    VAR field  : tin_screenline;
                    length     : tin_natural;
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype);
 
        PROCEDURE
              i50put2field (
                    VAR field  : tsp00_C40;
                    length     : tin_natural;
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype);
 
        PROCEDURE
              i50clear (
                    part : tin_ls_part);
 
        PROCEDURE
              i50getwindow (
                    first_pos          : tin_ls_position;
                    window_len         : tin_natural;
                    window_width       : tin_natural;
                    VAR window_changed : boolean);
 
      ------------------------------ 
 
        FROM
              logical_screen_layout : VIN51;
 
        PROCEDURE
              i51size (
                    screen_part : tin_ls_part;
                    VAR length  : tin_natural;
                    VAR width   : tin_natural);
 
        PROCEDURE
              i51layout (
                    functionmenu_length : tin_natural;
                    inputarea_length    : tin_natural;
                    message_lines       : tin_natural);
 
      ------------------------------ 
 
        FROM
              logical_screen_modules : VIN56;
 
        PROCEDURE
              i56title (
                    blinking_modefield : boolean;
                    screen_nr          : integer;
                    VAR title          : tsp00_OnlineHeader);
 
        PROCEDURE
              i56putlabels (
                    fct_cursorpos      : tin_ls_releasemode;
                    functionline_label : boolean);
 
        PROCEDURE
              i56putframe (
                    with_name   :  boolean;
                    with_parms  :  boolean );
&       ifdef WINDOWS
 
        PROCEDURE
              i56setmark (
                    screen_nr     : tsp00_Int2;
                    screenpart    : tin_ls_part;
                    mode          : tsp00_VtMark;
                    top, left     : tsp00_Int2;
                    bottom, right : tsp00_Int2 );
&       endif
 
      ------------------------------ 
 
        FROM
              logical_screen_IO : VIN57 ;
 
        PROCEDURE
              i57ioscreen (
                    VAR csr_pos        : tin_ls_position;
                    VAR rf             : tin_ls_releasemode;
                    VAR screen_changed : boolean);
 
      ------------------------------ 
 
        FROM
              os_filenames : VIN60;
 
        PROCEDURE
              i60osfilename (
                    sf     : tin_standardfiles;
                    VAR fn : tsp00_VFilename);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30: VSP30;
 
        FUNCTION
              s30lnr (
                    VAR str : tsp00_C10;
                    skipval : char;
                    start   : tsp00_Int4;
                    length  : tsp00_Int4) : tsp00_Int4;
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              i50put1field;
 
              tsp00_MoveObj tin_screenline
 
        PROCEDURE
              i50put2field;
 
              tsp00_MoveObj tsp00_C40
 
        PROCEDURE
              s30lnr;
 
              tsp00_MoveObj tsp00_C10
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1988-04-25
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-01-07
.sp
***********************************************************
.sp
.cp 20
.fo
.oc _/1
Specification:
 
   PROCEDURE i07INITSETPARMS;
   ------------------------
.sp;.fo
Serves to initialize I01_G.SET_PARMS and is called immediately
after a successful logon.
APPL, DB_AUFTRAG.APPL_PID and DB_AUFTRAG.SERVER_PID must be assigned
in I01_GLOB.
.sp;.cp 5
The SET parameters that are currently valid for this user are read into
SET_PARMS from the database.
.sp;.cp 3
If no entry is yet present, the values of the users owner
are read in.
.sp;.cp 3
If access to the database is not successful, SET_PARMS is assigned
the default values.
.sp 3;.cp 6;.nf
   PROCEDURE i07SHOWSETPARMS ( ID, RELNO, SHOW );
   -----------------------------------------------
.sp;.fo
Used for the display and modification of I01_G.SET_PARMS on the screen;
after i07INITSETPARMS, can be called at any point in a program.
.sp;.cp 5
That which is to be located in the upper left-hand
corner of the screen, e.g. the component name with release number,
is passed in ID_MODE.
.sp;.cp 5
The set parameters that are to be displayed are specified in SHOW,
e.g. SHOW := [ 1..4 ] means that the first parameter (language) to the
fourth parameter (l_sep) are displayed.
.sp
SET parameters that are modified are stored immediately.  If this is
not possible (e.g. SYSSET does not exist) a warning message is
displayed that must be acknowledged.
 
.CM *-END-* specification -------------------------------
.sp 2.fo
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
TYPE
      (* used to save the linenumber of each of the set parameters *)
      tin07_parm_lineno_array = ARRAY [cin_set_username..mxin_setparms]
            OF tsp00_Uint1;
 
CONST
      cin07_colno        =  1;
      cin07_fieldlen     = 30;
      cin07_from_sysdba  = true;
      cin07_own_entry    = false;
 
 
(*------------------------------*) 
 
FUNCTION
      in0730 : tsp00_Int4;
 
BEGIN
(* linkcheck function *)
in0730 := 219020722;
END;
 
(*------------------------------*) 
 
PROCEDURE
      i07initsetparms (
            component  : tsp4_component );
 
CONST
      c_user = false;
      c_sysdba = true;
 
VAR
      ok          : boolean;
      is_sysdba   : boolean;
 
BEGIN
i01g^.set_parms.change := false;
WITH i01g^.session [i01g^.dbno] DO
    is_sysdba := user_ident = system_user;
(*ENDWITH*) 
i09selectsetparms (i01g, c_user, ok);
IF  ok
THEN
    i09readsetparms (i01g)
ELSE
    IF  NOT is_sysdba
    THEN
        BEGIN
        i09selectsetparms (i01g, c_sysdba, ok);
        IF  ok
        THEN
            i09readsetparms (i01g);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  NOT ok
THEN
    in071_default;
(*ENDIF*) 
in071_setattrandprint (component);
&ifndef WINDOWS
i06setattr;
&endif
i09setlang (i01g);
i09setformat (i01g);
END;
 
(*------------------------------*) 
 
PROCEDURE
      in071_setattrandprint (
            component  : tsp4_component );
 
BEGIN
in071_setattr ( component );
in071_setprint;
END; (* i07_setattrandprint *)
 
(*------------------------------*) 
 
PROCEDURE
      in071_setattr (
            component  : tsp4_component );
 
VAR
      user        : tsp00_KnlIdentifier;
      ok          : boolean;
      is_sysdba   : boolean;
 
BEGIN
user := i01g^.session [i01g^.dbno].user_ident;
is_sysdba := user = i01g^.session [i01g^.dbno].system_user;
WITH i01g^.set_parms DO
    BEGIN
    CASE component OF
        sp4co_sql_easy   :
            BEGIN
            i06attrsel (yepres, cin07_own_entry, ok);
            IF  NOT ok AND NOT is_sysdba
            THEN
                i06attrsel (yepres, cin07_from_sysdba, ok);
            (*ENDIF*) 
            IF  NOT ok
            THEN
                BEGIN
                presentation.count := 0;
                i06attrdefault (yepres);
                END;
            (*ENDIF*) 
            END;
        sp4co_sql_query  :
            BEGIN
            i06attrsel (qupres, cin07_own_entry, ok);
            IF  NOT ok AND NOT is_sysdba
            THEN
                i06attrsel (qupres, cin07_from_sysdba, ok);
            (*ENDIF*) 
            IF  NOT ok
            THEN
                BEGIN
                presentation.count := 0;
                i06attrdefault (qupres);
                END;
            (*ENDIF*) 
            END;
        sp4co_sql_dialog,
        sp4co_sql_appl    :
            BEGIN
            i06attrsel (plpres, cin07_own_entry, ok);
            IF  NOT ok AND NOT is_sysdba
            THEN
                i06attrsel (plpres, cin07_from_sysdba, ok);
            (*ENDIF*) 
            IF  NOT ok
            THEN
                BEGIN
                presentation.count := 0;
                i06attrdefault (plpres);
                END;
            (*ENDIF*) 
            END;
        sp4co_sql_load   :
            BEGIN
            i06attrsel (lopres, cin07_own_entry, ok);
            IF  NOT ok AND NOT is_sysdba
            THEN
                i06attrsel (lopres, cin07_from_sysdba, ok);
            (*ENDIF*) 
            IF  NOT ok
            THEN
                BEGIN
                presentation.count := 0;
                i06attrdefault (lopres);
                END;
            (*ENDIF*) 
            END;
        OTHERWISE
        END;
    (*ENDCASE*) 
    END;
(*ENDWITH*) 
END; (* in071_setattr *)
 
(*------------------------------*) 
 
PROCEDURE
      in071_setprint;
 
VAR
      user        : tsp00_KnlIdentifier;
      ok          : boolean;
      is_sysdba   : boolean;
 
BEGIN
user := i01g^.session [i01g^.dbno].user_ident;
is_sysdba := user = i01g^.session [i01g^.dbno].system_user;
WITH i01g^.set_parms DO
    BEGIN
    i06psetsel (act_print_name, cin07_own_entry, ok);
    IF  NOT ok AND NOT is_sysdba
    THEN
        i06psetsel (act_print_name, cin07_from_sysdba, ok);
    (*ENDIF*) 
    IF  NOT ok
    THEN
        WITH printformat DO
            BEGIN
            count := 0;
            i06psetdefault;
            act_print_name := printerset [act_print].formatname;
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* in071_setprint *)
 
(*------------------------------*) 
 
PROCEDURE
      i07setformat_and_lang;
 
BEGIN
i09setlang (i01g);
i09setformat (i01g);
END; (* i07setformat_and_lang *)
 
(*------------------------------*) 
 
PROCEDURE
      i07showsetparms (
            component  : tsp00_C8;
            release_id : tsp00_C8;
            VAR show   : tin_show_set;
            VAR exit   : boolean );
 
CONST
      functionmenu_length = 1;
      inputarea_length    = 0;
      message_lines       = 1;
 
VAR
      old_comp     : tin_component_id;
      old_ls       : tin_ls_record;
      old_key_type : tin_ls_key_type;
      vt           : tin_vt_record;
      all_show     : tin_show_set;
      all_cnt      : integer;
      easy_show    : tin_show_set;
      easy_cnt     : integer;
 
BEGIN
exit := false;
&ifdef WINDOWS
i56setmark (1, cin_ls_workarea, vt_mark_off, 0, 0, 0, 0);
show := show - [ cin_set_language,
      cin_set_yepres,
      cin_set_lopres,
      cin_set_qupres ];
&endif
vt := i01g^.vt;
old_comp := i01g^.i20.comp;
i01g^.i20.comp := cin_k_set;
(* save screen layout *)
WITH i01g^ DO
    BEGIN
    old_ls := ls;
    old_key_type := key_type;
    END;
(*ENDWITH*) 
(* new layout *)
i51layout (functionmenu_length, inputarea_length, message_lines);
i50clear (cin_ls_basic_window);
init_showset (show, all_show, all_cnt,
      easy_show, easy_cnt);
putout_setscreen (component, release_id, all_show, all_cnt,
      easy_show, easy_cnt, exit);
(* restore layout *)
WITH i01g^ DO
    BEGIN
    ls := old_ls;
    key_type := old_key_type;
    END;
(*ENDWITH*) 
i01g^.i20.comp := old_comp;
i01g^.vt := vt;
END; (* i07showsetparms *)
 
(*------------------------------*) 
 
PROCEDURE
      init_showset (
            VAR show       : tin_show_set;
            VAR all_show   : tin_show_set;
            VAR all_cnt    : integer;
            VAR easy_show  : tin_show_set;
            VAR easy_cnt   : integer);
 
VAR
      i         : integer;
      maxshow   : tin_natural;
      not_used  : tin_natural;
 
BEGIN
fetch_setmessages (show);
i51size (cin_ls_workarea, maxshow, not_used);
all_cnt := 0;
all_show := show;
easy_cnt := 0;
easy_show := [ ];
FOR i := 1 TO mxin_setparms DO
    IF  i in all_show
    THEN
        BEGIN
        IF  NOT is_easy_parm ( i, all_show, easy_show, easy_cnt )
        THEN
            IF  all_cnt <= maxshow
            THEN
                all_cnt := all_cnt + 1
            ELSE
                all_show := all_show -  [i] ;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDFOR*) 
END; (* init_showset *)
 
(*------------------------------*) 
 
PROCEDURE
      fetch_setmessages (
            VAR show : tin_show_set);
 
VAR
      i        : integer;
      messages : tin_msgnos;
 
BEGIN
i03mfinit ( messages );
i03mfrange (cin_setmsg_first, cin_setmsg_last, messages);
(* i03mfrange (17801, 17803, messages); *)
FOR i := cin_set_language TO mxin_setparms DO
    IF  i IN show
    THEN
        i03mfset (cin_setmsg_nameoffset+ i, messages);
    (*ENDIF*) 
(*ENDFOR*) 
i03mfetch (messages);
END; (* fetch_setmessages *)
 
(*------------------------------*) 
 
PROCEDURE
      putout_setscreen (
            VAR component  : tsp00_C8;
            VAR release_id : tsp00_C8;
            VAR all_show   : tin_show_set;
            all_cnt        : integer;
            VAR easy_show  : tin_show_set;
            easy_cnt       : integer;
            VAR exit       : boolean );
 
VAR
      parm_lno       : tin07_parm_lineno_array;
      easyswap       : boolean;
      screen_changed : boolean;
      helpcnt        : integer;
      msg_no         : integer;
      err_no         : integer;
      input          : tin_ls_input_field;
      rf             : tin_ls_releasemode;
      csr_pos        : tin_ls_position;
      screen_pos     : tin_ls_position;
      date_pos       : tin_ls_position;
      msg            : tin_screenline;
      helpshow       : tin_show_set;
      pres_show      : tin_show_set;
      save_set       : tin_set_parms_record;
      save_component : tsp00_C8;
      save_comp_enum : tsp4_component;
      multi_pres     : boolean;
      selected_pres  : tin_show_set;
      save_pres_name : tsp00_Name;
      comp_pres_name : tsp00_Name;
      okay           : boolean;
 
BEGIN
multi_pres := false;
save_set := i01g^.set_parms;
(* 12.01.1995 h.b. Probleme auf der AIX: weiter unten nach set_key *)
(*
      helpcnt := all_cnt;
      helpshow := all_show;
      *)
easyswap := true;
CASE i01g^.i20.comp_enum OF
    sp4co_sql_easy :
        pres_show := [ cin_set_yepres ];
    sp4co_sql_query :
        pres_show := [ cin_set_qupres ];
    sp4co_sql_dialog, sp4co_sql_appl :
        BEGIN
        pres_show := [ cin_set_plpres ];
        IF  ( cin_set_lopres IN all_show )
            OR  ( cin_set_qupres IN all_show )
            OR  ( cin_set_yepres IN all_show )
        THEN
            BEGIN
            multi_pres := true;
            (*   pres_show := [ cin_set_controlpres ];*)
            END;
        (*ENDIF*) 
        END;
    sp4co_sql_load :
        pres_show := [ cin_set_lopres ];
    OTHERWISE :
        pres_show := [ ];
    END;
(*ENDCASE*) 
(* 12.01.1995 h.b. Probleme auf der AIX: Uebergabe an eine Hilfsvar. *)
helpshow := all_show + easy_show;
in071_set_keys (helpshow);
helpcnt := all_cnt;
helpshow := all_show;
IF  easy_cnt > 0
THEN
    WITH i01g^.key_type DO
        activated := activated + [ f11 ];
    (*ENDWITH*) 
(*ENDIF*) 
set_first_pos (helpcnt, csr_pos);
screen_pos := csr_pos;
msg_no := cin_setmsg_go_ahead;
err_no := cin_setmsg_go_ahead;
IF  i20dbok
THEN
    BEGIN
    REPEAT
        i50clear (cin_ls_workarea);
        in071_put_label;
        i56putlabels (f_clear, false);
        WITH i01g^.vt.opt DO
            BEGIN
            wait_for_input := true;
            usage_mode := vt_form;
            return_on_last  := false;
            return_on_first := false;
            returnkeys      := [  ] ;
            reject_keys     := [  ] ;
            bell := false;
            END;
        (*ENDWITH*) 
        construct_setscreen (component, release_id, helpcnt,
              msg_no, msg, helpshow, parm_lno, date_pos);
        i57ioscreen (csr_pos, rf, screen_changed);
        msg_no := cin_setmsg_go_ahead;
        IF  NOT (rf in [f9, f_end, f_exit, f_clear])
        THEN
            BEGIN
            i09execute (i01g, cin_setmsg_storesetparms);
            IF  screen_changed
            THEN
                BEGIN
                i50getwindow (screen_pos, 999, 999, screen_changed);
                csr_pos := date_pos;
                err_no := cin_setmsg_go_ahead;
                i08replacesetparms (helpshow, input, csr_pos,
                      msg_no, err_no, true);
                END;
            (*ENDIF*) 
            IF  err_no <> cin_setmsg_go_ahead
            THEN
                msg_no := err_no;
            (*ENDIF*) 
            IF  (rf = f8)
            THEN
                BEGIN
                (* DEFAULT-key *)
                in071_default;
                in071_setattrandprint (i01g^.i20.comp_enum);
                i01g^.set_parms.change := true;
                END;
            (*ENDIF*) 
            IF  (rf = f1) AND (msg_no = cin_setmsg_go_ahead)
            THEN
                BEGIN
                (* SAVE-key *)
                (* i09execute (i01g, cin_setmsg_storesetparms); *)
                i09setlang (i01g);
                i09setformat (i01g);
                i01g^.set_parms.change := true;
                END;
            (*ENDIF*) 
            IF  (rf = f4) AND (cin_set_printformat in (all_show + easy_show) )
                AND (msg_no = cin_setmsg_go_ahead)
            THEN
                BEGIN
                (* PRINTER-key *)
                in071_printer_menu (component, release_id,
                      save_set.act_print_name, save_set.printformat, exit);
                save_set.change := i01g^.set_parms.change;
                END;
&           ifndef WINDOWS
            (*ENDIF*) 
            IF  ( pres_show * (all_show + easy_show) <> [ ])
                AND (msg_no = cin_setmsg_go_ahead)
                AND (rf = f5)
            THEN
                BEGIN
                (* PRESENTATION-key *)
                IF  ( i01g^.i20.comp_enum in
                    [ sp4co_sql_dialog, sp4co_sql_appl ] )
                    AND multi_pres
                THEN
                    BEGIN
                    (* ------------------------------------------ *)
                    (* More than one presentation                 *)
                    (* This variant is used by CONTROL to make    *)
                    (* the SET parameters of the sysdba updatable *)
                    (* all at once.  B.J. 1994-11-09              *)
                    (* ------------------------------------------ *)
                    save_component := component;
                    save_comp_enum := i01g^.i20.comp_enum;
                    WITH  i01g^.set_parms.presentation DO
                        save_pres_name := attrset [act_attr].attr_name;
                    (*ENDWITH*) 
                    IF  in071_csr_on_presentation (component, all_show,
                        selected_pres, csr_pos, parm_lno, comp_pres_name)
                    THEN
                        BEGIN
                        i06newattr ( comp_pres_name, okay );
                        (*    in071_setattr (i01g^.i20.comp_enum);
                              i06setattr;      *)
                        in071_presentation_menu (component, release_id,
                              selected_pres, save_set, exit);
                        save_set.change := i01g^.set_parms.change;
                        END
                    ELSE
                        msg_no := cin_setmsg_select_pres;
                    (*ENDIF*) 
                    component           := save_component;
                    i01g^.i20.comp_enum := save_comp_enum;
                    i06newattr ( save_pres_name, okay );
                    (*   in071_setattr (i01g^.i20.comp_enum);
                          i06setattr;  *)
                    END
                ELSE
                    BEGIN
                    in071_presentation_menu (component, release_id,
                          pres_show, save_set, exit);
                    save_set.change := i01g^.set_parms.change;
                    END;
                (*ENDIF*) 
                END;
&           endif
            (*ENDIF*) 
            IF  (rf in [f11, f12]) AND (msg_no = cin_setmsg_go_ahead)
            THEN
                BEGIN
                (* UP/DOWN-keys *)
                IF  easyswap
                THEN
                    BEGIN
                    helpcnt := easy_cnt;
                    helpshow := easy_show;
                    WITH i01g^.key_type DO
                        activated := activated + [ f12 ] - [ f11 ];
                    (*ENDWITH*) 
                    END
                ELSE
                    BEGIN
                    helpcnt := all_cnt;
                    helpshow := all_show;
                    WITH i01g^.key_type DO
                        activated := activated + [ f11 ] - [ f12 ];
                    (*ENDWITH*) 
                    END;
                (*ENDIF*) 
                easyswap := NOT easyswap;
                set_first_pos (helpcnt, csr_pos);
                screen_pos := csr_pos;
                END;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            i01g^.set_parms := save_set;
            exit := rf = f_exit;
            END;
        (*ENDIF*) 
    UNTIL
        exit OR (NOT i20dbok)
        OR (rf in [f9, f_clear, f_end, f_exit])
        OR ((rf = f1) AND (msg_no = cin_setmsg_go_ahead))
    (*ENDREPEAT*) 
    END;
(*ENDIF*) 
END; (* putout_setscreen *)
 
(*------------------------------*) 
 
PROCEDURE
      in071_default;
 
BEGIN
WITH i01g^.set_parms DO
    BEGIN
    change                 := false; (* use SYSSET.ins initialization *)
&   ifndef WINDOWS
    (* B.M. 16.06.93 : ifndef WINDOWS *)
    language               := cin_k_eng;
&   endif
    null                   := '?                   ';
    bool_presentation.truestr           := 'TRUE      ';
    bool_presentation.falsestr          := 'FALSE     ';
    decimal.thousand_token := ' ';
    decimal.zero_point     := '.';
    date.dm_type           := dm_int;
    date.msk               := cin_key_int;
    date.mlen              := mxin_key_int;
    time                   := date;
    timestamp              := time;
    sep                    := 'STANDARD            ';
    l_sep                  := 8;
    act_print_name         := 'DEFAULT           ';
    copy                   := 1;
&   if $OS = OS2
    syseditor              := 'EPM                                     ';
&   else
&   if $OS = DOS
    syseditor              := 'EDIT                                    ';
&   else
&   if $OS = WIN32
    syseditor              := 'NOTEPAD                                 ';
&   else
    syseditor              := 'vi                                      ';
&   endif
&   endif
&   endif
    editor                 := no_prefix;
    numeric_prefix         := false;
    lopres                 := 'DEFAULT           ';
    i60osfilename (loadprotfile, loadprot);
    transize               := 100;
    yepres                 := 'DEFAULT           ';
    lt_pres                := '< %1                                    ';
    le_pres                := '<= %1                                   ';
    gt_pres                := '> %1                                    ';
    ge_pres                := '>= %1                                   ';
    eq_pres                := '= %1                                    ';
    ne_pres                := '<> %1                                   ';
    not_pres               := '<> %1                                   ';
    in_pres                := '%1 | %2                                 ';
    betw_pres              := '%1  ..  %2                              ';
    sounds_pres            := ': %1                                    ';
    delimiter              := '/';
    fillchar               := '.';
    graficchar             := '|';
    ignore_case            := false;
    actualize_menu         := false;
    qupres                 := 'DEFAULT           ';
    i60osfilename (queryprotfile, queryprot);
    autoprot               := false;
    sqltime                := false;
    history                := false;
    plpres                 := 'DEFAULT           ';
    i60osfilename (dialogprotfile, plprot);
    pretty                 := false;
    nesting                := 20;
    code_area              := 128000;
    value_area             := 128000;
    dia_version            := 'TEST';
    dia_target_langs       := '                        ';
    END;
(*ENDWITH*) 
END; (* in071_default *)
 
(*------------------------------*) 
 
PROCEDURE
      i07nodbset (
            component  : tsp4_component );
 
BEGIN
in071_default;
WITH i01g^.set_parms DO
    BEGIN
    presentation.count := 0;
    CASE component OF
        sp4co_sql_easy   :
            i06attrdefault (yepres);
        sp4co_sql_query  :
            i06attrdefault (qupres);
        sp4co_sql_dialog,
        sp4co_sql_appl    :
            i06attrdefault (plpres);
        sp4co_sql_load   :
            i06attrdefault (lopres);
        OTHERWISE
        END;
    (*ENDCASE*) 
    WITH printformat DO
        BEGIN
        count := 0;
        i06psetdefault;
        act_print_name := printerset [act_print].formatname;
        END;
    (*ENDWITH*) 
    END;
(*ENDWITH*) 
&ifndef WINDOWS
i06setattr;
&endif
END; (* i07setdefaults *)
 
(*------------------------------*) 
 
PROCEDURE
      in071_printer_menu (
            VAR component   : tsp00_C8;
            VAR release_id  : tsp00_C8;
            VAR printername : tsp00_Name;
            VAR print_parms : tin_pset_type;
            VAR exit        : boolean );
 
VAR
      printerchange : boolean;
 
BEGIN
exit := false;
i06printerset (component, release_id, i01g^.set_parms.printformat,
      printerchange, exit);
IF  printerchange
THEN
    print_parms := i01g^.set_parms.printformat
ELSE
    i01g^.set_parms.printformat := print_parms;
(*ENDIF*) 
IF  printerchange
THEN
    BEGIN
    WITH print_parms DO
        printername := printerset [act_print].formatname;
    (*ENDWITH*) 
    WITH i01g^.set_parms, printformat DO
        act_print_name := printerset [act_print].formatname;
    (*ENDWITH*) 
    i01g^.set_parms.change := true;
    END;
(*ENDIF*) 
END; (* in071_printer_menu *)
 
(*------------------------------*) 
 
PROCEDURE
      in071_presentation_menu (
            VAR component  : tsp00_C8;
            VAR release_id : tsp00_C8;
            pres_show      : tin_show_set;
            VAR save_set   : tin_set_parms_record;
            VAR exit       : boolean );
 
VAR
      attrib_change : boolean;
      pres_name     : tsp00_Name;
 
BEGIN
exit := false;
i06presentation (component, release_id, i01g^.set_parms.presentation,
      attrib_change, exit);
IF  attrib_change
THEN
    save_set.presentation := i01g^.set_parms.presentation
ELSE
    i01g^.set_parms.presentation := save_set.presentation;
(*ENDIF*) 
IF  attrib_change
THEN
    BEGIN
    WITH save_set.presentation DO
        pres_name := attrset [act_attr].attr_name;
    (*ENDWITH*) 
    IF  cin_set_yepres in pres_show
    THEN
        BEGIN
        i01g^.set_parms.yepres := pres_name;
        save_set.       yepres := pres_name;
        END;
    (*ENDIF*) 
    IF  cin_set_lopres in pres_show
    THEN
        BEGIN
        i01g^.set_parms.lopres := pres_name;
        save_set.       lopres := pres_name;
        END;
    (*    IF  cin_set_controlpres in pres_show
          THEN
          BEGIN
          i01g^.set_parms.plpres := pres_name;
          save_set.       plpres := pres_name;
          END;*)
    (*ENDIF*) 
    IF  cin_set_plpres in pres_show
    THEN
        BEGIN
        i01g^.set_parms.plpres := pres_name;
        save_set.       plpres := pres_name;
        END;
    (*ENDIF*) 
    IF  cin_set_qupres in pres_show
    THEN
        BEGIN
        i01g^.set_parms.qupres := pres_name;
        save_set.       qupres := pres_name;
        END;
    (*ENDIF*) 
    i01g^.set_parms.change := true;
    END;
&ifndef WINDOWS
(*ENDIF*) 
i06setattr;
&endif
END; (* in071_presentation_menu *)
 
(*------------------------------*) 
 
PROCEDURE
      construct_setscreen (
            VAR component  : tsp00_C8;
            VAR release_id : tsp00_C8;
            quantity       : integer;
            msg_no         : integer;
            VAR msg        : tin_screenline;
            VAR show       : tin_show_set;
            VAR parm_lno   : tin07_parm_lineno_array;
            VAR date_pos   : tin_ls_position);
 
VAR
      j          : integer;
      ci_pos     : tin_ls_position;
      val        : tsp00_Int4;
      s40        : tsp00_C40;
      field_type : tin_ls_fieldtype;
      boollen    : integer;
      (* fillchar etc... 89/09/07 B.M. *)
 
BEGIN
FOR  j := cin_set_username  TO mxin_setparms  DO
    parm_lno [j] := 0;
(*ENDFOR*) 
screenframe (component, release_id, msg_no, msg);
WITH field_type DO
    BEGIN
    field_att := cin_attr2;
    fieldmode := [ ls_input] ;
    END;
(*ENDWITH*) 
WITH i01g^.set_parms DO
    BEGIN
    set_first_pos (quantity, ci_pos);
    IF  to_be_shown (show, cin_set_language, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_language ] := ci_pos.sline;
        FOR j := 1 TO 3 DO
            s40  [j]  := language  [j] ;
        (*ENDFOR*) 
        i50put2field (s40, 3, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_null, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_null ] := ci_pos.sline;
        FOR j := 1 TO mxin_null_string DO
            s40  [j]  := null  [j] ;
        (*ENDFOR*) 
        field_type.fieldmode := [ ls_input] ;
        i50put2field (s40, mxin_null_string, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_boolean, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_boolean ] := ci_pos.sline;
        boollen := s30lnr (bool_presentation.truestr, bsp_c1, 1, mxin_bool_string);
        FOR j := 1 TO boollen DO
            s40  [j]  := bool_presentation.truestr  [j] ;
        (*ENDFOR*) 
        s40  [ boollen+1 ]  := '/';
        FOR j := 1 TO mxin_bool_string DO
            s40 [ boollen + 1 + j ]  := bool_presentation.falsestr [ j ];
        (*ENDFOR*) 
        field_type.fieldmode := [ ls_input] ;
        i50put2field (s40, boollen + 1 + mxin_bool_string,
              ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_decimal, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_decimal ] := ci_pos.sline;
        s40  [1]  := '/';
        (* N bedeutet, dass fuer thausend_token
              kein Zeichen angegeben ist *)
        IF  decimal.thousand_token <> cin_no_thousand_groups
        THEN
            BEGIN
            s40  [2]  := decimal.thousand_token;
            s40  [3]  := '/';
            s40  [4]  := decimal.zero_point;
            s40  [5]  := '/';
            END
        ELSE
            BEGIN
            s40  [2]  := '/';
            s40  [3]  := decimal.zero_point;
            s40  [4]  := '/';
            s40  [5]  := ' ';
            END;
        (*ENDIF*) 
        i50put2field (s40, 5, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_date, ci_pos)
    THEN
        BEGIN
        date_pos := ci_pos;
        parm_lno [ cin_set_date ] := ci_pos.sline;
        s10mv (mxin_date_mask_string,40,
              @date.msk,1,
              @s40,1,date.mlen);
        SAPDB_PascalForcedFill (40, @s40, date.mlen + 1, 40 - date.mlen, bsp_c1);
        i50put2field (s40, 40, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_time, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_time ] := ci_pos.sline;
        s10mv (mxin_date_mask_string,40,
              @time.msk,1,
              @s40,1,time.mlen);
        SAPDB_PascalForcedFill (40, @s40, time.mlen + 1, 40 - time.mlen, bsp_c1);
        i50put2field (s40, 40, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_timestamp, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_timestamp ] := ci_pos.sline;
        s10mv (mxin_date_mask_string,40,
              @timestamp.msk,1,
              @s40,1,timestamp.mlen);
        SAPDB_PascalForcedFill (40, @s40, timestamp.mlen + 1, 40 - timestamp.mlen, bsp_c1);
        i50put2field (s40, 40, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_sep, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_sep ] := ci_pos.sline;
        (* SEP enthaelt nur den echt auszugebenden String; beim Ein- *)
        (* lesen werden schliessende Blanks wegoptimiert => Solche   *)
        (* Separatoren muss man in Hochkommas geklammert eingeben.   *)
        SAPDB_PascalForcedFill (mxin_sep_string, @s40, 1, mxin_sep_string, ' ');
        IF  l_sep > 0
        THEN
            BEGIN
            IF  sep [ l_sep ] = bsp_c1
            THEN
                BEGIN
                s40  [1]  := '''';
                FOR j := 1 TO l_sep DO
                    s40 [ j+1 ] := sep  [j] ;
                (*ENDFOR*) 
                s40 [ l_sep + 2 ] := '''';
                END
            ELSE
                FOR j := 1 TO l_sep DO
                    s40  [j]  := sep  [j] ;
                (*ENDFOR*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        i50put2field (s40, mxin_sep_string, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_printformat, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_printformat ] := ci_pos.sline;
        FOR j := 1 TO 18 DO
            s40  [j]  := act_print_name [j];
        (*ENDFOR*) 
        i50put2field (s40, 18, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_copy, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_copy ] := ci_pos.sline;
        val := copy;
        i09itoc40 (val, s40);
        i50put2field (s40, 3, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_syseditor, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_syseditor ] := ci_pos.sline;
        s40 := syseditor;
        i50put2field (s40, 40, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_lopres, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_lopres ] := ci_pos.sline;
        FOR j := 1 TO 18 DO
            s40  [j]  := lopres  [j] ;
        (*ENDFOR*) 
        i50put2field (s40, 18, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_loadprot, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_loadprot ] := ci_pos.sline;
        s10mv (VFILENAME_MXSP00,40,
              @loadprot,1,
              @s40,1,40);
        i50put2field (s40, 40, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_transize, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_transize ] := ci_pos.sline;
        val := transize;
        i09itoc40 (val, s40);
        i50put2field (s40, 9, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_yepres, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_yepres ] := ci_pos.sline;
        FOR j := 1 TO 18 DO
            s40  [j]  := yepres  [j] ;
        (*ENDFOR*) 
        i50put2field (s40, 18, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_lt_pres, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_lt_pres ] := ci_pos.sline;
        i50put2field (lt_pres, 40, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_le_pres, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_le_pres ] := ci_pos.sline;
        i50put2field (le_pres, 40, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_gt_pres, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_gt_pres ] := ci_pos.sline;
        i50put2field (gt_pres, 40, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_ge_pres, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_ge_pres ] := ci_pos.sline;
        i50put2field (ge_pres, 40, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_eq_pres, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_eq_pres ] := ci_pos.sline;
        i50put2field (eq_pres, 40, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_ne_pres, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_ne_pres ] := ci_pos.sline;
        i50put2field (ne_pres, 40, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_not_pres, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_not_pres ] := ci_pos.sline;
        i50put2field (not_pres, 40, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_in_pres, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_in_pres ] := ci_pos.sline;
        i50put2field (in_pres, 40, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_betw_pres, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_betw_pres ] := ci_pos.sline;
        i50put2field (betw_pres, 40, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_sounds_pres, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_sounds_pres ] := ci_pos.sline;
        i50put2field (sounds_pres, 40, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_delimiter, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_delimiter ] := ci_pos.sline;
        s40  [1]  := delimiter;
        i50put2field (s40, 1, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_fillchar, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_fillchar ] := ci_pos.sline;
        s40  [1]  := fillchar;
        i50put2field (s40, 1, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_graficchar, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_graficchar ] := ci_pos.sline;
        s40  [1]  := graficchar;
        i50put2field (s40, 1, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_ignore_case, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_ignore_case ] := ci_pos.sline;
        i09putonoff (i01g, ignore_case, s40);
        i50put2field (s40, 5, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_actualize_menu, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_actualize_menu ] := ci_pos.sline;
        i09putonoff (i01g, actualize_menu, s40);
        i50put2field (s40, 5, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_qupres, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_qupres ] := ci_pos.sline;
        FOR j := 1 TO 18 DO
            s40  [j]  := qupres  [j] ;
        (*ENDFOR*) 
        i50put2field (s40, 18, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_queryprot, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_queryprot ] := ci_pos.sline;
        s10mv (VFILENAME_MXSP00,40,
              @queryprot,1,
              @s40,1,40);
        i50put2field (s40, 40, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_autoprot, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_autoprot ] := ci_pos.sline;
        i09putonoff (i01g, autoprot, s40);
        i50put2field (s40, 5, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_sqltime, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_sqltime ] := ci_pos.sline;
        i09putonoff (i01g, sqltime, s40);
        i50put2field (s40, 5, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_history, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_history ] := ci_pos.sline;
        i09putonoff (i01g, history, s40);
        i50put2field (s40, 5, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_controlpres, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_controlpres ] := ci_pos.sline;
        FOR j := 1 TO 18 DO
            s40  [j]  := plpres [j] ;
        (*ENDFOR*) 
        i50put2field (s40, 18, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END
    ELSE
        IF  to_be_shown (show, cin_set_plpres, ci_pos)
        THEN
            BEGIN
            parm_lno [ cin_set_plpres ] := ci_pos.sline;
            FOR j := 1 TO 18 DO
                s40  [j]  := plpres [j] ;
            (*ENDFOR*) 
            i50put2field (s40, 18, ci_pos, field_type);
            ci_pos.sline := ci_pos.sline + 1;
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_plprot, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_plprot ] := ci_pos.sline;
        s10mv (VFILENAME_MXSP00,40,
              @plprot,1,
              @s40,1,40);
        i50put2field (s40, 40, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_pretty, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_pretty ] := ci_pos.sline;
        i09putonoff (i01g, pretty, s40);
        i50put2field (s40, 5, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_nesting, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_nesting ] := ci_pos.sline;
        val := nesting;
        i09itoc40 (val, s40);
        i50put2field (s40, 3, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_code_area, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_code_area ] := ci_pos.sline;
        val := code_area;
        i09itoc40 (val, s40);
        i50put2field (s40, 9, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_value_area, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_value_area ] := ci_pos.sline;
        val := value_area;
        i09itoc40 (val, s40);
        i50put2field (s40, 9, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_dia_version, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_dia_version ] := ci_pos.sline;
        FOR j := 1 TO 4 DO
            s40  [j]  := dia_version  [j] ;
        (*ENDFOR*) 
        i50put2field (s40, 4, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    IF  to_be_shown (show, cin_set_dia_target_langs, ci_pos)
    THEN
        BEGIN
        parm_lno [ cin_set_dia_target_langs ] := ci_pos.sline;
        FOR j := 1 TO 24 DO
            s40  [j]  := dia_target_langs  [j] ;
        (*ENDFOR*) 
        i50put2field (s40, 24, ci_pos, field_type);
        ci_pos.sline := ci_pos.sline + 1;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* construct_setscreen *)
 
(*------------------------------*) 
 
PROCEDURE
      i07readsetparm (
            setid   : tsp00_Int2;
            VAR buf : tsp00_Buf;
            VAR len : tsp00_Int2);
 
VAR
      j    : integer;
      val  : tsp00_Int4;
      s40  : tsp00_C40;
 
BEGIN
WITH i01g^, i01g^.set_parms DO
    BEGIN
    CASE setid OF
        cin_set_language :
            BEGIN
            FOR j := 1 TO 3 DO
                s40  [j]  := language  [j] ;
            (*ENDFOR*) 
            len := 3;
            END;
        cin_set_null :
            BEGIN
            FOR j := 1 TO mxin_null_string DO
                s40  [j]  := null  [j] ;
            (*ENDFOR*) 
            len := mxin_null_string;
            END;
        cin_set_boolean :
            BEGIN
            FOR j := 1 TO mxin_bool_string DO
                s40  [j]  := bool_presentation.truestr  [j] ;
            (*ENDFOR*) 
            s40  [mxin_bool_string+1]  := '/';
            FOR j := 1 TO mxin_bool_string DO
                s40 [mxin_bool_string + 1 + j]  := bool_presentation.falsestr [j];
            (*ENDFOR*) 
            len := 2 * mxin_bool_string + 1;
            END;
        cin_set_decimal :
            BEGIN
            s40  [1]  := '/';
            (* N means no_thousand_grouping *)
            IF  decimal.thousand_token <> cin_no_thousand_groups
            THEN
                BEGIN
                s40  [2]  := decimal.thousand_token;
                s40  [3]  := '/';
                s40  [4]  := decimal.zero_point;
                s40  [5]  := '/';
                END
            ELSE
                BEGIN
                s40  [2]  := '/';
                s40  [3]  := decimal.zero_point;
                s40  [4]  := '/';
                s40  [5]  := ' ';
                END;
            (*ENDIF*) 
            len := 5;
            END;
        cin_set_date :
            BEGIN
            s10mv (mxin_date_mask_string,40,
                  @date.msk,1,
                  @s40,1,date.mlen);
            len := date.mlen;
            END;
        cin_set_time :
            BEGIN
            s10mv (mxin_date_mask_string,40,
                  @time.msk,1,
                  @s40,1,time.mlen);
            len := time.mlen;
            END;
        cin_set_timestamp :
            BEGIN
            s10mv (mxin_date_mask_string,40,
                  @timestamp.msk,1,
                  @s40,1,timestamp.mlen);
            len := timestamp.mlen;
            END;
        cin_set_sep :
            BEGIN
            SAPDB_PascalForcedFill (mxin_sep_string, @s40, 1, mxin_sep_string, ' ');
            IF  l_sep > 0
            THEN
                BEGIN
                FOR j := 1 TO l_sep DO
                    s40  [j]  := sep  [j] ;
                (*ENDFOR*) 
                END;
            (*ENDIF*) 
            len :=  l_sep;
            END;
        cin_set_printformat :
            BEGIN
            FOR j := 1 TO mxsp_name DO
                s40  [j] := act_print_name [j];
            (*ENDFOR*) 
            len := mxsp_name;
            END;
        cin_set_plpres, cin_set_controlpres :
            BEGIN
            FOR j := 1 TO mxsp_name DO
                s40  [j] := plpres [j];
            (*ENDFOR*) 
            len := mxsp_name;
            END;
        cin_set_copy :
            BEGIN
            val := copy;
            i09itoc40 (val, s40);
            len := 3;
            END;
        cin_set_syseditor :
            BEGIN
            s40 := syseditor;
            len := 40;
            END;
        cin_set_loadprot :
            BEGIN
            s10mv (VFILENAME_MXSP00,40,
                  @loadprot,1,
                  @s40,1,40);
            len := 40;
            END;
        cin_set_transize :
            BEGIN
            val := transize;
            i09itoc40 (val, s40);
            len := 9;
            END;
        cin_set_lt_pres :
            BEGIN
            s40 := lt_pres;
            len := 40;
            END;
        cin_set_le_pres :
            BEGIN
            s40 := le_pres;
            len := 40;
            END;
        cin_set_gt_pres :
            BEGIN
            s40 := gt_pres;
            len := 40;
            END;
        cin_set_ge_pres :
            BEGIN
            s40 := ge_pres;
            len := 40;
            END;
        cin_set_eq_pres :
            BEGIN
            s40 := eq_pres;
            len := 40;
            END;
        cin_set_ne_pres :
            BEGIN
            s40 := ne_pres;
            len := 40;
            END;
        cin_set_not_pres :
            BEGIN
            s40 := not_pres;
            len := 40;
            END;
        cin_set_in_pres :
            BEGIN
            s40 := in_pres;
            len := 40;
            END;
        cin_set_betw_pres :
            BEGIN
            s40 := betw_pres;
            len := 40;
            END;
        cin_set_sounds_pres :
            BEGIN
            s40 := sounds_pres;
            len := 40;
            END;
        cin_set_delimiter :
            BEGIN
            s40  [1]  := delimiter;
            len := 1;
            END;
        cin_set_fillchar :
            BEGIN
            s40  [1]  := fillchar;
            len := 1;
            END;
        cin_set_graficchar :
            BEGIN
            s40  [1]  := graficchar;
            len := 1;
            END;
        cin_set_ignore_case :
            BEGIN
            i09putonoff (i01g, ignore_case, s40);
            len := 5;
            END;
        cin_set_actualize_menu :
            BEGIN
            i09putonoff (i01g, actualize_menu, s40);
            len := 5;
            END;
        cin_set_queryprot :
            BEGIN
            s10mv (VFILENAME_MXSP00,40,
                  @queryprot,1,
                  @s40,1,40);
            len := 40;
            END;
        cin_set_autoprot :
            BEGIN
            i09putonoff (i01g, autoprot, s40);
            len := 5;
            END;
        cin_set_sqltime :
            BEGIN
            i09putonoff (i01g, sqltime, s40);
            len := 5;
            END;
        cin_set_history :
            BEGIN
            i09putonoff (i01g, history, s40);
            len := 5;
            END;
        cin_set_plprot :
            BEGIN
            s10mv (VFILENAME_MXSP00,40,
                  @plprot,1,
                  @s40,1,40);
            len := 40;
            END;
        cin_set_pretty :
            BEGIN
            i09putonoff (i01g, pretty, s40);
            len := 5;
            END;
        cin_set_nesting :
            BEGIN
            val := nesting;
            i09itoc40 (val, s40);
            len := 3;
            END;
        cin_set_code_area :
            BEGIN
            val := code_area;
            i09itoc40 (val, s40);
            len := 9;
            END;
        cin_set_value_area :
            BEGIN
            val := value_area;
            i09itoc40 (val, s40);
            len := 9;
            END;
        cin_set_dia_version :
            BEGIN
            FOR j := 1 TO 4 DO
                s40  [j]  := dia_version  [j] ;
            (*ENDFOR*) 
            len := 4;
            END;
        cin_set_dia_target_langs :
            BEGIN
            FOR j := 1 TO 24 DO
                s40  [j]  := dia_target_langs  [j] ;
            (*ENDFOR*) 
            len := 24;
            END;
        OTHERWISE:
            len := 0;
        END;
    (*ENDCASE*) 
    s10mv (40,mxsp_buf,
          @s40,1,
          @buf,1,len);
    END;
(*ENDWITH*) 
END; (* i07readsetparm *)
 
(*------------------------------*) 
 
PROCEDURE
      screenframe (
            VAR component  : tsp00_C8;
            VAR release_id : tsp00_C8;
            msg_no         : integer;
            VAR msg        : tin_screenline);
 
CONST
      calm_mode = false;
      screen_1  = 1;
 
VAR
      field_type : tin_ls_fieldtype;
      screen_pos : tin_ls_position;
      outline    : tin_screenline;
      header     : tsp00_OnlineHeader;
 
BEGIN
WITH header DO
    BEGIN
    id_field := component;
    relno_field := release_id;
    mode_field := cin_k_set;
    text_field := bsp_c40;
    END;
(*ENDWITH*) 
i56title (calm_mode, screen_1, header);
i56putframe (true, true);
IF  msg_no > 0
THEN
    i09getmsg (i01g, msg_no, outline)
ELSE
    outline := msg;
(*ENDIF*) 
WITH screen_pos DO
    BEGIN
    screen_part := cin_ls_sysline;
    sline := 1;
    scol := cin07_colno;
    END;
(*ENDWITH*) 
WITH field_type DO
    BEGIN
    field_att := cin_attr5;
    fieldmode := [  ] ;
    END;
(*ENDWITH*) 
i50put1field (outline, i01g^.vt.desc.num_of_cols,
      screen_pos, field_type);
END; (* screenframe *)
 
(*------------------------------*) 
 
PROCEDURE
      set_first_pos (
            anzahl  : integer;
            VAR pos : tin_ls_position);
 
VAR
      length : tin_natural;
      width  : tin_natural;
      line   : integer;
 
BEGIN
i51size (cin_ls_workarea, length, width);
line := (length DIV 2) - (anzahl DIV 2);
IF  line < 1
THEN
    line := 1;
(*ENDIF*) 
WITH pos DO
    BEGIN
    screen_part := cin_ls_workarea;
    sline := line;
    scol := cin07_colno + cin07_fieldlen + 2;
    END;
(*ENDWITH*) 
END; (* set_first_pos *)
 
(*------------------------------*) 
 
FUNCTION
      to_be_shown (
            VAR show       : tin_show_set;
            parm           : integer;
            VAR screen_pos : tin_ls_position) : boolean;
 
VAR
      fieldname : tin_screenline;
      fieldtype : tin_ls_fieldtype;
 
BEGIN
IF  (parm in show)
THEN
    BEGIN
    to_be_shown := true;
    i09getmsg (i01g, cin_setmsg_nameoffset+ parm, fieldname);
    WITH fieldtype DO
        BEGIN
        field_att := cin_attr1;
        fieldmode := [  ] ;
        END;
    (*ENDWITH*) 
    screen_pos.scol := cin07_colno;
    i50put1field (fieldname, cin07_fieldlen, screen_pos, fieldtype);
    screen_pos.scol := screen_pos.scol + cin07_fieldlen + 2;
    END
ELSE
    to_be_shown := false;
(*ENDIF*) 
END; (* to_be_shown *)
 
(* 89/091/07 B.M. *)
(*------------------------------*) 
 
FUNCTION
      is_easy_parm (
            parm          : integer;
            VAR all_show  : tin_show_set;
            VAR easy_show : tin_show_set;
            VAR easy_cnt  : integer ) : boolean;
 
BEGIN
is_easy_parm := false;
IF  parm in [ cin_set_lt_pres,
    cin_set_le_pres,
    cin_set_gt_pres,
    cin_set_ge_pres,
    cin_set_eq_pres,
    cin_set_ne_pres,
    cin_set_not_pres,
    cin_set_in_pres,
    cin_set_betw_pres,
    cin_set_sounds_pres ]
THEN
    BEGIN
    easy_cnt := easy_cnt + 1;
    easy_show := easy_show + [ parm ];
    all_show := all_show - [ parm ];
    is_easy_parm := true;
    END;
(*ENDIF*) 
END; (* in071_is_easy_parm *)
 
(*------------------------------*) 
 
PROCEDURE
      in071_set_keys (
            VAR show : tin_show_set );
 
VAR
      helpshow : tin_show_set; (* B.M. 20.01.93 *)
 
BEGIN
WITH i01g^.key_type DO
    BEGIN
    in071_put_label;
    activated := [  f1, f8, f9, f_end, f_exit ] ;
    IF  (cin_set_printformat in show)
    THEN
        activated := activated +  [f4] ;
&   ifndef WINDOWS
    (*ENDIF*) 
    helpshow := [cin_set_plpres, cin_set_yepres,
          cin_set_lopres, cin_set_qupres, cin_set_controlpres] ;
    IF  ( helpshow * show <> [ ])
    THEN
        activated := activated +  [f5] ;
&   endif
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* in071_set_keys *)
 
(*------------------------------*) 
 
PROCEDURE
      in071_put_label;
 
CONST
      cin07_first_default_pfkey = 17860;
 
VAR
      f      : tin_prog_function;
      j      : integer;
      lab    : tin_ls_sk_label;
      msg    : tin_screenline;
 
BEGIN
WITH i01g^.key_type DO
    BEGIN
    in071_blank_label;
    j := cin07_first_default_pfkey;
    FOR f := f1 TO f12 DO
        BEGIN
        IF  ( f IN [  f1, f4, f5, f8, f9, f11, f12 ] )
        THEN
            BEGIN
            i09getmsg (i01g, j, msg);
            j := j + 1;
            s10mv (mxin_screenline,csp_lslabel,
                  @msg,1,
                  @lab,1,csp_lslabel );
            key_labels  [f]  := lab;
            END;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      in071_blank_label;
 
CONST
      cin07_blank_lab = '        ';
 
BEGIN
WITH i01g^.key_type DO
    BEGIN
    key_labels  [f1]  := cin07_blank_lab;
    key_labels  [f2]  := cin07_blank_lab;
    key_labels  [f3]  := cin07_blank_lab;
    key_labels  [f4]  := cin07_blank_lab;
    key_labels  [f5]  := cin07_blank_lab;
    key_labels  [f6]  := cin07_blank_lab;
    key_labels  [f7]  := cin07_blank_lab;
    key_labels  [f8]  := cin07_blank_lab;
    key_labels  [f9]  := cin07_blank_lab;
    key_labels  [f10] := cin07_blank_lab;
    key_labels  [f11] := cin07_blank_lab;
    key_labels  [f12] := cin07_blank_lab;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      in071_csr_on_presentation (
            VAR component     : tsp00_C8;
            all_show          : tin_show_set;
            VAR selected_pres : tin_show_set;
            csr_pos           : tin_ls_position;
            VAR parm_lno      : tin07_parm_lineno_array;
            VAR pres_name     : tsp00_Name ) : boolean;
 
BEGIN
in071_csr_on_presentation := true;
IF  ( cin_set_lopres in all_show )
    AND ( parm_lno [ cin_set_lopres ] = csr_pos.sline )
THEN
    BEGIN
    component := 'LOAD    ';
    i01g^.i20.comp_enum := sp4co_sql_load;
    selected_pres := [ cin_set_lopres ];
    pres_name     := i01g^.set_parms.lopres;
    END
ELSE
    IF  ( cin_set_qupres in all_show )
        AND ( parm_lno [ cin_set_qupres ] = csr_pos.sline )
    THEN
        BEGIN
        component := 'QUERY   ';
        i01g^.i20.comp_enum := sp4co_sql_query;
        selected_pres := [ cin_set_qupres ];
        pres_name     := i01g^.set_parms.qupres;
        END
    ELSE
        IF  ( cin_set_yepres in all_show )
            AND ( parm_lno [ cin_set_yepres ] = csr_pos.sline )
        THEN
            BEGIN
            component := 'EASY    ';
            i01g^.i20.comp_enum := sp4co_sql_easy;
            selected_pres := [ cin_set_yepres ];
            pres_name     := i01g^.set_parms.yepres;
            END
        ELSE
            IF  ( cin_set_plpres in all_show )
                AND ( parm_lno [ cin_set_plpres ] = csr_pos.sline )
            THEN
                BEGIN
                component := 'CONTROL ';
                i01g^.i20.comp_enum := sp4co_sql_dialog;
                selected_pres := [ cin_set_plpres ];
                pres_name     := i01g^.set_parms.plpres;
                END
            ELSE
                IF  ( cin_set_controlpres in all_show )
                    AND ( parm_lno [ cin_set_controlpres ] = csr_pos.sline )
                THEN
                    BEGIN
                    component := 'CONTROL ';
                    i01g^.i20.comp_enum := sp4co_sql_dialog;
                    selected_pres := [ cin_set_controlpres ];
                    pres_name     := i01g^.set_parms.plpres;
                    END
                ELSE
                    in071_csr_on_presentation := false;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
