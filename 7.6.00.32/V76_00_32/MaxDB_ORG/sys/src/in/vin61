.CM  SCRIPT , Version - 1.1 , last edited by Manuela Rathmann
.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VIN61$
.tt 2 $$$
.TT 3 $$Output Virtual Printer$1998-06-19$
***********************************************************
.nf
 
.nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : vp_output
=========
.sp
Purpose :
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              i61init;
 
        PROCEDURE
              i61reset;
 
        PROCEDURE
              i61open (
                    VAR printer   : tsp00_PrtName;
                    VAR errtext   : tsp00_ErrText;
                    VAR vpok      : boolean ) ;
 
        PROCEDURE
              i61print (
                    VAR line     : tsp00_PrtLine ;
                    length       : tsp00_Int2;
                    lfs          : tsp00_VpLinefeeds;
                    VAR errtext  : tsp00_ErrText;
                    VAR vpok     : boolean );
 
        PROCEDURE
              i61oldprint (
                    VAR line      : tsp00_PrtLine ;
                    length        : tsp00_Int2;
                    lfs           : tsp00_VpLinefeeds;
                    VAR errtext   : tsp00_ErrText;
                    VAR vpok      : boolean );
 
        PROCEDURE
              i61close (
                    print       : boolean;
                    VAR errtext : tsp00_ErrText;
                    VAR ok      : boolean);
 
        FUNCTION
              i61status (
                    VAR printer : tsp00_PrtName) : tin_vp_status;
 
        PROCEDURE
              i61prtname (
                    VAR prtname : tsp00_PrtName);
 
        PROCEDURE
              i61setprinterparms (
                    pw : tin_natural;
                    lm : tin_natural;
                    rm : tin_natural;
                    pl : tin_natural;
                    tm : tin_natural;
                    bm : tin_natural);
 
        PROCEDURE
              i61inittitle;
 
        PROCEDURE
              i61title (
                    VAR line : tsp00_PrtLine ;
                    linelen  : tin_natural;
                    linenum  : tin_natural;
                    linefeed : tsp00_VpLinefeeds;
                    linetyp  : tin_vp_titletyp);
 
        PROCEDURE
              i61defaulttitle (
                    ktext : tsp00_C12);
 
        PROCEDURE
              i61setpage (
                    pagenum : tin_natural);
 
        PROCEDURE
              i61newprint (
                    VAR line    : tsp00_PrtLine;
                    linelen     : tin_natural;
                    linefeeds   : tsp00_VpLinefeeds;
                    linestyle   : tin_vp_style;
                    VAR errtext : tsp00_ErrText;
                    VAR vpok    : boolean );
 
        FUNCTION
              i61linesleft : tin_natural;
 
        FUNCTION
              i61actualline : tin_natural;
 
        PROCEDURE
              i61linefeeds (
                    lf          : tin_natural;
                    VAR errtext : tsp00_ErrText;
                    VAR vpok    : boolean );
 
        PROCEDURE
              i61conditionalpage (
                    needlines   : tin_natural;
                    VAR vpok    : boolean );
 
        PROCEDURE
              i61endpage (
                    inittitle   : boolean);
 
        FUNCTION
              i61pw : tin_natural;
 
        FUNCTION
              i61questionprint (
                    msgtext     : tin_screenline;
                    msglen      : tin_natural;
                    VAR errtext : tsp00_ErrText;
                    VAR ok      : boolean) : boolean;
 
.CM *-END-* define --------------------------------------
 
Use     :
 
        FROM
              global_variable : VIN01;
 
        VAR
              i01g   : tin_global_in_vars;
 
      ------------------------------ 
 
        FROM
              Output of Date and Time : VIN41 ;
 
        PROCEDURE
              i41tput (
                    VAR mask        : tin_date_mask;
                    VAR time_string : tsp00_Time;
                    VAR outputfield : tin_date_mask);
 
        PROCEDURE
              i41dput (
                    VAR mask        : tin_date_mask;
                    VAR date_string : tsp00_Date;
                    VAR outputfield : tin_date_mask);
&       ifdef WINDOWS
 
      ------------------------------ 
 
        FROM
              logical_screen_modules : VIN56;
 
        FUNCTION
              i56question(
                    VAR text : tsp00_Line;
                    textlen  : tsp00_Int2 ) : boolean;
&       endif
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;       
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;    
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;    
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE_driver : VEN102;
 
        PROCEDURE
              sqlpon (
                    VAR printer   : tsp00_PrtName;
                    VAR vpok      : boolean ) ;
 
        PROCEDURE
              sqlprint (
                    VAR line     : tsp00_PrtLine ;
                    length       : tsp00_Int2;
                    lfs          : tsp00_VpLinefeeds;
                    VAR errtext  : tsp00_ErrText;
                    VAR vpok     : boolean ) ;
 
        PROCEDURE
              sqlpoff (
                    print       : boolean;
                    VAR errtext : tsp00_ErrText;
                    VAR ok      : boolean);
 
        PROCEDURE
              sqldattime (
                    VAR d : tsp00_Date;
                    VAR t : tsp00_Time);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              m90buf;
 
              tsp00_Buf tsp00_PrtLine
 
        PROCEDURE
              m90buf1;
 
              tsp00_Buf tsp00_PrtName
 
        PROCEDURE
              sqlpon;
 
              tsp00_PrtName  tsp00_PrtName
 
        PROCEDURE
              sqlprint;
 
              tsp00_PrtLine     tsp00_PrtLine
              tsp00_Int2        tsp00_Int2
              tsp00_VpLinefeeds tsp00_VpLinefeeds
              tsp00_ErrText     tsp00_ErrText
 
        PROCEDURE
              sqlpoff;
 
              tsp00_ErrText tsp00_ErrText
 
        PROCEDURE
              sqldattime;
 
              tsp00_Date  tsp00_Date
              tsp00_Time  tsp00_Time
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1986-03-06
.sp
.cp 3
.sp
.cp 3
Release :      Date : 1998-06-19
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
Die Prozeduren dieses Moduls werden k?unftig anstelle der
VEN30-Prozeduren (Virtueller Drucker) aufgerufen:
.sp;Der globale Record I01_G^ erh?alt daf?ur ein weiteres
Feld VP vom Typ VP_RECORD, in dem die Information dar?uber
abgelegt ist, ob und f?ur welchen Druckertyp bereits ein
Druckprotokoll er?offnet wurde.
Diese Information wird mit der Funktion I61_STATUS zur?uckge-
liefert.
.sp;Damit ist es m?oglich, zwischen verschiedenen Komponenten
 (wie EASY und REPORT, DIALOG und REPORT) hin- und herzuschalten
und die Druckausgabe auf ein gemeinsames Druckprotokoll auszuge-
ben.
.sp;Zus?atzlich besteht f?ur die aufrufende Komponente (wie z.B. EASY
oder DIALOG) die M?oglichkeit festzustellen,
ob die aufgerufene Komponente (wie z.B.
REPORT oder der Editor) seit dem letzten Aufruf etwas zum Druckpro-
tokoll hinzugef?ugt hat. Wenn nicht, kann so verfahren werden,
als w?are die andere Komponente gar nicht aufgerufen worden.
 (EASY z.B. versucht dann, auf derselben Druckseite weiterzuschreiben ]
.sp 2;.nf
        PROCEDURE
              i61init;
.sp 2;.fo
Initialisiert die Information im globalen Record; Diese Prozedur
wird von I06_INIT und von I61_CLOSE aufgerufen. Die Dialogkomponenten
sollen diese Prozedur
.oc _/1;nicht
aufrufen!
.sp 2;.nf
        PROCEDURE
              i61reset;
.sp 2;.fo
Da bei jedem I61_PRINT ein Vermerk im
VP_RECORD gemacht wird, kann prinzipiell festgestellt
werden, ob etwas in das Druckprotokoll geschrieben wurde.
.sp;
Mit I61_RESET kann man diese Information l?oschen, ehe man
die Kontrolle an eine andere Komponente abgibt (z.B. Aufruf
von REPORT aus EASY heraus), so da?z
beim R?ucksprung aus dieser anderen Komponente
mit I61_STATUS festgestellt werden kann,
ob seit dem letzten Aufruf von
I61_RESET (d.h. dann in der anderen Komponente)
etwas zum Druckprotokoll hinzugef?ugt wurde.
.sp;Der Aufruf von I61_RESET bei nicht ge?offnetem Druckprotokoll
bewirkt nichts.
.sp 2;.nf
        PROCEDURE
              i61open (VAR printer : printername ;
                          VAR vpok : boolean ) ;
.sp 2;.fo
Diese Prozedur mu?z
.oc _/1;jedesmal vor Beginn
einer Druckausgabe aufgerufen werden, die zusammenh?angend ausge-
geben werden soll.
.sp;Diese Prozedur bewirkt folgendes:
.hi 3;.sp
.sp;- Falls noch kein Druckprotokoll
offen ist, wird eines f?ur diese PRINTERID er?offnet.
.sp;- Ist bereits ein Druckprotokoll mit dieser PRINTERID er?offnet,
so geschieht gar nichts.
.sp;- Falls ein Druckprotokoll f?ur eine andere PRINTERID offen ist,
wird dieses geschlossen (ausgegeben) und ein neues Druckprotokoll
angelegt.
.hi 0;.sp;Es kann immer nur ein Druckprotokoll auf einmal ge?offnet sein!
.sp;Es sollte sichergestellt sein, da?z nur dann I61_OPEN
aufgerufen wird, wenn auch wirklich I61_PRINT-Aufrufe folgen.
.sp 2;.nf
        PROCEDURE
              i61print (VAR line  : prline ;
                          length  : int2;
                          lfs     : vp_linefeeds;
                          VAR errtext : errortext;
                          VAR vpok    : boolean );
.sp 2;.fo
Gibt eine Druckzeile auf das ge?offnete Druckprotokoll aus.
.sp;Parameter siehe VEN30 (VPRINT); Abweichend von VPRINT
wird allerdings bei einem frisch ge?offneten Druckprotokoll
 (also beim ersten I61_PRINT auf einem definitiv
neuen Druckprotokoll) LFS\=\PAGE in LFS\=\ONELF umge?andert.
.sp;Wenn vorher kein I61_OPEN aufgerufen wurde, wird VPOK
auf FALSE gesetzt.
.sp;Bei jedem Aufruf wird im globalen VP_RECORD vermerkt, da?z
etwas gedruckt wurde.
.sp 2;.nf
        PROCEDURE
              i61close (print : boolean);
.sp 2;.fo
Diese Prozedur gibt das Druckprotokoll aus;
wenn allerdings kein Druckprotokoll er?offnet wurde, bewirkt sie
gar nichts.
.sp;I61_CLOSE wird aufgerufen ...
.hi 3;.sp;- auf ausdr?ucklichen Wunsch des Benutzers (Befehl in QUERY /
REPORT / DIALOG , Tastendruck bei EASY)
.sp;- stets bei Beendigung der QUERY / EASY / DIALOG - Sitzung.
.hi 0;.sp 2;.nf
        FUNCTION
              i61status (VAR printer : printername) : ti_vp_status;
.sp 2;.fo
Diese Funktion liefert den VP_STATUS zur?uck:
.sp;Dieser Typ ist wie folgt definiert:
.nf;.sp;       ti_vp_status = ( vp_not_open, vp_open,
                           vp_reset, vp_used );
.fo;.sp;Dabei bedeutet:
.hi 20;.sp;VP_NOT_OPEN ein Druckprotokoll f?ur die angegebene
PRINTERID ist nicht ge?offnet.
.sp;VP_OPEN F?ur diese PRINTERID ist bereits ein Druckprotokoll
er?offnet; allerdings ist noch
nichts auf dieses Protokoll geschrieben worden.
.sp;VP_RESET,VP_USED F?ur die angegebene PRINTERID ist ein Druckprotokoll
ge?offnet. Bei VP_RESET ist seit dem letzten
I61_RESET nichts Neues mehr eingetragen worden.
.sp;.hi 0
Das aufrufende Programm kann nach Aufruf von I61_STATUS dann
z.B. entscheiden, ob
ein Seitenvorschub ausgegeben wird, um die eigene von der
vorhergehenden Druckausgabe abzugrenzen.
Henceforth, the procedures of this module will be called in place of
the VEN30 procedures (virtual printer):
.sp;For this purpose, the global record I01_G^ receives an additional
field VP of the type VP_RECORD which stores information on
whether a printer listing has already been opened and, if yes, for which
type of printer.  This information is returned with the function
I61_STATUS.
.sp;In this way, it is possible to switch back and forth between
various components (such as EASY and REPORT, DIALOG and REPORT)
and to output the printer output to a common printer listing.
.sp;In addition, it is also possible for the calling components (e.g.
EASY or DIALOG) to determine whether the called component (e.g.
REPORT or the editor) has added something to the printer listing since
the last call.  If not, the procedure can carry on as though the other
component had not been called at all.  (EASY, for example. then
attempts to continue writing to the same print page).
.sp 2;.nf
        PROCEDURE
              i61init;
.sp 2;.fo
Initializes the information in the global record.  This procedure is
called by I06_INIT and I61_CLOSE.   The dialog components should
.oc _/1;not
call this procedure!
.sp 2;.nf
        PROCEDURE
              i61reset;
.sp 2;.fo
Since, for every I61_PRINT, an entry is made in the
VP_RECORD, it can always be determined whether anything has
been written to the printer listing.
.sp;
With I61_RESET, this information can be deleted before control is
relinquished to another component (e.g. REPORT is called from EASY)
so that, when returning from this other
component, I61_STATUS can be used to determine whether anything has
been added to the printer listing since the last time
I61_RESET was called (now meaning in the other component).
.sp;Calling I61_RESET when a printer listing is not open has no effect.
.sp 2;.nf
        PROCEDURE
              i61open (VAR printer : printername ;
                          VAR vpok : boolean ) ;
.sp 2;.fo
This procedure must be called
.oc _/1;each time before the start
of a printer output that is to be output contiguously.
.sp;This procedure has the following effects:
.hi 3;.sp
.sp;- If no printer listing is open yet, one is opened for this
PRINTERID.
.sp;- If a printer listing with this PRINTERID is already open,
nothing happens.
.sp;- If a printer listing for another PRINTERID is open, it is
closed (output) and a new printer listing is created.
.hi 0;.sp;Only one printer listing can be open at any one time!
.sp;It is to be ensured that I61_OPEN is called only if
it is actually followed by I61_PRINT calls.
.sp 2;.nf
        PROCEDURE
              i61print (VAR line  : prline ;
                          length  : int2;
                          lfs     : vp_linefeeds;
                          VAR errtext : errortext;
                          VAR vpok    : boolean );
.sp 2;.fo
Outputs a print line to the open printer listing.
.sp;For parameters, see VEN30 (VPRINT).  Unlike VPRINT, in the
case of a newly opened printer listing (that is, for the first
I61_PRINT to a definitively new printer listing), LFS\=\PAGE is
changed to LFS\=\ONELF.
.sp;If no I61_OPEN was called beforehand, VPOK is set to
FALSE.
.sp;For each call, an entry is made in the global VP_RECORD indicating
that something has been printed.
.sp 2;.nf
        PROCEDURE
              i61close (print : boolean);
.sp 2;.fo
This procedure outputs the printer listing.  If, however, no printer
listing has been opened, it has no effect.
.sp;I61_CLOSE is called ...
.hi 3;.sp;- at the express wish of the user (command in QUERY /
REPORT / DIALOG , pressing of key in the case of EASY)
.sp;- each time the QUERY / EASY / DIALOG  session is terminated.
.hi 0;.sp 2;.nf
        FUNCTION
              i61status (VAR printer : printername) : ti_vp_status;
.sp 2;.fo
This function returns the VP_STATUS:
.sp;This type is defined as follows:
.nf;.sp;       ti_vp_status = ( vp_not_open, vp_open,
                           vp_reset, vp_used );
.fo;.sp;The following applies:
.hi 20;.sp;VP_NOT_OPEN means that a printer listing for a specified
PRINTERID is not open.
.sp;VP_OPEN means that a printer listing is already open for this
PRINTERID.  However, nothing has been written to this listing as yet.
.sp;VP_RESET,VP_USED means that a printer listing has been opened for
the PRINTERID specified.  In the case of
VP_RESET, nothing new has been entered since the last I61_RESET.
.sp;.hi 0
After I61_STATUS is called, the calling program can, for example,
decide whether a form feed is output to separate its own printer
output from the previous one.
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
In der globalen Variablen I01_G^ wird ein weiteres Feld vereinbart:
.sp;
                       vp         : ti_vp_record;
.sp;mit dem Typ
.sp;
        ti_vp_record = RECORD
                       status  : ti_vp_status;
                       pr_id   : printerid;
                       END;
.sp;und
.sp
        ti_vp_status = ( vp_not_open,vp_open, vp_reset, vp_used );
.sp;I61_INIT initialisiert STATUS zu VP_NOT_OPEN.
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
(*------------------------------*) 
 
PROCEDURE
      i61init;
 
BEGIN
WITH i01g^.vp DO
    BEGIN
    act_page := 1;
    act_line := 0;
    status   := vp_not_open;
    style    := vp_trunc;
    END;
(*ENDWITH*) 
i61inittitle;
END; (* i61init *)
 
(*------------------------------*) 
 
PROCEDURE
      i61reset;
 
BEGIN
WITH i01g^.vp DO
    IF  status = vp_used
    THEN
        status := vp_reset;
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i61reset *)
 
(*------------------------------*) 
 
PROCEDURE
      i61open (
            VAR printer : tsp00_PrtName;
            VAR errtext : tsp00_ErrText;
            VAR vpok    : boolean ) ;
 
BEGIN
vpok := true;
IF  i01g^.vp.status = vp_not_open
THEN
    printer_open (printer, vpok)
ELSE
    IF  i61status (printer) = vp_not_open
    THEN
        BEGIN
        i61close (true, errtext, vpok);
        printer_open (printer, vpok);
        END;
    (*ENDIF*) 
(*ENDIF*) 
END; (* i61open *)
 
(*------------------------------*) 
 
PROCEDURE
      i61print (
            VAR line      : tsp00_PrtLine ;
            length        : tsp00_Int2;
            lfs           : tsp00_VpLinefeeds;
            VAR errtext   : tsp00_ErrText;
            VAR vpok      : boolean );
 
BEGIN
(* i61oldprint (line, length, lfs, errtext, vpok); *)
i61newprint (line, length, lfs, vp_trunc, errtext, vpok);
END; (* i61print *)
 
(*------------------------------*) 
 
PROCEDURE
      i61oldprint (
            VAR line      : tsp00_PrtLine ;
            length        : tsp00_Int2;
            lfs           : tsp00_VpLinefeeds;
            VAR errtext   : tsp00_ErrText;
            VAR vpok      : boolean );
 
BEGIN
WITH i01g^ DO
    vpok := (vp.status <> vp_not_open);
(*ENDWITH*) 
IF  vpok
THEN
    BEGIN
    sqlprint (line, length, lfs, errtext, vpok);
    IF  vpok
    THEN
        i01g^.vp.status := vp_used;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END; (* i61oldprint *)
 
(*------------------------------*) 
 
PROCEDURE
      i61close (
            print       : boolean;
            VAR errtext : tsp00_ErrText;
            VAR ok      : boolean);
 
VAR
      new_page : boolean;
 
BEGIN
WITH i01g^.vp DO
    BEGIN
    IF  status IN [ vp_used, vp_reset ]
    THEN
        BEGIN
        new_page := false;
        printtitlelines (vp_bottitle, new_page);
        END;
    (*ENDIF*) 
    IF  status <> vp_not_open
    THEN
        sqlpoff (print, errtext, ok);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
i61init;
END; (* i61close *)
 
(*------------------------------*) 
 
FUNCTION
      i61status (
            VAR printer : tsp00_PrtName) : tin_vp_status;
 
VAR
      stat : tin_vp_status;
 
BEGIN
WITH i01g^.vp DO
    BEGIN
    stat := status;
    IF  stat <> vp_not_open
    THEN
        IF  printer <> pr_name
        THEN
            stat := vp_not_open;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
i61status := stat;
END; (* i61status *)
 
(*------------------------------*) 
 
PROCEDURE
      i61prtname (
            VAR prtname : tsp00_PrtName);
 
BEGIN
WITH i01g^.set_parms.printformat DO
    prtname := printerset [act_print].printer;
(*ENDWITH*) 
END; (* i61prtname *)
 
(*------------------------------*) 
 
PROCEDURE
      printer_open (
            VAR printer : tsp00_PrtName;
            VAR vpok    : boolean);
 
BEGIN
sqlpon (printer, vpok);
IF  vpok
THEN
    WITH i01g^.vp DO
        BEGIN
        status  := vp_open;
        pr_name := printer;
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END; (* printer_open *)
 
(*nnn*)
(*------------------------------*) 
 
PROCEDURE
      i61inittitle;
 
VAR
      i : tin_natural;
 
BEGIN
WITH i01g^.vp DO
    BEGIN
    page_pos.tlinenum := 0;
    date_pos.tlinenum := 0;
    time_pos.tlinenum := 0;
    FOR i:=1 TO cin_maxtitleline DO
        BEGIN
        top_title.tlinelen [i]  := 0;
        top_title.tlinefeed [i] := vp_onelf;
        bot_title.tlinelen [i]  := 0;
        bot_title.tlinefeed [i] := vp_onelf;
        END;
    (*ENDFOR*) 
    END;
(*ENDWITH*) 
END; (* i61inittitle *)
 
(*------------------------------*) 
 
PROCEDURE
      i61title (
            VAR line : tsp00_PrtLine ;
            linelen  : tin_natural;
            linenum  : tin_natural;
            linefeed : tsp00_VpLinefeeds;
            linetyp  : tin_vp_titletyp);
 
VAR
      vpok : boolean;
 
BEGIN
vpok := true;
(*
      WITH i01g^ DO
      vpok := (vp.status <> vp_not_open);
      *)
IF  vpok
THEN
    vpok := (linenum IN [ 1, 2, cin_maxtitleline] ) AND
          (linetyp IN [ vp_toptitle, vp_bottitle] ) AND
          (linefeed IN [ vp_onelf, vp_twolf, vp_threelf] );
(*ENDIF*) 
IF  (vpok) AND (linelen > 0)
THEN
    BEGIN
    CASE linetyp OF
        vp_toptitle:
            WITH i01g^.vp.top_title DO
                BEGIN
                gettitleline (line, linelen,
                      tline [linenum] , tlinelen [linenum] );
                tlinefeed [linenum ] := linefeed;
                getpdtpos (tline [linenum] , tlinelen [linenum] ,
                      vp_toptitle, linenum, cin_pagechar);
                getpdtpos (tline [linenum] , tlinelen [linenum] ,
                      vp_toptitle, linenum, cin_datechar);
                getpdtpos (tline [linenum] , tlinelen [linenum] ,
                      vp_toptitle, linenum, cin_timechar);
                END;
            (*ENDWITH*) 
        vp_bottitle:
            WITH i01g^.vp.bot_title DO
                BEGIN
                gettitleline (line, linelen,
                      tline [linenum] , tlinelen [linenum] );
                tlinefeed [linenum ] := linefeed;
                getpdtpos (tline [linenum] , tlinelen [linenum] ,
                      vp_bottitle, linenum, cin_pagechar);
                getpdtpos (tline [linenum] , tlinelen [linenum] ,
                      vp_toptitle, linenum, cin_datechar);
                getpdtpos (tline [linenum] , tlinelen [linenum] ,
                      vp_toptitle, linenum, cin_timechar);
                END;
            (*ENDWITH*) 
        END;
    (*ENDCASE*) 
    END;
(*ENDIF*) 
END; (* i61title *)
 
(*------------------------------*) 
 
PROCEDURE
      gettitleline (
            VAR line     : tsp00_PrtLine;
            linelen      : tin_natural;
            VAR tline    : tsp00_PrtLine;
            VAR tlinelen : tin_natural);
 
VAR
      tlinepos : tin_natural;
      column   : ARRAY [ 1..3 ] OF tsp00_PrtLine;
      collen   : ARRAY [ 1..3 ] OF tin_natural;
      linecol  : tin_natural;
      linepos  : tin_natural;
      pwidth   : tin_natural;
      len      : tin_natural;
 
BEGIN
WITH i01g^.set_parms.printformat, printerset [act_print] DO
    BEGIN
    linepos := 1;
    tlinelen := 0;
    tlinepos := 1;
    SAPDB_PascalForcedFill (PRTLINE_MXSP00, @tline, tlinepos, PRTLINE_MXSP00, bsp_c1);
    pwidth := printwidth;
    tlinepos := tlinepos + lmargin;
    IF  line [linepos ] <> cin_titlechar
    THEN
        BEGIN
        IF  linelen > pwidth
        THEN
            len := pwidth
        ELSE
            len := linelen;
        (*ENDIF*) 
        s10mv (PRTLINE_MXSP00,PRTLINE_MXSP00,
              @line,1,
              @tline,tlinepos,len);
        tlinelen := len + lmargin;
        END
    ELSE
        BEGIN
        tlinelen := 0;
        linecol := 0;
        linepos := linepos + 1;
        WHILE (linepos < linelen) AND (linecol < 3) DO
            BEGIN
            linecol := linecol + 1;
            gettitlecolumn (line, linelen, linepos,
                  column [linecol] , collen [linecol] );
            END;
        (*ENDWHILE*) 
        tlinepos := 1 + lmargin;
        IF  collen [1]  > 0
        THEN
            BEGIN
            s10mv (PRTLINE_MXSP00,PRTLINE_MXSP00,
                  @column [1] ,1,
                  @tline,tlinepos,collen [1] );
            tlinelen := tlinepos + collen [1]  - 1;
            END;
        (*ENDIF*) 
        tlinepos := 1 + lmargin;
        IF  collen [2]  > 0
        THEN
            BEGIN
            tlinepos := tlinepos + ( (pwidth - collen [2] ) DIV 2);
            s10mv (PRTLINE_MXSP00,PRTLINE_MXSP00,
                  @column [2] ,1,
                  @tline,tlinepos,collen [2] );
            tlinelen := tlinepos + collen [2]  - 1;
            END;
        (*ENDIF*) 
        tlinepos := 1 + lmargin;
        IF  collen [3]  > 0
        THEN
            BEGIN
            tlinepos := tlinepos + (pwidth - collen [3] );
            s10mv (PRTLINE_MXSP00,PRTLINE_MXSP00,
                  @column [3] ,1,
                  @tline,tlinepos,collen [3] );
            tlinelen := tlinepos + collen [3]  - 1;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  tlinelen = 0
    THEN
        BEGIN
        tlinelen := 1;
        tline [1]  := bsp_c1;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      gettitlecolumn (
            VAR line    : tsp00_PrtLine;
            VAR linelen : tin_natural;
            VAR linepos : tin_natural;
            VAR column  : tsp00_PrtLine;
            VAR collen  : tin_natural);
 
VAR
      colpos : tin_natural;
 
BEGIN
colpos := 1;
IF  line [linepos ] = cin_titlechar
THEN
    BEGIN
    collen := 0;
    linepos := linepos + 1;
    END
ELSE
    BEGIN
    WHILE (line [linepos ] <> cin_titlechar) AND (linepos < linelen) DO
        BEGIN
        column [colpos ] := line [linepos] ;
        colpos           := colpos + 1;
        linepos          := linepos + 1;
        END;
    (*ENDWHILE*) 
    collen := colpos - 1;
    IF  (line [linepos ] = cin_titlechar) AND (linepos < linelen)
    THEN
        linepos := linepos + 1;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      getpdtpos (
            VAR line    : tsp00_PrtLine;
            VAR linelen : tin_natural;
            linetyp     : tin_vp_titletyp;
            linenum     : tin_natural;
            pdtchar     : char );
 
VAR
      linepos  : tin_natural;
      pdtpos   : tin_natural;
 
BEGIN
pdtpos  := 0;
linepos := 1;
WHILE (( line [ linepos + 1 ] <> pdtchar )  OR
      ( line [ linepos ] <> cin_pdtchar )) AND
      ( linepos < ( linelen - 1 ))          DO
    linepos := linepos + 1;
(*ENDWHILE*) 
IF  (line [ linepos ] = cin_pdtchar) AND
    (line [ linepos + 1 ] = pdtchar)
THEN
    BEGIN
    pdtpos               := linepos + 1;
    line [ linepos ]     := bsp_c1;
    line [ linepos + 1 ] := bsp_c1;
    END;
(*ENDIF*) 
IF  pdtpos > 0
THEN
    CASE pdtchar OF
        cin_pagechar:
            BEGIN
            WITH i01g^.vp.page_pos DO
                BEGIN
                tlinetyp := linetyp;
                tlinenum := linenum;
                tlinepos := pdtpos;
                END;
            (*ENDWITH*) 
            END;
        cin_datechar:
            BEGIN
            WITH i01g^.vp.date_pos DO
                BEGIN
                tlinetyp := linetyp;
                tlinenum := linenum;
                tlinepos := pdtpos;
                END;
            (*ENDWITH*) 
            END;
        cin_timechar:
            BEGIN
            WITH i01g^.vp.time_pos DO
                BEGIN
                tlinetyp := linetyp;
                tlinenum := linenum;
                tlinepos := pdtpos;
                END;
            (*ENDWITH*) 
            END;
        END;
    (*ENDCASE*) 
(*ENDIF*) 
END; (* getpdtpos *)
 
(*------------------------------*) 
 
PROCEDURE
      i61defaulttitle (
            ktext : tsp00_C12);
 
CONST
      k_datetext = '$$%D$       ';
      l_datetext = 5;
      k_pagetext = '$$$%P$      ';
      l_pagetext = 6;
      k_fillchar = '-';
 
VAR
      text12   : tsp00_C12;
      tline    : tsp00_PrtLine;
      tlinelen : tin_natural;
      tlinepos : tin_natural;
 
BEGIN
i61inittitle;
(**)
(* *** Toptitle 1 *** *)
(**)
tlinepos := 1;
tline [tlinepos ] := cin_titlechar;
tlinepos := tlinepos + 1;
s10mv (mxsp_c12,PRTLINE_MXSP00,
      @ktext,1,
      @tline,tlinepos,mxsp_c12);
tlinepos := tlinepos + mxsp_c12;
text12 := k_datetext;
s10mv (mxsp_c12,PRTLINE_MXSP00,
      @text12,1,
      @tline,tlinepos,l_datetext);
tlinepos := tlinepos + l_datetext;
tlinelen := tlinepos - 1;
i61title (tline, tlinelen, 1, vp_onelf, vp_toptitle);
(**)
(* *** Toptitle 2 *** *)
(**)
SAPDB_PascalForcedFill (PRTLINE_MXSP00, @tline, 1, PRTLINE_MXSP00, k_fillchar);
tlinelen := PRTLINE_MXSP00;
i61title (tline, tlinelen, 2, vp_onelf, vp_toptitle);
(**)
(* *** Bottomtitle 1 *** *)
(**)
i61title (tline, tlinelen, 1, vp_onelf, vp_bottitle);
(**)
(* *** Bottomtitle 2 *** *)
(**)
tlinepos := 1;
text12 := k_pagetext;
s10mv (mxsp_c12,PRTLINE_MXSP00,
      @text12,1,
      @tline,tlinepos,l_pagetext);
tlinepos := tlinepos + l_pagetext;
tlinelen := tlinepos - 1;
i61title (tline, tlinelen, 2, vp_onelf, vp_bottitle);
END; (* i61defaulttitle *)
 
(*------------------------------*) 
 
PROCEDURE
      i61setprinterparms (
            pw : tin_natural;
            lm : tin_natural;
            rm : tin_natural;
            pl : tin_natural;
            tm : tin_natural;
            bm : tin_natural);
 
BEGIN
WITH i01g^.set_parms.printformat, printerset [act_print] DO
    BEGIN
    pagelength := pl;
    pagewidth  := pw;
    tmargin    := tm;
    bmargin    := bm;
    lmargin    := lm;
    rmargin    := rm;
    END;
(*ENDWITH*) 
END; (* i61setprinterparms *)
 
(*------------------------------*) 
 
PROCEDURE
      i61setpage (
            pagenum : tin_natural);
 
BEGIN
i01g^.vp.act_page := pagenum;
END;
 
(*------------------------------*) 
 
PROCEDURE
      i61newprint (
            VAR line    : tsp00_PrtLine;
            linelen     : tin_natural;
            linefeeds   : tsp00_VpLinefeeds;
            linestyle   : tin_vp_style;
            VAR errtext : tsp00_ErrText;
            VAR vpok    : boolean );
 
VAR
      pline       : tsp00_PrtLine;
      plinelen    : tin_natural;
      plinepos    : tin_natural;
      plinefeeds  : tsp00_VpLinefeeds;
      pwidth      : tin_natural;
      linerest    : tsp00_PrtLine;
      linelenrest : tin_natural;
      linetemp    : tsp00_PrtLine;
      new_page    : boolean;
      npl         : tin_natural;
 
BEGIN
WITH i01g^ DO
    vpok := (vp.status <> vp_not_open);
(*ENDWITH*) 
IF  vpok
THEN
    BEGIN
    new_page := false;
    IF  i01g^.vp.act_line = 0
    THEN
        BEGIN
        WITH i01g^.set_parms.printformat DO
            printlinefeeds (printerset [act_print].tmargin, new_page);
        (*ENDWITH*) 
        printtitlelines (vp_toptitle, new_page);
        END
    ELSE
        BEGIN
        npl := needprintlines (linelen, linefeeds, linestyle);
        IF  (linefeeds = vp_page) OR
            (npl > i61linesleft)
        THEN
            BEGIN
            new_page := false;
            printtitlelines (vp_bottitle, new_page);
            new_page := true;
            i01g^.vp.act_page := i01g^.vp.act_page + 1;
            WITH i01g^.set_parms.printformat DO
                printlinefeeds (printerset [act_print].tmargin, new_page);
            (*ENDWITH*) 
            printtitlelines (vp_toptitle, new_page);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    pwidth := printwidth;
    linetemp := line;
    linelenrest := linelen;
    WHILE linelenrest > 0 DO
        BEGIN
        linerest := linetemp;
        plinelen := 0;
        plinepos := 1;
        SAPDB_PascalForcedFill (PRTLINE_MXSP00, @pline, plinepos, PRTLINE_MXSP00, bsp_c1);
        WITH i01g^.set_parms.printformat DO
            plinepos := plinepos + printerset [act_print].lmargin;
        (*ENDWITH*) 
        IF  linelenrest > pwidth
        THEN
            BEGIN
            CASE linestyle OF
                vp_trunc:
                    BEGIN
                    s10mv (PRTLINE_MXSP00,PRTLINE_MXSP00,
                          @linerest,1,
                          @pline,plinepos,pwidth);
                    WITH i01g^.set_parms.printformat DO
                        plinelen := pwidth + printerset [act_print].lmargin;
                    (*ENDWITH*) 
                    linelenrest := 0;
                    END;
                vp_split:
                    BEGIN
                    s10mv (PRTLINE_MXSP00,PRTLINE_MXSP00,
                          @linerest,1,
                          @pline,plinepos,pwidth);
                    WITH i01g^.set_parms.printformat DO
                        plinelen := pwidth + printerset [act_print].lmargin;
                    (*ENDWITH*) 
                    linelenrest := linelenrest - pwidth;
                    s10mv (PRTLINE_MXSP00,PRTLINE_MXSP00,
                          @linetemp,1,
                          @linerest,plinepos,linelenrest);
                    END;
                vp_wrap:
                    BEGIN
                    s10mv (PRTLINE_MXSP00,PRTLINE_MXSP00,
                          @linerest,1,
                          @pline,plinepos,pwidth);
                    WITH i01g^.set_parms.printformat DO
                        plinelen := pwidth + printerset [act_print].lmargin;
                    (*ENDWITH*) 
                    linelenrest := 0;
                    END;
                END;
            (*ENDCASE*) 
            END
        ELSE
            BEGIN
            s10mv (PRTLINE_MXSP00,PRTLINE_MXSP00,
                  @linerest,1,
                  @pline,plinepos,linelenrest);
            WITH i01g^.set_parms.printformat DO
                plinelen := pwidth + printerset [act_print].lmargin;
            (*ENDWITH*) 
            linelenrest := 0;
            END;
        (*ENDIF*) 
        IF  new_page
        THEN
            BEGIN
            plinefeeds := vp_page;
            new_page := false;
            END
        ELSE
            BEGIN
            IF  i01g^.vp.act_line = 0
            THEN
                plinefeeds := vp_nolf
            ELSE
                plinefeeds := linefeeds;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        sqlprint (pline, plinelen, plinefeeds, errtext, vpok);
        IF  vpok
        THEN
            BEGIN
            i01g^.vp.status := vp_used;
            nextline (plinefeeds);
            END;
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
END; (* i61newprint *)
 
(*------------------------------*) 
 
FUNCTION
      i61linesleft : tin_natural;
 
VAR
      ll : integer;
 
BEGIN
WITH i01g^.vp, i01g^.set_parms.printformat DO
    BEGIN
    IF  act_line = 0
    THEN
        ll := printlength -
              (needtitlelines (top_title) + needtitlelines (bot_title))
    ELSE
        ll := printerset [act_print].pagelength -
              (act_line + needtitlelines (bot_title) +
              printerset [act_print].bmargin);
    (*ENDIF*) 
    IF  ll < 0
    THEN
        ll := 0;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
i61linesleft := ll;
END; (* i61linesleft *)
 
(*------------------------------*) 
 
FUNCTION
      i61actualline : tin_natural;
 
VAR
      aline : tin_natural;
 
BEGIN
WITH i01g^.vp, i01g^.set_parms.printformat DO
    BEGIN
    IF  act_line = 0
    THEN
        aline := 0
    ELSE
        aline := act_line - (needtitlelines (top_title)
              + printerset [act_print].tmargin);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
i61actualline := aline;
END; (* i61actualline *)
 
(*------------------------------*) 
 
PROCEDURE
      i61linefeeds (
            lf          : tin_natural;
            VAR errtext : tsp00_ErrText;
            VAR vpok    : boolean );
 
VAR
      i        : tin_natural;
      pline    : tsp00_PrtLine;
      plinelen : tin_natural;
      lfeed    : tsp00_VpLinefeeds;
      lstyle   : tin_vp_style;
 
BEGIN
pline[1]  := bsp_c1;
plinelen := 1;
lfeed := vp_onelf;
lstyle := vp_trunc;
FOR i := 1 TO lf DO
    i61newprint (pline, plinelen, lfeed, lstyle, errtext, vpok);
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i61conditionalpage (
            needlines   : tin_natural;
            VAR vpok    : boolean );
 
VAR
      new_page : boolean;
 
BEGIN
WITH i01g^.vp DO
    vpok := ( (printlength -
          (needtitlelines (top_title) + needtitlelines (bot_title))) >=
          needlines);
(*ENDWITH*) 
IF  vpok AND (needlines > i61linesleft)
THEN
    BEGIN
    new_page := false;
    printtitlelines (vp_bottitle, new_page);
    new_page := true;
    i01g^.vp.act_page := i01g^.vp.act_page + 1;
    WITH i01g^.set_parms.printformat DO
        printlinefeeds (printerset [act_print].tmargin, new_page);
    (*ENDWITH*) 
    printtitlelines (vp_toptitle, new_page);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i61endpage (
            inittitle   : boolean);
 
VAR
      new_page : boolean;
 
BEGIN
new_page := false;
printtitlelines (vp_bottitle, new_page);
IF  inittitle
THEN
    i61inittitle;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      printlinefeeds (
            lf           : tin_natural;
            VAR new_page : boolean);
 
VAR
      n_threelf   : tin_natural;
      i_threelf   : tin_natural;
      rest_lf     : 0..2;
      lfeed       : tsp00_VpLinefeeds;
      pline       : tsp00_PrtLine;
      plinelen    : tin_natural;
      lines       : tin_natural;
      errtext     : tsp00_ErrText;
      vpok        : boolean;
 
BEGIN
vpok := true;
lines := lf;
IF  lines > 0
THEN
    BEGIN
    pline [1]  := bsp_c1;
    plinelen := 1;
    lfeed := vp_onelf;
    IF  (i01g^.vp.act_line = 0) AND (NOT new_page)
    THEN
        lfeed := vp_nolf;
    (*ENDIF*) 
    IF  new_page
    THEN
        lfeed := vp_page;
    (*ENDIF*) 
    sqlprint (pline, plinelen, lfeed, errtext, vpok);
    IF  vpok
    THEN
        BEGIN
        i01g^.vp.act_line := 0;
        i01g^.vp.status := vp_used;
        lines := lines - 1;
        new_page := false;
        END;
    (*ENDIF*) 
    IF  lines > 0
    THEN
        BEGIN
        n_threelf := lf DIV 3;
        FOR i_threelf := 1 TO n_threelf DO
            sqlprint (pline, plinelen, vp_threelf, errtext, vpok);
        (*ENDFOR*) 
        rest_lf := lf MOD 3;
        IF  rest_lf > 0
        THEN
            BEGIN
            CASE rest_lf OF
                1:
                    lfeed := vp_onelf;
                2:
                    lfeed := vp_twolf;
                END;
            (*ENDCASE*) 
            sqlprint (pline, plinelen, lfeed, errtext, vpok);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  vpok
    THEN
        BEGIN
        i01g^.vp.status   := vp_used;
        i01g^.vp.act_line := i01g^.vp.act_line + lf;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END; (* printlinefeeds *)
 
(*------------------------------*) 
 
FUNCTION
      needprintlines (
            linelen   : tin_natural;
            linefeeds : tsp00_VpLinefeeds;
            linestyle : tin_vp_style) : tin_natural;
 
VAR
      nl : tin_natural;
 
BEGIN
nl := 0;
IF  NOT (linefeeds IN [  vp_nolf, vp_page ] )
THEN
    BEGIN
    CASE linestyle OF
        vp_trunc :
            nl := 1;
        vp_split :
            BEGIN
            nl := printwidth DIV linelen;
            IF  (printwidth MOD linelen) > 0
            THEN
                nl := nl + 1;
            (*ENDIF*) 
            END;
        vp_wrap :
            BEGIN
            nl := printwidth DIV linelen;
            IF  (printwidth MOD linelen) > 0
            THEN
                nl := nl + 1;
            (*ENDIF*) 
            END;
        END;
    (*ENDCASE*) 
    CASE linefeeds OF
        vp_onelf:
            nl := nl;
        vp_twolf:
            nl := nl * 2;
        vp_threelf:
            nl := nl * 3;
        END;
    (*ENDCASE*) 
    END;
(*ENDIF*) 
needprintlines := nl;
END; (* needprintlines *)
 
(*------------------------------*) 
 
PROCEDURE
      nextline (
            linefeeds : tsp00_VpLinefeeds );
 
BEGIN
IF  i01g^.vp.act_line = 0
THEN
    i01g^.vp.act_line := 1
ELSE
    BEGIN
    IF  linefeeds <>  vp_nolf
    THEN
        WITH i01g^.vp DO
            CASE linefeeds OF
                vp_page:
                    act_line := 1;
                vp_onelf:
                    act_line := act_line + 1;
                vp_twolf:
                    act_line := act_line + 2;
                vp_threelf:
                    act_line := act_line + 3;
                END;
            (*ENDCASE*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END; (* nextline *)
 
(*------------------------------*) 
 
PROCEDURE
      printtitlelines (
            ttyp : tin_vp_titletyp;
            VAR new_page : boolean);
 
VAR
      i       : tin_natural;
      lfeed   : tsp00_VpLinefeeds;
      errtext : tsp00_ErrText;
      vpok    : boolean;
      first   : boolean;
 
BEGIN
CASE ttyp OF
    vp_toptitle :
        WITH i01g^.vp.top_title DO
            BEGIN
            first := true;
            FOR i := 1 TO cin_maxtitleline  DO
                BEGIN
                IF  tlinelen [i]  > 0
                THEN
                    BEGIN
                    WITH i01g^.vp.page_pos DO
                        IF  (tlinepos > 0) AND
                            (tlinetyp = vp_toptitle) AND
                            (tlinenum = i)
                        THEN
                            setpagenum (tline [i] , tlinelen [i] ,
                                  tlinepos);
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    WITH i01g^.vp.date_pos DO
                        IF  (tlinepos > 0) AND
                            (tlinetyp = vp_toptitle) AND
                            (tlinenum = i)
                        THEN
                            setdatestr (tline [i] , tlinelen [i] ,
                                  tlinepos);
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    WITH i01g^.vp.time_pos DO
                        IF  (tlinepos > 0) AND
                            (tlinetyp = vp_toptitle) AND
                            (tlinenum = i)
                        THEN
                            settimestr (tline [i] , tlinelen [i] ,
                                  tlinepos);
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    IF  new_page
                    THEN
                        BEGIN
                        sqlprint (tline [i] , tlinelen [i] , vp_page,
                              errtext, vpok);
                        new_page := false;
                        i01g^.vp.act_line := 0;
                        first := false;
                        END
                    ELSE
                        BEGIN
                        IF  first
                        THEN
                            lfeed := vp_nolf
                        ELSE
                            lfeed := tlinefeed [i] ;
                        (*ENDIF*) 
                        sqlprint (tline [i] , tlinelen [i] , lfeed,
                              errtext, vpok);
                        first := false;
                        END;
                    (*ENDIF*) 
                    IF  vpok
                    THEN
                        BEGIN
                        i01g^.vp.status := vp_used;
                        nextline (tlinefeed [i] );
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDFOR*) 
            END;
        (*ENDWITH*) 
    vp_bottitle :
        BEGIN
        tobottomtitle;
        WITH i01g^.vp.bot_title DO
            FOR i := 1 TO cin_maxtitleline DO
                BEGIN
                IF  tlinelen [i]  > 0
                THEN
                    BEGIN
                    WITH i01g^.vp.page_pos DO
                        IF  (tlinepos > 0) AND
                            (tlinetyp = vp_bottitle) AND
                            (tlinenum = i)
                        THEN
                            setpagenum (tline [i] , tlinelen [i] ,
                                  tlinepos);
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    WITH i01g^.vp.date_pos DO
                        IF  (tlinepos > 0) AND
                            (tlinetyp = vp_bottitle) AND
                            (tlinenum = i)
                        THEN
                            setdatestr (tline [i] , tlinelen [i] ,
                                  tlinepos);
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    WITH i01g^.vp.time_pos DO
                        IF  (tlinepos > 0) AND
                            (tlinetyp = vp_bottitle) AND
                            (tlinenum = i)
                        THEN
                            settimestr (tline [i] , tlinelen [i] ,
                                  tlinepos);
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    sqlprint (tline [i] , tlinelen [i] , tlinefeed [i] ,
                          errtext, vpok);
                    IF  vpok
                    THEN
                        BEGIN
                        i01g^.vp.status := vp_used;
                        nextline (tlinefeed [i] );
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDFOR*) 
        (*ENDWITH*) 
        END;
    END;
(*ENDCASE*) 
END; (* printtitlelines *)
 
(*------------------------------*) 
 
FUNCTION
      needtitlelines (
            title : tin_vp_title ) : tin_natural;
 
VAR
      ntl : tin_natural;
      i   : tin_natural;
 
BEGIN
WITH title DO
    BEGIN
    ntl := 0;
    FOR i:=1 TO cin_maxtitleline DO
        IF  (tlinelen [i]  > 0) AND
            (tlinefeed [i]  IN [  vp_onelf, vp_twolf, vp_threelf ] )
        THEN
            BEGIN
            CASE tlinefeed [i]  OF
                vp_onelf:
                    ntl := ntl + 1;
                vp_twolf:
                    ntl := ntl + 2;
                vp_threelf:
                    ntl := ntl + 3;
                END;
            (*ENDCASE*) 
            END;
        (*ENDIF*) 
    (*ENDFOR*) 
    needtitlelines := ntl;
    END;
(*ENDWITH*) 
END; (* needtitlelines *)
 
(*------------------------------*) 
 
PROCEDURE
      tobottomtitle;
 
VAR
      lf : tin_natural;
      blines : tin_natural;
      new_page : boolean;
 
BEGIN
blines := needtitlelines (i01g^.vp.bot_title);
IF  blines > 0
THEN
    BEGIN
    WITH i01g^.set_parms.printformat, printerset [act_print] DO
        BEGIN
        lf := pagelength - (bmargin + blines);
        lf := lf - i01g^.vp.act_line;
        END;
    (*ENDWITH*) 
    new_page := false;
    printlinefeeds (lf, new_page);
    END;
(*ENDIF*) 
END; (* tobottomtitle *)
 
(*------------------------------*) 
 
PROCEDURE
      setpagenum (
            VAR line : tsp00_PrtLine;
            linelen  : tin_natural;
            pagepos  : tin_natural);
 
VAR
      pn      : tin_natural;
      ppos    : tin_natural;
      strnum  : tsp00_C5;
      divisor : tin_natural;
      digit   : tin_natural;
      range   : tin_natural;
      i       : tin_natural;
 
BEGIN
pn := i01g^.vp.act_page;
range := 0;
divisor := 0;
REPEAT
    pn := pn DIV 10;
    range := range + 1;
    IF  divisor = 0
    THEN
        divisor := 1
    ELSE
        divisor := divisor * 10;
    (*ENDIF*) 
UNTIL
    pn = 0;
(*ENDREPEAT*) 
pn := i01g^.vp.act_page;
FOR i:=1 TO range DO
    BEGIN
    digit := pn DIV divisor;
    strnum [i]  := chr (ord ('0')+digit);
    pn := pn - (digit * divisor);
    divisor := divisor DIV 10;
    END;
(*ENDFOR*) 
IF  (pagepos + range - 1) > linelen
THEN
    ppos := (linelen - range) + 1
ELSE
    ppos := pagepos;
(*ENDIF*) 
s10mv (mxsp_c5,PRTLINE_MXSP00,
      @strnum,1,
      @line,ppos,range);
END;
 
(*------------------------------*) 
 
PROCEDURE
      setdatestr (
            VAR line : tsp00_PrtLine;
            linelen  : tin_natural;
            datepos  : tin_natural);
 
VAR
      date        : tsp00_Date;
      time        : tsp00_Time;
      outputfield : tin_date_mask;
      dpos        : tin_natural;
 
BEGIN
sqldattime (date, time);
i41dput (i01g^.set_parms.date, date, outputfield);
IF  (datepos + outputfield.mlen - 1) > linelen
THEN
    dpos := (linelen - outputfield.mlen) + 1
ELSE
    dpos := datepos;
(*ENDIF*) 
s10mv (mxin_date_mask_string,PRTLINE_MXSP00,
      @outputfield.msk,1,
      @line,dpos,outputfield.mlen);
END;
 
(*------------------------------*) 
 
PROCEDURE
      settimestr (
            VAR line : tsp00_PrtLine;
            linelen  : tin_natural;
            timepos  : tin_natural);
 
VAR
      date        : tsp00_Date;
      time        : tsp00_Time;
      outputfield : tin_date_mask;
      tpos        : tin_natural;
 
BEGIN
sqldattime (date, time);
i41tput (i01g^.set_parms.time, time, outputfield);
IF  (timepos + outputfield.mlen - 1) > linelen
THEN
    tpos := (linelen - outputfield.mlen) + 1
ELSE
    tpos := timepos;
(*ENDIF*) 
s10mv (mxin_date_mask_string,PRTLINE_MXSP00,
      @outputfield.msk,1,
      @line,tpos,outputfield.mlen);
END;
 
(*------------------------------*) 
 
FUNCTION
      i61pw : tin_natural;
 
BEGIN
i61pw := printwidth;
END; (* i61pw *)
 
(*------------------------------*) 
 
FUNCTION
      printwidth : tin_natural;
 
VAR
      pw : tin_natural;
 
BEGIN
WITH i01g^.set_parms.printformat, printerset [act_print] DO
    pw := pagewidth - (lmargin + rmargin);
(*ENDWITH*) 
printwidth := pw;
END; (* printwidth *)
 
(*------------------------------*) 
 
FUNCTION
      printlength : tin_natural;
 
VAR
      pl : tin_natural;
 
BEGIN
WITH i01g^.set_parms.printformat, printerset [act_print] DO
    pl := pagelength - (tmargin + bmargin);
(*ENDWITH*) 
printlength := pl;
END; (* printlength *)
 
(*------------------------------*) 
 
FUNCTION
      i61questionprint (
            msgtext     : tin_screenline;
            msglen      : tin_natural;
            VAR errtext : tsp00_ErrText;
            VAR ok      : boolean ) : boolean;
 
VAR
      answer : boolean;
      line   : tsp00_Line;
 
BEGIN
answer := false;
&ifdef WINDOWS
s10mv (mxin_screenline,LINE_MXSP00,
      @msgtext,1,
      @line,1,msglen);
answer := i56question (line, msglen);
IF  answer
THEN
    i61close (true, errtext, ok);
&endif
(*ENDIF*) 
i61questionprint := answer;
END; (* i61questionprint *)
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
