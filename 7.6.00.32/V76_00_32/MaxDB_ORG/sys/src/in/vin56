.CM  SCRIPT , Version - 1.1 , last edited by holger
.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VIN56$
.tt 2 $$$
.TT 3 $$Logical Screen Procedures$07.02.95$$1998-06-02$
***********************************************************
.nf
 
.nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : logical_screen_modules
=========
.sp
Purpose : Logical Screen modules such as frame, scroll bars
          and title (headerline)
 
 
&       if $OS=UNIX
&       define hifmode 1
&       else
&       ifdef WINDOWS
&       define hifmode 1
&       define NEW 1
&       endif
&       endif
 
.CM *-END-* purpose -------------------------------------
.sp
Define  :
 
&       ifdef WINDOWS
        VAR
              i56input_from_box : boolean;
              i56recursion      : tsp00_Int2;
              i56desc2          : tsp00_TerminalDescription ;
              i56sysline2       : tsp00_Line;
              i56sysatt2        : tsp00_Line;
&       endif
 
        PROCEDURE
              i56init;
 
        PROCEDURE
              i56putframe (
                    with_name  : boolean;
                    with_parms : boolean );
 
        PROCEDURE
              i56title (
                    blinking_modefield : boolean;
                    screen_nr          : integer;
                    VAR title          : tsp00_OnlineHeader);
 
        PROCEDURE
              i56clwinheader (
                    screen_nr : integer );
 
        FUNCTION
              i56modecol (
                    VAR title : tsp00_OnlineHeader) : integer;
 
        PROCEDURE
              i56hrange (
                    screen_nr  : integer;
                    VAR hrange : tin_display_range);
 
        PROCEDURE
              i56vrange (
                    screen_nr  : integer;
                    VAR lbl    : tsp00_C8;
                    VAR vrange : tin_display_range);
 
        FUNCTION
              i56scrolldir (
                    VAR key : tsp00_VtKeyStroke ) : tsp00_Int4;
 
        PROCEDURE
              i56putlabels (
                    fct_cursorpos      : tin_ls_releasemode;
                    functionline_label : boolean);
 
        PROCEDURE
              i56setmark (
                    screen_nr     : tsp00_Int2;
                    screenpart    : tin_ls_part;
                    mode          : tsp00_VtMark;
                    top, left     : tsp00_Int2;
                    bottom, right : tsp00_Int2 );
 
        PROCEDURE
              i56getmark (
                    screen_nr         : tsp00_Int2;
                    screenpart        : tin_ls_part;
                    VAR mode          : tsp00_VtMark;
                    VAR top, left     : tsp00_Int2;
                    VAR bottom, right : tsp00_Int2 );
 
        PROCEDURE
              i56errormessage (
                    screen_nr : tsp00_Int2;
                    VAR field : tin_screenline;
                    length    : tin_natural );
&       ifdef WINDOWS
 
        PROCEDURE
              i56dlgbox (
                    box_id          : tsp00_Int2;
                    style           : tsp00_DlgBoxStyle;
                    screenpart      : tin_ls_part;
                    VAR trigger     : tin_ls_key_set;
                    immediate       : boolean;
                    callback_switch : tsp00_Int2;
                    context         : tsp00_BufAddr;
                    ok_button       : tin_ls_releasemode;
                    cancel_button   : tin_ls_releasemode);
 
        PROCEDURE
              i56standardbox (
                    mode      : tsp00_VtUsageMode;
                    immediate : boolean ;
                    enable    : boolean );
 
        PROCEDURE
              i56confirmbox (
                    boxid       : tsp00_Int2;
                    VAR trigger : tin_ls_key_set;
                    VAR text    : tsp00_Line;
                    textlen     : tsp00_Int2 );
 
        PROCEDURE
              i56clconfirmboxes ;
 
        FUNCTION
              i56question (
                    VAR text : tsp00_Line;
                    textlen  : tsp00_Int2 ) : boolean;
 
        PROCEDURE
              i56infobox (
                    VAR text : tsp00_Line;
                    textlen  : tsp00_Int2 ;
                    wait     : boolean ) ;
 
        PROCEDURE
              i56ckinfobox ;
 
        PROCEDURE
              i56setfocus(
                    boxid       : tsp00_Int2;
                    sline, scol : tsp00_Int2);
 
        PROCEDURE
              i56check_box(
                    boxid           : tsp00_Int2;
                    VAR box_changed : boolean;
                    VAR focus_line  : tsp00_Int2;
                    VAR focus_col   : tsp00_Int2);
 
        PROCEDURE
              i56dlgremove (
                    boxid : tsp00_Int2 );
 
        PROCEDURE
              i56dlgerase (
                    screenpart : tin_ls_part );
 
        PROCEDURE
              i56clearerrormsg;
 
        PROCEDURE
              i56exitmessage ;
 
        PROCEDURE
              i56todialogbox (
                    VAR field      : tsp00_Line;
                    length         : tin_natural;
                    VAR field_pos  : tin_ls_position;
                    VAR field_type : tin_ls_fieldtype);
 
        PROCEDURE
              i56getwindow (
                    first_pos          : tin_ls_position;
                    VAR window_changed : boolean);
 
        PROCEDURE
              i56getfield (
                    VAR vt_input    : tin_ls_input_field;
                    VAR field_found : boolean);
 
        PROCEDURE
              i56selectitem (
                    VAR handle      : tin_screenline;
                    VAR item        : tin_screenline;
                    VAR item_length : tsp00_Int2;
                    VAR ok          : boolean );
 
        PROCEDURE
              i56plistbox (
                    VAR field     : tsp00_Line;
                    length        : tin_natural;
                    VAR field_pos : tin_ls_position;
                    selected      : boolean;
                    current       : boolean );
 
        PROCEDURE
              i56scrarea (
                    VAR first_pos : tin_ls_position;
                    scroll_dir    : tsp00_VtScroll;
                    lines         : tin_natural;
                    cols          : tin_natural);
 
        FUNCTION
              i56spartswitched (
                    screenpart : tin_ls_part ) : boolean;
 
        FUNCTION
              i56boxswitched (
                    boxid : tsp00_Int2 ) : boolean;
 
        FUNCTION
              i56push : tsp00_Int4;
 
        PROCEDURE
              i56pop (
                    adr : tsp00_Int4 );
 
        PROCEDURE
              i56acttofocus;
 
        FUNCTION
              i56actbox : tsp00_Int2;
 
        FUNCTION
              i56actscreenpart : tin_ls_part;
&       endif
 
        FUNCTION
              in5630 : tsp00_Int4;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              global_variable : VIN01;
 
        VAR
              i01g : tin_global_in_vars;
 
      ------------------------------ 
 
        FROM
              Binary_String_Conversions : VIN35 ;
 
        PROCEDURE
              i35intlj_into_str (
                    source_num     : tsp00_Int4;
                    VAR result_str : tsp00_C10;
                    VAR res_len    : integer);
 
      ------------------------------ 
 
        FROM
              logical_screen : VIN50;
 
        PROCEDURE
              i50put1field (
                    VAR field  : tsp00_C8;
                    length     : tin_natural;
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype);
 
        PROCEDURE
              i50put2field (
                    VAR field  : tin_text_field;
                    length     : tin_natural;
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype);
 
        PROCEDURE
              i50put3field (
                    VAR field  : tin_mode_field;
                    length     : tin_natural;
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype);
 
        PROCEDURE
              i50put4field (
                    VAR field  : tin_screenline;
                    length     : tin_natural;
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype);
 
        PROCEDURE
              i50put5field (
                    VAR field  : tin_screenline;
                    length     : tin_natural;
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype);
 
      ------------------------------ 
 
        FROM
              logical_screen_layout : VIN51;
 
        PROCEDURE
              i51size (
                    screen_part    : tin_ls_part;
                    VAR partlength : tin_natural;
                    VAR partwidth  : tin_natural);
 
        PROCEDURE
              i51size2 (
                    sno            : integer;
                    screen_part    : tin_ls_part;
                    VAR partlength : tin_natural;
                    VAR partwidth  : tin_natural);
 
      ------------------------------ 
 
        FROM
              logical_screen_variants : VIN52;
 
        PROCEDURE
              i52substmsg (
                    msgno        : integer;
                    VAR textline : tin_screenline;
                    VAR length   : tin_natural);
 
        PROCEDURE
              i52fromscreenpos (
                    VAR pos       : tin_ls_position;
                    VAR screenlno : tin_natural;
                    VAR screencol : tin_natural);
 
        PROCEDURE
              i52lsmsg (
                    msgno        : integer;
                    VAR textline : tin_screenline;
                    VAR length   : tin_natural);
 
        PROCEDURE
              i52pflabels (
                    fct_cursorpos      : tin_ls_releasemode;
                    functionline_label : boolean);
&       ifdef hifmode
 
        PROCEDURE
              i52skmenu (
                    VAR hif : tsp00_HifParms);
&       endif
&       ifdef WINDOWS
 
        PROCEDURE
              i52keysettrans (
                    VAR inp : tin_ls_key_set;
                    VAR res : tsp00_VtKeys);
 
        FUNCTION
              i52keytrans (
                    rf : tin_ls_releasemode) : tsp00_VtKey ;
 
      ------------------------------ 
 
        FROM
              logical_screen_procedures : VIN53 ;
 
        PROCEDURE
              i53put1field (
                    VAR field      : tsp00_C12;
                    length         : integer;
                    sno            : tsp00_Int2;
                    field_slno     : integer;
                    field_scol     : integer;
                    VAR field_type : tin_ls_fieldtype;
                    lines,cols     : integer;
                    vt_screen      : tin_lineaddr;
                    vt_att         : tin_lineaddr);
&       endif
 
      ------------------------------ 
 
        FROM
              logical_screen_help_procedures : VIN54;
 
        PROCEDURE
              i54terminal_type (
                    VAR typ : tin_terminal_type);
&       ifdef WINDOWS
 
      ------------------------------ 
 
        FROM
              logical_screen_IO : VIN57;
 
        PROCEDURE
              i57ioscreen (
                    VAR csr_pos        : tin_ls_position;
                    VAR rf             : tin_ls_releasemode;
                    VAR screen_changed : boolean);
&       endif
&       ifdef WINDOWS
 
      ------------------------------ 
 
        FROM
              Windows_RTE_Extension : VEN102W ;
 
        PROCEDURE
              sqlwtitle (
                    reference : tsp00_Int4;
                    screen_nr : tsp00_Int2;
                    VAR text  : tsp00_Line;
                    len       : tsp00_Int2;
                    VAR ok    : boolean);
 
        PROCEDURE
              sqlwdgstext (
                    box_id   : tsp00_Int2;
                    item_id  : tsp00_Int2;
                    VAR text : tin_screenline;
                    text_len : tsp00_Int2;
                    att      : tsp00_VtAttrib;
                    VAR ok   : boolean);
 
        PROCEDURE
              sqlwdggtext (
                    box_id       : tsp00_Int2;
                    VAR item_id  : tsp00_Int2;
                    VAR text     : tin_screenline;
                    VAR text_len : tsp00_Int2;
                    VAR changed  : boolean ;
                    VAR ok       : boolean);
 
        PROCEDURE
              sqlwdgsfocus(
                    box_id  : tsp00_Int2;
                    item_id : tsp00_Int2);
 
        PROCEDURE
              sqlwdggfocus(
                    VAR box_id  : tsp00_Int2;
                    VAR item_id : tsp00_Int2);
 
        PROCEDURE
              sqlwscbar (
                    term_ref  : tsp00_Int4;
                    screen_nr : tsp00_Int2;
                    t         : tsp_scroll;
                    range_beg : tsp00_Int2;
                    range_end : tsp00_Int2;
                    pos       : tsp00_Int2;
                    VAR ok    : boolean);
 
        PROCEDURE
              sqlwdgremove (
                    box_id : tsp00_Int2);
 
        PROCEDURE
              sqlwdgswitch (
                    box_id          : tsp00_Int2;
                    style           : tsp00_DlgBoxStyle;
                    VAR trigger     : tsp00_VtKeys;
                    callback_switch : tsp00_Int2;
                    context         : tsp00_BufAddr;
                    ok_button       : tsp00_VtKey;
                    cancel_button   : tsp00_VtKey;
                    VAR ok          : boolean);
 
        PROCEDURE
              sqlwdgerase (
                    box_id  : tsp00_Int2;
                    item_id : tsp00_Int2 );
 
        PROCEDURE
              sqlwscrarea (
                    term_ref   : tsp00_Int4;
                    screen_nr  : tsp00_Int2;
                    scroll_dir : tsp00_VtScroll;
                    VAR rect   : tsp00_VtRectangle;
                    VAR ok     : boolean);
 
        PROCEDURE
              sqltsetmark (
                    term_ref   : tsp00_Int4;
                    screen_nr  : tsp00_Int2;
                    mode       : tsp00_VtMark;
                    VAR region : tsp00_VtRectangle ;
                    VAR switchkeys : tsp00_VtKeys;
                    VAR ok     : boolean );
 
        PROCEDURE
              sqltgetmark (
                    term_ref   : tsp00_Int4;
                    screen_nr  : tsp00_Int2;
                    VAR mode   : tsp00_VtMark;
                    VAR region : tsp00_VtRectangle ;
                    VAR ok     : boolean );
 
        PROCEDURE
              sqlwlget (
                    listhandle  : tsp00_Int4;
                    rowpos      : tsp00_Int4;
                    colpos      : tsp00_Int2;
                    VAR text    : tin_screenline;
                    VAR textlen : tsp00_Int2;
                    VAR ok      : boolean );
&       endif
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30klen (
                    VAR str : tsp00_C8;
                    val     : char; cnt : integer) : integer;
 
        FUNCTION
              s30lnr (
                    VAR str : tin_screenline;
                    val     : char;
                    start   : tsp00_Int4;
                    cnt     : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30lnr1 (
                    VAR str : tin_text_field;
                    val     : char;
                    start   : tsp00_Int4;
                    cnt     : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30gad (
                    VAR b : tsp00_Line) : tin_lineaddr;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;       
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;    
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;    
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              m90buf;
 
              tsp00_Buf tsp00_C20
 
        PROCEDURE
              s30lnr;
 
              tsp00_MoveObj tin_screenline
 
        PROCEDURE
              i50put4field;
 
              tsp00_MoveObj tin_screenline
 
        PROCEDURE
              i50put3field;
 
              tsp00_MoveObj tin_mode_field
 
        PROCEDURE
              i50put1field;
 
              tsp00_MoveObj tsp00_C8
 
        PROCEDURE
              i50put2field;
 
              tsp00_MoveObj tin_text_field
 
        FUNCTION
              s30lnr1;
 
              tsp00_MoveObj tin_text_field
 
        FUNCTION
              s30klen;
 
              tsp00_MoveObj tsp00_C8
 
        PROCEDURE
              i53put1field;
 
              tsp00_MoveObj tsp00_C12
              tsp00_ScreenBufAddr tin_lineaddr
 
        FUNCTION
              s30gad;
 
              tsp00_MoveObj tsp00_Line
              tsp00_Addr tin_lineaddr
 
        PROCEDURE
              i50put5field;
 
              tsp00_MoveObj tin_screenline
 
&             ifdef WINDOWS
 
        PROCEDURE
              sqlwdgstext;
 
              tsp00_Line tin_screenline
 
        PROCEDURE
              sqlwdggtext;
 
              tsp00_Line tin_screenline
 
        PROCEDURE
              sqlwlget;
 
              tsp00_MoveObj tin_screenline
&             endif
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1989-12-04
.sp
.cp 3
.sp
.cp 3
Release :      Date : 1998-06-02
.sp
.cp 3
.sp
***********************************************************
.pa
.cp 10
.fo
.oc _/1
Specification:
.sp 2;.nf
        PROCEDURE
              i56standardbox (
                    mode      : tsp00_VtUsageMode;
                    immediate : boolean ;
                    enable    : boolean );
.sp 2;.fo
This procedure enables or disables the Windows Standard Box
("Commandline").  MODE is the usage mode currently defined for I/O
(vt_edit or vt_form).  If IMMEDIATE = TRUE, the standard box appears
immediately after the next output; if FALSE, it appears after the user
selects "Command" on the Menu Bar.  If ENABLE = TRUE, the Standard Box
will be enabled; if FALSE, it is disabled.
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      msg_sysname        = 2;
&     ifdef WINDOWS
      mx_sysline         = 128 (* LINE_MXSP00 - 4 *);
      maxboxlist         = 10;
      cin_dlg_infobox    = 18500 ;
&     else
      mx_sysline = LINE_MXSP00 ;
&     endif
 
TYPE
 
      text20 = RECORD
            len : tin_natural;
            txt : tsp00_C20;
      END;
 
 
      stext = RECORD
            len : tin_natural;
            txt : tin_screenline;
      END;
 
      side_of_screen = (left_side, right_side);
      tin56_scroll_direction = (left_only, right_only, left_and_right,
            no_shift);
&     ifdef WINDOWS
      tin56_infobox_state = ( boxstate_off, boxstate_open,
            boxstate_written );
 
      tin56_boxentry = RECORD
            boxid      : tsp00_Int2;
            screenpart : tin_ls_part;
      END;
 
      tin56_boxlist = ARRAY [1..maxboxlist] OF tin56_boxentry;
 
      tin56_stack = RECORD
            input_from_box : boolean;
            boxlist        : tin56_boxlist;
            actual         : tsp00_Int2;
      END;
 
 
      tin56_stackp = RECORD
            CASE boolean OF
                true:
                    (p : ^tin56_stack);
                false:
                    (i : tsp00_Int4);
                END;
            (*ENDCASE*) 
&           endif
&           ifdef WINDOWS
 
 
VAR
      i56boxlist : tin56_boxlist;
      i56actual  : tsp00_Int2;
      i56hfactor : real;
      i56vfactor : real;
      i56hcols   : tsp00_Int2;
      i56vlines  : tsp00_Int2;
      i56boxstate: tin56_infobox_state ;
&     endif
 
 
(*------------------------------*) 
 
FUNCTION
      in5630 : tsp00_Int4;
 
BEGIN
(* linkcheck function *)
in5630 := 219020708;
END; (* in5630 *)
 
(*------------------------------*) 
 
PROCEDURE
      i56init;
 
VAR
      i : integer;
 
BEGIN
&ifdef WINDOWS
FOR i := 1 TO maxboxlist DO
    i56boxlist [ i ] . screenpart := cin_ls_undef_part ;
(*ENDFOR*) 
i56actual := 0;
i56input_from_box := false;
i56hfactor := 1.0 ;
i56vfactor := 1.0 ;
i56hcols   := i01g^.vt.desc.num_of_cols ;
i56vlines  := i01g^.vt.desc.num_of_lines;
SAPDB_PascalForcedFill (LINE_MXSP00, @i56sysline2, 1, LINE_MXSP00, chr(0) );
SAPDB_PascalForcedFill (LINE_MXSP00, @i56sysatt2, 1, LINE_MXSP00, chr(0) );
i56boxstate := boxstate_off ;
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      i56putframe (
            with_name  : boolean;
            with_parms : boolean );
 
BEGIN
&ifdef WINDOWS
sessionparms_to_aboutbox;
&else
normal_frame (with_name, with_parms);
&endif
END; (* i56putframe *)
 
&ifdef WINDOWS
(*------------------------------*) 
 
PROCEDURE
      sessionparms_to_aboutbox;
 
VAR
      txt : tin_screenline;
      len : tsp00_Int2;
      ok  : boolean;
 
BEGIN
IF  i01g^.session [i01g^.dbno].is_connected
THEN
    BEGIN
    WITH i01g^, session [dbno] DO
        BEGIN
        s10mv (DBNAME_MXSP00,mxin_screenline,
              @serverdb,1,
              @txt,1,DBNAME_MXSP00);
        len := s30lnr (txt , bsp_c1, 1, DBNAME_MXSP00);
        sqlwdgstext ( csp_dlg_aboutbox, csp_dlgabout_dbasename,
              txt , len, [], ok );
        s10mv (sizeof(tsp00_KnlIdentifier),mxin_screenline,
              @user_ident,1,
              @txt,1,sizeof(tsp00_KnlIdentifier));
        len := s30lnr (txt , bsp_c1, 1, DBNAME_MXSP00);
        sqlwdgstext ( csp_dlg_aboutbox, csp_dlgabout_username,
              txt , len, [], ok );
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END; (* sessionparms_to_aboutbox *)
 
&else
(*------------------------------*) 
 
PROCEDURE
      normal_frame (
            with_name  : boolean;
            with_parms : boolean );
 
CONST
      hor = csp_horizontal_bar;
 
VAR
      dash_pos        : tin_ls_position;
      dashline        : tin_screenline;
      systext         : tin_screenline;
      systextlen      : tin_natural;
      workarea_length : tin_natural;
      inarea_length   : tin_natural;
      width           : tin_natural;
      sno             : integer;
      ft              : tin_ls_fieldtype;
 
BEGIN
i51size (cin_ls_inputarea, inarea_length, width);
i51size (cin_ls_workarea, workarea_length, width);
SAPDB_PascalForcedFill (mxin_screenline, @dashline, 1, width, hor);
(* upper line *)
FOR sno := 1 TO i01g^.ls.nr_screens DO
    BEGIN
    i51size2(sno, cin_ls_inputarea, inarea_length, width);
    i51size2(sno, cin_ls_workarea, workarea_length, width);
    WITH dash_pos DO
        BEGIN
        screen_nr := sno;
        screen_part := cin_ls_workarea;
        scol := cin_first_scol;
        sline := 0;
        END;
    (*ENDWITH*) 
    (* ft := i01g^.ls.defaults  [i]  [  ls_workarea ] ; *)
    (* preliminary *)
    ft.field_att := cin_attr7;
    ft.fieldmode := [  ] ;
    i50put4field (dashline, width, dash_pos, ft);
    (* system name *)
    IF  with_name AND (sno = 1)
    THEN
        BEGIN
        get_system_name ( systext, systextlen);
        put_systext (dash_pos, systext, systextlen);
        END;
    (* lower line *)
    (*ENDIF*) 
    get_lower_frameline_pos (sno, dash_pos);
    ft.field_att := cin_attr7;
    i50put4field (dashline, width, dash_pos, ft);
    IF  with_parms AND (sno = i01g^.ls.nr_screens)
    THEN
        BEGIN
        get_sessionparms (systext, systextlen);
        put_systext (dash_pos, systext, systextlen);
        END;
    (*ENDIF*) 
    END;
(*ENDFOR*) 
END; (* normal_frame *)
 
&endif
(*------------------------------*) 
 
PROCEDURE
      get_lower_frameline_pos (
            sno     : integer;
            VAR pos : tin_ls_position);
 
VAR
      length : tin_natural;
      width  : tin_natural;
      part   : tin_ls_part;
 
BEGIN
part := cin_ls_workarea;
i51size2 (sno, part, length, width);
pos.sline := length + 1;
WITH pos DO
    BEGIN
    screen_nr := sno;
    screen_part := part;
    scol := cin_first_scol;
    END;
(*ENDWITH*) 
END; (* get_lower_frameline_pos *)
 
(*------------------------------*) 
 
PROCEDURE
      get_system_name (
            VAR systext    : tin_screenline;
            VAR systextlen : tin_natural);
 
VAR
      local_systext : tin_screenline;
      local_length  : tin_natural;
      i             : integer;
      stretch       : boolean;
 
BEGIN
i52lsmsg (msg_sysname, local_systext, local_length);
stretch := (local_systext  [1]  <> bsp_c1);
systextlen := 0;
FOR i := 1 TO local_length DO
    BEGIN
    IF  stretch
    THEN
        BEGIN
        systextlen := systextlen + 1;
        systext [  systextlen  ] := bsp_c1;
        END;
    (*ENDIF*) 
    systextlen := systextlen + 1;
    systext [  systextlen  ] := local_systext [  i ] ;
    END;
(*ENDFOR*) 
SAPDB_PascalForcedFill (LINE_MXSP00, @systext, systextlen+1,
      LINE_MXSP00-systextlen, bsp_c1);
END; (* get_system_name *)
 
(*------------------------------*) 
 
PROCEDURE
      put_systext (
            VAR pos     : tin_ls_position;
            VAR systext : tin_screenline;
            systextlen  : integer);
 
VAR
      workarea_length : tin_natural;
      width           : tin_natural;
      ft              : tin_ls_fieldtype;
      i               : integer;
      is_blank        : boolean;
 
BEGIN
IF  systextlen > 0
THEN
    BEGIN
    i51size (cin_ls_workarea, workarea_length, width);
    i := 0;
    is_blank := true;
    WHILE (i < width)
          AND (systextlen < width)
          AND is_blank DO
        BEGIN
        i := i + 1;
        is_blank := systext  [i]  = bsp_c1;
        IF  is_blank
        THEN
            systextlen := systextlen + 1; (* add blank *)
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    pos.scol := cin_first_scol + (width DIV 2) - ((systextlen + 1) DIV 2);
    ft.field_att := cin_attr7;
    ft.fieldmode := [  ] ;
    i50put4field (systext, systextlen, pos, ft);
    END;
(*ENDIF*) 
END; (* put_systext *)
 
(*------------------------------*) 
 
PROCEDURE
      get_sessionparms (
            VAR systext    : tin_screenline;
            VAR systextlen : tin_natural);
 
CONST
      sep = ':';
 
VAR
      dblen         : integer;
      nodelen       : integer;
      userlen       : integer;
      header_length : tin_natural;
      header_width  : tin_natural;
 
BEGIN
IF  i01g^.session [i01g^.dbno].is_connected
THEN (* B.M. Rel 3.0.0C 9 Apr 1991 *)
    BEGIN
    i51size (cin_ls_header, header_length, header_width);
    header_width := header_width - mxsp_c12;
    systextlen := 0;
    WITH i01g^, session [dbno] DO
        BEGIN
        dblen := DBNAME_MXSP00;
        WHILE ( dblen >= 1) AND (serverdb [ dblen ] = bsp_c1) DO
            dblen := dblen - 1;
        (*ENDWHILE*) 
        nodelen := NODEID_MXSP00;
        WHILE ( nodelen >= 1) AND (nodeid [ nodelen ] = bsp_c1) DO
            nodelen := nodelen - 1;
        (*ENDWHILE*) 
        userlen := sizeof (tsp00_KnlIdentifier);
        WHILE ( userlen >= 1) AND (user_ident [ userlen ] = bsp_c1) DO
            userlen := userlen - 1;
        (*ENDWHILE*) 
        IF  ((nodelen + dblen + userlen + 2) < header_width)
            AND (nodelen > 0)
        THEN
            BEGIN
            s10mv (NODEID_MXSP00,mxin_screenline,
                  @nodeid,1,
                  @systext,systextlen + 1,nodelen);
            systextlen := systextlen + nodelen;
            systextlen := systextlen + 1;
            systext [  systextlen  ] := sep;
            END;
        (*ENDIF*) 
        IF  ((dblen + userlen + 2) < header_width)
            AND (dblen > 0)
        THEN
            BEGIN
            s10mv (DBNAME_MXSP00,mxin_screenline,
                  @serverdb,1,
                  @systext,systextlen + 1,dblen);
            systextlen := systextlen + dblen;
            systextlen := systextlen + 1;
            systext [  systextlen  ] := sep;
            END;
        (*ENDIF*) 
        s10mv (sizeof(tsp00_KnlIdentifier),mxin_screenline,
              @user_ident,1,
              @systext,systextlen + 1,userlen);
        systextlen := systextlen + userlen;
        END;
    (*ENDWITH*) 
    END
ELSE
    systextlen := 0;
(*ENDIF*) 
END; (* get_sessionparms *)
 
(*------------------------------*) 
 
PROCEDURE
      i56title (
            blinking_modefield : boolean;
            screen_nr          : integer;
            VAR title          : tsp00_OnlineHeader);
 
VAR
      text0 : tsp00_String;
      text1 : tsp00_String;
      ok    : boolean;
 
BEGIN
IF  i01g^.ls.nr_screens = 1
THEN
    screen_nr := 1;
&ifdef WINDOWS
(*ENDIF*) 
modefield_to_sysline( screen_nr, title.mode_field );
set_dlgbox_texts( title.id_field, title.relno_field );
header_to_wtitle (title, text0, text1);
IF  (text0.length > 0) OR (text1.length > 0)
THEN
    WITH i01g^.vt DO
        BEGIN
        IF  text0.length > 0
        THEN
            sqlwtitle ( vt_ref, 0, text0.text, text0.length, ok);
        (*ENDIF*) 
        sqlwtitle ( vt_ref, screen_nr, text1.text, text1.length, ok);
        END;
    (*ENDWITH*) 
&else
(*ENDIF*) 
header_to_topline (blinking_modefield, title, screen_nr);
&endif
END; (* i56title *)
 
(*------------------------------*) 
 
PROCEDURE
      i56clwinheader (
            screen_nr : integer );
 
VAR
      title : tsp00_OnlineHeader ;
 
BEGIN
WITH title DO
    BEGIN
    id_field    := bsp_c8;
    relno_field := bsp_c8;
    mode_field  := bsp_c12;
    text_field  := bsp_c40;
    END;
(*ENDWITH*) 
i56title ( false, screen_nr, title );
END; (* i56clwinheader *)
 
(*------------------------------*) 
 
PROCEDURE
      i56hrange (
            screen_nr  : integer;
            VAR hrange : tin_display_range);
 
VAR
      scroll : tin56_scroll_direction;
 
BEGIN
&ifdef WINDOWS
win_set_hrange ( screen_nr , hrange );
&else
get_scroll_direction (hrange, scroll);
(*IF  scroll in [ left_only, left_and_right] *)
IF  (scroll = left_only)
    OR (scroll = left_and_right)
THEN
    put_scroll_chars ('<', screen_nr, left_side);
(*IF  scroll in [ right_only, left_and_right] *)
(*ENDIF*) 
IF  (scroll = right_only)
    OR (scroll = left_and_right)
THEN
    put_scroll_chars ('>', screen_nr, right_side);
&endif
(*ENDIF*) 
END; (* i56hrange *)
 
(*------------------------------*) 
 
PROCEDURE
      put_scroll_chars (
            scroll_char : char;
            sno         : integer;
            side        : side_of_screen);
 
CONST
      nr_scroll_chars = 3;
 
VAR
      scroll_chars    : tsp00_C8;
      scroll_pos      : tin_ls_position;
      ft              : tin_ls_fieldtype;
      width           : tin_natural;
      workarea_length : tin_natural;
      i               : integer;
 
BEGIN
FOR i := 1 TO nr_scroll_chars DO
    scroll_chars [  i  ] := scroll_char;
(*ENDFOR*) 
i51size (cin_ls_workarea, workarea_length, width);
WITH scroll_pos DO
    BEGIN
    screen_nr := sno;
    screen_part := cin_ls_workarea;
    sline := 0; (* upper bound *)
    IF  side = left_side
    THEN
        scol := cin_first_scol
    ELSE
        scol := width - nr_scroll_chars + 1;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
ft.field_att := cin_attr7;
ft.fieldmode := [ ] ;
i50put1field (scroll_chars, nr_scroll_chars,
      scroll_pos, ft);
WITH scroll_pos DO
    sline := workarea_length + 1; (* lower bound *)
(*ENDWITH*) 
i50put1field (scroll_chars, nr_scroll_chars,
      scroll_pos, ft);
END; (* put_scroll_chars *)
 
(*------------------------------*) 
 
PROCEDURE
      get_scroll_direction (
            VAR hrange : tin_display_range;
            VAR scroll : tin56_scroll_direction);
 
BEGIN
scroll := no_shift;
IF  hrange.displ_begin > hrange.total_begin
THEN
    scroll := left_only;
(*ENDIF*) 
IF  hrange.displ_end < hrange.total_end
THEN
    IF  scroll = left_only
    THEN
        scroll := left_and_right
    ELSE
        scroll := right_only;
    (*ENDIF*) 
(*ENDIF*) 
END; (* get_scroll_direction *)
 
(*------------------------------*) 
 
PROCEDURE
      i56vrange (
            screen_nr  : integer;
            VAR lbl    : tsp00_C8;
            VAR vrange : tin_display_range);
 
BEGIN
&ifdef WINDOWS
win_set_vrange ( screen_nr, vrange );
&else
put_rangenumbers (screen_nr, lbl, vrange.displ_begin,
      vrange.displ_end);
&endif
END; (* i56vrange *)
 
(*------------------------------*) 
 
FUNCTION
      i56scrolldir (
            VAR key : tsp00_VtKeyStroke ) : tsp00_Int4;
 
VAR
      sign       : tsp00_Int2;
      rdir       : real;
      scroll_dir : tsp00_Int4;
 
BEGIN
IF  (key.key = vt_hscroll)
    OR (key.key = vt_vscroll)
THEN
    BEGIN
    scroll_dir := key.scroll_dir;
&   ifdef WINDOWS
    IF  scroll_dir > 0
    THEN
        sign := +1
    ELSE
        sign := -1;
    (*ENDIF*) 
    rdir := scroll_dir * sign;
    IF  key.key = vt_hscroll
    THEN
        rdir := rdir / i56hfactor
    ELSE
        rdir := rdir / i56vfactor;
    (*ENDIF*) 
    scroll_dir := trunc ( rdir + 0.5 ) ;
    IF  scroll_dir < 1
    THEN
        scroll_dir := 1;
    (*ENDIF*) 
    scroll_dir := scroll_dir * sign;
&   endif
    END
ELSE
    scroll_dir := 0;
(*ENDIF*) 
i56scrolldir := scroll_dir;
END;
 
(*------------------------------*) 
 
PROCEDURE
      put_rangenumbers (
            sno       : integer;
            VAR lbl   : tsp00_C8;
            first_row : tsp00_Int4 ;
            last_row  : tsp00_Int4);
 
CONST
      dash = '-';
 
VAR
      min_numlen    : integer;
      first, last   : text20;
      fld           : stext;
      screen_length : tin_natural;
      screen_width  : tin_natural;
      field_pos     : tin_ls_position;
      field_type    : tin_ls_fieldtype;
 
BEGIN
IF  first_row <= last_row
THEN
    BEGIN
    fld.len := klen_i56 (lbl, bsp_c1, 8);
    IF  fld.len > 0
    THEN
        BEGIN
        s10mv (8,LINE_MXSP00,
              @lbl,1,
              @fld.txt,1,fld.len);
        fld.len := fld.len + 1;
        fld.txt [  fld.len  ] := bsp_c1;
        min_numlen := 1;
        END
    ELSE
        min_numlen := 3;
    (*ENDIF*) 
    encode_int4_i56 (first_row, min_numlen, first);
    encode_int4_i56 (last_row, min_numlen, last);
    s10mv (20,mxin_screenline,
          @first.txt,1,
          @fld.txt,fld.len+1,first.len);
    fld.len := fld.len + first.len;
    fld.len := fld.len + 1;
    fld.txt [ fld.len ] := dash;
    s10mv (20,mxin_screenline,
          @last.txt,1,
          @fld.txt,fld.len+1,last.len);
    fld.len := fld.len + last.len;
    i51size (cin_ls_header, screen_length, screen_width);
    WITH field_pos DO
        BEGIN
        screen_nr := sno;
        screen_part := cin_ls_header;
        sline := 1;
        scol := screen_width - fld.len + 1;
        END;
    (*ENDWITH*) 
    WITH field_type DO
        BEGIN
        field_att := cin_attr3;
        fieldmode := [ ] ;
        END;
    (*ENDWITH*) 
    i50put4field (fld.txt, fld.len, field_pos, field_type);
    END;
(*ENDIF*) 
END; (* put_rangenumbers *)
 
(*------------------------------*) 
 
FUNCTION
      klen_i56 (
            VAR str : tsp00_C8;
            val     : char;
            cnt     : integer) : integer;
 
VAR
      i      : integer;
      finish : boolean;
 
BEGIN
i := cnt;
finish := false;
WHILE  (i >= 1) AND NOT finish DO
    IF  str  [i]  <> val
    THEN
        BEGIN
        klen_i56 := i;
        finish := true;
        END
    ELSE
        i := i-1;
    (*ENDIF*) 
(*ENDWHILE*) 
IF  NOT finish
THEN
    klen_i56 := 0;
(*ENDIF*) 
END; (* klen_i56 *)
 
(*------------------------------*) 
 
PROCEDURE
      encode_int4_i56 (
            n          : tsp00_Int4;
            min_numlen : integer;
            VAR num    : text20);
 
VAR
      s10   : tsp00_C10;
      n_len : integer;
      i     : integer;
 
BEGIN
num.txt := bsp_c20;
i35intlj_into_str (n, s10, n_len);
IF  n_len < min_numlen
THEN
    BEGIN
    FOR i := 1 TO (min_numlen - n_len) DO
        num.txt  [i]  := '0';
    (*ENDFOR*) 
    FOR i := 1 TO n_len DO
        num.txt [ min_numlen - n_len + i ] := s10  [i] ;
    (*ENDFOR*) 
    num.len := min_numlen;
    END
ELSE
    BEGIN
    FOR i := 1 TO n_len DO
        num.txt  [i]  := s10  [i] ;
    (*ENDFOR*) 
    num.len := n_len;
    END;
(*ENDIF*) 
END; (* encode_int4_i56 *)
 
&ifdef WINDOWS
(*------------------------------*) 
 
PROCEDURE
      header_to_wtitle (
            VAR title : tsp00_OnlineHeader;
            VAR text0 : tsp00_String;
            VAR text1 : tsp00_String);
 
BEGIN
text0.length := 0;
text1.length := 0;
WITH title DO
    BEGIN
    IF  i01g^.ls.nr_screens > 1
    THEN
        BEGIN
        id_and_text_to_wtitle( title, text0 );
        modefield_to_wtitle ( mode_field, text1 );
        END
    ELSE
        id_and_text_to_wtitle( title, text1 );
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* header_to_wtitle *)
 
(*------------------------------*) 
 
PROCEDURE
      id_and_text_to_wtitle(
            VAR title : tsp00_OnlineHeader;
            VAR text  : tsp00_String );
 
VAR
      textfield_len : integer;
      i             : integer;
 
BEGIN
WITH title DO
    BEGIN
    idfield_to_wtitle( id_field, text );
    IF  text_field [1]  = chr(0)
    THEN
        textfield_len := 0
    ELSE
        textfield_len := s30lnr1 (text_field, bsp_c1, 1, mxin_text_field );
    (*ENDIF*) 
    IF  textfield_len > 0
    THEN
        BEGIN
        i56_add_char (text , bsp_c1);
        i56_add_char (text , '-');
        i56_add_char (text , bsp_c1);
        END;
    (*ENDIF*) 
    FOR i := 1 TO textfield_len DO
        i56_add_char (text , text_field  [i] );
    (*ENDFOR*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      idfield_to_wtitle (
            VAR id_field : tsp00_C8;
            VAR text     : tsp00_String);
 
VAR
      i      : integer;
      actlen : integer;
 
BEGIN
actlen := s30klen (id_field, bsp_c1, mxin_id_field);
FOR i := 1 TO actlen DO
    i56_add_char (text, id_field  [i] );
(*ENDFOR*) 
END; (* idfield_to_wtitle *)
 
(*------------------------------*) 
 
PROCEDURE
      modefield_to_wtitle (
            VAR mode_field : tsp00_C12 ;
            VAR text       : tsp00_String );
 
VAR
      len : integer;
      i   : integer;
 
BEGIN
i := mxsp_c12;
len := -1;
WHILE (len < 0) AND (i > 0) DO
    BEGIN
    IF  mode_field [ i ] <> bsp_c1
    THEN
        len := i;
    (*ENDIF*) 
    i := i - 1;
    END;
(*ENDWHILE*) 
IF  len < 0
THEN
    len := 0;
(*ENDIF*) 
FOR i := 1 TO len DO
    i56_add_char (text, mode_field [i] );
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      modefield_to_sysline (
            sno            : tsp00_Int2;
            VAR mode_field : tsp00_C12 );
 
VAR
      ft     : tin_ls_fieldtype ;
      screen : tin_lineaddr;
      att    : tin_lineaddr;
 
BEGIN
&ifdef WINDOWS
IF  ( sno = 2)
THEN
    BEGIN
    screen := s30gad( i56sysline2 );
    att := s30gad( i56sysatt2 );
    END
ELSE
&   endif
    WITH i01g^.i50.hif DO
        BEGIN
        screen := s30gad(sys_text);
        att := s30gad(sys_attr);
        END ;
    (*ENDWITH*) 
(*ENDIF*) 
ft.field_att := cin_ls_normal;
ft.fieldmode := [  ] ;
WITH i01g^.i50.hif DO
    BEGIN
    i53put1field(mode_field,mxsp_c12,sno, 1,2,
          ft, 1,mx_sysline, screen, att );
    END;
(*ENDWITH*) 
END; (* modefield_to_sysline *)
 
(*------------------------------*) 
 
PROCEDURE
      set_dlgbox_texts (
            VAR id_field    : tsp00_C8;
            VAR relno_field : tsp00_C8 );
 
VAR
      ok         : boolean;
      text       : tsp00_String;
      txt        : tin_screenline;
      local_text : tin_screenline;
      local_len  : tin_natural;
      i          : integer;
 
BEGIN
s10mv (8,mxin_screenline,
      @id_field,1,
      @txt,1,mxsp_c8);
sqlwdgstext ( csp_dlg_aboutbox , csp_dlgabout_cname,
      txt, mxsp_c8 , [], ok );
s10mv (8,mxin_screenline,
      @relno_field,1,
      @txt,1,mxsp_c8);
sqlwdgstext ( csp_dlg_aboutbox , csp_dlgabout_relno,
      txt, mxsp_c8 , [], ok );
i52lsmsg (msg_commandline, local_text, local_len);
(* set commandline box texts *)
text.length := 0;
idfield_to_wtitle( id_field, text );
parms.buffer [1]  := chr( text.length );
FOR i := 1 TO text.length DO
    parms.buffer [i+1 ] := text.text [i] ;
(*ENDFOR*) 
i56_add_char (text, bsp_c1);
i56_add_char (text, '-');
i56_add_char (text, bsp_c1);
FOR i := 1 TO local_len DO
    i56_add_char (text, local_text  [i] );
(*ENDFOR*) 
s10mv (LINE_MXSP00,mxin_screenline,
      @text.text,1,
      @txt,1,text.length);
sqlwdgstext ( cin_dlg_standardbox , 0, txt, text.length,
      [], ok );
i52substmsg ( msg_exitdialog , local_text, local_len );
sqlwdgstext ( cin_dlg_exitbox ,cin_dlgexit_textfield,
      local_text, local_len, [], ok );
END; (* set_dlgbox_texts *)
 
&else
(*------------------------------*) 
 
PROCEDURE
      header_to_topline (
            blinking_modefield : boolean;
            VAR title          : tsp00_OnlineHeader;
            sno                : integer);
 
VAR
      abspos        : tin_ls_position;
      text_pos      : tin_ls_position;
      length        : tin_natural;
      header_length : tin_natural;
      header_width  : tin_natural;
      field_type    : tin_ls_fieldtype;
 
BEGIN
i51size (cin_ls_header, header_length, header_width);
WITH field_type DO
    BEGIN
    field_att  := cin_attr3;
    fieldmode  := [  ] ;
    END;
(*ENDWITH*) 
WITH abspos DO
    BEGIN
    screen_part := cin_ls_header;
    sline       := 1;
    scol        := 1;
    screen_nr := sno;
    END;
(*ENDWITH*) 
length := mxin_id_field;
length := s30klen (title.id_field, bsp_c1, mxin_id_field);
i50put1field (title.id_field, length, abspos, field_type);
abspos.scol := abspos.scol + length + 1;
length := s30klen (title.relno_field, bsp_c1, mxin_id_field);
i50put1field (title.relno_field, length, abspos, field_type);
(*               *)
(*  mode_field   *)
(*               *)
WITH abspos DO
    scol := i56modecol (title);
(*ENDWITH*) 
IF  blinking_modefield
THEN
    field_type.field_att := cin_attr4
ELSE
    field_type.field_att := cin_attr3;
(*ENDIF*) 
IF  (title.mode_field  [1]  <> chr (0))
    AND (title.mode_field  [1]  <> bsp_c1)
THEN
    i50put3field (title.mode_field, mxin_mode_field, abspos, field_type);
(*ENDIF*) 
WITH abspos DO
    scol := scol + mxin_mode_field + 1;
(*ENDWITH*) 
(* textfield *)
text_pos := abspos;
IF  title.text_field  [1]  = chr(0)
THEN
    length := 0
ELSE
    length := s30lnr1 (title.text_field, bsp_c1, 1, mxin_text_field);
(*ENDIF*) 
IF  length > 0
THEN
    BEGIN
    clear_textfield (title, sno);
    text_pos.scol := (header_width DIV 2) - (length DIV 2);
    IF  text_pos.scol < abspos.scol
    THEN
        text_pos.scol := abspos.scol;
    (*ENDIF*) 
    field_type.field_att := cin_attr3;
    i50put2field (title.text_field, length, text_pos, field_type);
    END;
(*ENDIF*) 
END; (* header_to_topline *)
 
(*------------------------------*) 
 
PROCEDURE
      clear_textfield (
            VAR title : tsp00_OnlineHeader;
            sno       : integer);
 
VAR
      ft   : tin_ls_fieldtype;
      pos  : tin_ls_position;
      text : tin_text_field;
 
BEGIN
WITH pos DO
    BEGIN
    screen_nr := sno;
    screen_part := cin_ls_header;
    sline       := 1;
    scol := i56modecol (title) + mxin_mode_field + 1;
    END;
(*ENDWITH*) 
ft.field_att := cin_attr1;
ft.fieldmode := [ ] ;
text := bin_text_field;
i50put2field (text, mxin_text_field, pos, ft);
END; (* clear_textfield *)
 
&endif
(*------------------------------*) 
 
PROCEDURE
      i56putlabels (
            fct_cursorpos      : tin_ls_releasemode;
            functionline_label : boolean);
 
VAR
      typ : tin_terminal_type;
 
BEGIN
IF  NOT i01g^.is_batch
THEN
    BEGIN
    i54terminal_type (typ);
    WITH i01g^ DO
        BEGIN
        CASE typ OF
&           ifdef hifmode
            dap4x, win_terminal:
                i52skmenu ( (*i01g^.*)i50.hif);
&           endif
            t_3270:
                i52pflabels (fct_cursorpos, functionline_label);
            OTHERWISE:
            END;
        (*ENDCASE*) 
        (*i01g^.*)
        key_type.highlighted := [ ] ;
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END; (* i56putlabels *)
 
(*------------------------------*) 
 
PROCEDURE
      i56setmark (
            screen_nr     : tsp00_Int2;
            screenpart    : tin_ls_part;
            mode          : tsp00_VtMark;
            top, left     : tsp00_Int2;
            bottom, right : tsp00_Int2 );
&     ifdef NEW
 
VAR
      region : tsp00_VtRectangle ;
      ok     : boolean;
      switchkeys : tsp00_VtKeys;
&     endif
 
BEGIN
IF  i01g^.ls.nr_screens = 1
THEN
    screen_nr := 1;
&ifdef NEW
(*ENDIF*) 
IF  mode = vt_mark_off
THEN
    BEGIN
    region.top := 1;
    region.bottom := 0;
    region.left := 1;
    region.right := 0;
    END
ELSE
    BEGIN
    WITH i01g^.ls.description [screen_nr]  [ screenpart  ] DO
        BEGIN
        IF  top = csp_minint2
        THEN
            region.top := csp_minint2
        ELSE
            region.top := top + first_line - 1;
        (*ENDIF*) 
        IF  bottom = csp_maxint2
        THEN
            region.bottom := csp_maxint2
        ELSE
            region.bottom := bottom + first_line - 1;
        (*ENDIF*) 
        IF  left = csp_minint2
        THEN
            region.left := csp_minint2
        ELSE
            region.left := left + first_col - 1;
        (*ENDIF*) 
        IF  right = csp_maxint2
        THEN
            region.right := csp_maxint2
        ELSE
            region.right := right + first_col - 1;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
WITH i01g^.key_type DO
    i52keysettrans ( active_marked, switchkeys );
(*ENDWITH*) 
WITH i01g^.vt DO
    sqltsetmark ( vt_ref, screen_nr, mode, region, switchkeys, ok );
(*ENDWITH*) 
&else
i01g^.vt.opt.mark := mode;
WITH i01g^.vt.parms DO
    BEGIN
    mark_begin.screen_nr := screen_nr;
    mark_begin.screen_part := screenpart;
    mark_begin.sline := top;
    mark_begin.scol := left;
    mark_end.screen_nr := screen_nr;
    mark_end.screen_part := screenpart;
    mark_end.sline := bottom;
    mark_end.scol := right;
    END;
(*ENDWITH*) 
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      i56getmark (
            screen_nr         : tsp00_Int2;
            screenpart        : tin_ls_part;
            VAR mode          : tsp00_VtMark;
            VAR top, left     : tsp00_Int2;
            VAR bottom, right : tsp00_Int2 );
 
VAR
      region : tsp00_VtRectangle ;
      ok     : boolean ;
 
BEGIN
IF  i01g^.ls.nr_screens = 1
THEN
    screen_nr := 1;
&ifdef NEW
(*ENDIF*) 
WITH i01g^.vt DO
    sqltgetmark ( vt_ref, screen_nr, mode, region, ok );
(*ENDWITH*) 
IF  (region.top <= region.bottom)
    AND (region.left <= region.right)  (* marked *)
THEN
    BEGIN
    WITH i01g^.ls.description [screen_nr]  [ screenpart  ] DO
        BEGIN
        IF  region.top = csp_minint2
        THEN
            top := csp_minint2
        ELSE
            top := region.top - first_line + 1;
        (*ENDIF*) 
        IF  region.bottom = csp_maxint2
        THEN
            bottom := csp_maxint2
        ELSE
            bottom := region.bottom - first_line + 1;
        (*ENDIF*) 
        IF  region.left = csp_minint2
        THEN
            left := csp_minint2
        ELSE
            left := region.left - first_col + 1;
        (*ENDIF*) 
        IF  region.right = csp_maxint2
        THEN
            right := csp_maxint2
        ELSE
            right := region.right - first_col + 1;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    END
ELSE
    BEGIN
    top    := 1;
    bottom := 0;
    left   := 1;
    right  := 0;
    END;
(*ENDIF*) 
&else
mode := i01g^.vt.opt.mark;
WITH i01g^.vt.parms DO
    BEGIN
    top := mark_begin.sline ;
    left := mark_begin.scol ;
    bottom := mark_end.sline ;
    right := mark_end.scol ;
    END;
(*ENDWITH*) 
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      i56_add_char (
            VAR text : tsp00_String;
            c        : char);
 
BEGIN
text.length := text.length + 1;
text.text [ text.length ] := c;
END; (* i56_add_char *)
 
(*------------------------------*) 
 
FUNCTION
      middle_headercol : tin_natural;
 
VAR
      workarea_length : tin_natural;
      screen_width    : tin_natural;
 
BEGIN
i51size (cin_ls_header, workarea_length, screen_width);
middle_headercol := (screen_width + 1) DIV 2;
END; (* middle_headercol *)
 
(*------------------------------*) 
 
FUNCTION
      i56modecol (
            VAR title : tsp00_OnlineHeader) : integer;
 
VAR
      scol   : integer;
      length : integer;
 
BEGIN
(* Manuela 22.10.91, same formula used in VIN10: i10info *)
i56modecol := mxin_id_field + mxin_rel_field + 2;
END; (* i56modecol *)
 
(*------------------------------*) 
 
PROCEDURE
      i56errormessage (
            screen_nr : tsp00_Int2;
            VAR field : tin_screenline;
            length    : tin_natural );
 
BEGIN
length := s30lnr ( field, bsp_c1, 1, length );
&ifdef WINDOWS
win_errorbox( field, length );
&else
errmsg_to_sysline( screen_nr, field, length );
&endif
IF  length > 0
THEN
    i01g^.vt.opt.bell := true;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      errmsg_to_sysline (
            sno       : tsp00_Int2;
            VAR field : tin_screenline;
            length    : tin_natural );
 
VAR
      field_pos  : tin_ls_position;
      field_type : tin_ls_fieldtype ;
      slength    : tin_natural;
      swidth     : tin_natural;
      errline    : tin_screenline;
 
BEGIN
s10mv(mxin_screenline,mxin_screenline,
      @field,1,
      @errline,1,length );
i51size(cin_ls_sysline,slength,swidth);
IF  swidth > length
THEN
    SAPDB_PascalForcedFill (mxin_screenline, @errline, length+1, swidth-length, bsp_c1 );
(*ENDIF*) 
WITH field_pos DO
    BEGIN
    screen_nr := sno;
    screen_part := cin_ls_sysline;
    sline := slength; (* to the very last line *)
    scol := 1;
    END;
(*ENDWITH*) 
WITH field_type DO
    BEGIN
    IF  length > 0
    THEN
        field_att := cin_attr6
    ELSE
        field_att := cin_attr1;
    (*ENDIF*) 
    fieldmode := [  ] ;
    END;
(*ENDWITH*) 
i50put5field ( errline, swidth, field_pos, field_type );
END;
 
&ifdef WINDOWS
(*------------------------------*) 
 
PROCEDURE
      win_errorbox (
            VAR field : tin_screenline;
            length    : tin_natural );
 
VAR
      ok        : boolean;
      trigger   : tsp00_VtKeys;
      ok_button : tsp00_VtKey;
      stack     : tsp00_Int4;
 
BEGIN
stack := i56push;
IF  length > 0
THEN
    BEGIN
    trigger := [  vt_unknown ] ; (* immediate box *)
    ok_button := i52keytrans ( f_clear );
    WITH i01g^.key_type DO
        activated := activated + [  f_clear ] ;
    (*ENDWITH*) 
    IF  insert_boxlist( cin_ls_sysline, csp_dlg_error )
    THEN
        BEGIN
        sqlwdgswitch ( csp_dlg_error, dg_modal, trigger, -1, NIL,
              ok_button, vt_clear, ok);
        sqlwdgstext ( csp_dlg_error, 101, field, length, [], ok );
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
i56pop( stack );
END; (* i56errormessage *)
 
(*------------------------------*) 
 
PROCEDURE
      i56dlgbox (
            box_id          : tsp00_Int2;
            style           : tsp00_DlgBoxStyle;
            screenpart      : tin_ls_part;
            VAR trigger     : tin_ls_key_set;
            immediate       : boolean;
            callback_switch : tsp00_Int2;
            context         : tsp00_BufAddr;
            ok_button       : tin_ls_releasemode;
            cancel_button   : tin_ls_releasemode);
 
VAR
      trg  : tsp00_VtKeys;
      ok_k : tsp00_VtKey;
      c_k  : tsp00_VtKey;
      ok   : boolean ;
 
BEGIN
i52keysettrans ( trigger, trg );
IF  immediate
THEN
    trg := trg + [  vt_unknown ] ;
(*ENDIF*) 
IF  ok_button = f_cmd
THEN
    ok_k := vt_unknown
ELSE
    ok_k := i52keytrans ( ok_button );
(*ENDIF*) 
IF  cancel_button = f_cmd
THEN
    c_k := vt_unknown
ELSE
    c_k := i52keytrans ( cancel_button );
(*ENDIF*) 
IF  insert_boxlist( screenpart, box_id )
THEN
    sqlwdgswitch ( box_id, style, trg, callback_switch, context,
          ok_k, c_k, ok );
(*ENDIF*) 
END; (* i56dlgbox *)
 
(*------------------------------*) 
 
PROCEDURE
      i56standardbox (
            mode      : tsp00_VtUsageMode;
            immediate : boolean ;
            enable    : boolean );
 
CONST
      callback_switch = 0;
      box_id = cin_dlg_standardbox;
 
VAR
      context : tsp00_BufAddr;
      trg     : tsp00_VtKeys;
      ok_k    : tsp00_VtKey;
      c_k     : tsp00_VtKey;
      ok      : boolean ;
 
BEGIN
IF  enable
THEN
    BEGIN
    context := NIL;
    IF  mode = vt_edit
    THEN
        (*  ok_k := vt_next_field *)
        ok_k := vt_do_key
    ELSE
        ok_k := vt_enter;
    (*ENDIF*) 
    IF  immediate
    THEN
        trg := [  vt_unknown, vt_cmd_key ]
    ELSE
        trg := [  vt_cmd_key ] ;
    (*ENDIF*) 
    c_k := vt_clear;
    IF  insert_boxlist( cin_ls_inputarea, box_id )
    THEN
        sqlwdgswitch ( box_id, dg_modeless, trg, callback_switch, context,
              ok_k, c_k, ok );
    (*ENDIF*) 
    END
ELSE
    i56dlgremove( box_id );
(*ENDIF*) 
END; (* i56standardbox *)
 
(*------------------------------*) 
 
PROCEDURE
      i56confirmbox (
            boxid       : tsp00_Int2;
            VAR trigger : tin_ls_key_set;
            VAR text    : tsp00_Line;
            textlen     : tsp00_Int2 );
 
VAR
      ok_k    : tsp00_VtKey;
      c_k     : tsp00_VtKey;
      trg     : tsp00_VtKeys;
      txt     : tin_screenline;
      ok      : boolean ;
      title   : tsp00_Line;
      titlen  : integer;
      sav_act : tsp00_Int2;
 
BEGIN
boxid := free_confirmid;
IF  boxid > 0
THEN
    BEGIN
    i52keysettrans ( trigger, trg );
    ok_k := vt_unknown;
    c_k := vt_clear;
    sav_act := i56actual;
    IF  insert_boxlist( cin_ls_inputarea, boxid)
    THEN
        BEGIN
        sqlwdgswitch ( boxid, dg_modal, trg, 0, NIL,
              ok_k, c_k, ok );
        s10mv (LINE_MXSP00,mxin_screenline,
              @text,1,
              @txt,1,textlen);
        sqlwdgstext ( boxid, 100, txt, textlen, [], ok );
        confirmbox_title( title, titlen);
        s10mv (LINE_MXSP00,mxin_screenline,
              @title,1,
              @txt,1,titlen);
        sqlwdgstext ( boxid, 0, txt, titlen, [], ok );
        END;
    (*ENDIF*) 
    i56actual := sav_act;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      free_confirmid : tsp00_Int2;
 
VAR
      boxid : tsp00_Int2;
      free  : boolean;
 
BEGIN
boxid := cin_dlg_confirm1;
free := false;
WHILE (boxid <= cin_dlg_confirm5) AND (NOT free) DO
    BEGIN
    IF  NOT i56boxswitched ( boxid )
    THEN
        free := true;
    (*ENDIF*) 
    IF  NOT free
    THEN
        boxid := boxid + 1;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  free
THEN
    free_confirmid := boxid
ELSE
    free_confirmid := -1 ;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      confirmbox_title(
            VAR title  : tsp00_Line;
            VAR titlen : integer );
 
VAR
      i : integer;
 
BEGIN
titlen := 0;
FOR i := 1 TO mxsp_c12 DO
    IF  i01g^.i20.comp [i] <> bsp_c1
    THEN
        BEGIN
        titlen := titlen + 1;
        title [ titlen ] := i01g^.i20.comp [i] ;
        END;
    (*ENDIF*) 
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      i56question (
            VAR text : tsp00_Line;
            textlen  : tsp00_Int2 ) : boolean;
 
VAR
      old_activated  : tin_ls_key_set;
      trg            : tsp00_VtKeys;
      ok_k           : tsp00_VtKey;
      c_k            : tsp00_VtKey;
      ok             : boolean ;
      txt            : tin_screenline;
      csr_pos        : tin_ls_position;
      rf             : tin_ls_releasemode;
      screen_changed : boolean;
      boxid          : tsp00_Int2;
      title          : tsp00_Line;
      titlen         : integer;
 
BEGIN
boxid := free_confirmid;
IF  boxid > 0
THEN
    BEGIN
    WITH i01g^.key_type DO
        BEGIN
        old_activated := activated;
        activated := activated + [  f_enter, f_undo ] ;
        END;
    (*ENDWITH*) 
    trg := [  vt_unknown ] ; (* immediate *)
    ok_k := i52keytrans ( f_enter );
    c_k := i52keytrans ( f_undo );
    sqlwdgswitch ( boxid, dg_modal, trg, -1, NIL,
          ok_k, c_k, ok );
    s10mv (LINE_MXSP00,mxin_screenline,
          @text,1,
          @txt,1,textlen);
    sqlwdgstext ( boxid, 100, txt, textlen, [], ok );
    confirmbox_title( title, titlen);
    s10mv (LINE_MXSP00,mxin_screenline,
          @title,1,
          @txt,1,titlen);
    sqlwdgstext ( boxid, 0, txt, titlen, [], ok );
    WITH csr_pos DO
        BEGIN
        screen_part := cin_ls_workarea;
        screen_nr := 1;
        sline := 1;
        scol := 1;
        END;
    (*ENDWITH*) 
    i57ioscreen ( csr_pos, rf, screen_changed );
    i56question := ( rf = f_enter);
    sqlwdgremove ( boxid );
    WITH i01g^.key_type DO
        activated := old_activated;
    (*ENDWITH*) 
    END
ELSE
    i56question := false;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i56infobox (
            VAR text : tsp00_Line;
            textlen  : tsp00_Int2 ;
            wait     : boolean ) ;
 
VAR
      old_activated  : tin_ls_key_set;
      trg            : tsp00_VtKeys;
      ok_k           : tsp00_VtKey;
      c_k            : tsp00_VtKey;
      ok             : boolean ;
      txt            : tin_screenline;
      csr_pos        : tin_ls_position;
      rf             : tin_ls_releasemode;
      screen_changed : boolean;
      boxid          : tsp00_Int2;
      title          : tsp00_Line;
      titlen         : integer;
      style          : tsp00_DlgBoxStyle ;
 
BEGIN
WITH i01g^.key_type DO
    BEGIN
    old_activated := activated;
    activated := activated + [  f_enter, f_undo ] ;
    END;
(*ENDWITH*) 
IF  wait
THEN
    BEGIN
    boxid := csp_dlg_info ;
    style := dg_modal ;
    END
ELSE
    BEGIN
    boxid := cin_dlg_infobox ;
    style := dg_modeless ;
    END ;
(*ENDIF*) 
IF  wait OR ( i56boxstate = boxstate_off)
THEN
    BEGIN
    trg := [  vt_unknown ] ; (* immediate *)
    ok_k := i52keytrans ( f_enter );
    c_k := i52keytrans ( f_undo );
    sqlwdgswitch ( boxid, style, trg, -1, NIL,
          ok_k, c_k, ok );
    IF  ok AND NOT wait
    THEN
        i56boxstate := boxstate_open ;
    (*ENDIF*) 
    IF  ( NOT wait )
    THEN
        BEGIN
        (* if wait, the title will be default *)
        confirmbox_title( title, titlen);
        s10mv (LINE_MXSP00,mxin_screenline,
              @title,1,
              @txt,1,titlen);
        sqlwdgstext ( boxid, 0, txt, titlen, [], ok );
        END ;
    (*ENDIF*) 
    END ;
(*ENDIF*) 
s10mv (LINE_MXSP00,mxin_screenline,
      @text,1,
      @txt,1,textlen);
sqlwdgstext ( boxid, 100, txt, textlen, [], ok );
IF  ok AND ( i56boxstate = boxstate_open )
THEN
    i56boxstate := boxstate_written ;
(*ENDIF*) 
WITH csr_pos DO
    BEGIN
    screen_part := cin_ls_workarea;
    screen_nr := 1;
    sline := 1;
    scol := 1;
    END;
(*ENDWITH*) 
WITH i01g^.vt.opt DO
    wait_for_input := wait;
(*ENDWITH*) 
i57ioscreen ( csr_pos, rf, screen_changed );
IF  wait
THEN
    BEGIN
    sqlwdgremove ( boxid );
    i56boxstate := boxstate_off ;
    END ;
(*ENDIF*) 
WITH i01g^.key_type DO
    activated := old_activated;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i56ckinfobox ;
 
BEGIN
(* will be called by i57ioscreen before screen I/O *)
(* box will be closed before the first I/O from outside i56infobox *)
CASE i56boxstate OF
    boxstate_off:
        ;
    boxstate_open:
        BEGIN
        sqlwdgremove ( cin_dlg_infobox );
        i56boxstate := boxstate_off ;
        END ;
    boxstate_written:
        i56boxstate := boxstate_open ;
    END ;
(*ENDCASE*) 
END ;
 
(*------------------------------*) 
 
PROCEDURE
      i56setfocus(
            boxid       : tsp00_Int2;
            sline, scol : tsp00_Int2);
 
VAR
      item_id : tsp00_Int2;
 
BEGIN
item_id := -boxitem ( sline, scol-1);
sqlwdgsfocus( boxid, item_id );
END;
 
(*------------------------------*) 
 
PROCEDURE
      i56check_box(
            boxid           : tsp00_Int2;
            VAR box_changed : boolean;
            VAR focus_line  : tsp00_Int2;
            VAR focus_col   : tsp00_Int2);
 
VAR
      item_id       : tsp00_Int2;
      text          : tin_screenline;
      text_len      : tsp00_Int2;
      changed       : boolean ;
      ok            : boolean;
      focus_box     : tsp00_Int2;
      focus_control : tsp00_Int2;
 
BEGIN
box_changed := false;
focus_line := 0;
focus_col := 0;
item_id := -boxitem ( 1, 0 );
REPEAT
    sqlwdggtext ( boxid, item_id, text, text_len,
          changed, ok );
    IF  ok
    THEN
        box_changed := box_changed OR changed;
    (*ENDIF*) 
UNTIL
    NOT ok;
(*ENDREPEAT*) 
sqlwdggfocus( focus_box, focus_control );
IF  focus_box = boxid
THEN
    BEGIN
    focus_line := focus_control DIV 100;
    focus_col := focus_control MOD 100;
    END
ELSE
    BEGIN
    focus_line := 0;
    focus_col := 0;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i56clconfirmboxes ;
 
VAR
      i : tsp00_Int2;
 
BEGIN
FOR i := 1 TO maxboxlist DO
    IF  (i56boxlist [i].screenpart <> cin_ls_undef_part)
    THEN
        BEGIN
        IF  (i56boxlist [i].boxid >= cin_dlg_confirm1)
            AND (i56boxlist [i].boxid <= cin_dlg_confirm5)
        THEN
            i56dlgremove(i56boxlist [i].boxid);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i56dlgremove (
            boxid : tsp00_Int2);
 
VAR
      index : integer;
 
BEGIN
sqlwdgremove ( boxid );
FOR index := 1 TO maxboxlist DO
    IF  i56boxlist [ index ] . boxid = boxid
    THEN
        BEGIN
        i56boxlist [ index ].screenpart := cin_ls_undef_part;
        IF  index = i56actual
        THEN
            BEGIN
            IF  i56input_from_box
            THEN
                i56input_from_box := false;
            (*ENDIF*) 
            i56actual := 0;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDFOR*) 
END; (* i56dlgremove *)
 
(*------------------------------*) 
 
PROCEDURE
      i56dlgerase (
            screenpart : tin_ls_part );
 
VAR
      i : integer;
 
BEGIN
IF  (screenpart = cin_ls_basic_window)
    OR (screenpart = cin_ls_whole_screen)
THEN
    BEGIN
    FOR i := 1 TO maxboxlist DO
        IF  i56boxlist [i].screenpart <> cin_ls_undef_part
        THEN
            BEGIN
            IF  (i56boxlist [i].boxid < cin_dlg_confirm1)
                OR (i56boxlist [i].boxid > cin_dlg_confirm5)
            THEN
                sqlwdgerase( i56boxlist [i].boxid, 0 );
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDFOR*) 
    END
ELSE
    BEGIN
    FOR i := 1 TO maxboxlist DO
        IF  i56boxlist [i].screenpart = screenpart
        THEN
            BEGIN
            IF  (i56boxlist [i].boxid < cin_dlg_confirm1)
                OR (i56boxlist [i].boxid > cin_dlg_confirm5)
            THEN
                sqlwdgerase( i56boxlist [i].boxid, 0 );
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDFOR*) 
    END ;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i56exitmessage ;
 
VAR
      ok        : boolean;
      trigger   : tsp00_VtKeys;
      ok_button : tsp00_VtKey;
 
BEGIN
ok_button := i52keytrans ( f_exit );
trigger := [  ok_button ] ;
sqlwdgswitch ( cin_dlg_exitbox, dg_modal, trigger, -1, NIL,
      ok_button, vt_clear, ok);
END; (* i56exitmessage *)
 
(*------------------------------*) 
 
PROCEDURE
      i56clearerrormsg;
 
BEGIN
i56dlgremove ( csp_dlg_error );
END; (* i56clearerrormsg *)
 
(*------------------------------*) 
 
PROCEDURE
      i56todialogbox (
            VAR field      : tsp00_Line;
            length         : tin_natural;
            VAR field_pos  : tin_ls_position;
            VAR field_type : tin_ls_fieldtype);
 
VAR
      ok  : boolean;
      att : tsp00_VtAttrib;
      txt : tin_screenline;
 
BEGIN
CASE field_type.field_att OF
    cin_ls_inverse:
        att := [ vt_inverse ];
    cin_ls_grayed:
        att := [ vt_grayed ];
    cin_ls_invisible:
        att := [ vt_invisible ];
    OTHERWISE
        att := [];
    END;
(*ENDCASE*) 
IF  length > mxin_screenline
THEN
    length := mxin_screenline ;
(*ENDIF*) 
IF  length > LINE_MXSP00
THEN
    length := LINE_MXSP00 ;
(*ENDIF*) 
s10mv (LINE_MXSP00,mxin_screenline,
      @field,1,
      @txt,1,length );
sqlwdgstext ( boxid_from_screenpart( field_pos.screen_part ),
      boxitem(field_pos.sline, field_pos.scol) ,
      txt, length, att, ok );
END; (* i56todialogbox *)
 
(*------------------------------*) 
 
PROCEDURE
      i56plistbox (
            VAR field     : tsp00_Line;
            length        : tin_natural;
            VAR field_pos : tin_ls_position;
            selected      : boolean;
            current       : boolean );
 
VAR
      ok  : boolean;
      att : tsp00_VtAttrib;
      txt : tin_screenline;
 
BEGIN
att := [];
IF  selected
THEN
    att := att + [ vt_inverse ];
(*ENDIF*) 
IF  current
THEN
    att := att + [ vt_bright ];
(*ENDIF*) 
s10mv (LINE_MXSP00,mxin_screenline,
      @field,1,
      @txt,1,length );
sqlwdgstext ( boxid_from_screenpart( field_pos.screen_part ),
      boxitem(field_pos.sline, field_pos.scol) ,
      txt, length, att, ok );
END;
 
(*------------------------------*) 
 
FUNCTION
      boxid_from_screenpart (
            screenpart : tin_ls_part ) : tsp00_Int2;
 
VAR
      i     : integer;
      boxid : integer;
 
BEGIN
boxid := -1;
FOR i := 1 TO maxboxlist DO
    IF  i56boxlist [i].screenpart = screenpart
    THEN
        BEGIN
        IF  (boxid < 0) OR ( i = i56actual)
        THEN
            boxid := i56boxlist [i].boxid;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDFOR*) 
boxid_from_screenpart := boxid;
END;
 
(*------------------------------*) 
 
FUNCTION
      boxitem (
            sline : tsp00_Int2;
            scol  : tsp00_Int2) : tsp00_Int2;
 
BEGIN
boxitem := 100 * sline + scol;
END; (* boxitem *)
 
(*------------------------------*) 
 
PROCEDURE
      i56getwindow (
            first_pos          : tin_ls_position;
            VAR window_changed : boolean);
 
BEGIN
i01g^.i50.curr_sno := first_pos.screen_nr;
i01g^.i50.curr_row := first_pos.sline;
i01g^.i50.curr_col := first_pos.scol - 1;
window_changed := true;
END; (* i56getwindow *)
 
(*------------------------------*) 
 
PROCEDURE
      i56getfield (
            VAR vt_input    : tin_ls_input_field;
            VAR field_found : boolean);
 
VAR
      id       : tsp00_Int2;
      text_len : tsp00_Int2;
 
BEGIN
id := -boxitem ( i01g^.i50.curr_row, i01g^.i50.curr_col );
sqlwdggtext ( i56boxlist [i56actual].boxid,
      id, vt_input.buf, text_len,
      vt_input.changed, field_found);
IF  field_found
THEN
    BEGIN
    IF  (text_len < 0)
    THEN
        BEGIN
        (* This is a select listhandle from a listbox *)
        text_len := text_len - 1;
        vt_input.buf [ -text_len ] := chr(0);
        END;
    (*ENDIF*) 
    vt_input.len := text_len;
    vt_input.left_trunc := 0;
    vt_input.right_trunc := 0;
    WITH vt_input.fld_pos DO
        BEGIN
        screen_part := i56boxlist [ i56actual ] . screenpart;
        sline := (-id) DIV 100;
        scol := (-id) MOD 100;
        i01g^.i50.curr_row := sline;
        i01g^.i50.curr_col := scol;
        screen_nr := 1;
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END; (* i56getfield *)
 
(*------------------------------*) 
 
PROCEDURE
      i56selectitem (
            VAR handle      : tin_screenline;
            VAR item        : tin_screenline;
            VAR item_length : tsp00_Int2;
            VAR ok          : boolean );
 
CONST
      cr = 13;
      lf = 10;
 
TYPE
 
      convert4 = RECORD
            CASE boolean OF
                true:
                    (c4 : tsp00_C4);
                false:
                    (i4 : tsp00_Int4);
                END;
            (*ENDCASE*) 
 
 
VAR
      c     : convert4;
      i     : integer;
      h     : tsp00_Int4;
      count : tsp00_Int2;
 
BEGIN
FOR i := 1 TO 4 DO
    c.c4 [i] := handle [i];
(*ENDFOR*) 
h := c.i4;
ok := (h <> 0);
IF  ok
THEN
    BEGIN
    count := ord(handle [5]) + 1;
    item_length := mxin_screenline;
    sqlwlget ( h, count, 1, item, item_length, ok );
    IF  ok
    THEN
        BEGIN
        WHILE (item_length > 0)
              AND (item [item_length] IN [ chr(cr), chr(lf) ] ) DO
            item_length := item_length - 1;
        (*ENDWHILE*) 
        END
    ELSE
        count := 0;
    (*ENDIF*) 
    handle [5] := chr(count);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i56scrarea (
            VAR first_pos : tin_ls_position;
            scroll_dir    : tsp00_VtScroll;
            lines         : tin_natural;
            cols          : tin_natural);
 
VAR
      rect      : tsp00_VtRectangle;
      ok        : boolean ;
      lno, col  : tin_natural;
      length    : tin_natural;
      width     : tin_natural;
      full_line : boolean;
 
BEGIN
IF  i01g^.ls.nr_screens = 1
THEN
    first_pos.screen_nr := 1;
(*ENDIF*) 
IF  first_pos.scol = 0
THEN
    BEGIN
    full_line := true;
    first_pos.scol := 1;
    END
ELSE
    full_line := false;
(*ENDIF*) 
i52fromscreenpos (first_pos, lno, col);
i51size2 (first_pos.screen_nr, first_pos.screen_part, length, width);
IF  full_line
THEN
    width := width + 1;
(*ENDIF*) 
WITH rect DO
    BEGIN
    top      := lno;
    IF  full_line
    THEN
        left := 1
    ELSE
        left := col;
    (*ENDIF*) 
    IF  (top + lines - 1) <= length
    THEN
        bottom := top + lines - 1
    ELSE
        bottom := length;
    (*ENDIF*) 
    IF  (left + cols - 1) <= width
    THEN
        right  := left + cols - 1
    ELSE
        right := width;
    (*ENDIF*) 
    IF  scroll_dir = vt_horizontal_scroll
    THEN
        i56hcols := right - left + 1
    ELSE
        i56vlines := bottom - top + 1 ;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
sqlwscrarea ( i01g^.vt.vt_ref, first_pos.screen_nr,
      scroll_dir, rect, ok );
END;
 
(*------------------------------*) 
 
FUNCTION
      i56spartswitched (
            screenpart : tin_ls_part ) : boolean;
 
VAR
      i  : integer;
      ok : boolean;
 
BEGIN
i := 0;
ok := false;
REPEAT
    i := i + 1;
    IF  i56boxlist [i].screenpart = screenpart
    THEN
        ok := true;
    (*ENDIF*) 
UNTIL
    ok OR (i >= maxboxlist);
(*ENDREPEAT*) 
i56spartswitched := ok;
END;
 
(*------------------------------*) 
 
FUNCTION
      i56boxswitched (
            boxid : tsp00_Int2 ) : boolean;
 
VAR
      i  : integer;
      ok : boolean;
 
BEGIN
i := 0;
ok := false;
REPEAT
    i := i + 1;
    IF  i56boxlist [i].screenpart <> cin_ls_undef_part
    THEN
        IF  i56boxlist [i].boxid = boxid
        THEN
            ok := true;
        (*ENDIF*) 
    (*ENDIF*) 
UNTIL
    ok OR (i >= maxboxlist);
(*ENDREPEAT*) 
i56boxswitched := ok;
END;
 
(*------------------------------*) 
 
FUNCTION
      i56push : tsp00_Int4;
 
VAR
      t : tin56_stackp;
 
BEGIN
new(t.p);
WITH t.p^ DO
    BEGIN
    input_from_box := i56input_from_box;
    boxlist := i56boxlist;
    actual  := i56actual;
    END;
(*ENDWITH*) 
i56push := t.i;
END;
 
(*------------------------------*) 
 
PROCEDURE
      i56pop (
            adr : tsp00_Int4 );
 
VAR
      t : tin56_stackp;
 
BEGIN
t.i := adr;
WITH t.p^ DO
    BEGIN
    i56input_from_box := input_from_box;
    i56boxlist := boxlist;
    i56actual  := actual;
    END;
(*ENDWITH*) 
dispose( t.p );
END;
 
(*------------------------------*) 
 
PROCEDURE
      i56acttofocus;
 
VAR
      focus_box     : tsp00_Int2;
      focus_control : tsp00_Int2;
      i             : integer;
      index         : integer;
 
BEGIN
sqlwdggfocus( focus_box, focus_control );
index := 0;
IF  focus_box > 0
THEN
    FOR i := 1 TO maxboxlist DO
        IF  i56boxlist [ i ] . screenpart <> cin_ls_undef_part
        THEN
            IF  i56boxlist [ i ] . boxid = focus_box
            THEN
                index := i;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDFOR*) 
(*ENDIF*) 
IF  (index > 0)
THEN
    i56actual := index;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      i56actbox : tsp00_Int2;
 
BEGIN
IF  i56actual > 0
THEN
    i56actbox := i56boxlist [ i56actual ] . boxid
ELSE
    i56actbox := 0;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      i56actscreenpart : tin_ls_part;
 
BEGIN
IF  i56actual > 0
THEN
    i56actscreenpart := i56boxlist [ i56actual ] . screenpart
ELSE
    i56actscreenpart := cin_ls_undef_part;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      insert_boxlist(
            screenpart : tin_ls_part;
            boxid      : tsp00_Int2 ) : boolean;
 
VAR
      i  : integer;
      ok : boolean;
 
BEGIN
i := 1;
REPEAT
    ok := i56boxlist [i].screenpart = cin_ls_undef_part;
    IF  NOT ok
    THEN
        ok := (i56boxlist [i].boxid = boxid)
              AND (i56boxlist [i].screenpart = screenpart);
    (*ENDIF*) 
    IF  NOT ok
    THEN
        i := i + 1;
    (*ENDIF*) 
UNTIL
    ok OR (i > maxboxlist);
(*ENDREPEAT*) 
IF  ok
THEN
    BEGIN
    i56boxlist [i].screenpart := screenpart;
    i56boxlist [i].boxid := boxid;
    i56actual := i;
    END;
(*ENDIF*) 
insert_boxlist := ok;
END;
 
(*------------------------------*) 
 
PROCEDURE
      win_set_hrange (
            screen_nr  : integer;
            VAR hrange : tin_display_range);
 
VAR
      local_range : tin_display_range;
      ok          : boolean;
 
BEGIN
local_range := hrange;
WITH local_range DO
    BEGIN
    IF  displ_begin < total_begin
    THEN
        displ_begin := total_begin;
    (*ENDIF*) 
    IF  displ_end > total_end
    THEN
        displ_end := total_end;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
get_scroll_factor ( local_range, i56hcols, i56hfactor );
WITH local_range DO
    sqlwscbar ( i01g^.vt.vt_ref, screen_nr,
          vt_horizontal_scroll, total_begin,
          total_end, displ_begin, ok);
(*ENDWITH*) 
hrange := local_range;
END;
 
(*------------------------------*) 
 
PROCEDURE
      win_set_vrange (
            screen_nr  : integer;
            VAR vrange : tin_display_range);
 
VAR
      local_range : tin_display_range;
      ok          : boolean;
 
BEGIN
local_range := vrange;
get_scroll_factor ( local_range, i56vlines, i56vfactor );
WITH local_range DO
    sqlwscbar ( i01g^.vt.vt_ref, screen_nr,
          vt_vertical_scroll, total_begin,
          total_end, displ_begin, ok);
(*ENDWITH*) 
vrange := local_range ;
END;
 
(*------------------------------*) 
 
PROCEDURE
      get_scroll_factor (
            VAR rge    : tin_display_range;
            units      : tsp00_Int2;
            VAR factor : real );
 
VAR
      rhelp         : real;
      display_range : tsp00_Int4;
      offset        : tsp00_Int4;
      unknown_end   : boolean;
 
BEGIN
factor := 1.0;
WITH rge DO
    BEGIN
    unknown_end := (total_end = csp_maxint4);
    offset := total_begin;
    total_begin := total_begin - offset;
    total_end := total_end - offset;
    displ_begin := displ_begin - offset;
    displ_end := displ_end - offset;
    (*  IF  displ_begin + units - 1 >= total_end *)
    IF  displ_end >= total_end
    THEN
        display_range := 0
              (* output finished *)
    ELSE
        display_range := displ_end - displ_begin + 1;
    (*ENDIF*) 
    IF  display_range > 0
    THEN
        factor := units / display_range
    ELSE
        factor := 1.0;
    (*ENDIF*) 
    IF  unknown_end
    THEN
        total_end := csp_maxint2
    ELSE
        BEGIN
        rhelp := (total_end + 1) * factor ;
        IF  rhelp >= csp_maxint2
        THEN
            BEGIN
            factor := ( csp_maxint2 - 1) / (total_end + 1);
            total_end := csp_maxint2 - 1;
            END
        ELSE
            total_end := trunc ( rhelp + 0.5 );
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    rhelp := total_begin * factor ;
    total_begin := trunc ( rhelp + 0.5 ) + 1;
    rhelp := displ_begin * factor ;
    displ_begin := trunc ( rhelp + 0.5 ) + 1;
    rhelp := (displ_end + 1) * factor ;
    displ_end := trunc ( rhelp + 0.5 );
    END;
(*ENDWITH*) 
END;
 
&endif
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
