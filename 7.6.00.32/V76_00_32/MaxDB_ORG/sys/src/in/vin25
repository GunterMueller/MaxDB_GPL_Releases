.CM  SCRIPT , Version - 1.1 , last edited by barbara
.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 1998-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VIN25$
.tt 2 $$$
.TT 3 $$Logon$1998-06-19$
***********************************************************
.nf

.nf

.nf

    ========== licence begin  GPL
    Copyright (c) 1998-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo


.fo


.fo
.nf
.sp
MODULE  : Logon
=========
.sp
Purpose : Logon to DDB4 via argument line, XUSER or logon mask
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :

        FUNCTION
              i25connected (
                    VAR options   : tsp4_args_options;
                    VAR ready_msg : tin_screenline) : boolean;

        PROCEDURE
              i25getuser (
                    calling_component : tsp4_component;
                    VAR user_params   : tsp4_xuser_record;
                    VAR errtext       : tsp00_ErrText;
                    VAR ok            : boolean);
&       ifdef WINDOWS

        FUNCTION
              i25callback (
                    rf              : tin_ls_releasemode;
                    context         : tin25_lc_pointer;
                    callback_switch : tsp00_Int2;
                    VAR csr_pos     : tin_ls_position)
                    : tsp00_DgcallbackResult;
&       endif

.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :

        FROM
              global_variable : VIN01;

        VAR
              i01g : tin_global_in_vars;

      ------------------------------

        FROM
              messages : VIN03;

        PROCEDURE
              i03crashmsg (
                    VAR msg : tin_screenline);

      ------------------------------

        FROM
              setparms: VIN07;

        PROCEDURE
              i07nodbset (
                    component  : tsp4_component );

      ------------------------------

        FROM
              SQLDB-command-interface: VIN21;

        PROCEDURE
              i21dbcrash (
                    g_area : tin_global_in_vars );

      ------------------------------

        FROM
              Logonscreen : VIN26;

        PROCEDURE
              i26centered_logon_screen (
                    VAR cl          : tin_comp_label;
                    VAR line_offset : integer;
                    VAR col_offset  : integer);

      ------------------------------

        FROM
              connect_release : VIN27;

        PROCEDURE
              i27connect (
                    calling_component : tsp4_component;
                    installation      : boolean;
                    VAR termcharset   : tsp00_KnlIdentifier;
                    VAR status        : tin_connect_status);

        PROCEDURE
              i27release;

      ------------------------------

        FROM
              Code-Translation: VIN32;

        PROCEDURE
              i32deftranstables(
                    VAR ig : tin_global_in_record);

      ------------------------------

        FROM
              logical_screen : VIN50;

        PROCEDURE
              i50on (
                    VAR ok : boolean);

        PROCEDURE
              i50put1field (
                    VAR field  : tsp00_C14;
                    length     : tin_natural;
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype);

        PROCEDURE
              i50put2field (
                    VAR field  : tsp00_C20;
                    length     : tin_natural;
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype);

        PROCEDURE
              i50put3field (
                    VAR field  : tsp00_DbName;
                    length     : tin_natural;
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype);

        PROCEDURE
              i50put4field (
                    VAR field  : tsp00_NodeId;
                    length     : tin_natural;
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype);

        PROCEDURE
              i50put5field (
                    VAR field  : tsp00_C80;
                    length     : tin_natural;
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype);

        PROCEDURE
              i50clear (
                    part : tin_ls_part);

        PROCEDURE
              i50getfield (
                    VAR vt_input    : tin_ls_input_field;
                    VAR field_found : boolean);

        PROCEDURE
              i50getwindow (
                    first_pos          : tin_ls_position;
                    window_len         : tin_natural;
                    window_width       : tin_natural;
                    VAR window_changed : boolean);

      ------------------------------

        FROM
              logical_screen_layout : VIN51;

        PROCEDURE
              i51layout (
                    functionmenu_length : tin_natural;
                    inputarea_length    : tin_natural;
                    msg_lines           : tin_natural);

      ------------------------------

        FROM
              logical_screen_modules : VIN56 ;

&       ifdef WINDOWS
        PROCEDURE
              i56dlgbox (
                    box_id          : tsp00_Int2;
                    style           : tsp00_DlgBoxStyle;
                    screenpart      : tin_ls_part;
                    VAR trigger     : tin_ls_key_set;
                    immediate       : boolean;
                    callback_switch : tsp00_Int2;
                    context         : tsp00_BufAddr;
                    ok_button       : tin_ls_releasemode;
                    cancel_button   : tin_ls_releasemode);

        PROCEDURE
              i56dlgremove (
                    boxid : tsp00_Int2 );

        PROCEDURE
              i56exitmessage ;
&       endif

        PROCEDURE
              i56errormessage ( screen_nr : tsp00_Int2;
                    VAR field : tin_screenline;
                    length    : tin_natural );

        PROCEDURE
              i56putlabels (
                    fct_cursorpos      : tin_ls_releasemode;
                    functionline_label : boolean);

      ------------------------------

        FROM
              logical_screen_IO : VIN57 ;

        PROCEDURE
              i57ioscreen (
                    VAR csr_pos        : tin_ls_position;
                    VAR rf             : tin_ls_releasemode;
                    VAR screen_changed : boolean);

      ------------------------------

        FROM
              RTE_driver : VEN102;

        PROCEDURE
              sqlarg3 (
                    VAR user_params : tsp4_xuser_record;
                    VAR password    : tsp00_Pw;
                    VAR options     : tsp4_args_options;
                    VAR xusertype   : tsp4_xuserset;
                    VAR errtext     : tsp00_ErrText;
                    VAR ok          : boolean);

        PROCEDURE
              sqlgetuser (
                    VAR xuser_params : tsp4_xuser_record;
                    VAR errtext       : tsp00_ErrText;
                    VAR ok            : boolean);

        PROCEDURE
              sqlresult (
                    result : tsp00_Uint1);

        PROCEDURE
              sqlcharsetname (
                    VAR charsetname : tsp00_KnlIdentifier );

      ------------------------------

        FROM
              Encrypting: VSP02;

        PROCEDURE
              s02applencrypt (
                    pw_clear     : tsp00_Pw;
                    VAR pw_crypt : tsp00_CryptPw);

      ------------------------------

        FROM
              Kernel_move_and_fill : VGG101;

        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;       
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;    
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;    
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
&       ifdef WINDOWS

      ------------------------------

        FROM
              RTE-Extension-30 : VSP30 ;

        FUNCTION
              s30gad (
                    VAR b : tin_comp_label ) : p_comp_label;

        FUNCTION
              s30gad1 (
                    VAR b : tin_screenline ) : p_screenline ;

        FUNCTION
              s30gad2 (
                    VAR context : tin25_logon_context ) : tsp00_BufAddr;
&       endif

      ------------------------------

        FROM
              RTE-Extension-82: VSP82;

        PROCEDURE
              s82uni_fload (VAR encodings_ptr : tsp8_encodings_ptr;
                    VAR encoding_cnt   : tsp00_Int2;
                    read_dblang_flag   : boolean;
                    VAR iso_locale_str : tsp00_KnlIdentifier;
                    VAR codeset        : tsp00_Int2;
                    VAR rc             : tsp8_uni_load_error);

        PROCEDURE
              s82uni_load_error (
                    rc      : tsp8_uni_load_error;
                    VAR msg : tsp00_C40);
&       IFDEF ARG3

      ------------------------------

        FROM
              link_check_msg : VSP99;

        PROCEDURE
              s99arg3 (
                    VAR user_params : tsp4_xuser_record;
                    VAR password    : tsp00_Pw;
                    VAR options     : tsp4_args_options;
                    VAR xusertype   : tsp4_xuserset;
                    VAR errtext     : tsp00_ErrText;
                    VAR ok          : boolean);
&       ENDIF
&       ifdef i25slow

      ------------------------------

        FROM
              Test_Procedures : VMT90;

        PROCEDURE
              m90init;

        PROCEDURE
              m90xtinit (
                    VAR term_ref  : tsp00_Int4;
                    VAR term_desc : tsp00_TerminalDescription );

        PROCEDURE
              m90switch;

        PROCEDURE
              m90sname (
                    layer : tsp00_ToolLayer;
                    nam   : tsp00_Sname);

        PROCEDURE
              m90identifier (
                    layer : tsp00_ToolLayer;
                    ident : tsp00_KnlIdentifier);
&       endif

.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :

        PROCEDURE
              i50put1field;

              tsp00_MoveObj tsp00_C14

        PROCEDURE
              i50put2field;

              tsp00_MoveObj tsp00_C20

        PROCEDURE
              i50put3field;

              tsp00_MoveObj tsp00_DbName

        PROCEDURE
              i50put4field;

              tsp00_MoveObj tsp00_NodeId

        PROCEDURE
              i50put5field;

              tsp00_MoveObj tsp00_C80

        PROCEDURE
              s02applencrypt;

              tsp00_Name tsp00_Pw

        PROCEDURE
              s30gad;

              tsp00_MoveObj tin_comp_label
              tsp00_Addr    p_comp_label

        PROCEDURE
              s30gad1;

              tsp00_MoveObj tin_screenline
              tsp00_Addr    p_screenline

        PROCEDURE
              s30gad2;

              tsp00_MoveObj tin25_logon_contex
              tsp00_Addr    tsp00_BufAddr

        PROCEDURE
              sqlarg3;

              tsp00_Pw      tsp00_Pw
              tsp00_ErrText tsp00_ErrText

        PROCEDURE
              sqlgetuser;
	
              tsp00_ErrText tsp00_ErrText

        PROCEDURE
              sqlresult;

              tsp00_Uint1 tsp00_Uint1

        PROCEDURE
              sqlcharsetname;
	
              tsp00_KnlIdentifier tsp00_KnlIdentifier
	
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : 
.sp
.cp 3
Created : 1985-08-09
.sp
.cp 3
Version : 1998-05-19
.sp
.cp 3
Release :      Date : 1998-06-19
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:

Latest syntax when calling the dialog components:
.sp;.nf
<Component> /(<user parms>)/ /<lock mode>/ /<command>/
.sp
such that <lock mode> ::= LOCK Normal | LOCK Explicit | LOCK Implicit
.sp
i.e. XLOAD ( manuela , ra ) lock explicit run 'x x' prom
.sp;.fo

TYPE
     ti_comp_label   = c20;

i25_CONNECTED :
.sp
The information required for the logon can
.br
a) be read from the argument line.
.br
b) from the file XUSER DDB4
.br
c) from the logon mask
.br
The format for a) is " ( <name> , <password> , <location> )";
all entries are optional.
.sp
This function attempts a logon via the logon mask or with the
available parameters and supplies a BOOLEAN value that indicates
whether the user is logged onto the database system.  If
i25_CONNECTED is TRUE, the program can run.  Otherwise it should
be terminated immediately.
.sp
In addition, the following are returned:
the message line that is to be output when the program is
terminated and the OPTION-record.
.sp
The calling component must supply its name in the form needed by
the logon mask as a parameter (type COMP_LABEL).
In the option record, sql_component must be set!
.sp
If user name, password, and location are known, an implicit logon
is attempted.
.sp
Invalid parameters detected during the implicit logon can be corrected
by means of an explicit logon via the logon mask if no batch call
is involved.
.sp
An implicit logon is not attempted if the information is incomplete.
If the user name is known, it is in the superimposed mask
and the cursor is on the password input field.
.sp 2
The SUPERDBA can change its logon name but (as an additional protective
measure) this name should not appear on any screen of the dialog
components.  Therefore, two names must be maintained:
.hi 15;.sp
USERID:  The name that is to be displayed on all screens
.sp
CONNECT_ID:  The name used in I20_CONNECT and I20_RECONNECT.
.hi 0;.sp
Both names are of the type SQL_USER_NAME and are located in the record
I01_G^.APPL.
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:


IS_IT_BATCH :
.sp
Determines whether a batch command has been specified.  In this case,
screen I/O must not take place.
.sp 2
TRY_TO_LOGON :
.sp
RESULT becomes 0 only if the ti_connect_status is rc_OK.
The ready-msg is empty.
.br;Connect_status rc_dbms_START_required --> RESULT = 1.
The ready-msg is "Start of database machine required".
.br;Connect_status rc_RESTART_required --> RESULT = 2.
The ready-msg is "Restart of database system required".
.br;Connect_status rc_TOO_MANY_USERS --> RESULT = 3.
The ready-msg is "Too many database users active".
.br;Connect_status rc_USER_or_PSWD_ILLEGAL, rc_LOGON_required --> RESULT = 4.
The ready-msg is "Username/password illegal".
.br;Otherwise (this should never be the case) RESULT = ORD(ti_connect_status)
and the ready-msg is "System error, result = ord (status)".
.sp 2
MASK_LOGON :
.sp
The input screen is assigned once only and then repeatedly output
in the MASK_LOGON loop.  After the user inputs have been read in, a
database logon is attempted.  The loop is terminated if the logon
was successful or if the attempt failed three times or if the user
input was acknowledged with an end key.  If
MASK_LOGON is called with RESULT <> 0, MSG must be assigned, since
it is output the first time the mask is superimposed.
.sp 2
INIT_LOGON_SCREEN :
.sp
The logon mask is formed from inividual parts.  It consists of DDB/4
and a line group with the component
name (this part of the mask is created in INIT_HEADER) and three
input/output fields that are defined in the procedures
FIRST_FIELD, SECOND_FIELD and THIRD_FIELD.  The accepted keys are
assigned in SET_KEYS.
.sp 2
DISPLAY_LOGON_SCREEN :
.sp
The first time the procedure is called, the logon screen is output
with CLEAR = TRUE; for all subsequent calls, it is output with
CLEAR = FALSE.  If USERID (from I01_G) contains characters that do
not equal blank, the cursor is placed on the PASSWORD input field;
otherwise it is placed on the USERNAME input field.
.sp 2
TRANSFER_INPUT :
.sp
The inputs are read from the screen and interpreted.
The procedures GET_USER_ID, GET_PASSWORD and GET_DATABASE are used.
.sp 2
TELL_ERROR :
.sp
The message supplied is written to the screen buffer; the procedures
FIRST_FIELD, SECOND_FIELD and THIRD_FIELD are used for the input/output
fields.
.sp3;.oc _/1;Changes subject to WINDOWS
.sp2;statements/procedures marked by
.br;(* B.M. Rel 3.0.1H 3 Mar 1992 *)
.br;have been changed to fit to WINDOWS conventions.
.sp 2;Tme main part of the logon proceeding has been put into
the procedure CALL_LOGON which is replaced by WIN_LOGON in the
WINDOWS case.
.sp;All changes specific to WINOWS have been embraced by
"&ifdef WINDOWS" and "&endif"
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:

.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :


TYPE
&     ifdef WINDOWS
      p_comp_label = ^tin_comp_label;
      p_screenline = ^tin_screenline;
      (* ATTENTION: structure is (illegally) used also in RTE *)
      (* modules (ven21...), type  must remain unchanged *)

      tin25_logon_context = RECORD
            count             : integer;
            from_mask         : boolean;
            calling_component : tsp4_component;
            cl                : p_comp_label;
            line_offset       : integer;
            col_offset        : integer;
            ready_msg         : p_screenline;
            result            : tsp00_Uint1;
      END;

      tin25_lc_pointer = ^tin25_logon_context;
&     endif


(*------------------------------*)

PROCEDURE
      in25_set_comp_label (
            VAR options   : tsp4_args_options;
            VAR cl        : tin_comp_label);

BEGIN
CASE options.opt_component OF
    sp4co_sql_easy :
        cl :=  '      E A S Y       ';
    sp4co_sql_query :
        cl :=  '     Q U E R Y      ';
    sp4co_sql_dialog, sp4co_sql_appl :
        IF  (options.opt_object_owner <> 'DOMAIN            ') OR
            (options.opt_object_name1 <> 'SYSDD             ') OR
            (options.opt_object_name2 <> 'START             ')
        THEN
            cl := '     S Q L P L      '
        ELSE
            cl := '    D O M A I N     ';
        (*ENDIF*)
    sp4co_sql_load :
        cl := '      L O A D       ';
    OTHERWISE
        cl := bsp_c20;
    END;
(*ENDCASE*)
END; (* in25_set_comp_label *)

(*------------------------------*)

PROCEDURE
      is_it_batch (
            VAR options : tsp4_args_options);

BEGIN
IF  (options.opt_component in
    [sp4co_sql_query, sp4co_sql_dialog, sp4co_sql_easy] )
    AND (options.opt_comm_mode in [sp4cm_sql_import, sp4cm_sql_export] )
THEN
    i01g^.is_batch := true
ELSE
    IF  (options.opt_comm_mode = sp4cm_sql_batch) OR
        (options.opt_comm_mode = sp4cm_sql_batch_object)
    THEN
        i01g^.is_batch := true
    ELSE
        i01g^.is_batch := false;
    (*ENDIF*)
(*ENDIF*)
&ifdef oldfkt
writeln ('is_batch  ', i01g^.is_batch);
writeln ('comm_mode ', ord (options.opt_comm_mode));
writeln ('component ', ord (options.opt_component));
&endif
END; (* is_it_batch *)

(*------------------------------*)

PROCEDURE
      mask_logon (
            calling_component : tsp4_component;
            VAR cl            : tin_comp_label;
            VAR line_offset   : integer;
            VAR col_offset    : integer;
            VAR msg           : tin_screenline;
            VAR stop          : boolean;
            VAR result        : tsp00_Uint1);

CONST
      not_connected = 99;

VAR
      dummy      : integer;
      connect_ok : boolean;
      from_mask  : boolean;

BEGIN
i50clear (cin_ls_basic_window);
init_logon_screen (cl, line_offset, col_offset);
IF  result <> 0
THEN
    tell_error (msg, line_offset, col_offset);
(*ENDIF*)
connect_ok := false;
WHILE NOT connect_ok AND NOT stop DO
    BEGIN
    out_logonscreen (line_offset, col_offset, stop);
    IF  NOT stop
    THEN
        BEGIN
        from_mask := true;
        try_mask_logon (calling_component, line_offset, col_offset,
              msg, from_mask, dummy, connect_ok, result);
        END;
    (*ENDIF*)
    END;
(*ENDWHILE*)
IF  NOT (connect_ok OR stop)
THEN
    result := not_connected;
(*ENDIF*)
SAPDB_PascalForcedFill (mxin_screenline, @msg, 1, mxin_screenline, bsp_c1);
END; (* mask_logon *)

(*------------------------------*)

PROCEDURE
      init_logon_screen (
            VAR cl          : tin_comp_label;
            VAR line_offset : integer;
            VAR col_offset  : integer);

BEGIN
i26centered_logon_screen (cl, line_offset, col_offset);
(* Inputlines *)
first_field  ('USERNAME   ==>', line_offset, col_offset);
second_field ('PASSWORD   ==>', line_offset, col_offset);
third_field  ('SERVERDB   ==>', line_offset, col_offset);
fourth_field ('SERVERNODE ==>', line_offset, col_offset);
(* Softkeys *)
set_keys;
END; (* init_logon_screen *)

(*------------------------------*)

PROCEDURE
      first_field (
            fieldname   : tsp00_C14;
            line_offset : integer;
            col_offset  : integer);

VAR
      field_pos      : tin_ls_position;
      outfield_type  : tin_ls_fieldtype;
      infield_type   : tin_ls_fieldtype;
      help           : tsp00_C80;
      i              : integer;

BEGIN
in251_set_ls_fieldtype ( outfield_type, cin_ls_enhanced, [] );
in251_set_ls_position  ( field_pos, cin_ls_basic_window,
      line_offset + cin_logon_un_line, col_offset + cin_logon_nam_col);
i50put1field (fieldname, 14, field_pos, outfield_type);
in251_set_ls_fieldtype ( infield_type, cin_ls_enhanced, [ls_input ] );
in251_set_ls_position  ( field_pos, cin_ls_basic_window,
      line_offset + cin_logon_un_line, col_offset + cin_logon_inp_col );
WITH i01g^, session [dbno] DO
    BEGIN
    FOR i := 1 TO sizeof (user_ident) DO
        help [i] := user_ident [i] ;
    (*ENDFOR*)
    help [sizeof (user_ident) + 1 ] := bsp_c1;
    help [sizeof (user_ident) + 2 ] := bsp_c1;
    i50put5field (help, sizeof (user_ident) + 2,
          field_pos, infield_type);
    END;
(*ENDWITH*)
END; (* first_field *)

(*------------------------------*)

PROCEDURE
      second_field (
            fieldname   : tsp00_C14;
            line_offset : integer;
            col_offset  : integer);

VAR
      local_pw      : tsp00_C20;
      field_pos     : tin_ls_position;
      outfield_type : tin_ls_fieldtype;
      infield_type  : tin_ls_fieldtype;

BEGIN
in251_set_ls_fieldtype ( outfield_type, cin_ls_enhanced, [] );
in251_set_ls_position  ( field_pos, cin_ls_basic_window,
      line_offset + cin_logon_pw_line, col_offset + cin_logon_nam_col );
i50put1field (fieldname, 14, field_pos, outfield_type);
&ifdef WINDOWS
in251_set_ls_fieldtype ( infield_type, cin_ls_normal, [ls_input ] );
(* Dialog Item is PASSWORD *)
(* B.M. 16.08.93 Release 3.1.3 *)
&else
in251_set_ls_fieldtype ( infield_type, cin_ls_invisible, [ls_input ] );
&endif
in251_set_ls_position  ( field_pos, cin_ls_basic_window,
      line_offset + cin_logon_pw_line, col_offset + cin_logon_inp_col );
local_pw := bsp_c20;
i50put2field (local_pw, mxsp_c20, field_pos, infield_type);
END; (* second_field *)

(*------------------------------*)

PROCEDURE
      third_field (
            fieldname   : tsp00_C14;
            line_offset : integer;
            col_offset  : integer);

VAR
      field_pos     : tin_ls_position;
      outfield_type : tin_ls_fieldtype;
      infield_type  : tin_ls_fieldtype;

BEGIN
in251_set_ls_fieldtype ( outfield_type, cin_ls_enhanced, [] );
in251_set_ls_position  ( field_pos, cin_ls_basic_window,
      line_offset + cin_logon_db_line, col_offset + cin_logon_nam_col );
i50put1field (fieldname, 14, field_pos, outfield_type);
in251_set_ls_fieldtype ( infield_type, cin_ls_enhanced, [ls_input ] );
in251_set_ls_position  ( field_pos, cin_ls_basic_window,
      line_offset + cin_logon_db_line, col_offset + cin_logon_inp_col );
WITH i01g^, session [dbno] DO
    i50put3field (serverdb, DBNAME_MXSP00, field_pos, infield_type);
(*ENDWITH*)
END; (* third_field *)

(*------------------------------*)

PROCEDURE
      fourth_field (
            fieldname   : tsp00_C14;
            line_offset : integer;
            col_offset  : integer);

VAR
      field_pos     : tin_ls_position;
      outfield_type : tin_ls_fieldtype;
      infield_type  : tin_ls_fieldtype;

BEGIN
in251_set_ls_fieldtype ( outfield_type, cin_ls_enhanced, [] );
in251_set_ls_position  ( field_pos, cin_ls_basic_window,
      line_offset + cin_logon_locline, col_offset + cin_logon_nam_col);
i50put1field (fieldname, 14, field_pos, outfield_type);
in251_set_ls_fieldtype ( infield_type, cin_ls_enhanced, [ls_input ] );
in251_set_ls_position  ( field_pos, cin_ls_basic_window,
      line_offset + cin_logon_locline, col_offset + cin_logon_inp_col );
WITH i01g^, session [dbno] DO
    i50put4field (nodeid, sizeof (nodeid), field_pos, infield_type);
(*ENDWITH*)
END; (* fourth_field *)

(*------------------------------*)

PROCEDURE
      set_keys;

CONST
      blank_sk_label = '        ';

VAR
      f : f1 .. f_down;

BEGIN
WITH i01g^.key_type DO
    BEGIN
    FOR f := f1 TO f_down DO
        key_labels [f  ] := blank_sk_label;
    (*ENDFOR*)
    key_labels [f9  ] := 'END     ';
    activated := [f9, f_enter, f_end, f_exit] ;
    i50clear (cin_ls_functionmenu);
    i56putlabels (f_clear, false);
    END;
(*ENDWITH*)
END; (* set_keys *)

(*------------------------------*)

PROCEDURE
      out_logonscreen (
            line_offset : integer;
            col_offset  : integer;
            VAR stop    : boolean);

VAR
      rf             : tin_ls_releasemode;
      csr_pos        : tin_ls_position;
      screen_changed : boolean;

BEGIN
in251_set_ls_position  ( csr_pos, cin_ls_basic_window,
      line_offset + cin_logon_un_line, col_offset + cin_logon_inp_col);
WITH i01g^.vt.opt DO
    BEGIN
    wait_for_input := true;
    usage_mode      := vt_form;
    return_on_last  := false;
    return_on_first := false;
    returnkeys      := [] ;
    reject_keys     := [] ;
    bell := false;
    END;
(*ENDWITH*)
i57ioscreen (csr_pos, rf, screen_changed);
IF  rf IN [f9, f_end, f_exit ]
THEN
    stop := true;
(*ENDIF*)
END; (* out_logonscreen *)

(*------------------------------*)

PROCEDURE
      try_mask_logon (
            calling_component : tsp4_component;
            line_offset       : integer;
            col_offset        : integer;
            VAR msg           : tin_screenline;
            VAR from_mask     : boolean;
            VAR attempt       : integer;
            VAR connect_ok    : boolean;
            VAR result        : tsp00_Uint1);

VAR
      get_ok : boolean;

BEGIN
IF  from_mask
THEN
    transfer_input (get_ok)
ELSE
    get_ok := true;
(*ENDIF*)
from_mask := true; (* for the next time *)
IF  get_ok
THEN
    BEGIN
    try_to_logon (calling_component, msg, result);
    connect_ok := (result = 0);
    attempt := attempt - 1;
    END;
(*ENDIF*)
IF  get_ok AND NOT connect_ok
THEN
    tell_error (msg, line_offset, col_offset);
(*ENDIF*)
END; (* try_mask_logon *)

(*------------------------------*)

PROCEDURE
      transfer_input (
            VAR get_ok : boolean);

VAR
      in_buf         : tin_ls_input_field;
      field_found    : boolean;
      first_pos      : tin_ls_position;
      window_changed : boolean;

BEGIN
in251_set_ls_position  ( first_pos, cin_ls_basic_window, 1, 1 );
i50getwindow (first_pos, 999, 999, window_changed);
get_ok := true;
i50getfield (in_buf, field_found);
IF  field_found
THEN
    get_userid (in_buf);
(*ENDIF*)
i50getfield (in_buf, field_found);
IF  field_found
THEN
    get_password (in_buf);
(*ENDIF*)
i50getfield (in_buf, field_found);
IF  field_found
THEN
    get_database (in_buf);
(*ENDIF*)
i50getfield (in_buf, field_found);
IF  field_found
THEN
    get_nodeid (in_buf);
(*ENDIF*)
END; (* transfer_input *)

(*------------------------------*)

PROCEDURE
      get_userid (
            VAR in_buf : tin_ls_input_field);

VAR
      i : integer;

BEGIN
WITH in_buf DO
    BEGIN
    WITH i01g^, session [dbno] DO
        BEGIN
        user_ident := bsp_c64;
        IF  len > sizeof(tsp00_KnlIdentifier)
        THEN
            len := sizeof(tsp00_KnlIdentifier);
        (*ENDIF*)
        IF  (buf [1]  = '"') OR (buf [1]  = '''')
        THEN
            BEGIN
            FOR i := 1 TO len - 2 DO
                user_ident [i] := buf [i + 1] ;
            (*ENDFOR*)
            END
        ELSE
            BEGIN
            FOR i := 1 TO len DO
                user_ident [i] := in25_to_upper (buf [i]) ;
            (*ENDFOR*)
            END;
        (*ENDIF*)
        END;
    (*ENDWITH*)
    END;
(*ENDWITH*)
END; (* get_userid *)

(*------------------------------*)

PROCEDURE
      get_password (
            VAR in_buf : tin_ls_input_field);

VAR
      i          : integer;
      local_name : tsp00_Pw;

BEGIN
WITH in_buf DO
    BEGIN
    WITH i01g^, session [dbno] DO
        BEGIN
        IF  (buf [1]  = '"') OR (buf [1]  = '''')
        THEN
            BEGIN
            FOR i := 1 TO len - 2 DO
                local_name [i]  := buf [i + 1] ;
            (*ENDFOR*)
            FOR i := len - 1 TO PW_MXSP00 DO
                local_name [i]  := bsp_c1;
            (*ENDFOR*)
            END
        ELSE
            BEGIN
            IF  len > PW_MXSP00
            THEN
                len := PW_MXSP00;
            (*ENDIF*)
            FOR i := 1 TO len DO
                local_name [i] := in25_to_upper (buf [i]) ;
            (*ENDFOR*)
            FOR i := len + 1 TO PW_MXSP00 DO
                local_name [i]  := bsp_c1;
            (*ENDFOR*)
            END;
        (*ENDIF*)
        IF  local_name = bsp_c18
        THEN
            FOR i := 1 TO CRYPTPW_MXSP00 DO
                password [i ]  := chr (0)
            (*ENDFOR*)
        ELSE
            BEGIN
            s02applencrypt (local_name, password);
            local_name := bsp_c18;
            END;
        (*ENDIF*)
        END;
    (*ENDWITH*)
    END;
(*ENDWITH*)
END; (* get_password *)

(*------------------------------*)

PROCEDURE
      get_database (
            VAR in_buf : tin_ls_input_field);

VAR
      i : integer;

BEGIN
WITH in_buf DO
    BEGIN
    WITH i01g^, session [dbno] DO
        BEGIN
        FOR i := 1 TO len DO
            serverdb [i] := buf [i] ;
        (*ENDFOR*)
        FOR i := len + 1 TO DBNAME_MXSP00 DO
            serverdb [i] := bsp_c1;
        (*ENDFOR*)
        END;
    (*ENDWITH*)
    END;
(*ENDWITH*)
END; (* get_database *)

(*------------------------------*)

PROCEDURE
      get_nodeid (
            VAR in_buf : tin_ls_input_field);

VAR
      i : integer;

BEGIN
WITH in_buf DO
    BEGIN
    WITH i01g^, session [dbno] DO
        BEGIN
        FOR i := 1 TO len DO
            nodeid [i]  := buf [i] ;
        (*ENDFOR*)
        FOR i := len + 1 TO NODEID_MXSP00 DO
            nodeid [i]  := bsp_c1;
        (*ENDFOR*)
        END;
    (*ENDWITH*)
    END;
(*ENDWITH*)
END; (* get_nodeid *)

(*------------------------------*)

PROCEDURE
      try_to_logon (
            calling_component : tsp4_component;
            VAR msg           : tin_screenline;
            VAR result        : tsp00_Uint1);

VAR
      status       : tin_connect_status;
      charsetname  : tsp00_KnlIdentifier;

BEGIN
result := 100;
WITH i01g^, session [dbno] DO
    BEGIN
    connect_id      := user_ident;
    symbolic_dbname := serverdb;
    connect_status  := rc_ok;
&   ifdef i25slow
    m90sname (vin, 'dblang      ');
    m90identifier (vin, multibyte.dblang);
&   endif
    END;
(*ENDWITH*)
charsetname := bsp_knl_identifier;
sqlcharsetname ( charsetname );
i27connect (calling_component, false, charsetname, status);
CASE status OF
    rc_ok :
        result := 0;
    rc_dbms_start_required :
        result := 1;
    rc_restart_required :
        result := 2;
    rc_too_many_users, rc_timeout, rc_crash :
        result := 3;
    rc_user_or_pswd_illegal, rc_logon_required :
        result := 4;
    OTHERWISE:
        result := ord (status);
    END;
(*ENDCASE*)
i03crashmsg (msg);
END; (* try_to_logon *)

(*------------------------------*)

PROCEDURE
      tell_error (
            VAR msg     : tin_screenline;
            line_offset : integer;
            col_offset  : integer);

VAR
      dummy      : tin_ls_releasemode;

BEGIN
first_field  ('USERNAME   ==>', line_offset, col_offset);
second_field ('PASSWORD   ==>', line_offset, col_offset);
third_field  ('SERVERDB   ==>', line_offset, col_offset);
fourth_field ('SERVERNODE ==>', line_offset, col_offset);
i56errormessage ( 1, msg, mxin_screenline );
&ifdef WINDOWS
dummy := screen_io (true, line_offset, col_offset);
i01g^.vt.ok := true;
&endif
END; (* tell_error *)

(*------------------------------*)

FUNCTION
      in25_to_upper (
            c : char) : char;

BEGIN
IF  c in ['a'..'i', 'j'..'r', 's'..'z' ]
THEN
    in25_to_upper := chr (ord (c) + ord ('A') - ord ('a'))
ELSE
    in25_to_upper := c;
(*ENDIF*)
END; (* in25_to_upper *)

(*------------------------------*)

FUNCTION
      pw_specified : boolean;

VAR
      not_null : boolean;
      i        : integer;

BEGIN
i := 1;
REPEAT
    not_null := i01g^.session [i01g^.dbno].password [i] <> chr (0);
    i := i + 1;
UNTIL
    not_null OR (i > CRYPTPW_MXSP00);
(*ENDREPEAT*)
pw_specified := not_null;
END; (* pw_specified *)

(*------------------------------*)

PROCEDURE
      call_logon (
            calling_component : tsp4_component;
            logon_set         : tsp4_xuserset;
            VAR cl            : tin_comp_label;
            VAR ready_msg     : tin_screenline;
            VAR stop          : boolean;
            VAR result        : tsp00_Uint1);

VAR
      all_specified : boolean;
      line_offset   : integer;
      col_offset    : integer;

BEGIN
WITH i01g^, session [dbno] DO
    all_specified :=
          (user_ident <> bsp_c64) AND
          pw_specified AND
          (serverdb <> bsp_dbname);
(*ENDWITH*)
IF  NOT (sp4xu_sql_usermask in logon_set) AND all_specified
THEN
    BEGIN
    try_to_logon (calling_component, ready_msg, result);
    IF  (result <> 0) AND NOT i01g^.is_batch
    THEN
        mask_logon (calling_component, cl, line_offset, col_offset,
              ready_msg, stop, result);
    (*ENDIF*)
    END
ELSE
    BEGIN
    IF  NOT i01g^.is_batch
    THEN
        mask_logon (calling_component, cl, line_offset, col_offset,
              ready_msg, stop, result)
    ELSE
        try_to_logon (calling_component, ready_msg, result);
    (*ENDIF*)
    (* get error message *)
    END;
(*ENDIF*)
END; (* call_logon *)

(*------------------------------*)

PROCEDURE
      in25_get_appl (
            calling_component : tsp4_component;
            VAR user_params   : tsp4_xuser_record;
            VAR errtext       : tsp00_ErrText;
            VAR error         : boolean);

CONST
      c_no_read_dblang     = false;
      const_load_isolev    = 3;
      const_easy_isolev    = 1;
      const_query_isolev   = 0;
      mode_adabas          = 'ADABAS  ';
      mode_ansi            = 'ANSI    ';
      mode_db2             = 'DB2     ';
      mode_oracle          = 'ORACLE  ';
      mode_sap_r3          = 'SAPR3   ';

VAR
      i       : integer;
      uni_err : tsp8_uni_load_error;

BEGIN
WITH i01g^, session [dbno], user_params DO
    BEGIN
    user_ident     := xu_user;
    password       := xu_password;
    nodeid         := xu_servernode;
    serverdb       := xu_serverdb;
    CASE calling_component OF
        sp4co_sql_load :
            isolationlevel := const_load_isolev;
        sp4co_sql_easy :
            isolationlevel := const_easy_isolev;
        sp4co_sql_query :
            IF  (xu_isolation >= 0) AND (xu_isolation <= 3)
            THEN
                isolationlevel := xu_isolation
            ELSE
                isolationlevel := const_query_isolev;
            (*ENDIF*)
        sp4co_sql_dialog, sp4co_sql_appl :
            IF  (xu_isolation >= 0) AND (xu_isolation <= 3)
            THEN
                isolationlevel := xu_isolation
            ELSE
                isolationlevel := 1;
            (*ENDIF*)
        OTHERWISE
            IF  xu_isolation >= 0
            THEN
                isolationlevel := xu_isolation
            ELSE
                isolationlevel := 1;
            (*ENDIF*)
        END;
    (*ENDCASE*)
    timeout    := xu_timeout;
    cachelimit := xu_cachelimit;
    FOR i := 1 TO mxsp_c8 DO
        xu_sqlmode [i] := in25_to_upper (xu_sqlmode [i]) ;
    (*ENDFOR*)
    IF  xu_sqlmode = mode_adabas
    THEN
        BEGIN
        sql_mode := sp1sm_internal;
        sqlmode  := sqlm_internal;
        END
    ELSE
        IF  xu_sqlmode = mode_ansi
        THEN
            BEGIN
            sql_mode := sp1sm_ansi;
            sqlmode  := sqlm_ansi;
            END
        ELSE
            IF  xu_sqlmode = mode_db2
            THEN
                BEGIN
                sql_mode := sp1sm_db2;
                sqlmode  := sqlm_db2;
                END
            ELSE
                IF  (xu_sqlmode = mode_oracle)
                    OR (xu_sqlmode = mode_sap_r3)
                THEN
                    BEGIN
                    sql_mode := sp1sm_oracle;
                    sqlmode  := sqlm_oracle;
                    END
                ELSE
                    BEGIN
                    sql_mode := sp1sm_internal;
                    sqlmode  := sqlm_internal;
                    END;
                (*ENDIF*)
            (*ENDIF*)
        (*ENDIF*)
    (*ENDIF*)
    WITH multibyte DO
        BEGIN
        dblang        := xu_dblang;
        dblang_idx    := 0;
        encodings_ptr := NIL;
        encoding_cnt  := 0;
        IF  dblang <> bsp_c64
        THEN
            BEGIN
            s82uni_fload (encodings_ptr, encoding_cnt, c_no_read_dblang,
                  dblang, dblang_idx, uni_err);
            IF  uni_err <> uni_load_ok
            THEN
                BEGIN
                s82uni_load_error (uni_err, errtext);
                error := true;
                END;
            (*ENDIF*)
            END;
        (*ENDIF*)
        END;
    (*ENDWITH*)
    END;
(*ENDWITH*)
END; (* in25_get_appl *)

(*------------------------------*)

PROCEDURE
      i25getuser (
            calling_component : tsp4_component;
            VAR user_params   : tsp4_xuser_record;
            VAR errtext       : tsp00_ErrText;
            VAR ok            : boolean);

VAR
      error : boolean;

BEGIN
sqlgetuser (user_params, errtext, ok);
IF  ok
THEN
    BEGIN
    error := false;
    in25_get_appl (calling_component, user_params, errtext, error);
    IF  error
    THEN
        ok := false;
    (*ENDIF*)
    END;
(*ENDIF*)
END; (* i25getuser *)

(*------------------------------*)

FUNCTION
      in251_is_coldpl (
            VAR options : tsp4_args_options) : boolean;

BEGIN
WITH options DO
    in251_is_coldpl :=
          (opt_component in [sp4co_sql_dialog, sp4co_sql_appl])
          AND (opt_comm_mode in [sp4cm_sql_run, sp4cm_sql_batch]);
(*ENDWITH*)
END; (* in251_is_coldpl *)

(*------------------------------*)

PROCEDURE
      in25_termcheck (
            VAR ready_msg   : tin_screenline;
            VAR term_ok     : boolean);

CONST
      functionmenu_length = 1;
      inputarea_length    = 0;
      message_lines       = 1;
      (* *)
      terminal_notok      =
            'The terminal screen is not accessible             ';
      no_keys_defined     =
            'No function keys defined, command canceled        ';
      window_too_large    =
            'The window size is too large                      ';

VAR
      s50         : tsp00_C50;

BEGIN
i50on (term_ok);
IF  NOT i01g^.is_batch
THEN
    BEGIN
    IF  NOT term_ok
    THEN
        BEGIN
        s50  := terminal_notok;
        SAPDB_PascalForcedFill ( mxin_screenline, @ready_msg, 1, mxin_screenline, ' ');
        s10mv (mxsp_c50,mxin_screenline,
@s50,1,
@ready_msg,1,mxsp_c50 );
        END
    ELSE
&       ifndef WINDOWS
        IF  NOT ( [vt_pf01..vt_pf12, vt_enter] <= i01g^.vt.desc.returnkeys)
        THEN (* H.B. 20.04.93 *)
            BEGIN
            term_ok := false;
            s50  := no_keys_defined;
            SAPDB_PascalForcedFill ( mxin_screenline, @ready_msg, 1, mxin_screenline, ' ');
            s10mv (mxsp_c50,mxin_screenline,
@s50,1,
@ready_msg,1,mxsp_c50 );
            END
        ELSE
&           endif
            IF  (i01g^.vt.desc.num_of_cols > mxin_screenline + 1) OR
                (i01g^.vt.desc.num_of_lines > mxin_screenline + 1)
            THEN (* hb. 22.04.93 *)
                BEGIN
                term_ok := false;
                s50  := window_too_large;
                SAPDB_PascalForcedFill ( mxin_screenline, @ready_msg, 1, mxin_screenline, ' ');
                s10mv (mxsp_c50,mxin_screenline,
@s50,1,
@ready_msg,1,mxsp_c50 );
                END
            ELSE
                BEGIN
                i51layout (functionmenu_length,
                      inputarea_length, message_lines);
                i01g^.ls.description [1] [cin_ls_sysline] .first_col :=
                      cin_logon_nam_col;
                END
            (*ENDIF*)
        (*ENDIF*)
    (*ENDIF*)
    END;
&ifdef i25slow
(*ENDIF*)
IF  NOT i01g^.is_batch AND i01g^.vt.ok
THEN
    m90xtinit (i01g^.vt.vt_ref, i01g^.vt.desc)
ELSE
    m90init;
(*ENDIF*)
m90switch;
&endif
END; (* in25_termcheck *)

(*------------------------------*)

FUNCTION
      i25connected (
            VAR options   : tsp4_args_options;
            VAR ready_msg : tin_screenline) : boolean;

CONST
      c_no_unicode_component = 'no UNICODE component                    ';

VAR
      error       : boolean;
      stop        : boolean;
      term_ok     : boolean;
      ok          : boolean;
      result      : tsp00_Uint1;
      help_pass   : tsp00_Pw;
      logon_set   : tsp4_xuserset;
      user_params : tsp4_xuser_record;
      errtext     : tsp00_ErrText;
      cl          : tin_comp_label;

BEGIN
result := 0;
stop := false;
error := false;
term_ok := true;
help_pass := bsp_c18;
sqlarg3 (user_params, help_pass, options, logon_set, errtext, ok);
&IFDEF ARG3
s99arg3 (user_params, help_pass, options, logon_set, errtext, ok);
&ENDIF
IF  ok
THEN
    BEGIN
    in25_get_appl (options.opt_component, user_params, errtext, error);
    WITH i01g^, session [dbno] DO
        BEGIN
        IF  NOT error AND (help_pass <> bsp_c18)
        THEN
            s02applencrypt (help_pass, password);
        (*ENDIF*)
        IF  options.opt_component = sp4co_sql_load
        THEN
            as_utility := options.opt_utility_session;
        (*ENDIF*)
        END;
    (*ENDWITH*)
    END
ELSE
    error := true;
(*ENDIF*)
IF  error
THEN
    BEGIN
    SAPDB_PascalForcedFill (mxin_screenline, @ready_msg, 1, mxin_screenline, bsp_c1);
    s10mv (ERRTEXT_MXSP00,mxin_screenline,
@errtext,1,
@ready_msg,1,ERRTEXT_MXSP00);
    IF  options.opt_component = sp4co_sql_query
    THEN
        sqlresult (10)
    ELSE
        sqlresult (5);
    (*ENDIF*)
    END
ELSE
    IF  options.opt_comm_mode = sp4cm_sql_comp_vers
    THEN
        BEGIN
        stop := true;
        i01g^.is_batch := true;
        END
    ELSE
        BEGIN
        is_it_batch (options);
        in25_termcheck (ready_msg, term_ok);
        IF  term_ok OR i01g^.is_batch
        THEN
            IF  in251_is_coldpl ( options )
            THEN
                BEGIN
                i07nodbset(options.opt_component);
                i32deftranstables (i01g^);
                i21dbcrash (i01g);
                END
            ELSE
                BEGIN
                in25_set_comp_label (options, cl);
&               ifdef WINDOWS
                IF  NOT i01g^.is_batch
                THEN
                    win_logon (options.opt_component, logon_set, cl,
                          ready_msg, stop, result)
                ELSE
&                   endif
                    call_logon (options.opt_component, logon_set, cl,
                          ready_msg, stop, result);
                (*ENDIF*)
                IF  result <> 0
                THEN
                    sqlresult (result);
                (*ENDIF*)
                WITH i01g^, session [dbno] DO
                    symbolic_dbname := serverdb;
                (*ENDWITH*)
                END
            (*ENDIF*)
        ELSE
            error := true;
        (*ENDIF*)
        END;
    (*ENDIF*)
(*ENDIF*)
IF  (result = 0) AND NOT stop AND NOT error
THEN
    IF  (options.opt_component in
        [sp4co_sql_easy, sp4co_sql_dialog, sp4co_sql_appl])
        AND NOT in251_is_coldpl ( options )
        AND i01g^.session[i01g^.dbno].is_unicode_db
    THEN
        BEGIN
        i27release;
        errtext := c_no_unicode_component;
        error    := true;
        SAPDB_PascalForcedFill (mxin_screenline, @ready_msg, 1, mxin_screenline, bsp_c1);
        s10mv (ERRTEXT_MXSP00,mxin_screenline,
@errtext,1,
@ready_msg,1,ERRTEXT_MXSP00);
        sqlresult (5);
        END;
    (*ENDIF*)
(*ENDIF*)
i25connected := (result = 0) AND NOT stop AND NOT error;
END; (* i25connected *)

&ifdef WINDOWS
(*------------------------------*)

PROCEDURE
      win_logon (
            calling_component : tsp4_component;
            logon_set         : tsp4_xuserset;
            VAR cl            : tin_comp_label;
            VAR ready_msg     : tin_screenline;
            VAR stop          : boolean;
            VAR result        : tsp00_Uint1);

VAR
      context       : tin25_logon_context;
      wait          : boolean;
      rf            : tin_ls_releasemode;
      all_specified : boolean;

BEGIN
WITH i01g^, session [dbno] DO
    all_specified :=
          (user_ident <> bsp_username) AND
          pw_specified AND
          (serverdb <> bsp_dbname);
(*ENDWITH*)
i50clear (cin_ls_basic_window);
context.calling_component := calling_component;
context.result := result;
context.cl := s30gad (cl);
context.ready_msg := s30gad1 (ready_msg);
IF  (sp4xu_sql_usermask in logon_set) OR (NOT all_specified)
THEN
    BEGIN
    IF  NOT i01g^.is_batch
    THEN
        wait := true
    ELSE
        wait := false;
    (*ENDIF*)
    END
ELSE
    wait := false;
(*ENDIF*)
IF  i01g^.is_batch
THEN
    context.count := 1
ELSE
    context.count := 3;
(*ENDIF*)
rf := call_logonbox (context, wait);
stop := (rf IN [f9, f_end, f_exit ] );
i56dlgremove (cin_dlg_logon);
i56exitmessage;
result := context.result;
IF  wait
THEN
    SAPDB_PascalForcedFill (mxin_screenline, @ready_msg, 1, mxin_screenline, bsp_c1);
(*ENDIF*)
END; (* win_logon *)

(*------------------------------*)

FUNCTION
      call_logonbox (
            VAR context : tin25_logon_context ;
            wait        : boolean) : tin_ls_releasemode;

VAR
      trigger     : tin_ls_key_set;

BEGIN
trigger := [] ;
i56dlgbox (cin_dlg_logon, dg_modal, cin_ls_basic_window, trigger, true,
      cin_switch_logon, s30gad2(context), f_enter, f_exit);
init_logon_screen (context.cl^, context.line_offset,
      context.col_offset);
context.from_mask := wait;
call_logonbox := screen_io (wait, context.line_offset,
      context.col_offset);
END; (* call_logonbox *)

(*------------------------------*)

FUNCTION
      screen_io (
            wait        : boolean;
            line_offset : integer;
            col_offset  : integer) : tin_ls_releasemode;

VAR
      dummy_pos      : tin_ls_position;
      rf             : tin_ls_releasemode;
      screen_changed : boolean;

BEGIN
WITH i01g^.vt.opt DO
    wait_for_input := wait;
(*ENDWITH*)
in251_set_ls_position  ( dummy_pos, cin_ls_basic_window,
      line_offset + cin_logon_un_line, col_offset + cin_logon_nam_col);
i57ioscreen (dummy_pos, rf, screen_changed);
IF  wait
THEN
    screen_io := rf
ELSE
    screen_io := f_enter;
(*ENDIF*)
END; (* screen_io *)

(*------------------------------*)

FUNCTION
      i25callback (
            rf              : tin_ls_releasemode;
            context         : tin25_lc_pointer;
            callback_switch : tsp00_Int2;
            VAR csr_pos     : tin_ls_position) : tsp00_DgcallbackResult;

VAR
      connect_ok  : boolean;

BEGIN
WITH context^ DO
    try_mask_logon (calling_component, line_offset, col_offset,
          ready_msg^, from_mask, count, connect_ok, result);
(*ENDWITH*)
IF  connect_ok
THEN
    i25callback := dg_ok
ELSE
    IF  context^.count <= 0
    THEN
        i25callback := dg_cancel
    ELSE
        i25callback := dg_again;
    (*ENDIF*)
(*ENDIF*)
END; (* i25callback *)

&endif
(*------------------------------*)

PROCEDURE
      in251_set_ls_position (
            VAR pos : tin_ls_position;
            scr_part : tin_ls_part;
            line       : tin_natural;
            col        : tin_natural );

BEGIN
WITH  pos  DO
    BEGIN
    screen_nr   := 1;
    screen_part := scr_part;
    scol        := col;
    sline       := line;
    END;
(*ENDWITH*)
END;

(*------------------------------*)

PROCEDURE
      in251_set_ls_fieldtype (
            VAR fieldtype : tin_ls_fieldtype;
            fattr : tin_ls_attribute_index;
            fmode : tin_ls_fieldmode );

BEGIN
WITH fieldtype DO
    BEGIN
    field_att  := fattr;
    fieldmode  := fmode;
    END;
(*ENDWITH*)
END;

.CM *-END-* code ----------------------------------------
.SP 2
***********************************************************
*-PRETTY-*  statements    :        368
*-PRETTY-*  lines of code :       1267        PRETTYX 3.10
*-PRETTY-*  lines in file :       1919         1997-12-10
.PA
