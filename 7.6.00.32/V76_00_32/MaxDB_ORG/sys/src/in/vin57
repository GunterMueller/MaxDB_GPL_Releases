.cm SCRIPT , Version - 1.1 , last edited by B.Morgeneyer
.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VIN57$
.tt 2 $$$
.TT 3 $$Logischer Bildschirm$1998-09-15$
***********************************************************
.nf
 
.nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : logical_screen_IO
=========
.sp
Purpose : Logischer Bildschirm
 
&       if $OS=UNIX
&       define hifmode 1
&       else
&       ifdef WINDOWS
&       define hifmode 1
&       else
&       if $OS=MSDOS
&       define pcmode 1
&       endif
&       endif
&       endif
 
.CM *-END-* purpose -------------------------------------
.sp
Define  :
 
&       ifdef pcmode
        VAR
              i57auto        : boolean;
              i57lockhscroll : boolean;
&       endif
 
        PROCEDURE
              i57ioscreen (
                    VAR csr_pos        : tin_ls_position;
                    VAR rf             : tin_ls_releasemode;
                    VAR screen_changed : boolean);
 
        PROCEDURE
              i57refioscreen (
                    VAR csr_pos        : tin_ls_position;
                    VAR rf             : tin_ls_releasemode;
                    VAR screen_changed : boolean;
                    refresh            : boolean);
 
        PROCEDURE
              i57vtopt_init;
&       ifdef WINDOWS
 
        PROCEDURE
              i57updkeys ;
&       endif
 
        PROCEDURE
              i57screenmessed;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              global_variable : VIN01;
 
        VAR
              i01g : tin_global_in_vars;
&       ifdef TEST
 
      ------------------------------ 
 
        FROM
              Test-Treiber : VMT01;
 
        VAR
              m01g : tin_testmode;
 
        PROCEDURE
              m01vtinout (
                    VAR screen         : tsp00_ScreenBuf;
                    VAR attributes     : tsp00_ScreenBuf;
                    VAR cursorzeile    : tsp00_Int2;
                    VAR cursorspalte   : tsp00_Int2;
                    VAR hif            : tsp00_HifParms;
                    VAR options        : tsp00_VtOptions;
                    VAR screen_changed : boolean;
                    VAR keystroke      : tsp00_VtKeyStroke);
&       endif
 
      ------------------------------ 
 
        FROM
              logical_screen : VIN50 ;
 
        PROCEDURE
              i50getfield (
                    VAR vt_input    : tin_ls_input_field;
                    VAR field_found : boolean);
 
        PROCEDURE
              i50getwindow (
                    first_pos          : tin_ls_position;
                    window_len         : tin_natural;
                    window_width       : tin_natural;
                    VAR window_changed : boolean);
 
      ------------------------------ 
 
        FROM
              logical_screen_layout : VIN51;
 
        PROCEDURE
              i51size (
                    screen_part    : tin_ls_part;
                    VAR partlength : tin_natural;
                    VAR partwidth  : tin_natural);
 
      ------------------------------ 
 
        FROM
              logical_screen_variants : VIN52;
 
&       ifdef pcmode
        VAR
              i52funclabel : boolean;
              i52callevel  : integer;
&       endif
 
        FUNCTION
              i52pffunction (
                    fno : integer) : tin_ls_releasemode;
 
        PROCEDURE
              i52activekeys (
                    VAR active_keys : tsp00_VtKeys);
 
        FUNCTION
              i52rf (
                    rk : tsp00_VtKey) : tin_ls_releasemode;
 
        PROCEDURE
              i52lsmsg (
                    msgno        : integer;
                    VAR textline : tin_screenline;
                    VAR length   : tin_natural);
 
        PROCEDURE
              i52fromscreenpos (
                    VAR pos       : tin_ls_position;
                    VAR screenlno : tin_natural;
                    VAR screencol : tin_natural);
 
        PROCEDURE
              i52toscreenpos (
                    lno            : tin_natural;
                    col            : tin_natural;
                    preferred_part : tin_ls_part;
                    VAR pos        : tin_ls_position);
&       ifdef pcmode
 
        PROCEDURE
              i52pclabels (
                    VAR fct             : tin_ls_releasemode;
                    opt                 : tin_menu_comment;
                    functionline_labels : boolean);
&       endif
&       ifdef WINDOWS
 
        FUNCTION
              i52keytrans (
                    rf : tin_ls_releasemode) : tsp00_VtKey ;
&       endif
 
      ------------------------------ 
 
        FROM
              logical_screen_procedures : VIN53;
 
        PROCEDURE
              i53screenaddresses (
                    sno        : tsp00_Int2;
                    VAR screen : tsp00_ScreenBufAddr;
                    VAR att    : tsp00_ScreenBufAddr ;
                    VAR maxlines : tsp00_Int2;
                    VAR maxcols  : tsp00_Int2 );
 
        FUNCTION
              i53isinput(
                    vt_screen : tsp00_ScreenBufAddr;
                    vt_att    : tsp00_ScreenBufAddr;
                    pos       : integer) : boolean;
 
        PROCEDURE
              i53frombufpos (
                    pos     : integer;
                    maxcols : integer;
                    VAR row : integer;
                    VAR col : integer);
 
        PROCEDURE
              i53setprotected (
                    row     : integer;
                    lines   : integer;
                    maxcols : integer;
                    vt_att  : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53nextfield (
                    VAR row,col       : integer;
                    VAR length        : integer;
                    VAR found         : boolean;
                    VAR field_changed : boolean;
                    num_of_lines      : integer;
                    num_of_cols       : integer;
                    vt_screen         : tsp00_ScreenBufAddr;
                    vt_att            : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53setunchanged (
                    row,col,length : integer;
                    num_of_cols    : integer;
                    vt_att         : tsp00_ScreenBufAddr);
 
        FUNCTION
              i53tobufpos (
                    lno, col : integer;
                    maxcols  : integer) : integer;
 
      ------------------------------ 
 
        FROM
              logical_screen_help_procedures : VIN54;
 
        PROCEDURE
              i54terminal_type (
                    VAR typ : tin_terminal_type);
 
        PROCEDURE
              i54initls_pos (
                    VAR ls_pos : tin_ls_position);
 
      ------------------------------ 
 
        FROM
              logical_screen_modules : VIN56;
 
&       ifdef WINDOWS
        VAR
              i56recursion      : tsp00_Int2;
              i56desc2          : tsp00_TerminalDescription ;
              i56sysline2       : tsp00_Line;
              i56sysatt2        : tsp00_Line;
 
        PROCEDURE
              i56setfocus(
                    boxid       : tsp00_Int2;
                    sline, scol : tsp00_Int2);
 
        PROCEDURE
              i56check_box(
                    boxid           : tsp00_Int2;
                    VAR box_changed : boolean;
                    VAR focus_line  : tsp00_Int2;
                    VAR focus_col   : tsp00_Int2);
 
        PROCEDURE
              i56acttofocus;
 
        FUNCTION
              i56actbox : tsp00_Int2;
 
        FUNCTION
              i56actscreenpart : tin_ls_part;
 
        PROCEDURE
              i56ckinfobox ;
&       endif
&       ifdef PCMODE
 
        FUNCTION
              i56hscroll (
                    VAR mouse_pos  : tin_ls_position;
                    VAR scroll_dir : tsp00_Int2) : boolean;
 
        FUNCTION
              i56vscroll (
                    VAR mouse_pos  : tin_ls_position;
                    VAR scroll_dir : tsp00_Int2) : boolean;
&       endif
 
        FUNCTION
              i56scrolldir (
                    VAR key : tsp00_VtKeyStroke ) : tsp00_Int4;
 
        PROCEDURE
              i56errormessage (
                    sno          : tsp00_Int2;
                    VAR textline : tin_screenline;
                    length       : tin_natural );
&       ifdef WINDOWS
 
        PROCEDURE
              i56clearerrormsg;
 
      ------------------------------ 
 
        FROM
              global_init : VIN02;
 
        PROCEDURE
              i02unlockgp (
                    VAR p : tin_global_in_vars);
 
        PROCEDURE
              i02lockgp (
                    VAR p : tin_global_in_vars);
&       endif
 
      ------------------------------ 
 
        FROM
              RTE_driver : VEN102;
 
        PROCEDURE
              sqltio (
                    term_ref          : tsp00_Int4;
                    VAR screen_buf    : tsp00_ScreenBufAddr;
                    VAR attribute_buf : tsp00_ScreenBufAddr;
                    refresh           : boolean;
                    VAR cursorline    : tsp00_Int2;
                    VAR cursorcolumn  : tsp00_Int2;
                    VAR hif           : tsp00_HifParms;
                    VAR options       : tsp00_VtOptions;
                    VAR result        : tsp00_VtResult;
                    VAR ok            : boolean);
&       ifdef WINDOWS
 
        PROCEDURE
              sqlwspsetactscreen (
                    term_ref  : tsp00_Int4;
                    screen_nr : tsp00_Int2;
                    VAR ok    : boolean);
 
        PROCEDURE
              sqlwspaddr2 (
                    term_ref    : tsp00_Int4;
                    VAR screen2 : tsp00_ScreenBufAddr;
                    VAR att2    : tsp00_ScreenBufAddr;
                    VAR ok      : boolean);
 
        PROCEDURE
              sqlwspgetactscreen (
                    term_ref      : tsp00_Int4;
                    VAR screen_nr : tsp00_Int2;
                    VAR ok        : boolean );
 
        PROCEDURE
              sqltsysline (
                    term_ref     : tsp00_Int4;
                    screen_nr    : tsp00_Int2;
                    VAR sys_text : tsp00_Line;
                    VAR sys_attr : tsp00_Line;
                    VAR ok       : boolean );
 
        PROCEDURE
              sqltslabels (
                    term_ref    : tsp00_Int4;
                    VAR slabels : tsp00_VtSlabels;
                    VAR ok      : boolean );
 
        PROCEDURE
              sqltreturnkeys (
                    term_ref       : tsp00_Int4;
                    VAR returnkeys : tsp00_VtKeys;
                    VAR ok         : boolean );
&       endif
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;       
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;    
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;    
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
&       ifdef plprof
 
      ------------------------------ 
 
        FROM
              monitoring: VDG57;
 
        PROCEDURE
              d57contop (
                    opcnew : integer;
                    sopnew : integer );
 
        PROCEDURE
              d57startop (
                    opcnew : integer;
                    sopnew : integer );
 
        PROCEDURE
              d57getop (
                    VAR curr_opc : integer;
                    VAR curr_sop : integer );
&       endif
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              m90buf;
 
              tsp00_Buf tsp00_ScreenBuf
 
        PROCEDURE
              i56errormessage;
 
              tsp00_MoveObj tin_screenline
 
        PROCEDURE
              sqltio;
 
              tsp00_Int4          tsp00_Int4
              tsp00_ScreenBufAddr tsp00_ScreenBufAddr
              tsp00_ScreenBufAddr tsp00_ScreenBufAddr
              tsp00_Int2          tsp00_Int2
              tsp00_Int2          tsp00_Int2
              tsp00_HifParms      tsp00_HifParms
              tsp00_VtOptions     tsp00_VtOptions
              tsp00_VtResult      tsp00_VtResult
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1990-11-07
.sp
.cp 3
.sp
.cp 3
Release :      Date : 1998-09-15
.sp
***********************************************************
.pa
.cp 10
.fo
.oc _/1
Specification:
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      (* ls_msgno *)
      msg_undef = 1;
&     ifdef plprof
 
VAR
      i57opc : integer;
      i57sop : integer;
&     endif
 
 
(*------------------------------*) 
 
PROCEDURE
      i57refioscreen (
            VAR csr_pos        : tin_ls_position;
            VAR rf             : tin_ls_releasemode;
            VAR screen_changed : boolean;
            refresh            : boolean);
 
VAR
      width                : tin_natural;
      release              : boolean;
      active_keys          : tsp00_VtKeys;
      local_keys           : tsp00_VtKeys;
      alternate_cursor     : tin_ls_position;
      local_screen_changed : boolean;
      reset_changed_bit    : boolean;
      wait_opt             : boolean;
 
BEGIN
IF  NOT i01g^.is_batch
THEN
    BEGIN
&   ifdef pcmode
    i52callevel := i52callevel + 1;
&   endif
    IF  i01g^.ls.nr_screens  = 1
    THEN
        csr_pos.screen_nr := 1;
    (*ENDIF*) 
    CASE csr_pos.screen_part OF
        cin_ls_functionmenu:
            WITH i01g^.ls DO
                IF  NOT initial_lspos(cursorpos)
                THEN
                    csr_pos := cursorpos;
                (*ENDIF*) 
            (*ENDWITH*) 
        cin_ls_sysline:
            IF  i01g^.vt.desc.has_sysline
            THEN
                i54initls_pos(csr_pos);
            (*ENDIF*) 
        OTHERWISE:
        END;
    (*ENDCASE*) 
    alternate_cursor := csr_pos;
    get_allowed_keys ( active_keys, local_keys );
    wait_opt := i01g^.vt.opt.wait_for_input;
    reset_changed_bit := i01g^.vt.parms.reset_changed_bit
          AND wait_opt
&         ifdef pcmode
          AND (i52callevel = 1)  (* not for recursive calls *)
&         endif
          ;
&   ifdef WINDOWS
    i56ckinfobox ;
&   endif
    IF  reset_changed_bit
    THEN
        set_changed_attributes;
    (*ENDIF*) 
    screen_changed := false;
    release := false;
    (* here: get sysline content *)
    REPEAT
        screen_interaction_50(csr_pos,i01g^.i50.hif,
              local_screen_changed, refresh );
        screen_changed := screen_changed OR local_screen_changed;
        IF  NOT wait_opt
        THEN
            BEGIN
            rf := f_enter;
            release := true;
            END
        ELSE
            BEGIN
            get_allowed_keys ( active_keys, local_keys );
            process_releasekey(rf, active_keys, local_keys,
                  csr_pos, alternate_cursor,
                  release);
            END;
        (*ENDIF*) 
    UNTIL
        release OR NOT i01g^.vt.ok;
    (*ENDREPEAT*) 
    editmode_returnkey( rf );
    i57vtopt_init;
    IF  wait_opt
    THEN
        i01g^.i50.new_value := false;
    (*ENDIF*) 
    WITH i01g^.ls DO
        cursorpos := csr_pos;
    (*ENDWITH*) 
    WITH i01g^.i50.window DO
        BEGIN
        first_line := 1;
        first_col := 1;
        length := i01g^.vt.desc.num_of_lines;
        width := i01g^.vt.desc.num_of_cols;
        END;
    (*ENDWITH*) 
    i01g^.i50.curr_sno := 1;
    i01g^.i50.curr_row := 1;
    i01g^.i50.curr_col := 0;
    i54initls_pos(i01g^.ls.cursorpos);
&   ifdef pcmode
    i52callevel := i52callevel - 1;
&   endif
    END;
(*ENDIF*) 
END; (* i57refioscreen *)
 
(*------------------------------*) 
 
PROCEDURE
      get_allowed_keys (
            VAR active_keys : tsp00_VtKeys;
            VAR local_keys  : tsp00_VtKeys);
 
BEGIN
i52activekeys( active_keys );
IF  NOT (f_local IN i01g^.key_type.activated)
THEN
    WITH i01g^.vt DO
        BEGIN
&       ifdef WINDOWS
        opt.returnkeys := active_keys;
&       else
        opt.returnkeys := opt.returnkeys + [  vt_enter..vt_end_key  ]
              - [  vt_clear, vt_unknown  ] + active_keys;
&       endif
        END;
    (*ENDWITH*) 
(*  plus keys from return_on_last etc... *)
(*>>>only for active_keys, not options<<<*)
(*ENDIF*) 
active_local_keys( active_keys ,local_keys);
END;
 
(*------------------------------*) 
 
PROCEDURE
      editmode_returnkey(
            VAR rf : tin_ls_releasemode);
 
BEGIN
IF  i01g^.vt.opt.usage_mode = vt_edit
THEN
    BEGIN
    IF  rf = f_local
    THEN
        BEGIN
        IF  i01g^.vt.parms.key.key = vt_next_field
        THEN
            BEGIN
            (* return on last field *)
            rf := f_enter;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i57vtopt_init;
 
BEGIN
WITH i01g^.vt.opt DO
    BEGIN
    wait_for_input     := true;
    usage_mode         := vt_form;
    return_on_last     := false;
    return_on_first    := false;
&   ifdef WINDOWS
    returnkeys := [];
&   else
    returnkeys         := [  vt_enter .. vt_cmd_key ]
          * i01g^.vt.desc.returnkeys;
&   endif
    reject_keys        := [  ] ;
    bell               := false;
&   ifdef WINDOWS
    IF  i01g^.ls.nr_screens > 1
    THEN
        BEGIN
        first_line_changed := i01g^.vt.desc.num_of_lines + 1;
        screen2_first_changed := i01g^.vt.desc.num_of_lines + 1;
        last_line_changed := 0;
        screen2_last_changed := 0;
        END
    ELSE
&       endif
        BEGIN
        first_line_changed := i01g^.vt.desc.num_of_lines + 1;
        last_line_changed := 0;
        END;
    (*ENDIF*) 
    overtype := false;
    END;
(*ENDWITH*) 
END; (* i57vtopt_init *)
 
(*------------------------------*) 
 
PROCEDURE
      active_local_keys (
            VAR active_keys : tsp00_VtKeys;
            VAR local_keys  : tsp00_VtKeys);
 
BEGIN
local_keys := [  ] ;
WITH i01g^.vt.opt DO
    BEGIN
    IF  return_on_last
    THEN
        active_keys := active_keys + [  vt_next_field, vt_cursor_down,
              vt_cursor_right, vt_character_key ] ;
    (*ENDIF*) 
    IF  return_on_first
    THEN
        active_keys := active_keys + [  vt_prev_field, vt_cursor_up,
              vt_cursor_left ] ;
&   ifdef pcmode
    (*ENDIF*) 
    IF  i57auto
    THEN
        active_keys := active_keys + [  vt_vscroll ] ;
    (*ENDIF*) 
    local_keys := local_keys + [  vt_escape_key, vt_mouse_up ] ;
&   endif
    END;
(*ENDWITH*) 
END; (* active_local_keys *)
 
(*------------------------------*) 
 
PROCEDURE
      screen_interaction_50 (
            VAR csr_pos        : tin_ls_position;
            VAR hif            : tsp00_HifParms;
            VAR screen_changed : boolean;
            refresh            : boolean);
 
BEGIN
&ifdef pcmode
IF  i57auto
THEN
    io_with_autoscroll(csr_pos, hif, screen_changed)
ELSE
&   endif
    io_screen_50(csr_pos, hif, screen_changed, refresh);
(*ENDIF*) 
END; (* screen_interaction_50 *)
 
&ifdef pcmode
(*------------------------------*) 
 
PROCEDURE
      io_with_autoscroll (
            VAR csr_pos        : tin_ls_position;
            VAR hif            : tsp00_HifParms;
            VAR screen_changed : boolean);
 
VAR
      save_att            : tsp00_Buf;
      inactive_part       : tin_ls_part;
      quit                : boolean;
      this_screen_changed : boolean;
 
BEGIN
set_autoscroll_vtopt;
screen_changed := false;
REPEAT
    IF  csr_pos.screen_part = cin_ls_workarea
    THEN
        inactive_part := cin_ls_inputarea
    ELSE
        IF  csr_pos.screen_part = cin_ls_inputarea
        THEN
            inactive_part := cin_ls_workarea
        ELSE
            inactive_part := cin_ls_undef_part;
        (*ENDIF*) 
    (*ENDIF*) 
    save_part(inactive_part, save_att);
    change_inactive_attributes(inactive_part);
    io_screen_50(csr_pos, hif, this_screen_changed);
    screen_changed := screen_changed OR this_screen_changed;
    restore_part(inactive_part, save_att);
    exec_autoscroll_cmd(inactive_part,csr_pos, quit);
UNTIL
    quit OR NOT i01g^.vt.ok;
(*ENDREPEAT*) 
END; (* io_with_autoscroll *)
 
(*------------------------------*) 
 
PROCEDURE
      set_autoscroll_vtopt;
 
BEGIN
WITH i01g^.vt.opt DO
    BEGIN
    return_on_last  := true;
    return_on_first := true;
    END;
(*ENDWITH*) 
END; (* set_autoscroll_vtopt *)
 
(*------------------------------*) 
 
PROCEDURE
      exec_autoscroll_cmd (
            inactive_part : tin_ls_part;
            VAR csr_pos   : tin_ls_position;
            VAR quit      : boolean);
 
BEGIN
quit := false;
WITH i01g^.vt DO
    BEGIN
    CASE parms.key.key OF
        vt_next_field:
            IF  csr_pos.screen_part = cin_ls_workarea
            THEN
                skip_to_inputarea(csr_pos);
            (*ENDIF*) 
        vt_prev_field:
            IF  csr_pos.screen_part = cin_ls_inputarea
            THEN
                skip_to_workarea(csr_pos);
            (*ENDIF*) 
        vt_cursor_up:
            scroll_i57(csr_pos, -1, quit);
        vt_cursor_down:
            scroll_i57(csr_pos, +1, quit);
        vt_mouse_move:
            scroll_by_mouse(quit);
        vt_mouse_up:
            cursor_to_mousepos_i57(inactive_part, csr_pos, quit);
        OTHERWISE:
            quit := true;
        END;
    (*ENDCASE*) 
    END;
(*ENDWITH*) 
END; (* exec_autoscroll_cmd *)
 
(*------------------------------*) 
 
PROCEDURE
      scroll_by_mouse(
            VAR quit : boolean);
 
VAR
      dir : integer;
 
BEGIN
WITH i01g^.vt.parms DO
    BEGIN
    IF  mouse_pos.sline <= 1
    THEN
        BEGIN
        dir := -1;
        i57lockhscroll := false;
        END
    ELSE
        BEGIN
        dir := +1;
        i57lockhscroll := true;
        END;
    (*ENDIF*) 
    scroll_i57(mouse_pos, dir, quit);
    END;
(*ENDWITH*) 
END; (* scroll_by_mouse *)
 
(*------------------------------*) 
 
PROCEDURE
      scroll_i57 (
            VAR pos  : tin_ls_position;
            dir      : integer;
            VAR quit : boolean);
 
BEGIN
IF  pos.screen_part = cin_ls_workarea
THEN
    BEGIN
    WITH i01g^.vt.parms.key DO
        BEGIN
        key := vt_vscroll;
        scroll_dir := dir;
        END;
    (*ENDWITH*) 
    quit := true;
    END;
(*ENDIF*) 
END; (* scroll_i57 *)
 
(*------------------------------*) 
 
PROCEDURE
      skip_to_inputarea (
            VAR csr_pos : tin_ls_position);
 
CONST
      is_first = true;
 
VAR
      pos : tin_ls_position;
      ok  : boolean;
 
BEGIN
search_inputfield(csr_pos.screen_nr, cin_ls_inputarea, is_first, pos, ok);
IF  ok
THEN
    csr_pos := pos;
(*ENDIF*) 
END; (* skip_to_inputarea *)
 
(*------------------------------*) 
 
PROCEDURE
      skip_to_workarea (
            VAR csr_pos : tin_ls_position);
 
CONST
      is_first = false;
 
VAR
      pos : tin_ls_position;
      ok  : boolean;
 
BEGIN
search_inputfield(csr_pos.screen_nr, cin_ls_workarea, is_first, pos, ok);
IF  ok
THEN
    csr_pos := pos;
(*ENDIF*) 
END; (* skip_to_workarea *)
 
(*------------------------------*) 
 
PROCEDURE
      cursor_to_mousepos_i57 (
            inactive_part : tin_ls_part;
            VAR csr_pos   : tin_ls_position;
            VAR quit      : boolean);
 
BEGIN
quit := true;
WITH i01g^.vt.parms DO
    BEGIN
    IF  mouse_pos.screen_part = inactive_part
    THEN
        BEGIN
        IF  is_inputfield_i57(key.mouse_y, key.mouse_x)
        THEN
            BEGIN
            csr_pos := mouse_pos;
            quit := false;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* cursor_to_mousepos_i57 *)
 
(*------------------------------*) 
 
FUNCTION
      is_inputfield_i57 (
            row, col : integer) : boolean;
 
VAR
      pos : integer;
 
BEGIN
WITH i01g^.vt.desc DO
    BEGIN
    pos := i53tobufpos(row, col, num_of_cols);
    is_inputfield_i57 := i53isinput(content_buf^, attribute_buf^, pos);
    END;
(*ENDWITH*) 
END; (* is_inputfield_i57 *)
 
(*------------------------------*) 
 
PROCEDURE
      save_part (
            part         : tin_ls_part;
            VAR save_att : tsp00_Buf);
 
VAR
      length   : integer;
      pos      : integer;
      is_first : integer;
      lines    : integer;
 
BEGIN
WITH i01g^.ls,description [nr_screens]  [part ] DO
    BEGIN
    is_first := first_line;
    lines    := last_line - first_line + 1;
    END;
(*ENDWITH*) 
WITH i01g^.vt,desc DO
    BEGIN
    pos := i53tobufpos(is_first, 1, num_of_cols);
    length := lines * num_of_cols;
    s10mv(SCREEN_BUF_MXSP00,mxsp_buf,
          @attribute_buf^,pos,
          @save_att,1,length);
    END;
(*ENDWITH*) 
END; (* save_part *)
 
(*------------------------------*) 
 
PROCEDURE
      restore_part (
            part         : tin_ls_part;
            VAR save_att : tsp00_Buf);
 
VAR
      length   : integer;
      pos      : integer;
      is_first : integer;
      lines    : integer;
 
BEGIN
WITH i01g^.ls,description [nr_screens]  [part ] DO
    BEGIN
    is_first := first_line;
    lines    := last_line - first_line + 1;
    END;
(*ENDWITH*) 
WITH i01g^.vt,desc DO
    BEGIN
    pos := i53tobufpos(is_first, 1, num_of_cols);
    length := lines * num_of_cols;
    s10mv(mxsp_buf,SCREEN_BUF_MXSP00,
          @save_att,1,
          @attribute_buf^,pos,length);
    END;
(*ENDWITH*) 
END; (* restore_part *)
 
(*------------------------------*) 
 
PROCEDURE
      change_inactive_attributes (
            part : tin_ls_part);
 
VAR
      is_first : integer;
      lines    : integer;
 
BEGIN
WITH i01g^.ls,description [nr_screens]  [part ] DO
    BEGIN
    is_first := first_line;
    lines    := last_line - first_line + 1;
    END;
(*ENDWITH*) 
WITH i01g^.vt,desc DO
    BEGIN
    i53setprotected (is_first, lines, num_of_cols, attribute_buf^);
    END;
(*ENDWITH*) 
END; (* change_inactive_attributes *)
 
&endif
(*------------------------------*) 
 
PROCEDURE
      io_screen_50 (
            VAR csr_pos        : tin_ls_position;
            hif                : tsp00_HifParms;
            VAR screen_changed : boolean;
            refresh            : boolean );
 
VAR
      cursorline   : tsp00_Int2;
      cursorcolumn : tsp00_Int2;
      wait_opt     : boolean;
      scr, att     : tsp00_ScreenBufAddr;
      refr         : tsp00_Int4;
      options      : tsp00_VtOptions;
      result       : tsp00_VtResult;
      ret,rej      : boolean;
 
BEGIN
IF  NOT i01g^.is_batch
THEN
    BEGIN
    init_vt_result( result );
    (* ========================================================= *)
    (* Die folgenden Anweisungen .. bis sqlabort einschliesslich *)
    (* noetig, seitdem das virtuelle Terminal abstuerzt, wenn    *)
    (* die folgenden Bedingungen nicht erfuellt sind.            *)
    (*                                          (B.J. 14.5.93)   *)
    (* ========================================================= *)
&   ifndef WINDOWS
    IF  i01g^.vt.opt.last_line_changed > i01g^.vt.desc.num_of_lines
    THEN
        i01g^.vt.opt.last_line_changed := i01g^.vt.desc.num_of_lines;
    (*ENDIF*) 
    IF  i01g^.vt.opt.first_line_changed < 1
    THEN
        i01g^.vt.opt.first_line_changed := 1;
    (*ENDIF*) 
    IF  i01g^.vt.opt.last_line_changed < i01g^.vt.opt.first_line_changed
    THEN
        BEGIN
        (* Fuehrt im virt.Terminal auch zum Absturz *)
        (*i01g^.vt.opt.last_line_changed := i01g^.vt.opt.first_line_changed;*)
        i01g^.vt.opt.last_line_changed := i01g^.vt.desc.num_of_lines;
        i01g^.vt.opt.first_line_changed := 1;
        END;
&   endif
    (*ENDIF*) 
    cursor_from_screenpos(csr_pos,cursorline, cursorcolumn );
    set_mark_limits(result);
&   ifdef WINDOWS
    set_sysline(hif);
    remove_locked_vtkeys;
&   endif
&   ifdef TEST
    WITH i01g^.vt,desc DO
        BEGIN
        wait_opt := opt.wait_for_input;
        IF  m01g.mode = single_test
        THEN
            opt.wait_for_input := false;
        (*ENDIF*) 
        IF  m01g.mode <> notest
        THEN
            m01vtinout (content_buf^,
                  attribute_buf^,
                  cursorline, cursorcolumn,
                  hif,i01g^.vt.opt,screen_changed,i01g^.vt.parms.key);
        (*ENDIF*) 
        scr := content_buf;
        att := attribute_buf;
        refr := vt_ref;
        END;
    (*ENDWITH*) 
&   ifdef plprof
    d57getop ( i57opc, i57sop );
    d57startop ( 33, 1 );
&   endif
    (* =========================================================*)
    sqltio(refr, scr, att, refresh,
          cursorline, cursorcolumn,
          hif, i01g^.vt.opt, result, i01g^.vt.ok);
    (* =========================================================*)
&   ifdef plprof
    d57contop ( i57opc, i57sop );
&   endif
    get_vt_result(result, screen_changed);
    WITH i01g^.vt,desc DO
        BEGIN
        content_buf := scr;
        attribute_buf := att;
        IF  m01g.mode <> notest
        THEN
            m01vtinout (content_buf^,
                  attribute_buf^,cursorline,
                  cursorcolumn,hif,opt,screen_changed,parms.key);
        (*ENDIF*) 
        opt.wait_for_input := wait_opt;
        END;
    (*ENDWITH*) 
&   else
    WITH i01g^.vt,desc DO
        BEGIN
        scr := content_buf;
        att := attribute_buf;
        refr := vt_ref;
        options := opt;
        END;
    (*ENDWITH*) 
&   ifdef pcmode
    add_pc_returnkeys;
&   endif
&   ifdef WINDOWS
    i02unlockgp(i01g);
&   endif
&   ifdef plprof
    d57getop ( i57opc, i57sop );
    d57startop ( 33, 1 );
&   endif
    (* =========================================================*)
    ret := vt_mouse_down IN options.returnkeys;
    rej := vt_mouse_down IN options.reject_keys;
    ret := vt_mouse_up   IN options.returnkeys;
    rej := vt_mouse_up   IN options.reject_keys;
    ret := vt_mouse_dbl  IN options.returnkeys;
    rej := vt_mouse_dbl  IN options.reject_keys;
    sqltio(refr, scr, att, refresh,
          cursorline, cursorcolumn,
          hif, options, result, i01g^.vt.ok);
    (* =========================================================*)
&   ifdef plprof
    d57contop ( i57opc, i57sop );
&   endif
&   ifdef WINDOWS
    i02lockgp(i01g);
&   endif
    get_vt_result(result, screen_changed);
    WITH i01g^.vt,desc DO
        BEGIN
        IF  NOT i01g^.vt.ok
        THEN
            vt_ref := 0;
        (*ENDIF*) 
        opt := options;
        content_buf := scr;
        attribute_buf := att;
        IF  (content_buf = NIL) OR (attribute_buf = NIL)
        THEN
            i01g^.vt.ok := false;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
&   ifdef WINDOWS
    IF  options.wait_for_input
    THEN
        i56clearerrormsg;
    (*ENDIF*) 
    sqlwspaddr2( i01g^.vt.vt_ref, i56desc2.content_buf,
          i56desc2.attribute_buf, ok );
&   endif
&   endif
    cursor_to_screenpos( cursorline, cursorcolumn,
          csr_pos, screen_changed );
    i01g^.vt.opt.bell := false;
    (* here: restore sysline content *)
    END;
(*ENDIF*) 
END; (* io_screen_50 *)
 
(*------------------------------*) 
 
PROCEDURE
      init_vt_result(
            VAR result : tsp00_VtResult );
 
BEGIN
WITH result DO
    BEGIN
    no_mark( result );
    num_of_lines   := i01g^.vt.desc.num_of_lines;
    num_of_cols    := i01g^.vt.desc.num_of_cols ;
    screen_changed := false;
    keystroke      := i01g^.vt.parms.key;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      cursor_from_screenpos(
            VAR csr_pos      : tin_ls_position;
            VAR cursorline   : tsp00_Int2;
            VAR cursorcolumn : tsp00_Int2);
 
VAR
      cursor_slno : tin_natural;
      cursor_col  : tin_natural;
      ok          : boolean;
 
BEGIN
&ifdef WINDOWS
sqlwspsetactscreen ( i01g^.vt.vt_ref, csr_pos.screen_nr, ok );
IF  csr_pos.screen_part = i56actscreenpart
THEN
    BEGIN
    i56setfocus( i56actbox, csr_pos.sline, csr_pos.scol );
    cursorline := 0;
    cursorcolumn := 0;
    (* dummy values to show cursor on normal screen *)
    END
ELSE
&   endif
    BEGIN
&   ifdef WINDOWS
    i56setfocus( 0, 0, 0 );
&   endif
    i52fromscreenpos(csr_pos,cursor_slno,cursor_col);
    cursorline := cursor_slno;
    cursorcolumn := cursor_col;
    END;
(*ENDIF*) 
&ifdef WINDOWS
IF  (cursorline = 0) OR (cursorcolumn = 0)
THEN
    BEGIN
    search_inputfield(csr_pos.screen_nr, cin_ls_workarea,
          true, csr_pos, ok);
    IF  ok
    THEN
        BEGIN
        i52fromscreenpos(csr_pos,cursor_slno,cursor_col);
        cursorline := cursor_slno;
        cursorcolumn := cursor_col;
        END
    ELSE
        BEGIN
        cursorline := 1;
        cursorcolumn := 1;
        END;
    (*ENDIF*) 
    END;
&endif
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      cursor_to_screenpos(
            cursorline         : tsp00_Int2;
            cursorcolumn       : tsp00_Int2;
            VAR csr_pos        : tin_ls_position;
            VAR screen_changed : boolean);
 
VAR
      box_changed : boolean;
      focus_line  : tsp00_Int2;
      focus_col   : tsp00_Int2;
      ok          : boolean;
      sno         : tsp00_Int2;
 
BEGIN
i52toscreenpos(cursorline,cursorcolumn,csr_pos.screen_part,csr_pos);
&ifdef WINDOWS
i56acttofocus;
IF  (i56actscreenpart <> cin_ls_undef_part)
THEN
    BEGIN
    i56check_box( i56actbox, box_changed, focus_line, focus_col );
    screen_changed := screen_changed OR box_changed;
    END
ELSE
    focus_line := 0;
(*ENDIF*) 
IF  (focus_line > 0)
THEN
    BEGIN
    csr_pos.screen_part := i56actscreenpart;
    csr_pos.sline := focus_line;
    csr_pos.scol := focus_col;
    END
ELSE
    BEGIN
    sqlwspgetactscreen ( i01g^.vt.vt_ref, sno, ok );
    csr_pos.screen_nr := sno;
    END;
(*ENDIF*) 
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      set_mark_limits (
            VAR result : tsp00_VtResult);
 
VAR
      lno, col : tin_natural;
 
BEGIN
WITH i01g^.vt DO
    IF  opt.mark <> vt_mark_off
    THEN
        BEGIN
        i52fromscreenpos(parms.mark_begin, lno, col);
        IF  (lno > 0) AND (col > 0)
        THEN
            BEGIN
            result.mark_begin := i53tobufpos(lno, col, desc.num_of_cols);
            i52fromscreenpos(parms.mark_end, lno, col);
            IF  (lno > 0) AND (col > 0)
            THEN
                BEGIN
                result.mark_end := i53tobufpos(lno, col, desc.num_of_cols);
                END
            ELSE
                no_mark( result );
            (*ENDIF*) 
            END
        ELSE
            no_mark( result );
        (*ENDIF*) 
        END
    ELSE
        no_mark( result );
    (*ENDIF*) 
(*ENDWITH*) 
END; (* set_mark_limits *)
 
(*------------------------------*) 
 
PROCEDURE
      no_mark(
            VAR result : tsp00_VtResult);
 
BEGIN
result.mark_begin := 0;
result.mark_end := -1;
END;
 
(*------------------------------*) 
 
PROCEDURE
      get_vt_result (
            VAR result         : tsp00_VtResult;
            VAR screen_changed : boolean);
 
BEGIN
screen_changed := result.screen_changed;
WITH i01g^.vt.desc DO
    BEGIN
    num_of_lines := result.num_of_lines;
    num_of_cols := result.num_of_cols;
    END;
(*ENDWITH*) 
get_mark_limits(result);
WITH i01g^.vt DO
    BEGIN
    parms.key := result.keystroke;
&   ifdef CTEST
    IF  parms.key.key = vt_enter
    THEN
        parms.key.key := vt_cmd_key;
&   endif
    (*ENDIF*) 
    END;
(*ENDWITH*) 
WITH i01g^.vt.parms.key DO
    IF  (key = vt_mouse_move)
        OR (key = vt_mouse_up)
        OR (key = vt_mouse_down)
        OR (key = vt_mouse_dbl)
    THEN
        i52toscreenpos(mouse_y, mouse_x, cin_ls_workarea,
              i01g^.vt.parms.mouse_pos);
    (*ENDIF*) 
(*ENDWITH*) 
END; (* get_vt_result *)
 
(*------------------------------*) 
 
PROCEDURE
      get_mark_limits (
            VAR result : tsp00_VtResult);
 
VAR
      row : integer;
      col : integer;
 
BEGIN
WITH i01g^.vt DO
    IF  desc.num_of_cols = 0
    THEN
        opt.mark := vt_mark_off
    ELSE
        IF  opt.mark <> vt_mark_off
        THEN
            BEGIN
            i53frombufpos(result.mark_begin, desc.num_of_cols, row, col);
            reset_range_limits(row, col);
            i52toscreenpos(row, col, cin_ls_workarea, parms.mark_begin);
            i53frombufpos(result.mark_end, desc.num_of_cols, row, col);
            reset_range_limits(row, col);
            i52toscreenpos(row, col, cin_ls_workarea, parms.mark_end);
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* get_mark_limits *)
 
(*------------------------------*) 
 
PROCEDURE
      reset_range_limits (
            VAR row : integer;
            VAR col : integer);
 
BEGIN
IF  row < 0
THEN
    row := 0;
(*ENDIF*) 
IF  col < 0
THEN
    col := 0;
(*ENDIF*) 
END; (* reset_range_limits *)
 
(*------------------------------*) 
 
PROCEDURE
      process_releasekey (
            VAR rf               : tin_ls_releasemode;
            VAR active_keys      : tsp00_VtKeys;
            VAR local_keys       : tsp00_VtKeys;
            VAR csr_pos          : tin_ls_position;
            VAR alternate_cursor : tin_ls_position;
            VAR release          : boolean);
 
VAR
      defined : boolean;
      typ     : tin_terminal_type;
 
BEGIN
release := false;
defined := i01g^.vt.parms.key.key IN active_keys +
      local_keys;
IF  defined
THEN
    BEGIN (* !!! *)
    rf := i52rf(i01g^.vt.parms.key.key);
&   ifdef pcmode
    i54terminal_type(typ);
    IF  typ = pc_terminal
    THEN
        process_pc_relkey(rf, csr_pos, active_keys, release)
    ELSE (* no pc terminal *)
&       endif
        BEGIN
        release := true;
        i01g^.ls.fctline_cursor :=
              functioncursor_relmode(csr_pos);
        END;
    (*ENDIF*) 
    IF  (rf = f_vscroll) OR (rf = f_hscroll)
    THEN
        i01g^.vt.parms.scroll_dir := i56scrolldir ( i01g^.vt.parms.key );
    (*ENDIF*) 
    END
ELSE
    BEGIN (* not defined *)
    release := false;
    IF  i01g^.vt.parms.key.key = vt_cmd_key
    THEN
        switch_to_cmdline(csr_pos,
              alternate_cursor)
    ELSE
        BEGIN
        put_undef_error(csr_pos);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END; (* process_releasekey *)
 
(*------------------------------*) 
 
PROCEDURE
      switch_to_cmdline (
            VAR csr_pos          : tin_ls_position;
            VAR alternate_cursor : tin_ls_position);
 
CONST
      is_first = true;
 
VAR
      temp      : tin_ls_position;
      search_ok : boolean;
 
BEGIN
IF  csr_pos.screen_part = cin_ls_inputarea
THEN
    BEGIN (* from inputarea to recent pos *)
    IF  alternate_cursor.screen_part = cin_ls_inputarea
    THEN
        BEGIN (* first time *)
        search_inputfield(csr_pos.screen_nr,cin_ls_workarea,
              is_first,temp,search_ok);
        END
    ELSE
        BEGIN
        temp := alternate_cursor;
        search_ok := true;
        END
    (*ENDIF*) 
    END
ELSE
    BEGIN (* from elsewhere to inputarea *)
    IF  alternate_cursor.screen_part = cin_ls_inputarea
    THEN
        BEGIN
        temp := alternate_cursor;
        search_ok := true;
        END
    ELSE
        search_inputfield(csr_pos.screen_nr,cin_ls_inputarea,
              is_first,temp,search_ok);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  search_ok
THEN
    BEGIN
    alternate_cursor := csr_pos;
    csr_pos := temp;
    END;
(*ENDIF*) 
END; (* switch_to_cmdline *)
 
(*------------------------------*) 
 
PROCEDURE
      search_inputfield (
            screen_nr   : tin_natural;
            screen_part : tin_ls_part;
            is_first    : boolean;
            VAR pos     : tin_ls_position;
            VAR found   : boolean);
 
VAR
      row,col       : integer;
      length        : integer;
      field_changed : boolean;
      temp          : tin_ls_position;
      search_ok     : boolean;
      screen        : tsp00_ScreenBufAddr;
      att           : tsp00_ScreenBufAddr;
      maxlines : tsp00_Int2;
      maxcols  : tsp00_Int2;
 
BEGIN
WITH i01g^.ls.description [screen_nr]  [ screen_part  ] DO
    BEGIN
    row := first_line;
    col := first_col - 1;
    END;
(*ENDWITH*) 
found := false;
i53screenaddresses( screen_nr, screen, att, maxlines, maxcols );
IF  (screen <> NIL) AND (att <> NIL)
THEN
    REPEAT
        i53nextfield (row, col,length, search_ok, field_changed,
              maxlines, maxcols, screen, att );
        IF  search_ok
        THEN
            BEGIN
            i52toscreenpos(row,col,cin_ls_undef_part,temp);
            search_ok := (temp.screen_nr = screen_nr)
                  AND (temp.screen_part = screen_part);
            IF  search_ok
            THEN
                pos := temp;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  search_ok
        THEN
            found := true;
        (*ENDIF*) 
    UNTIL
        (NOT search_ok) OR is_first;
    (*ENDREPEAT*) 
(*ENDIF*) 
END; (* search_inputfield *)
 
(*------------------------------*) 
 
PROCEDURE
      put_undef_error (
            VAR csr_pos : tin_ls_position);
 
VAR
      textline : tin_screenline;
      length   : tin_natural;
 
BEGIN
i52lsmsg(msg_undef,textline,length);
i56errormessage( csr_pos.screen_nr, textline, length);
END; (* put_undef_error *)
 
(*------------------------------*) 
 
PROCEDURE
      set_changed_attributes;
 
VAR
      row,col       : integer;
      length        : integer;
      field_changed : boolean;
      search_ok     : boolean;
      sno           : tsp00_Int2;
      screen        : tsp00_ScreenBufAddr;
      att           : tsp00_ScreenBufAddr;
      maxlines : tsp00_Int2;
      maxcols  : tsp00_Int2;
 
BEGIN
&ifdef WINDOWS
IF  i56recursion = 0
THEN
&   endif
    BEGIN
    IF  NOT i01g^.i50.new_value
    THEN
        FOR sno := 1 TO i01g^.ls.nr_screens DO
            BEGIN
            row := 1;
            col := 0;
            i53screenaddresses( sno, screen, att,
                  maxlines, maxcols );
            REPEAT
                BEGIN
                i53nextfield (row, col,length, search_ok, field_changed,
                      maxlines, maxcols, screen, att );
                IF  search_ok AND field_changed
                THEN
                    BEGIN
                    i53setunchanged(row,col,length,maxcols, att );
                    END;
                (*ENDIF*) 
                END;
            UNTIL
                NOT search_ok;
            (*ENDREPEAT*) 
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END; (* set_changed_attributes *)
 
(*------------------------------*) 
 
FUNCTION
      functioncursor_relmode (
            VAR pos : tin_ls_position) : tin_ls_releasemode;
 
VAR
      typ     : tin_terminal_type;
      fno     : integer;
      relmode : tin_ls_releasemode;
 
BEGIN
IF  pos.screen_part = cin_ls_functionmenu
THEN
    BEGIN
    i54terminal_type(typ);
    (* IF  typ IN [ t_3270, pc_terminal ] *)
    IF  (typ = t_3270)
        OR (typ = pc_terminal )
    THEN
        BEGIN
        get_function_nr(pos,fno);
        IF  fno > 0
        THEN
            relmode := i52pffunction(fno)
        ELSE
            relmode := f_clear;
        (*ENDIF*) 
        END
    ELSE
        relmode := f_clear;
    (*ENDIF*) 
    END
ELSE
    relmode := f_clear;
(*ENDIF*) 
functioncursor_relmode := relmode;
END; (* functioncursor_relmode *)
 
(*------------------------------*) 
 
FUNCTION
      initial_lspos (
            cursorpos : tin_ls_position) : boolean;
 
VAR
      ok : boolean;
 
BEGIN
WITH cursorpos DO
    BEGIN
    ok := (screen_nr = 1);
    IF  ok
    THEN
        ok := (screen_part = cin_ls_header);
    (*ENDIF*) 
    IF  ok
    THEN
        ok := (scol = mxin_id_field + 1);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
initial_lspos := ok;
END; (* initial_lspos *)
 
(*------------------------------*) 
 
PROCEDURE
      get_function_nr (
            pos     : tin_ls_position;
            VAR fno : integer);
 
VAR
      lines,cols     : tin_natural;
      first_pos      : tin_ls_position;
      window_changed : boolean;
      vt_input       : tin_ls_input_field;
      field_found    : boolean;
      position_found : boolean;
 
BEGIN
position_found := false;
fno := 0;
i51size(cin_ls_functionmenu,lines,cols);
first_pos := pos;
first_pos.sline := 1;
first_pos.scol := 1;
i50getwindow(first_pos,lines,cols,window_changed);
REPEAT
    i50getfield(vt_input,field_found);
    IF  field_found
    THEN
        BEGIN
        fno := fno + 1;
        position_found := (vt_input.fld_pos.sline = pos.sline);
        IF  position_found
        THEN
            position_found := ((vt_input.fld_pos.scol <= pos.scol)
                  AND (pos.scol <= vt_input.fld_pos.scol + vt_input.len - 1));
        (*ENDIF*) 
        END;
    (*ENDIF*) 
UNTIL
    (NOT field_found) OR position_found;
(*ENDREPEAT*) 
IF  NOT position_found
THEN
    fno := 0;
(*ENDIF*) 
END; (* get_function_nr *)
 
&ifdef pcmode
(*------------------------------*) 
 
PROCEDURE
      add_pc_returnkeys;
 
BEGIN
WITH i01g^.vt.opt DO
    returnkeys := returnkeys + [  vt_escape_key, vt_mouse_up ] ;
(*ENDWITH*) 
END; (* add_pc_returnkeys *)
 
(*------------------------------*) 
 
PROCEDURE
      process_pc_relkey (
            VAR rf          : tin_ls_releasemode;
            VAR csr_pos     : tin_ls_position;
            VAR active_keys : tsp00_VtKeys;
            VAR release     : boolean);
 
VAR
      process_normally : boolean;
 
BEGIN
process_normally := false;
CASE rf OF
    f_local:
        CASE i01g^.vt.parms.key.key OF
            vt_escape_key:
                (* start pc mode *)
                BEGIN
                rf := f1;
                i01g^.vt.opt.first_line_changed := SCREEN_LINES_MXSP00;
                i01g^.vt.opt.last_line_changed := 0;
                i52pclabels(rf,interactive_menu, i52funclabel);
                release := (rf IN
                      i01g^.key_type.activated
                      - [  f_undo ] );
                END;
            vt_mouse_up:
                IF  i52callevel > 1
                THEN
                    process_normally := true
                ELSE
                    IF  i01g^.vt.parms.mouse_pos.screen_part = cin_ls_functionmenu
                    THEN
                        BEGIN
                        rf := f1;
                        i01g^.vt.opt.first_line_changed := SCREEN_LINES_MXSP00;
                        i01g^.vt.opt.last_line_changed := 0;
                        i52pclabels(rf,position_result_only, i52funclabel);
                        release := (rf IN
                              i01g^.key_type.activated
                              - [  f_undo ] );
                        END
                    ELSE
                        IF  mouse_on_scrollbar (rf)
                        THEN
                            release := true
                        ELSE
                            process_normally := true;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            OTHERWISE:
                process_normally := true;
            END;
        (*ENDCASE*) 
    f_undo: (* pc mode end *)
        release := true;
    OTHERWISE:
        process_normally := true;
    END;
(*ENDCASE*) 
(* process_pc_relkey *)
IF  process_normally
THEN
    BEGIN
    release := i01g^.vt.parms.key.key IN active_keys;
    i01g^.ls.fctline_cursor :=
          functioncursor_relmode(csr_pos);
    END;
(*ENDIF*) 
END; (* process_pc_relkey *)
 
(*------------------------------*) 
 
FUNCTION
      mouse_on_scrollbar (
            VAR rf          : tin_ls_releasemode) : boolean;
 
VAR
      ok    : boolean;
 
BEGIN
ok := (NOT i57lockhscroll) AND
      (f_hscroll IN i01g^.key_type.activated);
(* Inhibit this function if
      mouse_up was immediately preceeded
      by mouse_move *)
IF  ok
THEN
    ok := i56hscroll(i01g^.vt.parms.mouse_pos,
          i01g^.vt.parms.key.scroll_dir);
(*ENDIF*) 
IF  ok
THEN
    rf := f_hscroll
ELSE
    BEGIN
    ok := f_vscroll IN i01g^.key_type.activated;
    IF  ok
    THEN
        ok := i56vscroll(i01g^.vt.parms.mouse_pos,
              i01g^.vt.parms.key.scroll_dir);
    (*ENDIF*) 
    IF  ok
    THEN
        rf := f_vscroll;
    (*ENDIF*) 
    END;
(*ENDIF*) 
i57lockhscroll := false;
mouse_on_scrollbar := ok;
END; (* mouse_on_scrollbar *)
 
&endif
&ifdef WINDOWS
(*------------------------------*) 
 
PROCEDURE
      set_sysline(
            VAR hif : tsp00_HifParms);
 
VAR
      ok : boolean;
 
BEGIN
sqltsysline (i01g^.vt.vt_ref, 1, hif.sys_text, hif.sys_attr, ok );
IF  i01g^.ls.nr_screens > 1
THEN
    sqltsysline (i01g^.vt.vt_ref, 2, i56sysline2, i56sysatt2, ok );
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      remove_locked_vtkeys;
 
VAR
      lsk : tin_ls_releasemode;
      vtk : tsp00_VtKey;
 
BEGIN
FOR lsk := f1 TO f_end DO
    IF  NOT (lsk IN i01g^.key_type.activated)
    THEN
        BEGIN
        vtk := i52keytrans ( lsk );
        IF  vtk <> vt_unknown
        THEN
            WITH i01g^.vt DO
                opt.returnkeys := opt.returnkeys - [  vtk ] ;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i57updkeys ;
 
VAR
      active_keys : tsp00_VtKeys ;
      ok          : boolean;
 
BEGIN
i52activekeys( active_keys );
i01g^.vt.opt.returnkeys := active_keys;
sqltslabels ( i01g^.vt.vt_ref, i01g^.i50.hif.slabels, ok );
sqltreturnkeys ( i01g^.vt.vt_ref, i01g^.vt.opt.returnkeys, ok );
END;
 
&endif
(*------------------------------*) 
 
PROCEDURE
      i57screenmessed;
 
BEGIN
WITH i01g^.vt.opt DO
    BEGIN
    first_line_changed := SCREEN_LINES_MXSP00;
    last_line_changed := 0;
    END;
(*ENDWITH*) 
END; (* i57screenmessed *)
 
(*------------------------------*) 
 
PROCEDURE
      i57ioscreen (
            VAR csr_pos        : tin_ls_position;
            VAR rf             : tin_ls_releasemode;
            VAR screen_changed : boolean);
 
BEGIN
i57refioscreen ( csr_pos, rf, screen_changed, false );
END; (* i57ioscreen *)
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
