.CM  SCRIPT , Version - 1.1 , last edited by holger
.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VIN14$
.tt 2 $$$
.TT 3 $$standard_editor_functions$1998-06-17$
***********************************************************
.nf
 
.nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : standard_editor_functions
=========
.sp
Purpose : Standard operations to handle edit form:
          Read, write, insert, delete, copy, move of lines
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              i14cleareform (
                    VAR evars     : tin_eform_vars);
 
        PROCEDURE
              i14inserteline (
                    VAR eform        : tin_eform_buffer;
                    VAR evars        : tin_eform_vars;
                    line_nr          : tin_natural;
                    line_count       : tin_natural;
                    VAR error        : boolean);
 
        PROCEDURE
              i14deleteeline (
                    VAR eform        : tin_eform_buffer;
                    VAR evars        : tin_eform_vars;
                    line_nr          : tin_natural;
                    line_count       : tin_natural);
 
        PROCEDURE
              i14copyeline (
                    VAR eform      : tin_eform_buffer;
                    VAR evars      : tin_eform_vars;
                    source_nr      : tin_natural;
                    line_count     : tin_natural;
                    dest_nr        : tin_natural;
                    VAR error      : boolean);
 
        PROCEDURE
              i14moveeline (
                    VAR eform      : tin_eform_buffer;
                    VAR evars      : tin_eform_vars;
                    source_nr      : tin_natural;
                    dest_nr        : tin_natural;
                    line_count     : tin_natural;
                    VAR error      : boolean);
 
        PROCEDURE
              i14duplicateeline (
                    VAR eform      : tin_eform_buffer;
                    VAR evars      : tin_eform_vars;
                    line_nr        : tin_natural;
                    line_count     : tin_natural;
                    is_block       : boolean;
                    VAR error      : boolean);
 
        PROCEDURE
              i14shifteline (
                    VAR eform   : tin_eform_buffer;
                    VAR evars   : tin_eform_vars;
                    line_nr     : tin_natural;
                    line_count  : tin_natural;
                    shift_count : tin_natural;
                    right       : boolean;
                    max_cols    : tin_natural;
                    VAR error   : boolean);
 
        PROCEDURE
              i14geteline (
                    VAR eform     : tin_eform_buffer;
                    VAR evars     : tin_eform_vars;
                    VAR line      : tin_eline;
                    line_nr       : tin_natural;
                    VAR length    : tin_natural;
                    VAR error     : boolean);
 
        PROCEDURE
              i14get1eline (
                    VAR eform     : tin_eform_buffer;
                    VAR evars     : tin_eform_vars;
                    VAR line      : tin_eline;
                    line_nr       : tin_natural;
                    VAR length    : tin_natural;
                    VAR error     : boolean);
 
        PROCEDURE
              i14puteline (
                    VAR eform     : tin_eform_buffer;
                    VAR evars     : tin_eform_vars;
                    VAR line      : tin_eline;
                    line_nr       : tin_natural;
                    length        : tin_natural;
                    VAR error     : boolean);
 
        PROCEDURE
              i14put1eline (
                    VAR eform     : tin_eform_buffer;
                    VAR evars     : tin_eform_vars;
                    VAR line      : tin_eline;
                    line_nr       : tin_natural;
                    length        : tin_natural;
                    VAR error     : boolean);
 
        PROCEDURE
              i14insblock (
                    VAR eform      : tin_eform_buffer;
                    VAR evars      : tin_eform_vars;
                    line1          : tin_natural;
                    line2          : tin_natural;
                    scol1          : tin_natural;
                    scol2          : tin_natural;
                    max_cols       : tin_natural;
                    VAR error      : boolean);
 
        PROCEDURE
              i14delblock (
                    VAR eform      : tin_eform_buffer;
                    VAR evars      : tin_eform_vars;
                    line1          : tin_natural;
                    line2          : tin_natural;
                    scol1          : tin_natural;
                    scol2          : tin_natural);
 
        PROCEDURE
              i14splitjoin (
                    VAR eform      : tin_eform_buffer;
                    VAR evars      : tin_eform_vars;
                    line_no        : tin_natural;
                    scol           : tin_natural;
                    max_cols       : tin_natural;
                    VAR error      : boolean);
 
        PROCEDURE
              i14sojsplitorjoin (
                    VAR eform      : tin_eform_buffer;
                    VAR evars      : tin_eform_vars;
                    line_no        : tin_natural;
                    scol           : tin_natural;
                    VAR only_split : boolean;
                    VAR only_join  : boolean;
                    max_cols       : tin_natural;
                    VAR error      : boolean);
 
        PROCEDURE
              i14setuplinecount (
                    VAR eform     : tin_eform_buffer;
                    VAR evars     : tin_eform_vars);
 
        PROCEDURE
              i14trunceform (
                    VAR eform    : tin_eform_buffer;
                    VAR evars    : tin_eform_vars;
                    newlength    : tin_natural );
 
        FUNCTION
              i14linelength (
                    VAR eform   : tin_eform_buffer;
                    VAR evars   : tin_eform_vars;
                    line_nr     : tin_natural) : tin_natural;
 
        PROCEDURE
              i14lineinfo (
                    VAR eform   : tin_eform_buffer;
                    VAR evars   : tin_eform_vars;
                    line_nr     : tin_natural;
                    VAR blanks  : tin_natural;
                    VAR chars   : tin_natural );
 
        PROCEDURE
              i14findactpos(
                    VAR eform    : tin_eform_buffer;
                    VAR  evars   : tin_eform_vars;
                    line         : tin_natural;
                    VAR error    : boolean);
 
        FUNCTION
              i14lolen_overflow (
                    VAR eform     : tin_eform_buffer;
                    VAR evars     : tin_eform_vars;
                    VAR this      : tin_natural;
                    VAR max_lnlen : tin_natural ) : boolean;
 
        FUNCTION
              i14clcut_line (
                    VAR eform     : tin_eform_buffer;
                    VAR evars     : tin_eform_vars;
                    VAR max_lnlen : tin_natural ) : boolean;
 
        PROCEDURE
              i14expand_eform (
                    VAR eform     : tin_eform_buffer;
                    VAR evars     : tin_eform_vars;
                    max_cols      : tin_natural;
                    VAR error     : boolean);
 
        PROCEDURE
              i14reduce_eform (
                    VAR eform     : tin_eform_buffer;
                    VAR evars     : tin_eform_vars;
                    max_cols      : tin_natural;
                    VAR error     : boolean);
 
        PROCEDURE
              i14itoa (
                    VAR eform    : tin_eform_buffer;
                    VAR evars    : tin_eform_vars);
 
        PROCEDURE
              i14atoi (
                    VAR eform    : tin_eform_buffer;
                    VAR evars    : tin_eform_vars);
 
        FUNCTION
              i14ischar_eform (
                    VAR eform : tin_eform_buffer;
                    VAR evars : tin_eform_vars) : boolean;
 
        FUNCTION
              in1430 : tsp00_Int4;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedOverlappingMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              m90buf;
 
              tsp00_Buf tin_eform_buffer
 
        PROCEDURE
              m90buf1;
 
              tsp00_Buf tin_eline
 
        PROCEDURE
              m90int;
 
              integer tin_natural
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1986-11-12
.sp
.cp 3
.sp
.cp 3
Release :      Date : 1998-06-17
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.nf
PROCEDURE
      i14expand_eform (
            VAR eform     : tin_eform_buffer;
            VAR evars     : tin_eform_vars;
            max_cols      : tin_natural;
            VAR error     : boolean);
.fo;.sp
Aufloesung die Zeilendarstellung des Editorformulars :
i14expand_eform fuellt die Zeilen mit Blanks auf die Laenge max_cols auf
und setzt sie hintereinanter in eform.
.sp 2;.nf
PROCEDURE
      i14reduce_eform (
            VAR eform     : tin_eform_buffer;
            VAR evars     : tin_eform_vars;
            max_cols      : tin_natural;
            VAR error     : boolean);
.fo;.sp
Herstellen der Zeilendarstellung des Editorformulars aus einem mit
i14expand umgestellten Editorformulars:
i14expand_eform zerlegt eform in Zeilen der Laenge max_cols und
loescht fuehrende und folgende Blanks (eform Darstellung).
.sp 2;.nf
FUNCTION i14clcut_line (
            VAR eform     : tin_eform_buffer;
            VAR evars     : tin_eform_vars;
            VAR max_lnlen : tin_natural ) : boolean;
.fo;.sp
Abschneiden aller Zeilen in eform auf die Laenge max_lnlen.
.sp 2;.nf
FUNCTION
      i14lolen_overflow (
            VAR eform     : tin_eform_buffer;
            VAR evars     : tin_eform_vars;
            VAR this      : tin_natural;
            VAR max_lnlen : tin_natural ) : boolean;
.fo;.sp
Prueft die Zeilenlaenge:
Es wird i14lolen_overflow als false zurueckgeliefert und this als
Zeile, wenn die Laenge einer Zeile > max_lnlen ist
(Beginnend bei Zeile 1).
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.sp 2;.nf
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
(*------------------------------*) 
 
FUNCTION
      in1430 : tsp00_Int4;
 
BEGIN
(* linkcheck function *)
in1430 := 219020330;
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14cleareform (
            VAR evars     : tin_eform_vars);
 
BEGIN
WITH evars DO
    BEGIN
    elength     := 0;
    lines       := 0;
    act_pos     := 0;
    act_line    := 0;
    text_offset := 2;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14duplicateeline (
            VAR eform      : tin_eform_buffer;
            VAR evars      : tin_eform_vars;
            line_nr        : tin_natural;
            line_count     : tin_natural;
            is_block       : boolean;
            VAR error      : boolean);
 
VAR
      new_line_nr    : tin_natural;
      line           : tin_eline;
      length         : tin_natural;
      geterror       : boolean;
 
BEGIN
error := false;
IF  line_nr <= evars.lines
THEN
    BEGIN
    IF  is_block
    THEN
        new_line_nr := line_nr + line_count
    ELSE
        new_line_nr := line_nr + 1;
    (*ENDIF*) 
    enough_space(eform,evars,line_nr,line_count,is_block,error);
    IF  NOT error
    THEN
        BEGIN
        i14inserteline(eform,evars,new_line_nr,line_count,error);
        IF  is_block
        THEN
            REPEAT
                i14geteline(eform,evars,line,line_nr,
                      length,geterror);
                i14puteline(eform,evars,line,new_line_nr,
                      length,error);
                line_nr := line_nr + 1;
                new_line_nr := new_line_nr + 1;
                line_count := line_count - 1;
            UNTIL
                (line_count = 0) OR error
            (*ENDREPEAT*) 
        ELSE
            BEGIN
            i14geteline(eform,evars,line,line_nr,length,geterror);
            REPEAT
                i14puteline(eform,evars,line,new_line_nr,
                      length,error);
                new_line_nr := new_line_nr + 1;
                line_count := line_count - 1;
            UNTIL
                (line_count = 0) OR error
            (*ENDREPEAT*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14shifteline (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            line_nr     : tin_natural;
            line_count  : tin_natural;
            shift_count : tin_natural;
            right       : boolean;
            max_cols    : tin_natural;
            VAR error   : boolean);
 
VAR
      line_length     : tin_natural;
      blank_count     : tin_natural;
      pos             : tin_natural;
 
BEGIN
WITH evars DO
    BEGIN
    i14findactpos(eform,evars,line_nr,error);
    IF  NOT error
    THEN
        BEGIN
        pos := act_pos;
        IF  line_nr + line_count - 1 > lines
        THEN
            line_count := lines - line_nr + 1;
        (*ENDIF*) 
        REPEAT
            blank_count := ord(eform [pos + 1] );
            line_length := ord(eform [pos]) - text_offset +
                  blank_count;
            IF  right
            THEN
                IF  line_length + shift_count > max_cols
                THEN
                    blank_count := max_cols -
                          line_length + blank_count
                ELSE
                    blank_count := blank_count + shift_count
                (*ENDIF*) 
            ELSE
                IF  shift_count > blank_count
                THEN
                    blank_count := 0
                ELSE
                    blank_count := blank_count - shift_count;
                (*ENDIF*) 
            (*ENDIF*) 
            eform [pos + 1 ] := chr(blank_count);
            pos := pos + ord(eform [pos] );
            line_count := line_count - 1;
        UNTIL
            line_count = 0;
        (*ENDREPEAT*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14geteline (
            VAR eform     : tin_eform_buffer;
            VAR evars     : tin_eform_vars;
            VAR line      : tin_eline;
            line_nr       : tin_natural;
            VAR length    : tin_natural;
            VAR error     : boolean);
 
VAR
      blanks      : tin_natural;
      e_pos       : tin_natural;
      l_pos       : tin_natural;
 
BEGIN
WITH evars DO
    BEGIN
    i14findactpos(eform,evars,line_nr,error);
    IF  NOT error
    THEN
        BEGIN
        length := ord(eform [act_pos] ) - text_offset;
        blanks := ord(eform [act_pos + 1] );
        l_pos := 1;
        e_pos := act_pos + text_offset;
        SAPDB_PascalForcedFill(mxin_eline,@line,l_pos,blanks,' ');
        l_pos := l_pos + blanks;
        s10mv(size,mxin_eline,
              @eform,e_pos,
              @line,l_pos,length);
        length := length + blanks;
        END
    ELSE
        length := 0;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14put1eline (
            VAR eform     : tin_eform_buffer;
            VAR evars     : tin_eform_vars;
            VAR line      : tin_eline;
            line_nr       : tin_natural;
            length        : tin_natural;
            VAR error     : boolean);
 
BEGIN
i14puteline (eform,evars,line,line_nr,length,error);
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14get1eline (
            VAR eform     : tin_eform_buffer;
            VAR evars     : tin_eform_vars;
            VAR line      : tin_eline;
            line_nr       : tin_natural;
            VAR length    : tin_natural;
            VAR error     : boolean);
 
BEGIN
i14geteline (eform,evars,line,line_nr,length,error);
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14puteline (
            VAR eform     : tin_eform_buffer;
            VAR evars     : tin_eform_vars;
            VAR line      : tin_eline;
            line_nr       : tin_natural;
            length        : tin_natural;
            VAR error     : boolean);
 
VAR
      length_overflow : boolean;
 
BEGIN
length_overflow := false;
IF  length > mxin_eline
THEN
    BEGIN
    length := mxin_eline;
    length_overflow := true;
    END;
(*ENDIF*) 
i14ineline ( eform, evars, line, line_nr, length, error );
IF  length_overflow
THEN
    error := true;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14ineline (
            VAR eform     : tin_eform_buffer;
            VAR evars     : tin_eform_vars;
            VAR line      : tin_eline;
            line_nr       : tin_natural;
            length        : tin_natural;
            VAR error     : boolean);
 
VAR
      fill_count      : tin_natural;
      blank_count     : tin_natural;
      old_len         : tin_natural;
 
BEGIN
WITH evars DO
    BEGIN
    i14findactpos(eform,evars,line_nr,error);
    kill_blanks(line,length,blank_count);
    IF  error
    THEN
        BEGIN
        error := false;
        IF  length > 0
        THEN
            BEGIN
            fill_count := (line_nr - lines - 1);
            IF  elength + (fill_count * text_offset)
                + length + text_offset > size
            THEN
                error := true
            ELSE
                BEGIN
                act_pos := elength + 1;
                IF  fill_count > 0
                THEN
                    REPEAT
                        eform [act_pos ] := chr(text_offset);
                        eform [act_pos + 1 ] := chr(0);
                        elength := elength + text_offset;
                        act_pos := act_pos + text_offset;
                        fill_count := fill_count - 1;
                    UNTIL
                        fill_count = 0;
                    (*ENDREPEAT*) 
                (*ENDIF*) 
                eform [act_pos ] := chr(length + text_offset);
                eform [act_pos + 1 ] := chr(blank_count);
                s10mv(mxin_eline,size,
                      @line,blank_count + 1,
                      @eform,act_pos+text_offset,length);
                elength := elength + length + text_offset;
                lines := line_nr;
                act_line := lines;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        length := length + text_offset;
        old_len := ord(eform [act_pos] );
        IF  old_len > length
        THEN
            del1space(size,eform,elength,act_pos + length,
                  old_len - length);
        (*ENDIF*) 
        IF  old_len < length
        THEN
            IF  length - old_len + elength > size
            THEN
                error := true
            ELSE
                addspace_14(size,eform,elength,act_pos + old_len,
                      length - old_len);
            (*ENDIF*) 
        (*ENDIF*) 
        IF  NOT error
        THEN
            BEGIN
            eform [act_pos ] := chr(length);
            eform [act_pos + 1 ] := chr(blank_count);
            s10mv(mxin_eline,size,
                  @line,blank_count + 1,
                  @eform,act_pos + text_offset,length - text_offset);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14inserteline (
            VAR eform        : tin_eform_buffer;
            VAR evars        : tin_eform_vars;
            line_nr          : tin_natural;
            line_count       : tin_natural;
            VAR error        : boolean);
 
VAR
      fill_count  : tin_natural;
 
BEGIN
WITH evars DO
    BEGIN
    i14findactpos(eform,evars,line_nr,error);
    IF  error
    THEN
        error := false
    ELSE
        BEGIN
        fill_count := line_count * text_offset;
        IF  fill_count + elength > size
        THEN
            error := true;
        (*ENDIF*) 
        IF  NOT error
        THEN
            BEGIN
            addspace_14(size,eform,elength,act_pos,fill_count);
            lines := lines + line_count;
            REPEAT
                eform [act_pos ] := chr(text_offset);
                eform [act_pos + 1 ] := chr(0);
                act_pos := act_pos + text_offset;
                act_line := act_line + 1;
                line_count := line_count - 1;
            UNTIL
                line_count = 0;
            (*ENDREPEAT*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14deleteeline (
            VAR eform    : tin_eform_buffer;
            VAR evars    : tin_eform_vars;
            line_nr      : tin_natural;
            line_count   : tin_natural);
 
VAR
      error     : boolean;
 
BEGIN
WITH evars DO
    BEGIN
    i14findactpos(eform,evars,line_nr,error);
    IF  NOT error
    THEN
        BEGIN
        IF  line_count + act_line > lines
        THEN
            BEGIN
            elength := act_pos - 1;
            lines := act_line - 1;
            IF  lines = 0
            THEN
                BEGIN
                act_pos := 0;
                act_line := 0;
                END
            ELSE
                BEGIN
                act_pos := 1;
                act_line := 1;
                END;
            (*ENDIF*) 
            END
        ELSE
            REPEAT
                del1space(size,eform,elength,act_pos,
                      ord(eform [act_pos] ));
                lines := lines - 1;
                line_count := line_count - 1;
            UNTIL
                line_count = 0;
            (*ENDREPEAT*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14copyeline (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            source_nr   : tin_natural;
            line_count  : tin_natural;
            dest_nr     : tin_natural;
            VAR error   : boolean);
 
VAR
      line           : tin_eline;
      length         : tin_natural;
      geterror       : boolean;
 
BEGIN
error := false;
IF  (source_nr <= evars.lines) OR (dest_nr <= evars.lines)
THEN
    BEGIN
    enough_space(eform,evars,source_nr,line_count,true,error);
    IF  NOT error
    THEN
        BEGIN
        i14inserteline(eform,evars,dest_nr,line_count,error);
        IF  dest_nr <=  source_nr
        THEN
            source_nr := source_nr + line_count;
        (*ENDIF*) 
        REPEAT
            i14geteline(eform,evars,line,source_nr,
                  length,geterror);
            i14puteline(eform,evars,line,dest_nr,length,error);
            source_nr := source_nr + 1;
            dest_nr := dest_nr + 1;
            line_count := line_count - 1
        UNTIL
            (line_count = 0) OR error;
        (*ENDREPEAT*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      enough_space (
            VAR eform      : tin_eform_buffer;
            VAR evars      : tin_eform_vars;
            source_nr      : tin_natural;
            line_count     : tin_natural;
            is_block       : boolean;
            VAR error      : boolean);
 
VAR
      h_space          : tin_natural;
 
BEGIN
source_nr := source_nr;
line_count := line_count;
h_space := 0;
IF  is_block
THEN
    REPEAT
        IF  source_nr > evars.lines
        THEN
            h_space := h_space + evars.text_offset
        ELSE
            BEGIN
            i14findactpos(eform,evars,source_nr,error);
            h_space := h_space + ord(eform [evars.act_pos] );
            END;
        (*ENDIF*) 
        source_nr := source_nr + 1;
        line_count := line_count - 1
    UNTIL
        line_count = 0
    (*ENDREPEAT*) 
ELSE
    BEGIN
    i14findactpos(eform,evars,source_nr,error);
    h_space := ord(eform [evars.act_pos] ) * line_count;
    END;
(*ENDIF*) 
error :=   h_space + evars.elength > evars.size;
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14moveeline (
            VAR eform      : tin_eform_buffer;
            VAR evars      : tin_eform_vars;
            source_nr      : tin_natural;
            dest_nr        : tin_natural;
            line_count     : tin_natural;
            VAR error      : boolean);
 
VAR
      line           : tin_eline;
      length         : tin_natural;
      new_space      : tin_natural;
      geterror       : boolean;
 
BEGIN
error := false;
new_space := 0;
IF  (source_nr <= evars.lines) OR (dest_nr <= evars.lines)
THEN
    BEGIN
    IF  source_nr + line_count - 1 > evars.lines
    THEN
        new_space := source_nr + line_count - 1 - evars.lines;
    (*ENDIF*) 
    IF  evars.elength + evars.text_offset * new_space > evars.size
    THEN
        error := true;
    (*ENDIF*) 
    IF  NOT error
    THEN
        REPEAT
            i14geteline(eform,evars,line,source_nr,length,geterror);
            i14deleteeline(eform,evars,source_nr,1);
            IF  source_nr < dest_nr
            THEN
                BEGIN
                source_nr := source_nr - 1;
                dest_nr := dest_nr - 1;
                END;
            (*ENDIF*) 
            i14inserteline(eform,evars,dest_nr,1,error);
            i14puteline(eform,evars,line,dest_nr,length,error);
            source_nr := source_nr + 1;
            dest_nr := dest_nr + 1;
            line_count := line_count - 1
        UNTIL
            (line_count = 0) OR error;
        (*ENDREPEAT*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14insblock (
            VAR eform      : tin_eform_buffer;
            VAR evars      : tin_eform_vars;
            line1          : tin_natural;
            line2          : tin_natural;
            scol1          : tin_natural;
            scol2          : tin_natural;
            max_cols       : tin_natural;
            VAR error      : boolean);
 
VAR
      fill_count  : tin_natural;
      blank_count : tin_natural;
      i           : tin_natural;
 
BEGIN
WITH evars DO
    BEGIN
    i14findactpos(eform,evars,line1,error);
    IF  error
    THEN
        error := false
    ELSE
        BEGIN
        IF  line2 > lines
        THEN
            line2 := lines;
        (*ENDIF*) 
        fill_count := (scol2 - scol1) * (line2 - line1 + 1);
        IF  fill_count + elength > size
        THEN
            error := true;
        (*ENDIF*) 
        IF  NOT error
        THEN
            FOR i := line1 TO line2 DO
                IF   (scol1 <= i14linelength(eform,evars,i)) AND
                    (i14linelength(eform,evars,i) +
                    scol2 - scol1 > max_cols)
                THEN
                    error := true;
                (*ENDIF*) 
            (*ENDFOR*) 
        (*ENDIF*) 
        IF  NOT error
        THEN
            BEGIN
            fill_count := scol2 - scol1;
            FOR i := line1 TO line2 DO
                BEGIN
                i14findactpos(eform,evars,i,error);
                blank_count := ord(eform [act_pos + 1] );
                IF  scol1 <= blank_count + ord(eform [act_pos] )
                    - text_offset
                THEN
                    IF  scol1 <= blank_count + 1
                    THEN
                        BEGIN
                        blank_count := blank_count + fill_count;
                        eform [act_pos + 1 ] := chr(blank_count);
                        END
                    ELSE
                        BEGIN
                        addspace_14(size,eform,elength,act_pos +
                              scol1 + 1 - blank_count,
                              fill_count);
                        SAPDB_PascalForcedFill(size,@eform,
                              act_pos + scol1 + 1 -
                              blank_count,fill_count,' ');
                        eform [act_pos ] := chr(fill_count +
                              ord(eform [act_pos] ));
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14delblock (
            VAR eform      : tin_eform_buffer;
            VAR evars      : tin_eform_vars;
            line1          : tin_natural;
            line2          : tin_natural;
            scol1          : tin_natural;
            scol2          : tin_natural);
 
VAR
      del_count   : tin_natural;
      line_length : tin_natural;
      i           : tin_natural;
      line        : tin_eline;
      error       : boolean;
 
BEGIN
WITH evars DO
    BEGIN
    i14findactpos(eform,evars,line1,error);
    IF  error
    THEN
        error := false
    ELSE
        BEGIN
        IF  line2 > lines
        THEN
            line2 := lines;
        (*ENDIF*) 
        del_count := scol2 - scol1;
        FOR i := line1 TO line2 DO
            BEGIN
            i14geteline(eform,evars,line,i,line_length,error);
            IF  scol1 <= line_length
            THEN
                BEGIN
                del_count := scol2 - scol1;
                IF  scol1 + del_count - 1 > line_length
                THEN
                    del_count := line_length - scol1 + 1;
                (*ENDIF*) 
                del2space(mxin_eline,line,line_length,scol1,del_count);
                i14puteline(eform,evars,line,i,line_length,error);
                END;
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14splitjoin (
            VAR eform      : tin_eform_buffer;
            VAR evars      : tin_eform_vars;
            line_no        : tin_natural;
            scol           : tin_natural;
            max_cols       : tin_natural;
            VAR error      : boolean);
 
VAR
      only_split : boolean;
      only_join  : boolean;
 
BEGIN
only_split := false;
only_join  := false;
i14sojsplitorjoin ( eform, evars, line_no, scol, only_split, only_join,
      max_cols, error );
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14sojsplitorjoin (
            VAR eform      : tin_eform_buffer;
            VAR evars      : tin_eform_vars;
            line_no        : tin_natural;
            scol           : tin_natural;
            VAR only_split : boolean;
            VAR only_join  : boolean;
            max_cols       : tin_natural;
            VAR error      : boolean);
 
VAR
      len         : tin_natural;
      line        : tin_eline;
 
BEGIN
WITH evars DO
    BEGIN
    i14findactpos(eform,evars,line_no,error);
    IF  error
    THEN
        error := false
    ELSE
        BEGIN
        i14geteline(eform,evars,line,line_no,len,error);
        IF  scol <= len
        THEN
            BEGIN
            IF  only_join
            THEN
                BEGIN
                scol := len + 1;
                i14join ( eform, evars, line, line_no, scol, len, max_cols,
                      error )
                END
            ELSE
                BEGIN
                i14split ( eform, evars, line, line_no, scol, len, error )
                END;
            (*ENDIF*) 
            END
        ELSE
            IF  NOT only_split
            THEN
                i14join ( eform, evars, line, line_no, scol, len, max_cols,
                      error );
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14join (
            VAR eform      : tin_eform_buffer;
            VAR evars      : tin_eform_vars;
            VAR line       : tin_eline;
            line_no        : tin_natural;
            scol           : tin_natural;
            len            : tin_natural;
            max_cols       : tin_natural;
            VAR error      : boolean);
 
VAR
      joinlen     : tin_natural;
      len1        : tin_natural;
      line1       : tin_eline;
      error1      : boolean;
 
BEGIN
i14findactpos(eform,evars,line_no + 1,error1);
IF  NOT error1
THEN
    eform [evars.act_pos + 1 ] := chr(0);
(*ENDIF*) 
i14geteline(eform,evars,line1,line_no + 1,len1,error1);
IF  NOT error1
THEN
    BEGIN
    SAPDB_PascalForcedFill(mxin_eline,@line,len + 1,max_cols - len,' ');
    IF  scol + len1 - 1 > max_cols
    THEN
        joinlen := max_cols - scol + 1
    ELSE
        joinlen := len1;
    (*ENDIF*) 
    s10mv(mxin_eline,mxin_eline,
          @line1,1,
          @line,scol,joinlen);
    len := scol + joinlen - 1;
    i14puteline(eform,evars,line,line_no,len,error);
    IF  NOT error
    THEN
        IF  joinlen = len1
        THEN
            BEGIN
            i14deleteeline(eform,evars,line_no + 1,1);
            END
        ELSE
            BEGIN
            s10mv (mxin_eline,mxin_eline,
                  @line1,joinlen + 1,
                  @line,1,len1 - joinlen );
            len1 := len1 - joinlen;
            i14puteline(eform,evars,line,
                  line_no + 1,len1,error);
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14split (
            VAR eform      : tin_eform_buffer;
            VAR evars      : tin_eform_vars;
            VAR line       : tin_eline;
            line_no        : tin_natural;
            scol           : tin_natural;
            len            : tin_natural;
            VAR error      : boolean);
 
VAR
      blanks      : char;
 
BEGIN
WITH evars DO
    BEGIN
    IF  elength + text_offset > size
    THEN
        error := true
    ELSE
        BEGIN
        blanks := eform [evars.act_pos + 1] ;
        i14puteline(eform,evars,line,line_no,scol - 1,error);
        s10mv(mxin_eline,mxin_eline,
              @line,scol,
              @line,1,len - scol + 1);
        i14inserteline(eform,evars,line_no + 1,1,error);
        i14puteline(eform,evars,line,line_no + 1,
              len - scol + 1,error);
        eform [evars.act_pos + 1 ] := blanks;
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14setuplinecount (
            VAR eform    : tin_eform_buffer;
            VAR evars    : tin_eform_vars);
 
VAR
      pos           : tin_natural;
      new_elength   : tin_natural;
      new_lines     : tin_natural;
      end_found     : boolean;
      error         : boolean;
 
BEGIN
WITH evars DO
    BEGIN
    error := false;
    lines := 0;
    IF  elength > 0
    THEN
        BEGIN
        pos := 1;
        new_elength := 0;
        new_lines := 0;
        end_found := false;
        IF  (act_line = 0) AND (act_pos = 0)
        THEN
            BEGIN
            act_line := 1;
            act_pos := 1;
            END;
        (*ENDIF*) 
        REPEAT
            IF  (ord(eform [pos] ) > mxin_eline + text_offset) OR
                (ord(eform [pos + 1] ) > mxin_eline)
            THEN
                error := true
            ELSE
                BEGIN
                IF  (ord(eform [pos] ) = text_offset) AND NOT end_found
                THEN
                    BEGIN
                    end_found := true;
                    new_elength := pos - 1;
                    new_lines := lines;
                    END
                ELSE
                    IF  ord(eform [pos] ) > text_offset
                    THEN
                        end_found := false
                    ELSE
                        IF  ord(eform [pos] ) = 0
                        THEN
                            error := true;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                lines := lines + 1;
                pos := pos + ord(eform [pos] );
                END;
            (*ENDIF*) 
        UNTIL
            (pos >= elength) OR (pos >= size)  OR error;
        (*ENDREPEAT*) 
        IF  error
        THEN
            BEGIN
            elength := 0;
            lines := 0;
            END
        ELSE
            IF  end_found
            THEN
                BEGIN
                elength := new_elength;
                lines := new_lines;
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  act_line > lines
        THEN
            IF  lines > 0
            THEN
                BEGIN
                act_line := 1;
                act_pos := 1;
                END
            ELSE
                BEGIN
                act_line := 0;
                act_pos := 0;
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        act_line := 0;
        act_pos := 0;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14trunceform (
            VAR eform    : tin_eform_buffer;
            VAR evars    : tin_eform_vars;
            newlength    : tin_natural );
 
VAR
      pos           : tin_natural;
      error         : boolean;
      new_elength   : tin_natural;
      new_lines     : tin_natural;
 
BEGIN
WITH evars DO
    BEGIN
    error := false;
    lines := 0;
    IF  elength > 0
    THEN
        BEGIN
        pos := 1;
        new_elength := 0;
        new_lines := 0;
        IF  (act_line = 0) AND (act_pos = 0)
        THEN
            BEGIN
            act_line := 1;
            act_pos := 1;
            END;
        (*ENDIF*) 
        WHILE (pos < elength) AND (pos < size)  AND NOT error
              AND (pos < newlength - text_offset) DO
            BEGIN
            IF  (ord(eform [pos] ) > mxin_eline + text_offset) OR
                (ord(eform [pos + 1] ) > mxin_eline) OR
                (ord(eform [pos] ) = 0)
            THEN
                error := true
            ELSE
                BEGIN
                new_elength := pos - 1;
                new_lines := lines;
                lines := lines + 1;
                pos := pos + ord(eform [pos] );
                END;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        IF  error
        THEN
            BEGIN
            elength := 0;
            lines := 0;
            END
        ELSE
            BEGIN
            eform [pos + 1] := chr (text_offset);
            eform [pos + 2] := chr (0);
            elength := new_elength + text_offset;
            lines := new_lines + 1;
            END;
        (*ENDIF*) 
        IF  act_line > lines
        THEN
            IF  lines > 0
            THEN
                BEGIN
                act_line := 1;
                act_pos := 1;
                END
            ELSE
                BEGIN
                act_line := 0;
                act_pos := 0;
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        act_line := 0;
        act_pos := 0;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14itoa (
            VAR eform    : tin_eform_buffer;
            VAR evars    : tin_eform_vars);
 
VAR
      pos           : tin_natural;
      save_pos      : tin_natural;
      blanks        : tin_natural;
      length        : tin_natural;
      i             : integer;
 
BEGIN
pos := 1;
WITH evars DO
    BEGIN
    WHILE (pos < elength) AND (pos < size) DO
        BEGIN
        save_pos := pos;
        length := ord(eform [pos]);
        blanks := ord(eform [pos + 1]);
        pos := pos + length;
        SAPDB_PascalForcedFill ( size, @eform, save_pos, text_offset, '0' );
        i := 2;
        REPEAT
            eform [save_pos+i] := chr (ord ('0') + (length MOD 10));
            length := length DIV 10;
            i := i - 1;
        UNTIL
            length = 0;
        (*ENDREPEAT*) 
        i := 5;
        REPEAT
            eform [save_pos+i] := chr (ord ('0') + (blanks MOD 10));
            blanks := blanks DIV 10;
            i := i - 1;
        UNTIL
            blanks = 0;
        (*ENDREPEAT*) 
        END;
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14atoi (
            VAR eform    : tin_eform_buffer;
            VAR evars    : tin_eform_vars);
 
VAR
      pos           : tin_natural;
      blanks        : tin_natural;
      length        : tin_natural;
 
BEGIN
pos := 1;
WITH evars DO
    BEGIN
    WHILE (pos < elength) AND (pos < size) DO
        BEGIN
        length := (ord(eform [pos]) - ord('0')) * 100 +
              (ord(eform [pos+1]) - ord('0')) * 10 +
              (ord(eform [pos+2]) - ord('0'));
        blanks := (ord(eform [pos+3]) - ord('0')) * 100 +
              (ord(eform [pos+4]) - ord('0')) * 10 +
              (ord(eform [pos+5]) - ord('0'));
        SAPDB_PascalForcedFill ( size, @eform, pos, text_offset, '0' );
        eform [pos]   := chr(length);
        eform [pos+1] := chr(blanks);
        pos := pos + length;
        END;
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      i14ischar_eform (
            VAR eform : tin_eform_buffer;
            VAR evars : tin_eform_vars) : boolean;
 
VAR
      blanks    : tin_natural;
      length    : tin_natural;
      i         : integer;
      length_ok : boolean;
      blanks_ok : boolean;
 
BEGIN
length_ok := true;
length    := 0;
FOR i := 1 TO 3 DO
    IF  eform[i] in [ '0'..'9' ]
    THEN
        length := (length * 10) + (ord(eform [i]) - ord('0'))
    ELSE
        length_ok := false;
    (*ENDIF*) 
(*ENDFOR*) 
blanks_ok := true;
blanks   := 0;
FOR i := 4 TO 6 DO
    IF  eform[i] in [ '0'..'9' ]
    THEN
        blanks := (blanks * 10) + (ord(eform [i]) - ord('0'))
    ELSE
        blanks_ok := false;
    (*ENDIF*) 
(*ENDFOR*) 
i14ischar_eform := length_ok AND blanks_ok
      AND (length <= mxin_eline + evars.text_offset)
      AND (blanks <= mxin_eline);
END; (* i14ischar_eform *)
 
(*------------------------------*) 
 
FUNCTION
      i14linelength (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            line_nr     : tin_natural) : tin_natural;
 
VAR
      chars  : tin_natural;
      blanks : tin_natural;
 
BEGIN
i14lineinfo ( eform, evars, line_nr, blanks, chars );
i14linelength := blanks + chars;
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14lineinfo (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            line_nr     : tin_natural;
            VAR blanks  : tin_natural;
            VAR chars   : tin_natural );
 
VAR
      error   : boolean;
 
BEGIN
i14findactpos(eform,evars,line_nr,error);
IF  error
THEN
    BEGIN
    blanks := 0;
    chars  := 0;
    END
ELSE
    BEGIN
    chars  := ord(eform [evars.act_pos] ) - evars.text_offset;
    blanks := ord(eform [evars.act_pos + 1] );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14findactpos(
            VAR eform     : tin_eform_buffer;
            VAR  evars    : tin_eform_vars;
            line          : tin_natural;
            VAR error     : boolean);
 
VAR
      i      :    tin_natural;
      offset :    tin_natural;
 
BEGIN
WITH evars DO
    BEGIN
    error := false;
    IF  (line > lines) OR (line = 0) OR (act_line = 0)
    THEN
        error := true;
    (*ENDIF*) 
    IF  NOT error
    THEN
        BEGIN
        IF  line < act_line
        THEN
            BEGIN
            act_line := 1;
            act_pos := 1;
            END;
        (*ENDIF*) 
        offset := line - act_line;
        FOR i := 1 TO offset DO
            BEGIN
            act_pos := act_pos + ord(eform [act_pos] );
            act_line := act_line + 1;
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      del1space (
            size          : tin_natural;
            VAR buf       : tin_eform_buffer;
            VAR buflength : tin_natural;
            pos,minus     : integer);
 
BEGIN
s10mv (size,size,
      @buf,pos+minus,
      @buf,pos,buflength-pos-minus+1);
buflength := buflength - minus;
END;
 
(*------------------------------*) 
 
PROCEDURE
      del2space (
            size          : tin_natural;
            VAR buf       : tin_eline;
            VAR buflength : tin_natural;
            pos,minus     : integer);
 
BEGIN
s10mv (size,size,
      @buf,pos+minus,
      @buf,pos,buflength-pos-minus+1);
buflength := buflength - minus;
END;
 
(*------------------------------*) 
 
PROCEDURE
      addspace_14 (
            size          : tin_natural;
            VAR buf       : tin_eform_buffer;
            VAR buflength : tin_natural;
            pos,plus      : integer);
 
BEGIN
IF  pos + plus > buflength
THEN
    s10mv (size,size,
          @buf,pos,
          @buf,pos+plus,buflength-pos + 1)
ELSE
    SAPDB_PascalForcedOverlappingMove (size,size,@buf,pos,@buf,pos+plus,buflength-pos + 1);
(*ENDIF*) 
buflength := buflength + plus
END;
 
(*------------------------------*) 
 
PROCEDURE
      kill_blanks (
            VAR line  : tin_eline;
            VAR len   : tin_natural;
            VAR count : tin_natural);
 
VAR
      pos        :  tin_natural;
      char_found : boolean;
 
BEGIN
pos := 1;
count := 0;
char_found := false;
REPEAT
    IF  (line [pos ] = ' ') AND (pos <= len)
    THEN
        BEGIN
        count := count + 1;
        pos := pos + 1;
        END
    ELSE
        char_found := true;
    (*ENDIF*) 
UNTIL
    char_found OR (pos > len);
(*ENDREPEAT*) 
len := len - count;
END;
 
(*------------------------------*) 
 
FUNCTION
      i14lolen_overflow (
            VAR eform     : tin_eform_buffer;
            VAR evars     : tin_eform_vars;
            VAR this      : tin_natural;
            VAR max_lnlen : tin_natural ) : boolean;
 
VAR
      overflow : boolean;
 
BEGIN
overflow := false;
this := 0;
WHILE NOT overflow AND ( this <= evars.lines )  DO
    BEGIN
    this := this + 1;
    overflow :=  i14linelength( eform, evars, this ) > max_lnlen;
    END;
(*ENDWHILE*) 
i14lolen_overflow := overflow;
END;
 
(*------------------------------*) 
 
FUNCTION
      i14clcut_line (
            VAR eform     : tin_eform_buffer;
            VAR evars     : tin_eform_vars;
            VAR max_lnlen : tin_natural ) : boolean;
 
VAR
      this   : tin_natural;
      error  : boolean;
      line   : tin_eline;
      length : tin_natural;
 
BEGIN
error := false;
this  := 0;
WHILE NOT error AND ( this <= evars.lines )  DO
    BEGIN
    this := this + 1;
    IF  i14linelength ( eform, evars, this ) > max_lnlen
    THEN
        BEGIN
        i14geteline ( eform, evars, line, this, length, error);
        i14puteline ( eform, evars, line, this, max_lnlen, error);
        END;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
i14clcut_line := NOT error;
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14reduce_eform (
            VAR eform     : tin_eform_buffer;
            VAR evars     : tin_eform_vars;
            max_cols      : tin_natural;
            VAR error     : boolean);
 
VAR
      this       : tin_natural;
      line       : tin_eline;
      length     : tin_natural;
      stop       : boolean;
 
BEGIN
WITH evars DO
    BEGIN
    IF  elength > 0
    THEN
        BEGIN
        error:= false;
        this := 0;
        stop := false;
        act_pos  := 1;
        WHILE NOT  stop DO
            BEGIN
            addspace_14 ( size, eform, elength, act_pos, text_offset );
            eform [ act_pos ] := chr ( max_cols + text_offset );
            eform [ act_pos + 1 ] := chr ( 0 );
            this := this + 1;
            act_pos := act_pos + max_cols + text_offset;
            act_line := act_line + 1;
            stop := act_pos + max_cols - text_offset > elength;
            END;
        (*ENDWHILE*) 
        lines := this;
        act_pos  := 1;
        act_line := 1;
        FOR this := 1 TO lines DO
            BEGIN
            i14geteline(eform,evars,line,this, length,error);
            i14puteline(eform,evars,line,this, length,error);
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i14expand_eform (
            VAR eform     : tin_eform_buffer;
            VAR evars     : tin_eform_vars;
            max_cols      : tin_natural;
            VAR error     : boolean);
 
VAR
      this    : tin_natural;
      len     : tin_natural;
 
BEGIN
error := false;
WITH evars DO
    BEGIN
    IF  lines > 0
    THEN
        BEGIN
        WHILE NOT error AND ( 0 < evars.lines )  DO
            BEGIN
            this  := lines;
            i14findactpos ( eform, evars, this, error );
            ins_blanks ( eform, evars, max_cols, elength );
            del1space( size, eform, elength, act_pos, text_offset );
            lines := lines - 1;
            END;
        (*ENDWHILE*) 
        lines := 1;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ins_blanks (
            VAR eform     : tin_eform_buffer;
            VAR evars     : tin_eform_vars;
            max_cols      : tin_natural;
            VAR elength   : tin_natural);
 
VAR
      prelen   : tin_natural;
      postlen  : tin_natural;
      len      : tin_natural;
 
BEGIN
WITH evars DO
    BEGIN
    len     := ord ( eform [ act_pos ] );
    prelen  := ord ( eform [ act_pos + 1 ] );
    postlen := max_cols + text_offset -
          ord ( eform [ act_pos ] ) - prelen;
    IF  postlen > 0
    THEN
        BEGIN
        SAPDB_PascalForcedOverlappingMove ( size, size, @eform, act_pos + len,
              @eform, act_pos + postlen + len , elength - act_pos -
              len + 1 );
        SAPDB_PascalForcedFill ( size, @eform, act_pos + len, postlen, ' ' );
        elength := elength + postlen;
        END;
    (*ENDIF*) 
    IF  prelen > 0
    THEN
        BEGIN
        SAPDB_PascalForcedOverlappingMove ( size, size, @eform, act_pos + text_offset ,
              @eform, act_pos + prelen + text_offset,
              elength - act_pos - 1 );
        SAPDB_PascalForcedFill ( size, @eform, act_pos + text_offset, prelen, ' ' );
        END;
    (*ENDIF*) 
    elength := elength + prelen;
    END;
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
