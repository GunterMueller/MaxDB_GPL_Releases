.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK47$
.tt 2 $$$
.TT 3 $ThomasA$Show_table $2000-11-16$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : AK_Show_table
=========
.sp
Purpose : Show Table und Tablenames.
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a47range_default (VAR acv : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    VAR col_info : tak00_columninfo);
 
        PROCEDURE
              a47show_table (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob;
                    kw_index : integer);
 
        PROCEDURE
              a47table_kind (VAR acv : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    VAR base_rec : tak_baserecord);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Resultname_handling : VAK663;
 
        PROCEDURE
              a663restable_get (VAR acv : tak_all_command_glob;
                    dstate      : tak_directory_state;
                    VAR tablen  : tsp00_KnlIdentifier;
                    VAR p_arr   : tak_syspointerarr;
                    VAR ok      : boolean);
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : vta01;
 
        PROCEDURE
              t01int4 (debug : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01lidentifier (layer : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier);
&       ENDIF
 
      ------------------------------ 
 
        FROM
              AK_Show_Procedure : VAK49;
 
        PROCEDURE
              a49one_table_trigger (VAR acv : tak_all_command_glob;
                    VAR a41v        : tak40_show_glob;
                    trigger_len     : integer);
 
        PROCEDURE
              a49trigger_param (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
      ------------------------------ 
 
        FROM
              AK_Show_view : VAK48;
 
        PROCEDURE
              a48get_view_def_string (VAR acv : tak_all_command_glob;
                    VAR tabid       : tgg00_Surrogate;
                    length_only     : boolean;
                    outbuf_size     : tsp00_Int4;
                    VAR outbuf      : tsp00_MoveObj;
                    VAR viewtextlen : tsp00_Int4);
 
        PROCEDURE
              a48referenced_columns (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
      ------------------------------ 
 
        FROM
              AK_Show_user_priv : VAK43;
 
        PROCEDURE
              a43get_granted_priv (VAR acv : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    VAR owner     : tsp00_KnlIdentifier;
                    VAR tablename : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_Show_statistics : VAK42;
 
        PROCEDURE
              a42table_statistics   (VAR acv : tak_all_command_glob;
                    VAR a41v   : tak40_show_glob;
                    pages_only : boolean);
 
        PROCEDURE
              a42iindex_statistics   (VAR acv : tak_all_command_glob;
                    VAR a41v   : tak40_show_glob);
 
      ------------------------------ 
 
        FROM
              AK_universal_show_tools : VAK40;
 
        VAR
              a40yes_no : ARRAY[boolean] OF tsp00_C3;
 
        PROCEDURE
              a40comment_descriptor (VAR acv : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    is_null      : boolean;
                    VAR tabid    : tgg00_Surrogate;
                    column_no    : integer;
                    comment_kind : tak_comment_type);
 
        PROCEDURE
              a40datatype_code (VAR col_info : tak00_columninfo;
                    is_oracle    : boolean;
                    comp_type    : tak_appl_type;
                    VAR datatype : tsp00_Sname;
                    VAR code     : tsp00_C10;
                    VAR datalen  : integer);
 
        PROCEDURE
              a40FinishTableScan (
                    VAR acv          : tak_all_command_glob;
                    VAR a41v         : tak40_show_glob);
 
        PROCEDURE
              a40get_catalog_table (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a40ignore_down_error (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a40_p_priv (VAR pr : tak_privilege;
                    VAR prn : tsp00_C40;
                    colno   : tsp00_Int2);
 
        PROCEDURE
              a40default (VAR acv : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    VAR colinfo : tak00_columninfo;
                    VAR domrec  : tak_defaultrecord);
 
        PROCEDURE
              a40init_table_scan (VAR acv : tak_all_command_glob;
                    VAR a41v         : tak40_show_glob;
                    scan_temp        : boolean;
                    scan_private     : boolean;
                    scan_non_private : boolean;
                    scan_public      : boolean;
                    use_synonyms     : boolean;
                    all_base         : boolean);
 
        PROCEDURE
              a40long_descriptor (VAR acv : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    VAR tabid    : tgg00_Surrogate;
                    column_no    : integer);
 
        PROCEDURE
              a40move (VAR acv : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : integer);
 
        PROCEDURE
              a40move_const (VAR acv : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : integer);
 
        PROCEDURE
              a40move_i4 (VAR acv : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    i4_val        : tsp00_Int4;
                    is_null       : boolean;
                    frac          : integer;
                    zero_to_undef : boolean);
 
        PROCEDURE
              a40move_real (VAR acv : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    val           : tsp00_Longreal;
                    is_null       : boolean;
                    frac          : integer);
 
        FUNCTION
              a40next_table (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob) : boolean;
 
        PROCEDURE
              a40put_date_time (VAR acv : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    VAR datetime : tsp00_Int4;
                    date         : boolean;
                    is_undef     : boolean);
 
        PROCEDURE
              a40SetAllObjects(VAR acv : tak_all_command_glob;
                    VAR a41v  : tak40_show_glob);
 
        PROCEDURE
              a40table_column_to_shbuf (VAR acv : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    base_ptr     : tak_sysbufferaddress;
                    colindex     : integer;
                    with_owner   : boolean);
 
        PROCEDURE
              a40column_description (VAR acv : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    tablekind    : tgg00_TableKind;
                    VAR col_info : tak00_columninfo;
                    opt_undef    : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Link : VAK25;
 
        PROCEDURE
              a25get_linkname (VAR acv : tak_all_command_glob;
                    linkbuf        : tak_sysbufferaddress;
                    index          : integer;
                    VAR link_name  : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_Index : VAK24;
 
        PROCEDURE
              a24get_indexname (VAR acv : tak_all_command_glob;
                    indexbuf       : tak_sysbufferaddress;
                    index          : integer;
                    VAR index_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a24init_index_scan (VAR acv : tak_all_command_glob;
                    VAR tabid          : tgg00_Surrogate;
                    VAR index_scan_rec : tak_index_scan_record);
 
        PROCEDURE
              a24finish_index_scan (VAR acv : tak_all_command_glob;
                    VAR index_scan_rec : tak_index_scan_record);
 
        FUNCTION
              a24next_named_index (VAR acv : tak_all_command_glob;
                    VAR index_scan_rec : tak_index_scan_record) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_update_statistics: VAK28;
 
        PROCEDURE
              a28column_statistics (
                    VAR acv            : tak_all_command_glob;
                    base_ptr           : tak_sysbufferaddress;
                    VAR col_info       : tak00_columninfo;
                    infer_stats        : boolean;
                    VAR statistics     : tak_column_statistics;
                    VAR stat_rec_found : boolean);
 
        PROCEDURE
              a28info (VAR acv : tak_all_command_glob;
                    base_ptr       : tak_sysbufferaddress;
                    VAR pages      : tsp00_Int4;
                    VAR rows       : tsp00_Int4;
                    VAR date       : tsp00_Int4;
                    VAR time       : tsp00_Int4);
 
        FUNCTION
              a28prim_pages (VAR acv : tak_all_command_glob;
                    VAR baserec : tak_baserecord) : tsp00_Int4;
 
        FUNCTION
              a28primrows (VAR acv : tak_all_command_glob;
                    VAR baserec : tak_baserecord) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache  : VAK10;
 
        PROCEDURE
              a10dispose (VAR acv : tak_all_command_glob;
                    VAR p : tsp00_MoveObjPtr);
 
        PROCEDURE
              a10FlushResnames (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10get_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10new (VAR acv : tak_all_command_glob;
                    obj_size : tsp00_Int4;
                    VAR p    : tsp00_MoveObjPtr);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10next_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    stop_prefix  : integer;
                    dstate       : tak_directory_state;
                    rec_kind     : tsp00_C2;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate (* ptocConst *);
                    VAR schemaName : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_Data_Type_Options : VAK14;
 
        FUNCTION
              a14LengthOfDefaultValue (
                    VAR DefaultRec : tak_defaultrecord) : integer; (* PTS 1108428 *)
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (VAR acv : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06check_username (VAR acv : tak_all_command_glob;
                    VAR auth   : tsp00_KnlIdentifier;
                    VAR is_dba : boolean;
                    VAR ok     : boolean);
 
        PROCEDURE
              a06extcolno (VAR baserec : tak_baserecord;
                    extcolno     : integer;
                    VAR col_ptr  : tak00_colinfo_ptr);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06determine_username (VAR acv : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06_get_priv  (VAR acv : tak_all_command_glob;
                    VAR brec : tak_sysbufferaddress;
                    VAR priv : tak_privilege);
 
        PROCEDURE
              a06_systable_get (VAR acv : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR tableid  : tgg00_Surrogate;
                    VAR base_ptr : tak_sysbufferaddress;
                    get_all      : boolean;
                    VAR ok       : boolean);
 
        FUNCTION
              a06_table_exist (VAR acv : tak_all_command_glob;
                    dstate      : tak_directory_state;
                    VAR authid  : tsp00_KnlIdentifier;
                    VAR tablen  : tsp00_KnlIdentifier;
                    VAR d_sparr : tak_syspointerarr;
                    get_all     : boolean) : boolean;
 
        PROCEDURE
              a06_view_get_basetable (VAR acv : tak_all_command_glob;
                    VAR view_id  : tgg00_Surrogate;
                    tabno        : integer;
                    VAR base_id  : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061get_colname (VAR col_info : tak00_columninfo;
                    VAR colname  : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01char_size         : integer;
              a01defaultkey        : tgg00_SysInfoKey;
              a01emptypriv         : tak_privilege;
              a01kw                : tak_keywordtab;
              a01_i_temp           : tsp00_KnlIdentifier;
              a01_il_b_identifier  : tsp00_KnlIdentifier;
              a01_zero_res_name    : tsp00_KnlIdentifier;
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        PROCEDURE
              b01filestate (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_3 : VBD03;
 
        PROCEDURE
              bd03GetInvPageCount (
                    VAR t             : tgg00_TransContext;
                    VAR indexSurr     : tgg00_Surrogate(*ptocConst*);
                    VAR leafPageCount : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_7 : VBD07;
 
        PROCEDURE
              b07cnext_record (VAR t : tgg00_TransContext;
                    VAR file_id    : tgg00_FileId;
                    VAR rk         : tgg00_Lkey;
                    VAR set_result : tgg00_BdSetResultRecord;
                    VAR tree_pos   : tgg00_FilePos;
                    VAR b          : tak_resn_rec_arr);
 
      ------------------------------ 
 
        FROM
              BD_Wrapper : VBD999;
 
        FUNCTION
              bd999GetPageSize : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04index_tree_build (
                    VAR file_id    : tgg00_FileId;
                    VAR index_tree : tgg00_FileId;
                    index_no       : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30eq (VAR a,b : tsp00_KnlIdentifier;
                    bi,cnt : tsp00_Int4) : boolean;
 
      ------------------------------ 
 
        FROM
              GETSTRING-Conversions : VSP42;
 
        PROCEDURE
              s42gstr (VAR buf : tsp00_C20;
                    pos      : tsp00_Int4;
                    len      : integer;
                    frac     : integer;
                    origlen  : integer;
                    VAR dest : tsp00_C50;
                    dpos     : tsp00_Int4;
                    VAR dlen : integer;
                    VAR res  : tsp00_NumError);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              a10dispose;
 
              tak_sysbufferaddress tsp00_MoveObjPtr
 
        PROCEDURE
              a10new;
 
              tak_sysbufferaddress tsp00_MoveObjPtr
 
        PROCEDURE
              s30eq;
 
              tsp00_MoveObj   tsp00_KnlIdentifier
 
        PROCEDURE
              s42gstr;
 
              tsp00_MoveObj    tsp00_C20
              tsp00_MoveObj    tsp00_C50
 
        PROCEDURE
              b07cnext_record;
 
              tsp00_MoveObj   tak_resn_rec_arr
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ThomasA
.sp
.cp 3
Created : 1985-03-01
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-11-16
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
Erkennt Syntax :
.sp
  'SHOW'  'TABLE'
        [  <table_name>
        /  <auth_id> '.' '*'
         ]
.sp 3
Erkennt Syntax :
.sp
   'SHOW'  'TABLENAMES'
        [  '*'
        /  <prefix> '*'
        /  <auth_id> '.'
           [  '*'
           /  <prefix> '*'
            ]
         ]
.sp 3
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.sp 4
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_all           = true;
      c_null          = true;
      c_to_undef      = true;
      c_is_date       = true;
      c_is_time       = false;
      c_full_spec     = true;
      c_with_owner    = true;
      c_inferStats    = true;
      c_gateway       = 'GATEWAY ';
      c_result        = 'RESULT  ';
      c_synonym       = 'SYNONYM ';
      c_system        = 'SYSTEM  ';
      c_table         = 'TABLE   ';
      c_view          = 'VIEW    ';
 
TYPE
      show_phase     = (show_results, show_temp, show_perm);
 
 
(*------------------------------*) 
 
FUNCTION
      ak47get_synonym_rec (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob) : boolean;
 
VAR
      b_err : tgg00_BasisError;
      sysk  : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    sysk          := a01defaultkey;
    sysk.stableid := a4p_arr.psynid;
    a10get_sysinfo (acv, sysk, d_release, a4usertab_buf, b_err);
    IF  b_err = e_ok
    THEN
        a4synname := a4usertab_buf^.ssynonym.syn_tablen;
    (*ENDIF*) 
    a4is_synonym        := true;
    ak47get_synonym_rec := b_err = e_ok
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47optimize_statistics (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      stat_rec_found : boolean;
      j              : integer;
      colno          : integer;
      ipages         : tsp00_Int4;
      pCol           : tak00_colinfo_ptr;
      table_stat     : tsp00_C18;
      index_name     : tsp00_KnlIdentifier;
      statistics     : tak_column_statistics;
      priv           : tak_privilege;
      index_scan_rec : tak_index_scan_record;
      indexFileId    : tgg00_FileId;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    IF  a4sh_kind<>sh_optimizerinformation
    THEN
        a4sh_kind := sh_table_stat;
    (*ENDIF*) 
    priv      := a01emptypriv;
    a40get_catalog_table (acv, a41v);
    IF  a_ex_kind <> only_parsing
    THEN
        BEGIN
        a40table_column_to_shbuf (acv, a41v, a4p_arr.pbasep, -1,
              a4sh_kind<>sh_optimizerinformation);
        colno := a4pos;
        (* PTS 1115043 E.Z. *)
        stat_rec_found := false;
        a28column_statistics (acv, a4p_arr.pbasep,
              a103GetColumn (a4p_arr.pbasep^.sbase, a4p_arr.pbasep^.sbase.bfirstindex)^,
              c_inferStats, statistics, stat_rec_found);
        IF  stat_rec_found
        THEN
            FOR j := a4p_arr.pbasep^.sbase.bfirstindex TO
                  a4p_arr.pbasep^.sbase.blastindex DO
                BEGIN
                pCol := a103GetColumn (a4p_arr.pbasep^.sbase, j);
                WITH a4p_arr.pbasep^.sbase, pCol^ DO
                    BEGIN
                    a4pos := colno;
                    a28column_statistics (acv, a4p_arr.pbasep,
                          pCol^, c_inferStats, statistics, stat_rec_found);
                    IF  (NOT (ctdropped in ccolpropset))
                        AND
                        (NOT (ctinvisible in ccolpropset))
                        AND
                        ((statistics.c_values <> cak_is_undefined)
                        OR
                        ( statistics.c_pages  <> cak_is_undefined))
                    THEN
                        BEGIN
                        a40move (acv, a41v, @ccolumnn, ord (ccolumnn_len));
                        a40move (acv, a41v, NIL,
                              sizeof (index_name));
                        a40move_i4 (acv, a41v, statistics.c_values,
                              statistics.c_values < 0,
                              0, false);
                        a40move_i4 (acv, a41v, statistics.c_pages,
                              statistics.c_pages < 0,
                              0, false);
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                END;
            (*ENDFOR*) 
        (*ENDIF*) 
        IF  (a4p_arr.pbasep^.sbase.bindexexist) AND
            (a4p_arr.pbasep^.sbase.btablekind <> tview)
        THEN
            BEGIN
            a24init_index_scan (acv,
                  a4p_arr.pbasep^.sbase.btreeid.fileTabId_gg00,
                  index_scan_rec);
            WITH index_scan_rec DO
                WHILE a24next_named_index (acv, index_scan_rec) DO
                    WITH isr_buf^.smindex.indexdef[isr_index] DO
                        BEGIN
                        a4pos := colno;
                        a40move (acv, a41v, NIL, sizeof (a4tablen));
                        a24get_indexname (acv, isr_buf, isr_index,
                              index_name);
                        a40move (acv, a41v, @index_name,
                              sizeof (index_name));
                        a40move (acv, a41v, NIL, 0);
                        g04index_tree_build (a4p_arr.pbasep^.sbase.btreeid,
                              indexFileId, indexno);
                        bd03GetInvPageCount (acv.a_transinf.tri_trans,
                              indexFileId.fileTabId_gg00,
                              ipages);
                        IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
                        THEN
                            a07_b_put_error (acv,
                                  acv.a_transinf.tri_trans.trError_gg00, 1);
                        (*ENDIF*) 
                        IF  a4sh_kind <> sh_optimizerinformation (* PTS 1115043 U.J. *)
                        THEN
                            a40move_i4 (acv, a41v, ipages,
                                  false, 0, false)
                        ELSE
                            a40move_i4 (acv, a41v, (ipages * (bd999GetPageSize DIV 1024)),
                                  false, 0, false)
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDWHILE*) 
            (*ENDWITH*) 
            a24finish_index_scan (acv, index_scan_rec)
            END;
        (*ENDIF*) 
        a4pos          := colno;
        IF  a4sh_kind <> sh_optimizerinformation (* PTS 1115043 U.J. *)
        THEN
            BEGIN
            table_stat     := 'TABLE STATISTICS  ';
            a40move_const (acv, a41v, @table_stat, sizeof (table_stat));
            END
        ELSE
            a40move (acv, a41v, NIL, 0);
        (*ENDIF*) 
        a40move (acv, a41v, NIL, 0);
        a40move_i4 (acv, a41v,
              a28primrows (acv, a4p_arr.pbasep^.sbase),
              NOT c_null, 0, NOT c_to_undef);
        IF  a4sh_kind <> sh_optimizerinformation (* PTS 1115043 U.J. *)
        THEN
            a40move_i4 (acv, a41v,
                  a28prim_pages (acv, a4p_arr.pbasep^.sbase),
                  NOT c_null, 0, NOT c_to_undef)
        ELSE
            a40move_i4 (acv, a41v,
                  (a28prim_pages (acv, a4p_arr.pbasep^.sbase) * (bd999GetPageSize DIV 1024)),
                  NOT c_null, 0, NOT c_to_undef);
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a47show_table (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            kw_index : integer);
 
VAR
      scan_temp       : boolean;
      scan_private    : boolean;
      scan_nonprivate : boolean;
      scan_public     : boolean;
      use_synonyms    : boolean;
      modul_name      : tsp00_KnlIdentifier;
      phase           : show_phase;
 
BEGIN
WITH acv, a41v, a4p_arr DO
    BEGIN
    modul_name := a01_il_b_identifier;
    a40get_catalog_table (acv, a41v);
    IF  (a_returncode = 0) AND (a_ex_kind <> only_parsing)
    THEN
        IF  ((a4authname <> a01_il_b_identifier)     AND
            ( a4tablen   <> a01_il_b_identifier)     AND
            ( a4tab_len  =  sizeof (a4tablen)))
        THEN (* complete table specification *)
            BEGIN
            a40SetAllObjects (acv, a41v); (* PTS 1109359 *)
            IF  a4authname = a01_i_temp
            THEN (* temporary table *)
                ak47one_table_show (acv, a41v, a4authname, a4tablen,
                      modul_name, kw_index, c_full_spec, show_temp)
            ELSE (* named result or permanent table *)
                BEGIN
                IF  (a4authname    =  a_curr_user_name)
                    AND
                    (a_sqlmode = sqlm_internal)
                    AND
                    (a4sh_kind      <> sh_constraint)
                    AND
                    NOT a_in_ddl_trigger
                    (* no interest for result tables in DDL-Triggers *)
                THEN (* may be result table *)
                    ak47one_table_show (acv, a41v, a4authname,
                          a4tablen, modul_name,
                          kw_index, c_full_spec, show_results);
                (*ENDIF*) 
                IF  (acv.a_show_last_key = 0) OR (a4sh_kind = sh_table)
                THEN (* no result table found *)
                    BEGIN
                    ak47one_table_show (acv, a41v, a4authname,
                          a4tablen, modul_name,
                          kw_index, c_full_spec, show_perm);
                    IF  (a4sh_kind = sh_constraint) AND
                        (a4tab_count > 0)
                    THEN
                        WITH a4p_arr.pbasep^.sbase DO
                            IF  (btablekind <> twithkey) AND
                                (btablekind <> twithoutkey)
                            THEN
                                a07_b_put_error (acv,
                                      e_missing_basetable, 1)
                            (*ENDIF*) 
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        ELSE (* incomplete table specification *)
            BEGIN
            IF  ((a4authname = a_curr_user_name) OR
                ( a4authname = a01_il_b_identifier))
                AND
                NOT a_in_ddl_trigger
                AND
                (a_sqlmode = sqlm_internal)
                AND
                NOT (a4sh_kind in [sh_constraint,
                sh_cons_columns, sh_all_cons_columns,
                sh_param_trigger, sh_object,
                sh_all_object, sh_ref_column, sh_trigger,
                sh_view, sh_st_table, sh_view_uses_table,
                sh_table_stat, sh_optimizerinformation])
            THEN
                ak47result_tables (acv, a41v, kw_index);
            (*ENDIF*) 
            scan_temp       := true;
            scan_private    := true;
            scan_nonprivate := true;
            scan_public     := true;
            use_synonyms    := true;
            CASE a4sh_kind OF
                sh_trigger, sh_param_trigger :
                    BEGIN
                    scan_temp       := false;
                    scan_public     := false;
                    use_synonyms    := false
                    END;
                sh_ref_column, sh_view, sh_view_uses_table,
                sh_object, sh_all_object, sh_table_stat, sh_optimizerinformation :
                    scan_temp := false;
                sh_st_table, sh_pages :
                    BEGIN
                    scan_nonprivate := true;
                    scan_public     := false;
                    use_synonyms    := false
                    END;
                OTHERWISE ;
                END;
            (*ENDCASE*) 
            a40init_table_scan (acv, a41v,
                  scan_temp, scan_private, scan_nonprivate, scan_public,
                  use_synonyms, ak47all_base(kw_index));
            WHILE a40next_table (acv, a41v) DO
                BEGIN
                IF  a4p_arr.pbasep^.syskey.sentrytyp < cak_etemp
                THEN
                    phase := show_perm
                ELSE
                    phase := show_temp;
                (*ENDIF*) 
                ak47one_table_show (acv, a41v, a4next_owner,
                      a4next_tablen, modul_name,
                      kw_index, NOT c_full_spec, phase);
                END;
            (*ENDWHILE*) 
            a40FinishTableScan (acv, a41v);
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak47all_base (kw_index : integer) : boolean;
 
BEGIN
ak47all_base := (kw_index = cak_i_column  ) OR
      (kw_index = cak_i_primary );
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47result_tables (VAR acv : tak_all_command_glob;
            VAR a41v      : tak40_show_glob;
            kw_index      : integer);
 
VAR
      b_err        : tgg00_BasisError;
      i            : integer;
      set_result   : tgg00_BdSetResultRecord;
      tree_pos     : tgg00_FilePos;
      rk           : tgg00_Lkey;
      res_rec      : tak_resn_rec_arr;
 
BEGIN
a10FlushResnames (acv);
IF  acv.a_returncode = 0
THEN
    WITH acv, a41v DO
        BEGIN
        tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
        rk.len         := SURROGATE_MXGG00 + mxak_entry_type +
              2 * sizeof (tsp00_KnlIdentifier);
        WITH res_rec[ 1 ] DO
            BEGIN
            reskeylen         := rk.len;
            reskey_idfill     := cgg_zero_id;
            reskey_identr     := cak_eresname;
            reskey_name       := a01_zero_res_name;
            reskey_modul_name := a01_il_b_identifier;
            END;
        (*ENDWITH*) 
        SAPDB_PascalForcedMove (sizeof(res_rec), sizeof(rk.k),
              @res_rec[1], cgg_rec_key_offset + 1, @rk.k, 1, rk.len);
        WITH set_result DO
            BEGIN
            bd_key_check_len := SURROGATE_MXGG00 + mxak_entry_type;
            (* PTS 1111574 E.Z. *)
            bd_max_rec_cnt   := cak_max_resn;
            bd_max_fill_len  := sizeof (tak_resn_rec_arr);
            bd_next          := true;
            bd_drop_page     := false;
            bd_rec_cnt       := 1;
            END;
        (*ENDWITH*) 
        REPEAT
            b07cnext_record (a_transinf.tri_trans, a_pars_curr, rk,
                  set_result, tree_pos, res_rec);
            b_err := a_transinf.tri_trans.trError_gg00;
            IF  b_err = e_key_not_found
            THEN
                b_err := e_ok;
            (*ENDIF*) 
            IF  ((b_err = e_ok) OR (b_err = e_buffer_limit))
            THEN
                BEGIN
                i := 1;
                WHILE (i <= set_result.bd_rec_cnt) AND
                      (a_returncode = 0) DO
                    WITH res_rec[ i ] DO
                        BEGIN
                        a4is_systable  := false;
                        a4p_arr.pbasep := NIL;
&                       ifdef trace
                        t01lidentifier (ak_sem, reskey_name);
                        t01lidentifier (ak_sem, a4showfile_name);
&                       endif
                        IF  (resexecuted) AND
                            (reskey_name <> a4showfile_name) AND
                            (reskey_name <> a01_il_b_identifier)
                        THEN
                            ak47one_table_show (acv, a41v, a_curr_user_name,
                                  reskey_name, reskey_modul_name,
                                  kw_index, NOT c_full_spec, show_results);
                        (*ENDIF*) 
                        a10rel_sysinfo (a4p_arr.pbasep);
                        i := i + 1
                        END;
                    (*ENDWITH*) 
                (*ENDWHILE*) 
                IF  b_err = e_buffer_limit
                THEN
                    BEGIN
                    rk.len := res_rec[set_result.bd_rec_cnt].reskeylen;
                    SAPDB_PascalForcedMove (sizeof(res_rec), sizeof(rk.k),
                          @res_rec[set_result.bd_rec_cnt], cgg_rec_key_offset + 1, @rk.k, 1, rk.len);
                    tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            (b_err <> e_buffer_limit) OR (acv.a_returncode <> 0);
        (*ENDREPEAT*) 
&       ifdef trace
        t01int4 (ak_sem, 'end results ', 1);
&       endif
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47one_table_show (VAR acv : tak_all_command_glob;
            VAR a41v       : tak40_show_glob;
            VAR authname   : tsp00_KnlIdentifier;
            VAR tablen     : tsp00_KnlIdentifier;
            VAR modul_name : tsp00_KnlIdentifier;
            kw_index       : integer;
            full_spec      : boolean;
            phase          : show_phase);
 
VAR
      is_sequence : boolean;
      ok          : boolean;
      priv        : tak_privilege;
      pTablen     : tsp00_KnlIdentifierPtr;
 
BEGIN
WITH acv, a41v DO
    IF  a_returncode = 0
    THEN
        BEGIN
&       IFDEF TRACE
        t01lidentifier (ak_sem, authname);
        t01lidentifier (ak_sem, tablen);
        t01lidentifier (ak_sem, modul_name);
        t01lidentifier (ak_sem, a4authname);
        t01lidentifier (ak_sem, a4tablen);
        t01int4     (ak_sem, 'phase       ', ord (phase));
&       ENDIF
        a4pos       := 1;
        ok          := false;
        is_sequence := false;
&       IFDEF TRACE
        t01lidentifier (ak_sem, authname);
        t01lidentifier (ak_sem, tablen);
        t01int4  (ak_sem, 'phase       ', ord (phase));
&       ENDIF
        pTablen:= NIL;
        IF  phase = show_results
        THEN
            BEGIN
            a663restable_get (acv, d_fix, tablen, a4p_arr, ok);
            IF  ok
            THEN (* PTS 1106260 *)
                BEGIN
                pTablen := a4p_arr.pbasep^.sbase.btablen;
                a4p_arr.pbasep^.sbase.btablen := @tablen;
                END
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            IF  a4p_arr.pbasep = NIL
            THEN
                BEGIN
                ok := a06_table_exist (acv, d_fix, authname,
                      tablen, a4p_arr, ak47all_base (kw_index));
                IF  ok
                THEN
                    BEGIN
                    IF  a4p_arr.psynfound AND
                        ((kw_index = cak_i_table) OR
                        ( a4sh_kind = sh_odbc_columns))
                    THEN
                        ok := ak47get_synonym_rec (acv, a41v);
                    (*ENDIF*) 
                    a4is_systable := a4p_arr.psystable
                    END;
                (*ENDIF*) 
                END
            ELSE
                ok := true;
            (*ENDIF*) 
            IF  ok
            THEN
                a4tab_count := a4tab_count + 1;
            (*ENDIF*) 
            a40ignore_down_error (acv)
            END;
        (*ENDIF*) 
        IF  ok
        THEN
            BEGIN
            is_sequence := a4p_arr.pbasep^.syskey.sentrytyp = cak_esequence;
            IF  is_sequence
            THEN
                ok := kw_index = cak_i_object
            ELSE
                WITH a4p_arr.pbasep^.sbase DO
                    CASE kw_index OF
                        cak_i_constraint, cak_i_references, cak_i_trigger, cak_i_param :
                            ok := (btablekind = twithkey) OR
                                  (btablekind = twithoutkey);
                        cak_i_index, cak_i_stat:
                            ok := (btablekind in [ twithkey,
                                  twithoutkey ])
                                  AND
                                  (bauthid = acv.a_curr_user_id);
                        cak_i_object :
                            ok := btablekind in [twithkey,
                                  twithoutkey, tsynonym, tresult,
                                  tonebase, tview, tcomplexview,
                                  tdb2view, tcatalog_table];
                        cak_i_key, cak_i_view :
                            ok := (btablekind in [tonebase,
                                  tview, tcomplexview]) OR
                                  ((btablekind = tshow_view) AND
                                  (bv_tablekind <> tresult));
                        cak_i_using :
                            ok := (btablekind in [tonebase,
                                  tview, tcomplexview]) OR
                                  ((btablekind = tshow_view) AND
                                  (bv_tablekind <> tresult));
                        OTHERWISE
                            ok := btablekind in [twithkey,
                                  twithoutkey, tsynonym, tresult,
                                  tonebase, tview, tcomplexview,
                                  tdb2view, tcatalog_table]
                        END;
                    (*ENDCASE*) 
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  ok
        THEN
            BEGIN
            IF  phase = show_results
            THEN
                BEGIN
                priv                := a01emptypriv;
                priv.priv_all_set   := [ r_sel ];
                priv.priv_col_exist := [  ];
                END
            ELSE
                BEGIN
                IF  NOT is_sequence
                    AND
                    NOT (a4sh_kind in [sh_object, sh_all_object])
                THEN
                    a06_get_priv (acv, a4p_arr.pbasep, priv);
                (*ENDIF*) 
                IF  NOT (a4all_objects)                           AND
                    NOT (a4sh_kind in [sh_object, sh_all_object]) AND
                    (priv.priv_all_set   = [  ])                  AND
                    (priv.priv_col_exist = [  ])
                THEN
                    BEGIN
                    ok := false;
                    END
                ELSE
                    IF  kw_index in [cak_i_trigger, cak_i_param]
                    THEN
                        ok := a4p_arr.pbasep^.sbase.bauthid = acv.a_curr_user_id
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  a4is_synonym
                AND
                ((kw_index = cak_i_column  ) OR
                ( kw_index = cak_i_table   ))
            THEN
                BEGIN
                a10rel_sysinfo (a4p_arr.pbasep);
                a4p_arr.px[ 3 ] := a4p_arr.pbasep;
                a4p_arr.pbasep  := a4usertab_buf
                END;
            (*ENDIF*) 
            IF  ok AND (a_returncode = 0)
            THEN
                CASE kw_index OF
                    cak_i_constraint :
                        ak47constraint_show (acv, a41v, priv);
                    cak_i_index :
                        a42iindex_statistics (acv, a41v);
                    cak_i_column :
                        ak47columns_show (acv,
                              a41v, priv, kw_index);
                    cak_i_object :
                        ak47objects (acv, a41v, is_sequence);
                    cak_i_optimize :
                        ak47optimize_statistics (acv, a41v);
                    cak_i_param :
                        a49trigger_param (acv, a41v);
                    cak_i_privileges :
                        a43get_granted_priv (acv, a41v,
                              a4next_owner, a4next_tablen);
                    cak_i_references :
                        ak47col_constraint_references (acv,
                              a41v, priv);
                    cak_i_key :
                        a48referenced_columns (acv, a41v);
                    cak_i_stat, cak_i_log :
                        a42table_statistics (acv, a41v,
                              a4sh_kind = sh_pages);
                    cak_i_table :
                        ak47table_add (acv, a41v, priv);
                    cak_i_trigger :
                        a49one_table_trigger (acv, a41v, 0);
                    cak_i_using :
                        ak47view_uses_table (acv, a41v);
                    cak_i_view :
                        ak47view_add (acv, a41v);
                    END
                (*ENDCASE*) 
            ELSE
                a40ignore_down_error (acv);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  pTablen <> NIL
        THEN
            a4p_arr.pbasep^.sbase.btablen := pTablen;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47columns_show (VAR acv : tak_all_command_glob;
            VAR a41v     : tak40_show_glob;
            VAR priv     : tak_privilege;
            kw_index     : integer);
 
VAR
      ok              : boolean;
      is_syskey       : boolean; (* ADIS 1001495, T.A. 17.09.1998 *)
      colno           : integer;
      curr_show_colno : integer;
      max             : integer;
      col_ptr         : tak00_colinfo_ptr;
      colname         : tsp00_KnlIdentifier;
      syn_ptr         : tak_sysbufferaddress;
      aux_authid      : tgg00_Surrogate;
      aux_schema      : tgg00_Surrogate;
      aux_tablen      : tsp00_KnlIdentifier;
      colnoMap        : ARRAY[1..MAX_COL_PER_TAB_GG00] OF integer;
 
BEGIN
WITH acv, a41v DO
    IF  a_returncode = 0
    THEN
        BEGIN
        syn_ptr          := NIL;
        IF  a4p_arr.pbasep^.sbase.btablekind = tsynonym
        THEN
            WITH a4p_arr.pbasep^.ssynonym DO
                BEGIN
                syn_ptr := a4p_arr.pbasep;
                a06_systable_get (acv, d_fix, syn_tableid,
                      a4p_arr.pbasep, c_all, ok);
                IF  ok
                THEN
                    WITH a4p_arr.pbasep^.sbase DO
                        BEGIN
                        aux_schema := bschema;
                        aux_authid := bauthid;
                        aux_tablen := btablen^;
                        (* PTS 1104784 E.Z. *)
                        bschema    := syn_owner;
                        bauthid    := syn_owner(*syn_authid*);
                        btablen^   := syn_tablen;
                        a10rel_sysinfo (syn_ptr)
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        WITH a4p_arr.pbasep^.sbase DO
            IF  kw_index = cak_i_primary
            THEN
                BEGIN
                max    := bkeycolcount;
                col_ptr := a103GetColumn (a4p_arr.pbasep^.sbase, bfirstcolind);
                END
            ELSE
                BEGIN
                IF  acv.a_isReplicationUser
                THEN
                    priv.priv_all_set := priv.priv_all_set + [r_sel];
                (*ENDIF*) 
                max     := bmaxcol;
                col_ptr := a103GetColumn (a4p_arr.pbasep^.sbase, bfirstcolind);
                FOR colno := 1 TO bmaxcol DO
                    BEGIN
                    colnoMap[col_ptr^.cextcolno] := colno;
                    IF  col_ptr^.cnextind <> 0
                    THEN
                        col_ptr := a103GetColumn (a4p_arr.pbasep^.sbase, col_ptr^.cnextind)
                    (*ENDIF*) 
                    END;
                (*ENDFOR*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
        curr_show_colno := a4pos;
        FOR colno := 1 TO max DO
            BEGIN
            IF  kw_index <> cak_i_primary
            THEN
                a06extcolno (a4p_arr.pbasep^.sbase, colno, col_ptr);
            (*ENDIF*) 
            WITH col_ptr^ DO
                BEGIN
                IF  ak47is_visible_column (col_ptr^,
                    a4sh_kind, priv)
                THEN
                    BEGIN
                    (* ADIS 1001495, T.A. 17.09.1998 *)
                    is_syskey := (ccolpropset = [ ctkey, ctopt ]) OR
                          (ccolpropset = [ ctkey, ctopt, ctmulti ]);
                    IF  is_syskey
                    THEN
                        IF  a4p_arr.pbasep^.sbase.btablekind in [tonebase, tview]
                        THEN
                            IF  NOT (ctinvisible in ccolpropset)
                            THEN
                                is_syskey := false;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    a061get_colname (col_ptr^, colname);
                    IF  ((NOT is_syskey) OR
                        ( kw_index = cak_i_primary))
                        AND
                        ((kw_index <> cak_i_primary)    OR
                        ( ctkey         in ccolpropset) OR
                        ( ctjoinviewkey in ccolpropset))
                        AND
                        ((kw_index <> cak_i_column) OR
                        ( a4coln = a01_il_b_identifier ) OR
                        s30eq(a4coln, colname, 1, a4col_len))
                    THEN
                        BEGIN
                        a4pos := curr_show_colno;
                        CASE a4sh_kind OF
                            sh_cons_columns, sh_all_cons_columns :
                                ak47one_constraint_column (acv, a41v,
                                      col_ptr^, priv, colno);
                            sh_odbc_columns :
                                ak47one_odbc_column (acv, a41v, col_ptr^);
                            OTHERWISE
                                BEGIN
                                ak47one_column_show (acv, a41v,
                                      col_ptr^, priv);
                                a40move_i4 (acv, a41v,
                                      colnoMap[col_ptr^.cextcolno], NOT c_null, 0, NOT c_to_undef);
                                END;
                            END;
                        (*ENDCASE*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  (kw_index = cak_i_primary) AND (colno <> max)
                THEN
                    col_ptr := a103GetColumn (a4p_arr.pbasep^.sbase, col_ptr^.cnextind)
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
            END;
        (*ENDFOR*) 
        IF  syn_ptr <> NIL
        THEN
            WITH a4p_arr.pbasep^.sbase DO
                BEGIN
                bschema  := aux_schema;
                bauthid  := aux_authid;
                btablen^ := aux_tablen
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47col_constraint_references (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            VAR priv : tak_privilege);
 
VAR
      jx             : integer;
      colno_consname : integer;
      colno_colname  : integer;
      cons_name      : tsp00_C18;
      cons_type      : tsp00_C12;
      pCol           : tak00_colinfo_ptr;
 
BEGIN
ak47constraint_show (acv, a41v, priv);
(* show record is initialized now *)
WITH a41v DO
    BEGIN (* primary key constraints *)
    a4pos          := 4;
    colno_consname := a4pos;
    cons_name      := 'NOT NULL          ';
    a40move_const (acv, a41v, @cons_name, sizeof (cons_name));
    cons_type := 'CHECK       ';
    a40move_const (acv, a41v, @cons_type, sizeof (cons_type));
    colno_colname := a4pos;
    WITH a4p_arr.pbasep^.sbase DO
        FOR jx := bfirstindex TO blastindex DO
            BEGIN
            pCol := a103GetColumn (a4p_arr.pbasep^.sbase, jx);
            IF  NOT (ctopt in pCol^.ccolpropset)
            THEN
                BEGIN
                a4pos := colno_colname;
                ak47one_constraint_column (acv, a41v,
                      pCol^, priv, pCol^.cextcolno)
                END;
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
    (*ENDWITH*) 
    a4pos     := colno_consname;
    cons_name := 'PRIMARY_KEY       ';
    a40move_const (acv, a41v, @cons_name, sizeof (cons_name));
    cons_type := 'KEY         ';
    a40move_const (acv, a41v, @cons_type, sizeof (cons_type));
    ak47columns_show (acv, a41v, priv, cak_i_primary);
    a4pos := colno_consname;
    IF  acv.a_returncode = 0
    THEN
        ak47unique_cols (acv, a41v, priv);
    (*ENDIF*) 
    a4pos := colno_consname;
    IF  (is_secondary_table in a4p_arr.pbasep^.sbase.blinkexist) AND
        (acv.a_returncode = 0)
    THEN
        ak47foreign_key_cols (acv, a41v, priv)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47constraint_show (VAR acv : tak_all_command_glob;
            VAR a41v      : tak40_show_glob;
            VAR priv      : tak_privilege);
 
VAR
      b_err       : tgg00_BasisError;
      entrytype   : tsp00_C2;
      colno       : integer;
      keypos      : integer;
      ix          : integer;
      fill_x      : integer;
      constr_buf  : tak_sysbufferaddress;
      sysk        : tgg00_SysInfoKey;
 
      object_id   : RECORD
            obj_surrogate : tgg00_Surrogate;
            obj_c4        : tsp00_C4;
      END;
 
 
BEGIN
WITH acv, a41v  DO
    BEGIN
    keypos := 1;
    a40table_column_to_shbuf (acv, a41v, a4p_arr.pbasep, -1, c_with_owner);
    IF  a4p_arr.pbasep^.syskey.sentrytyp >= cak_etemp
    THEN
        entrytype := cak_etmpconstraintname
    ELSE
        entrytype := cak_econstraintname;
    (*ENDIF*) 
    sysk           := a4p_arr.pbasep^.syskey;
    sysk.sentrytyp := entrytype;
    ix             := 1;
    colno          := a4pos;
    WHILE (ix <= a4p_arr.pbasep^.sbase.bnamed_constr) AND
          (a_returncode = 0) DO
        BEGIN
        a10next_sysinfo (acv, sysk, SURROGATE_MXGG00 + 2,
              d_release, entrytype, constr_buf, b_err);
        IF  b_err = e_ok
        THEN
            BEGIN
            a4pos         := colno;
            a40move (acv, a41v, @sysk.sidentifier, sizeof (sysk.sidentifier));
            IF  (a4sh_kind = sh_cons_columns) OR
                (a4sh_kind = sh_all_cons_columns)
            THEN
                ak47constraint_columns (acv, a41v,
                      priv, constr_buf^.sconstrname.cnid)
            ELSE
                BEGIN
                IF  (a4sh_kind in [sh_constraint, sh_all_constraint])
                THEN
                    BEGIN
                    object_id.obj_surrogate := sysk.stableid;
                    FOR fill_x := 1 TO sizeof (object_id.obj_c4) DO
                        object_id.obj_c4[fill_x] := chr(0);
                    (*ENDFOR*) 
                    object_id.obj_c4[3]  :=
                          chr(constr_buf^.sconstrname.cnid DIV 256);
                    object_id.obj_c4[4]  :=
                          chr(constr_buf^.sconstrname.cnid MOD 256);
                    a40move (acv, a41v,
                          @object_id, sizeof (object_id))
                    END;
                (*ENDIF*) 
                a40long_descriptor (acv, a41v,
                      a4p_arr.pbasep^.syskey.stableid,
                      constr_buf^.sconstrname.cnid);
                END;
            (*ENDIF*) 
            END
        ELSE
            IF  b_err <> e_no_next_record
            THEN
                a07_b_put_error (acv, b_err, 1);
            (*ENDIF*) 
        (*ENDIF*) 
        ix := ix + 1
        END;
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47constraint_columns (VAR acv : tak_all_command_glob;
            VAR a41v      : tak40_show_glob;
            VAR priv      : tak_privilege;
            constraint_id : integer);
 
VAR
      b_err        : tgg00_BasisError;
      curr_colno   : integer;
      ix           : integer;
      col_ptr      : tak00_colinfo_ptr;
      cons_type    : tsp00_C12;
      viewdesc_ptr : tak_sysbufferaddress;
      sysk         : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    sysk             := a4p_arr.pbasep^.syskey;
    sysk.sentrytyp   := cak_eviewdesc;
    sysk.slinkage[1] := chr (constraint_id DIV 256);
    sysk.slinkage[2] := chr (constraint_id MOD 256);
    a10get_sysinfo (acv, sysk, d_release, viewdesc_ptr, b_err);
    IF  b_err = e_ok
    THEN
        WITH viewdesc_ptr^.sviewdesc DO
            BEGIN
            cons_type := 'CHECK       ';
            a40move_const (acv, a41v, @cons_type, sizeof (cons_type));
            curr_colno := a4pos;
            ix         := 1;
            WHILE (ix <= vdesc_cnt) AND
                  (a_returncode = 0) DO
                WITH vdescription[ix] DO
                    BEGIN
                    a06extcolno (a4p_arr.pbasep^.sbase,
                          vfromextcolno, col_ptr);
                    IF  ak47is_visible_column (col_ptr^, a4sh_kind, priv)
                    THEN
                        BEGIN
                        a4pos := curr_colno;
                        a40move    (acv, a41v,
                              @col_ptr^.ccolumnn, ord (col_ptr^.ccolumnn_len));
                        a40move_i4 (acv, a41v, ix,
                              NOT c_null, 0, NOT c_to_undef)
                        END;
                    (*ENDIF*) 
                    ix   := ix + 1
                    END;
                (*ENDWITH*) 
            (*ENDWHILE*) 
            END
        (*ENDWITH*) 
    ELSE
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47foreign_key_cols (VAR acv : tak_all_command_glob;
            VAR a41v     : tak40_show_glob;
            VAR priv     : tak_privilege);
 
VAR
      b_err          : tgg00_BasisError;
      fk_ptr         : tak_sysbufferaddress;
      ix             : integer;
      jx             : integer;
      col_ptr        : tak00_colinfo_ptr;
      count          : integer;
      curr_count     : integer;
      curr_colno     : integer;
      colno_consname : integer;
      cons_type      : tsp00_C12;
      linkname       : tsp00_KnlIdentifier;
      sysk           : tgg00_SysInfoKey;
 
BEGIN
curr_count     := 0;
colno_consname := a41v.a4pos;
sysk           := a41v.a4p_arr.pbasep^.syskey;
sysk.sentrytyp := cak_eforeignkey;
REPEAT
    a10get_sysinfo (acv, sysk, d_release, fk_ptr, b_err);
    IF  b_err = e_ok
    THEN
        WITH fk_ptr^.slink DO
            BEGIN
            IF  sysk.slinkage = cak_init_linkage
            THEN
                count := linkcount;
            (*ENDIF*) 
            ix    := 1;
            WHILE (ix <= cak_maxlinkdef) AND (curr_count < count) DO
                WITH a41v, linkdef [ix] DO
                    BEGIN
                    a4pos := colno_consname;
                    a25get_linkname (acv, fk_ptr, ix, linkname);
                    a40move (acv, a41v, @linkname, sizeof (linkname));
                    cons_type := 'FOREIGN KEY ';
                    a40move_const (acv,
                          a41v, @cons_type, sizeof (cons_type));
                    curr_colno := a41v.a4pos;
                    jx         := 1;
                    WHILE (jx <= lcolcount) AND
                          (acv.a_returncode = 0) DO
                        BEGIN
                        a41v.a4pos := curr_colno;
                        a06extcolno (a4p_arr.pbasep^.sbase,
                              lseccolseq[jx], col_ptr);
                        ak47one_constraint_column (acv, a41v, col_ptr^,
                              priv, jx);
                        jx := jx + 1
                        END;
                    (*ENDWHILE*) 
                    curr_count := curr_count + 1;
                    ix         := ix + 1;
                    END;
                (*ENDWITH*) 
            (*ENDWHILE*) 
            a06inc_linkage (sysk.slinkage)
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
UNTIL
    (b_err <> e_ok)      OR
    (curr_count = count) OR
    (acv.a_returncode <> 0)
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47objects (VAR acv : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            is_sequence : boolean);
 
CONST
      c_mult_index   = 2;
 
VAR
      ix               : integer;
      createdate       : tsp00_Int4;
      createtime       : tsp00_Int4;
      zero_c4          : tsp00_C4;
      owner_id         : tgg00_Surrogate;
      owner            : tsp00_KnlIdentifier;
      index_scan_rec   : tak_index_scan_record;
      index_name       : tsp00_KnlIdentifier;
 
      object_id        : RECORD
            obj_surrogate : tgg00_Surrogate;
            obj_c4        : tsp00_C4;
      END;
 
 
BEGIN
IF  is_sequence
THEN
    WITH a41v, a4p_arr.pbasep^.ssequence DO
        BEGIN
        ak47move_owner_id (acv, a41v, seq_owner);
        a40move (acv, a41v, @seq_surrogate, sizeof (seq_surrogate));
        a06determine_username (acv, seq_owner, owner);
        a40move (acv, a41v, @owner,    sizeof (owner));
        a40move (acv, a41v, @seq_name, sizeof (seq_name));
        a40move_const (acv, a41v,
              @a01kw[cak_i_sequence], sizeof (a01kw[cak_i_sequence]));
        a40put_date_time (acv, a41v, seq_date, c_is_date, NOT c_null);
        a40put_date_time (acv, a41v, seq_time, c_is_time, NOT c_null);
        a40move (acv, a41v, NIL, 0);
        a40move (acv, a41v, NIL, 0)
        END
    (*ENDWITH*) 
ELSE
    BEGIN
    WITH a41v, a4p_arr.pbasep^.sbase DO
        BEGIN
        object_id.obj_surrogate := bsurrogate;
        FOR ix := 1 TO sizeof (zero_c4) DO
            zero_c4[ix] := chr(0);
        (*ENDFOR*) 
        object_id.obj_c4 := zero_c4;
        IF  btablekind = tsynonym
        THEN
            owner_id := a4p_arr.pbasep^.ssynonym.syn_owner
        ELSE
            owner_id := bauthid;
        (*ENDIF*) 
        ak47move_owner_id (acv, a41v, owner_id);
        a40move           (acv, a41v, @bsurrogate, sizeof (bsurrogate));
        a06determine_username (acv, owner_id, owner);
        a40move (acv, a41v, @owner, sizeof (owner));
        IF  btablekind = tsynonym
        THEN
            a40move (acv, a41v, @a4p_arr.pbasep^.ssynonym.syn_tablen,
                  sizeof (a4p_arr.pbasep^.ssynonym.syn_tablen))
        ELSE
            a40move (acv, a41v, @btablen^, sizeof (btablen^));
        (*ENDIF*) 
        a4is_systable := false;
        a47table_kind   (acv, a41v, a4p_arr.pbasep^.sbase);
        IF  btablekind = tsynonym
        THEN
            BEGIN
            createdate := a4p_arr.pbasep^.ssynonym.syn_date;
            createtime := a4p_arr.pbasep^.ssynonym.syn_time
            END
        ELSE
            BEGIN
            createdate := bdatecreate;
            createtime := btimecreate
            END;
        (*ENDIF*) 
        a40put_date_time (acv, a41v, createdate, c_is_date, NOT c_null);
        a40put_date_time (acv, a41v, createtime, c_is_time, NOT c_null);
        a40put_date_time (acv, a41v, balterdate,  c_is_date,
              NOT (btablekind in [twithkey, twithoutkey]));
        a40put_date_time (acv, a41v, baltertime,  c_is_time,
              NOT (btablekind in [twithkey, twithoutkey]));
        IF  btablekind in [twithkey, twithoutkey]
        THEN
            BEGIN
            IF  bindexexist
            THEN
                BEGIN
                a24init_index_scan (acv, bsurrogate,
                      index_scan_rec);
                WITH index_scan_rec DO
                    WHILE a24next_named_index (acv, index_scan_rec) DO
                        WITH isr_buf^.smindex.indexdef[isr_index] DO
                            BEGIN
                            a4pos            := 2;
                            object_id.obj_c4 := zero_c4;
                            object_id.obj_c4[c_mult_index] := chr (indexno);
                            a40move (acv, a41v,
                                  @object_id, sizeof (object_id));
                            a4pos := 4;
                            a24get_indexname (acv, isr_buf, isr_index,
                                  index_name);
                            a40move (acv, a41v, @index_name,
                                  sizeof (index_name));
                            a40move_const (acv,
                                  a41v, @a01kw[cak_i_index], mxsp_c8);
                            a40put_date_time (acv, a41v,
                                  idatecre, c_is_date, NOT c_null);
                            a40put_date_time (acv, a41v,
                                  itimecre, c_is_time, NOT c_null);
                            a40move (acv, a41v, NIL, 0);
                            a40move (acv, a41v, NIL, 0)
                            END;
                        (*ENDWITH*) 
                    (*ENDWHILE*) 
                (*ENDWITH*) 
                a24finish_index_scan (acv, index_scan_rec)
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47move_owner_id (VAR acv : tak_all_command_glob;
            VAR a41v            : tak40_show_glob;
            VAR owner_surrogate : tgg00_Surrogate);
 
VAR
      mult     : integer;
      ix       : integer;
      owner_id : tsp00_Int4;
 
BEGIN
owner_id         := 0;
mult             := 1;
FOR ix := sizeof (owner_surrogate) DOWNTO 5 DO
    BEGIN
    owner_id := owner_id + mult * ord (owner_surrogate[ix]);
    mult     := mult * 256
    END;
(*ENDFOR*) 
a40move_i4 (acv,
      a41v, owner_id,  NOT c_null, 0, NOT c_to_undef)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47unique_cols (VAR acv : tak_all_command_glob;
            VAR a41v     : tak40_show_glob;
            VAR priv     : tak_privilege);
 
VAR
      exit_loop      : boolean;
      jx             : integer;
      col_ptr        : tak00_colinfo_ptr;
      col_count      : integer;
      curr_colno     : integer;
      cons_type      : tsp00_C12;
      index_set      : tak_columnset;
      indexname      : tsp00_KnlIdentifier;
      index_scan_rec : tak_index_scan_record;
 
BEGIN
index_set := [];
IF  a41v.a4p_arr.pbasep^.sbase.bindexexist
THEN
    BEGIN
    a24init_index_scan (acv, a41v.a4p_arr.pbasep^.sbase.bsurrogate,
          index_scan_rec);
    WITH a41v, index_scan_rec DO
        WHILE a24next_named_index (acv, index_scan_rec) DO
            WITH isr_buf^.smindex.indexdef[isr_index] DO
                IF  iunique
                THEN
                    BEGIN
                    a24get_indexname (acv, isr_buf, isr_index,
                          indexname);
                    a40move (acv, a41v, @indexname, sizeof (indexname));
                    cons_type := 'UNIQUE_CONST';
                    a40move_const (acv,
                          a41v, @cons_type, sizeof (cons_type));
                    jx := 1;
                    col_count := 0;
                    exit_loop := false;
                    REPEAT
                        IF  col_count = MAX_COL_SEQUENCE_GG00
                        THEN
                            exit_loop := true
                        ELSE
                            IF  icolseq[col_count+1] > 0
                            THEN
                                col_count := col_count + 1
                            ELSE
                                exit_loop := true;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    UNTIL
                        exit_loop;
                    (*ENDREPEAT*) 
                    curr_colno := a41v.a4pos;
                    WHILE (jx <= col_count) AND
                          (acv.a_returncode = 0) DO
                        BEGIN
                        a06extcolno (a4p_arr.pbasep^.sbase,
                              icolseq[jx], col_ptr);
                        a41v.a4pos := curr_colno;
                        ak47one_constraint_column (acv, a41v, col_ptr^,
                              priv, jx);
                        jx := jx + 1
                        END;
                    (*ENDWHILE*) 
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDWHILE*) 
    (*ENDWITH*) 
    a24finish_index_scan (acv, index_scan_rec)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak47is_visible_column (VAR col_info : tak00_columninfo;
            sh_kind  : tgg00_ShowKind;
            VAR priv : tak_privilege) : boolean;
 
BEGIN
WITH col_info DO
    ak47is_visible_column :=
          (NOT (ctdropped in ccolpropset))
          AND
          (NOT (ctinvisible in ccolpropset))
          AND
          ((priv.priv_all_set <> [  ])            OR
          (sh_kind >= sh_all_column)              OR
          ((priv.priv_col_exist <> [  ]) AND
          (cextcolno in priv.priv_upd_set))  OR
          ((priv.priv_col_exist <> [  ]) AND
          (cextcolno in priv.priv_sel_set)))
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47one_constraint_column (VAR acv : tak_all_command_glob;
            VAR a41v     : tak40_show_glob;
            VAR col_info : tak00_columninfo;
            VAR priv     : tak_privilege;
            col_no       : integer);
 
BEGIN
WITH a41v DO
    BEGIN
    IF  ak47is_visible_column (col_info, a4sh_kind, priv)
    THEN
        BEGIN
        a40move    (acv, a41v, @col_info.ccolumnn, ord(col_info.ccolumnn_len));
        a40move_i4 (acv, a41v, col_no, NOT c_null, 0, NOT c_to_undef)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47table_add (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            VAR priv : tak_privilege);
 
CONST
      (* PTS 1105104 E.Z. *)
      c_colno_pages     = 13;
      c_colno_rows      = 12;
      c_colno_updstdate = 7;
      c_colno_updsttime = 8;
 
VAR
      ok           : boolean;
      is_dba       : boolean;
      comment_ex   : boolean;
      comment_kind : tak_comment_type;
      ix           : integer;
      jx           : integer;
      colcount     : integer;
      createdate   : tsp00_Int4;
      createtime   : tsp00_Int4;
      updstatdate  : tsp00_Int4;
      updstattime  : tsp00_Int4;
      alterdate    : tsp00_Int4;
      altertime    : tsp00_Int4;
      rows         : tsp00_Int4;
      pages        : tsp00_Int4;
      sample_pcnt  : tsp00_Int4;
      sample_rows  : tsp00_Int4;
      root         : tsp00_PageNo;
      base_ptr     : tak_sysbufferaddress;
      commentId    : tgg00_Surrogate;
      authname     : tsp00_KnlIdentifier;
      prn          : tsp00_C40;
 
BEGIN
WITH acv, a41v, a4p_arr.pbasep^.sbase  DO
    BEGIN
    (* key construction *)
    a40table_column_to_shbuf (acv, a41v, a4p_arr.pbasep, -1, c_with_owner);
    (* privileges *)
    a40_p_priv (priv, prn, 0);
    a40move_const  (acv, a41v, @prn, 28);
    a47table_kind (acv, a41v, a4p_arr.pbasep^.sbase);
    (* update statistics date, time *)
    WITH a4p_arr.pbasep^, ssynonym, sbase DO
        BEGIN
        rows         := cak_is_undefined;
        pages        := cak_is_undefined;
        IF  btablekind = tsynonym
        THEN
            BEGIN
            base_ptr := a4p_arr.px[ 3 ];
            a06determine_username (acv, syn_owner, authname);
            a06check_username (acv, authname, is_dba, ok);
            IF  NOT (ok)
            THEN
                BEGIN
                a07_b_put_error (acv, e_unknown_user,
                      a_ap_tree^[ a4ti ].n_pos);
                END;
            (*ENDIF*) 
            createdate   := syn_date;
            createtime   := syn_time;
            updstatdate  := cak_is_undefined;
            updstattime  := cak_is_undefined;
            alterdate    := 0;
            altertime    := 0;
            comment_ex   := syncomment;
            comment_kind := cm_synonym;
            IF  comment_ex
            THEN
                commentId := a4p_arr.pbasep^.syskey.stableid
            ELSE
                BEGIN
                (* synonym has no own comment,                            *)
                (* look for a comment on the table the synonym stands for *)
                (* In this case the synonym inherits this comment         *)
                comment_ex := base_ptr^.sbase.bcomment;
                IF  comment_ex
                THEN
                    BEGIN
                    comment_kind := cm_table;
                    commentId    := base_ptr^.sbase.bsurrogate;
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            comment_kind := cm_table;
            commentId    := a4p_arr.pbasep^.syskey.stableid;
            base_ptr     := a4p_arr.pbasep;
            createdate   := bdatecreate;
            createtime   := btimecreate;
            (* PTS 1116837 E.Z. *)
            updstatdate  := bdatecreate;
            updstattime  := btimecreate;
            IF  a4strategy.str_catalog.scat_col_needed[c_colno_pages]     OR
                a4strategy.str_catalog.scat_col_needed[c_colno_rows]      OR
                a4strategy.str_catalog.scat_col_needed[c_colno_updstdate] OR
                a4strategy.str_catalog.scat_col_needed[c_colno_updsttime]
            THEN
                a28info (acv, a4p_arr.pbasep, pages, rows,
                      updstatdate, updstattime);
            (*ENDIF*) 
            IF  btablekind in [twithkey, twithoutkey]
            THEN
                BEGIN
                alterdate    := balterdate;
                altertime    := baltertime
                END
            ELSE
                BEGIN
                alterdate := 0;
                altertime := 0
                END;
            (*ENDIF*) 
            comment_ex := bcomment
            END;
        (*ENDIF*) 
        a40put_date_time (acv, a41v, createdate, c_is_date, NOT c_null);
        a40put_date_time (acv, a41v, createtime, c_is_time, NOT c_null);
        a40put_date_time (acv, a41v, updstatdate,
              c_is_date, updstatdate = cak_is_undefined);
        a40put_date_time(acv, a41v, updstattime,
              c_is_time, updstattime = cak_is_undefined);
        END;
    (*ENDWITH*) 
    a40put_date_time (acv, a41v, alterdate,
          c_is_date, alterdate = 0);
    a40put_date_time(acv, a41v, altertime,
          c_is_time, alterdate = 0);
    a40move (acv, a41v, @bsurrogate, sizeof (bsurrogate));
    a40move_i4 (acv, a41v, rows,
          rows  = cak_is_undefined, 0, false);
    a40move_i4 (acv, a41v, pages,
          pages = cak_is_undefined, 0, false);
    IF  btablekind = tsynonym (* PTS 1110042 *)
    THEN
        a40move (acv, a41v, NIL, 0)
    ELSE
        BEGIN
        CASE a4p_arr.pbasep^.sbase.bsqlmode OF
            sqlm_ansi :
                ix := cak_i_ansi;
            sqlm_db2  :
                ix := cak_i_db2;
            sqlm_oracle :
                ix := cak_i_oracle;
            OTHERWISE
                ix := cak_i_internal;
            END;
        (*ENDCASE*) 
        a40move_const (acv, a41v, @a01kw[ix], sizeof (a01kw[ix]));
        END;
    (*ENDIF*) 
    IF  (a4p_arr.pbasep^.sbase.btablekind in
        [twithkey, twithoutkey])
    THEN
        BEGIN
        a40move_const (acv, a41v, @a40yes_no [ftsDynamic_egg00 in
              a4p_arr.pbasep^.sbase.btreeid.fileType_gg00],
              sizeof (a40yes_no[true]));
        (* PTS 1117381 E.Z. *)
        a40move_const (acv, a41v, @a40yes_no [ftsArchive_egg00 in
              a4p_arr.pbasep^.sbase.btreeid.fileType_gg00],
              sizeof (a40yes_no[true]));
        IF  a4strategy.str_catalog.scat_col_needed[a4pos]
        THEN
            BEGIN
            b01filestate (a_transinf.tri_trans,
                  a4p_arr.pbasep^.sbase.btreeid);
            a40move_const (acv, a41v, @a40yes_no[
                  a_transinf.tri_trans.trError_gg00 = e_file_read_only],
                  sizeof (a40yes_no[true]));
            END
        ELSE
            a40move (acv, a41v, NIL, 0);
        (*ENDIF*) 
        a40move_const (acv, a41v,
              @a40yes_no[a4p_arr.pbasep^.sbase.bunloaded],
              sizeof (a40yes_no[true]));
        a40move_const (acv, a41v, @a40yes_no [ta_fact in
              a4p_arr.pbasep^.sbase.battributes],
              sizeof (a40yes_no[true]));
        a40move_const (acv, a41v, @a40yes_no [ta_dimension in
              a4p_arr.pbasep^.sbase.battributes],
              sizeof (a40yes_no[true]));
        a40move_const (acv, a41v, @a40yes_no [ta_bwhierarchy in
              a4p_arr.pbasep^.sbase.battributes],
              sizeof (a40yes_no[true]));
        (* PTS 1126711 E.Z. *)
        a40move_const (acv, a41v, @a40yes_no [ta_no_fixed_length_column in
              a4p_arr.pbasep^.sbase.battributes],
              sizeof (a40yes_no[true]));
        a40move_const (acv, a41v, @a40yes_no [ta_cluster_key in
              a4p_arr.pbasep^.sbase.battributes],
              sizeof (a40yes_no[true]));
        END
    ELSE
        (* PTS 1117381 E.Z. *)
        FOR ix := 1 TO 9 DO
            a40move (acv, a41v, NIL, 0);
        (*ENDFOR*) 
    (*ENDIF*) 
    IF  a4p_arr.pbasep^.sbase.btablekind in
        [tview, tonebase, tcomplexview]
    THEN
        BEGIN
        a40move_const (acv, a41v,
              @a40yes_no [a4p_arr.pbasep^.sbase.bv_checkopt], sizeof (a40yes_no[true]));
        a40move_const (acv, a41v,
              @a40yes_no [tcomplexview = a4p_arr.pbasep^.sbase.btablekind], sizeof (a40yes_no[true]));
        END
    ELSE
        BEGIN
        a40move (acv, a41v, NIL, 0);
        a40move (acv, a41v, NIL, 0);
        END;
    (*ENDIF*) 
    IF  a4p_arr.pbasep^.sbase.btablekind in
        [twithkey, twithoutkey, tonebase, tresult]
    THEN
        BEGIN
        IF  a4strategy.str_catalog.scat_col_needed[a4pos] AND
            (a4p_arr.pbasep^.sbase.btreeid.fileRoot_gg00 = NIL_PAGE_NO_GG00)
        THEN
            b01filestate (a_transinf.tri_trans,
                  a4p_arr.pbasep^.sbase.btreeid);
        (*ENDIF*) 
        root := a4p_arr.pbasep^.sbase.btreeid.fileRoot_gg00
        END
    ELSE
        root := NIL_PAGE_NO_GG00;
    (*ENDIF*) 
    a40move_i4 (acv, a41v, btreeid.fileRoot_gg00,
          root = NIL_PAGE_NO_GG00, 0, NOT c_to_undef);
    a40comment_descriptor (acv, a41v, comment_ex,
          commentId, 1,comment_kind);
    IF  a4strategy.str_catalog.scat_col_needed[a4pos]
    THEN
        BEGIN
        IF  btablekind = tsynonym
        THEN (* reload a4p_arr with table description   *)
            (* of the table the synonym is defined for *)
            a4p_arr.pbasep := a4p_arr.px[3];
        (*ENDIF*) 
        CASE a4p_arr.pbasep^.sbase.btablekind OF
            twithoutkey :
                colcount :=
                      a4p_arr.pbasep^.sbase.bmaxcol -
                      a4p_arr.pbasep^.sbase.bcntdropcol - 1;
            tonebase :
                BEGIN
                colcount := 0;
                FOR jx := a4p_arr.pbasep^.sbase.bfirstindex TO
                      a4p_arr.pbasep^.sbase.blastindex DO
                    WITH a103GetColumn (a4p_arr.pbasep^.sbase, jx)^ DO
                        IF  NOT (ctdropped in ccolpropset  ) AND
                            NOT (ctinvisible in ccolpropset)
                        THEN
                            colcount := colcount + 1
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (*ENDFOR*) 
                END;
            OTHERWISE
                colcount := a4p_arr.pbasep^.sbase.bmaxcol -
                      a4p_arr.pbasep^.sbase.bcntdropcol;
            END;
        (*ENDCASE*) 
        a40move_i4 (acv, a41v, colcount,
              NOT c_null, 0, NOT c_to_undef)
        END
    ELSE
        a40move (acv, a41v, NIL, 0);
    (*ENDIF*) 
    a4is_systable := false;
    a47table_kind (acv, a41v, a4p_arr.pbasep^.sbase);
    sample_pcnt := cak_is_undefined;
    sample_rows := cak_is_undefined;
    IF  a4p_arr.pbasep^.sbase.btablekind in
        [twithkey, twithoutkey]
    THEN
        IF  a4p_arr.pbasep^.sbase.bsample < 0
        THEN
            sample_pcnt := - a4p_arr.pbasep^.sbase.bsample
        ELSE
            sample_rows := a4p_arr.pbasep^.sbase.bsample;
        (*ENDIF*) 
    (*ENDIF*) 
    a40move_i4 (acv, a41v, sample_pcnt,
          sample_pcnt < 0, 0, NOT c_to_undef);
    a40move_i4 (acv, a41v, sample_rows,
          sample_rows < 0, 0, NOT c_to_undef)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a47table_kind (VAR acv : tak_all_command_glob;
            VAR a41v     : tak40_show_glob;
            VAR base_rec : tak_baserecord);
 
VAR
      c8 : tsp00_C8;
 
BEGIN
IF  a41v.a4is_systable
THEN
    c8 := c_system
ELSE
    WITH base_rec DO
        CASE btablekind OF
            tresult :
                c8 := c_result;
            twithkey, twithoutkey, tcatalog_table :
                c8 := c_table;
            tonebase :
                IF  btreeid.fileTabId_gg00 = base_rec.bsurrogate
                THEN (* pseudo view created by save catalog *)
                    c8 := c_table
                ELSE
                    c8 := c_view;
                (*ENDIF*) 
            tview, tcomplexview, tshow_view :
                c8 := c_view;
            tsynonym :
                c8 := c_synonym;
            tdb2view :
                c8 := c_gateway;
            OTHERWISE
                c8 := bsp_c8;
            END;
        (*ENDCASE*) 
    (*ENDWITH*) 
(*ENDIF*) 
a40move_const (acv, a41v, @c8, sizeof (c8))
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47view_add (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
CONST
      c_length_only      = true;
 
VAR
      textlen      : tsp00_Int4;
      ix           : integer;
      movelen      : tsp00_Int4;
      bufsize      : tsp00_Int4;
      colno        : integer;
      textbuf      : tsp00_MoveObjPtr;
 
BEGIN
WITH acv, a41v, a4p_arr.pbasep^.sbase  DO
    BEGIN
    a40table_column_to_shbuf (acv, a41v, a4p_arr.pbasep, -1, c_with_owner);
    IF  a4sh_kind = sh_show_view
    THEN
        BEGIN
        textbuf := NIL;
        bufsize := 0;
        a48get_view_def_string (acv,
              a4p_arr.pbasep^.syskey.stableid,
              c_length_only, 0, a_out_packet^.sp1_varpart, bufsize);
        IF  a_returncode = 0
        THEN
            BEGIN
            a10new (acv, bufsize, textbuf);
            textlen := 0;
            a48get_view_def_string (acv,
                  a4p_arr.pbasep^.syskey.stableid,
                  NOT c_length_only, bufsize, textbuf^, textlen)
            END;
        (*ENDIF*) 
        ix    := 1;
        colno := a4pos;
        WHILE (textlen > 0) AND (a_returncode = 0) DO
            BEGIN
            movelen := textlen;
            IF  movelen > mxsp_c80 * a01char_size
            THEN
                movelen := mxsp_c80 * a01char_size;
            (* PTS 1111608 E.Z. *)
            (* truncation of blanks does not work. the blanks will be appended by a40move *)
            (* and the truncated ones will be in the beginning of the next line           *)
            (*ENDIF*) 
            a4pos := colno;
            a40move (acv, a41v, @textbuf^[ix], movelen);
            ix      := ix + movelen;
            textlen := textlen - movelen
            END;
        (*ENDWHILE*) 
        a10dispose (acv, textbuf)
        END
    ELSE
        BEGIN
        textlen := 0;
        a48get_view_def_string (acv,
              a4p_arr.pbasep^.syskey.stableid,
              c_length_only, 0, a_out_packet^.sp1_varpart, textlen);
        (* length in character, not in bytes. *)
        a40move_i4 (acv, a41v, textlen DIV a01char_size,
              NOT c_null, 0, NOT c_to_undef);
        a40long_descriptor (acv, a41v, a4p_arr.pbasep^.syskey.stableid, 0)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47view_uses_table (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
CONST
      c_found = csp_maxint2;
 
VAR
      ok       : boolean;
      b_err    : tgg00_BasisError;
      ix       : integer;
      jx       : integer;
      phase    : integer;
      refname_p: tsp00_Int4;
      sys_ptr  : tak_sysbufferaddress;
      c8       : tsp00_C8;
      tabid    : tgg00_Surrogate;
      schema   : tsp00_KnlIdentifier;
      table    : tsp00_KnlIdentifier;
      from_ptr : tak_sysbufferaddress;
      sysk     : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a41v  DO
    BEGIN
    a40table_column_to_shbuf (acv, a41v, a4p_arr.pbasep, -1, c_with_owner);
    IF  a4is_systable
    THEN
        c8 := c_system
    ELSE
        c8 := c_view;
    (*ENDIF*) 
    a40move_const (acv, a41v, @c8, sizeof (c8));
    refname_p := a4pos;
    sysk           := a4p_arr.pbasep^.syskey;
    sysk.sentrytyp := cak_eviewtext;
    a10get_sysinfo (acv, sysk, d_fix, sys_ptr, b_err);
    IF  b_err = e_ok
    THEN
        WITH sys_ptr^.sviewtext DO
            BEGIN
            ix    := 1;
            phase := 1;
            WHILE (ix <= vttabcount) AND
                  (a_returncode = 0) DO
                BEGIN
                a4pos := refname_p;
                jx := 1;
                IF  phase = 1
                THEN
                    BEGIN
                    tabid := vttab[ix].vtttableid;
                    WHILE jx < ix DO
                        IF  vttab[jx].vtttableid =
                            vttab[ix].vtttableid
                        THEN
                            jx := c_found
                        ELSE
                            jx := jx + 1;
                        (*ENDIF*) 
                    (*ENDWHILE*) 
                    END
                ELSE
                    IF  vttab[ix].vttfromTableInfo = fti_synonym
                    THEN
                        BEGIN
                        tabid := vttab[ix].vttreftabid;
                        WHILE jx < ix DO
                            IF  (vttab[jx].vttfromTableInfo = fti_synonym) AND
                                (vttab[jx].vttreftabid      = vttab[ix].vttreftabid)
                            THEN
                                jx := c_found
                            ELSE
                                jx := jx + 1;
                            (*ENDIF*) 
                        (*ENDWHILE*) 
                        END
                    ELSE
                        jx := c_found;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  jx <> c_found
                THEN
                    a06_systable_get (acv, d_fix,
                          tabid, from_ptr, NOT c_all, ok)
                ELSE
                    ok := false;
                (*ENDIF*) 
                IF  ok
                THEN
                    BEGIN
                    IF  from_ptr^.sbase.btablekind = tsynonym
                    THEN
                        BEGIN
                        schema := a01_il_b_identifier;
                        table  := from_ptr^.ssynonym.syn_tablen;
                        END
                    ELSE
                        BEGIN
                        a103GetSchemaName (acv,
                              from_ptr^.sbase.bschema, schema);
                        table := from_ptr^.sbase.btablen^;
                        END;
                    (*ENDIF*) 
                    a40move (acv, a41v, @schema,   sizeof (schema));
                    a40move (acv, a41v, @table, sizeof(table));
                    a47table_kind (acv, a41v, from_ptr^.sbase);
                    IF  from_ptr <> a4p_arr.pinfop
                    THEN
                        a10rel_sysinfo (from_ptr)
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                ix := ix + 1;
                IF  (ix > vttabcount) AND (phase = 1)
                THEN
                    BEGIN
                    phase := 2;
                    ix    := 1
                    END;
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            a10rel_sysinfo (sys_ptr)
            END
        (*ENDWITH*) 
    ELSE
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47one_column_show (VAR acv : tak_all_command_glob;
            VAR a41v       : tak40_show_glob;
            VAR col_info   : tak00_columninfo;
            VAR priv       : tak_privilege);
 
VAR
      prn       : tsp00_C40;
 
BEGIN
WITH acv, a41v  DO
    BEGIN
    a40column_description (acv, a41v,
          a4p_arr.pbasep^.sbase.btablekind,
          col_info, false);
    (*---------- columnprivileges ==> show info ----------------*)
    a40_p_priv    (priv, prn, col_info.cextcolno);
    a40move_const (acv, a41v, @prn, 28);
    (*--- constraint (yes, no), default ==> show info ---*)
    a47range_default (acv, a41v, col_info)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47one_odbc_column (VAR acv : tak_all_command_glob;
            VAR a41v       : tak40_show_glob;
            VAR col_info   : tak00_columninfo);
 
CONST
      c_oracle = true;
 
VAR
      datalen  : integer;
      colno    : integer;
      len      : integer;
      nullable : integer;
      datatype : tsp00_Sname;
      code     : tsp00_C10;
 
BEGIN
a40table_column_to_shbuf (acv, a41v, a41v.a4p_arr.pbasep, -1, c_with_owner);
a40move  (acv, a41v, @col_info.ccolumnn, ord (col_info.ccolumnn_len));
a40datatype_code (col_info,
      NOT c_oracle, acv.a_comp_type, datatype, code, datalen);
a40move_const (acv, a41v, @datatype, sizeof(datatype));
a40move_i4    (acv, a41v, datalen,
      datalen = csp_maxint4, 0, NOT c_to_undef);
CASE col_info.cdatatyp OF
    dfixed :
        IF  col_info.cbinary
        THEN
            IF  datalen = 10
            THEN
                len := 4
            ELSE
                len := 2
            (*ENDIF*) 
        ELSE
            len := col_info.cdatalen + 2;
        (*ENDIF*) 
    dfloat :
        CASE (col_info.cdatalen DIV 8 + 1) * 4 OF
            4 :
                len := 4;
            8 :
                len := 8;
            OTHERWISE
                len := 8;
            END;
        (*ENDCASE*) 
    OTHERWISE
        len := col_info.cdatalen;
    END;
(*ENDCASE*) 
a40move_i4 (acv, a41v, len, NOT c_null, 0, NOT c_to_undef);
a40move_i4 (acv, a41v, col_info.cdatafrac - cak_frac_offset,
      col_info.cdatatyp <> dfixed, 0, NOT c_to_undef);
a40move_i4 (acv, a41v, 10, NOT (col_info.cdatatyp in [dfixed, dfloat]),
      0, NOT c_to_undef);
IF  (ctopt in col_info.ccolpropset) AND
    NOT (ctkey in col_info.ccolpropset)
THEN
    nullable := 1
ELSE
    nullable := 0;
(*ENDIF*) 
a40move_i4 (acv, a41v,
      nullable, NOT c_null, 0, NOT c_to_undef);
IF  a41v.a4p_arr.pbasep^.sbase.btablekind in
    [twithoutkey, tcatalog_table, tcomplexview]
THEN (* forget the invisible SYSKEY. *)
    colno := col_info.cextcolno - 1
ELSE
    colno := col_info.cextcolno;
(*ENDIF*) 
a40move_i4 (acv, a41v,
      colno, NOT c_null, 0, NOT c_to_undef);
ak47key_colno (acv, a41v, col_info);
a40move_const (acv, a41v, @code, sizeof(code));
(* PTS 1136013 *)
a47range_default (acv, a41v, col_info);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a47range_default (VAR acv : tak_all_command_glob;
            VAR a41v     : tak40_show_glob;
            VAR col_info : tak00_columninfo);
 
CONST
      c_get_default   = true;
 
VAR
      stat_rec_found : boolean;
      sysbuf         : tak_sysbufferaddress;
      ix             : integer;
      colno          : tsp00_Int4;
      startvalue     : tsp00_C20;
      dom_owner      : tsp00_KnlIdentifier;
      statistics     : tak_column_statistics;
 
BEGIN
WITH acv, a41v  DO
    WITH a4p_arr DO
        BEGIN
        (*---------- default value ==> show info -------------*)
        sysbuf := NIL;
        IF  (a4strategy.str_catalog.scat_col_needed[a4pos]) OR
            (a4strategy.str_catalog.scat_col_needed[a4pos+1])
        THEN
            IF  ctdefault in col_info.ccolpropset
            THEN
                ak47get_default_domain_info (acv, a41v,
                      col_info, c_get_default, sysbuf)
            ELSE
                IF  ctserial in col_info.ccolpropset
                THEN
                    ak47serial (acv, a41v, sysbuf, startvalue)
                ELSE
                    sysbuf := NIL;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  sysbuf <> NIL
        THEN
            IF  ctserial in col_info.ccolpropset
            THEN
                ak47put_serial (acv, a41v, col_info, startvalue)
            ELSE
                a40default (acv, a41v, col_info, sysbuf^.sdefault)
            (*ENDIF*) 
        ELSE
            BEGIN
            (* default value *)
            a40move (acv, a41v, NIL, 0);
            (* default function *)
            a40move (acv, a41v, NIL, 0);
            END;
        (*ENDIF*) 
        IF  a4sh_kind in [sh_column, sh_all_column]
        THEN
            BEGIN
            (*---------- domain name ==> show info -------------*)
            IF  ctdomain in col_info.ccolpropset
            THEN
                ak47get_default_domain_info (acv, a41v,
                      col_info, NOT c_get_default, sysbuf)
            ELSE
                sysbuf := NIL;
            (*ENDIF*) 
            IF  sysbuf <> NIL
            THEN
                WITH sysbuf^.scol_uses_dom DO
                    BEGIN
                    a06determine_username (acv, cud_owner,
                          dom_owner);
                    a40move (acv, a41v, @dom_owner, sizeof (dom_owner));
                    a40move (acv, a41v, @cud_name,
                          cud_reclen - (sizeof (sysbuf^.scol_uses_dom) -
                          sizeof (cud_name)));
                    END
                (*ENDWITH*) 
            ELSE
                BEGIN
                a40move (acv, a41v, NIL, sizeof (tsp00_KnlIdentifier));
                a40move (acv, a41v, NIL, sizeof (tsp00_KnlIdentifier))
                END;
            (*ENDIF*) 
            (*------------- column no ==> show info -------------*)
            IF  a4p_arr.pbasep^.sbase.btablekind in
                [twithoutkey, tcatalog_table, tcomplexview]
            THEN (* forget the invisible SYSKEY. *)
                colno := col_info.cextcolno - 1
            ELSE
                colno := col_info.cextcolno;
            (*ENDIF*) 
            a40move_i4 (acv, a41v,
                  colno, NOT c_null, 0, NOT c_to_undef);
            (*-------- key column no ==> show info -------------*)
            ak47key_colno (acv, a41v, col_info);
            (*------ no of leaf pages ==> show info -------------*)
            IF  NOT a4strategy.str_catalog.scat_col_needed[a4pos]
            THEN
                statistics.c_values := cak_is_undefined
            ELSE
                BEGIN
                stat_rec_found := false;
                a28column_statistics (acv, a4p_arr.pbasep,
                      col_info, c_inferStats, statistics, stat_rec_found);
                END;
            (*ENDIF*) 
            a40move_i4 (acv, a41v, statistics.c_values,
                  statistics.c_values < 0, 0, NOT c_to_undef);
            (*----------- table kind ==> show info -------------*)
            a47table_kind (acv, a41v, a4p_arr.pbasep^.sbase);
            (*---- create and alter date/time ==> show info ----*)
            IF  ((a4strategy.str_catalog.scat_col_needed[a4pos]) OR
                (a4strategy.str_catalog.scat_col_needed[a4pos+1]) OR
                (a4strategy.str_catalog.scat_col_needed[a4pos+2]) OR
                (* PTS 2059 *)
                (a4strategy.str_catalog.scat_col_needed[a4pos+3]))
                AND
                (ctaltered in col_info.ccolpropset)
            THEN
                BEGIN
                (* PTS 1117415 E.Z. *)
                sysbuf := NIL;
                IF  a4p_arr.pbasep^.sbase.btablekind in
                    [twithkey, twithoutkey]
                THEN
                    ak47get_alter_date_info (acv,
                          a41v, col_info, sysbuf);
                (*ENDIF*) 
                IF  a_returncode = 0
                THEN
                    IF  sysbuf <> NIL
                    THEN
                        WITH sysbuf^.salterdate DO
                            BEGIN
                            a40put_date_time (acv,
                                  a41v, ad_createdate,
                                  c_is_date, NOT c_null);
                            a40put_date_time(acv,
                                  a41v, ad_createtime,
                                  c_is_time, NOT c_null);
                            a40put_date_time (acv,
                                  a41v, ad_alterdate,
                                  c_is_date, NOT c_null);
                            a40put_date_time(acv,
                                  a41v, ad_altertime,
                                  c_is_time, NOT c_null)
                            END
                        (*ENDWITH*) 
                    ELSE
                        FOR ix := 1 TO 4 DO
                            a40move (acv, a41v, NIL, 0)
                        (*ENDFOR*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                WITH a4p_arr.pbasep^.sbase DO
                    BEGIN
                    a40put_date_time (acv, a41v, bdatecreate,
                          c_is_date, NOT c_null);
                    a40put_date_time(acv, a41v, btimecreate,
                          c_is_time, NOT c_null);
                    a40put_date_time (acv, a41v, bdatecreate,
                          c_is_date, NOT c_null);
                    a40put_date_time(acv, a41v, btimecreate,
                          c_is_time, NOT c_null)
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  a4sh_kind in [sh_column, sh_all_column, sh_odbc_columns]
        THEN
            (*------- comment descriptor ==> show info -------*)
            a40comment_descriptor (acv, a41v,
                  ctcomment in col_info.ccolpropset,
                  a4p_arr.pbasep^.syskey.stableid,
                  col_info.cextcolno, cm_column);
        (*ENDIF*) 
        IF  a4sh_kind in [sh_column, sh_all_column]
        THEN
            BEGIN
            (*------- object id ==> show info ----------------*)
            a40move (acv, a41v,
                  @a4p_arr.pbasep^.syskey.stableid,
                  sizeof (a4p_arr.pbasep^.syskey.stableid));
            (*------- nullable ==> show info ----------------*)
            a40move_const (acv, a41v,
                  @a40yes_no[(ctopt in col_info.ccolpropset) AND
                  NOT (ctkey in col_info.ccolpropset)],
                  sizeof (a40yes_no[true]));
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47get_alter_date_info (VAR acv : tak_all_command_glob;
            VAR a41v     : tak40_show_glob;
            VAR col_info : tak00_columninfo;
            VAR buf      : tak_sysbufferaddress);
 
VAR
      b_err : tgg00_BasisError;
      sysk  : tgg00_SysInfoKey;
 
BEGIN
WITH a41v DO
    BEGIN
    sysk.stableid    := a4p_arr.pbasep^.syskey.stableid;
    sysk.sentrytyp   := cak_ealterdate;
    sysk.slinkage[1] := chr (col_info.creccolno DIV 256);
    sysk.slinkage[2] := chr (col_info.creccolno MOD 256);
    sysk.skeylen     := mxak_standard_sysk;
    a10get_sysinfo (acv, sysk, d_release, buf, b_err);
    IF  (b_err <> e_ok)
    THEN
&       ifdef trace
        a07_b_put_error (acv, b_err, 1);
&   else
    (*ENDIF*) 
    IF  b_err <> e_sysinfo_not_found
    THEN
        a07_b_put_error (acv, b_err, 1);
&   endif
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47get_default_domain_info (VAR acv : tak_all_command_glob;
            VAR a41v     : tak40_show_glob;
            VAR col_info : tak00_columninfo;
            get_default  : boolean;
            VAR buf      : tak_sysbufferaddress);
 
VAR
      b_err : tgg00_BasisError;
      colno : integer;
      sysk  : tgg00_SysInfoKey;
 
BEGIN
WITH a41v, a4p_arr DO
    BEGIN
    colno := col_info.creccolno;
    IF  get_default AND (a4sh_kind = sh_u_domain)
    THEN
        BEGIN
        sysk.stableid  := a4dombuf^.syskey.stableid;
        sysk.sentrytyp := cak_edefault;
        END
    ELSE
        BEGIN
        sysk.stableid := pbasep^.syskey.stableid;
        CASE pbasep^.sbase.btablekind OF
            tonebase :
                WITH pbasep^.sbase DO
                    BEGIN
                    sysk.stableid := btreeid.fileTabId_gg00;
                    END;
                (*ENDWITH*) 
            tview :
                a06_view_get_basetable (acv, sysk.stableid,
                      col_info.ctabno, sysk.stableid);
            OTHERWISE ;
            END;
        (*ENDCASE*) 
        IF  get_default
        THEN
            IF  pbasep^.syskey.sentrytyp >= cak_etemp
            THEN
                sysk.sentrytyp := cak_etempdefault
            ELSE
                sysk.sentrytyp := cak_edefault
            (*ENDIF*) 
        ELSE
            sysk.sentrytyp := cak_edomainusage;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  colno > 0
    THEN
        BEGIN
        sysk.slinkage[1] := chr (colno DIV 256);
        sysk.slinkage[2] := chr (colno MOD 256);
        sysk.skeylen     := mxak_standard_sysk;
        a10get_sysinfo (acv, sysk, d_release, buf, b_err);
&       ifdef trace
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1)
&                 endif
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47key_colno (VAR acv : tak_all_command_glob;
            VAR a41v     : tak40_show_glob;
            VAR col_info : tak00_columninfo);
 
VAR
      found  : boolean;
      colno  : integer;
      keyind : integer;
      pCol   : tak00_colinfo_ptr;
 
BEGIN
(*-------- key column no ==> show info -------------*)
IF  ((ctkey in col_info.ccolpropset) AND
    ( a41v.a4p_arr.pbasep^.sbase.btablekind in [twithkey,twithoutkey, tonebase]))
    OR
    (ctjoinviewkey in col_info.ccolpropset) (* PTS 1104903, T.A. 04.01.2000 *)
THEN
    BEGIN
    colno  := 1;
    keyind := a41v.a4p_arr.pbasep^.sbase.bfirstcolind;
    found  := false;
    REPEAT
        pCol := a103GetColumn (a41v.a4p_arr.pbasep^.sbase, keyind);
        IF  pCol^.cextcolno = col_info.cextcolno
        THEN
            found := true
        ELSE
            BEGIN
            colno  := colno + 1;
            keyind := pCol^.cnextind
            END;
        (*ENDIF*) 
    UNTIL
        found;
    (*ENDREPEAT*) 
    END
ELSE
    colno := csp_maxint4;
(*ENDIF*) 
a40move_i4 (acv, a41v,
      colno, colno = csp_maxint4, 0, NOT c_to_undef)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47put_serial (VAR acv : tak_all_command_glob;
            VAR a41v       : tak40_show_glob;
            VAR col_info   : tak00_columninfo;
            VAR startvalue : tsp00_C20);
 
VAR
      len   : integer;
      pos   : integer;
      res   : tsp00_NumError;
      b_err : tgg00_BasisError;
 
      val   : RECORD
            c16        : tsp00_C16;
            startvalue : tsp00_C50;
      END;
 
 
BEGIN
val.c16 := 'DEFAULT SERIAL (';
s42gstr (startvalue, 1, col_info.cdatalen,
      0, col_info.cdatalen, val.startvalue, 1, len, res);
IF  res = num_ok
THEN
    BEGIN
    b_err := e_ok;
    pos   := 1;
    WHILE val.startvalue[pos] = bsp_c1 DO
        pos := pos + 1;
    (*ENDWHILE*) 
&   ifdef trace
    t01int4 (ak_sem, 'pos         ', pos);
&   endif
    len := len - pos + 1;
    SAPDB_PascalOverlappingMove ('VAK47 ',   1,    
          sizeof (val.startvalue), sizeof (val.startvalue),
          @val.startvalue, pos, @val.startvalue, 1, len, b_err)
    END
ELSE
    b_err := e_num_overflow;
(*ENDIF*) 
IF  b_err = e_ok
THEN
    BEGIN
    val.startvalue[len+1] := ')';
    a40move_const (acv, a41v, @val, sizeof (val.c16) + len + 1);
    a40move_const (acv, a41v, @val.c16[9], sizeof (val.c16) - 8 + len + 1)
    END
ELSE
    BEGIN
    a40move (acv, a41v, NIL, 0);
    a40move (acv, a41v, NIL, 0);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak47serial (VAR acv : tak_all_command_glob;
            VAR a41v       : tak40_show_glob;
            VAR sysbuf     : tak_sysbufferaddress;
            VAR startvalue : tsp00_C20);
 
VAR
      temp_table : boolean;
      b_err      : tgg00_BasisError;
      sysk       : tgg00_SysInfoKey;
 
BEGIN
IF  a41v.a4sh_kind = sh_u_domain
THEN
    BEGIN
    sysk           := a41v.a4dombuf^.syskey;
    sysk.sentrytyp := cak_edefault;
    END
ELSE
    BEGIN
    sysk           := a41v.a4p_arr.pbasep^.syskey;
    temp_table     := a101_IsExtendedTempFile (acv, a41v.a4p_arr.pbasep^.sbase.btreeid);
    IF  temp_table
    THEN
        sysk.sentrytyp := cak_etempdefault
    ELSE
        sysk.sentrytyp := cak_esequence;
    (*ENDIF*) 
    END;
(*ENDIF*) 
a10get_sysinfo (acv, sysk, d_release, sysbuf, b_err);
IF  b_err = e_ok
THEN
    IF  a41v.a4sh_kind = sh_u_domain
    THEN
        BEGIN
        SAPDB_PascalForcedFill (sizeof (startvalue), @startvalue, 1,
              sizeof (startvalue), chr(0));
        SAPDB_PascalMove ('VAK47 ',   2,    
              sizeof (sysbuf^.sdefault.dfvalues), sizeof (startvalue),
              @sysbuf^.sdefault.dfvalues, 3, @startvalue, 1,
              a14LengthOfDefaultValue(sysbuf^.sdefault) - 1, b_err)
        END
    ELSE
        startvalue := sysbuf^.ssequence.seq_info.seq_increment
              ;
    (*ENDIF*) 
(* errors are ignored ==> NULL value will be returned *)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak47tablename_qualified (VAR specified_name : tsp00_KnlIdentifier;
            VAR curr_tab_name : tsp00_KnlIdentifier;
            tab_len           : integer) : boolean;
 
VAR
      systable : boolean;
 
BEGIN
&IFDEF TRACE
t01lidentifier (ak_sem, specified_name);
t01lidentifier (ak_sem, curr_tab_name);
t01int4 (ak_sem, 'tab_len     ', tab_len);
&ENDIF
systable :=
      (curr_tab_name[ 1 ] = 'S') AND
      (curr_tab_name[ 2 ] = 'Y') AND
      (curr_tab_name[ 3 ] = 'S');
ak47tablename_qualified :=
      ((specified_name = a01_il_b_identifier) OR
      s30eq (curr_tab_name, specified_name, 1, tab_len))
      AND
      (NOT ((systable) AND ((tab_len < 3) OR
      (specified_name = a01_il_b_identifier))))
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
