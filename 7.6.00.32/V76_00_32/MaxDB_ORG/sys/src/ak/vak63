.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK63$
.tt 2 $$$
.TT 3 $ElkeZ$Where_Part$$2000-03-03$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : Where_Part
=========
.sp
Purpose : Checking of the Where condition and building of the
          corresponding part of the syntax tree.
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a63_asearch_condition (VAR acv : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a63_avalue_expression (VAR acv : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        FUNCTION
              a63pure_subquery (VAR acv : tak_all_command_glob) : boolean;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01kw        : tak_keywordtab;
              a01char_size : integer;
 
        PROCEDURE
              a01_next_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_get_keyword (VAR acv : tak_all_command_glob;
                    VAR index    : integer;
                    VAR reserved : boolean);
 
        PROCEDURE
              a01_put_node (VAR acv : tak_all_command_glob;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_function_put (VAR acv : tak_all_command_glob;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_call_put (VAR acv : tak_all_command_glob;
                    proc       : tak_procs;
                    subproc    : tsp00_Int2;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_is_odbc_syntax (VAR acv : tak_all_command_glob;
                    VAR partype  : tak_odbc_partype;
                    VAR functype : tak_odbc_functiontype);
 
        FUNCTION
              a01_odbc_end_ok (VAR acv : tak_all_command_glob;
                    partype : tak_odbc_partype) : boolean;
 
        FUNCTION
              a01_eqkey (VAR a : tak_keyword;
                    sqlmode    : tsp00_SqlMode;
                    VAR b      : tsp00_MoveObj;
                    VAR scv    : tak_scanner_glob) : boolean;
 
        FUNCTION
              a01mandatory_keyword (VAR acv : tak_all_command_glob;
                    required_keyword : integer) : boolean;
 
        PROCEDURE
              a01_force_symbol (VAR acv : tak_all_command_glob;
                    expected_symbol : tak_sc_symbol;
                    VAR node1       : tsp00_Int2;
                    VAR node2       : tsp00_Int2);
 
        PROCEDURE
              a01_character_set (VAR acv : tak_all_command_glob;
                    VAR put_node   : tsp00_Int2;
                    VAR last_node  : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_syntax_tools : VAK02;
 
        PROCEDURE
              a02_acolumnspec (VAR acv : tak_all_command_glob;
                    table_required : boolean;
                    VAR put_node   : tsp00_Int2;
                    VAR last_node  : tsp00_Int2);
 
        PROCEDURE
              a02_s_aparameterspec (VAR acv : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_syntax_values_tools : VAK03;
 
        PROCEDURE
              a03_avalue_spec (VAR acv : tak_all_command_glob;
                    null_allowed    : boolean;
                    stamp_allowed   : boolean;
                    default_allowed : boolean;
                    sysdba_allowed  : boolean;
                    VAR put_node    : tsp00_Int2;
                    VAR last_node   : tsp00_Int2);
 
        PROCEDURE
              a03_l_avalue_list (VAR acv : tak_all_command_glob;
                    null_allowed    : boolean;
                    stamp_allowed   : boolean;
                    default_allowed : boolean;
                    sysdba_allowed  : boolean;
                    VAR put_node    : tsp00_Int2;
                    VAR last_node   : tsp00_Int2);
 
        PROCEDURE
              a03_l_aexpression_list (VAR acv : tak_all_command_glob;
                    VAR put_node    : tsp00_Int2;
                    VAR last_node   : tsp00_Int2);
 
        PROCEDURE
              a03_ln_aexpression_list (VAR acv : tak_all_command_glob;
                    VAR put_node    : tsp00_Int2;
                    VAR last_node   : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_error (VAR acv : tak_all_command_glob;
                    errorcode : tgg00_BasisError;
                    VAR nod1  : tsp00_Int2;
                    VAR nod2  : tsp00_Int2);
 
        PROCEDURE
              a07_b_put_error (VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07const_param (VAR acv : tak_all_command_glob;
                    param_no   : integer;
                    param_addr : tsp00_MoveObjPtr;
                    param_len  : integer);
 
      ------------------------------ 
 
        FROM
              Select_Syntax : VAK60;
 
        PROCEDURE
              a60_asub_query (VAR acv : tak_all_command_glob;
                    VAR put_node      : tsp00_Int2;
                    list_cnt          : integer;
                    one_valsubquery   : boolean);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code           : tgg04_CodeGlobals;
              g01unicode        : boolean;
 
        FUNCTION
              g01userstackoverflow : boolean;
 
      ------------------------------ 
 
        FROM
              Codetransformation_and_Coding : VGG02;
 
        VAR
              g02codetables : tgg04_CodeTables;
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        PROCEDURE
              s30cmp (VAR buf1   : tsp00_MoveObj;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tsp00_C32;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
        PROCEDURE
              s30map (VAR code_t : tsp00_Ctable;
                    VAR source : tsp00_MoveObj;
                    spos       : tsp00_Int4;
                    VAR dest   : tsp00_MoveObj;
                    dpos       : tsp00_Int4;
                    length     : tsp00_Int4);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01bool (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    curr_bool: boolean);
 
        PROCEDURE
              t01int4 (debug : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01moveobj (debug : tgg00_Debug;
                    VAR moveobj : tsp00_MoveObj;
                    startpos    : tsp00_Int4;
                    endpos      : tsp00_Int4);
&       endif
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              s30cmp;
 
              tsp00_MoveObj tsp00_C32
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ElkeZ
.sp
.cp 3
Created : 1986-02-21
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-03-03
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.sp
Order of calling procedures for processing of a Where condition:
.sp
.nf
(1) A63_ASEARCH_CONDITION
  (1.1) SE_OR_TERM
    (1.1.1) SE_AND_TERM
      (1.1.1.1) SE_PREDICATE
        (1.1.1.1.1) SE_OR_TERM
        (1.1.1.1.2) COMP_OP_PREDICATE
        (1.1.1.1.3) ADIFF_PREDICATE
.sp 2
Order of calling preocedures for processing of an expression:
.sp
(2) A63_AVALUE_EXPRESSION
  (2.1) ATERM
    (2.1.1) AFACTOR
      (2.1.1.1) A03_AVALUE_SPEC
      (2.1.1.2) AK63AVALUE_EXPRESSION
      (2.1.1.3) AFUNCTION_SPEC
        (2.1.1.3.1) ACSTRING_EXPRESSION
        (2.1.1.3.2) ASSTRING_EXPRESSION
        (2.1.1.3.3) ASTRING_EXPRESSION
        (2.1.1.3.4) AK63AVALUE_EXPRESSION
        (2.1.1.3.5) LRPAD
    (2.1.2) AREST_FACTOR
      (2.1.2.1) AFACTOR
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
.sp 2
A63_ASEARCH_CONDITION
.sp
Processes the specified Where condition and builds the corresponding part of
the syntax tree. In A63_ASEARCH_CONDITION, various boolean values are
initialized that specify the type of Where condition. The variable 'is_allow'
is used in order in the case of bracketing and nesting to detect whether only
one expression ( see A63_AVALUE_EXPRESSION  ) or a complete predicate has been
read or is to be read.
.sp
.cp 2
INPUT :
.in +11
.of 12
acv:  especially scv, a_cmd_part^.sp1p_buf
.in -11
.sp
.cp 3
OUTPUT :
.in +11
.of 12
put_node:  highest node of the part-tree built here.
.sp
.of 12
last_node:  last node to which further nodes can be attached; may possibly
differ from put_node (if, for example, a NOT comes before an and_term or
or_term, put_node points to the NOT node and last_node points to the node in
which the term begins).
.in -11
 
.sp 2
A63_AVALUE_EXPRESSION :
.sp
Completely processes an arithmetic expression. For this purpose, first of all,
ATERM is called in order to read a (multiplicative) term; then, as long as an
additive operator is found, ATERM is called in order to read the next operand.
Since the multiplicative expressions are checked in ATERM, the order of
precedence of the arithmetic operators is taken into account by the order of
calling.
.sp
Building of the corresponding syntax tree:
.br
The operator is entered in the tree as the highest node and the first operand
is hung below it as lo_level. The second operand is entered as the sa_level of
the first. If one of the operands, in turn, is an operator expression, the
syntax tree is built analogously.
.br
If a set_function has been found in the expression (allow_function = tf_func),
it is checked whether an arithmetic expression has been formed with this
function (the highest node does not have the corresponding function symbol). If
so, allow_function is set to tf_func_arith for the purpose of identification.
.br
If 'ROWNO' has now occurred and previously did not occur (m_rowno_found =
false), it is likewise checked whether an expression has been formed with it.
In this case, a corresponding error is generated.
.sp
.cp 2
INPUT :
.in +11
.of 12
acv:  especially scv, a_cmd_part^.sp1p_buf
.in -11
.sp
.cp 4
OUTPUT :
.in +11
.of 12
put_node:  highest node of the part-tree built here.
.sp
.of 12
last_node:  last node to which further nodes can be attached
.in -11
 
.sp 2
ATERM :
.sp
Breaks down a term into the first factor, which is processed with AFACTOR, and
into the remaining factors, which are processed with  AREST_FACTOR. The
remaining factors are linked to the previous ones by multiplicative operators.
.br;If the next symbol is 's_identifier' and durations are allowed
('duration_allowed', durations are only allowed in case of a previous
additiv operand)
then it is check whether a labeled duration is
given. Then a node in ap_tree is entered ( a64, x_duration ) and the
last processed term is entered as n_lo_level. The duration node is
returned as put_node.
.sp 2
.cp 2
INPUT :
.in +11
.of 12
acv:  especially scv, a_cmd_part^.sp1p_buf
.in -11
.sp
.cp 4
OUTPUT :
.in +11
.of 12
put_node:  highest node of the part-tree built here.
.sp
.of 12
last_node:  last node to which further nodes can be attached
.in -11
 
.sp 2
AREST_FACTOR :
.sp
Processes both multiplicative expressions and also concatenations of strings.
The procedure is analogous in both cases; as long as a corresponding operator
is read, AFACTOR is called in order to read the next (individual) factor.
.br
The syntax tree is built analogously to the additive operators.
.br
As regards the multiplicative operators, the operators 'MOD' and 'DIV' are
initially recognized only as identifiers, which are then identified more
precisely with A01_EQKEY.
.sp
The symbol 's_asterisk' is converted to the symbol 's_mult', since it is
certain at this point in time that a multiplication is being performed and not,
for example, that there is a '*' in 'SELECT * ... '. The distinction is
necessary, since, otherwise, a multiplication in the Select list is recognized
and analyzed as an asterisk (see VAK61).
.sp
.cp 2
INPUT :
.in +11
.of 12
acv:  especially scv, a_cmd_part^.sp1p_buf
.in -11
.sp
.cp 4
OUTPUT :
.in +11
.of 12
put_node:  highest node of the part-tree built here.
.sp
.of 12
last_node:  last node to which further nodes can be attached
.in -11
 
.sp 2
AFACTOR :
.sp
In AFACTOR an individual factor is processed. If this factor begins with a
monadic operator, the corresponding tree node is created, the node number is
stored in 'curr_n1' and the variable 'may_p_m' is set to 'false' in order to
identify the existence of such an operator. The next symbol is then read for
further processing.
.sp
With reference to the current symbol, a distinction is made between:
.sp
.of 5
(1) There is a Value_specification (s_string_literal, s_unsigned_integer,.. ],
which is checked with A03_AVALUE_SPEC.
.sp
.of 5
(2) There is a (further) monadic operator, which is regarded as an error, e.g.
'--3', correct -(-3).
.sp
.of 5
(3) There is an opening bracket.
In this case, there may be a further complete
expression, which is processed recursively with A63_AVALUE_EXPRESSION.
A closing
bracket is expected at the end of the expression and if there is none, the
response is an ERROR. In addition, with the aid of the entry in 'may_p_m' ( see
above ), it is checked whether there are two monadic operators (in correct
form, see (2)). If these are identical, an operator need not be inserted;
otherwise, only an 's_minus' is entered. The variable 'may_p_m' is set to
'true' in order to detect at the end whether the monadic operators have already
been taken into account (if applicable). If not, the node ( curr_n1 ) that
contains the operator is returned as the highest node.
.sp
.of 5
(4) In the case of an identifier, it must be determined first of all with
A01_GET_KEYWORD whether a keyword has been specified and which one. An
appropriate entry is made in the variable 'index':
.in +5
.of 5
(a) i_no_keyword ; there is a column specification, which is processed
with A02_COLUMNSPEC.
.sp
.of 5
(b) One of the functions without parameter
('DATE', 'TIME', 'TIMESTAMP', 'USER',
'USERGROUP') has been found, which are processed with A03_AVALUE_SPEC (since
they basically stand for a value). In case of 'DATE', 'TIME', 'IMESTAMP'
at first
the next_symbol is testes for an opening bracket and, if successfull,
AFUNCTION_SPEC is called to process the corresponding functions.
Otherwise A03_AVALUE_SPEC is called.
.sp
.of 5
(c) The keyword 'ROWNO' has been found. After it has been checked whether there
is a CREATE VIEW or not (first node is identified by 'a16'), it is checked
whether 'ROWNO' may occur at this position (rowno_allowed is 'true' and
rowno_found  is 'false', 'ROWNO' not found so far). In this case, rowno_found
is set in order to be able to intercept a further occurrence, and the
corresponding node is entered in the syntax tree.
.sp
.of 5
(d) All other key words (including incorrect ones) are processed in
AFUNCTION_SPEC, since these then identify functions.
.sp
.in -5
Finally, depending on 'may_p_m', entries are made in the output parameters
'put_node' and 'last_node' (see (3)).
.sp
.cp 2
INPUT :
.in +11
.of 12
acv:  especially scv, a_cmd_part^.sp1p_buf
.in -11
.sp
.cp 4
OUTPUT:
.in +11
.of 12
put_node:  highest node of the part-tree built here.
.sp
.of 12
last_node:  last node to which further nodes can be attached
.in -11
 
.sp 2
AFUNCTION_SPEC :
.sp
The various functions are recognized on the basis of the parameter 'index',
which specifies the keyword-index. The sequence of actions in the individual
cases is analogous and depends on the type and number of the expected
arguments. In all cases, an opening
bracket is read, an argument is processed (if
a string is expected, this is processed with ASTRING_SPEC, complete expressions
are processed recursively with A63_AVALUE_EXPRESSION, or the type of argument
is recognized directly by the symbol, e.g. 's_unsigned_integer'), the
individual arguments must be separated by a comma and must be ended with a
closing bracket. Deviations are recognized as syntax errors and are reported by
A07_ERROR with the message 'missing_keyword'.
.br
For various functions ( e.g. 'SUBSTR', 'INDEX',... ), procedures are called
that perform the above-described steps.
.br
All other keyword indices that have not been listed as a CASE-label
are then checked
as to whether there is a set_function. A distinction is made as to whether they
are allowed or not. If not, an ERROR is generated with the message
'invalid_mix_function_column'.
.br
Otherwise, a possible 'DISTINCT' or a 'COUNT(*)' is recognized. The argument is
again read with A63_AVALUE_EXPRESSION, with it being detected by the entry
'tf_no_func' in 'tf_func' whether there is a nested set_function (see above).
All other key words lead to an ERROR with 'invalid_keyword'.
.sp
.cp 2
INPUT :
.in +11
.of 12
acv:  especially scv, a_cmd_part^.sp1p_buf
.sp
.of 12
index: Keyword index of the current key word
.in -11
.sp
.cp 4
OUTPUT:
.in +11
.of 12
put_node:  highest node of the part-tree built here.
.sp
.of 12
last_node:  last node to which further nodes can be attached
.in -11
 
.sp 2
LRPAD :
.sp
Processes the functions 'LPAD', 'RPAD', 'LFILL', 'RFILL'.
.sp
.cp 2
INPUT :
.in +11
.of 12
acv:  especially scv, a_cmd_part^.sp1p_buf
.sp
.of 12
index: keyword index of the current key word
.in -11
.sp
.cp 4
OUTPUT :
.in +11
.of 12
put_node:  highest node of the part-tree built here.
.sp
.of 12
last_node:  last node to which further nodes can be attached
.in -11
 
.sp 2
ACSTRING_EXPRESSION :
.sp
Processes the function 'INDEX'.
.sp
.cp 2
INPUT :
.in +11
.of 12
acv:  especially scv, a_cmd_part^.sp1p_buf
.in -11
.sp
.cp 4
OUTPUT:
.in +11
.of 12
put_node:  highest node of the part-tree built here.
.sp
.of 12
last_node:  last node to which further nodes can be attached
.in -11
 
.sp 2
ASSTRING_EXPRESSION :
.sp
Processes the function 'SUBSTR'.
.sp
.cp 2
INPUT :
.in +11
.of 12
acv:  especially scv, a_cmd_part^.sp1p_buf
.in -11
.sp
.cp 4
OUTPUT :
.in +11
.of 12
put_node:  highest node of the part-tree built here.
.sp
.of 12
last_node:  last node to which further nodes can be attached
.in -11
 
.sp 2
ASTRING_SPEC :
.sp
Processing of a string specification.
.sp
Initially, the current scanner status is stored in the variable 'scvh' in order
possibly to access it later.
.sp
A distinction is made between the following strings:
.in +5
.of 5
(1) byte_string, string_literal, the symbols of which are entered directly in
the tree.
.sp
.of 5
(2) Parameters for which it is checked whether they are at all allowable (
'ex_kind' is scanned ).
.sp
.of 5
(3) Identifiers that identify either the functions 'DATE', 'TIME',
'TIMESTAMP' ( in case of 'DATE', 'TIME', 'TIMESTAMP' see also
AFACTOR  for distinction between value and function ), 'USER'
or 'USERGROUP' (the result of which may be considered as a string) or a column
specification. Also, there may be a function whose result is a string, which is
processed recursively with AFUNCTION_SPEC.
.sp
.in -5
Otherwise, there is an error, which is identified by 'missing_identifier'.
.sp
If the string specification is followed by a concatenation symbol, the
previously performed steps are cancelled (by using 'scvh', see above) and ATERM
is called, since there is now an expression.
.sp
.cp 2
INPUT :
.in +11
.of 12
acv:  especially scv, a_cmd_part^.sp1p_buf
.in -11
.sp
.cp 4
OUTPUT :
.in +11
.of 12
put_node:  highest node of the part-tree built here.
.sp
.of 12
last_node:  last node to which further nodes can be attached
.in -11
 
.sp 2
SE_OR_TERM :
.sp
Processes the highest level of precedences for the boolean operators: and_term
'OR' and_term.
.sp
The first and_term is processed with SE_AND_TERM. If there is then an 'OR', it
is entered in the syntax tree and the next and_term is read. The position of
the OR node is given beforehand to the parameters 'put_node' and 'last_node',
since the first OR is to be the highest node (no matter how many ORs there are
to follow). All further ORs are processed in a WHILE loop.
.sp
Building of the syntax tree:
.br
The first and_term and the operator are entered, with the first and_term being
attached as the lo_level of the operator. The second and_term is entered as the
sa_level of the first. If there is a further OR, the second and_term is
detached as the sa_level, the new operator is entered there and the detached
and_term is re-attached as the lo_level of the new operator. The now following
and_term is then again attached as the sa_level of the previous and_term. Each
further occurrence of an OR is handled analogously.
.sp
Each time a further OR and the following and_term are read, the tree is
further modified as required. Otherwise
the following case may occur and leads in the
determination of the semantics to bad stack structures:
.in +5
.nf;.sp
OR expression         : ( BED1 OR1 BED2 ) OR2 BED3
.sp 2
.cp 8
Original tree         : ------     ------     ------
                        |OR2 |-----|OR1 |-----|BED1|
                        ------     ------     ------
                                      |          |
                                      |          |
                                   ------     ------
                                   |BED3|     |BED2|
                                   ------     ------
.sp 2
.cp 8
Modified tree         : ------     ------
                        |OR2 |-----|BED1|
                        ------     ------
                                      |
                                      |
                                   ------     ------
                                   |OR1 |-----|BED2|
                                   ------     ------
                                                 |
                                                 |
                                              ------
                                              |BED3|
                                              ------
.in -5
.fo
.sp 2
If a modification was necessary, the pointer (ilast.n_sa_level), pointing to
the last node to which an attachment can be made does not have the correct
entry and must be altered.
.sp
Since the specification of 'ROWNO' is allowed only at the highest AND-Level,
'rowno_allowed' is set to 'false' in order to be able to intercept an
occurrence.
.sp
.cp 2
INPUT :
.in +11
.of 12
acv:  especially scv, a_cmd_part^.sp1p_buf
.sp
.of 12
is_allow: identification required in the case of nesting (see
A63_ASEARCH_CONDITION or SE_PREDICATE).
.in -11
.sp
.cp 4
OUTPUT :
.in +11
.of 12
put_node:  highest node of the part-tree built here.
.sp
.of 12
last_node:  last node to which further nodes can be attached
.sp
.of 12
is_allow: identification required in the case of nesting (see
A63_ASEARCH_CONDITION or SE_PREDICATE).
.in -11
 
.sp 2
SE_AND_TERM :
.sp
Processes an and_term having the following structure:
.br;predicate AND predicate.
.sp
This procedure is
analogous in the sequence of actions to SE_OR_TERM. The difference is that
there is no handling
of 'ROWNO', because 'ROWNO' may occur at the AND level. The individual
predicates are handled by SE_PREDICATE.
.sp
The tree may be modified for the same reasons as in the case of SE_OR_TERM.
.sp
.cp 2
INPUT :
.in +11
.of 12
acv:  especially scv, a_cmd_part^.sp1p_buf
.sp
.of 12
is_allow: identification required in the case of nesting (see
A63_ASEARCH_CONDITION or SE_PREDICATE).
.in -11
.sp
.cp 4
OUTPUT:
.in +11
.of 12
put_node:  highest node of the part-tree built here.
.sp
.of 12
last_node:  last node to which further nodes can be attached
.sp
.of 12
is_allow: identification required in the case of nesting (see
A63_ASEARCH_CONDITION or SE_PREDICATE).
.in -11
 
.sp 2
SE_PREDICATE :
.sp
Processing of a predicate.
.sp
If an opening bracket has been read, there is 'some sort of' nesting, which is
processed by a recursive call of SE_OR_TERM. Some sort of nesting means that an
or_term, an and_term, a predicate or any expression is in brackets. In order to
ensure that only this bracketed expression is processed in the recursion, it is
checked in the second part of SE_PREDICATE (through which the recursive
expression also runs) whether there is a closing bracket as a current symbol.
In this case, no further check is performed, since this bracket is expected
after the recursion. The parameter 'is_allow' specifies whether only one
expression has been read and whether the remainder of the predicate must still
be processed (in this case, 'is_allow' has the entry 'a_predicate'), or whether
a predicate has already been processed in the course of recursion (in this
case, 'is_allow' has the entry 'a_value'; entire and_terms, or or_terms are
included).
.sp
If a 'NOT' occurs, it is processed recursively in a manner comparable to that
for bracketing, with consideration being given to the possible presence of
brackets. In this case, it is possible that there is a complete or_term,
which is checked with SE_OR_TERM. And it is possible that
only one single predicate is negated, with
the result that SE_PREDICATE is called recursively. In addition, it is checked
whether there is a double negation, with the result that the two corresponding
nodes are skipped.
.sp
If there is 'EXISTS' as a symbol, then a CREATE VIEW is
excluded (first node is identified by 'a16') and a subquery is expected, which
is processed with A60_ASUB_QUERY. The symbol 's_exists' is entered in the tree
and the subquery is hung below it as the lo_level.
.sp
If none of the above cases occurs, a factor is read with AFACTOR and 'is_allow'
is set to 'a_predicate', so that further processing can take place.
.sp
By calling of AREST_FACTOR, a possible remaining factor is read and,
by a construction analogous to the one in A63_AVALUE_EXPRESSION, an additive
expression is read. Further processing takes place only if there is no closing
bracket as a current symbol.
.sp
First of all, the specification of 'ROWNO' is tested, with only '<' and '<='
being allowed as the possible comparison operator. Likewise, 'ROWNO' must not
occur in an expression. The specified unsigned integer or parameter is handled
with AFACTOR.
.sp
If there was no 'ROWNO', but a comparison operator, this is checked in
COMP_OP_PREDICATE.
.sp
The cases 'IS NULL' and 'IS NOT NULL' are dealt with next, with an additional
node with symbol 's_null' being entered into the syntax tree,
so that the further processing
need not deal separately with this special case (monadic predicate).
.br
All other possible predicates are checked in ADIFF_PREDICATE.
.br
Finally, the parameters, 'put_node' and 'last_node' are set and the node
describing the existence and type of a predicate (a64, pred_node) is written
above the arguments of the predicate in the syntax tree. 'is_allow' is set to
'a_value' in order to identify the successful processing of a predicate.
.sp
.cp 2
INPUT :
.in +11
.of 12
acv:  especially scv, a_cmd_part^.sp1p_buf
.sp
.of 12
is_allow: identification required in the case of nesting (see
A63_ASEARCH_CONDITION or SE_PREDICATE).
.in -11
.sp
.cp 4
OUTPUT :
.in +11
.of 12
put_node:  highest node of the part-tree built here.
.sp
.of 12
last_node:  last node to which further nodes can be attached
.sp
.of 12
is_allow: identification required in the case of nesting (see
A63_ASEARCH_CONDITION or SE_PREDICATE).
.in -11
 
.sp 2
COMP_OP_PREDCIATE :
.sp
Processes the comparison operators '<', '>', '=', '<=', '>=', '<>'.
.sp
After the predicate node (a64, pred_node) has been entered, it is tested
whether there is an identifier as a current symbol that identifies one of the
keywords 'ANY', 'ALL' or 'SOME'.
In this case, it is specified by the entry in 'psub_query' that there must
be a subquery, which is then handled with A60_ASUB_QUERY. Otherwise,
there may be a subquery, which is processed accordingly, or any expression,
which is checked with A63_AVALUE_EXPRESSION.
.sp
If everything was O.K., the parameter 'curr_n' is set.
.sp
.cp 2
INPUT :
.in +11
.of 12
acv:  especially scv, a_cmd_part^.sp1p_buf
.in -11
.sp
.cp 4
OUTPUT :
.in +11
.of 12
curr_n:  Pointer to the predicate node (a64, pred_node)
.in -11
 
.sp 2
ADIFF_PREDICATE :
.sp
Processing of the predicates 'BETWEEN', 'IN', 'LIKE' and 'SOUNDS'.
.sp
First of all, a possible 'NOT' is intercepted and is identified in the variable
'pnot'. Accordingly, the symbols are then entered with or without negation. The
basic sequence of actions again depends on the type and number of arguments:
.in +5;.sp
.of 10
BETWEEN: Two expressions that must be linked by an 'AND'. Both expressions are
handled with A63_AVALUE_EXPRESSION.
.sp
.of 10
IN: Either a subquery, which is processed with A60_SUB_QUERY, or a list of
values, which is processed with A03_L_AVALUE_LIST. In the second case, a node
(a64, list_node) is also entered to specify the existence of the list of
values.
.sp
.of 10
LIKE: One argument is expected, which is read with A63_AVALUE_EXPRESSION.
.sp
.of 10
SOUNDS: One argument is expected, which is read with A63_AVALUE_EXPRESSION.
.in -5
.sp
.cp 2
INPUT :
.in +11
.of 12
acv:  especially scv, a_cmd_part^.sp1p_buf
.in -11
.sp
.cp 4
OUTPUT :
.in +11
.of 12
curr_n:  Pointer to the predicate node (a64, pred_node)
.in -11
 
.sp 2
CHANGE_NODE :
.sp
Performs the modification of the syntax tree.
Swaps the nodes that have been transferred if the symbol of the first node is
equal to the parameter 'symbol'. Any lower swaps are also implemented by a
recursive call.
.sp
.cp 2
INPUT :
.in +11
.of 12
acv:  especially scv, a_cmd_part^.sp1p_buf
.sp
.of 12
symbol: Specifies whether an OR or an AND node is to be modified.
.sp
.of 12
curr_n: First node that is to be swapped.
.sp
.of 12
last: Second node that is to be swapped.
.in -11
.sp
.cp 4
OUTPUT :
.in +11
.of 12
curr_n:  Pointer to the predicate node (a64, pred_node)
.in -11
.sp 3
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_table_required  = true (* a02_acolumnspec *);
      c_null_allowed    = true (* a03_avalue_spec *);
      (*                          a03_l_avalue_list *)
      c_stamp_allowed   = true (* a03_avalue_spec *);
      (*                          a03_l_avalue_list *)
      c_default_allowed = true (* a03_avalue_spec *);
      (*                          a03_l_avalue_list *)
      c_sysuser_allowed = true (* a03_avalue_spec *);
      (*                          a03_l_avalue_list *)
      c_one_valsubquery = true (* a60_asub_query *);
      c_duration_allowed= true (* ak63aterm *);
 
TYPE
      allow_type = (a_value, a_predicate);
      list_type = (
            lt_unknown,
            lt_subquery,
            lt_value_expression,
            lt_one_list,
            lt_list_of_lists);
 
 
(*------------------------------*) 
 
PROCEDURE
      ak63subq_check (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      inode : tsp00_Int2;
 
BEGIN
IF  acv.a_ap_tree^[put_node].n_proc = a63query_spec
THEN
    BEGIN
    a01_call_put (acv, a63, cak_x_arith_with_subquery, inode);
    acv.a_ap_tree^[inode].n_lo_level := put_node;
    put_node  := inode;
    last_node := inode;
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a63pure_subquery (VAR acv : tak_all_command_glob) : boolean;
 
VAR
      ltype : list_type;
 
BEGIN
ak63list_type_get (acv, ltype);
a63pure_subquery := (ltype = lt_subquery);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63acstring_expression (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        sc_symb := s_index;
        a01_function_put (acv, put_node);
        curr_n := put_node;
        last_node := put_node;
        a01_next_symbol (acv);
        a01_force_symbol (acv, s_leftpar, put_node, last_node);
        IF  a_returncode = 0
        THEN
            BEGIN
            ak63astring_spec (acv, a_ap_tree^[ curr_n ].n_lo_level, curr_n);
            a01_force_symbol (acv, s_comma, put_node, last_node);
            IF  a_returncode = 0
            THEN
                BEGIN
                ak63subq_check (acv, a_ap_tree^[ put_node ].n_lo_level, curr_n);
                curr_n1 := curr_n;
                ak63astring_spec (acv, a_ap_tree^[ curr_n ].n_sa_level, curr_n);
                IF  a_returncode = 0
                THEN
                    ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_sa_level, curr_n);
                (*ENDIF*) 
                IF  (a_returncode = 0) AND
                    (index = cak_i_locate)
                THEN
                    BEGIN
                    a_ap_tree^[put_node].n_lo_level := curr_n;
                    a_ap_tree^[curr_n  ].n_sa_level := curr_n1;
                    a_ap_tree^[curr_n1 ].n_sa_level := 0;
                    curr_n := curr_n1;
                    curr_n1 := a_ap_tree^[put_node].n_lo_level;
                    END;
                (*ENDIF*) 
                IF  sc_symb <> s_rightpar
                THEN
                    BEGIN
                    a01_force_symbol (acv, s_comma, put_node, last_node);
                    IF  a_returncode = 0
                    THEN
                        BEGIN
                        curr_n1 := curr_n;
                        ak63avalue_expression (acv,
                              a_ap_tree^[ curr_n ].n_sa_level, curr_n);
                        IF  sc_symb <> s_rightpar
                        THEN
                            BEGIN
                            a01_force_symbol (acv, s_comma,
                                  put_node, last_node);
                            IF  a_returncode = 0
                            THEN
                                BEGIN
                                ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_sa_level, curr_n);
                                ak63avalue_expression (acv,
                                      a_ap_tree^[ curr_n ].n_sa_level,
                                      curr_n)
                                END
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                a01_force_symbol (acv, s_rightpar, put_node, last_node)
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63adiff_predicates (VAR acv : tak_all_command_glob;
            put_node    : tsp00_Int2;
            VAR curr_n  : tsp00_Int2;
            VAR curr1_n : tsp00_Int2;
            list_cnt    : integer);
 
VAR
      m_rowno_allowed : boolean;
      ilast           : tsp00_Int2;
      curr2_n         : tsp00_Int2;
      curr_n1         : tsp00_Int2;
      index           : integer;
      scvh            : tak_scanner_glob;
      pnot            : boolean;
      res_kw          : boolean;
      save_symb       : tak_sc_symbol;
      odbc_partype    : tak_odbc_partype;
      odbc_functype   : tak_odbc_functiontype;
      ltype           : list_type;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        odbc_partype    := no_odbc;
        odbc_functype   := odbc_nothing;
        m_rowno_allowed := a_rowno_allowed;
        a_rowno_allowed := false;
        IF  a01_eqkey ( a01kw[ cak_i_not ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv )
        THEN
            BEGIN
            pnot := true;
            a01_next_symbol (acv)
            END
        ELSE
            pnot := false;
        (*ENDIF*) 
        a01_get_keyword (acv, index, res_kw);
        IF  (list_cnt > 1) AND (index <> cak_i_in)
        THEN
            a07_error (acv, e_missing_keyword, curr_n, curr_n)
        ELSE
            CASE index OF
                cak_i_between :
                    BEGIN
                    IF  pnot
                    THEN
                        sc_symb := s_notbetween
                    ELSE
                        sc_symb := s_between;
                    (*ENDIF*) 
                    a01_call_put (acv, a64, cak_x_between_pred, ilast);
                    a_ap_tree^[ ilast ].n_symb := a_scv.sc_symb;
                    a01_next_symbol (acv);
                    curr_n1 := curr_n;
                    a63_avalue_expression (acv,
                          a_ap_tree^[ curr_n ].n_sa_level, curr_n);
                    ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_sa_level, curr_n);
                    IF  a01mandatory_keyword (acv, cak_i_and)
                    THEN
                        a63_avalue_expression (acv,
                              a_ap_tree^[ curr_n ].n_sa_level, curr_n)
                    (*ENDIF*) 
                    END;
                cak_i_in :
                    BEGIN
                    IF  pnot
                    THEN
                        sc_symb := s_notin
                    ELSE
                        sc_symb := s_in;
                    (*ENDIF*) 
                    a01_call_put (acv, a64, cak_x_in_pred, ilast);
                    a_ap_tree^[ ilast ].n_symb := a_scv.sc_symb;
                    a01_next_symbol (acv);
                    scvh := a_scv;
                    ak63list_type_get (acv, ltype);
                    a01_force_symbol (acv, s_leftpar, ilast, ilast);
                    IF  a_returncode = 0
                    THEN
                        BEGIN
                        IF  ltype = lt_subquery
                        THEN
                            BEGIN
                            a_scv := scvh;
                            a60_asub_query (acv,
                                  a_ap_tree^[ curr_n ].n_sa_level,
                                  list_cnt, NOT c_one_valsubquery);
                            curr_n := a_ap_tree^[ curr_n ].n_sa_level;
                            END
                        ELSE
                            BEGIN
                            a_scv := scvh;
                            a01_next_symbol(acv);
                            a01_call_put (acv, a64, cak_x_in_pred_list,
                                  a_ap_tree^[ curr_n ].n_sa_level);
                            curr_n := a_ap_tree^[ curr_n ].n_sa_level;
                            IF  list_cnt > 1
                            THEN (* only possible for mode sql_db or oracle *)
                                ak63a_ll_expr_list_list (acv,
                                      a_ap_tree^[ curr_n ].n_lo_level,
                                      curr_n, list_cnt)
                            ELSE
                                IF  a_sqlmode = sqlm_internal
                                THEN
                                    a03_l_aexpression_list (acv,
                                          a_ap_tree^[ curr_n ].n_lo_level,
                                          curr_n)
                                ELSE
                                    IF  a_sqlmode = sqlm_oracle
                                    THEN
                                        a03_ln_aexpression_list (acv,
                                              a_ap_tree^[ curr_n ].n_lo_level,
                                              curr_n)
                                    ELSE
                                        a03_l_avalue_list (acv,
                                              NOT c_null_allowed,
                                              NOT c_stamp_allowed,
                                              NOT c_default_allowed,
                                              c_sysuser_allowed,
                                              a_ap_tree^[ curr_n ].n_lo_level,
                                              curr_n);
                                    (*ENDIF*) 
                                (*ENDIF*) 
                            (*ENDIF*) 
                            a01_force_symbol (acv, s_rightpar, ilast, ilast)
                            END
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                cak_i_like :
                    BEGIN
                    IF  pnot
                    THEN
                        sc_symb := s_notlike
                    ELSE
                        sc_symb := s_like;
                    (*ENDIF*) 
                    a01_call_put (acv, a64, cak_x_like_pred, ilast);
                    a_ap_tree^[ ilast ].n_symb := a_scv.sc_symb;
                    a01_next_symbol (acv);
                    IF  (a_ap_tree^[ put_node ].n_symb in
                        [ s_authid, s_tablename, s_columnname ]) AND
                        (sc_symb = s_parameter_name)
                    THEN
                        a_no_of_likes := succ(a_no_of_likes);
                    (*ENDIF*) 
                    curr_n1 := curr_n;
                    a63_avalue_expression (acv,
                          a_ap_tree^[ curr_n ].n_sa_level, curr_n);
                    IF  (a_comp_type = at_odbc)               OR
                        (a_comp_type = at_jdbc)               OR
                        (a_internal_sql = sql_restore_schema) OR
                        (a_internal_sql = sql_alter_table   )
                    THEN
                        a01_is_odbc_syntax ( acv, odbc_partype, odbc_functype );
                    (*ENDIF*) 
                    IF  sc_symb = s_identifier
                    THEN
                        IF  a01_eqkey (a01kw[ cak_i_escape ], a_sqlmode,
                            a_cmd_part^.sp1p_buf, a_scv)
                        THEN
                            BEGIN
                            ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_sa_level, curr_n);
                            a01_call_put (acv, a64, cak_x_escape, curr1_n);
                            a_ap_tree^[ curr1_n ].n_symb := a_scv.sc_symb;
                            a_ap_tree^[ ilast ].n_lo_level := curr1_n;
                            a01_next_symbol (acv);
                            a63_avalue_expression (acv,
                                  a_ap_tree^[ curr1_n ].n_sa_level, curr2_n);
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  ((a_comp_type = at_odbc) OR (a_comp_type = at_jdbc) OR
                        ( a_internal_sql = sql_restore_schema) OR
                        ( a_internal_sql = sql_alter_table   ))
                        AND
                        (odbc_partype <> no_odbc)
                    THEN
                        IF  NOT a01_odbc_end_ok (acv, odbc_partype)
                        THEN
                            a07_error (acv, e_missing_keyword,
                                  curr_n, curr_n)
                        ELSE
                            a01_next_symbol (acv);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                cak_i_sounds :
                    BEGIN
                    IF  pnot
                    THEN
                        sc_symb := s_notsounds
                    ELSE
                        sc_symb := s_sounds;
                    (*ENDIF*) 
                    a01_call_put (acv, a64, cak_x_sounds_pred, ilast);
                    a_ap_tree^[ ilast ].n_symb := a_scv.sc_symb;
                    a01_next_symbol (acv);
                    IF  a01_eqkey (a01kw[ cak_i_like ], a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv)
                    THEN
                        a01_next_symbol (acv);
                    (*ENDIF*) 
                    a63_avalue_expression (acv,
                          a_ap_tree^[ curr_n ].n_sa_level, curr_n)
                    END;
                OTHERWISE :
                    IF  pnot
                    THEN
                        a07_error (acv, e_missing_keyword,
                              curr_n, curr_n)
                    ELSE
                        BEGIN
                        save_symb := sc_symb;
                        sc_symb := s_is_true;
                        a01_call_put(acv, a64, cak_x_predicate, ilast);
                        a_ap_tree^[ ilast ].n_symb := a_scv.sc_symb;
                        sc_symb := s_true;
                        a01_put_node (acv, a_ap_tree^[ curr_n ].n_sa_level);
                        curr_n := ilast;
                        sc_symb := save_symb;
                        END;
                    (*ENDIF*) 
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            curr_n := ilast;
            IF  index <> cak_i_like
            THEN
                curr1_n := curr_n
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a_rowno_allowed := m_rowno_allowed;
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63afactor (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      may_p_m        : boolean;
      subquery       : boolean;
      index          : integer;
      curr_n         : tsp00_Int2;
      curr_n1        : tsp00_Int2;
      curr_n2        : tsp00_Int2;
      aux_n          : tsp00_Int2;
      scvh           : tak_scanner_glob;
      m_scv          : tak_scanner_glob;
      res_kw         : boolean;
      odbc_partype   : tak_odbc_partype;
      odbc_functype  : tak_odbc_functiontype;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        odbc_partype := no_odbc;
        odbc_functype := odbc_nothing;
        may_p_m := true;
        curr_n1 := 0;
        IF  (a_comp_type = at_odbc              ) OR
            (a_comp_type = at_jdbc              ) OR
            (a_internal_sql = sql_restore_schema) OR
            (a_internal_sql = sql_alter_table   )
        THEN
            BEGIN
            a01_is_odbc_syntax ( acv, odbc_partype, odbc_functype );
            IF  (odbc_partype <> no_odbc) AND
                (odbc_functype in [odbc_fn, odbc_d, odbc_t, odbc_ts])
            THEN
                a01_next_symbol (acv);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  sc_symb in [ s_plus, s_minus ]
        THEN
            BEGIN
            a01_put_node (acv, curr_n1);
            a01_next_symbol (acv);
            may_p_m := false
            END;
        (*ENDIF*) 
        CASE sc_symb OF
            s_parameter_name,
            s_byte_string, s_string_literal,
            s_fixed_point_literal, s_floating_point_literal,
            s_unsigned_integer :
                IF  (((sc_symb = s_byte_string)    OR
                    (  sc_symb = s_string_literal))
                    AND NOT may_p_m)
                THEN
                    a07_error (acv, e_missing_number, put_node,
                          last_node)
                ELSE
                    a03_avalue_spec (acv, NOT c_null_allowed,
                          NOT c_stamp_allowed, NOT c_default_allowed,
                          NOT c_sysuser_allowed, curr_n, curr_n2);
                (*ENDIF*) 
            s_plus, s_minus :
                a07_error (acv, e_too_many_monadic_operators,
                      put_node, last_node);
            s_leftpar :
                BEGIN
                (* PTS 1116169 E.Z. *)
                scvh := a_scv;
                subquery := false;
                a01_next_symbol (acv);
                IF  a01_eqkey (a01kw[ cak_i_select ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    IF  a_oneval_subq_allowed
                    THEN
                        BEGIN
                        a_scv := scvh;
                        subquery := true;
                        a60_asub_query (acv, curr_n, 1, c_one_valsubquery);
                        curr_n2 := curr_n;
                        END
                    ELSE
                        a07_error (acv, e_missing_value_spec,
                              put_node, last_node)
                    (*ENDIF*) 
                ELSE
                    ak63avalue_expression (acv, curr_n, curr_n2);
                (*ENDIF*) 
                IF  a_returncode = 0
                THEN
                    BEGIN
                    IF  ((a_ap_tree^[ curr_n ].n_symb in [ s_plus, s_minus ])
                        AND
                        (NOT may_p_m))
                    THEN
                        BEGIN
                        may_p_m := true;
                        IF  a_ap_tree^[ curr_n ].n_symb =
                            a_ap_tree^[ curr_n1 ].n_symb
                        THEN
                            curr_n := a_ap_tree^[ curr_n ].n_lo_level
                        ELSE
                            a_ap_tree^[ curr_n ].n_symb := s_minus
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  NOT subquery
                    THEN
                        a01_force_symbol (acv, s_rightpar, put_node, last_node)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            s_identifier :
                BEGIN
                IF  ((a01_eqkey (a01kw[ cak_i_current ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)) AND
                    (a_sqlmode = sqlm_db2))
                THEN
                    BEGIN
                    scvh := a_scv;
                    a01_next_symbol(acv);
                    a01_get_keyword (acv, index, res_kw);
                    IF  (index = cak_i_date)         OR
                        (index = cak_i_time)         OR
                        (index = cak_i_timestamp)    OR
                        (index = cak_i_timezone)     OR
                        (index = cak_i_sqlid)        OR
                        (index = cak_i_degree)
                    THEN
                        BEGIN
                        a_scv := scvh;
                        a03_avalue_spec (acv, NOT c_null_allowed,
                              NOT c_stamp_allowed, NOT c_default_allowed,
                              c_sysuser_allowed, curr_n, curr_n2)
                        END
                    ELSE
                        a07_error (acv, e_wanted_keyword,
                              put_node, last_node)
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    a01_get_keyword (acv, index, res_kw);
                    IF  NOT may_p_m
                    THEN
                        IF  ((index <> cak_i_no_keyword) AND
                            (* functions are all res_kw *)
                            res_kw)
                        THEN
                            CASE index OF
                                cak_i_index, cak_i_instr, cak_i_locate,
                                cak_i_length, cak_i_num, cak_i_fixed,
                                cak_i_vsize, cak_i_ascii, cak_i_to_number,
                                cak_i_decimal, cak_i_trunc, cak_i_truncate,
                                cak_i_integer, cak_i_float, cak_i_round,
                                cak_i_noround, cak_i_mod, cak_i_abs,
                                cak_i_ceil, cak_i_ceiling, cak_i_floor,
                                cak_i_sign, cak_i_sqrt, cak_i_power,
                                cak_i_dayofweek, cak_i_dayofmonth,
                                cak_i_dayofyear, cak_i_weekofyear,
                                cak_i_week, cak_i_day, cak_i_days,
                                cak_i_monthname, cak_i_dayname,
                                cak_i_hour, cak_i_microsec, cak_i_minute,
                                cak_i_month, cak_i_second, cak_i_year,
                                cak_i_max, cak_i_min, cak_i_sum,
                                cak_i_count, cak_i_avg,
                                cak_i_stddev, cak_i_variance,
                                cak_i_value, cak_i_ifnull, cak_i_greatest,
                                cak_i_least, cak_i_nvl, cak_i_decode,
                                cak_i_exp, cak_i_ln, cak_i_log, cak_i_log10,
                                cak_i_sin, cak_i_cos, cak_i_tan, cak_i_cot,
                                cak_i_sinh, cak_i_cosh, cak_i_tanh,
                                cak_i_acos, cak_i_asin,
                                cak_i_atan, cak_i_atan2,
                                cak_i_degrees, cak_i_radians:
                                    BEGIN
                                    END;
                                OTHERWISE
                                    a07_error (acv, e_missing_number,
                                          put_node, last_node);
                                END;
                            (*ENDCASE*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  ((index = cak_i_default) AND
                        (a_sqlmode <> sqlm_internal))
                    THEN
                        index := cak_i_no_keyword;
                    (*ENDIF*) 
                    CASE index OF
                        cak_i_true :
                            IF  a_sqlmode = sqlm_internal
                            THEN
                                BEGIN
                                sc_symb := s_true;
                                a01_put_node (acv, put_node);
                                a01_next_symbol (acv);
                                curr_n  := put_node;
                                curr_n2 := put_node;
                                END
                            ELSE
                                a07_error (acv, e_missing_keyword,
                                      put_node, last_node);
                            (*ENDIF*) 
                        cak_i_false :
                            IF  a_sqlmode = sqlm_internal
                            THEN
                                BEGIN
                                sc_symb := s_false;
                                a01_put_node (acv, put_node);
                                a01_next_symbol (acv);
                                curr_n  := put_node;
                                curr_n2 := put_node;
                                END
                            ELSE
                                a07_error (acv, e_missing_keyword,
                                      put_node, last_node);
                            (*ENDIF*) 
                        cak_i_null :
                            IF  ((a_sqlmode = sqlm_oracle) OR
                                ( a_sqlmode = sqlm_internal))
                            THEN
                                BEGIN
                                sc_symb := s_null;
                                a01_put_node (acv, put_node);
                                a01_next_symbol (acv);
                                curr_n  := put_node;
                                curr_n2 := put_node;
                                END
                            ELSE
                                a07_error (acv, e_missing_keyword,
                                      put_node, last_node);
                            (*ENDIF*) 
                        cak_i_default :
                            BEGIN
                            sc_symb := s_default;
                            a01_put_node (acv, put_node);
                            a01_next_symbol (acv);
                            curr_n  := put_node;
                            curr_n2 := put_node;
                            END;
                        cak_i_curdate, cak_i_curtime, cak_i_now :
                            a03_avalue_spec (acv, NOT c_null_allowed,
                                  NOT c_stamp_allowed,
                                  NOT c_default_allowed,
                                  NOT c_sysuser_allowed,
                                  curr_n, curr_n2);
                        cak_i_date, cak_i_time, cak_i_timestamp :
                            BEGIN
                            scvh := a_scv;
                            a01_next_symbol(acv);
                            (* PTS 1000313 E.Z. *)
                            (* PTS 1105820 E.Z. *)
                            IF  (sc_symb = s_leftpar)                       AND
                                (
                                (a_sqlmode in [sqlm_db2, sqlm_internal])    OR
                                ((a_sqlmode = sqlm_oracle)            AND
                                (index = cak_i_timestamp)
                                )
                                )
                            THEN
                                BEGIN
                                a_scv := scvh;
                                ak63afunction_spec (acv, curr_n, curr_n2,
                                      index)
                                END
                            ELSE
                                BEGIN
                                a_scv := scvh;
                                a03_avalue_spec (acv, NOT c_null_allowed,
                                      NOT c_stamp_allowed,
                                      NOT c_default_allowed,
                                      NOT c_sysuser_allowed,
                                      curr_n, curr_n2)
                                END;
                            (*ENDIF*) 
                            END;
                        cak_i_uid,
                        cak_i_current, cak_i_timezone,
                        cak_i_sysdate, cak_i_pi, cak_i_database,
                        cak_i_transaction,
                        (* PTS 1116175 E.Z. *)
                        cak_i_utcdate,
                        (* PTS 1109925 E.Z. *)
                        cak_i_utcdiff :
                            BEGIN
                            a03_avalue_spec (acv, NOT c_null_allowed,
                                  NOT c_stamp_allowed,
                                  NOT c_default_allowed,
                                  c_sysuser_allowed,
                                  curr_n, curr_n2);
                            IF  (a_sqlmode in
                                [sqlm_internal, sqlm_oracle])                                 AND
                                ((a_comp_type = at_odbc) OR (a_comp_type = at_jdbc)
                                OR (a_internal_sql in [sql_restore_schema, sql_alter_table])) AND
                                (index in [cak_i_pi, cak_i_database])                         AND
                                (sc_symb = s_leftpar)
                            THEN
                                BEGIN
                                a01_next_symbol(acv);
                                a01_force_symbol (acv, s_rightpar,
                                      put_node, last_node)
                                END;
                            (*ENDIF*) 
                            END;
                        (* PTS 1111797 E.Z. *)
                        cak_i_sysdba,
                        cak_i_user, cak_i_usergroup,
                        cak_i_current_schema :
                            BEGIN
                            scvh := a_scv;
                            a01_next_symbol(acv);
                            IF  sc_symb = s_point
                            THEN (* author of table/column specification *)
                                BEGIN
                                a_scv := scvh;
                                m_scv := scvh;
                                a02_acolumnspec (acv,
                                      NOT c_table_required, curr_n,
                                      curr_n2);
                                (* h.b. PTS 1000901 *)
                                ak63acheck_sequence (acv, m_scv, curr_n,
                                      curr_n2, put_node);
                                END
                            ELSE
                                BEGIN
                                a_scv := scvh;
                                a03_avalue_spec (acv, NOT c_null_allowed,
                                      NOT c_stamp_allowed,
                                      NOT c_default_allowed,
                                      c_sysuser_allowed,
                                      curr_n, curr_n2);
                                IF  (a_sqlmode in
                                    [sqlm_internal, sqlm_oracle])                                 AND
                                    ((a_comp_type = at_odbc) OR (a_comp_type = at_jdbc)
                                    OR (a_internal_sql in [sql_restore_schema, sql_alter_table])) AND
                                    (index = cak_i_user)                                          AND
                                    (sc_symb = s_leftpar)
                                THEN
                                    BEGIN
                                    a01_next_symbol(acv);
                                    a01_force_symbol (acv, s_rightpar,
                                          put_node, last_node)
                                    END;
                                (*ENDIF*) 
                                END
                            (*ENDIF*) 
                            END;
                        cak_i_rowno,
                        cak_i_rownum :
                            IF  a_ap_tree^[a_ap_tree^[0].n_lo_level].n_proc = a16
                            THEN
                                a07_error (acv, e_in_view_not_allowed,
                                      put_node, last_node)
                            ELSE
                                IF  (a_rowno_allowed    AND
                                    (NOT a_rowno_found) AND
                                    (NOT a_limit_found))
                                THEN
                                    BEGIN
                                    a_rowno_found := true;
                                    sc_symb       := s_rowno;
                                    a01_put_node (acv, curr_n);
                                    curr_n2       := curr_n;
                                    a01_next_symbol (acv)
                                    END
                                ELSE
                                    a07_error (acv, e_rowno_not_allowed,
                                          put_node, last_node);
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (* PTS 1112324 E.Z. *)
                        cak_i_select :
                            a07_error (acv, e_subquery_not_allowed,
                                  put_node, last_node);
                        OTHERWISE
                            BEGIN
                            scvh      := a_scv;
                            a01_next_symbol(acv);
                            IF  sc_symb = s_point
                            THEN
                                BEGIN
                                a01_next_symbol(acv);
                                IF  sc_symb = s_identifier
                                THEN
                                    BEGIN
                                    a01_next_symbol(acv);
                                    IF  sc_symb = s_leftpar
                                    THEN
                                        BEGIN (* user defined function (schema.function (...) *)
                                        m_scv   := a_scv;
                                        a_scv   := scvh;
                                        sc_symb := s_authid;
                                        index   := 0;
                                        a01_put_node (acv, curr_n2);
                                        a_scv   := m_scv;
                                        curr_n  := curr_n2;
                                        END;
                                    (*ENDIF*) 
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            IF  ((sc_symb = s_leftpar) OR
                                ( index = cak_i_null)  OR
                                ( index = cak_i_case))
                            THEN
                                BEGIN
                                a_scv := scvh;
                                ak63afunction_spec (acv, curr_n, curr_n2,
                                      index)
                                END
                            ELSE
                                BEGIN
                                a_scv := scvh;
                                m_scv := scvh;
                                a02_acolumnspec (acv, NOT c_table_required,
                                      curr_n, curr_n2);
                                IF  sc_symb = s_method_call
                                THEN
                                    BEGIN
&                                   ifdef trace
                                    t01int4 (ak_sem, 'curr_n      ', curr_n);
                                    t01int4 (ak_sem, 'curr_n2     ', curr_n2);
&                                   endif
                                    a01_next_symbol (acv);
                                    ak63user_defined_func (acv, s_method_call,
                                          curr_n, aux_n,
                                          curr_n2);
                                    curr_n := aux_n;
&                                   ifdef trace
                                    t01int4 (ak_sem, 'curr_n      ', curr_n);
&                                   endif
                                    END;
                                (* h.b. PTS 1000901 *)
                                (*ENDIF*) 
                                ak63acheck_sequence (acv, m_scv, curr_n,
                                      curr_n2, put_node);
                                END
                            (*ENDIF*) 
                            END;
                        END
                    (*ENDCASE*) 
                    END
                (*ENDIF*) 
                END;
            OTHERWISE
                a07_error (acv, e_missing_value_spec, put_node,
                      last_node)
            END;
        (*ENDCASE*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            IF  may_p_m
            THEN
                BEGIN
                put_node  := curr_n;
                last_node := curr_n2
                END
            ELSE
                BEGIN
                put_node  := curr_n1;
                last_node := curr_n1;
                a_ap_tree^[ curr_n1 ].n_lo_level := curr_n
                END;
            (*ENDIF*) 
            (* for future use
                  IF  a01_eqkey (a01kw[ cak_i_collate ], a_sqlmode,
                  a_cmd_part^.sp1p_buf, a_scv)
                  THEN
                  BEGIN
                  sc_symb := s_mbcs;
                  a01_function_put (acv, curr_n);
                  a_ap_tree^[ curr_n ].n_lo_level := put_node;
                  put_node := curr_n;
                  a01_next_symbol (acv);
                  IF  a01_eqkey (a01kw[ cak_i_default ], a_sqlmode,
                  a_cmd_part^.sp1p_buf, a_scv)
                  THEN
                  BEGIN
                  a01_next_symbol (acv);
                  END
                  ELSE
                  BEGIN
                  a01_character_set (acv,
                  a_ap_tree^[ last_node ].n_sa_level,
                  curr_n);
                  END;
                  last_node := put_node;
                  END
                  *)
            END
        ELSE
            BEGIN
            put_node  := 0;
            last_node := 0;
            END;
        (*ENDIF*) 
        IF  ((a_comp_type = at_odbc) OR (a_comp_type = at_jdbc) OR 
            ( a_internal_sql in [sql_restore_schema, sql_alter_table])) 
            AND (odbc_partype <> no_odbc)
        THEN
            IF  NOT a01_odbc_end_ok (acv, odbc_partype)
            THEN
                a07_error (acv, e_missing_keyword,
                      put_node, last_node)
            ELSE
                BEGIN
                CASE odbc_functype OF
                    odbc_d :
                        a_ap_tree^[ put_node ].n_datatype := ddate;
                    odbc_t :
                        a_ap_tree^[ put_node ].n_datatype := dtime;
                    odbc_ts :
                        a_ap_tree^[ put_node ].n_datatype := dtimestamp;
                    OTHERWISE :
                        a_ap_tree^[ put_node ].n_datatype := dunknown;
                    END;
                (*ENDCASE*) 
                a01_next_symbol (acv);
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63acheck_sequence (VAR acv : tak_all_command_glob;
            VAR m_scv     : tak_scanner_glob;
            VAR curr_n    : tsp00_Int2;
            VAR curr_n2   : tsp00_Int2;
            VAR put_node  : tsp00_Int2);
 
VAR
      m_symb         : tak_sc_symbol;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  ((a_returncode = 0)
        AND
        (curr_n <> curr_n2)
        AND
        ((a_sqlmode = sqlm_oracle) OR
        ( a_sqlmode = sqlm_internal)))
    THEN
        BEGIN
        m_symb            := a_scv.sc_symb;
        m_scv.sc_sypos    := a_ap_tree^[ curr_n2 ].n_pos;
        m_scv.sc_sylength := a_ap_tree^[ curr_n2 ].n_length;
        IF  a01_eqkey (a01kw[ cak_i_nextval ], a_sqlmode,
            a_cmd_part^.sp1p_buf, m_scv)
        THEN
            a_scv.sc_symb := s_nextval
        ELSE
            IF  a01_eqkey (a01kw[ cak_i_currval ], a_sqlmode,
                a_cmd_part^.sp1p_buf, m_scv)
            THEN
                a_scv.sc_symb := s_currval;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  ((a_scv.sc_symb = s_nextval) OR (a_scv.sc_symb = s_currval))
        THEN
            BEGIN
            a01_put_node (acv, put_node);
            a_ap_tree^[ put_node ].n_lo_level := curr_n;
            IF  a_ap_tree^[ curr_n ].n_symb = s_authid
            THEN
                curr_n := a_ap_tree^[ curr_n ].n_sa_level;
            (*ENDIF*) 
            a_ap_tree^[ curr_n ].n_symb := s_sequence;
            a_ap_tree^[ curr_n ].n_sa_level := 0;
            curr_n := put_node;
            curr_n2 := put_node;
            a_scv.sc_symb := m_symb;
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63afunction_spec (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
VAR
      curr_n    : tsp00_Int2;
      cur2_n    : tsp00_Int2;
      scvh      : tak_scanner_glob;
      hfunc     : tak_function;
 
BEGIN
&ifdef TRACE
t01int4 (ak_syn, 'a_col_func_c', acv.a_col_func_count);
t01int4 (ak_syn, 'a_internal_s', ord(acv.a_internal_sql));
&endif
curr_n := last_node;
cur2_n := last_node;
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        IF  a_col_func_count >= mxak_col_func_nesting
        THEN
            a07_error (acv, e_too_many_nested_functions,
                  put_node, last_node)
        ELSE
            IF  (a_comp_type <> at_odbc              ) AND
                (a_comp_type <> at_jdbc              ) AND
                (a_internal_sql <> sql_restore_schema) AND
                (a_internal_sql <> sql_alter_table   ) AND
                (index in [ cak_i_left, cak_i_right,
                cak_i_ucase, cak_i_lcase,
                cak_i_truncate, cak_i_ifnull])
            THEN
                a07_error (acv, e_missing_keyword,
                      put_node, last_node)
            ELSE
                (* PTS 1000313 E.Z. *)
                (* PTS 1105820 E.Z. *)
                BEGIN
                a_col_func_count := succ(a_col_func_count);
                CASE index OF
                    cak_i_no_keyword :
                        ak63user_defined_func (acv,
                              s_user_func, 0, put_node, last_node);
                    cak_i_mbcs :
                        ak63mbcs_syn (acv, put_node, last_node);
                    cak_i_index, cak_i_locate, cak_i_instr :
                        IF  (a_sqlmode <> sqlm_internal) AND (index = cak_i_index)
                        THEN
                            a07_error (acv, e_missing_keyword,
                                  put_node, last_node)
                        ELSE
                            ak63acstring_expression (acv, put_node, last_node, index);
                        (*ENDIF*) 
                    cak_i_substr, cak_i_substring,
                    cak_i_left, cak_i_right :
                        ak63asstring_expression (acv, put_node, last_node, index);
                    cak_i_upper, cak_i_ucase, cak_i_lower, cak_i_lcase,
                    (* PTS 1122828 E.Z. *)
                    cak_i_initcap, cak_i_soundex,
                    cak_i_toidentifier, cak_i_unicode :
                        IF  (a_sqlmode = sqlm_ansi)
                        THEN
                            a07_error (acv, e_missing_keyword,
                                  put_node, last_node)
                        ELSE
                            (* PTS 1110039 E.Z. *)
                            IF  ((index = cak_i_unicode) AND
                                NOT g01unicode)
                            THEN
                                a07_error (acv, e_missing_keyword,
                                      put_node, last_node)
                            ELSE
                                ak63one_string_spec_param_syn ( acv, put_node,
                                      last_node, index );
                            (*ENDIF*) 
                        (*ENDIF*) 
                    cak_i_ascii :
                        IF  (a_sqlmode = sqlm_internal)
                        THEN
                            ak63one_string_spec_param_syn ( acv, put_node,
                                  last_node, index )
                        ELSE
                            ak63one_value_expr_param_syn ( acv, put_node,
                                  last_node, index );
                        (*ENDIF*) 
                    cak_i_concat :
                        IF  (a_sqlmode in [sqlm_oracle, sqlm_internal])
                        THEN
                            ak63concat_syn ( acv, put_node, last_node )
                        ELSE
                            a07_error (acv, e_missing_keyword,
                                  put_node, last_node);
                        (*ENDIF*) 
                    cak_i_expand :
                        ak63expand_syn ( acv, put_node, last_node );
                    cak_i_space :
                        ak63space_syn ( acv, put_node, last_node );
                    cak_i_num, cak_i_to_number :
                        ak63num_to_number_func_syn (acv, put_node,
                              last_node, index);
                    cak_i_fixed, cak_i_decimal :
                        ak63fixed_decimal_func_syn (acv, put_node,
                              last_node, index);
                    cak_i_chr, cak_i_alpha:
                        ak63chr_alpha_func_syn (acv, put_node,
                              last_node, index);
                    cak_i_mapchar:
                        ak63mapchar_func_syn (acv, put_node, last_node);
                    cak_i_nlssort:
                        ak63nlssort_func_syn (acv, put_node, last_node);
                    cak_i_lpad, cak_i_rpad :
                        IF  a_sqlmode = sqlm_internal
                        THEN
                            ak63lrpad_syn (acv, put_node, last_node, index)
                        ELSE
                            ak63pad_oracle_syn (acv, put_node, last_node, index);
                        (*ENDIF*) 
                    cak_i_lfill, cak_i_rfill :
                        ak63lrpad_syn (acv, put_node, last_node, index);
                    cak_i_to_char, cak_i_to_date :
                        ak63to_char_date_syn (acv, put_node, last_node, index);
                    cak_i_trim, cak_i_ltrim, cak_i_rtrim:
                        IF  (a_sqlmode = sqlm_ansi)
                        THEN
                            a07_error (acv, e_missing_keyword,
                                  put_node, last_node)
                        ELSE
                            ak63trim_parameter_syn ( acv, put_node,
                                  last_node, index );
                        (*ENDIF*) 
                    cak_i_trunc, cak_i_truncate, cak_i_round :
                        ak63trunc_round_parameter_syn ( acv, put_node,
                              last_node, index );
                    cak_i_integer:
                        IF  (a_sqlmode <> sqlm_db2)
                        THEN
                            a07_error (acv, e_missing_keyword,
                                  put_node, last_node)
                        ELSE
                            BEGIN
                            sc_symb := s_integer;
                            ak63value_expression_syn
                                  (acv, put_node, last_node)
                            END;
                        (*ENDIF*) 
                    cak_i_float:
                        IF  (a_sqlmode <> sqlm_db2)
                            AND  (a_sqlmode <> sqlm_internal)
                        THEN
                            a07_error (acv, e_missing_keyword,
                                  put_node, last_node)
                        ELSE
                            BEGIN
                            sc_symb := s_float;
                            IF  a_sqlmode = sqlm_db2
                            THEN
                                ak63value_expression_syn
                                      (acv, put_node, last_node)
                            ELSE
                                ak63two_value_expr_para_syn ( acv, put_node,
                                      last_node, index);
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    cak_i_ceil,       cak_i_ceiling,
                    cak_i_floor,
                    cak_i_sign,       cak_i_sqrt,
                    cak_i_sin,        cak_i_sinh,
                    cak_i_cos,        cak_i_cosh,
                    cak_i_tan,        cak_i_tanh,
                    cak_i_exp,        cak_i_ln,
                    cak_i_abs,        cak_i_noround,
                    cak_i_dayofweek,  cak_i_dayofyear,
                    cak_i_dayofmonth, cak_i_weekofyear,
                    cak_i_week,
                    cak_i_monthname,  cak_i_dayname,
                    cak_i_length,
                    cak_i_vsize,      cak_i_atan,
                    cak_i_acos,       cak_i_asin,
                    cak_i_log10,      cak_i_cot,
                    cak_i_degrees,    cak_i_radians :
                        BEGIN
                        ak63one_value_expr_param_syn ( acv, put_node,
                              last_node, index );
                        END;
                    cak_i_power,
                    cak_i_adddate,  cak_i_subdate,
                    cak_i_datediff, cak_i_timediff,
                    cak_i_addtime,  cak_i_subtime,
                    cak_i_next_day, cak_i_atan2 :
                        ak63two_value_expr_para_syn ( acv, put_node,
                              last_node, index);
                    cak_i_mod :
                        IF  NOT (a_sqlmode in [sqlm_oracle, sqlm_internal])
                        THEN
                            a07_error (acv, e_missing_keyword,
                                  put_node, last_node)
                        ELSE
                            ak63two_value_expr_para_syn ( acv, put_node,
                                  last_node, index);
                        (*ENDIF*) 
                    cak_i_log :
                        BEGIN
                        IF  ((a_comp_type = at_odbc) OR (a_comp_type = at_jdbc))
                        THEN
                            ak63one_value_expr_param_syn ( acv, put_node,
                                  last_node, cak_i_ln)
                        ELSE
                            ak63two_value_expr_para_syn ( acv, put_node,
                                  last_node, index);
                        (*ENDIF*) 
                        END;
                    cak_i_new_time :
                        IF  a_sqlmode <> sqlm_oracle
                        THEN
                            a07_error (acv, e_missing_keyword,
                                  put_node, last_node)
                        ELSE
                            ak63three_value_expr_para_syn ( acv, put_node,
                                  last_node, index);
                        (*ENDIF*) 
                    cak_i_maketime :
                        ak63maketime_syn ( acv, put_node, last_node);
                    cak_i_makedate :
                        ak63_makedate_syn ( acv, put_node, last_node);
                    (* PTS 1000313 E.Z. *)
                    (* PTS 1105820 E.Z. *)
                    cak_i_day, cak_i_month,
                    cak_i_year,
                    cak_i_date,
                    cak_i_hour, cak_i_minute,
                    cak_i_second, cak_i_microsec,
                    cak_i_time :
                        IF  (a_sqlmode = sqlm_ansi) OR
                            ((a_sqlmode = sqlm_oracle)
                            AND (a_comp_type <> at_odbc)
                            AND (a_comp_type <> at_jdbc)
                            AND (a_internal_sql <> sql_restore_schema)
                            AND (a_internal_sql <> sql_alter_table   ))
                        THEN
                            a07_error (acv, e_missing_keyword,
                                  put_node, last_node)
                        ELSE
                            ak63extraction_func_syn ( acv, put_node, last_node,
                                  index );
                        (*ENDIF*) 
                    cak_i_days :
                        IF  a_sqlmode <> sqlm_db2
                        THEN
                            a07_error (acv, e_missing_keyword,
                                  put_node, last_node)
                        ELSE
                            ak63extraction_func_syn ( acv, put_node, last_node,
                                  index );
                        (*ENDIF*) 
                    cak_i_hex, cak_i_digits,
                    cak_i_rawtohex, cak_i_hextoraw :
                        ak63hex_digits_hextoraw_syn ( acv, put_node,
                              last_node, index );
                    cak_i_timestamp :
                        IF  (a_sqlmode <> sqlm_db2) AND
                            (a_sqlmode <> sqlm_internal) AND
                            (a_sqlmode <> sqlm_oracle)
                        THEN
                            a07_error (acv, e_missing_keyword, put_node,
                                  last_node)
                        ELSE
                            ak63_timestamp_syn ( acv, put_node, last_node);
                        (*ENDIF*) 
                    cak_i_char      :
                        IF  (a_sqlmode <> sqlm_db2) AND
                            (a_sqlmode <> sqlm_internal)
                        THEN
                            a07_error (acv, e_missing_keyword, put_node,
                                  last_node)
                        ELSE
                            ak63char_syn ( acv, put_node, last_node);
                        (*ENDIF*) 
                    cak_i_decode, cak_i_greatest, cak_i_least,
                    cak_i_nvl, cak_i_value, cak_i_ifnull :
                        IF  (a_sqlmode = sqlm_ansi)
                        THEN
                            a07_error (acv, e_missing_keyword,
                                  put_node, last_node)
                        ELSE
                            ak63_special_func_syn (acv, put_node,
                                  last_node, index);
                        (*ENDIF*) 
                    cak_i_translate, cak_i_replace:
                        IF  (a_sqlmode = sqlm_ansi)
                        THEN
                            a07_error (acv, e_missing_keyword,
                                  put_node, last_node)
                        ELSE
                            ak63replace_translate_func_syn (acv, put_node,
                                  last_node, index);
                        (*ENDIF*) 
                    cak_i_add_months :
                        ak63add_months_syn (acv, put_node, last_node);
                    cak_i_last_day :
                        ak63last_day_syn (acv, put_node, last_node);
                    cak_i_months_between :
                        ak63months_between_syn (acv, put_node, last_node);
                    (* PTS 1111577 E.Z. *)
                    cak_i_get_objectname, cak_i_get_schema :
                        BEGIN
                        ak63get_name (acv, put_node, last_node, index);
                        END;
                    (* PTS 1117523 E.Z. *)
                    cak_i_case :
                        ak63case (acv, put_node, last_node);
                    OTHERWISE
                        IF  (index =  cak_i_isupdatedcolumn) AND (acv.a_proc_compile = pct_update_trigger)
                        THEN (* updated function allowed in update triggers only *)
                            ak63updated (acv, put_node, last_node)
                        ELSE
                            IF  a_allow_functions = tf_no_func
                            THEN
                                IF  (index = cak_i_avg)    OR
                                    (index = cak_i_max)    OR
                                    (index = cak_i_min)    OR
                                    (index = cak_i_sum)    OR
                                    (index = cak_i_count)  OR
                                    (index = cak_i_stddev) OR
                                    (index = cak_i_variance)
                                THEN
                                    a07_error (acv,
                                          e_invalid_mix_functions_columns,
                                          put_node, last_node)
                                ELSE
                                    a07_error (acv, e_invalid_keyword,
                                          put_node, last_node)
                                (*ENDIF*) 
                            ELSE
                                BEGIN
                                IF  (index <> cak_i_avg)    AND
                                    (index <> cak_i_max)    AND
                                    (index <> cak_i_min)    AND
                                    (index <> cak_i_sum)    AND
                                    (index <> cak_i_count)  AND
                                    (index <> cak_i_stddev) AND
                                    (index <> cak_i_variance)
                                THEN
                                    a07_error (acv, e_wanted_keyword,
                                          put_node, last_node);
                                (*ENDIF*) 
                                IF  a_returncode = 0
                                THEN
                                    BEGIN
                                    a01_next_symbol (acv);
                                    IF  sc_symb <> s_leftpar
                                    THEN
                                        a07_error (acv, e_missing_keyword,
                                              put_node, last_node)
                                    ELSE
                                        BEGIN
                                        CASE a_precomp_info_byte OF
                                            csp1_p_mass_command :
                                                (* for MINSERT..SELECT*)
                                                a_precomp_info_byte := csp1_p_none;
                                            csp1_p_mselect_found :
                                                a_precomp_info_byte := csp1_p_mass_select_found;
                                            csp1_p_for_upd_mselect_found :
                                                a_precomp_info_byte := csp1_p_select_for_update_found;
                                            csp1_p_reuse_mselect_found :
                                                a_precomp_info_byte := csp1_p_reuse_mass_select_found;
                                            csp1_p_reuse_upd_mselect_found :
                                                a_precomp_info_byte := csp1_p_reuse_update_sel_found;
                                            OTHERWISE
                                                BEGIN
                                                END
                                            END;
                                        (*ENDCASE*) 
                                        scvh      := a_scv;
                                        a01_next_symbol (acv);
                                        IF  sc_symb = s_asterisk
                                        THEN
                                            IF  index = cak_i_count
                                            THEN
                                                BEGIN
                                                sc_symb := s_all_count;
                                                a01_put_node (acv, put_node);
                                                curr_n  := put_node;
                                                a01_next_symbol (acv);
                                                END
                                            ELSE
                                                a07_error (acv, e_invalid_keyword,
                                                      put_node, last_node)
                                            (*ENDIF*) 
                                        ELSE
                                            IF  a01_eqkey (a01kw[ cak_i_distinct ], a_sqlmode,
                                                a_cmd_part^.sp1p_buf, a_scv)
                                            THEN
                                                BEGIN
                                                CASE index OF
                                                    cak_i_avg :
                                                     sc_symb := s_dis_avg;
                                                    cak_i_max :
                                                     sc_symb := s_max;
                                                    cak_i_min :
                                                     sc_symb := s_min;
                                                    cak_i_sum :
                                                     sc_symb := s_dis_sum;
                                                    cak_i_count :
                                                     sc_symb := s_dis_count;
                                                    cak_i_stddev :
                                                     sc_symb := s_dis_stddev;
                                                    cak_i_variance :
                                                     sc_symb := s_dis_variance;
                                                    END;
                                                (*ENDCASE*) 
                                                a01_put_node (acv, put_node);
                                                curr_n := put_node;
                                                a01_next_symbol (acv);
                                                IF  a_sqlmode = sqlm_ansi
                                                THEN
                                                    (* Entry Level and Intermediate ! *)
                                                    a02_acolumnspec (acv,
                                                       NOT c_table_required,
                                                       a_ap_tree^[ curr_n ].n_lo_level,
                                                       cur2_n)
                                                ELSE
                                                    ak63avalue_expression (acv,
                                                       a_ap_tree^[ curr_n ].n_lo_level,
                                                       cur2_n)
                                                (*ENDIF*) 
                                                END
                                            ELSE
                                                IF  ((index = cak_i_count) AND
                                                    ((a_sqlmode = sqlm_ansi) OR
                                                    ( a_sqlmode = sqlm_db2)))
                                                THEN
                                                    a07_error (acv, e_missing_keyword,
                                                       put_node, last_node)
                                                ELSE
                                                    BEGIN
                                                    a_scv := scvh;
                                                    CASE index OF
                                                     cak_i_avg :
                                                      sc_symb := s_avg;
                                                     cak_i_max :
                                                      sc_symb := s_max;
                                                     cak_i_min :
                                                      sc_symb := s_min;
                                                     cak_i_sum :
                                                      sc_symb := s_sum;
                                                     cak_i_count :
                                                      sc_symb := s_count;
                                                     cak_i_stddev :
                                                      sc_symb := s_stddev;
                                                     cak_i_variance :
                                                      sc_symb := s_variance;
                                                     END;
                                                    (*ENDCASE*) 
                                                    a01_put_node (acv, put_node);
                                                    curr_n := put_node;
                                                    a01_next_symbol (acv);
                                                    IF  a01_eqkey (a01kw[ cak_i_all ], a_sqlmode,
                                                     a_cmd_part^.sp1p_buf, a_scv)
                                                    THEN
                                                     a01_next_symbol (acv);
                                                    (*ENDIF*) 
                                                    hfunc := a_allow_functions;
                                                    a_allow_functions := tf_no_func;
                                                    ak63avalue_expression (acv,
                                                       a_ap_tree^[ curr_n ].n_lo_level,
                                                       cur2_n);
                                                    a_allow_functions := hfunc
                                                    END;
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                        a01_force_symbol (acv, s_rightpar,
                                              put_node, last_node);
                                        last_node := curr_n
                                        END
                                    (*ENDIF*) 
                                    END;
                                (*ENDIF*) 
                                a_allow_functions := tf_func;
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    END
                (*ENDCASE*) 
                END
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63arest_factor (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2 );
 
VAR
      curr_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    IF  sc_symb = s_leftpar
    THEN
        a07_error (acv, e_invalid_keyword, put_node, last_node)
    ELSE
        BEGIN
        IF  a_sqlmode = sqlm_db2
        THEN
            IF  a01_eqkey (a01kw[ cak_i_concat ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                sc_symb := s_concat;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  ((sc_symb = s_concat) AND (a_returncode = 0))
        THEN
            WHILE ((sc_symb = s_concat) AND
                  (a_returncode = 0)) DO
                BEGIN
                a01_function_put (acv, curr_n);
                ak63subq_check (acv, put_node, last_node);
                a_ap_tree^[ curr_n ].n_lo_level := put_node;
                put_node  := curr_n;
                curr_n    := last_node;
                last_node := put_node;
                a01_next_symbol (acv);
                ak63afactor (acv, a_ap_tree^[ curr_n ].n_sa_level, curr_n );
                IF  a_sqlmode = sqlm_db2
                THEN
                    IF  a01_eqkey (a01kw[ cak_i_concat ], a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv)
                    THEN
                        sc_symb := s_concat;
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            (*ENDWHILE*) 
        ELSE
            BEGIN
            IF  (a_sqlmode       = sqlm_internal)  AND
                (sc_symb         = s_identifier) AND
                (sc_double_quote = 0)
            THEN
                IF  a01_eqkey (a01kw[ cak_i_mod ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    sc_symb := s_mod
                ELSE
                    IF  a01_eqkey (a01kw[ cak_i_div ], a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv)
                    THEN
                        sc_symb := s_div;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            WHILE ( sc_symb in [ s_asterisk, s_divide, s_mod, s_div  ] )
                  AND ( a_returncode = 0 )DO
                BEGIN
                IF  sc_symb = s_asterisk
                THEN
                    sc_symb := s_mult;
                (*ENDIF*) 
                a01_call_put (acv, a64, cak_x_mult_operator, curr_n);
                a_ap_tree^[ curr_n ].n_symb := a_scv.sc_symb;
                ak63subq_check (acv, put_node, last_node);
                a_ap_tree^[ curr_n ].n_lo_level := put_node;
                put_node  := curr_n;
                curr_n    := last_node;
                last_node := put_node;
                a01_next_symbol( acv );
                ak63afactor( acv, a_ap_tree^[ curr_n ].n_sa_level,curr_n );
                IF  (a_sqlmode       = sqlm_internal)  AND
                    (sc_symb         = s_identifier) AND
                    (sc_double_quote = 0)
                THEN
                    IF  a01_eqkey (a01kw[ cak_i_mod ], a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv)
                    THEN
                        sc_symb := s_mod
                    ELSE
                        IF  a01_eqkey (a01kw[ cak_i_div ], a_sqlmode,
                            a_cmd_part^.sp1p_buf, a_scv)
                        THEN
                            sc_symb := s_div;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            (*ENDWHILE*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63add_months_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    sc_symb   := s_add_months;
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := put_node;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        a01_force_symbol (acv, s_comma, put_node, last_node);
        IF  a_returncode = 0
        THEN
            BEGIN
            ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level, curr_n);
            ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_sa_level,
                  curr_n);
            a01_force_symbol (acv, s_rightpar, put_node, last_node)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63asstring_expression (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        CASE index OF
            cak_i_substr,
            cak_i_substring :
                sc_symb := s_substr;
            cak_i_left   :
                sc_symb := s_left;
            cak_i_right  :
                sc_symb := s_right;
            OTHERWISE    :  ;
            END;
        (*ENDCASE*) 
        a01_function_put (acv, put_node);
        curr_n    := put_node;
        last_node := put_node;
        a01_next_symbol (acv);
        a01_force_symbol (acv, s_leftpar, put_node, last_node);
        IF  a_returncode = 0
        THEN
            BEGIN
            curr_n1 := curr_n;
            ak63astring_spec (acv, a_ap_tree^[ curr_n ].n_lo_level, curr_n);
            a01_force_symbol (acv, s_comma, put_node, last_node);
            IF  a_returncode = 0
            THEN
                BEGIN
                ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level, curr_n);
                curr_n1 := curr_n;
                ak63avalue_expression (acv,
                      a_ap_tree^[ curr_n ].n_sa_level, curr_n);
                IF  (sc_symb = s_comma) AND
                    (index in [cak_i_substr, cak_i_substring])
                THEN
                    BEGIN
                    a01_next_symbol (acv);
                    ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_sa_level, curr_n);
                    ak63avalue_expression (acv,
                          a_ap_tree^[ curr_n ].n_sa_level, curr_n)
                    END;
                (*ENDIF*) 
                a01_force_symbol (acv, s_rightpar, put_node, last_node)
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63astring_spec (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      (* PTS 1116169 E.Z. *)
      subquery          : boolean;
      index             : integer;
      m_parameter_count : integer;
      hscv_index        : tsp00_Int2;
      scvh              : tak_scanner_glob;
      res_kw            : boolean;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        scvh       := a_scv;
        hscv_index := a_scv_index;
        (* PTS 1118281 E.Z. *)
        m_parameter_count := a_count_variab;
        CASE sc_symb OF
            s_byte_string,
            s_string_literal :
                BEGIN
                a01_put_node (acv, put_node);
                a01_next_symbol (acv);
                last_node := put_node
                END;
            (* to get the same error-msg as in all other cases *)
            (* the returncode e_missing_identifier is right    *)
            s_parameter_name :
                IF  ((a_ex_kind <> only_parsing) AND
                    (a_ex_kind <> only_syntax))
                THEN
                    a07_error (acv, e_parameter_not_allowed,
                          put_node, last_node)
                ELSE
                    a02_s_aparameterspec (acv, put_node, last_node);
                (*ENDIF*) 
            s_identifier :
                BEGIN
                IF  a01_eqkey (a01kw[ cak_i_current ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    a01_next_symbol(acv);
                (*ENDIF*) 
                a01_get_keyword (acv, index, res_kw);
                IF  (index <> cak_i_rowno) AND (index <> cak_i_timezone)
                THEN
                    BEGIN
                    a_scv := scvh;
                    ak63afactor (acv, put_node, last_node)
                    END
                (*ENDIF*) 
                END;
            (* PTS 1116169 E.Z. *)
            s_leftpar :
                BEGIN
                scvh := a_scv;
                subquery := false;
                a01_next_symbol (acv);
                IF  a01_eqkey (a01kw[ cak_i_select ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    IF  a_oneval_subq_allowed
                    THEN
                        BEGIN
                        a_scv := scvh;
                        subquery := true;
                        a60_asub_query (acv, put_node, 1, c_one_valsubquery);
                        last_node := put_node;
                        END
                    ELSE
                        a07_error (acv, e_missing_value_spec,
                              put_node, last_node)
                    (*ENDIF*) 
                ELSE
                    ak63afactor (acv, put_node, last_node);
                (*ENDIF*) 
                IF  NOT subquery
                THEN
                    a01_force_symbol (acv, s_rightpar, put_node, last_node)
                (*ENDIF*) 
                END;
            OTHERWISE
                a07_error (acv, e_missing_identifier,
                      put_node, last_node)
            END;
        (*ENDCASE*) 
        IF  a_sqlmode = sqlm_db2
        THEN
            IF  a01_eqkey (a01kw[ cak_i_concat ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                sc_symb := s_concat;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  ((sc_symb = s_concat) AND (a_returncode = 0))
        THEN
            BEGIN
            a_scv       := scvh;
            a_scv_index := hscv_index;
            (* PTS 1118281 E.Z. *)
            a_count_variab := m_parameter_count;
            ak63aterm (acv, put_node, last_node, NOT c_duration_allowed)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63aterm (VAR acv : tak_all_command_glob;
            VAR put_node     : tsp00_Int2;
            VAR last_node    : tsp00_Int2;
            duration_allowed : boolean);
 
VAR
      curr_n      : tsp00_Int2;
      index       : integer;
      res_kw      : boolean;
      dur_allowed : boolean;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        ak63afactor (acv, put_node, last_node);
        ak63arest_factor (acv, put_node, last_node);
        dur_allowed := (duration_allowed AND
              (a_sqlmode = sqlm_db2));
        IF  ( sc_symb = s_identifier ) AND dur_allowed
        THEN
            BEGIN
            a01_get_keyword(acv, index, res_kw);
            IF  (index = cak_i_month)       OR
                (index = cak_i_months)      OR
                (index = cak_i_day)         OR
                (index = cak_i_days)        OR
                (index = cak_i_hour)        OR
                (index = cak_i_hours)       OR
                (index = cak_i_minute)      OR
                (index = cak_i_minutes)     OR
                (index = cak_i_second)      OR
                (index = cak_i_seconds)     OR
                (index = cak_i_microsec)    OR
                (index = cak_i_microsecs)   OR
                (index = cak_i_year )       OR
                (index = cak_i_years )
            THEN
                BEGIN
                CASE index OF
                    cak_i_year, cak_i_years     :
                        sc_symb := s_year;
                    cak_i_month, cak_i_months   :
                        sc_symb := s_month;
                    cak_i_day, cak_i_days       :
                        sc_symb := s_day;
                    cak_i_hour, cak_i_hours     :
                        sc_symb := s_hour;
                    cak_i_minute, cak_i_minutes :
                        sc_symb := s_minute;
                    cak_i_second, cak_i_seconds :
                        sc_symb := s_second;
                    cak_i_microsec, cak_i_microsecs :
                        sc_symb := s_microsecond
                    END;
                (*ENDCASE*) 
                a01_call_put ( acv, a64, cak_x_duration, curr_n);
                a_ap_tree^[ curr_n ].n_symb := a_scv.sc_symb;
                a_ap_tree^[ curr_n ].n_lo_level := put_node;
                put_node := curr_n;
                curr_n := last_node;
                last_node := put_node;
                a01_next_symbol(acv);
                ak63arest_factor (acv, put_node, last_node);
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63change_nodes ( VAR acv : tak_all_command_glob;
            symbol      : tak_sc_symbol;
            VAR curr_n  : tsp00_Int2;
            VAR last    : tsp00_Int2;
            VAR changed : boolean );
 
VAR
      ilast1 : tsp00_Int2;
      ilast2 : tsp00_Int2;
      pos    : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  symbol = s_or
    THEN
        pos := cak_x_or_operator
    ELSE
        pos := cak_x_and_operator;
    (*ENDIF*) 
    IF  ( a_ap_tree^[ curr_n ].n_proc = a64)
        AND ( a_ap_tree^[ curr_n ].n_subproc = pos)
    THEN
        BEGIN
        changed := true;
        ilast1 := curr_n;
        WITH a_ap_tree^[ ilast1 ] DO
            BEGIN
            curr_n := n_lo_level;
            IF  a_ap_tree^[ n_lo_level ].n_symb = s_not
            THEN
                BEGIN
                ilast2 := a_ap_tree^[ a_ap_tree^[ n_lo_level ].
                      n_sa_level ].n_sa_level;
                a_ap_tree^[ a_ap_tree^[ n_lo_level ].
                      n_sa_level ].n_sa_level := ilast1
                END
            ELSE
                BEGIN
                ilast2 := a_ap_tree^[ n_lo_level ].n_sa_level;
                a_ap_tree^[ n_lo_level ].n_sa_level := ilast1;
                END;
            (*ENDIF*) 
            n_lo_level := ilast2;
            IF  a_ap_tree^[ n_lo_level ].n_symb = s_not
            THEN
                a_ap_tree^[ a_ap_tree^[ n_lo_level ].n_sa_level ].
                      n_sa_level := last
            ELSE
                a_ap_tree^[ n_lo_level ].n_sa_level := last;
            (*ENDIF*) 
            ak63change_nodes ( acv, symbol, n_lo_level, last, changed );
            n_sa_level := 0
            END;
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63char_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      hindex : integer;
      curr_n : tsp00_Int2;
      res_kw : boolean;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    sc_symb   := s_func_char;
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        IF  sc_symb = s_comma
        THEN
            BEGIN
            a01_next_symbol (acv);
            a01_get_keyword(acv, hindex, res_kw);
            WITH a_ap_tree^[ put_node ] DO
                CASE hindex OF
                    cak_i_iso      :
                        n_length := ord(dtf_iso);
                    cak_i_usa      :
                        n_length := ord(dtf_usa);
                    cak_i_eur   :
                        n_length := ord(dtf_eur);
                    cak_i_jis      :
                        n_length := ord(dtf_jis);
                    cak_i_internal :
                        n_length := ord(dtf_normal);
                    (* PTS 1112472 E.Z. *)
                    OTHERWISE
                        a07_error (acv, e_wanted_keyword, put_node,
                              last_node)
                    END;
                (*ENDCASE*) 
            (*ENDWITH*) 
            a01_next_symbol (acv)
            END
        ELSE
            BEGIN
            a_date_time_used := true;
            (* because of function CHAR used for datatype fixed *)
            (* in SQLMODE DB2 it must be stored that there was  *)
            (* only one parameter                               *)
            a_ap_tree^[ put_node ].n_length := ord(dtf_none);
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    a01_force_symbol (acv, s_rightpar, put_node, last_node)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63chr_alpha_func_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  index = cak_i_chr
    THEN
        IF  a_sqlmode = sqlm_internal
        THEN
            sc_symb := s_chr
        ELSE
            sc_symb := s_chr_ora
        (*ENDIF*) 
    ELSE
        sc_symb   := s_upper;
    (*ENDIF*) 
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    IF  index = cak_i_alpha
    THEN
        BEGIN
        sc_symb   := s_mapchar;
        a01_function_put (acv, curr_n);
        a_ap_tree^[ last_node ].n_lo_level := curr_n;
        END;
    (*ENDIF*) 
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        IF  (sc_symb = s_comma) AND
            (a_sqlmode <> sqlm_oracle)
        THEN
            BEGIN
            a01_next_symbol (acv);
            IF  sc_symb = s_unsigned_integer
            THEN
                BEGIN
                ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level, curr_n);
                a01_put_node (acv, a_ap_tree^[ curr_n ].n_sa_level);
                a01_next_symbol (acv);
                END
            ELSE
                a07_error (acv, e_missing_keyword, put_node, last_node)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a01_force_symbol (acv, s_rightpar, put_node, last_node)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63nlssort_func_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
      ap_pos  : tsp00_Int4;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    sc_symb   := s_mapchar;
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        IF  (sc_symb = s_comma)
        THEN
            BEGIN
            a01_next_symbol (acv);
            IF  sc_symb = s_string_literal
            THEN
                BEGIN
                s30map (g02codetables.tables[ cgg04_up_ascii ],
                      a_cmd_part^.sp1p_buf, sc_sypos,
                      a_cmd_part^.sp1p_buf, sc_sypos,
                      sc_sylength);
&               ifdef TRACE
                t01moveobj (ak_syn, a_cmd_part^.sp1p_buf,
                      sc_sypos, sc_sypos + sc_sylength);
&               endif
                sc_newpos := sc_sypos;
                ap_pos := sc_sypos + sc_sylength - 1 + a01char_size;
                a_cmd_part^.sp1p_buf[ ap_pos ] := bsp_c1;
                a01_next_symbol (acv);
                IF  a01mandatory_keyword (acv, cak_i_nls_sort)
                THEN
                    a01_force_symbol (acv, s_equal, put_node, last_node);
                (*ENDIF*) 
                IF  a_returncode = 0
                THEN
                    BEGIN
                    IF  (sc_symb = s_identifier)
                    THEN
                        BEGIN
                        ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                              curr_n);
                        a01_put_node (acv,
                              a_ap_tree^[ curr_n ].n_sa_level);
                        a01_next_symbol (acv);
                        a_cmd_part^.sp1p_buf[ ap_pos ] := '''';
                        END
                    ELSE
                        a07_error (acv, e_missing_keyword,
                              put_node, last_node);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                a07_error (acv, e_missing_value_spec, put_node, last_node)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a01_force_symbol (acv, s_rightpar, put_node, last_node)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63mapchar_func_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      length  : boolean;
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    sc_symb   := s_mapchar;
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        IF  (sc_symb = s_comma)
        THEN
            BEGIN
            a01_next_symbol (acv);
            length := sc_symb = s_unsigned_integer;
            IF  length OR  (sc_symb = s_identifier)
            THEN
                BEGIN
                ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                      curr_n);
                a01_put_node (acv, a_ap_tree^[ curr_n ].n_sa_level);
                a01_next_symbol (acv);
                IF  length
                THEN
                    IF  (sc_symb = s_comma)
                    THEN
                        BEGIN
                        curr_n := a_ap_tree^[ curr_n ].n_sa_level;
                        a01_next_symbol (acv);
                        IF  (sc_symb = s_identifier)
                        THEN
                            BEGIN
                            a01_put_node (acv,
                                  a_ap_tree^[ curr_n ].n_sa_level);
                            a01_next_symbol (acv);
                            END
                        ELSE
                            a07_error (acv, e_missing_keyword,
                                  put_node, last_node);
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                a07_error (acv, e_missing_keyword, put_node, last_node)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a01_force_symbol (acv, s_rightpar, put_node, last_node)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1116169 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak63list_type_get (VAR acv : tak_all_command_glob;
            VAR ltype : list_type);
 
VAR
      scvh              : tak_scanner_glob;
      leftparcnt        : integer;
      startleftparcnt   : integer;
 
BEGIN
ltype := lt_unknown;
WITH acv, a_scv DO
    BEGIN
    scvh := a_scv;
    leftparcnt := 0;
    WHILE sc_symb = s_leftpar DO
        BEGIN
        leftparcnt := succ(leftparcnt);
        a01_next_symbol (acv);
        END;
    (*ENDWHILE*) 
    startleftparcnt := leftparcnt;
    IF  a01_eqkey (a01kw[ cak_i_select ], a_sqlmode,
        a_cmd_part^.sp1p_buf, a_scv)
    THEN
        BEGIN
        WHILE ((leftparcnt >= startleftparcnt) AND
              (sc_symb <> s_eof)) DO
            BEGIN
            CASE sc_symb OF
                s_leftpar :
                    leftparcnt := succ(leftparcnt);
                s_rightpar :
                    leftparcnt := pred(leftparcnt);
                OTHERWISE
                    BEGIN
                    END
                END;
            (*ENDCASE*) 
            a01_next_symbol (acv);
            END;
        (*ENDWHILE*) 
        startleftparcnt := pred(startleftparcnt);
        IF  (
            (sc_symb in [ s_plus, s_minus, s_asterisk, s_divide, s_concat ] )
            OR
            ( (sc_symb = s_identifier) AND
            ( (a01_eqkey (a01kw[ cak_i_mod ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)) OR
            (  a01_eqkey (a01kw[ cak_i_div ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv))  )  )
            )
        THEN
            ltype := lt_value_expression
        ELSE
            ltype := lt_subquery;
        (*ENDIF*) 
        END
    ELSE
        ltype := lt_value_expression;
    (*ENDIF*) 
    IF  startleftparcnt > 2
    THEN
        startleftparcnt := 2;
    (*ENDIF*) 
    IF  leftparcnt > 0
    THEN
        WHILE ((leftparcnt >= startleftparcnt) AND
              (sc_symb <> s_eof)) DO
            BEGIN
            CASE sc_symb OF
                s_leftpar :
                    leftparcnt := succ(leftparcnt);
                s_rightpar :
                    leftparcnt := pred(leftparcnt);
                s_comma :
                    IF  leftparcnt = startleftparcnt
                    THEN
                        ltype := lt_one_list;
                    (*ENDIF*) 
                OTHERWISE
                    BEGIN
                    END
                END;
            (*ENDCASE*) 
            a01_next_symbol (acv);
            END;
        (*ENDWHILE*) 
    (*ENDIF*) 
    IF  (ltype = lt_one_list)
        AND
        ((sc_symb = s_comma) OR
        ((sc_symb = s_rightpar) AND (leftparcnt = 1)))
    THEN
        ltype := lt_list_of_lists;
&   ifdef TRACE
    (*ENDIF*) 
    t01int4 (ak_syn, 'ltype       ', ord(ltype));
&   endif
    a_scv := scvh;
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63comp_op_predicate (VAR acv : tak_all_command_glob;
            VAR curr_n : tsp00_Int2;
            predicate  : tsp00_Int2;
            list_cnt   : integer);
 
VAR
      psub_query        : boolean;
      m_rowno_allowed   : boolean;
      all_or_any        : boolean;
      ilast             : tsp00_Int2;
      ltype             : list_type;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  a_returncode = 0
    THEN
        IF  (list_cnt > 1) AND (sc_symb <> s_equal) AND (sc_symb <> s_unequal)
        THEN (* list <equal-or-not> list *)
            a07_error (acv, e_missing_keyword, curr_n, curr_n);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        m_rowno_allowed   := a_rowno_allowed;
        a_rowno_allowed   := false;
        a01_call_put( acv, a64, predicate, ilast);
        a_ap_tree^[ ilast ].n_symb := a_scv.sc_symb;
        a_outer_n := ilast;
&       ifdef TRACE
        t01int4 (ak_syn, 'A_OUTER_Node', a_outer_n);
&       endif
        a01_next_symbol (acv);
        psub_query := false;
        all_or_any := false;
        IF  sc_symb = s_identifier
        THEN
            IF  a01_eqkey (a01kw[ cak_i_all ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                sc_symb    := s_all;
                all_or_any := true;
                psub_query := true
                END
            ELSE
                IF  a01_eqkey (a01kw[ cak_i_any ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    BEGIN
                    sc_symb    := s_any;
                    all_or_any := true;
                    psub_query := true
                    END
                ELSE
                    IF  a01_eqkey (a01kw[ cak_i_some ], a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv)
                    THEN
                        BEGIN
                        sc_symb    := s_any;
                        all_or_any := true;
                        psub_query := true
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  all_or_any
        THEN
            BEGIN
            a01_put_node (acv, a_ap_tree^[ curr_n ].n_sa_level);
            curr_n := a_ap_tree^[ curr_n ].n_sa_level;
            a01_next_symbol (acv)
            END;
        (*ENDIF*) 
        IF  sc_symb = s_leftpar
        THEN
            BEGIN
            IF  (a_sqlmode in [ sqlm_internal, sqlm_oracle ]) AND (list_cnt > 1)
            THEN (* Here is e.g. '(1,2) = ANY ((1,2))' perfectly alright. *)
                psub_query := false;
            (* PTS 1116169 E.Z. *)
            (*ENDIF*) 
            ak63list_type_get (acv, ltype);
            IF  ltype = lt_subquery
            THEN
                BEGIN
                a60_asub_query (acv, a_ap_tree^[ curr_n ].n_sa_level,
                      list_cnt, ((list_cnt = 1) AND (NOT all_or_any)));
                curr_n :=  a_ap_tree^[ curr_n ].n_sa_level;
                END
            ELSE
                IF  psub_query
                THEN
                    IF  (list_cnt = 1) AND
                        (a_sqlmode in [ sqlm_internal, sqlm_oracle ])
                    THEN
                        BEGIN
                        a01_next_symbol (acv); (* skip the leftpar.       *)
                        a03_l_aexpression_list (acv,
                              a_ap_tree^[ curr_n ].n_sa_level, curr_n);
                        a01_force_symbol (acv, s_rightpar, curr_n, curr_n)
                        END
                    ELSE
                        a07_error (acv, e_missing_keyword, ilast, ilast)
                    (*ENDIF*) 
                ELSE
                    BEGIN
                    IF  list_cnt = 1 (* We expect a list only on the right *)
                    THEN             (* when there was one on the left.    *)
                        ak63avalue_expression (acv,
                              a_ap_tree^[ curr_n ].n_sa_level, curr_n)
                    ELSE
                        BEGIN
                        a01_next_symbol (acv); (* skip the leftpar.       *)
                        IF  all_or_any (* the generic case:               *)
                        THEN           (* (a,b) = ANY ((c,d),(e,f)...)    *)
                            ak63a_ll_expr_list_list (acv,
                                  a_ap_tree^[ curr_n ].n_sa_level,
                                  curr_n, list_cnt)
                        ELSE (* For op without ALL just one list allowed. *)
                            ak63a_l_expr_list (acv,
                                  a_ap_tree^[ curr_n ].n_sa_level,
                                  curr_n, list_cnt);
                        (*ENDIF*) 
                        a01_force_symbol (acv, s_rightpar, curr_n, curr_n)
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            IF  psub_query OR (list_cnt > 1)
            THEN
                a07_error (acv, e_missing_keyword, ilast, ilast)
            ELSE
                ak63avalue_expression (acv,
                      a_ap_tree^[ curr_n ].n_sa_level, curr_n);
            (*ENDIF*) 
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            curr_n := ilast;
        (*ENDIF*) 
        a_rowno_allowed := m_rowno_allowed
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63pad_oracle_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
VAR
      curr_n       : tsp00_Int2;
      curr_n1      : tsp00_Int2;
      first_param  : tsp00_Int2;
      second_param : tsp00_Int2;
      third_param  : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    CASE index OF
        cak_i_lpad :
            sc_symb := s_lfill;
        cak_i_rpad :
            sc_symb := s_rfill;
        END;
    (*ENDCASE*) 
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63astring_spec (acv, a_ap_tree^[ curr_n ].n_lo_level, curr_n);
        a01_force_symbol (acv, s_comma, put_node, last_node);
        IF  a_returncode = 0
        THEN
            BEGIN
            first_param := curr_n;
            IF  (sc_symb = s_unsigned_integer) OR
                a01_eqkey (a01kw [ cak_i_null ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                      curr_n);
                a01_put_node (acv, a_ap_tree^[ curr_n ].n_sa_level);
                curr_n := a_ap_tree^[ curr_n ].n_sa_level;
                IF  a01_eqkey (a01kw [ cak_i_null ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    a_ap_tree^[ curr_n ].n_symb := s_null;
                (*ENDIF*) 
                a01_next_symbol (acv);
                IF  sc_symb = s_comma
                THEN
                    BEGIN
                    a01_next_symbol (acv);
                    second_param := curr_n;
                    ak63string_literal_syn (acv, curr_n, put_node,
                          last_node);
                    third_param := curr_n;
                    a_ap_tree^[ first_param ].n_sa_level
                          := third_param;
                    a_ap_tree^[ second_param ].n_sa_level
                          := 0;
                    a_ap_tree^[ third_param ].n_sa_level
                          := second_param;
                    END;
                (*ENDIF*) 
                a01_force_symbol (acv, s_rightpar, put_node, last_node)
                END
            ELSE
                a07_error (acv, e_invalid_unsign_integer,
                      put_node, last_node);
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63hex_digits_hextoraw_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            VAR index     : integer);
 
VAR
      curr_n      : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    CASE index OF
        cak_i_hex, cak_i_rawtohex :
            sc_symb := s_hex;
        cak_i_digits     :
            sc_symb := s_digits;
        cak_i_hextoraw   :
            sc_symb := s_hextoraw;
        END;
    (*ENDCASE*) 
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        a01_force_symbol (acv, s_rightpar, put_node, last_node)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63last_day_syn (  VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      curr_n      : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    sc_symb   := s_last_day;
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := put_node;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        a01_force_symbol (acv, s_rightpar, put_node, last_node)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63updated (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      dummyNode : tsp00_Int2;
 
BEGIN
acv.a_scv.sc_symb := s_updated;
a01_function_put (acv, put_node);
last_node := put_node;
a01_next_symbol (acv);
a01_force_symbol (acv, s_leftpar, put_node, last_node);
IF  acv.a_returncode = 0
THEN
    BEGIN
    a02_acolumnspec (acv, NOT c_table_required, acv.a_ap_tree^[last_node].n_lo_level, dummyNode);
    a01_force_symbol (acv, s_rightpar, put_node, last_node);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63lrpad_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
VAR
      field_found : boolean;
      curr_n      : tsp00_Int2;
      old_n       : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    CASE index OF
        cak_i_lpad :
            sc_symb := s_lpad;
        cak_i_rpad :
            sc_symb := s_rpad;
        cak_i_lfill :
            sc_symb := s_lfill;
        cak_i_rfill :
            sc_symb := s_rfill;
        END;
    (*ENDCASE*) 
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        old_n := curr_n;
        ak63astring_spec (acv, a_ap_tree^[ curr_n ].n_lo_level, curr_n);
        field_found :=
              a_ap_tree^[ a_ap_tree^[ old_n ].n_lo_level ].n_symb
              in [ s_authid, s_tablename, s_columnname ];
        a01_force_symbol (acv, s_comma, put_node, last_node);
        IF  a_returncode = 0
        THEN
            BEGIN
            IF  ((index = cak_i_lpad) OR (index = cak_i_rpad))
            THEN
                BEGIN
                ak63subq_check (acv, a_ap_tree^[ old_n ].n_lo_level, curr_n);
                ak63avalue_expression (acv,
                      a_ap_tree^[ curr_n ].n_sa_level, curr_n);
                a01_force_symbol (acv, s_comma, put_node, last_node)
                END;
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                ak63string_literal_syn (acv, curr_n, put_node,
                      last_node);
                IF  a_returncode = 0
                THEN
                    BEGIN
                    IF  sc_symb = s_rightpar
                    THEN
                        BEGIN
                        IF  NOT field_found
                        THEN
                            a07_error (acv, e_missing_integer,
                                  put_node, last_node)
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        a01_force_symbol (acv, s_comma, put_node, last_node);
                        IF  a_returncode = 0
                        THEN
                            IF  sc_symb <> s_unsigned_integer
                            THEN
                                a07_error (acv, e_missing_integer,
                                      put_node, last_node)
                            ELSE
                                BEGIN
                                a01_put_node (acv,
                                      a_ap_tree^[ curr_n ].n_sa_level);
                                a01_next_symbol (acv)
                                END
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            a01_force_symbol (acv, s_rightpar, put_node, last_node)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63se_and_term ( VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            VAR is_allow  : allow_type;
            list_cnt      : integer;
            predlevel     : integer);
 
VAR
      changed     : boolean;
      curr_n      : tsp00_Int2;
      ilast       : tsp00_Int2;
      ilast1      : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    ak63se_predicate ( acv, put_node, last_node, is_allow,
          list_cnt, predlevel );
    IF  ( a_returncode = 0 ) AND
        a01_eqkey ( a01kw[ cak_i_and ], a_sqlmode,
        a_cmd_part^.sp1p_buf, a_scv )
    THEN
        BEGIN
        a_outer_n := 0;
        sc_symb   := s_and;
        a01_call_put( acv, a64, cak_x_and_operator, curr_n );
        a_ap_tree^[ curr_n ].n_symb := a_scv.sc_symb;
        a_ap_tree^[ curr_n ].n_lo_level := put_node;
        put_node  := curr_n;
        ilast     := last_node;
        last_node := put_node;
        a01_next_symbol ( acv );
        predlevel        := 0;
        ak63se_predicate ( acv, a_ap_tree^[ ilast ].n_sa_level, ilast1,
              is_allow, list_cnt, predlevel);
        changed   := false;
        ak63change_nodes ( acv, s_and, a_ap_tree^[ curr_n ].n_lo_level,
              a_ap_tree^[ ilast ].n_sa_level, changed);
        IF  changed
        THEN
            BEGIN
            ilast := a_ap_tree^[ curr_n ].n_lo_level;
            (* PTS 1123320 E.Z. *)
            WITH a_ap_tree^[ ilast ] DO
                IF  ((n_proc = no_proc) AND (n_symb = s_not))
                THEN
                    ilast := n_sa_level;
                (*ENDIF*) 
            (*ENDWITH*) 
            ilast := a_ap_tree^[ ilast ].n_sa_level;
            ilast := a_ap_tree^[ ilast ].n_lo_level;
            WITH a_ap_tree^[ ilast ] DO
                IF  ((n_proc = no_proc) AND (n_symb = s_not))
                THEN
                    ilast := n_sa_level;
                (*ENDIF*) 
            (*ENDWITH*) 
            WHILE ((a_ap_tree^[ ilast ].n_sa_level <> 0) AND
                  (a_ap_tree^[ a_ap_tree^[ ilast ].n_sa_level ].n_proc
                  = a64) AND
                  (a_ap_tree^[ a_ap_tree^[ ilast ].n_sa_level ].n_subproc
                  = cak_x_and_operator)) DO
                BEGIN
                ilast := a_ap_tree^[ ilast ].n_sa_level;
                ilast := a_ap_tree^[ ilast ].n_lo_level;
                WITH a_ap_tree^[ ilast ] DO
                    IF  ((n_proc = no_proc) AND (n_symb = s_not))
                    THEN
                        ilast := n_sa_level;
                    (*ENDIF*) 
                (*ENDWITH*) 
                ilast1 := a_ap_tree^[ ilast ].n_sa_level;
                WITH a_ap_tree^[ ilast1 ] DO
                    IF  ((n_proc = no_proc) AND (n_symb = s_not))
                    THEN
                        ilast1 := n_sa_level;
                    (*ENDIF*) 
                (*ENDWITH*) 
                END;
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        WHILE ( a_returncode = 0 ) AND
              a01_eqkey ( a01kw[ cak_i_and ], a_sqlmode,
              a_cmd_part^.sp1p_buf, a_scv ) DO
            BEGIN
            a_outer_n := 0;
            sc_symb   := s_and;
            a01_call_put ( acv, a64, cak_x_and_operator, curr_n );
            a_ap_tree^[ curr_n ].n_symb := a_scv.sc_symb;
            a_ap_tree^[ curr_n ].n_lo_level :=
                  a_ap_tree^[ ilast ].n_sa_level;
            a_ap_tree^[ ilast ].n_sa_level  := curr_n;
            ilast                          := ilast1;
            a01_next_symbol ( acv );
            predlevel        := 0;
            ak63se_predicate ( acv, a_ap_tree^[ ilast ].n_sa_level,
                  ilast1, is_allow, list_cnt, predlevel);
            changed := false;
            ak63change_nodes ( acv, s_and,
                  a_ap_tree^[ curr_n ].n_lo_level,
                  a_ap_tree^[ ilast ].n_sa_level, changed );
            IF  changed
            THEN
                BEGIN
                ilast := a_ap_tree^[ curr_n ].n_lo_level;
                (* PTS 1123320 E.Z. *)
                WITH a_ap_tree^[ ilast ] DO
                    IF  ((n_proc = no_proc) AND (n_symb = s_not))
                    THEN
                        ilast := n_sa_level;
                    (*ENDIF*) 
                (*ENDWITH*) 
                ilast := a_ap_tree^[ ilast ].n_sa_level;
                ilast := a_ap_tree^[ ilast ].n_lo_level;
                WITH a_ap_tree^[ ilast ] DO
                    IF  ((n_proc = no_proc) AND (n_symb = s_not))
                    THEN
                        ilast := n_sa_level;
                    (*ENDIF*) 
                (*ENDWITH*) 
                WHILE ((a_ap_tree^[ ilast ].n_sa_level <> 0) AND
                      (a_ap_tree^[ a_ap_tree^[ ilast ].n_sa_level ].n_proc
                      = a64) AND
                      (a_ap_tree^[ a_ap_tree^[ ilast ].n_sa_level ].n_subproc
                      = cak_x_and_operator)) DO
                    BEGIN
                    ilast := a_ap_tree^[ ilast ].n_sa_level;
                    ilast := a_ap_tree^[ ilast ].n_lo_level;
                    WITH a_ap_tree^[ ilast ] DO
                        IF  ((n_proc = no_proc) AND (n_symb = s_not))
                        THEN
                            ilast := n_sa_level;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    ilast1 := a_ap_tree^[ ilast ].n_sa_level;
                    WITH a_ap_tree^[ ilast1 ] DO
                        IF  ((n_proc = no_proc) AND (n_symb = s_not))
                        THEN
                            ilast1 := n_sa_level;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    END;
                (*ENDWHILE*) 
                END
            (*ENDIF*) 
            END
        (*ENDWHILE*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63se_or_term ( VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2 ;
            VAR is_allow  : allow_type;
            list_cnt      : integer;
            predlevel     : integer);
 
VAR
      changed         : boolean;
      m_rowno_allowed : boolean;
      m_rowno_found   : boolean;
      curr_n          : tsp00_Int2;
      ilast           : tsp00_Int2;
      ilast1          : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    m_rowno_found := a_rowno_found;
    ak63se_and_term ( acv, put_node, last_node,is_allow,
          list_cnt, predlevel);
    IF  ( a_returncode = 0 )  AND
        a01_eqkey ( a01kw[ cak_i_or ], a_sqlmode,
        a_cmd_part^.sp1p_buf, a_scv )
    THEN
        IF  ( NOT m_rowno_found AND a_rowno_found )
        THEN
            a07_error ( acv, e_rowno_not_allowed, put_node, last_node )
        ELSE
            BEGIN
            a_outer_n := 0;
            m_rowno_allowed := a_rowno_allowed;
            a_rowno_allowed := false;
            sc_symb         := s_or;
            a01_call_put( acv, a64, cak_x_or_operator, curr_n );
            a_ap_tree^[ curr_n ].n_symb := a_scv.sc_symb;
            a_ap_tree^[ curr_n ].n_lo_level := put_node;
            put_node        := curr_n;
            ilast           := last_node;
            last_node       := put_node;
            a01_next_symbol ( acv );
            predlevel        := 0;
            ak63se_and_term ( acv, a_ap_tree^[ ilast ].n_sa_level,
                  ilast1, is_allow, list_cnt, predlevel);
            changed         := false;
            ak63change_nodes ( acv, s_or,
                  a_ap_tree^[ curr_n ].n_lo_level,
                  a_ap_tree^[ ilast ].n_sa_level, changed);
            IF  changed
            THEN
                BEGIN
                ilast := a_ap_tree^[ curr_n ].n_lo_level;
                (* PTS 1123320 E.Z. *)
                WITH a_ap_tree^[ ilast ] DO
                    IF  ((n_proc = no_proc) AND (n_symb = s_not))
                    THEN
                        ilast := n_sa_level;
                    (*ENDIF*) 
                (*ENDWITH*) 
                ilast := a_ap_tree^[ ilast ].n_sa_level;
                ilast := a_ap_tree^[ ilast ].n_lo_level;
                WITH a_ap_tree^[ ilast ] DO
                    IF  ((n_proc = no_proc) AND (n_symb = s_not))
                    THEN
                        ilast := n_sa_level;
                    (*ENDIF*) 
                (*ENDWITH*) 
                WHILE ((a_ap_tree^[ ilast ].n_sa_level <> 0) AND
                      (a_ap_tree^[ a_ap_tree^[ ilast ].n_sa_level ].n_proc
                      = a64) AND
                      (a_ap_tree^[ a_ap_tree^[ ilast ].n_sa_level ].n_subproc
                      = cak_x_or_operator)) DO
                    BEGIN
                    ilast := a_ap_tree^[ ilast ].n_sa_level;
                    ilast := a_ap_tree^[ ilast ].n_lo_level;
                    WITH a_ap_tree^[ ilast ] DO
                        IF  ((n_proc = no_proc) AND (n_symb = s_not))
                        THEN
                            ilast := n_sa_level;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    ilast1 := a_ap_tree^[ ilast ].n_sa_level;
                    WITH a_ap_tree^[ ilast1 ] DO
                        IF  ((n_proc = no_proc) AND (n_symb = s_not))
                        THEN
                            ilast1 := n_sa_level;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    END;
                (*ENDWHILE*) 
                END;
            (*ENDIF*) 
            a_rowno_allowed := m_rowno_allowed;
            WHILE  ( a_returncode = 0 ) AND
                  a01_eqkey ( a01kw[ cak_i_or ], a_sqlmode,
                  a_cmd_part^.sp1p_buf, a_scv )  DO
                BEGIN
                a_outer_n := 0;
                m_rowno_allowed := a_rowno_allowed;
                a_rowno_allowed := false;
                sc_symb         := s_or;
                a01_call_put ( acv, a64, cak_x_or_operator, curr_n);
                a_ap_tree^[ curr_n ].n_symb := a_scv.sc_symb;
                a_ap_tree^[ curr_n ].n_lo_level :=
                      a_ap_tree^[ ilast ].n_sa_level;
                a_ap_tree^[ ilast ].n_sa_level  := curr_n;
                ilast                          := ilast1;
                a01_next_symbol ( acv );
                predlevel        := 0;
                ak63se_and_term ( acv, a_ap_tree^[ ilast ].n_sa_level,
                      ilast1, is_allow, list_cnt, predlevel);
                changed := false;
                ak63change_nodes ( acv, s_or,
                      a_ap_tree^[ curr_n ].n_lo_level,
                      a_ap_tree^[ ilast ].n_sa_level, changed);
                IF  changed
                THEN
                    BEGIN
                    ilast := a_ap_tree^[ curr_n ].n_lo_level;
                    (* PTS 1123320 E.Z. *)
                    WITH a_ap_tree^[ ilast ] DO
                        IF  ((n_proc = no_proc) AND (n_symb = s_not))
                        THEN
                            ilast := n_sa_level;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    ilast := a_ap_tree^[ ilast ].n_sa_level;
                    ilast := a_ap_tree^[ ilast ].n_lo_level;
                    WITH a_ap_tree^[ ilast ] DO
                        IF  ((n_proc = no_proc) AND (n_symb = s_not))
                        THEN
                            ilast := n_sa_level;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    WHILE ((a_ap_tree^[ ilast ].n_sa_level <> 0) AND
                          (a_ap_tree^[ a_ap_tree^[ ilast ].n_sa_level ].n_proc
                          = a64) AND
                          (a_ap_tree^[ a_ap_tree^[ ilast ].n_sa_level ].n_subproc
                          = cak_x_or_operator)) DO
                        BEGIN
                        ilast := a_ap_tree^[ ilast ].n_sa_level;
                        ilast := a_ap_tree^[ ilast ].n_lo_level;
                        WITH a_ap_tree^[ ilast ] DO
                            IF  ((n_proc = no_proc) AND (n_symb = s_not))
                            THEN
                                ilast := n_sa_level;
                            (*ENDIF*) 
                        (*ENDWITH*) 
                        ilast1 := a_ap_tree^[ ilast ].n_sa_level;
                        WITH a_ap_tree^[ ilast1 ] DO
                            IF  ((n_proc = no_proc) AND (n_symb = s_not))
                            THEN
                                ilast1 := n_sa_level;
                            (*ENDIF*) 
                        (*ENDWITH*) 
                        END;
                    (*ENDWHILE*) 
                    END;
                (*ENDIF*) 
                a_rowno_allowed := m_rowno_allowed
                END
            (*ENDWHILE*) 
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63se_predicate ( VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            VAR is_allow  : allow_type;
            list_cnt      : integer;
            VAR predlevel : integer );
 
VAR
      pnot            : boolean;
      m_rowno_allowed : boolean;
      m_rowno_found   : boolean;
      include_not     : boolean;
      parcount        : integer;
      curr_n          : tsp00_Int2;
      curr_n1         : tsp00_Int2;
      curr1_n         : tsp00_Int2;
      ilast           : tsp00_Int2;
      predicate       : tsp00_Int2;
      m_symb          : tak_sc_symbol;
      scvh            : tak_scanner_glob;
      kw_index        : integer;
      res             : boolean;
      savelevel       : integer;
 
BEGIN
&ifdef TRACE
t01int4 (ak_syn, 'pred: allow ', ord (is_allow));
&endif
WITH acv, a_scv  DO
    IF  a_returncode = 0
    THEN
        BEGIN
        predlevel := predlevel + 1;
        curr1_n          := 0;
        m_rowno_allowed  := a_rowno_allowed;
        m_rowno_found    := a_rowno_found;
        (* PTS 1116169 E.Z. *)
        IF  (is_allow = a_value) AND
            a01_eqkey (a01kw[ cak_i_not ], a_sqlmode, a_cmd_part^.sp1p_buf, a_scv)
        THEN
            BEGIN
            a_rowno_allowed := false;
            a01_next_symbol (acv);
            include_not := true
            END
        ELSE
            include_not := false;
        (*ENDIF*) 
        scvh := a_scv;
        IF  sc_symb = s_leftpar
        THEN
            BEGIN
            a01_next_symbol (acv);
            (* PTS 1116169 E.Z. *)
            IF  ((a01_eqkey (a01kw[ cak_i_select ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)) AND
                a_oneval_subq_allowed)
            THEN
                BEGIN
                a_scv := scvh;
                a60_asub_query (acv, put_node,
                      1,  c_one_valsubquery);
                last_node := put_node;
                list_cnt := 1;
                is_allow := a_predicate
                END
            ELSE
                BEGIN
                ak63se_or_term  (acv, put_node, last_node, is_allow,
                      list_cnt, predlevel);
                IF  (sc_symb = s_comma) AND (is_allow = a_predicate)
                    AND ((a_sqlmode = sqlm_oracle) OR (a_sqlmode = sqlm_internal))
                THEN
                    BEGIN
                    ilast := put_node;
                    a01_call_put (acv, a56, cak_x_value_list, put_node);
                    a01_call_put (acv, a64, cak_x_value_expression,
                          a_ap_tree^[ put_node ].n_lo_level);
                    curr_n := a_ap_tree^[ put_node ].n_lo_level;
                    a_ap_tree^[ curr_n ].n_lo_level := ilast;
                    last_node := put_node;
                    WHILE (sc_symb = s_comma) DO
                        BEGIN
                        is_allow := a_value;
                        list_cnt := succ (list_cnt);
                        a01_next_symbol (acv);
                        a01_call_put (acv, a64, cak_x_value_expression,
                              a_ap_tree^[ curr_n ].n_sa_level);
                        curr_n := a_ap_tree^[ curr_n ].n_sa_level;
                        a_col_func_count := 0;
                        ak63avalue_expression (acv,
                              a_ap_tree^[ curr_n ].n_lo_level, ilast)
                        END;
                    (*ENDWHILE*) 
                    a_ap_tree^[ put_node ].n_length := list_cnt;
                    is_allow := a_predicate
                    END;
                (*ENDIF*) 
                a01_force_symbol (acv, s_rightpar, put_node, last_node)
                END
            (*ENDIF*) 
            END
        ELSE
            IF  is_allow = a_value
            THEN
                BEGIN
                IF  a01_eqkey( a01kw[ cak_i_exists ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv )
                THEN
                    BEGIN
                    sc_symb := s_exists;
                    a01_call_put (acv, a64, cak_x_predicate, put_node);
                    a_ap_tree^[ put_node ].n_symb := a_scv.sc_symb;
                    a01_next_symbol (acv);
                    a60_asub_query (acv,
                          a_ap_tree^[ put_node ].n_lo_level, 1,
                          NOT c_one_valsubquery);
                    last_node := put_node
                    END
                ELSE
                    BEGIN
                    a_col_func_count := 0;
                    list_cnt         := 1;
                    ak63avalue_expression (acv, put_node, last_node);
                    is_allow := a_predicate
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  ((is_allow = a_predicate) AND (a_returncode = 0))
        THEN
            BEGIN
            IF  list_cnt = 1 (* there was no expression list yet detected, *)
            THEN             (* so there can come more terms or factors.   *)
                BEGIN
                ak63arest_factor (acv, put_node, last_node);
                ak63subq_check (acv, put_node, last_node);
                WHILE ( sc_symb in [ s_plus, s_minus ] ) AND
                      ( a_returncode = 0 ) DO
                    BEGIN
                    a01_call_put (acv, a64, cak_x_add_operator, curr_n);
                    a_ap_tree^[ curr_n ].n_symb     := a_scv.sc_symb;
                    a_ap_tree^[ curr_n ].n_lo_level := put_node;
                    put_node                        := curr_n;
                    curr_n                          := last_node;
                    last_node                       := put_node;
                    curr_n1                         := curr_n;
                    a01_next_symbol (acv);
                    ak63aterm (acv, a_ap_tree^[ curr_n ].n_sa_level,
                          curr_n, c_duration_allowed);
                    ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_sa_level,
                          curr_n);
                    END
                (*ENDWHILE*) 
                END;
&           ifdef TRACE
            (*ENDIF*) 
            t01int4 (ak_syn, 'predlevel   ', predlevel);
&           endif
            IF  (a_returncode = 0) AND
                ((sc_symb <> s_comma) OR (predlevel = 1)) AND
                ((sc_symb <> s_rightpar) OR (predlevel = 1))
            THEN
                BEGIN
                curr_n := last_node;
                IF  ((NOT m_rowno_found) AND a_rowno_found)
                    (* rowno was in factor *)
                THEN
                    BEGIN
                    IF  a_ap_tree^[ curr_n ].n_symb <> s_rowno
                    THEN
                        a07_error (acv, e_rowno_not_allowed,
                              put_node, last_node)
                    ELSE
                        IF  sc_symb in [ s_less, s_less_or_eq ]
                        THEN
                            BEGIN
                            a01_call_put(acv, a64, cak_x_predicate, ilast );
                            a_ap_tree^[ ilast ].n_symb := a_scv.sc_symb;
                            a01_next_symbol (acv);
                            parcount := 0;
                            WHILE sc_symb = s_leftpar DO
                                BEGIN
                                parcount := succ(parcount);
                                a01_next_symbol(acv)
                                END;
                            (*ENDWHILE*) 
                            IF  sc_symb in [ s_parameter_name,
                                s_unsigned_integer ]
                            THEN
                                ak63afactor (acv,
                                      a_ap_tree^[curr_n].n_sa_level,
                                      curr_n)
                            ELSE
                                a07_error (acv,
                                      e_invalid_unsign_integer,
                                      put_node, last_node);
                            (*ENDIF*) 
                            curr_n := ilast;
                            IF  parcount > 0
                            THEN
                                BEGIN
                                WHILE ((parcount > 0) AND
                                      (sc_symb = s_rightpar)) DO
                                    BEGIN
                                    parcount := pred(parcount);
                                    a01_next_symbol (acv)
                                    END;
                                (*ENDWHILE*) 
                                IF  parcount > 0
                                THEN
                                    a07_error (acv, e_missing_keyword,
                                          put_node, last_node)
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END
                        ELSE
                            a07_error (acv, e_rowno_not_allowed,
                                  put_node, last_node );
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    IF  (sc_symb = s_outer_join)
                    THEN
                        IF  ((a_sqlmode = sqlm_internal) OR
                            ( a_sqlmode = sqlm_oracle)   )
                        THEN
                            BEGIN
                            a_outer_join := true;
                            predicate    := cak_x_left_outer_join;
                            a01_next_symbol (acv);
                            END
                        ELSE
                            a07_error (acv, e_missing_keyword,
                                  put_node, last_node)
                        (*ENDIF*) 
                    ELSE
                        predicate := cak_x_predicate;
                    (*ENDIF*) 
                    IF  sc_symb in [ s_equal, s_greater, s_greater_or_eq,
                        s_less, s_less_or_eq, s_unequal ]
                    THEN
                        ak63comp_op_predicate (acv, curr_n, predicate, list_cnt)
                    ELSE
                        BEGIN (* PTS 1113327 *)
                        IF  a01_eqkey ( a01kw[ cak_i_is ], a_sqlmode,
                            a_cmd_part^.sp1p_buf, a_scv )
                        THEN
                            BEGIN
                            pnot := false;
                            a01_next_symbol (acv);
                            IF  a01_eqkey (a01kw[ cak_i_not ], a_sqlmode,
                                a_cmd_part^.sp1p_buf, a_scv)
                            THEN
                                BEGIN
                                pnot := true;
                                a01_next_symbol (acv)
                                END;
                            (*ENDIF*) 
                            a01_get_keyword (acv, kw_index, res);
                            CASE  kw_index OF
                                cak_i_null :
                                    BEGIN
                                    IF  pnot
                                    THEN
                                        sc_symb := s_is_not_null
                                    ELSE
                                        sc_symb := s_is_null;
                                    (*ENDIF*) 
                                    a01_call_put(acv, a64,
                                          predicate, ilast); (* PTS 1113327 *)
                                    a_ap_tree^[ ilast ].n_symb := a_scv.sc_symb;
                                    sc_symb := s_null;
                                    a01_put_node (acv,
                                          a_ap_tree^[ curr_n ].n_sa_level);
                                    curr_n := ilast;
                                    a01_next_symbol (acv);
                                    END;
                                cak_i_true :
                                    BEGIN
                                    IF  pnot
                                    THEN
                                        sc_symb := s_is_false
                                    ELSE
                                        sc_symb := s_is_true;
                                    (*ENDIF*) 
                                    a01_call_put(acv, a64,
                                          predicate, ilast); (* PTS 1113327 *)
                                    a_ap_tree^[ ilast ].n_symb := a_scv.sc_symb;
                                    IF  pnot
                                    THEN
                                        sc_symb := s_false
                                    ELSE
                                        sc_symb := s_true;
                                    (*ENDIF*) 
                                    a01_put_node (acv,
                                          a_ap_tree^[ curr_n ].n_sa_level);
                                    curr_n := ilast;
                                    a01_next_symbol (acv);
                                    END;
                                cak_i_false :
                                    BEGIN
                                    IF  pnot
                                    THEN
                                        sc_symb := s_is_true
                                    ELSE
                                        sc_symb := s_is_false;
                                    (*ENDIF*) 
                                    a01_call_put(acv, a64,
                                          predicate, ilast); (* PTS 1113327 *)
                                    a_ap_tree^[ ilast ].n_symb := a_scv.sc_symb;
                                    IF  pnot
                                    THEN
                                        sc_symb := s_true
                                    ELSE
                                        sc_symb := s_false;
                                    (*ENDIF*) 
                                    a01_put_node (acv,
                                          a_ap_tree^[ curr_n ].n_sa_level);
                                    curr_n := ilast;
                                    a01_next_symbol (acv);
                                    END;
                                OTHERWISE :
                                    a07_error (acv, e_wanted_keyword,
                                          put_node, last_node);
                                END;
                            (*ENDCASE*) 
                            END
                        ELSE
                            BEGIN
                            ak63adiff_predicates (acv, put_node,
                                  curr_n, curr1_n, list_cnt)
                            END
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  curr1_n = 0
                THEN
                    curr1_n := curr_n;
                (*ENDIF*) 
                IF  (a_ap_tree^[put_node].n_proc = no_proc)
                    AND (a_ap_tree^[put_node].n_symb = s_not)
                THEN
                    BEGIN
                    a_ap_tree^[curr1_n ].n_lo_level := a_ap_tree^[put_node].n_sa_level;
                    a_ap_tree^[put_node].n_sa_level := curr_n;
                    last_node := curr_n;
                    END
                ELSE
                    BEGIN
                    a_ap_tree^[ curr1_n ].n_lo_level := put_node;
                    put_node  := curr_n;
                    last_node := curr_n;
                    END;
                (*ENDIF*) 
                is_allow  := a_value
                END
            ELSE
                IF  (a_returncode = 0) AND
                    (list_cnt > 1)    AND  (* if an expression list was *)
                    (sc_symb = s_rightpar) (* given, the operation must *)
                THEN                       (* be on the same level.     *)
                    a07_error (acv, e_missing_keyword,
                          put_node, last_node)
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (a_returncode = 0) AND include_not
        THEN
            IF  ((a_ap_tree^[put_node].n_proc = no_proc) AND
                (a_ap_tree^[put_node].n_symb = s_not))
            THEN
                put_node := a_ap_tree^[ put_node ].n_sa_level
            ELSE
                BEGIN
                m_symb := sc_symb;
                sc_symb := s_not;
                a01_put_node (acv, curr_n);
                sc_symb := m_symb;
                a_ap_tree^[ curr_n ].n_sa_level := put_node;
                put_node  := curr_n;
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  (sc_symb     = s_outer_join) AND
            (a_outer_n   > 0)            AND
            (a_returncode = 0)
        THEN
            IF  ((a_sqlmode = sqlm_internal) OR
                ( a_sqlmode = sqlm_oracle)   )
            THEN
                BEGIN
                IF  (a_ap_tree^[ a_outer_n ].n_subproc = cak_x_left_outer_join)
                THEN
                    a_ap_tree^[ a_outer_n ].n_subproc :=
                          cak_x_full_outer_join
                ELSE
                    a_ap_tree^[ a_outer_n ].n_subproc :=
                          cak_x_right_outer_join;
                (*ENDIF*) 
                a_outer_join := a_returncode = 0;
                a_outer_n    := 0;
                a01_next_symbol (acv);
                END
            ELSE
                a07_error (acv, e_missing_keyword,
                      put_node, last_node);
            (*ENDIF*) 
        (*ENDIF*) 
        predlevel := predlevel - 1;
        a_rowno_allowed := m_rowno_allowed
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63num_to_number_func_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
VAR
      curr_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  (index = cak_i_num)
    THEN
        sc_symb := s_num
    ELSE
        sc_symb := s_to_number;
    (*ENDIF*) 
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  (index = cak_i_num)
        THEN
            ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
                  curr_n)
        ELSE
            ak63astring_spec (acv, a_ap_tree^[ curr_n ].n_lo_level, curr_n);
        (*ENDIF*) 
        a01_force_symbol (acv, s_rightpar, put_node, last_node)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63one_string_spec_param_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
VAR
      curr_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    CASE index OF
        cak_i_upper, cak_i_ucase :
            sc_symb := s_upper;
        cak_i_lower, cak_i_lcase :
            sc_symb := s_lower;
        cak_i_ascii  :
            sc_symb := s_ascii;
        (* PTS 1122828 E.Z. *)
        cak_i_soundex :
            sc_symb := s_soundex;
        cak_i_initcap :
            sc_symb := s_initcap;
        cak_i_toidentifier :
            sc_symb := s_toidentifier;
        cak_i_unicode :
            sc_symb := s_unicode;
        END;
    (*ENDCASE*) 
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        ak63astring_spec (acv, a_ap_tree^[ curr_n ].n_lo_level, curr_n);
        a01_force_symbol (acv, s_rightpar, put_node, last_node)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63string_literal_syn (VAR acv : tak_all_command_glob;
            VAR curr_n     : tsp00_Int2;
            VAR put_node   : tsp00_Int2;
            VAR last_node  : tsp00_Int2);
 
BEGIN
WITH acv, a_scv DO
    IF  (sc_symb = s_string_literal) OR (sc_symb = s_byte_string)
    THEN
        BEGIN
        a01_put_node (acv, a_ap_tree^[ curr_n ].n_sa_level);
        curr_n := a_ap_tree^[ curr_n ].n_sa_level;
        a01_next_symbol (acv);
        END
    ELSE
        IF  a01_eqkey (a01kw [ cak_i_null ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)
        THEN
            BEGIN
            a01_put_node (acv, a_ap_tree^[ curr_n ].n_sa_level);
            curr_n := a_ap_tree^[ curr_n ].n_sa_level;
            a_ap_tree^[ curr_n ].n_symb := s_null;
            a01_next_symbol (acv);
            END
        ELSE
            a07_error (acv, e_missing_string_literal,
                  put_node, last_node);
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63_timestamp_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    sc_symb   := s_func_timestamp;
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        IF  sc_symb = s_comma
        THEN
            BEGIN
            a01_next_symbol (acv);
            ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                  curr_n);
            ak63avalue_expression (acv,
                  a_ap_tree^[ curr_n ].n_sa_level, curr_n)
            END;
        (*ENDIF*) 
        a01_force_symbol (acv, s_rightpar, put_node, last_node)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63to_char_date_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
VAR
      curr_n        : tsp00_Int2;
      curr_n1       : tsp00_Int2;
      i             : integer;
      s32           : tsp00_C32;
      lcomp_result  : tsp00_LcompResult;
      simple_format : boolean;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    CASE index OF
        cak_i_to_char :
            sc_symb := s_to_char;
        cak_i_to_date :
            sc_symb := s_to_date;
        END;
    (*ENDCASE*) 
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        IF  sc_symb = s_comma
        THEN
            BEGIN
            a01_next_symbol (acv);
            IF  (index = cak_i_to_char) AND (sc_symb = s_string_literal)
            THEN
                BEGIN
                s32 := 'YYYYMMDDHH24MISS                ';
                IF  g01unicode
                THEN
                    FOR i := 16 DOWNTO 1 DO
                        BEGIN
                        s32 [ 2*i   ] := s32[ i ];
                        s32 [ 2*i-1 ] := csp_unicode_mark;
                        s30cmp (a_cmd_part^.sp1p_buf, sc_sypos, sc_sylength,
                              s32, 1, 32, lcomp_result);
                        END
                    (*ENDFOR*) 
                ELSE
                    s30cmp (a_cmd_part^.sp1p_buf, sc_sypos, sc_sylength,
                          s32, 1, 16, lcomp_result);
                (*ENDIF*) 
                simple_format := lcomp_result = l_equal
                END
            ELSE
                simple_format := false;
            (*ENDIF*) 
            IF  simple_format
            THEN
                BEGIN
                a01_next_symbol (acv);
                a_ap_tree^[ put_node ].n_symb := s_to_24_char
                END
            ELSE
                BEGIN
                ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                      curr_n);
                ak63avalue_expression (acv,
                      a_ap_tree^[ curr_n ].n_sa_level, curr_n);
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a01_force_symbol (acv, s_rightpar, put_node, last_node)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63trim_parameter_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    CASE index OF
        cak_i_trim :
            sc_symb := s_trim;
        cak_i_ltrim :
            sc_symb := s_ltrim;
        cak_i_rtrim :
            sc_symb := s_rtrim;
        END;
    (*ENDCASE*) 
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        IF  (sc_symb = s_comma)
        THEN
            BEGIN
            a01_next_symbol (acv);
            ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                  curr_n);
            ak63avalue_expression
                  (acv, a_ap_tree^[ curr_n ].n_sa_level, curr_n);
            END;
        (*ENDIF*) 
        a01_force_symbol (acv, s_rightpar, put_node, last_node)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63trunc_round_parameter_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  (index = cak_i_trunc) OR (index = cak_i_truncate)
    THEN
        sc_symb := s_trunc
    ELSE
        sc_symb := s_round;
    (*ENDIF*) 
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        IF  sc_symb = s_comma
        THEN
            BEGIN
            a01_next_symbol (acv);
            ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                  curr_n);
            ak63avalue_expression (acv,
                  a_ap_tree^[ curr_n ].n_sa_level, curr_n);
            END;
        (*ENDIF*) 
        a01_force_symbol (acv, s_rightpar, put_node, last_node)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63_makedate_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    sc_symb   := s_makedate;
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := put_node;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        a01_force_symbol (acv, s_comma, put_node, last_node);
        IF  a_returncode = 0
        THEN
            BEGIN
            ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                  curr_n);
            ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_sa_level,
                  curr_n);
            a01_force_symbol (acv, s_rightpar, put_node, last_node)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63maketime_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    sc_symb   := s_maketime;
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := put_node;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        a01_force_symbol (acv, s_comma, put_node, last_node);
        IF  a_returncode = 0
        THEN
            BEGIN
            ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                  curr_n);
            curr_n1 := curr_n;
            ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_sa_level,
                  curr_n);
            a01_force_symbol (acv, s_comma, put_node, last_node);
            IF  a_returncode = 0
            THEN
                BEGIN
                ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_sa_level,
                      curr_n);
                ak63avalue_expression (acv,
                      a_ap_tree^[ curr_n ].n_sa_level, curr_n);
                a01_force_symbol (acv, s_rightpar, put_node, last_node)
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63months_between_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    sc_symb   := s_months_between;
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := put_node;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        a01_force_symbol (acv, s_comma, put_node, last_node);
        IF  a_returncode = 0
        THEN
            BEGIN
            ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                  curr_n);
            ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_sa_level,
                  curr_n);
            a01_force_symbol (acv, s_rightpar, put_node, last_node)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1111577 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak63get_name (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            kw_index      : integer);
 
VAR
      res_kw    : boolean;
      index     : integer;
      curr_n    : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  kw_index = cak_i_get_schema
    THEN
        sc_symb := s_get_schema
    ELSE
        sc_symb := s_get_name;
    (*ENDIF*) 
    a01_function_put (acv, put_node);
    last_node := put_node;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  sc_symb in [ s_parameter_name, s_string_literal ]
        THEN
            BEGIN
            ak63afactor (acv, a_ap_tree^[put_node].n_lo_level, curr_n);
            a01_force_symbol (acv, s_comma, put_node, last_node);
            IF  a_returncode = 0
            THEN
                BEGIN
                a01_get_keyword (acv, index, res_kw);
                CASE index OF
                    cak_i_dbproc, cak_i_dbprocedure :
                        a_ap_tree^[put_node].n_subproc := ord(cak_cprivproc);
                    cak_i_domain :
                        a_ap_tree^[put_node].n_subproc := ord(cak_cdomain);
                    cak_i_sequence :
                        a_ap_tree^[put_node].n_subproc := ord(cak_csequence);
                    cak_i_synonym :
                        a_ap_tree^[put_node].n_subproc := ord(cak_cusage);
                    cak_i_view :
                        a_ap_tree^[put_node].n_subproc := ord(cak_cviewdesc);
                    cak_i_table :
                        a_ap_tree^[put_node].n_subproc := ord(cak_ctable);
                    cak_i_index, cak_i_trigger :
                        BEGIN
                        (* indices and trigger do not live without a table *)
                        (* more than one object may have the same name     *)
                        (* therefore we do not see a good chance to return *)
                        (* THE ONE schema, the object belongs to           *)
                        a07_error (acv, e_missing_keyword, put_node, put_node)
                        END;
                    OTHERWISE
                        a07_error (acv, e_missing_keyword, put_node, put_node)
                    END;
                (*ENDCASE*) 
                END
            (*ENDIF*) 
            END
        ELSE
            a07_error (acv, e_missing_string_literal, put_node, last_node);
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            a01_next_symbol (acv);
            a01_force_symbol (acv, s_rightpar, put_node, last_node)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63one_value_expr_param_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    CASE index OF
        cak_i_abs :
            sc_symb := s_abs;
        cak_i_acos :
            sc_symb := s_acos;
        cak_i_asin :
            sc_symb := s_asin;
        cak_i_ascii :
            sc_symb := s_ascii;
        cak_i_atan :
            sc_symb := s_atan;
        cak_i_ceil, cak_i_ceiling :
            sc_symb := s_ceil;
        cak_i_cos :
            sc_symb := s_cos;
        cak_i_cosh :
            sc_symb := s_cosh;
        cak_i_cot :
            sc_symb := s_cot;
        cak_i_dayname :
            sc_symb := s_dayname;
        cak_i_dayofmonth :
            sc_symb := s_dayofmonth;
        cak_i_dayofweek :
            sc_symb := s_dayofweek;
        cak_i_dayofyear :
            sc_symb := s_dayofyear;
        cak_i_degrees :
            sc_symb := s_degrees;
        cak_i_floor :
            sc_symb := s_floor;
        cak_i_exp :
            sc_symb := s_exp;
        cak_i_ln :
            sc_symb := s_ln;
        cak_i_log10 :
            sc_symb := s_log10;
        cak_i_length :
            sc_symb := s_length;
        cak_i_monthname :
            sc_symb := s_monthname;
        cak_i_noround :
            sc_symb := s_noround;
        cak_i_radians :
            sc_symb := s_radians;
        cak_i_sign :
            sc_symb := s_sign;
        cak_i_sin :
            sc_symb := s_sin;
        cak_i_sinh :
            sc_symb := s_sinh;
        cak_i_sqrt :
            sc_symb := s_sqrt;
        cak_i_tan :
            sc_symb := s_tan;
        cak_i_tanh :
            sc_symb := s_tanh;
        cak_i_vsize :
            sc_symb := s_vsize;
        cak_i_week,
        cak_i_weekofyear       :
            sc_symb := s_weekofyear
        END;
    (*ENDCASE*) 
    ak63value_expression_syn ( acv, put_node, last_node);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63value_expression_syn
            (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      curr_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        a01_force_symbol (acv, s_rightpar, put_node, last_node)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63two_value_expr_para_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    CASE index OF
        (*   arithmetic functions   *)
        cak_i_log :
            sc_symb := s_log;
        cak_i_mod :
            sc_symb := s_mod_func;
        cak_i_power :
            sc_symb := s_power;
        cak_i_float :
            sc_symb := s_float;
        (*   date-time functions    *)
        cak_i_adddate :
            sc_symb := s_adddate;
        cak_i_addtime :
            sc_symb := s_addtime;
        cak_i_datediff :
            sc_symb := s_datediff;
        cak_i_next_day :
            sc_symb := s_next_day;
        cak_i_subdate :
            sc_symb := s_subdate;
        cak_i_subtime :
            sc_symb := s_subtime;
        cak_i_timediff :
            sc_symb := s_timediff;
        cak_i_atan2 :
            sc_symb := s_atan2;
        END;
    (*ENDCASE*) 
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := put_node;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        a01_force_symbol (acv, s_comma, put_node, last_node);
        IF  a_returncode = 0
        THEN
            BEGIN
            ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                  curr_n);
            ak63avalue_expression
                  (acv, a_ap_tree^[ curr_n ].n_sa_level, curr_n);
            a01_force_symbol (acv, s_rightpar, put_node, last_node)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63three_value_expr_para_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    CASE index OF
        (*   date-time functions    *)
        cak_i_new_time :
            sc_symb := s_new_time;
        END;
    (*ENDCASE*) 
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := put_node;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        a01_force_symbol (acv, s_comma, put_node, last_node);
        IF  a_returncode = 0
        THEN
            BEGIN
            ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                  curr_n);
            curr_n1 := curr_n;
            ak63avalue_expression
                  (acv, a_ap_tree^[ curr_n ].n_sa_level, curr_n);
            a01_force_symbol (acv, s_comma, put_node, last_node);
            IF  a_returncode = 0
            THEN
                BEGIN
                ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_sa_level,
                      curr_n);
                ak63avalue_expression
                      (acv, a_ap_tree^[ curr_n ].n_sa_level, curr_n);
                a01_force_symbol (acv, s_rightpar, put_node, last_node)
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63concat_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    sc_symb   := s_concat;
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63astring_spec(acv, a_ap_tree^[ curr_n ].n_lo_level, curr_n);
        a01_force_symbol (acv, s_comma, put_node, last_node);
        IF  a_returncode = 0
        THEN
            BEGIN
            ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                  curr_n);
            ak63astring_spec(acv, a_ap_tree^[ curr_n ].n_sa_level, curr_n);
            a01_force_symbol (acv, s_rightpar, put_node, last_node)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63expand_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    sc_symb   := s_expand;
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63astring_spec(acv, a_ap_tree^[ curr_n ].n_lo_level, curr_n);
        a01_force_symbol (acv, s_comma, put_node, last_node);
        IF  a_returncode = 0
        THEN
            BEGIN
            IF  (sc_symb = s_unsigned_integer) OR
                a01_eqkey (a01kw [ cak_i_null ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                      curr_n);
                a01_put_node (acv,
                      a_ap_tree^[ curr_n ].n_sa_level);
                IF  a01_eqkey (a01kw [ cak_i_null ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    BEGIN
                    curr_n := a_ap_tree^[ curr_n ].n_sa_level;
                    a_ap_tree^[ curr_n ].n_symb := s_null;
                    END;
                (*ENDIF*) 
                a01_next_symbol (acv);
                a01_force_symbol (acv, s_rightpar, put_node, last_node)
                END
            ELSE
                a07_error (acv, e_invalid_unsign_integer,
                      put_node, last_node);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63space_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      curr_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    sc_symb   := s_space;
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  (sc_symb = s_unsigned_integer) OR
            a01_eqkey (a01kw [ cak_i_null ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)
        THEN
            BEGIN
            a01_put_node (acv,
                  a_ap_tree^[ curr_n ].n_sa_level);
            IF  a01_eqkey (a01kw [ cak_i_null ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                curr_n := a_ap_tree^[ curr_n ].n_sa_level;
                a_ap_tree^[ curr_n ].n_symb := s_null;
                END;
            (*ENDIF*) 
            a01_next_symbol (acv);
            a01_force_symbol (acv, s_rightpar, put_node, last_node)
            END
        ELSE
            a07_error (acv, e_invalid_unsign_integer,
                  put_node, last_node);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63extraction_func_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
VAR
      curr_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    CASE index OF
        cak_i_date       :
            sc_symb := s_func_date;
        cak_i_day        :
            sc_symb := s_day;
        cak_i_days       :
            sc_symb := s_days;
        cak_i_hour       :
            sc_symb := s_hour;
        cak_i_microsec:
            sc_symb := s_microsecond;
        cak_i_minute     :
            sc_symb := s_minute;
        cak_i_month      :
            sc_symb := s_month;
        cak_i_second     :
            sc_symb := s_second;
        cak_i_time       :
            sc_symb := s_func_time;
        cak_i_year       :
            sc_symb := s_year;
        END;
    (*ENDCASE*) 
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        a01_force_symbol (acv, s_rightpar, put_node, last_node)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63fixed_decimal_func_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  (index = cak_i_decimal) AND
        (a_sqlmode <> sqlm_db2)
    THEN
        a07_error (acv, e_invalid_keyword, put_node, last_node)
    ELSE
        BEGIN
        sc_symb   := s_fixed;
        a01_function_put (acv, put_node);
        curr_n    := put_node;
        last_node := curr_n;
        a01_next_symbol (acv);
        a01_force_symbol (acv, s_leftpar, put_node, last_node);
        IF  a_returncode = 0
        THEN
            BEGIN
            curr_n1 := curr_n;
            ak63avalue_expression (acv,
                  a_ap_tree^[ curr_n ].n_lo_level, curr_n);
            IF  sc_symb = s_comma
            THEN
                BEGIN
                a01_next_symbol (acv);
                IF  (sc_symb = s_unsigned_integer) OR
                    a01_eqkey (a01kw [ cak_i_null ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    BEGIN
                    ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                          curr_n);
                    a01_put_node (acv,
                          a_ap_tree^[ curr_n ].n_sa_level);
                    curr_n := a_ap_tree^[ curr_n ].n_sa_level;
                    IF  a01_eqkey (a01kw [ cak_i_null ], a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv)
                    THEN
                        a_ap_tree^[ curr_n ].n_symb := s_null;
                    (*ENDIF*) 
                    a01_next_symbol (acv);
                    IF  sc_symb = s_comma
                    THEN
                        BEGIN
                        a01_next_symbol (acv);
                        IF  (sc_symb = s_unsigned_integer) OR
                            a01_eqkey (a01kw [ cak_i_null ], a_sqlmode,
                            a_cmd_part^.sp1p_buf, a_scv)
                        THEN
                            BEGIN
                            a01_put_node (acv,
                                  a_ap_tree^[ curr_n ].n_sa_level);
                            curr_n := a_ap_tree^[curr_n].n_sa_level;
                            IF  a01_eqkey (a01kw [ cak_i_null ], a_sqlmode,
                                a_cmd_part^.sp1p_buf, a_scv)
                            THEN
                                a_ap_tree^[curr_n].n_symb := s_null;
                            (*ENDIF*) 
                            a01_next_symbol (acv)
                            END
                        ELSE
                            a07_error (acv, e_invalid_unsign_integer,
                                  put_node, last_node);
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END
                ELSE
                    a07_error (acv, e_invalid_unsign_integer,
                          put_node, last_node);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            a01_force_symbol (acv, s_rightpar, put_node, last_node)
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63replace_translate_func_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  index = cak_i_replace
    THEN
        sc_symb := s_replace
    ELSE
        sc_symb := s_translate;
    (*ENDIF*) 
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := put_node;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        a01_force_symbol (acv, s_comma, put_node, last_node);
        IF  a_returncode = 0
        THEN
            BEGIN
            ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                  curr_n);
            curr_n1 := curr_n;
            ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_sa_level,
                  curr_n);
            IF  sc_symb = s_comma
            THEN
                BEGIN
                ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_sa_level,
                      curr_n);
                a01_next_symbol (acv);
                ak63avalue_expression (acv,
                      a_ap_tree^[ curr_n ].n_sa_level, curr_n);
                END
            ELSE
                IF  index = cak_i_translate
                THEN
                    a07_error (acv, e_missing_keyword, put_node,
                          last_node);
                (*ENDIF*) 
            (*ENDIF*) 
            a01_force_symbol (acv, s_rightpar, put_node, last_node)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63mbcs_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      curr_n  : tsp00_Int2;
      curr_n1 : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    sc_symb := s_mbcs;
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := curr_n;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        IF  sc_symb <> s_rightpar
        THEN
            BEGIN
            a01_force_symbol (acv, s_comma, put_node, last_node);
            IF  a_returncode = 0
            THEN
                BEGIN
                ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                      curr_n);
                a01_character_set (acv,
                      a_ap_tree^[ curr_n ].n_sa_level, curr_n)
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a01_force_symbol (acv, s_rightpar, put_node, last_node);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a63_asearch_condition (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      is_allow  : allow_type;
      list_cnt  : integer;
      predlevel : integer;
      snot      : boolean;
      res_kw    : boolean;
      index     : integer;
      curr_n    : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    is_allow         := a_value;
    a_rowno_found    := false;
    list_cnt         := 1;
    predlevel        := 0;
    ak63se_or_term(acv, put_node, last_node, is_allow, list_cnt, predlevel);
    IF  sc_symb <> s_eof
    THEN
        IF  a01_eqkey ( a01kw[ cak_i_is ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv )
        THEN
            IF  (a_init_ddl <> ddl_alter_tab_alter) AND
                (a_init_ddl <> ddl_alter_tab_add)
            THEN
                a07_error (acv, e_invalid_keyword, put_node, last_node)
            ELSE
                BEGIN
&               ifdef TRACE
                t01int4 (ak_syn, 'SEARCH COND ', 1);
                t01int4 (ak_syn, 'sc_symb     ', ord(sc_symb));
                t01int4 (ak_syn, 'sc_err      ', ord(a_returncode));
&               endif
                a01_next_symbol (acv);
                IF  a01_eqkey ( a01kw[ cak_i_not ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv )
                THEN
                    BEGIN
                    snot := true;
                    a01_next_symbol (acv);
                    END
                ELSE
                    snot := false;
                (*ENDIF*) 
                (* PTS 1115778 E.Z. *)
                (* do not use a01_get_keyword; true not known in Oracle-mode *)
                IF  a01_eqkey ( a01kw[ cak_i_true ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv )
                THEN
                    IF  snot
                    THEN
                        sc_symb := s_is_not_true
                    ELSE
                        sc_symb := s_is_true
                    (*ENDIF*) 
                ELSE
                    IF  a01_eqkey ( a01kw[ cak_i_false ], a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv )
                    THEN
                        IF  snot
                        THEN
                            sc_symb := s_is_not_false
                        ELSE
                            sc_symb := s_is_false
                        (*ENDIF*) 
                    ELSE
                        IF  a01_eqkey ( a01kw[ cak_i_unknown ], a_sqlmode,
                            a_cmd_part^.sp1p_buf, a_scv )
                        THEN
                            IF  snot
                            THEN
                                sc_symb := s_is_not_null
                            ELSE
                                sc_symb := s_is_null
                            (*ENDIF*) 
                        ELSE
                            a07_error (acv, e_wanted_keyword, put_node,
                                  last_node);
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  a_returncode = 0
                THEN
                    BEGIN
                    a01_call_put (acv, a64, cak_x_truth_value, curr_n);
                    a_ap_tree^[ curr_n ].n_symb := a_scv.sc_symb;
                    a01_next_symbol (acv);
                    END;
                (*ENDIF*) 
                a_ap_tree^[ curr_n ].n_lo_level := put_node;
                put_node  := curr_n;
                last_node := curr_n
                END
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a63_avalue_expression (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
BEGIN
acv.a_col_func_count := 0;
ak63avalue_expression (acv, put_node, last_node);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63avalue_expression (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      m_rowno_found  : boolean;
      first_duration : boolean;
      plus_found     : boolean;
      curr_n         : tsp00_Int2;
      duration_n     : tsp00_Int2;
      dur_1_n        : tsp00_Int2;
      last_n         : tsp00_Int2;
      scvh           : tak_scanner_glob;
 
BEGIN
(* PTS 1119064 E.Z. *)
IF  g01userstackoverflow
THEN
    BEGIN
    a07_b_put_error (acv, e_program_stack_overflow, 1);
    put_node := 0;
    last_node := 0;
    END;
(*ENDIF*) 
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        m_rowno_found  := a_rowno_found;
        ak63aterm (acv, put_node, last_node, c_duration_allowed);
        duration_n      := put_node;
        first_duration := (a_ap_tree^[ put_node ].n_proc = a64) AND
              (a_ap_tree^[ put_node ].n_subproc = cak_x_duration);
        WHILE (((sc_symb in [ s_plus, s_minus ]) OR first_duration) AND
              (a_returncode = 0)) DO
            BEGIN
            IF  (first_duration AND NOT (sc_symb in [ s_plus, s_minus ]))
            THEN
                WITH a_ap_tree^[ duration_n ] DO
                    IF  NOT (n_symb in [ s_hour, s_minute, s_second ])
                    THEN
                        BEGIN
                        sc_sypos := n_pos;
                        a07_error (acv, e_wanted_keyword,
                              put_node, last_node)
                        END;
                    (*ENDIF*) 
                (*ENDWITH*) 
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                IF  NOT (sc_symb in [ s_plus, s_minus ])
                THEN
                    BEGIN
                    scvh       := a_scv;
                    sc_symb    := s_plus;
                    plus_found := true;
                    a01_call_put (acv, a64, cak_x_add_operator, curr_n);
                    a_ap_tree^[ curr_n ].n_symb := a_scv.sc_symb;
                    sc_symb    := s_midnight;
                    END
                ELSE
                    BEGIN
                    a01_call_put (acv, a64, cak_x_add_operator, curr_n);
                    a_ap_tree^[ curr_n ].n_symb := a_scv.sc_symb;
                    ak63subq_check (acv, put_node, last_node);
                    END;
                (*ENDIF*) 
                a_ap_tree^[ curr_n ].n_lo_level := put_node;
                put_node  := curr_n;
                curr_n    := last_node;
                last_node := put_node;
                IF  sc_symb in [ s_plus, s_minus ]
                THEN
                    BEGIN
                    plus_found := (sc_symb = s_plus);
                    a01_next_symbol( acv );
                    ak63aterm ( acv, a_ap_tree^[ curr_n ].n_sa_level,
                          last_n, c_duration_allowed);
                    END
                ELSE
                    BEGIN
                    a01_put_node (acv, a_ap_tree^[ curr_n ].n_sa_level);
                    last_n := a_ap_tree^[ curr_n ].n_sa_level;
                    a_scv  := scvh;
                    END;
                (*ENDIF*) 
                IF  (first_duration AND plus_found AND
                    ((a_ap_tree^[ a_ap_tree^[ curr_n ].n_sa_level ].n_subproc
                    <> cak_x_duration)
                    OR
                    (a_ap_tree^[ a_ap_tree^[ curr_n ].n_sa_level ].n_proc
                    <> a64)))
                THEN
                    BEGIN
                    (* duration must NOT be the first factor *)
                    IF  ((a_ap_tree^[ curr_n ].n_subproc = cak_x_duration) AND
                        (a_ap_tree^[ curr_n ].n_proc = a64))
                    THEN
                        BEGIN
                        a_ap_tree^[ last_n ].n_sa_level   :=
                              a_ap_tree^[ put_node ].n_lo_level;
                        a_ap_tree^[ put_node ].n_lo_level :=
                              a_ap_tree^[ curr_n ].n_sa_level;
                        a_ap_tree^[ curr_n ].n_sa_level   := 0
                        END
                    ELSE
                        BEGIN
                        dur_1_n    := curr_n;
                        duration_n := a_ap_tree^[ curr_n ].n_lo_level;
                        WHILE a_ap_tree^[ duration_n ].n_subproc =
                              cak_x_add_operator DO
                            BEGIN
                            dur_1_n    := duration_n;
                            duration_n := a_ap_tree^[ duration_n ].
                                  n_lo_level;
                            END;
                        (*ENDWHILE*) 
                        a_ap_tree^[ last_n ].n_sa_level  :=
                              a_ap_tree^[ duration_n ].n_sa_level;
                        a_ap_tree^[ dur_1_n ].n_lo_level :=
                              a_ap_tree^[ curr_n ].n_sa_level;
                        a_ap_tree^[ curr_n ].n_sa_level  := duration_n;
                        a_ap_tree^[ duration_n ].n_sa_level := 0;
                        END;
                    (*ENDIF*) 
                    first_duration := false
                    END;
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        IF  a_allow_functions = tf_func
        THEN
            IF  NOT (a_ap_tree^[ put_node ].n_symb in
                [ s_avg  , s_dis_avg,
                s_count  , s_dis_count, s_all_count,
                s_sum    , s_dis_sum,
                s_stddev , s_dis_stddev,
                s_variance, s_dis_variance,
                s_min    , s_max ])
            THEN
                a_allow_functions := tf_func_arith;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  (NOT m_rowno_found AND a_rowno_found)
        THEN (* anywhere in val_expr was rowno *)
            IF  a_ap_tree^[ put_node ].n_symb <> s_rowno
            THEN
                a07_error (acv, e_rowno_not_allowed, put_node,
                      last_node)
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63_special_func_syn (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            index         : integer);
 
VAR
      is_decode    : boolean;
      is_nvl       : boolean;
      curr_n       : tsp00_Int2;
      curr_n1      : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    is_decode := index = cak_i_decode;
    is_nvl    := index = cak_i_nvl;
    CASE index OF
        cak_i_decode :
            sc_symb := s_decode;
        cak_i_greatest :
            sc_symb := s_greatest;
        cak_i_least :
            sc_symb := s_least;
        cak_i_value, cak_i_ifnull :
            sc_symb := s_value;
        cak_i_nvl :
            sc_symb := s_value;
        END;
    (*ENDCASE*) 
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := put_node;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        curr_n1 := curr_n;
        ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
              curr_n);
        IF  sc_symb <> s_comma
        THEN
            a07_error (acv, e_missing_keyword, put_node, last_node)
        ELSE
            BEGIN
            IF  is_nvl
            THEN
                BEGIN
                a01_next_symbol (acv);
                ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                      curr_n);
                ak63avalue_expression (acv,
                      a_ap_tree^[ curr_n ].n_sa_level, curr_n);
                END
            ELSE
                BEGIN
                IF  is_decode
                THEN
                    BEGIN
                    a01_next_symbol (acv);
                    ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
                          curr_n);
                    curr_n1 := curr_n;
                    IF  NOT a01_eqkey (a01kw[ cak_i_null ], a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv)
                    THEN
                        ak63avalue_expression (acv,
                              a_ap_tree^[ curr_n ].n_sa_level, curr_n)
                    ELSE
                        BEGIN
                        sc_symb := s_null;
                        a01_put_node (acv,
                              a_ap_tree^[ curr_n ].n_sa_level);
                        curr_n := a_ap_tree^[ curr_n ].n_sa_level;
                        a01_next_symbol (acv)
                        END;
                    (*ENDIF*) 
                    IF  sc_symb <> s_comma
                    THEN
                        a07_error (acv, e_missing_keyword,
                              put_node, last_node);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                WHILE ( sc_symb = s_comma )
                      AND ( a_returncode = 0 ) DO
                    BEGIN
                    a01_next_symbol (acv);
                    ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_sa_level,
                          curr_n);
                    curr_n1 := curr_n;
                    IF  is_decode
                    THEN
                        IF  NOT a01_eqkey (a01kw[ cak_i_null ], a_sqlmode,
                            a_cmd_part^.sp1p_buf, a_scv)
                        THEN
                            ak63avalue_expression (acv,
                                  a_ap_tree^[ curr_n ].n_sa_level,
                                  curr_n)
                        ELSE
                            BEGIN
                            sc_symb := s_null;
                            a01_put_node (acv,
                                  a_ap_tree^[ curr_n ].n_sa_level);
                            curr_n := a_ap_tree^[ curr_n ].n_sa_level;
                            a01_next_symbol (acv)
                            END
                        (*ENDIF*) 
                    ELSE
                        ak63avalue_expression (acv,
                              a_ap_tree^[ curr_n ].n_sa_level, curr_n);
                    (*ENDIF*) 
                    END;
                (*ENDWHILE*) 
                END;
            (*ENDIF*) 
            a01_force_symbol (acv, s_rightpar, put_node, last_node)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1117523 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak63case (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      first           : boolean;
      m_rowno_allowed : boolean;
      curr_n          : tsp00_Int2;
      curr_n1         : tsp00_Int2;
      scvh            : tak_scanner_glob;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    scvh := a_scv;
    a01_next_symbol (acv);
    IF  NOT a01_eqkey (a01kw[ cak_i_when ], a_sqlmode,
        a_cmd_part^.sp1p_buf, a_scv)
    THEN
        BEGIN
        a_scv := scvh;
        ak63decode_like_case (acv, put_node, last_node)
        END
    ELSE
        BEGIN
        sc_symb := s_case;
        a01_function_put (acv, put_node);
        curr_n    := put_node;
        last_node := put_node;
        curr_n1    := curr_n;
        first := true;
        m_rowno_allowed := a_rowno_allowed;
        a_rowno_allowed := false;
        REPEAT
            a01_next_symbol (acv);
            IF  first
            THEN
                BEGIN
                first := false;
                a63_asearch_condition (acv, a_ap_tree^[ curr_n ].n_lo_level, curr_n)
                END
            ELSE
                a63_asearch_condition (acv, a_ap_tree^[ curr_n ].n_sa_level, curr_n);
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                curr_n1 := curr_n;
                IF  a01mandatory_keyword (acv, cak_i_then)
                THEN
                    BEGIN
                    IF  NOT a01_eqkey (a01kw[ cak_i_null ], a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv)
                    THEN
                        ak63avalue_expression (acv,
                              a_ap_tree^[ curr_n ].n_sa_level, curr_n)
                    ELSE
                        BEGIN
                        sc_symb := s_null;
                        a01_put_node (acv,
                              a_ap_tree^[ curr_n ].n_sa_level);
                        curr_n := a_ap_tree^[ curr_n ].n_sa_level;
                        a01_next_symbol (acv)
                        END;
                    (*ENDIF*) 
                    ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_sa_level,
                          curr_n);
                    curr_n1 := curr_n;
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
        UNTIL
            (a_returncode <> 0)
            OR
            (NOT a01_eqkey (a01kw[ cak_i_when ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv));
        (*ENDREPEAT*) 
        IF  a_returncode = 0
        THEN
            IF  a01_eqkey (a01kw[ cak_i_else ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                a01_next_symbol (acv);
                IF  NOT a01_eqkey (a01kw[ cak_i_null ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    ak63avalue_expression (acv,
                          a_ap_tree^[ curr_n ].n_sa_level, curr_n)
                ELSE
                    BEGIN
                    sc_symb := s_null;
                    a01_put_node (acv,
                          a_ap_tree^[ curr_n ].n_sa_level);
                    curr_n := a_ap_tree^[ curr_n ].n_sa_level;
                    a01_next_symbol (acv)
                    END;
                (*ENDIF*) 
                ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_sa_level,
                      curr_n);
                curr_n1 := curr_n;
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  a01mandatory_keyword (acv, cak_i_end)
        THEN
            BEGIN
            END;
        (*ENDIF*) 
        a_rowno_allowed := m_rowno_allowed;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63decode_like_case (VAR acv : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      curr_n         : tsp00_Int2;
      curr_n1        : tsp00_Int2;
      wanted_keyword : integer;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    sc_symb := s_decode;
    a01_function_put (acv, put_node);
    curr_n    := put_node;
    last_node := put_node;
    a01_next_symbol (acv);
    curr_n1 := curr_n;
    ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
          curr_n);
    ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
          curr_n);
    curr_n1 := curr_n;
    wanted_keyword := cak_i_when;
    IF  NOT a01_eqkey (a01kw[ cak_i_when ], a_sqlmode,
        a_cmd_part^.sp1p_buf, a_scv)
    THEN
        a07_error (acv, e_missing_keyword, put_node, last_node)
    ELSE
        BEGIN
        REPEAT
            a01_next_symbol (acv);
            IF  NOT a01_eqkey (a01kw[ cak_i_null ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                ak63avalue_expression (acv,
                      a_ap_tree^[ curr_n ].n_sa_level, curr_n)
            ELSE
                BEGIN
                sc_symb := s_null;
                a01_put_node (acv,
                      a_ap_tree^[ curr_n ].n_sa_level);
                curr_n := a_ap_tree^[ curr_n ].n_sa_level;
                a01_next_symbol (acv)
                END;
            (*ENDIF*) 
            ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_sa_level,
                  curr_n);
            curr_n1 := curr_n;
            IF  wanted_keyword = cak_i_when
            THEN
                wanted_keyword := cak_i_then
            ELSE
                wanted_keyword := cak_i_when;
            (*ENDIF*) 
        UNTIL
            (a_returncode <> 0)
            OR
            (
            (NOT a01_eqkey (a01kw[ wanted_keyword ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv))
            AND
            NOT((wanted_keyword = cak_i_when) AND
            a01_eqkey (a01kw[ cak_i_else ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv))
            );
        (*ENDREPEAT*) 
        IF  a01mandatory_keyword (acv, cak_i_end)
        THEN
            BEGIN
            END;
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* END PTS 1117523 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak63user_defined_func (VAR acv : tak_all_command_glob;
            symb          : tak_sc_symbol;
            column_node   : tsp00_Int2;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      owner_n   : tsp00_Int2;
      curr_n    : tsp00_Int2;
      curr_n1   : tsp00_Int2;
      aux_scv   : tak_scanner_glob;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    owner_n := 0;
    aux_scv := acv.a_scv;
    a01_next_symbol (acv);
    IF  acv.a_scv.sc_symb = s_point
    THEN
        BEGIN (* reset and out owner *)
        acv.a_scv := aux_scv;
        a01_call_put (acv, a262, 0, owner_n);
        sc_symb := s_authid;
        a01_put_node (acv, a_ap_tree^[owner_n].n_sa_level);
        a01_next_symbol (acv); (* dot *)
        a01_next_symbol (acv); (* function name *)
        END
    ELSE
        acv.a_scv := aux_scv;
    (*ENDIF*) 
    sc_symb := symb;
    a01_function_put (acv, put_node);
    IF  owner_n <> 0
    THEN
        BEGIN
        a_ap_tree^[put_node].n_lo_level := owner_n;
        curr_n    := owner_n;
        END
    ELSE
        curr_n    := put_node;
    (*ENDIF*) 
    last_node := put_node; (* PTS 1136294 *)
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    curr_n1 := curr_n;
    IF  a_returncode = 0
    THEN
        BEGIN (* the first param will be tied at low level. *)
        IF  symb = s_method_call
        THEN
            BEGIN (* implicit 'this' parameter *)
            a01_put_node (acv, a_ap_tree^[ curr_n ].n_lo_level);
            curr_n := a_ap_tree^[curr_n].n_lo_level;
            a_ap_tree^[curr_n] := a_ap_tree^[column_node];
            WHILE a_ap_tree^[curr_n].n_symb <> s_columnname DO
                curr_n := a_ap_tree^[curr_n].n_sa_level;
            (*ENDWHILE*) 
            a_ap_tree^[curr_n].n_sa_level := 0;
            a_ap_tree^[curr_n].n_lo_level := 0;
            IF  sc_symb <> s_rightpar
            THEN
                ak63avalue_expression (acv,
                      a_ap_tree^[ curr_n ].n_sa_level, curr_n)
            (*ENDIF*) 
            END
        ELSE
            IF  sc_symb <> s_rightpar
            THEN
                IF  NOT a01_eqkey (a01kw[ cak_i_null ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    ak63avalue_expression (acv,
                          a_ap_tree^[ curr_n ].n_lo_level, curr_n)
                ELSE (* null value as expression detected. *)
                    BEGIN
                    sc_symb := s_null;
                    a01_put_node (acv, a_ap_tree^[ curr_n ].n_lo_level);
                    curr_n := a_ap_tree^[ curr_n ].n_lo_level;
                    a01_next_symbol (acv)
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_lo_level,
              curr_n);
        WHILE ( sc_symb = s_comma ) AND (a_returncode = 0) DO
            BEGIN (* all following params we'll tie at same level. *)
            a01_next_symbol (acv);
            curr_n1 := curr_n;
            IF  NOT a01_eqkey (a01kw[ cak_i_null ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                ak63avalue_expression (acv,
                      a_ap_tree^[ curr_n ].n_sa_level, curr_n)
            ELSE (* null value as expression detected. *)
                BEGIN
                sc_symb := s_null;
                a01_put_node (acv, a_ap_tree^[ curr_n ].n_sa_level);
                curr_n := a_ap_tree^[ curr_n ].n_sa_level;
                a01_next_symbol (acv)
                END;
            (*ENDIF*) 
            ak63subq_check (acv, a_ap_tree^[ curr_n1 ].n_sa_level,
                  curr_n);
            END;
        (*ENDWHILE*) 
        a01_force_symbol (acv, s_rightpar, put_node, last_node)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63a_ll_expr_list_list (VAR acv: tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            list_cnt      : integer);
 
VAR
      curr_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN (* the left paranthese is already read in the input. *)
    ak63a_l_expr_list (acv, put_node, last_node, list_cnt);
    curr_n := put_node;
    WHILE (sc_symb = s_comma) AND (a_returncode = 0) DO
        BEGIN (* Here another list as list element is coming. *)
        a01_next_symbol (acv);
        ak63a_l_expr_list (acv, a_ap_tree^[ curr_n ].n_sa_level,
              last_node, list_cnt);
        curr_n := a_ap_tree^[ curr_n ].n_sa_level
        END
    (*ENDWHILE*) 
    END (* the right paranthese has to be read elsewhere. *)
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak63a_l_expr_list (VAR acv: tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            list_cnt      : integer);
 
VAR
      c              : tsp00_C1;
      found_list_cnt : integer;
      ilast          : tsp00_Int2;
      curr_n         : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    IF  sc_symb = s_leftpar
    THEN
        BEGIN (* the beginning of an expr list was detected. *)
        a01_next_symbol (acv);
        ak63avalue_expression (acv, put_node, last_node);
        found_list_cnt := 1;
        IF  (sc_symb = s_comma)
        THEN
            BEGIN
            ilast := put_node;
            a01_call_put (acv, a56, cak_x_value_list, put_node);
            a01_call_put (acv, a64, cak_x_value_expression,
                  a_ap_tree^[ put_node ].n_lo_level);
            curr_n := a_ap_tree^[ put_node ].n_lo_level;
            a_ap_tree^[ curr_n ].n_lo_level := ilast;
            last_node := put_node;
            WHILE (sc_symb = s_comma) AND (found_list_cnt < list_cnt) DO
                BEGIN (* another expected list element was found. *)
                a01_next_symbol (acv);
                a01_call_put (acv, a67, cak_x_value_expression,
                      a_ap_tree^[ curr_n ].n_sa_level);
                curr_n           := a_ap_tree^[ curr_n ].n_sa_level;
                a_col_func_count := 0;
                found_list_cnt   := succ (found_list_cnt);
                ak63avalue_expression (acv, a_ap_tree^[ curr_n ].n_lo_level,
                      ilast)
                END
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        IF  sc_symb = s_comma
        THEN (* here is at least one value too much. *)
            a07_error (acv, e_too_many_values, put_node, last_node)
        ELSE
            BEGIN
            a01_force_symbol (acv, s_rightpar, put_node, last_node);
            IF  (a_returncode = 0) AND (found_list_cnt < list_cnt)
            THEN (* the value list is shorter than that to the left. *)
                a07_error (acv, e_too_few_values, put_node, last_node)
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    ELSE
        IF  list_cnt = 1
        THEN
            ak63avalue_expression (acv, put_node, last_node)
        ELSE (* too less values on the right side. *)
            BEGIN
            a07_error (acv, e_missing_delimiter, put_node,
                  last_node);
            c[1] := '(';
            a07const_param (acv, 1, @c, sizeof (c))
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
