.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-10-19
*****************************************************
modname : VAK44
changed : 2000-10-19
module  : AK_Show_synonym_domain
 
Author  : ThomasA
Created : 1985-03-01
*****************************************************
 
Purpose : Show Synonym, Domain und Comment semantische Routinen.
 
Define  :
 
        PROCEDURE
              a44constraint_into_moveobj (
                    VAR acv        : tak_all_command_glob;
                    base_ptr       : tak_sysbufferaddress;
                    VAR tabid      : tgg00_Surrogate;
                    object_type    : tak_object_type;
                    constraint_id  : integer;
                    tabno          : integer;
                    VAR moveobj    : tsp00_MoveObj;
                    moveobj_size   : tsp00_Int4;
                    VAR filled_len : tsp00_Int4);
 
        PROCEDURE
              a44domain_show (
                    VAR acv      : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob);
 
        PROCEDURE
              a44dom_constraints (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a44get_domaindef (
                    VAR acv           : tak_all_command_glob;
                    VAR dom_surrogate : tgg00_Surrogate;
                    constraint_only   : boolean;
                    VAR moveobj       : tsp00_MoveObj;
                    moveobj_size      : tsp00_Int4;
                    VAR filled_len    : tsp00_Int4);
 
        PROCEDURE
              a44oms_versions (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a44sequence_show (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a44synonym_show_execute (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01char_size         : integer;
              a01defaultkey        : tgg00_SysInfoKey;
              a01kw                : tak_keywordtab;
              a01_i_public         : tsp00_KnlIdentifier;
              a01_i_sys            : tsp00_KnlIdentifier;
              a01_il_b_identifier  : tsp00_KnlIdentifier;
 
        FUNCTION
              a01is_identifier (
                    VAR identifier : tsp00_KnlIdentifier;
                    len     : integer;
                    sqlmode : tsp00_SqlMode) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06rsend_mess_buf (
                    VAR acv        : tak_all_command_glob;
                    VAR mblock     : tgg00_MessBlock;
                    result_req     : boolean;
                    VAR b_err      : tgg00_BasisError);
 
        PROCEDURE
              a06get_page_cnt (
                    VAR acv          : tak_all_command_glob;
                    VAR file_id      : tgg00_FileId;
                    do_sample        : boolean;
                    VAR page_count   : tsp00_Int4;
                    VAR b_err        : tgg00_BasisError);
 
        PROCEDURE
              a06det_user_id (
                    VAR acv      : tak_all_command_glob;
                    VAR authname : tsp00_KnlIdentifier;
                    VAR authid   : tgg00_Surrogate);
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061get_colname (
                    VAR col_info : tak00_columninfo;
                    VAR colname  : tsp00_KnlIdentifier);
&       ifdef trace
 
        PROCEDURE
              a061td_colinfo (
                    VAR colinfo : tak00_columninfo;
                    index : integer);
&       endif
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache  : VAK10;
 
        PROCEDURE
              a10next_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    stop_prefix  : integer;
                    dstate       : tak_directory_state;
                    rec_kind     : tsp00_C2;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_rel_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate (* ptocConst *);
                    VAR schemaName : tsp00_KnlIdentifier);
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
      ------------------------------ 
 
        FROM
              Kernel_Sink_1 : VAK341;
 
        FUNCTION
              ak341NextVersion (
                    VAR acv            : tak_all_command_glob;
                    isFirstCall        : boolean;
                    VAR versionId      : tsp00_C24;
                    VAR createDate     : tsp00_Date;
                    VAR createTime     : tsp00_Time;
                    VAR openDate       : tsp00_Date;
                    VAR openTime       : tsp00_Time;
                    VAR consistentView : tgg91_TransNo;
                    VAR isMarked       : boolean;
                    VAR isOpen         : boolean;
                    VAR isUnloaded     : boolean;
                    VAR heapUsage      : tsp00_8ByteCounter;
                    VAR hashSize       : tsp00_Int4;
                    VAR versionTree    : tgg00_FileId;
                    VAR versionInvTree : tgg00_FileId;
                    VAR versionDesc    : tsp00_C512) : boolean; (* PTS 1117690 *)
 
      ------------------------------ 
 
        FROM
              AK_universal_show_tools : VAK40;
 
        VAR
              a40yes_no : ARRAY[boolean] OF tsp00_C3;
 
        PROCEDURE
              a40get_catalog_table (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a40column_description (
                    VAR acv      : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    tablekind    : tgg00_TableKind;
                    VAR col_info : tak00_columninfo;
                    opt_undef    : boolean);
 
        PROCEDURE
              a40comment_descriptor (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    comment_exist : boolean;
                    VAR tabid     : tgg00_Surrogate;
                    column_no     : integer;
                    comment_kind  : tak_comment_type);
 
        PROCEDURE
              a40ignore_down_error (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a40init_table_scan (
                    VAR acv          : tak_all_command_glob;
                    VAR a41v         : tak40_show_glob;
                    scan_temp        : boolean;
                    scan_private     : boolean;
                    scan_non_private : boolean;
                    scan_public      : boolean;
                    use_synonyms     : boolean;
                    all_base         : boolean);
 
        PROCEDURE
              a40FinishTableScan (
                    VAR acv          : tak_all_command_glob;
                    VAR a41v         : tak40_show_glob);
 
        PROCEDURE
              a40move (
                    VAR acv     : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : integer);
 
        PROCEDURE
              a40move_counter (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    val           : tsp00_8ByteCounter;
                    is_null       : boolean;
                    frac          : integer;
                    zero_to_undef : boolean);
 
        PROCEDURE
              a40move_i4 (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    i4_val        : tsp00_Int4;
                    is_null       : boolean;
                    frac          : integer;
                    zero_to_undef : boolean);
 
        PROCEDURE
              a40move_ui4 (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    i4_val        : tsp00_Int4;
                    is_null       : boolean;
                    frac          : integer;
                    zero_to_undef : boolean);
 
        PROCEDURE
              a40move_const (
                    VAR acv     : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : integer);
 
        PROCEDURE
              a40put_date_time (
                    VAR acv      : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    VAR datetime : tsp00_Int4;
                    date         : boolean;
                    is_undef     : boolean);
 
        PROCEDURE
              a40long_descriptor (
                    VAR acv      : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    VAR tabid    : tgg00_Surrogate;
                    column_no    : integer);
 
        FUNCTION
              a40next_table (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob) : boolean;
 
        PROCEDURE
              a40table_column_to_shbuf (
                    VAR acv    : tak_all_command_glob;
                    VAR a41v   : tak40_show_glob;
                    base_ptr   : tak_sysbufferaddress;
                    colindex   : integer;
                    with_owner : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Show_table : VAK47;
 
        PROCEDURE
              a47range_default (
                    VAR acv      : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    VAR col_info : tak00_columninfo);
 
        PROCEDURE
              a47table_kind (
                    VAR acv      : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    VAR base_rec : tak_baserecord);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01nil_stack_desc : tgg00_StackDesc;
              g01unicode        : boolean;
 
        PROCEDURE
              g01mblock_init (
                    VAR source_trans : tgg00_TransContext;
                    mess_type  : tgg00_MessType;
                    mess2_type : tgg00_MessType2;
                    VAR mblock : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id      : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30unilnr (
                    str       : tsp00_MoveObjPtr;
                    skip_val  : tsp00_C2;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30eq (
                    VAR a,b : tsp00_KnlIdentifier;
                    bi,cnt : tsp00_Int4) : boolean;
 
      ------------------------------ 
 
        FROM
              Number-Arithmetic : VSP51;
 
        PROCEDURE
              s51div (
                    VAR left       : tsp00_C20;
                    lpos           : tsp00_Int4;
                    llen           : integer;
                    VAR right      : tsp00_C20;
                    rpos           : tsp00_Int4;
                    rlen           : integer;
                    VAR result     : tsp00_Number;
                    respos         : tsp00_Int4;
                    reslen         : integer;
                    resfrac        : integer;
                    VAR resbytelen : integer;
                    VAR ret        : tsp00_NumError);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01lidentifier (
                    debug      : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
&       endif
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        FUNCTION
              a01is_identifier;
 
              tsp00_MoveObj   tsp00_KnlIdentifier
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj   tsp00_KnlIdentifier
 
        PROCEDURE
              s30eq;
 
              tsp00_MoveObj   tsp00_KnlIdentifier
 
        PROCEDURE
              s51div;
 
              tsp00_MoveObj tsp00_C20
              tsp00_MoveObj tsp00_Number
 
.CM *-END-* synonym -------------------------------------
***********************************************************
 
Specification:
 
.CM *-END-* specification -------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      c_scan_temp         = true;
      c_scan_private      = true;
      c_scan_nonprivate   = true;
      c_scan_public       = true;
      c_use_synonyms      = true;
      c_all_base          = true;
 
 
(*------------------------------*) 
 
PROCEDURE
      a44domain_show (
            VAR acv      : tak_all_command_glob;
            VAR a41v     : tak40_show_glob);
 
VAR
      full_spec    : boolean;
      is_qualified : boolean;
      b_err        : tgg00_BasisError;
      prefix_len   : integer;
      owner        : tsp00_KnlIdentifier;
      dom_key      : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a41v, a4p_arr DO
    BEGIN
&   ifdef trace
    t01int4       (ak_sem, 'a4tab_len   ', a4tab_len);
    t01lidentifier (ak_sem, a4authname);
    t01lidentifier (ak_sem, a4tablen);
&   endif
    a4sh_kind := sh_u_domain;
    a40get_catalog_table (acv, a41v);
    IF  (a_ex_kind <> only_parsing) AND (a_returncode = 0)
    THEN
        BEGIN
        full_spec :=
              (a4authname <> a01_il_b_identifier)
              AND
              (a4tab_len = sizeof (a4tablen));
        a4sysk := a01defaultkey;
        IF  a4authname <> a01_il_b_identifier
        THEN
            BEGIN
            a06det_user_id (acv, a4authname, a4sysk.sauthid);
            a4sysk.sidentifier := a4tablen;
            IF  NOT full_spec
            THEN
                a4sysk.sidentifier[sizeof (a4sysk.sidentifier)] :=
                      chr (ord (a4sysk.sidentifier[sizeof (a4sysk.sidentifier)]) -
                      1);
            (*ENDIF*) 
            a4sysk.skeylen := mxak_standard_sysk + sizeof (a4sysk.sidentifier);
            prefix_len     := sizeof (a4sysk.sauthid) +
                  sizeof (a4sysk.sentrytyp) +
                  sizeof (a4sysk.slinkage) + a4tab_len
            END
        ELSE
            prefix_len := 0;
        (*ENDIF*) 
        a4sysk.sentrytyp := cak_edomainref;
        REPEAT
            IF  full_spec
            THEN
                a10get_sysinfo (acv, a4sysk, d_release, a4sysbuf, b_err)
            ELSE
                a10next_sysinfo (acv, a4sysk, prefix_len, d_release,
                      cak_edomainref, a4sysbuf, b_err);
            (*ENDIF*) 
            IF  b_err = e_ok
            THEN
                WITH a4sysbuf^.sdomainref DO
                    BEGIN
                    IF  a4tab_len > 0
                    THEN
                        is_qualified :=
                              s30eq (a4tablen, dname, 1, a4tab_len)
                    ELSE
                        is_qualified := true;
                    (*ENDIF*) 
                    IF  is_qualified
                    THEN
                        BEGIN
                        a06determine_username (acv,
                              a4sysbuf^.syskey.sauthid, owner);
                        dom_key           := a01defaultkey;
                        dom_key.stableid  := dsurrogate;
                        dom_key.sentrytyp := cak_edomain;
                        a10get_sysinfo (acv, dom_key,
                              d_fix, a4dombuf, b_err)
                        END
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            IF  (b_err = e_ok) AND (is_qualified)
            THEN
                BEGIN
                ak44put_domain (acv, a41v, owner);
                a10_rel_sysinfo (acv, dom_key);
                IF  full_spec
                THEN
                    b_err := e_no_next_record
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            b_err <> e_ok;
        (*ENDREPEAT*) 
        IF  b_err <> e_no_next_record
        THEN
            IF  full_spec AND (b_err = e_sysinfo_not_found)
            THEN
                BEGIN
                END
            ELSE
                BEGIN
                a07_b_put_error (acv, b_err, 1);
                a40ignore_down_error (acv);
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a44dom_constraints (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      full_spec : boolean;
      b_err     : tgg00_BasisError;
      ix        : integer;
      sysbuf    : tak_sysbufferaddress;
      sysk      : tgg00_SysInfoKey;
      domkey    : tgg00_SysInfoKey;
      owner     : tsp00_KnlIdentifier;
 
BEGIN
a40get_catalog_table (acv, a41v);
full_spec      := false;
sysk           := a01defaultkey;
sysk.sentrytyp := cak_edomainref;
IF  a41v.a4authname <> a01_il_b_identifier
THEN
    BEGIN
    a06det_user_id (acv, a41v.a4authname, sysk.sauthid);
    IF  a41v.a4tablen <> a01_il_b_identifier
    THEN
        BEGIN
        full_spec        := true;
        sysk.sidentifier := a41v.a4tablen;
        sysk.skeylen     := sysk.skeylen + sizeof (sysk.sidentifier)
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
REPEAT
    IF  full_spec
    THEN
        a10get_sysinfo (acv,
              sysk, d_release, sysbuf, b_err)
    ELSE
        a10next_sysinfo (acv, sysk, 0, d_release,
              cak_edomainref, sysbuf, b_err);
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        BEGIN
        domkey           := a01defaultkey;
        domkey.stableid  := sysbuf^.sdomainref.dsurrogate;
        domkey.sentrytyp := cak_edomain;
        a10get_sysinfo (acv,
              domkey, d_release, sysbuf, b_err);
        END;
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        IF  sysbuf^.sdomain.dom_constraint
        THEN
            WITH acv, a41v  DO
                BEGIN
                a06determine_username (acv, sysk.sauthid, owner);
                a40move (acv, a41v, @owner, sizeof (owner));
                a40move (acv, a41v, @sysk.stablen, sizeof (sysk.stablen));
                a40move (acv, a41v, @owner, sizeof (owner));
                a40move (acv, a41v, @sysk.stablen, sizeof (sysk.stablen));
                a40long_descriptor (acv, a41v,
                      sysbuf^.sdomain.dom_surrogate, 1)
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
UNTIL
    (b_err <> e_ok) OR full_spec;
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a44get_domaindef (
            VAR acv           : tak_all_command_glob;
            VAR dom_surrogate : tgg00_Surrogate;
            constraint_only   : boolean;
            VAR moveobj       : tsp00_MoveObj;
            moveobj_size      : tsp00_Int4;
            VAR filled_len    : tsp00_Int4);
 
VAR
      b_err     : tgg00_BasisError;
      kind      : tgg00_TableKind;
      dombuf    : tak_sysbufferaddress;
      base_rec  : tak_baserecord;
      sysk      : tgg00_SysInfoKey;
 
BEGIN
sysk           := a01defaultkey;
sysk.stableid  := dom_surrogate;
sysk.sentrytyp := cak_edomain;
a10get_sysinfo (acv, sysk, d_release, dombuf, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    IF  constraint_only
    THEN
        kind := tempty
    ELSE
        kind := tdummy;
    (*ENDIF*) 
    ak44make_dom_baserec (dombuf^.sdomain, kind, base_rec);
    a44constraint_into_moveobj (acv, @base_rec, dom_surrogate,
          obj_domain, 1, 1, moveobj,
          moveobj_size, filled_len);
    END
ELSE
    a07_b_put_error (acv, b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak44make_dom_baserec (
            VAR domrec   : tak_domainrecord;
            tablekind    : tgg00_TableKind;
            VAR base_rec : tak_baserecord);
 
BEGIN
WITH base_rec DO
    BEGIN
    bkeylen                := mxak_standard_sysk;
    bsurrogate             := domrec.dom_surrogate;
    bentrytype             := cak_etable;
    bseqno                 := cak_init_linkage;
    bsegmentid             := cak00_public_segment_id;
    bcolumn[2]             := @bcolumn[3];
    bcolumn[2]^            := domrec.dom_colinfo;
    bfirstindex            := 2;
    blastindex             := 2;
    btablekind             := tablekind;
    btreeid.fileTabId_gg00 := bsurrogate;
    bextcolindex[ 1 ]      := 0;
    bcolumnExtension       := NIL;
    bcolumnSplitIdx        := csp_maxint2;
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak44moveSchemaName(VAR acv : tak_all_command_glob;
            VAR a41v       : tak40_show_glob;
            VAR schemaName : tsp00_KnlIdentifier);
 
VAR
      ix  : integer;
      aux : tsp00_KnlIdentifier;
 
BEGIN
aux := schemaName;
ix  := sizeof(schemaName);
WHILE schemaName[ix] = chr(0) DO
    BEGIN
    aux[ix] := bsp_c1;
    ix      := ix - a01char_size;
    END;
(*ENDWHILE*) 
a40move (acv, a41v, @aux, sizeof (aux))
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak44put_domain  (
            VAR acv   : tak_all_command_glob;
            VAR a41v  : tak40_show_glob;
            VAR owner : tsp00_KnlIdentifier);
 
BEGIN
WITH acv, a41v  DO
    IF  (a_returncode = 0) AND
        (a_ex_kind <> only_parsing)
    THEN
        BEGIN
        a40move (acv, a41v, @owner, sizeof (owner));
        a40column_description (acv, a41v,
              twithkey, a4dombuf^.sdomain.dom_colinfo, false);
        a40move          (acv, a41v, @a4dombuf^.sdomain.dom_type_uid,
              sizeof (a4dombuf^.sdomain.dom_type_uid));
        a40put_date_time (acv, a41v, a4dombuf^.sdomain.dom_date,
              true, false);
        a40put_date_time (acv, a41v, a4dombuf^.sdomain.dom_time,
              false, false);
        a47range_default (acv, a41v,
              a4dombuf^.sdomain.dom_colinfo);
        IF  a4dombuf^.sdomain.dom_colinfo.cdatatyp <> dudt
        THEN
            a40long_descriptor (acv, a41v,
                  a4dombuf^.sdomain.dom_surrogate, 1)
        ELSE
            BEGIN
            a40move (acv, a41v, NIL, 0);
            a40move (acv, a41v, NIL, 0)
            END;
        (*ENDIF*) 
        a40comment_descriptor (acv, a41v, ctcomment in
              a4dombuf^.sdomain.dom_colinfo.ccolpropset,
              a4dombuf^.sdomain.dom_surrogate, 1, cm_domain)
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak44put_synonym  (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      is_synonym      : boolean;
      is_public_syn   : boolean;
      is_sequence_syn : boolean;
      skipSynonym     : boolean;
      owner           : tsp00_KnlIdentifier;
      schema          : tsp00_KnlIdentifier;
      tablename       : tsp00_KnlIdentifier;
 
BEGIN
WITH acv, a41v  DO
    IF  (a_returncode = 0) AND
        (a_ex_kind <> only_parsing         )
    THEN
        BEGIN
        skipSynonym   := false;
        is_public_syn := a4next_owner = a01_i_public;
        (* synonym owner -> result row *)
        IF  NOT is_public_syn
        THEN
            a40move (acv, a41v,
                  @a4next_owner, sizeof (a4next_owner))
        ELSE
            BEGIN
            a06determine_username (acv,
                  a4usertab_buf^.ssynonym.syn_owner, owner);
            IF  (a_session_sqlmode <> sqlm_oracle) AND (owner = a01_i_sys) AND (a_curr_user_name <> a01_i_sys)
            THEN (* show oracle system synonyms in sqlmode oracle only *)
                skipSynonym := true
            ELSE
                a40move (acv, a41v, @owner, sizeof (owner));
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        (* synonym name -> result row *)
        IF  NOT skipSynonym
        THEN
            BEGIN
            a40move (acv, a41v, @a4synname, sizeof (a4synname));
            (* public attribute -> result row *)
            a40move_const (acv, a41v, @a40yes_no[is_public_syn], 3);
            (* table owner -> result row *)
            IF  a4p_arr.pbasep^.syskey.sentrytyp = cak_esequence
            THEN
                BEGIN
                is_sequence_syn := true;
                a06determine_username (acv,
                      a4p_arr.pbasep^.ssequence.seq_owner, owner);
                a103GetSchemaName (acv, a4p_arr.pbasep^.ssequence.seq_schema, schema);
                a40move (acv, a41v, @schema, sizeof (schema));
                a40move (acv, a41v,
                      @a4p_arr.pbasep^.ssequence.seq_name,
                      sizeof (a4p_arr.pbasep^.ssequence.seq_name));
                a40move (acv, a41v, @owner, sizeof (owner));
                END
            ELSE
                BEGIN
                is_sequence_syn := false;
                is_synonym      := a4is_synonym;
                a4is_synonym    := false;
                a40table_column_to_shbuf (acv, a41v, a4p_arr.pbasep, -1, true);
                a4is_synonym := is_synonym;
                END;
            (*ENDIF*) 
            IF  a4usertab_buf^.ssynonym.syn_tableid <> cgg_zero_id
            THEN
                IF  is_sequence_syn
                THEN
                    a40move_const (acv, a41v, @a01kw[cak_i_sequence],
                          sizeof (tsp00_C8))
                ELSE
                    BEGIN
                    a4is_systable := false;
                    a47table_kind (acv, a41v, a4p_arr.pbasep^.sbase)
                    END
                (*ENDIF*) 
            ELSE
                a40move (acv, a41v, NIL, 0);
            (*ENDIF*) 
            a40put_date_time (acv, a41v,
                  a4usertab_buf^.ssynonym.syn_date,
                  true, false);
            a40put_date_time (acv, a41v,
                  a4usertab_buf^.ssynonym.syn_time,
                  false, false);
            (* object id -> result row *)
            a40move (acv, a41v, @a4usertab_buf^.syskey.stableid,
                  sizeof (a4usertab_buf^.syskey.stableid));
            a40move_const   (acv, a41v, (* PTS 1109242 *)
                  @a40yes_no[a4usertab_buf^.ssynonym.syn_internal], 3);
            a40comment_descriptor (acv, a41v,
                  a4usertab_buf^.ssynonym.syncomment,
                  a4usertab_buf^.syskey.stableid,
                  1, cm_synonym);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a44constraint_into_moveobj (
            VAR acv        : tak_all_command_glob;
            base_ptr       : tak_sysbufferaddress;
            VAR tabid      : tgg00_Surrogate;
            object_type    : tak_object_type;
            constraint_id  : integer;
            tabno          : integer;
            VAR moveobj    : tsp00_MoveObj;
            moveobj_size   : tsp00_Int4;
            VAR filled_len : tsp00_Int4);
 
VAR
      is_old   : boolean;
      b_err    : tgg00_BasisError;
      bufpos   : integer;
      descpos  : integer;
      movelen  : integer;
      i        : integer;
      k        : integer;
      l        : integer;
      offset   : integer;
      ptr      : tak_sysbufferaddress;
      col_name : tsp00_KnlIdentifier;
      sysk     : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
    IF  object_type = obj_temp_table
    THEN
        BEGIN
        sysk.stableid  := base_ptr^.syskey.stableid;
        sysk.sentrytyp := cak_etempviewdesc
        END
    ELSE
        BEGIN
        sysk.stableid  := tabid;
        sysk.sentrytyp := cak_eviewdesc
        END;
    (*ENDIF*) 
    IF  object_type = obj_trigger
    THEN
        sysk.slinkage[ 1 ] := chr(255)
    ELSE
        sysk.slinkage[ 1 ] := chr(constraint_id DIV 256);
    (*ENDIF*) 
    sysk.slinkage[ 2 ] := chr (constraint_id MOD 256);
    sysk.skeylen       := mxak_standard_sysk;
    a10get_sysinfo (acv, sysk, d_release, ptr, b_err);
    IF  b_err = e_ok
    THEN
        WITH ptr^.sviewdesc DO
            BEGIN
            is_old  := vdescription[vdesc_cnt+1].vfromtabno = 0;
            bufpos  := filled_len + 1;
            descpos := cak_viewdesc_offset +
                  vdesc_cnt * mxak_vcolumndesc + 3;
            IF  base_ptr^.sbase.btablekind = tempty
            THEN
                BEGIN
                (* show constraint <domain name>, skip to *)
                (* constraint definition                  *)
                offset  := pred(vdescription[ vdesc_cnt+1 ].vfromtabno);
                descpos := descpos + offset
                END
            ELSE
                offset := 0;
            (*ENDIF*) 
            FOR i := 1 TO vdesc_cnt DO
                BEGIN
                movelen := vdescription[ i ].vfromtabno;
                IF  movelen > 0
                THEN
                    BEGIN
                    IF  i = 1
                    THEN
                        movelen := movelen - offset;
&                   ifdef trace
                    (*ENDIF*) 
                    t01int4 (ak_sem, 'vn_pos      ',
                          vdescription[ i ].vn_pos);
                    t01int4 (ak_sem, 'extcolno    ',
                          vdescription[ i ].vfromextcolno);
                    t01int4 (ak_sem, 'movelen     ', movelen);
                    t01int4 (ak_sem, 'offset      ', offset);
&                   endif
                    IF  bufpos + movelen - 1 > moveobj_size
                    THEN
                        a07_b_put_error (acv, e_too_many_mb_data, 1)
                    ELSE
                        SAPDB_PascalMove ('VAK44 ',   1,    
                              sizeof(ptr^), moveobj_size,
                              @ptr^, descpos, @moveobj, bufpos, movelen,
                              a_returncode);
                    (*ENDIF*) 
                    descpos := descpos + movelen;
                    bufpos  := bufpos  + movelen;
                    END;
                (*ENDIF*) 
                k := base_ptr^.sbase.bfirstindex;
                l := base_ptr^.sbase.blastindex;
                WHILE k <= l DO
                    WITH a103GetColumn (base_ptr^.sbase, k)^,
                         vdescription[i] DO
                        BEGIN
&                       ifdef trace
                        t01int4 (ak_sem, 'vfromextcoln',
                              vfromextcolno);
                        a061td_colinfo (a103GetColumn (base_ptr^.sbase, k)^, k);
&                       endif
                        IF  (creccolno = vfromextcolno) AND
                            (ctabno    = tabno)         AND
                            ((base_ptr^.sbase.btablekind <>
                            tdummy) OR (bufpos > 1))
                        THEN
                            BEGIN
                            a061get_colname (a103GetColumn (base_ptr^.sbase, k)^,
                                  col_name);
                            ak44colname_into_buf (acv, col_name,
                                  moveobj, moveobj_size, bufpos);
                            k := csp_maxint2;
                            END
                        ELSE
                            k := succ(k);
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDWHILE*) 
                END;
            (*ENDFOR*) 
            IF  descpos <= ptr^.b_sl
            THEN
                BEGIN
                movelen := succ(ptr^.b_sl - descpos);
                IF  bufpos + movelen - 1 > moveobj_size
                THEN
                    a07_b_put_error (acv, e_too_many_mb_data, 1)
                ELSE
                    SAPDB_PascalMove ('VAK44 ',   2,    
                          sizeof(ptr^), moveobj_size,
                          @ptr^, descpos, @moveobj, bufpos, movelen,
                          a_returncode);
                (*ENDIF*) 
                filled_len := bufpos + movelen - 1;
                IF  is_old
                THEN
                    BEGIN
                    bufpos            := filled_len + 1;
                    IF  g01unicode
                    THEN
                        BEGIN
                        moveobj[bufpos  ] := csp_unicode_mark;
                        moveobj[bufpos+1] := bsp_c1;
                        moveobj[bufpos+2] := csp_unicode_mark;
                        moveobj[bufpos+3] := 'O';
                        moveobj[bufpos+4] := csp_unicode_mark;
                        moveobj[bufpos+5] := 'R';
                        moveobj[bufpos+6] := csp_unicode_mark;
                        moveobj[bufpos+7] := bsp_c1;
                        bufpos            := bufpos + 8;
                        END
                    ELSE
                        BEGIN
                        moveobj[bufpos  ] := bsp_c1;
                        moveobj[bufpos+1] := 'O';
                        moveobj[bufpos+2] := 'R';
                        moveobj[bufpos+3] := bsp_c1;
                        bufpos            := bufpos + 4;
                        END;
                    (*ENDIF*) 
                    ak44colname_into_buf (acv, col_name,
                          moveobj, moveobj_size, bufpos);
                    IF  g01unicode
                    THEN
                        BEGIN
                        moveobj[bufpos   ] := csp_unicode_mark;
                        moveobj[bufpos+1 ] := bsp_c1;
                        moveobj[bufpos+2 ] := csp_unicode_mark;
                        moveobj[bufpos+3 ] := 'I';
                        moveobj[bufpos+4 ] := csp_unicode_mark;
                        moveobj[bufpos+5 ] := 'S';
                        moveobj[bufpos+6 ] := csp_unicode_mark;
                        moveobj[bufpos+7 ] := bsp_c1;
                        moveobj[bufpos+8 ] := csp_unicode_mark;
                        moveobj[bufpos+9 ] := 'N';
                        moveobj[bufpos+10] := csp_unicode_mark;
                        moveobj[bufpos+11] := 'U';
                        moveobj[bufpos+12] := csp_unicode_mark;
                        moveobj[bufpos+13] := 'L';
                        moveobj[bufpos+14] := csp_unicode_mark;
                        moveobj[bufpos+15] := 'L';
                        filled_len          := bufpos + 15
                        END
                    ELSE
                        BEGIN
                        moveobj[bufpos   ] := bsp_c1;
                        moveobj[bufpos+1 ] := 'I';
                        moveobj[bufpos+2 ] := 'S';
                        moveobj[bufpos+3 ] := bsp_c1;
                        moveobj[bufpos+4 ] := 'N';
                        moveobj[bufpos+5 ] := 'U';
                        moveobj[bufpos+6 ] := 'L';
                        moveobj[bufpos+7 ] := 'L';
                        filled_len          := bufpos + 7
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                filled_len := bufpos - 1
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    ELSE
        BEGIN
        a07_b_put_error (acv, b_err, 1);
        IF  a_command_kind = show_command
        THEN
            a40ignore_down_error (acv);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a44synonym_show_execute (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
BEGIN
WITH acv, a41v DO
    BEGIN
    a40get_catalog_table (acv, a41v);
    IF  a4sh_kind <> sh_all_synonyms
    THEN
        a4authname := a_curr_user_name;
    (*ENDIF*) 
    a40init_table_scan (acv, a41v,
          NOT(c_scan_temp), c_scan_private, NOT(c_scan_nonprivate),
          NOT c_scan_public, c_use_synonyms, NOT c_all_base);
    WHILE a40next_table (acv, a41v) DO
        BEGIN
        IF  a4is_synonym
        THEN
            ak44put_synonym (acv, a41v);
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    a40FinishTableScan (acv, a41v);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a44oms_versions (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
CONST
      c_is_null       = true;
      c_zero_to_undef = true;
 
VAR
      b_err          : tgg00_BasisError;
      isFirstCall    : boolean;
      emitNull       : boolean;
      page_cnt       : tsp00_Int4;
      sum_page_cnt   : tsp00_Int4;
      hashSize       : tsp00_Int4;
      versionId      : tsp00_C24;
      createDate     : tsp00_Date;
      createTime     : tsp00_Time;
      openDate       : tsp00_Date;
      openTime       : tsp00_Time;
      heapUsage      : tsp00_8ByteCounter;
      consistentView : tgg91_TransNo;
      isMarked       : boolean;
      isOpen         : boolean;
      isUnloaded     : boolean;
      versionTree    : tgg00_FileId;
      versionInvTree : tgg00_FileId;
      versionDesc    : tsp00_C512;   (* PTS 1117690 *)
 
BEGIN
a40get_catalog_table (acv, a41v);
IF  acv.a_ex_kind <> only_parsing
THEN
    BEGIN
    isFirstCall := true;
    WHILE  ak341NextVersion (acv, isFirstCall, versionId,
          createDate, createTime, openDate, openTime, consistentView, isMarked, isOpen, isUnloaded,
          heapUsage, hashSize, versionTree, versionInvTree, versionDesc) DO
        BEGIN
        a40move_const   (acv, a41v, @versionId,  sizeof(versionId));  (* PTS 1117690 *)
        a40move         (acv, a41v, @createDate, sizeof(createDate));
        a40move         (acv, a41v, @createTime, sizeof(createTime));
        a40move         (acv, a41v, @consistentView, sizeof (consistentView));
        a40move         (acv, a41v, @openDate, sizeof(openDate));
        a40move         (acv, a41v, @openTime, sizeof(openTime));
        a40move_const   (acv, a41v, @a40yes_no[isOpen], 3);
        a40move_const   (acv, a41v, @a40yes_no[isMarked], 3);
        a40move_const   (acv, a41v, @a40yes_no[isUnloaded], 3);
        a40move_counter (acv, a41v, heapUsage, NOT c_is_null, 0, NOT c_zero_to_undef);
        emitNull := true;
        IF  isUnloaded
        THEN
            BEGIN (* PTS 1112041 *)
            page_cnt := 0;
            a06get_page_cnt (acv, versionTree,
                  false, sum_page_cnt, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                a06get_page_cnt (acv, versionInvTree,
                      false, page_cnt, b_err);
                sum_page_cnt := sum_page_cnt + page_cnt;
                emitNull := false;
                a40move_i4 (acv, a41v, sum_page_cnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  emitNull
        THEN
            a40move (acv, a41v, NIL, 0);
        (*ENDIF*) 
        a40move         (acv, a41v, @versionDesc,  sizeof(versionDesc));  (* PTS 1117690 *)
        isFirstCall := false;
        END;
    (*ENDWHILE*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a44sequence_show (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
BEGIN
WITH acv, a41v DO
    BEGIN
    a40get_catalog_table (acv, a41v);
    IF  a_ex_kind <> only_parsing
    THEN
        BEGIN
        a40init_table_scan (acv, a41v, NOT (c_scan_temp), c_scan_private,
              a4sh_kind <> sh_all_sequences,
              a4sh_kind <> sh_all_sequences,
              NOT c_use_synonyms, NOT c_all_base);
        WHILE a40next_table (acv, a41v) DO
            ak44one_sequence (acv, a41v);
        (*ENDWHILE*) 
        a40FinishTableScan (acv, a41v);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak44colname_into_buf (
            VAR acv      : tak_all_command_glob;
            VAR col_name : tsp00_KnlIdentifier;
            VAR moveobj  : tsp00_MoveObj;
            moveobj_size : tsp00_Int4;
            VAR pos      : integer);
 
VAR
      is_identifier : boolean;
      move_len      : tsp00_Int4;
      ix            : integer;
 
BEGIN
IF  g01unicode
THEN
    BEGIN
    move_len := s30unilnr (@col_name, csp_unicode_blank,
          1, sizeof(col_name));
    is_identifier := a01is_identifier (col_name, move_len, acv.a_sqlmode);
    IF  pos + move_len + 4 - 4 * ord (is_identifier) - 1 > moveobj_size
    THEN
        a07_b_put_error (acv, e_too_many_mb_data, 1)
    ELSE
        IF  NOT is_identifier
        THEN
            BEGIN
            IF  pos > 2
            THEN
                is_identifier := (moveobj[pos - 1] = '"') AND
                      (moveobj[pos - 2] = csp_unicode_mark);
            (*ENDIF*) 
            IF  NOT is_identifier
            THEN
                BEGIN
                moveobj[pos  ] := csp_unicode_mark;
                moveobj[pos+1] := '"';
                pos := pos + 2;
                END;
            (*ENDIF*) 
            ix := 1;
            WHILE ix < move_len DO
                BEGIN
                moveobj[pos  ] := col_name[ix  ];
                moveobj[pos+1] := col_name[ix+1];
                IF  (col_name[ix  ] = csp_unicode_mark) AND
                    (col_name[ix+1] = '"')
                THEN
                    BEGIN
                    moveobj[pos+2] := csp_unicode_mark;
                    moveobj[pos+3] := '"';
                    pos            := pos + 4
                    END
                ELSE
                    pos := pos + 2;
                (*ENDIF*) 
                ix := ix+2
                END;
            (*ENDWHILE*) 
            IF  NOT is_identifier
            THEN
                BEGIN
                moveobj[pos  ] := csp_unicode_mark;
                moveobj[pos+1] := '"';
                pos := pos + 2
                END
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            SAPDB_PascalMove ('VAK44 ',   3,    
                  sizeof(col_name), moveobj_size,
                  @col_name, 1, @moveobj, pos, move_len,
                  acv.a_returncode);
            pos := pos + move_len;
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END
ELSE
    BEGIN
    move_len := sizeof(col_name);
    WHILE col_name[ move_len ] = bsp_c1 DO
        move_len := pred(move_len);
    (*ENDWHILE*) 
    is_identifier := a01is_identifier (col_name, move_len, acv.a_sqlmode);
    IF  pos + move_len + 2 - 2 * ord (is_identifier) - 1 > moveobj_size
    THEN
        a07_b_put_error (acv, e_too_many_mb_data, 1)
    ELSE
        IF  NOT is_identifier
        THEN
            BEGIN
            IF  pos > 1
            THEN
                is_identifier := moveobj[pos - 1] = '"';
            (*ENDIF*) 
            IF  NOT is_identifier
            THEN
                BEGIN
                moveobj[pos] := '"';
                pos := succ(pos);
                END;
            (*ENDIF*) 
            FOR ix := 1 TO move_len DO
                BEGIN
                moveobj[pos] := col_name[ix];
                IF  col_name[ix] = '"'
                THEN
                    BEGIN
                    moveobj[pos+1] := '"';
                    pos            := pos + 2
                    END
                ELSE
                    pos := pos + 1
                (*ENDIF*) 
                END;
            (*ENDFOR*) 
            IF  NOT is_identifier
            THEN
                BEGIN
                moveobj[pos] := '"';
                pos := succ(pos)
                END
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            SAPDB_PascalMove ('VAK44 ',   4,    
                  sizeof(col_name), moveobj_size,
                  @col_name, 1, @moveobj, pos, move_len,
                  acv.a_returncode);
            pos := pos + move_len;
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak44one_sequence (
            VAR acv          : tak_all_command_glob;
            VAR a41v         : tak40_show_glob);
 
VAR
      res             : tsp00_NumError;
      b_err           : tgg00_BasisError;
      resbytelen      : integer;
      seq_owner_name  : tsp00_KnlIdentifier;
      seq_schema_name : tsp00_KnlIdentifier;
      curr_data_buf  : tsp00_C20;
 
      curr_qual_buf  : RECORD
            CASE integer OF
                1:
                    (seq_id   : tgg00_Surrogate;
                    seq_info : tgg00_SeqInfo);
                2:
                    (qual_buf : tgg00_QualBuf);
                END;
            (*ENDCASE*) 
 
      mblock         : tgg00_MessBlock;
      cache_value    : tsp00_Number;
 
BEGIN
(* insert one row describing a sequence into result *)
WITH a41v, a4p_arr.pbasep^.ssequence, seq_info DO
    BEGIN
    (*--------------- sequence owner name ---------------------------*)
    a103GetSchemaName (acv, seq_schema, seq_schema_name);
    a40move           (acv, a41v, @seq_schema_name, sizeof (seq_schema_name));
    a40move     (acv, a41v, @seq_name,       sizeof (seq_name));
    a06determine_username (acv, seq_owner, seq_owner_name);
    a40move     (acv, a41v, @seq_owner_name, sizeof (seq_owner_name));
    a40move (acv, a41v, @seq_minvalue,   sizeof (seq_minvalue));
    a40move (acv, a41v, @seq_maxvalue,   sizeof (seq_maxvalue));
    a40move (acv, a41v, @seq_increment,  sizeof (seq_increment));
    a40move_const (acv, a41v, @a40yes_no[seq_cycle], 1);
    a40move_const (acv, a41v, @a40yes_no[true],      1);
    s51div (seq_cachevalue, 1, sizeof (tsp00_Number),
          seq_increment, 1, sizeof (tsp00_Number),
          cache_value, 1, sizeof (cache_value), 0,
          resbytelen, res);
    IF  res = num_ok
    THEN
        a40move (acv, a41v, @cache_value, resbytelen)
    ELSE
        a40move (acv, a41v, NIL, 0);
    (*ENDIF*) 
    (* PTS 1110096 E.Z. *)
    g01mblock_init (acv.a_transinf.tri_trans,
          m_nextval, mm_direct, mblock);
    WITH mblock DO
        BEGIN
        mb_data              := @curr_data_buf;
        mb_data_size         := sizeof (curr_data_buf);
        mb_qual              := @curr_qual_buf;
        mb_qual_size         := sizeof (curr_qual_buf);
        mb_qual^.mstack_desc := g01nil_stack_desc;
        mb_qual^.mtree       := b01niltree_id;
        mb_struct            := mbs_buf;
        mb_st                := NIL;
        mb_st_max            := 0;
        mb_st_size           := 0;
        mb_data^.mbp_reclen  := 0;
        mb_data^.mbp_keylen  := 0
        END;
    (*ENDWITH*) 
    curr_qual_buf.seq_id   := seq_surrogate;
    curr_qual_buf.seq_info := seq_info;
    mblock.mb_qual_len := sizeof (curr_qual_buf);
    a06rsend_mess_buf (acv, mblock, cak_return_req, b_err);
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1)
    ELSE
        a40move (acv, a41v, @mblock.mb_data^.mbp_buf,
              mblock.mb_data_len);
    (*ENDIF*) 
    a40put_date_time (acv, a41v, seq_date, true, false);
    a40put_date_time (acv, a41v, seq_time, false, false);
    a40move (acv, a41v, @seq_surrogate, sizeof (seq_surrogate));
    a40comment_descriptor (acv, a41v, seq_comment,
          seq_surrogate, 1, cm_sequence);
    END;
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
