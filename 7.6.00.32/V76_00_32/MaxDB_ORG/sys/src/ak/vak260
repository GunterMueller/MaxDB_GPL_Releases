.ad 8
.bm 3
.fm 2
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 5
.hm 2
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK260$
.tt 2 $$$
.TT 3 $ThomasA$AK_dialog_tools$$$$$$2000-11-21$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : AK_dialog_tools
=========
.sp
Purpose :
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a260BuildCodeSyskey (VAR CodeId : tgg00_Surrogate (* ptocConst *);
                    VAR CodeSyskey : tgg00_SysInfoKey);
 
        FUNCTION
              a260BuildDebugStack : boolean; (* PTS 1107878 *)
 
        PROCEDURE
              a260CallSystemTriggers (
                    VAR acv     : tak_all_command_glob);
 
        PROCEDURE
              a260check_priv (
                    VAR acv     : tak_all_command_glob;
                    proc_id     : tgg00_Surrogate;
                    VAR user_id : tgg00_Surrogate);
 
        FUNCTION
              a260CurrentTaskInCppDBProc : boolean;
 
        PROCEDURE
              a260DropParseIds (
                    VAR acv   : tak_all_command_glob;
                    VAR parsk : tak_parskey);
 
        PROCEDURE
              a260end_session (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a260exec_dialog (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a260get_proc (
                    VAR acv        : tak_all_command_glob;
                    VAR authname   : tsp00_KnlIdentifier;
                    VAR proc       : tsp00_KnlIdentifier;
                    VAR tree_index : integer);
 
        PROCEDURE
              a260GetDBProcOwner (
                    VAR acv          : tak_all_command_glob;
                    VAR MethodRecord : tak_methodrecord;
                    VAR OwnerId      : tgg00_Surrogate);
 
        PROCEDURE
              a260hresult_error (
                    hresult         : tsp00_Int4;
                    VAR dbproc_name : tsp00_KnlIdentifier;
                    VAR errtext     : tsp00_C64;
                    VAR e           : tgg00_BasisError);
 
        PROCEDURE
              a260internal_proc_call (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a260init;
 
        FUNCTION
              a260IsInternalDBProc (VAR MethodRec : tak_methodrecord) : boolean;
 
        FUNCTION
              a260max_output_params : integer;
 
        FUNCTION
              a260max_params : integer;
 
        FUNCTION
              a260sql_in_dbproc (
                    VAR acv            : tak_all_command_glob;
                    VAR clsid          : tsp00_C16;
                    VAR packageId      : tgg00_Surrogate) : boolean;
 
        PROCEDURE
              a260ParseIdDrop (
                    VAR acv    : tak_all_command_glob;
                    VAR parsid : tak_parsid);
 
        PROCEDURE
              a260reset_statistics;
 
        PROCEDURE
              a260session_frame_release (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a260statistics (
                    VAR external_proc_cnt : tsp00_8ByteCounter;
                    VAR internal_proc_cnt : tsp00_8ByteCounter);
 
        PROCEDURE
              a260sysdbproc_exist (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a260TransEnd (
                    VAR acv  : tak_all_command_glob;
                    messType : tgg00_MessType;
                    release  : boolean;
                    VAR e    : tgg00_BasisError);
 
        PROCEDURE
              a260trigger_call (
                    VAR acv          : tak_all_command_glob;
                    trigger_parsinfo : tak_sysbufferaddress);
 
        PROCEDURE
              a260trigger_parsinfo (
                    VAR acv         : tak_all_command_glob;
                    VAR parsinfokey : tgg00_SysInfoKey;
                    VAR proc_id     : tgg00_Surrogate);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01defaultkey      : tgg00_SysInfoKey;
              a01sysnullkey      : tgg00_SysInfoKey;
              a01_i_sysddltrigger: tsp00_KnlIdentifier;
              a01_il_b_identifier: tsp00_KnlIdentifier;
              a01_i_sysdba       : tsp00_KnlIdentifier;
              a01_i_temp         : tsp00_KnlIdentifier;
 
        FUNCTION
              a01aligned_cmd_len (len : tsp00_Int4) : tsp00_Int4;
 
        PROCEDURE
              a01setl_identifier (
                    VAR id         : tsp00_KnlIdentifier;
                    set_identifier : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
        PROCEDURE
              a05_string_literal_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    datatyp     : tsp00_DataType;
                    obj_len     : integer;
                    VAR moveobj : tsp00_C132);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06init_curr_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06get_username (
                    VAR acv        : tak_all_command_glob;
                    VAR tree_index : integer;
                    VAR username   : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06finish_curr_retpart (
                    VAR acv   : tak_all_command_glob;
                    part_kind : tsp1_part_kind;
                    arg_count : tsp00_Int2);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06reset_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
        PROCEDURE
              a06colname_retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4;
                    src_codeset : tsp00_Int2);
 
        FUNCTION
              a06_role_excluded (
                    VAR acv     : tak_all_command_glob;
                    VAR role_id : tgg00_Surrogate) : boolean;
 
        PROCEDURE
              a06a_mblock_init (
                    VAR acv         : tak_all_command_glob;
                    mtype           : tgg00_MessType;
                    m2type          : tgg00_MessType2;
                    VAR tree        : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061app_columnname (
                    VAR acv               : tak_all_command_glob;
                    VAR base_rec          : tak_baserecord;
                    VAR column            : tsp00_KnlIdentifier;
                    VAR index             : integer);
 
        PROCEDURE
              a061copy_colinfo (
                    VAR src_col : tak00_columninfo;
                    VAR dst_col : tak00_columninfo);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07ClientLayoutParam (
                    VAR acv    : tak_all_command_glob;
                    param_no   : integer;
                    param_addr : tsp00_MoveObjPtr;
                    param_len  : integer);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
        PROCEDURE
              a07const_param (
                    VAR acv    : tak_all_command_glob;
                    param_no   : integer;
                    param_addr : tsp00_MoveObjPtr;
                    param_len  : integer);
 
        PROCEDURE
              a07_const_b_put_error (
                    VAR acv    : tak_all_command_glob;
                    b_err      : tgg00_BasisError;
                    err_code   : tsp00_Int4;
                    param_addr : tsp00_MoveObjPtr;
                    const_len  : integer);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache :  VAK10;
 
        PROCEDURE
              a10add_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_cache_delete  (
                    VAR acv     : tak_all_command_glob;
                    is_rollback : boolean);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10key_del (
                    VAR acv        : tak_all_command_glob;
                    VAR syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10_key_del  (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10mblock_into_cache (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    VAR mblock   : tgg00_MessBlock;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10shrink_syntax_tree (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        PROCEDURE
              a101_ProcedureCall (
                    VAR acv           : tak_all_command_glob;
                    VAR outParamCount : integer);
 
        PROCEDURE
              a101_IncrementProcLevel(
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a101_DecrementProcLevel(
                    VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Table : VAK11;
 
        PROCEDURE
              a11glob_init (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
        PROCEDURE
              a11init_baserecord (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
      ------------------------------ 
 
        FROM
              AK_Domain : VAK12;
 
        FUNCTION
              a12dbproc_exist (
                    VAR acv        : tak_all_command_glob;
                    VAR owner      : tsp00_KnlIdentifier;
                    VAR dbproc     : tsp00_KnlIdentifier;
                    dstate         : tak_directory_state;
                    VAR method_buf : tak_sysbufferaddress) : boolean;
 
        PROCEDURE
              a12LoadFileInfo (
                    VAR acv               : tak_all_command_glob;
                    VAR dbproc_id         : tgg00_Surrogate;
                    VAR pFileName         : tsp00_Addr;
                    VAR MD5_footprint     : tsp00_C32);
 
        FUNCTION
              a12SystemTriggerExists (VAR acv : tak_all_command_glob;
                    VAR schema     : tsp00_KnlIdentifier;
                    VAR dbproc     : tsp00_KnlIdentifier;
                    dstate         : tak_directory_state;
                    VAR method_buf : tak_sysbufferaddress) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Trigger : VAK262;
 
        PROCEDURE
              a262Call (
                    VAR acv : tak_all_command_glob;
                    p      : tak_sysbufferaddress;
                    data_p : tsp00_MoveObjPtr);
 
        PROCEDURE
              a262DropParseIds (
                    VAR acv    : tak_all_command_glob;
                    VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              a262LoadCode (
                    VAR acv     : tak_all_command_glob;
                    VAR CodeId  : tgg00_Surrogate;
                    Linkage     : tsp00_C2;
                    VAR p       : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              Stream_Handle_Functions : VAK263;
 
        PROCEDURE
              ak263CheckHandle (
                    VAR acv      : tak_all_command_glob;
                    VAR st_ix    : tsp00_Int4;
                    phandle      : tsp00_MoveObjPtr;
                    handleLen    : integer;
                    isABAP       : boolean;
                    VAR e        : tgg00_BasisError;
                    paramNo      : tsp00_Int4;
                    methodName   : tsp00_KnlIdentifier);
 
        PROCEDURE
              ak263NumberToInt8 (
                    pNumber     : tsp00_MoveObjPtr;
                    inOutLength : integer;
                    VAR result  : tsp00_8ByteCounter;
                    VAR e       : tsp00_NumError);
 
        PROCEDURE
              ak263NumberToUInt8 (
                    pNumber     : tsp00_MoveObjPtr;
                    inOutLength : integer;
                    VAR result  : tsp00_8ByteCounter;
                    VAR e       : tsp00_NumError);
 
        PROCEDURE
              ak263Int8ToNumber (
                    source      : tsp00_8ByteCounter;
                    pNumber     : tsp00_MoveObjPtr;
                    inOutLength : integer;
                    VAR e       : tsp00_NumError);
 
        PROCEDURE
              ak263UInt8ToNumber (
                    source      : tsp00_8ByteCounter;
                    pNumber     : tsp00_MoveObjPtr;
                    inOutLength : integer;
                    VAR e       : tsp00_NumError);
 
        PROCEDURE
              ak263WriteConversionError (
                    VAR acv          : tak_all_command_glob;
                    phandle          : tsp00_MoveObjPtr;
                    paramNo          : integer;
                    tableid          : tsp00_Int4;
                    VAR methodName   : tsp00_KnlIdentifier);
 
        PROCEDURE
              ak263WriteTranslationError (
                    VAR acv          : tak_all_command_glob;
                    VAR methodName   : tsp00_KnlIdentifier;
                    paramNo          : integer;
                    errorOffset      : integer;
                    errorChar        : integer);
 
      ------------------------------ 
 
        FROM
              Kernel_Sink : VAK34;
 
        PROCEDURE
              a34outstanding_packet (
                    VAR acv : tak_all_command_glob;
                    VAR e : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Kernel_Sink_1 : VAK341;
 
        PROCEDURE
              ak341ReleaseEmergencyAllocator(taskId : tsp00_TaskId);
&       ifdef OMSTST
 
        FUNCTION
              ak341NormalOmsTerminateHandling : boolean;
&       endif
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51RestoreUserContext (
                    VAR acv          : tak_all_command_glob;
                    VAR pOldContext  : tsp00_Addr);
 
        PROCEDURE
              a51switch_user (VAR acv : tak_all_command_glob;
                    VAR new_user_name  : tsp00_KnlIdentifier;
                    VAR pOldContext   : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              AK_Lock_Commit_Rollback : VAK52;
 
        PROCEDURE
              a52_ex_commit_rollback (
                    VAR acv        : tak_all_command_glob;
                    m_type         : tgg00_MessType;
                    n_rel          : boolean;
                    normal_release : boolean);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK54;
 
        PROCEDURE
              a54_dml_init (
                    VAR acv   : tak_all_command_glob;
                    VAR dmli  : tak_dml_info;
                    in_union  : boolean);
 
        PROCEDURE
              a54_dml_finalize (
                    VAR dmli         : tak_dml_info;
                    VAR TransContext : tgg00_TransContext);
 
        PROCEDURE
              a54_fixedpos (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a54_get_pparsp_pinfop (
                    VAR acv   : tak_all_command_glob;
                    VAR sparr : tak_syspointerarr;
                    mtype     : tgg00_MessType);
 
        PROCEDURE
              a54_last_part (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    last_pars_part : boolean);
 
      ------------------------------ 
 
        FROM
              DML_Parts : VAK55;
 
        PROCEDURE
              a55_found_one_value (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR dfa  : tak_dfarr);
 
      ------------------------------ 
 
        FROM
              Select_List : VAK61;
 
        PROCEDURE
              a61_p_short_info (
                    VAR acv    : tak_all_command_glob;
                    VAR sparr  : tak_syspointerarr;
                    VAR colinf : tak00_columninfo;
                    i          : integer;
                    fix_bufpos : integer);
 
      ------------------------------ 
 
        FROM
              Resultname_handling : VAK663;
 
        PROCEDURE
              a663_drop_parsid (
                    VAR acv     : tak_all_command_glob;
                    VAR p       : tak_parsid;
                    VAR del_cnt : integer);
 
      ------------------------------ 
 
        FROM
              Execute_Where_Part : VAK65;
 
        PROCEDURE
              a65_val_expr (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    VAR colin  : tak00_scolinf;
                    first_node : integer);
 
      ------------------------------ 
 
        FROM
              Const_Expression : VAK651;
 
        PROCEDURE
              a651value_calculate (
                    VAR acv  : tak_all_command_glob;
                    st_begin : integer;
                    st_end   : integer;
                    byte_str : boolean;
                    like     : boolean;
                    iolen    : tsp00_Int2;
                    err_pos  : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Deal-With-User-Commands : VAK92;
 
        PROCEDURE
              a92_add_pcount (
                    VAR acv  : tak_all_command_glob;
                    pcount   : tsp00_C3;
                    parskind : tgg00_MessType);
 
        PROCEDURE
              a92find_return_part (
                    VAR acv      : tak_all_command_glob;
                    part_kind    : tsp1_part_kind;
                    VAR part_ptr : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              KB_trans_state : vkb50;
 
        PROCEDURE
              k50StartDbProcedure (VAR t : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              KB_get : VKB71;
 
        PROCEDURE
              k71get_operand (
                    VAR sel             : tgg00_SelectFieldsParam;
                    check_spec_null     : boolean;
                    VAR operand_addr    : tsp00_MoveObjPtr;
                    VAR len             : integer;
                    VAR e               : tgg00_BasisError);
 
        PROCEDURE
              k71num_err_to_b_err (
                    num_err : tsp00_NumError;
                    VAR e : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1  : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code          : tgg04_CodeGlobals;
              g01glob          : tgg00_KernelGlobals;
              g01unicode       : boolean;
 
        PROCEDURE
              g01datapart_init (
                    VAR mblock    : tgg00_MessBlock;
                    datapart_ptr  : tgg00_DataPartPtr;
                    datapart_size : tsp00_Int4);
 
        PROCEDURE
              g01mblock_init (
                    VAR source_trans : tgg00_TransContext;
                    mess_type  : tgg00_MessType;
                    mess2_type : tgg00_MessType2;
                    VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              g01optextmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8 (* ptocSynonym const char* *);
                    msg_text  : tsp00_C40(* ptocSynonym const char* *));
 
        PROCEDURE
              g01stack_init (
                    VAR mblock : tgg00_MessBlock;
                    stack_ptr  : tgg00_StackListPtr;
                    stack_size : tsp00_Int4;
                    qual_ptr   : tgg00_QualBufPtr;
                    qual_size  : tsp00_Int4);
              (* PTS 1107617 E.Z. *)
 
        FUNCTION
              g01trigger : boolean;
 
        PROCEDURE
              g01unioptextmsg (
                    msg_enc   : tsp00_Int4;
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C80);
 
      ------------------------------ 
 
        FROM
              Regions_and_Longwaits : VGG08;
 
        VAR
              g08dcom  : tsp00_RegionId;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedUnicodeFill (
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2 );
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedOverlappingMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17hexto_line (
                    c          : char;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_C80);
 
        PROCEDURE
              g17basis_err_to_line (
                    b_err      : tgg00_BasisError;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_C80);
 
      ------------------------------ 
 
        FROM
              GG_allocator_interface : VGG941;
 
        FUNCTION
              gg941Allocate(
                    VAR TransContext : tgg00_TransContext;
                    wantedBytes : integer) : tsp00_MoveObjPtr;
 
        PROCEDURE
              gg941Deallocate(
                    VAR TransContext : tgg00_TransContext;
                    VAR p : tsp00_MoveObjPtr);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20swap_int4 (
                    VAR val        : tsp00_Int4;
                    source_swap    : tsp00_SwapKind;
                    destin_swap    : tsp00_SwapKind);
 
      ------------------------------ 
 
        FROM
              Pointer-Arithmetik : VSP35;
 
        FUNCTION
              s35inc_st_ptocm (
                    addr : tgg00_StEntryAddr;
                    pos : tsp00_Int4) : tgg00_StEntryAddr;
 
        FUNCTION
              s35ge_bufaddr_ptocm (
                    addr1 : tgg00_StEntryAddr;
                    addr2 : tgg00_StEntryAddr) : boolean;
 
      ------------------------------ 
 
        FROM
              GET-Conversions : VSP40;
 
        PROCEDURE
              s40gsint (
                    VAR buf  : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    len      : integer;
                    VAR dest : tsp00_Int2;
                    VAR res  : tsp00_NumError);
 
        PROCEDURE
              s40gsuns (
                    VAR buf  : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    len      : integer;
                    VAR dest : tsp00_Int2;
                    VAR res  : tsp00_NumError);
 
        PROCEDURE
              s40glint (
                    VAR buf  : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    len      : integer;
                    VAR dest : tsp00_Int4;
                    VAR res  : tsp00_NumError);
 
        PROCEDURE
              s40gluns (
                    VAR buf  : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    len      : integer;
                    VAR dest : tsp00_Int4;
                    VAR res  : tsp00_NumError);
 
        PROCEDURE
              s40gsrel (
                    VAR buf  : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    len      : integer;
                    VAR dest : tsp00_Shortreal;
                    VAR res  : tsp00_NumError);
 
        PROCEDURE
              s40glrel (
                    VAR buf  : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    len      : integer;
                    VAR dest : tsp00_Longreal;
                    VAR res  : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              PUT-Conversions : VSP41;
 
        PROCEDURE
              s41plint (
                    VAR buf : tsp00_MoveObj;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
        PROCEDURE
              s41plrel (
                    VAR buf : tsp00_MoveObj;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Longreal;
                    VAR res : tsp00_NumError);
 
        PROCEDURE
              s41psuns (
                    VAR buf : tsp00_MoveObj;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int2;
                    VAR res : tsp00_NumError);
 
        PROCEDURE
              s41pluns (
                    VAR buf : tsp00_MoveObj;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
              (* PTS 1107617 E.Z. *)
 
      ------------------------------ 
 
        FROM
              Number-Arithmetic : VSP51;
 
        PROCEDURE
              s51kroun (
                    VAR source     : tsp00_MoveObj;
                    spos           : tsp00_Int4;
                    slen           : integer;
                    VAR result     : tsp00_MoveObj;
                    respos         : tsp00_Int4;
                    reslen         : integer;
                    resfrac        : integer;
                    VAR resbytelen : integer;
                    VAR ret        : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80: VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vbegexcl (
                    pid     : tsp00_TaskId;
                    region  : tsp00_RegionId);
 
        PROCEDURE
              vendexcl (
                    pid     : tsp00_TaskId;
                    region  : tsp00_RegionId);
 
        PROCEDURE
              vmfree (p        : tsp1_packet_ptr);
 
        PROCEDURE
              vdcom_dbproc (VAR cdp : tsp_dcom_dispatch_parms);
 
        PROCEDURE
              vdcom_get_dispaddr (VAR gip : tsp_dcom_co_create_instance_parms );
 
        PROCEDURE
              vdcom_co_get_classobject (VAR cip : tsp_dcom_co_create_instance_parms );
 
        PROCEDURE
              vdcom_create_instance (VAR cip : tsp_dcom_co_create_instance_parms );
 
        PROCEDURE
              vdcom_iid_ilivecachespec ( VAR iid : tsp00_C16 );
 
        PROCEDURE
              vdcom_release_instance (VAR rp : tsp_dcom_release_instance_parms );
 
        PROCEDURE
              vdcom_trans_end (VAR cdp : tsp_dcom_dispatch_parms);
 
        FUNCTION
              vGetAcvPtrFromCurrentTask : tak_acv_address;
&       ifdef trace
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01addr (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    bufaddr  : tsp00_MoveObjPtr);
 
        PROCEDURE
              t01packet (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname;
                    packet_ptr : tsp1_packet_ptr);
 
        PROCEDURE
              t01sname (debug : tgg00_Debug; nam : tsp00_Sname);
 
        PROCEDURE
              t01lidentifier (
                    debug      : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR m         : tgg00_MessBlock);
 
        PROCEDURE
              t01moveobj (
                    debug    : tgg00_Debug;
                    VAR buf  : tsp00_MoveObj;
                    startpos : tsp00_Int4;
                    endpos   : tsp00_Int4);
 
        PROCEDURE
              t01int4 (
                    layer : tgg00_Debug;
                    nam : tsp00_Sname;
                    int : tsp00_Int4);
 
        PROCEDURE
              t01p2int4 (
                    debug : tgg00_Debug;
                    nam_1 : tsp00_Sname (*ptocSynonym const char**);
                    int_1 : tsp00_Int4;
                    nam_2 : tsp00_Sname (*ptocSynonym const char**);
                    int_2 : tsp00_Int4);
 
        PROCEDURE
              t01stackentry (
                    debug          : tgg00_Debug;
                    VAR st         : tgg00_StackEntry;
                    entry_index    : integer);
 
        PROCEDURE
              t01surrogate (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname (*ptocSynonym const char**);
                    VAR tabid : tgg00_Surrogate);
&       endif
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              a05_string_literal_get;
 
              tsp00_MoveObj tsp00_C132
 
        FUNCTION
              gg941Allocate;
 
              tsp00_Addr tsp00_MoveObjPtr
 
        PROCEDURE
              gg941Allocate;
 
              tsp00_Addr tsp00_MoveObjPtr
 
        PROCEDURE
              gg941Deallocate;
 
              tsp00_Addr tsp00_MoveObjPtr
 
        PROCEDURE
              g17hexto_line;
 
              tsp00_Line tsp00_C80
 
        PROCEDURE
              g17basis_err_to_line;
 
              tsp00_Line tsp00_C80
 
        FUNCTION
              s35ge_bufaddr_ptocm;
 
              tsp00_Addr tgg00_StEntryAddr
 
        PROCEDURE
              vmfree;
 
              tsp00_ObjAddr tsp1_packet_ptr
 
        PROCEDURE
              t01addr;
 
              tsp00_BufAddr tsp00_MoveObjPtr
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ThomasA
.sp
.cp 3
Created : 1989-08-29
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-11-21
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.sp 4
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_in_union             = true;
      c_factory_found        = 1;
      c_is_trigger           = true;
      c_scan_roles           = true;
      c_max_out_params       = 64;
      c_monitoring           = true;
      c_release              = true;
      c_normal_release       = true;
      c_user_defined_hresult = -1;
      c_terminated_hresult   = -2;
      c_is_rollback          = true;
      c_is_curr_user_id      = true;
      sw_none                = 0;
      sw_i2                  = 1;
      sw_i4                  = 2;
      sw_i8                  = 3;
      sw_r4                  = 4;
      sw_r8                  = 5;
 
TYPE
 
      tmblock_ptr = RECORD
            CASE boolean OF
                true :
                    (mbl : tgg00_MessBlockPtr);
                false :
                    (mobj : tsp00_MoveObjPtr);
                END;
            (*ENDCASE*) 
 
      t_MoveObjPtrPtr = ^tsp00_MoveObjPtr;
 
      tcreate_inst_params = RECORD
            coclsid        : tsp00_C16;
            iid            : tsp00_C16;
            surrogate      : tgg00_Surrogate;
            packageId      : tgg00_Surrogate;
            dispid         : tsp00_Int4;
            debug          : tak_debug_mode;
            wait_for_checkp: boolean; (* 1102637, T.A. 1999-05-10 *)
            with_commit    : boolean;
            filler1        : tsp00_Int2;
            inout_offset   : tsp00_Int4;
            out_length     : tsp00_Int4;
            dbproc_name    : tsp00_KnlIdentifier;
            debug_location : tsp00_C132;
      END;
 
 
      tcreate_param = RECORD
            coclsid        : tsp00_C16;
            iid            : tsp00_C16;
            debug          : tak_debug_mode;
            debug_location : tsp00_C132;
      END;
 
 
      tout_param = RECORD
            op_val          : tak_dbproc_stack_param;
            op_offset       : tsp00_Int4;
            op_vt           : tsp00_Int2;
            op_datatype     : tsp00_C1;
            op_io_len       : tsp00_Int2;
            op_cpp_len      : tsp00_Int2;
            op_translateIdx : tsp00_Int2;
            op_paramNo      : tsp00_Int2;
            op_swapIdx      : integer;
      END;
 
      tout_param_stack = ARRAY[1..c_max_out_params] OF tout_param;
      tak260ParamNameInfo = ARRAY[1..cak_max_param_index] OF integer;
 
VAR
      ak260main_exists       : boolean;
      ak260ext_proc_call_cnt : tsp00_Int4;
      ak260int_proc_call_cnt : tsp00_Int4;
 
 
(*------------------------------*) 
 
FUNCTION
      ak260Allocate (
            VAR acv : tak_all_command_glob;
            size    : tsp00_Int4;
            ptrAddr : t_MoveObjPtrPtr) : boolean;
 
BEGIN
ptrAddr^ := gg941Allocate (acv.a_transinf.tri_trans, size);
IF  ptrAddr^<> NIL
THEN
    ak260Allocate := true
ELSE
    BEGIN
    ak260Allocate := false;
    a07_b_put_error (acv, e_no_more_memory, 1)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260CallSystemTriggers (
            VAR acv     : tak_all_command_glob);
 
VAR
      dummyCnt       : integer;
      e              : tgg00_BasisError;
      ix             : integer;
      p              : tak_sysbufferaddress;
      pCode          : tak_sysbufferaddress;
      mblock_ptr     : tak_sysbufferaddress;
      pMethodInfo    : tak_sysbufferaddress;
      pOldContext    : tsp00_Addr;
      sysk           : tgg00_SysInfoKey;
      CodeSyskey     : tgg00_SysInfoKey;
      pOutPacket     : tsp1_packet_ptr;
      packetHeader   : tsp1_packet_header;
      segmentHeader  : tsp1_segment_header;
      cmdSegmHeader  : tsp1_segment_header;
      pReturnSegm    : tsp1_segment_ptr;
      owner          : tsp00_KnlIdentifier;
 
BEGIN
acv.a_localCacheUsageOnly := true;
a10_cache_delete (acv, NOT c_is_rollback);
sysk             := a01defaultkey;
sysk.sentrytyp   := cak_eusertab;
sysk.slinkage[1] := chr(128);
ix               := 0;
REPEAT
    ix := ix + 1;
    a10get_sysinfo (acv, sysk, d_fix, p, e);
    IF  e = e_ok
    THEN
        BEGIN
        IF  ix > p^.susertab.usertabcount
        THEN
            IF  NOT p^.susertab.usertabnext_exist
            THEN
                e := e_no_next_record
            ELSE
                BEGIN
                ix := 0;
                a06inc_linkage (sysk.slinkage)
                END
            (*ENDIF*) 
        ELSE
            IF  NOT p^.susertab.usertabdef[ix].ut_empty
            THEN
                BEGIN
                a06a_mblock_init (acv, m_delete, mm_file, b01niltree_id);
                acv.a_mblock.mb_qual^.mtree.fileTabId_gg00 := p^.susertab.usertabdef[ix].ut_surrogate;
                a262LoadCode (acv, p^.susertab.usertabdef[ix].ut_surrogate, cak_init_linkage, pCode);
                IF  pCode <> NIL
                THEN
                    BEGIN
                    a260BuildCodeSyskey (p^.susertab.usertabdef[ix].ut_surrogate, CodeSyskey);
                    a10mblock_into_cache (acv, CodeSyskey,
                          pCode^.smessblock.mbr_mess_block, d_release, mblock_ptr, e);
                    a10rel_sysinfo (pCode);
                    IF  e = e_ok
                    THEN
                        a10add_sysinfo (acv, mblock_ptr, e);
                    (*ENDIF*) 
                    CodeSyskey.sentrytyp := cak_emethodinfo;
                    CodeSyskey.slinkage  := cak_init_linkage;
                    a10get_sysinfo (acv, CodeSyskey, d_release, pMethodInfo, e);
                    IF  e = e_ok
                    THEN
                        BEGIN
                        a06determine_username (acv, pMethodInfo^.smethodinfo.mei_owner, owner);
                        a51switch_user (acv, owner, pOldContext);
                        IF  acv.a_returncode = 0
                        THEN
                            BEGIN
                            acv.a_in_ddl_trigger := true;
                            acv.a_dbproc_level   := acv.a_dbproc_level + 1; (* PTS 1133300 TA 2005-01-11 *)
                            a101_IncrementProcLevel (acv);
                            packetHeader         := acv.a_out_packet^.sp1_header;
                            pOutPacket           := acv.a_out_packet;
                            segmentHeader        := acv.a_out_packet^.sp1_segm.sp1s_segm_header;
                            cmdSegmHeader        := acv.a_cmd_segment_header;
                            pReturnSegm          := acv.a_return_segm;
                            IF  e = e_ok
                            THEN
                                BEGIN
                                g01optextmsg (sp3p_console, sp3m_info, csp3_a260_system_trigger,
                                      csp3_n_trigger, 'system trigger started ...              ');
                                a101_ProcedureCall (acv, dummyCnt);
                                g01optextmsg (sp3p_console, sp3m_info, csp3_a260_system_trigger,
                                      csp3_n_trigger, 'system trigger completed                ');
                                END;
                            (*ENDIF*) 
                            acv.a_out_packet^.sp1_header                := packetHeader;
                            acv.a_out_packet                            := pOutPacket;
                            acv.a_out_packet^.sp1_segm.sp1s_segm_header := segmentHeader;
                            acv.a_cmd_segment_header                    := cmdSegmHeader;
                            acv.a_return_segm                           := pReturnSegm;
                            acv.a_dbproc_level   := acv.a_dbproc_level - 1; (* PTS 1133300 TA 2005-01-11 *)
                            a101_DecrementProcLevel (acv);
                            acv.a_in_ddl_trigger := false;
                            a51RestoreUserContext (acv, pOldContext);
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    e := e_sysinfo_not_found;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        IF  (e = e_sysinfo_not_found) AND
            (sysk.slinkage[2] = a01defaultkey.slinkage[2])
        THEN
            e := e_no_next_record;
        (*ENDIF*) 
    (*ENDIF*) 
UNTIL
    (e <> e_ok) OR (acv.a_returncode <> 0);
(*ENDREPEAT*) 
IF  e <> e_no_next_record
THEN
    a07_b_put_error (acv, e, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260check_priv (
            VAR acv     : tak_all_command_glob;
            proc_id     : tgg00_Surrogate;
            VAR user_id : tgg00_Surrogate);
 
VAR
      found : boolean;
 
BEGIN
ak260check_priv (acv, c_scan_roles, proc_id, user_id, found);
IF  NOT found
THEN
    a07_b_put_error (acv, e_unknown_procedure_name, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a260CurrentTaskInCppDBProc : boolean;
 
VAR
      pAcv : tak_acv_address;
 
BEGIN
pAcv := vGetAcvPtrFromCurrentTask;
IF  pAcv <> NIL
THEN
    a260CurrentTaskInCppDBProc := pAcv^.a_isInCppDBProcedure
ELSE
    a260CurrentTaskInCppDBProc := false;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260DropParseIds (
            VAR acv   : tak_all_command_glob;
            VAR parsk : tak_parskey);
 
VAR
      e          : tgg00_BasisError;
      p          : tak_sysbufferaddress;
      CodeId     : tgg00_Surrogate;
      CodeSyskey : tgg00_SysInfoKey;
 
BEGIN
CodeId[1] := cak_tempinfo_byte;
SAPDB_PascalForcedMove (sizeof(parsk), sizeof(CodeId),
      @parsk, 1, @CodeId, 2, mxak_parskey);
CodeId[1+mxak_parskey+1] := bsp_c1;
a260BuildCodeSyskey (CodeId, CodeSyskey);
a10get_sysinfo (acv, CodeSyskey, d_fix, p, e);
IF  e = e_ok
THEN
    a262DropParseIds (acv, p^.smessblock.mbr_mess_block);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260check_priv (
            VAR acv     : tak_all_command_glob;
            scan_roles  : boolean;
            proc_id     : tgg00_Surrogate;
            VAR user_id : tgg00_Surrogate;
            VAR found   : boolean);
 
VAR
      b_err : tgg00_BasisError;
      buf   : tak_sysbufferaddress;
      sysk  : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
    sysk.stableid  := proc_id;
    sysk.sentrytyp := cak_eprocpriv;
    sysk.slinkage  := cak_init_linkage;
    sysk.suserid   := user_id;
    sysk.skeylen   := mxak_standard_sysk + SURROGATE_MXGG00;
    a10get_sysinfo (acv, sysk, d_release, buf, b_err);
    IF  b_err = e_sysinfo_not_found
    THEN
        BEGIN
        (* PTS 1106186 E.Z. *)
        sysk.suserid := cak_public_id;
        a10get_sysinfo (acv, sysk, d_release, buf, b_err)
        END;
&   ifdef trace
    (*ENDIF*) 
    t01surrogate (ak_sem, 'curr_user_id', acv.a_curr_user_id);
    t01surrogate (ak_sem, 'proc_user_id', acv.a_proc_userid);
    t01int4      (ak_sem, 'dbproc_level', acv.a_dbproc_level);
&   endif
    IF  (b_err = e_sysinfo_not_found)                  AND
        (acv.a_dbproc_level + acv.a_trigger_level > 0) AND
        (acv.a_curr_user_id <> acv.a_proc_userid)
    THEN
        BEGIN
        (* this is a procedure call inside a procedure call. Check, if the owner of the *)
        (* calling procedure has the grant option for the called procedure              *)
        sysk.sentrytyp := cak_emethodinfo;
        sysk.skeylen   := mxak_standard_sysk;
        a10get_sysinfo (acv, sysk, d_release, buf, b_err);
        IF  b_err = e_ok
        THEN
            IF  buf^.smethodinfo.mei_owner <> acv.a_proc_userid
            THEN
                b_err := e_sysinfo_not_found;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    found := b_err = e_ok;
    IF  NOT found
    THEN
        IF  b_err <> e_sysinfo_not_found
        THEN
            a07_b_put_error (acv, b_err, 1)
        ELSE
            IF  scan_roles
            THEN
                ak260check_role_privileges (acv, proc_id, user_id, c_is_curr_user_id, found)
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260check_role_privileges (
            VAR acv          : tak_all_command_glob;
            VAR proc_id      : tgg00_Surrogate;
            role_id          : tgg00_Surrogate;
            roleIsCurrUserId : boolean;
            VAR found        : boolean);
 
VAR
      b_err       : tgg00_BasisError;
      ix          : integer;
      roletab_ptr : tak_sysbufferaddress;
      sysk        : tgg00_SysInfoKey;
 
BEGIN
found := false;
IF  acv.a_role_info in [role_all, role_except]
THEN
    BEGIN
    sysk           := a01defaultkey;
    sysk.sauthid   := role_id;
    sysk.sentrytyp := cak_eroletab;
    REPEAT
        a10get_sysinfo (acv, sysk, d_fix, roletab_ptr, b_err);
        IF  b_err = e_ok
        THEN
            WITH roletab_ptr^.susertab DO
                BEGIN
                ix := 1;
                WHILE (ix <= usertabcount) AND NOT found DO
                    WITH usertabdef[ix] DO
                        BEGIN
                        IF  NOT ut_empty
                        THEN
                            IF  NOT a06_role_excluded (acv, ut_surrogate)
                            THEN
                                BEGIN
                                ak260check_priv (acv, NOT c_scan_roles,
                                      proc_id, ut_surrogate, found);
                                IF  NOT found
                                THEN
                                    ak260check_role_privileges (acv, proc_id,
                                          ut_surrogate, NOT c_is_curr_user_id, found)
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        ix := ix + 1;
                        END;
                    (*ENDWITH*) 
                (*ENDWHILE*) 
                IF  NOT found AND
                    roletab_ptr^.susertab.usertabnext_exist
                THEN
                    a06inc_linkage (sysk.slinkage)
                ELSE
                    b_err := e_sysinfo_not_found
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  (b_err = e_sysinfo_not_found  ) AND
            (sysk.sauthid <> cak_public_id) AND
            roleIsCurrUserId                AND
            NOT found
        THEN
            BEGIN
            b_err         := e_ok;
            sysk.sauthid  := cak_public_id;
            sysk.slinkage := cak_init_linkage
            END;
        (*ENDIF*) 
    UNTIL
        b_err <> e_ok;
    (*ENDREPEAT*) 
    IF  b_err <> e_sysinfo_not_found
    THEN
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
    END
ELSE
    IF  roleIsCurrUserId AND (acv.a_role_ptr  <> NIL)
    THEN
        BEGIN
        ix := 1;
        WHILE (ix <= acv.a_role_ptr^.rctxt_cnt) AND NOT found DO
            BEGIN
            ak260check_priv (acv, NOT c_scan_roles, proc_id, acv.a_role_ptr^.rctxt_roles[ix], found);
            IF  NOT found
            THEN
                ak260check_role_privileges (acv, proc_id,
                      acv.a_role_ptr^.rctxt_roles[ix], NOT c_is_curr_user_id, found);
            (*ENDIF*) 
            ix := ix + 1
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a260max_output_params : integer;
 
BEGIN
a260max_output_params := c_max_out_params
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260InitAllocatorMonitorInfo (VAR info : tak_AllocatorMonitorInfo);
 
BEGIN
info.ami_MallocMin := csp_maxint4;
info.ami_MallocMax := 0;
info.ami_MallocSum := 0;
info.ami_MallocCnt := 0;
info.ami_FreeMin   := csp_maxint4;
info.ami_FreeMax   := 0;
info.ami_FreeSum   := 0;
info.ami_FreeCnt   := 0;
END;
 
(*------------------------------*) 
 
FUNCTION
      a260max_params : integer;
 
BEGIN
a260max_params := cak260max_params;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260end_session (VAR acv : tak_all_command_glob);
 
VAR
      rip     : tsp_dcom_release_instance_parms;
 
BEGIN
rip.session_context := @acv;  (* PTS 1104668 FF    17-Nov-99 *)
rip.session         := acv.a_transinf.tri_trans.trSessionId_gg00.ci4_gg00;
vdcom_release_instance (rip);
(* errors are ignored *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260exec_dialog (VAR acv : tak_all_command_glob);
 
VAR
      do_execute    : boolean;
      dropParseid   : boolean;
      variableInput : boolean;
      asciiOutput   : boolean;
      ex_kind       : tak_execution_kind;
      ix            : integer;
      li_length     : integer;
      parsid        : tak_parsid;
      part_ptr      : tsp1_part_ptr;
 
      mb_data      : RECORD
            CASE boolean OF
                true :
                    (dpp   : tgg00_DataPartPtr);
                false :
                    (pmobj : tsp00_MoveObjPtr);
                END;
            (*ENDCASE*) 
 
 
      segm_ptr     : RECORD
            CASE boolean OF
                true :
                    (bptr : tsp00_MoveObjPtr);
                false :
                    (sptr : tsp1_segment_ptr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
WITH acv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        mb_data.dpp      := NIL;
        variableInput    := a_variable_input;
        a_variable_input := false;
        asciiOutput           := a_ascii_in_and_output;
        (*a_ascii_in_and_output := false;*)
        IF  a_ex_kind = parsing_executing (* PTS 1104386 *)
        THEN
            BEGIN
            a_cmd_segment_header.sp1c_mess_type := sp1m_parse;
            ex_kind        := a_init_ex_kind;
            a_init_ex_kind := only_parsing;
            a_ex_kind      := only_parsing;
            do_execute     := true;
            dropParseid    := false;
            END
        ELSE
            BEGIN
            do_execute := false;
            IF  a_cmd_segment_header.sp1c_mess_type = sp1m_execute
            THEN
                BEGIN
                IF  acv.a_mblock.mb_qual^.mspecial > 0
                THEN
                    mb_data.dpp := acv.a_mblock.mb_data;
                (*ENDIF*) 
                SAPDB_PascalMove ('VAK260',   1,    
                      a_cmd_part^.sp1p_buf_size, sizeof(parsid.pid_parsk),
                      @a_cmd_part^.sp1p_buf, 5, @parsid.pid_parsk, 1, mxak_parskey,
                      a_returncode)
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        ak260CallDBProc (acv, parsid, do_execute);
        IF  do_execute                            AND
            (a_returncode = 0 ) AND
            (a_return_segm^.sp1s_no_of_parts > 0)
        THEN
            BEGIN
            dropParseid   := true;
            segm_ptr.sptr := NIL;
            li_length := a_return_segm^.sp1s_segm_len;
            IF  li_length > 0
            THEN
                BEGIN
                (*-------- save longinfo --------*)
                IF  ak260Allocate (acv, li_length, @segm_ptr.bptr)
                THEN
                    SAPDB_PascalForcedMove (a_return_segm^.sp1s_segm_len, li_length,
                          @a_return_segm^, 1, @segm_ptr.bptr^, 1, li_length)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                (*-------- execute dbproc --------*)
                a_cmd_segment_header.sp1c_mess_type   := sp1m_execute;
                a_init_ex_kind             := only_executing;
                a_ex_kind                  := only_executing;
                parsid.pid_parsk           := a_pars_last_key;
                IF  a_mblock.mb_qual^.mspecial > 0
                THEN
                    BEGIN
                    IF  ak260Allocate (acv, a_mblock.mb_data_len, @mb_data.pmobj)
                    THEN
                        BEGIN
                        (* save parameters in new datapart, because original datapart may be *)
                        (* used by sql in dbprocedure                                        *)
                        SAPDB_PascalMove  ('VAK260',   2,    
                              a_mblock.mb_data_size, a_mblock.mb_data_len,
                              @a_mblock.mb_data^.mbp_buf, 1, @mb_data.pmobj^, 1, a_mblock.mb_data_len,
                              acv.a_returncode);
                        a_mblock.mb_data      := mb_data.dpp;
                        a_mblock.mb_data_size := a_mblock.mb_data_len
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                ak260CallDBProc (acv, parsid, false)
                END;
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                a_init_ex_kind := ex_kind;
                part_ptr       := @segm_ptr.sptr^.sp1p_part;
                FOR ix := 1 TO segm_ptr.sptr^.sp1s_no_of_parts DO
                    BEGIN
                    IF  (part_ptr^.sp1p_part_kind in
                        [sp1pk_shortinfo, sp1pk_columnnames])
                        AND
                        (part_ptr^.sp1p_buf_len > 0)
                    THEN
                        BEGIN
                        a06retpart_move (acv,
                              @part_ptr^.sp1p_buf, part_ptr^.sp1p_buf_len);
                        a06finish_curr_retpart (acv,
                              part_ptr^.sp1p_part_kind,
                              part_ptr^.sp1p_arg_count)
                        END;
                    (*ENDIF*) 
                    part_ptr := @part_ptr^.sp1p_buf[
                          a01aligned_cmd_len (part_ptr^.sp1p_buf_len) + 1]
                    END;
                (*ENDFOR*) 
                END;
            (*ENDIF*) 
            IF  dropParseid
            THEN
                BEGIN
                a260DropParseIds (acv, parsid.pid_parsk);
                a260ParseIdDrop  (acv, parsid); (* PTS 1111062 *)
                END;
            (*ENDIF*) 
            IF  segm_ptr.bptr <> NIL
            THEN
                gg941Deallocate (acv.a_transinf.tri_trans, segm_ptr.bptr)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  mb_data.dpp <> NIL
        THEN
            BEGIN
            gg941Deallocate (acv.a_transinf.tri_trans, mb_data.pmobj);
            acv.a_mblock.mb_data      := acv.a_mb_data_addr;
            acv.a_mblock.mb_data_size := acv.a_mb_data_size
            END;
        (*ENDIF*) 
        a_variable_input := variableInput;
        a_ascii_in_and_output   := asciiOutput;
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260CallDBProc (
            VAR acv           : tak_all_command_glob;
            VAR parsid        : tak_parsid;
            parse_for_execute : boolean);
 
CONST
      c_kernel_only = true;
 
VAR
      isCursorProc      : boolean;
      in_ddl_trigger    : boolean;
      with_commit       : boolean;
      do_parse_again    : boolean;
      rollbackWanted    : boolean;
      dt_format         : tgg00_DateTimeFormat;
      init_ex_kind      : tak_execution_kind;
      init_sqlmode      : tsp00_SqlMode;
      init_mess_type    : tsp1_cmd_mess_type;
      first_node        : integer;
      cursorNameNode    : integer;
      curr_node         : integer;
      procbuf           : tak_sysbufferaddress;
      p_arr             : tak_syspointerarr;
      schema            : tsp00_KnlIdentifier;
      ownerId           : tgg00_Surrogate;
      proc              : tsp00_KnlIdentifier;
      paramNameInfo     : tak260ParamNameInfo;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    isCursorProc    := false;
    rollbackWanted  := false; (* PTS 1109340*)
    in_ddl_trigger  := false;
    init_mess_type  := a_cmd_segment_header.sp1c_mess_type;
    init_sqlmode    := a_sqlmode;
    with_commit     := false;
    IF  a_cmd_segment_header.sp1c_mess_type = sp1m_parse
    THEN
        BEGIN (* parsing of db procedure *)
        WITH a_pars_last_key DO
            BEGIN
            p_id[ 1 ] := chr(ord(p_id[ 1 ])+1);
            p_kind    := m_begin;
            p_no      := 0;
            END;
        (*ENDWITH*) 
        a_precomp_info_byte := csp1_p_dialog_call;
        a_ex_kind           := only_parsing;
        first_node          := a_ap_tree^[0].n_lo_level;
        curr_node           := a_ap_tree^[first_node].n_sa_level;
        cursorNameNode      := a_ap_tree^[curr_node].n_lo_level;
        curr_node           := a_ap_tree^[curr_node].n_sa_level;
        a260get_proc (acv, schema, proc, curr_node);
        IF  a_ap_tree^[first_node].n_length = cak_i_system
        THEN
            BEGIN
            IF  NOT a12SystemTriggerExists (acv, schema, proc, d_fix, procbuf)
            THEN
                a07_nb_put_error (acv, e_unknown_name, 1, proc);
            (*ENDIF*) 
            END
        ELSE
            IF  NOT a12dbproc_exist (acv, schema, proc, d_fix, procbuf)
            THEN
                a07_nb_put_error (acv, e_unknown_procedure_name, 1, proc);
            (*ENDIF*) 
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            isCursorProc := procbuf^.smethod.me_cursor;
            a260GetDBProcOwner (acv, procbuf^.smethod, ownerId);
            IF  (ownerId <> a_curr_user_id) AND NOT acv.a_in_ddl_trigger
            THEN
                BEGIN
                (* Check call privilege of current user *)
                a260check_priv (acv,
                      procbuf^.smethod.me_surrogate, a_curr_user_id);
                END;
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                ak260parse_dbproc (acv, proc, parse_for_execute,
                      a_ap_tree^[first_node].n_lo_level,
                      cursorNameNode, procbuf, paramNameInfo, p_arr);
            (*ENDIF*) 
            a10rel_sysinfo (procbuf);
            END
        (*ENDIF*) 
        END
    ELSE
        IF  a_cmd_segment_header.sp1c_mess_type <> sp1m_execute
        THEN
            a07_b_put_error (acv, e_invalid_command, 1)
        ELSE
            BEGIN
            a_mblock.mb_qual^.mcol_pos := cak_is_undefined;
&           ifdef trace
            t01messblock (ak_sem, 'a_mblock    ', a_mblock);
&           endif
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        a_dbproc_level := a_dbproc_level + 1;
        a101_IncrementProcLevel (acv);
        (*============= Call Dialog Interpreter ==============*)
        init_ex_kind       := a_ex_kind;
        a_ex_kind          := only_executing;
        a_ex_kind          := init_ex_kind;
        dt_format          := a_dt_format;
        IF  a_returncode = 0
        THEN
            BEGIN
            IF  init_mess_type = sp1m_parse
            THEN
                BEGIN
                (* return parsid to user process and store  *)
                (* pars info required for db proc execution *)
                a06reset_retpart    (acv);
                ak260store_parsinfo (acv, paramNameInfo, p_arr);
                END
            ELSE
                BEGIN
                do_parse_again := false;
                IF  a_mblock.mb_qual^.mstrat_cnt = 0
                THEN
                    BEGIN
                    ak260int_proc_call_cnt := ak260int_proc_call_cnt + 1;
                    ak260CallInternalDBProc (acv, a_mblock, isCursorProc)
                    END
                ELSE
&                   ifdef check
                    IF  acv.a_subtrans_ptr > 1 (* PTS 1103883 *)
                    THEN
                        a07_b_put_error (acv, e_invalid_subtrans_structure,
                              acv.a_subtrans_ptr)
                    ELSE
&                       endif
                        BEGIN
                        a_dt_format            := dtf_normal;
                        ak260ext_proc_call_cnt := ak260ext_proc_call_cnt + 1;
                        ak260dbproc_call (acv, a_mblock, c_monitoring,
                              NOT c_is_trigger, with_commit, do_parse_again,
                              rollbackWanted (* PTS 1109340 *),
                              NOT c_kernel_only)
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  do_parse_again
                THEN
                    BEGIN
                    a_returncode := 0;
                    ak260parse_again (acv, parsid.pid_parsk);
                    IF  a_returncode = 0
                    THEN
                        BEGIN
                        ak260dbproc_call (acv, a_mblock, c_monitoring,
                              NOT c_is_trigger, with_commit, do_parse_again,
                              rollbackWanted (* PTS 1109340 *),
                              NOT c_kernel_only);
                        IF  do_parse_again
                        THEN
                            a07_b_put_error (acv, e_old_fileversion, 1)
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
&       ifdef trace
        (*ENDIF*) 
        ;
        t01packet (ak_sem, 'ret packet  ', a_out_packet);
&       endif
        a_dt_format      := dt_format;
        a_dbproc_level   := a_dbproc_level - 1;
        a101_DecrementProcLevel (acv);
        END;
    (*ENDIF*) 
    init_ex_kind := a_ex_kind;
    a_ex_kind    := only_executing;
    IF  rollbackWanted (* PTS 1109340 *)
    THEN
        a52_ex_commit_rollback (acv, m_rollback, false, false)
    ELSE
        IF  a_returncode = 0
        THEN
            BEGIN
            IF  with_commit
            THEN
                a52_ex_commit_rollback (acv, m_commit, NOT c_release, c_normal_release);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    a_ex_kind    := init_ex_kind;
    a_sqlmode    := init_sqlmode;
    a_init_ddl   := no_ddl;
    IF  isCursorProc
    THEN
        a_return_segm^.sp1r_function_code := csp1_cursor_pl_sql_execute_fc
    ELSE
        a_return_segm^.sp1r_function_code := csp1_pl_sql_execute_fc
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260CreateInstance (
            VAR acv         : tak_all_command_glob;
            VAR cip         : tsp_dcom_co_create_instance_parms;
            VAR method_name : tsp00_KnlIdentifier;
            VAR packageId   : tgg00_Surrogate);
 
VAR
      e         : tgg00_BasisError;
      methodBuf : tak_sysbufferaddress;
      sysk      : tgg00_SysInfoKey;
 
BEGIN
IF  cip.ret <> c_factory_found
THEN
    BEGIN
    cip.use_libname  := false;
    cip.force_run_in_kernel := true;
    vbegexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08dcom);
    vdcom_get_dispaddr (cip);
    IF  (cip.ret <> 0) AND (cip.ret <> c_factory_found)
    THEN
        BEGIN
        a12LoadFileInfo ( acv, packageId,
              cip.library_name, cip.MD5_footprint);
        cip.package_id  := packageId;
        cip.use_libname := cip.library_name <> NIL;
        vdcom_co_get_classobject ( cip );
        END
    ELSE
        IF  cip.ret = c_factory_found
        THEN
            cip.ret := 0;
        (*ENDIF*) 
    (*ENDIF*) 
    vendexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08dcom)
    END
ELSE
    cip.ret := 0;
(*ENDIF*) 
IF  cip.ret = 0
THEN
    vdcom_create_instance ( cip );
(*ENDIF*) 
IF  cip.ret = 0
THEN
    acv.a_no_of_com_objects := acv.a_no_of_com_objects + 1
ELSE
    IF  cip.ret = c_user_defined_hresult
    THEN
        BEGIN
        acv.a_user_defined_error           := true;
        acv.a_returncode := acv.a_dca.msgno;
        a06retpart_move (acv, @acv.a_dca.stop_msg, sizeof (acv.a_dca.stop_msg));
        a06finish_curr_retpart (acv, sp1pk_errortext, 1);
        END
    ELSE
        BEGIN
        a260hresult_error (cip.ret, method_name, cip.errtext, e);
        a07_nb_put_error  (acv, e, 1, method_name);
        a07const_param    (acv, 2, @cip.errtext, sizeof (cip.errtext));
        END;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260SwapParameter (
            VAR paramDesc    : tgg00_StackList;
            VAR paramDescIdx : integer;
            pParam           : tsp00_MoveObjPtr
            );
 
VAR
      exit_loop : boolean;
      aux       : char;
      pos       : integer;
      kx        : integer;
      curr_st   : tgg00_StEntryAddr;
      pI4       : ^tsp00_Int4;
      c8        : tsp00_C8;
      pC8       : ^tsp00_C8;
&     ifdef trace
      length    : integer;
      maxLength : integer;
&     endif
 
BEGIN
exit_loop := false;
&ifdef trace
maxLength := 0;
t01moveobj (ak_sem, pParam^, 1, 100);
&endif
REPEAT
    curr_st := @paramDesc[paramDescIdx];
    IF  (curr_st^.etype = st_op) AND (curr_st^.eop = op_swap)
    THEN
        BEGIN
&       ifdef trace
        t01stackentry (ak_sem, curr_st^, paramDescIdx);
        length := curr_st^.epos;
&       endif
        CASE ord(curr_st^.ecol_tab[2]) OF
            sw_i2 :
                BEGIN
                pos := curr_st^.epos + 1;
                FOR kx := 1 TO curr_st^.elen_var DO
                    BEGIN
                    aux              := pParam^[pos];
                    pParam^[pos    ] := pParam^[pos + 1];
                    pParam^[pos + 1] := aux;
                    pos              := pos + 2
                    END;
                (*ENDFOR*) 
&               ifdef trace
                length := length + 2 * curr_st^.elen_var;
&               endif
                END;
            sw_i4, sw_r4 :
                BEGIN
                pI4 := @pParam^[curr_st^.epos+1];
                s20swap_int4 (pI4^, sw_normal, sw_full_swapped);
&               ifdef trace
                length := length + 4;
&               endif
                END;
            sw_i8, sw_r8 :
                BEGIN
                pC8 := @pParam^[curr_st^.epos+1];
                c8  := pC8^;
                FOR kx := 1 TO sizeof(c8) DO
                    pC8^[kx] := c8[sizeof(c8) - kx + 1];
                (*ENDFOR*) 
&               ifdef trace
                length := length + 8;
&               endif
                END;
            OTHERWISE ;
            END;
        (*ENDCASE*) 
&       ifdef trace
        IF  length > maxLength
        THEN
            maxLength := length;
&       endif
        (*ENDIF*) 
        paramDescIdx := paramDescIdx + 1
        END
    ELSE
        exit_loop := true;
    (*ENDIF*) 
UNTIL
    exit_loop;
(*ENDREPEAT*) 
&ifdef trace
t01moveobj (ak_sem, pParam^, 1, maxLength);
&endif
paramDescIdx := paramDescIdx - 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260dbproc_call (
            VAR acv            : tak_all_command_glob;
            VAR mblock         : tgg00_MessBlock;
            do_monitoring      : boolean;
            is_trigger         : boolean;
            VAR with_commit    : boolean;
            VAR parse_again    : boolean;
            VAR rollbackWanted : boolean (* PTS 1109695 *);
            kernel_only        : boolean);
 
CONST
      c_parse_again   = 2;
      c_next_param    = -1;
      c_inout         = 0;
      c_out           = 1;
      c_version72     = '70200';
 
TYPE
      t_ParamBufferPtr = ^t_ParamBuffer;
 
      t_ParamBuffer = RECORD
            next      : t_ParamBufferPtr;
            wydeValue : tak_WydeArray;
      END;
 
 
VAR
      is_parms_with_desc  : boolean;
      isUnicodeClient     : boolean;
      integerSwap         : boolean;
      exitLoop            : boolean;
      e                   : tgg00_BasisError;
      res                 : tsp00_NumError;
      aux                 : char;
      i2                  : tsp00_Int2;
      i2c2                : tsp_int_map_c2;
      swap_cnt            : integer;
      st_ix               : integer;
      stack_len           : integer;
      length              : integer;
      vt                  : integer;
      ix                  : integer;
      jx                  : integer;
      kx                  : integer;
      stack_entry_len     : integer;
      bufpos_idx          : integer;
      pPos                : integer;
      vPos                : integer;
      highByte            : integer;
      lowByte             : integer;
      srcPos              : integer;
      destPos             : integer;
      clientSize          : integer;
      cppSize             : integer;
      paramNo             : tsp00_Int4;
      pI4                 : ^tsp00_Int4;
      c8                  : tsp00_C8;
      pC8                 : ^tsp00_C8;
      pAddr               : ^tsp00_C8;
      pParam              : t_ParamBufferPtr;
      pCurrParam          : t_ParamBufferPtr;
      pWydeArray          : ^tak_WydeArray;
      buf_pos             : ARRAY[0..1] OF tsp00_Int4;
      out_length          : tsp00_Int4;
      inout_offset        : tsp00_Int4;
      param_addr          : tsp00_MoveObjPtr;
      res_buf_ptr         : tsp00_MoveObjPtr;
      curr_st             : tgg00_StEntryAddr;
      curr_res_st         : tgg00_StEntryAddr;
      stack_ptr           : ^tak_dbproc_stack_param_debug;
      in_param_ptr        : ^tak_dbproc_stack_param;
      cip                 : tsp_dcom_co_create_instance_parms;
      dp                  : tsp_dcom_dispatch_parms;
      val_st_ptr          : tgg00_StEntryAddr;
      pcip                : ^tcreate_inst_params;
      errtext             : tsp00_ErrText;
      stack               : ARRAY[1..cak260max_params] OF tak_dbproc_stack_param_debug;
      pStack              : tsp00_MoveObjPtr;
      out_parm_cnt        : integer;
      currDBProcedure     : tgg00_Surrogate;
      dbproc_name         : tsp00_KnlIdentifier;
      out_parms           : tout_param_stack;
      pC64                : ^tsp00_C64;
      pParamDesc          : tgg00_StackListPtr;
      packageId           : tgg00_Surrogate;
      savedDbprocCallInfo : tak_dbproc_call_info;
&     ifdef OMSTST
      badAllocCntDwn  : tsp00_Int4;
&     endif
 
LABEL
      999;
 
BEGIN
&ifdef OMSTST
(* no bad allocs wanted in this phase *)
badAllocCntDwn                           := acv.a_allocatorInfo.ai_badAllocCountDown;
acv.a_allocatorInfo.ai_badAllocCountDown := -1;
&endif
&ifdef trace
t01messblock (ak_sem, 'mblock      ', mblock);
&endif
isUnicodeClient := acv.a_cmd_packet_header.sp1h_mess_code in [csp_unicode_swap, csp_unicode];
integerSwap     := acv.a_out_packet^.sp1_header.sp1h_mess_swap <> g01code.kernel_swap;
IF  acv.a_out_packet^.sp1_header.sp1h_mess_swap = sw_normal
THEN
    BEGIN
    highByte := 0;
    lowByte  := 1;
    END
ELSE
    BEGIN
    highByte := 1;
    lowByte  := 0;
    END;
(*ENDIF*) 
rollbackWanted  := false;
out_parm_cnt    := 0;
pParam          := NIL;
acv.a_transinf.tri_trans.trError_gg00 := e_ok;
(* 1102637, T.A. 1999-05-10 *)
pcip               := @mblock.mb_data^.mbp_buf[
      mblock.mb_st^[mblock.mb_qual^.mstrat_pos].epos];
IF  pcip^.wait_for_checkp
THEN
    (* PTS 1107002 2000-06-21 UH *)
    (* PTS 1107004 *)
    k50StartDbProcedure (acv.a_transinf.tri_trans);
(*ENDIF*) 
IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
THEN
    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
ELSE
    BEGIN
    res_buf_ptr         := NIL;
    pParamDesc          := NIL;
    pcip                := @mblock.mb_data^.mbp_buf[
          mblock.mb_st^[mblock.mb_qual^.mstrat_pos].epos];
    cip.coclsid         := pcip^.coclsid;
    cip.iid             := pcip^.iid;
    parse_again         := false;
    with_commit         := pcip^.with_commit;
    cip.session_context := @acv;
    cip.session         := acv.a_transinf.tri_trans.trSessionId_gg00.ci4_gg00;
    cip.ikernel_sink    := @acv.a_kernel_sink;
    dbproc_name         := pcip^.dbproc_name;
    packageId           := pcip^.packageId;
    dp.dispid           := pcip^.dispid;
    (* dp.debug_location   := cip.debug_location; PTS 1112663 *)
    (* change Request 1000139, T.A. 14.10.1998 *)
    dp.method_name      := pcip^.dbproc_name;
    dp.monitoring       := do_monitoring;
    dp.monitor_slot_id  := dp.dispid;
    out_length          := pcip^.out_length;
    inout_offset        := pcip^.inout_offset;
    (* PTS 1116339 FF 2002-06-26                                                *)
    (* creation of COM instance has been moved down before call of db-procedure *)
    IF  out_length > 0
    THEN
        BEGIN
&       ifdef trace
        t01int4 (ak_sem, 'out_length  ', out_length);
&       endif
        IF  ak260Allocate (acv, out_length, @res_buf_ptr)
        THEN
            ;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  ak260Allocate (acv, (mblock.mb_qual^.mqual_cnt + 1) * sizeof(tgg00_StackEntry), @pParamDesc)
    THEN
        BEGIN
        FOR ix := 1 TO mblock.mb_qual^.mqual_cnt DO
            pParamDesc^[ix] := mblock.mb_st^[mblock.mb_qual^.mqual_pos + ix - 1];
        (*ENDFOR*) 
        pParamDesc^[mblock.mb_qual^.mqual_cnt+1].etype := st_dummy;
        END;
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        is_parms_with_desc := a260BuildDebugStack; (* PTS 1107878 & PTS 1112663*)
        buf_pos[c_inout]   := 0;
        buf_pos[c_out  ]   := inout_offset;
        e                  := e_ok;
        stack_ptr          := @stack;
        pStack             := @stack;
        stack_len          := 0;
        res                := num_ok;
        st_ix              := mblock.mb_qual^.mqual_pos;
        IF  is_parms_with_desc
        THEN
            stack_entry_len := sizeof (tak_dbproc_stack_param_debug)
        ELSE
            stack_entry_len := sizeof (tsp00_Addr);
        (*ENDIF*) 
        paramNo := 0;
        WHILE st_ix < mblock.mb_qual^.mqual_pos + mblock.mb_qual^.mqual_cnt DO
            BEGIN
            curr_st := @mblock.mb_st^[st_ix];
            CASE curr_st^.etype OF
                st_jump_absolute :
                    st_ix      := curr_st^.epos;
                st_op :
                    BEGIN
                    CASE curr_st^.eop OF
                        op_swap :
                            BEGIN
                            swap_cnt :=  curr_st^.elen_var;
                            IF  (curr_res_st^.eop <> op_in) AND (out_parms[out_parm_cnt].op_swapIdx = 0)
                            THEN (* output parameter, store swap info *)
                                BEGIN
                                out_parms[out_parm_cnt].op_swapIdx := st_ix;
                                END;
                            (*ENDIF*) 
                            IF  curr_res_st^.eop <> op_not_in
                            THEN
                                ak260SwapParameter (mblock.mb_st^, st_ix, stack_ptr^.dbg_value.ptr);
                            (*ENDIF*) 
                            END;
                        op_dbyte_translate :
                            BEGIN
                            IF  curr_res_st^.eop <> op_in
                            THEN
                                BEGIN
                                (* output parameter, store info to be able to translate machine *)
                                (* into client layout                                           *)
                                IF  out_parms[out_parm_cnt].op_translateIdx = 0
                                THEN
                                    out_parms[out_parm_cnt].op_translateIdx := st_ix;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            IF  curr_res_st^.eop <> op_not_in
                            THEN (* input parameter, translate ascii to wyde *)
                                BEGIN
                                destPos := curr_st^.epos + 1;     (* position in cpp layout    *)
                                srcPos  := curr_st^.ecol_pos + 2; (* position in client layout *)
&                               ifdef trace
                                t01p2int4 (ak_sem, 'ascii from  ', srcPos, 'to wyde     ', destPos);
                                t01int4   (ak_sem, 'length      ', curr_st^.elen_var);
&                               endif
                                pWydeArray := @stack_ptr^.dbg_value.ptr^[destPos];
                                FOR ix := 1 TO curr_st^.elen_var DO
                                    pWydeArray^[ix] := ord(param_addr^[srcPos + ix - 1]);
                                (*ENDFOR*) 
                                END;
                            (*ENDIF*) 
                            END;
                        op_trunc :
                            BEGIN
                            IF  curr_res_st^.eop <> op_in
                            THEN
                                BEGIN
                                (* output parameter, store info to be able to translate machine *)
                                (* into client layout                                           *)
                                IF  out_parms[out_parm_cnt].op_translateIdx = 0
                                THEN
                                    out_parms[out_parm_cnt].op_translateIdx := st_ix;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            IF  curr_res_st^.eop <> op_not_in
                            THEN (* input parameter, translate into machine layout *)
                                BEGIN
                                destPos := curr_st^.epos + 1;     (* position in cpp layout    *)
                                srcPos  := curr_st^.ecol_pos + 2; (* position in client layout *)
&                               ifdef trace
                                t01p2int4 (ak_sem, 'wyde from   ', srcPos, 'to ascii    ', destPos);
                                t01int4   (ak_sem, 'length      ', curr_st^.elen_var);
&                               endif
                                FOR ix := 1 TO curr_st^.elen_var DO
                                    BEGIN
                                    IF  (param_addr^[srcPos + highByte] <> chr(0)) OR
                                        (param_addr^[srcPos + lowByte ] > chr(127))
                                    THEN
                                        BEGIN
                                        a07_b_put_error (acv, e_not_translatable, 1);
                                        ak263WriteTranslationError (acv, dbproc_name, paramNo, srcPos - 1,
                                              ord(param_addr^[srcPos + highByte]) * 256 + ord(param_addr^[srcPos + lowByte]));
                                        goto 999;
                                        END;
                                    (*ENDIF*) 
                                    stack_ptr^.dbg_value.ptr^[destPos] := param_addr^[srcPos + lowByte];
                                    srcPos  := srcPos + 2;
                                    destPos := destPos + 1;
                                    END;
                                (*ENDFOR*) 
                                END;
                            (*ENDIF*) 
                            END;
                        op_none :
                            BEGIN
                            IF  curr_res_st^.eop <> op_in
                            THEN
                                BEGIN
                                (* output parameter, store info to be able to translate machine *)
                                (* into client layout                                           *)
                                IF  out_parms[out_parm_cnt].op_translateIdx = 0
                                THEN
                                    out_parms[out_parm_cnt].op_translateIdx := st_ix;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            IF  curr_res_st^.eop <> op_not_in
                            THEN (* input parameter, translate into machine layout *)
                                BEGIN
                                destPos := curr_st^.epos + 1;     (* position in cpp layout    *)
                                srcPos  := curr_st^.ecol_pos + 2; (* position in client layout *)
&                               ifdef trace
                                t01p2int4 (ak_sem, 'copy from   ', srcPos, 'to          ', destPos);
                                t01int4   (ak_sem, 'bytes       ', curr_st^.elen_var);
&                               endif
                                SAPDB_PascalMove ('VAK260',   3,    
                                      sizeof(tsp00_MoveObj), cppSize,
                                      @param_addr^, srcPos, @stack_ptr^.dbg_value.ptr^, destPos,
                                      curr_st^.elen_var, acv.a_returncode);
                                END;
                            (*ENDIF*) 
                            END;
                        END;
                    (*ENDCASE*) 
&                   ifdef trace
                    IF  mblock.mb_st^[st_ix+1].etype <> st_op
                    THEN
                        t01moveobj (ak_sem, stack_ptr^.dbg_value.ptr^, 1, cppSize);
&                   endif
                    (*ENDIF*) 
                    END;
                st_value :
                    val_st_ptr := curr_st;
                st_dbproc_param :
                    BEGIN
                    paramNo     := paramNo + 1;
                    curr_res_st := curr_st;
                    vt          := ord(curr_st^.ecol_tab[1]);
                    cppSize     := curr_st^.elen_var;
                    st_ix       := st_ix + 1;
                    clientSize  := mblock.mb_st^[st_ix].elen_var;
                    stack_ptr   := @pStack^[stack_len + 1];
                    stack_len   := stack_len + stack_entry_len;
                    IF  curr_st^.eop <> op_not_in
                    THEN
                        BEGIN (* no pure output parameter *)
                        IF  (curr_st^.eop = op_in) AND NOT is_trigger
                        THEN
                            in_param_ptr := @stack_ptr^.dbg_value
                        ELSE
                            BEGIN
                            in_param_ptr             := @out_parms[out_parm_cnt + 1].op_val;
                            stack_ptr^.dbg_value.ptr := @in_param_ptr^;
                            END;
                        (*ENDIF*) 
                        IF  val_st_ptr^.ecol_tab[1] = chr(1)
                        THEN
                            param_addr := @acv.a_data_ptr^[val_st_ptr^.epos]
                        ELSE
                            param_addr := @mblock.mb_data^.mbp_buf[val_st_ptr^.epos];
                        (*ENDIF*) 
                        length := val_st_ptr^.elen_var;
&                       ifdef trace
                        t01int4    (ak_sem, 'Push Param  ', 0);
                        t01moveobj (ak_sem, param_addr^, 1, length);
&                       endif
                        IF  param_addr^[1] = csp_undef_byte
                        THEN
                            BEGIN
                            IF  NOT is_trigger
                                AND
                                ((curr_st^.eop <> op_in) OR
                                (vt <> csp1_vt_userdefined))
                            THEN
                                BEGIN
                                a07_b_put_error (acv, e_null_not_allowed, 1);
                                goto 999;
                                END;
                            (*ENDIF*) 
                            stack_ptr^.dbg_value.ptr := NIL;
                            END
                        ELSE
                            BEGIN
                            CASE vt OF
                                csp1_vt_i1, csp1_vt_ui1 ,
                                csp1_vt_lc_byte, csp1_vt_lc_bool :
                                    in_param_ptr^.i1[1] := param_addr^[2];
                                csp1_vt_lc_char, csp1_vt_lc_ascii7, csp1_vt_lc_numc :   (* PTS 1131373, PG *)
                                    BEGIN
                                    (* don't consider unicode client, vak50X layer already *)
                                    (* translated into ascii                               *)
                                    in_param_ptr^.i1[1] := param_addr^[2];
                                    END;
                                csp1_vt_lc_wyde :
                                    BEGIN
                                    IF  isUnicodeClient
                                    THEN
                                        BEGIN
                                        IF  integerSwap
                                        THEN
                                            BEGIN
                                            i2c2.map_c2[1] := param_addr^[3];
                                            i2c2.map_c2[2] := param_addr^[2];
                                            END
                                        ELSE
                                            BEGIN
                                            i2c2.map_c2[1] := param_addr^[2];
                                            i2c2.map_c2[2] := param_addr^[3];
                                            END;
                                        (*ENDIF*) 
                                        in_param_ptr^.i2 := i2c2.map_int
                                        END
                                    ELSE
                                        in_param_ptr^.i2 := ord(param_addr^[2]);
                                    (*ENDIF*) 
                                    END;
                                csp1_vt_lc_wchar :
                                    BEGIN
                                    in_param_ptr^.c2[1] := param_addr^[2];
                                    in_param_ptr^.c2[2] := param_addr^[3];
                                    END;
                                csp1_vt_lc_int1 :
                                    BEGIN
                                    s40gsint (param_addr^,
                                          2, (length - 2) * 2, i2c2.map_int, res); (* PTS 1103190, T.A. 1999-07-02 *)
                                    IF  (i2c2.map_int >= -128) AND (i2c2.map_int < 128)
                                    THEN
                                        IF  g01code.kernel_swap = sw_normal
                                        THEN
                                            in_param_ptr^.i1[1] := i2c2.map_c2[2]
                                        ELSE
                                            in_param_ptr^.i1[1] := i2c2.map_c2[1]
                                        (*ENDIF*) 
                                    ELSE
                                        res := num_overflow
                                    (*ENDIF*) 
                                    END;
                                csp1_vt_lc_uint1 :
                                    BEGIN
                                    s40gsint (param_addr^,
                                          2, (length - 2) * 2, i2c2.map_int, res); (* PTS 1104796, FF 1999-11-29 *)
                                    IF  (i2c2.map_int >= 0) AND (i2c2.map_int < 256)
                                    THEN
                                        IF  g01code.kernel_swap = sw_normal
                                        THEN
                                            in_param_ptr^.i1[1] := i2c2.map_c2[2]
                                        ELSE
                                            in_param_ptr^.i1[1] := i2c2.map_c2[1]
                                        (*ENDIF*) 
                                    ELSE
                                        res := num_overflow
                                    (*ENDIF*) 
                                    END;
                                csp1_vt_i2 :
                                    s40gsint (param_addr^,
                                          2, (length - 2) * 2, in_param_ptr^.i2, res);
                                csp1_vt_ui2 :
                                    s40gsuns (param_addr^,
                                          2, (length - 2) * 2, in_param_ptr^.i2, res);
                                csp1_vt_i4, csp1_vt_int :
                                    s40glint (param_addr^,
                                          2, (length - 2) * 2, in_param_ptr^.i4, res);
                                csp1_vt_ui4, csp1_vt_uint :
                                    s40gluns (param_addr^,
                                          2, (length - 2) * 2, in_param_ptr^.i4, res);
                                csp1_vt_r4 :
                                    s40gsrel (param_addr^,
                                          2, (length - 2) * 2, in_param_ptr^.r4, res);
                                csp1_vt_i8 :
                                    ak263NumberToInt8 (@param_addr^[2], length, in_param_ptr^.i8, res);
                                csp1_vt_ui8 :
                                    ak263NumberToUInt8 (@param_addr^[2], length, in_param_ptr^.i8, res);
                                csp1_vt_r8 :
                                    BEGIN
                                    s40glrel (param_addr^,
                                          2, (length - 2) * 2, in_param_ptr^.r8, res);
                                    IF  NOT is_parms_with_desc AND (curr_st^.eop = op_in)
                                    THEN
                                        stack_len := stack_len - sizeof (stack_ptr^.dbg_value.ptr) +
                                              sizeof (stack_ptr^.dbg_value.r8)
                                    (*ENDIF*) 
                                    END;
                                csp1_vt_carray, csp1_vt_userdefined :
                                    BEGIN
                                    IF  (curr_st^.eop <> op_in        ) AND
                                        (curr_st^.ecol_tab[2] = chr(0))
                                    THEN (* copied in/out parameter *)
                                        BEGIN
                                        IF  vt = csp1_vt_carray
                                        THEN
                                            pPos := buf_pos[c_inout] + 1
                                        ELSE
                                            pPos := a01aligned_cmd_len (buf_pos[c_inout] + 1);
                                        (*ENDIF*) 
                                        SAPDB_PascalMove  ('VAK260',   4,    
                                              length, out_length,
                                              @param_addr^, 1, @res_buf_ptr^, pPos, length,
                                              acv.a_returncode);
                                        END
                                    ELSE
                                        IF  curr_st^.eparamdatatype = dwyde
                                        THEN
                                            BEGIN
                                            IF  isUnicodeClient OR acv.a_pseudoUnicodeClient
                                            THEN
                                                BEGIN
                                                IF  integerSwap
                                                THEN
                                                    BEGIN
                                                    pWydeArray := @param_addr^[2];
                                                    ix         := 2;
                                                    jx         := 1;
                                                    WHILE jx <= cppSize DIV 2 DO
                                                     BEGIN
                                                     i2c2.map_c2[2]  := param_addr^[ix];
                                                     i2c2.map_c2[1]  := param_addr^[ix+1];
                                                     pWydeArray^[jx] := i2c2.map_int;
                                                     ix := ix + 2;
                                                     jx := jx + 1
                                                     END;
                                                    (*ENDWHILE*) 
                                                    END;
                                                (*ENDIF*) 
                                                stack_ptr^.dbg_value.ptr := @param_addr^[2];
                                                END
                                            ELSE
                                                IF  ak260Allocate (acv,
                                                    sizeof(tsp00_MoveObjPtr) + cppSize, @pCurrParam)
                                                THEN
                                                    BEGIN
                                                    pCurrParam^.next := pParam;
                                                    pParam           := pCurrParam;
                                                    FOR ix := 1 TO cppSize DIV 2 DO
                                                     pParam^.wydeValue[ix] :=
                                                        ord(param_addr^[ix+1]);
                                                    (*ENDFOR*) 
                                                    stack_ptr^.dbg_value.ptr := @pParam^.wydeValue;
                                                    END;
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                            END
                                        ELSE
                                            IF  curr_st^.ecol_tab[2] <> chr(0)
                                            THEN
                                                BEGIN
                                                IF  ak260Allocate (acv,
                                                    sizeof(tsp00_MoveObjPtr) + cppSize,
                                                    @pCurrParam)
                                                THEN
                                                    BEGIN
                                                    pCurrParam^.next         := pParam;
                                                    pParam                   := pCurrParam;
                                                    stack_ptr^.dbg_value.ptr := @pParam^.wydeValue;
                                                    END;
                                                (*ENDIF*) 
                                                END
                                            ELSE
                                                BEGIN
                                                stack_ptr^.dbg_value.ptr := @param_addr^[2];
                                                END;
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                    END;
                                csp1_vt_lc_abap_tab_handle, csp1_vt_lc_stream_handle :
                                    BEGIN (* cannot be in/out parameter *)
                                    stack_ptr^.dbg_value.ptr := @param_addr^[2];
                                    (* PTS 1103894 *)
                                    IF  acv.a_comp_vers < c_version72
                                    THEN
                                        BEGIN (* handle in 7.1 layout, migrate to 7.2 layout, i.e *)
                                        (* insert filler into handle (see vco03.idl)              *)
                                        pAddr := @param_addr^[2];
                                        IF  pAddr^ <> cgg_zero_id
                                        THEN
                                            BEGIN (* call from a 32 bit platform, cannot be NULL due to colcount *)
                                            SAPDB_PascalOverlappingMove  ('VAK260',   5,    
                                                  length - 1, length - 1,
                                                  @stack_ptr^.dbg_value.ptr^, sizeof(tsp00_Int4) + 1,
                                                  @stack_ptr^.dbg_value.ptr^, sizeof(tsp00_C8) + 1,
                                                  length - 1 - sizeof(tsp00_Int4) - (sizeof(tsp00_C8) - sizeof(tsp00_Int4)),
                                                  acv.a_returncode);
                                            SAPDB_PascalFill ('VAK260',   6,    
                                                  length - 1, @stack_ptr^.dbg_value.ptr^,
                                                  sizeof(tsp00_Int4) + 1, sizeof(tsp00_Addr) - sizeof(tsp00_Int4),
                                                  chr(0), acv.a_returncode)
                                            END;
                                        (*ENDIF*) 
                                        END;
                                    (*ENDIF*) 
                                    ak263CheckHandle (acv, st_ix, stack_ptr^.dbg_value.ptr, length - 1,
                                          vt =  csp1_vt_lc_abap_tab_handle, e, paramNo, dbproc_name);
                                    IF  e <> e_ok
                                    THEN
                                        BEGIN
                                        goto 999;
                                        END;
                                    (*ENDIF*) 
                                    END;
                                OTHERWISE
                                    BEGIN
                                    a07_b_put_error (acv, e_not_implemented, 1);
                                    goto 999;
                                    END
                                END;
                            (*ENDCASE*) 
                            IF  res <> num_ok
                            THEN
                                BEGIN
                                k71num_err_to_b_err (res, e);
                                a07_b_put_error (acv, e, 1);
                                goto 999;
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  curr_st^.eop <> op_in
                    THEN
                        BEGIN (* output parameter *)
                        bufpos_idx   := -1;
                        out_parm_cnt := out_parm_cnt + 1;
                        IF  curr_st^.eop = op_not_in
                        THEN
                            BEGIN
                            IF  curr_st^.ecol_tab[2] = chr(1)
                            THEN
                                BEGIN
                                IF  ak260Allocate (acv,
                                    sizeof(tsp00_MoveObjPtr) + cppSize,
                                    @pCurrParam)
                                THEN
                                    BEGIN
                                    pCurrParam^.next         := pParam;
                                    pParam                   := pCurrParam;
                                    stack_ptr^.dbg_value.ptr := @pParam^.wydeValue;
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            bufpos_idx := c_out
                            END
                        ELSE (* in/out parameter *)
                            bufpos_idx := c_inout;
                        (*ENDIF*) 
                        out_parms[out_parm_cnt].op_vt          := vt;
                        out_parms[out_parm_cnt].op_io_len      := clientSize;
                        out_parms[out_parm_cnt].op_cpp_len     := cppSize;
                        out_parms[out_parm_cnt].op_datatype[1] := chr(ord(curr_st^.eparamdatatype));
                        CASE vt OF
                            csp1_vt_carray :
                                stack_ptr^.dbg_value.ptr :=
                                      @res_buf_ptr^[buf_pos[bufpos_idx] + 2];
                            csp1_vt_userdefined :
                                BEGIN
                                buf_pos[bufpos_idx] := a01aligned_cmd_len (buf_pos[bufpos_idx] + 1) - 1;
                                IF  curr_st^.ecol_tab[2] <> chr(1)
                                THEN
                                    stack_ptr^.dbg_value.ptr :=
                                          @res_buf_ptr^[buf_pos[bufpos_idx] + 2];
&                               ifdef trace
                                (*ENDIF*) 
                                t01addr (ak_sem , 'param addr  ', stack_ptr^.dbg_value.ptr);
&                               endif
                                out_parms[out_parm_cnt].op_val.ptr := stack_ptr^.dbg_value.ptr;
                                END;
                            OTHERWISE
                                stack_ptr^.dbg_value.ptr := @out_parms[out_parm_cnt].op_val;
                            END;
                        (*ENDCASE*) 
                        out_parms[out_parm_cnt].op_translateIdx := 0;
                        out_parms[out_parm_cnt].op_swapIdx      := 0;
                        out_parms[out_parm_cnt].op_offset       := buf_pos[bufpos_idx];
                        out_parms[out_parm_cnt].op_paramNo      := paramNo;
                        buf_pos  [bufpos_idx] := buf_pos[bufpos_idx] + out_parms[out_parm_cnt].op_io_len
                        END;
                    (*ENDIF*) 
                    IF  is_parms_with_desc
                    THEN
                        BEGIN
                        stack_ptr^.dbg_vt := vt;
                        CASE curr_st^.eop OF
                            op_not_in :
                                stack_ptr^.dbg_inout := sp1io_output;
                            op_in :
                                stack_ptr^.dbg_inout := sp1io_input;
                            OTHERWISE
                                stack_ptr^.dbg_inout := sp1io_inout;
                            END;
                        (*ENDCASE*) 
                        stack_ptr^.dbg_is_ptr := is_trigger OR
                              (stack_ptr^.dbg_inout in [sp1io_output, sp1io_inout]) OR
                              (vt in [csp1_vt_carray, csp1_vt_userdefined,
                              csp1_vt_lc_abap_tab_handle, csp1_vt_lc_stream_handle]);
                        CASE vt OF
                            csp1_vt_i1, csp1_vt_ui1, csp1_vt_lc_char, csp1_vt_lc_ascii7,
                            csp1_vt_lc_numc,   (* PTS 1131373, PG *)
                            csp1_vt_lc_byte, csp1_vt_lc_bool, csp1_vt_lc_int1, csp1_vt_lc_uint1 :
                                stack_ptr^.dbg_length := 1;
                            csp1_vt_lc_wchar, csp1_vt_i2, csp1_vt_ui2 :
                                stack_ptr^.dbg_length := 2;
                            csp1_vt_i4, csp1_vt_int, csp1_vt_ui4, csp1_vt_uint,
                            csp1_vt_r4 :
                                stack_ptr^.dbg_length := 4;
                            csp1_vt_r8, csp1_vt_i8, csp1_vt_ui8 :
                                stack_ptr^.dbg_length := 8;
                            OTHERWISE
                                stack_ptr^.dbg_length := cppSize;
                            END;
                        (*ENDCASE*) 
                        END;
                    (*ENDIF*) 
                    END;
                OTHERWISE
                END;
            (*ENDCASE*) 
            st_ix := st_ix + 1
            END;
        (*ENDWHILE*) 
        acv.a_mblock.mb_data      := acv.a_mb_data_addr;
        acv.a_mblock.mb_data_size := acv.a_mb_data_size;
        (* PTS 1116339 FF 2002-06-26                    *)
        (* creation of COM instance has been moved here *)
        (* to allow SQL with 'Register' method          *)
        cip.force_run_in_kernel := kernel_only;
        cip.library_name := NIL;
        vdcom_get_dispaddr (cip);
        IF  cip.ret <> 0
        THEN
            BEGIN
            IF  cip.ret = c_parse_again
            THEN
                BEGIN
                parse_again := true;
                goto 999;
                END
            ELSE
                BEGIN
                ak260CreateInstance (acv, cip, dp.method_name, packageId);
                IF  cip.ret <> 0
                THEN
                    goto 999
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*dp.coclassname          := cip.coclassname; CTS 1103603 FF 12-Aug-99 *)
        (*ENDIF*) 
        dp.idispatch              := cip.idispatch;
        dp.ifactory               := cip.ifactory;
        dp.session_context        := @acv;
        dp.param_stack            := pStack;
        dp.param_stack_len        := stack_len;
        dp.run_in_ude_server      := cip.run_in_ude_server;
        dp.coclsid                := cip.coclsid;
        dp.iid                    := cip.iid;
        (* TODO: NUR wenn UDE-Server *)
        IF  cip.library_name = NIL
        THEN
            a12LoadFileInfo(acv, packageId, dp.library_name, dp.MD5_footprint)
        ELSE
            BEGIN
            dp.library_name  := cip.library_name;
            dp.MD5_footprint := cip.MD5_footprint
            END;
        (*ENDIF*) 
        acv.a_outstanding_packet  := false;
        acv.a_dca.stop_msg_set    := false;
        acv.a_allocatorInfo.ai_badAllocCount := 0; (* PTS 1126797 *)
        acv.a_allocatorInfo.ai_HeapUsageMax := 0;
        ak260InitAllocatorMonitorInfo(acv.a_allocatorInfo.ai_alloc_sys);
        ak260InitAllocatorMonitorInfo(acv.a_allocatorInfo.ai_alloc_usr);
        savedDbprocCallInfo := acv.a_dbproc_call_info;
        acv.a_dbproc_call_info.dbc_conversionError := false;
&       ifdef OMSTST
        acv.a_allocatorInfo.ai_badAllocCountDown := badAllocCntDwn;
&       endif
        acv.a_isInCppDBProcedure  := true;  (* PTS 1110148 *)
        currDBProcedure := acv.a_curr_dbprocedure;
        acv.a_curr_dbprocedure := pcip^.surrogate;
        vdcom_dbproc (dp);
        acv.a_curr_dbprocedure := currDBProcedure;
        acv.a_isInCppDBProcedure  := false; (* PTS 1110148 *)
        IF  acv.a_dbproc_call_info.dbc_conversionError
        THEN
            BEGIN
            (* conversion error, UNICODE<->ASCII *)
            FOR ix := 1 TO paramNo DO
                IF  stack[ix].dbg_vt in [csp1_vt_lc_abap_tab_handle, csp1_vt_lc_stream_handle]
                THEN
                    ak263WriteConversionError (acv, stack[ix].dbg_value.ptr,
                          ix, acv.a_dbproc_call_info.dbc_errorTableId, dbproc_name);
                (*ENDIF*) 
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        acv.a_dbproc_call_info := savedDbprocCallInfo;
        ak341ReleaseEmergencyAllocator(acv.a_transinf.tri_trans.trTaskId_gg00);
        a34outstanding_packet (acv, e);
        IF  e <> e_ok
        THEN
            acv.a_returncode := e
        ELSE
            BEGIN
&           ifdef OMSTST
            (* PTS 1112358 *)
            IF  (dp.hresult = c_terminated_hresult) AND NOT ak341NormalOmsTerminateHandling
            THEN
                IF  (acv.a_allocatorInfo.ai_badAllocCountDown = -2)
                THEN (* required bad alloc has been thrown *)
                    dp.hresult := 0
                ELSE
                    BEGIN
                    (* a exception has been provoked by the test-kernel.     *)
                    (* No sqlcode must be set in this case                   *)
                    IF  acv.a_provoked_exception = true
                    THEN
                        BEGIN
                        dp.hresult := 0;
                        acv.a_provoked_exception := false
                              (* ENDIF *)
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
&           endif
            (*ENDIF*) 
            IF  dp.hresult <> 0
            THEN
                BEGIN
                a06reset_retpart (acv);
                IF  dp.hresult = c_user_defined_hresult
                THEN
                    BEGIN
                    IF  ((acv.a_returncode =  e_oms_istream_error) OR
                        ( acv.a_returncode =  e_oms_ostream_error))
                        AND
                        (acv.a_dca.msgno = acv.a_returncode)
                    THEN
                        BEGIN
                        e := acv.a_returncode;
                        acv.a_user_defined_error           := false;
                        acv.a_returncode := 0;
                        a06reset_retpart      (acv);
                        a06init_curr_retpart  (acv);
                        (* this message is always ascii7, comes from precompiler runtime *)
                        a07_const_b_put_error (acv, e, 1, @acv.a_dca.stop_msg,
                              sizeof (acv.a_dca.stop_msg))
                        END
                    ELSE (* PTS 1102574, T.A. 1999-05-05 *)
                        IF  acv.a_dca.stop_msg_set
                        THEN
                            BEGIN
                            IF  trans_rollback in acv.a_rollback_info
                            THEN (* PTS 1109695 *)
                                rollbackWanted := true;
                            (*ENDIF*) 
                            acv.a_rollback_info                := [];
                            acv.a_user_defined_error           := true;
                            acv.a_returncode := acv.a_dca.msgno;
                            a06retpart_move (acv, @acv.a_dca.stop_msg, sizeof (acv.a_dca.stop_msg));
                            a06finish_curr_retpart (acv, sp1pk_errortext, 1)
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    a06init_curr_retpart  (acv);
                    a260hresult_error (dp.hresult, dbproc_name, dp.errtext, e);
                    IF  (e = e_com_object_crashed) OR (e = e_cancelled)
                    THEN (* PTS 1105154 *)
                        BEGIN
                        IF  (dp.hresult = c_terminated_hresult) AND acv.a_dca.stop_msg_set
                        THEN (* PTS 1109693 *)
                            BEGIN
                            pC64 := @acv.a_dca.stop_msg;
                            IF  pC64^ <> bsp_c64
                            THEN
                                dp.errtext := pC64^;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        a07_b_put_error (acv, e_work_rolled_back, 1);
                        acv.a_rollback_info := [trans_rollback]
                        END
                    ELSE
                        a07_nb_put_error  (acv, e, 1, dbproc_name);
                    (*ENDIF*) 
                    IF  dp.errtext <> bsp_c64
                    THEN
                        a07ClientLayoutParam (acv, c_next_param,
                              @dp.errtext, sizeof (dp.errtext));
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            ELSE
                IF  NOT is_trigger
                THEN
                    BEGIN
                    IF  NOT acv.a_user_defined_error
                    THEN
                        acv.a_returncode := 0;
                    (*ENDIF*) 
                    a06reset_retpart (acv);
                    IF  out_parm_cnt > 0
                    THEN
                        BEGIN
                        a06init_curr_retpart (acv);
                        IF  acv.a_curr_retpart^.sp1p_buf_len + buf_pos[c_inout] + buf_pos[c_out] >
                            acv.a_curr_retpart^.sp1p_buf_size
                        THEN
                            BEGIN
                            a07_b_put_error (acv,
                                  e_too_small_packet_size, 1);
                            goto 999
                            END;
                        (*ENDIF*) 
                        IF  res_buf_ptr <> NIL
                        THEN
                            SAPDB_PascalMove  ('VAK260',   7,    
                                  out_length, acv.a_curr_retpart^.sp1p_buf_size,
                                  @res_buf_ptr^, 1, @acv.a_curr_retpart^.sp1p_buf, 1, out_length,
                                  acv.a_returncode);
                        (*ENDIF*) 
                        FOR ix := 1 TO out_parm_cnt DO
                            WITH out_parms[ix], acv.a_curr_retpart^ DO
                                BEGIN
                                CASE op_vt OF
                                    csp1_vt_i1, csp1_vt_ui1, csp1_vt_lc_byte, csp1_vt_lc_bool  :
                                        BEGIN
                                        sp1p_buf[op_offset + 1] := csp_defined_byte;
                                        sp1p_buf[op_offset + 2] := op_val.i1[1];
                                        END;
                                    csp1_vt_lc_char, csp1_vt_lc_ascii7, csp1_vt_lc_numc :   (* PTS 1131373, PG *)
                                        BEGIN
                                        IF  isUnicodeClient
                                        THEN
                                            BEGIN
                                            sp1p_buf[op_offset + 1] := csp_unicode_def_byte;
                                            sp1p_buf[op_offset + 2 + highByte] := chr(0);
                                            sp1p_buf[op_offset + 2 + lowByte ] := op_val.i1[1];
                                            END
                                        ELSE
                                            BEGIN
                                            sp1p_buf[op_offset + 1] := csp_ascii_blank;
                                            sp1p_buf[op_offset + 2] := op_val.i1[1];
                                            END;
                                        (*ENDIF*) 
                                        END;
                                    csp1_vt_lc_wchar :
                                        BEGIN
                                        sp1p_buf[op_offset + 1] := csp_unicode_def_byte;
                                        sp1p_buf[op_offset + 2] := op_val.c2[1];
                                        sp1p_buf[op_offset + 3] := op_val.c2[2];
                                        END;
                                    csp1_vt_lc_int1 :
                                        BEGIN
                                        sp1p_buf[op_offset + 1] :=
                                              csp_defined_byte;
                                        (* PTS 1103190, T.A. 1999-07-02 *)
                                        i2 := ord (op_val.i1[1]);
                                        IF  i2 > 127
                                        THEN
                                            i2 := i2 - 256;
                                        (*ENDIF*) 
                                        s41plint (sp1p_buf,
                                              op_offset + 2, 5, 0, i2, res);
                                        END;
                                    csp1_vt_lc_uint1 :          (* PTS 1104796, FF 1999-11-29 *)
                                        BEGIN
                                        sp1p_buf[op_offset + 1] :=
                                              csp_defined_byte;
                                        i2 := ord (op_val.i1[1]);
                                        s41plint (sp1p_buf,
                                              op_offset + 2, 5, 0, i2, res);
                                        END;
                                    csp1_vt_i2 :
                                        BEGIN
                                        sp1p_buf[op_offset + 1] :=
                                              csp_defined_byte;
                                        s41plint (sp1p_buf,
                                              op_offset + 2, 5, 0, op_val.i2,
                                              res);
                                        END;
                                    csp1_vt_ui2 :
                                        BEGIN
                                        sp1p_buf[op_offset + 1] :=
                                              csp_defined_byte;
                                        s41psuns (sp1p_buf,
                                              op_offset + 2, 5, 0, op_val.i2,
                                              res);
                                        END;
                                    csp1_vt_i4, csp1_vt_int :
                                        BEGIN
                                        sp1p_buf[op_offset + 1] :=
                                              csp_defined_byte;
                                        s41plint (sp1p_buf,
                                              op_offset + 2, 10, 0,
                                              op_val.i4, res);
                                        END;
                                    csp1_vt_ui4, csp1_vt_uint :
                                        BEGIN
                                        sp1p_buf[op_offset + 1] :=
                                              csp_defined_byte;
                                        s41pluns (sp1p_buf,
                                              op_offset + 2, 10, 0,
                                              op_val.i4, res)
                                        END;
                                    csp1_vt_r4 :
                                        BEGIN
                                        sp1p_buf[op_offset + 1] :=
                                              csp_defined_byte;
                                        s41plrel (sp1p_buf,
                                              op_offset + 2, (op_io_len-2) * 2,
                                              csp_float_frac,
                                              op_val.r4, res);
                                        END;
                                    csp1_vt_r8 :
                                        BEGIN
                                        sp1p_buf[op_offset + 1] :=
                                              csp_defined_byte;
                                        s41plrel (sp1p_buf,
                                              op_offset + 2, (op_io_len-2) * 2,
                                              csp_float_frac,
                                              op_val.r8, res);
                                        END;
                                    csp1_vt_i8 :
                                        BEGIN
                                        sp1p_buf[op_offset + 1] := csp_defined_byte;
                                        ak263Int8ToNumber (op_val.i8, @sp1p_buf[op_offset+2], op_io_len, res);
                                        END;
                                    csp1_vt_ui8 :
                                        BEGIN
                                        sp1p_buf[op_offset + 1] := csp_defined_byte;
                                        ak263UInt8ToNumber (op_val.i8, @sp1p_buf[op_offset+2], op_io_len, res);
                                        END;
                                    csp1_vt_carray :
                                        BEGIN
                                        IF  op_datatype[1] = chr(ord(dcha))
                                        THEN
                                            sp1p_buf[op_offset + 1] :=
                                                  csp_ascii_blank
                                        ELSE
                                            IF  op_datatype[1] = chr(ord(dunicode))
                                            THEN
                                                sp1p_buf[op_offset + 1] :=
                                                      csp_unicode_def_byte
                                            ELSE
                                                sp1p_buf[op_offset + 1] :=
                                                      csp_defined_byte;
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                        IF  op_datatype[1] = chr(ord(dwyde))
                                        THEN
                                            IF  isUnicodeClient
                                            THEN
                                                BEGIN (* TODO *)
                                                sp1p_buf[op_offset + 1] :=
                                                      csp_unicode_def_byte;
                                                END
                                            ELSE
                                                BEGIN
                                                sp1p_buf[op_offset + 1] := csp_ascii_blank;
                                                pWydeArray := @sp1p_buf[op_offset + 1 + ix];
                                                FOR jx := 1 TO op_io_len - 1 DO
                                                    IF  pWydeArray^[jx] > 255
                                                    THEN
                                                     BEGIN
                                                     ak263WriteTranslationError (acv, dbproc_name, op_paramNo,
                                                        op_offset + jx, pWydeArray^[jx]);
                                                     a07_b_put_error (acv, e_not_translatable, 1);
                                                     goto 999;
                                                     END
                                                    ELSE
                                                     sp1p_buf[op_offset + 1 + jx] := chr(pWydeArray^[jx]);
                                                    (*ENDIF*) 
                                                (*ENDFOR*) 
                                                END;
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                        END;
                                    csp1_vt_userdefined :
                                        BEGIN
                                        sp1p_buf[op_offset + 1] :=
                                              csp_defined_byte;
                                        IF  op_translateIdx <> 0
                                        THEN
                                            BEGIN
                                            param_addr := op_val.ptr;
                                            IF  op_swapIdx <> 0
                                            THEN
                                                BEGIN
                                                ak260SwapParameter (pParamDesc^, op_swapIdx, param_addr);
                                                op_swapIdx := 0
                                                END;
&                                           ifdef trace
                                            (*ENDIF*) 
                                            t01addr    (ak_sem, 'param_addr  ', param_addr);
                                            t01moveobj (ak_sem, param_addr^, 1, op_cpp_len);
&                                           endif
                                            st_ix    := op_translateIdx - 1;
                                            exitLoop := false;
                                            REPEAT
                                                st_ix   := st_ix + 1;
                                                curr_st := @pParamDesc^[st_ix];
                                                IF  (curr_st^.etype = st_op)
                                                THEN
                                                    BEGIN
                                                    (* position in cpp layout    *)
                                                    srcPos   := curr_st^.epos + 1;
                                                    (* position in client layout *)
                                                    destPos  := op_offset + 1 + curr_st^.ecol_pos + 1;
                                                    CASE curr_st^.eop OF
                                                     op_trunc :
                                                      BEGIN (* wyde client layout, ascii c++ layout *)
                                                      FOR jx := 1 TO curr_st^.elen_var DO
                                                       BEGIN
                                                       sp1p_buf[destPos+highByte] := chr(0);
                                                       sp1p_buf[destPos+lowByte ] := param_addr^[srcPos];
                                                       srcPos  := srcPos + 1;
                                                       destPos := destPos + 2;
                                                       END;
                                                      (*ENDFOR*) 
                                                      END;
                                                     op_dbyte_translate :
                                                      BEGIN (* ascii client layout, wyde c++ layout *)
                                                      pWydeArray := @param_addr^[srcPos];
                                                      FOR jx := 1 TO curr_st^.elen_var DO
                                                       BEGIN
                                                       sp1p_buf[destPos] := chr(pWydeArray^[jx]);
                                                       destPos := destPos + 1;
                                                       END;
                                                      (*ENDFOR*) 
                                                      END;
                                                     op_none :
                                                      BEGIN (* just copy member without any transformation *)
                                                      FOR jx := 1 TO curr_st^.elen_var DO
                                                       BEGIN
                                                       sp1p_buf[destPos] := param_addr^[srcPos];
                                                       srcPos  := srcPos + 1;
                                                       destPos := destPos + 1;
                                                       END;
                                                      (*ENDFOR*) 
                                                      END;
                                                     OTHERWISE
                                                      exitLoop := true;
                                                     END;
                                                    (*ENDCASE*) 
                                                    END
                                                ELSE
                                                    exitLoop := true;
                                                (*ENDIF*) 
                                            UNTIL
                                                exitLoop;
                                            (*ENDREPEAT*) 
                                            END;
                                        (*ENDIF*) 
                                        END;
                                    OTHERWISE
                                        a07_b_put_error (acv,
                                              e_not_implemented, 1)
                                    END;
                                (*ENDCASE*) 
                                IF  op_swapIdx <> 0
                                THEN
                                    ak260SwapParameter (pParamDesc^, op_swapIdx, @sp1p_buf[op_offset+2]);
                                (*ENDIF*) 
                                END;
                            (*ENDWITH*) 
                        (*ENDFOR*) 
&                       ifdef trace
                        t01int4 (ak_sem, 'buf_pos[io] ', buf_pos[c_inout]);
                        t01int4 (ak_sem, 'buf_pos[o]  ', buf_pos[c_out]);
&                       endif
                        acv.a_curr_retpart^.sp1p_buf_len := acv.a_curr_retpart^.sp1p_buf_len +
                              buf_pos[c_out];
                        a06finish_curr_retpart (acv, sp1pk_data, 1);
                        a06retpart_move        (acv, @g01glob.rescnt_1, sizeof (g01glob.rescnt_1));
                        a06finish_curr_retpart (acv, sp1pk_resultcount, 1)
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    999 : ;
&   ifdef OMSTST
    IF  (acv.a_allocatorInfo.ai_badAllocCountDown < 0)
    THEN (* disable bad alloc count down, PTS 1112358 *)
        acv.a_allocatorInfo.ai_badAllocCountDown := -1;
&   endif
    (*ENDIF*) 
    WHILE pParam <> NIL DO
        BEGIN
        param_addr := @pParam^;
        pParam     := pParam^.next;
        gg941Deallocate (acv.a_transinf.tri_trans, param_addr);
        END;
    (*ENDWHILE*) 
    IF  res_buf_ptr <> NIL
    THEN
        gg941Deallocate (acv.a_transinf.tri_trans, res_buf_ptr);
    (*ENDIF*) 
    IF  pParamDesc <> NIL
    THEN
        BEGIN
        param_addr := @pParamDesc^;
        gg941Deallocate (acv.a_transinf.tri_trans, param_addr)
        END;
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260CallInternalDBProc (
            VAR acv          : tak_all_command_glob;
            VAR mblock       : tgg00_MessBlock;
            VAR isCursorProc : boolean);
 
VAR
      outParamCount : integer;
 
BEGIN
&ifdef trace
t01messblock (ak_sem, 'a_mblock    ', acv.a_mblock);
&endif
;
a101_ProcedureCall (acv, outParamCount);
isCursorProc := acv.a_return_segm^.sp1r_function_code = csp1_cursor_pl_sql_execute_fc;
IF  (outParamCount > 0) AND (acv.a_returncode = 0)
THEN
    BEGIN
    a06finish_curr_retpart (acv, sp1pk_data, 1);
    a06retpart_move        (acv, @g01glob.rescnt_1, sizeof (g01glob.rescnt_1));
    a06finish_curr_retpart (acv, sp1pk_resultcount, 1)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260parse_again   (
            VAR acv     : tak_all_command_glob;
            VAR parskey : tak_parskey);
 
VAR
      e         : tgg00_BasisError;
      pcip      : ^tcreate_inst_params;
      methodbuf : tak_sysbufferaddress;
      mbbuf     : tak_sysbufferaddress;
      pmbp      : tgg00_MessBlockPtr;
      sysk      : tgg00_SysInfoKey;
 
BEGIN
pcip := @acv.a_mblock.mb_data^.mbp_buf[
      acv.a_mblock.mb_st^[acv.a_mblock.mb_qual^.mstrat_pos].epos];
sysk           := a01defaultkey;
sysk.sauthid   := pcip^.surrogate;
sysk.sentrytyp := cak_emethod;
a10_key_del     (acv, sysk);
acv.a_parsing_again := true;
a10get_sysinfo (acv, sysk, d_release, methodbuf, e);
IF  e = e_ok
THEN
    BEGIN
    pcip^.coclsid     := methodbuf^.smethod.me_coclsid;
    pcip^.iid         := methodbuf^.smethod.me_iid;
    sysk              := a01sysnullkey;
    sysk.sauthid[ 1 ] := cak_tempinfo_byte;
    SAPDB_PascalForcedMove (sizeof(parskey), sizeof(sysk.sauthid), @parskey, 1,
          @sysk.sauthid, 2, mxak_parskey);
    sysk.sauthid[1 + mxak_parskey    ] := chr(0);
    sysk.sentrytyp := cak_emessblock;
    a10get_sysinfo (acv, sysk, d_release, mbbuf, e);
    IF  e = e_ok
    THEN
        BEGIN
        pmbp := @mbbuf^.smessblock.mbr_mess_block;
        pcip := @pmbp^.mb_data^.mbp_buf[
              pmbp^.mb_st^[pmbp^.mb_qual^.mstrat_pos].epos];
        pcip^.coclsid := methodbuf^.smethod.me_coclsid;
        pcip^.iid     := methodbuf^.smethod.me_iid;
        a10repl_sysinfo (acv, mbbuf, e)
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260GetDBProcOwner (
            VAR acv          : tak_all_command_glob;
            VAR MethodRecord : tak_methodrecord;
            VAR OwnerId      : tgg00_Surrogate);
 
VAR
      e             : tgg00_BasisError;
      methodInfoBuf : tak_sysbufferaddress;
      sysk          : tgg00_SysInfoKey;
 
BEGIN
IF  MethodRecord.me_type = dbo_dbfunc
THEN
    OwnerId := MethodRecord.me_owner
ELSE
    BEGIN
    sysk.sauthid    := MethodRecord.me_surrogate;
    sysk.sentrytyp  := cak_emethodinfo;
    sysk.slinkage   := cak_init_linkage;
    sysk.skeylen    := mxak_standard_sysk;
    a10get_sysinfo (acv, sysk, d_release, methodInfoBuf, e);
    IF  e = e_ok
    THEN
        OwnerId := methodInfoBuf^.smethodinfo.mei_owner
    ELSE
        a07_b_put_error (acv, e, 1)
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260get_proc (
            VAR acv        : tak_all_command_glob;
            VAR authname   : tsp00_KnlIdentifier;
            VAR proc       : tsp00_KnlIdentifier;
            VAR tree_index : integer);
 
BEGIN
WITH acv DO
    BEGIN
&   ifdef trace
    t01int4 (ak_sem, 'tree_index  ', tree_index);
&   endif
    IF  a_ap_tree^[tree_index].n_symb = s_authid
    THEN
        a06get_username (acv, tree_index, authname)
    ELSE
        authname := a_curr_schema;
    (*ENDIF*) 
    a05identifier_get (acv, tree_index, sizeof (proc), proc);
    tree_index := a_ap_tree^[tree_index].n_sa_level
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260internal_proc_call (VAR acv : tak_all_command_glob);
 
CONST
      c_kernel_only = true;
 
VAR
      rename_curr_user    : boolean;
      rollbackWanted      : boolean; (* PTS 1109362 *)
      h_variable_input    : boolean;
      h_ascii_output      : boolean;
      dummyCnt            : integer;
      e                   : tgg00_BasisError;
      init_ddl            : tak_ddl_descriptor;
      init_sqlmode        : tsp00_SqlMode;
      init_statement_kind : tgg00_RefInfoIndex;
      method_buf          : tak_sysbufferaddress;
      mblock_ptr          : tak_sysbufferaddress;
      pCode               : tak_sysbufferaddress;
      aux_curr_user       : tsp00_KnlIdentifier;
      dummy_bool          : boolean;
      cip                 : tcreate_inst_params;
      mblock              : tgg00_MessBlock;
      qual                : tgg00_QualBuf;
      out_packet_ptr      : tsp1_packet_ptr;
      packet_header       : tsp1_packet_header;
      segm_header         : tsp1_segment_header;
      CodeSyskey          : tgg00_SysInfoKey;
      stack               : ARRAY[0..1] OF tgg00_StackEntry;
 
BEGIN
WITH acv DO
    BEGIN
    h_variable_input := a_variable_input;
    a_variable_input := false;
    h_ascii_output   := a_ascii_in_and_output;
    a_ascii_in_and_output   := false;
    rename_curr_user := (a_is_ddl = ddl_rename_user) AND
          (a_acc_user <> a_curr_user_name);
    IF  NOT (a_cmd_segment_header.sp1c_mess_type in [sp1m_parse, sp1m_syntax])
        AND
        (a_usage_curr.fileRoot_gg00 <> NIL_PAGE_NO_GG00)
        AND
        (a_init_ddl <> no_ddl)
        AND
        ak260main_exists
    THEN
        BEGIN
        IF  NOT acv.a_progusage_add AND g01trigger
            AND
            (a_returncode = 0)
        THEN
            BEGIN
            (* ddl order that requires a stored procedure call *)
            (* has been executed                               *)
            init_sqlmode := acv.a_sqlmode;
            init_statement_kind := acv.a_statement_kind;
            IF  rename_curr_user
            THEN
                BEGIN
                aux_curr_user    := a_curr_user_name;
                a_connected_name := a_acc_user;
                a_curr_user_name := a_acc_user
                END;
            (*ENDIF*) 
            IF  a_ex_kind = only_parsing
            THEN
                a_pars_last_key.p_kind := m_nil;
            (*ENDIF*) 
            IF  a12dbproc_exist (acv, g01glob.sysuser_name, a01_i_sysddltrigger, d_release, method_buf)
            THEN
                BEGIN
                acv.a_in_ddl_trigger       := true;
                packet_header              := a_out_packet^.sp1_header;
                out_packet_ptr             := a_out_packet;
                segm_header                := a_out_packet^.sp1_segm.sp1s_segm_header;
                a_dbproc_level             := a_dbproc_level + 1;
                a101_IncrementProcLevel (acv);
                a_in_internal_subtr        := false;
                init_ddl                   := acv.a_init_ddl;
                a06a_mblock_init (acv, m_delete, mm_file, b01niltree_id);
                acv.a_mblock.mb_qual^.mtree.fileTabId_gg00 := method_buf^.smethod.me_surrogate;
                pCode := NIL;
                a262LoadCode (acv, method_buf^.smethod.me_surrogate, cak_init_linkage, pCode);
                IF  pCode <> NIL
                THEN
                    BEGIN
                    a260BuildCodeSyskey (method_buf^.smethod.me_surrogate, CodeSyskey);
                    a10get_sysinfo (acv, CodeSyskey, d_release, mblock_ptr, e);
                    IF  e = e_sysinfo_not_found
                    THEN
                        BEGIN
                        a10mblock_into_cache (acv, CodeSyskey,
                              pCode^.smessblock.mbr_mess_block, d_release, mblock_ptr, e);
                        IF  e = e_ok
                        THEN
                            a10add_sysinfo (acv, mblock_ptr, e);
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    a10rel_sysinfo (pCode);
                    acv.a_in_ddl_trigger := true;
                    acv.a_dbproc_level   := acv.a_dbproc_level + 1; (* PTS 1133300 TA 2005-01-11 *)
                    a101_IncrementProcLevel (acv);
                    IF  e = e_ok
                    THEN
                        BEGIN
                        a101_ProcedureCall (acv, dummyCnt);
                        END;
                    (*ENDIF*) 
                    acv.a_dbproc_level   := acv.a_dbproc_level - 1; (* PTS 1133300 TA 2005-01-11 *)
                    a101_DecrementProcLevel (acv);
                    acv.a_in_ddl_trigger := false;
                    END
                ELSE
                    e := e_sysinfo_not_found;
                (*ENDIF*) 
                IF  e <> e_ok
                THEN
                    a07_b_put_error (acv, e, 1);
                (*ENDIF*) 
                a_in_internal_subtr        := true;
                a_dbproc_level             := a_dbproc_level - 1;
                a101_DecrementProcLevel (acv);
                IF  (a_returncode = 0) OR (NOT acv.a_user_defined_error)
                THEN
                    BEGIN
                    a_out_packet                            := out_packet_ptr;
                    a_out_packet^.sp1_header                := packet_header;
                    a_out_packet^.sp1_segm.sp1s_segm_header := segm_header;
                    a_return_segm                           := @a_out_packet^.sp1_segm;
                    END;
                (*ENDIF*) 
                acv.a_in_ddl_trigger := false;
                acv.a_init_ddl       := init_ddl;
                acv.a_is_ddl         := init_ddl;
                acv.a_sqlmode        := init_sqlmode;
                acv.a_statement_kind := init_statement_kind;
                END;
            (*ENDIF*) 
            IF  rename_curr_user
            THEN
                BEGIN
                a_connected_name := aux_curr_user;
                a_curr_user_name := aux_curr_user
                END;
            (*ENDIF*) 
            END;
        (* restore procedure information before  *)
        (* internal procedure call               *)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_returncode <> 0
    THEN
        BEGIN
        a10_cache_delete (acv, NOT c_is_rollback);
        a_part_rollback := true
        END
    ELSE
        IF  rename_curr_user
        THEN
            BEGIN
            a52_ex_commit_rollback (acv, m_commit, false, false);
            IF  a_returncode  = 0
            THEN
                BEGIN
                IF  a_curr_user_name = g01glob.sysuser_name
                THEN (* actually sysuser_name must be *)
                    (*  protected by a region         *)
                    g01glob.sysuser_name := a_acc_user;
                (*ENDIF*) 
                a_connected_name := a_acc_user;
                a_curr_user_name := a_acc_user
                END
            ELSE
                a_acc_user := a_connected_name
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    a_variable_input := h_variable_input;
    a_ascii_in_and_output   := h_ascii_output;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260init;
 
BEGIN
ak260main_exists := false;
a260reset_statistics
END;
 
(*------------------------------*) 
 
FUNCTION
      a260IsInternalDBProc (VAR MethodRec : tak_methodrecord) : boolean;
 
BEGIN
a260IsInternalDBProc := MethodRec.me_package_id = cgg_zero_id
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260reset_statistics;
 
BEGIN
ak260ext_proc_call_cnt := 0;
ak260int_proc_call_cnt := 0
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260session_frame_release (VAR acv : tak_all_command_glob);
 
BEGIN
IF  acv.a_dbp_packet_ptr <> NIL
THEN
    BEGIN
    vmfree (acv.a_dbp_packet_ptr);
    acv.a_dbp_packet_ptr := NIL
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260statistics (
            VAR external_proc_cnt : tsp00_8ByteCounter;
            VAR internal_proc_cnt : tsp00_8ByteCounter);
 
BEGIN
external_proc_cnt := ak260ext_proc_call_cnt;
internal_proc_cnt := ak260int_proc_call_cnt
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260sysdbproc_exist (VAR acv : tak_all_command_glob);
 
VAR
      procbuf : tak_sysbufferaddress;
 
BEGIN
IF  a12dbproc_exist (acv, g01glob.sysuser_name, a01_i_sysddltrigger, d_release, procbuf)
THEN
    ak260main_exists := true;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260TransEnd (
            VAR acv  : tak_all_command_glob;
            messType : tgg00_MessType;
            release  : boolean;
            VAR e    : tgg00_BasisError);
 
CONST
      c_sys_dispid = 5;
      c_transend_failed = -2147220716;
 
TYPE
 
      ttransEndBuf = RECORD
            CASE integer OF
                1 :
                    (mtype : tgg00_MessType;
                    mtype2 : tgg00_MessType2);
                2 :
                    (retcode : tgg00_BasisError);
                3 :
                    (align   : tsp00_Int4);
                END;
            (*ENDCASE*) 
 
 
VAR
      exit_loop : boolean;
      dp        : tsp_dcom_dispatch_parms;
      bufLen    : tsp00_Int4;
      buf       : ttransEndBuf;
      dbprocLvl : integer;
 
      stack : RECORD
            plong     : ^tsp00_Int4;
            pBuf      : ^ttransEndBuf;
      END;
 
 
BEGIN
IF  (acv.a_no_of_com_objects > 0)
THEN
    BEGIN
&   ifdef OMSTST
    (* no bad allocs wanted in this phase *)
    acv.a_allocatorInfo.ai_badAllocCountDown := -1;
&   endif
    dbprocLvl          := acv.a_dbproc_level;
    acv.a_dbproc_level := 1; (* prevent from implicit session release, PTS 1112420 *)
    e                  := e_ok;
    dp.idispatch       := NIL;
    dp.ifactory        := NIL;
    dp.session_context := @acv;
    dp.session         := acv.a_transinf.tri_trans.trSessionId_gg00.ci4_gg00;
    dp.dispid          := c_sys_dispid;
    dp.hresult         := 0;
    dp.param_stack     := @stack;
    dp.param_stack_len := sizeof(stack);
    (* dp.debug_mode      := false; PTS 1112663 *)
    (* dp.debug_location  := NIL;   PTS 1112663 *)
    dp.errtext         := bsp_c64;
    (* change Request 1000139, T.A. 14.10.1998 *)
    dp.method_name := 'Transaction End                                                 ';
    IF  g01unicode
    THEN
        a01setl_identifier (dp.method_name, dp.method_name);
    (*ENDIF*) 
    dp.monitoring      := messType <> m_unlock;
    dp.monitor_slot_id := 0;
    acv.a_allocatorInfo.ai_badAllocCount := 0; (* PTS 1126797 *)
    acv.a_allocatorInfo.ai_HeapUsageCurrent := 0;
    acv.a_allocatorInfo.ai_HeapUsageMax := 0;
    ak260InitAllocatorMonitorInfo(acv.a_allocatorInfo.ai_alloc_sys);
    ak260InitAllocatorMonitorInfo(acv.a_allocatorInfo.ai_alloc_usr);
    REPEAT
        buf.mtype := messType;
        IF  release
        THEN
            buf.mtype2 := mm_close
        ELSE
            buf.mtype2 := mm_nil;
        (*ENDIF*) 
        bufLen             := sizeof(buf.mtype) + sizeof(buf.mtype2);
        stack.plong        := @bufLen;
        stack.pBuf         := @buf;
        vdcom_trans_end (dp);
        IF  (dp.hresult <> 0) AND (messType = m_commit)
        THEN
            BEGIN
            IF  dp.hresult = c_transend_failed
            THEN
                e := buf.retcode
            ELSE
                e := e_invalid;
            (*ENDIF*) 
            messType  := m_rollback;
            exit_loop := false
            END
        ELSE
            exit_loop := true;
        (*ENDIF*) 
    UNTIL
        exit_loop;
    (*ENDREPEAT*) 
    acv.a_dbproc_level := dbprocLvl;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260trigger_parsinfo (
            VAR acv         : tak_all_command_glob;
            VAR parsinfokey : tgg00_SysInfoKey;
            VAR proc_id     : tgg00_Surrogate);
 
CONST
      c_commit = true;
 
VAR
      e           : tgg00_BasisError;
      pos         : integer;
      ix          : integer;
      methodbuf   : tak_sysbufferaddress;
      mblock_ptr  : tak_sysbufferaddress;
      sysk        : tgg00_SysInfoKey;
      dbproc_name : tsp00_KnlIdentifier;
      cip         : tcreate_inst_params;
      qual        : ARRAY[1..1024] OF char;
      stack       : ARRAY[1..2048] OF char;
      mblock      : tgg00_MessBlock;
 
BEGIN
sysk           := a01defaultkey;
sysk.sauthid   := proc_id;
sysk.sentrytyp := cak_emethod;
a10get_sysinfo (acv, sysk, d_release, methodbuf, e);
IF  e = e_ok
THEN
    BEGIN
    pos := 1;
    g01mblock_init   (acv.a_transinf.tri_trans, m_nil, mm_nil, mblock);
    g01stack_init    (mblock, @stack, sizeof (stack), @qual, sizeof(qual));
    g01datapart_init (mblock, @cip, sizeof (cip));
    WITH methodbuf^.smethod, mblock.mb_qual^ DO
        FOR ix := 1 TO me_param_cnt DO
            WITH me_param_list[ix]^ DO
                BEGIN
                WITH mblock.mb_st^[mfirst_free] DO
                    BEGIN
                    etype       := st_value;
                    eop         := op_none;
                    epos        := pos;
                    elen_var    := param_inoutlength;
                    ecol_tab[1] := chr(1);
                    ecol_tab[2] := chr(0)
                    END;
                (*ENDWITH*) 
                mfirst_free := mfirst_free + 1;
                WITH mblock.mb_st^[mfirst_free]  DO
                    BEGIN
                    etype          := st_dbproc_param;
                    eop            := op_in;
                    eparamdatatype := param_datatype;
                    efraction      := param_datafrac;
                    elen_var       := param_inoutlength;
                    ecol_tab[1]    := chr(param_com_datatype);
                    ecol_tab[2]    := chr(0);
                    pos := pos + param_inoutlength;
                    END;
                (*ENDWITH*) 
                mfirst_free := mfirst_free + 1
                END;
            (*ENDWITH*) 
        (*ENDFOR*) 
    (*ENDWITH*) 
    mblock.mb_qual^.mqual_pos := 1;
    mblock.mb_qual^.mqual_cnt :=
          mblock.mb_qual^.mfirst_free - 1;
    ak260describe_dbproc (acv, mblock, dbproc_name, 0, 0, 0, NOT c_commit,
          0, 0, methodbuf);
    a10mblock_into_cache (acv, parsinfokey, mblock, d_release, mblock_ptr, e);
    END;
(*ENDIF*) 
IF  e = e_ok
THEN
    a10add_sysinfo (acv, mblock_ptr, e);
(*ENDIF*) 
IF  (e <> e_ok) AND (e <> e_duplicate_sysinfo)
THEN
    a07_b_put_error (acv, e, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260trigger_call (
            VAR acv          : tak_all_command_glob;
            trigger_parsinfo : tak_sysbufferaddress);
 
CONST
      c_kernel_only = true;
 
VAR
      dummy       : boolean;
      parse_again : boolean;
      with_commit : boolean;
 
BEGIN
with_commit           := false;
parse_again           := false;
ak260dbproc_call (acv, trigger_parsinfo^.smessblock.mbr_mess_block,
      NOT c_monitoring, c_is_trigger, with_commit, parse_again, dummy, c_kernel_only);
IF  parse_again
THEN
    a07_b_put_error (acv, e_old_fileversion, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260long_info (
            VAR acv           : tak_all_command_glob;
            VAR dbproc        : tak_methodrecord;
            VAR paramNameInfo : tak260ParamNameInfo);
 
VAR
      count     : integer;
      ix        : integer;
      jx        : integer;
 
BEGIN
WITH acv DO
    BEGIN
    count := 0;
    WITH dbproc DO
        FOR ix := 1 TO me_param_cnt DO
            WITH me_param_list[ix]^ DO
                FOR jx := 1 TO paramNameInfo[ix] DO
                    BEGIN
                    count := count + 1;
                    a06colname_retpart_move (acv, @param_name,
                          ord (param_name_len), csp_unicode);
                    END;
                (*ENDFOR*) 
            (*ENDWITH*) 
        (*ENDFOR*) 
    (*ENDWITH*) 
    IF  count > 0
    THEN
        a06finish_curr_retpart (acv, sp1pk_columnnames, count)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260store_parsinfo (
            VAR acv           : tak_all_command_glob;
            VAR paramNameInfo : tak260ParamNameInfo;
            VAR p_arr         : tak_syspointerarr);
 
BEGIN
IF  acv.a_info_output
THEN
    ak260long_info (acv, p_arr.px[1]^.smethod, paramNameInfo);
(*ENDIF*) 
a54_last_part (acv, p_arr, true)
END;
 
(*------------------------------*) 
 
FUNCTION
      a260BuildDebugStack : boolean; (* PTS 1107878 & PTS 1112663 *)
 
BEGIN
(* always build debug stack, we need it for procserver, PTS 1120396 *)
a260BuildDebugStack := true;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260hresult_error (
            hresult         : tsp00_Int4;
            VAR dbproc_name : tsp00_KnlIdentifier;
            VAR errtext     : tsp00_C64;
            VAR e           : tgg00_BasisError);
 
CONST
      c_wrong_first_param     = -2147220992;
      c_too_many_out_param    = -2147220991;
      c_unsupported_type      = -2147220990;
      c_progid_not_found      = -2147220987;
      c_typelib_not_found     = -2147312566;
      c_method_not_found      = -2147220984;
      c_inprocserver_not_found= -2147220986;
      c_localserver_not_found = -2147220985;
      c_dbproc_crashed        = -2147220975;
      c_bad_alloc             = -2147220973;
      c_package_outdated      = -2147220711;
      (* PTS 1107617 E.Z. *)
 
VAR
      ix       : integer;
      len      : integer;
      encoding : tsp00_Int4;
      c4_ptr   : ^tsp00_C4;
      crashMsg : ARRAY[1..16] OF char;
      msg80    : tsp00_C80;
      err_char_no: tsp00_Int4;
      uni_err    : tsp8_uni_error;
      byte_swap  : boolean;
      c80_ptr    : ^tsp00_C80;
      dummy      : integer;
 
BEGIN
(* Determine whether maschine in low- or big-endian *)
dummy  := 32;
c4_ptr := @dummy;
IF  c4_ptr^[1] = ' '
THEN
    byte_swap := true
ELSE
    byte_swap := false;
(*ENDIF*) 
IF  hresult <> c_user_defined_hresult
THEN
    BEGIN
    CASE hresult OF
        (* PTS 1114833 E.Z. *)
        c_unsupported_type :
            e := e_unsupported_param_type;
        c_progid_not_found :
            e := e_progid_not_found;
        c_method_not_found :
            e := e_method_not_found;
        c_inprocserver_not_found :
            e := e_inprocserver_not_found;
        c_localserver_not_found :
            e := e_localserver_not_found;
        c_dbproc_crashed :
            e := e_com_object_crashed;
        c_terminated_hresult :
            e := e_cancelled;
        c_bad_alloc :
            e := e_no_more_memory;
        c_package_outdated :
            e := e_package_out_of_date;
        OTHERWISE
            BEGIN
            e       := e_dcom_hresult;
            errtext := bsp_c64;
            len     := 0;
            c4_ptr  := @hresult;
            IF  byte_swap
            THEN
                FOR ix := sizeof (c4_ptr^) DOWNTO 1 DO
                    g17hexto_line (c4_ptr^[ix], len, msg80)
                (*ENDFOR*) 
            ELSE
                FOR ix := 1 TO sizeof (c4_ptr^) DO
                    g17hexto_line (c4_ptr^[ix], len, msg80);
                (*ENDFOR*) 
            (*ENDIF*) 
            SAPDB_PascalForcedMove (
                  sizeof (msg80), sizeof(errtext),
                  @msg80, 1, @errtext, 1, len);
            END;
        END;
    (*ENDCASE*) 
    len     := 0;
    IF  (hresult = c_dbproc_crashed) OR (hresult = c_terminated_hresult)
    THEN
        BEGIN
        IF  hresult = c_dbproc_crashed
        THEN
            crashMsg := 'Exception in    '
        ELSE
            crashMsg := 'omsTerminate in ';
        (*ENDIF*) 
        IF  g01unicode
        THEN
            BEGIN
            encoding := csp_unicode;
            len      := sizeof(msg80);
            s80uni_trans (@crashMsg, sizeof(crashMsg), csp_ascii,
                  @msg80, len, csp_unicode, [ ], uni_err,
                  err_char_no);
            SAPDB_PascalForcedUnicodeFill (sizeof(msg80),
                  @msg80, len+1, sizeof(msg80) - len,
                  csp_unicode_blank);
            END
        ELSE
            BEGIN
            encoding := csp_ascii;
            FOR ix := 1 TO sizeof(crashMsg) DO
                msg80[ix] := crashMsg[ix];
            (*ENDFOR*) 
            len := sizeof(crashMsg);
            SAPDB_PascalFill ('VAK260',   8,    
                  sizeof(msg80), @msg80, len+1, sizeof(msg80) - len, bsp_c1, e);
            END;
        (*ENDIF*) 
        FOR ix := 1 TO sizeof (dbproc_name) DO
            IF  len < sizeof(msg80)
            THEN
                BEGIN
                len        := len + 1;
                msg80[len] := dbproc_name[ix]
                END;
            (*ENDIF*) 
        (*ENDFOR*) 
        SAPDB_PascalForcedMove (
              sizeof (msg80), sizeof(errtext),
              @msg80, 1, @errtext, 1, sizeof(errtext));
        g01unioptextmsg (encoding, sp3p_console, sp3m_error, csp3_a260_hresult,
              csp3_n_hresult, msg80)
        END
    ELSE
        BEGIN
        c4_ptr  := @hresult;
        c80_ptr := @msg80;
        (*** WRITE HRESULT ***)
        IF  byte_swap
        THEN
            FOR ix  := sizeof (c4_ptr^) DOWNTO 1 DO
                g17hexto_line (c4_ptr^[ix], len, msg80)
            (*ENDFOR*) 
        ELSE
            FOR ix  := 1 TO sizeof (c4_ptr^) DO
                g17hexto_line (c4_ptr^[ix], len, msg80);
            (*ENDFOR*) 
        (*ENDIF*) 
        (***  WRITE ERROR-CODE ***)
        c80_ptr^[len+1] := ' ';
        len := len + 1;
        g17basis_err_to_line(e, len, msg80);
        SAPDB_PascalFill ('VAK260',   9,    
              sizeof(msg80), @msg80, len+1, sizeof(msg80) - len, bsp_c1, e);
        g01unioptextmsg (csp_ascii, sp3p_console, sp3m_error, csp3_a260_hresult,
              csp3_n_hresult, msg80)
        END;
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260parse_dbproc (
            VAR acv           : tak_all_command_glob;
            VAR dbproc_name   : tsp00_KnlIdentifier;
            parse_for_execute : boolean;
            start_node        : integer;
            cursorNameNode    : integer;
            method_buf        : tak_sysbufferaddress;
            VAR paramNameInfo : tak260ParamNameInfo;
            VAR p_arr         : tak_syspointerarr);
 
VAR
      e                  : tgg00_BasisError;
      mtype              : tgg00_MessType;
      ix                 : integer;
      debug_node         : integer;
      debug_mode         : integer;
      tree_index         : integer;
      output_length      : tsp00_Int4;
      inout_offset       : tsp00_Int4;
      CodeSyskey         : tgg00_SysInfoKey;
      p                  : tak_sysbufferaddress;
      mblock_ptr         : tak_sysbufferaddress;
      dmli               : tak_dml_info;
 
BEGIN
WITH acv, dmli DO
    BEGIN
    tree_index := a_ap_tree^[start_node].n_sa_level;
&   ifdef trace
    t01int4 (ak_sem, 'tree_index  ', tree_index);
    t01int4 (ak_sem, 'cursorNameNo', cursorNameNode);
&   endif
    FOR ix := 1 TO method_buf^.smethod.me_param_cnt DO
        paramNameInfo[ix] := 0;
    (*ENDFOR*) 
    a54_dml_init (acv, dmli, NOT c_in_union);
    p_arr.pbasep := NIL; (* just to make a54_get_pparsp_pinfop happy *)
    IF  a260IsInternalDBProc (method_buf^.smethod)
    THEN
        mtype := m_delete
    ELSE
        mtype := m_update;
    (*ENDIF*) 
    a54_get_pparsp_pinfop (acv, p_arr, mtype);
    p_arr.px[1]  := method_buf;
    p_arr.pcount := 1;
    IF  a_returncode = 0
    THEN
        BEGIN
        d_sparr := p_arr;
        IF  cursorNameNode <> 0
        THEN
            BEGIN
            a05identifier_get (acv, cursorNameNode,
                  sizeof(p_arr.pparsp^.sparsinfo.p_resn),
                  p_arr.pparsp^.sparsinfo.p_resn);
&           ifdef trace
            t01lidentifier (ak_sem, p_arr.pparsp^.sparsinfo.p_resn);
&           endif
            END;
        (*ENDIF*) 
        a06a_mblock_init (acv,
              mtype, mm_file, b01niltree_id);
        a_mblock.mb_qual^.mqual_pos := 1;
        a_stored_proc_call          := true;
        ak260check_param_list (acv, dmli,
              parse_for_execute, p_arr, tree_index, paramNameInfo, output_length, inout_offset);
        p_arr.pparsp       := d_sparr.pparsp; (* may have been changed by a54_fixedpos, PTS 1105224, T.A. *)
        a_stored_proc_call := false;
        IF  a260IsInternalDBProc (method_buf^.smethod)
        THEN
            BEGIN
            acv.a_mblock.mb_qual^.mtree.fileTabId_gg00 := p_arr.pinfop^.syskey.stableid;
            IF  method_buf^.smethod.me_language in [lang_java, lang_system, lang_other]
            THEN
                acv.a_mblock.mb_qual^.mbool := true;
            (*ENDIF*) 
            ;
            (* Load Stack Code of DB-Procedure and store into temp catalog *)
            a262LoadCode (acv, method_buf^.smethod.me_surrogate, cak_init_linkage, p);
            IF  p <> NIL
            THEN
                BEGIN
                a260BuildCodeSyskey (p_arr.pinfop^.syskey.stableid, CodeSyskey);
                a10mblock_into_cache (acv, CodeSyskey,
                      p^.smessblock.mbr_mess_block, d_release, mblock_ptr, e);
                a10rel_sysinfo (p);
                IF  e = e_ok
                THEN
                    a10add_sysinfo (acv, mblock_ptr, e);
                (*ENDIF*) 
                IF  e <> e_ok
                THEN
                    a07_b_put_error (acv, e, 1)
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            debug_node := a_ap_tree^[0].n_lo_level;
            debug_mode := a_ap_tree^[debug_node].n_length;
            ak260describe_dbproc (acv, a_mblock, dbproc_name, debug_node, debug_mode, d_maxlen,
                  a_ap_tree^[a_ap_tree^[0].n_lo_level].n_subproc = cak_i_commit,
                  output_length, inout_offset, method_buf)
            END
        (*ENDIF*) 
        END;
&   ifdef trace
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        WITH d_sparr.pinfop^.sshortinfo DO
            BEGIN
            t01int4 (ak_sem, 'sicount     ', sicount);
            FOR ix := 1 TO sicount DO
                WITH siinfo [ix] DO
                    BEGIN
                    IF  sp1ot_mandatory in sp1i_mode
                    THEN
                        t01int4 (ak_sem, 'mandatory   ', 1);
                    (*ENDIF*) 
                    IF  sp1ot_optional in sp1i_mode
                    THEN
                        t01int4 (ak_sem, 'optional    ', 1);
                    (*ENDIF*) 
                    CASE sp1i_io_type OF
                        sp1io_input :
                            t01int4 (ak_sem, 'input       ', 1);
                        OTHERWISE
                            t01int4 (ak_sem, 'output      ', 1);
                        END;
                    (*ENDCASE*) 
                    CASE sp1i_data_type OF
                        dfixed :
                            t01int4 (ak_sem, 'fixed       ', 1);
                        dfloat :
                            t01int4 (ak_sem, 'float       ', 1);
                        dcha :
                            t01int4 (ak_sem, 'char        ', 1);
                        dchb :
                            t01int4 (ak_sem, 'byte        ', 1);
                        ddate :
                            t01int4 (ak_sem, 'date        ', 1);
                        dtime :
                            t01int4 (ak_sem, 'time        ', 1);
                        dtimestamp :
                            t01int4 (ak_sem, 'timestamp   ', 1);
                        dsmallint :
                            t01int4 (ak_sem, 'smallint    ', 1);
                        dinteger :
                            t01int4 (ak_sem, 'integer     ', 1);
                        dvarchara, dvarcharb :
                            t01int4 (ak_sem, 'varchar     ', 1);
                        OTHERWISE
                            (*
                                  drowid :
                                  dstra :
                                  dstrb :
                                  dvfloat :
                                  dlonga :
                                  dlongb :
                                  dboolean :
                                  dunicode :*)
                            t01int4 (ak_sem, 'unknown     ',
                                  ord (sp1i_data_type));
                        END;
                    (*ENDCASE*) 
                    END;
                (*ENDWITH*) 
            (*ENDFOR*) 
            END;
        (*ENDWITH*) 
        END;
&   endif
    (*ENDIF*) 
    a54_dml_finalize( dmli, acv.a_transinf.tri_trans );
    END;
(*ENDWITH*) 
IF  acv.a_ap_max_node <> cak_init_node
THEN
    a10shrink_syntax_tree (acv);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a260BuildCodeSyskey (
            VAR CodeId     : tgg00_Surrogate;
            VAR CodeSyskey : tgg00_SysInfoKey);
 
BEGIN
CodeSyskey.stableid    := CodeId;
CodeSyskey.sentrytyp   := cak_emessblock;
CodeSyskey.slinkage[1] := chr(0);
CodeSyskey.slinkage[2] := chr(2);
CodeSyskey.skeylen     := mxak_standard_sysk;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260check_param_list (
            VAR acv                 : tak_all_command_glob;
            VAR dmli                : tak_dml_info;
            parse_for_ex            : boolean;
            VAR proc_arr            : tak_syspointerarr;
            tree_index              : integer;
            VAR paramNameInfo       : tak260ParamNameInfo;
            VAR output_length       : tsp00_Int4;
            VAR inout_param_offset  : tsp00_Int4);
 
CONST
      c_exit_loop = csp_maxint2;
 
TYPE
      tphase_indicator = (ph_inout_params, ph_in_or_out_params, ph_exit);
 
VAR
      is_inout_param   : boolean;
      result_buf_needed: boolean;
      IsInternalDBProc : boolean;
      isUnicodeClient  : boolean;
      wydeFound        : boolean;
      swap             : integer;
      first            : integer;
      parm_no          : integer;
      p_index          : integer;
      init_ti          : integer;
      ix               : integer;
      moveOffset       : integer;
      paramInfoCount   : integer;
      inout_offset     : tsp00_Int4;
      aux_data_len     : tsp00_Int4;
      input_data_pos   : tsp00_Int4;
      paramInOutLength : tsp00_Int4;
      init_mess_type   : tsp1_cmd_mess_type;
      phase            : tphase_indicator;
      parm_ptr         : tak_param_info_ptr;
      dfa              : tak_dfarr;
 
BEGIN
IsInternalDBProc := a260IsInternalDBProc(proc_arr.px[1]^.smethod);
isUnicodeClient  := acv.a_cmd_packet_header.sp1h_mess_code in [csp_unicode_swap, csp_unicode];
WITH acv, dfa[1] DO
    BEGIN
    dmli.d_linkbuf := NIL;
    init_ti        := tree_index;
    phase          := ph_inout_params;
    init_mess_type := a_cmd_segment_header.sp1c_mess_type;
    inout_offset   := 0;
    IF  parse_for_ex
    THEN
        a_cmd_segment_header.sp1c_mess_type := sp1m_dbs;
    (*ENDIF*) 
    output_length     := 0;
    result_buf_needed := false;
    WHILE (phase <= ph_in_or_out_params) AND
          (a_returncode = 0) DO
        BEGIN
        parm_no      := 1;
        p_index      := 1;
        tree_index   := init_ti;
        WHILE parm_no <= proc_arr.px[1]^.smethod.me_param_cnt DO
            WITH proc_arr.px[1]^.smethod, me_param_list[parm_no]^ DO
                BEGIN
                IF  param_com_datatype = csp1_vt_userdefined
                THEN (* struct, param_offset contains size at client site *)
                    paramInOutLength := param_cpp_offset + 1
                ELSE
                    IF  (param_datatype in [ddate, dtime, dtimestamp]) AND
                        (acv.a_in_packet^.sp1_header.sp1h_mess_code in [csp_unicode, csp_unicode_swap]) AND
                        (param_in_out[2] <> csp_info_output) AND NOT acv.a_ascii_in_and_output
                    THEN
                        paramInOutLength := 1 + (param_inoutlength -1) * 2
                    ELSE
                        paramInOutLength := param_inoutlength;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  tree_index = 0
                THEN
                    BEGIN
                    a07_b_put_error (acv, e_too_few_values,
                          a_cmd_part^.sp1p_buf_len);
                    parm_no := c_exit_loop
                    END;
                (*ENDIF*) 
                dml_node       := a_ap_tree^[tree_index].n_lo_level;
                is_inout_param := param_in_out[2] = csp_info_inout;
                IF  parse_for_ex AND
                    (param_in_out[2] in
                    [csp_info_input, csp_info_inout])
                THEN
                    ak260look_for_parameters (acv, dml_node);
                (*ENDIF*) 
                IF  (param_in_out[2] in
                    [csp_info_output, csp_info_inout])
                THEN
                    BEGIN
                    IF  a_ap_tree^[dml_node].n_symb <>
                        s_parameter_name
                    THEN
                        WITH a_ap_tree^[dml_node] DO
                            BEGIN
                            a07_b_put_error (acv,
                                  e_value_expr_must_be_param_name,
                                  n_pos);
                            parm_no := c_exit_loop
                            END
                        (*ENDWITH*) 
                    ELSE
                        IF  phase = ph_inout_params
                        THEN
                            BEGIN
                            IF  param_com_datatype = csp1_vt_userdefined
                            THEN
                                BEGIN
                                result_buf_needed := true;
                                output_length     := a01aligned_cmd_len (output_length + 1) - 1;
                                END
                            ELSE
                                IF  param_com_datatype = csp1_vt_carray
                                THEN
                                    result_buf_needed := true;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            output_length := output_length + paramInOutLength;
                            IF  (param_com_datatype = csp1_vt_carray) AND
                                (param_datatype     = dwyde         ) AND
                                NOT (acv.a_cmd_packet_header.sp1h_mess_code in
                                [csp_unicode_swap, csp_unicode])
                            THEN (* reserve space for blowing out ascii to wyde character *)
                                output_length := output_length + param_datalength;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  a_returncode = 0
                THEN
                    IF  phase = ph_inout_params
                    THEN
                        BEGIN
                        IF  is_inout_param
                        THEN
                            BEGIN
                            IF  param_com_datatype = csp1_vt_userdefined
                            THEN
                                inout_offset := a01aligned_cmd_len (inout_offset + 1) - 1;
                            (*ENDIF*) 
                            inout_offset :=
                                  inout_offset + paramInOutLength
                            END;
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        IF  is_inout_param
                        THEN
                            BEGIN
                            aux_data_len    := a_mblock.mb_data_len;
                            input_data_pos  := a_input_data_pos;
                            IF  param_com_datatype = csp1_vt_userdefined
                            THEN
                                inout_offset := a01aligned_cmd_len (inout_offset + 1) - 1;
                            (*ENDIF*) 
                            a_mblock.mb_data_len := inout_offset;
                            a_input_data_pos     := inout_offset + 1;
                            a54_fixedpos (acv, dmli);
                            inout_offset :=
                                  inout_offset + paramInOutLength
                            END;
                        (*ENDIF*) 
                        paramInfoCount := dmli.d_sparr.pinfop^.sshortinfo.sicount;
                        ak260one_parameter (acv, dmli,
                              me_param_list[parm_no]^, dfa, IsInternalDBProc);
                        paramNameInfo[parm_no] := dmli.d_sparr.pinfop^.sshortinfo.sicount - paramInfoCount;
                        IF  is_inout_param
                        THEN
                            BEGIN
                            a_mblock.mb_data_len := aux_data_len;
                            a_input_data_pos     := input_data_pos
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                tree_index := a_ap_tree^[tree_index].n_sa_level;
                IF  param_datatype = dabaptabhandle
                THEN
                    BEGIN
                    IF  phase <> ph_inout_params
                    THEN
                        BEGIN
                        ix := parm_no + 1;
                        WITH a_mblock, mb_qual^, mb_st^[mfirst_free] DO
                            WHILE ix <= parm_no + param_datafrac DO
                                IF  mfirst_free + 1 > mb_st_max
                                THEN
                                    BEGIN
                                    ix := parm_no + param_datafrac + 1;
                                    a07_b_put_error (acv,
                                          e_too_many_mb_stackentries, -mb_st_max)
                                    END
                                ELSE
                                    BEGIN
                                    parm_ptr := proc_arr.px[1]^.smethod.me_param_list[ix];
                                    WITH mb_st^[mfirst_free] DO
                                        BEGIN
                                        etype          := st_op;
                                        eop            := op_none;
                                        eparamdatatype := parm_ptr^.param_datatype;
                                        efraction      := parm_ptr^.param_datafrac;
                                        elen_var       := parm_ptr^.param_datalength;
                                        ecol_pos       := parm_ptr^.param_cpp_offset;
                                        mfirst_free    := mfirst_free + 1;
                                        END;
                                    (*ENDWITH*) 
                                    WITH mb_st^[mfirst_free] DO
                                        BEGIN
                                        etype       := st_op;
                                        eop         := op_none;
                                        epos        := 0;
                                        elen_var    := parm_ptr^.param_datalength;
                                        IF  acv.a_pseudoUnicodeClient
                                        THEN
                                            ecol_pos := parm_ptr^.param_cpp_offset
                                        ELSE
                                            IF  isUnicodeClient
                                            THEN
                                                ecol_pos := parm_ptr^.param_unicode_offset
                                            ELSE
                                                ecol_pos := parm_ptr^.param_ascii_offset;
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                        mfirst_free := mfirst_free + 1;
                                        END;
                                    (*ENDWITH*) 
                                    ix := ix + 1
                                    END;
                                (*ENDIF*) 
                            (*ENDWHILE*) 
                        (*ENDWITH*) 
                        a_mblock.mb_qual^.mqual_cnt :=
                              a_mblock.mb_qual^.mfirst_free - 1;
                        END;
                    (*ENDIF*) 
                    parm_no := parm_no + param_datafrac + 1
                    END
                ELSE
                    IF  param_com_datatype = csp1_vt_userdefined
                    THEN
                        BEGIN
                        IF  phase <> ph_inout_params
                        THEN
                            ak260GenerateSwapAndModifyCode (acv,
                                  proc_arr.px[1]^.smethod.me_param_list, parm_no);
                        (*ENDIF*) 
                        parm_no := parm_no + param_datafrac + 1
                        END
                    ELSE
                        parm_no := parm_no + 1
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDWHILE*) 
        a_mblock.mb_qual^.mqual_cnt := a_mblock.mb_qual^.mfirst_free - 1;
        IF  tree_index <> 0
        THEN
            a07_b_put_error (acv, e_too_many_values,
                  a_ap_tree^[tree_index].n_pos);
        (*ENDIF*) 
        phase := succ (phase);
        IF  phase <> ph_exit
        THEN
            BEGIN
            a_mblock.mb_data_len := inout_offset;
            inout_param_offset   := inout_offset;
            a_output_data_pos    := a_output_data_pos + inout_offset;
            a_input_data_pos     := inout_offset + 1
            END;
&       ifdef trace
        (*ENDIF*) 
        t01int4 (ak_sem, 'inout_offset', inout_offset);
&       endif
        inout_offset := 0
        END;
    (*ENDWHILE*) 
    a_cmd_segment_header.sp1c_mess_type := init_mess_type;
    IF  NOT result_buf_needed
    THEN
        output_length := 0;
    (*ENDIF*) 
    IF  dmli.d_linkbuf <> NIL
    THEN
        a10key_del (acv, dmli.d_linkbuf)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260GenerateSwapAndModifyCode (
            VAR acv        : tak_all_command_glob;
            VAR parameters : tak_param_array;
            paramIdx       : integer);
 
VAR
      isUnicodeClient  : boolean;
      wydeFound        : boolean;
      ascii7Found      : boolean;
      ix               : integer;
      swap             : integer;
      swapLength       : integer;
      pStructParam     : tak_param_info_ptr;
      pMember          : tak_param_info_ptr;
 
BEGIN
isUnicodeClient  := acv.a_cmd_packet_header.sp1h_mess_code in [csp_unicode_swap, csp_unicode];
pStructParam     := parameters[paramIdx];
IF  pStructParam^.param_state = param_new
THEN
    BEGIN (* this struct has to be modifier, generate code *)
    ix := paramIdx + 1;
    WHILE ix <= paramIdx + pStructParam^.param_datafrac DO
        BEGIN
        pMember := parameters[ix];
        WITH acv.a_mblock, mb_qual^ DO
            BEGIN
            IF  mfirst_free > mb_st_max
            THEN
                BEGIN
                ix := paramIdx + pStructParam^.param_datafrac + 1;
                a07_b_put_error (acv,
                      e_too_many_mb_stackentries, -mb_st_max)
                END
            ELSE
                BEGIN
                WITH mb_st^[mfirst_free] DO
                    BEGIN
                    etype := st_op;
                    IF  (pMember^.param_datatype = dcha) AND isUnicodeClient
                    THEN
                        eop := op_trunc
                    ELSE
                        IF  (pMember^.param_datatype = dwyde) AND
                            NOT isUnicodeClient                   AND
                            NOT acv.a_pseudoUnicodeClient
                        THEN
                            eop := op_dbyte_translate
                        ELSE
                            eop := op_none;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    epos := pMember^.param_cpp_offset;
                    CASE pMember^.param_com_datatype OF
                        csp1_vt_bool,
                        csp1_vt_i1,
                        csp1_vt_ui1,
                        csp1_vt_lc_char,
                        csp1_vt_lc_byte,
                        csp1_vt_lc_bool,
                        csp1_vt_lc_int1,
                        csp1_vt_lc_uint1,
                        csp1_vt_lc_ascii7,
                        csp1_vt_lc_numc :   (* PTS 1131373, PG *)
                            elen_var := 1;
                        csp1_vt_i2,
                        csp1_vt_ui2,
                        csp1_vt_lc_wyde :
                            elen_var := 2;
                        csp1_vt_i4,
                        csp1_vt_r4,
                        csp1_vt_ui4,
                        csp1_vt_int,
                        csp1_vt_uint :
                            elen_var := 4;
                        csp1_vt_r8,
                        csp1_vt_i8,
                        csp1_vt_ui8 :
                            elen_var := 8;
                        OTHERWISE
                            IF  (pMember^.param_datatype = dwyde) AND
                                (isUnicodeClient OR acv.a_pseudoUnicodeClient)
                            THEN (* length is stored as number of characters, eval byte length *)
                                elen_var := pMember^.param_datalength * 2
                            ELSE
                                elen_var := pMember^.param_datalength;
                            (*ENDIF*) 
                        END;
                    (*ENDCASE*) 
                    IF  acv.a_pseudoUnicodeClient
                    THEN
                        ecol_pos := pMember^.param_cpp_offset
                    ELSE
                        IF  isUnicodeClient
                        THEN
                            ecol_pos := pMember^.param_unicode_offset
                        ELSE
                            ecol_pos := pMember^.param_ascii_offset;
                        (*ENDIF*) 
                    (*ENDIF*) 
&                   ifdef trace
                    t01p2int4 (ak_sem, 'cppOffset   ', epos, 'clientOffset', ecol_pos);
&                   endif
                    mfirst_free := mfirst_free + 1;
                    END;
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            ix := ix + 1;
            END;
        (*ENDWITH*) 
        END;
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
IF  (acv.a_out_packet^.sp1_header.sp1h_mess_swap <> g01code.kernel_swap)
THEN
    BEGIN
    ix := paramIdx + 1;
    WITH acv.a_mblock, mb_qual^ DO
        BEGIN
        WHILE ix <= paramIdx + pStructParam^.param_datafrac DO
            BEGIN
            swapLength := 1;
            pMember    := parameters[ix];
            IF  (pMember^.param_datatype = dwyde) AND
                (isUnicodeClient OR acv.a_pseudoUnicodeClient)
            THEN
                BEGIN
                swap       := sw_i2;
                swapLength := pMember^.param_datalength;
                END
            ELSE
                CASE pMember^.param_com_datatype OF
                    csp1_vt_i2, csp1_vt_ui2 :
                        swap := sw_i2;
                    csp1_vt_i4, csp1_vt_ui4,
                    csp1_vt_int, csp1_vt_uint (* PTS 1107154 *) :
                        swap := sw_i4;
                    csp1_vt_i8, csp1_vt_ui8 : (* PTS 1107784 *)
                        swap := sw_i8;
                    csp1_vt_r4 :
                        swap := sw_r4;
                    csp1_vt_r8 :
                        swap := sw_r8;
                    OTHERWISE
                        swap := sw_none;
                    END;
                (*ENDCASE*) 
            (*ENDIF*) 
            IF  swap <> sw_none
            THEN
                IF  mfirst_free > mb_st_max
                THEN
                    BEGIN
                    ix := paramIdx + pStructParam^.param_datafrac + 1;
                    a07_b_put_error (acv,
                          e_too_many_mb_stackentries, -mb_st_max)
                    END
                ELSE
                    BEGIN
                    WITH mb_st^[mfirst_free] DO
                        BEGIN
                        etype       := st_op;
                        eop         := op_swap;
                        epos        := pMember^.param_cpp_offset;
                        elen_var    := swapLength;
                        ecol_tab[1] := chr(0);
                        ecol_tab[2] := chr(ord(swap));
                        mfirst_free := mfirst_free + 1;
                        END;
                    (*ENDWITH*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            ix := ix + 1
            END;
        (*ENDWHILE*) 
        END;
    (*ENDWITH*) 
    acv.a_mblock.mb_qual^.mqual_cnt :=
          acv.a_mblock.mb_qual^.mfirst_free - 1;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260describe_dbproc (
            VAR acv         : tak_all_command_glob;
            VAR mblock      : tgg00_MessBlock;
            VAR dbproc_name : tsp00_KnlIdentifier;
            debug_node      : integer;
            debug_mode      : integer;
            d_maxlen        : integer;
            with_commit     : boolean;
            output_length   : tsp00_Int4;
            inout_offset    : tsp00_Int4;
            method_buf      : tak_sysbufferaddress);
 
VAR
      e                  : tgg00_BasisError;
      methodinfobuf      : tak_sysbufferaddress;
      methodinfokey      : tgg00_SysInfoKey;
      create_inst_params : ^tcreate_inst_params;
 
BEGIN
WITH mblock.mb_qual^ DO
    BEGIN
    mblock.mb_data_len :=
          ((mblock.mb_data_len + 8 - 1) DIV 8) * 8;
    mstrat_pos           := mfirst_free;
    WITH mblock.mb_st^[mstrat_pos] DO
        BEGIN
        etype              := st_value;
        eop                := op_none;
        epos               := mblock.mb_data_len + 1;
        create_inst_params := @mblock.mb_data^.mbp_buf[epos];
        elen_var           := sizeof (create_inst_params^) -
              sizeof(create_inst_params^.debug_location);
        ecol_tab[1]        := chr(0);
        ecol_tab[2]        := chr(0)
        END;
    (*ENDWITH*) 
    mstrat_cnt         := 1;
    mfirst_free        := mfirst_free + 1;
    END;
(*ENDWITH*) 
IF  (method_buf^.smethod.me_sql)
THEN (* Input Parameters must not be copied into mblock.mb_data, see vak505 *)
    mblock.mb_qual^.mspecial := mblock.mb_data_len + d_maxlen
ELSE
    mblock.mb_qual^.mspecial := 0;
(*ENDIF*) 
IF  mblock.mb_qual^.mspecial > 0
THEN
    mblock.mb_qual^.mspecial :=
          mblock.mb_qual^.mspecial + sizeof (create_inst_params^);
(*ENDIF*) 
mblock.mb_data_len              := mblock.mb_data_len +
      sizeof (create_inst_params^) - sizeof(create_inst_params^.debug_location);
create_inst_params^.coclsid         := method_buf^.smethod.me_coclsid;
create_inst_params^.iid             := method_buf^.smethod.me_iid;
create_inst_params^.surrogate       := method_buf^.smethod.me_surrogate;
create_inst_params^.packageId       := method_buf^.smethod.me_package_id;
create_inst_params^.dispid          := method_buf^.smethod.me_dispid;
(* 1102637, T.A. 1999-05-10 *)
create_inst_params^.wait_for_checkp := false;
IF  debug_mode <> 0
THEN
    BEGIN
    IF  (method_buf^.smethod.me_debug <> dbg_inproc) AND
        (debug_mode = cak_i_local                  )
    THEN
        a07_b_put_error (acv, e_not_implemented, 1)
    ELSE
        CASE debug_mode OF
            cak_i_inproc :
                create_inst_params^.debug := dbg_inproc;
            cak_i_local  :
                create_inst_params^.debug := dbg_local;
            END;
        (*ENDCASE*) 
    (*ENDIF*) 
    END
ELSE
    create_inst_params^.debug := method_buf^.smethod.me_debug;
(*ENDIF*) 
create_inst_params^.with_commit  := with_commit;
create_inst_params^.out_length   := output_length;
create_inst_params^.inout_offset := inout_offset;
create_inst_params^.dbproc_name  := dbproc_name;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260look_for_parameters (
            VAR acv   : tak_all_command_glob;
            curr_node : integer);
 
BEGIN
IF  curr_node <> 0
THEN
    IF  acv.a_ap_tree^[curr_node].n_symb = s_parameter_name
    THEN
        a07_b_put_error (acv, e_parameter_not_allowed,
              acv.a_ap_tree^[curr_node].n_pos)
    ELSE
        BEGIN
        ak260look_for_parameters (acv,
              acv.a_ap_tree^[curr_node].n_sa_level);
        ak260look_for_parameters (acv,
              acv.a_ap_tree^[curr_node].n_lo_level)
        END;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260one_parameter (
            VAR acv               : tak_all_command_glob;
            VAR dmli              : tak_dml_info;
            VAR param             : tak_param_info;
            VAR dfa               : tak_dfarr;
            IsInternalDBProc      : boolean);
 
VAR
      isUnicodeClient : boolean;
      paramNo         : integer;
      move_len        : integer;
      si_index        : integer;
      colname         : tsp00_KnlIdentifier;
      colinfo         : tak00_columninfo;
      msg             : tsp00_C32;
 
BEGIN
WITH acv, dmli DO
    BEGIN
    isUnicodeClient := acv.a_cmd_packet_header.sp1h_mess_code in [csp_unicode_swap, csp_unicode];
    d_fieldno       := 1;
    IF  ord (param.param_name_len) > sizeof (colname)
    THEN
        move_len := sizeof (colinfo.ccolumnn)
    ELSE
        BEGIN
        colinfo.ccolumnn  := a01_il_b_identifier;
        move_len          := ord (param.param_name_len)
        END;
    (*ENDIF*) 
    SAPDB_PascalForcedMove (ord (param.param_name_len), sizeof (colinfo.ccolumnn),
          @param.param_name, 1, @colinfo.ccolumnn, 1, move_len);
    dfa[1].dml_col_ptr := @colinfo;
    WITH dfa[1].dml_col_ptr^ DO
        BEGIN
        ccolumnn_len := chr(move_len);
        IF  param.param_in_out[1] = csp_info_optional
        THEN
            ccolpropset := [ctopt]
        ELSE
            ccolpropset := [];
        (*ENDIF*) 
        cextcolno   := 1;
        creccolno   := 1;
        ctabno      := 1;
        cbinary     := false;
        IF  param.param_com_datatype = csp1_vt_userdefined
        THEN
            BEGIN
            cdatalen    := param.param_cpp_offset;
            cinoutlen   := param.param_cpp_offset + 1;
            END
        ELSE
            BEGIN
            cdatalen := param.param_datalength;
            IF  isUnicodeClient AND
                (param.param_datatype in [dcha, ddate, dtime, dtimestamp]) AND
                ((param.param_in_out[2] <> csp_info_output) OR NOT acv.a_ascii_in_and_output)
            THEN
                cinoutlen := 1 + 2 * param.param_datalength
            ELSE
                cinoutlen := param.param_inoutlength;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        CASE param.param_datatype OF
            dinteger, dsmallint :
                BEGIN
                cdatatyp := dfixed;
                cbinary  := true
                END;
            dwyde :
                BEGIN
                IF  acv.a_cmd_packet_header.sp1h_mess_code in [csp_unicode_swap, csp_unicode]
                THEN
                    BEGIN
                    cdatatyp  := dunicode;
                    cinoutlen := 1 + 2 * param.param_datalength;
                    END
                ELSE
                    cdatatyp := dcha;
                (*ENDIF*) 
                END;
            OTHERWISE
                cdatatyp := param.param_datatype;
            END;
        (*ENDCASE*) 
        IF  param.param_datatype = dfloat
        THEN
            cdatafrac := 0
        ELSE
            cdatafrac := param.param_datafrac;
        (*ENDIF*) 
        WITH ccolstack DO
            BEGIN
            etype    := st_fixcol;
            eop      := op_none;
            epos     := 1;
            elen_var := cinoutlen;
            ecol_tab := cgg_zero_c2
            END;
        (*ENDWITH*) 
        dmli.d_pars_kind := fp_val_all_without_l;
        IF  param.param_in_out[2] = csp_info_output
        THEN
            BEGIN
            IF  param.param_com_datatype = csp1_vt_userdefined
            THEN
                a_output_data_pos := a01aligned_cmd_len (a_output_data_pos);
            (*ENDIF*) 
            a61_p_short_info (acv, d_sparr,
                  dfa[1].dml_col_ptr^,
                  a_ap_tree^[dfa[1].dml_node].n_length, 0)
            END
        ELSE
            BEGIN
            WITH a_ap_tree^[dfa[1].dml_node] DO
                IF  (n_proc = a64)                OR
                    (n_proc = a641)               OR
                    (n_symb in [s_plus, s_minus]) OR
                    (param.param_datatype in [ddate, dtime, dtimestamp])
                THEN (* expression *)
                    WITH dfa[1] DO
                        ak260val_expr (acv, dmli,
                              dml_col_ptr, dml_node)
                    (*ENDWITH*) 
                ELSE
                    BEGIN
                    WITH a_mblock, mb_qual^ DO
                        BEGIN
                        IF  (param.param_com_datatype = csp1_vt_userdefined) OR
                            (param.param_datatype     = dabaptabhandle     )
                        THEN
                            BEGIN
                            mb_data_len := a01aligned_cmd_len (mb_data_len + 1) - 1;
                            a54_fixedpos (acv, dmli)
                            END;
                        (*ENDIF*) 
                        WITH mb_st^[mfirst_free] DO
                            BEGIN
                            etype := st_value;
                            eop   := op_none;
                            epos  := mb_data_len + 1;
                            ecol_tab[1] := chr(0);
                            ecol_tab[2] := chr(0)
                            END;
                        (*ENDWITH*) 
                        IF  n_symb = s_default
                        THEN
                            ak260get_default_value (acv, dmli,
                                  dfa[1].dml_col_ptr^)
                        ELSE
                            BEGIN
                            paramNo := 0;
                            IF  (n_symb = s_parameter_name) AND (cdatatyp in [dstra, dstrb, dstruni])
                            THEN
                                BEGIN
                                cdatatyp := dchb;
                                paramNo  := n_length;
                                END
                            ELSE
                                IF  (n_symb <> s_parameter_name) AND (cdatatyp in [dstra, dstrb, dstruni])
                                THEN
                                    BEGIN
                                    msg := 'constant as LOB parameter       ';
                                    a07_const_b_put_error (acv, e_not_implemented, n_pos,
                                          @msg, sizeof(msg));
                                    END;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            a55_found_one_value (acv, dmli, dfa);
                            IF  (paramNo > 0) AND (acv.a_returncode = 0)
                            THEN
                                BEGIN
                                WITH dmli.d_sparr.pinfop^.sshortinfo, siinfo[ paramNo ] DO
                                    sp1i_data_type := param.param_datatype;
                                (*ENDWITH*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        WITH mb_st^[mfirst_free] DO
                            elen_var := mb_data_len - epos + 1;
                        (*ENDWITH*) 
                        mfirst_free := mfirst_free + 1
                        END;
                    (*ENDWITH*) 
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
            IF  param.param_in_out[2] = csp_info_inout
            THEN
                BEGIN
&               ifdef trace
                t01int4 (ak_sem, 'shinfo ind  ',
                      a_ap_tree^[dfa[1].dml_node].n_length);
&               endif
                WITH dmli.d_sparr.pinfop^.sshortinfo.siinfo[
                     a_ap_tree^[dfa[1].dml_node].n_length] DO
                    BEGIN
                    CASE param.param_in_out[1] OF
                        csp_info_optional :
                            sp1i_mode := [ sp1ot_optional ];
                        csp_info_mandatory :
                            sp1i_mode := [ sp1ot_mandatory ];
                        csp_info_default :
                            sp1i_mode := [ sp1ot_default, sp1ot_mandatory ];
                        END;
                    (*ENDCASE*) 
                    sp1i_io_type := sp1io_inout
                    END;
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        WITH a_mblock, mb_qual^, mb_st^[mfirst_free] DO
            BEGIN
            etype := st_dbproc_param;
            CASE param.param_in_out[2] OF
                csp_info_output :
                    eop := op_not_in;
                csp_info_input :
                    eop := op_in;
                OTHERWISE
                    eop := op_none;
                END;
            (*ENDCASE*) 
            eparamdatatype := param.param_datatype;
            efraction      := param.param_datafrac;
            IF  IsInternalDBProc
            THEN
                BEGIN
                ecol_pos := param.param_cpp_offset;
                elen_var := param.param_inoutlength;
                END
            ELSE
                BEGIN
                (* store sizeof the parameter in c++ layout *)
                CASE param.param_com_datatype OF
                    csp1_vt_i1, csp1_vt_ui1, csp1_vt_lc_char, csp1_vt_lc_ascii7,
                    csp1_vt_lc_numc,   (* PTS 1131373, PG *)
                    csp1_vt_lc_byte, csp1_vt_lc_bool, csp1_vt_lc_int1, csp1_vt_lc_uint1 :
                        elen_var := 1;
                    csp1_vt_lc_wchar, csp1_vt_i2, csp1_vt_ui2 :
                        elen_var := 2;
                    csp1_vt_i4, csp1_vt_int, csp1_vt_ui4, csp1_vt_uint,
                    csp1_vt_r4 :
                        elen_var := 4;
                    csp1_vt_r8 :
                        elen_var := 8;
                    csp1_vt_carray :
                        IF  param.param_datatype = dwyde
                        THEN
                            elen_var := 2 * param.param_datalength
                        ELSE
                            elen_var := param.param_inoutlength - 1;
                        (*ENDIF*) 
                    csp1_vt_userdefined :
                        elen_var := param.param_datalength;
                    OTHERWISE
                        elen_var := param.param_inoutlength - 1;
                    END;
                (*ENDCASE*) 
                ecol_tab[1] := chr(param.param_com_datatype);
                IF  (param.param_com_datatype = csp1_vt_userdefined) AND
                    (param.param_state        = param_new          )
                THEN (* client layout and c++ layout differ, mark that struct has to be constructed on heap *)
                    ecol_tab[2] := chr(1)
                ELSE
                    ecol_tab[2] := chr(0);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            mfirst_free := mfirst_free + 1;
            END;
        (*ENDWITH*) 
        IF  NOT IsInternalDBProc
        THEN
            WITH a_mblock, mb_qual^, mb_st^[mfirst_free] DO
                BEGIN
                etype    := st_result;
                eop      := op_none;
                epos     := 0;
                (* store the parameters size from the client point of view in elen_var *)
                CASE param.param_com_datatype OF
                    csp1_vt_carray :
                        CASE param.param_datatype OF
                            dwyde :
                                IF  isUnicodeClient
                                THEN
                                    elen_var := param.param_inoutlength
                                ELSE
                                    elen_var := 1 + param.param_datalength;
                                (*ENDIF*) 
                            OTHERWISE
                                elen_var := param.param_inoutlength;
                            END;
                        (*ENDCASE*) 
                    csp1_vt_userdefined :
                        elen_var := param.param_cpp_offset + 1;
                    csp1_vt_lc_char, csp1_vt_lc_ascii7, csp1_vt_lc_numc :   (* PTS 1131373, PG *)
                        IF  isUnicodeClient
                        THEN
                            elen_var := 1 + 2 * param.param_datalength
                        ELSE
                            elen_var := 1 + param.param_datalength;
                        (*ENDIF*) 
                    OTHERWISE
                        elen_var := param.param_inoutlength;
                    END;
                (*ENDCASE*) 
                ecol_pos    := 0;
                mfirst_free := mfirst_free + 1;
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        a_mblock.mb_qual^.mqual_cnt :=
              a_mblock.mb_qual^.mfirst_free - 1;
&       ifdef trace
        t01messblock (ak_sem, 'a_mblock    ', a_mblock);
&       endif
        END;
    (*ENDWITH*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260get_default_value (
            VAR acv      : tak_all_command_glob;
            VAR dmli     : tak_dml_info;
            VAR col_info : tak00_columninfo);
 
BEGIN
WITH acv, a_mblock DO
    BEGIN
    CASE col_info.cdatatyp OF
        dcha :
            SAPDB_PascalForcedFill (mb_data_size,
                  @mb_data^.mbp_buf, mb_data_len+1, col_info.cinoutlen, bsp_c1);
        dchb :
            SAPDB_PascalForcedFill (mb_data_size,
                  @mb_data^.mbp_buf, mb_data_len+1, col_info.cinoutlen, chr(0));
        dunicode :
            SAPDB_PascalForcedUnicodeFill (mb_data_size,
                  @(mb_data^.mbp_buf), mb_data_len+1, col_info.cinoutlen,
                  csp_unicode_blank);
        dfixed, dfloat, dinteger, dsmallint :
            BEGIN
            SAPDB_PascalForcedFill (mb_data_size,
                  @mb_data^.mbp_buf, mb_data_len+1, col_info.cinoutlen, chr(0));
            mb_data^.mbp_buf[mb_data_len + 2] := csp_zero_exponent
            END;
        OTHERWISE
            a07_b_put_error (acv, e_not_implemented, 1)
        END;
    (*ENDCASE*) 
    mb_data_len       := mb_data_len + col_info.cinoutlen;
    dmli.d_movebefore := dmli.d_movebefore + col_info.cinoutlen
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak260val_expr (
            VAR acv   : tak_all_command_glob;
            VAR dmli  : tak_dml_info;
            col_ptr   : tak00_colinfo_ptr;
            curr_node : integer);
 
VAR
      index  : integer;
      colin  : tak00_scolinf;
      a11v   : tak_a11_glob;
 
BEGIN
WITH acv, dmli DO
    BEGIN
    (* create a dummy table with one column, required by VAK65 ff *)
    a11glob_init (acv, a11v);
    a11v.a1authname   := a01_i_temp;
    a11v.a1authid     := cak_temp_user_id;
    a11v.a1tablen     := a01_i_temp;
    a11v.a1coln       := col_ptr^.ccolumnn;
    a11v.a1temp_table := true;
    a11init_baserecord (acv, a11v);
    IF  acv.a_returncode = 0
    THEN
        a061app_columnname (acv, acv.a_p_arr1.pbasep^.sbase, col_ptr^.ccolumnn, index);
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        WITH acv.a_p_arr1.pbasep^.sbase.bcolumn[index]^ DO
            BEGIN
            a061copy_colinfo (col_ptr^, acv.a_p_arr1.pbasep^.sbase.bcolumn[index]^);
            ccolpropset := ccolpropset + [ctdropped];
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    d_sparr.pbasep := acv.a_p_arr1.pbasep;
    d_cntfromtab   := 1;
    d_acttabindex  := 1;
    d_wherepart    := true;
    WITH col_ptr^ DO
        IF  ((cdatatyp = dfixed) OR (cdatatyp = dfloat) OR
            (cdatatyp = dvfloat))
        THEN
            d_datatype := dnumber
        ELSE
            d_datatype := cdatatyp;
        (*ENDIF*) 
    (*ENDWITH*) 
    d_colptr           := col_ptr;
    colin.sci_len      := 0;
    d_first_tab        := 0;
    d_allowed          := may_more_tabs;
    d_change_date_time := false;
    d_const_value_expr := true;
    d_param_st_begin   := 0;
    d_param_st_index   := 0;
    WITH a_ap_tree^[curr_node] DO
        IF  (n_proc = a64) AND (n_subproc = cak_x_value_expression)
        THEN
            a65_val_expr (acv, dmli, colin, n_lo_level)
        ELSE
            a65_val_expr (acv, dmli, colin, curr_node);
        (*ENDIF*) 
    (*ENDWITH*) 
    IF  acv.a_returncode = 0
    THEN
        a10key_del (acv, acv.a_p_arr1.pbasep);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1114071 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a260ParseIdDrop (
            VAR acv    : tak_all_command_glob;
            VAR parsid : tak_parsid);
 
VAR
      del_cnt : integer;
 
BEGIN
a663_drop_parsid (acv, parsid, del_cnt);
IF  (del_cnt > 0)
    (*
          OR
          (parsid.pid_parsk.p_kind in [m_commit, m_rollback, m_destroy_temp])
          *)
THEN
    a92_add_pcount (acv, parsid.pid_parsk.p_count,
          parsid.pid_parsk.p_kind);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a260sql_in_dbproc (
            VAR acv            : tak_all_command_glob;
            VAR clsid          : tsp00_C16;
            VAR packageId      : tgg00_Surrogate) : boolean;
 
CONST
      c_sql_dispid = 4;
      c_kernel_only = true;
 
VAR
      sql_in_dbproc : boolean;
      dummy_bool    : boolean;
      data_ptr      : tsp1_part_ptr;
      cip           : tcreate_inst_params;
      mblock        : tgg00_MessBlock;
      qual          : tgg00_QualBuf;
      stack         : ARRAY[0..2] OF tgg00_StackEntry;
 
BEGIN
sql_in_dbproc := false;
IF  acv.a_returncode = 0
THEN
    BEGIN
    sql_in_dbproc := false;
    g01mblock_init   (acv.a_transinf.tri_trans, m_nil, mm_nil, mblock);
    g01datapart_init (mblock, @cip, sizeof (cip));
    g01stack_init    (mblock, @stack, sizeof (stack), @qual, sizeof(qual));
    cip.coclsid      := clsid;
    vdcom_iid_ilivecachespec (cip.iid);
    cip.dbproc_name            := a01_il_b_identifier;
    cip.dispid                 := c_sql_dispid;
    cip.with_commit            := false;
    cip.out_length             := 0;
    cip.inout_offset           := 0;
    cip.wait_for_checkp        := false; (* 1102637, T.A. 1999-05-10 *)
    cip.packageId              := packageId;
    stack[0].etype             := st_dbproc_param;
    stack[0].eop               := op_not_in;
    stack[0].eparamdatatype    := dboolean;
    stack[0].efraction         := 0;
    stack[0].elen_var          := 2;
    stack[0].ecol_tab[1]       := chr(csp1_vt_lc_bool);
    stack[0].ecol_tab[2]       := chr(0);
    stack[1].etype             := st_result;
    stack[1].eop               := op_none;
    stack[1].epos              := 0;
    stack[1].elen_var          := 2;
    stack[1].ecol_tab[1]       := chr(0);
    stack[1].ecol_tab[2]       := chr(0);
    stack[2].etype             := st_value;
    stack[2].eop               := op_none;
    stack[2].epos              := 1;
    stack[2].elen_var          := sizeof (cip);
    stack[2].ecol_tab          := cgg_zero_c2;
    mblock.mb_qual^.mqual_pos  := 1;
    mblock.mb_qual^.mqual_cnt  := 2;
    mblock.mb_qual^.mstrat_pos := 3;
    mblock.mb_qual^.mstrat_cnt := 1;
    ak260dbproc_call (acv, mblock,  NOT c_monitoring, NOT c_is_trigger, cip.with_commit,
          dummy_bool, dummy_bool, c_kernel_only);
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        a92find_return_part (acv, sp1pk_data, data_ptr);
        IF  data_ptr <> NIL
        THEN
            sql_in_dbproc := data_ptr^.sp1p_buf[2] = chr(1)
        ELSE
            a07ak_system_error (acv, 260, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
a260sql_in_dbproc := sql_in_dbproc
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
