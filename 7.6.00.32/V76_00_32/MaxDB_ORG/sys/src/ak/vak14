.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 2000-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-16
*****************************************************
modname : VAK14
changed : 2000-11-17
module  : AK_Data_Type_Options
 
Author  : ThomasA
Created : 1985-10-16
*****************************************************
 
Purpose :
 
Define  :
 
        PROCEDURE
              a14constraint_check (
                    VAR acv       : tak_all_command_glob;
                    col_info      : tak00_columninfo;
                    constraint_id : integer;
                    error_pos     : integer);
 
        PROCEDURE
              a14create_tab_as_select (
                    VAR acv     : tak_all_command_glob;
                    VAR tableid : tgg00_Surrogate;
                    parskey     : tak_parskey);
 
        PROCEDURE
              a14default_spec (
                    VAR acv          : tak_all_command_glob;
                    VAR a11v         : tak_a11_glob;
                    VAR col_info     : tak00_columninfo);
 
        PROCEDURE
              a14dfunction (
                    VAR acv      : tak_all_command_glob;
                    VAR col_info : tak00_columninfo;
                    subproc      : integer;
                    error_pos    : integer;
                    VAR func_id  : tsp00_Int2);
 
        PROCEDURE
              a14drop_default (
                    VAR acv      : tak_all_command_glob;
                    VAR col_info : tak00_columninfo);
 
        PROCEDURE
              a14get_colname (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob;
                    err_pos  : integer);
 
        PROCEDURE
              a14get_result_datatype (
                    VAR acv          : tak_all_command_glob;
                    VAR a11v         : tak_a11_glob;
                    VAR col_info     : tak00_columninfo;
                    error_pos        : integer);
 
        FUNCTION
              a14LengthOfDefaultValue (
                    VAR DefaultRec : tak_defaultrecord) : integer; (* PTS 1108428 *)
 
        PROCEDURE
              a14like_tablen (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Resultname_handling : VAK663;
 
        PROCEDURE
              a663_drop_parsid (
                    VAR acv     : tak_all_command_glob;
                    VAR p       : tak_parsid;
                    VAR del_cnt : integer);
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01moveobj (
                    debug       : tgg00_Debug;
                    VAR moveobj : tsp00_MoveObj;
                    startpos    : tsp00_Int4;
                    endpos      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01char_size        : integer;
              a01identifier_size  : integer;
              a01sysnullkey       : tgg00_SysInfoKey;
              a01_i_temp          : tsp00_KnlIdentifier;
              a01_il_b_identifier : tsp00_KnlIdentifier;
              a01kw               : tak_keywordtab;
 
        PROCEDURE
              a01_next_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_init_command (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              Deal-With-User-Commands : VAK92;
 
        PROCEDURE
              a92_mode_analyzer (
                    VAR acv     : tak_all_command_glob;
                    ddl         : tak_ddl_descriptor;
                    corr_select : boolean);
 
        PROCEDURE
              a92find_return_part (
                    VAR acv      : tak_all_command_glob;
                    part_kind    : tsp1_part_kind;
                    VAR part_ptr : tsp1_part_ptr);
 
        PROCEDURE
              a92parse_again (
                    VAR acv       : tak_all_command_glob;
                    VAR parsid    : tak_parsid;
                    dropStoredCmd : boolean); (* PTS 1106250 *)
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542fill_packet (
                    VAR acv : tak_all_command_glob;
                    pos : tsp00_Int4;
                    len : tsp00_Int4;
                    fillchar : char);
 
        PROCEDURE
              a542move_to_packet (
                    VAR acv    : tak_all_command_glob;
                    const_addr : tsp00_MoveObjPtr;
                    const_len  : tsp00_Int4);
 
        PROCEDURE
              a542reset_packet (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK54;
 
        PROCEDURE
              a54return_parsid (
                    VAR acv     : tak_all_command_glob;
                    VAR parskey : tak_parskey);
 
      ------------------------------ 
 
        FROM
              AK_Lock_Commit_Rollback : VAK52;
 
        PROCEDURE
              a52end_rollback_subtrans (
                    VAR acv           : tak_all_command_glob;
                    VAR subtrans_name : tsp00_KnlIdentifier;
                    m_type : tgg00_MessType);
 
      ------------------------------ 
 
        FROM
              AK_distributor : VAK35;
 
        PROCEDURE
              a35_asql_statement (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Alter_Table : VAK13;
 
        PROCEDURE
              a13FlushSequenceForDrop (
                    VAR acv            : tak_all_command_glob;
                    VAR sequenceRecord : tak_sequencerecord;
                    VAR b_err          : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              AK_Domain : VAK12;
 
        PROCEDURE
              a12read_domain_ref (
                    VAR acv         : tak_all_command_glob;
                    VAR owner_id    : tgg00_Surrogate;
                    VAR domain_name : tsp00_KnlIdentifier;
                    VAR domain_ref  : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              AK_Table   : VAK11;
 
        PROCEDURE
              a11constraint (
                    VAR acv       : tak_all_command_glob;
                    VAR a11v      : tak_a11_glob;
                    VAR base_rec  : tak_baserecord;
                    constraint_id : integer);
 
        PROCEDURE
              a11domain_usage (
                    VAR acv             : tak_all_command_glob;
                    VAR a11v            : tak_a11_glob;
                    VAR domain_owner_id : tgg00_Surrogate;
                    VAR domain_name     : tsp00_KnlIdentifier;
                    VAR domain_id       : tgg00_Surrogate;
                    colno               : integer);
 
        PROCEDURE
              a11end_create_table (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
        PROCEDURE
              a11get_check_table (
                    VAR acv          : tak_all_command_glob;
                    new_table        : boolean;
                    basetable        : boolean;
                    unload_allowed   : boolean;
                    required_priv    : tak00_PrivilegeSet;
                    any_priv         : boolean;
                    all_base_rec     : boolean;
                    d_state          : tak_directory_state;
                    VAR act_tree_ind : tsp00_Int4;
                    VAR auth         : tsp00_KnlIdentifier;
                    VAR tablen       : tsp00_KnlIdentifier;
                    VAR d_sparr      : tak_syspointerarr);
 
        PROCEDURE
              a11getconstraintname (
                    VAR constraint_rec  : tak_constraintrecord;
                    VAR constraint_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a11init_baserecord (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
        PROCEDURE
              a11put_systemkey (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache   : VAK10;
 
        PROCEDURE
              a10_copy_catalog_rec (
                    VAR acv         : tak_all_command_glob;
                    VAR old_key     : tgg00_SysInfoKey;
                    del_old_rec     : boolean;
                    VAR new_key     : tgg00_SysInfoKey;
                    new_segment_id  : tsp00_C2;
                    add_new_rec     : boolean;
                    VAR b_err       : tgg00_BasisError);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10del_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_key_del  (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10_add_repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    add_sysinfo  : boolean;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10next_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    stop_prefix  : integer;
                    dstate       : tak_directory_state;
                    rec_kind     : tsp00_C2;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10prefix_parsid_delete (
                    VAR acv       : tak_all_command_glob;
                    VAR parsk     : tak_parskey;
                    VAR del_cnt   : integer;
                    prefix_length : integer);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06extcolno (
                    VAR baserec     : tak_baserecord;
                    extcolno        : integer;
                    VAR colinfo_ptr : tak00_colinfo_ptr);
 
        PROCEDURE
              a06reset_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06_get_priv  (
                    VAR acv     : tak_all_command_glob;
                    VAR brec    : tak_sysbufferaddress;
                    VAR priv    : tak_privilege);
 
        PROCEDURE
              a06get_page_cnt (
                    VAR acv          : tak_all_command_glob;
                    VAR file_id      : tgg00_FileId;
                    do_sample        : boolean;
                    VAR page_count   : tsp00_Int4;
                    VAR b_err        : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061app_columnname (
                    VAR acv         : tak_all_command_glob;
                    VAR base_rec    : tak_baserecord;
                    VAR column      : tsp00_KnlIdentifier;
                    VAR index       : integer);
 
        PROCEDURE
              a061colinfo_to_var (
                    VAR src : tak00_columninfo;
                    VAR dst : tak00_columninfo);
 
        PROCEDURE
              a061copy_colinfo (
                    VAR src_col : tak00_columninfo;
                    VAR dst_col : tak00_columninfo);
 
        PROCEDURE
              a061get_colname (
                    VAR col_info : tak00_columninfo;
                    VAR colname  : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05_li_constant_get (
                    VAR acv    : tak_all_command_glob;
                    ni         : integer;
                    VAR colinfo: tak00_columninfo;
                    orig_len   : integer;
                    mv_dest    : integer;
                    VAR dest   : tak_default_value;
                    destpos    : integer;
                    variable_length  : boolean;
                    VAR actlen : integer);
 
        PROCEDURE
              a05long_literal_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    datatyp     : tsp00_DataType;
                    VAR moveobj : tak_default_value;
                    obj_pos     : integer;
                    VAR obj_len : integer);
 
        PROCEDURE
              a05is_const_in_constraint (
                    VAR acv         : tak_all_command_glob;
                    VAR valbuf      : tak_default_value;
                    val_pos         : integer;
                    val_len         : integer;
                    VAR tree        : tgg00_FileId;
                    constraint_id   : integer;
                    b_err          : tgg00_BasisError;
                    error_pos       : integer);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_const_b_put_error (
                    VAR acv    : tak_all_command_glob;
                    b_err      : tgg00_BasisError;
                    err_code   : tsp00_Int4;
                    param_addr : tsp00_MoveObjPtr;
                    const_len  : integer);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              GET-Conversions : VSP40;
 
        PROCEDURE
              s40glint (
                    VAR buf  : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    len      : integer;
                    VAR dest : tsp00_Int4;
                    VAR res  : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              PUT-Conversions : VSP41;
 
        PROCEDURE
              s41plint (
                    VAR buf : tak_default_value;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        FUNCTION
              g01columncompression : boolean;
 
      ------------------------------ 
 
        FROM
              GG_allocator_interface : VGG941;
 
        FUNCTION
              gg941Allocate(VAR TransContext : tgg00_TransContext;
                    wantedBytes : integer) : tsp00_Addr;
 
        PROCEDURE
              gg941Deallocate(VAR TransContext : tgg00_TransContext;
                    VAR p : tsp00_Addr);
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              s41plint;
 
              tsp00_MoveObj tak_default_value
 
        PROCEDURE
              a05is_const_in_constraint;
 
              tsp00_MoveObj tak_default_value
 
        PROCEDURE
              a05_li_constant_get;
 
              tsp00_MoveObj  tak_default_value
 
        PROCEDURE
              a05long_literal_get;
 
              tsp00_MoveObj  tak_default_value
 
.CM *-END-* synonym -------------------------------------
***********************************************************
 
Specification:
 
A14DEFAULT_RANGE_SPEC
-------------------------
 
For the column described by col_info, the procedure builds catalog information
of type tvaluesrecord in the cache that describes the default and range
definitions of the column.
 
On entry into the procedure, the tbaserecords of the table must have been
allocated in the cache with status d_fix (a1p_arr). In addition, a cache area
may already have been allocated for the catalog record (a1valsysp <> NIL). If
this is not the case, a cache area is first of all requested and is initialized
as tvaluesrecord. The key of the record results from the table name
a1authid.a1tablen as well as from the external column number of the column.
 
Then the default and/or range descriptions are entered in the record. The range
and default definitions are either in part 1 of the SQL-PACKET
(val_from_varpart = TRUE), or in a tvaluesrecord that already exists for the
column and that has been allocated in the cache starting at address a1sysbuf.
The latter case occurs if the procedure is called in the course of an alter
table column command in which the data type of the column has been changed. In
this case, the column description col_info describes the new data type, while
old_col_info contains the original description of the column. The default and
range descriptions are stored by calling the procedures ak14default,
a14range_in and a14between.
 
AK14DEFAULT
-------------------------
 
The procedure inserts a default definition of column col_info into the
tvaluesrecord allocated starting at address a1valsysp. The description consists
in writing the value of the default with  a length byte into the vvalues part
of the record starting at vdefaultpos.
 
A distinction must be made between two cases:
 
i)  The default definition is in part 1 of the SQL packet:
 
In this case, the default definition must be analyzed with the aid of the
syntax tree. A syntax-tree entry with n_proc = a14 signifies that a default
function has been specified (DEFAULT USER, DATE, TIME, STAMP). In
these cases, a 1-BYTE-long indicator of the respective function is written to
the record as the value. To be able to distinguish these values from user-
defined values, a negative vdefaultpos is stored.
 
A syntax-tree entry <> a14 specifies a user-defined default value, which is
transferred to the record by a05_li_constant_get.
 
ii) The default definition results from an already existing catalog record
starting at address a1sysbuf in the cache:
 
The default value from the original tvaluesrecord is transferred by procedure
a14_val_from_valrec to the record allocated starting at address a1valsysp.
 
Since columns with default definition may not assume the zero value, the
optional flag is removed from the column description col_info and the external
column number of the column is entered in the bdefaultset of the table.
 
A14RANGE_IN
-------------------------
 
The procedure inserts a RANGE IN or RANGE NOT IN definition of column col_info
into the tvaluesrecord allocated starting at address a1valsysp. The description
consists of:
 
i)   an indicator byte at position venumpos that defines whether this is a
range in (x'00') or range not in (x'01') definition.
 
ii)  the values of the IN or NOT IN condition, in each case in the form of
length byte followed by the value (directly following the indicator byte).
 
iii) an index starting at venumindexpos that simulates the sorting of the
values in order to enable binary searching on the values.
 
iv)  the IN or NOT IN qualification starting a venumstpos in the form of stack
entries.
 
The values may, as in the default case, come either from the SQL-PACKET
(val_from_varpart = TRUE) or from the tvaluesrecord allocated starting at
a1sysbuf. The transfer to the current tvaluesrecord is accomplished, depending
on this, by                     a14_val_from_valrec. If a default value has
been defined for the column, it must be checked whether it satisfies the IN or
NOT IN condition (a05_rvalue_in_range).
 
A14BETWEEN
-------------------------
 
The procedure inserts a RANGE BETWEEN or RANGE NOT BETWEEN definition of column
col_info into the tvaluesrecord allocated starting as address a1valsysp. The
description consists of:
 
i)   an indicator byte at position verangepos that defines whether this is a
RANGE BETWEEN (x'00') or RANGE NOT BETWEEN (x'01') definition.
 
ii)  the two values of the BETWEEN or NOT BETWEEN condition, in each case in
the form of length-byte value (directly following the indicator byte). The
second value must be greater than the first one.
 
iii) the BETWEEN or NOT BETWEEN qualification starting at vrangestpos in the
form of stack entries.
 
The values may, as in the default case, come either from the SQL-PACKET
(val_from_varpart = TRUE), or from the tvaluesrecord allocated starting at
a1sysbuf. Transfer to the current tvaluesrecord is accomplished, depending on
this, by                     a14_val_from_valrec. If a default has been defined
for the column, it must be checked whether it satisfies the BETWEEN or NOT
BETWEEN condition (a05_rvalue_in_range).
 
A14_VAL_FROM_VALREC
-------------------------
 
The procedure transfers the val_no-th value from the tvaluesrecord allocated
starting at a1sysbuf to the tvaluesrecord allocated starting at valbuf at
position valpos. The value to be transferred has the form appropriate to
old_col_info and must, therefore, be converted to the form appropriate to
col_info prior to transfer. The length of the transferred value is returned in
actlen.
 
A14_PRIV_COLUMN_LIKE
-------------------------
 
The procedure is called in the course of the create table like command in order
to generate the tbaserecords of the table to be created.
 
The tbaserecords of the like table a1likeauthid.a1liketablen must, when the
procedure is called, have been allocated in the cache with status d_fix
(p_arr). The parameter tabpriv contains the external column numbers of the
columns of the like table to which the current user has at least one privilege.
 
When the procedure is called, the created tbaserecords have been allocated in
the cache with status d_fix (a1p_arr).
 
First of all, in the procedure, a cache area is requested for the first
tbaserecord of table a1authid.a1tablen and is initialized by
a11init_baserecord. For each column of the Like Table, it is now checked by
a14_get_columninfo whether the column will become a part of the table to be
created. If this is the case, the column description is inserted by
a14_put_columninfo into the tbaserecords of the table to be created. If the
column has a default or range definition, the tvaluesrecord describing this
definition must be created. The external column number is therefore entered in
a1range_default_pos, which leads in the further course of a11_like_table by
a11end_create_table to the creation of this system information. If the first
transferred column description is not a key-column description, the new table
is a table without a user-defined key and a column description of the system
keys is created by a11put_systemkey.
 
A14_GET_COLUMNINFO
-------------------------
 
Beginning with the external column number colno of the table specified  by
p_arr, the next column visible to the current user is determined. If such a
column is found, TRUE is returned in found and the column description of the
column that has been found is returned in colinfo.
 
A14_PUT_COLUMNINFO
-------------------------
 
The column description colinfo is inserted as the last column description into
the last of the tbaserecords specified by a1p_arr
(a061app_columnname). The external column number, the  ccolpropset and the
stack entry of the column must have corresponding entries. If the column is a
mandatory column, its external column number is inserted into the bmatoryset in
the first tbaserecord. If a default definition exists for the column, its
external column number is inserted into the bdefaultset in the first
tbaserecord.
 
.CM *-END-* specification -------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      c_corr_select    = true;
      c_do_sample      = true;
      c_variable_length= true;
 
 
(*------------------------------*) 
 
PROCEDURE
      a14create_tab_as_select (
            VAR acv     : tak_all_command_glob;
            VAR tableid : tgg00_Surrogate;
            parskey     : tak_parskey);
 
VAR
      select_parsed  : boolean;
      m_corr_select  : boolean;
      sharedSQL      : boolean;
      init_ex_kind   : tak_execution_kind;
      b_err          : tgg00_BasisError;
      dummy_int      : integer;
      del_cnt        : integer;
      aux_return     : tsp00_Int2;
      aux_errorpos   : tsp00_Int4;
      as_pos         : tsp00_Int4;
      select_pos     : tsp00_Int4;
      init_mess_type : tsp1_cmd_mess_type;
      init_prepare   : boolean;
      parsid         : tak_parsid;
      part_ptr       : tsp1_part_ptr;
      sel_parsk      : tak_parsid;
      create_parsk   : tak_parskey;
      temptabkey     : tgg00_SysInfoKey;
      hpages         : tsp00_Int4;
      hrows          : tsp00_Int4;
      hres           : tsp00_NumError;
      p              : tsp00_Addr;
      stored_data    : tsp1_part_ptr;
      stored_ptr     : tsp1_part_ptr;
      htreeid        : tgg00_FileId;
 
BEGIN
init_mess_type  := acv.a_cmd_segment_header.sp1c_mess_type;
init_prepare    := acv.a_cmd_segment_header.sp1c_prepare;
init_ex_kind    := acv.a_init_ex_kind;
&ifdef trace
t01int4( ak_sem, 'init_mess_ty', ord( init_mess_type ));
&endif
parsid.pid_session := acv.a_transinf.tri_trans.trSessionId_gg00;
parsid.pid_parsk   := parskey;
(* the stored cmd has the old command_count            *)
(* if not, a corr subquery will destroy the stored cmd *)
(* now we have to destroy it in the end ! *)
IF  ( acv.a_command_sequence < csp_maxint4 )
THEN
    acv.a_command_sequence := acv.a_command_sequence + 1
ELSE
    acv.a_command_sequence := 1;
(*ENDIF*) 
acv.a_command_id := acv.a_command_sequence;
(* disable shared sql, will be reset to initial state at procedure end *)
;
sharedSQL             := acv.a_createSharedSQL;
acv.a_createSharedSQL := false;
create_parsk    := acv.a_pars_last_key;
a06reset_retpart( acv );
IF  acv.a_data_part <> NIL
THEN
    BEGIN
    (* save data_part in case it is execution of a *)
    (* create table as select with parameter       *)
    p := gg941Allocate (acv.a_transinf.tri_trans,
          sizeof (acv.a_data_part^.sp1p_part_header) + acv.a_data_part^.sp1p_buf_len);
    IF  p = NIL
    THEN
        a07_b_put_error (acv, e_no_more_memory, 1)
    ELSE
        BEGIN
        stored_data := @p^;
        SAPDB_PascalMove ('VAK14 ',   1,    
              acv.a_data_part^.sp1p_buf_size,
              sizeof (acv.a_data_part^.sp1p_part_header) + acv.a_data_part^.sp1p_buf_len,
              @acv.a_data_part^, 1, @stored_data^, 1,
              sizeof (acv.a_data_part^.sp1p_part_header) + acv.a_data_part^.sp1p_buf_len,
              acv.a_returncode);
        stored_ptr := acv.a_data_part;
        END
    (*ENDIF*) 
    END
ELSE
    BEGIN
    stored_data := NIL;
    stored_ptr := NIL
    END;
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    ak14parse_select_expr( acv, parsid, as_pos, select_pos );
&   ifdef trace
    t01int4( ak_sem, 'AS position ', as_pos );
&   endif
    END;
(*ENDIF*) 
m_corr_select := acv.a_corr_select;
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN (* save parse id of select *)
    a92find_return_part( acv, sp1pk_parsid, part_ptr );
    IF  ( part_ptr <> NIL )
    THEN
        BEGIN
        SAPDB_PascalMove ('VAK14 ',   2,    
              part_ptr^.sp1p_buf_size, sizeof( sel_parsk ),
              @part_ptr^.sp1p_buf, 1, @sel_parsk, 1, mxak_parsid,
              acv.a_returncode);
        a06reset_retpart( acv );
        select_parsed := true;
        END
    ELSE
        a07ak_system_error( acv, 14, 1 );
    (*ENDIF*) 
    END
ELSE
    select_parsed := false;
(*ENDIF*) 
IF  stored_data <> NIL
THEN
    BEGIN
    acv.a_data_part := stored_ptr;
    SAPDB_PascalMove ('VAK14 ',   3,    
          sizeof (stored_data^.sp1p_part_header) + stored_data^.sp1p_buf_len,
          sizeof (stored_data^.sp1p_part_header) + stored_data^.sp1p_buf_len,
          @stored_data^, 1, @acv.a_data_part^, 1,
          sizeof (stored_data^.sp1p_part_header) + stored_data^.sp1p_buf_len,
          acv.a_returncode);
    gg941Deallocate(acv.a_transinf.tri_trans, p);
    stored_data := NIL;
    END;
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    ak14create_table( acv, parsid, sel_parsk.pid_parsk, init_mess_type,
          as_pos, temptabkey, tableid );
(*ENDIF*) 
IF  ( select_parsed )
THEN
    BEGIN
    (* drop parse id of select, ignore errors, if occured in *)
    (* the course of drop parseid                            *)
    aux_return   := acv.a_returncode;
    aux_errorpos := acv.a_errorpos;
    acv.a_returncode := 0;
    acv.a_cmd_segment_header.sp1c_mess_type := sp1m_dbs;
    acv.a_cmd_segm^.sp1c_mess_type          := sp1m_dbs;
    (* PTS 1114071 E.Z. *)
    a663_drop_parsid (acv, sel_parsk, del_cnt);
    acv.a_returncode := aux_return;
    acv.a_errorpos   := aux_errorpos;
    END;
(*ENDIF*) 
IF  (acv.a_returncode = 0) AND
    (init_mess_type <> sp1m_execute)
THEN
    ak14insert_select( acv, parsid, init_mess_type, select_pos, m_corr_select );
(*ENDIF*) 
IF  (acv.a_returncode = 0) AND
    (temptabkey.stableid <> cgg_zero_id)
THEN
    BEGIN (* remove nolog Flag of Temp Table and set brows and bpages *)
    a10get_sysinfo (acv, temptabkey, d_release, acv.a_ptr1, b_err);
    IF  b_err = e_ok
    THEN
        BEGIN
        WITH acv.a_ptr1^.sbase DO
            BEGIN
            a92find_return_part (acv, sp1pk_resultcount, part_ptr);
            hrows := 1;
            hres := num_ok;
            IF  part_ptr <> NIL
            THEN
                s40glint (part_ptr^.sp1p_buf, 2, 10 (* 10 digits, PTS 1119764 *), hrows, hres);
            (*ENDIF*) 
            htreeid := btreeid;
            a06get_page_cnt (acv, htreeid, c_do_sample, hpages, b_err);
            IF  (hres = num_ok) AND (b_err = e_ok)
            THEN
                BEGIN
                bpages := hpages;
                brows  := hrows;
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        WITH acv.a_ptr1^.sbase.btreeid DO
            fileHandling_gg00 := fileHandling_gg00 - [ hsNoLog_egg00 ];
        (*ENDWITH*) 
        a10_add_repl_sysinfo (acv, acv.a_ptr1, false, b_err)
        END;
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  init_mess_type = sp1m_parse
    THEN
        BEGIN
        IF  NOT acv.a_progusage_add
        THEN
            BEGIN
            (* drop table in case of parsing for executing *)
            a52end_rollback_subtrans (acv,
                  a01_il_b_identifier, m_rollback)
            END;
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            ak14create_complex_parsinfo (acv, tableid, create_parsk)
        (*ENDIF*) 
        END
    ELSE
        IF  init_mess_type = sp1m_execute
        THEN
            acv.a_is_ddl := ddl_create_table
        ELSE
            acv.a_is_ddl := ddl_create_as_select;
        (*ENDIF*) 
    (*ENDIF*) 
    acv.a_ex_kind  := init_ex_kind;
    acv.a_cmd_segment_header.sp1c_mess_type := init_mess_type;
    acv.a_init_ddl := acv.a_is_ddl
    END
ELSE
    acv.a_part_rollback := true;
(*ENDIF*) 
acv.a_try_again := false;
WITH acv.a_transinf.tri_trans DO
    IF  acv.a_returncode = 0
    THEN
        IF  trWarning_gg00 <> [  ]
        THEN
            BEGIN
            acv.a_return_segm^.sp1r_extern_warning := trWarning_gg00;
            trWarning_gg00 := [  ]
            END
        ELSE
            trWarning_gg00 := [  ];
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
a542reset_packet (acv);
IF  ((acv.a_returncode <> 0) OR
    ((init_mess_type <> sp1m_parse) AND
    ( init_mess_type <> sp1m_execute)))
THEN
    BEGIN
    aux_return   := acv.a_returncode;
    aux_errorpos := acv.a_errorpos;
    acv.a_returncode := 0;
    a10prefix_parsid_delete (acv, parsid.pid_parsk, dummy_int,
          cak_complete_prefix);
    acv.a_shortinfo_key := cgg_zero_id;
    acv.a_returncode := aux_return;
    acv.a_errorpos   := aux_errorpos;
    END;
(*ENDIF*) 
acv.a_createSharedSQL := sharedSQL;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak14create_complex_parsinfo (
            VAR acv          : tak_all_command_glob;
            VAR tableid      : tgg00_Surrogate;
            VAR create_parsk : tak_parskey);
 
VAR
      b_err    : tgg00_BasisError;
      sysbuf   : tak_sysbufferaddress;
      sysk     : tgg00_SysInfoKey;
      part_ptr : tsp1_part_ptr;
 
BEGIN
WITH acv DO
    BEGIN
    sysk                := a01sysnullkey;
    sysk.sauthid[1]     := cak_tempinfo_byte;
    create_parsk.p_kind := m_complex;
    SAPDB_PascalForcedMove (sizeof (create_parsk), sizeof (sysk.sauthid),
          @create_parsk, 1, @sysk.sauthid, 2, mxak_parskey);
    sysk.sentrytyp := cak_ecomplex;
    a10_nil_get_sysinfo (acv, sysk,
          d_release, mxak_complexrecminlength +
          mxak_complex_entry, sysbuf, b_err);
    IF  b_err = e_ok
    THEN
        WITH sysbuf^.scomplexrec DO
            BEGIN
            create_parsk.p_kind := m_create_table;
            compcnt             := 2;
            compmax_sel_cnt     := 1;
            compcreateaseltree.fileTabId_gg00 := tableid;
            WITH comparr[1] DO
                BEGIN
                cparsk       := create_parsk;
                cnextpars    := 2;
                centryinfo   := [ ];
                cqual_jv_upd := no_jv_upd;
                END;
            (*ENDWITH*) 
            WITH comparr[2] DO
                BEGIN
                a92find_return_part (acv, sp1pk_parsid, part_ptr);
                IF  part_ptr <> NIL
                THEN
                    SAPDB_PascalMove ('VAK14 ',   4,    
                          part_ptr^.sp1p_buf_size, sizeof (cparsk),
                          @part_ptr^.sp1p_buf, INT4_MXSP00 + 1,
                          @cparsk, 1, mxak_parskey, b_err)
                ELSE
                    a07ak_system_error (acv, 14, 2);
                (*ENDIF*) 
                cnextpars    := 0;
                centryinfo   := [ ci_lastpars ];
                cqual_jv_upd := no_jv_upd;
                END;
            (*ENDWITH*) 
            IF  b_err = e_ok
            THEN
                a10_add_repl_sysinfo (acv, sysbuf, true, b_err)
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1)
    ELSE
        BEGIN
        a_is_ddl            := no_ddl;
        create_parsk.p_kind := m_complex;
        a54return_parsid (acv, create_parsk)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak14create_table (
            VAR acv          : tak_all_command_glob;
            VAR parsid       : tak_parsid;
            VAR sel_parsk    : tak_parskey;
            init_mess_type   : tsp1_cmd_mess_type;
            as_pos           : tsp00_Int4;
            VAR temptabkey   : tgg00_SysInfoKey;
            VAR tableid      : tgg00_Surrogate);
 
VAR
      in_subtrans : boolean;
      aux_parskey : tak_parskey;
 
BEGIN
(* restore initial command *)
in_subtrans         := acv.a_in_internal_subtr;
acv.a_in_internal_subtr := false;
a92parse_again( acv, parsid, false );
acv.a_in_internal_subtr := in_subtrans;
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN (* create table statement *)
    acv.a_cmd_segment_header.sp1c_mess_type := sp1m_dbs;
    acv.a_cmd_segm^.sp1c_mess_type          := sp1m_dbs;
    acv.a_cmd_part^.sp1p_buf_len   := as_pos - 1;
    acv.a_is_ddl                   := ddl_create_as_select;
    aux_parskey                    := acv.a_pars_last_key;
    acv.a_pars_last_key            := sel_parsk;
    a35_asql_statement( acv );
    IF  ( acv.a_returncode = 0 )
    THEN
        BEGIN
        tableid := acv.a_p_arr1.pbasep^.sbase.btreeid.fileTabId_gg00;
        IF  a101_IsExtendedTempFile (acv, acv.a_p_arr1.pbasep^.sbase.btreeid)
            AND
            NOT ( hsNoLog_egg00 in
            acv.a_p_arr1.pbasep^.sbase.btreeid.fileHandling_gg00 )
        THEN
            BEGIN
            (* insert select into temp table will always *)
            (* be executed without logging !             *)
            acv.a_p_arr1.pbasep^.sbase.btreeid.fileHandling_gg00 :=
                  acv.a_p_arr1.pbasep^.sbase.btreeid.fileHandling_gg00 +
                  [ hsNoLog_egg00 ];
            temptabkey  := acv.a_p_arr1.pbasep^.syskey;
            END
        ELSE
            temptabkey.stableid := cgg_zero_id
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    acv.a_pars_last_key := aux_parskey;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak14insert_select (
            VAR acv          : tak_all_command_glob;
            VAR parsid       : tak_parsid;
            init_mess_type   : tsp1_cmd_mess_type;
            select_pos       : integer;
            corr_select      : boolean);
 
VAR
      in_subtrans   : boolean;
      ins_len       : integer;
      ins_string    : tsp00_Sname;
      buf_len       : tsp00_Int4;
 
BEGIN
WITH acv DO
    BEGIN
    in_subtrans         := a_in_internal_subtr;
    a_in_internal_subtr := false;
    a92parse_again (acv, parsid, init_mess_type <> sp1m_parse);
    a_in_internal_subtr := in_subtrans;
    (* insert select statement *)
    a01_init_command (acv);
    a01_next_symbol  (acv);
    buf_len                  := a_cmd_part^.sp1p_buf_len;
    a_cmd_part^.sp1p_buf_len := 0;
    ins_string := 'INSERT INTO ';
    a542move_to_packet (acv, @ins_string, sizeof (ins_string));
    a_cmd_part^.sp1p_buf_len := buf_len;
    ins_len                  := a01char_size * sizeof (ins_string);
    a542fill_packet    (acv, ins_len + 1,
          a_scv.sc_sypos + a_scv.sc_sylength - ins_len - 1, bsp_c1);
    a01_next_symbol (acv);
    a01_next_symbol (acv);
    IF  a_scv.sc_symb = s_point
    THEN
        BEGIN
        a01_next_symbol (acv);
        a01_next_symbol (acv)
        END;
    (*ENDIF*) 
    a542fill_packet (acv,
          a_scv.sc_sypos, select_pos - a_scv.sc_sypos, bsp_c1);
&   IFDEF TRACE
    t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, 1, a_cmd_part^.sp1p_buf_len);
&   ENDIF
    acv.a_cmd_segment_header.sp1c_mess_type := init_mess_type;
    acv.a_cmd_segm^.sp1c_mess_type          := init_mess_type;
    (* PTS 1113190 E.Z. *)
    a92_mode_analyzer (acv, no_ddl, corr_select);
    IF  a_returncode =
        a071_return_code (e_row_not_found, a_sqlmode)
    THEN
        BEGIN
        a_part_rollback := false;
        a_returncode     := 0
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak14parse_select_expr (
            VAR acv         : tak_all_command_glob;
            VAR parsid      : tak_parsid;
            VAR as_pos      : tsp00_Int4;
            VAR select_pos  : tsp00_Int4);
 
VAR
      in_subtrans : boolean;
 
BEGIN
(* parse select expression *)
in_subtrans             := acv.a_in_internal_subtr;
acv.a_in_internal_subtr := false;
a92parse_again( acv, parsid, false );
acv.a_in_internal_subtr := in_subtrans;
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN (* recreate the syntax tree of select expr *)
    acv.a_cmd_segment_header.sp1c_mess_type := sp1m_syntax;
    acv.a_cmd_segm^.sp1c_mess_type          := sp1m_syntax;
    a92_mode_analyzer( acv, no_ddl, NOT c_corr_select );
    END;
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    as_pos := acv.a_ap_tree^[acv.a_ap_tree^[ 0 ].n_lo_level].n_pos;
    acv.a_compact_varpart := false;
    acv.a_scv.sc_newpos   := as_pos;
    a01_next_symbol (acv); (* keyword 'as' *)
    a01_next_symbol (acv); (* keyword 'select' *)
    select_pos := acv.a_scv.sc_sypos;
    (* remove CREATE TABLE AS *)
    a542fill_packet( acv, 1, select_pos - 1, bsp_c1 );
    IF  ( acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_lo_level <> 0 )
    THEN
        (* reject, ignore, update duplicates *)
        WITH acv.a_ap_tree^[ acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].
             n_lo_level ].n_lo_level ] DO
            (*  h.b. 25.11.98                                            *)
            (*  don't manipulate sp1p_buf_len because of following parts *)
            (*                                                           *)
            (*  acv.a_cmd_part^.sp1p_buf_len := n_pos - 1;                   *)
            a542fill_packet( acv, n_pos,
                  acv.a_cmd_part^.sp1p_buf_len - n_pos, bsp_c1 );
        (*ENDWITH*) 
    (*ENDIF*) 
    acv.a_cmd_segment_header.sp1c_mess_type := sp1m_parse;
    acv.a_cmd_segm^.sp1c_mess_type          := sp1m_parse;
&   IFDEF TRACE
    t01int4( ak_sem, 'as_pos      ', as_pos );
    t01int4( ak_sem, 'select_pos  ', select_pos);
    t01moveobj( ak_sem, acv.a_cmd_part^.sp1p_buf,
          1, acv.a_cmd_part^.sp1p_buf_len );
&   ENDIF
    a92_mode_analyzer( acv, ddl_create_as_select, NOT c_corr_select );
    acv.a_resname_addr[ cak_extern_pos ] := NIL;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a14default_spec (
            VAR acv          : tak_all_command_glob;
            VAR a11v         : tak_a11_glob;
            VAR col_info     : tak00_columninfo);
 
VAR
      b_err        : tgg00_BasisError;
      ix           : integer;
      error_pos    : integer;
      required_len : integer;
      valueLength  : integer; (* PTS 1108428 *)
 
BEGIN
WITH acv, a11v DO
    IF  a_returncode = 0
    THEN
        BEGIN
        valueLength := 0; (* PTS 1108428 *)
        b_err       := e_ok;
&       IFDEF TRACE
        t01int4 (ak_sem, 'a1ti        ', a1ti);
&       ENDIF
        IF  a1ti > 0
        THEN
            error_pos :=
                  a_ap_tree^[a_ap_tree^[a1ti].n_lo_level].n_pos
        ELSE
            error_pos := a_ap_tree^[ -a1ti ].n_pos;
        (*ENDIF*) 
        col_info.ccolpropset := col_info.ccolpropset + [ ctdefault ];
        WITH a1valkey DO
            BEGIN
            stableid := a1tableid;
            IF  a1temp_table
            THEN
                sentrytyp:= cak_etempdefault
            ELSE
                sentrytyp:= cak_edefault;
            (*ENDIF*) 
            slinkage[1]   := chr (col_info.cextcolno DIV 256);
            slinkage[2]   := chr (col_info.cextcolno MOD 256);
            skeylen       := mxak_standard_sysk;
            required_len  := sizeof (tak_defaultrecord);
            a10_nil_get_sysinfo (acv, a1valkey, d_release,
                  required_len, a1valsysp, b_err);
            IF  b_err = e_ok
            THEN
                WITH  a1valsysp^, sdefault DO
                    BEGIN
                    IF  a_is_ddl = ddl_create_domain
                    THEN (* Call from create domain *)
                        dfsegment_id := cak00_public_segment_id
                    ELSE (* Call from create or alter table *)
                        dfsegment_id :=
                              a_p_arr1.pbasep^.sbase.bsegmentid;
                    (*ENDIF*) 
                    dfdefault_function := 0;
                    a1valbufexist     := true
                    END
                (*ENDWITH*) 
            ELSE
                IF  b_err = e_duplicate_sysinfo
                THEN
                    a07_b_put_error (acv, e_duplicate_default,
                          error_pos)
                ELSE
                    a07_b_put_error (acv, b_err, 1)
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        IF  a_returncode = 0
        THEN
            IF  a1ti > 0
            THEN
                BEGIN (* default spec *)
                ak14default (acv, a11v, col_info, valueLength)
                END
            ELSE
                BEGIN (* not null with default *)
                ak14not_null_with_default (acv, a11v, col_info, valueLength)
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            IF  ctserial in col_info.ccolpropset
            THEN
                BEGIN
                IF  a1serial_node > 0
                THEN
                    a07_b_put_error (acv, e_too_many_serials, error_pos)
                ELSE
                    BEGIN
                    a1serial_node := a1ti;
                    FOR ix := 1 TO 2 DO
                        a1serial_node :=
                              a_ap_tree^[a1serial_node].n_lo_level;
                    (*ENDFOR*) 
                    a10_key_del (acv, a1valsysp^.syskey)
                    END
                (*ENDIF*) 
                END
            ELSE
                IF  ctdefault in col_info.ccolpropset
                THEN
                    BEGIN
                    (* PTS 1114777 E.Z. *)
                    WITH a1valsysp^.sdefault DO
                        dfreclen := cak_sysbufferoffset + 4 + 1 + valueLength;
                    (*ENDWITH*) 
                    a10_add_repl_sysinfo (acv, a1valsysp, a1add_rec, b_err);
                    IF  b_err = e_duplicate_sysinfo
                    THEN
                        a07_b_put_error (acv, e_duplicate_default,
                              error_pos)
                    (*ENDIF*) 
                    END
                ELSE
                    IF  NOT a1add_rec
                    THEN
                        a10del_sysinfo (acv, a1valkey, b_err);
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            IF  b_err <> e_ok
            THEN
                a07_b_put_error (acv, b_err, 1);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a14constraint_check (
            VAR acv       : tak_all_command_glob;
            col_info      : tak00_columninfo;
            constraint_id : integer;
            error_pos     : integer);
 
VAR
      b_err       : tgg00_BasisError;
      default_ptr : tak_sysbufferaddress;
      sysk        : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
    IF  ctdefault in col_info.ccolpropset
    THEN
        BEGIN (* check, if default fulfills constraint *)
        sysk           := a_p_arr1.pbasep^.syskey;
        (* PTS 1115207 E.Z. *)
        IF  sysk.sentrytyp > cak_etemp
        THEN
            sysk.sentrytyp := cak_etempdefault
        ELSE
            sysk.sentrytyp := cak_edefault;
        (*ENDIF*) 
        sysk.slinkage[1] := chr(col_info.cextcolno DIV 256);
        sysk.slinkage[2] := chr(col_info.cextcolno MOD 256);
        a10get_sysinfo (acv, sysk, d_release, default_ptr, b_err);
        IF  b_err = e_ok
        THEN
            WITH default_ptr^.sdefault DO
                BEGIN
                IF  dfdefault_function = 0
                THEN
                    a05is_const_in_constraint (acv, dfvalues, 2,
                          a14LengthOfDefaultValue(default_ptr^.sdefault),
                          a_p_arr1.pbasep^.sbase.btreeid, constraint_id,
                          e_default_not_in_range, error_pos)
                (*ENDIF*) 
                END
            (*ENDWITH*) 
        ELSE
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a14LengthOfDefaultValue (
            VAR DefaultRec : tak_defaultrecord) : integer;
 
BEGIN
a14LengthOfDefaultValue := DefaultRec.dfreclen -
      cgg_rec_key_offset - DefaultRec.dfkeylen -
      sizeof(DefaultRec.dfsegment_id) - sizeof(DefaultRec.dfdefault_function) - 1;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a14dfunction (
            VAR acv      : tak_all_command_glob;
            VAR col_info : tak00_columninfo;
            subproc      : integer;
            error_pos    : integer;
            VAR func_id  : tsp00_Int2);
 
VAR
      e        : tgg00_BasisError;
      fraction : integer;
 
BEGIN
e := e_ok;
WITH col_info DO
    CASE subproc OF
        cak_i_null :
            ccolpropset :=
                  ccolpropset - [ctdefault] + [ctopt];
        cak_i_stamp :
            IF  cdatatyp in [ dchb, dstra, dstrb, dstruni,
                dlonga, dlongb, dlonguni ]
            THEN
                IF  cinoutlen > SURROGATE_MXGG00
                THEN
                    func_id := cak_x_stamp
                ELSE
                    e := e_invalid_datalength
                (*ENDIF*) 
            ELSE
                e := e_function_not_allowed;
            (*ENDIF*) 
        cak_i_uid :
            IF  (cdatatyp in [ dfixed, dfloat ])
            THEN
                BEGIN
                IF  cdatatyp = dfloat
                THEN
                    fraction := 0
                ELSE
                    fraction := cdatafrac - 1;
                (*ENDIF*) 
                IF  cdatalen - fraction >= 10
                THEN
                    func_id := cak_x_uid
                ELSE
                    e := e_invalid_datalength
                (*ENDIF*) 
                END
            ELSE
                e := e_function_not_allowed;
            (*ENDIF*) 
        (* PTS 1122484 E.Z. *)
        cak_i_user, cak_i_usergroup, cak_i_sysdba :
            IF  (cdatatyp in [ dcha, dunicode ]) AND
                (* PTS 1103792 E.Z. *)
                ((cdatalen >= a01identifier_size DIV a01char_size) OR
                ((acv.a_sqlmode = sqlm_ansi) AND (cinoutlen > mxsp_c18)))
            THEN
                CASE subproc OF
                    cak_i_user :
                        func_id := cak_x_user;
                    cak_i_usergroup :
                        func_id := cak_x_usergroup;
                    cak_i_sysdba :
                        func_id := cak_x_sysdba;
                    END
                (*ENDCASE*) 
            ELSE
                e := e_function_not_allowed;
            (*ENDIF*) 
        cak_i_date :
            IF  cdatatyp = ddate
            THEN
                func_id := cak_x_date
            ELSE
                e := e_function_not_allowed;
            (*ENDIF*) 
        cak_i_time :
            IF  cdatatyp = dtime
            THEN
                func_id := cak_x_time
            ELSE
                e := e_function_not_allowed;
            (*ENDIF*) 
        cak_i_timestamp :
            IF  cdatatyp = dtimestamp
            THEN
                func_id := cak_x_timestamp
            ELSE
                e := e_function_not_allowed;
            (*ENDIF*) 
        cak_i_transaction :
            IF  (cdatatyp = dchb) AND (cdatalen >= sizeof (tgg91_TransNo))
            THEN
                func_id := cak_x_transaction
            ELSE
                e := e_function_not_allowed;
            (*ENDIF*) 
        cak_i_true :
            IF  cdatatyp = dboolean
            THEN
                func_id := cak_x_true
            ELSE
                e := e_function_not_allowed;
            (*ENDIF*) 
        cak_i_false :
            IF  cdatatyp = dboolean
            THEN
                func_id := cak_x_false
            ELSE
                e := e_function_not_allowed;
            (*ENDIF*) 
        cak_i_serial :
            IF  (cdatatyp = dfixed) AND (cdatafrac = cak_frac_offset)
            THEN
                BEGIN
                ccolpropset := ccolpropset + [ctserial] - [ctdefault];
                func_id    := 0
                END
            ELSE
                e := e_function_not_allowed;
            (*ENDIF*) 
        (* PTS 1122484 E.Z. *)
        cak_i_utcdate :
            IF  cdatatyp = dtimestamp
            THEN
                func_id := cak_x_utcdate
            ELSE
                e := e_function_not_allowed;
            (*ENDIF*) 
        cak_i_utcdiff :
            IF  (cdatatyp in [ dfixed, dfloat ])
                AND
                (cdatalen >= cak_utcdiff_len)
                AND
                ((cdatafrac = cak_ak_float)                     OR
                ((cdatalen - (cdatafrac - cak_frac_offset) >=
                cak_utcdiff_len - cak_utcdiff_frac) AND
                ( cdatafrac - cak_frac_offset >= cak_utcdiff_frac)))
            THEN
                func_id := cak_x_utcdiff
            ELSE
                e := e_function_not_allowed;
            (*ENDIF*) 
        cak_i_timezone :
            IF  (cdatatyp in [ dfixed, dfloat ]) AND
                (cdatalen >= cak_time_durationlen)
            THEN
                func_id := cak_x_timezone
            ELSE
                e := e_function_not_allowed;
            (*ENDIF*) 
        END;
    (*ENDCASE*) 
(*ENDWITH*) 
IF  e <> e_ok
THEN
    IF  e = e_function_not_allowed
    THEN
        a07_const_b_put_error (acv, e,
              error_pos, @a01kw[subproc], sizeof (a01kw[subproc]))
    ELSE
        a07_b_put_error (acv, e, error_pos)
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a14get_colname (
            VAR acv  : tak_all_command_glob;
            VAR a11v : tak_a11_glob;
            err_pos  : integer);
 
VAR
      colno   : integer;
      offset  : integer;
      col_ptr : tak00_colinfo_ptr;
 
BEGIN
WITH acv, a11v DO
    BEGIN
    IF  a_p_arr1.pbasep^.sbase.btablekind = twithkey
    THEN
        offset := 1
    ELSE
        offset := 0;
    (*ENDIF*) 
    colno := a_p_arr1.pbasep^.sbase.bmaxcol + 1;
    IF  colno + offset > a_p_arr2.pbasep^.sresult.bmaxcol
    THEN
        a07_b_put_error (acv, e_too_many_columns, err_pos)
    ELSE
        BEGIN
        a06extcolno (a_p_arr2.pbasep^.sbase, colno + offset, col_ptr);
        a061get_colname (col_ptr^, a1coln)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a14get_result_datatype (
            VAR acv          : tak_all_command_glob;
            VAR a11v         : tak_a11_glob;
            VAR col_info     : tak00_columninfo;
            error_pos        : integer);
 
VAR
      offset  : integer;
      col_ptr : tak00_colinfo_ptr;
 
BEGIN
WITH acv, a11v DO
    BEGIN
    IF  a_p_arr1.pbasep^.sbase.btablekind = twithkey
    THEN
        offset := 1
    ELSE
        offset := 0;
    (*ENDIF*) 
    IF  col_info.cextcolno + offset > a_p_arr2.pbasep^.sresult.bmaxcol
    THEN
        a07_b_put_error (acv, e_too_many_columns, error_pos)
    ELSE
        BEGIN
        a06extcolno (a_p_arr2.pbasep^.sbase,
              col_info.cextcolno + offset, col_ptr);
        WITH col_ptr^ DO
            BEGIN
            col_info.cdatatyp      := cdatatyp;
            (* PTS 1120890 E.Z. *)
            col_info.cdatatyp      := cdatatyp;
            IF  col_info.cdatatyp in
                [dstra, dstrb, dstruni,
                dlonga, dlongb, dlonguni]
            THEN
                IF  a11v.a1temp_table
                THEN
                    a07_b_put_error (acv, e_command_for_string_not_allow, 1)
                ELSE
                    BEGIN
                    col_info.cdatalen      := SURROGATE_MXGG00;
                    col_info.cinoutlen     := succ(col_info.cdatalen);
                    END
                (*ENDIF*) 
            ELSE
                BEGIN
                col_info.cdatalen      := cdatalen;
                col_info.cinoutlen     := cinoutlen;
                END;
            (*ENDIF*) 
            col_info.cdatafrac     := cdatafrac;
            (*col_info.cshiftoutchar := chr(ord(false))*)
            col_info.cshiftoutchar := cshiftoutchar
            END;
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak14default  (
            VAR acv          : tak_all_command_glob;
            VAR a11v         : tak_a11_glob;
            VAR col_info     : tak00_columninfo;
            VAR valueLength  : integer (* PTS 1108428 *)
            );
 
VAR
      i         : integer;
 
BEGIN
WITH acv, a11v, a1valsysp^.sdefault  DO
    BEGIN
    dfdefault_function := 0;
    i                  := a_ap_tree^[ a1ti ].n_lo_level;
    WITH   col_info, a_ap_tree^[ i ] DO
        BEGIN
        IF  n_proc = a14
        THEN
            a14dfunction (acv,
                  col_info, n_subproc, n_pos, dfdefault_function)
        ELSE
            BEGIN
            IF  col_info.cdatatyp in [ dstra, dstrb, dstruni,
                dlonga, dlongb, dlonguni ]
            THEN
                BEGIN
                valueLength := sizeof(dfvalues) - 1;
                a14dfunction (acv,
                      col_info, cak_i_stamp, n_pos, dfdefault_function);
                a05long_literal_get (acv, i, col_info.cdatatyp,
                      dfvalues, 2, valueLength);
                END
            ELSE
                a05_li_constant_get (acv, i, col_info, col_info.cinoutlen,
                      sizeof(dfvalues) - 1, dfvalues, 2, NOT c_variable_length, valueLength);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    dfvalues [ 1 ] := chr(1) (* PTS 1108428 *)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak14not_null_with_default  (
            VAR acv          : tak_all_command_glob;
            VAR a11v         : tak_a11_glob;
            VAR col_info     : tak00_columninfo;
            VAR curr_len     : integer (* PTS 1108428 *)
            );
 
VAR
      res              : tsp00_NumError;
 
BEGIN
WITH acv, a11v, a1valsysp^.sdefault  DO
    BEGIN
    dfdefault_function := 0;
    curr_len           := 0;
    CASE col_info.cdatatyp OF
        dboolean :
            BEGIN
            dfdefault_function := cak_x_false;
            END;
        dcha :
            BEGIN
            curr_len := 2;
            dfvalues[ 2 ] := csp_ascii_blank;
            dfvalues[ 3 ] := csp_ascii_blank
            END;
        dchb :
            BEGIN
            curr_len := 2;
            dfvalues[ 2 ] := csp_defined_byte;
            dfvalues[ 3 ] := csp_defined_byte
            END;
        dunicode :
            BEGIN
            curr_len := 3;
            dfvalues[ 2 ] := csp_unicode_def_byte;
            dfvalues[ 3 ] := csp_unicode_mark;
            dfvalues[ 4 ] := csp_ascii_blank
            END;
        ddate :
            dfdefault_function := cak_x_date;
        dfixed, dfloat :
            BEGIN
            dfvalues[ 2 ] := csp_defined_byte;
            s41plint (dfvalues, 3, col_info.cdatalen,
                  col_info.cdatafrac, 0, res);
            curr_len := col_info.cinoutlen
            END;
        dtime :
            dfdefault_function := cak_x_time;
        dtimestamp :
            dfdefault_function := cak_x_timestamp;
        (* PTS 1104649 E.Z. *)
        dlonga, dstra :
            BEGIN
            curr_len := 2;
            dfvalues[ 2 ] := csp_ascii_blank;
            dfvalues[ 3 ] := csp_ascii_blank
            END;
        dlongb, dstrb :
            BEGIN
            curr_len := 2;
            dfvalues[ 2 ] := csp_defined_byte;
            dfvalues[ 3 ] := csp_defined_byte
            END;
        dlonguni, dstruni :
            BEGIN
            curr_len := 3;
            dfvalues[ 2 ] := csp_unicode_def_byte;
            dfvalues[ 3 ] := csp_unicode_mark;
            dfvalues[ 4 ] := csp_ascii_blank
            END;
        OTHERWISE
            a07_b_put_error (acv, e_not_implemented, 1)
        END;
    (*ENDCASE*) 
    dfvalues [ 1 ] := chr(1)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a14drop_default (
            VAR acv      : tak_all_command_glob;
            VAR col_info : tak00_columninfo);
 
VAR
      b_err     : tgg00_BasisError;
      sysk      : tgg00_SysInfoKey;
      pSequence : tak_sysbufferaddress;
 
BEGIN
b_err := e_ok;
sysk  := acv.a_p_arr1.pbasep^.syskey;
IF  ctdefault in col_info.ccolpropset
THEN
    BEGIN
    col_info.ccolpropset :=
          col_info.ccolpropset - [ctdefault];
    sysk.sentrytyp   := cak_edefault;
    sysk.slinkage[1] := chr (col_info.creccolno DIV 256);
    sysk.slinkage[2] := chr (col_info.creccolno MOD 256);
    a10del_sysinfo (acv, sysk, b_err);
    END
ELSE (* PTS 1111778 *)
    IF  ctserial in col_info.ccolpropset
    THEN
        BEGIN
        col_info.ccolpropset :=
              col_info.ccolpropset - [ctserial];
        sysk.sentrytyp := cak_esequence;
        a10get_sysinfo (acv, sysk, d_release, pSequence, b_err);
        IF  b_err = e_ok
        THEN
            BEGIN
            a13FlushSequenceForDrop (acv, pSequence^.ssequence, b_err);
            IF  b_err = e_ok
            THEN
                (* remove from catalog *)
                a10del_sysinfo (acv, sysk, b_err);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  b_err <> e_ok
THEN
    a07_b_put_error (acv, b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a14like_tablen (
            VAR acv  : tak_all_command_glob;
            VAR a11v : tak_a11_glob);
 
CONST
      c_repl = false;
 
VAR
      b_err           : tgg00_BasisError;
      i               : integer;
      a11l            : tak_a11_like_record;
 
BEGIN
WITH acv, a11v, a11l DO
    BEGIN
    a1ti := a_ap_tree^[ a1ti ].n_sa_level;
&   IFDEF TRACE
    t01int4 (ak_sem, 'a1ti=       ', a1ti);
&   ENDIF
    a11get_check_table (acv, false, false, true, [  ], true, true,
          d_fix, a1ti, a1likename, a1liketablen, a1l_p_arr);
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  a1likename = a01_i_temp
        THEN
            BEGIN
            a1nolog := (hsNoLog_egg00 in
                  a1l_p_arr.pbasep^.sbase.btreeid.fileHandling_gg00) AND
                  NOT (a1l_p_arr.pbasep^.sbase.btablekind in
                  [tdb2view]);
            a1like_temp_table := true;
            a1likeid          := a1l_p_arr.pbasep^.syskey.stableid
            END
        ELSE
            BEGIN
            a1like_temp_table := false;
            a1likeid          := a1l_p_arr.pbasep^.sbase.btreeid.fileTabId_gg00
            END;
        (*ENDIF*) 
        a1l_likecolset := [  ];
        FOR i := 1 TO a1l_p_arr.pbasep^.sbase.bmaxcol DO
            a1l_rec_to_ext [ i ] := 0;
        (*ENDFOR*) 
        a06_get_priv (acv, a1l_p_arr.pbasep, a1l_privset);
        IF  a1l_privset.priv_all_set <> [  ]
        THEN
            BEGIN
            a1l_privset.priv_upd_set := [  ];
            a1l_privset.priv_sel_set := [  ];
            FOR i := 1 TO a1l_p_arr.pbasep^.sbase.bmaxcol DO
                a1l_privset.priv_upd_set :=
                      a1l_privset.priv_upd_set + [ i ];
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        ak14priv_column_like (acv, a11v, a11l);
        a1createtab        := true;
        a1liketable        := true;
        a1sort             := true;
        a11end_create_table (acv, a11v);
        IF  a_returncode = 0
        THEN
            BEGIN
            IF  (a1l_p_arr.pbasep^.sbase.bnamed_constr > 0) AND
                (a1l_p_arr.pbasep^.sbase.btablekind <> tview)
            THEN
                ak14like_constraints (acv, a11v, a11l);
            (*ENDIF*) 
            IF  a_p_arr1.pbasep^.sbase.bnamed_constr > 0
            THEN
                BEGIN
                a10_add_repl_sysinfo (acv, a_p_arr1.pbasep, c_repl, b_err);
                IF  b_err <> e_ok
                THEN
                    a07_b_put_error (acv, b_err, 1)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak14like_constraints (
            VAR acv  : tak_all_command_glob;
            VAR a11v : tak_a11_glob;
            VAR a11l : tak_a11_like_record);
 
VAR
      b_err      : tgg00_BasisError;
      entrytype  : tsp00_C2;
      colno      : integer;
      constr_id  : integer;
      cnamebuf   : tak_sysbufferaddress;
      constrbuf  : tak_sysbufferaddress;
      constr_key : tgg00_SysInfoKey;
      sysk       : tgg00_SysInfoKey;
      new_sysk   : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a11v, a11l DO
    BEGIN
    constr_id  := 0;
    constr_key := a1l_p_arr.pbasep^.syskey;
    IF  a101_IsExtendedTempFile (acv, a1l_p_arr.pbasep^.sbase.btreeid)
    THEN
        entrytype := cak_etmpconstraintname
    ELSE
        BEGIN
        entrytype            := cak_econstraintname;
        constr_key.stableid  := a1l_p_arr.pbasep^.sbase.btreeid.fileTabId_gg00
        END;
    (*ENDIF*) 
    constr_key.sentrytyp := entrytype;
    REPEAT
        a10next_sysinfo (acv, constr_key, SURROGATE_MXGG00+2, d_release,
              entrytype, cnamebuf, b_err);
        IF  b_err = e_ok
        THEN
            BEGIN
            sysk          := constr_key;
            sysk.skeylen  := mxak_standard_sysk;
            IF  a101_IsExtendedTempFile (acv, a1l_p_arr.pbasep^.sbase.btreeid)
            THEN
                sysk.sentrytyp := cak_etempconstraint
            ELSE
                sysk.sentrytyp := cak_econstraint;
            (*ENDIF*) 
            colno          := cnamebuf^.sconstrname.cnid;
            sysk.slinkage[1] := chr(colno DIV 256);
            sysk.slinkage[2] := chr(colno MOD 256);
            a10get_sysinfo (acv, sysk, d_release, constrbuf, b_err)
            END;
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            IF  constrbuf^.sconstraint.ccolset - a1l_likecolset = [  ]
            THEN
                BEGIN
                constr_id         := constr_id + 1;
                IF  constr_id > cak_max_constraints
                THEN
                    a07_b_put_error (acv, e_too_many_constraints, 1)
                ELSE
                    BEGIN
                    a11getconstraintname (constrbuf^.sconstraint,
                          a1constraint_name);
                    new_sysk          := cnamebuf^.syskey;
                    new_sysk.stableid := a_p_arr1.pbasep^.syskey.stableid;
                    IF  a1temp_table
                    THEN
                        new_sysk.sentrytyp := cak_etmpconstraintname
                    ELSE
                        new_sysk.sentrytyp := cak_econstraintname;
                    (*ENDIF*) 
                    cnamebuf^.sconstrname.cnid := constr_id;
                    a10_copy_catalog_rec (acv, cnamebuf^.syskey,
                          false,new_sysk, a_p_arr1.pbasep^.sbase.bsegmentid,
                          true, b_err);
                    IF  b_err = e_ok
                    THEN
                        a11constraint (acv, a11v,
                              a1l_p_arr.pbasep^.sbase, constr_id)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    UNTIL
        b_err <> e_ok;
    (*ENDREPEAT*) 
    IF  b_err <> e_no_next_record
    THEN
        a07_b_put_error (acv, b_err, 1)
    ELSE
        a_p_arr1.pbasep^.sbase.bnamed_constr := constr_id
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak14priv_column_like (
            VAR acv     : tak_all_command_glob;
            VAR a11v    : tak_a11_glob;
            VAR a11l : tak_a11_like_record);
 
VAR
      ok          : boolean;
      is_joinview : boolean;
      col_cnt     : integer;
      maxcols     : integer;
      i           : integer;
      colind      : integer;
      privset     : tak_columnset;
      colinfo     : tak00_columninfo;
 
BEGIN
WITH acv, a11v, a11l DO
    BEGIN
    a1strcolcount := 0;
    IF  a_returncode = 0
    THEN
        BEGIN
        is_joinview := a1l_p_arr.pbasep^.sbase.btablekind = tview;
        privset     :=
              a1l_privset.priv_upd_set + a1l_privset.priv_sel_set;
        IF  privset = [  ]
        THEN
            a07_b_put_error (acv, e_unknown_tablename, 1)
        ELSE
            a11init_baserecord (acv, a11v)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        a1inpkey    := true;
        a1keypos    := 1;
        a1reclen    := cgg_rec_key_offset;
        col_cnt     := 1;
        maxcols     := a1l_p_arr.pbasep^.sbase.bmaxcol;
        a1createtab := true;
        colind      := a1l_p_arr.pbasep^.sbase.bfirstcolind;
        i           := 0;
        a_p_arr1.pbasep^.sbase.btablekind := twithkey;
        IF  g01columncompression           AND
            NOT (a_initial_segment_header.sp1c_producer = sp1pr_installation)
        THEN
            a_p_arr1.pbasep^.sbase.battributes := a_p_arr1.pbasep^.sbase.battributes +
                  [ ta_no_fixed_length_column ];
        (*ENDIF*) 
        REPEAT
            WITH a1l_p_arr.pbasep^.sbase.bcolumn[ colind ]^ DO
                IF  (ctopt in ccolpropset      ) OR
                    (ctinvisible in ccolpropset) OR
                    NOT (ctkey in ccolpropset)   OR
                    NOT (cextcolno in privset)
                THEN
                    BEGIN (* assign system key, if complete key of the *)
                    (* source table is not visible for current user    *)
                    a11put_systemkey (acv, a11v);
                    a_p_arr1.pbasep^.sbase.btablekind := twithoutkey
                    END
                ELSE
                    colind := cnextind;
                (*ENDIF*) 
            (*ENDWITH*) 
            i := i + 1;
        UNTIL
            (i = a1l_p_arr.pbasep^.sbase.bkeycolcount) OR
            (a_p_arr1.pbasep^.sbase.btablekind = twithoutkey);
        (*ENDREPEAT*) 
        REPEAT
            a14_get_columninfo (acv, a11l, privset,
                  col_cnt, maxcols, colinfo, ok);
            IF  ok
            THEN
                BEGIN
                a1coln := colinfo.ccolumnn;
                IF  (ctaltered in colinfo.ccolpropset)         (* PTS: 1117200 *)
                THEN
                    colinfo.ccolpropset := colinfo.ccolpropset - [ ctaltered ];
                (*ENDIF*) 
                a14_put_columninfo (acv,
                      a11v, a11l, is_joinview, colinfo);
&               ifdef TRACE
                t01int4 (ak_sem, 'a1reclen    ', a1reclen);
&               endif
                END;
            (*ENDIF*) 
        UNTIL
            (NOT ok) OR (a_returncode <> 0);
        (*ENDREPEAT*) 
        a_p_arr1.pbasep^.sbase.bmaxreclen := a1reclen;
        IF  a1l_p_arr.pbasep^.sbase.btablekind in [twithkey, twithoutkey]
        THEN
            a_p_arr1.pbasep^.sbase.bsample :=
                  a1l_p_arr.pbasep^.sbase.bsample
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a14_get_columninfo  (
            VAR acv     : tak_all_command_glob;
            VAR a11l    : tak_a11_like_record;
            VAR privset : tak_columnset;
            VAR colno   : integer;
            VAR maxcolno: integer;
            VAR colinfo : tak00_columninfo;
            VAR found   : boolean);
 
VAR
      colptr : tak00_colinfo_ptr;
 
BEGIN
found := false;
WITH acv, a11l  DO
    IF  a_returncode = 0
    THEN
        BEGIN
        found := false;
        WHILE (colno <= maxcolno) AND (NOT found) DO
            BEGIN
            IF  (colno in privset)
            THEN
                BEGIN
                a06extcolno (a1l_p_arr.pbasep^.sbase, colno, colptr);
                WITH colptr^ DO
                    IF  NOT (ctdropped in ccolpropset)
                        AND
                        NOT (ctinvisible in ccolpropset)
                        AND
                        NOT ((ctkey in ccolpropset) AND
                        (ctopt in ccolpropset))
                        AND
                        ((
                        (cdatatyp <> dstra   ) AND
                        (cdatatyp <> dstrb   ) AND
                        (cdatatyp <> dstruni ) AND
                        (cdatatyp <> dlonga  ) AND
                        (cdatatyp <> dlongb  ) AND
                        (cdatatyp <> dlonguni)) OR
                        (a1l_p_arr.pbasep^.sbase.bauthid <>
                        cak_temp_user_id))
                    THEN
                        BEGIN
                        found   := true;
                        a061colinfo_to_var (colptr^, colinfo)
                        END;
                    (*ENDIF*) 
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            colno := colno + 1;
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a14_put_columninfo  (
            VAR acv     : tak_all_command_glob;
            VAR a11v    : tak_a11_glob;
            VAR a11l    : tak_a11_like_record;
            is_joinview : boolean;
            VAR colinfo : tak00_columninfo);
 
VAR
      b_err    : tgg00_BasisError;
      dom_ptr  : tak_sysbufferaddress;
      sysk     : tgg00_SysInfoKey;
      new_sysk : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a11v, a11l  DO
    BEGIN
    IF  a_returncode = 0
    THEN
        a061app_columnname (acv,
              a_p_arr1.pbasep^.sbase, a1coln, a1ci);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        WITH a_p_arr1, pbasep^.sbase, bcolumn[ a1ci ]^ DO
            BEGIN
            a061copy_colinfo (colinfo, bcolumn[a1ci]^);
            IF  ((ctdefault in ccolpropset) OR (ctserial in ccolpropset))
                AND NOT is_joinview
            THEN
                BEGIN (* copy default catalog record *)
                sysk := a1l_p_arr.pbasep^.syskey;
                IF  sysk.sentrytyp > cak_etemp
                THEN
                    sysk.sentrytyp := cak_etempdefault
                ELSE
                    BEGIN
                    sysk.stableid  :=
                          a1l_p_arr.pbasep^.sbase.btreeid.fileTabId_gg00;
                    IF  ctserial in ccolpropset
                    THEN
                        sysk.sentrytyp := cak_esequence
                    ELSE
                        sysk.sentrytyp := cak_edefault;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  NOT (ctserial in ccolpropset)
                THEN
                    BEGIN
                    sysk.slinkage[1] := chr (creccolno DIV 256);
                    sysk.slinkage[2] := chr (creccolno MOD 256)
                    END;
                (*ENDIF*) 
                new_sysk := a_p_arr1.pbasep^.syskey;
                IF  new_sysk.sentrytyp > cak_etemp
                THEN
                    new_sysk.sentrytyp := cak_etempdefault
                ELSE
                    IF  ctserial in ccolpropset
                    THEN
                        new_sysk.sentrytyp := cak_esequence
                    ELSE
                        new_sysk.sentrytyp := cak_edefault;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  NOT (ctserial in ccolpropset)
                THEN
                    BEGIN
                    new_sysk.slinkage[1] :=
                          chr (a_p_arr1.pbasep^.sbase.bmaxcol DIV 256);
                    new_sysk.slinkage[2] :=
                          chr (a_p_arr1.pbasep^.sbase.bmaxcol MOD 256)
                    END;
                (*ENDIF*) 
                a10_copy_catalog_rec (acv, sysk, false,
                      new_sysk, a_p_arr1.pbasep^.sbase.bsegmentid,
                      true, b_err);
                IF  b_err <> e_ok
                THEN
                    a07_b_put_error (acv, b_err, 1)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  (ctdomain in ccolpropset) AND NOT is_joinview
            THEN
                BEGIN (* copy default catalog record *)
                sysk             := a1l_p_arr.pbasep^.syskey;
                sysk.stableid    := a1l_p_arr.pbasep^.sbase.btreeid.fileTabId_gg00;
                sysk.sentrytyp   := cak_edomainusage;
                sysk.slinkage[1] := chr (creccolno DIV 256);
                sysk.slinkage[2] := chr (creccolno MOD 256);
                a10get_sysinfo (acv, sysk, d_release, dom_ptr, b_err);
                IF  b_err = e_ok
                THEN
                    BEGIN
                    WITH dom_ptr^.scol_uses_dom DO
                        a12read_domain_ref (acv,
                              cud_owner, cud_name, dom_ptr);
                    (*ENDWITH*) 
                    IF  NOT a1temp_table AND (dom_ptr <> NIL)
                    THEN
                        WITH dom_ptr^.sdomainref DO
                            a11domain_usage (acv, a11v,
                                  downer, dname , dsurrogate,
                                  a_p_arr1.pbasep^.sbase.bmaxcol)
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  b_err <> e_ok
                THEN
                    a07_b_put_error (acv, b_err, 1)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            cextcolno := a_p_arr1.pbasep^.sbase.bmaxcol;
            IF  NOT is_joinview
            THEN
                BEGIN
                a1l_likecolset :=
                      a1l_likecolset + [ creccolno ];
                a1l_rec_to_ext[ creccolno ] := cextcolno
                END;
            (*ENDIF*) 
            creccolno       := cextcolno;
            ctabno          := 1;
            (* PTS 1001449 E.Z. *)
            ccolpropset     := ccolpropset - [ ctcomment,
                  ctmulti,
                  ctlink, ctexpression, ctinvisible,
                  ctviewname ];
            WITH ccolstack DO
                BEGIN
                IF  (cdatatyp <> dstra   ) AND
                    (cdatatyp <> dstrb   ) AND
                    (cdatatyp <> dstruni ) AND
                    (cdatatyp <> dlonga  ) AND
                    (cdatatyp <> dlongb  ) AND
                    (cdatatyp <> dlonguni)
                THEN
                    ecol_tab[ 1 ] := chr(0);
                (*ENDIF*) 
                ecol_tab[ 2 ] := chr(0);
                eop           := op_none;
                END;
            (*ENDWITH*) 
            a1extcolno := cextcolno;
            a1reclen   := a1reclen + cinoutlen;
            IF  (ctkey in ccolpropset) AND
                (pbasep^.sbase.btablekind = twithkey)
            THEN
                BEGIN
                WITH pbasep^.sbase DO
                    bkeycolcount := succ(bkeycolcount);
                (*ENDWITH*) 
                END
            ELSE
                BEGIN
                ccolpropset := ccolpropset - [ ctkey ];
                a1inpkey := false
                END;
            (*ENDIF*) 
            IF  NOT (ctkey in ccolpropset)
            THEN
                BEGIN
                IF  cdatatyp in [dstra, dstrb, dstruni,
                    dlonga, dlongb, dlonguni]
                THEN
                    BEGIN
                    cdatalen  := cgg04_str_col_entry_size;
                    cinoutlen := cgg04_str_col_entry_size + 1;
                    WITH ccolstack DO
                        BEGIN
                        epos          := a1strcolcount * (cgg_col_fd_size) + 1;
                        elen_var      := cinoutlen;
                        a1strcolcount := a1strcolcount + 1
                        END;
                    (*ENDWITH*) 
                    END
                ELSE
                    WITH ccolstack DO
                        IF  (cinoutlen > cak_maxconstlength + 1)
                            OR
                            (ta_no_fixed_length_column in battributes)
                            OR
                            ((cdatatyp <> dfixed) AND
                            cvarchar AND
                            (cdatalen > 2))
                        THEN
                            BEGIN
                            epos   := 0;
                            IF  cinoutlen > cak_maxfieldlength + 1
                            THEN
                                BEGIN
                                etype         := st_varlongchar;
                                a1longcharcnt := succ(a1longcharcnt);
                                ecolno        := a1longcharcnt;
                                elen_var      := cinoutlen;
                                a1reclen      := a1reclen + 2
                                END
                            ELSE
                                WITH pbasep^ DO
                                    BEGIN
                                    etype := st_varcol;
                                    sbase.bvarcolcount :=
                                          sbase.bvarcolcount+1;
                                    ecolno   := sbase.bvarcolcount;
                                    elen_var := cinoutlen;
                                    a1reclen := a1reclen + 1
                                    END;
                                (*ENDWITH*) 
                            (*ENDIF*) 
                            END
                        ELSE
                            WITH pbasep^ DO
                                BEGIN
                                etype    := st_fixcol;
                                epos     := sbase.blenfixedcol;
                                elen_var := cinoutlen;
                                sbase.blenfixedcol  :=
                                      sbase.blenfixedcol + cinoutlen;
                                END;
                            (*ENDWITH*) 
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        IF  (a1reclen > MAX_RECLEN_GG00)
        THEN
            a1reclen := MAX_RECLEN_GG00
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
