.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-17
*****************************************************
modname : VAK362
changed : 2000-11-17
module  : Catalog_Migration_2
 
Author      : MartinKi
responsible : MartinKi
Created : 2002-07-29
*****************************************************
 
Purpose : Catalog migration from ASCII to Unicode (UCS-2)
 
Define  :
 
        VAR
              a362OnlineTaskId : tsp00_TaskId;
 
        PROCEDURE
              a362migrate (
                    VAR acv             : tak_all_command_glob;
                    VAR in_warm_session : boolean);
 
        PROCEDURE
              a362AuthorizationConvertPasswords (VAR authorization : tak_userrecord;
                    VAR e : tgg00_BasisError);
 
        PROCEDURE
              a362SetUserAndSchema (
                    VAR acv      : tak_all_command_glob;
                    VAR userName : tsp00_KnlIdentifier;
                    VAR userId   : tgg00_Surrogate;
                    VAR schemaId : tgg00_Surrogate;
                    VAR userInfo : tak_user_info);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Encrypting : VSP02;
 
        PROCEDURE
              s02encrypt (
                    VAR clearname : tsp00_Name;
                    VAR crypt     : tsp00_CryptPw);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80 : VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        PROCEDURE
              s30cmp (VAR buf1   : tgg00_FileId;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tgg00_FileId;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
        FUNCTION
              s30lnr (VAR str : tsp00_KnlIdentifier;
                    skip_val  : char;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30lnr1 (VAR str : tsp00_MoveObj;
                    skip_val  : char;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30unilnr (str  : tsp00_MoveObjPtr       (*ptocSynonym const void**);
                    skip_val  : tsp00_C2;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vfclose (hostfileno : tsp00_Int4;
                    VAR error         : tsp00_VfReturn;
                    VAR errtext       : tsp00_ErrText);
 
        PROCEDURE
              vfrawopen (VAR hostfile : tsp00_VFilename;
                    VAR hostfileno : tsp00_Int4;
                    VAR error      : tsp00_VfReturn;
                    VAR errtext    : tsp00_ErrText);
 
        PROCEDURE
              vfwrite (hostfileno : tsp00_Int4;
                    buf               : tsp_vf_bufaddr;
                    VAR error         : tsp00_VfReturn;
                    VAR errtext       : tsp00_ErrText);
 
        PROCEDURE
              vtime_in_seconds (VAR time_in_sec : tsp00_Int4);
 
        PROCEDURE
              vxparam_save_good_config (
                    is_restart  : boolean;
                    VAR errtext : tsp00_ErrText;
                    VAR xp_ret  : tsp00_XpReturnCode);
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01defaultkey         : tgg00_SysInfoKey;
              a01controluser        : tsp00_KnlIdentifier;
              a01_il_b_identifier   : tsp00_KnlIdentifier;
              a01char_size          : integer;
 
        PROCEDURE
              a01sets_identifier (
                    VAR id         : tsp00_KnlIdentifier;
                    set_identifier : tak_oldidentifier);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06a_mblock_init (
                    VAR acv   : tak_all_command_glob;
                    mtype     : tgg00_MessType;
                    m2type    : tgg00_MessType2;
                    VAR tree  : tgg00_FileId);
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06lsend_mess_buf (
                    VAR acv         : tak_all_command_glob;
                    VAR mbuf        : tgg00_MessBlock;
                    call_from_rsend : boolean;
                    VAR e           : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache   : VAK10;
 
        PROCEDURE
              a10add_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_all_release (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10_cache_delete  (
                    VAR acv     : tak_all_command_glob;
                    is_rollback : boolean);
 
        PROCEDURE
              a10EnableTableAccess;
 
        PROCEDURE
              a10expand_rec (VAR rec_buf : tgg00_Rec;
                    VAR e : tgg00_BasisError);
 
        PROCEDURE
              a10key_del  (
                    VAR acv         : tak_all_command_glob;
                    VAR  syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10get_sysinfo (
                    (* don't use this, use ak362get_old_sysinfo instead *)
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_fix_len_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    required_len : integer;
                    plus         : integer;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate (* ptocConst *);
                    VAR schemaName : tsp00_KnlIdentifier);
 
        PROCEDURE
              a103ToUnicode (
                    VAR acv  : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              Catalog_Migration : vak361;
 
        PROCEDURE
              a361CreateProtTable (
                    VAR acv        : tak_all_command_glob;
                    VAR prot_tree  : tgg00_FileId;
                    createUnicode  : boolean;
                    isUnicodeMig   : boolean);
 
        PROCEDURE
              a361WriteProt (
                    VAR acv           : tak_all_command_glob;
                    VAR prot_tree     : tgg00_FileId;
                    VAR migrationId   : tsp00_C64;
                    migIdLength       : integer;
                    VAR schema        : tsp00_C64;
                    schemaLength      : integer;
                    VAR owner         : tsp00_C64;
                    ownerLength       : integer;
                    unicodeText       : boolean;
                    errCode           : integer;
                    errPos            : integer);
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : vta01;
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int4     : tsp00_Int4);
 
        PROCEDURE
              t01basis_error (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    b_err : tgg00_BasisError);
 
        PROCEDURE
              t01buf (
                    debug    : tgg00_Debug;
                    VAR buf  : tsp00_Buf;
                    startpos : integer;
                    endpos   : integer);
 
        PROCEDURE
              t01buf1 (
                    layer   : tgg00_Debug;
                    VAR buf : tgg00_SysInfoKey;
                    pos_anf : integer;
                    pos_end : integer);
 
        PROCEDURE
              t01catalog_entrytype (
                    debug      : tgg00_Debug;
                    etype      : tsp00_Char);
 
        PROCEDURE
              t01knl_identifier (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname (*ptocSynonym const char**);
                    identifier : tsp00_KnlIdentifier (*ptocSynonym const char**));
 
        PROCEDURE
              t01moveobj (
                    debug    : tgg00_Debug;
                    VAR buf  : tsp00_MoveObj;
                    startpos : tsp00_Int4;
                    endpos   : tsp00_Int4);
 
        PROCEDURE
              ta01TransNo (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname (*ptocSynonym const char**);
                    VAR TransNo  : tgg91_TransNo);
&       ENDIF
 
      ------------------------------ 
 
        FROM
              AK_usertab_tools : VAK19;
 
        PROCEDURE
              a19add_usertab  (VAR acv : tak_all_command_glob;
                    VAR user       : tgg00_Surrogate;
                    VAR surrogate  : tgg00_Surrogate;
                    surrogate_desc : tak_usertab_descriptor);
 
      ------------------------------ 
 
        FROM
              AK_Grant_Revoke : VAK22;
 
        FUNCTION
              a22exist_user  (
                    VAR acv       : tak_all_command_glob;
                    VAR user      : tsp00_KnlIdentifier;
                    errorpos      : integer;
                    VAR user_info : tak_user_info) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Index : VAK24;
 
        PROCEDURE
              a24assign_indexname (
                    VAR acv          : tak_all_command_glob;
                    ibuf             : tak_sysbufferaddress;
                    index            : integer;
                    VAR indexname    : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_Link : VAK25;
 
        PROCEDURE
              a25get_linkname (
                    VAR acv        : tak_all_command_glob;
                    linkbuf        : tak_sysbufferaddress;
                    index          : integer;
                    VAR link_name  : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_dialog_tools : VAK260;
 
        FUNCTION
              a260IsInternalDBProc (VAR MethodRec : tak_methodrecord) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Trigger: VAK262;
 
        PROCEDURE
              a262get_trigger_name (
                    VAR trigger_rec  : tak_triggerrecord;
                    VAR trigger_name : tsp00_KnlIdentifier;
                    VAR b_err        : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              AK_distributor : VAK35;
 
        PROCEDURE
              a35_asql_statement (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51build_userkey (VAR user_name : tsp00_KnlIdentifier;
                    VAR userkey : tgg00_SysInfoKey);
 
        PROCEDURE
              a51trimcn_password (VAR password : tsp00_CryptPw);
 
        PROCEDURE
              a51connect (
                    VAR acv          : tak_all_command_glob;
                    VAR connect_rec  : tak_connect_rec;
                    change_curr_user : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Lock_Commit_Rollback : VAK52;
 
        PROCEDURE
              a52_ex_commit_rollback (
                    VAR acv        : tak_all_command_glob;
                    m_type         : tgg00_MessType;
                    n_rel          : boolean;
                    normal_release : boolean);
 
        PROCEDURE
              a52new_subtrans (
                    VAR acv           : tak_all_command_glob;
                    VAR subtrans_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a52end_rollback_subtrans (
                    VAR acv           : tak_all_command_glob;
                    VAR subtrans_name : tsp00_KnlIdentifier;
                    m_type : tgg00_MessType);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01blankfilename : tsp00_VFilename;
              b01niltree_id    : tgg00_FileId;
 
        PROCEDURE
              b01tcreate_file (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              b01filestate (
                    VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_7 : VBD07;
 
        PROCEDURE
              b07cadd_record (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b07cnext_record (
                    VAR t            : tgg00_TransContext;
                    VAR curr         : tgg00_FileId;
                    VAR rk           : tgg00_Lkey;
                    VAR set_result   : tgg00_BdSetResultRecord;
                    VAR tree_pos     : tgg00_FilePos;
                    VAR b            : tsp00_Buf);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD02;
 
        PROCEDURE
              b02next_record (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_SysInfoKey;
                    inclusive   : boolean;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b02get_record (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_SysInfoKey;
                    VAR b       : tgg00_Rec);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              error_text_handling : VBD06;
 
        VAR
              b06check_rec : boolean;
&       endif
 
      ------------------------------ 
 
        FROM
              FileDir_Wrapper : vbd998;
 
        PROCEDURE
              bd998NewFileNo (
                    VAR file_no : tgg00_Surrogate);
 
        PROCEDURE
              bd998DestroyTempFile(
                    VAR trans         : tgg00_TransContext;
                    VAR tempSurrogate : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              KB_transaction : VKB53;
 
        PROCEDURE
              k53eot_excl_lock (
                    VAR t             : tgg00_TransContext;
                    VAR TreeId        : tgg00_FileId;
                    VAR k             : tgg00_Lkey;
                    forInsert         : boolean;
                    WantedMode        : tgg00_LockReqMode;
                    VAR GrantedMode   : tgg00_LockReqMode);
 
      ------------------------------ 
 
        FROM
              KB_file_table_handling : VKB64;
 
        PROCEDURE
              k64table_create (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k64rename_lob_file (
                    VAR t         : tgg00_TransContext;
                    VAR tableid   : tgg00_Surrogate;
                    VAR source_id : tgg00_FileId;
                    VAR target_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              KB_CreateDropFile_interface : VKB641;
 
        PROCEDURE
              kb641SuccFileVersion (
                    VAR TransContext   : tgg00_TransContext;
                    VAR FileId         : tgg00_FileId;
                    VAR NewFileVersion : tgg91_FileVersion;
                    OldLongCnt         : tsp00_Int4;
                    NewLongCnt         : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              KB_Logging : VKB560;
 
        PROCEDURE
              kb560StartSavepointAndWait (VAR Trans : tgg00_TransContext;
                    MessType2 : tgg00_MessType2);
 
        PROCEDURE
              kb560GetSys1CatalogTreeId(
                    VAR treeId : tgg00_FileId);
 
        PROCEDURE
              kb560GetSys2CatalogTreeId(
                    VAR treeId : tgg00_FileId);
 
        PROCEDURE
              kb560SetSys1CatalogTreeId(
                    VAR treeId : tgg00_FileId);
 
        PROCEDURE
              kb560SetSys2CatalogTreeId(
                    VAR treeId : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01glob          : tgg00_KernelGlobals;
              g01controluser   : tgg04_ControlUser;
              g01code          : tgg04_CodeGlobals;
              g01unicode       : boolean;
 
        PROCEDURE
              g01mblock_init (
                    VAR source_trans : tgg00_TransContext;
                    mess_type  : tgg00_MessType;
                    mess2_type : tgg00_MessType2;
                    VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              g01opmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8  (* ptocSynonym const char* *);
                    msg_text  : tsp00_C24 (* ptocSynonym const char* *);
                    msg_value : tsp00_Int4);
 
        PROCEDURE
              g01optextmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C40);
 
        PROCEDURE
              g01unioptextmsg (
                    msg_enc   : tsp00_Int4;
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C80);
 
        FUNCTION
              g01packet_size : tsp00_Int4;
 
        PROCEDURE
              g01stack_init (
                    VAR mblock : tgg00_MessBlock;
                    stack_ptr  : tgg00_StackListPtr;
                    stack_size : tsp00_Int4;
                    qual_ptr   : tgg00_QualBufPtr;
                    qual_size  : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Codetransformation_and_Coding : VGG02;
 
        PROCEDURE
              g02decrypt (VAR clearname : tsp00_Name;
                    VAR crypt : tsp00_CryptPw);
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures :  vgg04;
 
        PROCEDURE
              g04build_temp_tree_id (
                    VAR curr : tgg00_FileId;
                    VAR t    : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17int4to_line (
                    intval    : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_C40 (*ptocSynonym char**));
 
      ------------------------------ 
 
        FROM
              KernelAdministration_Interface : VGG999;
 
        PROCEDURE
              gg999SetKernelStateOnline;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove  (
                    mod_id         : tsp00_C6;
                    mod_intern_num : tsp00_Int4;
                    size1          : tsp00_Int4;
                    size2          : tsp00_Int4;
                    val1           : tsp00_MoveObjPtr;
                    p1             : tsp00_Int4;
                    val2           : tsp00_MoveObjPtr;
                    p2             : tsp00_Int4;
                    cnt            : tsp00_Int4;
                    VAR e          : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    size1    : tsp00_Int4;
                    size2    : tsp00_Int4;
                    val1     : tsp00_MoveObjPtr;
                    p1       : tsp00_Int4;
                    val2     : tsp00_MoveObjPtr;
                    p2       : tsp00_Int4;
                    cnt      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size     : tsp00_Int4;
                    m        : tsp00_MoveObjPtr;
                    pos      : tsp00_Int4;
                    len      : tsp00_Int4;
                    fillchar : char);
 
      ------------------------------ 
 
        FROM
              GG_allocator_interface : VGG941;
 
        FUNCTION
              gg941Allocate(VAR TransContext : tgg00_TransContext;
                    wantedBytes : integer) : tsp00_MoveObjPtr;
 
        PROCEDURE
              gg941Deallocate(VAR TransContext : tgg00_TransContext;
                    VAR p : tsp00_MoveObjPtr);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20int4_to_buf_swap (val    : tsp00_Int4;
                    sourceswap : tsp00_SwapKind;
                    VAR dest   : tgg00_Rec;
                    di         : tsp00_Int4;
                    destswap   : tsp00_SwapKind);
 
        FUNCTION
              s20buf_to_int4_swap (VAR source : tsp00_MoveObj;
                    si             : tsp00_Int4;
                    sourceswap     : tsp00_SwapKind;
                    destswap       : tsp00_SwapKind) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26init_cmd_packet (
                    packet_ptr               : tsp1_packet_ptr;
                    VAR first_segm_ptr       : tsp1_segment_ptr);
 
        PROCEDURE
              s26finish_part (
                    packet_ptr           : tsp1_packet_ptr;
                    VAR finish_part      : tsp1_part);
 
        PROCEDURE
              s26new_part_init (
                    packet_ptr             : tsp1_packet_ptr;
                    VAR segm               : tsp1_segment;
                    VAR new_part_ptr       : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              Version : VSP100;
 
        PROCEDURE
              sp100_GetSenderIDVersionP  (VAR SenderIDP  : tsp00_C5 );
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              t01buf1;
 
              tsp00_Buf tgg00_SysInfoKey
 
        PROCEDURE
              b02next_record;
 
              tgg00_Lkey tgg00_SysInfoKey
 
        PROCEDURE
              b02get_record;
 
              tgg00_Lkey tgg00_SysInfoKey;
 
        PROCEDURE
              b02del_record;
 
              tgg00_Lkey tgg00_SysInfoKey;
 
        PROCEDURE
              b07cnext_record;
 
              tsp00_MoveObj tsp00_Buf
 
        PROCEDURE
              s20int4_to_buf_swap;
 
              tsp00_MoveObj tgg00_Rec
 
        PROCEDURE
              s30cmp;
 
              tsp00_MoveObj tgg00_FileId
              tsp00_MoveObj tgg00_FileId
 
        PROCEDURE
              s30lnr;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              g17int4to_line;
 
              tsp00_Line tsp00_C40
 
        PROCEDURE
              g17hexto_line;
 
              tsp00_Line tsp00_C40
 
        PROCEDURE
              gg941Allocate;
 
              tsp00_Addr tsp00_MoveObjPtr
 
        PROCEDURE
              gg941Deallocate;
 
              tsp00_Addr tsp00_MoveObjPtr
 
        PROCEDURE
              a10new;
 
              tak_sysbufferaddress tak_param_info_ptr
 
.CM *-END-* synonym -------------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      (* time in seconds after which progress feedback should be *)
      (* written to knldiag:                                     *)
      c_feedback_interval        = 120;
      c_is_rollback              = true;
      c_call_from_rsend          = true;
      c_release                  = true;
      c_inclusive                = true;
      c_max_ascii_id_length      = 32;
      c_max_unicode_id_length    = 64;
      c_comment_stmt_header_size =  186 + 128;
      (* c_comment_stmt_header_size needs to be adjusted if there *)
      (* are changes in ak362InsertCommentStmtHeader              *)
      (* PTS 1128229 M.Ki. *)
      c_unicodeText = true;
      c_migrationId = 'CatalogToUnicode                                                ';
      c_migrationIdLength = 16;
 
TYPE
 
      tak362_MigrationGlob = RECORD
            oldCat1Id        : tgg00_FileId;
            newCat1Id        : tgg00_FileId;
            oldCat2Id        : tgg00_FileId;
            newCat2Id        : tgg00_FileId;
            trigger_tree     : tgg00_FileId;
            view_tree        : tgg00_FileId;
            comment_tree     : tgg00_FileId;
            priv_tree        : tgg00_FileId;
            prot_tree        : tgg00_FileId;
            cntTriggers      : tsp00_Int4;
            cntViews         : tsp00_Int4;
            cntComments      : tsp00_Int4;
            maxCreateStmtLen : tsp00_Int4;
      END;
 
 
      tak362_SurrogateInfoRecord = RECORD
            CASE boolean OF
                true :
                    (r : tgg00_Rec);
                false :
                    (recOffset    : ARRAY[1..cgg_rec_key_offset] OF char;
                    oldSurrogate : tgg00_Surrogate;
                    newSurrogate : tgg00_Surrogate;
                    );
                END;
            (*ENDCASE*) 
 
 
      tak362_Rec = RECORD
            CASE integer OF
                1 :
                    (align : tsp00_Addr);
                2 :
                    (syskey : tgg00_SysInfoKey);
                3 :
                    (rec : tgg00_Rec);
                END;
            (*ENDCASE*) 
 
 
      tak362_commentInfo = RECORD
            CASE integer OF
                1 :
                    (rec : tgg00_Rec);
                2 :
                    (ci_header   : tgg00_Lkey;
                    ci_ownerId   : tgg00_Surrogate;
                    ci_schemaId  : tgg00_Surrogate;
                    ci_tableName : tsp00_KnlIdentifier;
                    ci_commentOn : tsp00_KnlIdentifier);
                3 :
                    (ci_comment_rec : tak_comment_record);
                END;
            (*ENDCASE*) 
 
 
      tak362_ProcPrivInfoRec = RECORD
            CASE integer OF
                1 :
                    (rec : tgg00_Rec);
                2 :
                    (pi_syskey : tgg00_SysInfoKey);
                3 :
                    (pi_procPriv    : tak_proc_seq_privilege;
                    pi_schemaId     : tgg00_Surrogate;
                    pi_methodName   : tsp00_KnlIdentifier);
                END;
            (*ENDCASE*) 
 
 
 
(*------------------------------*) 
 
PROCEDURE
      ak362MigrateAuthorizations (
            VAR acv : tak_all_command_glob);
 
BEGIN
a103ToUnicode (acv);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a362migrate (
            VAR acv             : tak_all_command_glob;
            VAR in_warm_session : boolean);
 
CONST
      c_unicode_already  = 'CATALOG IS UNICODE ALREADY              ';
      c_start_as_unicode = '_UNICODE has to be YES for migration    ';
 
VAR
      bothCatsDone  : boolean;
      idComplete    : boolean;
      unhandledType : boolean;
      mtype         : tgg00_MessType;
      ix            : integer;
      packetSize    : tsp00_Int4;
      msgTime       : tsp00_Int4;
      curTime       : tsp00_Int4;
      recCounter    : tsp00_Int4;
      b_err         : tgg00_BasisError;
      buf           : tak_sysbufferaddress;
      packetPtr     : tsp1_packet_ptr;
      moveObjPtr    : tsp00_MoveObjPtr;
      connect_rec   : tak_connect_rec;
      transNo       : tgg91_TransNo;
      catalog_tree  : tgg00_FileId;
      msg           : tsp00_C40;
      sysk          : tgg00_SysInfoKey;
      syskey        : tgg00_SysInfoKey;
      MGlob         : tak362_MigrationGlob;
      comp_res      : tsp00_LcompResult;
      rec_buf       : tak362_Rec;
 
BEGIN
a362OnlineTaskId := acv.a_transinf.tri_trans.trTaskId_gg00; (* PTS 1120287 M.Ki *)
b_err := e_ok;
(* check whether our environment is correct: *)
IF  (a01char_size <> 2)
THEN
    BEGIN (* we were not started as a unicode database *)
    msg := c_start_as_unicode;
    g01optextmsg (sp3p_console, sp3m_error,
          csp3_a362_migrate_ascii_to_uni,
          csp3_n_migration, msg);
    b_err := e_migration_error;
    END;
(*ENDIF*) 
IF  ak362isUnicodeDatabase (acv)
THEN
    (* sysuser_name is already unicode -> catalog is already unicode *)
    BEGIN
    msg := c_unicode_already;
    g01optextmsg (sp3p_console, sp3m_error,
          csp3_a362_migrate_ascii_to_uni,
          csp3_n_migration, msg);
    b_err := e_migration_error;
    END;
(*ENDIF*) 
IF  (NOT in_warm_session) AND (b_err = e_ok)
THEN
    BEGIN
    WITH connect_rec DO
        BEGIN
        cn_username       := a01controluser;
        cn_password       := g01controluser.gg04cu_password;
        a51trimcn_password (cn_password); (* PTS 1130914 M.Ki. *)
        cn_timeout        := csp_maxint2;
        cn_global_state   := [ hsConsistentLock_egg00 ];
        cn_internal       := true;
        cn_tmp_cache_size := 0
        END;
    (*ENDWITH*) 
    (*  remove_locks /  k51del_transid_from_locklist (acv.a_transinf.tri_trans.trTaskId_gg00,
          acv.a_transinf.tri_trans.trIndex_gg00); *)
    a51connect( acv, connect_rec, false);
    in_warm_session := ( acv.a_returncode = 0 );
    END;
(* initialize tree id of migration glob so cleanup procedure will *)
(* work fine in error case as well                                *)
(*ENDIF*) 
MGlob.view_tree    := b01niltree_id;
MGlob.trigger_tree := b01niltree_id;
MGlob.comment_tree := b01niltree_id;
IF  (b_err = e_ok) AND (acv.a_returncode = 0)
THEN
    BEGIN
    a10_cache_delete (acv, NOT c_is_rollback);
    acv.a_p_arr1.pbasep := NIL;
    msg := 'MIGRATING ASCII CATALOG TO UNICODE      ';
    g01optextmsg (sp3p_console, sp3m_info,
          csp3_a362_migrate_ascii_to_uni,
          csp3_n_migration, msg);
    vtime_in_seconds (msgTime);
    ak362InitMigrationGlob(acv, MGlob);
    b_err := acv.a_transinf.tri_trans.trError_gg00;
    END;
(*ENDIF*) 
IF  (b_err = e_ok) AND (acv.a_returncode = 0)
THEN
    BEGIN
    (* g01glob.sysuser was interpreted as unicode although it's still ascii *)
    (* make it proper unicode                                               *)
    idComplete := false;
    FOR ix := 1 TO sizeof (tsp00_KnlIdentifier) DO
        BEGIN
        idComplete := idComplete OR (g01glob.sysuser_name[ ix ] = '\00');
        IF  idComplete
        THEN
            g01glob.sysuser_name[ ix ] := bsp_c1;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    ak362ConvertIdentifier(g01glob.sysuser_name, b_err);
    END;
(*ENDIF*) 
buf  := @rec_buf;
sysk := a01defaultkey;
catalog_tree    := MGlob.oldCat1Id;
sysk.sauthid    := cgg_zero_id;
(* build cgg_local_site *)
sysk.skeylen    := 0;
;
recCounter       := 0;
unhandledType    := false;
bothCatsDone     := false;
transNo          := acv.a_transinf.tri_trans.trTransId_gg00;
(* the following is needed because only the local catalog *)
(* cache can be modified                                  *)
acv.a_localCacheUsageOnly := true;
WHILE (b_err = e_ok) AND (NOT bothCatsDone) AND (acv.a_returncode = 0) DO
    BEGIN
&   ifdef trace
    b06check_rec := false;
&   endif
    b02next_record( acv.a_transinf.tri_trans, catalog_tree,
          sysk, NOT c_inclusive, rec_buf.rec );
&   ifdef trace
    b06check_rec := true;
&   endif
    b_err := acv.a_transinf.tri_trans.trError_gg00;
    IF  (b_err = e_ok) OR (b_err = e_key_not_found)
    THEN
        BEGIN
        b_err            := e_ok;
        acv.a_returncode := 0;
        sysk             := buf^.syskey;
        syskey           := sysk;
        CASE buf^.syskey.sentrytyp[2] OF
            cak_ccomment :
                (* linkage is not the last element of comment syskey *)
                (* therefore we cannot simply set it to \ff once we  *)
                (* are done with a comment but have to check each    *)
                (* comment record to see whether it is really the    *)
                (* start of a comment:                               *)
                IF  buf^.syskey.slinkage = cak_init_linkage
                THEN
                    ak362CommentRecord (acv, MGlob,
                          syskey, catalog_tree, rec_buf.rec);
                (*ENDIF*) 
            cak_cconstraint :
                ak362ConstraintRecord (acv, MGlob,
                      syskey, rec_buf.rec);
            cak_cconstraintname :
                ak362ConstraintNameRecord (acv, MGlob,
                      syskey, rec_buf.rec);
            cak_ccontainer:
                ak362ClassRecord (acv, MGlob, syskey);
            cak_cdomain:
                ak362DomainRecord (acv, MGlob,
                      syskey, rec_buf.rec);
            cak_cdomainref:
                ak362DomainRefRecord (acv, MGlob,
                      syskey, rec_buf.rec);
            cak_cdomainusage :
                ak362DomainUsageRecord (acv, MGlob, syskey);
            cak_cmindex:
                BEGIN
                ak362MIndexRecord (acv, MGlob, syskey);
                syskey.slinkage[1] := chr(255);
                syskey.slinkage[2] := chr(255)
                END;
            cak_cmapset :
                ak362MapsetRecord (acv, MGlob, syskey, rec_buf.rec);
            cak_cmethod :
                BEGIN
                ak362MethodRecord (acv, MGlob, syskey, rec_buf.rec);
                sysk.slinkage[1] := chr(255);
                sysk.slinkage[2] := chr(255)
                END;
            cak_cschema :
                ak362SchemaRecord (acv, MGlob, syskey);
            cak_cschemaref :
                ak362SchemarefRecord (acv, MGlob, syskey, rec_buf.rec);
            cak_ctable :
                BEGIN
                ak362TableRecord  (acv, MGlob, syskey);
                (* skip other records belonging to this table *)
                sysk.slinkage[1] := chr(255);
                sysk.slinkage[2] := chr(255)
                END;
            cak_ctableref:
                ak362TableRefRecord  (acv, MGlob, syskey, rec_buf.rec);
            cak_clinkdef :
                ak362LinkDefRecord (acv, MGlob, rec_buf.rec);
            cak_csequence :
                ak362SequenceRecord (acv, MGlob, syskey);
            cak_ctrigger :
                ak362TriggerRecord (acv, MGlob, syskey, b_err);
            cak_cuser :
                ak362UserRecord (acv, MGlob, syskey, b_err);
            cak_cuserref :
                ak362UserrefRecord (acv, MGlob, rec_buf.rec);
            cak_cforeignkey,
            cak_cprimarykey:
                BEGIN
                ak362LinkRecord (acv, MGlob, syskey);
                sysk.slinkage[1] := chr(255);
                sysk.slinkage[2] := chr(255)
                END;
            cak_calterdate,
            cak_ccorrinfo,
            cak_cdefault,
            cak_cclassmap,
            cak_cmethodfileinfo,
            cak_cpriv,
            cak_cprivuser,
            cak_croletab  (* is tak_usertablerecord *),
            cak_csequencepriv,
            cak_cstatistics,
            cak_csysdba,
            cak_ctype_uid,
            cak_cusage,
            cak_cuserid,
            cak_cviewqual_basis,
            cak_cviewqual_stack,
            cak_cviewqual_join,
            cak_cviewqual_expcol,
            cak_cviewqual_join_check,
            cak_cviewqual_derivedcol:
                BEGIN
&               ifdef TRACE
                t01catalog_entrytype (ak_sem, buf^.syskey.sentrytyp[2]);
                t01buf (ak_sem, rec_buf.rec.recBuf_gg00, 1,
                      rec_buf.rec.recLen_gg00);
&               endif
                ak362add_newkey_no_cache_sysinfo (acv, MGlob, syskey,
                      rec_buf.rec, rec_buf.rec.recLen_gg00);
                END;
            cak_cusertab:
                ak362UserTabRecord (acv, MGlob, syskey, b_err);
            cak_cprocpriv:
                ak362StoreProcPriv (acv, MGlob, syskey, b_err);
            cak_cmethodinfo,
            cak_cmethoddebuginfo, (* PTS 1122726 M.Ki *)
            cak_cmethodref (* method stuff handled during cak_cmethod *),
            cak_cpermmessblock,
            cak_cviewdesc,
            cak_cviewtext:
                BEGIN
&               ifdef TRACE
                t01int4 (ak_sem, 'ignoring    ',
                      ord(buf^.syskey.sentrytyp[2]));
                t01catalog_entrytype (ak_sem, buf^.syskey.sentrytyp[2]);
&               endif
                END;
            OTHERWISE
                BEGIN
&               ifdef TRACE
                t01catalog_entrytype (ak_sem, buf^.syskey.sentrytyp[2]);
                t01buf (ak_sem, rec_buf.rec.recBuf_gg00, 1,
                      rec_buf.rec.recLen_gg00);
&               endif
                unhandledType := true;
                g01opmsg (sp3p_console, sp3m_error,
                      csp3_a362_migrate_ascii_to_uni,
                      csp3_n_migration, 'UNHANDLED ENTRY TYPE    ',
                      ord (buf^.syskey.sentrytyp[2]));
                END;
            END;
        (*ENDCASE*) 
        END
    ELSE
        BEGIN
        s30cmp(catalog_tree, 1, sizeof (tgg00_FileId),
              MGlob.oldCat1Id, 1,  sizeof (tgg00_FileId), comp_res);
        IF  (comp_res = l_equal) AND
            (b_err = e_no_next_record)
        THEN
            BEGIN
            b_err           := e_ok;
            sysk            := a01defaultkey;
            catalog_tree    := MGlob.oldCat2Id;
            sysk.sauthid    := cgg_zero_id;
            sysk.skeylen    := 0;
            END
        ELSE
            bothCatsDone := true;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
&   ifdef TRACE
    a10_all_release (acv); (* check catalog consistency *)
&   endif
    recCounter := succ (recCounter);
    IF  (b_err <> e_ok) AND (b_err <> e_no_next_record)
    THEN
        BEGIN
        g01opmsg (sp3p_console, sp3m_error,
              csp3_a362_migrate_ascii_to_uni,
              csp3_n_migration, 'ERROR HANDLING TYPE     ',
              ord (buf^.syskey.sentrytyp[2]));
        g01optextmsg (sp3p_console, sp3m_error, csp3_a362_migrate_ascii_to_uni,
              csp3_n_migration, 'RECORD SAVED IN MIGERRORREC.BIN         ');
        ak362dumpRecord (rec_buf.rec);
        END
    ELSE
        BEGIN
        vtime_in_seconds (curTime);
        IF  (curTime - msgTime) >= c_feedback_interval
        THEN
            BEGIN
            msgTime := curTime;
            g01opmsg (sp3p_console, sp3m_info,
                  csp3_a362_migrate_ascii_to_uni,
                  csp3_n_migration, '  RECORDS MIGRATED      ',
                  recCounter);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
&ifdef TRACE
t01basis_error (ak_sem, 'error cond  ', b_err);
&endif
a10_cache_delete (acv, NOT c_is_rollback);
IF  unhandledType
THEN
    b_err := e_unknown_name;
(*ENDIF*) 
IF  (b_err <> e_no_next_record) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    ak362MigrateAuthorizations(acv);
(*ENDIF*) 
packetSize      := g01packet_size;
packetPtr       := acv.a_in_packet;
acv.a_in_packet :=  NIL;
IF  acv.a_returncode = 0
THEN
    BEGIN
    a10EnableTableAccess;
    moveObjPtr      := gg941Allocate(acv.a_transinf.tri_trans, packetSize);
    acv.a_in_packet := @moveObjPtr^[1];
    IF  acv.a_in_packet = NIL
    THEN
        a07_b_put_error (acv, e_no_more_memory, 1);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN (* PTS 1127791 M.Ki. *)
    ak362CreateProtTable(acv, MGlob);
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    ak362ReCreateViews (acv, MGlob, packetSize);
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    ak362ReCreateTriggers (acv, MGlob, packetSize);
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    ak362ReCreateComments (acv, MGlob, packetSize);
&ifdef TRACE
(*ENDIF*) 
t01basis_error (ak_sem, 'error cond  ', acv.a_returncode);
&endif
IF  acv.a_returncode = 0
THEN
    ak362UpdateProcPriv (acv, MGlob);
&ifdef TRACE
(*ENDIF*) 
t01basis_error (ak_sem, 'error cond  ', acv.a_returncode);
&endif
IF  acv.a_in_packet <> NIL
THEN
    gg941Deallocate(acv.a_transinf.tri_trans, moveObjPtr);
(*ENDIF*) 
acv.a_in_packet    := packetPtr;
IF  acv.a_in_packet <> NIL
THEN
    acv.a_cmd_segm  := @acv.a_in_packet^.sp1_segm
ELSE
    acv.a_cmd_segm := NIL;
(*ENDIF*) 
acv.a_internal_sql := no_internal_sql;
&ifdef TRACE
IF  transNo <> acv.a_transinf.tri_trans.trTransId_gg00
THEN
    BEGIN
    t01int4 (ak_sem, 'a_internal_s', ord (acv.a_internal_sql));
    ta01TransNo (ak_sem, 'transNo     ', transNo);
    ta01TransNo (ak_sem, 'now         ',
          acv.a_transinf.tri_trans.trTransId_gg00);
    g01optextmsg (sp3p_console, sp3m_error, csp3_a362_migrate_ascii_to_uni,
          csp3_n_migration, 'TRANSACTION ID CHANGED DURING MIGRATION ');
    a07_b_put_error (acv, e_migration_error, 1);
    END;
&endif
(*ENDIF*) 
IF  in_warm_session
THEN
    BEGIN
    acv.a_curr_user_name := a01controluser;
    acv.a_curr_user_id   := cak_util_user_id;
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        mtype := m_commit;
        ak362dropOldCatalog (acv, MGlob);
        END
    ELSE
        BEGIN
        msg := 'MIGRATION FAILED WITH ERROR             ';
        g17int4to_line (acv.a_returncode,
              false, 5, 29, msg);
        g01optextmsg (sp3p_console, sp3m_error, csp3_a362_migrate_ascii_to_uni,
              csp3_n_migration, msg);
        mtype := m_rollback;
        END;
    (*ENDIF*) 
    a52_ex_commit_rollback (acv, mtype,
          NOT c_release, NOT c_release);
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        kb560StartSavepointAndWait (acv.a_transinf.tri_trans, mm_config );
        ak362remove_paramfiles (acv.a_transinf.tri_trans);
        msg := 'MIGRATION FINISHED SUCCESSFULLY         ';
        g01optextmsg (sp3p_console, sp3m_info, csp3_a362_migrate_ascii_to_uni,
              csp3_n_migration, msg);
        END;
    (*ENDIF*) 
    END
ELSE (* PTS 1130914 M.Ki. *)
    BEGIN
    msg := 'INIT OF UNICODE MIGRATION FAILED        ';
    g01optextmsg (sp3p_console, sp3m_error, csp3_a362_migrate_ascii_to_uni,
          csp3_n_migration, msg);
    END;
(*ENDIF*) 
acv.a_localCacheUsageOnly := false;
IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
THEN
    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
(*ENDIF*) 
ak362CleanupMigrationGlob(acv, MGlob);
a362OnlineTaskId := UNDEF_SP00;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362InitMigrationGlob (
            VAR acv         : tak_all_command_glob;
            VAR MGlob       : tak362_MigrationGlob);
 
VAR
      sys_cat : tgg00_FileId;
 
BEGIN
MGlob.cntTriggers                   := 0;
MGlob.cntViews                      := 0;
MGlob.cntComments                   := 0;
MGlob.maxCreateStmtLen              := 0;
g04build_temp_tree_id (MGlob.view_tree, acv.a_transinf.tri_trans);
MGlob.view_tree.fileTfnTemp_gg00    := ttfnTrigger_egg00;
b01tcreate_file (acv.a_transinf.tri_trans, MGlob.view_tree);
IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
THEN
    BEGIN
    g04build_temp_tree_id (MGlob.trigger_tree, acv.a_transinf.tri_trans);
    MGlob.trigger_tree.fileTfnTemp_gg00 := ttfnTrigger_egg00;
    b01tcreate_file (acv.a_transinf.tri_trans, MGlob.trigger_tree);
    END;
(*ENDIF*) 
IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
THEN
    BEGIN
    g04build_temp_tree_id (MGlob.comment_tree, acv.a_transinf.tri_trans);
    MGlob.comment_tree.fileTfnTemp_gg00 := ttfnTrigger_egg00;
    b01tcreate_file (acv.a_transinf.tri_trans, MGlob.comment_tree);
    END;
(*ENDIF*) 
IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
THEN
    BEGIN
    g04build_temp_tree_id (MGlob.priv_tree, acv.a_transinf.tri_trans);
    MGlob.priv_tree.fileTfnTemp_gg00 := ttfnTrigger_egg00;
    b01tcreate_file (acv.a_transinf.tri_trans, MGlob.priv_tree);
    END;
(* *)
(* rename catalog files and create new catalog files to be filled: *)
(*ENDIF*) 
IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
THEN
    BEGIN
    kb560GetSys1CatalogTreeId (sys_cat);
    ak362CreateNewCatalogFile( acv, sys_cat, MGlob.oldCat1Id );
    kb560SetSys1CatalogTreeId (sys_cat);
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        kb560GetSys2CatalogTreeId (sys_cat);
        ak362CreateNewCatalogFile( acv, sys_cat, MGlob.oldCat2Id );
        kb560SetSys2CatalogTreeId (sys_cat);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
THEN
    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
(*ENDIF*) 
kb560GetSys1CatalogTreeId (MGlob.newCat1Id);
kb560GetSys2CatalogTreeId (MGlob.newCat2Id);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362CleanupMigrationGlob (
            VAR acv         : tak_all_command_glob;
            VAR MGlob       : tak362_MigrationGlob);
 
VAR
      aux_err : tgg00_BasisError;
 
BEGIN
aux_err := acv.a_transinf.tri_trans.trError_gg00;
(* *)
IF  MGlob.view_tree.fileTabId_gg00 <> cgg_zero_id
THEN
    bd998DestroyTempFile (acv.a_transinf.tri_trans,
          MGlob.view_tree.fileTabId_gg00 );
(*ENDIF*) 
MGlob.view_tree := b01niltree_id;
(* *)
IF  MGlob.trigger_tree.fileTabId_gg00 <> cgg_zero_id
THEN
    bd998DestroyTempFile (acv.a_transinf.tri_trans,
          MGlob.trigger_tree.fileTabId_gg00 );
(*ENDIF*) 
MGlob.trigger_tree := b01niltree_id;
(* *)
IF  MGlob.comment_tree.fileTabId_gg00 <> cgg_zero_id
THEN
    bd998DestroyTempFile (acv.a_transinf.tri_trans,
          MGlob.comment_tree.fileTabId_gg00 );
(*ENDIF*) 
MGlob.comment_tree := b01niltree_id;
IF  MGlob.priv_tree.fileTabId_gg00 <> cgg_zero_id
THEN
    bd998DestroyTempFile (acv.a_transinf.tri_trans,
          MGlob.priv_tree.fileTabId_gg00 );
(*ENDIF*) 
MGlob.priv_tree := b01niltree_id;
(* *)
acv.a_transinf.tri_trans.trError_gg00 := aux_err;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362dropOldCatalog (
            VAR acv        : tak_all_command_glob;
            VAR MGlob      : tak362_MigrationGlob);
 
BEGIN
ak362DropFile (acv, MGlob.oldCat1Id);
ak362DropFile (acv, MGlob.oldCat2Id);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362DropFile(VAR acv : tak_all_command_glob;
            VAR FileId : tgg00_FileId);
 
VAR
      e : tgg00_BasisError;
 
BEGIN
a06a_mblock_init (acv, m_drop, mm_clear, FileId );
a06lsend_mess_buf(acv, acv.a_mblock, NOT c_call_from_rsend, e);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362get_old_sysinfo (
            VAR acv      : tak_all_command_glob;
            VAR MGlob    : tak362_MigrationGlob;
            VAR syskey   : tgg00_SysInfoKey;
            dstate       : tak_directory_state;
            VAR syspoint : tak_sysbufferaddress;
            VAR b_err    : tgg00_BasisError);
 
BEGIN
(* get sysinfo from old catalog *)
ak362set_ascii (MGlob);
&ifdef trace
b06check_rec := false;
&endif
a10get_sysinfo (acv, syskey, dstate, syspoint, b_err);
&ifdef trace
b06check_rec := true;
&endif
ak362set_unicode (MGlob);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362_fix_len_get_old_sysinfo (
            VAR acv      : tak_all_command_glob;
            VAR MGlob    : tak362_MigrationGlob;
            VAR syskey   : tgg00_SysInfoKey;
            dstate       : tak_directory_state;
            required_len : integer;
            plus         : integer;
            VAR syspoint : tak_sysbufferaddress;
            VAR b_err    : tgg00_BasisError);
 
BEGIN
(* get sysinfo from old catalog *)
ak362set_ascii (MGlob);
&ifdef trace
b06check_rec := false;
&endif
a10_fix_len_get_sysinfo (acv, syskey, dstate, required_len,
      plus, syspoint, b_err);
&ifdef trace
b06check_rec := true;
&endif
ak362set_unicode (MGlob);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362expand_old_rec (VAR rec_buf : tgg00_Rec;
            VAR MGlob    : tak362_MigrationGlob;
            VAR e : tgg00_BasisError);
 
BEGIN
ak362set_ascii (MGlob);
a10expand_rec (rec_buf, e);
ak362set_unicode (MGlob);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362add_new_sysinfo (
            VAR acv      : tak_all_command_glob;
            VAR MGlob    : tak362_MigrationGlob;
            VAR syspoint : tak_sysbufferaddress;
            VAR b_err    : tgg00_BasisError);
 
BEGIN
(* put sysinfo into catalog *)
ak362set_unicode (MGlob);
a10add_sysinfo (acv, syspoint, b_err);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362add_newkey_sysinfo (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR sysk   : tgg00_SysInfoKey;
            VAR recBuf : tgg00_Rec;
            sysinfoLen : tsp00_Int2;
            VAR pBuf   : tak_sysbufferaddress;
            VAR b_err  : tgg00_BasisError);
 
BEGIN
(* put sysinfo into catalog *)
ak362set_unicode (MGlob);
a10_nil_get_sysinfo (acv, sysk, d_release,
      sysinfoLen, pBuf, b_err);
IF  (b_err = e_ok)
THEN
    BEGIN
    SAPDB_PascalMove ('VAK362',   1,    
          sysinfoLen, sysinfoLen,
          @recBuf.recBody_gg00, sysk.skeylen + 1,
          @(pBuf^), cgg_rec_key_offset + sysk.skeylen + 1,
          sysinfoLen - cgg_rec_key_offset - sysk.skeylen,
          b_err);
    ak362add_new_sysinfo (acv, MGlob, pBuf, b_err);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362add_newkey_no_cache_sysinfo (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR sysk   : tgg00_SysInfoKey;
            VAR recBuf : tgg00_Rec;
            sysinfoLen : tsp00_Int2);
 
VAR
      pBuf   : tak_sysbufferaddress;
      syskey : tgg00_SysInfoKey;
 
BEGIN
(* PTS 1122945 M.Ki. *)
SAPDB_PascalMove('VAK362',   2,    
      sizeof(syskey), sizeof(syskey),
      @sysk, 1,
      @syskey, 1,
      cgg_rec_key_offset + sysk.skeylen,
      acv.a_transinf.tri_trans.trError_gg00);
syskey.sreclen := cgg_rec_key_offset + sysk.skeylen;
ak362add_newkey_sysinfo (acv, MGlob, syskey, recBuf, sysinfoLen, pBuf,
      acv.a_transinf.tri_trans.trError_gg00);
IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
THEN
    BEGIN
    a10key_del (acv, pBuf);
    END;
(*ENDIF*) 
IF  (acv.a_transinf.tri_trans.trError_gg00 <> e_ok) AND
    (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362CreateNewCatalogFile (
            VAR acv           : tak_all_command_glob;
            VAR FileId        : tgg00_FileId;
            VAR RenamedFileId : tgg00_FileId);
 
CONST
      c_dummy_new_long_cnt = -1;
 
VAR
      dummy_granted : tgg00_LockReqMode;
      dummy_k       : tgg00_Lkey;
      mblock        : tgg00_MessBlock;
 
      qual   : RECORD
            q_hd : ARRAY[1..MB_PART1_HEAD_MXGG00] OF char;
            q_st : ARRAY[1..cgg04_return_stack_entries] OF tgg00_StackEntry;
      END;
 
 
BEGIN
acv.a_transinf.tri_trans.trError_gg00 := e_ok;
k53eot_excl_lock (acv.a_transinf.tri_trans, FileId, dummy_k, true, lckSysExcl_egg00, dummy_granted);
RenamedFileId := FileId;
bd998NewFileNo (RenamedFileId.fileTabId_gg00);
(* check if renamed file exists; if we just rename and rename fails due to *)
(* an already existing file, the rollback will crash when it tries to undo *)
(* the rename                                                              *)
b01filestate (acv.a_transinf.tri_trans, RenamedFileId);
IF  acv.a_transinf.tri_trans.trError_gg00 = e_file_not_found
THEN
    BEGIN
    acv.a_transinf.tri_trans.trError_gg00 := e_ok;
    k64rename_lob_file (acv.a_transinf.tri_trans, FileId.fileTabId_gg00, FileId, RenamedFileId);
    END
ELSE
    acv.a_transinf.tri_trans.trError_gg00 := e_duplicate_filename;
(*ENDIF*) 
IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
THEN
    BEGIN
    g01mblock_init   (acv.a_transinf.tri_trans,
          m_create_table, mm_nil, mblock);
    g01stack_init    (mblock, NIL, 0, @qual, sizeof (qual));
    mblock.mb_qual^.mtree := FileId;
    k64table_create  (mblock);
    mblock.mb_qual^.mtree.fileVersion_gg00 := FileId.fileVersion_gg00;
    IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
    THEN
        (* file version is not set properly in k64table_create, make sure *)
        (* it is correct                                                  *)
        kb641SuccFileVersion (acv.a_transinf.tri_trans, mblock.mb_qual^.mtree,
              mblock.mb_qual^.mtree.fileVersion_gg00,
              c_dummy_new_long_cnt, c_dummy_new_long_cnt);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
THEN
    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
ELSE
    FileId := mblock.mb_qual^.mtree
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362ConvertIdentifier (
            VAR idName : tsp00_KnlIdentifier;
            VAR b_err  : tgg00_BasisError);
 
VAR
      unicodeIdLength : integer;
      errPos          : tsp00_Int4;
      unicodeError    : tsp8_uni_error;
      unicodeId       : tsp00_KnlIdentifier;
 
BEGIN
unicodeIdLength := c_max_unicode_id_length;
s80uni_trans (@idName, c_max_ascii_id_length, csp_ascii,
      @unicodeId, unicodeIdLength, csp_unicode, [ ],
      unicodeError, errPos);
IF  unicodeError <> uni_ok
THEN
    BEGIN
&   ifdef TRACE
    t01knl_identifier (ak_sem, 'failed conv.', idName);
&   endif
    b_err := e_not_trans_to_uni;
    END
ELSE
    SAPDB_PascalForcedMove(
          sizeof (tsp00_KnlIdentifier), sizeof (tsp00_KnlIdentifier),
          @unicodeId, 1,
          @idName, 1,
          sizeof(tsp00_KnlIdentifier));
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362ClassRecord (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR syskey : tgg00_SysInfoKey);
 
VAR
      b_err  : tgg00_BasisError;
      pBuf   : tak_sysbufferaddress;
 
BEGIN
b_err := e_ok;
ak362get_old_sysinfo (acv, MGlob, syskey, d_release, pBuf, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    ak362ConvertIdentifier (pBuf^.sclass.fclassname, b_err);
    ak362add_new_sysinfo (acv, MGlob, pBuf, b_err);
    a10key_del (acv, pBuf);
    END;
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362CommentRecord (
            VAR acv         : tak_all_command_glob;
            VAR MGlob       : tak362_MigrationGlob;
            VAR recsyskey   : tgg00_SysInfoKey;
            VAR catalogTree : tgg00_FileId;
            VAR recBuf      : tgg00_Rec);
 
VAR
      storeCreateStmt : boolean;
      skipRecord      : boolean;
      b_err           : tgg00_BasisError;
      columnNameLen   : tsp00_Int2;
      columnIndex     : tsp00_Int2;
      extcolno        : tsp00_Int2;
      ix              : integer;
      commentRecPtr   : ^tak_comment_record;
      pBuf            : tak_sysbufferaddress;
      ownerId         : tgg00_Surrogate;
      schemaId        : tgg00_Surrogate;
      sysk            : tgg00_SysInfoKey;
      syskey          : tgg00_SysInfoKey;
      tableName       : tsp00_KnlIdentifier;
      commentOn       : tsp00_KnlIdentifier;
 
BEGIN
(* comment records tend to be left behind on the disk in the course of *)
(* events, so recreate a comment only if                               *)
(* 1. we can find the entity (table, column, trigger, dbproc) it is    *)
(*    refering to                                                      *)
(* 2. the entity actually thinks it has a comment attached             *)
&ifdef TRACE
t01buf (ak_sem, recBuf.recBuf_gg00, 1,
      recBuf.recLen_gg00);
&endif
syskey          := recsyskey;
storeCreateStmt := false;
skipRecord      := false;
b_err           := e_ok;
(* check if comment belongs to view, trigger or db procedure         *)
(* if yes, store text to recreate it later, otherwise convert record *)
commentRecPtr := @recBuf;
IF  commentRecPtr^.com_type = cm_dbproc
THEN
    BEGIN
    storeCreateStmt := true;
    sysk            := syskey;
    sysk.skeylen    := mxak_standard_sysk;
    sysk.sentrytyp  := cak_emethodinfo;
    ak362get_old_sysinfo (acv, MGlob, sysk, d_release, pBuf, b_err);
    IF  (b_err = e_ok)
    THEN
        BEGIN
        IF  pBuf^.smethodinfo.mei_comment
        THEN
            BEGIN
            tableName := a01_il_b_identifier;
            commentOn := pBuf^.smethodinfo.mei_name;
            ownerId   := pBuf^.smethodinfo.mei_owner;
            schemaId  := pBuf^.smethodinfo.mei_schema;
            END
        ELSE
            skipRecord := true;
        (*ENDIF*) 
        END
    ELSE
        IF  b_err = e_sysinfo_not_found
        THEN
            (* during 'Drop DBProc' Comment records used not to be deleted *)
            (* so just skip this record                                    *)
            BEGIN
            skipRecord       := true;
            b_err            := e_ok;
            acv.a_returncode := 0;
&           ifdef TRACE
            g01opmsg (sp3p_console, sp3m_info,
                  csp3_a362_migrate_ascii_to_uni,
                  csp3_n_migration, 'ignoring dbproc comment ', 0);
&           endif
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  commentRecPtr^.com_type = cm_trigger
THEN
    BEGIN
    storeCreateStmt := true;
    sysk            := syskey;
    sysk.skeylen    := mxak_standard_sysk;
    sysk.sentrytyp  := cak_etrigger;
    (* the trigger type this comment belongs to is stored as column no *)
    CASE ord (syskey.stablen[2]) * 256 + ord(syskey.stablen[3]) OF
        1:
            sysk.slinkage := cak_ins_trigger_linkage;
        2:
            sysk.slinkage := cak_upd_trigger_linkage;
        3:
            sysk.slinkage := cak_del_trigger_linkage;
        OTHERWISE
&           ifdef TRACE
            t01int4 (ak_sem, 'trigger type', ord (syskey.stablen[2]) * 256 + ord(syskey.stablen[3]));
&       endif
        (* *)
        END;
    (*ENDCASE*) 
    ak362get_old_sysinfo (acv, MGlob, sysk, d_release, pBuf, b_err);
    IF  (b_err = e_ok) AND (pBuf^.strigger.tr_comment)
    THEN
        BEGIN
        tableName := a01_il_b_identifier;
        ;
        ak362set_ascii (MGlob);
        a262get_trigger_name (pBuf^.strigger, commentOn, b_err);
        ak362set_unicode (MGlob);
        ;
        (* get owner id *)
        sysk           := syskey;
        sysk.skeylen   := mxak_standard_sysk;
        sysk.sentrytyp := cak_etable;
        sysk.slinkage  := cak_init_linkage;
        ak362get_old_sysinfo (acv, MGlob, sysk, d_release, pBuf,
              b_err);
        IF  b_err = e_ok
        THEN
            BEGIN
            ownerId   := pBuf^.sbase.bauthid;
            schemaId  := pBuf^.sbase.bschemacontext;
            tableName := pBuf^.sbase.btablen^;
            END;
        (*ENDIF*) 
        END
    ELSE
        IF  (b_err = e_sysinfo_not_found) OR (b_err = e_ok)
        THEN
            (* during 'Drop Trigger' Comment records used not to be deleted *)
            (* so just skip this record                                     *)
            BEGIN
            skipRecord       := true;
            b_err            := e_ok;
            acv.a_returncode := 0;
&           ifdef TRACE
            g01opmsg (sp3p_console, sp3m_info,
                  csp3_a362_migrate_ascii_to_uni,
                  csp3_n_migration, 'ignoring trigger comment', 0);
&           endif
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  commentRecPtr^.com_type in [ cm_table, cm_column ]
THEN
    BEGIN
    (* check if table/column is/belongs to view *)
    sysk           := syskey;
    sysk.skeylen   := mxak_standard_sysk;
    sysk.sentrytyp := cak_etable;
    ak362get_old_sysinfo (acv, MGlob, sysk, d_release, pBuf, b_err);
    IF  b_err = e_ok
    THEN
        BEGIN
        IF  (pBuf^.sbase.btablekind in [ twithkey, twithoutkey, tonebase,
            tview, tcomplexview ])
        THEN
            BEGIN
            storeCreateStmt := true;
            ownerId         := pBuf^.sbase.bauthid;
            schemaId        := pBuf^.sbase.bschemacontext;
            IF  commentRecPtr^.com_type = cm_table
            THEN
                BEGIN
                IF  pBuf^.sbase.bcomment
                THEN
                    BEGIN
                    tableName := a01_il_b_identifier;
                    commentOn := pBuf^.sbase.btablen^;
                    END
                ELSE
                    BEGIN
                    skipRecord := true;
&                   ifdef TRACE
                    g01opmsg (sp3p_console, sp3m_info,
                          csp3_a362_migrate_ascii_to_uni,
                          csp3_n_migration, 'ignoring dropped comment', 0);
&                   endif
                    END;
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                tableName := pBuf^.sbase.btablen^;
                (* column number (reverse of ak26build_comment_key) *)
                extcolno  := ord (syskey.stablen[2]) * 256
                      + ord(syskey.stablen[3]);
&               ifdef TRACE
                t01int4 (ak_sem, 'extcolno    ', extcolno);
                t01int4 (ak_sem, 'bmaxcol     ', pBuf^.sbase.bmaxcol);
&               endif
                IF  extcolno <= pBuf^.sbase.bmaxcol
                THEN
                    BEGIN
                    (* get correct column index *)
                    columnIndex := pBuf^.sbase.bextcolindex[ extcolno ]
                          + pBuf^.sbase.bfirstindex;
&                   ifdef TRACE
                    t01int4 (ak_sem, 'columnindex ', columnIndex);
&                   endif
                    IF  (ctcomment in
                        pBuf^.sbase.bcolumn[ columnIndex]^.ccolpropset) AND
                        NOT (ctdropped in
                        pBuf^.sbase.bcolumn[ columnIndex]^.ccolpropset) AND
                        NOT (ctinvisible in
                        pBuf^.sbase.bcolumn[ columnIndex]^.ccolpropset)
                    THEN
                        BEGIN
                        columnNameLen := ord (pBuf^.sbase.bcolumn[ columnIndex ]^.
                              ccolumnn_len);
                        commentOn := pBuf^.sbase.bcolumn[ columnIndex ]^.ccolumnn;
                        (* fill with ascii blanks :*)
                        FOR ix := columnNameLen + 1 TO sizeof (tsp00_KnlIdentifier) DO
                            commentOn[ ix ] := csp_ascii_blank;
                        (*ENDFOR*) 
                        END
                    ELSE
                        BEGIN
                        (* column was dropped or is invisible but there *)
                        (* still is a comment attached...               *)
                        skipRecord := true;
&                       ifdef TRACE
                        g01opmsg (sp3p_console, sp3m_info,
                              csp3_a362_migrate_ascii_to_uni,
                              csp3_n_migration, 'ignoring dropped comment',
                              extcolno);
                        t01int4 (ak_sem, 'skip colno  ', extcolno);
&                       endif
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    (* comment was not properly moved during drop/add of *)
                    (* column from/to table; we have to ignore it        *)
                    skipRecord := true;
&                   ifdef TRACE
                    g01opmsg (sp3p_console, sp3m_info,
                          csp3_a362_migrate_ascii_to_uni,
                          csp3_n_migration, 'ignoring stale comment  ',
                          extcolno);
                    t01int4 (ak_sem, 'skip colno  ', extcolno);
&                   endif
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  b_err = e_sysinfo_not_found
THEN
    BEGIN
    (* comment is not attached to anything anymore, ignore it *)
    b_err      := e_ok;
    skipRecord := true;
&   ifdef TRACE
    g01opmsg (sp3p_console, sp3m_info,
          csp3_a362_migrate_ascii_to_uni,
          csp3_n_migration, 'orphaned comment ignored',
          ord(sysk.sentrytyp[2]));
&   endif
    END;
(*ENDIF*) 
IF  (b_err = e_ok) AND NOT skipRecord
THEN
    IF  storeCreateStmt
    THEN
        ak362StoreCreateCommentStmt (acv, MGlob, syskey, ownerId, schemaId,
              tableName, commentOn, b_err)
    ELSE
        ak362ConvertCommentRecord (acv, MGlob, syskey, catalogTree, recBuf);
    (*ENDIF*) 
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362ConvertCommentRecord (
            VAR acv         : tak_all_command_glob;
            VAR MGlob       : tak362_MigrationGlob;
            VAR recsyskey   : tgg00_SysInfoKey;
            VAR catalogTree : tgg00_FileId;
            VAR recBuf      : tgg00_Rec);
 
CONST
      c_first_record_offset = 4;
 
VAR
      uniError         : tsp8_uni_error;
      b_err            : tgg00_BasisError;
      uniFree          : tsp00_Int4;
      ascRecPos        : tsp00_Int4;
      ascLen           : tsp00_Int4;
      recStrtOffset    : tsp00_Int4;
      commentLen       : tsp00_Int4;
      uniLen           : tsp00_Int4;
      errPos           : tsp00_Int4;
      moveObjPtr       : tsp00_MoveObjPtr;
      uniSysk          : tgg00_SysInfoKey;
      syskey           : tgg00_SysInfoKey;
      ascCommentRecPtr : ^tgg00_Rec;
      ascCommentRec    : tgg00_Rec;
      uniCommentRec    : tgg00_Rec;
 
BEGIN
(* Initialisation *)
b_err                     := e_ok;
syskey                    := recsyskey;
ascCommentRec             := recBuf;
ascCommentRecPtr          := @ascCommentRec;
uniCommentRec.recKey_gg00 := ascCommentRecPtr^.recKey_gg00;
recStrtOffset             := cgg_rec_key_offset + syskey.skeylen
      + sizeof (tsp00_C2);
uniSysk                   := syskey;
(* get length of complete record *)
moveObjPtr    := @ascCommentRec;
commentLen    := s20buf_to_int4_swap (moveObjPtr^, recStrtOffset + 1,
      sw_normal, g01code.kernel_swap);
(* first record needs special handling since first 4 byte contain *)
(* comment length:                                                *)
ascRecPos                 := recStrtOffset + c_first_record_offset + 1;
ascLen                    := ascCommentRec.recLen_gg00 - recStrtOffset
      - c_first_record_offset;
uniCommentRec.recLen_gg00 := recStrtOffset + c_first_record_offset;
uniFree                   := sizeof (tak_comment_record) -recStrtOffset
      - c_first_record_offset;
(* put unicode comment length in first record *)
s20int4_to_buf_swap (2 * commentLen, g01code.kernel_swap,
      uniCommentRec, recStrtOffset + 1, sw_normal);
REPEAT
&   ifdef TRACE
    t01buf (ak_sem, ascCommentRecPtr^.recBuf_gg00, 1,
          ascCommentRecPtr^.recLen_gg00);
&   endif
    REPEAT
        IF  (ascLen * 2) > uniFree
        THEN
            uniLen := uniFree
        ELSE
            uniLen := ascLen * 2;
        (*ENDIF*) 
        s80uni_trans (@ascCommentRecPtr^.recBuf_gg00[ ascRecPos ],
              uniLen DIV 2, csp_ascii,
              @uniCommentRec.recBuf_gg00[ uniCommentRec.recLen_gg00 + 1 ],
              uniLen,
              csp_unicode, [ ],
              uniError, errPos);
        IF  uniError <> uni_ok
        THEN
            b_err := e_not_trans_to_uni;
        (*ENDIF*) 
        uniFree                   := uniFree - uniLen;
        uniCommentRec.recLen_gg00 := uniCommentRec.recLen_gg00 + uniLen;
        ascLen                    := ascLen    - (uniLen DIV 2);
        ascRecPos                 := ascRecPos + (uniLen DIV 2);
        IF  ((sizeof (tak_comment_record) - uniCommentRec.recLen_gg00) < 2)
            AND (b_err = e_ok)
        THEN
            BEGIN
            ak362add_newkey_no_cache_sysinfo (acv, MGlob, uniSysk,
                  uniCommentRec,
                  uniCommentRec.recLen_gg00);
            a06inc_linkage (uniSysk.slinkage);
            uniCommentRec.recLen_gg00 := recStrtOffset;
            uniFree                   := sizeof (tak_comment_record)
                  - recStrtOffset;
            END;
        (*ENDIF*) 
        IF  acv.a_returncode <> 0
        THEN
            b_err := e_cancelled;
        (*ENDIF*) 
    UNTIL
        (ascLen = 0) OR (b_err <> e_ok);
    (*ENDREPEAT*) 
&   ifdef trace
    b06check_rec := false;
&   endif
    a06inc_linkage (syskey.slinkage);
    b02get_record (acv.a_transinf.tri_trans, catalogTree,
          syskey, ascCommentRec);
    b_err := acv.a_transinf.tri_trans.trError_gg00;
&   ifdef trace
    b06check_rec := true;
&   endif
    ascLen    := ascCommentRec.recLen_gg00 - cgg_rec_key_offset
          - syskey.skeylen - sizeof (tsp00_C2);
    ascRecPos := recStrtOffset + 1;
UNTIL
    b_err <> e_ok;
(*ENDREPEAT*) 
IF  b_err = e_key_not_found
THEN
    b_err := e_ok;
(*ENDIF*) 
IF  (uniCommentRec.recLen_gg00 <> recStrtOffset) AND (b_err = e_ok)
THEN
    ak362add_newkey_no_cache_sysinfo (acv, MGlob, uniSysk, uniCommentRec,
          uniCommentRec.recLen_gg00);
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362ConstraintRecord (
            VAR acv       : tak_all_command_glob;
            VAR MGlob     : tak362_MigrationGlob;
            VAR recsyskey : tgg00_SysInfoKey;
            VAR recBuf    : tgg00_Rec);
 
CONST
      c_constraint_too_long = 'CONSTRAINTTEXT IS TOO LONG:             ';
      c_name                = ' name:                                  ';
 
VAR
      asciiLen         : integer;
      unicodeLen       : integer;
      uniTextLen       : integer;
      recLenIncrease   : integer;
      errPos           : integer;
      uniError         : tsp8_uni_error;
      b_err            : tgg00_BasisError;
      newStackStart    : tsp00_Int2;
      sysBufPtr        : tak_sysbufferaddress;
      constraintRecPtr : ^tak_constraintrecord;
      syskey           : tgg00_SysInfoKey;
      msg              : tsp00_C40;
      constraintName   : tsp00_KnlIdentifier;
 
BEGIN
b_err            := e_ok;
syskey           := recsyskey;
constraintRecPtr := @recBuf.recBuf_gg00;
sysBufPtr        := @recBuf.recBuf_gg00;
recLenIncrease   := 0;
IF  acv.a_returncode = 0
THEN
    BEGIN
    (* first part of name is in ccname, rest in csuffix *)
    (* piece identifier together: *)
    constraintName   := a01_il_b_identifier;
    SAPDB_PascalForcedMove(
          sizeof (tgg00_RecBody), sizeof (tsp00_KnlIdentifier),
          @constraintRecPtr^.ccname, 1,
          @constraintName, 1,
          sizeof(tak_oldidentifier));
    IF  constraintRecPtr^.csuffixlen > 0
    THEN
        SAPDB_PascalMove('VAK362',   3,    
              sizeof (tsp00_KnlIdentifier), sizeof (tsp00_KnlIdentifier),
              @constraintRecPtr^.csuffix, 1,
              @constraintName, sizeof (tak_oldidentifier) + 1,
              constraintRecPtr^.csuffixlen,
              b_err);
    (*ENDIF*) 
    asciiLen       := s30lnr (constraintName, bsp_c1, 1,
          sizeof (constraintName));
    ak362ConvertIdentifier (constraintName, b_err);
    unicodeLen     := s30unilnr (@constraintName, csp_unicode_blank, 1,
          sizeof (constraintName));
    WITH constraintRecPtr^ DO
        BEGIN
        (* paste new name back into record,                  *)
        (* adjust csuffixlen, cstackstart and record size    *)
        SAPDB_PascalForcedMove(
              sizeof (tgg00_RecBody), sizeof (tsp00_KnlIdentifier),
              @constraintName, 1,
              @constraintRecPtr^.ccname, 1,
              sizeof(tak_oldidentifier));
        IF  unicodeLen > sizeof (ccname)
        THEN
            BEGIN
            csuffixlen      := unicodeLen - sizeof (ccname);
            newStackStart   := (csuffixlen - 1) DIV sizeof (cstack[1]) + 2;
            recLenIncrease  := (newStackStart - cstackstart) *
                  sizeof (tgg00_StackEntry);
            IF  (recBuf.recLen_gg00 + recLenIncrease) >
                sizeof (tak_constraintrecord)
            THEN
                BEGIN
                msg := c_constraint_too_long;
                g01optextmsg (sp3p_console, sp3m_error,
                      csp3_a362_migrate_ascii_to_uni,
                      csp3_n_migration, msg);
                msg        := c_name;
                uniTextLen := sizeof (msg) - 8; (* leave room for "name:" *)
                s80uni_trans (@constraintName, c_max_unicode_id_length,
                      csp_unicode,
                      @msg[8], uniTextLen, csp_ascii, [ ], uniError, errPos);
                g01optextmsg (sp3p_console, sp3m_error,
                      csp3_a362_migrate_ascii_to_uni,
                      csp3_n_migration, msg);
                b_err := e_too_long_record;
                END
            ELSE
                BEGIN
                (* move back record from start of stack to *)
                (* make room for csuffix                   *)
                SAPDB_PascalOverlappingMove ('VAK362',   4,    
                      sizeof (tak_ak_constr_stack),
                      sizeof (tak_ak_constr_stack),
                      @cstack[ cstackstart ], 1,
                      @cstack[ newStackStart ], 1,
                      recBuf.recLen_gg00
                      - (sizeof (tak_constraintrecord) - sizeof (cstack)),
                      b_err);
                recBuf.recLen_gg00 := recBuf.recLen_gg00 + recLenIncrease;
                cvalue_pos         := cvalue_pos + recLenIncrease;
                (* move remainder of name into csuffix *)
                SAPDB_PascalMove('VAK362',   5,    
                      sizeof (tsp00_KnlIdentifier),
                      sizeof (tsp00_KnlIdentifier),
                      @constraintName, sizeof (ccname) + 1,
                      @constraintRecPtr^.csuffix, 1,
                      csuffixlen,
                      b_err);
                cstackstart := newStackStart;
                END;
            (*ENDIF*) 
            END
        ELSE
            csuffixlen := 0;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
&   ifdef trace
    t01int4 (ak_sem, 'asciiLen    ', asciiLen);
    t01int4 (ak_sem, 'unicodeLen  ', unicodeLen);
    t01int4 (ak_sem, 'recLenIncrea', recLenIncrease);
    t01knl_identifier (ak_sem, 'constname   ', constraintName);
    t01int4 (ak_sem, 'cstack_cnt  ', constraintRecPtr^.cstack_cnt);
&   endif
    IF  b_err = e_ok
    THEN
        ak362add_newkey_no_cache_sysinfo (acv, MGlob, syskey, recBuf,
              recBuf.recLen_gg00);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (b_err = e_ok) AND (acv.a_returncode = 0)
THEN
    ak362ConstraintViewdesc (acv, MGlob, syskey, c_constraint_too_long,
          constraintName, b_err);
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362ConstraintViewdesc (
            VAR acv        : tak_all_command_glob;
            VAR MGlob      : tak362_MigrationGlob;
            VAR syskey     : tgg00_SysInfoKey;
            errMsg         : tsp00_C40;
            constraintName : tsp00_KnlIdentifier;
            VAR b_err      : tgg00_BasisError);
 
CONST
      c_name                = ' name:                                  ';
 
VAR
      uniError         : tsp8_uni_error;
      i                : integer;
      uniTextLen       : tsp00_Int4;
      descPos          : tsp00_Int4;
      descLen          : tsp00_Int4;
      errPos           : tsp00_Int4;
      uniTextPtr       : tsp00_MoveObjPtr;
      sysBufPtr        : tak_sysbufferaddress;
      msg              : tsp00_C40;
 
BEGIN (* constraint definition is saved in tak_viewdescrecord       *)
(* text is behind last used vdescription; vdescription[].vfromtabno *)
(* holds offset from last column name pos to current one (starting  *)
(* from 0)                                                          *)
(* (info from a11condition and a43constraint_into_moveobj)          *)
syskey.sentrytyp := cak_eviewdesc;
ak362_fix_len_get_old_sysinfo (acv, MGlob, syskey, d_release,
      sizeof(tak_viewdescrecord), 0, sysBufPtr,
      b_err);
WITH sysBufPtr^.sviewdesc DO
    BEGIN
    (* adjust position offsets *)
    FOR i := 1 TO vdesc_cnt DO
        vdescription[ i ].vfromtabno := vdescription[ i ].vfromtabno * 2;
    (*ENDFOR*) 
    descPos := cak_viewdesc_offset + vdesc_cnt * mxak_vcolumndesc + 3;
    descLen := vdreclen - descPos + 1;
    IF  (descPos + 2*descLen) > sizeof (sysBufPtr^.sviewdesc)
    THEN
        BEGIN
        msg := errMsg;
        g01optextmsg (sp3p_console, sp3m_error,
              csp3_a362_migrate_ascii_to_uni,
              csp3_n_migration, msg);
        msg        := c_name;
        uniTextLen := sizeof (msg) - 8; (* leave room for "name:" *)
        s80uni_trans (@constraintName, c_max_unicode_id_length,
              csp_unicode,
              @msg[8], uniTextLen, csp_ascii, [ ], uniError, errPos);
        g01optextmsg (sp3p_console, sp3m_error,
              csp3_a362_migrate_ascii_to_uni,
              csp3_n_migration, msg);
        b_err := e_too_long_record;
        END
    ELSE
        BEGIN
        uniTextLen := 2*descLen;
        uniTextPtr := gg941Allocate(acv.a_transinf.tri_trans, uniTextLen);
        IF  uniTextPtr = NIL
        THEN
            b_err := e_no_more_memory;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  b_err = e_ok
THEN
    BEGIN
    s80uni_trans (@sysBufPtr^.ssysbuf[descPos], descLen, csp_ascii,
          uniTextPtr, uniTextLen, csp_unicode, [ ], uniError, errPos);
    IF  uniError <> uni_ok
    THEN
        b_err := e_not_trans_to_uni
    ELSE
        BEGIN
&       ifdef trace
        t01int4 (ak_sem, 'descLen     ', descLen );
        t01int4 (ak_sem, 'descPos     ', descPos );
        t01int4 (ak_sem, 'unitextlen  ', uniTextLen);
&       endif
        sysBufPtr^.sviewdesc.vdreclen := sysBufPtr^.sviewdesc.vdreclen +
              descLen;
        SAPDB_PascalMove('VAK362',   6,    
              2*descLen, 2*descLen,
              @uniTextPtr^, 1,
              @sysBufPtr^.ssysbuf[ descPos ], 1,
              uniTextLen,
              b_err);
        ak362add_new_sysinfo (acv, MGlob, sysBufPtr, b_err);
        END;
    (*ENDIF*) 
    gg941Deallocate(acv.a_transinf.tri_trans, uniTextPtr);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362ConstraintNameRecord (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR sysk   : tgg00_SysInfoKey;
            VAR recBuf : tgg00_Rec);
 
VAR
      b_err                : tgg00_BasisError;
      constraintName       : tsp00_KnlIdentifier;
      constraintNameRecPtr : ^tak_constraintnamerecord;
 
BEGIN
b_err := e_ok;
ak362expand_old_rec (recBuf, MGlob, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    constraintNameRecPtr := @recBuf.recBuf_gg00[ 1 ];
    constraintName       := constraintNameRecPtr^.cnkey2;
    ak362ConvertIdentifier (constraintName, b_err);
    sysk.sidentifier     := constraintName;
    sysk.skeylen         := mxak_standard_sysk + sizeof (sysk.sidentifier);
    ak362add_newkey_no_cache_sysinfo (acv, MGlob, sysk, recBuf,
          recBuf.recLen_gg00);
    END;
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362DomainRecord (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR syskey : tgg00_SysInfoKey;
            VAR recBuf : tgg00_Rec);
 
CONST
      c_domain_too_long = 'DOMAIN DEFINITION TEXT TOO LONG         ';
 
VAR
      b_err          : tgg00_BasisError;
      domainNamePtr  : ^tsp00_KnlIdentifier;
      domainRecPtr   : ^tak_domainrecord;
 
BEGIN
b_err         := e_ok;
domainRecPtr  := @recBuf.recBuf_gg00;
ak362expand_old_rec (recBuf, MGlob, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    domainNamePtr := @domainRecPtr^.dom_colinfo.ccolumnn;
    ak362ConvertIdentifier (domainNamePtr^, b_err);
    domainRecPtr^.dom_colinfo.ccolumnn_len := chr (s30unilnr (@domainNamePtr^,
          csp_unicode_blank, 1, sizeof (tsp00_KnlIdentifier)));
    ak362add_newkey_no_cache_sysinfo (acv, MGlob, syskey, recBuf,
          recBuf.recLen_gg00);
    IF  (b_err = e_ok) AND (acv.a_returncode = 0)
    THEN
        ak362ConstraintViewdesc (acv, MGlob, syskey, c_domain_too_long,
              domainNamePtr^, b_err);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362DomainRefRecord (
            VAR acv       : tak_all_command_glob;
            VAR MGlob     : tak362_MigrationGlob;
            VAR recsyskey : tgg00_SysInfoKey;
            VAR recBuf    : tgg00_Rec);
 
VAR
      b_err               : tgg00_BasisError;
      domainRefNameRecPtr : ^tak_domainref;
      domainRefName       : tsp00_KnlIdentifier;
      syskey              : tgg00_SysInfoKey;
 
BEGIN
b_err := e_ok;
ak362expand_old_rec (recBuf, MGlob, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    syskey              := recsyskey;
    domainRefNameRecPtr := @recBuf.recBuf_gg00[ 1 ];
    domainRefName       := domainRefNameRecPtr^.dname;
    ak362ConvertIdentifier (domainRefName, b_err);
    syskey.sidentifier  := domainRefName;
    syskey.skeylen      := mxak_standard_sysk + sizeof (syskey.sidentifier);
    ak362add_newkey_no_cache_sysinfo (acv, MGlob, syskey, recBuf,
          recBuf.recLen_gg00);
    END;
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362DomainUsageRecord (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR syskey : tgg00_SysInfoKey);
 
VAR
      b_err  : tgg00_BasisError;
      pBuf   : tak_sysbufferaddress;
 
BEGIN
b_err := e_ok;
ak362get_old_sysinfo (acv, MGlob, syskey, d_release, pBuf, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    ak362ConvertIdentifier (pBuf^.scol_uses_dom.cud_name, b_err);
    ak362add_new_sysinfo (acv, MGlob, pBuf, b_err);
    a10key_del (acv, pBuf);
    END;
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362LinkRecord (
            VAR acv       : tak_all_command_glob;
            VAR MGlob     : tak362_MigrationGlob;
            VAR recsyskey : tgg00_SysInfoKey);
 
VAR
      b_err      : tgg00_BasisError;
      linkName   : tsp00_KnlIdentifier;
      sysBufPtr  : tak_sysbufferaddress;
      linkNo     : tsp00_Int2;
      linkCount  : tsp00_Int2;
      col_cnt    : integer;
      name_pos   : integer;
      rest_len   : integer;
      move_len   : integer;
      offset     : integer;
      suffix_len : integer;
      sysk       : tgg00_SysInfoKey;
      syskey     : tgg00_SysInfoKey;
      suffix_p   : tak_sysbufferaddress;
 
BEGIN
(* the outer loop of this procedure is mainly taken from     *)
(* ak25eval_link_pos_info, the handling of the new name from *)
(* ak25init_link_record                                      *)
b_err  := e_ok;
syskey := recsyskey;
linkNo := 0;
REPEAT
    linkNo := succ (linkNo);
    IF  linkNo MOD cak_maxlinkdef = 1
    THEN
        ak362get_old_sysinfo (acv, MGlob, syskey, d_fix, sysBufPtr, b_err);
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        BEGIN
        IF  syskey.slinkage = cak_init_linkage
        THEN
            BEGIN
            linkCount := sysBufPtr^.slink.linkcount;
&           ifdef TRACE
            t01int4 (ak_sem, 'linkCount   ', linkCount);
&           endif
            END;
        (*ENDIF*) 
        ;
&       ifdef TRACE
        t01int4 (ak_sem, 'linkNo      ', linkNo);
&       endif
        ak362set_ascii (MGlob);
        a25get_linkname (acv, sysBufPtr, (linkNo-1) MOD cak_maxlinkdef + 1,
              linkName);
        ak362set_unicode (MGlob);
        ;
        ak362ConvertIdentifier (linkName, b_err);
        ;
        (* the following is basically copied from ak25init_link_record *)
        WITH sysBufPtr^.slink.linkdef[(linkNo-1) MOD cak_maxlinkdef + 1 ] DO
            BEGIN
            col_cnt := lcolcount;
            suffix_len := s30unilnr (@linkName, csp_unicode_blank, 1,
                  sizeof (linkName)) - sizeof (linkn_prefix);
            IF  col_cnt = 1
            THEN
                col_cnt := 2;
            (*ENDIF*) 
            SAPDB_PascalForcedMove(
                  sizeof (linkName), sizeof (linkn_prefix),
                  @linkName, 1, @linkn_prefix, 1,
                  sizeof (linkn_prefix));
            name_pos := sizeof (linkn_prefix) + 1;
            IF  suffix_len < 0
            THEN
                lsuffixlen := 0
            ELSE
                lsuffixlen := suffix_len;
            (*ENDIF*) 
            rest_len := lsuffixlen;
            IF  rest_len > 0
            THEN
                BEGIN
                move_len := sizeof (lstack) -
                      col_cnt * sizeof (lstack[1]);
                IF  move_len > 0
                THEN
                    BEGIN
                    IF  move_len > rest_len
                    THEN
                        move_len := rest_len;
                    (*ENDIF*) 
                    SAPDB_PascalMove('VAK362',   7,    
                          sizeof (linkName), sizeof (lstack),
                          @linkName, name_pos,
                          @lstack, col_cnt * sizeof (lstack[1]) + 1,
                          move_len, b_err);
                    name_pos := name_pos + move_len;
                    rest_len := rest_len - move_len
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  rest_len > 0
            THEN
                BEGIN
                sysk             := sysBufPtr^.syskey;
                sysk.slinkage[1] := chr((linkNo-1) MOD cak_maxlinkdef + 1);
                offset           := cgg_rec_key_offset + sysk.skeylen +
                      sizeof (sysBufPtr^.slink.lsegmentid);
                a10_fix_len_get_sysinfo (acv, sysk, d_release,
                      offset + rest_len, 0, suffix_p, b_err);
                IF  b_err = e_sysinfo_not_found
                THEN
                    BEGIN
                    b_err            := e_ok;
                    acv.a_returncode := 0;
                    END;
                (*ENDIF*) 
                IF  b_err = e_ok
                THEN
                    BEGIN
&                   ifdef trace
                    t01knl_identifier (ak_sem, 'linkName    ', linkName);
                    t01int4 (ak_sem, 'name_pos    ', name_pos);
                    t01int4 (ak_sem, 'rest_len    ', rest_len);
                    t01int4 (ak_sem, 'offset      ', offset);
&                   endif
                    SAPDB_PascalMove('VAK362',   8,    
                          sizeof (linkName),
                          offset + rest_len,
                          @linkName, name_pos,
                          @suffix_p^.slink, offset + 1,
                          rest_len, b_err);
                    ak362add_new_sysinfo (acv, MGlob, suffix_p, b_err);
                    a10key_del (acv, suffix_p);
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        IF  (linkNo MOD cak_maxlinkdef = 0) OR (linkNo = linkCount)
        THEN
            BEGIN
            ak362add_new_sysinfo (acv, MGlob, sysBufPtr, b_err);
            a06inc_linkage (syskey.slinkage)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
UNTIL
    (linkNo = linkCount) OR (b_err <> e_ok) OR (acv.a_returncode <> 0);
(*ENDREPEAT*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362LinkDefRecord (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR recBuf : tgg00_Rec);
 
VAR
      b_err         : tgg00_BasisError;
      linkdefRecPtr : ^tak_link_def_record;
      pBuf          : tak_sysbufferaddress;
 
BEGIN
b_err := e_ok;
ak362expand_old_rec (recBuf, MGlob, b_err);
linkdefRecPtr := @recBuf.recBuf_gg00;
pBuf          := @recBuf.recBuf_gg00;
IF  b_err = e_ok
THEN
    BEGIN
    (* PTS 1129899 M.Ki. *)
    ak362ConvertIdentifier (linkdefRecPtr^.lkeyname, b_err);
    ak362add_newkey_no_cache_sysinfo (acv, MGlob, pBuf^.syskey, recBuf,
          recBuf.recLen_gg00);
    END;
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362MIndexRecord (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR syskey : tgg00_SysInfoKey);
 
VAR
      currIndex    : integer;
      b_err        : tgg00_BasisError;
      mIndexRecPtr : ^tak_mindexrecord;
      pBuf         : tak_sysbufferaddress;
      indexName    : tsp00_KnlIdentifier;
 
BEGIN
b_err := e_ok;
ak362get_old_sysinfo (acv, MGlob, syskey, d_fix, pBuf, b_err);
mIndexRecPtr := @pBuf^.smindex;
IF  b_err = e_ok
THEN
    BEGIN
    currIndex := 1;
    WHILE (currIndex <= mIndexRecPtr^.indexcount) AND
          (b_err = e_ok) AND
          (acv.a_returncode = 0) DO
        BEGIN
        ak362get_indexname (acv, MGlob, pBuf, currIndex, indexName);
        IF  s30lnr (indexName, bsp_c1, 1, sizeof (indexName)) > 0
        THEN
            BEGIN
            ak362ConvertIdentifier (indexName, b_err);
&           ifdef TRACE
            t01knl_identifier (ak_sem, 'mindex      ', indexName);
&           endif
            a24assign_indexname (acv, pBuf, currIndex, indexName);
            IF  acv.a_returncode <> 0
            THEN
                b_err := acv.a_returncode;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        currIndex := succ (currIndex);
        END;
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
IF  b_err = e_ok
THEN
    BEGIN
    ak362add_new_sysinfo (acv, MGlob, pBuf, b_err);
    a10key_del (acv, pBuf);
    END
ELSE
    IF  acv.a_returncode = 0
    THEN
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362MapsetRecord (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR syskey : tgg00_SysInfoKey;
            VAR recBuf : tgg00_Rec);
 
VAR
      b_err        : tgg00_BasisError;
      mapsetRecPtr : ^tak_mapset_record;
      pBuf         : tak_sysbufferaddress;
 
BEGIN
b_err        := e_ok;
ak362expand_old_rec (recBuf, MGlob, b_err);
mapsetRecPtr := @recBuf;
pBuf         := @recBuf;
IF  b_err = e_ok
THEN
    BEGIN
    ak362ConvertIdentifier (mapsetRecPtr^.map_name, b_err);
    ak362add_newkey_no_cache_sysinfo (acv, MGlob, pBuf^.syskey, recBuf,
          recBuf.recLen_gg00);
    END;
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362MethodRecord (
            VAR acv       : tak_all_command_glob;
            VAR MGlob     : tak362_MigrationGlob;
            VAR recsyskey : tgg00_SysInfoKey;
            VAR recBuf    : tgg00_Rec);
 
VAR
      uniError       : tsp8_uni_error;
      b_err          : tgg00_BasisError;
      context        : tsp00_Uint1;
      language       : tak_proc_language;
      ix             : integer;
      errPos         : tsp00_Int4;
      uniLen         : tsp00_Int4;
      moveObjPtr     : tsp00_MoveObjPtr;
      pMoveObjPtr    : tsp00_MoveObjPtr;
      pNewParInfoPtr : tak_param_info_ptr;
      methodRecPtr   : ^tak_methodrecord;
      pBuf           : tak_sysbufferaddress;
      methodOwner    : tgg00_Surrogate;
      methInfoKey    : tgg00_SysInfoKey;
      syskey         : tgg00_SysInfoKey;
      methodName     : tsp00_KnlIdentifier;
      orgInfoPtr     : ARRAY [1 .. cak_max_param_index] OF tak_param_info_ptr;
 
BEGIN
b_err        := e_ok;
syskey       := recsyskey;
methodRecPtr := @recBuf.recBuf_gg00;
IF  a260IsInternalDBProc (methodRecPtr^)
THEN (* in case of a db procedure only save viewtext to recreate the *)
    BEGIN (* procedure later; ignore the record itself               *)
    methInfoKey           := syskey;
    methInfoKey.sentrytyp := cak_emethodinfo;
    methInfoKey.slinkage  := cak_init_linkage;
    ak362get_old_sysinfo (acv, MGlob, methInfoKey, d_release, pBuf, b_err);
    methodOwner           := pBuf^.smethodinfo.mei_owner;
    IF  b_err = e_ok
    THEN
        BEGIN
        (* get sql-mode of statement from permanent messblock *)
        ak362getMethodSQLContext (acv, MGlob, syskey, context, b_err);
        IF  (b_err <> e_ok)
        THEN
            BEGIN
            b_err   := e_ok;
            context := 30; (* assume we are in Oracle mode *)
            END;
&       ifdef TRACE
        (*ENDIF*) 
        t01int4 (ak_sem, 'context     ', context);
&       endif
        methInfoKey               := syskey;
        methInfoKey.sentrytyp     := cak_eviewtext;
        methInfoKey.slinkage[ 1 ] := chr (255 - ord (syskey.slinkage[ 2 ]));
        methInfoKey.slinkage[ 2 ] := chr (1);
        ak362StoreCreateTriggerStmt (acv, MGlob, methInfoKey, context,
              b_err);
        END;
    (*ENDIF*) 
    END
ELSE
    BEGIN (* liveCache procedures: convert all records belonging to it *)
    (* convert methodrecord itself: *)
    ak362get_old_sysinfo (acv, MGlob, syskey, d_fix, pBuf, b_err);
    methodRecPtr := @pBuf^.smethod;
    IF  (b_err = e_ok)
    THEN
        BEGIN
        language := methodRecPtr^.me_language;
        IF  methodRecPtr^.me_param_cnt = 0
        THEN
            ak362add_new_sysinfo (acv, MGlob, pBuf, b_err)
        ELSE
            BEGIN
            syskey.slinkage := cak_zero_linkage;
            FOR ix := 1 TO methodRecPtr^.me_param_cnt DO
                BEGIN
                pMoveObjPtr       := gg941Allocate(acv.a_transinf.tri_trans,
                      sizeof(tak_param_info));
                pNewParInfoPtr    := @pMoveObjPtr^;
                orgInfoPtr[ ix ]  := NIL;
                IF  pNewParInfoPtr <> NIL
                THEN
                    BEGIN (* move content of record into new param record *)
                    SAPDB_PascalMove ('VAK362',   9,    
                          sizeof (tak_param_info) - sizeof (tsp00_C256),
                          sizeof (tak_param_info) - sizeof (tsp00_C256),
                          @methodRecPtr^.me_param_list[ ix ]^, 1,
                          @pNewParInfoPtr^, 1,
                          sizeof(tak_param_info) - sizeof (tsp00_C256),
                          b_err);
                    IF  ord (methodRecPtr^.me_param_list[ ix ]^.param_name_len) > 0
                    THEN
                        BEGIN
                        uniLen := sizeof (tsp00_C256);
                        s80uni_trans (@methodRecPtr^.me_param_list[ ix ]^.param_name,
                              ord(methodRecPtr^.me_param_list[ ix ]^.param_name_len),
                              csp_ascii,
                              @pNewParInfoPtr^.param_name, uniLen,
                              csp_unicode, [ ], uniError, errPos);
                        IF  uniError <> uni_ok
                        THEN
                            b_err := e_not_trans_to_uni;
                        (*ENDIF*) 
                        END
                    ELSE
                        uniLen := 0;
                    (*ENDIF*) 
                    pNewParInfoPtr^.param_name_len    := chr (uniLen);
                    orgInfoPtr[ ix ] := methodRecPtr^.me_param_list[ ix ];
                    methodRecPtr^.me_param_list[ ix ] := pNewParInfoPtr;
                    END
                ELSE
                    b_err := e_no_more_memory;
                (*ENDIF*) 
&               ifdef TRACE
                moveObjPtr := @methodRecPtr^.me_param_list[ ix ]^.param_name;
                t01moveobj (ak_sem, moveObjPtr^,
                      1, ord(methodRecPtr^.me_param_list[ ix ]^.param_name_len));
                t01int4 (ak_sem, 'org length  ', ord (orgInfoPtr[ix]^.param_name_len));
&               endif
                END;
            (*ENDFOR*) 
            IF  b_err = e_ok
            THEN
                IF  pNewParInfoPtr <> NIL
                THEN
                    ak362add_new_sysinfo (acv, MGlob, pBuf, b_err);
                (*ENDIF*) 
            (*ENDIF*) 
            ix := 1;
            WHILE (ix <= methodRecPtr^.me_param_cnt) AND
                  (orgInfoPtr[ ix ] <> NIL) DO
                BEGIN
                moveObjPtr := @methodRecPtr^.me_param_list[ ix ]^;
                gg941Deallocate(acv.a_transinf.tri_trans, moveObjPtr);
                methodRecPtr^.me_param_list[ ix ] := orgInfoPtr[ ix ];
                ix := succ (ix);
                END;
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    a10key_del (acv, pBuf);
    IF  (b_err = e_ok) AND (acv.a_returncode = 0)
    THEN
        BEGIN
        (* convert method_info_record: *)
        methInfoKey           := syskey;
        methInfoKey.sentrytyp := cak_emethodinfo;
        methInfoKey.slinkage  := cak_init_linkage;
        ak362MethodInfoRecord (acv, MGlob, methInfoKey, language, methodOwner,
              methodName);
        END;
    (* convert methodrefrecord: *)
    (*ENDIF*) 
    IF  (b_err = e_ok) AND (acv.a_returncode = 0)
    THEN
        BEGIN
        methInfoKey             := syskey;
        methInfoKey.sauthid     := methodOwner;
        methInfoKey.sentrytyp   := cak_emethodref;
        methInfoKey.sidentifier := methodName;
        methInfoKey.skeylen     := methInfoKey.skeylen + sizeof (methodName);
        methInfoKey.slinkage    := cak_init_linkage;
        ak362MethodrefRecord (acv, MGlob, methInfoKey);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362MethodrefRecord (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR syskey : tgg00_SysInfoKey);
 
VAR
      b_err        : tgg00_BasisError;
      methodrefRec : tak_methodrefrecord;
      oldSysBufPtr : tak_sysbufferaddress;
      newSysBufPtr : tak_sysbufferaddress;
      newRecPtr    : tgg00_RecPtr;
 
BEGIN
b_err := e_ok;
ak362get_old_sysinfo (acv, MGlob, syskey, d_fix, oldSysBufPtr, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    methodrefRec := oldSysBufPtr^.smethodref;
    newSysBufPtr := @methodrefRec;
    newRecPtr    := @methodrefRec;
    ak362ConvertIdentifier (methodrefRec.mrf_methodname, b_err);
    ak362add_newkey_no_cache_sysinfo (acv, MGlob, newSysBufPtr^.syskey,
          newRecPtr^, newRecPtr^.recLen_gg00);
    a10key_del (acv, oldSysBufPtr);
    END;
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362MethodInfoRecord (
            VAR acv         : tak_all_command_glob;
            VAR MGlob       : tak362_MigrationGlob;
            VAR syskey      : tgg00_SysInfoKey;
            language        : tak_proc_language;
            VAR methodOwner : tgg00_Surrogate;
            VAR methodName  : tsp00_KnlIdentifier);
 
VAR
      ix               : integer;
      b_err            : tgg00_BasisError;
      methodInfoRecPtr : ^tak_method_inforecord;
      pBuf             : tak_sysbufferaddress;
 
BEGIN
b_err := e_ok;
ak362get_old_sysinfo (acv, MGlob, syskey, d_release, pBuf, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    methodInfoRecPtr := @pBuf^.smethodinfo;
    IF  language in [lang_java, lang_other]
    THEN
        ak362ConvertIdentifier (methodInfoRecPtr^.mei_name, b_err)
    ELSE
        FOR ix := 1 TO sizeof (methodInfoRecPtr^.mei_language) DIV 2 DO
            BEGIN
            methodInfoRecPtr^.mei_language [ 2*ix-1 ] := '\00';
            methodInfoRecPtr^.mei_language [ 2*ix   ] := '\20';
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    methodName  := methodInfoRecPtr^.mei_name; (* return methodName *)
    methodOwner := methodInfoRecPtr^.mei_owner;
    (* convert mei_name: *)
    IF  b_err = e_ok
    THEN
        ak362ConvertIdentifier (methodInfoRecPtr^.mei_name, b_err);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  b_err = e_ok
THEN
    BEGIN
    ak362add_new_sysinfo (acv, MGlob, pBuf, b_err);
    a10key_del (acv, pBuf);
    END;
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362SchemaRecord (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR syskey : tgg00_SysInfoKey);
 
VAR
      b_err : tgg00_BasisError;
      pBuf  : tak_sysbufferaddress;
 
BEGIN
b_err := e_ok;
ak362get_old_sysinfo (acv, MGlob, syskey, d_release, pBuf, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    ak362ConvertIdentifier (pBuf^.sschema.sch_name, b_err);
    ak362add_new_sysinfo (acv, MGlob, pBuf, b_err);
    a10key_del (acv, pBuf);
    END;
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362SchemarefRecord (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR sysk   : tgg00_SysInfoKey;
            VAR recBuf : tgg00_Rec);
 
VAR
      b_err                : tgg00_BasisError;
      schemaRefName        : tsp00_KnlIdentifier;
      schemaRefNameRecPtr  : ^tak_schema_ref_record;
 
BEGIN
b_err := e_ok;
ak362expand_old_rec (recBuf, MGlob, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    schemaRefNameRecPtr  := @recBuf.recBuf_gg00[ 1 ];
    schemaRefName        := schemaRefNameRecPtr^.schr_name;
    ak362ConvertIdentifier (schemaRefName, b_err);
    sysk.sidentifier     := schemaRefName;
    sysk.skeylen         := mxak_standard_sysk + sizeof (sysk.sidentifier);
    ak362add_newkey_no_cache_sysinfo (acv, MGlob, sysk, recBuf,
          recBuf.recLen_gg00);
    END;
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362SequenceRecord (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR syskey : tgg00_SysInfoKey);
 
VAR
      b_err : tgg00_BasisError;
      pBuf  : tak_sysbufferaddress;
 
BEGIN
b_err := e_ok;
ak362get_old_sysinfo (acv, MGlob, syskey, d_release, pBuf, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    (* PTS 1129210 M.Ki. *)
    IF  pBuf^.ssequence.seq_reclen >= mxak_sequence_offset
    THEN
        ak362ConvertIdentifier (pBuf^.ssequence.seq_name, b_err);
    (*ENDIF*) 
    ak362add_new_sysinfo (acv, MGlob, pBuf, b_err);
    a10key_del (acv, pBuf);
    END;
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362TriggerRecord (
            VAR acv       : tak_all_command_glob;
            VAR MGlob     : tak362_MigrationGlob;
            VAR recsyskey : tgg00_SysInfoKey;
            VAR b_err     : tgg00_BasisError);
 
VAR
      context : tsp00_Uint1;
      sysk    : tgg00_SysInfoKey;
      syskey  : tgg00_SysInfoKey;
 
BEGIN
syskey := recsyskey;
ak362getMethodSQLContext (acv, MGlob, syskey, context, b_err);
IF  b_err <> e_ok
THEN (* trigger no information about sql mode;  it is safe to use *)
    (* sqlm_internal as default                                     *)
    BEGIN
    b_err   := e_ok;
    context := 0;
    END;
(*ENDIF*) 
IF  b_err = e_ok
THEN
    BEGIN
    (* store viewtexts defining trigger: *)
    sysk               := syskey;
    sysk.sentrytyp     := cak_eviewtext;
    sysk.slinkage[ 1 ] := chr (255 - ord (syskey.slinkage[ 2 ]));
    sysk.slinkage[ 2 ] := chr (1);
    ak362StoreCreateTriggerStmt (acv, MGlob, sysk, context,
          b_err);
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362TableRecord (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR syskey : tgg00_SysInfoKey);
 
VAR
      ix            : integer;
      jx            : integer;
      b_err         : tgg00_BasisError;
      pMoveObjPtr   : tsp00_MoveObjPtr;
      pNewCol       : tak00_colinfo_ptr;
      sysPointer    : tak_sysbufferaddress;
      pBase         : ^tak_baserecord;
      pTableNamePtr : tsp00_KnlIdentifierPtr;
 
BEGIN
b_err := e_ok;
ak362get_old_sysinfo (acv, MGlob, syskey, d_release, sysPointer, b_err);
pNewCol := NIL;
IF  b_err = e_ok
THEN
    BEGIN
    pBase := @sysPointer^;
    IF  sysPointer^.sbase.btablekind <> tsynonym
    THEN
        pTableNamePtr := sysPointer^.sbase.btablen
    ELSE
        pTableNamePtr := @sysPointer^.ssynonym.syn_tablen;
    (*ENDIF*) 
    ak362ConvertIdentifier (pTableNamePtr^, b_err);
&   ifdef trace
    t01knl_identifier (ak_sem, 'tablename   ', pTableNamePtr^);
&   endif
    (* remove triggers from baserecord; they will be recreated later *)
    sysPointer^.sbase.blinkexist := sysPointer^.sbase.blinkexist -
          [ del_trigger, ins_trigger, upd_trigger ];
    END;
(*ENDIF*) 
;
IF  (b_err = e_ok) AND (sysPointer^.sbase.btablekind <> tsynonym)
THEN
    (* convert column names; allocate memory to store new columninfo *)
    FOR ix := pBase^.bfirstindex TO pBase^.blastindex DO
        BEGIN
        pMoveObjPtr := gg941Allocate(acv.a_transinf.tri_trans,
              sizeof(tak00_columninfo) +
              2 * ord(pBase^.bcolumn[ix]^.ccolumnn_len));
        pNewCol := @pMoveObjPtr^;
        IF  pNewCol <> NIL
        THEN
            BEGIN
            SAPDB_PascalForcedMove(
                  sizeof(tak00_columninfo) - sizeof(tsp00_KnlIdentifier),
                  sizeof(tak00_columninfo) - sizeof(tsp00_KnlIdentifier),
                  @pBase^.bcolumn[ix]^, 1,
                  @pNewCol^, 1,
                  sizeof(tak00_columninfo) - sizeof(tsp00_KnlIdentifier));
            FOR jx := 1 TO ord(pBase^.bcolumn[ix]^.ccolumnn_len) DO
                BEGIN
                pNewCol^.ccolumnn[jx*2-1] := chr(0);
                pNewCol^.ccolumnn[jx*2  ] := pBase^.bcolumn[ix]^.ccolumnn[jx];
                END;
            (*ENDFOR*) 
            pNewCol^.ccolumnn_len := chr (ord (pBase^.bcolumn[ix]^.ccolumnn_len) * 2);
            pBase^.bcolumn[ix]    := pNewCol;
            END
        ELSE
            b_err := e_no_more_memory;
        (*ENDIF*) 
        pBase^.breccnt := 0; (* needed to make sure baserecord gets inserted *)
        (* into catalog, if > 0, catalog cache tries to do an update         *)
        END;
    (*ENDFOR*) 
(*ENDIF*) 
IF  b_err = e_ok
THEN
    ak362add_new_sysinfo (acv, MGlob, sysPointer, b_err);
(*ENDIF*) 
IF  (b_err = e_ok)    AND
    (pNewCol <> NIL)  AND
    (sysPointer^.sbase.btablekind <> tsynonym)
THEN
    BEGIN
    FOR ix := pBase^.bfirstindex TO pBase^.blastindex DO
        BEGIN
        pMoveObjPtr := @pBase^.bcolumn[ix]^;
        gg941Deallocate(acv.a_transinf.tri_trans, pMoveObjPtr);
        END;
    (*ENDFOR*) 
    END;
(*ENDIF*) 
IF  (b_err = e_ok)                                                AND
    NOT (sysPointer^.sbase.btablekind in [twithkey, twithoutkey]) AND
    (sysPointer^.sbase.btablekind <> tsynonym)                    AND
    (sysPointer^.sbase.btablekind <> tempty) (* PTS 1122726 M.Ki *)
THEN (* check for views *)
    ak362StoreCreateViewStmt (acv, MGlob, syskey,
          sysPointer^.sbase.bauthid,
          sysPointer^.sbase.bschemacontext,
          b_err);
(*ENDIF*) 
IF  (b_err = e_ok)     AND
    (sysPointer^.sbase.btablekind in [tonebase, tview, tcomplexview])
THEN
    (* convert viewtextrecords for this view *)
    ak362ViewtextRecord (acv, MGlob, syskey);
(*ENDIF*) 
IF  (b_err = e_ok) AND (acv.a_returncode = 0)
THEN
    a10key_del (acv, sysPointer);
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362TableRefRecord (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR syskey : tgg00_SysInfoKey;
            VAR recBuf : tgg00_Rec);
 
VAR
      b_err                : tgg00_BasisError;
      tableRefNameRecPtr   : ^tak_tablereference;
      sysk                 : tgg00_SysInfoKey;
      tableRefName         : tsp00_KnlIdentifier;
 
BEGIN
b_err := e_ok;
ak362expand_old_rec (recBuf, MGlob, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    tableRefNameRecPtr := @recBuf.recBuf_gg00[ 1 ];
    tableRefName       := tableRefNameRecPtr^.rtablerefkey2;
    ak362ConvertIdentifier (tableRefName, b_err);
    sysk               := syskey;
    sysk.sidentifier   := tableRefName;
    sysk.skeylen       := mxak_standard_sysk + sizeof (sysk.sidentifier);
    ak362add_newkey_no_cache_sysinfo (acv, MGlob, sysk, recBuf,
          recBuf.recLen_gg00);
    END;
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362UserRecord (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR syskey : tgg00_SysInfoKey;
            VAR b_err  : tgg00_BasisError);
 
VAR
      pBuf       : tak_sysbufferaddress;
 
BEGIN
ak362get_old_sysinfo (acv, MGlob, syskey, d_release, pBuf, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    ak362ConvertIdentifier (pBuf^.suser.username, b_err);
    IF  b_err = e_ok
    THEN (* convert passwords: decrypt, convert, encrypt *)
        a362AuthorizationConvertPasswords (pBuf^.suser, b_err);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  b_err = e_ok
THEN
    ak362add_new_sysinfo (acv, MGlob, pBuf, b_err);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362UserTabRecord (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR syskey : tgg00_SysInfoKey;
            VAR b_err  : tgg00_BasisError);
 
VAR
      ix       : integer;
      pUsertab : tak_sysbufferaddress;
 
BEGIN
ak362get_old_sysinfo (acv, MGlob, syskey, d_release, pUsertab, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    FOR ix := 1 TO pUsertab^.susertab.usertabcount DO
        WITH pUsertab^.susertab.usertabdef[ix] DO
            IF  NOT ut_empty
            THEN
                BEGIN
                CASE ut_kind OF
                    ut_procedure :
                        ut_empty := true;
                    OTHERWISE ;
                    END;
                (*ENDCASE*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDFOR*) 
    END;
(*ENDIF*) 
IF  b_err = e_ok
THEN
    ak362add_new_sysinfo (acv, MGlob, pUsertab, b_err);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362StoreProcPriv (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR syskey : tgg00_SysInfoKey;
            VAR b_err  : tgg00_BasisError);
 
VAR
      pBuf    : tak_sysbufferaddress;
      mSysKey : tgg00_SysInfoKey;
      infoBuf : tak362_ProcPrivInfoRec;
 
BEGIN
ak362get_old_sysinfo (acv, MGlob, syskey, d_release, pBuf, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    SAPDB_PascalMove ('VAK362',  10,    
          pBuf^.sprocseqpriv.psp_reclen, sizeof (infoBuf),
          @pBuf^.ssysbuf, 1,
          @infoBuf, 1,
          pBuf^.sprocseqpriv.psp_reclen,
          b_err);
    IF  b_err = e_ok
    THEN
        BEGIN
        mSysKey            := syskey;
        mSysKey.sauthid    := pBuf^.sprocseqpriv.psp_id;
        mSysKey.sentrytyp  := cak_emethodinfo;
        mSysKey.slinkage   := cak_init_linkage;
        mSysKey.skeylen    := mxak_standard_sysk;
        ak362get_old_sysinfo (acv, MGlob, mSysKey, d_release, pBuf, b_err);
        END;
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        BEGIN
        infoBuf.pi_methodName := pBuf^.smethodinfo.mei_name;
        infoBuf.pi_schemaId   := pBuf^.smethodinfo.mei_schema;
        (* *)
        infoBuf.pi_procPriv.psp_reclen := sizeof (infoBuf.pi_procPriv)
              + sizeof (infoBuf.pi_schemaId) + sizeof (infoBuf.pi_methodName);
        (* *)
        b07cadd_record (acv.a_transinf.tri_trans, MGlob.priv_tree,
              infoBuf.rec);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362UpdateProcPriv (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob);
 
VAR
      b_err     : tgg00_BasisError;
      pBuf      : tak_sysbufferaddress;
      setResult : tgg00_BdSetResultRecord;
      treePos   : tgg00_FilePos;
      recKey    : tgg00_Lkey;
      mSysKey   : tgg00_SysInfoKey;
      infoBuf   : tak362_ProcPrivInfoRec;
 
BEGIN
;
ak362set_unicode (MGlob);
;
pBuf       := NIL;
recKey.len := 0;
WITH setResult DO
    BEGIN
    bd_key_check_len := 0;
    bd_max_rec_cnt   := 1;
    bd_max_fill_len  := sizeof( infoBuf.rec.recBuf_gg00 );
    bd_next          := true;
    bd_drop_page     := false
    END;
(*ENDWITH*) 
REPEAT
    treePos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
    b07cnext_record( acv.a_transinf.tri_trans, MGlob.priv_tree,
          recKey, setResult, treePos, infoBuf.rec.recBuf_gg00 );
    b_err := acv.a_transinf.tri_trans.trError_gg00;
    IF  ( b_err = e_ok ) OR ( b_err = e_key_not_found )
    THEN
        BEGIN
        b_err := e_ok;
        (* update recKey *)
        SAPDB_PascalMove ('VAK362',  11,    
              sizeof (infoBuf), sizeof (recKey),
              @infoBuf, 1,
              @recKey, 1,
              cgg_rec_key_offset + infoBuf.rec.recKeyLen_gg00,
              b_err);
        IF  b_err = e_ok
        THEN (* init mSysKey *)
            SAPDB_PascalMove ('VAK362',  12,    
                  sizeof (infoBuf), sizeof (mSysKey),
                  @infoBuf, 1,
                  @mSysKey, 1,
                  cgg_rec_key_offset + infoBuf.rec.recKeyLen_gg00,
                  b_err);
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            BEGIN
            mSysKey.sauthid     := infoBuf.pi_schemaId;
            mSysKey.sentrytyp   := cak_emethodref;
            mSysKey.slinkage    := cak_init_linkage;
            mSysKey.sidentifier := infoBuf.pi_methodName;
            ak362ConvertIdentifier (mSysKey.sidentifier, b_err);
            mSysKey.skeylen     := mxak_standard_sysk
                  + sizeof (mSysKey.sidentifier);
            REPEAT
                a10get_sysinfo (acv, mSysKey, d_release, pBuf, b_err);
                a06inc_linkage (mSysKey.slinkage);
            UNTIL
                (b_err = e_ok)
                OR (mSysKey.slinkage = cak_init_linkage)
                OR (b_err <> e_sysinfo_not_found)
            (*ENDREPEAT*) 
            END;
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            BEGIN
            infoBuf.pi_procPriv.psp_id     := pBuf^.smethodref.mrf_method_id;
            infoBuf.pi_procPriv.psp_reclen := sizeof (tak_proc_seq_privilege);
            ak362add_newkey_no_cache_sysinfo (acv, MGlob, infoBuf.pi_syskey,
                  infoBuf.rec, sizeof (tak_proc_seq_privilege));
            IF  acv.a_returncode = 0
            THEN
                a19add_usertab (acv, infoBuf.pi_procPriv.psp_grantor,
                      infoBuf.pi_procPriv.psp_id, ut_procedure);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
UNTIL
    ( b_err <> e_ok ) OR ( acv.a_returncode <> 0 );
(*ENDREPEAT*) 
IF  ( b_err <> e_no_next_record ) AND ( acv.a_returncode = 0 )
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a362AuthorizationConvertPasswords (VAR authorization : tak_userrecord;
            VAR e : tgg00_BasisError);
 
BEGIN
ak362ConvertPassword (authorization.userpassw, e);
IF  e = e_ok
THEN
    ak362ConvertPassword (authorization.usupportpasspw, e);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362ConvertPassword (VAR cryptPw : tsp00_CryptPw;
            VAR e : tgg00_BasisError);
 
CONST
      c_blank_pw = '\00\20\00\20\00\20\00\20\00\20\00\20\00\20\00\20\00\20';
 
VAR
      errPos     : tsp00_Int4;
      uniLen     : integer;
      asciiLen   : integer;
      uniError   : tsp8_uni_error;
      moveObjPtr : tsp00_MoveObjPtr;
      oldPw      : tsp00_Name;
      newPw      : tsp00_Name;
 
BEGIN
e := e_ok;
(* convert passwords: decrypt, convert, encrypt *)
g02decrypt (oldPw, cryptPw);
moveObjPtr := @oldPw;
asciiLen   := s30lnr1 (moveObjPtr^, bsp_c1, 1, sizeof (oldPw));
IF  asciiLen > (sizeof (oldPw) DIV 2)
THEN (* unicode passwords can only have a length of 9 characters *)
    BEGIN
&   ifdef TRACE
    t01int4 (ak_sem, 'passwd trunc', asciiLen);
&   endif
    asciiLen := sizeof (oldPw) DIV 2;
    END;
(*ENDIF*) 
newPw  := c_blank_pw;
uniLen := sizeof (oldPw);
s80uni_trans (@oldPw, asciiLen, csp_ascii,
      @newPw, uniLen, csp_unicode, [ ], uniError, errPos);
IF  uniError <> uni_ok
THEN
    e := e_not_trans_to_uni
ELSE
    s02encrypt (newPw, cryptPw); (* store new passwd *)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362UserrefRecord (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR recBuf : tgg00_Rec);
 
VAR
      b_err         : tgg00_BasisError;
      userrefRecPtr : ^tak_userrefrecord;
      userrefName   : tsp00_KnlIdentifier;
      sysBufPtr     : tak_sysbufferaddress;
      newkey        : tgg00_SysInfoKey;
 
BEGIN
b_err         := e_ok;
ak362expand_old_rec (recBuf, MGlob, b_err);
userrefRecPtr := @recBuf.recBuf_gg00[1];
sysBufPtr     :=  @recBuf.recBuf_gg00[1];
IF  b_err = e_ok
THEN
    BEGIN
    (* piece identifier together: *)
    userrefName   := a01_il_b_identifier;
    SAPDB_PascalForcedMove(
          sizeof (tgg00_RecBody), sizeof (tsp00_KnlIdentifier),
          @recBuf.recBody_gg00, 1,
          @userrefName, 1,
          sizeof(tgg00_Surrogate));
    SAPDB_PascalForcedMove(
          sizeof (tgg00_RecBody), sizeof (tsp00_KnlIdentifier),
          @recBuf.recBody_gg00, mxak_standard_sysk + 1,
          @userrefName, sizeof (tgg00_Surrogate) + 1,
          sizeof (tak_uref_restkey));
    ak362ConvertIdentifier (userrefName, b_err);
    (* build new key and insert record *)
    a51build_userkey (userrefName, newkey);
    ak362add_newkey_no_cache_sysinfo (acv, MGlob, newkey, recBuf,
          recBuf.recLen_gg00);
    END;
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362ViewtextRecord (
            VAR acv     : tak_all_command_glob;
            VAR MGlob   : tak362_MigrationGlob;
            VAR srcSysk : tgg00_SysInfoKey);
 
VAR
      b_err          : tgg00_BasisError;
      uniError       : tsp8_uni_error;
      convPos        : tsp00_Int4;
      convPosOffset  : tsp00_Int4;
      convLen        : tsp00_Int4;
      uniLen         : tsp00_Int4;
      dstStrtPos     : tsp00_Int4;
      errPos         : tsp00_Int4;
      srcBasePtr     : tak_sysbufferaddress;
      dstBasePtr     : tak_sysbufferaddress;
      dstSysk        : tgg00_SysInfoKey;
      oldRec         : tgg00_Rec;
 
BEGIN
b_err             := e_ok;
srcSysk.sentrytyp := cak_eviewtext;
dstSysk           := srcSysk;
dstSysk.slinkage  := cak_init_linkage;
&ifdef trace
b06check_rec := false;
&endif
b02get_record( acv.a_transinf.tri_trans, MGlob.oldCat1Id, srcSysk, oldRec );
&ifdef trace
b06check_rec := true;
&endif
srcBasePtr    := @oldRec.recBuf_gg00;
(* first record needs special treatment: *)
a10_nil_get_sysinfo (acv, dstSysk, d_release,
      sizeof (tak_viewtextrecord), dstBasePtr, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    convPosOffset := srcBasePtr^.sviewtext.vttabcount * sizeof (tak_vttabdef);
    (* copy record up to beginning of text *)
    SAPDB_PascalMove ('VAK362',  13,    
          srcBasePtr^.b_sl, sizeof (tak_viewtextrecord),
          @srcBasePtr^.ssysbuf, 1,
          @dstBasePtr^.ssysbuf, 1,
          sizeof (srcBasePtr^.sviewtext) - sizeof (tak_viewtext) + convPosOffset,
          b_err);
    (* put proper syskey into record (lost during copy) *)
    dstBasePtr^.sviewtext.vtsegno      := dstSysk.slinkage;
    dstBasePtr^.sviewtext.vttextlength := 0;
    dstBasePtr^.sviewtext.vtreclen     := sizeof (tak_viewtextrecord)
          - sizeof (tak_viewtext) + convPosOffset;
    dstStrtPos                         := convPosOffset + 1;
    END
ELSE
    acv.a_transinf.tri_trans.trError_gg00 := b_err;
(*ENDIF*) 
WHILE b_err = e_ok DO
    BEGIN
    convPos := 1;
    REPEAT
        IF  b_err = e_ok
        THEN
            BEGIN
            dstBasePtr^.sviewtext.vtfromtabcnt := srcBasePtr^.sviewtext.vtfromtabcnt;
            dstBasePtr^.sviewtext.vttabcount   := srcBasePtr^.sviewtext.vttabcount;
            dstBasePtr^.sviewtext.vtcontext    := srcBasePtr^.sviewtext.vtcontext;
            IF  dstSysk.slinkage > cak_init_linkage
            THEN (* only the first record contains entries in vttab *)
                dstBasePtr^.sviewtext.vttabcount := 0;
            (*ENDIF*) 
            IF  (srcBasePtr^.sviewtext.vttextlength -
                convPos) >
                ((mxak_viewtext-dstStrtPos) DIV 2)
            THEN
                BEGIN
                convLen := (mxak_viewtext - dstStrtPos + 1) DIV 2;
                uniLen  := 2 * convLen;
                dstBasePtr^.sviewtext.vtreclen    := sizeof (tak_viewtextrecord);
                dstBasePtr^.sviewtext.vtnextexist := true;
                END
            ELSE
                BEGIN
                convLen := srcBasePtr^.sviewtext.vttextlength - convPos + 1;
                uniLen  := convLen * 2;
                dstBasePtr^.sviewtext.vtreclen    :=
                      dstBasePtr^.sviewtext.vtreclen + uniLen;
                dstBasePtr^.sviewtext.vtnextexist := srcBasePtr^.sviewtext.vtnextexist;
                END;
            (*ENDIF*) 
            (* although we try to convert vtselect_pos properly, mistakes  *)
            (* here shouldn't matter as viewtexts will be overwritten once *)
            (* the view gets reconstructed                                 *)
            dstBasePtr^.sviewtext.vtselect_pos :=
                  dstBasePtr^.sviewtext.vtselect_pos
                  + (srcBasePtr^.sviewtext.vtselect_pos -
                  srcBasePtr^.sviewtext.vttabcount * mxak_vttabdef - 1);
            s80uni_trans (@srcBasePtr^.sviewtext.vttbuf[ convPos+convPosOffset ],
                  convLen, csp_ascii,
                  @dstBasePtr^.sviewtext.vttbuf[ dstStrtPos ], uniLen,
                  csp_unicode, [ ], uniError, errPos);
&           ifdef TRACE
            t01int4 (ak_sem, 'convLen     ', convLen);
            t01int4 (ak_sem, 'uniLen      ', uniLen);
            t01int4 (ak_sem, 'convPos     ', convPos);
            t01int4 (ak_sem, 'vttextlen   ',
                  srcBasePtr^.sviewtext.vttextlength);
            t01int4 (ak_sem, 'dstStrtPos  ', dstStrtPos);
&           endif
            IF  uniError <> uni_ok
            THEN
                b_err := e_not_trans_to_uni;
            (*ENDIF*) 
            dstStrtPos := dstStrtPos + uniLen;
            dstBasePtr^.sviewtext.vttextlength :=
                  dstBasePtr^.sviewtext.vttextlength + uniLen;
            IF  dstBasePtr^.sviewtext.vtreclen = sizeof (tak_viewtextrecord)
            THEN
                BEGIN (* record is full, save it *)
                dstBasePtr^.sviewtext.vttextlength := dstStrtPos
                      - dstBasePtr^.sviewtext.vttabcount * sizeof (tak_vttabdef) - 1;
                ak362add_new_sysinfo (acv, MGlob, dstBasePtr, b_err);
                (* remove from cache, otherwise ak362get_old_sysinfo might *)
                (* return this new info from the cache during the next     *)
                (* iteration                                               *)
                a10key_del (acv, dstBasePtr);
                a06inc_linkage (dstSysk.slinkage);
                a10_nil_get_sysinfo (acv, dstSysk, d_release,
                      sizeof (tak_viewtextrecord), dstBasePtr, b_err);
                IF  (b_err = e_ok) AND (acv.a_returncode = 0)
                THEN
                    BEGIN
                    dstStrtPos                         := 1;
                    dstBasePtr^.sviewtext.vttextlength := 0;
                    dstBasePtr^.sviewtext.vtreclen     := sizeof (tak_viewtextrecord)
                          - sizeof (tak_viewtext);
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        convPos  := convPos + convLen;
    UNTIL
        (convPos > srcBasePtr^.sviewtext.vttextlength) OR
        (b_err <> e_ok) OR (acv.a_returncode <> 0);
    (*ENDREPEAT*) 
    a06inc_linkage (srcSysk.slinkage);
&   ifdef trace
    b06check_rec := false;
&   endif
    b02get_record( acv.a_transinf.tri_trans, MGlob.oldCat1Id, srcSysk, oldRec );
    b_err         := acv.a_transinf.tri_trans.trError_gg00;
    convPosOffset := srcBasePtr^.sviewtext.vttabcount * sizeof (tak_vttabdef);
&   ifdef trace
    b06check_rec := true;
&   endif
    END;
(*ENDWHILE*) 
IF  acv.a_transinf.tri_trans.trError_gg00 = e_key_not_found
THEN
    BEGIN
    b_err            := e_ok;
    acv.a_returncode := 0;
    ak362add_new_sysinfo (acv, MGlob, dstBasePtr, b_err);
    a10key_del (acv, dstBasePtr);
    END
ELSE
    b_err := acv.a_transinf.tri_trans.trError_gg00;
(*ENDIF*) 
IF  (b_err <> e_ok) AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362StoreCreateViewStmt (
            VAR acv           : tak_all_command_glob;
            VAR MGlob         : tak362_MigrationGlob;
            VAR sysk          : tgg00_SysInfoKey;
            VAR ownerId       : tgg00_Surrogate;
            VAR schemaContext : tgg00_Surrogate;
            VAR e             : tgg00_BasisError);
 
VAR
      next_exist    : boolean;
      createStmtLen : tsp00_Int4;
      pViewText     : ^tak_viewtextrecord;
      Syskey        : tgg00_SysInfoKey;
      b             : tak362_Rec;
 
BEGIN
pViewText        := @b;
createStmtLen    := 0;
Syskey           := sysk;
Syskey.sentrytyp := cak_eviewtext;
REPEAT
    next_exist   := false;
&   ifdef trace
    b06check_rec := false;
&   endif
    b02get_record( acv.a_transinf.tri_trans, MGlob.oldCat1Id, Syskey, b.rec );
&   ifdef trace
    b06check_rec := true;
&   endif
    e := acv.a_transinf.tri_trans.trError_gg00;
    IF  e = e_ok
    THEN
        BEGIN
        next_exist := pViewText^.vtnextexist;
        IF  Syskey.slinkage = cak_init_linkage
        THEN
            BEGIN
            pViewText^.vttab[ 1 ].vtttableid  := ownerId;
            pViewText^.vttab[ 1 ].vttreftabid := schemaContext;
            END;
        (*ENDIF*) 
        b07cadd_record ( acv.a_transinf.tri_trans, MGlob.view_tree, b.rec );
        e := acv.a_transinf.tri_trans.trError_gg00;
        createStmtLen := createStmtLen + sizeof (tak_viewtext);
        a06inc_linkage( Syskey.slinkage );
        END;
    (*ENDIF*) 
UNTIL
    NOT next_exist OR ( e <> e_ok );
(*ENDREPEAT*) 
MGlob.cntViews := MGlob.cntViews + 1;
IF  createStmtLen > MGlob.maxCreateStmtLen
THEN
    MGlob.maxCreateStmtLen := createStmtLen;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362StoreCreateTriggerStmt (
            VAR acv    : tak_all_command_glob;
            VAR MGlob  : tak362_MigrationGlob;
            VAR sysk   : tgg00_SysInfoKey;
            context    : tsp00_Uint1;
            VAR e      : tgg00_BasisError);
 
VAR
      next_exist    : boolean;
      createStmtLen : tsp00_Int4;
      pViewText     : ^tak_viewtextrecord;
      Syskey        : tgg00_SysInfoKey;
      b             : tak362_Rec;
 
BEGIN
pViewText        := @b;
createStmtLen    := 0;
Syskey           := sysk;
Syskey.sentrytyp := cak_eviewtext;
REPEAT
    next_exist   := false;
&   ifdef trace
    b06check_rec := false;
    t01buf1 (ak_sem, Syskey, 1, Syskey.sreclen);
&   endif
    b02get_record( acv.a_transinf.tri_trans, MGlob.oldCat1Id, Syskey, b.rec );
&   ifdef trace
    b06check_rec := true;
    t01buf (ak_sem, b.rec.recBuf_gg00, 1, b.rec.recLen_gg00);
&   endif
    e := acv.a_transinf.tri_trans.trError_gg00;
    IF  e = e_ok
    THEN
        BEGIN
        IF  Syskey.slinkage[ 2 ] = chr (1)
        THEN
            pViewText^.vtcontext := context;
        (*ENDIF*) 
        next_exist := pViewText^.vtnextexist;
        b07cadd_record ( acv.a_transinf.tri_trans, MGlob.trigger_tree, b.rec );
        e := acv.a_transinf.tri_trans.trError_gg00;
        createStmtLen := createStmtLen + sizeof (tak_viewtext);
        a06inc_linkage( Syskey.slinkage );
        END;
    (*ENDIF*) 
UNTIL
    NOT next_exist OR ( e <> e_ok );
(*ENDREPEAT*) 
MGlob.cntTriggers := MGlob.cntTriggers + 1;
IF  createStmtLen > MGlob.maxCreateStmtLen
THEN
    MGlob.maxCreateStmtLen := createStmtLen;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362StoreCreateCommentStmt (
            VAR acv         : tak_all_command_glob;
            VAR MGlob       : tak362_MigrationGlob;
            VAR sysk        : tgg00_SysInfoKey;
            ownerId         : tgg00_Surrogate;
            schemaId        : tgg00_Surrogate;
            VAR tableName   : tsp00_KnlIdentifier;
            VAR commentOn   : tsp00_KnlIdentifier;
            VAR e           : tgg00_BasisError);
 
VAR
      linkSave      : tsp00_C2;
      createStmtLen : tsp00_Int4;
      saveSysk      : ^tgg00_SysInfoKey;
      Syskey        : tgg00_SysInfoKey;
      b             : tak362_commentInfo;
 
BEGIN
createStmtLen := 0;
saveSysk      := @b.rec;
Syskey        := sysk;
REPEAT
&   ifdef trace
    b06check_rec := false;
    t01buf1 (ak_sem, Syskey, 1, Syskey.sreclen);
&   endif
    b02get_record( acv.a_transinf.tri_trans, MGlob.oldCat2Id, Syskey, b.rec );
    e := acv.a_transinf.tri_trans.trError_gg00;
&   ifdef trace
    b06check_rec := true;
&   endif
    IF  e = e_ok
    THEN
        BEGIN
        (* ATTENTION !!! ATTENTION !!! ATTENTION !!! ATTENTION !!! ATTENTION *)
        (* to be able to retrieve the records in the correct order later on  *)
        (* swap column no (syskey.stablen[2] and syskey.stablen[3]) and      *)
        (* linkage in saved record                                           *)
        (* ATTENTION !!! ATTENTION !!! ATTENTION !!! ATTENTION !!! ATTENTION *)
        linkSave               := saveSysk^.slinkage;
        saveSysk^.slinkage[ 1 ] := saveSysk^.stablen[ 2 ];
        saveSysk^.slinkage[ 2 ] := saveSysk^.stablen[ 3 ];
        saveSysk^.stablen [ 2 ] := linkSave[ 1 ];
        saveSysk^.stablen [ 3 ] := linkSave[ 2 ];
        b07cadd_record ( acv.a_transinf.tri_trans, MGlob.comment_tree, b.rec );
        e := acv.a_transinf.tri_trans.trError_gg00;
        createStmtLen := createStmtLen + sizeof (tak_comment_record);
        a06inc_linkage( Syskey.slinkage );
        END;
    (*ENDIF*) 
UNTIL
    e <> e_ok ;
(*ENDREPEAT*) 
IF  e = e_key_not_found
THEN
    BEGIN
    e := e_ok;
    acv.a_transinf.tri_trans.trError_gg00 := e;
    END;
(*ENDIF*) 
IF  e = e_ok
THEN (* add extra record with information necessary to build 'comment on' *)
    (*  statement                                                         *)
    BEGIN
    linkSave[ 1 ]          := saveSysk^.stablen[ 2 ];
    linkSave[ 2 ]          := saveSysk^.stablen[ 3 ];
    a06inc_linkage (linkSave);
    saveSysk^.stablen [ 2 ] := linkSave[ 1 ];
    saveSysk^.stablen [ 3 ] := linkSave[ 2 ];
    b.ci_ownerId   := ownerId;
    b.ci_schemaId  := schemaId;
    b.ci_tableName := tableName;
    b.ci_commentOn := commentOn;
    b.rec.recLen_gg00 :=  sizeof (b.ci_header) + sizeof (b.ci_ownerId)
          + sizeof (b.ci_tableName) + sizeof (b.ci_commentOn);
    b07cadd_record ( acv.a_transinf.tri_trans, MGlob.comment_tree, b.rec );
    e := acv.a_transinf.tri_trans.trError_gg00;
    END;
(*ENDIF*) 
MGlob.cntComments := MGlob.cntComments + 1;
IF  createStmtLen > MGlob.maxCreateStmtLen
THEN
    MGlob.maxCreateStmtLen := createStmtLen;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362ReCreateViews (
            VAR acv   : tak_all_command_glob;
            VAR MGlob : tak362_MigrationGlob;
            size      : tsp00_Int4);
 
VAR
      b_err             : tgg00_BasisError;
      tabcount          : tsp00_Int2;
      m_type            : tgg00_MessType;
      uniError          : tsp8_uni_error;
      compType          : tak_appl_type;
      pos               : integer;
      move_len          : integer;
      schemaLen         : integer;
      selectStart       : integer;
      cnt               : tsp00_Int4;
      uniLen            : tsp00_Int4;
      errPos            : tsp00_Int4;
      msgTime           : tsp00_Int4;
      curTime           : tsp00_Int4;
      set_result        : tgg00_BdSetResultRecord;
      pKey              : ^tgg00_Lkey;
      pSyskey           : ^tgg00_SysInfoKey;
      pViewtext         : ^tak_viewtextrecord;
      recPtr            : ^tgg00_Rec;
      partPtr           : tsp1_part_ptr;
      segmPtr           : tsp1_segment_ptr;
      packetPtr         : tsp1_packet_ptr;
      tree_pos          : tgg00_FilePos;
      userInfo          : tak_user_info;
      oldTabId          : tgg00_Surrogate;
      userId            : tgg00_Surrogate;
      schemaId          : tgg00_Surrogate;
      create_or_replace : tsp00_C20;
      drop_view         : tsp00_C40;
      viewname          : tsp00_C40;
      msg               : tsp00_C40;
      pMsg              : ^tsp00_C40;
      migrationId       : tsp00_C64;
      userName          : tsp00_KnlIdentifier;
      _b                : tak362_Rec;
 
BEGIN
msg        := 'MIGRATING VIEWS                         ';
g01optextmsg (sp3p_console, sp3m_info, csp3_a362_migrate_ascii_to_uni,
      csp3_n_migration, msg);
g01opmsg (sp3p_console, sp3m_info,
      csp3_a362_migrate_ascii_to_uni,
      csp3_n_migration, '  VIEW COUNT            ',
      MGlob.cntViews);
migrationId := c_migrationId;
vtime_in_seconds (msgTime);
packetPtr  := acv.a_in_packet;
;
ak362set_unicode (MGlob);
;
IF  acv.a_returncode = 0
THEN
    BEGIN
    acv.a_in_packet^.sp1_header.sp1h_varpart_size :=
          size - sizeof( acv.a_cmd_packet_header );
    s26init_cmd_packet( acv.a_in_packet, segmPtr );
    sp100_GetSenderIDVersionP( acv.a_cmd_packet_header.sp1h_appl_version );
    segmPtr^.sp1s_segm_header.sp1c_parsing_again  := false;
    segmPtr^.sp1s_segm_header.sp1c_mess_type      := sp1m_dbs;
    segmPtr^.sp1s_segm_header.sp1c_producer       := sp1pr_installation;
    segmPtr^.sp1p_buf_size                        :=
          size - sizeof (tsp1_segment_header);
    acv.a_cmd_packet_header := acv.a_in_packet^.sp1_header;
    s26new_part_init (acv.a_in_packet, segmPtr^, partPtr);
    acv.a_cmd_part          := partPtr;
    partPtr^.sp1p_part_kind := sp1pk_command;
    partPtr^.sp1p_buf_len   := 0;
    acv.a_initial_segment_header.sp1c_producer := sp1pr_installation;
    acv.a_cmd_segm  := @acv.a_in_packet^.sp1_segm;
    pViewtext       := @_b;
    pKey            := @_b;
    pSyskey         := @_b;
    pKey^.len       := 0;
    WITH set_result DO
        BEGIN
        bd_key_check_len := 0;
        bd_max_rec_cnt   := 1;
        bd_max_fill_len  := sizeof( _b.rec.recBuf_gg00 );
        bd_next          := true;
        bd_drop_page     := false
        END;
    (*ENDWITH*) 
    acv.a_curr_user_id := cgg_zero_id;
    cnt                := 0;
    a10_cache_delete (acv, NOT c_is_rollback);
    REPEAT
        ;
        acv.a_cmd_part := partPtr;
        ;
        tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
        b07cnext_record( acv.a_transinf.tri_trans, MGlob.view_tree,
              pKey^, set_result, tree_pos, _b.rec.recBuf_gg00 );
        b_err := acv.a_transinf.tri_trans.trError_gg00;
        IF  ( b_err = e_ok ) OR ( b_err = e_key_not_found )
        THEN
            BEGIN
            b_err := e_ok;
            IF  pViewtext^.vtsegno = cak_init_linkage
            THEN
                BEGIN
                oldTabId               := pSyskey^.stableid;
                partPtr^.sp1p_buf_len := 0;
                IF  pViewtext^.vtcontext >= 30
                THEN
                    acv.a_sqlmode := sqlm_oracle
                ELSE
                    IF  pViewtext^.vtcontext >= 20
                    THEN
                        acv.a_sqlmode := sqlm_db2
                    ELSE
                        IF  pViewtext^.vtcontext >= 10
                        THEN
                            acv.a_sqlmode := sqlm_ansi
                        ELSE
                            acv.a_sqlmode := sqlm_internal;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                CASE pViewtext^.vtcontext MOD 10 OF
                    0 :
                        acv.a_dt_format := dtf_none;
                    1 :
                        acv.a_dt_format := dtf_normal;
                    2 :
                        acv.a_dt_format := dtf_iso;
                    3 :
                        acv.a_dt_format := dtf_usa;
                    4 :
                        acv.a_dt_format := dtf_eur;
                    5 :
                        acv.a_dt_format := dtf_jis;
                    6 :
                        acv.a_dt_format := dtf_oracle_date;
                    7 :
                        (* PTS 1112472 E.Z. *)
                        acv.a_dt_format := dtf_iso;
                    8 :
                        acv.a_dt_format := dtf_ts_eur;
                    9 :
                        acv.a_dt_format := dtf_future;
                    END;
                (*ENDCASE*) 
&               ifdef trace
                b06check_rec := false;
&               endif
                a06determine_username( acv,
                      pViewtext^.vttab[ 1 ].vtttableid,
                      userName );
                userId   := pViewtext^.vttab[ 1 ].vtttableid;
                schemaId := pViewtext^.vttab[ 1 ].vttreftabid;
                a362SetUserAndSchema (acv,
                      userName, userId,
                      schemaId,
                      userInfo);
&               ifdef trace
                b06check_rec := true;
&               endif
                END;
            (*ENDIF*) 
            tabcount := pViewtext^.vttabcount;
            pos := sizeof( pViewtext^ ) -
                  sizeof( pViewtext^.vttbuf ) +
                  tabcount * sizeof( pViewtext^.vttab[1] ) + 1;
            move_len := pViewtext^.vtreclen - pos + 1;
            IF  pViewtext^.vtsegno = cak_init_linkage
            THEN
                BEGIN
                selectStart := 0;
                WHILE (_b.rec.recBuf_gg00[ pos + selectStart ] in
                      ['\09','\20','\0A']) DO
                    (* skip whitespaces at beginning of statement *)
                    selectStart := succ (selectStart);
                (*ENDWHILE*) 
&               ifdef TRACE
                t01int4 (ak_sem, '_pos        ', pos);
                t01int4 (ak_sem, '_select_strt', selectStart);
&               endif
                (* remove keyword SELECT *)
                pos      := pos + 6 + selectStart;
                move_len := move_len - 6 - selectStart;
                ;
                create_or_replace := 'CREATE OR REPLACE   ';
                uniLen := 2 * sizeof(create_or_replace);
                IF  (uniLen + partPtr^.sp1p_buf_len+1)
                    > partPtr^.sp1p_buf_size
                THEN
                    b_err := e_too_small_packet_size;
                (*ENDIF*) 
                s80uni_trans (@create_or_replace, sizeof (create_or_replace),
                      csp_ascii,
                      @partPtr^.sp1p_buf[ partPtr^.sp1p_buf_len+1 ],
                      uniLen, csp_unicode, [ ], uniError, errPos);
                partPtr^.sp1p_buf_len := partPtr^.sp1p_buf_len + uniLen;
                IF  uniError <> uni_ok
                THEN
                    b_err := e_not_trans_to_uni;
                (* store start of create view statement *)
                (*ENDIF*) 
                msg      := '                                        ';
                viewname := '                                        ';
                SAPDB_PascalMove ('VAK362',  14,    
                      sizeof (tgg00_Rec), sizeof (viewname),
                      @_b.rec.recBuf_gg00, pos,
                      @viewname, 1,
                      sizeof (viewname),
                      b_err);
&               ifdef TRACE
                g01optextmsg (sp3p_console, sp3m_info, cnt,
                      csp3_n_migration, viewname);
&               endif
                END;
            (*ENDIF*) 
            uniLen := 2*move_len;
            IF  (uniLen + partPtr^.sp1p_buf_len+1) > partPtr^.sp1p_buf_size
            THEN
                b_err := e_too_small_packet_size;
            (*ENDIF*) 
            s80uni_trans (@_b.rec.recBuf_gg00[ pos ], move_len,
                  csp_ascii,
                  @partPtr^.sp1p_buf[ partPtr^.sp1p_buf_len+1 ], uniLen,
                  csp_unicode, [ ], uniError, errPos);
            partPtr^.sp1p_buf_len := partPtr^.sp1p_buf_len + uniLen;
&           ifdef TRACE
            t01buf (ak_sem, _b.rec.recBuf_gg00, 1, _b.rec.recLen_gg00);
            t01int4 (ak_sem, 'pos         ', pos);
            t01int4 (ak_sem, 'uniLen      ', uniLen);
            t01int4 (ak_sem, 'dst_pos     ', partPtr^.sp1p_buf_len+1);
            recPtr := @partPtr^.sp1p_buf;
            t01buf (ak_sem, recPtr^.recBuf_gg00, 1, partPtr^.sp1p_buf_len);
&           endif
            IF  uniError <> uni_ok
            THEN
                b_err := e_not_trans_to_uni;
            (*ENDIF*) 
            IF  (NOT  pViewtext^.vtnextexist) AND (b_err = e_ok)
            THEN
                BEGIN
                s26finish_part( acv.a_in_packet, partPtr^ );
&               ifdef TRACE
                t01int4 (ak_sem, 'sqlMode     ', ord(acv.a_sqlmode));
&               endif
                a10_cache_delete (acv, NOT c_is_rollback);
                a52new_subtrans (acv, a01_il_b_identifier);
                acv.a_p_arr1.pcount := -1;
                a35_asql_statement (acv);
                IF  (acv.a_returncode <> 0) AND (acv.a_p_arr1.pcount = -1)
                THEN
                    BEGIN
                    (* if a_p_arr1.pcount ist still -1, a syntax error must have been occurred. Try with odbc syntax *)
                    acv.a_returncode := 0;
                    uniLen := 2 * sizeof(create_or_replace);
                    s80uni_trans (@create_or_replace, sizeof (create_or_replace),
                          csp_ascii,
                          @partPtr^.sp1p_buf[ 1 ],
                          uniLen, csp_unicode, [ ], uniError, errPos);
                    compType         := acv.a_comp_type;
                    acv.a_comp_type  := at_odbc;
                    a35_asql_statement( acv );
                    acv.a_comp_type := compType;
                    END;
                (*ENDIF*) 
                cnt     := cnt + 1;
                b_err   := acv.a_returncode;
                errPos  := acv.a_errorpos;
                IF  acv.a_returncode = 0
                THEN
                    BEGIN
                    m_type := m_end;
                    END
                ELSE
                    m_type := m_rollback;
                (*ENDIF*) 
                acv.a_returncode := 0;
                a52end_rollback_subtrans( acv, a01_il_b_identifier,
                      m_type );
                IF  b_err <> 0
                THEN
                    BEGIN
                    (* PTS 1129464 M.Ki. *)
                    acv.a_cmd_part := partPtr;
                    move_len       := s30unilnr (@acv.a_curr_user_name,
                          csp_unicode_blank, 1,
                          sizeof (acv.a_curr_user_name));
                    schemaLen      := s30unilnr (@acv.a_curr_schema,
                          csp_unicode_blank, 1,
                          sizeof (acv.a_curr_schema));
                    a361WriteProt( acv, MGlob.prot_tree, migrationId,
                          c_migrationIdLength,
                          acv.a_curr_schema, schemaLen,
                          acv.a_curr_user_name, move_len,
                          c_unicodeText, b_err, errPos);
                    IF  acv.a_returncode = 0
                    THEN
                        BEGIN
                        pSyskey^.sentrytyp[ 1 ] := chr( 255 ); (* skip all of this view *)
                        (* reinitialize user info *)
                        a362SetUserAndSchema (acv,
                              userName, userId, schemaId, userInfo);
                        (*-------------------------------------------------*)
                        (* try to drop the view now                        *)
                        (*-------------------------------------------------*)
                        partPtr^.sp1p_buf_len := 0;
                        drop_view := '\00D\00R\00O\00P\00 \00V\00I\00E\00W\00 \00 \00 \00 \00 \00 \00 \00 \00 \00 \00"';
                        SAPDB_PascalMove ('VAK362',  15,    
                              sizeof(drop_view), partPtr^.sp1p_buf_size,
                              @drop_view, 1,
                              @partPtr^.sp1p_buf, partPtr^.sp1p_buf_len + 1,
                              sizeof(drop_view), acv.a_returncode);
                        partPtr^.sp1p_buf_len :=
                              partPtr^.sp1p_buf_len + sizeof(drop_view);
                        SAPDB_PascalMove ('VAK362',  16,    
                              sizeof(acv.a_viewname), partPtr^.sp1p_buf_size,
                              @acv.a_viewname, 1,
                              @partPtr^.sp1p_buf, partPtr^.sp1p_buf_len + 1,
                              sizeof(acv.a_viewname), acv.a_returncode);
                        partPtr^.sp1p_buf_len :=
                              partPtr^.sp1p_buf_len
                              + s30unilnr (@acv.a_viewname,
                              csp_unicode_blank, 1,
                              sizeof (acv.a_viewname))
                              + 2;
                        partPtr^.sp1p_buf [partPtr^.sp1p_buf_len-1] := '\00';
                        partPtr^.sp1p_buf [partPtr^.sp1p_buf_len  ] := '"';
                        s26finish_part( acv.a_in_packet, partPtr^ );
                        a52new_subtrans( acv, a01_il_b_identifier );
                        acv.a_internal_sql := sql_restore_schema; (* PTS 1117920 M.Ki. *)
                        a35_asql_statement( acv );
                        b_err := acv.a_returncode;
                        IF  (b_err = 0) OR (b_err = -4004) OR (b_err = -942)
                        THEN
                            BEGIN
                            msg    := 'DROPPED VIEW :                          ';
                            m_type := m_end;
                            g01optextmsg (sp3p_console, sp3m_error,
                                  csp3_a361_no_direct_migration,
                                  csp3_n_migration, msg);
                            g01optextmsg (sp3p_console, sp3m_error,
                                  csp3_a361_no_direct_migration,
                                  csp3_n_migration, viewname);
                            END
                        ELSE
                            BEGIN
                            msg    := 'COULD NOT DROP VIEW :                   ';
                            g17int4to_line (b_err, false, 5, 22, msg);
                            m_type := m_rollback;
                            g01optextmsg (sp3p_console, sp3m_error, csp3_a361_no_direct_migration,
                                  csp3_n_migration, msg);
                            g01optextmsg (sp3p_console, sp3m_error, csp3_a361_no_direct_migration,
                                  csp3_n_migration, viewname);
                            END;
                        (*ENDIF*) 
                        acv.a_returncode := 0;
                        END
                    ELSE
                        BEGIN
                        msg    := 'WRITING PROTOCOL ENTRY FAILED FOR:      ';
                        g01optextmsg (sp3p_console, sp3m_error,
                              csp3_a361_no_direct_migration,
                              csp3_n_migration, msg);
                        g01optextmsg (sp3p_console, sp3m_error,
                              csp3_a361_no_direct_migration,
                              csp3_n_migration, viewname);
                        acv.a_returncode := b_err;
                        END;
                    (*ENDIF*) 
                    pMsg := @acv.a_viewname;
                    g01optextmsg (sp3p_console, sp3m_info,
                          csp3_a362_migrate_ascii_to_uni,
                          csp3_n_migration, pMsg^);
                    b_err := e_ok;
                    a52end_rollback_subtrans( acv, a01_il_b_identifier,
                          m_type );
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  ( b_err = e_ok ) OR ( acv.a_returncode = 0 )
        THEN
            BEGIN
            vtime_in_seconds (curTime);
            IF  (curTime - msgTime) >= c_feedback_interval
            THEN
                BEGIN
                msgTime := curTime;
                g01opmsg (sp3p_console, sp3m_info,
                      csp3_a362_migrate_ascii_to_uni,
                      csp3_n_migration, '  VIEWS MIGRATED SO FAR ',
                      cnt);
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    UNTIL
        ( b_err <> e_ok ) OR ( acv.a_returncode <> 0 );
    (*ENDREPEAT*) 
    IF  b_err <> e_no_next_record
    THEN
        BEGIN
        g01optextmsg (sp3p_console, sp3m_error,
              csp3_a362_migrate_ascii_to_uni, csp3_n_migration,
              'ERROR WHEN RECREATING VIEW:             ');
        g01optextmsg (sp3p_console, sp3m_error, csp3_a362_migrate_ascii_to_uni,
              csp3_n_migration, viewname);
        IF  acv.a_returncode = 0
        THEN
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
acv.a_in_packet := packetPtr;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362ReCreateTriggers (
            VAR acv   : tak_all_command_glob;
            VAR MGlob : tak362_MigrationGlob ;
            size      : tsp00_Int4);
 
CONST
      c_trigger_err = 'MIGRATION FAILED FOR TRIGGER:           ';
      c_dbproc_err  = 'MIGRATION FAILED FOR DB PROC:           ';
      c_name        = ' name :                                 ';
      c_owner       = ' owner:                                 ';
      c_offset      = 8;
 
VAR
      retry             : boolean;
      isTrigger         : boolean;
      ignoreError       : boolean;
      isMultiTriggerTab : boolean;
      b_err             : tgg00_BasisError;
      uniError          : tsp8_uni_error;
      m_type            : tgg00_MessType;
      triggerLinkage    : tsp00_C2;
      retCode           : integer;
      pos               : integer;
      move_len          : integer;
      schemaLen         : integer;
      selectStart       : integer;
      cnt               : tsp00_Int4;
      uniLen            : tsp00_Int4;
      errPos            : tsp00_Int4;
      msgTime           : tsp00_Int4;
      curTime           : tsp00_Int4;
      set_result        : tgg00_BdSetResultRecord;
      tree_pos          : tgg00_FilePos;
      pKey              : ^tgg00_Lkey;
      pSyskey           : ^tgg00_SysInfoKey;
      moveObjPtr        : tsp00_MoveObjPtr;
      tabSysBufPtr      : tak_sysbufferaddress;
      pViewtext         : ^tak_viewtextrecord;
      recPtr            : ^tgg00_Rec;
      partPtr           : tsp1_part_ptr;
      segmPtr           : tsp1_segment_ptr;
      packetPtr         : tsp1_packet_ptr;
      ownerId           : tgg00_Surrogate;
      schemaId          : tgg00_Surrogate;
      lastTriggerTab    : tgg00_Surrogate;
      tabSysk           : tgg00_SysInfoKey;
      userInfo          : tak_user_info;
      create_or_replace : tsp00_C20;
      msg               : tsp00_C40;
      triggerName       : tsp00_KnlIdentifier;
      triggerTable      : tsp00_KnlIdentifier;
      triggerOwner      : tsp00_KnlIdentifier;
      triggerOwner_u    : tsp00_KnlIdentifier;
      migrationId       : tsp00_C64;
      triggerSysk       : tgg00_SysInfoKey;
      _b                : tak362_Rec;
 
BEGIN
msg        := 'MIGRATING TRIGGERS AND DB PROCS         ';
g01optextmsg (sp3p_console, sp3m_info, csp3_a362_migrate_ascii_to_uni,
      csp3_n_migration, msg);
g01opmsg (sp3p_console, sp3m_info,
      csp3_a362_migrate_ascii_to_uni,
      csp3_n_migration, '  DB-PROC/TRIGGER COUNT ',
      MGlob.cntTriggers);
migrationId := c_migrationId;
vtime_in_seconds (msgTime);
packetPtr      := acv.a_in_packet;
;
ak362set_unicode (MGlob);
;
(* triggers need to be built in online mode *)
(* (otherwise we'll get an error)                 *)
gg999SetKernelStateOnline;
lastTriggerTab := cgg_zero_id;
;
IF  acv.a_returncode = 0
THEN
    BEGIN
    acv.a_in_packet^.sp1_header.sp1h_varpart_size :=
          size - sizeof( acv.a_cmd_packet_header );
    s26init_cmd_packet( acv.a_in_packet, segmPtr );
    sp100_GetSenderIDVersionP( acv.a_cmd_packet_header.sp1h_appl_version );
    segmPtr^.sp1s_segm_header.sp1c_parsing_again := false;
    segmPtr^.sp1s_segm_header.sp1c_mess_type     := sp1m_dbs;
    segmPtr^.sp1s_segm_header.sp1c_producer      := sp1pr_installation;
    segmPtr^.sp1p_buf_size  := size - sizeof (tsp1_segment_header);
    acv.a_cmd_packet_header := acv.a_in_packet^.sp1_header;
    s26new_part_init (acv.a_in_packet, segmPtr^, partPtr);
    acv.a_cmd_part          := partPtr;
    partPtr^.sp1p_part_kind := sp1pk_command;
    partPtr^.sp1p_buf_len   := 0;
    acv.a_initial_segment_header.sp1c_producer := sp1pr_installation;
    acv.a_cmd_segm := @acv.a_in_packet^.sp1_segm;
    pViewtext      := @_b;
    pKey           := @_b;
    pSyskey        := @_b;
    pKey^.len      := 0;
    WITH set_result DO
        BEGIN
        bd_key_check_len := 0;
        bd_max_rec_cnt   := 1;
        bd_max_fill_len  := sizeof( _b.rec.recBuf_gg00 );
        bd_next          := true;
        bd_drop_page     := false
        END;
    (*ENDWITH*) 
    acv.a_curr_user_id := cgg_zero_id;
    cnt                := 0;
    REPEAT
        acv.a_cmd_part := partPtr;
        ;
        tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
        b07cnext_record( acv.a_transinf.tri_trans, MGlob.trigger_tree,
              pKey^, set_result, tree_pos, _b.rec.recBuf_gg00 );
        b_err := acv.a_transinf.tri_trans.trError_gg00;
        IF  ( b_err = e_ok ) OR ( b_err = e_key_not_found )
        THEN
            BEGIN
            b_err := e_ok;
            IF  pViewtext^.vtsegno[ 2 ] = chr (1)
            THEN
                BEGIN
                (* get table this trigger belongs to to determine owner *)
                tabSysk           := pSyskey^;
                tabSysk.sentrytyp := cak_etable;
                tabSysk.slinkage  := cak_init_linkage;
                a10get_sysinfo (acv, tabSysk, d_release, tabSysBufPtr, b_err );
                isTrigger := (b_err = e_ok)     AND
                      (tabSysBufPtr^.sbase.btablekind in [twithkey, twithoutkey]);
                isMultiTriggerTab := false;
                IF  isTrigger
                THEN
                    BEGIN
                    (* PTS 1134069 M.Ki. *)
                    IF  lastTriggerTab = tabSysk.stableid
                    THEN
                        isMultiTriggerTab := true;
                    (*ENDIF*) 
                    lastTriggerTab := tabSysk.stableid;
                    (* *)
                    ownerId     := tabSysBufPtr^.sbase.bauthid;
                    schemaId    := tabSysBufPtr^.sbase.bschemacontext;
                    (* store trigger key and name in case of error: *)
                    triggerSysk               := pSyskey^;
                    triggerSysk.sentrytyp     := cak_etrigger;
                    triggerSysk.slinkage      := cak_init_linkage;
                    triggerSysk.slinkage[ 2 ] := chr (255 -
                          ord (pSyskey^.slinkage[ 1 ]));
                    uniLen       := sizeof(triggerTable);
                    triggerTable := bsp_c64;
                    s80uni_trans (@tabSysBufPtr^.sbase.btablen^,
                          sizeof (tabSysBufPtr^.sbase.btablen^),
                          csp_unicode,
                          @triggerTable[1], uniLen,
                          csp_ascii, [ ], uniError, errPos);
                    END
                ELSE (* must have been a db_proc *)
                    BEGIN
                    b_err             := e_ok;
                    isTrigger         := false;
                    tabSysk           := pSyskey^;
                    tabSysk.sentrytyp := cak_emethodinfo;
                    tabSysk.slinkage  := cak_init_linkage;
                    ak362get_old_sysinfo (acv, MGlob, tabSysk,
                          d_release, tabSysBufPtr, b_err );
                    IF  b_err = e_ok
                    THEN
                        BEGIN
                        ownerId  := tabSysBufPtr^.smethodinfo.mei_owner;
                        schemaId := tabSysBufPtr^.smethodinfo.mei_schema;
                        SAPDB_PascalForcedMove(
                              sizeof (tabSysBufPtr^.smethodinfo.mei_name),
                              sizeof(triggerName),
                              @tabSysBufPtr^.smethodinfo.mei_name, 1,
                              @triggerName, 1,
                              sizeof (triggerName));
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                partPtr^.sp1p_buf_len := 0;
                IF  pViewtext^.vtcontext >= 30
                THEN
                    acv.a_sqlmode := sqlm_oracle
                ELSE
                    IF  pViewtext^.vtcontext >= 20
                    THEN
                        acv.a_sqlmode := sqlm_db2
                    ELSE
                        IF  pViewtext^.vtcontext >= 10
                        THEN
                            acv.a_sqlmode := sqlm_ansi
                        ELSE
                            acv.a_sqlmode := sqlm_internal;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                CASE pViewtext^.vtcontext MOD 10 OF
                    0 :
                        acv.a_dt_format := dtf_none;
                    1 :
                        acv.a_dt_format := dtf_normal;
                    2 :
                        acv.a_dt_format := dtf_iso;
                    3 :
                        acv.a_dt_format := dtf_usa;
                    4 :
                        acv.a_dt_format := dtf_eur;
                    5 :
                        acv.a_dt_format := dtf_jis;
                    6 :
                        acv.a_dt_format := dtf_oracle_date;
                    7 :
                        (* PTS 1112472 E.Z. *)
                        acv.a_dt_format := dtf_iso;
                    8 :
                        acv.a_dt_format := dtf_ts_eur;
                    9 :
                        acv.a_dt_format := dtf_future;
                    END;
                (*ENDCASE*) 
&               ifdef trace
                b06check_rec := false;
&               endif
                a06determine_username (acv,
                      ownerId,
                      acv.a_curr_user_name);
                a362SetUserAndSchema (acv,
                      acv.a_curr_user_name,
                      ownerId, schemaId, userInfo);
&               ifdef trace
                b06check_rec := true;
&               endif
                END;
            (* save owner name in case of error: *)
            (*ENDIF*) 
            uniLen := sizeof(triggerOwner);
            s80uni_trans (@acv.a_curr_user_name,
                  sizeof (acv.a_curr_user_name),
                  csp_unicode,
                  @triggerOwner[1], uniLen,
                  csp_ascii, [ ], uniError, errPos);
            pos      := sizeof (pViewtext^) - sizeof (pViewtext^.vttbuf) + 1;
            move_len := pViewtext^.vtreclen - pos + 1;
            IF  pViewtext^.vtsegno[ 2 ] = chr (1)
            THEN
                BEGIN
                selectStart := 0;
                WHILE (_b.rec.recBuf_gg00[ pos + selectStart ] in
                      ['\09','\20','\0A']) DO
                    (* skip whitespaces at beginning of statement *)
                    selectStart := succ (selectStart);
                (*ENDWHILE*) 
&               ifdef TRACE
                t01int4 (ak_sem, '_pos        ', pos);
                t01int4 (ak_sem, '_select_strt', selectStart);
&               endif
                (* remove keyword SELECT *)
                pos      := pos + 6 + selectStart;
                move_len := move_len - 6 - selectStart;
                ;
                create_or_replace := 'CREATE              ';
                uniLen := 2 * sizeof(create_or_replace);
                IF  (uniLen + partPtr^.sp1p_buf_len+1)
                    > partPtr^.sp1p_buf_size
                THEN
                    b_err := e_too_small_packet_size;
                (*ENDIF*) 
                s80uni_trans (@create_or_replace, sizeof (create_or_replace),
                      csp_ascii,
                      @partPtr^.sp1p_buf[ partPtr^.sp1p_buf_len+1 ],
                      uniLen, csp_unicode, [ ], uniError, errPos);
                partPtr^.sp1p_buf_len := partPtr^.sp1p_buf_len + uniLen;
                IF  uniError <> uni_ok
                THEN
                    b_err := e_not_trans_to_uni;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            uniLen := 2*move_len;
            IF  (uniLen + partPtr^.sp1p_buf_len+1) > partPtr^.sp1p_buf_size
            THEN
                b_err := e_too_small_packet_size;
            (*ENDIF*) 
            s80uni_trans (@_b.rec.recBuf_gg00[ pos ], move_len,
                  csp_ascii,
                  @partPtr^.sp1p_buf[ partPtr^.sp1p_buf_len+1 ], uniLen,
                  csp_unicode, [ ], uniError, errPos);
            partPtr^.sp1p_buf_len := partPtr^.sp1p_buf_len +
                  uniLen;
&           ifdef TRACE
            t01buf (ak_sem, _b.rec.recBuf_gg00, 1, _b.rec.recLen_gg00);
            recPtr := @partPtr^.sp1p_buf;
            t01buf (ak_sem, recPtr^.recBuf_gg00, 1, partPtr^.sp1p_buf_len);
&           endif
            IF  uniError <> uni_ok
            THEN
                b_err := e_not_trans_to_uni;
            (*ENDIF*) 
            IF  (NOT  pViewtext^.vtnextexist) AND (b_err = e_ok)
            THEN
                BEGIN
                s26finish_part( acv.a_in_packet, partPtr^ );
                a10_cache_delete( acv, NOT c_is_rollback );
&               ifdef TRACE
                t01int4 (ak_sem, 'sqlMode     ', ord(acv.a_sqlmode));
&               endif
                REPEAT
                    retry := false;
                    a52new_subtrans( acv, a01_il_b_identifier );
                    a35_asql_statement( acv );
                    acv.a_initial_segment_header.sp1c_producer :=
                          sp1pr_installation;
                    (* PTS 1127315 M.Ki. *)
                    retCode := acv.a_returncode;
                    IF  retCode = 0
                    THEN
                        BEGIN
                        m_type := m_end;
                        END
                    ELSE
                        m_type := m_rollback;
                    (*ENDIF*) 
                    acv.a_returncode := 0;
                    a52end_rollback_subtrans( acv, a01_il_b_identifier,
                          m_type );
                    IF  (retCode <> 0) AND NOT isTrigger AND
                        (acv.a_sqlmode = sqlm_oracle)
                    THEN
                        BEGIN
&                       ifdef TRACE
                        g01optextmsg (sp3p_console, sp3m_info,
                              csp3_a362_migrate_ascii_to_uni,
                              csp3_n_migration,
                              'Retrying CREATE DBPROC for              ');
                        msg := c_name;
                        SAPDB_PascalForcedMove(
                              sizeof (triggerName),
                              sizeof (msg),
                              @triggerName, 1,
                              @msg, c_offset,
                              sizeof (msg) - c_offset);
                        g01optextmsg (sp3p_console, sp3m_info,
                              csp3_a362_migrate_ascii_to_uni,
                              csp3_n_migration, msg);
                        msg := c_owner;
                        SAPDB_PascalForcedMove(
                              sizeof (triggerOwner),
                              sizeof (msg),
                              @triggerOwner, 1,
                              @msg, c_offset,
                              sizeof (msg) - c_offset);
                        g01optextmsg (sp3p_console, sp3m_info,
                              csp3_a362_migrate_ascii_to_uni,
                              csp3_n_migration, msg);
&                       endif
                        acv.a_cmd_part := partPtr; (* PTS 1130888 M.Ki. *)
                        acv.a_sqlmode  := sqlm_internal;
                        retry          := true;
                        END;
                    (*ENDIF*) 
                UNTIL
                    retry = false;
                (*ENDREPEAT*) 
                cnt     := cnt + 1;
                acv.a_returncode := 0;
                IF  retCode <> 0
                THEN
                    BEGIN
                    acv.a_cmd_part := partPtr;
                    IF  isTrigger
                    THEN
                        BEGIN
                        (* ignoreError will be set to true later on *)
                        (* if substitute trigger could be created   *)
                        ignoreError := false;
                        b_err       := e_ok;
                        ak362get_old_sysinfo (acv, MGlob, triggerSysk,
                              d_release, tabSysBufPtr, b_err );
                        IF  b_err = e_ok
                        THEN
                            BEGIN
                            triggerLinkage := tabSysBufPtr^.strigger.tr_linkage;
                            triggerName    := bsp_c64;
                            (* get trigger name *)
                            SAPDB_PascalMove ('VAK362',  17,    
                                  sizeof (tabSysBufPtr^.strigger.tr_name),
                                  sizeof (triggerName),
                                  @tabSysBufPtr^.strigger.tr_name, 1,
                                  @triggerName, 1,
                                  tabSysBufPtr^.strigger.tr_name_len,
                                  b_err);
                            (* write error to knldiag.err *)
                            g01optextmsg (sp3p_console, sp3m_error,
                                  csp3_a362_migrate_ascii_to_uni,
                                  csp3_n_migration, c_trigger_err);
                            ak362DumpProcInfo (
                                  isTrigger,
                                  triggerName,
                                  triggerLinkage,
                                  triggerTable,
                                  triggerOwner);
                            END;
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        ignoreError := true;
                        g01optextmsg (sp3p_console, sp3m_error,
                              csp3_a362_migrate_ascii_to_uni,
                              csp3_n_migration, c_dbproc_err);
                        triggerLinkage := '\00\00';
                        ak362DumpProcInfo (
                              isTrigger,
                              triggerName,
                              triggerLinkage,
                              triggerTable,
                              triggerOwner);
                        END;
                    (*ENDIF*) 
                    (* translate triggerOwner to unicode for protocol table *)
                    FOR pos := sizeof(triggerOwner) DIV 2 DOWNTO 1 DO
                        BEGIN
                        triggerOwner_u[ 2*pos   ] := triggerOwner[ pos ];
                        triggerOwner_u[ 2*pos-1 ] := chr(0);
                        END;
                    (*ENDFOR*) 
                    moveObjPtr := @triggerOwner_u;
                    move_len   := s30unilnr (moveObjPtr,
                          csp_unicode_blank, 1,
                          sizeof (triggerOwner_u));
                    schemaLen  := s30unilnr (@acv.a_curr_schema,
                          csp_unicode_blank, 1,
                          sizeof (acv.a_curr_schema));
                    a361WriteProt (acv, MGlob.prot_tree, migrationId,
                          c_migrationIdLength,
                          acv.a_curr_schema, schemaLen,
                          triggerOwner_u, move_len,
                          c_unicodeText, retCode, errPos);
                    IF  acv.a_returncode <> 0
                    THEN
                        BEGIN
                        ignoreError := false;
                        msg    := 'WRITING PROTOCOL ENTRY FAILED FOR:      ';
                        g01optextmsg (sp3p_console, sp3m_error,
                              csp3_a361_no_direct_migration,
                              csp3_n_migration, msg);
                        ak362DumpProcInfo (
                              isTrigger,
                              triggerName,
                              triggerLinkage,
                              triggerTable,
                              triggerOwner);
                        END;
                    (*ENDIF*) 
                    IF  isTrigger AND (b_err = e_ok)
                        AND (acv.a_returncode = 0)
                    THEN (* PTS 1129464 M.Ki. *)
                        BEGIN
                        (* substitute trigger can only be created *after* *)
                        (* the protocol entry has been written since it   *)
                        (* will reinitialize acv.a_cmd_part               *)
                        IF  isMultiTriggerTab
                            AND ((retCode = -6006) OR (retCode = -955))
                        THEN
                            ignoreError := true
                        ELSE
                            ak362CreateTriggerSubstitute (
                                  acv,
                                  triggerName,
                                  triggerLinkage,
                                  triggerTable, triggerOwner,
                                  ownerId, schemaId, ignoreError);
                        (*ENDIF*) 
                        IF  NOT ignoreError
                        THEN
                            BEGIN
                            msg    := 'CREATION OF SUBSTITUTE TRIGGER FAILED:  ';
                            g01optextmsg (sp3p_console, sp3m_error,
                                  csp3_a361_no_direct_migration,
                                  csp3_n_migration, msg);
                            ak362DumpProcInfo (
                                  isTrigger,
                                  triggerName,
                                  triggerLinkage,
                                  triggerTable,
                                  triggerOwner);
                            END;
                        (*ENDIF*) 
                        END;
                    (* PTS 1129210 M.Ki. *)
                    (*ENDIF*) 
                    msg := ' error code:                            ';
                    g17int4to_line (retCode, false, 5, 14, msg);
                    g01optextmsg (sp3p_console, sp3m_error,
                          csp3_a362_migrate_ascii_to_uni,
                          csp3_n_migration, msg);
                    IF  NOT ignoreError
                    THEN
                        acv.a_returncode := retCode;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  ( b_err = e_ok ) OR ( acv.a_returncode = 0 )
        THEN
            BEGIN
            vtime_in_seconds (curTime);
            IF  (curTime - msgTime) >= c_feedback_interval
            THEN
                BEGIN
                msgTime := curTime;
                g01opmsg (sp3p_console, sp3m_info,
                      csp3_a362_migrate_ascii_to_uni,
                      csp3_n_migration, '  DB-PR. MIGRATED       ',
                      cnt-1);
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    UNTIL
        ( b_err <> e_ok ) OR ( acv.a_returncode <> 0 );
    (*ENDREPEAT*) 
    IF  b_err <> e_no_next_record
    THEN
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
    END;
(* restore usemode *)
(*ENDIF*) 
acv.a_in_packet := packetPtr;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362ReCreateComments (
            VAR acv   : tak_all_command_glob;
            VAR MGlob : tak362_MigrationGlob;
            size      : tsp00_Int4);
 
CONST
      c_commentOnLength = 105;
 
VAR
      commentType   : tak_comment_type;
      pos           : integer;
      move_len      : integer;
      ix            : integer;
      cnt           : tsp00_Int4;
      commentPos    : tsp00_Int4;
      commentLen    : tsp00_Int4;
      uniLen        : tsp00_Int4;
      msgTime       : tsp00_Int4;
      curTime       : tsp00_Int4;
      m_type        : tgg00_MessType;
      b_err         : tgg00_BasisError;
      set_result    : tgg00_BdSetResultRecord;
      tree_pos      : tgg00_FilePos;
      _b            : tak362_commentInfo;
      moveObjPtr1   : tsp00_MoveObjPtr;
      moveObjPtr2   : tsp00_MoveObjPtr;
      partPtr       : tsp1_part_ptr;
      segmPtr       : tsp1_segment_ptr;
      packetPtr     : tsp1_packet_ptr;
      pKey          : ^tgg00_Lkey;
      pSyskey       : ^tgg00_SysInfoKey;
      commentRecPtr : ^tgg00_Rec;
      userInfo      : tak_user_info;
      msg           : tsp00_C40;
      commentname   : tsp00_C80;
 
BEGIN
msg        := 'MIGRATING COMMENTS                      ';
g01optextmsg (sp3p_console, sp3m_info, csp3_a362_migrate_ascii_to_uni,
      csp3_n_migration, msg);
g01opmsg (sp3p_console, sp3m_info,
      csp3_a362_migrate_ascii_to_uni,
      csp3_n_migration, '  COMMENT COUNT         ',
      MGlob.cntComments);
vtime_in_seconds (msgTime);
packetPtr := acv.a_in_packet;
;
ak362set_unicode (MGlob);
;
IF  acv.a_returncode = 0
THEN
    BEGIN
    acv.a_in_packet^.sp1_header.sp1h_varpart_size :=
          size - sizeof( acv.a_cmd_packet_header );
    s26init_cmd_packet( acv.a_in_packet, segmPtr );
    sp100_GetSenderIDVersionP( acv.a_cmd_packet_header.sp1h_appl_version );
    segmPtr^.sp1s_segm_header.sp1c_parsing_again := false;
    segmPtr^.sp1s_segm_header.sp1c_mess_type     := sp1m_dbs;
    segmPtr^.sp1s_segm_header.sp1c_producer      := sp1pr_installation;
    segmPtr^.sp1p_buf_size                       :=
          size - sizeof (tsp1_segment_header);
    acv.a_cmd_packet_header := acv.a_in_packet^.sp1_header;
    s26new_part_init (acv.a_in_packet, segmPtr^, partPtr);
    acv.a_cmd_part          := partPtr;
    partPtr^.sp1p_part_kind := sp1pk_command;
    partPtr^.sp1p_buf_len   := 0;
    acv.a_initial_segment_header.sp1c_producer := sp1pr_installation;
    acv.a_cmd_segm := @acv.a_in_packet^.sp1_segm;
    acv.a_sqlmode  := sqlm_internal; (* comments are recreated in internal mode *)
    commentRecPtr  := @_b;
    pKey           := @_b;
    pSyskey        := @_b;
    pKey^.len      := 0;
    WITH set_result DO
        BEGIN
        bd_key_check_len := 0;
        bd_max_rec_cnt   := 1;
        bd_max_fill_len  := sizeof( _b.rec.recBuf_gg00 );
        bd_next          := true;
        bd_drop_page     := false
        END;
    (*ENDWITH*) 
    acv.a_curr_user_id := cgg_zero_id;
    cnt                := 0;
    (* leave room for 'COMMENT ON ... IS ' in front of actual comment *)
    partPtr^.sp1p_buf_len := c_comment_stmt_header_size;
    REPEAT
        acv.a_cmd_part := partPtr;
        ;
        tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
        b07cnext_record( acv.a_transinf.tri_trans, MGlob.comment_tree,
              pKey^, set_result, tree_pos, _b.rec.recBuf_gg00 );
        b_err := acv.a_transinf.tri_trans.trError_gg00;
        IF  ( b_err = e_ok ) OR ( b_err = e_key_not_found )
        THEN
            BEGIN
            b_err := e_ok;
            move_len := commentRecPtr^.recLen_gg00 - cgg_rec_key_offset
                  - pSyskey^.skeylen - sizeof (tsp00_C2);
            IF  (pSyskey^.stablen[ 2 ] = '\00') AND (* linkage has been put *)
                (pSyskey^.stablen[ 3 ] = '\01')     (* into stablen[]       *)
            THEN (* first record contains comment length *)
                BEGIN
                moveObjPtr1 := @_b.rec;
                commentLen  := s20buf_to_int4_swap (moveObjPtr1^, cgg_rec_key_offset +
                      pSyskey^.skeylen + sizeof (tsp00_C2) + 1,
                      sw_normal, g01code.kernel_swap);
                pos        :=  cgg_rec_key_offset +
                      pSyskey^.skeylen + sizeof (tsp00_C2) + 4 +1;
                commentPos := 1;
                commentType:= _b.ci_comment_rec.com_type;
                move_len   := move_len - 4;
                END
            ELSE
                pos       :=  cgg_rec_key_offset + pSyskey^.skeylen
                      + sizeof (tsp00_C2) + 1;
            (*ENDIF*) 
            (* handle possible single quotes in comment: *)
            moveObjPtr1 := @_b.rec.recBuf_gg00 [ pos ];
            moveObjPtr2 := @partPtr^.sp1p_buf[ partPtr^.sp1p_buf_len+1 ];
            ak362translate_and_quote (moveObjPtr1,
                  _b.rec.recLen_gg00 - pos + 1,
                  moveObjPtr2,
                  partPtr^.sp1p_buf_size - partPtr^.sp1p_buf_len - 1,
                  csp_ascii_quote,
                  csp_ascii_quote,
                  uniLen,
                  b_err);
            commentPos            := commentPos + (uniLen DIV 2);
            partPtr^.sp1p_buf_len := partPtr^.sp1p_buf_len + uniLen;
&           ifdef TRACE
            t01buf (ak_sem, _b.rec.recBuf_gg00, 1, _b.rec.recLen_gg00);
            t01int4 (ak_sem, '_move_len   ', move_len);
            t01int4 (ak_sem, 'dst_pos     ', partPtr^.sp1p_buf_len+1);
            t01int4 (ak_sem, '_e          ', ord(b_err));
            t01int4 (ak_sem, 'pos         ', pos);
            t01int4 (ak_sem, 'commentLen  ', commentLen);
            t01int4 (ak_sem, 'commentPos  ', commentPos);
            moveObjPtr1 := @partPtr^.sp1p_buf;
            t01moveobj (ak_sem, moveObjPtr1^, 1, partPtr^.sp1p_buf_len);
&           endif
            IF  commentPos >= commentLen
            THEN (* the whole comment has been loaded, now load          *)
                (* what it is commenting on and the user it belongs to   *)
                BEGIN
                b07cnext_record( acv.a_transinf.tri_trans, MGlob.comment_tree,
                      pKey^, set_result, tree_pos, _b.rec.recBuf_gg00 );
                b_err :=acv.a_transinf.tri_trans.trError_gg00;
                ak362InsertCommentStmtHeader (partPtr, commentType, _b,
                      b_err);
                (* save comment name in case of errors *)
                FOR ix := 1 TO sizeof(commentname) DIV 2 DO
                    BEGIN
                    commentname [2*ix-1] := '\00';
                    commentname [2*ix  ] := ' ';
                    END;
                (*ENDFOR*) 
                IF  partPtr^.sp1p_buf_len - c_commentOnLength < sizeof(tsp00_KnlIdentifier)
                THEN
                    move_len := partPtr^.sp1p_buf_len - c_commentOnLength
                ELSE
                    move_len := sizeof (tsp00_KnlIdentifier);
                (*ENDIF*) 
                SAPDB_PascalMove ('VAK362',  18,    
                      partPtr^.sp1p_buf_len, sizeof (commentname),
                      @partPtr^.sp1p_buf, c_commentOnLength, (* skip 'comment on ' *)
                      @commentname, 1,
                      move_len,
                      b_err);
                IF  ( b_err = e_ok )
                THEN
                    BEGIN
                    (* use correct username *)
                    a06determine_username( acv,
                          _b.ci_ownerId,
                          acv.a_curr_user_name );
                    a362SetUserAndSchema (acv,
                          acv.a_curr_user_name,
                          _b.ci_ownerId, _b.ci_schemaId, userInfo);
                    END;
                (*ENDIF*) 
                IF  b_err = e_ok
                THEN
                    BEGIN
&                   ifdef TRACE
                    t01int4 (ak_sem, 'sqlMode     ', ord (acv.a_sqlmode));
                    moveObjPtr1 := @partPtr^.sp1p_buf;
                    t01moveobj (ak_sem, moveObjPtr1^, 1, partPtr^.sp1p_buf_len);
&                   endif
                    IF  (partPtr^.sp1p_buf_len - c_comment_stmt_header_size)
                        > MAX_INT2_SP00
                    THEN
                        BEGIN
                        msg := 'truncating comment to 16383 characters  ';
                        g01optextmsg (sp3p_console, sp3m_warning,
                              csp3_a362_migrate_ascii_to_uni,
                              csp3_n_migration, msg);
                        partPtr^.sp1p_buf_len := ((MAX_INT2_SP00 +
                              c_comment_stmt_header_size - 1) DIV 2) * 2;
                        partPtr^.sp1p_buf[partPtr^.sp1p_buf_len-1] := '\00';
                        partPtr^.sp1p_buf[partPtr^.sp1p_buf_len  ] := csp_ascii_quote;
                        END;
                    (*ENDIF*) 
                    s26finish_part( acv.a_in_packet, partPtr^ );
                    a10_cache_delete( acv, NOT c_is_rollback );
                    a52new_subtrans( acv, a01_il_b_identifier );
                    a35_asql_statement( acv );
                    (* PTS 1127315 M.Ki. *)
                    IF  (acv.a_returncode = -4004)
                        OR (acv.a_returncode = -942)
                    THEN
                        BEGIN
                        msg    := 'DROPPED COMMENT ON:                     ';
                        g01optextmsg (sp3p_console, sp3m_info,
                              csp3_a361_no_direct_migration,
                              csp3_n_migration, msg);
                        g01unioptextmsg (csp_unicode, sp3p_console, sp3m_info,
                              csp3_a361_no_direct_migration,
                              csp3_n_migration, commentname);
                        END;
                    (*ENDIF*) 
                    IF  acv.a_returncode = 0
                    THEN
                        BEGIN
                        m_type := m_end;
                        END
                    ELSE
                        m_type := m_rollback;
                    (*ENDIF*) 
                    acv.a_returncode := 0;
                    a52end_rollback_subtrans( acv, a01_il_b_identifier,
                          m_type );
                    cnt   := cnt + 1;
                    partPtr^.sp1p_buf_len := c_comment_stmt_header_size;
                    b_err := acv.a_returncode;
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  ( b_err = e_ok ) OR ( acv.a_returncode = 0 )
        THEN
            BEGIN
            vtime_in_seconds (curTime);
            IF  (curTime - msgTime) >= c_feedback_interval
            THEN
                BEGIN
                msgTime := curTime;
                g01opmsg (sp3p_console, sp3m_info,
                      csp3_a362_migrate_ascii_to_uni,
                      csp3_n_migration, 'COMMENTS MIGRATED SO FAR',
                      cnt);
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    UNTIL
        ( b_err <> e_ok ) OR ( acv.a_returncode <> 0 );
    (*ENDREPEAT*) 
    IF  (b_err <> e_no_next_record) AND (acv.a_returncode = 0)
    THEN
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    END;
(*ENDIF*) 
acv.a_in_packet := packetPtr;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362get_indexname (
            VAR acv        : tak_all_command_glob;
            VAR MGlob      : tak362_MigrationGlob;
            indexbuf       : tak_sysbufferaddress;
            index          : integer;
            VAR index_name : tsp00_KnlIdentifier);
 
VAR
      b_err     : tgg00_BasisError;
      offset    : integer;
      rest_len  : integer;
      len       : integer;
      iname_pos : integer;
      sysk      : tgg00_SysInfoKey;
 
BEGIN
b_err := e_ok;
(* this procedure is (except for the get_sysinfo stuff) a one-to-one *)
(* copy of a24get_indexname                                          *)
ak362set_ascii (MGlob);
SAPDB_PascalForcedMove(
      sizeof( indexbuf^.smindex.indexdef[ index ].indexn_prefix ),
      sizeof( index_name ),
      @indexbuf^.smindex.indexdef[ index ].indexn_prefix, 1,
      @index_name, 1,
      sizeof( indexbuf^.smindex.indexdef[ index ].indexn_prefix ));
iname_pos := sizeof( indexbuf^.smindex.indexdef[ index ].indexn_prefix ) + 1;
rest_len  := indexbuf^.smindex.indexdef[ index ].isuffixlen;
IF  ( rest_len > 0 )
THEN
    BEGIN
    len := sizeof( indexbuf^.smindex.indexdef[ index ].icolstack ) -
          indexbuf^.smindex.indexdef[ index ].icount *
          sizeof( indexbuf^.smindex.indexdef[ index ].icolstack[ 1 ] );
    IF  ( len > rest_len )
    THEN
        len := rest_len;
    (*ENDIF*) 
    SAPDB_PascalMove ('VAK362',  19,    
          sizeof( indexbuf^.smindex.indexdef[ index ].icolstack ),
          sizeof( index_name ),
          @indexbuf^.smindex.indexdef[ index ].icolstack,
          indexbuf^.smindex.indexdef[ index ].icount
          * sizeof( indexbuf^.smindex.indexdef[ index ].icolstack[ 1 ] ) + 1,
          @index_name, iname_pos, len, acv.a_returncode);
    iname_pos := iname_pos + len;
    rest_len  := rest_len - len;
    END;
(*ENDIF*) 
IF  ( rest_len > 0 )
THEN
    BEGIN
    sysk               := indexbuf^.syskey;
    sysk.slinkage[ 1 ] := chr( index );
    ak362get_old_sysinfo( acv, MGlob, sysk, d_release, indexbuf, b_err );
    ak362set_ascii (MGlob);
    IF  ( b_err <> e_ok )
    THEN
        a07_b_put_error( acv, b_err, 1 )
    ELSE
        BEGIN
        offset := cgg_rec_key_offset + indexbuf^.syskey.skeylen +
              sizeof( indexbuf^.smindex.isegmentid );
        SAPDB_PascalMove ('VAK362',  20,    
              sizeof( indexbuf^.smindex ), sizeof( index_name),
              @indexbuf^.smindex, offset + 1,
              @index_name, iname_pos,
              indexbuf^.b_sl - offset, acv.a_returncode);
        iname_pos := iname_pos + indexbuf^.b_sl - offset;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
SAPDB_PascalMove('VAK362',  21,    
      sizeof( a01_il_b_identifier ), sizeof( index_name ),
      @a01_il_b_identifier, 1, @index_name, iname_pos,
      sizeof( index_name ) - iname_pos + 1, acv.a_returncode);
ak362set_unicode (MGlob);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362set_unicode (
            VAR MGlob : tak362_MigrationGlob);
 
BEGIN
kb560SetSys1CatalogTreeId (MGlob.newCat1Id);
kb560SetSys2CatalogTreeId (MGlob.newCat2Id);
g01unicode        := true;
a01char_size      := 2;
a01sets_identifier (a01_il_b_identifier, bsp_name);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362set_ascii (
            VAR MGlob : tak362_MigrationGlob);
 
BEGIN
kb560SetSys1CatalogTreeId (MGlob.oldCat1Id);
kb560SetSys2CatalogTreeId (MGlob.oldCat2Id);
g01unicode        := false;
a01char_size      := 1;
a01sets_identifier (a01_il_b_identifier, bsp_name);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362InsertCommentStmtHeader (
            VAR partPtr : tsp1_part_ptr;
            commentType : tak_comment_type;
            VAR buf     : tak362_commentInfo;
            VAR b_err   : tgg00_BasisError);
 
CONST
      c_comment_on      = 'COMMENT ON ';
      c_comment_on_size = 11;
      c_column          = 'COLUMN  ';
      c_dbproc          = 'DBPROC  ';
      c_table           = 'TABLE   ';
      c_trigger         = 'TRIGGER ';
      c_type_size       = 8;
      c_is              = ' IS ';
      c_is_size         = 4;
 
VAR
      uniError    : tsp8_uni_error;
      ix          : integer;
      pos         : tsp00_Int4;
      uniLen      : tsp00_Int4;
      errPos      : tsp00_Int4;
      moveObjPtr1 : tsp00_MoveObjPtr;
      moveObjPtr2 : tsp00_MoveObjPtr;
 
BEGIN
(* called once part has already been filled with statement text *)
(* inserts header in front and quotes at the end;               *)
(* c_comment_stmt_header_size needs to be adjusted if the *)
(* header size changes                                    *)
&ifdef TRACE
t01buf (ak_sem, buf.rec.recBuf_gg00, 1, buf.rec.recLen_gg00);
t01int4 (ak_sem, 'commentType ', ord (commentType));
&endif
(* end whole statement with single quotes (right behind end of *)
(* comment text)                                               *)
partPtr^.sp1p_buf[partPtr^.sp1p_buf_len+1] := '\00';
partPtr^.sp1p_buf[partPtr^.sp1p_buf_len+2] := csp_ascii_quote;
partPtr^.sp1p_buf_len := partPtr^.sp1p_buf_len + 2;
(* put header at beginning of part *)
pos    := 1;
uniLen := 2 * c_comment_on_size;
s80uni_trans (@c_comment_on, c_comment_on_size,
      csp_ascii,
      @partPtr^.sp1p_buf[ 1 ], uniLen,
      csp_unicode, [ ], uniError, errPos);
pos    := pos + uniLen;
CASE commentType OF
    cm_dbproc :
        s80uni_trans (@c_dbproc, c_type_size,
              csp_ascii,
              @partPtr^.sp1p_buf[ pos ],
              uniLen,
              csp_unicode, [ ], uniError, errPos);
    cm_trigger :
        s80uni_trans (@c_trigger, c_type_size,
              csp_ascii,
              @partPtr^.sp1p_buf[ pos ],
              uniLen,
              csp_unicode, [ ], uniError, errPos);
    cm_table :
        s80uni_trans (@c_table, c_type_size,
              csp_ascii,
              @partPtr^.sp1p_buf[ pos ],
              uniLen,
              csp_unicode, [ ], uniError, errPos);
    cm_column :
        s80uni_trans (@c_column, c_type_size,
              csp_ascii,
              @partPtr^.sp1p_buf[ pos ],
              uniLen,
              csp_unicode, [ ], uniError, errPos);
    OTHERWISE :
        (* *)
    END;
(*ENDCASE*) 
pos := pos + uniLen;
IF  buf.ci_tableName <> a01_il_b_identifier
THEN
    BEGIN (* table name given *)
    partPtr^.sp1p_buf[ pos     ] := '\00';
    partPtr^.sp1p_buf[ pos + 1 ] := csp_ascii_double_quote;
    pos    := pos + 2;
    uniLen := 2*sizeof(tsp00_KnlIdentifier);
    moveObjPtr1 := @buf.ci_tableName;
    moveObjPtr2 := @partPtr^.sp1p_buf[ pos ];
    ak362translate_and_quote (moveObjPtr1,
          sizeof(buf.ci_tableName) DIV 2,
          moveObjPtr2,
          uniLen,
          csp_ascii_double_quote,
          csp_ascii_double_quote,
          uniLen,
          b_err);
    pos := pos + uniLen;
    partPtr^.sp1p_buf[ pos     ] := '\00';
    partPtr^.sp1p_buf[ pos + 1 ] := csp_ascii_double_quote;
    partPtr^.sp1p_buf[ pos + 2 ] := '\00';
    partPtr^.sp1p_buf[ pos + 3 ] := '.';
    pos := pos + 4;
    END
ELSE
    BEGIN
    SAPDB_PascalMove ('VAK362',  22,    
          sizeof (a01_il_b_identifier),
          partPtr^.sp1p_buf_len,
          @a01_il_b_identifier, 1,
          @partPtr^.sp1p_buf[1], pos,
          sizeof (a01_il_b_identifier),
          b_err);
    pos := pos + sizeof (a01_il_b_identifier);
    END;
(*ENDIF*) 
partPtr^.sp1p_buf[ pos     ] := '\00';
partPtr^.sp1p_buf[ pos + 1 ] := csp_ascii_double_quote;
pos    := pos + 2;
uniLen := sizeof(buf.ci_commentOn);
moveObjPtr1 := @buf.ci_commentOn;
moveObjPtr2 := @partPtr^.sp1p_buf[ pos ];
ak362translate_and_quote (moveObjPtr1,
      sizeof(buf.ci_commentOn) DIV 2,
      moveObjPtr2,
      uniLen,
      csp_ascii_double_quote,
      csp_ascii_double_quote,
      uniLen,
      b_err);
pos := pos + uniLen + 2;
partPtr^.sp1p_buf[ pos - 2 ] := '\00';
partPtr^.sp1p_buf[ pos - 1 ] := csp_ascii_double_quote;
s80uni_trans (@c_is, c_is_size,
      csp_ascii,
      @partPtr^.sp1p_buf[ pos ],
      uniLen,
      csp_unicode, [ ], uniError, errPos);
pos := pos + uniLen;
(* fill space between end of header and statement text with blanks *)
FOR ix := 1 TO (c_comment_stmt_header_size - pos - 2) DIV 2 + 1 DO
    BEGIN
    partPtr^.sp1p_buf[ pos + (ix-1)*2   ] := '\00';
    partPtr^.sp1p_buf[ pos + (ix-1)*2+1 ] := '\20';
    END;
(*ENDFOR*) 
(* put quote before comment text *)
pos := c_comment_stmt_header_size - 1;
partPtr^.sp1p_buf[ pos     ] := '\00';
partPtr^.sp1p_buf[ pos + 1 ] := csp_ascii_quote;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362translate_and_quote (
            VAR srcObj   : tsp00_MoveObjPtr;
            srcLen       : tsp00_Int4;
            VAR dstObj   : tsp00_MoveObjPtr;
            dstSize      : tsp00_Int4;
            charToQuote  : tsp00_Char;
            quoteChar    : tsp00_Char;
            VAR transLen : tsp00_Int4;
            VAR b_err    : tgg00_BasisError);
 
VAR
      uniError   : tsp8_uni_error;
      srcPos     : tsp00_Int4;
      dstPos     : tsp00_Int4;
      chunkSize  : tsp00_Int4;
      srcRestLen : tsp00_Int4;
      uniLen     : tsp00_Int4;
      errPos     : tsp00_Int4;
 
BEGIN
dstPos     := 0;
srcPos     := 1;
srcRestLen := srcLen;
chunkSize  := 0;
uniError   := uni_ok;
WHILE (chunkSize < srcRestLen) AND (uniError = uni_ok) DO
    BEGIN
    WHILE (chunkSize <= srcRestLen) AND
          (srcObj^[ srcPos + chunkSize ] <> charToQuote) DO
        chunkSize := succ (chunkSize);
    (*ENDWHILE*) 
    uniLen := dstSize - dstPos;
&   ifdef TRACE
    t01int4 (ak_sem, 'srcRestLen  ', srcRestLen);
    t01int4 (ak_sem, 'chunkSize   ', chunkSize);
    t01int4 (ak_sem, 'pos         ', srcPos);
    t01int4 (ak_sem, 'uniLenPre   ', uniLen);
&   endif
    IF  (chunkSize < srcRestLen)
    THEN
        BEGIN
        s80uni_trans (@srcObj^[ srcPos ], chunkSize, csp_ascii,
              @dstObj^[ dstPos+1 ], uniLen, csp_unicode, [ ],
              uniError, errPos);
        IF  (dstPos + uniLen + 4) <= dstSize
        THEN
            BEGIN
            srcPos              := srcPos + (uniLen DIV 2) + 1;
            srcRestLen          := srcRestLen - (uniLen DIV 2) - 1;
            dstPos              := dstPos + uniLen + 4;
            dstObj^[ dstPos-3 ] := '\00';
            dstObj^[ dstPos-2 ] := quoteChar;
            dstObj^[ dstPos-1 ] := '\00';
            dstObj^[ dstPos   ] := charToQuote;
            chunkSize           := 0;
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        s80uni_trans (@srcObj^[ srcPos ], srcRestLen, csp_ascii,
              @dstObj^[ dstPos+1 ], uniLen, csp_unicode, [ ],
              uniError, errPos);
        dstPos     := dstPos + uniLen;
        srcRestLen := srcRestLen - (uniLen DIV 2);
        END;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  uniError = uni_not_translatable
THEN
    b_err := e_not_trans_to_uni
ELSE
    IF  uniError <> uni_ok
    THEN
        b_err := e_too_long_record;
    (*ENDIF*) 
(*ENDIF*) 
transLen := dstPos;
END;
 
(*------------------------------*) 
 
FUNCTION
      ak362isUnicodeDatabase(
            acv : tak_all_command_glob) : boolean;
 
VAR
      b_err   : tgg00_BasisError;
      buf     : tak_sysbufferaddress;
      syskey  : tgg00_SysInfoKey;
 
BEGIN
(* get sysdba username and check if it is still ASCII; g01glob.sysuser_name *)
(* can't be used since it will be preset with a02controluser (unicode) in   *)
(* in case of version mismatches                                            *)
ak362isUnicodeDatabase := false;
syskey                 := a01defaultkey;
syskey.sentrytyp       := cak_esysdba;
syskey.ssite           := cgg_zero_c2;
a10get_sysinfo (acv, syskey, d_release, buf, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    syskey.sauthid   := buf^.ssysdba.sysauthid;
    syskey.sentrytyp := cak_euser;
    syskey.slinkage  := cak_init_linkage;
    a10get_sysinfo (acv, syskey, d_release, buf, b_err);
    IF  b_err = e_ok
    THEN
        (* as identifier might be a mix of ASCII and unicode it seems *)
        (* safest to only rely on the first byte...                   *)
        ak362isUnicodeDatabase := (buf^.suser.username[ 1 ] = csp_unicode_mark);
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362getMethodSQLContext (
            VAR acv        : tak_all_command_glob;
            VAR MGlob      : tak362_MigrationGlob;
            VAR syskey     : tgg00_SysInfoKey;
            VAR sqlContext : tsp00_Uint1;
            VAR b_err      : tgg00_BasisError);
 
VAR
      sqlmode        : tsp00_SqlMode;
      dateTimeFormat : tgg00_DateTimeFormat;
      sysk           : tgg00_SysInfoKey;
      pBuf           : tak_sysbufferaddress;
      mblock_p       : tgg00_MessBlockPtr;
 
BEGIN
(* this procedure returns the sql context of a dbproc/trigger if it *)
(* can be determined; otherwise b_err <> e_ok will be returned      *)
(* *)
(* get sql-mode of statement from permanent messblock *)
sysk           := syskey;
sysk.sentrytyp := cak_epermmessblock;
sysk.skeylen   := mxak_standard_sysk;
ak362get_old_sysinfo (acv, MGlob, sysk, d_release, pBuf, b_err);
IF  (b_err = e_ok)
THEN
    BEGIN
    mblock_p := @pBuf^.smessblock.mbr_mess_block;
    IF  mblock_p^.mb_qual^.mbool
    THEN
        BEGIN (* code already contains date/time info, true since 7.3.0.22 *)
        sqlmode         := mblock_p^.mb_qual^.msqlmode;
        dateTimeFormat  := mblock_p^.mb_qual^.mdatetimeformat;
        CASE sqlmode OF
            sqlm_ansi   :
                sqlContext := 10;
            sqlm_db2    :
                sqlContext := 20;
            sqlm_oracle :
                sqlContext := 30;
            sqlm_internal :
                sqlContext :=  0;
            END;
        (*ENDCASE*) 
        sqlContext := sqlContext + ord (dateTimeFormat);
        END
    ELSE
        BEGIN (* don't know anything about date/time format *)
        (* try using sqlcontext of first sql statement of method *)
        (* (if available)                                        *)
        b_err := e_ok;
        sysk               := syskey;
        sysk.sentrytyp     := cak_eviewtext;
        sysk.slinkage[ 1 ] := sysk.slinkage[ 2 ];
        sysk.slinkage[ 2 ] := chr (1);
        ak362get_old_sysinfo (acv, MGlob, sysk, d_release, pBuf, b_err);
        IF  b_err = e_ok
        THEN
            sqlContext := pBuf^.sviewtext.vtcontext
        (*ENDIF*) 
        END;
    (*ENDIF*) 
&   ifdef TRACE
    t01int4 (ak_sem, 'sqlContext  ', sqlContext);
&   endif
    END;
(*ENDIF*) 
IF  acv.a_returncode = 100 (* e_key_not_found *)
THEN
    acv.a_returncode := 0;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362dumpRecord (
            VAR outRec : tgg00_Rec);
 
VAR
      b_err      : tgg00_BasisError;
      short_fn   : tsp00_C20;
      host_error : tsp00_VfReturn;
      hostfile   : tgg00_VfFileref;
      errtext    : tsp00_ErrText;
      dump_fn    : tsp00_VFilename;
      outPage    : tsp00_Page;
 
BEGIN
b_err := e_ok;
hostfile.buf_cnt := 0;
SAPDB_PascalForcedFill (
      sizeof (outPage), @outPage, 1, sizeof (outPage),
      chr(0));
SAPDB_PascalMove ('VAK362',  23,    
      sizeof (outPage), sizeof (outPage),
      @outRec, 1,
      @outPage, 1,
      outRec.recLen_gg00,
      b_err);
dump_fn := b01blankfilename;
short_fn := 'MIGERRORREC.BIN     ';
SAPDB_PascalForcedMove( sizeof(short_fn), sizeof (dump_fn),
      @short_fn, 1, @dump_fn, 1, sizeof(short_fn));
vfrawopen (dump_fn, hostfile.no, host_error, errtext);
IF  (host_error = vf_ok)
THEN
    vfwrite (hostfile.no, @outPage, host_error, errtext);
(*ENDIF*) 
IF  (host_error = vf_ok) OR (host_error = vf_eof)
THEN
    vfclose (hostfile.no, host_error, errtext);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362remove_paramfiles (
            VAR t : tgg00_TransContext);
 
CONST
      c_is_restart = true;
 
VAR
      xp_return        : tsp00_XpReturnCode;
      xp_errortext     : tsp00_ErrText;
 
BEGIN
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    vxparam_save_good_config (NOT c_is_restart, xp_errortext, xp_return);
    IF  xp_return <> xp_ok
    THEN
        g01optextmsg (sp3p_console, sp3m_warning, csp3_a362_migrate_ascii_to_uni,
              csp3_n_param, xp_errortext)
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362CreateProtTable (
            VAR acv   : tak_all_command_glob;
            VAR MGlob : tak362_MigrationGlob);
 
CONST
      c_createUnicode    = true;
      c_unicodeMigration = true; (* PTS 1132418 M.Ki. *)
 
BEGIN (* PTS 1128229 M.Ki. *)
ak362set_unicode (MGlob);
a361CreateProtTable (acv, MGlob.prot_tree, c_createUnicode,
      c_unicodeMigration);
IF  (MGlob.prot_tree.fileName_gg00 = cgg_zero_fn)
    AND (acv.a_returncode = 0)
THEN
    a07_b_put_error (acv, e_file_not_found, 1);
(*ENDIF*) 
ak362set_ascii (MGlob);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362CreateTriggerSubstitute (
            VAR acv          : tak_all_command_glob;
            VAR triggerName  : tsp00_KnlIdentifier;
            triggerLinkage   : tsp00_C2;
            VAR triggerTable : tsp00_KnlIdentifier;
            VAR triggerOwner : tsp00_KnlIdentifier;
            VAR ownerId      : tgg00_Surrogate;
            VAR schemaId     : tgg00_Surrogate;
            VAR createOk     : boolean);
 
CONST
      c_cTrigger    = 'CREATE TRIGGER                          ';
      c_cForTable   = 'FOR                                     ';
      c_cInsert     = 'AFTER INSERT EXECUTE ( STOP             ';
      c_cUpdate     = 'AFTER UPDATE EXECUTE ( STOP             ';
      c_cDelete     = 'AFTER DELETE EXECUTE ( STOP             ';
      c_cBody1      = '(-8052, ''trigger dropped during migratio';
      c_cBody2      = 'n; check table POSTUPGRADECHECKLISTUNICO';
      c_cBody3      = 'DE'');)                                  ';
 
VAR
      pos            : integer;
      m_type         : tgg00_MessType;
      userInfo       : tak_user_info;
      msg            : tsp00_C40;
      triggerOwner_u : tsp00_KnlIdentifier;
 
BEGIN
createOk := false;
(* translate trigger owner to unicode *)
FOR pos := sizeof(triggerOwner) DIV 2 DOWNTO 1 DO
    BEGIN
    triggerOwner_u[ 2*pos   ] := triggerOwner[ pos ];
    triggerOwner_u[ 2*pos-1 ] := chr(0);
    END;
(*ENDFOR*) 
a362SetUserAndSchema (acv, triggerOwner_u, ownerId, schemaId, userInfo);
acv.a_cmd_part^.sp1p_buf_len := 0;
msg := c_cTrigger;
SAPDB_PascalMove ('VAK362',  24,    
      sizeof(msg), acv.a_cmd_part^.sp1p_buf_size,
      @msg, 1,
      @acv.a_cmd_part^.sp1p_buf, acv.a_cmd_part^.sp1p_buf_len + 1,
      sizeof(msg), acv.a_returncode);
acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len + sizeof (msg);
SAPDB_PascalMove ('VAK362',  25,    
      sizeof(triggerName), acv.a_cmd_part^.sp1p_buf_size,
      @triggerName, 1,
      @acv.a_cmd_part^.sp1p_buf, acv.a_cmd_part^.sp1p_buf_len + 1,
      sizeof(triggerName), acv.a_returncode);
acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len + sizeof (triggerName);
msg := c_cForTable;
SAPDB_PascalMove ('VAK362',  26,    
      sizeof(msg), acv.a_cmd_part^.sp1p_buf_size,
      @msg, 1,
      @acv.a_cmd_part^.sp1p_buf, acv.a_cmd_part^.sp1p_buf_len + 1,
      sizeof(msg), acv.a_returncode);
acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len + sizeof (msg);
(* PTS 1134971 M.Ki.: quote table name *)
acv.a_cmd_part^.sp1p_buf [acv.a_cmd_part^.sp1p_buf_len+1] := '"';
acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len + 1;
SAPDB_PascalMove ('VAK362',  27,    
      sizeof(triggerTable), acv.a_cmd_part^.sp1p_buf_size,
      @triggerTable, 1,
      @acv.a_cmd_part^.sp1p_buf, acv.a_cmd_part^.sp1p_buf_len + 1,
      sizeof(triggerTable), acv.a_returncode);
acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len
      + s30lnr (triggerTable, bsp_c1, 1, sizeof (triggerTable));
acv.a_cmd_part^.sp1p_buf [acv.a_cmd_part^.sp1p_buf_len+1] := '"';
acv.a_cmd_part^.sp1p_buf [acv.a_cmd_part^.sp1p_buf_len+2] := ' ';
acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len + 2;
(* *)
IF  triggerLinkage = cak_ins_trigger_linkage
THEN
    msg := c_cInsert;
(*ENDIF*) 
IF  triggerLinkage = cak_upd_trigger_linkage
THEN
    msg := c_cUpdate;
(*ENDIF*) 
IF  triggerLinkage = cak_del_trigger_linkage
THEN
    msg := c_cDelete;
(*ENDIF*) 
SAPDB_PascalMove ('VAK362',  28,    
      sizeof(msg), acv.a_cmd_part^.sp1p_buf_size,
      @msg, 1,
      @acv.a_cmd_part^.sp1p_buf, acv.a_cmd_part^.sp1p_buf_len + 1,
      sizeof(msg), acv.a_returncode);
acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len + sizeof (msg);
msg := c_cBody1;
SAPDB_PascalMove ('VAK362',  29,    
      sizeof(msg), acv.a_cmd_part^.sp1p_buf_size,
      @msg, 1,
      @acv.a_cmd_part^.sp1p_buf, acv.a_cmd_part^.sp1p_buf_len + 1,
      sizeof(msg), acv.a_returncode);
acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len + sizeof (msg);
msg := c_cBody2;
SAPDB_PascalMove ('VAK362',  30,    
      sizeof(msg), acv.a_cmd_part^.sp1p_buf_size,
      @msg, 1,
      @acv.a_cmd_part^.sp1p_buf, acv.a_cmd_part^.sp1p_buf_len + 1,
      sizeof(msg), acv.a_returncode);
acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len + sizeof (msg);
msg := c_cBody3;
SAPDB_PascalMove ('VAK362',  31,    
      sizeof(msg), acv.a_cmd_part^.sp1p_buf_size,
      @msg, 1,
      @acv.a_cmd_part^.sp1p_buf, acv.a_cmd_part^.sp1p_buf_len + 1,
      sizeof(msg), acv.a_returncode);
acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len + sizeof (msg);
FOR pos := acv.a_cmd_part^.sp1p_buf_len DOWNTO 1 DO
    BEGIN
    acv.a_cmd_part^.sp1p_buf[2*pos  ] := acv.a_cmd_part^.sp1p_buf[pos];
    acv.a_cmd_part^.sp1p_buf[2*pos-1] := chr(0);
    END;
(*ENDFOR*) 
acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len * 2;
a52new_subtrans( acv, a01_il_b_identifier );
a35_asql_statement( acv );
acv.a_initial_segment_header.sp1c_producer := sp1pr_installation;
IF  acv.a_returncode = 0
THEN
    BEGIN
    m_type   := m_end;
    createOk := true;
    END
ELSE
    m_type   := m_rollback;
(*ENDIF*) 
acv.a_returncode := 0;
a52end_rollback_subtrans( acv, a01_il_b_identifier,
      m_type );
END;
 
(*------------------------------*) 
 
PROCEDURE
      a362SetUserAndSchema (
            VAR acv      : tak_all_command_glob;
            VAR userName : tsp00_KnlIdentifier;
            VAR userId   : tgg00_Surrogate;
            VAR schemaId : tgg00_Surrogate;
            VAR userInfo : tak_user_info);
 
BEGIN
acv.a_curr_user_name := userName;
acv.a_curr_user_id   := userId;
IF  a22exist_user( acv, acv.a_curr_user_name, 1,
    userInfo )
THEN
    BEGIN
    (* acv.a_curr_schema_id must be set *after*      *)
    (* acv.a_curr_schema otherwise acv.a_curr_schema *)
    (* will not be changed                           *)
    a103GetSchemaName (acv, schemaId,
          acv.a_curr_schema);
    acv.a_curr_schema_id    := schemaId;
    acv.a_current_user_kind := userInfo.ui_kind;
    acv.a_acc_dba_id        := userInfo.ui_owner;
    (* PTS 1134883 M.Ki. *)
    acv.a_acc_user          := userName;
    acv.a_acc_user_id       := userId;
    acv.a_connected_name    := userName;
    a06determine_username( acv,
          acv.a_acc_dba_id, acv.a_acc_dbaname );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak362DumpProcInfo (
            isTrigger        : boolean;
            VAR triggerName  : tsp00_KnlIdentifier;
            triggerLinkage   : tsp00_C2;
            VAR triggerTable : tsp00_KnlIdentifier;
            VAR triggerOwner : tsp00_KnlIdentifier);
 
CONST
      c_insert      = '      triggered on: INSERT              ';
      c_update      = '      triggered on: UPDATE              ';
      c_delete      = '      triggered on: DELETE              ';
      c_name        = ' name :                                 ';
      c_table       = ' table:                                 ';
      c_owner       = ' owner:                                 ';
      c_offset      = 8;
 
VAR
      msg : tsp00_C40;
 
BEGIN
IF  isTrigger
THEN
    BEGIN
    (* write error to knldiag.err *)
    msg := c_name;
    SAPDB_PascalForcedMove(
          sizeof (triggerName),
          sizeof (msg),
          @triggerName, 1,
          @msg, c_offset,
          sizeof (msg) - c_offset);
    g01optextmsg (sp3p_console, sp3m_error,
          csp3_a362_migrate_ascii_to_uni,
          csp3_n_migration, msg);
    (* *)
    msg := c_table;
    SAPDB_PascalForcedMove(
          sizeof (triggerTable),
          sizeof (msg),
          @triggerTable, 1,
          @msg, c_offset,
          sizeof (msg) - c_offset);
    g01optextmsg (sp3p_console, sp3m_error,
          csp3_a362_migrate_ascii_to_uni,
          csp3_n_migration, msg);
    (* *)
    msg := c_owner;
    SAPDB_PascalForcedMove(
          sizeof (triggerOwner),
          sizeof (msg),
          @triggerOwner, 1,
          @msg, c_offset,
          sizeof (msg) - c_offset);
    g01optextmsg (sp3p_console, sp3m_error,
          csp3_a362_migrate_ascii_to_uni,
          csp3_n_migration, msg);
    IF  triggerLinkage = cak_ins_trigger_linkage
    THEN
        g01optextmsg (sp3p_console, sp3m_error,
              csp3_a362_migrate_ascii_to_uni,
              csp3_n_migration, c_insert);
    (*ENDIF*) 
    IF  triggerLinkage = cak_upd_trigger_linkage
    THEN
        g01optextmsg (sp3p_console, sp3m_error,
              csp3_a362_migrate_ascii_to_uni,
              csp3_n_migration, c_update);
    (*ENDIF*) 
    IF  triggerLinkage = cak_del_trigger_linkage
    THEN
        g01optextmsg (sp3p_console, sp3m_error,
              csp3_a362_migrate_ascii_to_uni,
              csp3_n_migration, c_delete);
    (*ENDIF*) 
    END
ELSE
    BEGIN
    msg := c_name;
    SAPDB_PascalForcedMove(
          sizeof (triggerName),
          sizeof (msg),
          @triggerName, 1,
          @msg, c_offset,
          sizeof (msg) - c_offset);
    g01optextmsg (sp3p_console, sp3m_error,
          csp3_a362_migrate_ascii_to_uni,
          csp3_n_migration, msg);
    (* *)
    msg := c_owner;
    SAPDB_PascalForcedMove(
          sizeof (triggerOwner),
          sizeof (msg),
          @triggerOwner, 1,
          @msg, c_offset,
          sizeof (msg) - c_offset);
    g01optextmsg (sp3p_console, sp3m_error,
          csp3_a362_migrate_ascii_to_uni,
          csp3_n_migration, msg);
    END;
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
