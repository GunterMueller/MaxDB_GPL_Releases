.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK18$
.tt 2 $$$
.TT 3 $ThomasA$AK_exist_rename_Table$$2000-06-05$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : AK_exist_rename_Table
=========
.sp
Purpose : Syntax und Semantic_routinen f?ur
          exist table, rename column und rename table.
 
Included 62 Changes
 
CR 1000058 UH
 
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        VAR
              a18checktable_tree : tgg00_FileId;
 
        PROCEDURE
              a18_call_semantic (VAR acv : tak_all_command_glob);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              AK_Grant_Revoke : VAK22;
 
        PROCEDURE
              a22new_version_no (VAR acv : tak_all_command_glob;
                    tab_ptr         : tak_sysbufferaddress;
                    VAR version_no  : tgg91_FileVersion;
                    VAR viewscanpar : tak_viewscan_par);
 
      ------------------------------ 
 
        FROM
              AK_warm_utility_functions : VAK37;
 
        PROCEDURE
              a37get_surrogate (VAR acv : tak_all_command_glob;
                    ti            : integer;
                    VAR surrogate : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              AK_data_dictionary : VAK38;
 
        PROCEDURE
              a38rename (VAR acv : tak_all_command_glob;
                    objtype      : integer;
                    VAR owner    : tsp00_KnlIdentifier;
                    VAR name1    : tsp00_KnlIdentifier;
                    VAR name2    : tsp00_KnlIdentifier;
                    VAR new_name : tsp00_KnlIdentifier;
                    VAR schemaId : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_VIEW_SCAN : VAK27;
 
        PROCEDURE
              a27init_viewscanpar (VAR acv : tak_all_command_glob;
                    VAR viewscanpar : tak_viewscan_par;
                    v_type          : tak_viewscantype);
 
        PROCEDURE
              a27view_scan   (VAR acv : tak_all_command_glob;
                    VAR tableid     : tgg00_Surrogate;
                    VAR viewscanpar : tak_viewscan_par);
 
      ------------------------------ 
 
        FROM
              AK_usertab_tools : VAK19;
 
        PROCEDURE
              a19add_usertab  (VAR acv : tak_all_command_glob;
                    VAR user       : tgg00_Surrogate;
                    VAR surrogate  : tgg00_Surrogate;
                    surrogate_desc : tak_usertab_descriptor);
 
        PROCEDURE
              a19del_usertab  (VAR acv : tak_all_command_glob;
                    VAR user      : tgg00_Surrogate;
                    VAR surrogate : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              AK_Alter_Table : VAK13;
 
        PROCEDURE
              a13add_dropped_columns (VAR acv : tak_all_command_glob;
                    view_level      : integer;
                    VAR viewscanpar : tak_viewscan_par);
 
        PROCEDURE
              a13store_col_alter_date (VAR acv : tak_all_command_glob;
                    VAR p_arr    : tak_syspointerarr;
                    VAR col_info : tak00_columninfo);
 
      ------------------------------ 
 
        FROM
              AK_Table : VAK11;
 
        PROCEDURE
              a11end_create_table (VAR acv : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
        PROCEDURE
              a11del_usage_entry (VAR acv : tak_all_command_glob;
                    VAR usa_tabid : tgg00_Surrogate;
                    VAR del_tabid : tgg00_Surrogate);
 
        PROCEDURE
              a11get_check_table (VAR acv : tak_all_command_glob;
                    new_table        : boolean;
                    basetable        : boolean;
                    unload_allowed   : boolean;
                    required_priv    : tak00_PrivilegeSet;
                    any_priv         : boolean;
                    all_base_rec     : boolean;
                    d_state          : tak_directory_state;
                    VAR act_tree_ind : tsp00_Int4;
                    VAR authid       : tsp00_KnlIdentifier;
                    VAR tablen       : tsp00_KnlIdentifier;
                    VAR sparr        : tak_syspointerarr);
 
        PROCEDURE
              a11glob_init (VAR acv : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
        PROCEDURE
              a11put_date_time (VAR date : tsp00_Int4;
                    VAR time : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache   : VAK10;
 
        PROCEDURE
              a10_copy_catalog_rec (VAR acv : tak_all_command_glob;
                    VAR old_key    : tgg00_SysInfoKey;
                    del_old_rec    : boolean;
                    VAR new_key    : tgg00_SysInfoKey;
                    new_segment_id : tsp00_C2;
                    add_new_rec    : boolean;
                    VAR b_err      : tgg00_BasisError);
 
        PROCEDURE
              a10repl_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_cache_delete  (VAR acv : tak_all_command_glob;
                    is_roolback : boolean);
 
        PROCEDURE
              a10get_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        PROCEDURE
              a101_DestroySchemaMap (
                    VAR acv  : tak_all_command_glob);
 
        PROCEDURE
              a101_DiagnoseDropFile(
                    VAR acv       : tak_all_command_glob;
                    VAR surrogate : tgg00_Surrogate);
 
        PROCEDURE
              a101_InsertIntoSysCheckTableLog(
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier;
                    VAR tableName  : tsp00_KnlIdentifier;
                    msgNo          : tsp00_Int4);
 
        PROCEDURE
              a101_UpdateCounter(
                    VAR acv        : tak_all_command_glob);
 
        PROCEDURE
              a101_DeleteFromSysUpdateCounterWanted(
                    VAR acv  : tak_all_command_glob;
                    VAR surr : tgg00_Surrogate);
 
        PROCEDURE
              a101_ReadSchemaMap(
                    VAR acv  : tak_all_command_glob;
                    VAR guid : tsp00_C24);
 
        PROCEDURE
              a101_ResetReturnCode(
                    VAR acv       : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate (* ptocConst *);
                    VAR schemaName : tsp00_KnlIdentifier);
 
        PROCEDURE
              a103CheckCreateInPrivilege (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier (* ptocConst *);
                    errorPos       : integer);
 
        PROCEDURE
              a103GetSchemaId (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier (* ptocConst *);
                    errorPos       : integer;
                    VAR schemaId   : tgg00_Surrogate);
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_kw_put_error (VAR acv : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    kw       : integer);
 
        PROCEDURE
              a07_nb_put_error (VAR acv : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
        PROCEDURE
              a07_b_put_error (VAR acv : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06a_mblock_init (VAR acv : tak_all_command_glob;
                    mtype        : tgg00_MessType;
                    m2type       : tgg00_MessType2;
                    VAR tree     : tgg00_FileId);
 
        PROCEDURE
              a06get_username (VAR acv : tak_all_command_glob;
                    VAR tree_index : integer;
                    VAR username   : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        FUNCTION
              a06_table_exist (VAR acv : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR authname : tsp00_KnlIdentifier;
                    VAR tablen   : tsp00_KnlIdentifier;
                    VAR sparr    : tak_syspointerarr;
                    get_all      : boolean) : boolean;
 
        PROCEDURE
              a06rsend_mess_buf (VAR acv : tak_all_command_glob;
                    VAR mblock  : tgg00_MessBlock;
                    return_req  : boolean;
                    VAR b_err   : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061copy_colinfo (VAR src_col : tak00_columninfo;
                    VAR dst_col : tak00_columninfo);
 
        FUNCTION
              a061exist_columnname (VAR base_rec : tak_baserecord;
                    VAR column      : tsp00_KnlIdentifier;
                    VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
        PROCEDURE
              a061eval_colname_len (VAR src : tak00_columninfo);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05identifier_get (VAR acv : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
        PROCEDURE
              a05_constant_get (
                    VAR acv       : tak_all_command_glob;
                    ni            : integer;
                    VAR colinfo   : tak00_columninfo;
                    may_be_longer : boolean;
                    mv_dest       : integer;
                    VAR dest      : tsp00_C28;
                    destpos       : integer;
                    VAR actlen    : integer);
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01defaultkey          : tgg00_SysInfoKey;
              a01_i_domain           : tsp00_KnlIdentifier;
              a01_i_public           : tsp00_KnlIdentifier;
              a01_il_b_identifier    : tsp00_KnlIdentifier;
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        PROCEDURE
              b01vstate_fileversion (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              KB_Logging : VKB560;
 
        PROCEDURE
              kb560StartSavepointAndWait (VAR Trans : tgg00_TransContext;
                    MessType2 : tgg00_MessType2);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30klen (VAR str : tsp00_KnlIdentifier;
                    val : char; cnt : integer) : integer;
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : vta01;
 
        PROCEDURE
              t01int4 (
                    layer : tgg00_Debug;
                    nam : tsp00_Sname;
                    int : tsp00_Int4);
&       endif
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              a05_constant_get;
 
              tsp00_MoveObj  tsp00_C28
 
        FUNCTION
              s30klen;
 
              tsp00_MoveObj   tsp00_KnlIdentifier
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ThomasA
.sp
.cp 3
Created : 1979-06-07
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-06-05
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.nf
.pb '@'
Recognizes syntax:
.sp 2
  'EXIST'  'TABLE' <table_name>
.sp
  'RENAME'  'TABLE' <table_name> 'TO' <table_name>
.sp
  'RENAME'  'COLUMN' <table_name>.<column_name> 'TO' <column_name>
.sp 4
PROCEDURE  A18_CALL_SEMANTIC:
.sp;.nf
         a18 :  1  exist  table
                2  rename table
                3  rename column
.sp 4
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
PROCEDURE  A18_CALL_SEMANTIC (VAR acv : all_command_glob);
.sp;.fo
The procedure handles the SQL commands rename column, rename table and exist
table.
.br
The cache is deleted in order to set implicitly a read inhibition on all system
infos that have been read in the course of processing. By means of
a11get_check_table, the table name of the relevant table is read from the SQL
packet, the privileges are checked and the system information of type
tbaserecord of the table is loaded into the cache. In the case of a Rename
command, the file version of the table is increased in order to ensure that all
competing users that have sysinfos in the relevant table in their cache load
this new one. Depending on the syntax tree, the procedure RENAME_TABLE or
RENAME_COLUMN is then called and the necessary system-information alterations
are performed. If an error occurs during processing, the sysinfo modifications
that have already been made are cancelled again by a06_partial_rollback.
sp 4;.nf
PROCEDURE  RENAME_TABLEN (VAR acv : all_command_glob;
                  VAR a11v : a11_glob);
.sp;.nf
The procedure takes care of the sysinfo modifications that become necessary
through the renaming of the table name of table a1authid.a1tablen. The renaming
of the authid of the table is not possible.
.br
When the procedure is called, the name of the table to be renamed has already
been stored in a1authid and a1tablen and the system information of type
tbaserecord of the table has been allocated in the cache (a1p_arr).
.br
The new authid and the new table name of the table are read from the SQL
packet. If the new authid differs from the old one, an error message is output.
.br
It is now necessary for virtually an update of the key in the field stablen to
be performed for all sysinfos of the table a1authid.a1tablen. Since key updates
are not possible, this is achieved by deleting the original records and by
inserting the new records. Apart from these key updates, it is necessary for
the table name to be updated in all sysinfos that contain information of the
table. This concerns the sysinfos of type tviewtext, tviewqual of all dependent
views, as well as tlinkrecords and tusertabrecords. The renaming operations in
the sysinfos of the dependent views are handled by a27view_scan. All other
modifications are implemented in such a manner that each sysinfo record of the
table (Key.sauthid = a1authid and Key.stablen =
a1tablen) is loaded into the cache. Then, an area of equal length is allocated
in the cache into which the record is copied with the new key. The record that
has been read is deleted in the corresponding system file and the newly built
one is inserted there. For certain types of record, further activities are
necessary apart from this key update.
.hi +5
i)@@@The record is of type tmindexrecord, i.e. it contains the descriptions of
all multiple inversions of a1authid.a1tablen. Since the corresponding BD files
have to be renamed, the stack entries of each multiple inversion are stored in
order at the end of the procedure to be able to specify the files that are to
be renamed (==> MULTI_INDEX_RENAME).
.br
ii)@@The record is of type tprivrecord, i.e. it contains the description of the
privileges of user x (in the scolname field of the key) with regard to the
table a1authid.a1tablen. The table must, therefore, be in the list of tables
that are visible for user x (tusertabrecord). The table is renamed in this list
by REN_IN_USERTAB.
.br
iii)@The record is of type tlinkrecord, i.e. it contains the name tables that
are connected by links with a1authid.a1tablen. In the tlinkrecords of these
tables, the table name must be updated in the relevant link descriptions (==>
REN_IN_LINKS).
.hi -5;
Since no tprivrecord exists for the owner of the table, the table must be
renamed by ren_in_usertab in the tusertabrecord of the owners after the
completion of all key updates.
.br
After completion of these activities, the sysinfos already have their final
appearance; the BD files that represent the table and the inversions that are
defined on it must, however, still be renamed, since the BD file names are
derived from the table name. The files are renamed by a KB request (m_rename,
mm_table) in which the stack entries of the inversions are stored in part 1 of
the message buffer, with the new table name being stored in part 2.
.sp 4;.nf
PROCEDURE  RENAME_COLUMN (VAR acv : all_command_glob;
                  VAR a11v : a11_glob);
.sp;.fo
The procedure takes care of the sysinfo modifications that become necessary
through the renaming of a column of the base table a1authid.a1tablen.
.br
When the procedure is called, the name of the relevant table has already been
stored in a1authid and a1tablen and the system information of type tbaserecord
of the table has been allocated in the cache (a1p_arr).
.br
The column name that is to be altered and the new column name are read from the
SQL packet. If the "old" column name exists, it is replaced in the
corresponding column description by the "new" one. Sorting according to column
names in the and the writing-back of the tbaserecords is handled by
a11end_create_table.
.br
The modification of the version number as well as any necessary column renaming
in views dependent on a1authid.a1tablen are performed by a27view_scan.
.sp 4;.nf
PROCEDURE  MULTI_INDEX_RENAME (VAR acv : all_command_glob;
                  VAR a11v         : a11_glob;
                  VAR syspointer   : tsysbufferaddress;
                  VAR stack        : all_stack_entries;
                  VAR stackpointer : integer);
.sp;.fo
The procedure writes a stack entry of each multiple index of the transferred
tmindexrecord (syspointer^) to the stack.
.br
The stack entries are required by KB for renaming the corresponding index BD
files, since their names are composed of the table name and an index number
from the stack entries.
.sp 4;.nf
PROCEDURE  REN_IN_LINKS (VAR acv : all_command_glob;
                  VAR a11v           : a11_glob;
                  VAR linksyspointer : tsysbufferaddress);
.sp;.fo
When the procedure is called, a tlinkrecord with descriptions of links between
the renamed table a1authid.a1tablen and other base tables has been allocated
starting at address linksyspointer. The name a1tablen must be replaced by the
new table name in the tlinkrecords of these tables. This is done by calling
a25rename_tab_in_link.
.sp 4;.nf
PROCEDURE  REN_IN_USERTAB (VAR acv : all_command_glob;
                  VAR a11v        : a11_glob;
                  VAR viewscanpar : viewscan_par;
                  username        : user_id);
.sp;.fo
A search is made for the table a1authid.a1tablen in the sysinfos of type
tusertabrecord of the user username and, if it is found there, the table is
renamed a1authid.vsc_new_tablen. The corresponding tusertabrecord is written
back to system file 2.
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_newtable       = true (* a11get_check_table   *);
      c_basetable      = true (* a11get_check_table   *);
      c_unload_allowed = true (* a11get_check_table   *);
      c_any_priv       = true (* a11get_check_table   *);
      c_all_base_rec   = true (* a11get_check_table   *);
      c_get_all        = true (* a06_table_exist      *);
      c_return_req     = true (* a06rsend_mbuf        *);
      c_is_rollback    = true;
      (* CR 1000058 UH *)
 
 
(*------------------------------*) 
 
PROCEDURE
      a18_call_semantic (VAR acv : tak_all_command_glob);
 
VAR
      b_err       : tgg00_BasisError;
      requiredPriv: tak00_PrivilegeSet;
      a11v        : tak_a11_glob;
      curr_schema : tsp00_KnlIdentifier;
      viewscanpar : tak_viewscan_par;
      col_buf     : tak00_colinfo_ptr;
      fieldno     : integer;
      new_longs   : integer;
 
BEGIN
WITH acv, a11v, a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ] DO
    BEGIN
    a11glob_init (acv, a11v);
    a1ti := a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_lo_level;
    CASE n_subproc OF
        cak_x_check_table_system_table :
            a101_UpdateCounter (acv);
        (* PTS 1108979 E.Z. *)
        cak_i_check, cak_i_savepoint, cak_i_catalog, cak_i_lock :
            BEGIN
            IF  acv.a_curr_user_name = a01_i_domain (* PTS 1109359 *)
            THEN
                requiredPriv := []
            ELSE
                requiredPriv := [r_owner];
            (*ENDIF*) 
            a11get_check_table (acv, NOT c_newtable, c_basetable,
                  NOT c_unload_allowed, requiredPriv,
                  c_any_priv AND (requiredPriv <> []),
                  (* PTS 1109905 E.Z. *)
                  ((n_subproc = cak_i_check) OR (n_subproc = cak_i_lock)),
                  d_release, a1ti, a1authname, a1tablen, a_p_arr1);
            IF  a_returncode = 0
            THEN
                WITH a_p_arr1.pbasep^.sbase DO
                    BEGIN
                    IF  n_subproc = cak_i_catalog
                    THEN
                        ak18check_table_catalog (acv)
                    ELSE
                        BEGIN
                        (* PTS 1108979 E.Z. *)
                        IF  n_subproc = cak_i_lock
                        THEN
                            a06a_mblock_init (acv, m_verify, mm_lock,
                                  btreeid)
                        ELSE
                            a06a_mblock_init (acv, m_verify, mm_table,
                                  btreeid);
                        (*ENDIF*) 
                        a_mblock.mb_qual^.mtree. fileLeafNodes_gg00 :=
                              cgg_nil_leafnodes;
                        (* PTS 1125096 E.Z. *)
                        a_mblock.mb_qual^.mv_longcnt    := bstringcount;
                        a_mblock.mb_qual^.mv_newlongcnt := 0;
                        IF  bstringcount > 0
                        THEN
                            BEGIN
                            fieldno   := 1;
                            new_longs := 0;
                            col_buf   := bcolumn[bfirstcolind];
                            WHILE fieldno <= bmaxcol DO
                                WITH col_buf^ DO
                                    BEGIN
                                    IF  cdatatyp in [dlonga, dlongb,
                                        dlonguni]
                                    THEN
                                        new_longs := succ(new_longs);
                                    (*ENDIF*) 
                                    IF  cnextind > 0
                                    THEN
                                        col_buf := bcolumn[cnextind];
                                    (*ENDIF*) 
                                    fieldno := succ(fieldno)
                                    END;
                                (*ENDWITH*) 
                            (*ENDWHILE*) 
                            a_mblock.mb_qual^.mv_newlongcnt := new_longs;
                            END;
                        (*ENDIF*) 
                        a_mblock.mb_qual^.mv_extended := false;
                        a1ti := a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_sa_level;
                        IF  a1ti <> 0
                        THEN
                            IF  (a_ap_tree^[a1ti].n_proc = a30) AND
                                (a_ap_tree^[a1ti].n_subproc = cak_x_extended_check)
                            THEN
                                a_mblock.mb_qual^.mv_extended := true;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        a06rsend_mess_buf (acv, a_mblock,
                              c_return_req, b_err);
                        IF  (b_err = e_ok) AND
                            (n_subproc = cak_i_lock)
                        THEN
                            BEGIN
                            a101_DeleteFromSysUpdateCounterWanted (acv,
                                  btreeid.fileTabId_gg00);
                            a101_ResetReturnCode (acv); (* ignore errors *)
                            END;
                        (*ENDIF*) 
                        IF  (b_err = e_ok) AND
                            (n_subproc <> cak_i_savepoint)
                        THEN
                            BEGIN
                            kb560StartSavepointAndWait (a_transinf.tri_trans, mm_test);
                            b_err := a_transinf.tri_trans.trError_gg00
                            END;
                        (*ENDIF*) 
                        IF  b_err <> e_ok
                        THEN
                            a07_b_put_error (acv, b_err, 1);
                        (*ENDIF*) 
                        a101_InsertIntoSysCheckTableLog (
                              acv, a1authname, a1tablen, acv.a_returncode)
                        END;
                    (*ENDIF*) 
                    (* CR 1000058 UH *)
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
        cak_i_exists :
            BEGIN
            IF  a_ap_tree^[ a1ti ].n_symb = s_authid
            THEN
                a06get_username (acv, a1ti, a1authname);
            (*ENDIF*) 
            a05identifier_get (acv, a1ti, sizeof (a1tablen), a1tablen);
            IF  NOT a06_table_exist (acv,
                d_release, a1authname, a1tablen, a_p_arr1, c_get_all)
            THEN
                a07_nb_put_error (acv, e_unknown_tablename,
                      a_ap_tree^[ a1ti ].n_pos, a1tablen)
            (*ENDIF*) 
            END;
        cak_i_diagnose : (* PTS 1115972 *)
            ak18DropFile (acv, a1ti);
        cak_i_off :
            BEGIN
            a101_DestroySchemaMap (acv);
            acv.a_return_segm^.sp1r_function_code := csp1_create_table_fc;
            END;
        cak_i_translate :
            ak18TranslateSchema (acv, a1ti);
        OTHERWISE
            BEGIN
            a27init_viewscanpar (acv, viewscanpar, v_rename_table);
            a10_cache_delete (acv, NOT c_is_rollback);
            IF  a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_subproc = cak_i_public
            THEN
                BEGIN
                curr_schema   := a_curr_schema;
                a_curr_schema := a01_i_public;
                END;
            (*ENDIF*) 
            a11get_check_table (acv,
                  NOT c_newtable, n_subproc = cak_i_table,
                  c_unload_allowed, [r_owner],  NOT c_any_priv,
                  c_all_base_rec, d_fix, a1ti,
                  a1authname, a1tablen, a_p_arr1);
            IF  a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_subproc = cak_i_public
            THEN
                a_curr_schema := curr_schema;
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                WITH a_p_arr1.pbasep^.sbase DO
                    BEGIN
                    a11put_date_time (balterdate, baltertime);
                    a1tableid := bsurrogate;
                    a22new_version_no (acv, a_p_arr1.pbasep,
                          viewscanpar.vsc_filevers, viewscanpar);
                    viewscanpar.vsc_rp_rt_handling := false
                    END;
                (*ENDWITH*) 
                IF  a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc = cak_i_column
                THEN
                    ak18ren_column (acv, a11v, viewscanpar)
                ELSE
                    ak18ren_tablen (acv, a11v, viewscanpar)
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        END;
    (*ENDCASE*) 
    IF  a_returncode <> 0
    THEN
        a_part_rollback := true
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak18check_table_catalog (VAR acv : tak_all_command_glob);
 
VAR
      replace     : boolean;
      b_err       : tgg00_BasisError;
      ix          : integer;
      usage_index : integer;
      lvarcolcnt  : integer;
      linkage     : tsp00_C2;
      dummy_ptr   : tak_sysbufferaddress;
      tabkey      : tgg00_SysInfoKey;
      sysp        : tak_sysbufferaddress;
      sysk        : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a_p_arr1.pbasep^.sbase DO
    BEGIN
    b_err      := e_ok;
    lvarcolcnt := 0;
    ix         := bfirstcolind;
    replace    := false;
&   ifdef trace
    t01int4 (test_ak, 'bfirstindex ', bfirstindex);
    t01int4 (test_ak, 'blastindex  ', blastindex);
    t01int4 (test_ak, 'bmaxcol     ', bmaxcol);
    t01int4 (test_ak, 'bfirstcolin ', bfirstcolind);
    t01int4 (test_ak, 'blastkeyind ', blastkeyind);
    t01int4 (test_ak, 'bkeycolcount', bkeycolcount);
&   endif
    REPEAT
&       ifdef trace
        t01int4 (test_ak, 'ix          ', ix);
&       endif
        WITH a103GetColumn (a_p_arr1.pbasep^.sbase, ix)^ DO
            BEGIN
            IF  (btablekind in [twithkey, twithoutkey])
            THEN
                BEGIN
&               ifdef trace
                t01int4 (test_ak, 'check colsta', ix);
&               endif
                IF  ccolstack.eop in [op_unique, op_unique_desc,
                    op_order_desc, op_order_asc]
                THEN
                    BEGIN
&                   ifdef trace
                    t01int4 (test_ak, 'repaircolsta', ix);
&                   endif
                    ccolstack.eop := op_none;
                    IF  ctunused in ccolpropset
                    THEN
                        ccolpropset := ccolpropset - [ ctunused ];
                    (*ENDIF*) 
                    replace       := true;
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  ccolstack.etype = st_varlongchar
            THEN
                BEGIN
                lvarcolcnt := succ(lvarcolcnt);
                IF  ccolstack.ecolno <> lvarcolcnt
                THEN
                    BEGIN
                    ccolstack.ecolno := lvarcolcnt;
                    replace := true;
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            sysk := a_p_arr1.pbasep^.syskey;
            IF  (ctaltered in ccolpropset) AND
                (btablekind in [twithkey, twithoutkey])
            THEN
                BEGIN
                sysk.sentrytyp   := cak_ealterdate;
                sysk.slinkage[1] := chr (creccolno DIV 256);
                sysk.slinkage[2] := chr (creccolno MOD 256);
                a10get_sysinfo (acv, sysk, d_release,
                      sysp, b_err);
                IF  b_err = e_sysinfo_not_found
                THEN
                    BEGIN
                    ccolpropset := ccolpropset - [ctaltered];
                    replace     := true;
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  (ctdomain in ccolpropset) AND
                (btablekind in [twithkey, twithoutkey])
            THEN
                BEGIN
                sysk.sentrytyp   := cak_edomainusage;
                sysk.slinkage[1] := chr (creccolno DIV 256);
                sysk.slinkage[2] := chr (creccolno MOD 256);
                a10get_sysinfo (acv, sysk, d_release,
                      sysp, b_err);
                IF  b_err = e_sysinfo_not_found
                THEN
                    BEGIN
                    ccolpropset := ccolpropset - [ctdomain];
                    replace     := true;
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  ctcomment in ccolpropset
            THEN
                BEGIN
                sysk.sentrytyp  := cak_ecomment;
                sysk.stablen[1] := chr(ord (cm_column));
                sysk.stablen[2] := chr (cextcolno DIV 256);
                sysk.stablen[3] := chr (cextcolno MOD 256);
                sysk.skeylen    := sysk.skeylen + 3;
                a10get_sysinfo (acv, sysk, d_release,
                      sysp, b_err);
                IF  b_err = e_sysinfo_not_found
                THEN
                    BEGIN
                    ccolpropset := ccolpropset - [ctcomment];
                    replace     := true;
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            ix := cnextind;
            END;
        (*ENDWITH*) 
    UNTIL
        (ix = 0);
    (*ENDREPEAT*) 
    IF  (btablekind in [twithkey, twithoutkey])
    THEN
        BEGIN (* check file version *)
        b01vstate_fileversion (a_transinf.tri_trans,
              a_p_arr1.pbasep^.sbase.btreeid);
        IF  a_transinf.tri_trans.trError_gg00 = e_old_fileversion (* PTS:1117792 *)
        THEN
            replace := true
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  replace
    THEN
        a10repl_sysinfo (acv, a_p_arr1.pbasep, b_err);
    (*ENDIF*) 
    IF  (a_returncode = 0) AND (b_err = e_ok)
    THEN
        BEGIN
        usage_index := 0;
        linkage     := a01defaultkey.slinkage;
        REPEAT
            sysk           := a_p_arr1.pbasep^.syskey;
            sysk.sentrytyp := cak_eusage;
            sysk.slinkage  := linkage;
            a10get_sysinfo (acv,
                  sysk, d_release, a_ptr1, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                usage_index := usage_index + 1;
                IF  usage_index > a_ptr1^.susage.usagecount
                THEN
                    IF  a_ptr1^.susage.usagenext_exist
                    THEN
                        BEGIN
                        a06inc_linkage (linkage);
                        usage_index := 0
                        END
                    ELSE
                        b_err := e_sysinfo_not_found
                    (*ENDIF*) 
                ELSE
                    WITH a_ptr1^.susage.usagedef[usage_index] DO
                        BEGIN
                        tabkey          := a01defaultkey;
                        tabkey.stableid := usa_tableid;
                        a10get_sysinfo (acv,
                              tabkey, d_release, dummy_ptr, b_err);
                        IF  b_err = e_sysinfo_not_found
                        THEN
                            BEGIN
                            b_err := e_ok;
                            a11del_usage_entry (acv, bsurrogate, usa_tableid);
                            usage_index := usage_index - 1
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            (b_err <> e_ok) OR (a_returncode <> 0);
        (*ENDREPEAT*) 
        IF  b_err <> e_sysinfo_not_found
        THEN
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE (* PTS 1115972 *)
      ak18DropFile (VAR acv : tak_all_command_glob;
            tree_index : integer);
 
VAR
      tabid    : tgg00_Surrogate;
 
BEGIN
a37get_surrogate (acv, tree_index, tabid);
IF  acv.a_returncode = 0
THEN
    IF  (acv.a_current_user_kind in [uprivate, unoprivate])
    THEN
        a07_b_put_error (acv, e_missing_privilege, 1)
    ELSE
        a101_DiagnoseDropFile (acv, tabid);
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak18TranslateSchema (
            VAR acv    : tak_all_command_glob;
            tree_index : integer);
 
CONST
      c_may_be_longer = true;
 
VAR
      length  : integer;
 
      guid    : RECORD
            CASE boolean OF
                true :
                    (defByte : tsp00_C1;
                    c24     : tsp00_C24);
                false :
                    (c28 : tsp00_C28);
                END;
            (*ENDCASE*) 
 
      colInfo : tak00_columninfo;
 
BEGIN
&ifdef trace
t01int4 (ak_sem, 'tree_index  ', tree_index);
&endif
colInfo.cextcolno          := 1;
colInfo.creccolno          := 1;
colInfo.ctabno             := 1;
colInfo.cdatatyp           := dchb;
colInfo.cdatalen           := sizeof(guid.c24);
colInfo.cinoutlen          := 1 + colInfo.cdatalen;
colInfo.cdatafrac          := cak_frac_offset;
colInfo.ccolpropset        := [];
length                     := 0;
colInfo.ccolstack.etype    := st_fixcol;
colInfo.ccolstack.epos     := 1;
colInfo.ccolstack.elen_var := colInfo.cinoutlen;
a05_constant_get (acv, tree_index, colInfo, NOT c_may_be_longer,
      1 + sizeof(guid.c24), guid.c28, 1, length);
IF  acv.a_returncode = 0
THEN
    a101_ReadSchemaMap(acv, guid.c24);
(*ENDIF*) 
acv.a_return_segm^.sp1r_function_code := csp1_create_table_fc;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak18ren_column (VAR acv : tak_all_command_glob;
            VAR a11v          : tak_a11_glob;
            VAR viewscanpar   : tak_viewscan_par);
 
VAR
      ti         : integer;
      index      : integer;
      col_ptr    : tak00_colinfo_ptr;
      col_info   : tak00_columninfo;
      schemaName : tsp00_KnlIdentifier;
 
BEGIN
WITH acv,  viewscanpar, a11v  DO
    IF  a_returncode = 0
    THEN
        BEGIN
        vsc_type := v_rename_column;
        a1ti     := a_ap_tree^[ a1ti ].n_sa_level;
        a05identifier_get (acv, a1ti,
              sizeof (vsc_oldcolname), vsc_oldcolname);
        IF  NOT (a061exist_columnname (a_p_arr1.pbasep^.sbase, vsc_oldcolname,
            col_ptr))
        THEN
            a07_b_put_error (acv,
                  e_unknown_columnname, a_ap_tree^[ a1ti ].n_pos)
        ELSE
            BEGIN
            ti := a_ap_tree^[ a1ti ].n_lo_level;
            WITH a_ap_tree^[ ti ] DO
                BEGIN
                vsc_quotes     := a_cmd_part^.sp1p_buf[ n_pos-1 ] = '"';
                a05identifier_get (acv, ti,
                      sizeof (vsc_newcolname), vsc_newcolname);
                vsc_newcol_len := n_length;
                END;
            (*ENDWITH*) 
            vsc_rename_set   := [ col_ptr^.cextcolno ];
            vsc_col_extcolno := col_ptr^.cextcolno;
            vsc_col_dropped := true;
            a103GetSchemaName (acv, a_p_arr1.pbasep^.sbase.bschema,
                  schemaName); (* PTS 1132495 M.Ki *)
            IF  acv.a_returncode = 0
            THEN
                a38rename (acv, cak_i_column,
                      a1authname, a1tablen, vsc_oldcolname, vsc_newcolname,
                      schemaName);
            (*ENDIF*) 
            IF  a_p_arr1.pbasep^.sbase.btablekind in
                [twithkey, twithoutkey, tdb2view]
            THEN
                BEGIN
                a13add_dropped_columns (acv, 0, viewscanpar);
                a061copy_colinfo (col_ptr^, col_info);
                col_info.ccolumnn := vsc_newcolname;
                a061eval_colname_len (col_info);
                WITH a_p_arr1.pbasep^.sbase DO
                    BEGIN
                    index := bextcolindex[col_ptr^.cextcolno] +
                          bfirstindex;
                    bcolumn[index] := @col_info;
                    END;
                (*ENDWITH*) 
                a13store_col_alter_date (acv, a_p_arr1, col_info);
                a1sort   := true;
                a11end_create_table (acv, a11v);
                a10_cache_delete    (acv, NOT c_is_rollback)
                END
            ELSE
                vsc_col_list := a_p_arr1.pbasep^.sbase.bv_viewlist;
            (*ENDIF*) 
            a27view_scan (acv, viewscanpar.vsc_base_tabid,
                  viewscanpar)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak18ren_tablen (VAR acv : tak_all_command_glob;
            VAR a11v          : tak_a11_glob;
            VAR viewscanpar   : tak_viewscan_par);
 
CONST
      c_add_new = true;
      c_del_old = true;
 
VAR
      isSynonym     : boolean;
      newSchema     : boolean;
      tabKind       : tak_usertab_descriptor;
      b_err         : tgg00_BasisError;
      segment_id    : tsp00_C2;
      user_pos      : integer;
      sysp          : tak_sysbufferaddress;
      schemaName    : tsp00_KnlIdentifier;
      newSchemaName : tsp00_KnlIdentifier;
      new_syskey    : tgg00_SysInfoKey;
      sysk          : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a11v, viewscanpar DO
    BEGIN
    newSchema     := false;
    newSchemaName := a01_il_b_identifier;
    isSynonym     := false;
    b_err         := e_ok;
    WITH a_p_arr1.pbasep^.sbase DO
        CASE a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_subproc OF
            cak_i_public, cak_i_synonym :
                IF  NOT a_p_arr1.psynfound
                THEN
                    b_err := e_unknown_synonymname
                ELSE
                    isSynonym := true;
                (*ENDIF*) 
            cak_i_table :
                IF  (btablekind <> twithkey) AND
                    (btablekind <> twithoutkey)
                THEN
                    b_err := e_missing_basetable
                ELSE
                    IF  (internal_trigger in blinkexist)
                    THEN
                        b_err := e_replicated_table_not_allowed;
                    (*ENDIF*) 
                (*ENDIF*) 
            cak_i_view :
                IF  NOT (btablekind in [tonebase, tview, tcomplexview])
                THEN
                    b_err := e_missing_viewtable;
                (*ENDIF*) 
            END;
        (*ENDCASE*) 
    (*ENDWITH*) 
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, a_ap_tree^[a1ti].n_pos)
    ELSE
        BEGIN
        vsc_type         := v_rename_table;
        vsc_old_tablen   := a1tablen;
        a1ti             := a_ap_tree^[ a1ti ].n_lo_level;
        user_pos         := a_ap_tree^[ a1ti ].n_pos;
        IF  a_ap_tree^[ a1ti ].n_symb = s_authid
        THEN
            BEGIN
            newSchema := true;
            a05identifier_get (acv, a1ti,
                  sizeof (vsc_new_authname), vsc_new_authname);
            a1ti := a_ap_tree^[ a1ti ].n_sa_level;
            END;
        (*ENDIF*) 
        a05identifier_get (acv, a1ti,
              sizeof (vsc_new_tablen), vsc_new_tablen);
        IF  a_returncode = 0
        THEN
            BEGIN
            WITH a_ap_tree^ [ a1ti ] DO
                vsc_quotes := a_cmd_part^.sp1p_buf[ n_pos-1 ] = '"';
            (*ENDWITH*) 
            WITH sysk DO
                BEGIN
                IF  a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_subproc = cak_i_public
                THEN
                    sauthid := cak_public_id
                ELSE
                    IF  isSynonym
                    THEN
                        sauthid := a_curr_user_id
                    ELSE
                        sauthid := a_p_arr1.pbasep^.sbase.bschema;
                    (*ENDIF*) 
                (*ENDIF*) 
                sidentifier := vsc_old_tablen;
                sentrytyp   := cak_etableref;
                slinkage    := cak_init_linkage;
                skeylen     := mxak_standard_sysk + sizeof (sidentifier)
                END;
            (*ENDWITH*) 
            new_syskey := sysk;
            IF  newSchema
            THEN
                BEGIN
                newSchemaName := vsc_new_authname;
                a103GetSchemaId (acv, vsc_new_authname, user_pos, new_syskey.sauthid);
                IF  a_returncode = 0
                THEN
                    a103CheckCreateInPrivilege (acv, vsc_new_authname, user_pos);
                (*ENDIF*) 
                IF  a_returncode = 0
                THEN
                    IF  new_syskey.sauthid <> a_p_arr1.pbasep^.sbase.bschema
                    THEN
                        BEGIN (* a new schema name has been given *)
                        IF  a_p_arr1.pbasep^.sbase.bschema <> a_p_arr1.pbasep^.sbase.bauthid
                        THEN
                            a19del_usertab  (acv, a_p_arr1.pbasep^.sbase.bauthid,
                                  a_p_arr1.pbasep^.sbase.bsurrogate);
                        (*ENDIF*) 
                        IF  new_syskey.sauthid <> a_p_arr1.pbasep^.sbase.bauthid
                        THEN
                            BEGIN
                            IF  a_p_arr1.pbasep^.sbase.btablekind in
                                [twithkey, twithoutkey]
                            THEN
                                tabKind := ut_base_table
                            ELSE
                                tabKind := ut_view;
                            (*ENDIF*) 
                            a19add_usertab  (acv, a_p_arr1.pbasep^.sbase.bauthid,
                                  a_p_arr1.pbasep^.sbase.bsurrogate, tabKind);
                            END
                        ELSE
                            vsc_new_authname := a01_il_b_identifier;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                new_syskey.sidentifier := vsc_new_tablen;
                segment_id             := a_p_arr1.pbasep^.sbase.bsegmentid;
                sysp                   := NIL;
                a10get_sysinfo (acv, new_syskey, d_release,
                      sysp, b_err);
                IF  b_err = e_ok
                THEN
                    a07_nb_put_error (acv, e_duplicate_tablename,
                          a_ap_tree^[a1ti].n_pos, vsc_new_tablen)
                ELSE
                    a10_copy_catalog_rec (acv, sysk,
                          c_del_old, new_syskey, segment_id,
                          c_add_new, b_err);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  (b_err = e_ok) AND
                (a_returncode = 0)
            THEN
                BEGIN
                IF  NOT isSynonym
                THEN
                    a103GetSchemaName (acv, a_p_arr1.pbasep^.sbase.bschema,
                          schemaName)  (* PTS 1132495 M.Ki *)
                ELSE
                    schemaName := a01_il_b_identifier;
                (*ENDIF*) 
                IF  newSchemaName = a01_il_b_identifier
                THEN
                    newSchemaName := schemaName;
                (*ENDIF*) 
                IF  a_returncode = 0
                THEN
                    BEGIN
                    a38rename (acv,
                          a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_subproc,
                          a1authname, a1tablen, newSchemaName,
                          vsc_new_tablen, schemaName);
                    IF  a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc in
                        [cak_i_public, cak_i_synonym]
                    THEN
                        BEGIN (* rename in synonym record *)
                        sysk          := a01defaultkey;
                        sysk.stableid := a_p_arr1.psynid;
                        a10get_sysinfo (acv, sysk, d_release,
                              sysp, b_err);
                        IF  b_err = e_ok
                        THEN
                            BEGIN
                            IF  a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_subproc = cak_i_public
                            THEN
                                IF  sysp^.ssynonym.syn_owner <>
                                    a_curr_user_id
                                THEN
                                    a07_kw_put_error (acv,
                                          e_missing_privilege,
                                          1, cak_i_userid);
                                (*ENDIF*) 
                            (*ENDIF*) 
                            IF  a_returncode = 0
                            THEN
                                BEGIN
                                vsc_old_tablen := sysp^.ssynonym.syn_tablen;
                                sysp^.ssynonym.syn_tablen := vsc_new_tablen;
                                a10repl_sysinfo (acv, sysp, b_err);
                                vsc_ren_tabid := sysk.stableid
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        vsc_type := v_version
                        END
                    ELSE
                        vsc_ren_tabid := vsc_start_tabid;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  b_err = e_ok
                THEN
                    BEGIN
                    WITH a_p_arr1.pbasep^.sbase DO
                        BEGIN
                        IF  NOT isSynonym
                        THEN
                            BEGIN
                            bschema  := new_syskey.sauthid;
                            btablen^ := vsc_new_tablen;
                            END;
                        (*ENDIF*) 
                        IF  btablekind in
                            [twithkey, twithoutkey, tdb2view]
                        THEN
                            BEGIN
                            (* update tbaserecords in case       *)
                            (* of a base table, otherwise        *)
                            (* this will be done by a27view_scan *)
                            a11end_create_table (acv, a11v)
                            END
                        ELSE
                            IF  (btablekind = tcomplexview) OR
                                (bv_tablekind in [tshow_view, tcatalog_table])
                            THEN
                                a10repl_sysinfo (acv, a_p_arr1.pbasep, b_err);
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    (*ENDWITH*) 
                    END;
                (*ENDIF*) 
                IF  (b_err = e_ok) AND
                    (a_returncode = 0)
                THEN
                    BEGIN
                    vsc_old_len :=
                          s30klen (a1tablen, bsp_c1, sizeof (a1tablen));
                    vsc_new_len  :=
                          s30klen (vsc_new_tablen,
                          bsp_c1, sizeof (vsc_new_tablen));
                    vsc_col_dropped := false;
                    a27view_scan (acv, viewscanpar.vsc_base_tabid,
                          viewscanpar);
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
