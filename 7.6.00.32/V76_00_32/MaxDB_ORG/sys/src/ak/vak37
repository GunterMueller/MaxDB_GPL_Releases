.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-24
*****************************************************
modname : VAK37
changed : 2000-11-24
module  : AK_warm_utility_functions
 
Author  : ThomasA
Created : 1985-02-06
*****************************************************
 
Purpose : Behandlung von DBS_Utility-Auftr?age im warmen Betrieb.
 
Define  :
 
        PROCEDURE
              a37_call_semantic (
                    VAR acv               : tak_all_command_glob;
                    VAR util_cmd_id       : tgg00_UtilCmdId);
 
        FUNCTION
              a37blocksize (
                    VAR acv  : tak_all_command_glob;
                    VAR a30v : tak_a30_utility_glob) : tsp00_Int2;
 
        PROCEDURE
              a37get_surrogate (
                    VAR acv       : tak_all_command_glob;
                    ti            : integer;
                    VAR surrogate : tgg00_Surrogate);
 
        FUNCTION
              a37hex2char (
                    VAR acv : tak_all_command_glob;
                    hexpos : integer) : char;
 
        PROCEDURE
              a37char2hex (
                    input      : char;
                    VAR output : tsp00_C2);
 
        PROCEDURE
              a37return_hostname (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a37init_util_record (
                    VAR acv : tak_all_command_glob;
                    m_type  : tgg00_MessType;
                    mm_type : tgg00_MessType2);
 
        PROCEDURE
              a37media_name (
                    VAR acv  : tak_all_command_glob;
                    VAR ti   : tsp00_Int2;
                    VAR qual : tgg00_QualBuf);
 
        PROCEDURE
              a37label_name (
                    VAR acv  : tak_all_command_glob;
                    VAR ti   : tsp00_Int2;
                    VAR qual : tgg00_QualBuf);
 
        PROCEDURE
              a37multi_tape_info (
                    VAR acv  : tak_all_command_glob;
                    kw_index : integer);
 
        PROCEDURE
              a37put_count_to_messbuf (
                    VAR acv   : tak_all_command_glob;
                    VAR a30v  : tak_a30_utility_glob);
 
        PROCEDURE
              a37state_get (
                    VAR acv  : tak_all_command_glob;
                    kw_index : integer);
 
        PROCEDURE
              a37state_vtrace (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a37vtrace (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a37utilprot_needed (
                    VAR acv           : tak_all_command_glob;
                    VAR prot_needed   : boolean;
                    VAR with_tapeinfo : boolean);
 
        PROCEDURE
              a37ddl (
                    VAR acv : tak_all_command_glob;
                    ddl_id : tak30_ddl_kind);
 
        PROCEDURE
              a37insert_event (event : tsp31_event_ident);
 
        PROCEDURE
              a37resultevent (
                    ident   : tsp31_event_ident;
                    retcode : tsp00_Int2);
 
        PROCEDURE
              a37stop_all_vtrace (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a37verify_catalog (
                    VAR acv      : tak_all_command_glob;
                    do_repair    : boolean;
                    in_migration : boolean);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061get_colname (
                    VAR col_info : tak00_columninfo;
                    VAR colname  : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_User_Password : VAK21;
 
        PROCEDURE
              a21_call_semantic  (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
      ------------------------------ 
 
        FROM
              AK_Index : VAK24;
 
        PROCEDURE
              a24get_indexname (
                    VAR acv        : tak_all_command_glob;
                    indexbuf       : tak_sysbufferaddress;
                    index          : integer;
                    VAR index_name : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              Kernel_Sink_1 : VAK341;
 
        PROCEDURE
              ak341HeapCallStackMonitoring (level : integer);
 
        PROCEDURE
              ak341Shutdown;
 
      ------------------------------ 
 
        FROM
              AK_data_dictionary : VAK38;
 
        PROCEDURE
              a38create_parameter_file (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a38insert_parameters (
                    VAR acv        : tak_all_command_glob;
                    key_prefix     : tsp00_Int4;
                    VAR objecttype : tsp00_Name;
                    VAR username   : tsp00_KnlIdentifier;
                    VAR name1      : tsp00_KnlIdentifier;
                    VAR name2      : tsp00_KnlIdentifier;
                    VAR name3      : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542internal_packet (
                    VAR acv                 : tak_all_command_glob;
                    release_internal_packet : boolean;
                    required_len            : tsp00_Int4);
 
        PROCEDURE
              a542move_to_packet (
                    VAR acv    : tak_all_command_glob;
                    const_addr : tsp00_MoveObjPtr;
                    const_len  : tsp00_Int4);
 
        PROCEDURE
              a542pop_packet (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              diagnose monitor : VAK545;
 
        PROCEDURE
              a545clear_monitor (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a545sm_data_tree (
                    VAR acv          : tak_all_command_glob;
                    VAR mondata_tree : tgg00_FileId);
 
        PROCEDURE
              a545sm_reset (VAR monitor_tree : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              diagnose analyze : VAK544;
 
        PROCEDURE
              a544semantik_diag_analyze (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              Execute_factor_constants : VAK642;
 
        VAR
              a642standard_colinfo : tak00_columninfo;
 
      ------------------------------ 
 
        FROM
              object_garbage_collection : VBD91;
 
        PROCEDURE
              bd91CheckIndex (VAR Trans : tgg00_TransContext;
                    ObjFileNo  : tsp00_C16);
 
        PROCEDURE
              bd91RecreateIndex (VAR Trans : tgg00_TransContext;
                    ObjFileNo  : tsp00_C16);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : vta01;
 
        PROCEDURE
              t01int4 (
                    layer : tgg00_Debug;
                    nam : tsp00_Sname;
                    int : tsp00_Int4);
 
        PROCEDURE
              t01moveobj (
                    layer       : tgg00_Debug;
                    VAR moveobj : tsp00_MoveObj;
                    start_pos   : tsp00_Int4;
                    end_pos     : tsp00_Int4);
 
        PROCEDURE
              t01minbuf (min_wanted : boolean);
 
        PROCEDURE
              t01multiswitch (
                    VAR s20  : tsp00_C20;
                    VAR s201 : tsp00_C20 );
 
        PROCEDURE
              t01lmulti_switch (
                    VAR s20      : tsp00_C20;
                    VAR s201     : tsp00_C20;
                    VAR on_text  : tsp00_C16;
                    VAR off_text : tsp00_C16;
                    on_count     : integer);
 
        PROCEDURE
              t01SetSingleUser;
 
        PROCEDURE
              t01setmaxbuflength (max_len : tsp00_Int4);
 
        PROCEDURE
              t01surrogate (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR tabid : tgg00_Surrogate);
 
        PROCEDURE
              t01lidentifier (
                    debug      : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier);
&       endif
 
      ------------------------------ 
 
        FROM
              AK_Lock_Commit_Rollback  : VAK52;
 
        PROCEDURE
              a52_call_semantik (
                    VAR acv : tak_all_command_glob;
                    subproc : tsp00_Int2);
 
        PROCEDURE
              a52_ex_commit_rollback (
                    VAR acv                   : tak_all_command_glob;
                    m_type                    : tgg00_MessType;
                    n_rel                     : boolean;
                    normal_release            : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Connect  : VAK51;
 
        PROCEDURE
              a51_connect (
                    VAR acv         : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Show_statistics : VAK42;
 
        PROCEDURE
              a42index_inf_to_messbuf(
                    VAR acv         : tak_all_command_glob;
                    VAR mblock      : tgg00_MessBlock;
                    VAR a41v        : tak40_show_glob;
                    VAR indexn      : tsp00_KnlIdentifier;
                    VAR selectivity : boolean;
                    diagnose_index  : boolean);
 
        PROCEDURE
              a42_start_semantic (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a42name_and_val_statistic (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob;
                    VAR vkw  : tak_keyword;
                    value    : tsp00_Int4;
                    VAR nam  : tsp00_Sname);
 
      ------------------------------ 
 
        FROM
              AK_show_syntax : VAK41;
 
        PROCEDURE
              a41reset_all (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a41reset (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_cold_utility_functions : VAK36;
 
        PROCEDURE
              a36after_systable_load (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a36devname (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    VAR dname   : tsp00_VFilename;
                    dlen        : integer);
 
        PROCEDURE
              a36filename (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    VAR fname   : tsp00_VFilename;
                    fnlen       : integer);
 
        FUNCTION
              a36filetype (
                    VAR acv      : tak_all_command_glob;
                    tree_index   : tsp00_Int2;
                    VAR filetype : tsp00_VfType) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_distributor : VAK35;
 
        PROCEDURE
              a35_asql_statement (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a35_flush_vtrace (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_VIEW_SCAN : VAK27;
 
        PROCEDURE
              a27init_viewscanpar (
                    VAR acv         : tak_all_command_glob;
                    VAR viewscanpar : tak_save_viewscan_par;
                    v_type          : tak_viewscantype);
 
      ------------------------------ 
 
        FROM
              AK_save_scheme : VAK15;
 
        PROCEDURE
              a15restore_catalog (
                    VAR acv         : tak_all_command_glob;
                    VAR treeid      : tgg00_FileId;
                    VAR viewscanpar : tak_save_viewscan_par);
 
        PROCEDURE
              a15catalog_save (
                    VAR acv         : tak_all_command_glob;
                    VAR viewscanpar : tak_save_viewscan_par);
 
      ------------------------------ 
 
        FROM
              AK_Table : VAK11;
 
        PROCEDURE
              a11get_check_table (
                    VAR acv          : tak_all_command_glob;
                    new_table        : boolean;
                    basetable        : boolean;
                    unload_allowed   : boolean;
                    required_priv    : tak00_PrivilegeSet;
                    any_priv         : boolean;
                    all_base_rec     : boolean;
                    d_state          : tak_directory_state;
                    VAR act_tree_ind : tsp00_Int4;
                    VAR authid       : tsp00_KnlIdentifier;
                    VAR tablen       : tsp00_KnlIdentifier;
                    VAR d_sparr      : tak_syspointerarr);
 
        PROCEDURE
              a11del_usage_entry (
                    VAR acv       : tak_all_command_glob;
                    VAR usa_tabid : tgg00_Surrogate;
                    VAR del_tabid : tgg00_Surrogate);
 
        PROCEDURE
              a11drop_table  (
                    VAR acv       : tak_all_command_glob;
                    VAR tableid   : tgg00_Surrogate;
                    tablkind      : tgg00_TableKind;
                    succ_filevers : boolean);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache   : VAK10;
 
        PROCEDURE
              a10alter_long_version (
                    VAR acv        : tak_all_command_glob;
                    VAR base_rec   : tak_baserecord;
                    old_long_cnt   : integer;
                    m_type         : tgg00_MessType;
                    view_scan      : boolean);
 
        PROCEDURE
              a10_fix_len_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    required_len : integer;
                    plus         : integer;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_add_repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    add_sysinfo  : boolean;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_del_tab_sysinfo  (
                    VAR acv     : tak_all_command_glob;
                    VAR tableid : tgg00_Surrogate;
                    VAR qual    : tak_del_tab_qual;
                    temp_table  : boolean;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a10_cache_delete  (
                    VAR acv     : tak_all_command_glob;
                    is_rollback : boolean);
 
        PROCEDURE
              a10del_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_key_del  (
                    VAR acv     : tak_all_command_glob;
                    VAR syskey  : tgg00_SysInfoKey);
 
        PROCEDURE
              a10next_sysinfo (
                    VAR acv       : tak_all_command_glob;
                    VAR syskey    : tgg00_SysInfoKey;
                    stop_prefix   : integer;
                    dstate        : tak_directory_state;
                    rec_kind      : tsp00_C2;
                    VAR syspoint  : tak_sysbufferaddress;
                    VAR b_err     : tgg00_BasisError);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
        FUNCTION
              a101_GetExtendedTempFileType(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tgg00_TfnTemp;
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_const_b_put_error (
                    VAR acv    : tak_all_command_glob;
                    b_err      : tgg00_BasisError;
                    err_code   : tsp00_Int4;
                    param_addr : tsp00_MoveObjPtr;
                    const_len  : integer);
 
        PROCEDURE
              a07_hex_uni_error (
                    VAR acv     : tak_all_command_glob;
                    uni_err     : tsp8_uni_error;
                    err_code    : tsp00_Int4;
                    to_unicode  : boolean;
                    bytestr     : tsp00_MoveObjPtr;
                    len         : tsp00_Int4 );
 
        PROCEDURE
              a07_kw_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    kw       : integer);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06char_retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
        PROCEDURE
              a06colname_retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4;
                    src_codeset : tsp00_Int2);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06init_curr_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06_c_send_mess_buf (
                    VAR acv    : tak_all_command_glob;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06finish_curr_retpart (
                    VAR acv   : tak_all_command_glob;
                    part_kind : tsp1_part_kind;
                    arg_count : tsp00_Int2);
 
        PROCEDURE
              a06lsend_mess_buf (
                    VAR acv         : tak_all_command_glob;
                    VAR mblock      : tgg00_MessBlock;
                    call_from_rsend : boolean;
                    VAR e           : tgg00_BasisError);
 
        PROCEDURE
              a06retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
        PROCEDURE
              a06a_mblock_init (
                    VAR acv         : tak_all_command_glob;
                    mtype           : tgg00_MessType;
                    m2type          : tgg00_MessType2;
                    VAR tree        : tgg00_FileId);
 
        FUNCTION
              a06_table_exist (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR authid   : tsp00_KnlIdentifier;
                    VAR tablen   : tsp00_KnlIdentifier;
                    VAR d_sparr  : tak_syspointerarr;
                    get_all      : boolean) : boolean;
 
        PROCEDURE
              a06_systable_get (
                    VAR acv     : tak_all_command_glob;
                    dstate      : tak_directory_state;
                    VAR tableid : tgg00_Surrogate;
                    VAR base_ptr: tak_sysbufferaddress;
                    get_all     : boolean;
                    VAR ok      : boolean);
 
        PROCEDURE
              a06userid_get (
                    VAR acv    : tak_all_command_glob;
                    VAR userid : tgg00_Surrogate;
                    VAR ok     : boolean);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05_constant_get (
                    VAR acv       : tak_all_command_glob;
                    ni            : integer;
                    VAR colinfo   : tak00_columninfo;
                    may_be_longer : boolean;
                    mv_dest       : integer;
                    VAR dest      : tsp00_C18;
                    destpos       : integer;
                    VAR actlen    : integer);
 
        PROCEDURE
              a05_identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_MoveObj);
 
        PROCEDURE
              a05_unsigned_int2_get (
                    VAR acv  : tak_all_command_glob;
                    pos      : integer;
                    l        : tsp00_Int2;
                    err_code : tsp00_Int4;
                    VAR int  : tsp00_Int2);
 
        PROCEDURE
              a05_int4_unsigned_get (
                    VAR acv : tak_all_command_glob;
                    pos     : integer;
                    l       : tsp00_Int2;
                    VAR int : tsp00_Int4);
 
        PROCEDURE
              a05int4_get (
                    VAR acv            : tak_all_command_glob;
                    pos                : integer;
                    l                  : tsp00_Int2;
                    VAR int            : tsp00_Int4);
 
        PROCEDURE
              a05identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
        PROCEDURE
              a05_string_literal_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    datatyp     : tsp00_DataType;
                    obj_len     : integer;
                    VAR moveobj : tgg00_MediaName);
 
        PROCEDURE
              a05string_literal_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    datatyp     : tsp00_DataType;
                    VAR moveobj : tsp00_MoveObj;
                    obj_pos     : integer;
                    obj_len     : integer);
 
        PROCEDURE
              a05_str_literal_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    datatyp     : tsp00_DataType;
                    VAR moveobj : tak_map_set;
                    obj_pos     : integer;
                    obj_len     : integer);
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01diag_monitor_on   : boolean;
              a01diag_moni_parseid : boolean;
              a01sm_collect_data   : boolean;
              a01identifier_size   : integer;
              a01char_size         : integer;
              a01kw                : tak_keywordtab;
              a01defaultkey        : tgg00_SysInfoKey;
              a01_i_sysmonitor     : tsp00_KnlIdentifier;
              a01_i_sysmondata     : tsp00_KnlIdentifier;
              a01_i_sysparseid     : tsp00_KnlIdentifier;
              a01_i_syscmd_analyze : tsp00_KnlIdentifier;
              a01_i_sysdata_analyze: tsp00_KnlIdentifier;
              a01_il_b_identifier  : tsp00_KnlIdentifier;
 
        PROCEDURE
              a01_next_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_get_keyword (
                    VAR acv   : tak_all_command_glob;
                    VAR index : integer;
                    VAR reserved : boolean);
 
        FUNCTION
              a01mandatory_keyword (
                    VAR acv          : tak_all_command_glob;
                    required_keyword : integer) : boolean;
 
      ------------------------------ 
 
        FROM
              Deal-With-User-Commands : VAK92;
 
        PROCEDURE
              a92next_monitor_pcount (
                    VAR acv   : tak_all_command_glob;
                    VAR parsk : tak_parskey);
 
      ------------------------------ 
 
        FROM
              KB_functions : VKB05;
 
        FUNCTION
              k05MaxStackUsage : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              KB_headmaster : VKB38;
 
        PROCEDURE
              k38get_state (
                    buf_size         : tsp00_Int4;
                    VAR buf_len      : tsp00_Int4;
                    VAR buffer       : tsp00_MoveObj);
 
      ------------------------------ 
 
        FROM
              KB_LogSaveIterator : VKB391;
 
        PROCEDURE
              kb391FreeLogForPipe(
                    taskId                   : tsp00_TaskId;
                    VAR firstSavedIOsequence : tsp00_Uint4;
                    VAR lastSavedIOsequence  : tsp00_Uint4;
                    VAR trError              : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              KB_Logging : VKB560;
 
        PROCEDURE
              kb560SetTraceMaxBufferLength (length : tsp00_Int4);
 
        PROCEDURE
              kb560InvalidateIOSeq( VAR ioSeq : tsp00_Uint4);
 
      ------------------------------ 
 
        FROM
              Trace : VBD120;
 
        PROCEDURE
              b120ClearTrace (TaskId : tsp00_TaskId);
 
      ------------------------------ 
 
        FROM
              task_temp_data_cache : VBD21;
 
        PROCEDURE
              b21m_parse_again (
                    temp_cache_ptr  : tgg00_TempDataCachePtr;
                    VAR parse_again : tsp00_C3);
 
        PROCEDURE
              b21mp_parse_again_put (
                    temp_cache_ptr : tgg00_TempDataCachePtr;
                    parse_again : tsp00_C3);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_3 : VBD03;
 
        PROCEDURE
              bd03SetToNotAccessible(
                    VAR Trans   : tgg00_TransContext;
                    VAR FiledId : tgg00_FileId );
 
      ------------------------------ 
 
        FROM
              FileDir_Wrapper : vbd998;
 
        PROCEDURE
              bd998CreateNamedTempFile(
                    VAR trans          : tgg00_TransContext;
                    VAR fileNo         : tgg00_Surrogate(*ptocConst*);
                    VAR tempFileId     : tgg00_FileId;
                    isExtendedTempFile : boolean;
                    tempFileType       : tgg00_TfnTemp);
 
        PROCEDURE
              bd998GetTableBlobColCount (
                    VAR transContext   : tgg00_TransContext;
                    VAR tableSurrogate : tgg00_Surrogate;
                    VAR blobColCount   : tsp00_Int4;
                    VAR bErr           : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Codetransformation_and_Coding : VGG02;
 
        VAR
              g02codetables : tgg04_CodeTables;
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01diag_moni_parse_on : boolean;
              g01tabid              : tgg04_TabIdGlobals;
              g01vtrace             : tgg00_VtraceState;
              g01unicode            : boolean;
              g01glob               : tgg00_KernelGlobals;
 
        PROCEDURE
              g01event_init (VAR new_event : tsp31_event_description);
 
        PROCEDURE
              g01optextmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C40);
 
        PROCEDURE
              g01unioptextmsg (
                    msg_enc   : tsp00_Int4;
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C80);
 
      ------------------------------ 
 
        FROM
              Check-Date-Time : VGG03;
 
        PROCEDURE
              g03dchange_format_date (
                    VAR sbuf : tsp00_MoveObj;
                    VAR dbuf  : tsp00_MoveObj;
                    spos      : tsp00_Int4;
                    dpos      : tsp00_Int4;
                    format    : tgg00_DateTimeFormat;
                    VAR b_err : tgg00_BasisError);
 
        PROCEDURE
              g03tchange_format_time (
                    VAR sbuf : tsp00_MoveObj;
                    VAR dbuf  : tsp00_MoveObj;
                    spos      : tsp00_Int4;
                    dpos      : tsp00_Int4;
                    format    : tgg00_DateTimeFormat;
                    VAR b_err : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04index_tree_build (
                    VAR file_id    : tgg00_FileId (*ptocConst*);
                    VAR index_tree : tgg00_FileId;
                    index_no       : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Regions_and_Longwaits : VGG08;
 
        VAR
              g08monitor : tsp00_RegionId;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedUnicodeFill (
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2 );
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17hexto_line (
                    c          : char;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_KnlIdentifier);
 
        PROCEDURE
              g17int4to_line (
                    int4      : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_C12);
 
      ------------------------------ 
 
        FROM
              GG_allocator_interface : VGG941;
 
        PROCEDURE
              Kernel_TraceSwitch (VAR TopicStr : tsp00_MoveObj (*ptocSynonym const char**);
                    TopicStrLen : integer);
 
        FUNCTION
              Kernel_DiagInfop (
                    requested       : integer;
                    VAR kindOut     : tak_keyword;
                    VAR topicKeyOut : tsp00_Sname;
                    VAR levelOut    : integer) : boolean;
 
      ------------------------------ 
 
        FROM
              KernelAdministration_Interface : VGG999;
 
        PROCEDURE
              gg999AddDataVolume (VAR trans : tgg00_TransContext;
                    VAR volumeName : tsp00_VFilename;
                    newVolumeSize  : tsp00_Int4;
                    volumeId       : tsp00_Int2);
 
        PROCEDURE
              gg999AddLogVolume (VAR trans : tgg00_TransContext;
                    VAR volumeName       : tsp00_VFilename;
                    VAR mirrorVolumeName : tsp00_VFilename;
                    newVolumeSize        : tsp00_Int4;
                    volumeId             : tsp00_Int2);
 
        PROCEDURE
              gg999BackupData (VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              gg999BackupLog (VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              gg999BackupRestoreHandling (VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              gg999DeleteBlockAddress (
                    taskId    : tsp00_TaskId;
                    VAR error : tgg00_BasisError;
                    pageNo    : tsp00_PageNo;
                    recMode   : tgg00_RecoveryMode);
 
        PROCEDURE
              gg999DropDataVolume (VAR trans : tgg00_TransContext;
                    volumeId       : tsp00_Int2);
 
        PROCEDURE
              gg999GetBlockAddress (
                    taskId        : tsp00_TaskId;
                    pageNo        : tsp00_PageNo;
                    recMode       : tgg00_RecoveryMode;
                    VAR deviceNo  : tsp00_Int4;
                    VAR blockNo   : tsp00_Int4);
 
        PROCEDURE
              gg999GetRedoLogProgressInfo (VAR transread : tsp00_Int4;
                    VAR transredone : tsp00_Int4);
 
        FUNCTION
              gg999KernelStateIsOnline : boolean;
 
        FUNCTION
              gg999KernelStateIsAdmin : boolean;
 
        FUNCTION
              gg999KernelStateIsRedoLogProcessing : boolean;
 
        PROCEDURE
              gg999PrepareStandby (VAR trans : tgg00_TransContext;
                    VAR newStandbyNode : tsp00_NodeId);
 
        PROCEDURE
              gg999RegisterStandby (VAR trans : tgg00_TransContext;
                    VAR newStandbyNode : tsp00_NodeId;
                    firstNeededOffset  : tsp00_Int4;
                    VAR maxValidOffset : tsp00_Int4);
 
        PROCEDURE
              gg999SetLogAutoOverwrite (taskid : tsp00_TaskId;
                    on : boolean);
 
        PROCEDURE
              gg999SetNewBlockAddress (
                    taskId    : tsp00_TaskId;
                    VAR error : tgg00_BasisError;
                    pageNo    : tsp00_PageNo;
                    recMode   : tgg00_RecoveryMode;
                    deviceNo  : tsp00_Int4;
                    blockNo   : tsp00_Int4);
 
        PROCEDURE
              gg999Shutdown (VAR trans : tgg00_TransContext);
 
        FUNCTION
              gg999SuspendLogWriter (taskid : tsp00_TaskId;
                    VAR lastWrittenIOsequence : tsp00_Uint4) : tgg00_BasisError;
 
        PROCEDURE
              gg999ResumeLogWriter (taskid : tsp00_TaskId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id     : tgg00_FileId;
              b01blankfilename  : tsp00_VFilename;
 
        PROCEDURE
              b01destroy_file (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              b01filestate (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              b01vstate_fileversion (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vbackup_info (
                    VAR backup_info : tsp00_Buf;
                    info_len    : tsp00_Int4;
                    VAR error   : tsp00_VfReturn;
                    VAR errtext : tsp00_ErrText);
 
        PROCEDURE
              vbackup_medium_def (
                    VAR backup_medium_def : tsp00_Buf;
                    info_len     : tsp00_Int4;
                    VAR error    : tsp00_VfReturn;
                    VAR errtext  : tsp00_ErrText);
 
        PROCEDURE
              vbegexcl (
                    pid     : tsp00_TaskId;
                    region  : tsp00_RegionId);
 
        PROCEDURE
              vendexcl (
                    pid     : tsp00_TaskId;
                    region  : tsp00_RegionId);
 
        PROCEDURE
              vinsert_event (VAR event : tsp31_event_description );
 
        PROCEDURE
              vconf_param_put (VAR conf_param_name : tsp11_ConfParamName;
                    VAR conf_param_value  : tsp11_ConfParamValue;
                    is_numeric            : boolean;
                    permanent_change      : boolean;
                    VAR conf_param_ret    : tsp11_ConfParamReturnValue);
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        FUNCTION
              s26size_new_part (
                    packet_ptr : tsp1_packet_ptr;
                    VAR segm : tsp1_segment) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        PROCEDURE
              s30map (
                    VAR code_t   : tsp00_Ctable;
                    VAR source   : tsp00_MoveObj;
                    source_pos   : tsp00_Int4;
                    VAR destin   : tsp00_MoveObj;
                    destin_pos   : tsp00_Int4;
                    length       : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              PUT-Conversions : VSP41;
 
        PROCEDURE
              s41p4int (
                    VAR buf : tsp00_ResNum;
                    pos     : tsp00_Int4;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
        PROCEDURE
              s41pluns (
                    VAR buf : tsp00_ResNum;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80 : VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              a27init_viewscanpar;
 
              tak_viewscan_par tak_save_viewscan_par
 
        PROCEDURE
              a05_constant_get;
 
              tsp00_MoveObj tsp00_C18
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj  tsp00_KnlIdentifier
 
        PROCEDURE
              a05_string_literal_get;
 
              tsp00_MoveObj  tgg00_MediaName
 
        PROCEDURE
              a05_str_literal_get;
 
              tsp00_MoveObj tak_map_set
              (* PTS 1108247 E.Z. *)
 
        PROCEDURE
              g17hexto_line;
 
              tsp00_Line tsp00_KnlIdentifier
 
        PROCEDURE
              g17int4to_line;
 
              tsp00_Line tsp00_C12
 
        FUNCTION
              Kernel_DiagInfop;
 
              tsp00_Identifier tak_keyword
 
        PROCEDURE
              s41p4int;
 
              tsp00_MoveObj    tsp00_ResNum
 
        PROCEDURE
              s41pluns;
 
              tsp00_MoveObj    tsp00_ResNum
 
.CM *-END-* synonym -------------------------------------
 
Specification:
 
.cp 11
PROCEDURE  A37_CALL_SEMANTIC :
.sp;.fo
Die Prozedur ist ein Verteiler f?ur die Utility-Befehle im laufenden
Betrieb (warme Utilities). Das erste Element des Syntaxbaumes
spezifiziert den durchzuf?uhrenden Befehl.
Utility-Befehle, die ein Hostfile ben?otigen k?onnen optional
'Direct' betrieben werden, d.h. der Kern schreibt bzw. liest
selbst in bzw. aus dem angegebenen Hostfile. Dies bewirkt Performance-
verbesserungen in Umgebungen, die das virtuelle File auch f?ur den
Kern bereitstellen.
Wenn 'Direct' spezifiziert ist, besitzt n_pos im ersten
Syntaxbaumelement den Wert Befehlsindikator + 1000.
.sp 4
.cp 5
.cp 11
PROCEDURE  A37PUT_COUNT_TO_MESSBUF
.sp
Falls 'Direct' spezifiziert ist, wird der Hostfilename in Part2
des Message-Buffers geschrieben, ansonsten wird dieser Teil
mit Blank gef?ullt. Falls eine Anzahl von maximal auszugebenden
Pages spezifiziert ist wird dieser Count hinter den Hostfilenamen
geschrieben.
Der Hostfilename wird im Codetyp des Hostrechners
in den Auftrag.part1 geschrieben.
.sp 4
.cp 5
PROCEDURE  SEND_MESSBUFFER
.sp
Der Message-Buffer wird mit den ?ubergebenen Message-Typen
initialisiert und an der aktuellen Location an KB gesendet.
.sp 4
.cp 6
PROCEDURE  SET_BUFFER
.sp
Die verschieden Set Buffer Befehle werden mit dieser Prozedur
an KB gesendet. Die gew?unschte Anzahl wird in Part1.pagefill
?ubergeben.
.sp 4
.cp 11
PROCEDURE  SAVE_ALL
.sp
Die Prozedur wird f?ur die Befehle Save Datebase und Save Pages
aufgerufen. Der Name des Files, auf das gesichert werden soll,
wird durch in a30v gelesen.
Der Part2 des Message-Buffers wird durch ==> a37put_count_to_messbuf
korrekt belegt. Der Auftrag wird an Kb geschickt und der
Hostfilename wird im Auftragssegment an den Hostrechner zur?uckgegeben.
.sp 4
.nf
.sp
.cp 16
Part1 :
.sp
+--------+--------+--+--+--+--+--+--+--+--...--+
| authid | tablen |  |00|00|00|00|nn|00|       |
+--------+--------+-|+-|+-|+-|+--+-|+-|+--...--+
                    |  |  |  |     |  |    |
   count_col_desc --+  |  |  |     |  |    |
   count_mult_inv -----+  |  |     |  |    |
   count_qual_desc -------+  |     |  |    |
   count_qual2_desc ---------+     |  |    |
   pagefill -----------------------+  |    |
   count_str_desc    -----------------+    |
   ISAM-Index Beschreibungen --------------+
.sp2
.cp 15
Part2 :
.sp
i)   +---------------------+
     |   Blankhostname     |
     +---------------------+
.sp
     leer, falls weder direct noch count spezifiziert.
.sp
ii)  +---------------------+--------+
     |   Blankhostname     | count  |
     +---------------------+--------+
.sp
     falls direct nicht und count spezifiziert.
.sp
iii) +---------------------+--------+
     |   Hostfilename      | count  |
     +---------------------+--------+
.sp
     falls direct und count spezifiziert.
.sp;.fo
.cp 9
Der Hostfilename wird in a30v
gelesen. Falls ein F?ullungsgrad spezifiziert ist, wird dieser aus
dem Var_Part gelesen.
Die ISAM-Index-Stackentries werden in den Message-Buffer
geschrieben (==> isam_index_stack_get).
Der Part2 des Message-Buffers wird aufgebaut
(==> a37_put_count_to_mess_buf).
Der gew?unschte F?ullungsgrad nn wird in pagefill eingetragen und der
Messsage-Buffer wird anschlie?zend an KB gesendet.
.sp 4
.cp 5
PROCEDURE  UTILITY_TABLE
.sp;.fo
Die Prozedur baut den an KB zu sendenden Message-Buffer f?ur
die Befehle Reload, Unload, Save und Restore Table auf.
Der Message_Buffer besitzt folgendes Aussehen :
.nf
.sp
.cp 16
Part1 :
.sp
+--------+--------+--+--+--+--+--+--+--+--...--+--...--+--...--+
| authid | tablen |  |  |00|00|00|nn|  |       |       |       |
+--------+--------+-|+-|+-|+-|+--+-|+-|+--...--+--...--+--...--+
                    |  |  |  |     |  |    |       |       |
   count_col_desc --+  |  |  |     |  |    |       |       |
   count_mult_inv -----+  |  |     |  |    |       |       |
   count_qual_desc -------+  |     |  |    |       |       |
   count_qual2_desc ---------+     |  |    |       |       |
   pagefill -----------------------+  |    |       |       |
   count_str_desc    -----------------+    |       |       |
   Single-Index Spaltenbeschreibungen -----+       |       |
   Multiple-Index Spaltenbeschreibungen -----------+       |
   String Spaltenbeschreibungen ---------------------------+
.sp2
.cp 15
Part2 :
.sp
i)   +---------------------+
     |   Blankhostname     |
     +---------------------+
.sp
     leer, falls weder direct noch count spezifiziert.
.sp
ii)  +---------------------+--------+
     |   Blankhostname     | count  |
     +---------------------+--------+
.sp
     falls direct nicht und count spezifiziert.
.sp
iii) +---------------------+--------+
     |   Hostfilename      | count  |
     +---------------------+--------+
.sp
     falls direct und count spezifiziert.
.sp;.fo
.cp 9
Der Hostfilename wird durch in a30v
gelesen. Falls ein F?ullungsgrad spezifiziert ist, wird dieser aus
dem Var_Part gelesen. Im Basisrecord der Tabelle wird ggf. das
Unloaded-Flag aktualisiert. Die Index-Stackentries der Tabelle
sowie die Stackentries der String-Felder werden in den Message-Buffer
geschrieben (==> index_stack_get, ==> a37s_get_string_cols).
Der Part2 des Message-Buffers wird aufgebaut
(==> a37_put_count_to_mess_buf).
Der gew?unschte F?ullungsgrad nn wird in pagefill eingetragen und der
Messsage-Buffer wird anschlie?zend an KB gesendet.
.sp 4
.cp 6
PROCEDURE  EXIST_GET_FILENAME
.sp
Die Prozedur liest den Namen der String bzw. ISAM-Datei in a30v
und liest die Systeminformationen in den Cache. Falls die Datei
nicht existiert wird die Fehlermeldung Unknown_Tablename gesetzt.
.sp4
.cp 8
PROCEDURE  EXIST_GET_TABLE
.sp
Die Prozedur liest den Namen der Tabelle in a30v
und liest die Systeminformationen in den Cache. Falls die Tabelle
nicht existiert wird die Fehlermeldung Unknown_Tablename gesetzt.
Andernfalls wird gepr?uft, ob es sich um eine Basistabelle
handelt und ob der aktuelle Benutzer das Owner-Privileg besitzt.
.sp 4
.cp 6
PROCEDURE  INDEX_STACK_GET
.sp
Die Prozedur schreibt die Stackentries aller invertierten Spalten
der durch a30v spezifizierten Tabelle in den Part1 des
Message-Buffers.
.sp 4
.cp 6
PROCEDURE  ISAM_INDEX_STACK_GET
.sp
Die Prozedur schreibt die Stackentries aller ISAM-Indexe
der durch a30v spezifizierten ISAM-Datei in den Part1 des
Message-Buffers.
.sp 4
.cp 7
PROCEDURE  UPDATE_STATISTICS
.sp
Die Prozedur liest den Tabellenname der Tabelle, deren Statistik
aktualisiert werden soll und pr?uft die Zul?assigkeit des
Kommandos. Falls alle Bedingnungen erf?ullt sind, wird
==> table_upd_statistics aufgerufen.
.sp 4
.cp 12
PROCEDURE  TABLE_UPD_STATISTICS
.sp
Die Anzahl der durch die Tabelle belegten Pages sowie die Anzahl der
belegten Pages jedes Single-Indexes der Tabelle werden von KB geliefert.
Diese Werte werden im Basisrecord zusammen mit dem aktuellen Zeitpunkt
vermerkt. Die bestimmten Anzahlen werden in den Systeminformationen
aller von der Basistabelle abh?angigen Views aktualisiert
==> a27view_scan.
Die Index-Statistiken der Indexe, die auf der Tabelle
definiert sind, werden aktualisiert ==> index_upd_statistics.
Die Systeminformationen der Basistabelle werden zur?uckgeschrieben.
.sp 4
.cp 5
PROCEDURE  INDEX_UPD_STATISTICS
.sp
Die Anzahl der Pages jedes auf der durch a30v spezifizierten
Tabelle definierten Indexes wird bestimmt und in den Systeminformationen
aktualisiert.
.sp 4
.cp 8
PROCEDURE  DIAGNOSE INDEX
.sp
Die Beschreibung der Indexspalte(n) wird durch a42index_inf_to_messbuf
in den Message-Buffer ?ubertragen und der Befehl wird mit m_diagnose,
mm_index an KB gesendet. KB liefert in Part1 des Message-Buffers die
Anzahl der Eint?age, die durch das Kommando in den Index eingef?ugt
wurden. Diese Anzahl wird als Number in Part2 des Auftragssegmentes
geschrieben.
.CM *-END-* specification -------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      (* PTS 1103853 E.Z. *)
      sysparse1  = 'CREATE TABLE SYSPARSEID  ("PARSEID" CHAR';
      sysparse2  = '(12) BYTE,LINKAGE FIXED(1),SELECT_PARSEI';
      sysparse3  = 'D CHAR(12) BYTE,OWNER CHAR(64) ASCII  ,S';
      sysparse4  = 'QL_STATEMENT CHAR(7800) ASCII  , JOB CHA';
      sysparse5  = 'R(40) ASCII, LINE FIXED(10), CONSTRAINT ';
      sysparse6  = ' SYSP_PK PRIMARY KEY("PARSEID",LINKAGE))';
      (* *)
      sysuparse3 = 'D CHAR(12) BYTE,OWNER CHAR(32) UNICODE,S';
      sysuparse4 = 'QL_STATEMENT CHAR(3900) UNICODE, JOB CHA';
      sysuparse5 = 'R(20) UNICODE, LINE FIXED(10),CONSTRAINT';
      (* *)
      sysmon1   = 'CREATE TABLE SYSMONITOR (SYSK CHAR(8) BY';
      sysmon2   = 'TE,"LINKAGE" CHAR(1) BYTE, "PARSEID" CHA';
      sysmon3   = 'R(12) BYTE, ROWS_READ FIXED(20), ROWS_QU';
      sysmon4   = 'AL FIXED(20), VIRTUAL_READS FIXED(20),  ';
      sysmon5   = 'SUBREQUESTS FIXED(20),STRATEGY CHAR(40) ';
      sysmon6   = 'ASCII  ,RUNTIME FIXED(20,6),VWAITS FIXED';
      sysmon7   = '(20),VSUSPENDS FIXED(20), PHYSICAL_IO FI';
      sysmon8   = 'XED(20),ROWS_FETCHED FIXED (20), FETCH_C';
      sysmon9   = 'ALLS FIXED (20), ROOT1 FIXED(10), ROOT2 ';
      sysmon10  = 'FIXED(10),ROOT3 FIXED(10),ROOT4 FIXED(10';
      sysmon11  = '),ROOT5 FIXED(10),ROOT6 FIXED(10),      ';
      sysmon12  = 'RESULT_COPIED CHAR(3)                   ';
      sysmon13  = 'ASCII  ,DATETIME TIMESTAMP, TERMID CHAR(';
      sysmon14  = '18) ASCII, USERNAME CHAR(64) ASCII  ,   ';
      sysmon15  = 'APPL_PROCESS FIXED(10), APPL_NODE CHAR(6';
      sysmon16  = '4) ASCII, CONSTRAINT SYSMONITOR_PK      ';
      sysmon17  = 'PRIMARY KEY (SYSK, "LINKAGE"))          ';
      (* *)
      sysumon14 = '18) ASCII, USERNAME CHAR(32) UNICODE,   ';
      (* *)
      sysmondt1  = 'CREATE TABLE SYSMONDATA (SYSK CHAR(8)   ';
      sysmondt2  = 'BYTE, PARAMNO FIXED(5), CONSTRAINT      ';
      sysmondt3  = 'SYSMONDATA_PK PRIMARY KEY (SYSK,PARAMNO)';
      sysmondt4  = ', DATA_TYPE CHAR(12) ASCII,             ';
      sysumondt4 = ', DATA_TYPE CHAR(6)  UNICODE,           ';
      sysmondt5  = 'DATA CHAR(4000) ASCII)                  ';
      sysumondt5 = 'DATA CHAR(2000) UNICODE)                ';
      (* *)
      syscmd1    = 'CREATE TABLE SYSCMD_ANALYZE (JOB  CHAR (';
      syscmd2    = '40) ASCII  ,LINE FIXED(10),CMDID CHAR(8)';
      syscmd3    = ' BYTE,LINKAGE FIXED(1),SQL_STATEMENT    ';
      syscmd4    = 'CHAR(7800) ASCII  , CMDHASH FIXED(10),  ';
      syscmd5    = 'HASHLISTPOS FIXED(5),  CONSTRAINT       ';
      syscmd6    = 'SYSCMD_ANALYZE_PK PRIMARY KEY           ';
      syscmd7    = '(JOB,LINE,CMDHASH,LINKAGE,HASHLISTPOS)) ';
      (* *)
      sysucmd2   = '20) UNICODE,LINE FIXED(10),CMDID CHAR(8)';
      sysucmd4   = 'CHAR(3900) UNICODE,CMDHASH FIXED(10),   ';
      (* *)
      sysdata1   = 'CREATE TABLE SYSDATA_ANALYZE (CMDID CHAR';
      sysdata2   = '(8) BYTE,SESSION CHAR (4) BYTE,         ';
      sysdata3   = 'CALL_COUNT FIXED(20),                   ';
      sysdata4   = 'ROWS_READ FIXED(20),ROWS_QUAL FIXED(20),';
      sysdata5   = 'VIRTUAL_READS FIXED(20),   RUNTIME FIXED';
      sysdata6   = '(20,6),MIN_RUNTIME FIXED(20,6),MAX_RUNTI';
      sysdata7   = 'ME FIXED (20,6),VWAITS FIXED (20),VSUSPE';
      sysdata8   = 'NDS FIXED(20),PHYSICAL_IO FIXED(20),ROWS';
      sysdata9   = '_FETCHED FIXED(20), CONSTRAINT          ';
      sysdata10  = 'SYSDATA_ANALYZEPK PRIMARY KEY           ';
      sysdata11  = '(CMDID, SESSION))                       ';
      (* *)
      cak_may_be_longer   = true (* a05_constant_get *);
      cak_call_from_rsend = true (* a06lsend_mess_buf *);
      c_trans_to_uni    = true (* a07_hex_uni_error  *);
      c_unicode_wid     = 2    (* a07_hex_uni_error  *);
      c_is_rollback     = true;
      c_is_perm         = true;
      c_is_numeric      = true;
      c_with_zero       = true;
      c_in_migration    = true;
      (* PTS 1112983 E.Z. *)
      cak_logsave_numlen = 11;
 
TYPE
      tak37verify_errors = (
            ve_index,
            ve_file_missing,
            ve_multi_missing,
            ve_ref,
            ve_single_missing,
            ve_tableref,
            ve_version,
            ve_single_invalid,
            ve_priv_table_ref,
            ve_priv_user_ref,
            ve_usertab_user_ref,
            ve_usertab_table_ref,
            ve_usertab_dbproc_ref,
            ve_method_ref,
            ve_priv_method_ref,
            ve_priv_method_user_ref,
            ve_colstack,
            ve_blob_col_count,
            ve_longvar_cnt,
            ve_longvar_old_colno,
            ve_longvar_new_colno);
 
      tak37verify_msg = RECORD
            CASE integer OF
                1 :
                    (name      : tsp00_KnlIdentifier);
                2 :
                    (surrogate : tgg00_Surrogate);
                3 :
                    (number    : tsp00_Int4);
                END;
            (*ENDCASE*) 
            (* PTS 1111040 E.Z. *)
 
 
 
(*------------------------------*) 
 
PROCEDURE
      ak37add_devspace (
            VAR acv          : tak_all_command_glob;
            add_log_devspace : boolean);
 
VAR
      dafsVolume       : boolean;
      mirrorDafsVolume : boolean;
      ti               : integer;
      ti_int           : integer;
      volumeName       : tsp00_VFilename;
      mirrorVolumeName : tsp00_VFilename;
      newVolumeSize    : tsp00_Int4;
      volumeId         : tsp00_Int2;
 
BEGIN
WITH acv, a_mblock DO
    BEGIN
    dafsVolume := false;
    mirrorDafsVolume := false;
    ti := a_ap_tree^[ 0 ].n_lo_level;
    ti_int := a_ap_tree^[ ti ].n_sa_level;
    ti := a_ap_tree^[ ti ].n_lo_level;
    a36devname (acv, ti, volumeName, sizeof(volumeName));
    IF  a_ap_tree^[ti].n_sa_level <> 0
    THEN
        WITH a_ap_tree^[a_ap_tree^[ti].n_sa_level] DO
            IF  (n_proc = a37) AND (n_subproc = cak_i_dafs)
            THEN
                dafsVolume := true;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    ti := a_ap_tree^[ti].n_lo_level;
    IF  ti <> 0
    THEN
        BEGIN
        a36devname (acv, ti, mirrorVolumeName, sizeof(mirrorVolumeName));
        IF  a_ap_tree^[ti].n_sa_level <> 0
        THEN
            WITH a_ap_tree^[a_ap_tree^[ti].n_sa_level] DO
                IF  (n_proc = a37) AND (n_subproc = cak_i_dafs)
                THEN
                    mirrorDafsVolume := true;
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        mirrorVolumeName := volumeName;
        mirrorDafsVolume := dafsVolume;
        END;
    (*ENDIF*) 
    (* PAGES *)
    WITH acv.a_ap_tree^[ ti_int ] DO
        a05_int4_unsigned_get (acv, n_pos, n_length, newVolumeSize);
    (*ENDWITH*) 
    ti_int := a_ap_tree^[ ti_int ].n_sa_level;
    (* DEVNO *)
    WITH acv.a_ap_tree^[ ti_int ] DO
        a05_unsigned_int2_get (acv, n_pos, n_length,
              e_invalid_unsign_integer, volumeId);
    (*ENDWITH*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        mb_trns^.trError_gg00 := e_ok;
        IF  add_log_devspace
        THEN
            gg999AddLogVolume (mb_trns^,
                  volumeName, (* DafsVolume, *)
                  mirrorVolumeName, (* mirrorDafsVolume, *)
                  newVolumeSize, volumeId)
        ELSE
            gg999AddDataVolume (mb_trns^, volumeName, (* dafsVolume, *)
                  newVolumeSize, volumeId);
        (*ENDIF*) 
        IF  mb_trns^.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, mb_trns^.trError_gg00, 1)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37drop_volume (VAR acv : tak_all_command_glob);
 
VAR
      ti_int           : integer;
      volumeId         : tsp00_Int2;
 
BEGIN
WITH acv, a_mblock DO
    BEGIN
    ti_int := a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_sa_level;
    WITH acv.a_ap_tree^[ ti_int ] DO
        a05_unsigned_int2_get (acv, n_pos, n_length,
              e_invalid_unsign_integer, volumeId);
    (*ENDWITH*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        mb_trns^.trError_gg00 := e_ok;
        gg999DropDataVolume (mb_trns^, volumeId);
        IF  mb_trns^.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, mb_trns^.trError_gg00, 1)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37autosave (VAR acv : tak_all_command_glob);
 
VAR
      e         : tgg00_BasisError;
      a30v      : tak_a30_utility_glob;
      multi_buf : tgg00_QualBuf;
      colinfo   : tak00_columninfo;
      before    : tsp00_C18;
      beforelen : integer;
 
BEGIN
WITH acv, a30v DO
    BEGIN
    e := e_ok;
    a37init_util_record (acv, m_autosave, mm_nil);
    a_mblock.mb_data_len := 0;
    CASE a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_length OF
        cak_i_on :
            WITH a_mblock.mb_qual^, multi_buf.msave_restore DO
                BEGIN
                a3ti := a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_lo_level;
                ak37init_save_restore_input_param (multi_buf.msave_restore);
                REPEAT
                    sripHostTapeNum_gg00 := sripHostTapeNum_gg00 + 1;
                    (* PTS 1112983 E.Z. *)
                    sripHostTapenames_gg00 [sripHostTapeNum_gg00] := b01blankfilename;
                    a36filename (acv, a3ti,
                          sripHostTapenames_gg00 [sripHostTapeNum_gg00],
                          sizeof(sripHostTapenames_gg00 [sripHostTapeNum_gg00])
                          (* PTS 1112983 E.Z. *)
                          - cak_logsave_numlen);
                    a3ti := a_ap_tree^[a3ti].n_lo_level;
                    sripHostTapecount_gg00 [sripHostTapeNum_gg00] := csp_maxint4;
                    IF  a36filetype (acv, a3ti,
                        sripHostFiletypes_gg00 [sripHostTapeNum_gg00])
                    THEN
                        a3ti := a_ap_tree^[a3ti].n_lo_level
                    (*ENDIF*) 
                UNTIL
                    a3ti = 0;
                (*ENDREPEAT*) 
                a3ti := a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_sa_level;
                a37media_name (acv, a3ti, multi_buf);
                IF  (a3ti <> 0) AND
                    (a_ap_tree^[a3ti].n_subproc = cak_i_date)
                THEN
                    BEGIN (* before date *)
                    colinfo.cdatatyp  := ddate;
                    colinfo.cdatalen  := mxsp_extdate;
                    colinfo.cinoutlen := mxsp_date+1;
                    a05_constant_get (acv,a_ap_tree^[ a3ti ].n_lo_level,
                          colinfo, NOT cak_may_be_longer,
                          sizeof (before), before, 1, beforelen);
                    IF  a_returncode = 0
                    THEN
                        SAPDB_PascalMove ('VAK37 ',   1,    
                              sizeof (before), sizeof(sripUntilDate_gg00),
                              @before, 2, @sripUntilDate_gg00, 1,beforelen-1,
                              a_returncode);
                    (*ENDIF*) 
                    a3ti := a_ap_tree^[a3ti].n_sa_level
                    END;
                (*ENDIF*) 
                ak37get_count_int4 (acv, a30v, (* PTS 1109215 UH 2001-02-05 *)
                      sripHostTapecount_gg00[sripHostTapeNum_gg00]);
                IF  (a3ti <> 0) AND
                    (a_ap_tree^[a3ti].n_subproc = cak_i_fversion)
                THEN
                    BEGIN
                    sripFileVersion_gg00 := 1;
                    a3ti                 := a_ap_tree^[a3ti].n_sa_level
                    END
                ELSE
                    sripFileVersion_gg00 := -1;
                (*ENDIF*) 
                sripBlocksize_gg00  := a37blocksize (acv, a30v);
                sripIsAutoLoad_gg00 := false;
                IF  a3ti <> 0
                THEN
                    WITH a_ap_tree^[a3ti] DO
                        IF  (n_proc = a37) AND
                            (n_subproc = cak_i_cascade)
                        THEN
                            sripIsAutoLoad_gg00 := true;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (*ENDIF*) 
                a_mblock.mb_qual^.msave_restore :=
                      multi_buf.msave_restore;
                a_mblock.mb_qual_len :=
                      sizeof (a_mblock.mb_qual^.msave_restore);
                END;
            (*ENDWITH*) 
        cak_i_end :
            BEGIN
            a_mblock.mb_type2  := mm_last;
            a_mblock.mb_struct := mbs_nil;
            END;
        cak_i_cancel :
            BEGIN
            a_mblock.mb_type2  := mm_clear;
            a_mblock.mb_struct := mbs_nil;
            END;
        cak_i_show :
            a_mblock.mb_type2 := mm_outcopy;
        OTHERWISE
            e := e_invalid_command;
        END;
    (*ENDCASE*) 
    IF  (e = e_ok) AND (a_returncode = 0)
    THEN
        a06lsend_mess_buf (acv, a_mblock,
              NOT cak_call_from_rsend, e);
    (*ENDIF*) 
    IF  e <> e_ok
    THEN
        a07_b_put_error (acv, e, 1)
    ELSE
        IF  a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_length = cak_i_show
        THEN
            a37multi_tape_info (acv, cak_i_no_keyword)
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37diagnose_index (VAR acv : tak_all_command_glob);
 
VAR
      selectivity : boolean;
      indexname   : tsp00_KnlIdentifier;
      a41v        : tak40_show_glob;
      shortinfo   : tak_shortinforecord;
      pos         : tsp00_Int4;
      name        : tsp00_C18;
 
BEGIN
WITH acv, a_mblock DO
    BEGIN
    a41v.a4ti   := a_ap_tree^[ 0 ].n_lo_level;
    a41v.a4coln := a01_il_b_identifier;
    selectivity := false;
    a06a_mblock_init (acv, m_nil, mm_nil, b01niltree_id);
    a42index_inf_to_messbuf (acv,
          a_mblock, a41v, indexname, selectivity, true);
    IF  a_returncode = 0
    THEN
        BEGIN
        pos := 1;
        name := 'ADDED KEYS        ';
        a06colname_retpart_move (acv, @name, 10, csp_ascii);
        WITH shortinfo.siinfo[1] DO
            BEGIN
            sp1i_mode       := [ sp1ot_mandatory ];
            sp1i_io_type    := sp1io_output;
            sp1i_data_type  := dfixed;
            sp1i_frac       := 0;
            sp1i_length     := csp_resnum_deflen;
            sp1i_in_out_len := mxsp_resnum;
            sp1i_bufpos     := pos;
            pos             := pos + sp1i_in_out_len
            END;
        (*ENDWITH*) 
        name := 'DUPLICATE KEYS    ';
        a06colname_retpart_move (acv, @name, 14, csp_ascii);
        shortinfo.siinfo[2] := shortinfo.siinfo[1];
        shortinfo.siinfo[2].sp1i_bufpos := pos;
        pos := pos + shortinfo.siinfo[2].sp1i_in_out_len;
        name := 'UNKNOWN KEYS      ';
        a06colname_retpart_move (acv, @name, 12, csp_ascii);
        shortinfo.siinfo[3] := shortinfo.siinfo[1];
        shortinfo.siinfo[3].sp1i_bufpos := pos;
        pos := pos + shortinfo.siinfo[3].sp1i_in_out_len;
        a06finish_curr_retpart (acv, sp1pk_columnnames, 3);
        shortinfo.sicount := 3;
        a06retpart_move (acv, @shortinfo.siinfo,
              shortinfo.sicount * sizeof (shortinfo.siinfo[1]));
        a06finish_curr_retpart (acv, sp1pk_shortinfo, shortinfo.sicount);
        a06retpart_move (acv, @a_mblock.mb_qual^.buf,
              3 * mxsp_resnum);
        a06finish_curr_retpart (acv, sp1pk_data, 1)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37get_surrogate (
            VAR acv       : tak_all_command_glob;
            ti            : integer;
            VAR surrogate : tgg00_Surrogate);
 
CONST
      max_hex = 16; (* 2 * mx_surrogate *)
 
VAR
      i         : integer;
      j         : integer;
      pos       : integer;
      val       : integer;
      v         : integer;
      hex_input : ARRAY[ 1..max_hex ] OF char;
 
BEGIN
WITH acv DO
    BEGIN
    FOR i := 1 TO max_hex DO
        hex_input[ i ] := '0';
    (*ENDFOR*) 
    WITH a_ap_tree^[ ti ] DO
        IF  g01unicode
        THEN
            IF  n_length > 2 * 2 * SURROGATE_MXGG00
            THEN
                a07_b_put_error (acv, e_invalid_parameter, 1)
            ELSE
                BEGIN
                pos := 2 * SURROGATE_MXGG00;
                i := n_pos + n_length - 1;
                WHILE i >= n_pos DO
                    BEGIN
                    IF  NOT (a_cmd_part^.sp1p_buf[ i ] in [ '0'..'9','A'..'F' ])
                        OR
                        (a_cmd_part^.sp1p_buf[ i-1 ] <> csp_unicode_mark)
                    THEN
                        a07_b_put_error (acv, e_invalid_parameter, 1)
                    ELSE
                        BEGIN
                        hex_input[ pos ] := a_cmd_part^.sp1p_buf[ i ];
                        pos              := pred(pos)
                        END;
                    (*ENDIF*) 
                    i := i - 2
                    END
                (*ENDWHILE*) 
                END
            (*ENDIF*) 
        ELSE
            IF  n_length > 2 * SURROGATE_MXGG00
            THEN
                a07_b_put_error (acv, e_invalid_parameter, 1)
            ELSE
                BEGIN
                pos := 2 * SURROGATE_MXGG00;
                FOR i := n_pos + n_length - 1 DOWNTO n_pos DO
                    IF  NOT (a_cmd_part^.sp1p_buf[ i ] in [ '0'..'9','A'..'F' ])
                    THEN
                        a07_b_put_error (acv, e_invalid_parameter, 1)
                    ELSE
                        BEGIN
                        hex_input[ pos ] := a_cmd_part^.sp1p_buf[ i ];
                        pos              := pred(pos)
                        END;
                    (*ENDIF*) 
                (*ENDFOR*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDWITH*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        pos := 1;
        FOR i := 1 TO SURROGATE_MXGG00 DO
            BEGIN
            FOR j := 1 TO 2 DO
                BEGIN
                IF  hex_input[ pos ] in [ 'A'..'F' ]
                THEN
                    v := (ord(hex_input[ pos ]) - ord('A') + 10)
                ELSE
                    v := (ord(hex_input[ pos ]) - ord('0'));
                (*ENDIF*) 
                IF  j = 1
                THEN
                    val := v * 16
                ELSE
                    val := val + v;
                (*ENDIF*) 
                pos := succ(pos)
                END;
            (*ENDFOR*) 
            surrogate[ i ] := chr(val)
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37save (
            VAR acv         : tak_all_command_glob;
            VAR a30v        : tak_a30_utility_glob;
            VAR util_cmd_id : tgg00_UtilCmdId);
 
VAR
      is_parallel    : boolean;
      qual           : tgg00_QualBuf;
 
BEGIN
WITH acv, a30v DO
    BEGIN
    a37init_util_record (acv, m_save_parallel, mm_nil);
    ak37init_save_restore_input_param (qual.msave_restore);
    CASE a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc OF
        cak_x_save_database :
            a_mblock.mb_type2 := mm_database;
        cak_x_save_pages :
            a_mblock.mb_type2 := mm_pages;
        cak_x_save_log :
            a_mblock.mb_type2 := mm_log;
        END;
    (*ENDCASE*) 
    IF  NOT (
        (a_mblock.mb_type2 = mm_pages)    OR
        (a_mblock.mb_type2 = mm_log))
    THEN
        a_mblock.mb_type2 := mm_database;
    (*ENDIF*) 
    a3ti := acv.a_ap_tree^[ acv.a_ap_tree^ [ 0 ].n_lo_level ].n_sa_level;
    WITH a_ap_tree^[ a3ti ] DO
        IF  (n_proc = a37) AND (n_subproc = cak_i_quick)
        THEN
            BEGIN
            a3ti             := n_sa_level;
            a_mblock.mb_type := m_save_parallel
            END;
        (*ENDIF*) 
    (*ENDWITH*) 
    is_parallel := a_mblock.mb_type = m_save_parallel;
    (* PTS 1112983 E.Z. *)
    ak37multi_tapes (acv, a30v, qual, a_mblock.mb_type2);
    IF  (a3ti <> 0) AND
        (a_ap_tree^[a3ti].n_subproc = cak_i_fversion)
    THEN
        BEGIN
        qual.msave_restore.sripFileVersion_gg00 := 1;
        a3ti := a_ap_tree^[a3ti].n_sa_level
        END
    ELSE
        qual.msave_restore.sripFileVersion_gg00 := -1;
    (*ENDIF*) 
    qual.msave_restore.sripBlocksize_gg00 := a37blocksize (acv, a30v);
    a37put_count_to_messbuf (acv, a30v);
    qual.msave_restore.sripUtilCmdId_gg00  := util_cmd_id; (* PTS 1104845 UH 02-12-1999 *)
    qual.msave_restore.sripIsAutoLoad_gg00 := false;
    IF  a3ti <> 0
    THEN
        WITH a_ap_tree^[a3ti] DO
            IF  (n_proc = a37) AND (n_subproc = cak_i_cascade)
            THEN
                BEGIN
                qual.msave_restore.sripIsAutoLoad_gg00 := true;
                a3ti := a_ap_tree^[a3ti].n_sa_level
                END;
            (* PTS 2040 *)
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    qual.msave_restore.sripWithCheckpoint_gg00 := true;
    IF  a3ti <> 0
    THEN
        WITH a_ap_tree^[a3ti] DO
            IF  (n_proc = a37) AND (n_subproc = cak_i_no)
            THEN
                BEGIN
                qual.msave_restore.sripWithCheckpoint_gg00 := false;
                a3ti := a_ap_tree^[a3ti].n_sa_level (* PTS 1128703 mb 2004-05-05 *)
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    a37media_name (acv, a3ti, qual);
    IF  NOT is_parallel
    THEN
        BEGIN
        qual.msave_restore.sripBlocksize_gg00 :=
              s26size_new_part(a_out_packet, a_return_segm^) DIV
              mxsp_buf;
        qual.msave_restore.sripHostTapeNum_gg00       := 1;
        qual.msave_restore.sripHostFiletypes_gg00 [1] := vf_t_unknown;
        qual.msave_restore.sripHostTapecount_gg00 [1] := csp_maxint4;
        qual.msave_restore.sripHostTapenames_gg00 [1] := b01blankfilename
        END;
    (*ENDIF*) 
    IF  a3ti <> 0 (* PTS 1128703 mb 2004-05-05 *)
    THEN
        WITH a_ap_tree^[a3ti] DO
            IF  (n_proc = a37) AND (n_subproc = cak_i_hold)
            THEN
                BEGIN
                qual.msave_restore.sripNoReleaseLog_gg00 := true;
                a3ti := n_sa_level;
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  a3ti <> 0
    THEN
        WITH a_ap_tree^[a3ti] DO
            IF  (n_proc = a37) AND (n_subproc = cak_i_full)
            THEN
                BEGIN
                qual.msave_restore.sripOnlyCompleteSegments_gg00 := true;
                a3ti := n_sa_level;
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    a_mblock.mb_qual^     := qual;
    a_mblock.mb_qual_len  :=
          sizeof (a_mblock.mb_qual^.msave_restore);   (*++ JA ++*)
    a_mblock.mb_struct    := mbs_save_restore;        (*++ JA ++*)
    a_mblock.mb_data_len  := 0;                       (*++ UH ++*)
    IF  a_returncode = 0
    THEN
        BEGIN
        a_mblock.mb_trns^.trError_gg00 := e_ok;
        IF  a_mblock.mb_type2 = mm_log
        THEN
            gg999BackupLog (a_mblock)
        ELSE
            gg999BackupData (a_mblock);
        (*ENDIF*) 
        IF  NOT is_parallel
        THEN
            a_mblock.mb_trns^.trError_gg00 := e_invalid
        ELSE
            IF  a_mblock.mb_trns^.trError_gg00 <> e_ok
            THEN
                BEGIN
                a07_b_put_error (acv, a_mblock.mb_trns^.trError_gg00, 1);
                IF  ((a_mblock.mb_trns^.trError_gg00 = e_new_hostfile_required) OR
                    ( a_mblock.mb_trns^.trError_gg00 = e_wrong_hostfile       ))
                THEN
                    a37multi_tape_info (acv, cak_i_no_keyword);
                (*ENDIF*) 
                END
            ELSE
                a37multi_tape_info (acv, cak_i_no_keyword) (* PTS 1111717 MB 2001-09-14 *)
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37get_data_page (
            VAR acv   : tak_all_command_glob;
            diag_kind : tgg00_DiagType);
 
VAR
      b_err : tgg00_BasisError;
 
BEGIN
WITH acv DO
    BEGIN
    a37init_util_record (acv, m_diagnose, mm_nil);
    IF  (diag_kind = diagPermPages_egg00) OR (diag_kind = diagStaticPages_egg00)
    THEN
        WITH a_ap_tree^ [3] DO
            a05_int4_unsigned_get (acv, n_pos, n_length, a_mblock.mb_qual^.mut_pno);
        (*ENDWITH*) 
    (*ENDIF*) 
    a_mblock.mb_qual^.mut_diag_type := diag_kind;
&   ifdef TRACE
    t01int4 (ak_sem, 'data_pno    ', a_mblock.mb_qual^.mut_pno);
&   endif
    a06_c_send_mess_buf (acv, b_err);
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1)
    ELSE
        BEGIN
        IF  a_mblock.mb_data_len > 0
        THEN
            BEGIN
            IF  a_curr_retpart = NIL
            THEN
                a06init_curr_retpart (acv);
            (*ENDIF*) 
            a_curr_retpart^.sp1p_buf_len:= a_mblock.mb_data_len;
            SAPDB_PascalMove ('VAK37 ',   2,    
                  a_mblock.mb_data_size, a_curr_retpart^.sp1p_buf_size,
                  @a_mblock.mb_data^.mbp_buf, 1,
                  @a_curr_retpart^.sp1p_buf, 1,
                  a_mblock.mb_data_len, a_returncode);
            a06finish_curr_retpart (acv, sp1pk_page, 1)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37extract_files (
            VAR acv   : tak_all_command_glob;
            diag_kind : tgg00_DiagType);
 
VAR
      b_err         : tgg00_BasisError;
      hostfilename  : tsp00_VFilename;
 
BEGIN
WITH acv, a_mblock DO
    BEGIN
    hostfilename := b01blankfilename;
    (* *)
    a37init_util_record (acv, m_diagnose, mm_nil);
    WITH a_ap_tree^[ 2 ] DO
        IF  n_symb = s_hostfilename
        THEN
            (* diagnose extract command including a host filename *)
            BEGIN
            a36filename (acv, 2, mb_qual^.mut_hostfn, sizeof (mb_qual^.mut_hostfn));
            IF  mb_qual^.mut_hostfn <> b01blankfilename
            THEN
                hostfilename := mb_qual^.mut_hostfn;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDWITH*) 
    IF  (diag_kind = diagColRoot_egg00) OR
        (diag_kind = diagInvRoot_egg00) OR
        (diag_kind = diagFile_egg00   )
    THEN
        WITH a_ap_tree^ [3] DO
            a05_int4_unsigned_get (acv, n_pos, n_length, mb_qual^.mut_pno);
        (*ENDWITH*) 
    (*ENDIF*) 
    a_mblock.mb_qual^.mut_diag_type := diag_kind;
&   ifdef TRACE
    t01int4 (ak_sem, 'extract root', mb_qual^.mut_pno);
&   endif
    a06_c_send_mess_buf (acv, b_err);
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37diag_monitor (VAR acv : tak_all_command_glob);
 
VAR
      int4              : tsp00_Int4;
      command           : integer;
      conf_param_name   : tsp11_ConfParamName;
      conf_param_value  : tsp11_ConfParamValue;
      conf_param_ret    : tsp11_ConfParamReturnValue;
      c10               : tsp00_C10;
      value_n           : tsp00_Int2;
      moveobj_ptr       : tsp00_MoveObjPtr;
 
BEGIN
IF  NOT (acv.a_current_user_kind in [ucontroluser, usysdba, udba])
THEN
    a07_kw_put_error (acv, e_missing_privilege, 1, cak_i_dba)
ELSE
    BEGIN
    vbegexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08monitor);
    command := acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_length;
    WITH acv DO
        CASE  command OF
            cak_i_off :
                BEGIN (* h.b. PTS 1106105 *)
                IF  a01diag_monitor_on
                THEN
                    BEGIN
                    a01diag_monitor_on      := false;
                    a01sm_collect_data      := false;
                    a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_subproc := cak_i_off;
                    a42_start_semantic (acv);
                    IF  NOT a01diag_moni_parseid
                    THEN
                        g01diag_moni_parse_on := false;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            cak_i_call :
                BEGIN
                WITH a_ap_tree^[a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_sa_level] DO
                    a05_int4_unsigned_get (acv, n_pos, n_length, int4);
                (*ENDWITH*) 
                ak341HeapCallStackMonitoring(int4);
                END;
            cak_i_clear :
                a545clear_monitor (acv);
            cak_i_data :
                a01sm_collect_data :=
                      (a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_pos = cak_i_on)
                      AND a01diag_monitor_on;
            cak_i_parseid :
                BEGIN
                CASE a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_pos OF
                    cak_i_on:
                        BEGIN
                        a01diag_moni_parseid := true;
                        a37ddl (acv, create_sys_parsid);
                        END;
                    cak_i_off:
                        BEGIN
                        IF  NOT a01diag_monitor_on
                        THEN
                            g01diag_moni_parse_on := false;
                        (*ENDIF*) 
                        a01diag_moni_parseid := false
                        END;
                    END;
                (*ENDCASE*) 
                END;
            OTHERWISE
                BEGIN
                CASE command OF
                    cak_i_selectivity :
                        conf_param_name := 'MONITOR_SELECTIVITY             ';
                    cak_i_read :
                        conf_param_name := 'MONITOR_READ                    ';
                    cak_i_rowno :
                        conf_param_name := 'MONITOR_ROWNO                   ';
                    cak_i_time :
                        conf_param_name := 'MONITOR_TIME                    ';
                    END;
                (*ENDCASE*) 
                SAPDB_PascalForcedFill (sizeof(conf_param_value), @conf_param_value, 1,
                      sizeof(conf_param_value), csp_ascii_blank);
                IF  a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_sa_level = 0
                THEN
                    BEGIN (* turn off *)
                    CASE command OF
                        cak_i_read :
                            c10 := '2147483647';
                        cak_i_time :
                            c10 := '2147483647';
                        cak_i_selectivity :
                            c10 := '0         ';
                        OTHERWISE
                            c10 := '0         ';
                        END;
                    (*ENDCASE*) 
                    SAPDB_PascalForcedMove (sizeof(c10), sizeof(conf_param_value),
                          @c10, 1, @conf_param_value, 1, sizeof(c10));
                    END
                ELSE
                    BEGIN
                    value_n     := a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_sa_level;
                    moveobj_ptr := @conf_param_value;
                    a05string_literal_get (acv, value_n, dcha, moveobj_ptr^, 1, sizeof(conf_param_value));
                    WITH a_ap_tree^[a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_sa_level] DO
                        a05_int4_unsigned_get (acv, n_pos, n_length, int4);
                    (*ENDWITH*) 
                    CASE command OF
                        cak_i_selectivity, cak_i_read, cak_i_time :
                            BEGIN
                            IF  NOT g01diag_moni_parse_on
                            THEN
                                a37ddl (acv, create_sys_parsid);
                            (*ENDIF*) 
                            IF  (a_returncode = 0) AND
                                NOT a01diag_monitor_on
                            THEN
                                BEGIN
                                a37ddl (acv, create_sys_monitor);
                                IF  a_returncode = 0
                                THEN
                                    a37ddl (acv, create_sys_mondata)
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            a01sm_collect_data := true
                            END;
                        OTHERWISE ;
                        END;
                    (*ENDCASE*) 
                    END;
                (*ENDIF*) 
                vconf_param_put (conf_param_name, conf_param_value, c_is_numeric, NOT c_is_perm,
                      conf_param_ret);
                ak37param_put_error (acv, conf_param_ret, 1, conf_param_name);
                END;
            END;
        (*ENDCASE*) 
    (*ENDWITH*) 
    vendexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08monitor)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37media_name (
            VAR acv  : tak_all_command_glob;
            VAR ti   : tsp00_Int2;
            VAR qual : tgg00_QualBuf);
 
VAR
      lo_level : integer;
 
BEGIN
WITH qual, msave_restore DO
    BEGIN
    sripMedianame_gg00 := bsp_c64;
    IF  (ti <> 0) AND
        (acv.a_ap_tree^[ti].n_subproc = cak_i_medianame)
    THEN
        BEGIN (* medianame *)
        lo_level := acv.a_ap_tree^[ti].n_lo_level;
        a05_string_literal_get (acv, lo_level, dcha,
              sizeof (sripMedianame_gg00), sripMedianame_gg00);
        ti := acv.a_ap_tree^[ti].n_sa_level
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37label_name (
            VAR acv  : tak_all_command_glob;
            VAR ti   : tsp00_Int2;
            VAR qual : tgg00_QualBuf);
 
VAR
      lo_level : integer;
      help_c64 : tsp00_C64;
 
BEGIN
WITH qual, msave_restore DO
    BEGIN
    sripTapeLabel_gg00 := bsp_c14;
    IF  (ti <> 0) AND
        (acv.a_ap_tree^[ti].n_proc = a37) AND
        (acv.a_ap_tree^[ti].n_subproc = cak_i_label)
    THEN
        BEGIN (* medianame *)
        lo_level := acv.a_ap_tree^[ti].n_lo_level;
        a05_string_literal_get (acv, lo_level, dcha,
              sizeof (sripTapeLabel_gg00), help_c64);
        SAPDB_PascalForcedMove (sizeof(help_c64),
              sizeof(sripTapeLabel_gg00),
              @help_c64, 1,
              @sripTapeLabel_gg00, 1,
              sizeof(sripTapeLabel_gg00));
        ti := acv.a_ap_tree^[ti].n_sa_level
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37multi_tape_info (
            VAR acv  : tak_all_command_glob;
            kw_index : integer);
 
TYPE
 
      t_redo_trans_info = RECORD (* PTS 1000243 UH 27-10-1999 *)
            CountRead : tsp00_ResNum;
            CountDone : tsp00_ResNum;
      END;
 
      t_redo_trans_info_ptr = ^t_redo_trans_info; (* PTS 1000243 UH 27-10-1999 *)
 
VAR
      e           : tgg00_BasisError;
      get_state   : boolean;
      state_kind  : tsp00_Int2;
      pos         : integer;
      ix          : integer;
      colno       : integer;
      shortinfo   : tak_shortinforecord;
      TransRead   : tsp00_Int4;            (* PTS 1000243 UH 27-10-1999 *)
      TransReDone : tsp00_Int4;            (* PTS 1000243 UH 27-10-1999 *)
      RedoInfo    : t_redo_trans_info_ptr; (* PTS 1000243 UH 27-10-1999 *)
      dummy_err   : tsp00_NumError;        (* PTS 1000243 UH 27-10-1999 *)
      name        : tsp00_C18;
 
BEGIN
WITH acv DO
    BEGIN
    e          := e_ok;
    get_state  := kw_index <> cak_i_no_keyword;
    IF  get_state
    THEN
        CASE kw_index OF
            cak_i_restore, cak_i_save :
                state_kind := 1;
            OTHERWISE
                state_kind := 2;
            END;
        (*ENDCASE*) 
    (*ENDIF*) 
    colno := 1;
    (* PTS 1113268 E.Z. *)
    name := 'DATE              ';
    a06colname_retpart_move (acv, @name, 4, csp_ascii);
    WITH shortinfo.siinfo[colno] DO
        BEGIN (* save date *)
        sp1i_mode       := [ sp1ot_mandatory ];
        sp1i_io_type    := sp1io_output;
        sp1i_data_type  := ddate;
        sp1i_frac       := 0;
        sp1i_length     := mxsp_extdate;
        sp1i_in_out_len := mxsp_extdate+1;
        sp1i_bufpos     := 1;
        pos             := 1 + mxsp_extdate + 1
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'TIME              ';
    a06colname_retpart_move (acv, @name, 4, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[1];
    WITH shortinfo.siinfo[colno] DO
        BEGIN (* save time *)
        sp1i_data_type  := dtime;
        sp1i_length     := mxsp_exttime;
        sp1i_in_out_len := mxsp_exttime+1;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'SERVERDB          ';
    a06colname_retpart_move (acv, @name, 8, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[1];
    WITH shortinfo.siinfo[colno] DO
        BEGIN (* serverdb *)
        sp1i_data_type  := dcha;
        sp1i_length     := DBNAME_MXSP00;
        sp1i_in_out_len := DBNAME_MXSP00+1;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'SERVERNODE        ';
    a06colname_retpart_move (acv, @name, 10, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[colno - 1];
    WITH shortinfo.siinfo[colno] DO
        BEGIN (* servernode *)
        sp1i_length     := NODEID_MXSP00;
        sp1i_in_out_len := NODEID_MXSP00+1;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'KERNEL VERSION    ';
    a06colname_retpart_move (acv, @name, 14, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[colno - 1];
    WITH shortinfo.siinfo[colno] DO
        BEGIN (* kernel version *)
        sp1i_length     := mxsp_c40;
        sp1i_in_out_len := mxsp_c40+1;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'PAGES TRANSFERRED ';
    a06colname_retpart_move (acv, @name, 17, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[1];
    WITH shortinfo.siinfo[colno] DO
        BEGIN (* pages transferred *)
        sp1i_data_type  := dfixed;
        sp1i_length     := csp_resnum_deflen;
        sp1i_in_out_len := mxsp_resnum;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'PAGES LEFT        ';
    a06colname_retpart_move (acv, @name, 10, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[colno -1];
    WITH shortinfo.siinfo[colno] DO
        BEGIN (* pages left *)
        sp1i_length     := csp_resnum_deflen;
        sp1i_in_out_len := mxsp_resnum;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'NO OF VOLUMES     ';
    a06colname_retpart_move (acv, @name, 13, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[colno -1];
    WITH shortinfo.siinfo[colno] DO
        BEGIN (* no of volumes *)
        sp1i_length     := csp_resnum_deflen;
        sp1i_in_out_len := mxsp_resnum;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'MEDIA NAME        ';
    a06colname_retpart_move (acv, @name, 10, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[3];
    WITH shortinfo.siinfo[colno] DO
        BEGIN (* tape (hostfile)name *)
        sp1i_data_type  := dcha;
        sp1i_length     := sizeof (tgg00_MediaName);
        sp1i_in_out_len := sizeof (tgg00_MediaName) + 1;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'TAPE NAME         ';
    a06colname_retpart_move (acv, @name, 9, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[3];
    WITH shortinfo.siinfo[colno] DO
        BEGIN (* tape (hostfile)name *)
        sp1i_data_type  := dcha;
        sp1i_length     := VFILENAME_MXSP00;
        sp1i_in_out_len := VFILENAME_MXSP00 + 1;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'TAPE ERRORTEXT    ';
    a06colname_retpart_move (acv, @name, 14, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[3];
    WITH shortinfo.siinfo[colno] DO
        BEGIN (* tape errortext *)
        sp1i_length     := ERRTEXT_MXSP00;
        sp1i_in_out_len := ERRTEXT_MXSP00 + 1;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'TAPE LABEL        ';
    a06colname_retpart_move (acv, @name, 10, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[3];
    WITH shortinfo.siinfo[colno] DO
        BEGIN (* tape label *)
        sp1i_length     := sizeof (tsp00_C14);
        sp1i_in_out_len := sizeof (tsp00_C14) + 1;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                 := colno + 1;
    name := 'IS CONSISTENT     ';
    a06colname_retpart_move (acv, @name, 13, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[1];
    WITH shortinfo.siinfo[colno] DO
        BEGIN
        sp1i_data_type  := dboolean;
        sp1i_length     := 1;
        sp1i_in_out_len := 1 + 1;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'FIRST IO SEQUENCE ';
    a06colname_retpart_move (acv, @name, 17, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[7];
    WITH shortinfo.siinfo[colno] DO
        BEGIN
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'LAST IO SEQUENCE  ';
    a06colname_retpart_move (acv, @name, 16, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[7];
    WITH shortinfo.siinfo[colno] DO
        BEGIN
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'DBSTAMP1 DATE     ';
    a06colname_retpart_move (acv, @name, 13, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[1];
    WITH shortinfo.siinfo[colno] DO
        BEGIN
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'DBSTAMP1 TIME     ';
    a06colname_retpart_move (acv, @name, 13, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[2];
    WITH shortinfo.siinfo[colno] DO
        BEGIN
        sp1i_data_type  := dtime;
        sp1i_length     := mxsp_exttime;
        sp1i_in_out_len := mxsp_exttime+1;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'DBSTAMP2 DATE     ';
    a06colname_retpart_move (acv, @name, 13, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[1];
    WITH shortinfo.siinfo[colno] DO
        BEGIN
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'DBSTAMP2 TIME     ';
    a06colname_retpart_move (acv, @name, 13, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[2];
    WITH shortinfo.siinfo[colno] DO
        BEGIN
        sp1i_data_type  := dtime;
        sp1i_length     := mxsp_exttime;
        sp1i_in_out_len := mxsp_exttime+1;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'BD PAGE COUNT     ';
    a06colname_retpart_move (acv, @name, 13, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[7];
    WITH shortinfo.siinfo[colno] DO
        BEGIN
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    colno                   := colno + 1;
    name   := 'TAPEDEVICES USED  ';
    a06colname_retpart_move (acv, @name, 16, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[7];
    WITH shortinfo.siinfo[colno] DO
        BEGIN
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    (* PTS 1000449 UH 19980909 begin *)
    colno                   := colno + 1;
    name   := 'DB_IDENT          ';
    a06colname_retpart_move (acv, @name, 8, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[3];
    WITH shortinfo.siinfo[colno] DO
        BEGIN (* db_ident *)
        sp1i_length     := LINE_MXSP00;
        sp1i_in_out_len := LINE_MXSP00 + 1;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    (* PTS 1105071 UH 17-01-2000 begin *)
    colno                   := colno + 1;
    name   := 'MAX USED DATA PNO ';
    a06colname_retpart_move (acv, @name, 17, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[7];
    WITH shortinfo.siinfo[colno] DO
        BEGIN
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    (* PTS 1105071 UH 17-01-2000 end *)
    (* PTS 1129689 TS 2004-05-18 *)
    colno  := colno + 1;
    name   := 'CONV PAGE COUNT   ';
    a06colname_retpart_move (acv, @name, 15, csp_ascii);
    shortinfo.siinfo[colno] := shortinfo.siinfo[7];
    WITH shortinfo.siinfo[colno] DO
        BEGIN
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    (* PTS 1129689 *)
    IF  get_state (* PTS 1000243 UH 27-10-1999 *)
    THEN
        BEGIN
        colno                   := colno + 1;
        name   := 'REDO TRANS READ   ';
        a06colname_retpart_move (acv, @name, 15, csp_ascii);
        shortinfo.siinfo[colno] := shortinfo.siinfo[7];
        WITH shortinfo.siinfo[colno] DO
            BEGIN
            sp1i_bufpos     := pos;
            pos             := pos + sp1i_in_out_len
            END;
        (*ENDWITH*) 
        (* *)
        colno                   := colno + 1;
        name   := 'REDO TRANS DONE   ';
        a06colname_retpart_move (acv, @name, 15, csp_ascii);
        shortinfo.siinfo[colno] := shortinfo.siinfo[7];
        WITH shortinfo.siinfo[colno] DO
            BEGIN
            sp1i_bufpos     := pos;
            pos             := pos + sp1i_in_out_len
            END;
        (*ENDWITH*) 
        END;
    (* PTS 1000449 UH 19980909 end *)
    (*ENDIF*) 
    a06finish_curr_retpart (acv, sp1pk_columnnames, colno);
    shortinfo.sicount := colno;
    a06retpart_move (acv, @shortinfo.siinfo,
          shortinfo.sicount * sizeof (shortinfo.siinfo[1]));
    a06finish_curr_retpart (acv, sp1pk_shortinfo, colno);
    IF  get_state
    THEN
        BEGIN
        a06init_curr_retpart (acv);
        IF  a_curr_retpart <> NIL
        THEN
            WITH a_curr_retpart^ DO
                BEGIN
                (* PTS 1000397 UH *)
                k38get_state (sp1p_buf_size, sp1p_buf_len, sp1p_buf);
                (* PTS 1000243 UH 27-10-1999 begin *)
                (* PTS 1116085 UH 2002-08-16 *)
                gg999GetRedoLogProgressInfo (TransRead, TransReDone);
                RedoInfo := @sp1p_buf[sp1p_buf_len+1];
                RedoInfo^.CountRead[1] := csp_defined_byte;
                RedoInfo^.CountDone[1] := csp_defined_byte;
                s41p4int (RedoInfo^.CountRead, 2, TransRead,   dummy_err);
                s41p4int (RedoInfo^.CountDone, 2, TransReDone, dummy_err);
                sp1p_buf_len := sp1p_buf_len + sizeof (t_redo_trans_info);
                (* PTS 1000243 UH 27-10-1999 end*)
                END
            (*ENDWITH*) 
        ELSE
            a_transinf.tri_trans.trError_gg00 :=  e_too_small_packet_size;
        (*ENDIF*) 
        IF  a_transinf.tri_trans.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1)
        (*ENDIF*) 
        END
    ELSE
        (*-------------- put values into part2 ------------------------*)
        FOR ix := 1 TO shortinfo.sicount DO
            WITH shortinfo.siinfo[ix] DO
                IF  sp1i_data_type in
                    [ddate, dtime, dcha]
                THEN
                    a06char_retpart_move (acv,
                          @a_mblock.mb_qual^.buf[sp1i_bufpos],
                          sp1i_in_out_len)
                ELSE
                    a06retpart_move (acv,
                          @a_mblock.mb_qual^.buf[sp1i_bufpos],
                          sp1i_in_out_len);
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDFOR*) 
    (*ENDIF*) 
    FOR ix := 1 TO shortinfo.sicount DO
        WITH shortinfo.siinfo[ix] DO
            CASE sp1i_data_type OF
                ddate :
                    g03dchange_format_date (a_curr_retpart^.sp1p_buf,
                          a_curr_retpart^.sp1p_buf, sp1i_bufpos, sp1i_bufpos,
                          a_dt_format, e);
                dtime :
                    g03tchange_format_time (a_curr_retpart^.sp1p_buf,
                          a_curr_retpart^.sp1p_buf, sp1i_bufpos, sp1i_bufpos,
                          a_dt_format, e);
                OTHERWISE;
                END;
            (*ENDCASE*) 
        (*ENDWITH*) 
    (*ENDFOR*) 
    a06finish_curr_retpart (acv, sp1pk_data, colno);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37user_save_reaction (
            VAR acv  : tak_all_command_glob;
            VAR a30v : tak_a30_utility_glob;
            reaction : integer);
 
VAR
      m2type  : tgg00_MessType2;
 
BEGIN
CASE reaction OF
    cak_i_ignore :
        m2type := mm_ignore;
    cak_i_cancel :
        m2type := mm_abort;
    cak_i_replace :
        m2type := mm_newtape;
    END;
(*ENDCASE*) 
a06a_mblock_init (acv,
      m_save_parallel, m2type, b01niltree_id);
WITH acv, a_mblock, mb_qual^, a30v, a_ap_tree^[a3ti] DO
    BEGIN
    a_mblock.mb_struct := mbs_save_restore;
    mb_qual^.msave_restore.sripMedianame_gg00 := bsp_c64;
    a3ti := a_ap_tree^[a3ti].n_sa_level;
    mb_qual^.msave_restore.sripHostTapenames_gg00 [1] := b01blankfilename;
    IF  (a3ti <> 0) AND (a_ap_tree^[a3ti].n_symb = s_hostfilename)
    THEN
        BEGIN
        a36filename (acv, a3ti,
              mb_qual^.msave_restore.sripHostTapenames_gg00 [1],
              sizeof (mb_qual^.msave_restore.sripHostTapenames_gg00 [1]));
        a3ti := a_ap_tree^[a3ti].n_sa_level;
        IF  a36filetype (acv, a3ti,
            mb_qual^.msave_restore.sripHostFiletypes_gg00 [1])
        THEN
            a3ti := a_ap_tree^[a3ti].n_sa_level
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    ak37get_count_int4 (acv, a30v,
          mb_qual^.msave_restore.sripHostTapecount_gg00 [1]);
    mb_qual^.msave_restore.sripIsAutoLoad_gg00        := false;
    IF  a3ti <> 0
    THEN
        WITH a_ap_tree^[a3ti] DO
            IF  (n_proc = a37) AND (n_subproc = cak_i_cascade)
            THEN
                mb_qual^.msave_restore.sripIsAutoLoad_gg00 := true;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    mb_data_len := 0;
    IF  a_returncode = 0
    THEN
        BEGIN
        a_mblock.mb_trns^.trError_gg00 := e_ok;
        gg999BackupRestoreHandling (a_mblock);
        IF  mb_trns^.trError_gg00 <> e_ok
        THEN
            BEGIN
            a07_b_put_error (acv, mb_trns^.trError_gg00, 1);
            IF  (mb_trns^.trError_gg00 = e_new_hostfile_required) OR   (* JA 1996-04-10 *)
                (mb_trns^.trError_gg00 = e_wrong_hostfile       )
            THEN
                a37multi_tape_info (acv, cak_i_no_keyword)
            (*ENDIF*) 
            END
        ELSE
            IF  reaction <> cak_i_cancel (* JA 1996-04-10 *)
            THEN
                a37multi_tape_info (acv, cak_i_no_keyword)
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37return_hostname (VAR acv : tak_all_command_glob);
 
VAR
      arg_count   : integer;
      name        : tsp00_C18;
      shortinfo   : tak_shortinforecord;
 
BEGIN
WITH acv DO
    BEGIN
    name := 'FILENAME          ';
    a06colname_retpart_move (acv, @name, 8, csp_ascii);
    WITH shortinfo.siinfo[1] DO
        BEGIN
        sp1i_mode       := [ sp1ot_mandatory ];
        sp1i_io_type    := sp1io_output;
        sp1i_data_type  := dcha;
        sp1i_frac       := 0;
        sp1i_length     := sizeof (a_mblock.mb_qual^.mut_hostfn);
        sp1i_in_out_len := succ(sp1i_length);
        sp1i_bufpos     := 1;
        END;
    (*ENDWITH*) 
    a06finish_curr_retpart (acv, sp1pk_columnnames, 1);
    shortinfo.sicount := 1;
    a06retpart_move (acv, @shortinfo.siinfo,
          shortinfo.sicount * sizeof (shortinfo.siinfo[1]));
    a06finish_curr_retpart (acv, sp1pk_shortinfo, shortinfo.sicount);
    a06retpart_move (acv, @a_mblock.mb_qual^.mut_hostfn,
          sizeof (a_mblock.mb_qual^.mut_hostfn));
    arg_count := 1;
    a06finish_curr_retpart (acv, sp1pk_data, arg_count)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37init_util_record (
            VAR acv : tak_all_command_glob;
            m_type  : tgg00_MessType;
            mm_type : tgg00_MessType2);
 
BEGIN
a06a_mblock_init (acv,
      m_type, mm_type, b01niltree_id);
WITH acv, a_mblock.mb_qual^ DO
    BEGIN
    acv.a_mblock.mb_struct := mbs_util;
    IF  m_type in [m_save_parallel, m_autosave]
    THEN
        BEGIN
        acv.a_mblock.mb_struct := mbs_save_restore;
        ak37init_save_restore_input_param (msave_restore);
        END
    ELSE
        BEGIN
        mut_diag_type  := diagNil_egg00;
        mut_config     := false;
        mut_pool_size  := 0;
        mut_index_no   := 0;
        mut_pno        := NIL_PAGE_NO_GG00;
        mut_pno2       := NIL_PAGE_NO_GG00;
        mut_count      := -1;
        mut_dump_state := [];
        mut_surrogate  := cgg_zero_id;
        mut_authname   := a01_il_b_identifier ;
        mut_tabname    := a01_il_b_identifier ;
        mut_dev        := b01blankfilename;
        mut_dev2       := b01blankfilename;
        mut_hostfn     := b01blankfilename;
        acv.a_mblock.mb_qual_len  :=
              sizeof (b01niltree_id ) + sizeof (mut_diag_type ) +
              sizeof (mut_config    ) + sizeof (mut_pool_size ) +
              sizeof (mut_index_no  ) + sizeof (mut_pno       ) +
              sizeof (mut_pno2      ) + sizeof (mut_count     ) +
              sizeof (mut_dump_state) + sizeof (mut_surrogate ) +
              sizeof (mut_authname  ) +
              sizeof (mut_tabname   ) + sizeof (mut_dev       ) +
              sizeof (mut_dev2      ) + sizeof (mut_hostfn    )
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37init_save_restore_input_param (VAR newParam : tgg00_SaveRestoreInputParam);
 
BEGIN
WITH newParam DO
    BEGIN
    sripBlocksize_gg00            := 0;
    sripHostTapeNum_gg00          := 0;
    sripFileVersion_gg00          := 0;
    sripIsAutoLoad_gg00           := false;
    sripWithCheckpoint_gg00       := false;
    sripIsRestoreConfig_gg00      := false;
    sripOnlyCompleteSegments_gg00 := false;        (* PTS 1131132 EZ 2004-08-26 *)
    sripMedianame_gg00            := bsp_c64;
    sripUntilDate_gg00            := bsp_date;
    sripUntilTime_gg00            := bsp_time;
    kb560InvalidateIOSeq( sripUntilIOSequence_gg00 ); (* PTS 1121539 mb 2003-06-18 *)
    sripUtilCmdId_gg00.utidId_gg00     := bsp_c12; (* PTS 1108625 UH 2000-12-11 *)
    sripUtilCmdId_gg00.utidLineNo_gg00 := 0;       (* PTS 1108625 UH 2000-12-11 *)
    sripConfigDbName_gg00    := bsp_dbname;
    sripTapeLabel_gg00       := bsp_c14;           (* PTS 1128100 mb 1004-03-01 *)
    sripNoReleaseLog_gg00    := false;             (* PTS 1128703 mb 2004-05-05 *)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37multi_tapes (
            VAR acv      : tak_all_command_glob;
            VAR a30v     : tak_a30_utility_glob;
            VAR qual     : tgg00_QualBuf;
            messtype2    : tgg00_MessType2);
 
VAR
      ix         : integer;
 
BEGIN
WITH acv, a30v, qual, msave_restore DO
    BEGIN
    sripBlocksize_gg00   := 0;
    sripHostTapeNum_gg00 := 0;
    FOR ix := 1 TO MAX_TAPES_GG00 DO
        BEGIN
        sripHostTapecount_gg00 [ix] := csp_maxint4;
        sripHostTapenames_gg00 [ix] := b01blankfilename;
        END;
    (*ENDFOR*) 
    sripMedianame_gg00 := bsp_c64;
    WHILE a_ap_tree^[a3ti].n_symb = s_hostfilename DO
        BEGIN
        sripHostTapeNum_gg00 := sripHostTapeNum_gg00 + 1;
        (* PTS 1112983 E.Z. *)
        IF  messtype2 = mm_log
        THEN
            a36filename (acv, a3ti,
                  sripHostTapenames_gg00 [sripHostTapeNum_gg00],
                  sizeof(sripHostTapenames_gg00 [sripHostTapeNum_gg00])
                  - cak_logsave_numlen)
        ELSE
            a36filename (acv, a3ti,
                  sripHostTapenames_gg00 [sripHostTapeNum_gg00],
                  sizeof(sripHostTapenames_gg00 [sripHostTapeNum_gg00]));
        (*ENDIF*) 
        a3ti := a_ap_tree^[a3ti].n_sa_level;
        IF  a36filetype (acv, a3ti,
            sripHostFiletypes_gg00 [sripHostTapeNum_gg00])
        THEN
            a3ti := a_ap_tree^[a3ti].n_sa_level;
        (*ENDIF*) 
        ak37get_count_int4 (acv, a30v,
              sripHostTapecount_gg00 [sripHostTapeNum_gg00]);
&       ifdef trace
        t01int4 (ak_sem, 'a3ti        ', a3ti);
&       endif
        END
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37send_messbuffer (
            VAR acv    : tak_all_command_glob;
            m_type     : tgg00_MessType;
            mm_type    : tgg00_MessType2);
 
VAR
      b_err  : tgg00_BasisError;
      a30v   : tak_a30_utility_glob;
 
BEGIN
WITH acv, a30v, a_mblock DO
    IF  a_returncode  = 0
    THEN
        BEGIN
        a37init_util_record (acv, m_type, mm_type);
        a3ti := 1;
        IF  m_type = m_commit
        THEN
            BEGIN
            SAPDB_PascalMove ('VAK37 ',   3,    
                  sizeof(a_acc_user_id), a_mblock.mb_qual_size,
                  @a_acc_user_id, 1,
                  @a_mblock.mb_qual^.buf, 1, sizeof(a_acc_user_id), a_returncode);
            a_mblock.mb_qual_len  := SURROGATE_MXGG00
            END
        ELSE
            (* PTS 1115982 E.Z. *)
            IF  m_type = m_diagnose
            THEN
                BEGIN (* read hostfilename into mess_buf, return *)
                (* hostfilename to utility                       *)
                a36filename (acv, 2,
                      a_mblock.mb_qual^.mut_hostfn,
                      sizeof(a_mblock.mb_qual^.mut_hostfn));
                a37return_hostname (acv)
                END
            ELSE
                (* PTS 112096 E.Z. *)
                IF  m_type = m_verify
                THEN
                    BEGIN
                    a3ti := a_ap_tree^[a3ti].n_sa_level;
                    IF  a3ti <> 0
                    THEN
                        IF  (a_ap_tree^[a3ti].n_proc = a30) AND
                            (a_ap_tree^[a3ti].n_subproc = cak_x_extended_check)
                        THEN
                            BEGIN
                            a_mblock.mb_qual^.mv_extended := true;
                            a30v.a3ti := a_ap_tree^[a30v.a3ti].n_sa_level (* PTS 1133300 EZ 2005-01-11 *)
                            END
                        ELSE
                            a_mblock.mb_qual^.mv_extended := false;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    a_mblock.mb_qual^.mv_delete_longfile := false; (* PTS 1133300 EZ 2005-01-11 *)
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  gg999KernelStateIsAdmin   AND
            NOT gg999KernelStateIsRedoLogProcessing
        THEN
            a06_c_send_mess_buf (acv, b_err)
        ELSE
            a06lsend_mess_buf (acv, a_mblock,
                  NOT cak_call_from_rsend, b_err);
        (*ENDIF*) 
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37ddl (
            VAR acv : tak_all_command_glob;
            ddl_id : tak30_ddl_kind);
 
CONST
      c_release_packet = true;
 
VAR
      isExtendedTempFile : boolean;
      tempFileType       : tgg00_TfnTemp;
      init_user_kind     : tak_usertyp;
      init_sqlmode       : tsp00_SqlMode; (* h.b. PTS 1105040 *)
      char_size          : integer;
      i                  : integer;
      init_auth_id       : tgg00_Surrogate;
      init_auth_name     : tsp00_KnlIdentifier;
      stmt_cnt           : integer;
      p_arr              : tak_syspointerarr;
      tablename          : tsp00_KnlIdentifier;
      create_stmt        : ARRAY[1..17] OF tsp00_C40;
      c3                 : tsp00_C3;
 
BEGIN
WITH acv DO
    BEGIN
    init_user_kind := a_current_user_kind;
    init_auth_id   := a_curr_user_id;
    init_auth_name := a_curr_user_name;
    a_curr_user_name := g01glob.sysuser_name;
    a_curr_user_id   := g01glob.sysuser_id;
    CASE ddl_id OF
        create_sys_parsid :
            tablename := a01_i_sysparseid;
        create_sys_monitor :
            tablename := a01_i_sysmonitor;
        create_sysdata_analyze :
            tablename := a01_i_sysdata_analyze;
        create_syscmd_analyze :
            tablename := a01_i_syscmd_analyze;
        OTHERWISE
            tablename := a01_i_sysmondata;
        END;
    (*ENDCASE*) 
    IF  NOT a06_table_exist ( acv, d_release, a_curr_user_name,
        tablename, p_arr, false)
    THEN
        BEGIN
        CASE ddl_id OF
            create_sys_parsid :
                BEGIN
                (* create table sys_parseid *)
                create_stmt[1] := sysparse1;
                create_stmt[2] := sysparse2;
                IF  g01unicode
                THEN
                    BEGIN
                    create_stmt[3] := sysuparse3;
                    create_stmt[4] := sysuparse4;
                    create_stmt[5] := sysuparse5;
                    END
                ELSE
                    BEGIN
                    create_stmt[3] := sysparse3;
                    create_stmt[4] := sysparse4;
                    create_stmt[5] := sysparse5;
                    END;
                (*ENDIF*) 
                create_stmt[6] := sysparse6;
                stmt_cnt       := 6
                END;
            create_sys_monitor :
                BEGIN
                (* create table sysmonitor *)
                create_stmt[1]  := sysmon1;
                create_stmt[2]  := sysmon2;
                create_stmt[3]  := sysmon3;
                create_stmt[4]  := sysmon4;
                create_stmt[5]  := sysmon5;
                create_stmt[6]  := sysmon6;
                create_stmt[7]  := sysmon7;
                create_stmt[8]  := sysmon8;
                create_stmt[9]  := sysmon9;
                create_stmt[10] := sysmon10;
                create_stmt[11] := sysmon11;
                create_stmt[12] := sysmon12;
                create_stmt[13] := sysmon13;
                IF  g01unicode
                THEN
                    create_stmt[14] := sysumon14
                ELSE
                    create_stmt[14] := sysmon14;
                (*ENDIF*) 
                create_stmt[15] := sysmon15;
                create_stmt[16] := sysmon16;
                create_stmt[17] := sysmon17;
                stmt_cnt        := 17
                END;
            create_syscmd_analyze:
                BEGIN
                (* create table syscmd_analyze *)
                create_stmt[1] := syscmd1;
                IF  g01unicode
                THEN
                    BEGIN
                    create_stmt[2] := sysucmd2;
                    create_stmt[4] := sysucmd4;
                    END
                ELSE
                    BEGIN
                    create_stmt[2] := syscmd2;
                    create_stmt[4] := syscmd4;
                    END;
                (*ENDIF*) 
                create_stmt[3] := syscmd3;
                create_stmt[5] := syscmd5;
                create_stmt[6] := syscmd6;
                create_stmt[7] := syscmd7;
                stmt_cnt       := 7
                END;
            create_sysdata_analyze:
                BEGIN
                (* create table sys_data *)
                create_stmt[1]  := sysdata1;
                create_stmt[2]  := sysdata2;
                create_stmt[3]  := sysdata3;
                create_stmt[4]  := sysdata4;
                create_stmt[5]  := sysdata5;
                create_stmt[6]  := sysdata6;
                create_stmt[7]  := sysdata7;
                create_stmt[8]  := sysdata8;
                create_stmt[9]  := sysdata9;
                create_stmt[10] := sysdata10;
                create_stmt[11] := sysdata11;
                stmt_cnt        := 11
                END;
            create_sys_mondata :
                BEGIN
                (* create table sysmonitor *)
                create_stmt[1]  := sysmondt1;
                create_stmt[2]  := sysmondt2;
                create_stmt[3]  := sysmondt3;
                IF  g01unicode
                THEN
                    create_stmt[4]  := sysumondt4
                ELSE
                    create_stmt[4] := sysmondt4;
                (*ENDIF*) 
                IF  g01unicode
                THEN
                    create_stmt[5]  := sysumondt5
                ELSE
                    create_stmt[5] := sysmondt5;
                (*ENDIF*) 
                stmt_cnt        := 5
                END;
            END;
        (*ENDCASE*) 
        IF  g01unicode
        THEN
            char_size := 2
        ELSE
            char_size := 1;
        (*ENDIF*) 
        a542internal_packet (acv, NOT c_release_packet,
              char_size * stmt_cnt * sizeof (create_stmt[1]));
        IF  a_returncode = 0
        THEN
            BEGIN
            init_sqlmode := a_sqlmode; (* h.b. PTS 1105040 *)
            a_sqlmode    := sqlm_internal;
            a_cmd_part^.sp1p_buf_len := 0;
            FOR i := 1 TO stmt_cnt DO
                a542move_to_packet (acv,
                      @create_stmt[i], sizeof (create_stmt[i]));
            (*ENDFOR*) 
            a_current_user_kind := udba;
            a_command_kind      := internal_create_tab_command;
&           ifdef trace
            t01moveobj (ak_sem,
                  a_cmd_part^.sp1p_buf, 1, a_cmd_part^.sp1p_buf_len);
&           endif
            a35_asql_statement (acv);
            a542pop_packet (acv);
            a_command_kind := single_command;
            a_sqlmode      := init_sqlmode; (* h.b. PTS 1105040 *)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        IF  a06_table_exist ( acv, d_release, a_curr_user_name,
            tablename, p_arr, false )
        THEN
            BEGIN
            b01filestate (a_transinf.tri_trans,
                  p_arr.pbasep^.sbase.btreeid);
            (* temp tables doesn't exists after RESTART *)
            (* but catalog information already exists   *)
            IF  a_transinf.tri_trans.trError_gg00 = e_file_not_found
            THEN
                BEGIN
                isExtendedTempFile := a101_IsExtendedTempFile (acv,
                      p_arr.pbasep^.sbase.btreeid);
                IF  isExtendedTempFile
                THEN
                    tempFileType := a101_GetExtendedTempFileType (acv,
                          p_arr.pbasep^.sbase.btreeid)
                ELSE
                    tempFileType := ttfnNone_egg00;
                (*ENDIF*) 
                bd998CreateNamedTempFile (a_transinf.tri_trans,
                      p_arr.pbasep^.sbase.btreeid.fileTabId_gg00,
                      p_arr.pbasep^.sbase.btreeid,
                      isExtendedTempFile, tempFileType);
                END;
            (*ENDIF*) 
            IF  a_transinf.tri_trans.trError_gg00 = e_ok
            THEN
                BEGIN
                p_arr.pbasep^.sbase.btreeid.fileHandling_gg00 :=
                      p_arr.pbasep^.sbase.btreeid.fileHandling_gg00 + [hsNoLog_egg00];
                CASE ddl_id OF
                    create_sys_parsid:
                        g01tabid.sys_diag_parse :=
                              p_arr.pbasep^.sbase.btreeid;
                    create_sys_monitor :
                        a545sm_reset (p_arr.pbasep^.sbase.btreeid);
                    create_sys_mondata :
                        a545sm_data_tree (acv, p_arr.pbasep^.sbase.btreeid);
                    create_syscmd_analyze :
                        g01tabid.sys_cmd_analyze :=
                              p_arr.pbasep^.sbase.btreeid;
                    create_sysdata_analyze :
                        g01tabid.sys_data_analyze :=
                              p_arr.pbasep^.sbase.btreeid;
                    END;
                (*ENDCASE*) 
                END
            ELSE
                a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        a52_ex_commit_rollback (acv, m_commit, false, false);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        IF  ddl_id = create_sys_parsid
        THEN
            g01diag_moni_parse_on := true
        ELSE
            IF  ddl_id = create_sys_monitor
            THEN
                BEGIN  (* h.b. PTS 1106105 *)
                a01diag_monitor_on      := true;
                IF  a_transinf.tri_trans.trBdTcachePtr_gg00 <> NIL
                THEN
                    BEGIN
                    b21m_parse_again (a_transinf.tri_trans.trBdTcachePtr_gg00,
                          c3);
                    IF  c3 = '   '
                    THEN
                        BEGIN
                        WITH a_pars_last_key DO
                            BEGIN
                            (* PTS 1109291 E.Z. *)
                            a92next_monitor_pcount (acv, a_pars_last_key);
                            p_id   := chr(0);
                            p_kind := m_nil;
                            p_no   := 0
                            END;
                        (*ENDWITH*) 
                        b21mp_parse_again_put (acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                              a_pars_last_key.p_count);
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    a_internal_sql       := no_internal_sql;
    a_current_user_kind  := init_user_kind;
    a_curr_user_id       := init_auth_id;
    a_curr_user_name     := init_auth_name
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37read_label (VAR acv : tak_all_command_glob;
            VAR a30v : tak_a30_utility_glob);
 
VAR
      file_node : tsp00_Int2;
      dont_care : boolean;
 
BEGIN
a06a_mblock_init (acv, m_save_parallel, mm_fread, b01niltree_id);
WITH acv, a_mblock, mb_qual^, msave_restore DO
    BEGIN
    ak37init_save_restore_input_param (msave_restore);
    a_mblock.mb_struct   := mbs_save_restore;
    sripHostTapeNum_gg00 := 1;
    file_node            :=
          a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
    a36filename (acv, file_node,
          sripHostTapenames_gg00 [sripHostTapeNum_gg00],
          sizeof (sripHostTapenames_gg00 [sripHostTapeNum_gg00]));
    file_node := a_ap_tree^[ file_node ].n_sa_level;
    dont_care := a36filetype (acv, file_node,
          sripHostFiletypes_gg00 [sripHostTapeNum_gg00]);
    a30v.a3ti := a_ap_tree^[ file_node ].n_sa_level;
    a_mblock.mb_qual^.msave_restore.sripBlocksize_gg00 := a37blocksize (acv, a30v);
    mb_qual_len  := sizeof(msave_restore);
    IF  a_returncode = 0
    THEN
        BEGIN
        a_mblock.mb_trns^.trError_gg00 := e_ok;
        gg999BackupRestoreHandling (a_mblock);
        IF  a_mblock.mb_trns^.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, a_mblock.mb_trns^.trError_gg00, 1)
        ELSE
            a37multi_tape_info (acv, cak_i_no_keyword)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37verify (VAR acv : tak_all_command_glob);
 
BEGIN
WITH acv DO
    BEGIN
    CASE a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_length OF
        cak_i_catalog, cak_i_modify :
            a37verify_catalog (acv,
                  a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_length = cak_i_modify,
                  NOT c_in_migration);
        (* PTS 1105851 E.Z. *)
        cak_i_index :
            ak37send_messbuffer (acv, m_verify, mm_index);
        OTHERWISE
            ak37send_messbuffer (acv, m_verify, mm_nil);
        END;
    (*ENDCASE*) 
    IF  (a_returncode <> 0) AND
        (a_mblock.mb_qual_len  > 0)
    THEN
        BEGIN
        a06retpart_move (acv, @a_mblock.mb_qual^.buf[1],
              a_mblock.mb_qual_len );
        a06finish_curr_retpart (acv, sp1pk_errortext, 1);
        a_user_defined_error := true
        END;
    (*ENDIF*) 
    a37resultevent (sp31ei_checkdata, acv.a_returncode);
    END;
(*ENDWITH*) 
END;
 
(* PTS 1120247 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak37set_parameter (VAR acv : tak_all_command_glob);
 
VAR
      _moveobj_ptr     : tsp00_MoveObjPtr;
      _permanent       : boolean;
      _param_n         : tsp00_Int2;
      _value_n         : tsp00_Int2;
      _ident_len       : tsp00_Int4;
      _cp_name         : tsp11_ConfParamName;
      _cp_value        : tsp11_ConfParamValue;
      _cp_ret          : tsp11_ConfParamReturnValue;
      _is_numeric      : boolean;
      _uni_identifier  : tsp00_KnlIdentifier;
      _error           : tsp8_uni_error;
      _err_char_no     : tsp00_Int4;
 
BEGIN
WITH acv DO
    BEGIN
    _permanent := (a_ap_tree^[a_ap_tree^[0].n_lo_level].n_length = cak_i_permanent);
    _param_n := a_ap_tree^[a_ap_tree^[0].n_lo_level].n_lo_level;
    WHILE (_param_n <> 0) AND
          (a_returncode = 0) DO
        BEGIN
        (* PTS 1107610 E.Z. *)
        IF  g01unicode
        THEN
            BEGIN
            _moveobj_ptr := @_uni_identifier;
            _ident_len   := sizeof (_cp_name);
            a05_identifier_get (acv, _param_n,
                  sizeof (_cp_name) * a01char_size, _moveobj_ptr^);
            IF  (a_returncode = 0)
            THEN
                s80uni_trans (@_uni_identifier, sizeof (_cp_name) * a01char_size,
                      csp_unicode, @_cp_name, _ident_len,
                      csp_ascii, [ ], _error, _err_char_no);
            (*ENDIF*) 
            IF  _error <> uni_ok
            THEN
                a07_hex_uni_error (acv, _error, 1, NOT c_trans_to_uni,
                      @_uni_identifier [_err_char_no], c_unicode_wid)
            ELSE
                IF  _ident_len <> sizeof (_cp_name)
                THEN
                    a07_b_put_error (acv, e_identifier_too_long, 1)
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            _moveobj_ptr := @_cp_name;
            a05_identifier_get (acv, _param_n,
                  sizeof (_cp_name), _moveobj_ptr^);
            END;
        (*ENDIF*) 
        (* END PTS 1107610 E.Z. *)
        IF  (a_returncode = 0)
        THEN
            BEGIN
            _value_n    := a_ap_tree^[_param_n].n_lo_level;
            _is_numeric := (a_ap_tree^[_value_n].n_symb <> s_string_literal);
            _moveobj_ptr := @_cp_value;
            a05string_literal_get (acv, _value_n, dcha,
                  _moveobj_ptr^, 1, sizeof(_cp_value));
            END;
        (*ENDIF*) 
        IF  (a_returncode = 0)
        THEN
            WITH acv.a_mblock, mb_data^ DO
                BEGIN
                vconf_param_put (_cp_name, _cp_value, _is_numeric, _permanent, _cp_ret);
                IF  (_cp_ret <> ok_sp11)
                THEN
                    ak37param_put_error (acv, _cp_ret, a_ap_tree^[_param_n].n_pos, _cp_name);
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        _param_n := a_ap_tree^[_param_n].n_sa_level;
        END;
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1108247 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak37delete_log_from_to (VAR acv : tak_all_command_glob);
 
VAR
      node     : integer;
      frompage : tsp00_Int4;
      topage   : tsp00_Int4;
 
BEGIN
WITH acv DO
    BEGIN
    node := a_ap_tree^[a_ap_tree^[0].n_lo_level].n_lo_level;
    a05_int4_unsigned_get (acv, a_ap_tree^[ node ].n_pos,
          a_ap_tree^[ node ].n_length, frompage);
    node := a_ap_tree^[node].n_sa_level;
    IF  a_returncode = 0
    THEN
        a05_int4_unsigned_get (acv, a_ap_tree^[ node ].n_pos,
              a_ap_tree^[ node ].n_length, topage);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        kb391FreeLogForPipe(             (* PTS 1114791 mb 2002-08-22 *)
              acv.a_transinf.tri_trans.trTaskId_gg00,
              frompage,                         (* frompage means the first IOSequence *)
              topage,                           (* topage means the last IOSequence *)
              a_transinf.tri_trans.trError_gg00);
        END;
    (*ENDIF*) 
    IF  a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1)
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37verify_catalog (
            VAR acv      : tak_all_command_glob;
            do_repair    : boolean;
            in_migration : boolean);
 
CONST
      c_add = true;
 
VAR
      replace     : boolean;
      b_err       : tgg00_BasisError;
      recKind     : tsp00_C2;
      i           : integer;
      pos         : integer;
      err_count   : integer;
      msg         : tsp00_C36;
      cnt         : tsp00_C12;
      sysk        : tgg00_SysInfoKey;
      currSysk    : tgg00_SysInfoKey;
      error       : tsp8_uni_error;
      err_char_no : tsp00_Int4;
 
BEGIN
WITH acv DO
    BEGIN
    a_localCacheUsageOnly := true;
    a10_cache_delete (acv, NOT c_is_rollback);
    a38create_parameter_file (acv);
    sysk    := a01defaultkey;
    recKind := cak_edummy;
    REPEAT
        a10next_sysinfo (acv, sysk, 0, d_fix,
              recKind, a_p_arr1.pbasep, b_err);
        IF  b_err = e_ok
        THEN
            BEGIN
            replace  := false;
            currSysk := a_p_arr1.pbasep^.syskey;
            CASE a_p_arr1.pbasep^.syskey.sentrytyp[2] OF
                cak_ctable :
                    BEGIN
                    WITH a_p_arr1.pbasep^.sbase DO
                        IF  (btablekind = twithkey) OR
                            (btablekind = twithoutkey)
                        THEN
                            BEGIN
                            ak37scan (acv, sysk.stableid, do_repair);
                            ak37verify_base_table (acv,
                                  sysk.stableid, do_repair);
                            END;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    sysk.slinkage[2] := chr(3);
                    END;
                cak_cpriv :
                    IF  NOT in_migration
                    THEN
                        ak37CheckPrivilege (acv, a_p_arr1.pbasep, do_repair);
                    (*ENDIF*) 
                cak_cmethodref :
                    IF  NOT in_migration
                    THEN
                        ak37CheckMethodRef (acv, a_p_arr1.pbasep^.smethodref, do_repair);
                    (*ENDIF*) 
                cak_cprocpriv :
                    IF  NOT in_migration
                    THEN
                        ak37CheckDBProcPrivilege (acv, a_p_arr1.pbasep^.sprocseqpriv, do_repair);
                    (*ENDIF*) 
                cak_cusertab :
                    IF  NOT in_migration
                    THEN
                        ak37CheckUserTab   (acv, a_p_arr1.pbasep^.susertab, do_repair, replace);
                    (*ENDIF*) 
                cak_cmethod :
                    sysk.slinkage[2] := chr(255);
                OTHERWISE ;
                END;
            (*ENDCASE*) 
            IF  replace
            THEN
                a10_add_repl_sysinfo (acv, a_p_arr1.pbasep, NOT c_add, b_err);
            (*ENDIF*) 
            a10_key_del (acv, currSysk)
            END
        ELSE
            IF  (b_err = e_no_next_record) AND (recKind = cak_edummy)
            THEN
                BEGIN
                b_err   := e_ok;
                recKind := cak_esysfile2;
                sysk    := a01defaultkey;
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    UNTIL
        (b_err <> e_ok) OR (a_returncode <> 0);
    (*ENDREPEAT*) 
    IF  b_err <> e_no_next_record
    THEN
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    a_mblock.mb_qual_len  := 0;
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  a_show_data_cnt > 0
        THEN
            BEGIN
            IF  NOT do_repair
            THEN
                a07_b_put_error (acv, e_range_violation, 1);
            (*ENDIF*) 
            msg       := 'INCONSISTENCIES FOUND :             ';
            err_count := a_show_data_cnt;
            i         := sizeof (cnt);
            WHILE err_count > 0 DO
                BEGIN
                cnt[i]    := chr (err_count MOD 10 + ord ('0'));
                err_count := err_count DIV 10;
                i         := i - 1
                END;
            (*ENDWHILE*) 
            pos := 24;
            REPEAT
                i   := i + 1;
                pos := pos + 1;
                msg[pos] := cnt[i];
            UNTIL
                i = sizeof (cnt);
            (*ENDREPEAT*) 
            a_mblock.mb_qual_len  := a_mblock.mb_qual_size;
            s80uni_trans (@msg, sizeof(msg), csp_ascii,
                  @a_mblock.mb_qual^.buf, a_mblock.mb_qual_len,
                  a_out_packet^.sp1_header.sp1h_mess_code,
                  [ ], error, err_char_no);
            END
        ELSE
            b01destroy_file (a_transinf.tri_trans, a_usage_curr)
        (*ENDIF*) 
        END
    ELSE
        a_part_rollback := true;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37CheckDBProcPrivilege (
            VAR acv        : tak_all_command_glob;
            VAR DBProcPriv : tak_proc_seq_privilege;
            do_repair      : boolean);
 
VAR
      errorFound : boolean;
      ok         : boolean;
      e          : tgg00_BasisError;
      p          : tak_sysbufferaddress;
      sysk       : tgg00_SysInfoKey;
      publicId   : tgg00_Surrogate;
      error_msg  : tak37verify_msg;
 
BEGIN
errorFound      := false;
sysk.sauthid    := DBProcPriv.psp_id;
sysk.sentrytyp  := cak_emethod;
sysk.slinkage   := cak_init_linkage;
sysk.skeylen    := mxak_standard_sysk;
a10get_sysinfo (acv, sysk, d_release, p, e);
IF  e = e_sysinfo_not_found
THEN
    BEGIN
    errorFound          := true;
    error_msg.surrogate := DBProcPriv.psp_id;
    ak37put_errmsg (acv, ve_priv_method_ref, DBProcPriv.psp_id, error_msg);
    END;
(*ENDIF*) 
ok       := true;
publicId := cak_public_id;
IF  DBProcPriv.psp_grantor <> publicId
THEN
    a06userid_get (acv, DBProcPriv.psp_grantor, ok);
(*ENDIF*) 
IF  NOT ok AND (acv.a_returncode = 0)
THEN
    BEGIN
    errorFound          := true;
    error_msg.surrogate := DBProcPriv.psp_grantor;
    ak37put_errmsg (acv, ve_priv_method_user_ref, DBProcPriv.psp_grantor, error_msg);
    END;
(*ENDIF*) 
IF  do_repair AND errorFound
THEN
    BEGIN
    p := @DBProcPriv;
    a10del_sysinfo (acv, p^.syskey, e);
    IF  e <> e_ok
    THEN
        a07_b_put_error (acv, e, 1)
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37CheckPrivilege (
            VAR acv       : tak_all_command_glob;
            pPriv         : tak_sysbufferaddress;
            do_repair     : boolean);
 
VAR
      ok        : boolean;
      e         : tgg00_BasisError;
      pBase     : tak_sysbufferaddress;
      error_msg : tak37verify_msg;
      publicId  : tgg00_Surrogate;
 
BEGIN
a06_systable_get (acv, d_release, pPriv^.spriv.pr_tabid, pBase, true, ok);
IF  NOT ok AND (acv.a_returncode = 0)
THEN
    BEGIN
    error_msg.surrogate := pPriv^.spriv.pr_tabid;
    ak37put_errmsg (acv, ve_priv_table_ref, pPriv^.spriv.pr_tabid, error_msg);
    END
ELSE
    BEGIN
    publicId := cak_public_id;
    IF  pPriv^.spriv.pr_userid <> publicId
    THEN
        a06userid_get (acv, pPriv^.spriv.pr_userid, ok);
    (*ENDIF*) 
    IF  NOT ok AND (acv.a_returncode = 0)
    THEN
        BEGIN
        error_msg.surrogate := pPriv^.spriv.pr_userid;
        ak37put_errmsg (acv, ve_priv_user_ref, pPriv^.spriv.pr_tabid, error_msg);
        END;
    (*ENDIF*) 
    IF  pPriv^.spriv.pr_entrytype = cak_eprivuser
    THEN
        BEGIN
        IF  pPriv^.sprivuser.pru_grantor <> publicId
        THEN
            a06userid_get (acv, pPriv^.sprivuser.pru_grantor, ok);
        (*ENDIF*) 
        IF  NOT ok AND (acv.a_returncode = 0)
        THEN
            BEGIN
            error_msg.surrogate := pPriv^.sprivuser.pru_grantor;
            ak37put_errmsg (acv, ve_priv_user_ref, pPriv^.spriv.pr_tabid, error_msg);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  NOT ok AND do_repair
THEN
    BEGIN
    a10del_sysinfo (acv, pPriv^.syskey, e);
    IF  e <> e_ok
    THEN
        a07_b_put_error (acv, e, 1)
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37CheckMethodRef (
            VAR acv       : tak_all_command_glob;
            VAR methodRef : tak_methodrefrecord;
            do_repair     : boolean);
 
VAR
      e          : tgg00_BasisError;
      p          : tak_sysbufferaddress;
      sysk       : tgg00_SysInfoKey;
      error_msg  : tak37verify_msg;
 
BEGIN
sysk.sauthid    := methodRef.mrf_method_id;
sysk.sentrytyp  := cak_emethod;
sysk.slinkage   := cak_init_linkage;
sysk.skeylen    := mxak_standard_sysk;
a10get_sysinfo (acv, sysk, d_release, p, e);
IF  e = e_sysinfo_not_found
THEN
    BEGIN
    error_msg.surrogate := methodRef.mrf_method_id;
    ak37put_errmsg (acv, ve_method_ref, methodRef.mrf_method_id, error_msg);
    IF  do_repair
    THEN
        BEGIN
        p := @methodRef;
        a10del_sysinfo (acv, p^.syskey, e);
        IF  e <> e_ok
        THEN
            a07_b_put_error (acv, e, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END
ELSE
    IF  e <> e_ok
    THEN
        a07_b_put_error (acv, e, 1)
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37CheckUserTab (
            VAR acv       : tak_all_command_glob;
            VAR usertab   : tak_usertablerecord;
            do_repair     : boolean;
            VAR replace   : boolean);
 
VAR
      ok         : boolean;
      e          : tgg00_BasisError;
      ix         : integer;
      p          : tak_sysbufferaddress;
      sysk       : tgg00_SysInfoKey;
      error_msg  : tak37verify_msg;
      publicId   :  tgg00_Surrogate;
 
BEGIN
ok       := true;
replace  := false;
publicId := cak_public_id;
IF  (usertab.usatabsurrogate <> publicId) AND (usertab.usatabsurrogate <> a01defaultkey.stableid)
THEN
    a06userid_get (acv, usertab.usatabsurrogate, ok);
(*ENDIF*) 
IF  NOT ok
THEN
    BEGIN
    error_msg.surrogate := usertab.usatabsurrogate;
    ak37put_errmsg (acv, ve_usertab_user_ref, usertab.usatabsurrogate, error_msg);
    IF  do_repair
    THEN
        BEGIN
        p := @usertab;
        a10del_sysinfo (acv, p^.syskey, e);
        IF  e <> e_ok
        THEN
            a07_b_put_error (acv, e, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END
ELSE
    BEGIN
    FOR ix := 1 TO usertab.usertabcount DO
        WITH usertab.usertabdef[ix] DO
            IF  NOT ut_empty
            THEN
                BEGIN
                CASE ut_kind OF
                    ut_base_table, ut_internal_systable, ut_oracle_systable, ut_view :
                        BEGIN
                        a06_systable_get (acv, d_release, ut_surrogate, p, true, ok);
                        IF  NOT ok
                        THEN
                            BEGIN
                            error_msg.surrogate := ut_surrogate;
                            ak37put_errmsg (acv, ve_usertab_table_ref, usertab.usatabsurrogate, error_msg);
                            IF  do_repair
                            THEN
                                BEGIN
                                ut_empty := true;
                                replace  := true;
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    ut_procedure :
                        BEGIN
                        sysk.sauthid    := ut_surrogate;
                        sysk.sentrytyp  := cak_emethod;
                        sysk.slinkage   := cak_init_linkage;
                        sysk.skeylen    := mxak_standard_sysk;
                        a10get_sysinfo (acv, sysk, d_release, p, e);
                        IF  e <> e_ok
                        THEN
                            BEGIN
                            error_msg.surrogate := ut_surrogate;
                            ak37put_errmsg (acv, ve_usertab_dbproc_ref, usertab.usatabsurrogate, error_msg);
                            IF  do_repair
                            THEN
                                BEGIN
                                ut_empty := true;
                                replace  := true;
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    OTHERWISE ;
                    END;
                (*ENDCASE*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDFOR*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37scan (
            VAR acv       : tak_all_command_glob;
            tabid         : tgg00_Surrogate;
            do_repair     : boolean);
 
VAR
      ok          : boolean;
      b_err       : tgg00_BasisError;
      usage_index : integer;
      linkage     : tsp00_C2;
      udef        : tak_usagedef;
      error_msg   : tak37verify_msg;
      sysk        : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        usage_index := 0;
        linkage     := a01defaultkey.slinkage;
        REPEAT
            sysk           := a01defaultkey;
            sysk.stableid  := tabid;
            sysk.sentrytyp := cak_eusage;
            sysk.slinkage  := linkage;
            a10get_sysinfo (acv,
                  sysk, d_release, a_ptr1, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                usage_index := usage_index + 1;
                IF  usage_index > a_ptr1^.susage.usagecount
                THEN
                    IF  a_ptr1^.susage.usagenext_exist
                    THEN
                        BEGIN
                        a06inc_linkage (linkage);
                        usage_index := 0
                        END
                    ELSE
                        b_err := e_sysinfo_not_found
                    (*ENDIF*) 
                ELSE
                    WITH a_ptr1^.susage.usagedef[usage_index] DO
                        IF  NOT usa_empty
                        THEN
                            BEGIN
                            udef :=
                                  a_ptr1^.susage.usagedef[usage_index];
                            ak37check_table (acv,
                                  udef.usa_tableid, ok);
                            IF  NOT ok
                            THEN
                                BEGIN
                                IF  do_repair
                                THEN
                                    BEGIN
                                    a11del_usage_entry (acv, tabid,
                                          udef.usa_tableid);
                                    usage_index := usage_index - 1;
                                    END;
                                (*ENDIF*) 
                                error_msg.surrogate :=
                                      udef.usa_tableid;
                                ak37put_errmsg (acv,
                                      ve_ref, sysk.stableid,
                                      error_msg);
                                END
                            ELSE
                                ak37scan (acv, usa_tableid,
                                      do_repair)
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            (b_err <> e_ok) OR (a_returncode <> 0);
        (*ENDREPEAT*) 
        IF  b_err <> e_sysinfo_not_found
        THEN
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37put_errmsg (
            VAR acv       : tak_all_command_glob;
            error_kind    : tak37verify_errors;
            VAR tabid     : tgg00_Surrogate;
            VAR verifymsg : tak37verify_msg);
 
VAR
      b_err     : tgg00_BasisError;
      ptr       : tak_sysbufferaddress;
      i         : integer;
      pos       : integer;
      msg       : tsp00_Name;
      name1     : tsp00_KnlIdentifier;
      name2     : tsp00_KnlIdentifier;
      name3     : tsp00_KnlIdentifier;
      sysk      : tgg00_SysInfoKey;
      msg_label : tsp00_C8;
      c40       : tsp00_C40;
      c80       : tsp00_C80;
 
BEGIN
WITH acv DO
    BEGIN
    name1 := a01_il_b_identifier;
    name2 := a01_il_b_identifier;
    name3 := a01_il_b_identifier;
    IF  error_kind = ve_method_ref
    THEN
        BEGIN
        a06determine_username (acv, acv.a_p_arr1.pbasep^.smethodref.mrf_surrogate, name1);
        name2 := acv.a_p_arr1.pbasep^.smethodref.mrf_methodname;
        END
    ELSE
        IF  error_kind in [ve_usertab_user_ref, ve_usertab_table_ref, ve_usertab_dbproc_ref]
        THEN
            BEGIN
            a06determine_username (acv, tabid, name1);
            END
        ELSE
            BEGIN
            sysk          := a01defaultkey;
            sysk.stableid := tabid;
            a10get_sysinfo (acv, sysk, d_release, ptr, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                a06determine_username (acv, ptr^.sbase.bauthid, name1);
                name2 := ptr^.sbase.btablen^;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    name3 := a01_il_b_identifier;
    CASE error_kind OF
        ve_index :
            BEGIN
            msg       := 'INVALID INDEX INFO';
            msg_label := 'IND INFO';
            END;
        ve_file_missing :
            BEGIN
            msg       := 'FILE MISSING      ';
            msg_label := 'FILEMISS';
            pos := 0;
            FOR i := 1 TO sizeof (tabid) DO
                g17hexto_line (tabid[i], pos, name3)
            (*ENDFOR*) 
            END;
        ve_multi_missing :
            BEGIN
            msg       := 'MULTI IND MISSING ';
            msg_label := 'MULTMISS';
            name3     := verifymsg.name
            END;
        ve_ref, ve_priv_table_ref, ve_priv_user_ref, ve_usertab_user_ref, ve_usertab_table_ref,
        ve_usertab_dbproc_ref, ve_method_ref :
            BEGIN
            CASE error_kind OF
                ve_ref :
                    BEGIN
                    msg       := 'UNRESOLVED VIEWREF';
                    msg_label := 'VIEWREF ';
                    END;
                ve_priv_table_ref :
                    BEGIN
                    msg       := 'UNRES PRIV TABREF ';
                    msg_label := 'PTABREF ';
                    END;
                ve_priv_user_ref :
                    BEGIN
                    msg       := 'UNRES PRIV USERREF';
                    msg_label := 'PUSERREF';
                    END;
                ve_usertab_user_ref :
                    BEGIN
                    msg       := 'USERTAB USERREF   ';
                    msg_label := 'UUSERREF';
                    END;
                ve_usertab_table_ref :
                    BEGIN
                    msg       := 'USERTAB TABLEREF  ';
                    msg_label := 'UTABREF ';
                    END;
                ve_usertab_dbproc_ref :
                    BEGIN
                    msg       := 'USERTAB DBPROCREF ';
                    msg_label := 'UPROCREF';
                    END;
                ve_method_ref :
                    BEGIN
                    msg       := 'METHOD REF        ';
                    msg_label := 'MREF    ';
                    END;
                ve_priv_method_ref :
                    BEGIN
                    msg       := 'METHODPRIV PROCREF';
                    msg_label := 'MPROCREF';
                    END;
                ve_priv_method_user_ref :
                    BEGIN
                    msg       := 'METHODPRIV USERREF';
                    msg_label := 'MUSERREF';
                    END;
                END;
            (*ENDCASE*) 
            pos   := 0;
            FOR i := 1 TO sizeof (verifymsg.surrogate) DO
                g17hexto_line (verifymsg.surrogate[i], pos, name3);
            (*ENDFOR*) 
            END;
        ve_single_missing :
            BEGIN
            msg       := 'SINGLE IND MISSING';
            msg_label := 'SINGLIND';
            name3     := verifymsg.name
            END;
        ve_tableref :
            BEGIN
            msg       := 'INVALID TABLE REF ';
            msg_label := 'ITABREF ';
            pos := 0;
            FOR i := 1 TO sizeof (tabid) DO
                g17hexto_line (tabid[i], pos, name3)
            (*ENDFOR*) 
            END;
        ve_version :
            BEGIN
            msg       := 'WRONG TAB VERSION ';
            msg_label := 'TABVERS ';
            END;
        ve_single_invalid :
            BEGIN
            msg       := 'WRONG ECOL_TAB    ';
            msg_label := 'ECOL_TAB';
            name3     := verifymsg.name
            END;
        ve_longvar_cnt :
            BEGIN
            msg       := 'LONGVARCOLCOUNT   ';
            msg_label := 'LONGCOLC';
            END;
        ve_longvar_old_colno :
            BEGIN
            msg       := 'OLDLONGVARCOLNO   ';
            msg_label := 'OVARCOLN';
            IF  gg999KernelStateIsOnline
            THEN
                name3 := verifymsg.name
            ELSE
                name2 := verifymsg.name
            (*ENDIF*) 
            END;
        ve_longvar_new_colno :
            BEGIN
            msg       := 'NEWLONGVARCOLNO   ';
            msg_label := 'NVARCOLN';
            IF  gg999KernelStateIsOnline
            THEN
                name3 := verifymsg.name
            ELSE
                name2 := verifymsg.name
            (*ENDIF*) 
            END;
        ve_blob_col_count :
            BEGIN
            msg       := 'WRONG FDIR BLOBCNT';
            msg_label := 'FD BLOBC';
            pos := 0;
            FOR i := 1 TO sizeof (tabid) DO
                g17hexto_line (tabid[i], pos, name3)
            (*ENDFOR*) 
            END;
        OTHERWISE
            BEGIN
            msg       := bsp_name;
            msg_label := bsp_c8;
            END
        END;
    (*ENDCASE*) 
&   ifdef TRACE
    t01lidentifier (ak_sem, name1);
    t01lidentifier (ak_sem, name2);
    t01lidentifier (ak_sem, name3);
&   endif
    IF  gg999KernelStateIsOnline
    THEN
        a38insert_parameters (acv, a_show_data_cnt,
              msg, name1, name2, name3, a01_il_b_identifier)
    ELSE
        IF  NOT g01unicode
        THEN
            BEGIN
            c40 := bsp_c40;
            IF  error_kind in [ve_usertab_user_ref, ve_usertab_table_ref, ve_usertab_dbproc_ref]
            THEN
                SAPDB_PascalForcedMove (sizeof(name1), sizeof(c40),
                      @name1, 1, @c40, 1, a01identifier_size)
            ELSE
                SAPDB_PascalForcedMove (sizeof(name2), sizeof(c40),
                      @name2, 1, @c40, 1, a01identifier_size);
            (*ENDIF*) 
            g01optextmsg (sp3p_console, sp3m_info,
                  csp3_a361_migrate_check_catalog,
                  msg_label, c40)
            END
        ELSE
            BEGIN
            SAPDB_PascalForcedUnicodeFill (sizeof(c80),
                  @c80, 1, sizeof(c80), csp_unicode_blank);
            IF  error_kind in [ve_usertab_user_ref, ve_usertab_table_ref, ve_usertab_dbproc_ref]
            THEN
                SAPDB_PascalForcedMove (sizeof(name1), sizeof(c80),
                      @name1, 1, @c80, 1, a01identifier_size)
            ELSE
                SAPDB_PascalForcedMove (sizeof(name2), sizeof(c80),
                      @name2, 1, @c80, 1, a01identifier_size);
            (*ENDIF*) 
            g01unioptextmsg (csp_unicode,
                  sp3p_console, sp3m_info,
                  csp3_a361_migrate_check_catalog,
                  msg_label, c80);
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37check_table (
            VAR acv   : tak_all_command_glob;
            VAR tabid : tgg00_Surrogate;
            VAR ok    : boolean);
 
VAR
      b_err    : tgg00_BasisError;
      ptr      : tak_sysbufferaddress;
      tab_kind : tgg00_TableKind;
      sysk     : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
    sysk          := a01defaultkey;
    sysk.stableid := tabid;
    a10get_sysinfo (acv, sysk, d_release, ptr, b_err);
    ok := b_err <> e_sysinfo_not_found;
    IF  ok
    THEN
        IF  ptr^.sbase.btablekind in [tonebase, tview]
        THEN
            BEGIN (* check, if viewqual record does exist *)
            tab_kind       := ptr^.sbase.btablekind;
            sysk.sentrytyp := cak_eviewqual_basis;
            a10get_sysinfo (acv, sysk, d_release, ptr, b_err);
            IF  b_err = e_sysinfo_not_found
            THEN
                BEGIN
                a11drop_table (acv, tabid, tab_kind, false);
                ok := false;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37verify_base_table (
            VAR acv   : tak_all_command_glob;
            VAR tabid : tgg00_Surrogate;
            do_repair : boolean);
 
CONST
      c_scan_views = true;
 
VAR
      ok             : boolean;
      multi_error    : boolean;
      replace        : boolean;
      tab_dropped    : boolean;
      varcol_index   : boolean;
      varcolinind    : boolean;
      colstack_error : boolean;
      b_err          : tgg00_BasisError;
      i              : integer;
      j              : integer;
      dropped        : integer;
      blobColCount   : tsp00_Int4;
      aux_root       : tsp00_PageNo;
      ptr            : tak_sysbufferaddress;
      error_msg      : tak37verify_msg;
      colset         : tak_columnset;
      drop_index     : SET OF 1..MAX_COL_PER_INDEX_GG00;
      qual           : tak_del_tab_qual;
      index_tree     : tgg00_FileId;
      sysk           : tgg00_SysInfoKey;
      longvarcolcnt  : tsp00_Uint1;
 
BEGIN
WITH acv DO
    BEGIN
    (* the following inconsistencies are analyzed and repaired : *)
    (* 1. difference between bd and ak file version              *)
    (* 2. incorrect blob column count in file directory          *)
    (* 3. missing base table file (==> drop table)               *)
    (* 4. missing index files     (==> drop Index)               *)
    (* 5. invalid index information in catalog                   *)
    (* 6. Tableref referencing another table                     *)
    a06_systable_get (acv, d_fix, tabid,
          a_p_arr1.pbasep, true, ok);
    IF  ok
    THEN
        BEGIN
        tab_dropped := false;
        sysk              := a01defaultkey;
        sysk.sauthid      := a_p_arr1.pbasep^.sbase.bschema;
        sysk.sentrytyp    := cak_etableref;
        sysk.sidentifier  := a_p_arr1.pbasep^.sbase.btablen^;
        sysk.skeylen      := mxak_standard_sysk + sizeof (sysk.sidentifier);
        a10get_sysinfo (acv, sysk, d_release, ptr, b_err);
        IF  b_err <> e_ok
        THEN
            ak37put_errmsg (acv, ve_tableref, tabid, error_msg);
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            IF  ptr^.stableref.rtableid <> tabid
            THEN
                BEGIN
                ok := false;
                ak37put_errmsg (acv, ve_tableref, tabid, error_msg);
                IF  do_repair
                THEN
                    BEGIN
                    qual.del_colno := 0;
                    a10_del_tab_sysinfo  (acv, tabid, qual,
                          false, b_err);
                    IF  b_err <> e_ok
                    THEN
                        a07_b_put_error (acv, b_err, 1)
                    (*ENDIF*) 
                    END
                ELSE
                    a10rel_sysinfo (a_p_arr1.pbasep);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  ok
    THEN
        BEGIN
        replace  := false;
        IF  NOT (
            (ftsTemp_egg00       in a_p_arr1.pbasep^.sbase.btreeid.fileType_gg00) AND
            (ftsConcurrent_egg00 in a_p_arr1.pbasep^.sbase.btreeid.fileType_gg00) AND
            (ftsShared_egg00     in a_p_arr1.pbasep^.sbase.btreeid.fileType_gg00)
            )
        THEN
            BEGIN
            (* check file existence and file version *)
            b01filestate (a_transinf.tri_trans,
                  a_p_arr1.pbasep^.sbase.btreeid);
            b_err := a_transinf.tri_trans.trError_gg00;
            IF  b_err = e_ok
            THEN
                BEGIN
                b01vstate_fileversion (a_transinf.tri_trans,
                      a_p_arr1.pbasep^.sbase.btreeid);
                IF  a_transinf.tri_trans.trError_gg00 = e_old_fileversion
                THEN
                    BEGIN
                    ak37put_errmsg (acv, ve_version, tabid, error_msg);
                    IF  do_repair
                    THEN
                        BEGIN
                        replace := true;
                        END;
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (* PTS 1133311 M.Ki. *)
            (*ENDIF*) 
            bd998GetTableBlobColCount (a_transinf.tri_trans,
                  a_p_arr1.pbasep^.sbase.btreeid.fileTabId_gg00,
                  blobColCount,
                  b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                IF  blobColCount <> a_p_arr1.pbasep^.sbase.bstringcount
                THEN
                    BEGIN
                    ak37put_errmsg (acv, ve_blob_col_count, tabid, error_msg);
&                   ifdef trace
                    t01surrogate (test_ak, 'table fileNo',
                          a_p_arr1.pbasep^.sbase.btreeid.fileTabId_gg00);
                    t01int4 (test_ak, 'fdir blobCnt', blobColCount);
                    t01int4 (test_ak, 'cat  blobCnt',
                          a_p_arr1.pbasep^.sbase.bstringcount);
&                   endif
                    IF  do_repair
                    THEN
                        BEGIN
                        a10alter_long_version (acv, a_p_arr1.pbasep^.sbase,
                              blobColCount, m_succ_file_version,
                              NOT c_scan_views);
                        (* file version has been changed -> replace *)
                        replace := true;
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                a07_b_put_error (acv, b_err, 1);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        varcol_index := false;
        IF  (a_returncode = 0) AND NOT tab_dropped
        THEN
            WITH a_p_arr1.pbasep^.sbase DO
                BEGIN
                longvarcolcnt := blongvarcolcnt;
                blongvarcolcnt := 0;
                FOR i := 1 TO bmaxcol DO
                    WITH bcolumn[bextcolindex[i]+bfirstindex]^ DO
                        BEGIN
                        IF  ccolstack.etype = st_varlongchar
                        THEN
                            BEGIN
                            blongvarcolcnt := succ(blongvarcolcnt);
                            IF  blongvarcolcnt <> ccolstack.ecolno
                            THEN
                                BEGIN
                                IF  ctmulti in ccolpropset
                                THEN
                                    varcol_index := true;
                                (*ENDIF*) 
                                a061get_colname (bcolumn[bextcolindex[i]+bfirstindex]^, error_msg.name);
                                ak37put_errmsg (acv,
                                      ve_longvar_new_colno, tabid, error_msg);
                                FOR j := 1 TO i-1 DO
                                    IF  (bcolumn[bextcolindex[j]+bfirstindex]^.ccolstack.etype  = st_varlongchar) AND
                                        (bcolumn[bextcolindex[j]+bfirstindex]^.ccolstack.ecolno = ccolstack.ecolno)
                                    THEN
                                        BEGIN
                                        a061get_colname (bcolumn[bextcolindex[j]+bfirstindex]^, error_msg.name);
                                        ak37put_errmsg (acv,
                                              ve_longvar_old_colno, tabid, error_msg);
                                        END;
                                    (*ENDIF*) 
                                (*ENDFOR*) 
                                ccolstack.ecolno := blongvarcolcnt;
                                END
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDFOR*) 
                IF  longvarcolcnt <> blongvarcolcnt
                THEN
                    BEGIN
                    ak37put_errmsg (acv,
                          ve_longvar_cnt, tabid, error_msg);
                    replace := true;
                    END;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  (a_returncode = 0) AND NOT tab_dropped
        THEN
            BEGIN
            colset         := [];
            drop_index     := [];
            sysk           := a_p_arr1.pbasep^.syskey;
            sysk.sentrytyp := cak_emindex;
            a10get_sysinfo (acv, sysk, d_release, ptr, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                IF  a_p_arr1.pbasep^.sbase.bindexexist
                THEN
                    BEGIN
                    WITH ptr^.smindex DO
                        FOR i := 1 TO indexcount DO
                            WITH indexdef[i] DO
                                BEGIN
                                (* PTS 1116586 E.Z. *)
                                g04index_tree_build(
                                      a_p_arr1.pbasep^.sbase.btreeid,
                                      index_tree,
                                      indexno);
                                b01filestate(a_transinf.tri_trans,
                                      index_tree);
                                IF  a_transinf.tri_trans.trError_gg00 =
                                    e_file_not_found
                                THEN
                                    BEGIN
                                    drop_index := drop_index + [i];
                                    a24get_indexname (acv, ptr, i,
                                          error_msg.name);
                                    ak37put_errmsg (acv,
                                          ve_multi_missing, tabid, error_msg)
                                    END;
                                (*ENDIF*) 
                                varcolinind := false;
                                IF  NOT (i in drop_index)
                                THEN
                                    FOR j := 1 TO icount DO
                                        BEGIN
                                        colset := colset + [icolseq[j]];
                                        IF  varcol_index
                                        THEN
                                            WITH a_p_arr1.pbasep^.sbase DO
                                                IF  bcolumn[bextcolindex[icolseq[j]]+bfirstindex]^.ccolstack.etype =
                                                    st_varlongchar
                                                THEN
                                                    BEGIN
                                                    varcolinind := true;
                                                    icolstack[j].ecolno :=
                                                       bcolumn[bextcolindex[icolseq[j]]+bfirstindex]^.ccolstack.ecolno;
                                                    END;
                                                (*ENDIF*) 
                                            (*ENDWITH*) 
                                        (*ENDIF*) 
                                        END;
                                    (*ENDFOR*) 
                                (*ENDIF*) 
                                IF  varcolinind
                                THEN
                                    bd03SetToNotAccessible(a_transinf.tri_trans,
                                          index_tree);
                                (*ENDIF*) 
                                END;
                            (*ENDWITH*) 
                        (*ENDFOR*) 
                    (*ENDWITH*) 
                    END
                ELSE
                    BEGIN
                    a10del_sysinfo (acv, sysk, b_err)
                    END;
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  (b_err = e_sysinfo_not_found) AND
                    a_p_arr1.pbasep^.sbase.bindexexist
                THEN
                    BEGIN
                    a_p_arr1.pbasep^.sbase.bindexexist := false;
                    replace := true
                    END
                ELSE
                    IF  b_err = e_ok
                    THEN
                        a07_b_put_error (acv, b_err, 1);
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  ((drop_index <> []) OR varcol_index) AND
            do_repair                            AND
            NOT tab_dropped                      AND
            (a_returncode = 0)
        THEN
            WITH ptr^.smindex DO
                BEGIN
                (* Indexes in catalog without bd files have been *)
                (* found, remove them from catalog               *)
                replace := true;
                dropped := 0;
                FOR i := 1 TO MAX_COL_PER_INDEX_GG00 DO
                    IF  i in drop_index
                    THEN
                        BEGIN
                        indexdef[i-dropped] := indexdef[indexcount];
                        dropped             := dropped + 1;
                        indexcount          := indexcount - 1
                        END;
                    (*ENDIF*) 
                (*ENDFOR*) 
                IF  indexcount = 0
                THEN
                    BEGIN
                    a_p_arr1.pbasep^.sbase.bindexexist := false;
                    a10del_sysinfo (acv, sysk, b_err)
                    END
                ELSE
                    a10_add_repl_sysinfo (acv,
                          ptr, false, b_err);
                (*ENDIF*) 
                IF  b_err <> e_ok
                THEN
                    a07_b_put_error (acv, b_err, 1)
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        multi_error    := false;
        colstack_error := false;
        IF  (a_returncode = 0) AND NOT tab_dropped
        THEN
            WITH a_p_arr1.pbasep^.sbase DO
                BEGIN
                FOR j := bfirstindex TO blastindex DO
                    WITH a103GetColumn (a_p_arr1.pbasep^.sbase, j)^ DO
                        BEGIN
                        IF  (btablekind in [twithkey, twithoutkey])
                        THEN
                            BEGIN
                            IF  ccolstack.eop in [op_unique, op_unique_desc,
                                op_order_desc, op_order_asc]
                            THEN
                                BEGIN
&                               ifdef trace
                                t01int4 (test_ak, 'op_order fou', ord(ccolstack.eop));
                                t01lidentifier (test_ak, btablen^);
                                t01lidentifier (test_ak, ccolumnn);
&                               endif
                                ccolstack.eop := op_none;
                                IF  ctunused in ccolpropset
                                THEN
                                    ccolpropset := ccolpropset - [ ctunused ];
                                (*ENDIF*) 
                                colstack_error := true;
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  (ctmulti in ccolpropset) AND
                            NOT (cextcolno in colset)
                        THEN
                            BEGIN
                            ccolpropset := ccolpropset - [ctmulti];
                            multi_error := true
                            END
                        ELSE
                            IF  (cextcolno in colset) AND
                                NOT (ctmulti in ccolpropset)
                            THEN
                                BEGIN
                                ccolpropset :=
                                      ccolpropset + [ctmulti];
                                multi_error := true
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDFOR*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  colstack_error
        THEN
            BEGIN
            ak37put_errmsg (acv, ve_colstack, tabid, error_msg);
            replace := true
            END;
        (*ENDIF*) 
        IF  multi_error
        THEN
            BEGIN
            ak37put_errmsg (acv, ve_index, tabid, error_msg);
            replace := true
            END;
        (*ENDIF*) 
        IF  do_repair AND replace AND (a_returncode = 0)
        THEN
            BEGIN
&           ifdef trace
            t01int4 (test_ak, 'do repl     ', 12345);
&           endif
            a10_add_repl_sysinfo (acv, a_p_arr1.pbasep, false, b_err);
            IF  b_err <> e_ok
            THEN
                a07_b_put_error (acv, b_err, 1);
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                ak37recreate_views (acv)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  NOT tab_dropped
        THEN
            a10rel_sysinfo (a_p_arr1.pbasep);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37recreate_views (VAR acv : tak_all_command_glob);
 
VAR
      aux_root    : tsp00_PageNo;
      viewscanpar : tak_save_viewscan_par;
 
BEGIN
WITH acv, viewscanpar DO
    BEGIN
    a27init_viewscanpar (acv, viewscanpar, v_intern_save_scheme);
    a_internal_sql             := sql_alter_table;
    vsc_save_into              := false;
    vsc_cmd_cnt                := 0;
    vsc_first_save             := true;
    vsc_last_save              := true;
    vsc_base_tabid             := a_p_arr1.pbasep^.syskey.stableid;
    aux_root                   := a_usage_curr.fileRoot_gg00;
    a_usage_curr.fileRoot_gg00 := NIL_PAGE_NO_GG00;
    a15catalog_save    (acv, viewscanpar);
    a15restore_catalog (acv,
          a_p_arr1.pbasep^.sbase.btreeid, viewscanpar);
    a_usage_curr.fileRoot_gg00 := aux_root;
    a_internal_sql             := no_internal_sql
    END;
(*ENDWITH*) 
END;
 
(* PTS 1134856 FF *)
(*------------------------------*) 
 
PROCEDURE
      ak37recreate_index (VAR acv : tak_all_command_glob);
 
VAR
      moveobj_ptr : tsp00_MoveObjPtr;
      fileno      : tsp00_C16;
 
BEGIN
WITH acv DO
    BEGIN
    moveobj_ptr := @fileno;
    a05string_literal_get (acv, a_ap_tree^[a_ap_tree^[0].n_lo_level].n_sa_level,
          dcha, moveobj_ptr^, 1, sizeof(fileno));
    IF  a_return_segm^.sp1r_returncode = 0
    THEN
        BEGIN
        bd91RecreateIndex(a_transinf.tri_trans, fileno);
        END;
    (*ENDIF*) 
    IF  a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1)
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(* PTS 1134856 FF *)
(*------------------------------*) 
 
PROCEDURE
      ak37check_index (VAR acv : tak_all_command_glob);
 
VAR
      moveobj_ptr : tsp00_MoveObjPtr;
      fileno      : tsp00_C16;
 
BEGIN
WITH acv DO
    BEGIN
    moveobj_ptr := @fileno;
    a05string_literal_get (acv, a_ap_tree^[a_ap_tree^[0].n_lo_level].n_sa_level,
          dcha, moveobj_ptr^, 1, sizeof(fileno));
    IF  a_return_segm^.sp1r_returncode = 0
    THEN
        BEGIN
        bd91CheckIndex(a_transinf.tri_trans, fileno);
        END;
    (*ENDIF*) 
    IF  a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1)
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a37hex2char (
            VAR acv : tak_all_command_glob;
            hexpos : integer) : char;
 
VAR
      hexhi, hexlo : char;
      inthi, intlo : integer;
 
BEGIN
hexhi := acv.a_cmd_part^.sp1p_buf[ hexpos + a01char_size - 1];
hexlo := acv.a_cmd_part^.sp1p_buf[ hexpos + a01char_size + a01char_size - 1];
IF  (hexhi in [ 'a'..'f' ])
THEN
    hexhi := chr(ord('A') + ord(hexhi) - ord('a'));
(*ENDIF*) 
IF  (hexlo in [ 'a'..'f' ])
THEN
    hexlo := chr(ord('A') + ord(hexlo) - ord('a'));
(*ENDIF*) 
IF  (hexhi in [ '0'..'9', 'A'..'F' ]) AND
    (hexlo in [ '0'..'9', 'A'..'F' ])
THEN
    BEGIN
    IF  (hexhi in [ '0'..'9' ])
    THEN
        inthi := ord(hexhi) - ord('0')
    ELSE
        inthi := 10 + ord(hexhi) - ord('A');
    (*ENDIF*) 
    IF  (hexlo in [ '0'..'9' ])
    THEN
        intlo := ord(hexlo) - ord('0')
    ELSE
        intlo := 10 + ord(hexlo) - ord('A');
    (*ENDIF*) 
    a37hex2char := chr(inthi * 16 + intlo);
    END
ELSE
    BEGIN
    a07_b_put_error (acv, e_invalid_number_variable, hexpos);
    a37hex2char := ' ';
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37mapset (
            VAR acv        : tak_all_command_glob;
            VAR setname    : tsp00_KnlIdentifier;
            VAR tree_index : tsp00_Int2;
            indicator      : integer);
 
VAR
      b_err       : tgg00_BasisError;
      i           : integer;
      j           : integer;
      hexpos      : integer;
      var_index   : tsp00_Int2;
      sysk        : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
    sysk             := a01defaultkey;
    sysk.sentrytyp   := cak_emapset;
    sysk.slinkage    := cak_init_linkage;
    sysk.sidentifier := setname;
    sysk.skeylen     :=
          sizeof (sysk.stableid) + sizeof (sysk.sentrytyp) +
          sizeof (sysk.slinkage) + sizeof (sysk.sidentifier);
    a10_fix_len_get_sysinfo (acv, sysk, d_release,
          mxak_mapset_rec, 0, a_ptr1, b_err);
    IF  a_returncode = 0
    THEN
        IF  b_err = e_ok
        THEN
            BEGIN
            IF  indicator = cak_x_create_mapset
            THEN
                a07_b_put_error (acv, e_duplicate_name, 1)
            (*ENDIF*) 
            END
        ELSE
            IF  indicator = cak_x_alter_mapset
            THEN
                a07_b_put_error (acv, e_unknown_mapset, 1);
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        WITH  a_ptr1^, smapset DO
            BEGIN
            (* PTS 1120720 E.Z. *)
            map_count := 0;
            CASE a_ap_tree^[tree_index].n_symb OF
                s_ascii :
                    map_code := csp_ascii;
                (* PTS 1122828 E.Z. *)
                s_unicode :
                    map_code := csp_unicode;
                OTHERWISE :
                    map_code := csp_ascii;
                END;
            (*ENDCASE*) 
            i := 1;
            WHILE  (a_ap_tree^[ tree_index ].n_sa_level <> 0) AND
                  (a_returncode = 0) DO
                BEGIN
                tree_index    := a_ap_tree^[ tree_index ].n_sa_level;
                hexpos        := a_ap_tree^[ tree_index ].n_pos;
                map_set [ i ] := a37hex2char(acv, hexpos);
                IF  map_code = csp_unicode
                THEN
                    BEGIN
                    map_set [ i+1 ] := a37hex2char(acv, hexpos + 2 * a01char_size);
                    FOR j := 1 TO map_count DO
                        IF  (map_set[ i   ] = map_set[ j * 6 - 5 ]) AND
                            (map_set[ i+1 ] = map_set[ j * 6 - 4 ])
                        THEN
                            a07_b_put_error (acv, e_duplicate_value,
                                  a_ap_tree^[ tree_index ].n_pos);
                        (*ENDIF*) 
                    (*ENDFOR*) 
                    END
                ELSE
                    FOR j := 1 TO map_count DO
                        IF  map_set[ i ] = map_set[ j * 3 - 2 ]
                        THEN
                            a07_b_put_error (acv, e_duplicate_value,
                                  a_ap_tree^[ tree_index ].n_pos);
                        (*ENDIF*) 
                    (*ENDFOR*) 
                (*ENDIF*) 
                map_count := succ(map_count);
                var_index := a_ap_tree^[ tree_index ].n_lo_level;
                WITH a_ap_tree^[ var_index ] DO
                    BEGIN
                    IF  n_symb = s_byte_string
                    THEN
                        BEGIN
                        IF  map_code = csp_unicode
                        THEN
                            BEGIN
                            map_set [ i + 2 ] := a37hex2char(acv, n_pos);
                            map_set [ i + 3 ] := a37hex2char(acv, n_pos + 2 * a01char_size);
                            IF  n_length = 4
                            THEN
                                BEGIN
                                map_set [ i + 4 ] := csp_unicode_mark;
                                map_set [ i + 5 ] := csp_ascii_blank
                                END
                            ELSE
                                BEGIN
                                map_set [ i + 4 ] := a37hex2char(acv, n_pos + 4 * a01char_size);
                                map_set [ i + 5 ] := a37hex2char(acv, n_pos + 6 * a01char_size);
                                END;
                            (*ENDIF*) 
                            i := i + 6;
                            END
                        ELSE
                            BEGIN
                            map_set [ i + 1 ] := a37hex2char(acv, n_pos);
                            IF  n_length = 4
                            THEN
                                map_set [ i + 2 ] :=
                                      a37hex2char(acv, n_pos + 2 * a01char_size)
                            ELSE
                                map_set [ i + 2 ] := csp_ascii_blank;
                            (*ENDIF*) 
                            i := i + 3;
                            END
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        IF  map_code = csp_unicode
                        THEN
                            BEGIN
                            a05_str_literal_get (acv, var_index, dunicode,
                                  map_set, i+2, 4);
                            i := i + 6
                            END
                        ELSE
                            BEGIN
                            a05_str_literal_get (acv, var_index, dcha,
                                  map_set, i+1, 2);
                            (* PTS 1122828 E.Z. *)
                            i := i + 3;
                            END
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END
                (*ENDWITH*) 
                END;
            (*ENDWHILE*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                map_segmentid := cak00_public_segment_id;
                IF  map_code = csp_unicode
                THEN
                    a_ptr1^.b_sl  := sizeof (smapset) - sizeof (map_set) +
                          map_count * 6
                ELSE
                    a_ptr1^.b_sl  := sizeof (smapset) - sizeof (map_set) +
                          map_count * 3;
                (*ENDIF*) 
                a10_add_repl_sysinfo (acv, a_ptr1,
                      indicator = cak_x_create_mapset, b_err);
                IF  b_err <> e_ok
                THEN
                    a07_b_put_error (acv, b_err, 1);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37alter_create_set (
            VAR acv   : tak_all_command_glob;
            indicator : integer);
 
VAR
      tree_index   : tsp00_Int2;
      setname      : tsp00_KnlIdentifier;
 
BEGIN
WITH acv DO
    BEGIN
    IF  a_returncode  = 0
    THEN
        BEGIN
        (*== get setname ======================================*)
        tree_index := acv.a_ap_tree^[ acv.a_ap_tree^ [ 0 ].n_lo_level ].n_lo_level;
        a05identifier_get (acv, tree_index, sizeof (setname), setname);
        (*== get basic code (ASCII/UNICODE) ============*)
        tree_index := a_ap_tree^[tree_index].n_lo_level;
        ak37mapset (acv, setname, tree_index, indicator);
        END;
    (*ENDIF*) 
    IF  a_returncode <> 0
    THEN
        a_part_rollback := true;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37drop_set (
            VAR acv   : tak_all_command_glob);
 
VAR
      b_err      : tgg00_BasisError;
      sysk       : tgg00_SysInfoKey;
      setname    : tsp00_KnlIdentifier;
 
BEGIN
WITH acv DO
    IF  a_returncode  = 0
    THEN
        BEGIN
        (*== get set name ======================================*)
        a05identifier_get (acv, 2, sizeof (setname), setname);
        (*== delete from catalog ==============================*)
        sysk             := a01defaultkey;
        sysk.sentrytyp := cak_emapset;
        sysk.slinkage    := cak_init_linkage;
        sysk.sidentifier := setname;
        sysk.skeylen     :=
              sizeof (sysk.stableid) + sizeof (sysk.sentrytyp) +
              sizeof (sysk.slinkage) + sizeof (sysk.sidentifier);
        a10del_sysinfo (acv, sysk, b_err);
        IF  b_err <> e_ok
        THEN
            IF  b_err = e_sysinfo_not_found
            THEN
                a07_b_put_error (acv, e_unknown_mapset, 1)
            ELSE
                a07_b_put_error (acv, b_err, 1);
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37char2hex (
            input      : char;
            VAR output : tsp00_C2);
 
VAR
      i        : integer;
      dec      : integer;
      hex_byte : ARRAY [ 1..2 ] OF integer;
 
BEGIN
dec           := ord (input);
hex_byte[ 1 ] := dec DIV 16;
hex_byte[ 2 ] := dec MOD 16;
FOR i := 1 TO 2 DO
    IF  hex_byte[ i ] > 9
    THEN
        output [ i ] := chr(ord('A') - 10 + hex_byte[ i ])
    ELSE
        output [ i ] := chr(ord('0') + hex_byte[ i ]);
    (*ENDIF*) 
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37get_set (
            VAR acv   : tak_all_command_glob);
 
VAR
      i           : integer;
      j           : integer;
      b_err       : tgg00_BasisError;
      hex         : tsp00_C2;
      basic_code  : tsp00_C18;
      setname     : tsp00_KnlIdentifier;
      sysk        : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    IF  a_returncode  = 0
    THEN
        BEGIN
        sysk             := a01defaultkey;
        sysk.sentrytyp := cak_emapset;
        (*== get set name ======================================*)
        a05identifier_get (acv, 2, sizeof (setname), setname);
        (*== get record from catalog ==========================*)
        sysk.slinkage    := cak_init_linkage;
        sysk.sidentifier := setname;
        sysk.skeylen     :=
              sizeof (sysk.stableid) + sizeof (sysk.sentrytyp) +
              sizeof (sysk.slinkage) + sizeof (sysk.sidentifier);
        a10get_sysinfo (acv, sysk, d_release, a_ptr1, b_err);
        IF  b_err <> e_ok
        THEN
            IF  b_err = e_sysinfo_not_found
            THEN
                a07_b_put_error (acv, e_unknown_mapset, 1)
            ELSE
                a07_b_put_error (acv, b_err, 1)
            (*ENDIF*) 
        ELSE (* set_rec found *)
            BEGIN
            (* map set *)
            WITH a_ptr1^, smapset DO
                BEGIN
                IF  map_code = csp_ascii
                THEN
                    basic_code := 'ASCII             '
                ELSE
                    a07ak_system_error (acv, 37, 2);
                (*ENDIF*) 
                (*== put basic code  ==================*)
                a06char_retpart_move (acv,
                      @basic_code, sizeof (basic_code));
                (*== put values ======================*)
                j         := 1;
                FOR i := 1 TO cgg04_mapset_entries DO
                    IF  i <= map_count
                    THEN
                        BEGIN
                        (*== internal hex value ===============*)
                        a37char2hex (map_set[ j ], hex);
                        a06char_retpart_move (acv, @hex[1], 2);
                        (*== external character ===============*)
                        a06char_retpart_move (acv,
                              @map_set [ j+1 ], 1);
                        a06char_retpart_move (acv,
                              @map_set [ j+2 ], 1);
                        (*== external hex values ==============*)
                        a37char2hex (map_set [ j+1 ], hex);
                        a06char_retpart_move (acv, @hex[1], 2);
                        a37char2hex (map_set [ j+2 ], hex);
                        a06char_retpart_move (acv, @hex[1], 2);
                        j := j + 3
                        END
                    ELSE
                        BEGIN
                        a06char_retpart_move (acv,
                              @a01_il_b_identifier, 8)
                        END;
                    (*ENDIF*) 
                (*ENDFOR*) 
                END;
            (*ENDWITH*) 
            a06finish_curr_retpart (acv, sp1pk_data, 1);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(* PTS 1111229 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak37prepare_standby (VAR acv : tak_all_command_glob);
 
VAR
      moveobj_ptr : tsp00_MoveObjPtr;
      new_standby : tsp00_NodeId;
 
BEGIN
WITH acv DO
    BEGIN
    IF  a_returncode  = 0
    THEN
        BEGIN
        moveobj_ptr := @new_standby;
        a05string_literal_get (acv,
              a_ap_tree^[a_ap_tree^[0].n_lo_level].n_sa_level, dcha,
              moveobj_ptr^, 1, sizeof(new_standby));
        END;
    (*ENDIF*) 
    IF  a_returncode  = 0
    THEN
        BEGIN
        gg999PrepareStandby(a_transinf.tri_trans, new_standby);
        IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(* NEW with PTS 1129960 MB *)
(*------------------------------*) 
 
PROCEDURE
      ak37write_backuphistory (VAR acv : tak_all_command_glob);
 
VAR
      moveobj_ptr  : tsp00_MoveObjPtr;
      new_entry    : tsp00_Buf;
      localError   : tsp00_VfReturn;
      localErrText : tsp00_ErrText;
      node         : Integer;
 
BEGIN
WITH acv DO
    BEGIN
    IF  a_returncode  = 0
    THEN
        BEGIN
        moveobj_ptr := @new_entry;
        a05string_literal_get (acv,
              a_ap_tree^[a_ap_tree^[0].n_lo_level].n_sa_level, dcha,
              moveobj_ptr^, 1, sizeof(new_entry));
        END;
    (*ENDIF*) 
    IF  a_returncode  = 0
    THEN
        BEGIN
        node := acv.a_ap_tree^[ acv.a_ap_tree^[0].n_lo_level ].n_sa_level;
        vbackup_info(new_entry,
              acv.a_ap_tree^[ node ].n_length,
              localError,
              localErrText);
        IF  localError <> vf_ok
        THEN
            a07_b_put_error (acv, e_hostfile_error, 1);
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(* NEW with PTS 1129960 MB *)
(*------------------------------*) 
 
PROCEDURE
      ak37write_backupmedium (VAR acv : tak_all_command_glob);
 
VAR
      moveobj_ptr  : tsp00_MoveObjPtr;
      new_entry    : tsp00_Buf;
      localError   : tsp00_VfReturn;
      localErrText : tsp00_ErrText;
      node         : Integer;
 
BEGIN
WITH acv DO
    BEGIN
    IF  a_returncode  = 0
    THEN
        BEGIN
        moveobj_ptr := @new_entry;
        a05string_literal_get (acv,
              a_ap_tree^[a_ap_tree^[0].n_lo_level].n_sa_level, dcha,
              moveobj_ptr^, 1, sizeof(new_entry));
        END;
    (*ENDIF*) 
    IF  a_returncode  = 0
    THEN
        BEGIN
        node := acv.a_ap_tree^[ acv.a_ap_tree^[0].n_lo_level ].n_sa_level;
        vbackup_medium_def (new_entry,
              acv.a_ap_tree^[ node ].n_length,
              localError,
              localErrText);
        IF  localError <> vf_ok
        THEN
            a07_b_put_error (acv, e_hostfile_error, 1);
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37register_standby (VAR acv : tak_all_command_glob);
 
VAR
      moveobj_ptr : tsp00_MoveObjPtr;
      new_standby : tsp00_NodeId;
      curr_n      : tsp00_Int2;
 
      logpos : RECORD
            CASE boolean OF
                true :
                    (c4 : tsp00_C4);
                false :
                    (i4 : tsp00_Int4);
                END;
            (*ENDCASE*) 
 
      i           : integer;
      shortinfo   : tak_shortinforecord;
      pos         : tsp00_Int4;
      name        : tsp00_C18;
      c           : tsp00_C1;
      asciihexbyte: tsp00_C2;
 
BEGIN
WITH acv DO
    BEGIN
    IF  a_returncode  = 0
    THEN
        BEGIN
        moveobj_ptr := @new_standby;
        curr_n := a_ap_tree^[a_ap_tree^[0].n_lo_level].n_sa_level;
        a05string_literal_get (acv,
              curr_n, dcha, moveobj_ptr^, 1, sizeof(new_standby));
        END;
    (*ENDIF*) 
    IF  a_returncode  = 0
    THEN
        BEGIN
        curr_n := a_ap_tree^[curr_n].n_sa_level;
        WITH a_ap_tree^[curr_n] DO
            BEGIN
            (* n_symb = s_byte_string *)
            IF  n_length <> 8 * a01char_size
            THEN
                a07_b_put_error (acv, e_missing_string_literal, n_pos)
            ELSE
                BEGIN
                IF  g01unicode
                THEN
                    FOR i := 1 TO sizeof(logpos.c4) DO
                        IF  acv.a_cmd_part^.sp1p_buf[ n_pos + (i - 1) * 2 * a01char_size ] <> csp_unicode_mark
                        THEN
                            a07_b_put_error (acv, e_missing_string_literal, n_pos);
                        (*ENDIF*) 
                    (*ENDFOR*) 
                (*ENDIF*) 
                FOR i := 1 TO 4 DO
                    logpos.c4[i] := a37hex2char(acv, n_pos + (i - 1) * 2 * a01char_size);
                (*ENDFOR*) 
                END
            (*ENDIF*) 
            END
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        a_transinf.tri_trans.trError_gg00 := e_ok;
        gg999RegisterStandby(a_transinf.tri_trans, new_standby, logpos.i4, logpos.i4);
        IF  a_transinf.tri_trans.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        pos := 1;
        name := 'LOGPOS            ';
        (* PTS 1113268 E.Z. *)
        a06colname_retpart_move (acv, @name, 6, csp_ascii);
        WITH shortinfo.siinfo[1] DO
            BEGIN
            sp1i_mode       := [ sp1ot_mandatory ];
            sp1i_io_type    := sp1io_output;
            sp1i_data_type  := dcha;
            sp1i_frac       := 0;
            sp1i_length     := 8;
            sp1i_in_out_len := succ(sp1i_length);
            sp1i_bufpos     := pos;
            pos             := pos + sp1i_in_out_len
            END;
        (*ENDWITH*) 
        a06finish_curr_retpart (acv, sp1pk_columnnames, 1);
        shortinfo.sicount := 1;
        a06retpart_move (acv, @shortinfo.siinfo,
              shortinfo.sicount * sizeof (shortinfo.siinfo[1]));
        a06finish_curr_retpart (acv, sp1pk_shortinfo, shortinfo.sicount);
        c[1] := csp_defined_byte;
        a06retpart_move (acv, @c[1], 1);
        FOR i := 1 TO sizeof(logpos.c4) DO
            BEGIN
            a37char2hex(logpos.c4[i], asciihexbyte);
            a06char_retpart_move (acv, @asciihexbyte[1], 2);
            END;
        (*ENDFOR*) 
        a06finish_curr_retpart (acv, sp1pk_data, 1)
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37_call_semantic (
            VAR acv               : tak_all_command_glob;
            VAR util_cmd_id       : tgg00_UtilCmdId);
 
VAR
      commit          : boolean;
      diag_kind       : tgg00_DiagType;
      i               : integer;
      pC12            : ^tsp00_C12;
      c40             : tsp00_C40;
      a30v            : tak_a30_utility_glob;
 
BEGIN
WITH acv, a_mblock, a30v, a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ]  DO
    IF  a_returncode  = 0
    THEN
        BEGIN
        commit              := NOT (n_proc in [a36, a37]) OR
              (n_subproc in
              [cak_x_alter_mapset,
              cak_x_create_mapset,
              cak_x_drop_mapset]);
        a3ti                := 1;
        IF  (a_is_ddl <> no_ddl) AND (a_is_ddl <> ddl_create_table)
            (* see vak35: ddl_create_table is a ddl_kind that requires no trigger call *)
        THEN (* create file for show data for domain *)
            a38create_parameter_file (acv);
        (*ENDIF*) 
        CASE n_subproc OF
            cak_x_alter_mapset,    cak_x_create_mapset,
            cak_x_drop_mapset,     cak_x_get_mapset,
            cak_x_add_devspace,          (* PTS 1115982 E.Z. *)
            cak_x_init_after_load,
            (* PTS 1111229 E.Z. *)
            cak_x_prepare_standby,
            cak_x_write_backuphistory,   (* PTS 1129960 mb *)
            cak_x_write_backupmedium,    (* PTS 1129960 mb *)
            cak_x_register_standby,
            (* PTS 1120104 E.Z. *)
            cak_x_auto_overwrite_on,
            cak_x_auto_overwrite_off,
            (* PTS 1119691 E.Z. *)
            cak_x_delete_block, cak_x_get_block, cak_x_set_block,
            cak_x_drop_data_volume :
                IF  (a_current_user_kind <> usysdba)
                    AND
                    (a_current_user_kind <> ucontroluser)
                THEN
                    a07_b_put_error (acv, e_missing_privilege, 1);
                (* PTS 1111289 E.Z. *)
                (*ENDIF*) 
            cak_x_reset_all, cak_x_reset :
                IF  (a_current_user_kind <> udba) AND
                    (a_current_user_kind <> usysdba) AND
                    (a_current_user_kind <> ucontroluser)
                THEN
                    a07_b_put_error (acv, e_missing_privilege, 1);
                (*ENDIF*) 
            cak_x_shutdown,
            cak_x_on_diag_parse,   cak_x_off_diag_parse,
            cak_x_autosave,        cak_x_force_checkpoint :
                IF  ((a_current_user_kind = unoprivate) OR
                    (a_current_user_kind  = uprivate))
                    AND
                    (a_current_user_kind <> ucontroluser)
                THEN
                    a07_b_put_error (acv, e_missing_privilege, 1);
                (*ENDIF*) 
            cak_x_save_log_cold, cak_x_save_log,
            cak_x_save_database, cak_x_save_pages,
            (* PTS 1115978 E.Z. *)
            cak_x_vtrace_on, cak_x_vtrace_off, cak_x_diag_dump,
            cak_x_verify :
                IF  (a_current_user_kind = unoprivate) OR
                    (a_current_user_kind = uprivate)
                THEN
                    a07_b_put_error (acv, e_missing_privilege, 1);
                (*ENDIF*) 
            OTHERWISE
            END;
        (*ENDCASE*) 
        a_part_rollback := false;
        IF  (a_returncode = 0) AND
            (n_proc in [ a36, a37 ])
        THEN
            CASE n_subproc OF
                cak_x_add_devspace :
                    ak37add_devspace (acv, n_length = cak_i_log);
                cak_x_autosave :
                    ak37autosave (acv);
                cak_x_alter_mapset :
                    ak37alter_create_set (acv, cak_x_alter_mapset);
                cak_x_create_mapset :
                    ak37alter_create_set (acv, cak_x_create_mapset);
                (* PTS 1119691 E.Z. *)
                cak_x_delete_block :
                    ak37delete_block (acv);
                cak_x_drop_mapset :
                    ak37drop_set (acv);
                (* PTS 1119691 E.Z. *)
                cak_x_get_block :
                    ak37get_block (acv);
                cak_x_get_mapset :
                    ak37get_set (acv);
                cak_x_init_after_load :
                    a36after_systable_load(acv);
                cak_x_save_log, cak_x_save_log_cold,
                cak_x_save_database, cak_x_save_pages :
                    BEGIN
&                   ifdef trace
                    t01int4 (ak_sem, 'n_length    ', n_length);
&                   endif
                    IF  (n_length = cak_i_ignore) OR
                        (n_length = cak_i_cancel) OR
                        (n_length = cak_i_replace)
                    THEN
                        ak37user_save_reaction (acv, a30v, n_length)
                    ELSE
                        ak37save (acv, a30v, util_cmd_id);
                    (*ENDIF*) 
                    a37resultevent (sp31ei_backupresult, acv.a_returncode);
                    END;
                cak_x_connect :
                    BEGIN
                    a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ] := a_ap_tree^[ 2 ];
                    a51_connect (acv);
                    a_sqlmode := sqlm_internal
                    END;
                cak_x_util_commit :
                    BEGIN
                    a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ] := a_ap_tree^[ 2 ];
                    a52_call_semantik (acv, 1);
                    END;
                (* PTS 1115982 E.Z. *)
                (* PTS 1111289 E.Z. *)
                cak_x_shutdown :
                    BEGIN
                    ak37send_messbuffer (acv, m_commit, mm_nil);
                    a37insert_event (sp31ei_admin);
                    IF  k05MaxStackUsage > 0
                    THEN
                        BEGIN
                        c40  := 'max KB stack used :           bytes     ';
                        pC12 := @c40[21];
                        g17int4to_line (k05MaxStackUsage, false, 10, 0, pC12^);
                        g01optextmsg (sp3p_console, sp3m_info,
                              kbMsg_csp03, 'STACK   ', c40)
                        END;
                    (*ENDIF*) 
                    gg999Shutdown (a_transinf.tri_trans);
                    IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
                    THEN
                        a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
                    (*ENDIF*) 
                    IF  a_returncode = 0 (* PTS 1106544 *)
                    THEN
                        BEGIN
                        ak341Shutdown;
                        a_transinf.tri_trans.trBdTcachePtr_gg00 := NIL
                        END;
                    (*ENDIF*) 
                    END;
                cak_x_read_label :
                    ak37read_label (acv, a30v);
                (* PTS 1119691 E.Z. *)
                cak_x_set_block :
                    ak37set_block (acv);
                cak_x_set_nolog_off :
                    ak37send_messbuffer (acv, m_set, mm_end_read_only);
                (* PTS 1120104 E.Z. *)
                (* PTS 1111229 E.Z. *)
                cak_x_prepare_standby :
                    ak37prepare_standby (acv);
                cak_x_register_standby :
                    ak37register_standby (acv);
                (* PTS 1129960 mb *)
                cak_x_write_backuphistory:
                    ak37write_backuphistory (acv);
                (* PTS 1129960 mb *)
                cak_x_write_backupmedium:
                    ak37write_backupmedium (acv);
                (* PTS 1115978 E.Z. *)
                cak_x_vtrace_on, cak_x_vtrace_off :
                    a37vtrace (acv);
                cak_x_diag_index :
                    ak37diagnose_index (acv);
                cak_x_diag_dump :
                    ak37dump (acv);
                cak_x_on_diag_parse :
                    BEGIN
                    a01diag_moni_parseid := true;
                    a37ddl (acv, create_sys_parsid);
                    END;
                cak_x_off_diag_parse :
                    BEGIN
                    IF  NOT a01diag_monitor_on
                    THEN
                        g01diag_moni_parse_on := false;
                    (*ENDIF*) 
                    a01diag_moni_parseid := false
                    END;
                cak_x_monitor :
                    ak37diag_monitor (acv);
                cak_x_diagnose_analyze :
                    a544semantik_diag_analyze (acv);
                cak_x_diagnose :
                    BEGIN
                    diag_kind := diagNil_egg00;
                    FOR i := 1 TO a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_length DO
                        diag_kind := succ(diag_kind);
                    (*ENDFOR*) 
                    CASE diag_kind OF
                        diagPermPages_egg00, diagStaticPages_egg00,
                        diagRestart_egg00, diagLoginfoPage_egg00:
                            ak37get_data_page (acv, diag_kind);
                        diagColRoot_egg00, diagInvRoot_egg00, diagFile_egg00,
                        diagFDir1_egg00, diagFDir2_egg00:
                            ak37extract_files (acv, diag_kind);
                        OTHERWISE
                            a07_b_put_error (acv, e_invalid_command, 1);
                        END;
                    (*ENDCASE*) 
                    END;
                cak_x_timeout_on :
                    a_use_timeout := true;
                cak_x_timeout_off :
                    a_use_timeout := false;
                (* PTS 1115978 E.Z. *)
                cak_x_verify :
                    ak37verify (acv);
                cak_x_set_parameter :
                    ak37set_parameter (acv);
                (* PTS 1108247 E.Z. *)
                cak_x_delete_log_from_to :
                    ak37delete_log_from_to (acv);
&               ifdef TRACE
                cak_x_switch :
                    ak37switch_semantic (acv);
&               endif
                (* PTS 1120104 E.Z. *)
                cak_x_auto_overwrite_on,
                cak_x_auto_overwrite_off :
                    gg999SetLogAutoOverwrite (acv.a_transinf.tri_trans.trTaskId_gg00,
                          (n_subproc = cak_x_auto_overwrite_on));
                cak_x_suspend :
                    ak37suspend_semantic (acv);
                cak_x_resume :
                    gg999ResumeLogWriter (acv.a_transinf.tri_trans.trTaskId_gg00);
                (* PTS 1134856 FF *)
                cak_x_recreate_index:
                    ak37recreate_index(acv);
                (* PTS 1134856 FF *)
                cak_x_check_index:
                    ak37check_index(acv);
                cak_x_reset_all :
                    a41reset_all (acv);
                cak_x_reset :
                    a41reset (acv);
                cak_x_drop_data_volume :
                    ak37drop_volume (acv);
                OTHERWISE
                    a07_b_put_error (acv, e_invalid_command, 1);
                END
            (*ENDCASE*) 
        ELSE
            BEGIN
            IF  (n_proc = a21) AND (a_current_user_kind = usuperdba)
            THEN (* alter password of system user *)
                a21_call_semantic (acv)
            ELSE
                a07_b_put_error (acv, e_invalid_command, 1)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  a_is_ddl <> no_ddl
        THEN
            BEGIN
            a_is_ddl := no_ddl
            END;
        (*ENDIF*) 
        IF  commit AND (a_returncode = 0)
        THEN
            a52_ex_commit_rollback (acv, m_commit, false, false);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37utilprot_needed (
            VAR acv           : tak_all_command_glob;
            VAR prot_needed   : boolean;
            VAR with_tapeinfo : boolean);
 
BEGIN
WITH acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ] DO
    BEGIN
    prot_needed := ((n_proc in [ a36, a37 ]) AND (n_subproc in [
          cak_x_add_devspace,
          cak_x_force_checkpoint,
          cak_x_save_log,
          cak_x_save_log_cold,
          cak_x_save_database,
          cak_x_save_pages,
          (* PTS 1115982 E.Z. *)
          cak_x_shutdown,           (* PTS 1111289 E.Z. *)
          cak_x_delete_log_from_to, (* PTS 1108247 E.Z. *)
          cak_x_prepare_standby,    (* PTS 1111229 E.Z. *)
          cak_x_verify,
          cak_x_auto_overwrite_on,  (* PTS 1120104 E.Z. *)
          cak_x_auto_overwrite_off, (* PTS 1120104 E.Z. *)
          cak_x_drop_data_volume
          ]))
          OR
          ((n_proc    = a37) AND
          ( n_subproc = cak_x_autosave) AND
          ( n_length <> cak_i_show));
    with_tapeinfo := prot_needed AND (n_subproc in [
          (* PTS 1000360 UH *)
          (* PTS 1000360 UH *)
          (* PTS 1000360 UH *)
          cak_x_save_database,
          cak_x_save_pages
          ])
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a37blocksize (
            VAR acv  : tak_all_command_glob;
            VAR a30v : tak_a30_utility_glob) : tsp00_Int2;
 
VAR
      ti        : integer;
      blocksize : tsp00_Int4;
 
BEGIN
WITH acv, a30v DO
    BEGIN
&   ifdef TRACE
    t01int4 (ak_sem, 'a3ti=       ', a3ti);
&   endif
    blocksize := 0;
    IF  (a3ti <> 0) AND (a_ap_tree^[ a3ti ].n_proc = a37)
        AND (a_ap_tree^[ a3ti ].n_subproc = cak_i_blocksize)
    THEN
        BEGIN
        ti   := a_ap_tree^[ a3ti ].n_lo_level;
        a05_int4_unsigned_get (acv, a_ap_tree^[ ti ].n_pos,
              a_ap_tree^[ ti ].n_length, blocksize);
        a3ti := a_ap_tree^[ a3ti ].n_sa_level;
        IF  blocksize <= 0
        THEN
            BEGIN
            blocksize := 0;
            a07_b_put_error (acv, e_invalid_blocksize, 1)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
a37blocksize := blocksize;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37put_count_to_messbuf (
            VAR acv   : tak_all_command_glob;
            VAR a30v  : tak_a30_utility_glob);
 
VAR
      ti      : integer;
 
BEGIN
WITH acv, a30v DO
    BEGIN
&   ifdef TRACE
    t01int4 (ak_sem, 'a3ti=       ', a3ti);
&   endif
    IF  (a3ti <> 0) AND (a_ap_tree^[ a3ti ].n_proc = a37)
        AND (a_ap_tree^[ a3ti ].n_subproc = cak_i_count)
    THEN
        BEGIN
        ti   := a_ap_tree^[ a3ti ].n_lo_level;
        a05_int4_unsigned_get (acv, a_ap_tree^[ ti ].n_pos,
              a_ap_tree^[ ti ].n_length, a_mblock.mb_qual^.mut_count);
        a3ti := a_ap_tree^[ a3ti ].n_sa_level
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37get_count_int4 (
            VAR acv   : tak_all_command_glob;
            VAR a30v  : tak_a30_utility_glob;
            VAR i4    : tsp00_Int4);
 
VAR
      ti      : integer;
 
BEGIN
WITH acv, a30v DO
    BEGIN
    i4 := csp_maxint4;
&   ifdef TRACE
    t01int4 (ak_sem, 'a3ti=       ', a3ti);
&   endif
    IF  (a3ti <> 0) AND (a_ap_tree^[ a3ti ].n_proc = a37)
        AND (a_ap_tree^[ a3ti ].n_subproc = cak_i_count)
    THEN
        BEGIN
        ti   := a_ap_tree^[ a3ti ].n_lo_level;
        a05_int4_unsigned_get (acv, a_ap_tree^[ ti ].n_pos,
              a_ap_tree^[ ti ].n_length, i4);
        a3ti := a_ap_tree^[ a3ti ].n_sa_level
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37state_get (
            VAR acv  : tak_all_command_glob;
            kw_index : integer);
 
VAR
      res_kw    : boolean;
      dt_format : tgg00_DateTimeFormat;
 
BEGIN
dt_format := acv.a_dt_format;
IF  acv.a_cmd_part <> NIL
THEN
    BEGIN
    a01_next_symbol (acv);
    IF  acv.a_scv.sc_symb <> s_eof
    THEN
        IF  a01mandatory_keyword (acv, cak_i_format)
        THEN
            BEGIN
            a01_get_keyword (acv, kw_index, res_kw);
            CASE kw_index OF
                cak_i_normal :
                    acv.a_dt_format := dtf_normal;
                cak_i_iso    :
                    acv.a_dt_format := dtf_iso;
                cak_i_usa    :
                    acv.a_dt_format := dtf_usa;
                cak_i_eur    :
                    acv.a_dt_format := dtf_eur;
                cak_i_jis    :
                    acv.a_dt_format := dtf_jis;
                (* PTS 1112472 E.Z. *)
                OTHERWISE ;
                END;
            (*ENDCASE*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
a06init_curr_retpart (acv);
IF  acv.a_curr_retpart <> NIL
THEN
    a37multi_tape_info (acv, kw_index);
(*ENDIF*) 
acv.a_dt_format := dt_format
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37state_vtrace (VAR acv : tak_all_command_glob);
 
CONST
      c_vtrace_columns = 23;
 
TYPE
 
      tname_info = RECORD
            CASE boolean OF
                true :
                    (len  : char);
                false :
                    (name : tsp00_C16);
                END;
            (*ENDCASE*) 
 
 
VAR
      ix         : integer;
      pos        : integer;
      on_off     : ARRAY[boolean] OF tsp00_C4;
      shortinfo  : tak_shortinforecord;
      colnames   : ARRAY[1..c_vtrace_columns] OF tname_info;
 
BEGIN
colnames[1 ].name := ' AK             ';
colnames[1 ].len  := chr(2);
colnames[2 ].name := ' DELETE         ';
colnames[2 ].len  := chr(6);
colnames[3 ].name := ' INSERT         ';
colnames[3 ].len  := chr(6);
colnames[4 ].name := ' ORDER          ';
colnames[4 ].len  := chr(5);
colnames[5 ].name := ' SELECT         ';
colnames[5 ].len  := chr(6);
colnames[6 ].name := ' ORDER STANDARD ';
colnames[6 ].len  := chr(14);
colnames[7 ].name := ' UPDATE         ';
colnames[7 ].len  := chr(6);
colnames[8 ].name := ' INDEX          ';
colnames[8 ].len  := chr(5);
colnames[9 ].name := ' TABLE          ';
colnames[9 ].len  := chr(5);
colnames[10].name := ' LONG           ';
colnames[10].len  := chr(4);
colnames[11].name := ' PAGES          ';
colnames[11].len  := chr(5);
colnames[12].name := ' LOCK           ';
colnames[12].len  := chr(4);
colnames[13].name := ' OPTIMIZE       ';
colnames[13].len  := chr(8);
colnames[14].name := ' TIME           ';
colnames[14].len  := chr(4);
(* PTS 1111576 E.Z. *)
colnames[15].name := ' SESSION        ';
colnames[15].len  := chr(7);
colnames[16].name := ' CHECK          ';
colnames[16].len  := chr(5);
colnames[17].name := ' OBJECT         ';
colnames[17].len  := chr(6);
colnames[18].name := ' OBJECT ADD     ';
colnames[18].len  := chr(10);
colnames[19].name := ' OBJECT GET     ';
colnames[19].len  := chr(10);
colnames[20].name := ' OBJECT ALTER   ';
colnames[20].len  := chr(12);
colnames[21].name := ' OBJECT FREEPAGE';
colnames[21].len  := chr(15);
colnames[22].name := ' STOP           ';
colnames[22].len  := chr(4);
pos := 1;
FOR ix := 1 TO c_vtrace_columns DO
    BEGIN
    a06retpart_move (acv, @colnames[ix].name, ord(colnames[ix].len) + 1);
    WITH shortinfo.siinfo[ix] DO
        BEGIN
        sp1i_mode       := [ sp1ot_mandatory ];
        sp1i_io_type    := sp1io_output;
        sp1i_data_type  := dcha;
        sp1i_frac       := 0;
        sp1i_length     := 3;
        sp1i_in_out_len := 3+1;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    END;
(*ENDFOR*) 
a06finish_curr_retpart (acv, sp1pk_columnnames, c_vtrace_columns);
shortinfo.sicount := c_vtrace_columns;
a06retpart_move (acv, @shortinfo.siinfo,
      shortinfo.sicount * sizeof (shortinfo.siinfo[1]));
a06finish_curr_retpart (acv, sp1pk_shortinfo, c_vtrace_columns);
on_off[false] := ' OFF';
on_off[true ] := ' ON ';
WITH g01vtrace DO
    BEGIN
    a06retpart_move (acv, @on_off[vtrAk_gg00           ], 4);
    a06retpart_move (acv, @on_off[vtrAkDelete_gg00     ], 4);
    a06retpart_move (acv, @on_off[vtrAkInsert_gg00     ], 4);
    a06retpart_move (acv, @on_off[vtrAkPacket_gg00     ], 4);
    a06retpart_move (acv, @on_off[vtrAkSelect_gg00     ], 4);
    a06retpart_move (acv, @on_off[vtrAkShortPacket_gg00], 4);
    a06retpart_move (acv, @on_off[vtrAkUpdate_gg00     ], 4);
    a06retpart_move (acv, @on_off[vtrBdIndex_gg00      ], 4);
    a06retpart_move (acv, @on_off[vtrBdPrim_gg00       ], 4);
    a06retpart_move (acv, @on_off[vtrBdString_gg00     ], 4);
    (* PTS 1107617 E.Z. *)
    a06retpart_move (acv, @on_off[vtrIoTrace_gg00      ], 4);
    a06retpart_move (acv, @on_off[vtrKbLock_gg00       ], 4);
    a06retpart_move (acv, @on_off[vtrStrategy_gg00     ], 4);
    a06retpart_move (acv, @on_off[vtrTime_gg00         ], 4);
    a06retpart_move (acv, @on_off[vtrSession_gg00.ci4_gg00 <> cgg_nil_session], 4);
    a06retpart_move (acv, @on_off[vtrCheck_gg00        ], 4);
    a06retpart_move (acv, @on_off[vtrBdObject_gg00     ], 4);
    a06retpart_move (acv, @on_off[vtrOmsNew_gg00       ], 4);
    a06retpart_move (acv, @on_off[vtrOmsGet_gg00       ], 4);
    a06retpart_move (acv, @on_off[vtrOmsUpd_gg00       ], 4);
    a06retpart_move (acv, @on_off[vtrOmsFree_gg00      ], 4);
    a06retpart_move (acv, @on_off[vtrStopRetcode_gg00 <> 0 ], 4);
    a06finish_curr_retpart (acv, sp1pk_data, 1)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37stop_all_vtrace (VAR acv : tak_all_command_glob);
 
VAR
      requested    : integer;
      index        : integer;
      kindOut      : tak_keyword;
      topicKeyOut  : tsp00_Sname;
      levelOut     : integer;
      conf_param_name   : tsp11_ConfParamName;
      conf_param_value  : tsp11_ConfParamValue;
      conf_param_value1 : tsp11_ConfParamValue;
      conf_param_ret    : tsp11_ConfParamReturnValue;
      keyword           : tak_keyword;
      s1                : tsp00_C20;
 
BEGIN
SAPDB_PascalForcedFill (sizeof(conf_param_value), @conf_param_value, 1,
      sizeof(conf_param_value), csp_ascii_blank);
conf_param_value[1] := 'N';
conf_param_value[2] := 'O';
conf_param_name := 'TRACE_AK                        ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_DEFAULT                   ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_DELETE                    ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_INDEX                     ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_INSERT                    ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_LOCK                      ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_LONG                      ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OBJECT                    ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OBJECT_ADD                ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OBJECT_ALTER              ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OBJECT_FREE               ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OBJECT_GET                ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OPTIMIZE                  ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_ORDER                     ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_ORDER_STANDARD            ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_PAGES                     ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_PRIMARY_TREE              ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_SELECT                    ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_TIME                      ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_UPDATE                    ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_value[1] := '0';
conf_param_value[2] := ' ';
conf_param_name := 'TRACE_OMS_CONTAINERDIR          ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OMS_CONTEXT               ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OMS_ERROR                 ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OMS_FLUSHCACHE            ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OMS_INTERFACE             ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OMS_KEY                   ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OMS_KEYRANGE              ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OMS_LOCK                  ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OMS_MEMORY                ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OMS_NEWOBJ                ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OMS_SESSION               ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OMS_STREAM                ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OMS_VAROBJECT             ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
conf_param_name := 'TRACE_OMS_VERSION               ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
      NOT c_is_perm, conf_param_ret);
requested := 0;
WHILE Kernel_DiagInfop (requested, kindOut, topicKeyOut, levelOut) DO
    BEGIN
    IF  (levelOut > 0) AND (kindOut = 'Vtrace            ')
    THEN
        BEGIN
        conf_param_name := 'TRACE_                          ';
        FOR index := 1 TO sizeof (topicKeyOut) DO
            conf_param_name[6+index] := topicKeyOut[index];
        (*ENDFOR*) 
        vconf_param_put (conf_param_name, conf_param_value, c_is_numeric,
              NOT c_is_perm, conf_param_ret);
        END;
    (*ENDIF*) 
    requested := requested + 1;
    END;
(*ENDWHILE*) 
&ifdef TRACE
s1 := bsp_c20;
t01multiswitch (s1, s1);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37vtrace (VAR acv : tak_all_command_glob);
 
VAR
      vtrace_on_off     : boolean;
      other_cmd_kind    : boolean;
      i                 : integer;
      ti                : integer;
      oms_ti            : integer;
      len               : integer;
      c18               : tsp00_C18;
      oms_trace_lvl     : tsp00_KnlIdentifier;
      oms_trace_lvl2    : tsp00_KnlIdentifier;
      colinfo           : tak00_columninfo;
      _moveobj_ptr      : tsp00_MoveObjPtr;
      error             : tsp8_uni_error;
      err_char_no       : tsp00_Int4;
      length            : tsp00_Int4;
      conf_param_name   : tsp11_ConfParamName;
      conf_param_value  : tsp11_ConfParamValue;
      conf_param_value1 : tsp11_ConfParamValue;
      conf_param_ret    : tsp11_ConfParamReturnValue;
 
BEGIN
WITH acv DO
    BEGIN
    vbegexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08monitor);
    ti            := 1;
    vtrace_on_off :=
          a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc = cak_x_vtrace_on;
    SAPDB_PascalForcedFill (sizeof(conf_param_value), @conf_param_value, 1,
          sizeof(conf_param_value), csp_ascii_blank);
    IF  a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc = cak_x_vtrace_on
    THEN
        BEGIN
        conf_param_value[1] := 'Y';
        conf_param_value[2] := 'E';
        conf_param_value[3] := 'S';
        END
    ELSE
        BEGIN
        conf_param_value[1] := 'N';
        conf_param_value[2] := 'O';
        END;
    (*ENDIF*) 
    REPEAT
        other_cmd_kind := false;
        ti := a_ap_tree^[ ti ].n_sa_level;
        CASE a_ap_tree^[ ti ].n_subproc OF
            cak_i_add:
                conf_param_name := 'TRACE_OBJECT_ADD                ';
            cak_i_alter:
                conf_param_name := 'TRACE_OBJECT_ALTER              ';
            cak_i_analyze:
                conf_param_name := 'TRACE_AK                        ';
            cak_i_constraint:
                conf_param_name := 'CHECK_REGIONS                   ';
            cak_i_default :
                conf_param_name := 'TRACE_DEFAULT                   ';
            cak_i_delete :
                conf_param_name := 'TRACE_DELETE                    ';
            cak_i_freepage:
                conf_param_name := 'TRACE_OBJECT_FREE               ';
            cak_i_get:
                conf_param_name := 'TRACE_OBJECT_GET                ';
            cak_i_index :
                conf_param_name := 'TRACE_INDEX                     ';
            cak_i_insert :
                conf_param_name := 'TRACE_INSERT                    ';
            cak_i_lock :
                conf_param_name := 'TRACE_LOCK                      ';
            cak_i_long :
                conf_param_name := 'TRACE_LONG                      ';
            cak_i_optimize :
                conf_param_name := 'TRACE_OPTIMIZE                  ';
            cak_i_order :
                conf_param_name := 'TRACE_ORDER                     ';
            cak_i_pages :
                conf_param_name := 'TRACE_PAGES                     ';
            cak_i_select :
                conf_param_name := 'TRACE_SELECT                    ';
            cak_i_standard :
                conf_param_name := 'TRACE_ORDER_STANDARD            ';
            cak_i_table :
                conf_param_name := 'TRACE_PRIMARY_TREE              ';
            cak_i_time :
                conf_param_name := 'TRACE_TIME                      ';
            cak_i_update :
                conf_param_name := 'TRACE_UPDATE                    ';
            OTHERWISE
                other_cmd_kind := true
            END;
        (*ENDCASE*) 
        IF  NOT other_cmd_kind
        THEN
            BEGIN
            vconf_param_put (conf_param_name, conf_param_value,
                  NOT c_is_numeric,
                  NOT c_is_perm, conf_param_ret);
            IF  (conf_param_ret <> ok_sp11)
            THEN
                ak37param_put_error (acv, conf_param_ret, 1, conf_param_name);
            (*ENDIF*) 
            END
        ELSE
            CASE a_ap_tree^[ ti ].n_subproc OF
                cak_i_clear:
                    b120ClearTrace (a_transinf.tri_trans.trTaskId_gg00);
                cak_i_flush:
                    BEGIN
                    a35_flush_vtrace( acv );
                    END;
                cak_i_stop :
                    BEGIN
                    i := a_ap_tree^[ ti ].n_lo_level;
                    IF  ((a_ap_tree^[ i ].n_proc = a37) AND (a_ap_tree^[ i ].n_subproc = cak_i_all))
                    THEN
                        a37stop_all_vtrace (acv)
                    ELSE
                        BEGIN
                        conf_param_name := 'TRACE_STOP_ERRORCODE            ';
                        _moveobj_ptr := @conf_param_value1;
                        a05string_literal_get (acv, i, dcha,
                              _moveobj_ptr^, 2, sizeof(conf_param_value1)-1);
                        IF  acv.a_ap_tree^[i].n_pos < 0
                        THEN
                            conf_param_value1[1] := '-'
                        ELSE
                            conf_param_value1[1] := ' ';
                        (*ENDIF*) 
                        vconf_param_put (conf_param_name, conf_param_value1, c_is_numeric,
                              NOT c_is_perm, conf_param_ret);
                        IF  (conf_param_ret <> ok_sp11)
                        THEN
                            ak37param_put_error (acv, conf_param_ret, 1, conf_param_name);
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                cak_i_session :
                    BEGIN
                    ti := a_ap_tree^[ti].n_sa_level;
                    IF  a_ap_tree^[ti].n_symb = s_asterisk
                    THEN
                        g01vtrace.vtrSession_gg00.ci4_gg00 :=
                              cgg_nil_session
                    ELSE
                        IF  a_ap_tree^[ti].n_symb = s_equal
                        THEN
                            g01vtrace.vtrSession_gg00 :=
                                  a_transinf.tri_trans.trSessionId_gg00
                        ELSE
                            BEGIN
                            colinfo := a642standard_colinfo;
                            colinfo.cdatatyp  := dchb;
                            colinfo.cdatalen  := 4;
                            colinfo.cinoutlen := 5;
                            a05_constant_get (acv, ti, colinfo,
                                  NOT cak_may_be_longer, succ(mxsp_c4), c18, 1, len);
                            FOR i := 1 TO sizeof (g01vtrace.vtrSession_gg00) DO
                                g01vtrace.vtrSession_gg00.ci4_gg00[i] := chr(0);
                            (*ENDFOR*) 
                            i := 4;
                            WHILE (len > 1) AND (i > 0) DO
                                BEGIN
                                g01vtrace.vtrSession_gg00.ci4_gg00[i] := c18[len];
                                len := len - 1;
                                i   := i - 1
                                END;
                            (*ENDWHILE*) 
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                OTHERWISE ;
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
    UNTIL
        a_ap_tree^[ ti ].n_sa_level = 0;
    (*ENDREPEAT*) 
    ti := 1;
    REPEAT
        ti := a_ap_tree^[ ti ].n_sa_level;
        CASE a_ap_tree^[ ti ].n_subproc OF
            cak_i_object :
                BEGIN
                g01vtrace.vtrBdObject_gg00 := vtrace_on_off;
                g01vtrace.vtrOmsNew_gg00   := vtrace_on_off;
                g01vtrace.vtrOmsGet_gg00   := vtrace_on_off;
                g01vtrace.vtrOmsUpd_gg00   := vtrace_on_off;
                g01vtrace.vtrOmsFree_gg00  := vtrace_on_off;
                END;
            OTHERWISE ;
            END;
        (*ENDCASE*) 
    UNTIL
        a_ap_tree^[ ti ].n_sa_level = 0;
    (*ENDREPEAT*) 
&   ifdef TRACE
    (* SLOW KERNEL: do not switch off vtrCheck_gg00 *)
    g01vtrace.vtrCheck_gg00 := true;
    conf_param_name := 'CHECK_REGIONS                   ';
    conf_param_value[1] := 'Y';
    conf_param_value[2] := 'E';
    conf_param_value[3] := 'S';
    vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric,
          NOT c_is_perm, conf_param_ret);
&   endif
    vendexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08monitor);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37dump (VAR acv : tak_all_command_glob);
 
VAR
      curr_n : integer;
      b_err  : tgg00_BasisError;
      a30v   : tak_a30_utility_glob;
 
BEGIN
WITH acv, a30v, a_mblock, mb_qual^,
     a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ] DO
    IF  a_returncode  = 0
    THEN
        BEGIN
        a37init_util_record (acv, m_diagnose, mm_dump);
        a3ti := 1;
        a36filename (acv, 2, mut_hostfn, sizeof(mut_hostfn));
        curr_n := 1;
        WHILE (a_ap_tree^[ curr_n ].n_sa_level <> 0) DO
            BEGIN
            curr_n := a_ap_tree^[ curr_n ].n_sa_level;
            CASE a_ap_tree^[ curr_n ].n_subproc OF
                cak_i_pages :
                    mut_dump_state := mut_dump_state + [dumpBdLocklist_egg00];
                cak_i_config :
                    mut_dump_state := mut_dump_state + [dumpConfiguration_egg00];
                cak_i_psm :
                    mut_dump_state := mut_dump_state + [dumpConverter_egg00];
                cak_i_buffer :
                    mut_dump_state := mut_dump_state + [dumpConverterCache_egg00];
                cak_i_data :
                    mut_dump_state := mut_dump_state + [dumpDataCache_egg00];
                cak_i_write :
                    mut_dump_state := mut_dump_state + [dumpPagerWriter_egg00];
                cak_i_freepage :
                    mut_dump_state := mut_dump_state + [dumpFbm_egg00];
                cak_i_autosave :
                    mut_dump_state := mut_dump_state + [dumpBackup_egg00];
                cak_i_lock :
                    mut_dump_state := mut_dump_state + [dumpKbLocklist_egg00];
                cak_i_serverdb :
                    mut_dump_state := mut_dump_state + [dumpNetServer_egg00];
                cak_i_restart :
                    mut_dump_state := mut_dump_state + [dumpRestartRec_egg00];
                cak_i_version :
                    mut_dump_state := mut_dump_state + [dumpRte_egg00];
                cak_i_translate :
                    mut_dump_state := mut_dump_state + [dumpTransformation_egg00];
                cak_i_release :
                    mut_dump_state := mut_dump_state + [dumpGarbcoll_egg00];
                cak_i_object :
                    mut_dump_state := mut_dump_state + [dumpFileDir_egg00];
                OTHERWISE :
                END
            (*ENDCASE*) 
            END;
        (*ENDWHILE*) 
        IF  mut_dump_state = []
        THEN
            mut_dump_state := [dumpAll_egg00];
        (*ENDIF*) 
        IF  NOT gg999KernelStateIsOnline
        THEN
            a06_c_send_mess_buf (acv, b_err)
        ELSE
            a06lsend_mess_buf (acv, a_mblock,
                  NOT cak_call_from_rsend, b_err);
        (*ENDIF*) 
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37suspend_semantic (VAR acv : tak_all_command_glob);
 
VAR
      shortinfo       : tak_shortinforecord;
      name            : tsp00_C18;
      iosequence      : tsp00_Uint4;
      NumInfo         : ^tsp00_ResNum;
      num_err         : tsp00_NumError;
 
BEGIN
acv.a_transinf.tri_trans.trError_gg00 :=
      gg999SuspendLogWriter (acv.a_transinf.tri_trans.trTaskId_gg00, iosequence);
IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
THEN
    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
ELSE
    BEGIN
    name := 'IO SEQUENCE       ';
    a06colname_retpart_move (acv, @name, 11, csp_ascii);
    a06finish_curr_retpart (acv, sp1pk_columnnames, 1);
    shortinfo.siinfo[1].sp1i_mode       := [ sp1ot_mandatory ];
    shortinfo.siinfo[1].sp1i_data_type  := dfixed;
    shortinfo.siinfo[1].sp1i_length     := csp_resnum_deflen;
    shortinfo.siinfo[1].sp1i_frac       := 0;
    shortinfo.siinfo[1].sp1i_in_out_len := mxsp_resnum;
    shortinfo.siinfo[1].sp1i_bufpos     := 1;
    shortinfo.sicount := 1;
    a06retpart_move (acv, @shortinfo.siinfo, sizeof (shortinfo.siinfo[1]));
    a06finish_curr_retpart (acv, sp1pk_shortinfo, 1);
    a06init_curr_retpart (acv);
    IF  acv.a_curr_retpart <> NIL
    THEN
        WITH acv.a_curr_retpart^ DO
            BEGIN
            NumInfo := @sp1p_buf[sp1p_buf_len+1];
            NumInfo^[1] := csp_defined_byte;
            s41pluns (NumInfo^, 2, 10, 0, iosequence, num_err);
            sp1p_buf_len := mxsp_resnum + 1;
            a06finish_curr_retpart (acv, sp1pk_data, 1);
            END
        (*ENDWITH*) 
    ELSE
        a07_b_put_error (acv, e_too_small_packet_size, 1)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(* PTS 1119691 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak37delete_block (VAR acv : tak_all_command_glob);
 
VAR
      recMode    : tgg00_RecoveryMode;
      error      : tgg00_BasisError;
      curr_n     : tsp00_Int2;
      value      : tsp00_Int4;
      pageno     : tsp00_PageNo;
 
BEGIN
curr_n := acv.a_ap_tree^[0].n_lo_level;
IF  (ord(acv.a_ap_tree^[curr_n].n_length) = ord (rmPerm_egg00))
THEN
    recMode := rmPerm_egg00
ELSE
    IF  (ord(acv.a_ap_tree^[curr_n].n_length) = ord (rmTemp_egg00))
    THEN
        recMode := rmTemp_egg00
    ELSE
        recMode := rmStatic_egg00;
    (*ENDIF*) 
(*ENDIF*) 
curr_n := acv.a_ap_tree^[curr_n].n_sa_level;
WITH acv.a_ap_tree^[ curr_n ] DO
    a05_int4_unsigned_get (acv, n_pos, n_length, value);
(*ENDWITH*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    pageno := value;
    error := e_ok;
    gg999DeleteBlockAddress (acv.a_transinf.tri_trans.trTaskId_gg00,
          error, pageno, recMode);
    IF  error <> e_ok
    THEN
        a07_b_put_error (acv, error, 1)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37get_block (VAR acv : tak_all_command_glob);
 
VAR
      recMode    : tgg00_RecoveryMode;
      curr_n     : tsp00_Int2;
      value      : tsp00_Int4;
      deviceno   : tsp00_Int4;
      blockno    : tsp00_Int4;
      pageno     : tsp00_PageNo;
      shortinfo  : tak_shortinforecord;
      pos        : tsp00_Int4;
      name       : tsp00_C18;
      dummy_err  : tsp00_NumError;
      out_number : tsp00_ResNum;
 
BEGIN
curr_n := acv.a_ap_tree^[0].n_lo_level;
IF  (ord(acv.a_ap_tree^[curr_n].n_length) = ord (rmPerm_egg00))
THEN
    recMode := rmPerm_egg00
ELSE
    IF  (ord(acv.a_ap_tree^[curr_n].n_length) = ord (rmTemp_egg00))
    THEN
        recMode := rmTemp_egg00
    ELSE
        recMode := rmStatic_egg00;
    (*ENDIF*) 
(*ENDIF*) 
curr_n := acv.a_ap_tree^[curr_n].n_sa_level;
WITH acv.a_ap_tree^[ curr_n ] DO
    a05_int4_unsigned_get (acv, n_pos, n_length, value);
(*ENDWITH*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    pageno   := value;
    deviceno := 0;
    blockno  := 0;
    gg999GetBlockAddress (acv.a_transinf.tri_trans.trTaskId_gg00,
          pageno, recMode, deviceno, blockno);
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        pos := 1;
        name := 'DEVICENO          ';
        a06colname_retpart_move (acv, @name, 8, csp_ascii);
        WITH shortinfo.siinfo[1] DO
            BEGIN
            sp1i_mode       := [ sp1ot_mandatory ];
            sp1i_io_type    := sp1io_output;
            sp1i_data_type  := dfixed;
            sp1i_frac       := 0;
            sp1i_length     := csp_resnum_deflen;
            sp1i_in_out_len := mxsp_resnum;
            sp1i_bufpos     := pos;
            pos             := pos + sp1i_in_out_len
            END;
        (*ENDWITH*) 
        name := 'BLOCKNO           ';
        a06colname_retpart_move (acv, @name, 7, csp_ascii);
        shortinfo.siinfo[2] := shortinfo.siinfo[1];
        shortinfo.siinfo[2].sp1i_bufpos := pos;
        pos := pos + shortinfo.siinfo[2].sp1i_in_out_len;
        a06finish_curr_retpart (acv, sp1pk_columnnames, 2);
        shortinfo.sicount := 2;
        a06retpart_move (acv, @shortinfo.siinfo,
              shortinfo.sicount * sizeof (shortinfo.siinfo[1]));
        a06finish_curr_retpart (acv, sp1pk_shortinfo, shortinfo.sicount);
        out_number := csp_rescnt_zero;
        s41p4int (out_number, 2, deviceno, dummy_err);
        a06retpart_move (acv, @out_number, mxsp_resnum);
        out_number := csp_rescnt_zero;
        s41p4int (out_number, 2, blockno, dummy_err);
        a06retpart_move (acv, @out_number, mxsp_resnum);
        a06finish_curr_retpart (acv, sp1pk_data, 1)
        END;
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak37set_block (VAR acv : tak_all_command_glob);
 
VAR
      recMode    : tgg00_RecoveryMode;
      error      : tgg00_BasisError;
      curr_n     : tsp00_Int2;
      value      : tsp00_Int4;
      deviceno   : tsp00_Int4;
      blockno    : tsp00_Int4;
      pageno     : tsp00_PageNo;
 
BEGIN
curr_n := acv.a_ap_tree^[0].n_lo_level;
IF  (ord(acv.a_ap_tree^[curr_n].n_length) = ord (rmPerm_egg00))
THEN
    recMode := rmPerm_egg00
ELSE
    IF  (ord(acv.a_ap_tree^[curr_n].n_length) = ord (rmTemp_egg00))
    THEN
        recMode := rmTemp_egg00
    ELSE
        recMode := rmStatic_egg00;
    (*ENDIF*) 
(*ENDIF*) 
curr_n := acv.a_ap_tree^[curr_n].n_sa_level;
WITH acv.a_ap_tree^[ curr_n ] DO
    a05_int4_unsigned_get (acv, n_pos, n_length, value);
(*ENDWITH*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    pageno := value;
    curr_n := acv.a_ap_tree^[curr_n].n_sa_level;
    WITH acv.a_ap_tree^[ curr_n ] DO
        a05_int4_unsigned_get (acv, n_pos, n_length, value);
    (*ENDWITH*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    deviceno := value;
    curr_n := acv.a_ap_tree^[curr_n].n_sa_level;
    WITH acv.a_ap_tree^[ curr_n ] DO
        a05_int4_unsigned_get (acv, n_pos, n_length, value);
    (*ENDWITH*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    blockno := value;
    error   := e_ok;
    gg999SetNewBlockAddress (acv.a_transinf.tri_trans.trTaskId_gg00,
          error, pageno, recMode, deviceno, blockno);
    IF  error <> e_ok
    THEN
        a07_b_put_error (acv, error, 1)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      ak37switch_semantic (VAR acv : tak_all_command_glob);
 
VAR
      _value        : tsp00_Int4;
      _moveobj_ptr  : tsp00_MoveObjPtr;
      _on_text      : tsp00_C16;
      _off_text     : tsp00_C16;
      _layer        : tsp00_C20;
      _debug        : tsp00_C20;
      _topic_debug  : tsp00_C20;
      _curr_n       : tsp00_Int2;
 
BEGIN
vbegexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08monitor);
_value       := 0;
_layer       := bsp_c20;
_debug       := bsp_c20;
_topic_debug := bsp_c20;
_on_text     := bsp_c16;
_off_text    := bsp_c16;
_curr_n      := acv.a_ap_tree^[ 0 ].n_lo_level;
CASE acv.a_ap_tree^[ _curr_n ].n_length OF
    cak30_x_switch_off:
        t01lmulti_switch (_layer, _debug, _on_text, _off_text, _value);
    cak30_x_switch_exclusive :
        t01SetSingleUser;
    cak30_x_switch_minbuf:
        t01minbuf (true);
    cak30_x_switch_maxbuf:
        t01minbuf (false);
    cak30_x_switch_buflimit:
        BEGIN
        _curr_n := acv.a_ap_tree^[ _curr_n ].n_sa_level;
        a05_int4_unsigned_get (acv, acv.a_ap_tree^[ _curr_n ].n_pos,
              acv.a_ap_tree^[ _curr_n ].n_length, _value );
        t01setmaxbuflength (_value);
        kb560SetTraceMaxBufferLength (_value);
        END;
    cak30_x_switch_trace, cak30_x_switch_debug, cak30_x_switch_topic_debug:
        BEGIN
        IF  (_curr_n > 0) AND (acv.a_ap_tree^[ _curr_n ].n_length = cak30_x_switch_trace )
        THEN
            BEGIN
            _moveobj_ptr := @_layer;
            a05string_literal_get (acv,
                  acv.a_ap_tree^[ _curr_n ].n_sa_level,
                  dcha, _moveobj_ptr^, 1, sizeof(_layer));
            s30map (g02codetables.tables[ cgg04_up_ascii ],
                  _moveobj_ptr^, 1, _moveobj_ptr^, 1, sizeof(_layer));
            _curr_n := acv.a_ap_tree^[ _curr_n ].n_lo_level
            END;
        (*ENDIF*) 
        IF  (_curr_n > 0) AND (acv.a_ap_tree^[ _curr_n ].n_length = cak30_x_switch_debug )
        THEN
            BEGIN
            _moveobj_ptr := @_debug;
            a05string_literal_get (acv,
                  acv.a_ap_tree^[ _curr_n ].n_sa_level,
                  dcha, _moveobj_ptr^, 1, sizeof(_debug));
            s30map (g02codetables.tables[ cgg04_up_ascii ],
                  _moveobj_ptr^, 1, _moveobj_ptr^, 1, sizeof(_debug));
            _curr_n := acv.a_ap_tree^[ _curr_n ].n_lo_level;
            END;
        (*ENDIF*) 
        IF  (_curr_n > 0) AND (acv.a_ap_tree^[ _curr_n ].n_length = cak30_x_switch_topic_debug )
        THEN
            BEGIN
            _moveobj_ptr := @_topic_debug;
            a05string_literal_get (acv,
                  acv.a_ap_tree^[ _curr_n ].n_sa_level,
                  dcha, _moveobj_ptr^, 1, sizeof(_topic_debug));
            s30map (g02codetables.tables[ cgg04_up_ascii ],
                  _moveobj_ptr^, 1, _moveobj_ptr^, 1, sizeof(_topic_debug));
            _curr_n := acv.a_ap_tree^[ _curr_n ].n_lo_level
            END;
        (*ENDIF*) 
        Kernel_TraceSwitch (_moveobj_ptr^, sizeof(_topic_debug));
        IF  (_curr_n > 0) AND
            (acv.a_ap_tree^[ _curr_n ].n_length = cak30_x_switchlimit_start )
        THEN
            BEGIN
            _moveobj_ptr := @_on_text;
            a05string_literal_get (acv,
                  acv.a_ap_tree^[ _curr_n ].n_sa_level,
                  dcha, _moveobj_ptr^, 1, sizeof(_on_text));
            s30map (g02codetables.tables[ cgg04_up_ascii ],
                  _moveobj_ptr^, 1, _moveobj_ptr^, 1, sizeof(_on_text));
            _curr_n := acv.a_ap_tree^[ _curr_n ].n_lo_level;
            IF  (_curr_n > 0) AND
                (acv.a_ap_tree^[ _curr_n ].n_length = cak30_x_switchlimit_count )
            THEN
                BEGIN
                a05_int4_unsigned_get (acv, acv.a_ap_tree^[ _curr_n ].n_pos,
                      acv.a_ap_tree^[ _curr_n ].n_length, _value );
                _curr_n := acv.a_ap_tree^[ _curr_n ].n_lo_level;
                END
            ELSE
                _value := 1;
            (*ENDIF*) 
            IF  (_curr_n > 0) AND
                (acv.a_ap_tree^[ _curr_n ].n_length = cak30_x_switchlimit_stop )
            THEN
                BEGIN
                _moveobj_ptr := @_off_text;
                a05string_literal_get (acv,
                      acv.a_ap_tree^[ _curr_n ].n_sa_level,
                      dcha, _moveobj_ptr^, 1, sizeof(_off_text));
                s30map (g02codetables.tables[ cgg04_up_ascii ],
                      _moveobj_ptr^, 1, _moveobj_ptr^, 1, sizeof(_off_text));
                END;
            (*ENDIF*) 
            t01lmulti_switch (_layer, _debug, _on_text, _off_text, _value);
            END
        ELSE
            t01multiswitch (_layer, _debug)
        (*ENDIF*) 
        END;
    END;
(*ENDCASE*) 
vendexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08monitor);
END;
 
&endif
(*------------------------------*) 
 
PROCEDURE
      ak37param_put_error (VAR acv : tak_all_command_glob;
            conf_param_ret      : tsp11_ConfParamReturnValue;
            errorpos            : tsp00_Int4;
            VAR conf_param_name : tsp11_ConfParamName);
 
BEGIN
CASE conf_param_ret OF
    ok_sp11 :
        BEGIN
        END;
    key_not_found_sp11 :
        a07_const_b_put_error (acv, e_unknown_name, errorpos,
              @conf_param_name, sizeof(conf_param_name));
    cannot_change_online_sp11 :
        a07_const_b_put_error (acv, e_parameter_change_not_allowed,
              errorpos, @conf_param_name, sizeof(conf_param_name));
    no_change_permission_sp11 :
        a07_const_b_put_error (acv, e_missing_privilege, errorpos,
              @conf_param_name, sizeof(conf_param_name));
    OTHERWISE :
        a07_const_b_put_error (acv, e_conf_parameter_error, errorpos,
              @conf_param_name, sizeof(conf_param_name));
    END
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37insert_event (event : tsp31_event_ident);
 
VAR
      event_description : tsp31_event_description;
 
BEGIN
g01event_init (event_description);
WITH event_description DO
    BEGIN
    sp31ed_ident      := event;
    sp31ed_priority   := sp31ep_low;
    sp31ed_value_1    := 0;
    sp31ed_value_2    := 0;
    END;
(*ENDWITH*) 
vinsert_event (event_description)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a37resultevent (
            ident   : tsp31_event_ident;
            retcode : tsp00_Int2);
 
VAR
      event_description : tsp31_event_description;
      text_value        : tsp00_C12;
      dummy_returncode  : tsp00_Int2;
 
BEGIN
g01event_init (event_description);
WITH event_description DO
    BEGIN
    sp31ed_ident      := ident;
    IF  ident = sp31ei_systemerror
    THEN
        sp31ed_priority   := sp31ep_high
    ELSE
        sp31ed_priority   := sp31ep_low;
    (*ENDIF*) 
    g17int4to_line (retcode, NOT c_with_zero, 5, 1, text_value);
    sp31ed_text_len   := 5;
    dummy_returncode  := 0;
    SAPDB_PascalMove('VAK37 ',   4,    
          sizeof(text_value), sizeof(sp31ed_text_value),
          @text_value, 1, @sp31ed_text_value, 1,
          sp31ed_text_len, dummy_returncode);
    END;
(*ENDWITH*) 
vinsert_event (event_description)
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
