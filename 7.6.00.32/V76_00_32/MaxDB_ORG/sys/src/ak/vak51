.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK51$
.tt 2 $$$
.TT 3 $ElkeZ$AK_Connect$$$$2000-09-26$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : AK_Connect
=========
.sp
Purpose : Syntax analysis and processing of the commands:
          CONNECT, SET LANG, CURRENT USER
          CURRENT USER only with messagetype = ADBSCATALOG or
                       in system procedures
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a51_aconnect_statement (VAR acv : tak_all_command_glob;
                    VAR put_node      : tsp00_Int2);
 
        PROCEDURE
              a51_acurrent_user  (VAR acv : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a51_aset_statement (VAR acv : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        FUNCTION
              a51CatalogCacheSize : tsp00_Int4;
 
        PROCEDURE
              a51connect (VAR acv : tak_all_command_glob;
                    VAR connect_rec  : tak_connect_rec;
                    change_curr_user : boolean);
 
        PROCEDURE
              a51CreateConnectReturnSegment(
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a51create_file (VAR acv : tak_all_command_glob;
                    VAR current : tgg00_FileId);
 
        PROCEDURE
              a51getascii_password (VAR acv : tak_all_command_glob;
                    VAR password : tsp00_CryptPw);
 
        PROCEDURE
              a51trimcn_password (VAR password : tsp00_CryptPw);
 
        PROCEDURE
              a51init_cache_sizes;
 
        PROCEDURE
              a51_connect (VAR acv : tak_all_command_glob);
 
        FUNCTION
              a51NextSession (VAR isFirst : boolean) : tak_acv_address;
 
        FUNCTION
              a51SessionNext (
                    VAR isLocked       : boolean;
                    VAR currentIndex   : integer;
                    VAR currentPointer : tak_size_ptr) : tak_acv_address;
 
        PROCEDURE
              a51session_init (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a51SetSessionReplicationProlog (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a51build_userkey (VAR user_name : tsp00_KnlIdentifier (* ptocConst *);
                    VAR userkey : tgg00_SysInfoKey);
 
        PROCEDURE
              a51inc_ak_cache_size (size_info_ptr : tak_size_ptr;
                    increment     : tsp00_Int4);
 
        PROCEDURE
              a51cache_size_info (VAR acv : tak_all_command_glob;
                    session       : tgg91_SessionNo;
                    VAR ak_cache  : tsp00_Int4);
 
        PROCEDURE
              a51release_cache_size_info (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a51RestoreUserContext (
                    VAR acv          : tak_all_command_glob;
                    VAR pOldContext  : tsp00_Addr);
 
        PROCEDURE
              a51SaveUserContext (
                    VAR acv          : tak_all_command_glob;
                    VAR pOldContext  : tsp00_Addr);
 
        PROCEDURE
              a51semantic (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a51SetDebugSession (
                    VAR acv  : tak_all_command_glob;
                    session  : tgg91_SessionNo;
                    listener : tgg91_SessionNo);
 
        PROCEDURE
              a51set_degree (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a51switch_user (VAR acv : tak_all_command_glob;
                    VAR new_user_name  : tsp00_KnlIdentifier;
                    VAR pOldContext   : tsp00_Addr);
 
        PROCEDURE
              a51SwitchUser (VAR acv : tak_all_command_glob;
                    VAR new_user_name  : tsp00_KnlIdentifier);
 
        PROCEDURE
              a51a_alter_session_statement (VAR acv : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a51get_date_format (VAR acv : tak_all_command_glob;
                    VAR format    : tsp00_C120;
                    has_to_be_uni : boolean);
 
        PROCEDURE
              a51_internal_trans (VAR acv : tak_all_command_glob;
                    VAR old_trans : tgg00_UnivTrans);
 
        PROCEDURE
              a51close_internal_trans (VAR acv : tak_all_command_glob;
                    VAR old_trans : tgg00_UnivTrans;
                    m_type        : tgg00_MessType);
 
        FUNCTION
              a51UnlockSessionIterator : boolean;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
&       IFDEF TRACE
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01lidentifier (debug : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01int4 (debug : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01surrogate (debug : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR tabid : tgg00_Surrogate);
 
        PROCEDURE
              t01moveobj (debug : tgg00_Debug;
                    VAR moveobj : tsp00_C120;
                    startpos    : tsp00_Int4;
                    endpos      : tsp00_Int4);
 
        PROCEDURE
              t01segment (debug  : tgg00_Debug;
                    VAR cmd_segm : tsp1_segment);
&       ENDIF
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01char_size        : integer;
              a01kw               : tak_keywordtab;
              a01defaultkey       : tgg00_SysInfoKey;
              a01diag_monitor_on  : boolean;
              a01controluser      : tsp00_KnlIdentifier;
              a01_i_public        : tsp00_KnlIdentifier;
              a01_i_sys           : tsp00_KnlIdentifier;
              a01_i_sysdba        : tsp00_KnlIdentifier;
              a01_il_b_identifier : tsp00_KnlIdentifier;
              a01diag_analyze_on  : boolean;
 
        PROCEDURE
              a01_get_keyword (VAR acv : tak_all_command_glob;
                    VAR index    : integer;
                    VAR reserved : boolean);
 
        PROCEDURE
              a01_init_command (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_next_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_is_end_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_call_put (VAR acv : tak_all_command_glob;
                    proc       : tak_procs;
                    subproc    : tsp00_Int2;
                    VAR curr_n : tsp00_Int2);
 
        FUNCTION
              a01_eqkey (VAR a : tak_keyword;
                    sqlmode    : tsp00_SqlMode;
                    VAR b      : tsp00_MoveObj;
                    VAR scv    : tak_scanner_glob) : boolean;
 
        FUNCTION
              a01mandatory_keyword (VAR acv : tak_all_command_glob;
                    required_keyword : integer) : boolean;
 
        PROCEDURE
              a01_put_node (VAR acv : tak_all_command_glob;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_force_symbol (VAR acv : tak_all_command_glob;
                    expected_symbol : tak_sc_symbol;
                    VAR node1       : tsp00_Int2;
                    VAR node2       : tsp00_Int2);
 
        PROCEDURE
              a01_character_set (VAR acv : tak_all_command_glob;
                    VAR put_node   : tsp00_Int2;
                    VAR last_node  : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_syntax_tools : VAK02;
 
        PROCEDURE
              a02_aauthid (VAR acv : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a02_aparameter_name (VAR acv : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a02_put_identifier (VAR acv    : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_syntax_values_tools : VAK03;
 
        PROCEDURE
              a03_aunsigned_integer (VAR acv : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a03_astring_literal (VAR acv : tak_all_command_glob;
                    VAR put_node     : tsp00_Int2;
                    VAR last_node    : tsp00_Int2);
 
        PROCEDURE
              a03_avalue_spec (VAR acv : tak_all_command_glob;
                    null_allowed    : boolean;
                    stamp_allowed   : boolean;
                    default_allowed : boolean;
                    sysdba_allowed  : boolean;
                    VAR put_node    : tsp00_Int2;
                    VAR last_node   : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05_unsigned_int2_get (
                    VAR acv  : tak_all_command_glob;
                    pos      : integer;
                    l        : tsp00_Int2;
                    err_code : tsp00_Int4;
                    VAR int  : tsp00_Int2);
 
        PROCEDURE
              a05_int4_unsigned_get (VAR acv : tak_all_command_glob;
                    pos     : integer;
                    l       : tsp00_Int2;
                    VAR int : tsp00_Int4);
 
        PROCEDURE
              a05identifier_get (VAR acv : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
        PROCEDURE
              a05password_get (VAR acv : tak_all_command_glob;
                    tree_index   : integer;
                    VAR password : tsp00_Pw);
 
        PROCEDURE
              a05string_literal_get (VAR acv : tak_all_command_glob;
                    tree_index  : integer;
                    datatyp     : tsp00_DataType;
                    VAR moveobj : tsp00_MoveObj;
                    obj_pos     : integer;
                    obj_len     : integer);
 
        PROCEDURE
              a05_constant_get (
                    VAR acv       : tak_all_command_glob;
                    ni            : integer;
                    VAR colinfo   : tak00_columninfo;
                    may_be_longer : boolean;
                    mv_dest       : integer;
                    VAR dest      : tsp00_MoveObj;
                    destpos       : integer;
                    VAR actlen    : integer);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06a_mblock_init (VAR acv : tak_all_command_glob;
                    mtype        : tgg00_MessType;
                    m2type       : tgg00_MessType2;
                    VAR tree     : tgg00_FileId);
 
        PROCEDURE
              a06determine_username (VAR acv : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        FUNCTION
              a06exist_user (VAR acv : tak_all_command_glob;
                    VAR user_name    : tsp00_KnlIdentifier;
                    dstate           : tak_directory_state;
                    VAR user_rec_ptr : tak_sysbufferaddress) : boolean;
 
        PROCEDURE
              a06retpart_move (VAR acv : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
        FUNCTION
              a06role_exist (VAR acv : tak_all_command_glob;
                    VAR role_name    : tsp00_KnlIdentifier;
                    dstate           : tak_directory_state;
                    VAR role_rec_ptr : tak_sysbufferaddress) : boolean;
 
        PROCEDURE
              a06init_curr_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06finish_curr_retpart (VAR acv : tak_all_command_glob;
                    part_kind : tsp1_part_kind;
                    arg_count : tsp00_Int2);
 
        PROCEDURE
              a06get_username (VAR acv : tak_all_command_glob;
                    VAR tree_index : integer;
                    VAR username   : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06lsend_mess_buf (VAR acv : tak_all_command_glob;
                    VAR mbuf        : tgg00_MessBlock;
                    call_from_rsend : boolean;
                    VAR b_err       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_hex_uni_error (VAR acv : tak_all_command_glob;
                    uni_err     : tsp8_uni_error;
                    err_code    : tsp00_Int4;
                    to_unicode  : boolean;
                    bytestr     : tsp00_MoveObjPtr;
                    len         : tsp00_Int4 );
 
        PROCEDURE
              a07_error (VAR acv : tak_all_command_glob;
                    errorcode : tgg00_BasisError;
                    VAR nod1  : tsp00_Int2;
                    VAR nod2  : tsp00_Int2);
 
        PROCEDURE
              a07_b_put_error (VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_nb_put_error (VAR acv : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
        PROCEDURE
              a07ak_system_error (VAR acv : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        PROCEDURE
              a071_getmessagetext (
                    msgno          : tsp00_Int2;
                    VAR msgbuf     : tsp00_MoveObj;
                    VAR msglen     : tsp00_Int2;
                    VAR found      : boolean);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10_cache_delete  (VAR acv : tak_all_command_glob;
                    is_rollback : boolean);
 
        PROCEDURE
              a10get_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10next_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    stop_prefix  : integer;
                    dstate       : tak_directory_state;
                    reckind      : tsp00_C2;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10dispose (VAR acv : tak_all_command_glob;
                    VAR p : tak_role_context_ptr);
 
        PROCEDURE
              a10new (VAR acv : tak_all_command_glob;
                    obj_size : tsp00_Int4;
                    VAR p    : tak_role_context_ptr);
 
        PROCEDURE
              a10SessionCacheInit (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        FUNCTION
              a101_CheckMySqlPassword (
                    VAR acv              : tak_all_command_glob;
                    VAR password         : tsp00_Name;
                    isOldVersion         : boolean;
                    VAR receivedPassword : tsp00_C8) : boolean;
 
        PROCEDURE
              a101_DebuggerCreate (
                    VAR debuggingAcv : tak_all_command_glob;
                    VAR debuggedAcv  : tak_all_command_glob;
                    VAR listenerAcv  : tak_all_command_glob);
 
        PROCEDURE
              a101_InitSessionInfo(
                    VAR acv       : tak_all_command_glob);
 
        PROCEDURE
              a101_AddToSessionList(
                    VAR acv       : tak_all_command_glob);
 
        PROCEDURE
              a101_RemoveFromSessionList(
                    VAR acv       : tak_all_command_glob);
 
        PROCEDURE
              a101_SetSessionInfoIsolationLevel(
                    VAR acv        : tak_all_command_glob;
                    isolationLevel : tsp00_Uint1);
 
        PROCEDURE
              a101_CreateGroupedTempFile(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId;
                    tempFileType   : tgg00_TfnTemp);
 
        FUNCTION
              a101_GetExtendedTempFileType(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tgg00_TfnTemp;
 
        PROCEDURE
              a101_SetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId;
                    sublevel       : tsp00_Int4(*ptocConst*));
 
        FUNCTION
              a101_RTEMemAllocate (Size : tsp00_Int4) : tgg00_VoidPtr;
 
        FUNCTION
              a101_BasicAuthenticationAllowed (
                    VAR acv        : tak_all_command_glob) : boolean;
 
        FUNCTION
              a101_InitAuthentication (
                    VAR acv        : tak_all_command_glob;
                    VAR userName   : tsp00_KnlIdentifier;
                    isParameter    : boolean;
                    dataBuf        : tsp00_MoveObjPtr;
                    dataLength     : tsp00_Int4) : boolean;
 
        FUNCTION
              a101_VerifyAuthentication (
                    VAR acv        : tak_all_command_glob;
                    VAR userName   : tsp00_KnlIdentifier;
                    VAR pwd        : tsp00_Name;
                    dataBuf        : tsp00_MoveObjPtr;
                    dataLength     : tsp00_Int4) : boolean;
 
        PROCEDURE
              a101_ClearAuthenticationInfo (
                    VAR acv        : tak_all_command_glob);
 
        PROCEDURE
              a101_GetUsernameHostvar (
                    VAR acv        : tak_all_command_glob;
                    VAR userName   : tsp00_KnlIdentifier;
                    parameterIndex : integer);
 
        PROCEDURE
              a101_MapSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier;
                    pos            : integer);
 
        PROCEDURE
              a101_MarkUsernameAsParameter (
                    VAR acv        : tak_all_command_glob);
 
        PROCEDURE
              a101_ResetMappingInfo (
                    VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103LoadAuthorizationByName (
                    VAR acv    : tak_all_command_glob;
                    VAR name   : tsp00_KnlIdentifier;
                    useCache   : boolean;
                    VAR buf    : tak_userrecord;
                    VAR e      : tgg00_BasisError);
 
        PROCEDURE
              a103LockAuthorizationObject (
                    VAR acv        : tak_all_command_glob;
                    VAR authid     : tgg00_Surrogate;
                    lockExclusive  : boolean);
 
      ------------------------------ 
 
        FROM
              AK_usertab_tools : VAK19;
 
        PROCEDURE
              a19set_default_context (VAR acv : tak_all_command_glob;
                    role_cnt : integer);
 
        FUNCTION
              a19user_knows_role (VAR acv : tak_all_command_glob;
                    VAR user_id : tgg00_Surrogate;
                    VAR role_id : tgg00_Surrogate) : boolean;
 
      ------------------------------ 
 
        FROM
              Kernel_Sink_1 : VAK341;
 
        PROCEDURE
              ak341StartConsistentTrans (VAR Trans : tgg00_TransContext);
 
        PROCEDURE
              ak341HeapCallStackMonitoring (level : integer);
 
      ------------------------------ 
 
        FROM
              PUT-Conversions : VSP41;
 
        PROCEDURE
              s41plint (VAR buf : tsp00_Number;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              AK_Lock_Commit_Rollback : VAK52;
 
        PROCEDURE
              a52release_session (VAR acv : tak_all_command_glob;
                    normal_release : boolean);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542internal_packet (VAR acv : tak_all_command_glob;
                    release_internal_packet : boolean;
                    required_len            : tsp00_Int4);
 
        PROCEDURE
              a542move_to_packet (VAR acv : tak_all_command_glob;
                    const_addr : tsp00_MoveObjPtr;
                    const_len  : tsp00_Int4);
 
        PROCEDURE
              a542pop_packet (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              diagnose monitor : VAK545;
 
        PROCEDURE
              a545diag_parse_info (VAR acv : tak_all_command_glob;
                    VAR parsid     : tak_parsid;
                    VAR sel_parsid : tak_parsid);
 
      ------------------------------ 
 
        FROM
              Execute_factor_col_function : VAK641;
 
        PROCEDURE
              a641charset_get (VAR acv : tak_all_command_glob;
                    node          : tsp00_Int2;
                    VAR setname   : tsp00_KnlIdentifier;
                    VAR messcode  : tsp00_CodeType;
                    VAR codewidth : tsp00_Uint1);
 
        PROCEDURE
              a641get_mapcharset (VAR acv : tak_all_command_glob;
                    VAR mapcharsetname : tsp00_KnlIdentifier;
                    error_pos          : integer;
                    VAR max_maplen     : integer;
                    VAR sysbuf         : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              Execute_factor_constants : VAK642;
 
        VAR
              a642standard_colinfo : tak00_columninfo;
 
      ------------------------------ 
 
        FROM
              Execute_Select_Expression : VAK660;
 
        PROCEDURE
              a660_isolevel (VAR acv : tak_all_command_glob;
                    isolation_n    : tsp00_Int2;
                    VAR lock_state : tgg00_HandlingSet);
 
      ------------------------------ 
 
        FROM
              Deal-With-User-Commands : VAK92;
 
        PROCEDURE
              a92_mode_analyzer (VAR acv : tak_all_command_glob;
                    ddl         : tak_ddl_descriptor;
                    corr_select : boolean);
 
        PROCEDURE
              a92next_pcount (VAR acv : tak_all_command_glob;
                    VAR parsk : tak_parskey);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
        PROCEDURE
              b01tinit_temp_cache (VAR t : tgg00_TransContext;
                    is_control_session : boolean);
 
        PROCEDURE
              b01trelease_temp_cache (VAR t : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              task_temp_data_cache : VBD21;
 
        PROCEDURE
              b21mp_parse_again_put (temp_cache_ptr : tgg00_TempDataCachePtr;
                    parse_again : tsp00_C3);
 
        PROCEDURE
              b21mp_termid_put (temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR termid : tsp00_TermId);
 
        PROCEDURE
              b21mp_username_put (temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR username : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              BD_Wrapper : VBD999;
 
        FUNCTION
              bd999GetPageSize : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              KB_trans_state  : VKB50;
 
        PROCEDURE
              k50my_state (TransIndex : tgg00_TransIndex;
                    VAR IsEotExcl     : boolean;
                    VAR AuxPermExists : boolean;
                    VAR TransTaskId   : tsp00_TaskId);
 
        FUNCTION
              k50oms_have_obj_locks (TransIndex : tgg00_TransIndex) : boolean;
 
        PROCEDURE
              k50StartDbProcedure (VAR t : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              KB_locklist : VKB51;
 
        PROCEDURE
              k51new_session (VAR Trans : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              KB_transaction : VKB53;
 
        PROCEDURE
              k53StartInternalSession (
                    VAR TransContext    : tgg00_TransContext;
                    VAR AuxTransContext : tgg00_TransContext;
                    bOpenNewTrans       : boolean;
                    bInheritLocalFDir   : boolean);
 
        PROCEDURE
              k53StopInternalSession (
                    VAR TransContext    : tgg00_TransContext;
                    VAR AuxTransContext : tgg00_TransContext;
                    typeOfTransEnd      : tgg00_MessType);
 
      ------------------------------ 
 
        FROM
              KB_Logging : VKB560;
 
        PROCEDURE
              kb560CreateLogTransaction (VAR Trans : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01glob                  : tgg00_KernelGlobals;
              g01code                  : tgg04_CodeGlobals;
              g01controluser           : tgg04_ControlUser;
              g01nls_sort              : boolean;
              g01nls_default_map       : tsp00_KnlIdentifier;
              g01timeout               : tgg00_TimeoutGlobals;
              g01diag_moni_parse_on    : boolean;
              g01unicode               : boolean;
              g01ConsistentReadEnabled : boolean;
              gg01_usevariableinput    : boolean;
 
        FUNCTION
              g01catalog_cache_init_size : tsp00_Int4;
 
        FUNCTION
              g01maxuser : tsp00_Int4;
 
        PROCEDURE
              g01abort (msg_no : tsp00_Int4;
                    msg_label  : tsp00_C8;
                    msg_text   : tsp00_C24;
                    bad_value  : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Codetransformation_and_Coding : VGG02;
 
        VAR
              g02codetables : tgg04_CodeTables;
 
      ------------------------------ 
 
        FROM
              Check-Date-Time : VGG03;
 
        VAR
              g03dictionary : tsp6_dictionaries;
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04build_temp_tree_id (VAR curr : tgg00_FileId;
                    VAR t : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        PROCEDURE
              gg06SetNilRef (VAR PageRef : tgg91_PageRef);
 
      ------------------------------ 
 
        FROM
              Regions_and_Longwaits : VGG08;
 
        VAR
              g08diagcache : tsp00_RegionId;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              GG_allocator_interface : VGG941;
 
        FUNCTION
              gg941Allocate(VAR TransContext : tgg00_TransContext;
                    wantedBytes : integer) : tsp00_Addr;
 
        PROCEDURE
              gg941Deallocate(VAR TransContext : tgg00_TransContext;
                    VAR p : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              Encrypting : VSP02;
 
        PROCEDURE
              s02encrypt (VAR clearname : tsp00_Name;
                    VAR crypt : tsp00_CryptPw);
 
        PROCEDURE
              s02decrypt (
                    VAR clearname : tsp00_Name;
                    VAR crypt     : tsp00_CryptPw);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20int4_to_buf_swap (val     : tsp00_Int4;
                    source_swap : tsp00_SwapKind;
                    VAR destin  : tsp00_C4;
                    destin_pos  : tsp00_Int4;
                    destin_swap : tsp00_SwapKind);
 
        FUNCTION
              s20buf_to_int4_swap (VAR source : tsp00_C4;
                    si             : tsp00_Int4;
                    sourceswap     : tsp00_SwapKind;
                    destswap       : tsp00_SwapKind) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26new_part_init (packet_ptr : tsp1_packet_ptr;
                    VAR segm               : tsp1_segment;
                    VAR new_part_ptr       : tsp1_part_ptr);
 
        PROCEDURE
              s26find_part (VAR segm : tsp1_segment;
                    part_kind        : tsp1_part_kind;
                    VAR part_ptr     : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30lnr_defbyte (str : tsp00_MoveObjPtr;
                    defbyte   : char;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              date_time_formatting : VSP78;
 
        PROCEDURE
              s78language (VAR dictionary : tsp6_dictionaries;
                    VAR language_name : tsp00_C3;
                    VAR language_no   : tsp6_language;
                    for_init          : boolean;
                    VAR is_ok         : boolean);
 
        PROCEDURE
              s78df_analyze (format_addr : tsp00_MoveObjPtr;
                    format_len     : tsp00_Int2;
                    dest_addr      : tsp00_MoveObjPtr;
                    VAR dest_len   : tsp00_Int2;
                    to_date_format : boolean;
                    VAR e          : tsp6_date_error);
 
        PROCEDURE
              s78df_clear (VAR dictionary : tsp6_dictionary;
                    format_addr    : tsp00_MoveObjPtr;
                    format_len     : integer;
                    dest_addr      : tsp00_MoveObjPtr;
                    dest_size      : integer);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80 : VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Version : VSP100;
 
        PROCEDURE
              sp100_GetSenderIDVersionP  (
                    VAR SenderIDP  : tsp00_C5 );
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vbegexcl (pid : tsp00_TaskId;
                    region  : tsp00_RegionId);
 
        PROCEDURE
              vendexcl (pid : tsp00_TaskId;
                    region  : tsp00_RegionId);
 
        PROCEDURE
              vcinit (pid : tsp00_TaskId);
 
        FUNCTION
              vGetAcvPtrFromCurrentTask : tak_acv_address;
 
        PROCEDURE
              vioinit (pid : tsp00_TaskId);
 
        PROCEDURE
              vdcom_init_sink (VAR sink_info : tsp_dcom_init_sink_parms);
 
        PROCEDURE
              vtime_in_seconds (VAR time_in_sec : tsp00_Int4);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              a103LoadAuthorizationByName;
 
              tsp00_Buf tak_userrecord
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              a10new;
 
              tak_sysbufferaddress tak_role_context_ptr
 
        PROCEDURE
              a10dispose;
 
              tak_sysbufferaddress tak_role_context_ptr
 
        PROCEDURE
              s20int4_to_buf_swap;
 
              tsp00_MoveObj tsp00_C4
 
        PROCEDURE
              s20buf_to_int4_swap;
 
              tsp00_MoveObj tsp00_C4
 
        PROCEDURE
              s41plint;
 
              tsp00_MoveObj   tsp00_Number
&             ifdef trace
 
        PROCEDURE
              t01moveobj;
 
              tsp00_MoveObj tsp00_C120
&             endif
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ElkeZ
.sp
.cp 3
Created : 1985-02-07
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-09-26
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
Description:
.sp 2
A51_ACONNECT_STATEMENT
.sp
The syntax of the Connect Statement is checked, with it being allowable for the
user name to occur in the form of a name or with the entry of a parameter, the
password only in the form of the entry of a parameter. The entries relating to
the lock mode and timeout information are optional.
.sp 2;A51_SET_STATEMENT
.sp
By means of this command, it is possible to convert the language in which error
messages are output. The language itself is given in part2 of the SQL-PACKET.
 
.sp 2;A51_CURRENT_USER
.sp
The command CURRENT USER is legal only together with the messagetype
m_abschema. This makes the kernel believe that it is dealing with another
connected user without the original
user having to re-connect. This command is required
for the schema unloading and reloading tool, so that the current user, who,
after all, is recorded as the owner of the object, can be converted before
Create Table/View/User Statements. The user name itself is in part2 of the
SQL_PACKET.
.sp 2;A51_CONNECT
.sp
The processing of all three commands takes place in this procedure.
.br;For SET LANG the language (3-byte-long data entry,
4-byte long with Undef-Byte)
is transferred to the variable provided for it.
.br;The other two commands may be parsed only if the user is already connected
(current_auth_id <> blankusername).
.br;The user name is fetched from the command or data part (ak51get_userval); for a
CONNECT, the password is fetched from the data part and a new session is
started with a new session number and the next transaction number.
.br;Entries are made in elements of the ACV, with maximum values applying to
the SUPERDBA; for other users, these values are taken from the user record,
with it being checked at the same time, of course, whether this user with the
password exists at all (CHECK_USER_PW).
.br;The user is written into the list of currently connected users, with it
being checked whether this user name is already contained in the list, which
leads to an error if EXCLUSIVE is specified for this user.
.br;The names for various files (SHOW Result, File for the entries that are
necessary for the physical building of views, file for parsing information and
system information on result sets, result file for unnamed result sets, file to
which results of SELECT...INTO can be stored intermediately)
are formed and the files are created. The result files are created
during CONNECT
and are thereafter simply filled and emptied in order to dispense with the need
for entries in the file directory and the I/O when a temporary file is deleted.
.br;The array for the result sets is initialized.
.br;Depending on Lock mode (Default = NORMAL), an entry is made in a variable
that is passed as far as KB.
.br;An entry is made in the user-specific command timeout.
.br;If desired,
.br;KB is informed by a message buffer which user has been connected (for
AUDIT).
.br;If an error has occurred, the user is removed from the list of current
users, the files are deleted and KB receives a rollback request.
.sp 2;A51_CREATE_FILE
.sp
Contains only the creation of a file and the handling of errors.
.sp 2;A51SEARCH_USER
.sp
A search is made in the alphabetically arranged list of currently connected
users for where the user name should be and whether it is already contained.
 
.sp 2;A51_INSERT_USER
.sp
An attempt is made to enter the new user in the list of currently connected
users. If the command CURRENT USER is used, a search must not be
made in the list if, through this User-Change command, it is intended only to
return to the originally connected user.
.br;The readable terminalid is entered, code-converted, in the array in order
to be able to output it in SHOW USER CURRENT, so that a distinction can be made
between several users of the same name.
.sp 2;AK51GET_USERVAL
.sp
The 8-byte (+ 1 byte Undef-Byte)-long user name is fetched from the data part
of the SQL_PACKET and is passed, code-converted, to the outside.
.sp 2;AK51GET_PASSWORD
.sp
The password (encrypted as 24 bytes (+ 1 byte Undef-Byte)) is fetched from the
data part of the request segment. In G03PART2_DECRYPT, it is integer-swapped
(the 24 Bytes represent 6 int4), decrypted and code-converted. Since the
encryption in the SQL_PACKET is different from that in the database, (data
protection), the clearly readable PW must again be encrypted, so that the
comparisons can be made with the entries in the database.
.sp 2;CKECK_USER_PW
.sp
The system-information record for this user name is fetched. If it does not
exist, there is no user of this name. If it exists, it may still be the case
that this is a user-group sysinfo record (NOT is_user_rec in urecordtyp). A
user may not be connected with this user-group name either.
.br;If everything is O.K., the timeout and limit values are transferred to the
associated variables in the ACV.
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      ascii_e = 69;
      ascii_n = 78;
      ascii_g = 71;
      c_null_allowed    = true (* a03_avalue_spec *);
      c_stamp_allowed   = true (* a03_avalue_spec *);
      c_default_allowed = true (* a03_avalue_spec *);
      c_sysuser_allowed = true (* a03_avalue_spec *);
      c_call_from_rsend = true (* a06lsend_mess_buf *);
      c_trans_to_uni    = true (* a07_hex_uni_error *);
      c_unicode         = true (* a51get_date_format *);
      c_normal_release  = true (* a52release_session *);
      c_release_packet  = true (* a542internal_packet *);
      c_corr_select     = true (* a92_mode_analyzer *);
      c_for_init        = true (* g03language *);
      c_to_date_format  = true (* s78df_analyze *);
      c_unicode_wid     =  2;  (* a07_hex_uni_err *)
      c_inherit_locfdir = true (* PTS 1132447 FF*);
 
TYPE
      tak51head           = ARRAY[0..csp_maxint2] OF tak_size_ptr;
      tak51head_addr      = ^tak51head;
 
      tak51_SwitchUserContext = RECORD
            su_curr_user_name  : tsp00_KnlIdentifier;
            su_curr_user_id    : tgg00_Surrogate;
            su_userkind        : tak_usertyp;
            su_curr_schema_set : boolean;
            su_defaultcode     : tsp00_CodeType;
            su_curr_schema     : tsp00_KnlIdentifier;
            su_curr_schema_id  : tgg00_Surrogate;
      END;
 
 
VAR
      ak51free        : tak_size_ptr;
      ak51head        : tak51head_addr;
      ak51CurrIndex   : integer;
      ak51CurListPtr  : tak_size_ptr;
 
 
(*------------------------------*) 
 
PROCEDURE
      a51semantic (VAR acv : tak_all_command_glob);
 
CONST
      select_from_dual  = 'SELECT INTO :A FROM DUAL';
 
VAR
      commandExecuted : boolean;
      i               : integer;
      c24             : tsp00_C24;
      orig_buf        : tsp00_MoveObjPtr;
      orig_len        : tsp00_Int4;
      request_len     : tsp00_Int4;
      curr_n          : tsp00_Int2;
      iso_level       : tsp00_Uint1;
      h_language      : tsp00_C3;
      parseid         : tak_parsid;
      parsid          : tsp00_C12;
 
BEGIN
commandExecuted := false;
WITH acv DO
    CASE a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc OF
        cak_x_set_format :
            (* PTS 1115654 E.Z. *)
            IF  a_ex_kind <> only_parsing
            THEN
                BEGIN
                WITH a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ] DO
                    IF  n_length = ord(dtf_normal)
                    THEN
                        a_dt_format := dtf_normal
                    ELSE
                        IF  n_length = ord(dtf_iso)
                        THEN
                            a_dt_format := dtf_iso
                        ELSE
                            IF  n_length = ord(dtf_usa)
                            THEN
                                a_dt_format := dtf_usa
                            ELSE
                                IF  n_length = ord(dtf_eur)
                                THEN
                                    IF  a_session_sqlmode = sqlm_oracle
                                    THEN
                                        (* for this debis-project *)
                                        a_dt_format := dtf_ts_eur
                                    ELSE
                                        a_dt_format := dtf_eur
                                    (*ENDIF*) 
                                ELSE
                                    IF  n_length = ord(dtf_jis)
                                    THEN
                                        a_dt_format := dtf_jis
                                    ELSE
                                        IF  n_length = ord (dtf_oracle_date)
                                        THEN
                                            a_dt_format := dtf_oracle_date;
                                        (* PTS 1112472 E.Z. *)
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
        cak_x_set_lang :
            BEGIN
            IF  ((a_data_length <> 4) AND
                NOT (a_cmd_packet_header.sp1h_mess_code in
                [ csp_unicode_swap, csp_unicode ]))
                OR
                ((a_data_length <> (2 * 3) + 1) AND
                (a_cmd_packet_header.sp1h_mess_code in
                [ csp_unicode_swap, csp_unicode ]))
            THEN
                a07_b_put_error (acv, e_invalid_datalength, 1)
            ELSE
                BEGIN
                h_language    := a_ak_language;
                a_ak_language := '   ';
                IF  a_cmd_packet_header.sp1h_mess_code in
                    [ csp_unicode_swap, csp_unicode ]
                THEN
                    FOR i := 1 TO 3 DO
                        BEGIN
                        IF  a_data_ptr^[ 2*i ] <> csp_unicode_mark
                        THEN
                            BEGIN
                            a07_b_put_error (acv, e_incompatible_datatypes, 1);
                            a_ak_language := h_language
                            END
                        ELSE
                            a_ak_language[ i ] := a_data_ptr^[ 2*i + 1 ];
                        (*ENDIF*) 
                        END
                    (*ENDFOR*) 
                ELSE
                    FOR i := 1 TO 3 DO
                        a_ak_language[ i ] := a_data_ptr^[ 1 + i ];
                    (*ENDFOR*) 
                (*ENDIF*) 
                ak51get_row_not_found_text (acv);
                END;
            (*ENDIF*) 
            END;
        cak_x_set_degree :
            ak51set_degree (acv);
        cak_x_set_role :
            ak51set_role (acv);
        cak_x_get_special_register :
            WITH a_ap_tree^[ a_ap_tree^[ a_ap_tree^[ 0 ].
                 n_lo_level ].n_lo_level ] DO
                BEGIN
                c24         := select_from_dual;
                orig_buf    := @a_cmd_part^.sp1p_buf;
                orig_len    := a_cmd_part^.sp1p_buf_len;
                IF  g01unicode
                THEN
                    BEGIN
                    a01char_size := 2;
                    request_len := orig_len + 51 - n_pos
                    END
                ELSE
                    BEGIN
                    a01char_size := 1;
                    request_len := orig_len + 26 - n_pos;
                    END;
                (*ENDIF*) 
                a542internal_packet (acv,
                      NOT c_release_packet, request_len);
                IF  a_returncode = 0
                THEN
                    BEGIN
                    a542move_to_packet (acv, @c24[1], 7);
                    SAPDB_PascalOverlappingMove ('VAK51 ',   1,    
                          orig_len, request_len,
                          @orig_buf^, n_pos, @a_cmd_part^.sp1p_buf,
                          (7*a01char_size)+1, orig_len + 1 - n_pos,
                          a_returncode);
                    IF  a_returncode = 0
                    THEN
                        BEGIN
                        a_cmd_part^.sp1p_buf_len :=
                              a_cmd_part^.sp1p_buf_len + orig_len + 1 - n_pos;
                        a542move_to_packet (acv, @c24[7], 18);
&                       ifdef TRACE
                        t01segment (ak_sem, a_cmd_segm^);
&                       endif
                        a_cmd_segment_header := a_cmd_segm^.sp1s_segm_header;
                        a_cmd_packet_header  := a_in_packet^.sp1_header;
                        a92_mode_analyzer (acv, no_ddl, NOT c_corr_select);
                        a542pop_packet  (acv);
                        END;
                    (*ENDIF*) 
                    a_return_segm^.sp1r_function_code := csp1_set_fc
                    END
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        cak_x_set_isolevel :
            BEGIN
            iso_level := a_iso_level;
            a_iso_level := csp_maxint1;
            curr_n := a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
            a660_isolevel (acv, curr_n, a_transinf.tri_global_state);
            IF  a_returncode = 0
            THEN
                BEGIN
                IF  a_ex_kind = only_parsing
                THEN
                    BEGIN
                    parseid.pid_session.ci4_gg00 := cgg_zero_session;
                    FOR i := 1 TO sizeof (parseid.pid_parsk.p_count) DO
                        parseid.pid_parsk.p_count[i] := chr(0);
                    (*ENDFOR*) 
                    parseid.pid_parsk.p_id    := chr (0);
                    parseid.pid_parsk.p_kind  := m_nil;
                    parseid.pid_parsk.p_no    := 0;
                    parseid.pid_appl_info[1]  := chr (csp1_p_command_executed);
                    parseid.pid_dtime_info[1] := chr (0);
                    a06retpart_move (acv, @parseid, mxak_parsid);
                    a06finish_curr_retpart (acv, sp1pk_parsid, 1);
                    a06init_curr_retpart   (acv);
                    a06finish_curr_retpart (acv, sp1pk_shortinfo, 0)
                    END
                (*ENDIF*) 
                END
            ELSE
                a_iso_level := iso_level;
            (*ENDIF*) 
            a101_SetSessionInfoIsolationLevel (acv, a_iso_level);
            END;
        cak_x_nls_date_format:
            BEGIN
            commandExecuted := true;
            ak51nls_support (acv);
            END;
        cak_x_set_session_trace:
            ak51session_trace (acv);
        cak_x_set_session_unicode : (* PTS 1118814 T.A. *)
            BEGIN
            commandExecuted       := true;
            a_pseudoUnicodeClient := true;
            END;
        cak_x_set_session_replication :
            ak51session_replication (acv, commandExecuted);
        cak_x_authentication_init:
            ak51init_authentication (acv);
        OTHERWISE
            (* cak_x_connect *)
            a51_connect (acv);
        END;
    (*ENDCASE*) 
(*ENDWITH*) 
IF  (acv.a_ex_kind = only_parsing) AND commandExecuted
THEN
    BEGIN
    FOR i := 1 TO sizeof(parsid) DO
        parsid[ i ] := csp_defined_byte;
    (*ENDFOR*) 
    parsid[ sizeof(parsid)-1 ] := chr(csp1_p_command_executed);
    a06retpart_move (acv, @parsid, sizeof(parsid));
    a06finish_curr_retpart (acv, sp1pk_parsid, 1);
    a06init_curr_retpart   (acv);
    a06finish_curr_retpart (acv, sp1pk_shortinfo, 0)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51SetDebugSession (
            VAR acv  : tak_all_command_glob;
            session  : tgg91_SessionNo;
            listener : tgg91_SessionNo);
 
VAR
      ix          : integer;
      curr        : tak_size_ptr;
      debugAcv    : tak_acv_address;
      listenerAcv : tak_acv_address;
 
BEGIN
debugAcv    := NIL;
listenerAcv := NIL;
vbegexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
ix := 0;
WHILE ix <= g01maxuser DO
    BEGIN
    curr := ak51head^[ix];
    WHILE curr <> NIL DO
        BEGIN
        IF  curr^.csz_session = session
        THEN
            debugAcv := curr^.csz_acv
        ELSE
            IF  curr^.csz_session = listener
            THEN
                listenerAcv := curr^.csz_acv;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  (debugAcv <> NIL) AND (listenerAcv <> NIL)
        THEN
            BEGIN
            IF  (debugAcv = @acv) OR (listenerAcv = @acv) OR
                (acv.a_curr_user_id <> debugAcv^.a_curr_user_id)
            THEN
                a07_b_put_error (acv, e_missing_privilege, 1);
            (*ENDIF*) 
            a101_DebuggerCreate (acv, debugAcv^, listenerAcv^);
            curr := NIL;
            ix   := csp_maxint2 - 1;
            END
        ELSE
            curr := curr^.csz_next;
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    ix := ix + 1;
    END;
(*ENDWHILE*) 
vendexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
IF  ix <> csp_maxint2
THEN
    a07_b_put_error (acv, e_unknown_session, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51alloc_cache_size_info (VAR acv : tak_all_command_glob);
 
VAR
      head_index : integer;
      absval     : tsp00_Int4;
 
BEGIN
acv.a_size_ptr := NIL;
vbegexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
IF  ak51free <> NIL
THEN
    BEGIN
    acv.a_size_ptr := ak51free;
    ak51free       := ak51free^.csz_next;
    WITH acv.a_size_ptr^ DO
        BEGIN
        csz_session := acv.a_transinf.tri_trans.trSessionId_gg00;
        csz_acv     := NIL;
        absval      := abs (s20buf_to_int4_swap (csz_session.ci4_gg00, 1, sw_normal,
              g01code.kernel_swap));
        head_index := absval MOD (g01maxuser + 1);
&       ifdef TRACE
        t01int4 (ak_sem, 'head_index  ', head_index);
&       endif
        csz_next              := ak51head^[head_index];
        ak51head^[head_index] := acv.a_size_ptr;
        csz_ak_cache          := g01catalog_cache_init_size DIV sizeof (tsp00_Buf);
        (* PTS 1115043 E.Z. *)
        (* PTS 1115978 E.Z. *)
        csz_tracelevel        := 0;
        END;
    (*ENDWITH*) 
    END
ELSE
    a07ak_system_error (acv, 51, 1);
(*ENDIF*) 
vendexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51arole_list (VAR acv : tak_all_command_glob;
            check_identified_clause : boolean;
            VAR put_node : tsp00_Int2;
            VAR last_n   : tsp00_Int2);
 
VAR
      dummy_n : tsp00_Int2;
 
BEGIN
put_node := 0;
REPEAT
    IF  put_node = 0
    THEN
        a02_put_identifier (acv, put_node, last_n)
    ELSE
        BEGIN
        a01_next_symbol    (acv);
        a02_put_identifier (acv, acv.a_ap_tree^[last_n].n_sa_level, last_n);
        END;
    (*ENDIF*) 
    IF  (acv.a_scv.sc_symb <> s_comma) AND
        (acv.a_scv.sc_symb <> s_eof  ) AND
        check_identified_clause
    THEN
        IF  a01mandatory_keyword (acv, cak_i_identified)
        THEN
            IF  a01mandatory_keyword (acv, cak_i_by)
            THEN
                a02_put_identifier (acv,
                      acv.a_ap_tree^[last_n].n_lo_level, dummy_n);
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
UNTIL
    (* PTS 1102343 E.Z. *)
    (acv.a_returncode <> 0) OR
    (acv.a_scv.sc_symb <> s_comma);
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51compare_passwords (
            VAR acv             : tak_all_command_glob;
            VAR connect_rec     : tak_connect_rec;
            VAR cryptedpwd      : tsp00_CryptPw;
            VAR passwordMatch   : boolean);
 
VAR
      password        : tsp00_Name;
 
BEGIN
IF  acv.a_authentication <> NIL
THEN
    BEGIN
    IF  acv.a_data_ptr <> NIL
    THEN
        BEGIN
        s02decrypt (password, cryptedpwd);
        passwordMatch := a101_VerifyAuthentication (acv,
              connect_rec.cn_username, password,
              acv.a_data_ptr, acv.a_data_length);
        END
    ELSE
        passwordMatch := false;
    (*ENDIF*) 
    END
ELSE
    BEGIN
    passwordMatch := (connect_rec.cn_password = cryptedpwd);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51check_user_pw (VAR acv : tak_all_command_glob;
            VAR connect_rec      : tak_connect_rec;
            change_curr_user     : boolean;
            check_password       : boolean;
            VAR role_info        : tak_role_info;
            VAR default_role_cnt : integer;
            VAR exclusive        : boolean;
            VAR max_timeout      : tsp00_Int4;
            VAR cache_size       : tsp00_Int4);
 
CONST
      c_use_cache = true;
 
VAR
      b_err           : tgg00_BasisError;
      passwordMatch   : boolean;
      password        : tsp00_Name;
      group_buf       : tak_sysbufferaddress;
      pUser           : tak_sysbufferaddress;
      userBuf         : tak_userrecord;
      userkey         : tgg00_SysInfoKey;
 
BEGIN
cache_size := 0; (* temp cache not supported *)
exclusive  := true;
IF  a06exist_user (acv, connect_rec.cn_username, d_fix, pUser)
THEN
    IF  NOT pUser^.suser.userconnect AND NOT pUser^.suser.usersysdba
    THEN
        a07_b_put_error (acv, e_connection_disabled, 1)
    ELSE
        WITH acv DO
            BEGIN
            a_acc_user_id := pUser^.suser.usurrogate;
            IF  change_curr_user AND
                NOT (is_user_rec in pUser^.suser.urecordtyp)
            THEN
                ak51find_group_member (acv, pUser);
            (*ENDIF*) 
            IF  pUser^.suser.usersysdba
            THEN
                BEGIN
                (* the sysdba is cached in the catalog instance, the password may be out of date *)
                a103LoadAuthorizationByName (acv, connect_rec.cn_username, NOT c_use_cache, userBuf, b_err);
                pUser := @userBuf;
                IF  b_err <> e_ok
                THEN
                    a07ak_system_error (acv, 51, 3);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            ak51compare_passwords (acv, connect_rec, pUser^.suser.userpassw, passwordMatch);
            IF  NOT passwordMatch AND ( pUser^.suser.usupportpasspw <> bsp_c24)
            THEN
                ak51compare_passwords (acv, connect_rec, pUser^.suser.usupportpasspw, passwordMatch);
            (*ENDIF*) 
            a101_ClearAuthenticationInfo (acv);
            IF  check_password
                AND
                (
                NOT passwordMatch
                OR
                NOT (is_user_rec in pUser^.suser.urecordtyp)
                )
            THEN
                a07_b_put_error (acv, e_unknown_user_password_pair, 1)
            ELSE
                BEGIN
                IF  NOT (is_group_rec in pUser^.suser.urecordtyp)
                THEN
                    BEGIN
                    a_curr_user_id   := pUser^.suser.usergroup_id;
                    userkey          := pUser^.syskey;
                    userkey.sauthid  := pUser^.suser.usergroup_id;
                    a10get_sysinfo (acv, userkey,
                          d_release, group_buf, b_err);
                    IF  b_err = e_ok
                    THEN
                        BEGIN
                        a_curr_user_name := group_buf^.suser.username;
                        a_acc_groupname  := a_curr_user_name
                        END
                    ELSE
                        a07_b_put_error (acv, b_err, 1)
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    a_curr_user_id   := pUser^.suser.usurrogate;
                    a_acc_groupname  := a01_il_b_identifier;
                    a_curr_user_name := a_acc_user
                    END;
                (*ENDIF*) 
                IF  pUser^.suser.usersysdba
                THEN
                    a_current_user_kind := usysdba
                ELSE
                    a_current_user_kind := pUser^.suser.userkind;
                (*ENDIF*) 
                a_acc_dba_id := pUser^.suser.userowner_id;
                IF  (a_current_user_kind = uprivate) OR
                    (a_current_user_kind = unoprivate)
                THEN
                    a06determine_username (acv,
                          a_acc_dba_id, a_acc_dbaname)
                ELSE
                    IF  a_current_user_kind = udba
                    THEN
                        a_acc_dbaname := g01glob.sysuser_name
                    ELSE
                        a_acc_dbaname := a01_il_b_identifier;
                    (*ENDIF*) 
                (*ENDIF*) 
                a_user_perm_ref         := pUser^.suser.uperm_ref;
                default_role_cnt        := pUser^.suser.userrolecnt;
                exclusive               := pUser^.suser.uexclusive;
                max_timeout             := pUser^.suser.uparams[ maxtimeout ];
                IF  max_timeout = csp_maxint4
                THEN
                    max_timeout := g01timeout.timeCmd_gg00;
                (*ENDIF*) 
                a_costwarn_value  := pUser^.suser.uparams[ costwarning ];
                a_costlimit_value := pUser^.suser.uparams[ costlimit ];
                role_info         := pUser^.suser.userroleinfo;
                IF  a_current_user_kind in [udba, usysdba]
                THEN (* DBAROLE *)
                    default_role_cnt := default_role_cnt + 1;
                (* PTS 1117216 E.Z. *)
                (*ENDIF*) 
                IF  pUser^.suser.userchardefcode = csp_instance_code
                THEN
                    a_defaultcode := g01code.char_default
                ELSE
                    a_defaultcode := pUser^.suser.userchardefcode;
                (*ENDIF*) 
                a_isReplicationUser := pUser^.suser.ureplication;
                END
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    (*ENDIF*) 
ELSE
    a07_b_put_error (acv, e_unknown_user_password_pair, 1);
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    IF  NOT change_curr_user
    THEN
        BEGIN
        (* no check for log full needed any more    *)
        (* normal tasks and dbm will run in suspend *)
        (* if they need log, even dbm               *)
        (* It can use another task, therefore this  *)
        (* is no problem any more                   *)
        a51inc_ak_cache_size (acv.a_size_ptr, cache_size)
        END
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51connect_messbuf (VAR acv : tak_all_command_glob;
            m2_type : tgg00_MessType2);
 
VAR
      site      : tgg00_ServerdbNo;
 
BEGIN
a06a_mblock_init (acv, m_connect, m2_type, b01niltree_id);
WITH acv DO
    BEGIN
    SAPDB_PascalMove ('VAK51 ',   2,    
          sizeof(a_acc_user), acv.a_mblock.mb_data_size,
          @a_acc_user, 1, @acv.a_mblock.mb_data^.mbp_buf, 1,
          sizeof(a_acc_user), a_returncode);
    SAPDB_PascalMove ('VAK51 ',   3,    
          sizeof(a_acc_termid), acv.a_mblock.mb_data_size,
          @a_acc_termid, 1, @acv.a_mblock.mb_data^.mbp_buf,
          sizeof (a_acc_user) + 1, mxsp_termid,
          a_returncode);
    site := cgg_zero_c2;
    acv.a_mblock.mb_data^.mbp_buf[sizeof (a_acc_user) + mxsp_termid+1 ] := site[ 1 ];
    acv.a_mblock.mb_data^.mbp_buf[sizeof (a_acc_user) + mxsp_termid+2 ] := site[ 2 ];
    SAPDB_PascalMove ('VAK51 ',   4,    
          SURROGATE_MXGG00, acv.a_mblock.mb_data_size,
          @a_acc_user_id, SURROGATE_MXGG00 - USERID_MXGG04 + 1,
          @acv.a_mblock.mb_data^.mbp_buf,
          sizeof (a_acc_user) + mxsp_termid + SITE_MXGG04 + 1,
          USERID_MXGG04, a_returncode);
    acv.a_mblock.mb_data_len  := sizeof (a_acc_user) + mxsp_termid +
          SITE_MXGG04 + USERID_MXGG04 + 1;
    (* PTS 1113190 E.Z. *)
    acv.a_mblock.mb_data^.mbp_buf[acv.a_mblock.mb_data_len] := chr (ord (false))
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51create_file (VAR acv : tak_all_command_glob;
            VAR current : tgg00_FileId);
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    a101_CreateGroupedTempFile (acv.a_transinf.tri_trans, current,
          a101_GetExtendedTempFileType (acv, current));
    IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        IF  acv.a_transinf.tri_trans.trError_gg00 = e_no_more_temp_space
        THEN
            a07_b_put_error (acv, e_no_more_user_temp_space, 1)
        ELSE
            a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51find_group_member (VAR acv : tak_all_command_glob;
            VAR buf : tak_sysbufferaddress);
 
VAR
      b_err    : tgg00_BasisError;
      found    : boolean;
      init_buf : tak_sysbufferaddress;
      group_id : tgg00_Surrogate;
      sysk     : tgg00_SysInfoKey;
 
BEGIN
init_buf  := buf;
group_id  := buf^.syskey.sauthid;
sysk      := buf^.syskey;
found     := false;
REPEAT
    a10next_sysinfo (acv, sysk, 0, d_release,
          cak_euser, buf, b_err);
    IF  b_err = e_ok
    THEN
        IF  buf^.suser.usergroup_id = group_id
        THEN
            found := true;
        (*ENDIF*) 
    (*ENDIF*) 
UNTIL
    found OR (b_err <> e_ok);
(*ENDREPEAT*) 
IF  b_err <> e_ok
THEN
    IF  b_err = e_no_next_record
    THEN
        buf := init_buf
    ELSE
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51get_row_not_found_text (VAR acv : tak_all_command_glob);
 
CONST
      c_row_not_found_msgno  = 100;
 
VAR
      found        : boolean;
      in_len       : integer;
      msglen       : integer;
      errlen       : tsp00_Int2;
      e            : tsp8_uni_error;
      err_char_no  : tsp00_Int4;
 
BEGIN
WITH acv DO
    BEGIN
    (* The errormessages are always written in ASCII or in UNICODE.   *)
    a_len_row_not_found_text := 0;
    found := false;
    a071_getmessagetext (c_row_not_found_msgno, a_mblock.mb_data^.mbp_buf, errlen, found);
    IF  found
    THEN
        BEGIN
        msglen := errlen;
        IF  (a_out_packet^.sp1_header.sp1h_mess_code = csp_unicode)
            OR
            (a_out_packet^.sp1_header.sp1h_mess_code = csp_unicode_swap)
        THEN
            BEGIN
            in_len := msglen;
            msglen := sizeof(a_row_not_found_text);
            s80uni_trans (@a_mblock.mb_data^.mbp_buf[ 1 ], in_len,
                  csp_ascii, @a_row_not_found_text, msglen,
                  a_out_packet^.sp1_header.sp1h_mess_code, [ ],
                  e, err_char_no);
            END
        ELSE
            SAPDB_PascalMove ('VAK51 ',   5,    
                  a_mblock.mb_data_size,
                  sizeof (a_row_not_found_text),
                  @a_mblock.mb_data^.mbp_buf, 1,
                  @a_row_not_found_text, 1, msglen,
                  a_returncode);
        (*ENDIF*) 
        a_len_row_not_found_text := msglen;
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51get_userval (VAR acv : tak_all_command_glob;
            VAR user : tsp00_KnlIdentifier);
 
VAR
      identifier_len : integer;
      uni_error      : tsp8_uni_error;
      err_char_no    : tsp00_Int4;
 
BEGIN
WITH acv DO
    BEGIN
    identifier_len := sizeof (user);
    IF  g01unicode
    THEN
        BEGIN
        s80uni_trans (@a_data_ptr^[ a_input_data_pos + 1 ], identifier_len,
              a_cmd_packet_header.sp1h_mess_code,
              @user, identifier_len, csp_unicode,
              [ ], uni_error, err_char_no);
        IF  (uni_error <> uni_ok) AND (uni_error <> uni_dest_too_short)
        THEN
            a07_hex_uni_error (acv, uni_error, err_char_no,
                  c_trans_to_uni, @a_data_ptr^[a_input_data_pos+err_char_no],
                  a_max_codewidth)
        (*ENDIF*) 
        END
    ELSE
        SAPDB_PascalMove ('VAK51 ',   6,    
              sizeof(a_data_ptr^), sizeof(user),
              @a_data_ptr^, a_input_data_pos+1, @user, 1,
              identifier_len, a_returncode);
    (*ENDIF*) 
    a_input_data_pos := a_input_data_pos + 1 + identifier_len
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51nls_support (VAR acv : tak_all_command_glob);
 
CONST
      c_use_cache = true;
      c_exclusive = true;
 
VAR
      is_ok       : boolean;
      e           : tgg00_BasisError;
      date_err    : tsp6_date_error;
      sa_level_n  : integer;
      curr_n      : integer;
      dest_pos    : integer;
      ix          : integer;
      dummy_len   : integer;
      dummy_buf   : tak_sysbufferaddress;
      param_ptr   : tsp00_MoveObjPtr;
      nls_params  : tak_nls_param_rec;
      forbidden   : tak_charset;
      format_buf  : tsp00_C50;
      format_len  : tsp00_Int2;
      language_no : tsp6_language;
      schema      : tsp00_KnlIdentifier;
      schemaBuf   : tak_userrecord;
 
BEGIN
sa_level_n :=
      acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level].n_sa_level;
nls_params := acv.a_nls_params;
param_ptr  := @nls_params.date_format;
WHILE sa_level_n <> 0 DO
    BEGIN
    curr_n := acv.a_ap_tree^[sa_level_n].n_lo_level;
    CASE acv.a_ap_tree^[sa_level_n].n_subproc OF
        cak_i_current_schema :
            BEGIN
            a05identifier_get (acv, curr_n, sizeof (schema), schema);
            a101_MapSchemaName (acv, schema, acv.a_ap_tree^[curr_n].n_pos);
            a101_ResetMappingInfo (acv);
            a103LoadAuthorizationByName (acv, schema, NOT c_use_cache, schemaBuf, e);
            IF  (e = e_ok) AND NOT (is_role_rec in schemaBuf.urecordtyp)
            THEN
                BEGIN
                a103LockAuthorizationObject (acv, schemaBuf.usurrogate, NOT c_exclusive);
                a103LoadAuthorizationByName (acv, schema, NOT c_use_cache, schemaBuf, e);
                IF  e <> e_ok
                THEN
                    a07_nb_put_error (acv, e_unknown_name,
                          acv.a_ap_tree^[curr_n].n_pos, schema)
                ELSE
                    BEGIN
                    vbegexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
                    acv.a_curr_schema     := schema;
                    acv.a_curr_schema_id  := schemaBuf.usurrogate;
                    acv.a_curr_schema_set := acv.a_curr_user_id <> acv.a_curr_schema_id;
                    vendexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
                    END
                (*ENDIF*) 
                END
            ELSE
                a07_nb_put_error (acv, e_unknown_name,
                      acv.a_ap_tree^[curr_n].n_pos, schema);
            (*ENDIF*) 
            END;
        cak_i_nls_date_format :
            BEGIN
            is_ok := acv.a_ap_tree^[curr_n].n_length <=
                  sizeof (acv.a_nls_params.date_format) * a01char_size;
            IF  is_ok
            THEN
                BEGIN
                format_buf[ 1 ] := csp_ascii_blank;
                param_ptr  := @format_buf;
                a05string_literal_get (acv, curr_n, dcha,
                      param_ptr^, 2, sizeof (format_buf)-1);
                is_ok := acv.a_returncode = 0
                END;
            (*ENDIF*) 
            IF  is_ok
            THEN
                BEGIN
                dest_pos   := 1;
                format_len := s30lnr_defbyte (@format_buf,
                      csp_ascii_blank, 1, sizeof (nls_params.date_format));
                nls_params.df_length := sizeof (nls_params.date_format);
                s78df_analyze (@format_buf, format_len,
                      @nls_params.date_format, nls_params.df_length,
                      c_to_date_format, date_err);
                is_ok := date_err = sp6de_ok
                END;
            (*ENDIF*) 
            IF  NOT is_ok
            THEN
                a07_b_put_error (acv, e_date_time_format_invalid,
                      acv.a_ap_tree^[ curr_n ].n_pos)
            (*ENDIF*) 
            END;
        cak_i_nls_date_language,
        cak_i_nls_language:
            WITH nls_params DO
                BEGIN
                IF  acv.a_ap_tree^[ curr_n ].n_length >
                    sizeof (acv.a_nls_params.date_language)*a01char_size
                THEN (* Look only at the first three chars. *)
                    acv.a_ap_tree^[curr_n].n_length :=
                          sizeof (acv.a_nls_params.date_language) *
                          a01char_size;
                (* It is important to use literal_get   *)
                (* instead of get_identifier because of *)
                (* the forced tranformation into ascii. *)
                (*ENDIF*) 
                param_ptr := @nls_params.date_language;
                a05string_literal_get (acv, curr_n, dcha,
                      param_ptr^, 1, sizeof (nls_params.date_language));
                is_ok := acv.a_returncode = 0;
                IF  is_ok
                THEN
                    s78language (g03dictionary, nls_params.date_language,
                          language_no, NOT c_for_init, is_ok)
                ELSE
                    language_no := 1;
                (*ENDIF*) 
                IF  NOT is_ok
                THEN
                    a07_b_put_error (acv, e_unknown_name,
                          acv.a_ap_tree^[ curr_n ].n_pos)
                ELSE
                    BEGIN
                    nls_params.dl_language_no := language_no;
                    IF  acv.a_ap_tree^[sa_level_n].n_subproc = cak_i_nls_language
                    THEN
                        BEGIN
                        acv.a_ak_language := nls_params.date_language;
                        ak51get_row_not_found_text (acv);
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        cak_i_nls_numeric_chars:
            WITH nls_params DO
                BEGIN
                is_ok :=
                      acv.a_ap_tree^[curr_n].n_length = 2*a01char_size;
                IF  is_ok
                THEN
                    BEGIN
                    a05string_literal_get (acv, curr_n, dcha,
                          param_ptr^, 1, sizeof (nls_params.numeric_chars));
                    is_ok := acv.a_returncode = 0
                    END;
                (*ENDIF*) 
                IF  is_ok
                THEN
                    BEGIN
                    forbidden := [ '0'..'9', '+', '-', '''', '<', '>' ];
                    is_ok     :=
                          (nls_params.numeric_chars[ 1 ] <> nls_params.numeric_chars[ 2 ])
                          AND NOT (nls_params.numeric_chars[ 1 ] in forbidden)
                          AND NOT (nls_params.numeric_chars[ 2 ] in forbidden)
                    END;
                (*ENDIF*) 
                IF  NOT is_ok
                THEN
                    a07_b_put_error (acv, e_number_format_not_recogniz,
                          acv.a_ap_tree^[ curr_n ].n_pos)
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        cak_i_nls_currency:
            BEGIN
            is_ok  := acv.a_ap_tree^[curr_n].n_length <=
                  sizeof (nls_params.currency) * a01char_size;
            IF  is_ok
            THEN
                BEGIN
                a05string_literal_get (acv, curr_n, dcha,
                      param_ptr^, 1, sizeof (nls_params.currency));
                is_ok := acv.a_returncode = 0
                END;
            (*ENDIF*) 
            IF  is_ok
            THEN
                BEGIN
                forbidden := [ '0'..'9', '+', '-', '''', '<', '>' ];
                ix        := 1;
                WHILE is_ok AND (ix <= sizeof (nls_params.currency)) DO
                    BEGIN
                    is_ok := NOT (nls_params.currency[ix] in forbidden);
                    ix    := ix + 1
                    END;
                (*ENDWHILE*) 
                END;
            (*ENDIF*) 
            IF  NOT is_ok
            THEN
                a07_b_put_error (acv, e_number_format_not_recogniz,
                      acv.a_ap_tree^[ curr_n ].n_pos)
            (*ENDIF*) 
            END;
        cak_i_nls_sort :
            BEGIN
            nls_params.nls_binary := curr_n = 0;
            IF  NOT nls_params.nls_binary
            THEN
                BEGIN
                a05identifier_get (acv, curr_n,
                      sizeof (nls_params.nls_sort),
                      nls_params.nls_sort);
                a641get_mapcharset (acv, nls_params.nls_sort,
                      acv.a_ap_tree^[curr_n].n_pos, dummy_len,
                      dummy_buf)
                END;
            (*ENDIF*) 
            END;
        END;
    (*ENDCASE*) 
    sa_level_n := acv.a_ap_tree^[sa_level_n].n_sa_level
    END;
(*ENDWHILE*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    vbegexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
    (* assign in region because a select from sysdd.sessions may be running *)
    acv.a_nls_params := nls_params;
    vendexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
    ak51ret_session_info (acv)
    END;
&ifdef trace
(*ENDIF*) 
;
t01lidentifier (ak_sem, acv.a_nls_params.nls_sort);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51session_replication (VAR acv : tak_all_command_glob;
            VAR commandExecuted : boolean);
 
VAR
      e         : tgg00_BasisError;
      ix        : integer;
      treeIndex : integer;
      pMoveObj  : tsp00_MoveObjPtr;
      paramInfo : tsp1_param_info;
      parseId   : tak_parsid;
      length    : integer;
      checkBuf  : tsp00_C20;
      colInfo   : tak00_columninfo;
 
BEGIN
treeIndex := acv.a_ap_tree^[0].n_lo_level;
IF  acv.a_ap_tree^[treeIndex].n_length = cak_i_parse
THEN
    BEGIN
    acv.a_pars_last_key.p_kind := m_set_replication;
    WITH paramInfo DO
        BEGIN
        sp1i_mode       := [ sp1ot_mandatory ];
        sp1i_io_type    := sp1io_output;
        sp1i_data_type  := dchb;
        sp1i_frac       := 0;
        sp1i_length     := 8;
        sp1i_in_out_len := sp1i_length + 1;
        sp1i_bufpos     := 1;
        END;
    (*ENDWITH*) 
    parseId.pid_session       := acv.a_transinf.tri_trans.trSessionId_gg00;
    parseId.pid_parsk         := acv.a_pars_last_key;
    parseId.pid_appl_info[1]  := chr(acv.a_precomp_info_byte);
    parseId.pid_dtime_info[1] := chr(ord(dtf_none));
    (* Building of first return part with '1' and shortinfo ts. *)
    a06retpart_move (acv, @paramInfo, sizeof(tsp1_param_info));
    a06finish_curr_retpart (acv, sp1pk_shortinfo, 1);
    (* Building of second return part with parseId. *)
    a06retpart_move (acv, @parseId, sizeof (parseId));
    a06finish_curr_retpart (acv, sp1pk_parsid, 1);
    END
ELSE
    BEGIN
    pMoveObj         := @checkBuf;
    colInfo          := a642standard_colinfo;
    colInfo.cdatatyp := dchb;
    colInfo.cdatalen := 8;
    colInfo.cinoutlen:= 9;
    a05_constant_get (acv, acv.a_ap_tree^[treeIndex].n_sa_level,
          colInfo, false, sizeof(checkBuf), pMoveObj^, 1, length);
    e := e_invalid;
    IF  (acv.a_returncode = 0) AND (length = colInfo.cinoutlen)
    THEN
        BEGIN
        e := e_ok;
        IF  acv.a_replication_check_id <> cgg_zero_id
        THEN
            FOR ix := 1 TO sizeof(acv.a_replication_check_id) DO
                IF  acv.a_replication_check_id[ix] <> checkBuf[ix+1]
                THEN
                    e := e_invalid;
                (*ENDIF*) 
            (*ENDFOR*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    acv.a_replication_check_id  := cgg_zero_id;
    IF  e = e_ok
    THEN
        BEGIN
        acv.a_isReplicationSession := true;
        acv.a_withInternalTriggers := acv.a_ap_tree^[treeIndex].n_length = cak_i_with;
        END
    ELSE
        a07_b_put_error (acv, e, 1);
    (*ENDIF*) 
    commandExecuted := true;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51SetSessionReplicationProlog (VAR acv : tak_all_command_glob);
 
VAR
      ix       : integer;
      random   : tsp00_Int4;
      retBuf   : tsp00_C10;
 
BEGIN
vtime_in_seconds (random);
retBuf[1] := chr(0);
FOR ix := 1 TO 8 DO
    BEGIN
    random       := (((random * 214013 + 2531011) DIV 65536) MOD 32767);
    retBuf[ix+1] := chr(random MOD 256);
    END;
(*ENDFOR*) 
a06retpart_move (acv, @retBuf, 9);
a06finish_curr_retpart (acv, sp1pk_data, 1);
random := 8003;
FOR ix := 1 TO 8 DO
    BEGIN
    random := (((random * 214013 + 2531011) DIV 65536) MOD 8193);
    acv.a_replication_check_id[ix] := chr((random * ord(retBuf[ix+1])) MOD 256);
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51session_trace (VAR acv : tak_all_command_glob);
 
VAR
      found      : boolean;
      curr_n     : tsp00_Int2;
      tracelevel : tsp00_Int2;
      session    : tsp00_Int4;
      session_c4 : tsp00_C4;
      head_index : integer;
      curr       : tak_size_ptr;
 
BEGIN
(* PTS 1115654 E.Z. *)
IF  acv.a_ex_kind <> only_parsing
THEN
    BEGIN
    curr_n := acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
    WITH acv.a_ap_tree^[ curr_n ] DO
        a05_int4_unsigned_get (acv, n_pos, n_length, session);
    (*ENDWITH*) 
    curr_n := acv.a_ap_tree^[ curr_n ].n_sa_level;
    WITH acv.a_ap_tree^[ curr_n ] DO
        BEGIN
        a05_unsigned_int2_get (acv, n_pos, n_length,
              e_invalid_unsign_integer, tracelevel);
        IF  (tracelevel < 0) OR (tracelevel > csp_maxint1)
        THEN
            a07_b_put_error (acv, e_invalid_unsign_integer, n_pos)
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        head_index := session MOD (g01maxuser + 1);
&       ifdef TRACE
        t01int4 (ak_sem, 'head_index  ', head_index);
&       endif
        vbegexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
        s20int4_to_buf_swap (session, g01code.kernel_swap,
              session_c4, 1, sw_normal);
        found := false;
        curr := ak51head^[head_index];
        WHILE (curr <> NIL) AND NOT found DO
            IF  curr^.csz_session.ci4_gg00 = session_c4
            THEN
                BEGIN
                curr^.csz_tracelevel := tracelevel;
                found := true
                END
            ELSE
                curr := curr^.csz_next;
            (*ENDIF*) 
        (*ENDWHILE*) 
        vendexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
        IF  NOT found
        THEN
            a07_b_put_error (acv, e_unknown_session, 1);
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(* PTS 1102256 E.Z. *)
(* PTS 1110021 E.Z. *)
(* PTS 1115978 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak51control_connect (VAR acv : tak_all_command_glob;
            VAR password       : tsp00_CryptPw);
 
VAR
      xpcntrlpw : tsp00_CryptPw;
 
BEGIN
WITH acv DO
    BEGIN
    xpcntrlpw := g01controluser.gg04cu_password;
    IF  g01unicode
    THEN
        a51trimcn_password (xpcntrlpw);
    (*ENDIF*) 
    IF  (xpcntrlpw <> password)
        OR
        (* PTS 1115025 E.Z. *)
        (a_comp_type <> at_db_manager)
    THEN
        a07_b_put_error (acv, e_unknown_user_password_pair, 1)
    ELSE
        BEGIN
        a_acc_dba_id            := cak_zerotableid;
        a_acc_dbaname           := a01_il_b_identifier;
        a_acc_user              := a01controluser;
        a_acc_user_id           := cak_util_user_id;
        a_curr_user_name        := a_acc_user;
        a_curr_user_id          := cak_util_user_id;
        a_current_user_kind     := ucontroluser;
        a_acc_groupname         := a01_il_b_identifier;
        a_costwarn_value        := csp_maxint4;
        a_costlimit_value       := csp_maxint4;
        a_createSharedSQL       := true;
        gg06SetNilRef (a_user_perm_ref);
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51set_degree (VAR acv : tak_all_command_glob);
 
VAR
      h_degree     : tsp00_C3;
      curr_n       : tsp00_Int2;
      i            : integer;
      ts           : tsp1_param_info;
      parsid       : tak_parsid;
      dummy_parsid : tak_parsid;
 
BEGIN
WITH acv DO
    BEGIN
    h_degree := a_degree;
    curr_n := a_ap_tree^[ 0 ].n_lo_level;
    curr_n := a_ap_tree^[ curr_n ].n_lo_level;
    WITH a_ap_tree^[ curr_n ] DO
        IF  n_symb = s_string_literal
        THEN
            IF  (NOT g01unicode AND
                (n_length <> 3) AND
                (n_length <> 1))
                OR
                (g01unicode AND
                (n_length <> 6) AND (n_length <> 2))
            THEN
                a07_b_put_error (acv, e_invalid_datalength, 1)
            ELSE
                BEGIN
                a_degree := '   ';
                IF  g01unicode
                THEN
                    FOR i := 1 TO n_length DIV 2 DO
                        BEGIN
                        IF  a_cmd_part^.sp1p_buf[ n_pos + 2*i - 2 ] <> csp_unicode_mark
                        THEN
                            BEGIN
                            a07_b_put_error (acv, e_incompatible_datatypes, 1);
                            a_degree := h_degree
                            END
                        ELSE
                            a_degree[ i ] := a_cmd_part^.sp1p_buf[ n_pos + 2*i - 1 ];
                        (*ENDIF*) 
                        END
                    (*ENDFOR*) 
                ELSE
                    FOR i := 1 TO n_length DO
                        a_degree[ i ] := a_cmd_part^.sp1p_buf[ n_pos + i - 1 ];
                    (*ENDFOR*) 
                (*ENDIF*) 
                IF  ((a_degree <> 'ANY') AND
                    ( a_degree <> '1  '))
                THEN
                    BEGIN
                    a07_b_put_error (acv, e_incompatible_datatypes, 1);
                    a_degree := h_degree
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
        ELSE
            BEGIN
            a_pars_last_key.p_kind := m_set;
            WITH ts DO
                BEGIN
                sp1i_mode       := [ sp1ot_mandatory ];
                sp1i_io_type    := sp1io_input;
                sp1i_data_type  := dcha;
                sp1i_frac       := 0;
                sp1i_length     := 3;
                IF  (a_out_packet^.sp1_header.sp1h_mess_code in
                    [ csp_unicode_swap, csp_unicode ])
                    AND
                    NOT acv.a_ascii_in_and_output (* new feature *)
                THEN
                    sp1i_in_out_len := (2 * sp1i_length) + 1
                ELSE
                    sp1i_in_out_len := sp1i_length + 1;
                (*ENDIF*) 
                sp1i_bufpos     := 1;
                END;
            (*ENDWITH*) 
            parsid.pid_session := a_transinf.tri_trans.trSessionId_gg00;
            parsid.pid_parsk   := a_pars_last_key;
            parsid.pid_appl_info[1]  :=
                  chr(a_precomp_info_byte);
            parsid.pid_dtime_info[1] := chr(ord(dtf_none));
            IF  g01diag_moni_parse_on
            THEN
                BEGIN
                dummy_parsid.pid_session.ci4_gg00 := cgg_nil_session;
                a545diag_parse_info (acv,
                      parsid, dummy_parsid);
                END;
            (* Building of first return part with '1' and shortinfo ts. *)
            (*ENDIF*) 
            a06retpart_move (acv, @ts, sizeof(tsp1_param_info));
            a06finish_curr_retpart (acv, sp1pk_shortinfo, 1);
            (* Building of second return part with parsid. *)
            a06retpart_move (acv, @parsid, sizeof (parsid));
            a06finish_curr_retpart (acv, sp1pk_parsid, 1);
            END
        (*ENDIF*) 
    (*ENDWITH*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51set_role (VAR acv : tak_all_command_glob);
 
VAR
      ok        : boolean;
      ti        : integer;
      role_info : tak_role_info;
      role_cnt  : integer;
      p         : tak_role_context_ptr;
      role_ptr  : tak_sysbufferaddress;
      pw        : tsp00_Pw;
      cryptpw   : tsp00_CryptPw;
      role      : tsp00_KnlIdentifier;
 
BEGIN
p := NIL;
CASE acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_length OF
    cak_i_none :
        role_info := role_none;
    cak_i_all :
        role_info := role_all;
    OTHERWISE
        BEGIN
        IF  acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_length =
            cak_i_except
        THEN
            role_info := role_except
        ELSE
            role_info := role_none;
        (*ENDIF*) 
        role_cnt := 0;
        ti       := acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_sa_level;
        WHILE ti <> 0 DO
            BEGIN
            role_cnt := role_cnt + 1;
            ti       := acv.a_ap_tree^[ti].n_sa_level
            END;
        (*ENDWHILE*) 
        ti := acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_sa_level;
        a10new (acv, sizeof (tsp00_Int4) + role_cnt * sizeof (tgg00_Surrogate), p);
        IF  p <> NIL
        THEN
            BEGIN
            p^.rctxt_cnt := 0;
            WHILE ti <> 0 DO
                BEGIN
                a05identifier_get (acv, ti, sizeof (role), role);
                ok := a06role_exist (acv, role, d_release, role_ptr);
                IF  ok AND (role_info <> role_except)
                THEN
                    ok := a19user_knows_role (acv, acv.a_curr_user_id,
                          role_ptr^.syskey.sauthid);
                (*ENDIF*) 
                IF  ok
                THEN
                    BEGIN
                    IF  acv.a_ap_tree^[ti].n_lo_level <> 0
                    THEN
                        a05password_get (acv,
                              acv.a_ap_tree^[ti].n_lo_level, pw)
                    ELSE
                        pw := bsp_c18;
                    (*ENDIF*) 
                    s02encrypt (pw, cryptpw);
                    IF  (role_info <> role_except) AND
                        (cryptpw <> role_ptr^.suser.userpassw)
                    THEN
                        IF  acv.a_ap_tree^[ti].n_lo_level = 0
                        THEN
                            a07_b_put_error (acv, e_missing_password, 1)
                        ELSE
                            a07_b_put_error (acv, e_wrong_password, 1)
                        (*ENDIF*) 
                    ELSE
                        BEGIN
                        p^.rctxt_cnt := p^.rctxt_cnt + 1;
                        p^.rctxt_roles[p^.rctxt_cnt] :=
                              role_ptr^.syskey.sauthid;
                        END
                    (*ENDIF*) 
                    END
                ELSE
                    a07_nb_put_error (acv, e_unknown_name,
                          acv.a_ap_tree^[ti].n_pos, role);
                (*ENDIF*) 
                ti := acv.a_ap_tree^[ti].n_sa_level
                END;
            (*ENDWHILE*) 
            END
        ELSE
            a07_b_put_error (acv, e_no_more_memory, 1);
        (*ENDIF*) 
        END;
    END;
(*ENDCASE*) 
IF  acv. a_returncode = 0
THEN
    IF  acv.a_role_ptr <> NIL
    THEN
        a10dispose (acv, acv.a_role_ptr);
    (*ENDIF*) 
(*ENDIF*) 
IF  acv. a_returncode = 0
THEN
    BEGIN
    acv.a_role_info := role_info;
    acv.a_role_ptr  := p
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51init_cache_sizes;
 
VAR
      ix      : integer;
      prev    : tak_size_ptr;
 
      univ_ptr : RECORD
            CASE integer OF
                1 :
                    (void_ptr : tgg00_VoidPtr);
                2 :
                    (s_ptr    : tak_size_ptr);
                3 :
                    (hd_ptr   : tak51head_addr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
univ_ptr.void_ptr := a101_RTEMemAllocate (sizeof (tak_size_ptr) * (g01maxuser + 1));
IF  univ_ptr.void_ptr <> NIL
THEN
    BEGIN
    ak51head := univ_ptr.hd_ptr;
    FOR ix := 0 TO g01maxuser DO
        ak51head^[ix] := NIL
    (*ENDFOR*) 
    END;
(*ENDIF*) 
prev := NIL;
ix   := 0;
WHILE (univ_ptr.void_ptr <> NIL) AND (ix < g01maxuser + 1) DO
    BEGIN
    univ_ptr.void_ptr := a101_RTEMemAllocate (sizeof (tak_size_info));
    IF  univ_ptr.void_ptr <> NIL
    THEN
        BEGIN
        ak51free           := univ_ptr.s_ptr;
        ak51free^.csz_next := prev;
        prev               := ak51free
        END;
    (*ENDIF*) 
    ix := ix + 1
    END;
(*ENDWHILE*) 
IF  univ_ptr.void_ptr = NIL
THEN
    g01abort (csp3_no_more_memory, csp3_n_config, 'AK51SIZES list          ', 0)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51_aconnect_statement (VAR acv : tak_all_command_glob;
            VAR put_node      : tsp00_Int2);
 
VAR
      curr_n      : tsp00_Int2;
      last_n      : tsp00_Int2;
      regular_connect : boolean;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    regular_connect := true;
    a_return_segm^.sp1r_function_code := csp1_connect_fc;
    IF  (a_curr_user_name <> a01_il_b_identifier) AND
        (a_ex_kind        <> only_syntax)
    THEN
        a07_b_put_error (acv,
              e_user_connected_to_same_task, 1)
    ELSE
        BEGIN
        a_resname_addr[ cak_extern_pos ] := NIL;
        a_resname_addr[ cak_intern_pos ] := NIL;
        a_check_lock := false;
        a_sqlmode    := sqlm_internal;
        a01_call_put (acv, a51, cak_x_connect, curr_n);
        put_node     := curr_n;
        a01_next_symbol (acv);
        IF  (sc_symb = s_parameter_name)
        THEN
            a02_aparameter_name (acv, a_ap_tree^[ curr_n ].n_lo_level,
                  last_n)
        ELSE
            a02_aauthid (acv, a_ap_tree^[ curr_n ].n_lo_level,
                  last_n);
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            IF  a01_eqkey (a01kw[cak_i_authentication], acv.a_sqlmode,
                acv.a_cmd_part^.sp1p_buf, acv.a_scv)
            THEN
                BEGIN
                (* handle CONNECT <user> AUTHENTICATION *)
                a01_next_symbol (acv); (* consume AUTHENTICATION *)
                ak51parse_authentication (acv, curr_n);
                regular_connect := false;
                END
            ELSE
                IF  a01mandatory_keyword (acv, cak_i_identified)
                THEN
                    BEGIN
                    IF  a01mandatory_keyword (acv, cak_i_by)
                    THEN
                        a02_aparameter_name (acv,
                              a_ap_tree^[ last_n ].n_sa_level, last_n);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  (a_returncode = 0) AND
                (sc_symb <> s_eof) AND regular_connect
            THEN
                ak51connect_options (acv, last_n)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51connect_options (VAR acv : tak_all_command_glob;
            put_node : tsp00_Int2);
 
CONST
      c_max_options = 8; (* PTS 1121403 E.Z. *)
 
VAR
      res_kw      : boolean;
      ix          : integer;
      kw_option   : integer;
      sqlmode     : integer;
      curr_n      : tsp00_Int2;
      last_n      : tsp00_Int2;
      lock_pos    : integer;
      map         : ARRAY[0..cak_maxkeyword] OF integer;
      opt_n       : ARRAY[0..c_max_options]  OF integer;
      keyw        : tak_keyword;
 
BEGIN
FOR ix := 0 TO cak_maxkeyword DO
    map[ix] := 0;
(*ENDFOR*) 
(* PTS 1113190 E.Z. *)
map[cak_i_sqlmode   ] := 1;
map[cak_i_lock      ] := 3;
map[cak_i_isolation ] := 3;
map[cak_i_timeout   ] := 4;
map[cak_i_cachelimit] := 5;
map[cak_i_space     ] := 6; (* PTS 1121403 E.Z. *)
map[cak_i_character ] := 7;
map[cak_i_no        ] := 8;
FOR ix := 0 TO c_max_options DO
    opt_n[ix] := 0;
(*ENDFOR*) 
lock_pos := 0;
curr_n   := 0;
sqlmode  := cak_i_internal;
REPEAT
    a01_get_keyword (acv, kw_option, res_kw);
    IF  opt_n[map[kw_option]] <> 0
    THEN (* option already specified. *)
        a07_error (acv, e_wanted_keyword,
              put_node, last_n)
    ELSE
        CASE kw_option OF
            cak_i_cachelimit :
                BEGIN
                a01_call_put (acv, a51, kw_option, curr_n);
                a01_next_symbol (acv);
                a03_aunsigned_integer (acv,
                      acv.a_ap_tree^[curr_n].n_lo_level, last_n);
                curr_n := 0;
                END;
            cak_i_character :
                BEGIN
                a01_next_symbol (acv);
                IF  a01mandatory_keyword (acv, cak_i_set)
                THEN
                    BEGIN
                    a01_call_put (acv, a51,
                          cak_i_character, curr_n);
                    a01_character_set (acv,
                          acv.a_ap_tree^[ curr_n ].n_lo_level,
                          last_n)
                    END
                (*ENDIF*) 
                END;
            cak_i_isolation :
                BEGIN
                a01_next_symbol (acv);
                IF  a01mandatory_keyword (acv, cak_i_level)
                THEN
                    BEGIN
                    a01_call_put (acv, a51,
                          cak_i_isolation, curr_n);
                    a03_aunsigned_integer (acv,
                          acv.a_ap_tree^[curr_n].n_lo_level, last_n);
                    END
                (*ENDIF*) 
                END;
            cak_i_no :
                BEGIN
                a01_call_put (acv, a51, cak_i_file, curr_n);
                a01_next_symbol (acv);
                IF  a01mandatory_keyword (acv, cak_i_temp)
                THEN
                    IF  a01mandatory_keyword (acv, cak_i_file)
                    THEN
                        BEGIN
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (* PTS 1113190 E.Z. *)
            cak_i_nolog :
                (* because of R/3 load the option has to be accepted as syntax *)
                (* but no semantic is necessary                                *)
                BEGIN
                a01_next_symbol (acv)
                END;
            (* PTS 1121403 E.Z. *)
            cak_i_space :
                BEGIN
                a01_call_put (acv, a51, kw_option, curr_n);
                a01_next_symbol (acv);
                IF  a01mandatory_keyword (acv, cak_i_option)
                THEN
                    BEGIN
                    END
                (*ENDIF*) 
                END;
            cak_i_sqlmode :
                BEGIN
                a01_next_symbol (acv);
                a01_get_keyword (acv, sqlmode, res_kw);
                CASE sqlmode OF
                    cak_i_ansi,
                    cak_i_db2,
                    cak_i_oracle,
                    cak_i_internal :
                        BEGIN
                        a01_call_put (acv, a51, sqlmode, curr_n);
                        a01_next_symbol (acv);
                        END;
                    cak_i_sapr3 :
                        BEGIN
                        a01_call_put (acv, a51, cak_i_oracle, curr_n);
                        a01_next_symbol (acv);
                        END;
                    OTHERWISE
                        BEGIN
                        keyw := 'ADABAS            ';
                        IF  a01_eqkey (keyw, sqlm_internal,
                            acv.a_cmd_part^.sp1p_buf, acv.a_scv)
                        THEN
                            BEGIN
                            sqlmode := cak_i_internal;
                            a01_call_put (acv, a51, sqlmode, curr_n);
                            a01_next_symbol (acv);
                            END
                        ELSE
                            a07_error (acv, e_wanted_keyword,
                                  put_node, last_n);
                        (*ENDIF*) 
                        END
                    END
                (*ENDCASE*) 
                END;
            cak_i_timeout :
                BEGIN
                a01_call_put (acv, a51, kw_option, curr_n);
                a01_next_symbol (acv);
                a03_aunsigned_integer (acv,
                      acv.a_ap_tree^[curr_n].n_lo_level, last_n);
                END;
            OTHERWISE
                a07_error (acv, e_wanted_keyword,
                      put_node, last_n);
            END;
        (*ENDCASE*) 
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        opt_n[map[kw_option]] := curr_n
    (*ENDIF*) 
UNTIL
    (acv.a_scv.sc_symb = s_eof) OR
    (acv.a_returncode <> 0);
(*ENDREPEAT*) 
IF  acv.a_returncode = 0
THEN
    IF  (lock_pos > 0) AND (sqlmode <> cak_i_internal)
    THEN
        BEGIN
        acv.a_scv.sc_sypos := lock_pos;
        a07_error (acv, e_wanted_keyword,
              put_node, last_n)
        END
    ELSE
        BEGIN
        last_n := put_node;
        FOR ix := 1 TO c_max_options DO
            IF  opt_n[ix] <> 0
            THEN
                BEGIN
                acv.a_ap_tree^[last_n].n_sa_level := opt_n[ix];
                last_n := opt_n[ix]
                END;
            (*ENDIF*) 
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51_acurrent_user  (VAR acv : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      last_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_return_segm^.sp1r_function_code := csp1_set_fc;
    IF  (a_cmd_segment_header.sp1c_producer = sp1pr_internal_cmd) OR
        a_in_ddl_trigger
    THEN
        BEGIN
        a01_next_symbol (acv);
        IF  a01_eqkey (a01kw[ cak_i_user ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)
        THEN
            BEGIN
            a01_call_put (acv, a51, cak_x_current_user, put_node);
            a01_next_symbol (acv);
            a02_aauthid (acv, a_ap_tree^[ put_node ].n_lo_level, last_n);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  sc_symb <> s_eof
    THEN
        a07_error (acv, e_invalid_end_of_command, put_node, last_n)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51parse_authentication (VAR acv : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
BEGIN
acv.a_ap_tree^[put_node].n_subproc := cak_x_authentication_init;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51_aset_statement (VAR acv : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
CONST
      c_identified_clause = true;
 
VAR
      index  : integer;
      index1 : integer;
      res_kw : boolean;
      last_n : tsp00_Int2;
      hscv   : tak_scanner_glob;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_return_segm^.sp1r_function_code := csp1_set_fc;
    a01_next_symbol (acv);
    IF  ((sc_symb = s_parameter_name) AND
        (a_sqlmode = sqlm_db2)        AND
        ((a_ex_kind = only_parsing) OR
        ( a_ex_kind = only_syntax)))
    THEN
        BEGIN
        a01_call_put (acv, a51, cak_x_get_special_register, put_node);
        a01_next_symbol (acv);
        a01_force_symbol (acv, s_equal, put_node, put_node);
        hscv := a_scv;
        a03_avalue_spec (acv, NOT c_null_allowed,
              NOT c_stamp_allowed, NOT c_default_allowed,
              NOT c_sysuser_allowed,
              a_ap_tree^[ put_node ].n_lo_level, last_n);
        IF  a_returncode = 0
        THEN
            BEGIN
            last_n := a_ap_tree^[ put_node ].n_lo_level;
            IF  a_ap_tree^[ last_n ].n_symb in
                [ s_timezone, s_date, s_time, s_timestamp,
                s_user, s_degree ]
            THEN
                a_ap_tree^[ last_n ].n_pos := hscv.sc_sypos
            ELSE
                BEGIN
                a_scv := hscv;
                a07_error (acv, e_wanted_keyword,
                      put_node, put_node)
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        a01_get_keyword (acv, index, res_kw);
        CASE index OF
            cak_i_current :
                IF  a_sqlmode <> sqlm_db2
                THEN
                    a07_error (acv, e_wanted_keyword,
                          put_node, put_node)
                ELSE
                    BEGIN
                    a01_next_symbol (acv);
                    IF  a01mandatory_keyword (acv, cak_i_degree)
                    THEN
                        BEGIN
                        a01_call_put (acv, a51, cak_x_set_degree, put_node);
                        a01_force_symbol (acv, s_equal, put_node, put_node);
                        IF  ((sc_symb = s_parameter_name) OR
                            ( sc_symb = s_string_literal))
                        THEN
                            a03_avalue_spec (acv, NOT c_null_allowed,
                                  NOT c_stamp_allowed, NOT c_default_allowed,
                                  NOT c_sysuser_allowed,
                                  a_ap_tree^[ put_node ].n_lo_level, last_n)
                        ELSE
                            a07_error (acv, e_missing_keyword,
                                  put_node, put_node);
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            cak_i_isolation :
                IF  NOT (
                    ((a_sqlmode = sqlm_oracle) AND g01glob.db_is_for_sapr3) OR
                    (a_sqlmode = sqlm_internal)
                    )
                THEN
                    a07_error (acv, e_wanted_keyword,
                          put_node, put_node)
                ELSE
                    BEGIN
                    a01_next_symbol(acv);
                    IF  a01mandatory_keyword (acv, cak_i_level)
                    THEN
                        BEGIN
                        a01_call_put (acv, a51, cak_x_set_isolevel,
                              put_node);
                        a03_aunsigned_integer (acv,
                              a_ap_tree^[ put_node ].n_lo_level,
                              last_n);
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            cak_i_format :
                (* PTS 1115654 E.Z. *)
                (* PTS 1116801 E.Z. *)
                IF  NOT (
                    ((a_sqlmode = sqlm_db2) OR (a_sqlmode = sqlm_internal)) AND
                    (a_comp_type <> at_odbc)                              AND
                    (a_comp_type <> at_jdbc)
                    )
                THEN
                    a07_error (acv, e_wanted_keyword,
                          put_node, put_node)
                ELSE
                    BEGIN
                    a01_next_symbol (acv);
                    a01_call_put (acv, a51, cak_x_set_format, put_node);
                    a01_get_keyword (acv, index1, res_kw);
                    WITH a_ap_tree^[ put_node ] DO
                        CASE index1 OF
                            cak_i_iso :
                                n_length := ord(dtf_iso);
                            cak_i_usa :
                                n_length := ord(dtf_usa);
                            cak_i_eur :
                                n_length := ord(dtf_eur);
                            cak_i_jis :
                                n_length := ord(dtf_jis);
                            cak_i_internal :
                                n_length := ord(dtf_normal);
                            cak_i_oracle :
                                n_length := ord (dtf_oracle_date);
                            (* PTS 1112472 E.Z. *)
                            OTHERWISE
                                a07_error (acv, e_wanted_keyword,
                                      put_node, put_node);
                            END;
                        (*ENDCASE*) 
                    (*ENDWITH*) 
                    a01_next_symbol(acv);
                    END;
                (*ENDIF*) 
            cak_i_language :
                IF  a_ex_kind = only_parsing
                THEN
                    a07_b_put_error (acv, e_invalid_command, 1)
                ELSE
                    BEGIN
                    a01_call_put (acv, a51, cak_x_set_lang, put_node);
                    a01_next_symbol (acv);
                    END;
                (*ENDIF*) 
            cak_i_nls_sort, cak_i_current_schema :
                BEGIN
                a01_init_command (acv);
                a51a_alter_session_statement (acv, put_node)
                END;
            cak_i_role :
                BEGIN
                a01_call_put (acv, a51, cak_x_set_role, put_node);
                a01_next_symbol (acv);
                a01_get_keyword (acv, index, res_kw);
                a_ap_tree^[put_node].n_length := index;
                CASE index OF
                    cak_i_all :
                        BEGIN
                        a01_next_symbol (acv);
                        IF  sc_symb <> s_eof
                        THEN
                            IF  a01mandatory_keyword (acv, cak_i_except)
                            THEN
                                BEGIN
                                a_ap_tree^[put_node].n_length := cak_i_except;
                                ak51arole_list (acv, NOT c_identified_clause,
                                      a_ap_tree^[put_node].n_sa_level, last_n)
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    cak_i_none :
                        BEGIN
                        a01_next_symbol (acv);
                        END;
                    OTHERWISE
                        ak51arole_list (acv, c_identified_clause,
                              a_ap_tree^[put_node].n_sa_level, last_n);
                    END;
                (*ENDCASE*) 
                END;
            cak_i_session :
                (* PTS 1115654 E.Z. *)
                BEGIN
                a01_next_symbol (acv);
                IF  a01_eqkey (a01kw[ cak_i_unicode ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    BEGIN
                    a01_call_put (acv, a51,
                          cak_x_set_session_unicode, put_node);
                    a01_next_symbol (acv);
                    END
                ELSE
                    IF  a01_eqkey (a01kw[ cak_i_replication ], a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv)
                        AND
                        acv.a_isReplicationUser
                    THEN
                        BEGIN
                        a01_call_put (acv, a51,
                              cak_x_set_session_replication, put_node);
                        a_ap_tree^[put_node].n_length := 0;
                        a01_next_symbol (acv);
                        IF  acv.a_scv.sc_symb = s_parameter_name
                        THEN
                            BEGIN
                            a_ap_tree^[put_node].n_length := cak_i_parse;
                            a01_next_symbol (acv);
                            END
                        ELSE
                            BEGIN
                            a03_astring_literal (acv, a_ap_tree^[put_node].n_sa_level, last_n);
                            IF  (acv.a_scv.sc_symb <> s_eof)
                            THEN
                                IF  a01mandatory_keyword (acv, cak_i_with)
                                THEN
                                    IF  a01mandatory_keyword (acv, cak_i_trigger)
                                    THEN
                                        IF  a01mandatory_keyword (acv, cak_i_internal)
                                        THEN
                                            a_ap_tree^[put_node].n_length := cak_i_with;
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        a01_call_put (acv, a51,
                              cak_x_set_session_trace, put_node);
                        a03_aunsigned_integer (acv,
                              a_ap_tree^[ put_node ].n_lo_level,
                              last_n);
                        IF  a_returncode = 0
                        THEN
                            IF  a01mandatory_keyword (acv, cak_i_trace)
                            THEN
                                IF  a01mandatory_keyword (acv, cak_i_level)
                                THEN
                                    a03_aunsigned_integer (acv,
                                          a_ap_tree^[ last_n ].n_sa_level,
                                          last_n);
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            OTHERWISE
                a07_error (acv, e_wanted_keyword,
                      put_node, put_node);
            END
        (*ENDCASE*) 
        END;
    (*ENDIF*) 
    a01_is_end_symbol (acv)
    END
(*ENDWITH*) 
END;
 
(* PTS 1102256 E.Z. *)
(* PTS 1110021 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a51CreateConnectReturnSegment(
            VAR acv : tak_all_command_glob);
 
VAR
      error            : tsp8_uni_error;
      identifier_len   : integer;
      outlen           : integer;
      argument_count   : tsp00_Int2;
      err_char_no      : tsp00_Int4;
      user_type        : tsp00_C8;
      sysdbaname       : tsp00_KnlIdentifier;
      helpname         : tsp00_KnlIdentifier;
      defbyte          : char;
      lenbyte          : char;
 
BEGIN
IF  g01unicode
THEN
    defbyte := csp_unicode_def_byte
ELSE
    defbyte := bsp_c1;
(*ENDIF*) 
sysdbaname := g01glob.sysuser_name;
identifier_len :=  s30lnr_defbyte (@sysdbaname, defbyte, 1,
      sizeof(sysdbaname));
IF  g01unicode
THEN
    BEGIN
    outlen := sizeof (helpname);
    s80uni_trans (@sysdbaname, identifier_len, csp_unicode,
          @helpname, outlen,
          acv.a_out_packet^.sp1_header.sp1h_mess_code,
          [ ], error, err_char_no);
    lenbyte := chr (outlen);
    a06retpart_move (acv, @lenbyte, sizeof(lenbyte));
    IF  outlen > 0
    THEN
        a06retpart_move (acv, @helpname, outlen);
    (*ENDIF*) 
    END
ELSE
    BEGIN
    lenbyte := chr (identifier_len);
    a06retpart_move (acv, @lenbyte, sizeof(lenbyte));
    IF  identifier_len > 0
    THEN
        a06retpart_move (acv, @sysdbaname, identifier_len);
    (*ENDIF*) 
    END;
(*ENDIF*) 
(*============ return sysdba ============*)
(* PTS 1111797 E.Z. *)
identifier_len :=  s30lnr_defbyte (@g01glob.sysuser_name, defbyte, 1,
      sizeof(g01glob.sysuser_name));
IF  g01unicode
THEN
    BEGIN
    outlen := sizeof (helpname);
    s80uni_trans (@g01glob.sysuser_name, identifier_len, csp_unicode,
          @helpname, outlen,
          acv.a_out_packet^.sp1_header.sp1h_mess_code,
          [ ], error, err_char_no);
    lenbyte := chr (outlen);
    a06retpart_move (acv, @lenbyte, sizeof(lenbyte));
    IF  outlen > 0
    THEN
        a06retpart_move (acv, @helpname, outlen);
    (*ENDIF*) 
    END
ELSE
    BEGIN
    lenbyte := chr (identifier_len);
    a06retpart_move (acv, @lenbyte, sizeof(lenbyte));
    IF  identifier_len > 0
    THEN
        (* PTS 1111797 E.Z. *)
        a06retpart_move (acv, @g01glob.sysuser_name, identifier_len);
    (*ENDIF*) 
    END;
(*ENDIF*) 
(*============ return user type ==========*)
CASE acv.a_current_user_kind OF
    usuperdba :
        BEGIN
        user_type := 'OPERATOR';
        identifier_len := 8;
        END;
    udba :
        BEGIN
        user_type := 'DBA     ';
        identifier_len := 3;
        END;
    usysdba :
        BEGIN
        user_type := 'SYSDBA  ';
        identifier_len := 6;
        END;
    uprivate :
        BEGIN
        user_type := 'RESOURCE';
        identifier_len := 8;
        END;
    ucontroluser :
        BEGIN
        user_type := 'ADMIN   ';
        identifier_len := 5;
        END;
    OTHERWISE
        BEGIN
        user_type := 'STANDARD';
        identifier_len := 8;
        END;
    END;
(*ENDCASE*) 
(* 13.12.1995 h.b. changes in uni_trans neseccary *)
IF  (g01unicode) AND false
THEN
    BEGIN
    outlen := sizeof (helpname);
    (* PTS 1111797 E.Z. *)
    s80uni_trans (@g01glob.sysuser_name, identifier_len, csp_ascii,
          @helpname, outlen,
          acv.a_out_packet^.sp1_header.sp1h_mess_code,
          [ ], error, err_char_no);
    lenbyte := chr (outlen);
    a06retpart_move (acv, @lenbyte, sizeof(lenbyte));
    IF  outlen > 0
    THEN
        a06retpart_move (acv, @helpname, outlen);
    (*ENDIF*) 
    END
ELSE
    BEGIN
    lenbyte := chr (identifier_len);
    a06retpart_move (acv, @lenbyte, sizeof(lenbyte));
    IF  identifier_len > 0
    THEN
        a06retpart_move (acv, @user_type, identifier_len);
    (*ENDIF*) 
    END;
(*ENDIF*) 
(*============ return groupname ==========*)
(* PTS 1111797 E.Z. *)
identifier_len :=  s30lnr_defbyte (@acv.a_acc_groupname, defbyte, 1,
      sizeof(g01glob.sysuser_name));
IF  g01unicode
THEN
    BEGIN
    outlen := sizeof (helpname);
    s80uni_trans (@acv.a_acc_groupname, identifier_len, csp_unicode,
          @helpname, outlen,
          acv.a_out_packet^.sp1_header.sp1h_mess_code,
          [ ], error, err_char_no);
    lenbyte := chr (outlen);
    a06retpart_move (acv, @lenbyte, sizeof(lenbyte));
    IF  outlen > 0
    THEN
        a06retpart_move (acv, @helpname, identifier_len);
    (*ENDIF*) 
    END
ELSE
    BEGIN
    lenbyte := chr (identifier_len);
    a06retpart_move (acv, @lenbyte, sizeof(lenbyte));
    IF  identifier_len > 0
    THEN
        a06retpart_move (acv, @acv.a_acc_groupname, identifier_len);
    (*ENDIF*) 
    END;
(*ENDIF*) 
(* First return part is done, so now switch to the second... *)
a06finish_curr_retpart (acv, sp1pk_user_info_returned, 1);
(*========== return mess_code ============*)
acv.a_out_packet^.sp1_header.sp1h_mess_code := acv.a_mess_code;
s26new_part_init (acv.a_out_packet, acv.a_return_segm^, acv.a_curr_retpart);
(*========== return code tables ==========*)
ak51copy_code_tables (acv, acv.a_curr_retpart^.sp1p_buf,
      acv.a_curr_retpart^.sp1p_buf_len, acv.a_mess_code,
      argument_count);
(* Let's finish the second return part... *)
IF  argument_count > 0
THEN
    a06finish_curr_retpart (acv, sp1pk_conv_tables_returned,
          argument_count);
(*=== return unicode-info and session=====*)
(*ENDIF*) 
ak51ret_session_info (acv)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51copy_code_tables (VAR acv : tak_all_command_glob;
            VAR dest     : tsp00_MoveObj;
            VAR length   : tsp00_Int4;
            messcode     : tsp00_CodeType;
            VAR arg_cnt  : tsp00_Int2);
 
VAR
      code        : integer;
      basic_code  : tsp00_CodeType;
 
BEGIN
arg_cnt := 0;
basic_code := messcode;
&IFDEF TRACE
t01int4 (ak_sem, 'messcode  51', messcode);
t01int4 (ak_sem, 'basic_code51', basic_code);
&ENDIF
IF  acv.a_returncode = 0
THEN
    BEGIN
    (*===== TO SMALL ASCII ==============*)
    FOR code := 1 TO CTABLE_MXSP00 DO
        dest [ length + code ] :=
              g02codetables.tables[ cgg04_low_ascii, code ];
    (*ENDFOR*) 
    length := length + CTABLE_MXSP00;
    (*===== TO CAPITAL ASCII ============*)
    FOR code := 1 TO CTABLE_MXSP00 DO
        dest [ length + code ] :=
              g02codetables.tables[ cgg04_up_ascii, code ];
    (*ENDFOR*) 
    length := length + CTABLE_MXSP00;
    arg_cnt := 2;
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51_connect (VAR acv : tak_all_command_glob);
 
VAR
      change_curr_user : boolean;
      b_err            : tgg00_BasisError;
      connect_rec      : tak_connect_rec;
      features         : tsp1_features;
      feature_cnt      : integer;
      curr_feature     : tsp1_feature;
 
BEGIN
connect_rec.cn_mysql_connect := false;
change_curr_user   :=
      acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc = cak_x_current_user;
IF  acv.a_ex_kind = only_parsing
THEN
    BEGIN
    IF  acv.a_curr_user_name = a01_il_b_identifier
    THEN
        a07_b_put_error (acv, e_user_not_connected, 1)
    (*ENDIF*) 
    END
ELSE
    BEGIN
    IF  NOT a101_BasicAuthenticationAllowed (acv)
    THEN
        BEGIN
        a07_b_put_error (acv, e_no_basic_authentication, 1)
        END
    ELSE
        BEGIN
        ak51connect (acv, connect_rec);
        a51connect (acv, connect_rec, change_curr_user)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
(* PTS 1111797 E.Z. *)
IF  (acv.a_returncode = 0) AND NOT(change_curr_user)
THEN
    BEGIN
    feature_cnt := 0;
    IF  acv.a_feature_part <> NIL
    THEN
        BEGIN
        feature_cnt := acv.a_feature_part^.sp1p_arg_count;
        IF  feature_cnt * sizeof(tsp1_one_feature) > sizeof (features)
        THEN
            feature_cnt := sizeof(features) DIV sizeof(tsp1_one_feature);
        (*ENDIF*) 
        SAPDB_PascalMove ('VAK51 ',   7,    
              acv.a_feature_part^.sp1p_buf_size, sizeof(tsp1_features),
              @acv.a_feature_part^.sp1p_buf, 1,
              @features, 1, feature_cnt * sizeof(tsp1_one_feature), b_err);
        curr_feature := sp1f_nil_feature;
        WHILE (curr_feature < sp1f_last_feature) AND
              (ord(curr_feature) <= feature_cnt) DO
            BEGIN
            CASE features[curr_feature].of_feature OF
                sp1f_variable_input :
                    BEGIN
                    IF  gg01_usevariableinput AND
                        (features[curr_feature].of_value = 1)
                    THEN
                        acv.a_variable_input := true
                    ELSE
                        features[curr_feature].of_value := 0;
                    (*ENDIF*) 
                    END;
                sp1f_space_option :
                    IF  features[curr_feature].of_value = 1
                    THEN
                        acv.a_space_option := true;
                    (*ENDIF*) 
                sp1f_multiple_drop_parseid :
                    BEGIN
                    END;
                sp1f_optimized_streams :
                    IF  features[curr_feature].of_value = 1
                    THEN
                        acv.a_optimizedStreamSupport := true;
                    (*ENDIF*) 
                sp1f_check_scrollableoption :
                    IF  features[curr_feature].of_value = 1
                    THEN
                        acv.a_check_scrollableoption := true;
                    (*ENDIF*) 
                sp1f_ascii_in_and_output :
                    IF  features[curr_feature].of_value = 1
                    THEN
                        acv.a_ascii_in_and_output := true;
                    (*ENDIF*) 
                OTHERWISE
                    features[curr_feature].of_value := 0
                END;
            (*ENDCASE*) 
            curr_feature := succ(curr_feature)
            END;
        (*ENDWHILE*) 
        a06retpart_move (acv, @features, feature_cnt * sizeof(tsp1_one_feature));
        a06finish_curr_retpart (acv, sp1pk_feature, feature_cnt);
        END;
    (*ENDIF*) 
    a51CreateConnectReturnSegment (acv);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51init_authentication (
            VAR acv : tak_all_command_glob);
 
VAR
      curr_n   : integer;
      userName : tsp00_KnlIdentifier;
      isParameter : boolean;
      ok       : boolean;
 
BEGIN
WITH acv DO
    BEGIN
    curr_n := a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
    WITH a_ap_tree^[ curr_n ] DO
        BEGIN
        userName := a01_il_b_identifier;
        IF  n_symb = s_authid
        THEN
            BEGIN;
            a06get_username (acv, curr_n, userName);
            isParameter := false;
            END
        ELSE
            BEGIN
            isParameter := true;
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    ok := a101_InitAuthentication (acv, userName, isParameter,
          acv.a_data_ptr, acv.a_data_length);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51ret_session_info (VAR acv : tak_all_command_glob);
 
VAR
      this_byte   : tsp00_Uint1;
      unilen      : integer;
      i           : integer;
      format      : tsp00_C120;
      c50_ptr     : ^tsp00_C50;
      c3_ptr      : ^tsp00_C3;
      SenderIDP   : tsp00_C5;
      error       : tsp8_uni_error;
      err_char_no : tsp00_Int4;
      res         : tsp00_NumError;
      number      : tsp00_Number;
      local_dict  : tsp6_dictionary;
      (* *)
      (* A part with part_kind sp1pk_session_info_returned    *)
      (* will be constructed and put into the return segment. *)
      (* Since the character arrays are stored in ascii, but  *)
      (* there may be a unicode client out there, we have to  *)
      (* double the space for all the character values.       *)
 
BEGIN
(* BYTE LEN   VALUE                          *)
(*    1   1   UNICODE YES=1/NO=0             *)
(*    2   4   session_id                     *)
this_byte := ord (g01unicode);
a06retpart_move (acv, @this_byte, sizeof(this_byte));
a06retpart_move (acv,
      @acv.a_transinf.tri_trans.trSessionId_gg00,
      sizeof(acv.a_transinf.tri_trans.trSessionId_gg00));
(* BYTE LEN   VALUE                          *)
(*    6   1   NLS_DATE_FORMAT   clear length *)
(*    7 100   NLS_DATE_FORMAT   clear        *)
a51get_date_format (acv, format, NOT c_unicode);
this_byte := s30lnr_defbyte (@format,
      format[ 1 ], 2, 100);
a06retpart_move (acv, @this_byte, sizeof(this_byte));
IF  acv.a_out_packet^.sp1_header.sp1h_mess_code = csp_unicode_swap
THEN
    BEGIN
    unilen := 100;
    s80uni_trans (@format[ 2 ], unilen, csp_unicode,
          @format[ 2 ], unilen, csp_unicode_swap,
          [ ], error, err_char_no)
    END;
(*ENDIF*) 
a06retpart_move (acv, @format[ 2 ], 100);
(* BYTE LEN   VALUE                          *)
(*  107   1   NLS_DATE_FORMAT   coded length *)
(*  108  50   NLS_DATE_FORMAT   coded        *)
this_byte := acv.a_nls_params.df_length;
a06retpart_move (acv, @this_byte, sizeof(this_byte));
c50_ptr  := @format;
c50_ptr^ := acv.a_nls_params.date_format;
SAPDB_PascalForcedFill (sizeof(format), @format,
      sizeof (acv.a_nls_params.date_format)+1,
      sizeof(format) - sizeof (acv.a_nls_params.date_format),
      chr (csp_ascii_blank));
a06retpart_move (acv,
      @format, 50);
(* BYTE LEN   VALUE                          *)
(*  158   6   NLS_DATE_LANGUAGE clear        *)
IF  acv.a_out_packet^.sp1_header.sp1h_mess_code in
    [ csp_unicode_swap, csp_unicode ]
THEN
    BEGIN
    unilen := 6;
    s80uni_trans (@acv.a_nls_params.date_language,
          sizeof (acv.a_nls_params.date_language), csp_ascii,
          @format, unilen,
          acv.a_out_packet^.sp1_header.sp1h_mess_code,
          [ ], error, err_char_no);
    END
ELSE
    BEGIN
    c3_ptr  := @format;
    c3_ptr^ := acv.a_nls_params.date_language;
    SAPDB_PascalForcedFill (sizeof(format), @format,
          sizeof (acv.a_nls_params.date_language)+1,
          6 - sizeof (acv.a_nls_params.date_language),
          chr (csp_ascii_blank))
    END;
(*ENDIF*) 
a06retpart_move (acv,
      @format, 6);
(* BYTE LEN   VALUE                          *)
(*  164   6   LANGUAGE                       *)
IF  acv.a_out_packet^.sp1_header.sp1h_mess_code in
    [ csp_unicode_swap, csp_unicode ]
THEN
    BEGIN
    unilen := 6;
    s80uni_trans (@acv.a_ak_language,
          sizeof (acv.a_ak_language), csp_ascii,
          @format, unilen,
          acv.a_out_packet^.sp1_header.sp1h_mess_code,
          [ ], error, err_char_no);
    END
ELSE
    BEGIN
    c3_ptr  := @format;
    c3_ptr^ := acv.a_ak_language;
    SAPDB_PascalForcedFill (sizeof(format), @format,
          sizeof (acv.a_ak_language)+1,
          6 - sizeof (acv.a_ak_language),
          chr (csp_ascii_blank))
    END;
(*ENDIF*) 
a06retpart_move (acv,
      @format, 6);
(* BYTE LEN   VALUE                          *)
(*  170   1   DATE_FORMAT                    *)
a06retpart_move (acv,
      @acv.a_dt_format, sizeof(acv.a_dt_format));
(* BYTE LEN   VALUE                          *)
(*  171   4   NUMERIC_CHARACTERS             *)
IF  acv.a_out_packet^.sp1_header.sp1h_mess_code in
    [ csp_unicode_swap, csp_unicode ]
THEN
    BEGIN
    unilen := 4;
    s80uni_trans (@acv.a_nls_params.numeric_chars,
          sizeof (acv.a_nls_params.numeric_chars), csp_ascii,
          @format, unilen,
          acv.a_out_packet^.sp1_header.sp1h_mess_code,
          [ ], error, err_char_no);
    END
ELSE
    BEGIN
    format[ 1 ] := acv.a_nls_params.numeric_chars[ 1 ];
    format[ 2 ] := acv.a_nls_params.numeric_chars[ 2 ];
    format[ 3 ] := csp_ascii_blank;
    format[ 4 ] := csp_ascii_blank;
    END;
(*ENDIF*) 
a06retpart_move (acv,
      @format, 4);
(* BYTE LEN   VALUE                          *)
(*  175   2   empty (zero), alignment-filler *)
(*  177  16   empty (zero),place of 2 pointer*)
(*  193 2000  DICTIONARY (without code tables*)
SAPDB_PascalForcedFill (sizeof(format), @format, 1, 18, chr(0));
a06retpart_move (acv, @format, 18);
(* BYTE LEN   VALUE                          *)
(*  193 2000  DICTIONARY (without code tables*)
local_dict := g03dictionary.dict[ acv.a_nls_params.dl_language_no ];
IF  acv.a_out_packet^.sp1_header.sp1h_mess_code in
    [ csp_unicode_swap, csp_unicode ]
THEN
    WITH g03dictionary.dict[ acv.a_nls_params.dl_language_no ] DO
        BEGIN
        FOR i := 1 TO 12 DO
            BEGIN
            unilen := 12;
            s80uni_trans (@dict_lang_month[i].string,
                  sizeof (dict_lang_month[i].string), csp_ascii,
                  @local_dict.dict_lang_month[i].string, unilen,
                  acv.a_out_packet^.sp1_header.sp1h_mess_code,
                  [ ], error, err_char_no);
            END;
        (*ENDFOR*) 
        FOR i := 1 TO 7 DO
            BEGIN
            unilen := 12;
            s80uni_trans (@dict_lang_day[i].string,
                  sizeof (dict_lang_day[i].string), csp_ascii,
                  @local_dict.dict_lang_day[i].string, unilen,
                  acv.a_out_packet^.sp1_header.sp1h_mess_code,
                  [ ], error, err_char_no);
            END;
        (*ENDFOR*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
a06retpart_move (acv,
      @local_dict.lang,
      sizeof(tsp6_dictionary) - 2*sizeof (tsp00_MoveObjPtr));
(* BYTE LEN  VALUE                         *)
(* 2193   5  Page Size                     *)
s41plint (number, 2, 4, 0, bd999GetPageSize, res);
IF  res <> num_ok
THEN
    number[1] := csp_undef_byte
ELSE
    number[1] := csp_defined_byte;
(*ENDIF*) 
a06retpart_move (acv, @number, sizeof (tsp00_C5));
(* BYTE LEN  VALUE                         *)
(* 2198   3  empty (zero), alignment-filler*)
SAPDB_PascalForcedFill (sizeof(format), @format, 1, 3, chr(0));
a06retpart_move (acv, @format, 3);
(* BYTE LEN  VALUE                         *)
(* 2201   5  Kernel version                *)
sp100_GetSenderIDVersionP (SenderIDP);
a06retpart_move (acv, @SenderIDP, 5);
(* BYTE LEN  VALUE                         *)
(* 2206   3  empty (zero), alignment-filler*)
SAPDB_PascalForcedFill (sizeof(format), @format, 1, 3, chr(0));
a06retpart_move (acv, @format, 3);
a06finish_curr_retpart (acv,
      sp1pk_session_info_returned, 1)
END;
 
(*------------------------------*) 
 
FUNCTION
      a51CatalogCacheSize : tsp00_Int4;
 
BEGIN
a51CatalogCacheSize := ak51CurListPtr^.csz_ak_cache;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51connect (VAR acv : tak_all_command_glob;
            VAR connect_rec  : tak_connect_rec;
            change_curr_user : boolean);
 
CONST
      operator_maxtimeout = csp_maxint2;
 
VAR
      exclusive       : boolean;
      is_ok           : boolean;
      b_err           : tgg00_BasisError;
      max_timeout     : tsp00_Int4;
      role_info       : tak_role_info;
      default_role_cnt: integer;
      i               : integer;
      format_buf      : tsp00_C50;
      format_len      : tsp00_Int2;
      date_err        : tsp6_date_error;
      language_no     : tsp6_language;
      sink_info       : tsp_dcom_init_sink_parms;
      copysize        : integer;
 
BEGIN
WITH acv, connect_rec DO
    BEGIN
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  NOT change_curr_user
        THEN
            BEGIN
            (* PTS 1103813 *)
            a10SessionCacheInit (acv);
            WITH a_dca DO
                BEGIN
                code_p  := NIL;
                value_p := NIL
                END;
            (*ENDWITH*) 
            WITH a_transinf.tri_trans DO
                trBdTcachePtr_gg00 := NIL;
            (*ENDWITH*) 
            a_dbp_packet_ptr   := NIL;
            a_size_ptr         := NIL;
            END;
        (*ENDIF*) 
        a_ak_language[ 1 ] := chr(ascii_e);
        a_ak_language[ 2 ] := chr(ascii_n);
        a_ak_language[ 3 ] := chr(ascii_g);
        default_role_cnt := 0;
        max_timeout      := 0;
        exclusive        := false;
        role_info        := role_all;
        (* PTS 1117216 E.Z. *)
        a_defaultcode := g01code.char_default;
        IF  a_ex_kind = only_parsing
        THEN
            BEGIN
            IF  a_curr_user_name = a01_il_b_identifier
            THEN
                a07_b_put_error (acv, e_user_not_connected, 1)
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            IF  change_curr_user AND
                (cn_username = a01_i_sysdba )
            THEN
                cn_username := g01glob.sysuser_name;
            (*ENDIF*) 
            IF  NOT (change_curr_user)
            THEN
                BEGIN
                a_link_pending                      := false;
                a_pseudoUnicodeClient               := false; (* PTS 1118840 *)
                a_isReplicationSession              := false;
                a_in_ddl_trigger                    := false;
                a_optimizedStreamSupport            := false;
                a_check_scrollableoption            := false;
                a_ascii_in_and_output               := false;
                a_constraint_cnt                    := 0;
                a_release_instances                 := false;
                a_createSharedSQL                   := true;
                a_temp_tablekey                     := cgg_zero_id;
                a_nls_params.nls_binary             := NOT g01nls_sort;
                a_nls_params.nls_sort               := g01nls_default_map;
                a_nls_params.dl_language_no         := 1;
                FOR i := 0 TO cgg_idx_max_valuefieldlist DO
                    a_mblock.mb_fieldlists[i] := NIL;
                (*ENDFOR*) 
                a51session_init (acv);
                IF  a_transinf.tri_trans.trError_gg00 = e_ok
                THEN
                    BEGIN
                    (* PTS 1107767 E.Z. *)
                    IF  (* PTS 1115025 E.Z. *)
                        (acv.a_comp_type = at_db_manager)
                    THEN
                        a_transinf.tri_trans.trState_gg00 :=
                              a_transinf.tri_trans.trState_gg00 + [ tsDbFullNowait_egg00 ];
                    (*ENDIF*) 
                    ak51alloc_cache_size_info (acv);
                    END;
                (*ENDIF*) 
                a_variable_input    := false;
                sink_info.acv_addr  := @acv;
                sink_info.sink_addr := @acv.a_kernel_sink;
                sink_info.sink_size := sizeof (acv.a_kernel_sink);
                vdcom_init_sink (sink_info);
                IF  a_transinf.tri_trans.trError_gg00 <> e_ok
                THEN
                    a07_b_put_error (acv,
                          a_transinf.tri_trans.trError_gg00, 1);
                (*ENDIF*) 
                IF  a_returncode = 0
                THEN
                    ak51CreateTempFiles (acv, acv.a_comp_type = at_db_manager);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                IF  cn_username = a01controluser
                THEN
                    BEGIN
                    ak51control_connect (acv, cn_password);
                    max_timeout := operator_maxtimeout;
                    exclusive   := false
                    END
                ELSE
                    BEGIN
                    acv.a_acc_user := cn_username;
                    ak51check_user_pw (acv, connect_rec,
                          change_curr_user,
                          NOT change_curr_user, role_info,
                          default_role_cnt, exclusive, max_timeout,
                          cn_tmp_cache_size);
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            a_connected_name := a_curr_user_name;
        (*ENDIF*) 
        a_curr_schema_set := false;
        a_curr_schema     := a_curr_user_name;
        a_curr_schema_id  := a_curr_user_id;
        IF  ((NOT change_curr_user) AND (a_returncode = 0))
        THEN
            BEGIN
            a_init_user_id                := a_acc_user_id;
            a_is_exclusive                := exclusive;
            a_progusage_add               := false;
            a_named_subtrans              := false;
            a_optimize_info.o_do_optimize := true;
            a_result_cnt                  := 0;
            a_role_ptr                    := NIL;
            a_role_info                   := role_info;
            IF  (default_role_cnt > 0) AND
                ((role_info <> role_none) OR (a_current_user_kind in [udba, usysdba]))
            THEN
                a19set_default_context (acv, default_role_cnt);
            (*ENDIF*) 
            WITH a_dca DO
                BEGIN
                cancelb_ptr := @a_transinf.
                      tri_trans.trRteCommPtr_gg00^.to_cancel;
                msgno        := 0;
                stop_msg_set := false;
                curr_user := a_curr_user_name;
                IF  a_acc_groupname = a01_il_b_identifier
                THEN
                    curr_group := a_curr_user_name
                ELSE
                    curr_group := a_acc_groupname;
                (*ENDIF*) 
                system_user      := g01glob.sysuser_name;
                (* PTS 1111797 E.Z. *)
                user_system_user := g01glob.sysuser_name;
                proc_type  := sppr_db_proc;
                (*mess_type  := csp_m_adbs;*)
                a_cmd_segment_header.sp1c_mess_type := sp1m_dbs;
                a_cmd_segm^.sp1c_mess_type          := sp1m_dbs;
                firstcall  := false;
                lastcall   := false
                END;
            (*ENDWITH*) 
            a_nls_params.currency  := cak_nls_currency;
            format_buf             := cak_nls_date_format;
            format_len             := s30lnr_defbyte (@format_buf,
                  csp_ascii_blank, 1, sizeof (a_nls_params.date_format));
            a_nls_params.df_length := sizeof (a_nls_params.date_format);
            s78df_analyze (@format_buf, format_len,
                  @a_nls_params.date_format, a_nls_params.df_length,
                  c_to_date_format, date_err);
            a_nls_params.date_language := cak_nls_date_language;
            a_nls_params.numeric_chars := cak_nls_numeric_chars;
            s78language (g03dictionary, a_nls_params.date_language,
                  language_no, NOT c_for_init, is_ok);
            IF  is_ok
            THEN
                a_nls_params.dl_language_no := language_no
            ELSE
                a_nls_params.dl_language_no := 1;
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                a_col_file_count.mapInt_sp00 := 256;
                a_is_connected               := true;
                (* col_file = file used by string columns *)
                (* PTS 1109291 E.Z. *)
                (* PTS 1114071 E.Z. *)
                IF  a01diag_monitor_on OR a01diag_analyze_on
                THEN
                    BEGIN
                    WITH a_pars_last_key DO
                        BEGIN
                        a92next_pcount (acv, a_pars_last_key);
                        p_id   := chr(0);
                        p_kind := m_nil;
                        p_no   := 0
                        END;
                    (*ENDWITH*) 
                    b21mp_parse_again_put (acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                          a_pars_last_key.p_count);
                    END;
                (*ENDIF*) 
                a_max_res_id        := succ (cak_intern_res_fid);
                a_curr_res_id       := a_max_res_id;
                a_proc_userid       := cgg_zero_id;
                a_proc_compile      := pct_none;
                a_allocatorInfo.ai_badAllocCountDown := -1;
                END;
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                WITH a_transinf, tri_trans DO
                    BEGIN
                    vcinit  (trTaskId_gg00);
                    vioinit (trTaskId_gg00);
                    tri_global_state := cn_global_state;
                    IF  cn_timeout > max_timeout
                    THEN
                        a07_b_put_error (acv,
                              e_cmd_timeout_invalid, 1)
                    ELSE
                        IF  cn_timeout = cak_is_undefined
                        THEN
                            IF  (max_timeout < g01timeout.timeCmd_gg00) AND
                                (g01timeout.timeCmd_gg00 <> 0)
                            THEN
                                a_user_timeout := max_timeout
                            ELSE
                                a_user_timeout := g01timeout.timeCmd_gg00
                            (*ENDIF*) 
                        ELSE
                            a_user_timeout := cn_timeout
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            ak51get_row_not_found_text (acv);
        (*ENDIF*) 
        IF  NOT (change_curr_user)
        THEN
            BEGIN
            IF  a_clientid_part <> NIL
            THEN
                BEGIN
                (* PTS 1134562 DanielD *)
                a_acc_termid := bsp_c18;
                IF  a_clientid_part^.sp1p_buf_len - 1 > sizeof (a_acc_termid)
                THEN
                    copysize := sizeof (a_acc_termid)
                ELSE
                    copysize := a_clientid_part^.sp1p_buf_len - 1;
                (*ENDIF*) 
                SAPDB_PascalMove ('VAK51 ',   8,    
                      sizeof(a_clientid_part^.sp1p_buf), sizeof(a_acc_termid),
                      @a_clientid_part^.sp1p_buf, 1+1, @a_acc_termid, 1,
                      copysize, a_returncode)
                END
            ELSE
                (* PTS 1115978 E.Z. *)
                (* PTS 1118366 E.Z. *)
                IF  a_data_ptr <> NIL
                THEN
                    BEGIN
                    IF  a_cmd_packet_header.sp1h_mess_code in
                        [ csp_unicode_swap, csp_unicode ]
                    THEN
                        SAPDB_PascalMove ('VAK51 ',   9,    
                              sizeof(a_data_ptr^), sizeof(a_acc_termid),
                              @a_data_ptr^, a_input_data_pos+1, @a_acc_termid, 1,
                              mxsp_termid, a_returncode)
                    ELSE
                        SAPDB_PascalMove ('VAK51 ',  10,    
                              sizeof(a_data_ptr^), sizeof(a_acc_termid),
                              @a_data_ptr^, a_input_data_pos+1, @a_acc_termid, 1,
                              mxsp_termid, a_returncode);
                    (*ENDIF*) 
                    a_input_data_pos := a_input_data_pos + 1 + mxsp_termid
                    END
                ELSE
                    a_acc_termid := bsp_c18;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  a_sqlmode = sqlm_oracle
            THEN
                a_dt_format := dtf_oracle_date
            ELSE
                IF  a_sqlmode = sqlm_ansi
                THEN
                    (* PTS 1112472 E.Z. *)
                    (* PTS 1112472 E.Z. *)
                    a_dt_format := dtf_iso
                ELSE
                    a_dt_format := g01code.date_time;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  (a_comp_type = at_odbc) OR (a_comp_type = at_jdbc)
            THEN
                (* PTS 1112472 E.Z. *)
                a_dt_format := dtf_iso;
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                ak51connect_messbuf (acv, mm_nil);
                IF  exclusive
                THEN
                    a_mblock.mb_type2 := mm_user;
                (*ENDIF*) 
                a06lsend_mess_buf (acv,
                      a_mblock, NOT c_call_from_rsend, b_err);
                IF  b_err <> e_ok
                THEN
                    a07_b_put_error (acv, b_err, 1)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                a101_InitSessionInfo (acv);
                b21mp_termid_put (a_transinf.tri_trans.trBdTcachePtr_gg00,
                      a_acc_termid);
                b21mp_username_put (a_transinf.tri_trans.trBdTcachePtr_gg00,
                      a_curr_user_name);
                a101_AddToSessionList (acv);
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  NOT change_curr_user
        THEN
            BEGIN
            IF  acv.a_iso_level = cak_iso_level_trans_consistent
            THEN
                BEGIN
                ak341StartConsistentTrans (acv.a_transinf.tri_trans);
                IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
                THEN
                    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  acv.a_returncode = 0
            THEN
                acv.a_size_ptr^.csz_acv := @acv
            ELSE
                BEGIN
                (* PTS 1103938 E.Z. *)
                a52release_session (acv, NOT c_normal_release);
                (* PTS 1106828 E.Z. *)
                IF  a_transinf.tri_trans.trBdTcachePtr_gg00 <> NIL
                THEN
                    BEGIN
                    b01trelease_temp_cache (a_transinf.tri_trans);
                    a_transinf.tri_trans.trBdTcachePtr_gg00 := NIL
                    END;
                (*ENDIF*) 
                IF  a_transinf.tri_trans.trSessionId_gg00.ci4_gg00 <> cgg_nil_session
                THEN
                    a51release_cache_size_info (acv);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    acv.a_challenge := cgg_zero_id;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51connect (VAR acv : tak_all_command_glob;
            VAR connect_rec : tak_connect_rec);
 
VAR
      curr_n            : integer;
      aux_node          : integer;
      isolation_n       : integer;
      multibyte_setname : tsp00_KnlIdentifier;
 
BEGIN
WITH acv, connect_rec DO
    BEGIN
    curr_n := a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
    WITH a_ap_tree^[ curr_n ] DO
        BEGIN
        cn_username := a01_il_b_identifier;
        IF  n_symb = s_authid
        THEN
            a06get_username (acv, curr_n, cn_username)
        ELSE
            BEGIN
            (* get username as parameter *)
            IF  acv.a_authentication = NIL
            THEN
                BEGIN
                (* from data part / BASIC connect *)
                ak51get_userval (acv, cn_username);
                END
            ELSE
                BEGIN
                (* from vardata part / Challenge/Response *)
                a101_GetUsernameHostvar (acv, cn_username, 1);
                a101_MarkUsernameAsParameter (acv);
                END;
            (*ENDIF*) 
            curr_n := n_sa_level
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    WITH a_ap_tree^[ curr_n ] DO
        IF  n_symb = s_parameter_name
        THEN
            BEGIN
            (* a_authentication <> NIL: pwd is read from vardata part *)
            (*   in a101_VerifyAuthentication. DanielD                *)
            IF  (a_authentication = NIL)
            THEN
                IF  cn_username = a01controluser
                THEN
                    a51getascii_password (acv, cn_password) (* PTS 1109594 *)
                ELSE
                    ak51get_password (acv, connect_rec);
                (*ENDIF*) 
            (*ENDIF*) 
            curr_n := n_sa_level
            END;
        (*ENDIF*) 
    (*ENDWITH*) 
    IF  curr_n <> 0
    THEN
        WITH a_ap_tree^[ curr_n ] DO
            IF  n_proc = a51
            THEN
                CASE n_subproc OF
                    cak_i_ansi :
                        BEGIN
                        a_sqlmode := sqlm_ansi;
                        curr_n := n_sa_level
                        END;
                    cak_i_db2 :
                        BEGIN
                        a_sqlmode := sqlm_db2;
                        curr_n := n_sa_level
                        END;
                    cak_i_oracle :
                        BEGIN
                        a_sqlmode := sqlm_oracle;
                        curr_n := n_sa_level
                        END;
                    cak_i_internal :
                        BEGIN
                        a_sqlmode := sqlm_internal;
                        curr_n := n_sa_level
                        END;
                    OTHERWISE
                        BEGIN
                        END
                    END;
                (*ENDCASE*) 
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    a_session_sqlmode := a_sqlmode;
    IF  a_sqlmode = sqlm_ansi
    THEN
        BEGIN
        a_iso_level     := 3;
        cn_global_state := [ hsPermLock_egg00 ]
        END
    ELSE
        BEGIN
        a_iso_level     := 1;
        cn_global_state := [ hsConsistentLock_egg00 ];
        END;
    (*ENDIF*) 
    (* PTS 1113190 E.Z. *)
    IF  curr_n <> 0
    THEN
        WITH a_ap_tree^[ curr_n ] DO
            IF  n_proc = a51
            THEN
                BEGIN
                CASE n_subproc OF
                    cak_i_implicit :
                        BEGIN
                        curr_n := n_sa_level;
                        cn_global_state := [  ];
                        END;
                    cak_i_normal :
                        BEGIN
                        curr_n := n_sa_level;
                        cn_global_state := [ hsConsistentLock_egg00 ];
                        END;
                    cak_i_explicit :
                        BEGIN
                        curr_n := n_sa_level;
                        cn_global_state := [ hsWithoutLock_egg00 ];
                        END;
                    cak_i_isolation :
                        BEGIN
                        isolation_n := a_ap_tree^[ curr_n ].n_lo_level;
                        a_iso_level := csp_maxint1;
                        a660_isolevel (acv,
                              isolation_n, cn_global_state);
                        curr_n := n_sa_level;
                        END
                    OTHERWISE ;
                    END;
                (*ENDCASE*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    cn_timeout := cak_is_undefined;
    IF  curr_n <> 0
    THEN
        IF  (a_ap_tree^[ curr_n ].n_proc = a51) AND
            (a_ap_tree^[ curr_n ].n_subproc = cak_i_timeout)
        THEN
            BEGIN
            aux_node := a_ap_tree^[ curr_n ].n_lo_level;
            WITH a_ap_tree^[ aux_node ] DO
                a05_unsigned_int2_get (acv, n_pos,
                      n_length, e_cmd_timeout_invalid, cn_timeout);
            (*ENDWITH*) 
            curr_n := a_ap_tree^[ curr_n ].n_sa_level
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    cn_tmp_cache_size := 0;
    IF  curr_n <> 0
    THEN
        IF  (a_ap_tree^[ curr_n ].n_proc = a51) AND
            (a_ap_tree^[ curr_n ].n_subproc = cak_i_cachelimit)
        THEN
            BEGIN
            aux_node := a_ap_tree^[ curr_n ].n_lo_level;
            WITH a_ap_tree^[ aux_node ] DO
                a05_int4_unsigned_get (acv, n_pos,
                      n_length, cn_tmp_cache_size);
            (*ENDWITH*) 
            curr_n := a_ap_tree^[ curr_n ].n_sa_level
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    a_mass_all_rescount  := 0; (* h.b. CR 1000072 *)
    (* PTS 1121403 E.Z. *)
    a_space_option := false;
    IF  curr_n <> 0
    THEN
        IF  (a_ap_tree^[ curr_n ].n_proc = a51) AND
            (a_ap_tree^[ curr_n ].n_subproc = cak_i_space)
        THEN
            BEGIN
            a_space_option := true;
            curr_n := a_ap_tree^[ curr_n ].n_sa_level
            END;
        (* PTS END 1121403 E.Z. *)
        (*ENDIF*) 
    (*ENDIF*) 
    a_max_codewidth      := 1;
    IF  curr_n <> 0
    THEN
        BEGIN
        IF  (a_ap_tree^[ curr_n ].n_proc = a51) AND
            (a_ap_tree^[ curr_n ].n_subproc = cak_i_character)
        THEN
            BEGIN
            a641charset_get (acv, a_ap_tree^[ curr_n ].n_lo_level,
                  multibyte_setname, a_mess_code, a_max_codewidth);
            IF  a_returncode = 0
            THEN
                IF  ((a_mess_code = csp_unicode) AND
                    NOT g01unicode)
                THEN
                    a07_b_put_error (acv, e_unknown_multibyte_set, 1)
                ELSE
                    BEGIN
                    a_out_packet^.sp1_header.sp1h_mess_code := a_mess_code
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            curr_n := a_ap_tree^[ curr_n ].n_sa_level
            END
        (*ENDIF*) 
        END
    ELSE
        IF  (a_cmd_packet_header.sp1h_mess_code = csp_unicode) OR
            (a_cmd_packet_header.sp1h_mess_code = csp_unicode_swap)
        THEN
            BEGIN
            a_mess_code := a_cmd_packet_header.sp1h_mess_code;
            a_out_packet^.sp1_header.sp1h_mess_code := a_mess_code;
            a_max_codewidth := 2
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    a_session_mess_code     := a_mess_code;
    a_session_max_codewidth := a_max_codewidth;
    cn_internal := false;
    a_db_full_connection    := true;
    IF  curr_n <> 0
    THEN
        IF  (a_ap_tree^[ curr_n ].n_proc = a51) AND
            (a_ap_tree^[ curr_n ].n_subproc = cak_i_file)
        THEN
            IF  (cn_username <> a01controluser) OR
                (a_comp_type <> at_db_manager)
            THEN
                a07_b_put_error (acv, e_invalid_keyword, a_ap_tree^[ curr_n ].n_pos)
            ELSE
                BEGIN
                curr_n := a_ap_tree^[ curr_n ].n_sa_level;
                a_db_full_connection := false;
                END;
            (*ENDIF*) 
&       IFDEF TRACE
        (*ENDIF*) 
    (*ENDIF*) 
    t01int4 (ak_sem, 'cn_timeout  ', cn_timeout);
    t01int4 (ak_sem, 'cn_cache    ', cn_tmp_cache_size);
    t01int4 (ak_sem, 'a_mess_code ', ord(a_mess_code));
&   ENDIF
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51CreateTempFiles (VAR acv : tak_all_command_glob;
            control_connect : boolean);
 
BEGIN
b01tinit_temp_cache (acv.a_transinf.tri_trans, control_connect);
IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
THEN
    IF  acv.a_transinf.tri_trans.trError_gg00 =
        e_no_more_temp_space
    THEN
        a07_b_put_error (acv, e_no_more_user_temp_space, 1)
    ELSE
        a07_b_put_error (acv,
              acv.a_transinf.tri_trans.trError_gg00, 1)
    (*ENDIF*) 
ELSE
    BEGIN
    g04build_temp_tree_id (acv.a_pars_curr, acv.a_transinf.tri_trans);
    acv.a_pars_curr.fileTfnTemp_gg00       := ttfnPars_egg00;
    acv.a_intern_res_tree                  := acv.a_pars_curr;
    acv.a_intern_res_tree.fileTfnTemp_gg00 := ttfnComplexView_egg00;
    acv.a_intern_cmd_tree                  := acv.a_intern_res_tree;
    a101_SetTempFileIndex (acv, acv.a_intern_cmd_tree, 1);
    acv.a_usage_curr                       := acv.a_pars_curr;
    acv.a_usage_curr.fileTfnTemp_gg00      := ttfnUsage_egg00;
    acv.a_into_tree                        := acv.a_pars_curr;
    acv.a_into_tree.fileTfnTemp_gg00       := ttfnInto_egg00;
    a101_SetTempFileIndex (acv, acv.a_into_tree, cak_into_res_fid);
    acv.a_trigger_tree                     := acv.a_pars_curr;
    acv.a_trigger_tree.fileTfnTemp_gg00    := ttfnTrigger_egg00;
    IF  acv.a_db_full_connection
    THEN
        BEGIN
        a51create_file (acv, acv.a_pars_curr);
        a51create_file (acv, acv.a_into_tree);
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a51UnlockSessionIterator : boolean;
 
VAR
      unlocked : boolean;
 
BEGIN
unlocked := true;
IF  ak51CurListPtr <> NIL
THEN
    IF  ak51CurListPtr^.csz_next <> NIL
    THEN
        unlocked := false;
    (*ENDIF*) 
(*ENDIF*) 
IF  unlocked
THEN
    vendexcl (vGetAcvPtrFromCurrentTask^.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
(*ENDIF*) 
a51UnlockSessionIterator := unlocked;
END;
 
(*------------------------------*) 
 
FUNCTION
      a51SessionNext (
            VAR isLocked       : boolean;
            VAR currentIndex   : integer;
            VAR currentPointer : tak_size_ptr) : tak_acv_address;
 
VAR
      isFirst : boolean;
 
BEGIN
IF  NOT isLocked
THEN
    BEGIN
    isLocked := true;
    vbegexcl (vGetAcvPtrFromCurrentTask^.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
    END;
(*ENDIF*) 
ak51CurrIndex   := currentIndex;
ak51CurListPtr  := currentPointer;
isFirst         := false;
a51SessionNext  := a51NextSession (isFirst);
currentPointer  := ak51CurListPtr;
currentIndex    := ak51CurrIndex;
END;
 
(*------------------------------*) 
 
FUNCTION
      a51NextSession (VAR isFirst : boolean) : tak_acv_address;
 
VAR
      exitLoop  : boolean;
      nextFound : boolean;
 
BEGIN
IF  isFirst
THEN
    BEGIN
    isFirst := false;
    vbegexcl (vGetAcvPtrFromCurrentTask^.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
    ak51CurrIndex := -1;
    ak51CurListPtr  := NIL;
    END;
(*ENDIF*) 
nextFound := false;
REPEAT
    IF  ak51CurListPtr <> NIL
    THEN
        ak51CurListPtr := ak51CurListPtr^.csz_next;
    (*ENDIF*) 
    IF  ak51CurListPtr = NIL
    THEN
        BEGIN
        exitLoop := false;
        REPEAT
            ak51CurrIndex := ak51CurrIndex + 1;
            IF  ak51CurrIndex <= g01maxuser
            THEN
                ak51CurListPtr := ak51head^[ak51CurrIndex]
            ELSE
                exitLoop := true;
            (*ENDIF*) 
        UNTIL
            (ak51CurListPtr <> NIL) OR exitLoop;
        (*ENDREPEAT*) 
        END;
    (*ENDIF*) 
    IF  ak51CurListPtr <> NIL
    THEN
        nextFound := ak51CurListPtr^.csz_acv <> NIL;
    (*ENDIF*) 
UNTIL
    nextFound OR (ak51CurrIndex > g01maxuser);
(*ENDREPEAT*) 
IF  ak51CurListPtr <> NIL
THEN
    a51NextSession := ak51CurListPtr^.csz_acv
ELSE
    BEGIN
    a51NextSession := NIL;
    vendexcl (vGetAcvPtrFromCurrentTask^.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51session_init (VAR acv : tak_all_command_glob);
 
BEGIN
k51new_session (acv.a_transinf.tri_trans);
IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
THEN
    WITH acv DO
        BEGIN
        kb560CreateLogTransaction (a_transinf.tri_trans);
        WITH a_transinf.tri_trans DO
            BEGIN
            trWarning_gg00           := [ ];
            trSessionAuxCounter_gg00 := 0; (* h.b. PTS 1107826 *)
            trTempCount_gg00         := 0;
            trIoCount_gg00           := 0; (* PTS 1103743 JA 1999-08-25 *)
            trBdTcachePtr_gg00       := NIL;
            trObjReqTimeout_gg00     := 0;
            IF  trSeqInfoPtr_gg00 <> NIL
            THEN
                trSeqInfoPtr_gg00^.csi_cnt := 0; (* PTS 1110096 E.Z. *)
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        a_in_internal_subtr          := false;
        a_no_of_com_objects          := 0;
        a_command_sequence           := 1;
        a_command_id                 := 0;
        a_degree                     := '1  ';
        a_transinf.tri_global_state  := [ ];
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51build_userkey (VAR user_name : tsp00_KnlIdentifier;
            VAR userkey : tgg00_SysInfoKey);
 
VAR
      length_of_suffix : tsp00_Int4; (* To avoid a constant overflow warning *)
 
BEGIN
length_of_suffix := sizeof (user_name);
length_of_suffix := length_of_suffix - SURROGATE_MXGG00;
userkey          := a01defaultkey;
SAPDB_PascalForcedMove (sizeof(user_name), sizeof(userkey.sauthid), @user_name, 1,
      @userkey.sauthid, 1, SURROGATE_MXGG00);
SAPDB_PascalForcedMove (sizeof(user_name), sizeof(userkey.sidentifier),
      @user_name, SURROGATE_MXGG00 + 1, @userkey.sidentifier,
      1, length_of_suffix);
userkey.sentrytyp := cak_euserref;
userkey.skeylen   :=
      mxak_standard_sysk + sizeof (user_name) - SURROGATE_MXGG00
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51getascii_password (VAR acv : tak_all_command_glob;
            VAR password : tsp00_CryptPw);
 
VAR
      pw           : tsp00_Pw;
      aux_pw       : tsp00_Pw;
      error        : tsp8_uni_error;
      err_char_no  : tsp00_Int4;
      uni_len      : tsp00_Int4;
 
BEGIN (* PTS 1109594 *)
WITH acv DO
    IF  a_data_ptr = NIL
    THEN
        a07_b_put_error (acv,
              e_unknown_user_password_pair, 1)
    ELSE
        BEGIN
        a05password_get (acv, 0, pw);
        IF  g01unicode
        THEN
            BEGIN
            aux_pw  := pw;
            pw      := bsp_c18;
            uni_len := sizeof(pw);
            s80uni_trans (@aux_pw, sizeof(aux_pw), csp_unicode,
                  @pw, uni_len, csp_ascii,
                  [ ], error, err_char_no);
            IF  (error <> uni_ok)
            THEN
                a07_hex_uni_error (acv, error, err_char_no,
                      NOT c_trans_to_uni, @aux_pw[err_char_no],
                      c_unicode_wid);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            s02encrypt (pw, password);
            END;
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51trimcn_password (VAR password : tsp00_CryptPw);
 
VAR
      clearname : tsp00_Name;
 
BEGIN
s02decrypt (clearname , password);
SAPDB_PascalForcedFill (sizeof(clearname), @clearname, 10, 9, bsp_c1);
s02encrypt (clearname, password);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51get_password (VAR acv : tak_all_command_glob;
            VAR connect_rec : tak_connect_rec);
 
VAR
      ix : integer;
      pw : tsp00_Pw;
 
BEGIN
WITH acv DO
    IF  acv.a_authentication <> NIL
    THEN
        BEGIN
        (* authentication data is read in a different routine *)
        END
    ELSE
        IF  a_data_ptr = NIL
        THEN
            a07_b_put_error (acv,
                  e_unknown_user_password_pair, 1)
        ELSE
            IF  acv.a_challenge <> cgg_zero_id
            THEN
                BEGIN
                connect_rec.cn_mysql_connect := true;
                connect_rec.cn_oldVersion    :=
                      a_data_ptr^[a_input_data_pos+1] > chr(0);
                FOR ix := 1 TO sizeof(connect_rec.cn_receivedPw) DO
                    connect_rec.cn_receivedPw[ix] :=
                          a_data_ptr^[a_input_data_pos+1+ix];
                (*ENDFOR*) 
                END
            ELSE
                BEGIN
                a05password_get (acv, 0, pw);
                s02encrypt      (pw, connect_rec.cn_password);
                pw := bsp_c18
                END
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(* PTS 1115043 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a51inc_ak_cache_size (size_info_ptr : tak_size_ptr;
            increment     : tsp00_Int4);
 
BEGIN
IF  size_info_ptr <> NIL
THEN
    WITH size_info_ptr^ DO
        csz_ak_cache := csz_ak_cache + increment;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51release_cache_size_info (VAR acv : tak_all_command_glob);
 
VAR
&     ifdef trace
      found       : boolean;
&     endif
      head_index : integer;
      absval     : tsp00_Int4;
      session    : tgg91_SessionNo;
      curr       : tak_size_ptr;
      prev       : tak_size_ptr;
 
BEGIN
&ifdef trace
found := false;
&endif
a101_RemoveFromSessionList (acv);
session := acv.a_transinf.tri_trans.trSessionId_gg00;
absval  := abs (s20buf_to_int4_swap (session.ci4_gg00, 1, sw_normal, g01code.kernel_swap));
head_index := absval MOD (g01maxuser + 1);
&ifdef TRACE
t01int4 (ak_sem, 'head_index  ', head_index);
&endif
vbegexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
curr := ak51head^[head_index];
prev := NIL;
WHILE curr <> NIL DO
    IF  curr^.csz_session = session
    THEN
        BEGIN
&       ifdef trace
        found := true;
&       endif
        IF  prev = NIL
        THEN
            ak51head^[head_index] := curr^.csz_next
        ELSE
            prev^.csz_next := curr^.csz_next;
        (*ENDIF*) 
        curr^.csz_next := ak51free;
        ak51free       := curr;
        curr           := NIL;
        END
    ELSE
        BEGIN
        prev := curr;
        curr := curr^.csz_next
        END;
    (*ENDIF*) 
(*ENDWHILE*) 
vendexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
acv.a_size_ptr := NIL;
&ifdef trace
IF  NOT found
THEN
    a07ak_system_error (acv, 51, 2)
&         endif
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51set_degree (VAR acv : tak_all_command_glob);
 
VAR
      h_degree : tsp00_C3;
      i        : integer;
      offset   : integer;
 
BEGIN
acv.a_return_segm^.sp1r_function_code := csp1_set_fc;
IF  acv.a_variable_input
THEN
    offset := 2
ELSE
    offset := 0;
(*ENDIF*) 
WITH acv DO
    IF  ((a_data_length <> offset+4)                     AND
        (NOT (a_cmd_packet_header.sp1h_mess_code in
        [ csp_unicode_swap, csp_unicode ]) OR
        acv.a_ascii_in_and_output (* new feature *)
        ))
        OR
        ((a_data_length <> (offset + 1 + 2 * 3)) AND
        (a_cmd_packet_header.sp1h_mess_code in
        [ csp_unicode_swap, csp_unicode ])       AND
        NOT acv.a_ascii_in_and_output (* new feature *)
        )
    THEN
        a07_b_put_error (acv, e_invalid_datalength, 1)
    ELSE
        BEGIN
        h_degree := a_degree;
        a_degree := '   ';
        IF  (a_cmd_packet_header.sp1h_mess_code = csp_unicode) AND
            NOT acv.a_ascii_in_and_output (* new feature *)
        THEN
            FOR i := 1 TO 3 DO
                BEGIN
                IF  a_data_ptr^[ offset+2*i ] <> csp_unicode_mark
                THEN
                    BEGIN
                    a07_b_put_error (acv, e_incompatible_datatypes, 1);
                    a_degree := h_degree
                    END
                ELSE
                    a_degree[ i ] := a_data_ptr^[ offset + 1 + 2*i ];
                (*ENDIF*) 
                END
            (*ENDFOR*) 
        ELSE
            IF  (a_cmd_packet_header.sp1h_mess_code = csp_unicode_swap) AND
                NOT acv.a_ascii_in_and_output (* new feature *)
            THEN
                FOR i := 1 TO 3 DO
                    BEGIN
                    IF  a_data_ptr^[ offset+1+2*i ] <> csp_unicode_mark
                    THEN
                        BEGIN
                        a07_b_put_error (acv, e_incompatible_datatypes, 1);
                        a_degree := h_degree
                        END
                    ELSE
                        a_degree[ i ] := a_data_ptr^[ offset+2*i ];
                    (*ENDIF*) 
                    END
                (*ENDFOR*) 
            ELSE
                FOR i := 1 TO 3 DO
                    a_degree[ i ] := a_data_ptr^[ offset + 1 + i ];
                (*ENDFOR*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  ((a_degree <> 'ANY') AND
            ( a_degree <> '1  '))
        THEN
            BEGIN
            a07_b_put_error (acv, e_incompatible_datatypes, 1);
            a_degree := h_degree
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(* PTS 1115043 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a51cache_size_info (VAR acv : tak_all_command_glob;
            session       : tgg91_SessionNo;
            VAR ak_cache  : tsp00_Int4);
 
VAR
      head_index : integer;
      absval     : tsp00_Int4;
      curr       : tak_size_ptr;
 
BEGIN
(* PTS 1115043 E.Z. *)
ak_cache  := cak_is_undefined;
absval  := abs (s20buf_to_int4_swap (session.ci4_gg00, 1, sw_normal, g01code.kernel_swap));
head_index := absval MOD (g01maxuser + 1);
&ifdef TRACE
t01int4 (ak_sem, 'head_index  ', head_index);
&endif
vbegexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
curr := ak51head^[head_index];
WHILE curr <> NIL DO
    BEGIN
    IF  curr^.csz_session = session
    THEN
        BEGIN
        ak_cache  := curr^.csz_ak_cache;
        curr      := NIL
        END
    ELSE
        curr := curr^.csz_next;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
vendexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache)
END;
 
(* PTS 1115978 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a51RestoreUserContext (
            VAR acv          : tak_all_command_glob;
            VAR pOldContext  : tsp00_Addr);
 
VAR
      pContext         : ^tak51_SwitchUserContext;
 
BEGIN
IF  pOldContext <> NIL
THEN
    BEGIN
    pContext := @pOldContext^;
    acv.a_curr_user_name    := pContext^.su_curr_user_name;
    acv.a_curr_user_id      := pContext^.su_curr_user_id;
    acv.a_current_user_kind := pContext^.su_userkind;
    acv.a_defaultcode       := pContext^.su_defaultcode;
    acv.a_curr_schema_set   := pContext^.su_curr_schema_set;
    acv.a_curr_schema       := pContext^.su_curr_schema;
    acv.a_curr_schema_id    := pContext^.su_curr_schema_id;
    gg941Deallocate(acv.a_transinf.tri_trans, pOldContext);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51SaveUserContext (
            VAR acv          : tak_all_command_glob;
            VAR pOldContext  : tsp00_Addr);
 
VAR
      pContext : ^tak51_SwitchUserContext;
 
BEGIN
pOldContext := gg941Allocate(acv.a_transinf.tri_trans, sizeof(tak51_SwitchUserContext));
IF  pOldContext <> NIL
THEN
    BEGIN
    pContext := @pOldContext^;
    pContext^.su_curr_user_name  := acv.a_curr_user_name;
    pContext^.su_curr_user_id    := acv.a_curr_user_id;
    pContext^.su_userkind        := acv.a_current_user_kind ;
    pContext^.su_defaultcode     := acv.a_defaultcode;
    pContext^.su_curr_schema_set := acv.a_curr_schema_set;
    pContext^.su_curr_schema     := acv.a_curr_schema;
    pContext^.su_curr_schema_id  := acv.a_curr_schema_id;
    END
ELSE
    a07_b_put_error (acv, e_no_more_memory, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51SwitchUser (VAR acv : tak_all_command_glob;
            VAR new_user_name  : tsp00_KnlIdentifier);
 
CONST
      c_saveContext = true;
 
VAR
      dummyPointer : tsp00_Addr;
 
BEGIN
ak51switch_user (acv, new_user_name, NOT c_saveContext, dummyPointer);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51switch_user (VAR acv : tak_all_command_glob;
            VAR new_user_name  : tsp00_KnlIdentifier;
            VAR pOldContext    : tsp00_Addr);
 
CONST
      c_saveContext = true;
 
BEGIN
ak51switch_user (acv, new_user_name, c_saveContext, pOldContext);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak51switch_user (VAR acv : tak_all_command_glob;
            VAR new_user_name  : tsp00_KnlIdentifier;
            saveContext        : boolean;
            VAR pOldContext    : tsp00_Addr);
 
VAR
      ret_code         : integer;
      err_code         : integer;
      userbuf          : tak_sysbufferaddress;
 
BEGIN
&ifdef trace
t01lidentifier (ak_sem, acv.a_curr_user_name);
t01lidentifier (ak_sem, new_user_name);
&endif
(* the procedure must work even if a_returncode is <> 0 *)
ret_code               := acv.a_returncode;
err_code               := acv.a_errorpos  ;
acv.a_returncode       := 0;
pOldContext            := NIL;
IF  acv.a_curr_user_name <> new_user_name
THEN
    BEGIN
    IF  saveContext
    THEN
        a51SaveUserContext (acv, pOldContext);
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        IF  new_user_name = a01controluser
        THEN
            BEGIN
            acv.a_curr_user_name    := new_user_name;
            acv.a_curr_user_id      := cak_util_user_id;
            acv.a_current_user_kind := ucontroluser
            END
        ELSE
            IF  a06exist_user (acv, new_user_name, d_release, userbuf)
            THEN
                WITH userbuf^.suser DO
                    BEGIN
                    acv.a_curr_user_name    := new_user_name;
                    acv.a_curr_user_id      := usurrogate;
                    acv.a_curr_schema_set   := false;
                    acv.a_curr_schema       := acv.a_curr_user_name;
                    acv.a_curr_schema_id    := acv.a_curr_user_id;
                    IF  usersysdba
                    THEN
                        acv.a_current_user_kind := usysdba
                    ELSE
                        acv.a_current_user_kind := userkind;
                    (*ENDIF*) 
                    IF  userchardefcode = csp_instance_code
                    THEN
                        acv.a_defaultcode := g01code.char_default
                    ELSE
                        acv.a_defaultcode := userchardefcode;
                    (*ENDIF*) 
                    END
                (*ENDWITH*) 
            ELSE
                gg941Deallocate(acv.a_transinf.tri_trans, pOldContext);
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
&ifdef trace
(*ENDIF*) 
t01surrogate  (ak_sem, 'a_curr_user_', acv.a_curr_user_id);
&endif
IF  ret_code <> 0
THEN (* restore initial return code *)
    BEGIN
    acv.a_returncode := ret_code;
    acv.a_errorpos   := err_code
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51a_alter_session_statement (VAR acv : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      kw_index  : integer;
      res_kw    : boolean;
      curr_n    : tsp00_Int2;
      last_n    : tsp00_Int2;
      kw_set    : SET OF cak_i_no_keyword .. cak_maxkeyword;
 
BEGIN
acv.a_return_segm^.sp1r_function_code := csp1_alter_session_fc;
acv.a_is_ddl   := no_ddl; (* This may be already set, if we do *)
acv.a_init_ddl := no_ddl; (* parsing and executing separately. *)
IF  a01mandatory_keyword (acv, cak_i_set)
THEN
    BEGIN
    a01_call_put (acv, a51, cak_x_nls_date_format, put_node);
    curr_n := put_node;
    IF  acv.a_sqlmode = sqlm_oracle
    THEN
        kw_set := []
    ELSE (* restrict the following keywords *)
        kw_set := [cak_i_nls_date_format, cak_i_nls_numeric_chars,
              cak_i_nls_currency, cak_i_nls_date_language,
              cak_i_nls_language];
    (*ENDIF*) 
    REPEAT
        a01_get_keyword (acv, kw_index, res_kw);
        IF  kw_index in kw_set
        THEN
            kw_index := cak_i_no_keyword
        ELSE
            kw_set := kw_set + [kw_index];
        (*ENDIF*) 
        CASE kw_index OF
            cak_i_current_schema,
            cak_i_nls_date_format,
            cak_i_nls_numeric_chars,
            cak_i_nls_currency,
            cak_i_nls_date_language, cak_i_nls_language,
            cak_i_nls_sort :
                BEGIN
                a01_next_symbol  (acv); (* skip nls_param *)
                a01_force_symbol (acv, s_equal, put_node, put_node);
                IF  acv.a_returncode = 0
                THEN
                    BEGIN
                    a01_call_put (acv, a51, kw_index, last_n);
                    acv.a_ap_tree^[curr_n].n_sa_level := last_n;
                    curr_n := last_n;
                    CASE kw_index OF
                        cak_i_current_schema :
                            a02_put_identifier (acv,
                                  acv.a_ap_tree^[last_n].n_lo_level,
                                  last_n);
                        cak_i_nls_date_language,
                        cak_i_nls_language,
                        cak_i_nls_sort:
                            BEGIN
                            IF  kw_index = cak_i_nls_sort
                            THEN
                                a01_get_keyword (acv, kw_index, res_kw);
                            (*ENDIF*) 
                            IF  kw_index = cak_i_binary
                            THEN
                                a01_next_symbol (acv)
                            ELSE
                                a02_put_identifier (acv,
                                      acv.a_ap_tree^[last_n].n_lo_level,
                                      last_n)
                            (*ENDIF*) 
                            END;
                        cak_i_nls_date_format:
                            IF  (acv.a_scv.sc_symb     = s_identifier) AND
                                (acv.a_scv.sc_sylength = 0)
                            THEN
                                BEGIN
                                acv.a_scv.sc_symb := s_string_literal;
                                a01_put_node (acv,
                                      acv.a_ap_tree^[last_n].n_lo_level);
                                a01_next_symbol (acv)
                                END
                            ELSE
                                a03_astring_literal (acv,
                                      acv.a_ap_tree^[last_n].n_lo_level,
                                      last_n)
                            (*ENDIF*) 
                        OTHERWISE
                            a03_astring_literal (acv,
                                  acv.a_ap_tree^[last_n].n_lo_level, last_n)
                        END
                    (*ENDCASE*) 
                    END;
                (*ENDIF*) 
                END;
            OTHERWISE
                a07_error (acv, e_wanted_keyword, put_node, put_node)
            END;
        (*ENDCASE*) 
    UNTIL
        (acv.a_scv.sc_symb = s_eof) OR
        (acv.a_returncode <> 0);
    (*ENDREPEAT*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51get_date_format (VAR acv : tak_all_command_glob;
            VAR format    : tsp00_C120;
            has_to_be_uni : boolean);
 
VAR
      unibuf      : tsp00_C60;
      unilen      : integer;
      language_no : tsp6_language;
      error       : tsp8_uni_error;
      err_char_no : tsp00_Int4;
 
BEGIN
WITH acv, a_nls_params DO
    BEGIN
    IF  (acv.a_nls_params.dl_language_no >= 1) AND
        (acv.a_nls_params.dl_language_no <= g03dictionary.count)
    THEN
        language_no := acv.a_nls_params.dl_language_no
    ELSE
        language_no := 1;
    (*ENDIF*) 
    IF  (acv.a_out_packet^.sp1_header.sp1h_mess_code in
        [ csp_unicode_swap, csp_unicode ])               OR
        has_to_be_uni
    THEN
        BEGIN
        s78df_clear (g03dictionary.dict[ language_no ],
              @acv.a_nls_params.date_format, acv.a_nls_params.df_length,
              @unibuf, sizeof (unibuf));
        unilen := sizeof (format) - 1;
        format[ 1 ] := csp_unicode_def_byte;
        s80uni_trans (@unibuf[ 2 ], sizeof (unibuf)-1, csp_ascii,
              @format[ 2 ], unilen, csp_unicode,
              [ ], error, err_char_no)
        END
    ELSE
        s78df_clear (g03dictionary.dict[ language_no ],
              @acv.a_nls_params.date_format, acv.a_nls_params.df_length,
              @format, sizeof (format))
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef trace
t01moveobj (ak_sem, format, 1, sizeof (format));
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51_internal_trans (VAR acv : tak_all_command_glob;
            VAR old_trans : tgg00_UnivTrans);
 
VAR
      old_trans_has_excl_locks : boolean;
      dummy1                   : boolean;
      dummy2                   : tsp00_TaskId;
 
BEGIN
(* PTS 1107545 UH 2000-08-17 *)
(* internal session must not collide with its parent session *)
(* so set an exclusve object lock for the internal session   *)
(* if the parent session has eot-exclusive locks             *)
IF  acv.a_transinf.tri_trans.trIndex_gg00 = cgg_nil_transindex
THEN
    k53StartInternalSession (acv.a_transinf.tri_trans, old_trans.utrTrans,
          false, c_inherit_locfdir) (* PTS 1132447 FF*)
ELSE
    BEGIN
    k50my_state (acv.a_transinf.tri_trans.trIndex_gg00, old_trans_has_excl_locks,
          dummy1, dummy2);
    old_trans_has_excl_locks :=
          old_trans_has_excl_locks
          OR
          k50oms_have_obj_locks (acv.a_transinf.tri_trans.trIndex_gg00);
    k53StartInternalSession (acv.a_transinf.tri_trans, old_trans.utrTrans,
          false, c_inherit_locfdir); (* PTS 1132447 FF*)
    IF  old_trans_has_excl_locks
    THEN
        k50StartDbProcedure (acv.a_transinf.tri_trans);
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a51close_internal_trans (VAR acv : tak_all_command_glob;
            VAR old_trans : tgg00_UnivTrans;
            m_type        : tgg00_MessType);
 
BEGIN
k53StopInternalSession (acv.a_transinf.tri_trans, old_trans.utrTrans, m_type);
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
