.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK061$
.tt 2 $$$
.TT 3 $ThomasA$AK_universal_semantic_tools$2000-11-08$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : AK_Identifier_Handling
=========
.sp
Purpose :
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a061add_name (VAR acv : tak_all_command_glob;
                    VAR base_rec : tak_baserecord;
                    VAR name     : tsp00_KnlIdentifier;
                    VAR p        : tsp00_KnlIdentifierPtr);
 
        PROCEDURE
              a061app_columnname (VAR acv : tak_all_command_glob;
                    VAR base_rec          : tak_baserecord;
                    VAR column            : tsp00_KnlIdentifier;
                    VAR index             : integer);
 
        PROCEDURE
              a061assign_colname (value : tsp00_C18;
                    VAR colname : tsp00_KnlIdentifier);
 
        PROCEDURE
              a061colinfo_to_var (VAR src : tak00_columninfo;
                    VAR dst : tak00_columninfo);
 
        PROCEDURE
              a061compress_baserec (VAR base_rec : tak_baserecord;
                    VAR b_err : tgg00_BasisError);
 
        PROCEDURE
              a061copy_colinfo (VAR src_col : tak00_columninfo;
                    VAR dst_col : tak00_columninfo);
 
        FUNCTION
              a061exist_columnname (VAR base_rec : tak_baserecord;
                    VAR column      : tsp00_KnlIdentifier;
                    VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
        FUNCTION
              a061exist_columnindex (VAR base_rec : tak_baserecord;
                    extcolno        : integer;
                    VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
        FUNCTION
              a061ExistColumnnameSequential (VAR base_rec : tak_baserecord;
                    VAR column      : tsp00_KnlIdentifier;
                    VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
        PROCEDURE
              a061get_colname (VAR col_info : tak00_columninfo;
                    VAR colname  : tsp00_KnlIdentifier);
 
        PROCEDURE
              a061eval_colname_len (VAR src : tak00_columninfo);
 
        FUNCTION
              a061identifier_len
                    (VAR id : tsp00_KnlIdentifier (*ptocSynonym const tsp00_KnlIdentifier VAR_ARRAY_REF *)) : integer;
 
        PROCEDURE
              a061old_to_new_identifier (VAR old : tak_oldidentifier;
                    VAR new_ident : tsp00_KnlIdentifier);
 
        PROCEDURE
              a061put_systemkey (VAR acv : tak_all_command_glob;
                    VAR base_rec : tak_baserecord);
 
        PROCEDURE
              a061sort (VAR acv   : tak_all_command_glob;
                    VAR base_rec          : tak_baserecord;
                    last_used_expr_no     : integer;
                    VAR duplicate_column  : boolean;
                    VAR duplicate_colname : tsp00_KnlIdentifier);
&       ifdef trace
 
        PROCEDURE
              a061td_colinfo (VAR colinfo : tak00_columninfo;
                    index : integer);
&       endif
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Select_List : VAK61;
 
        PROCEDURE
              a61_new_expr_no (VAR colinf : tak00_columninfo;
                    VAR exprno : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
      ------------------------------ 
 
        FROM
              AK_Table : VAK11;
 
        FUNCTION
              a11firstindex (colcount : integer;
                    VAR baserec : tak_baserecord) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10new (VAR acv : tak_all_command_glob;
                    obj_size : tsp00_Int4;
                    VAR p    : tak_basecolinfo_ptr);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06extcolno (
                    VAR baserec     : tak_baserecord;
                    extcolno        : integer;
                    VAR colinfo_ptr : tak00_colinfo_ptr);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (VAR acv : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01_i_tablekey      : tsp00_KnlIdentifier;
              a01_il_b_identifier : tsp00_KnlIdentifier;
              a01_i_internal       : tsp00_KnlIdentifier;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30lnr (VAR str : tsp00_KnlIdentifier;
                    val   : char;
                    start : tsp00_Int4;
                    cnt   : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30unilnr (str  : tsp00_MoveObjPtr;
                    skip_val  : tsp00_C2;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
        PROCEDURE
              s30cmp1 (VAR buf1  : tsp00_KnlIdentifier;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tsp00_KnlIdentifier;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01unicode       : boolean;
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01addr (debug : tgg00_Debug;
                    nam      : tsp00_Sname;
                    bufaddr  : tsp00_BufAddr);
 
        PROCEDURE
              t01int4 (debug : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01lidentifier (layer : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01str30 (layer : tgg00_Debug;
                    str30 : tsp00_C30);
 
        PROCEDURE
              t01buf (layer : tgg00_Debug;
                    VAR buf : tsp00_KnlIdentifier;
                    start   : integer;
                    stop    : integer);
 
        PROCEDURE
              t01stackentry (layer : tgg00_Debug;
                    VAR st      : tgg00_StackEntry;
                    entry_index : integer);
&       ENDIF
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              a10new;
 
              tak_sysbufferaddress tak_basecolinfo_ptr
 
        FUNCTION
              s30lnr;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              s30cmp1;
 
              tsp00_MoveObj tsp00_KnlIdentifier
              tsp00_MoveObj tsp00_KnlIdentifier
&             ifdef trace
 
        PROCEDURE
              t01buf;
 
              tsp00_Buf tsp00_KnlIdentifier
&             endif
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ElkeZ / ThomasA
.sp
.cp 3
Created : 1985-02-06
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-11-08
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
 
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.sp 2
PROCEDURE a06_sort
.sp 1
sorts the entries of the 'bcolumn'-array within the entire
indexrange. Sorting key is the component 'ccolumn'.
.br
In case of a duplicate column name the variable 'duplicate_column'
is set to true and the variable 'duplicate_colname' contains
one of the duplicate column names.
.br
Execution is continued in any case and the array is sorted with
completion of the procedure.
.sp 2
PROCEDURE sort
.sp 1
sorts the entries of the 'bcolumn'-array within the indexrange
l..r (l<=r). Sorting key is the component 'ccolumn'.
.br
In case of a duplicate column name the variable 'duplicate_column'
is set to true and the variable 'duplicate_colname' contains
one duplicate column name.
.br
Execution is continued in any case and the array is sorted with
completion of the procedure.
 
.sp 2
PROCEDURE A06_APP_COLUMN
.sp 1
adds a new column into the last position of the 'bcolumn'-array
.sp 2
 
PROCEDURE  A06_VIEW_GET_BASETABLE :
.sp 2
Bei einer View mit mehreren Fromtabellen wird
aus der Viewqualification ?uber die tabno der
zugeh?orige Baistabellennamen mit Location
geholt.
.sp 2
.sp 4
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
(*------------------------------*) 
 
PROCEDURE
      a061add_name (VAR acv : tak_all_command_glob;
            VAR base_rec : tak_baserecord;
            VAR name     : tsp00_KnlIdentifier;
            VAR p        : tsp00_KnlIdentifierPtr);
 
BEGIN
IF  base_rec.bptr = NIL
THEN
    BEGIN
    a10new (acv, sizeof (tak_basecolinfo), base_rec.bptr);
    IF  base_rec.bptr <> NIL
    THEN
        WITH base_rec.bptr^ DO
            BEGIN
            bci_buf_size := sizeof(bci_buf);
            bci_index   := 1;
            bci_rec_cnt := 0;
            bci_ref_cnt := 1;
            bci_next    := NIL
            END
        (*ENDWITH*) 
    ELSE
        a07_b_put_error (acv, e_no_more_memory, 1)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    WITH base_rec.bptr^ DO
        BEGIN
&       ifdef trace
        t01int4 (ak_sem, 'bci_index   ', bci_index);
&       endif
        p  := @bci_buf[bci_index];
        p^ := name;
        bci_index := bci_index +
              ((sizeof (name) - 1) DIV sizeof (tak_align) + 1) *
              sizeof (tak_align)
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a061app_columnname (VAR acv : tak_all_command_glob;
            VAR base_rec          : tak_baserecord;
            VAR column            : tsp00_KnlIdentifier;
            VAR index             : integer);
 
VAR
      col_len         : integer;
      colinfo_len     : integer;
      curr            : tak_basecolinfo_ptr;
 
BEGIN
IF  g01unicode
THEN
    col_len := s30unilnr (@column,
          csp_unicode_blank, 1, sizeof (tsp00_KnlIdentifier))
ELSE
    col_len := s30lnr (column, bsp_c1, 1, sizeof (column));
(*ENDIF*) 
&ifdef trace
t01int4 (ak_sem, 'col_len     ', col_len);
t01buf  (ak_sem, column, 1, sizeof (column));
&endif
IF  acv.a_returncode = 0
THEN
    BEGIN
    curr := base_rec.bptr;
    (* find last column buffer *)
    WHILE curr^.bci_next <> NIL DO
        curr := curr^.bci_next;
    (*ENDWHILE*) 
    index               := base_rec.blastindex + 1;
    base_rec.blastindex := index;
&   ifdef trace
    t01int4 (ak_sem, 'bci_index   ', curr^.bci_index);
    t01int4 (ak_sem, 'bci_buf_size', curr^.bci_buf_size);
&   endif
    colinfo_len := sizeof (tak00_columninfo) -
          sizeof(tsp00_KnlIdentifier) + col_len;
    IF  curr^.bci_index - 1 + colinfo_len > curr^.bci_buf_size
    THEN
        BEGIN
        (* column info does not fit into current buffer *)
        (* allocate succ buffer                         *)
        a10new (acv, sizeof (tak_basecolinfo), curr^.bci_next);
        IF  curr^.bci_next <> NIL
        THEN
            BEGIN
            curr               := curr^.bci_next;
            curr^.bci_buf_size := sizeof(curr^.bci_buf);
            curr^.bci_index    := 1;
            curr^.bci_ref_cnt  := 1;
            curr^.bci_next     := NIL
            END
        ELSE
            a07_b_put_error (acv, e_no_more_memory, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        base_rec.bcolumn[index] := @curr^.bci_buf[curr^.bci_index];
        base_rec.bcolumn[index]^.ccolumnn_len := chr(col_len);
        SAPDB_PascalMove ('VAK061',   1,    
              sizeof (column), col_len,
              @column, 1, @base_rec.bcolumn[index]^.ccolumnn, 1, col_len,
              acv.a_returncode);
        curr^.bci_index := curr^.bci_index +
              ((colinfo_len - 1) DIV sizeof (tak_align) + 1)
              * sizeof(tak_align);
        base_rec.bmaxcol := base_rec.bmaxcol + 1;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a061assign_colname (value : tsp00_C18;
            VAR colname : tsp00_KnlIdentifier);
 
VAR
      ix          : integer;
      colname_ptr : ^tsp00_C18;
 
BEGIN
colname_ptr  := @colname;
colname_ptr^ := value;
FOR ix := sizeof (value) + 1 TO sizeof (colname) DO
    colname[ix] := bsp_c1
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a061colinfo_to_var (VAR src : tak00_columninfo;
            VAR dst : tak00_columninfo);
 
BEGIN
&ifdef trace
dst.ccolumnn_len := chr(0);
&endif
a061copy_colinfo (src, dst);
dst.ccolumnn_len := src.ccolumnn_len;
a061get_colname (src, dst.ccolumnn)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a061compress_baserec (VAR base_rec : tak_baserecord;
            VAR b_err : tgg00_BasisError);
 
VAR
      firstindex : integer;
      diff       : integer;
      ix         : integer;
 
BEGIN
(* This procedure overlays the unused part of bextcolindex *)
(* with pointers to columns (bcolumn)                      *)
firstindex := a11firstindex (base_rec.bmaxcol, base_rec);
diff := base_rec.bfirstindex - firstindex;
IF  diff > 0
THEN
    BEGIN
    SAPDB_PascalOverlappingMove ('VAK061',   2,    
          sizeof (base_rec.bcolumn), sizeof (base_rec.bcolumn),
          @base_rec.bcolumn,
          (base_rec.bfirstindex - 1) * sizeof (base_rec.bcolumn[1]) + 1,
          @base_rec.bcolumn,
          (firstindex - 1) * sizeof (base_rec.bcolumn[1]) + 1,
          (base_rec.blastindex - base_rec.bfirstindex + 1) *
          sizeof (base_rec.bcolumn[1]), b_err);
    IF  b_err = e_ok
    THEN
        BEGIN
        base_rec.bfirstindex := firstindex;
        base_rec.blastindex  := firstindex + base_rec.bmaxcol - 1;
        base_rec.breclen     := sizeof (base_rec) - sizeof (base_rec.bcolumn) +
              base_rec.blastindex * sizeof (base_rec.bcolumn[1]);
        base_rec.bfirstcolind := base_rec.bfirstcolind - diff;
        (* PTS 1112311 E.Z. *)
        IF  base_rec.blastkeyind > 0
        THEN
            base_rec.blastkeyind  := base_rec.blastkeyind  - diff;
        (*ENDIF*) 
        FOR ix := base_rec.bfirstindex TO base_rec.blastindex DO
            WITH base_rec.bcolumn[ix]^ DO
                IF  cnextind > 0
                THEN
                    cnextind := cnextind - diff
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDFOR*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a061copy_colinfo (VAR src_col : tak00_columninfo;
            VAR dst_col : tak00_columninfo);
 
VAR
      coln_len : char;
 
BEGIN
coln_len := dst_col.ccolumnn_len;
SAPDB_PascalForcedMove (sizeof (src_col), sizeof (dst_col), @src_col, 1,
      @dst_col, 1, sizeof (src_col) - sizeof (src_col.ccolumnn));
dst_col.ccolumnn_len := coln_len
&     ifdef trace
      ;
a061td_colinfo (dst_col, 1)
&     endif
END;
 
(*------------------------------*) 
 
FUNCTION
      a061exist_columnname (VAR base_rec : tak_baserecord;
            VAR column      : tsp00_KnlIdentifier;
            VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
VAR
      found        : boolean;
      res          : tsp00_LcompResult;
      exit_loop    : boolean;
      i            : integer;
      lwb          : integer;
      upb          : integer;
      middle       : integer;
      colname_len  : integer;
      col_ptr      : tak00_colinfo_ptr;
 
BEGIN
&ifdef trace
t01lidentifier (ak_sem, column);
&endif
colname_len := a061identifier_len (column);
found       := false;
colinfo_ptr := NIL;
lwb         := base_rec.bfirstindex;
upb         := base_rec.blastindex;
REPEAT
    (* binary search *)
    middle      := (lwb + upb) DIV 2;
    col_ptr     := a103GetColumn (base_rec, middle);
    s30cmp1 (col_ptr^.ccolumnn, 1, ord (col_ptr^.ccolumnn_len),
          column, 1, colname_len, res);
    IF  res = l_greater
    THEN
        upb := middle - 1
    ELSE
        lwb := middle + 1;
    (*ENDIF*) 
UNTIL
    (res = l_equal) OR (lwb > upb);
(*ENDREPEAT*) 
IF  res = l_equal
THEN
&   ifdef LONGREC
    found := (NOT (ctdropped in col_ptr^.ccolpropset))
          OR (column = a01_i_internal);
&else
(*ENDIF*) 
found := NOT (ctdropped in col_ptr^.ccolpropset);
&endif
IF  found
THEN
    IF  ctinvisible in col_ptr^.ccolpropset
    THEN
        BEGIN
        (* invisible column with required name found, check if        *)
        (* a column to the right with this name that is not invisible *)
        (* does exist. if true, return this column                    *)
        found     := false;
        exit_loop := false;
        i         := middle;
        REPEAT
            i := i + 1;
            IF  i > base_rec.blastindex
            THEN
                exit_loop := true
            ELSE
                BEGIN
                col_ptr := a103GetColumn (base_rec, i);
                s30cmp1 (col_ptr^.ccolumnn, 1,
                      ord (col_ptr^.ccolumnn_len),
                      column, 1, colname_len, res);
                IF  (res = l_equal)                           AND
                    NOT (ctinvisible in col_ptr^.ccolpropset) AND
                    NOT (ctdropped   in col_ptr^.ccolpropset)
                THEN
                    BEGIN
                    found     := true;
                    exit_loop := true
                    END
                ELSE
                    IF   res <> l_equal
                    THEN
                        exit_loop := true;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            exit_loop;
        (*ENDREPEAT*) 
        IF  NOT found
        THEN
            BEGIN
            (* no column to the right found, search to the left now *)
            exit_loop := false;
            i         := middle;
            REPEAT
                i := i - 1;
                IF  i < base_rec.bfirstindex
                THEN
                    exit_loop := true
                ELSE
                    BEGIN
                    col_ptr := a103GetColumn (base_rec, i);
                    s30cmp1 (col_ptr^.ccolumnn, 1,
                          ord (col_ptr^.ccolumnn_len),
                          column, 1, colname_len, res);
                    IF  (res = l_equal)                           AND
                        NOT (ctinvisible in col_ptr^.ccolpropset) AND
                        NOT (ctdropped   in col_ptr^.ccolpropset)
                    THEN
                        BEGIN
                        found     := true;
                        exit_loop := true
                        END
                    ELSE
                        IF  res <> l_equal
                        THEN
                            exit_loop := true;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            UNTIL
                exit_loop;
            (*ENDREPEAT*) 
            END;
        (*ENDIF*) 
        END;
&   IFDEF TRACE
    (*ENDIF*) 
(*ENDIF*) 
IF  found
THEN
    a061td_colinfo (col_ptr^, middle);
&endif
(*ENDIF*) 
colinfo_ptr := col_ptr;
a061exist_columnname := found
END;
 
(* PTS 1128197 D.T. *)
(*FUNCTION
      a061exist_columnindex (VAR base_rec : tak_baserecord;
      extcolno        : integer;
      VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
      VAR
      found        : boolean;
      upb          : integer;
      i            : integer;
      colno        : integer;
      col_ptr      : tak00_colinfo_ptr;
      BEGIN
      found       := false;
      colinfo_ptr := NIL;
      i           := base_rec.bfirstindex;
      upb         := base_rec.blastindex;
      WHILE (NOT found) AND (i<=upb) DO
      BEGIN
      colno   := i;
      col_ptr := a103GetColumn (base_rec, colno);
      found   := (col_ptr^.cextcolno = extcolno) AND
      (NOT (ctdropped in col_ptr^.ccolpropset));
      i       := succ(i);
      END;
&     IFDEF TRACE
      IF  found
      THEN
      a061td_colinfo (col_ptr^, colno);
&     endif
      colinfo_ptr := col_ptr;
      a061exist_columnindex := found
      END;*)
(*------------------------------*) 
 
FUNCTION
      a061exist_columnindex (VAR base_rec : tak_baserecord;
            extcolno        : integer;
            VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
VAR
      found        : boolean;
      colindex     : integer;
 
BEGIN
WITH base_rec DO
    colindex := bextcolindex[extcolno] + bfirstindex;
(*ENDWITH*) 
colinfo_ptr := a103GetColumn (base_rec, colindex);
(*    a06extcolno(base_rec, extcolno, colinfo_ptr); *)
found := (NOT (ctdropped in colinfo_ptr^.ccolpropset));
&IFDEF TRACE
IF  found
THEN
    a061td_colinfo (colinfo_ptr^, colinfo_ptr^.cextcolno);
&endif
(*ENDIF*) 
a061exist_columnindex := found
END;
 
(*------------------------------*) 
 
FUNCTION
      a061ExistColumnnameSequential (VAR base_rec : tak_baserecord;
            VAR column      : tsp00_KnlIdentifier;
            VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
VAR
      res          : tsp00_LcompResult;
      ix           : integer;
      colname_len  : integer;
      col_ptr      : tak00_colinfo_ptr;
 
BEGIN
a061ExistColumnnameSequential := false;
&ifdef trace
t01lidentifier (ak_sem, column);
&endif
colname_len := a061identifier_len (column);
colinfo_ptr := NIL;
ix          := base_rec.bfirstindex;
WHILE ix <= base_rec.blastindex DO
    BEGIN
    col_ptr := a103GetColumn (base_rec, ix);
    s30cmp1 (col_ptr^.ccolumnn, 1, ord (col_ptr^.ccolumnn_len),
          column, 1, colname_len, res);
    IF  res = l_equal
    THEN
        BEGIN
        a061ExistColumnnameSequential := true;
        colinfo_ptr := col_ptr;
        ix := base_rec.blastindex + 1 (* exit loop *)
        END
    ELSE
        ix := ix + 1;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a061eval_colname_len (VAR src : tak00_columninfo);
 
BEGIN
src.ccolumnn_len := chr (a061identifier_len (src.ccolumnn))
END;
 
(*------------------------------*) 
 
PROCEDURE
      a061get_colname (VAR col_info : tak00_columninfo;
            VAR colname  : tsp00_KnlIdentifier);
 
VAR
      b_err : tgg00_BasisError;
 
BEGIN
colname := a01_il_b_identifier;
(* PTS 1122898 E.Z. *)
IF  NOT (ctinvisible in col_info.ccolpropset)
THEN
    BEGIN
    b_err   := e_ok;
    SAPDB_PascalMove ('VAK061',   3,    
          ord(col_info.ccolumnn_len), sizeof (colname),
          @col_info.ccolumnn, 1, @colname, 1,
          ord(col_info.ccolumnn_len), b_err)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a061identifier_len (VAR id : tsp00_KnlIdentifier) : integer;
 
BEGIN
IF  g01unicode
THEN
    a061identifier_len := s30unilnr (@id,
          csp_unicode_blank, 1, sizeof (id))
ELSE
    a061identifier_len :=
          s30lnr (id, bsp_c1, 1, sizeof (id))
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a061old_to_new_identifier (VAR old : tak_oldidentifier;
            VAR new_ident : tsp00_KnlIdentifier);
 
VAR
      new_ptr : ^tak_oldidentifier;
 
BEGIN
new_ptr  := @new_ident;
new_ptr^ := old;
SAPDB_PascalForcedMove (sizeof (a01_il_b_identifier), sizeof (new_ident),
      @a01_il_b_identifier, 1, @new_ident, sizeof (old) + 1,
      sizeof (new_ident) - sizeof (old))
END;
 
(*------------------------------*) 
 
PROCEDURE
      a061put_systemkey (VAR acv : tak_all_command_glob;
            VAR base_rec : tak_baserecord);
 
VAR
      col_index : integer;
 
BEGIN
(* inserts the key column 'SYSKEY' CHAR(8) BYTE into  *)
(* the base catalog record allocated at address p_arr *)
a061app_columnname (acv, base_rec, a01_i_tablekey, col_index);
IF  acv.a_returncode = 0
THEN
    BEGIN
    WITH base_rec, a103GetColumn (base_rec, col_index)^ DO
        BEGIN
        ccolpropset  := [ ctkey ] + [ ctopt ];
        cextcolno    := bmaxcol;
        creccolno    := cextcolno;
        ctabno       := 1;
        cdatatyp     := dchb;
        cdatalen     := SURROGATE_MXGG00;
        cdatafrac    := cak_frac_offset;
        cinoutlen    := SURROGATE_MXGG00 + 1;
        cbinary      := false;
        WITH ccolstack DO
            BEGIN
            etype      := st_varkey;
            eop        := op_none;
            epos       := 1;
            elen_var   := SURROGATE_MXGG00 + 1;
            ecol_tab   := cgg_zero_c2
            END;
        (*ENDWITH*) 
        bkeycolcount := 1;
        blastkeyind  := col_index
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a061sort (VAR acv   : tak_all_command_glob;
            VAR base_rec          : tak_baserecord;
            last_used_expr_no     : integer;
            VAR duplicate_column  : boolean;
            VAR duplicate_colname : tsp00_KnlIdentifier);
      (*================================================*)
      (* sparr             : array to be sorted         *)
      (* duplicate_column  : indicates whether column   *)
      (*                     is double_defined          *)
      (* duplicate_colname : name of a duplicate column *)
      (*================================================*)
 
VAR
      ix            : integer;
      declare_found : boolean;
      decl_node     : integer;
      dupl_col_ptr  : tak00_colinfo_ptr;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
&   ifdef trace
    t01int4 (ak_sem, 'tablekind   ', ord (base_rec.btablekind));
    t01addr (ak_sem, 'bptr        ', @base_rec.bptr^);
    FOR ix := base_rec.bfirstindex TO base_rec.blastindex DO
        a061td_colinfo (a103GetColumn (base_rec, ix)^, ix);
    (*ENDFOR*) 
&   endif
    dupl_col_ptr := NIL;
    ak061sort (base_rec, dupl_col_ptr);
    duplicate_column := dupl_col_ptr <> NIL;
    IF  duplicate_column
    THEN
        a061get_colname (dupl_col_ptr^, duplicate_colname);
    (* Call with first and last index-position of array 'bcolumn' *)
    (*ENDIF*) 
    IF  (duplicate_column) AND (acv.a_is_ddl = no_ddl)
    THEN
        WITH acv DO
            BEGIN
            (* PTS 1106874 E.Z. *)
            declare_found:= (acv.a_resname_part <> NIL);
            decl_node:= a_ap_tree^[ 0 ].n_lo_level;
            WHILE ((decl_node <> 0) AND NOT declare_found) DO
                IF  ((a_ap_tree^[decl_node].n_proc = a63) AND
                    ( a_ap_tree^[decl_node].n_subproc = cak_x_decl_cursor))
                THEN
                    declare_found:= true
                ELSE
                    decl_node:= a_ap_tree^[ decl_node ].n_lo_level;
                (*ENDIF*) 
            (*ENDWHILE*) 
            IF  declare_found
            THEN
                BEGIN
&               IFDEF TRACE
                ak061print_sorted_names (base_rec);
&               ENDIF
                ak061rename_duplicate_columns (acv,
                      base_rec, last_used_expr_no);
                dupl_col_ptr := NIL;
                ak061sort (base_rec, dupl_col_ptr);
                duplicate_column := dupl_col_ptr <> NIL;
                IF  duplicate_column
                THEN
                    a061get_colname (dupl_col_ptr^, duplicate_colname);
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
&   IFDEF TRACE
    (*ENDIF*) 
    ak061print_sorted_names (base_rec);
&   ENDIF
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak061name_equal (VAR base_rec      : tak_baserecord;
            testcolindex      : integer;
            VAR equalcolindex : integer) : boolean;
 
VAR
      do_compare : boolean;
      res        : tsp00_LcompResult;
      cmp_ptr    : tak00_colinfo_ptr;
      test_ptr   : tak00_colinfo_ptr;
 
BEGIN
do_compare := true;
IF  testcolindex = base_rec.blastindex
THEN
    do_compare    := false
ELSE
    equalcolindex := testcolindex+1;
(*ENDIF*) 
IF  do_compare
THEN
    BEGIN
    test_ptr := a103GetColumn (base_rec, testcolindex);
    cmp_ptr  := a103GetColumn (base_rec, equalcolindex);
    s30cmp1 (test_ptr^.ccolumnn, 1, ord (test_ptr^.ccolumnn_len),
          cmp_ptr^.ccolumnn, 1, ord (cmp_ptr^.ccolumnn_len), res);
    ak061name_equal:= res = l_equal
    END
ELSE
    ak061name_equal := false;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak061rename_duplicate_columns (VAR acv : tak_all_command_glob;
            VAR base_rec      : tak_baserecord;
            last_used_expr_no : integer);
 
CONST
      c_exit_loop = csp_maxint2;
 
VAR
      found             : boolean;
      found1            : boolean;
      name_is_double    : boolean;
      expr_no           : tsp00_Int2;
      ix                : tsp00_Int4;
      testcolindex      : integer;
      equalcolindex     : integer;
      startexprcolindex : integer;
      stopexprcolindex  : integer;
      lastindex         : integer;
      maxcol            : integer;
      startexpr_ptr     : tak00_colinfo_ptr;
      stopexpr_ptr      : tak00_colinfo_ptr;
      colinfo_ptr       : tak00_colinfo_ptr;
      pTestCol          : tak00_colinfo_ptr;
      hcolinfo          : tak00_columninfo;
 
BEGIN
(* where are 'EXPRESSION-columns ? *)
expr_no              := 0;
hcolinfo.ccolpropset := [  ];
a61_new_expr_no (hcolinfo, expr_no);
found := a061exist_columnname (base_rec, hcolinfo.ccolumnn,
      startexpr_ptr);
&ifdef trace
a061td_colinfo (startexpr_ptr^, 0);
&endif
expr_no              := 98;
hcolinfo.ccolpropset := [  ];
a61_new_expr_no (hcolinfo, expr_no);
found1 := a061exist_columnname (base_rec, hcolinfo.ccolumnn,
      stopexpr_ptr);
&ifdef trace
a061td_colinfo (startexpr_ptr^, 0);
&endif
found := found OR found1;
IF  found OR (startexpr_ptr <> stopexpr_ptr)
THEN
    found := true
ELSE
    found := false;
(*ENDIF*) 
startexprcolindex := base_rec.bfirstindex;
stopexprcolindex  := base_rec.blastindex;
IF  found
THEN
    BEGIN
    ix                := base_rec.bfirstindex;
    WHILE ix <= base_rec.blastindex DO
        BEGIN
        IF  a103GetColumn (base_rec, ix) = startexpr_ptr
        THEN
            startexprcolindex := ix
        ELSE
            IF  a103GetColumn (base_rec, ix) = stopexpr_ptr
            THEN
                BEGIN
                stopexprcolindex := ix;
                ix               := c_exit_loop
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        ix := ix + 1;
        END;
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
expr_no       := last_used_expr_no;
equalcolindex := 1;
testcolindex  := base_rec.bfirstindex;
maxcol        := base_rec.bmaxcol;
lastindex     := base_rec.blastindex;
WHILE testcolindex <= base_rec.blastindex DO
    BEGIN
    IF  ak061name_equal (
        base_rec, testcolindex, equalcolindex)
    THEN
        BEGIN
        WITH base_rec, a103GetColumn (base_rec, equalcolindex)^ DO
            BEGIN
            pTestCol := a103GetColumn (base_rec, testcolindex);
            IF  ((ccolstack.epos > pTestCol^.ccolstack.epos) OR
                ((ctexpression in ccolpropset) AND
                (NOT(ctexpression in pTestCol^.ccolpropset))))
            THEN
                BEGIN
                colinfo_ptr := pTestCol;
                bcolumn[ testcolindex ]  :=
                      base_rec.bcolumn[equalcolindex];
                bcolumn[ equalcolindex ] := colinfo_ptr
                END;
            (* always the colinfo with lower bufindex/colindex-value *)
            (* will change its name, always testbuf/colindex         *)
            (*ENDIF*) 
            a061colinfo_to_var (bcolumn[ testcolindex ]^, hcolinfo);
            name_is_double   := false;
            REPEAT
                a61_new_expr_no (hcolinfo, expr_no);
                IF  found
                THEN
                    ak061test_one_name ( base_rec,
                          startexprcolindex, stopexprcolindex,
                          hcolinfo.ccolumnn,
                          ord(hcolinfo.ccolumnn_len), name_is_double);
                (*ENDIF*) 
            UNTIL
                NOT name_is_double;
            (*ENDREPEAT*) 
            base_rec.blastindex := testcolindex - 1;
            a061app_columnname (acv,
                  base_rec, hcolinfo.ccolumnn, testcolindex);
            a061copy_colinfo (hcolinfo, base_rec.bcolumn[testcolindex]^);
            base_rec.blastindex := lastindex;
            base_rec.bmaxcol    := maxcol
            END
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    testcolindex:= succ(testcolindex)
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak061sort (VAR base_rec          : tak_baserecord;
            VAR dupl_col_ptr           : tak00_colinfo_ptr);
 
VAR
      exit_while : boolean;
      res1       : tsp00_LcompResult;
      res2       : tsp00_LcompResult;
      x_prop     : tak00_colpropset;
      count      : integer;
      i          : integer;
      j          : integer;
      l          : integer;
      r          : integer;
      index      : integer;
      st_ptr     : integer;
      x          : tak00_colinfo_ptr;
      y          : tak00_colinfo_ptr;
      el         : tak00_colinfo_ptr;
 
      stack      : ARRAY[1..16] OF RECORD
            left  : integer;
            right : integer;
      END;
 
 
BEGIN
st_ptr         := 1;
stack[1].left  := base_rec.bfirstindex;
stack[1].right := base_rec.bfirstindex + base_rec.bmaxcol - 1;
REPEAT
    l        := stack[st_ptr].left;
    r        := stack[st_ptr].right;
    st_ptr   := st_ptr - 1;
&   ifdef trace
    t01int4 (ak_sem, 'from st left', l);
    t01int4 (ak_sem, 'from st righ', r);
&   endif
    REPEAT
        i        := l;
        j        := r;
&       ifdef trace
        t01int4 (ak_sem, 'i           ', i);
        t01int4 (ak_sem, 'j           ', j);
&       endif
        index    := (l + r) DIV 2;
        x        := base_rec.bcolumn[index];
        x_prop   := x^.ccolpropset;
        count    := 0;
&       ifdef trace
        t01buf (ak_sem, x^.ccolumnn, 1, ord(x^.ccolumnn_len));
&       endif
        REPEAT
            exit_while := false;
            res1 := l_equal;
            res2 := l_equal;
            WHILE NOT exit_while DO
                BEGIN
                y := base_rec.bcolumn[i];
                s30cmp1 (y^.ccolumnn, 1, ord(y^.ccolumnn_len),
                      x^.ccolumnn, 1, ord(x^.ccolumnn_len), res1);
                IF  res1 = l_less
                THEN
                    i := i + 1
                ELSE
                    exit_while := true
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            (* searches to the right for first element  >= x    *)
            (* i refers to this element                         *)
            exit_while := false;
            WHILE NOT exit_while DO
                BEGIN
                y := base_rec.bcolumn[j];
                s30cmp1 (y^.ccolumnn, 1, ord (y^.ccolumnn_len),
                      x^.ccolumnn, 1, ord (x^.ccolumnn_len), res2);
                IF  res2 = l_greater
                THEN
                    j := j - 1
                ELSE
                    exit_while := true;
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            (* searches to the left for first element <= x *)
            (* j refers to this element                    *)
            IF  i < j
            THEN
                BEGIN
                IF  NOT (ctdropped   in x_prop)            AND
                    NOT (ctinvisible in x_prop)
                THEN
                    BEGIN
                    (* column with name x found *)
                    IF  (res1 = l_equal)                           AND
                        NOT (ctdropped   in
                        base_rec.bcolumn[i]^.ccolpropset) AND
                        NOT (ctinvisible
                        in base_rec.bcolumn[i]^.ccolpropset)
                    THEN
                        count := count + 1;
                    (*ENDIF*) 
                    IF  (res2 = l_equal) AND
                        NOT (ctdropped   in
                        base_rec.bcolumn[j]^.ccolpropset) AND
                        NOT (ctinvisible
                        in base_rec.bcolumn[j]^.ccolpropset)
                    THEN
                        count := count + 1;
                    (*ENDIF*) 
                    END;
                (* Swapping-Part *)
                (* Copy first element into dummy variable *)
                (*ENDIF*) 
                el                  := base_rec.bcolumn[i];
                base_rec.bcolumn[i] := base_rec.bcolumn[j];
                base_rec.bcolumn[j] := el;
                (* Swapping via record assignment*)
                i := i + 1;
                j := j - 1;
                END
            ELSE
                IF  i = j
                THEN
                    BEGIN
                    IF  NOT (ctdropped   in x_prop)                AND
                        NOT (ctinvisible in x_prop)                AND
                        NOT (ctdropped   in
                        base_rec.bcolumn[i]^.ccolpropset) AND
                        NOT (ctinvisible
                        in base_rec.bcolumn[i]^.ccolpropset)
                    THEN
                        (* motivation: the two initial while loops  *)
                        (* yield cname<=x and cname>=x; ==> cname=x *)
                        count := count + 1;
                    (*ENDIF*) 
                    i := i + 1;
                    j := j - 1;
                    END;
                (* ===================================================*)
                (* At this point of execution there are only elements *)
                (* <= x to the left of i and elements >=x             *)
                (* to the right of j (excluding positions i and j)    *)
                (* ===================================================*)
                (*ENDIF*) 
            (*ENDIF*) 
        UNTIL
            i > j; (* all elements examined *)
        (*ENDREPEAT*) 
        (*==========================================================*)
        (* at this point in execution the array is partitioned      *)
        (* case1 : i=j+2; (then also array[ i ]= x )                *)
        (* case2 : i=j+1;                                           *)
        (*==========================================================*)
        IF  count > 1
        THEN
            BEGIN
            IF  dupl_col_ptr = NIL
            THEN
                dupl_col_ptr := x
            ELSE
                IF  x^.cextcolno < dupl_col_ptr^.cextcolno
                THEN
                    dupl_col_ptr := x;
&               IFDEF TRACE
                (*ENDIF*) 
            (*ENDIF*) 
            t01str30 (ak_sem,'duplicate_column found:       ');
            t01buf (ak_sem, x^.ccolumnn, 1, ord(x^.ccolumnn_len));
&           ENDIF
            END;
        (*ENDIF*) 
        IF  j - l < r - i
        THEN
            BEGIN
            IF  i < r
            THEN
                BEGIN
                st_ptr              := st_ptr + 1;
                stack[st_ptr].left  := i;
                stack[st_ptr].right := r
                END;
            (*ENDIF*) 
            r := j
            END
        ELSE
            BEGIN
            IF  l < j
            THEN
                BEGIN
                st_ptr              := st_ptr + 1;
                stack[st_ptr].left  := l;
                stack[st_ptr].right := j
                END;
            (*ENDIF*) 
            l := i
            END;
        (*ENDIF*) 
    UNTIL
        l >= r;
    (*ENDREPEAT*) 
UNTIL
    st_ptr = 0;
(*ENDREPEAT*) 
END; (*sort*)
 
(*------------------------------*) 
 
PROCEDURE
      ak061test_one_name (VAR base_rec : tak_baserecord;
            startcolindex      : integer;
            stopcolindex       : integer;
            VAR testname       : tsp00_KnlIdentifier;
            testname_len       : integer;
            VAR name_is_double : boolean);
 
VAR
      res       : tsp00_LcompResult;
      colindex  : integer;
      col_ptr   : tak00_colinfo_ptr;
 
BEGIN
&ifdef trace
t01int4 (ak_sem, 'stopcolindex', stopcolindex);
&endif
name_is_double := false;
colindex := startcolindex;
WITH base_rec DO
    WHILE (colindex <= stopcolindex) AND NOT name_is_double DO
        BEGIN
        col_ptr := a103GetColumn (base_rec, colindex);
&       ifdef trace
        a061td_colinfo (col_ptr^, colindex);
&       endif
        s30cmp1 (col_ptr^.ccolumnn, 1, ord(col_ptr^.ccolumnn_len),
              testname, 1, testname_len, res);
        IF  res = l_equal
        THEN
            name_is_double:= true
        ELSE
            colindex:= succ(colindex)
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
(*ENDWITH*) 
END;
 
&ifdef trace
(*------------------------------*) 
 
PROCEDURE
      a061td_colinfo (VAR colinfo : tak00_columninfo;
            index : integer);
 
VAR
      put : boolean;
 
BEGIN
put := true;
IF  put
THEN
    BEGIN
    t01int4 (ak_sem, 'Col Index   ', index);
    t01buf  (ak_sem, colinfo.ccolumnn, 1, ord(colinfo.ccolumnn_len));
    t01int4 (ak_sem, 'cextcolno   ', colinfo.cextcolno);
    t01int4 (ak_sem, 'creccolno   ', colinfo.creccolno);
    t01int4 (ak_sem, 'ctabno      ', colinfo.ctabno);
    t01int4 (ak_sem, 'cdatatyp    ', ord(colinfo.cdatatyp));
    t01int4 (ak_sem, 'cdatalen    ', colinfo.cdatalen);
    t01int4 (ak_sem, 'cinoutlen   ', colinfo.cinoutlen);
    t01int4 (ak_sem, 'cdatafrac   ', colinfo.cdatafrac);
    t01int4 (ak_sem, 'cnextind    ', colinfo.cnextind);
    IF  ctopt in colinfo.ccolpropset
    THEN
        t01int4 (ak_sem, 'ctopt       ', 1)
    ELSE
        t01int4 (ak_sem, 'mandatory   ', 1);
    (*ENDIF*) 
    IF  ctinvisible in colinfo.ccolpropset
    THEN
        t01int4 (ak_sem, 'ctinvisible ', 1);
    (*ENDIF*) 
    IF  ctdropped in colinfo.ccolpropset
    THEN
        t01int4 (ak_sem, 'ctdropped   ', 1);
    (*ENDIF*) 
    IF  ctkey in colinfo.ccolpropset
    THEN
        t01int4 (ak_sem, 'ctkey       ', 1);
    (*ENDIF*) 
    IF  ctmulti in colinfo.ccolpropset
    THEN
        t01int4 (ak_sem, 'ctmulti     ', 1);
    (*ENDIF*) 
    t01stackentry (ak_sem, colinfo.ccolstack, index);
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak061print_sorted_names (VAR base_rec : tak_baserecord);
 
VAR
      i, j    : integer;
      x       : tak00_colinfo_ptr;
 
BEGIN
j := 0;
t01str30 (ak_sem, 'Sortierte Spaltenliste:       ');
FOR i := base_rec.bfirstindex TO base_rec.blastindex DO
    BEGIN
    j := j + 1;
    t01int4 (ak_sem,'Nummer:     ', j);
    x       := a103GetColumn (base_rec, i);
    t01buf (ak_sem, x^.ccolumnn, 1, ord(x^.ccolumnn_len))
    END;
(*ENDFOR*) 
END;
 
&endif
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
