.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.tt 1 $SQL$Project Distributed Database System$VAK642$
.tt 2 $$$
.TT 3 $ElkeZ$Execute_factor_constants$$2000-08-29$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : Execute_factor_constants
=========
.sp
Purpose : Processing of a factor of a value expression
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        VAR
              a642standard_colinfo : tak00_columninfo;
 
        PROCEDURE
              a642colinfo_init;
 
        PROCEDURE
              a642other_than_column (
                    VAR acv   : tak_all_command_glob;
                    VAR dmli  : tak_dml_info;
                    VAR frec  : tak_factorrec;
                    VAR colin : tak00_scolinf;
                    act_node  : integer);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01identifier_size    : integer;
              a01_il_b_identifier   : tsp00_KnlIdentifier;
              a01char_size          : integer;
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05_constant_get (
                    VAR acv       : tak_all_command_glob;
                    ni            : integer;
                    VAR colinfo   : tak00_columninfo;
                    may_be_longer : boolean;
                    mv_dest       : integer;
                    VAR dest      : tsp00_MoveObj;
                    destpos       : integer;
                    VAR actlen    : integer);
 
        PROCEDURE
              a05var_constant_get (
                    VAR acv          : tak_all_command_glob;
                    ni               : integer;
                    VAR colinfo      : tak00_columninfo;
                    may_be_longer    : boolean;
                    VAR valfieldno   : integer;
                    VAR valstart     : tsp00_MoveObjPtr;
                    VAR actlen       : integer);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061colinfo_to_var (
                    VAR src : tak00_columninfo;
                    VAR dst : tak00_columninfo);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10dispose (
                    VAR acv : tak_all_command_glob;
                    VAR p   : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              AK_Synonym : VAK23;
 
        FUNCTION
              a23exist_sequence (
                    VAR acv         : tak_all_command_glob;
                    tree_index      : integer;
                    inclusiveSerial : boolean;
                    VAR seq_buf     : tak_sysbufferaddress;
                    VAR seq_owner   : tsp00_KnlIdentifier;
                    VAR seq_name    : tsp00_KnlIdentifier) : boolean;
 
      ------------------------------ 
 
        FROM
              DML_Parts : VAK55;
 
        PROCEDURE
              a55_describe_value (
                    VAR acv       : tak_all_command_glob;
                    VAR dmli      : tak_dml_info;
                    VAR colinfo   : tak00_columninfo;
                    nodeno        : integer;
                    res_buf_index : integer;
                    in_datapart   : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Insert : VAK56;
 
        PROCEDURE
              a56one_default_value (
                    VAR acv     : tak_all_command_glob;
                    VAR dmli    : tak_dml_info;
                    VAR colinfo : tak00_columninfo;
                    with_length : tak_fp_kind_type);
 
        PROCEDURE
              a56get_longlit (
                    VAR acv           : tak_all_command_glob;
                    VAR dmli          : tak_dml_info;
                    datatyp           : tsp00_DataType;
                    dml_node          : tsp00_Int2);
 
        PROCEDURE
              a56_datatype (
                    in_datatype      : char;
                    VAR out_datatype : tsp00_DataType);
 
      ------------------------------ 
 
        FROM
              Execute_Select_Expression : VAK660;
 
        PROCEDURE
              a660fsame_pred (
                    VAR acv             : tak_all_command_glob;
                    same_node           : integer;
                    VAR first_same_node : integer;
                    VAR node_node       : integer);
 
        FUNCTION
              a660lower_pred (
                    VAR acv    : tak_all_command_glob;
                    lower_node : integer) : integer;
 
      ------------------------------ 
 
        FROM
              Execute_factor_col_function : VAK641;
 
        PROCEDURE
              a641string_set_operator (
                    VAR acv      : tak_all_command_glob;
                    operator     : tgg00_StackOpBuildIn;
                    destlength   : integer;
                    sourcelength : integer;
                    tab1         : char;
                    tab2         : char);
 
      ------------------------------ 
 
        FROM
              Execute_Where_Part : VAK65;
 
        PROCEDURE
              a65ch_format (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    VAR startstack : integer;
                    VAR colin      : tak00_scolinf;
                    left_type      : tsp00_DataType;
                    d_type         : tsp00_DataType);
 
        PROCEDURE
              a65_look_for_datatypes (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    first_node : integer);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code           : tgg04_CodeGlobals;
              g01unicode        : boolean;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove   (
                    mod_id         : tsp00_C6;
                    mod_intern_num : tsp00_Int4;
                    size1          : tsp00_Int4;
                    size2          : tsp00_Int4;
                    val1           : tsp00_MoveObjPtr;
                    p1             : tsp00_Int4;
                    val2           : tsp00_MoveObjPtr;
                    p2             : tsp00_Int4;
                    cnt            : tsp00_Int4;
                    VAR e          : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              PUTSTRING-Conversions : VSP43;
 
        PROCEDURE
              s43lfrac (
                    VAR source : tsp00_MoveObj;
                    spos        : tsp00_Int4;
                    slen        : integer;
                    VAR diglen  : integer;
                    VAR digfrac : integer;
                    VAR bytelen : integer);
 
      ------------------------------ 
 
        FROM
              Patterns : VSP49;
 
        PROCEDURE
              s49build_pattern (
                    VAR pat_buffer : tsp00_MoveObj;
                    start       : tsp00_Int4;
                    stop        : tsp00_Int4;
                    escape_char : char;
                    escape      : boolean;
                    string      : boolean;
                    sqlmode     : tsp00_SqlMode;
                    VAR ok      : boolean);
 
        PROCEDURE
              s49uni_build_pattern (
                    VAR pat_buffer : tsp00_MoveObj;
                    start       : tsp00_Int4;
                    stop        : tsp00_Int4;
                    escape_char : tsp00_C2;
                    escape      : boolean;
                    sqlmode     : tsp00_SqlMode;
                    VAR ok      : boolean);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR m         : tgg00_MessBlock);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
&       endif
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              a56_datatype;
 
              tsp00_DataType char
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ElkeZ
.sp
.cp 3
Created : 1985-05-29
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-08-29
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
.sp 2
OTHER_THAN_COLUMN
.sp
INPUT :
.in +11
.of 12
acv: especially ap_tree
.sp
.of 12
dmli: especially dm_datatype, atcolbuf
.sp
.of 12
frec: Temporary description of the factor and of the processing status
.sp
.of 12
act_node: Tree node at which the function begins
.sp;.in -11
OUTPUT :
.in +11
.of 12
acv: especially mess_buf, part1
.sp
.of 12
dmli: especially dm_datatype
.sp
.of 12
frec: Temporary description of the factor and of the processing status
.sp
.of 12
colin: Description of the factor processed
.sp
.in -11
 
Handles all other factors that do not contain functions or that are not
columns.
.br
More specifically, first of all, the description of the factors is entered in
'colin' and then the stack entries are created. A distinction is made between
the following cases:
.in 5
'n_symb' = 's_rowno'
.br;Since 'ROWNO' is a function that has no operands and that supplies at
maximum an int4 value, the length can be specified with 10. 'st_rowno' is
inserted as the stack type.
.sp
n_symb' = 's_stamp'
.br;If there is information in 'd_colbuf', it is transferred to 'colin';
otherwise (i.e. the last-handled factor was an expression, with the result that
the information was destroyed; see COL_FUNCTION), standard information is
used. An operator stack entry is created in the stack with 'op_stamp' as
operator.
.sp
'n_proc' = a67 :
.br;This is a special node that contains information on the data type, the
output position and output length in the case of a subquery. This makes it
possible to compare the data types and to determine 'dm_datatype' and to enter
the length and position of the output in the stack (with VALUE_STACK_ENTRY).
.sp
'n_symb' = 's_date', 's_time'
.br;Apart from the determination of 'colin', it must be considered if
only parseinformation is to be build out of the command.
In this case, the value must not
be determined now,
but only at the time of execution. This is indicated by the
setting of 'fr_describ', with the result that special information is created in
the stack.
.sp
'n_symb' = 's_parameter_name' :
.br;In the case of a parameter, on the basis of the expected data type,
standard values are entered in 'colin' in order to create a field description
in case the information from 'd_colbuf' cannot be used. If 'dunknown' is
specified as the expected data type, 'par_error' is returned as the
'a_returncode', which leads in some cases to re-calling with another data type
(see, for example, SET_FUNCTION).
.sp
ak642easy_parameter
.br;In the case of a parameter, ak642easy_parameter is called. This proce-
dure attempts to get the description of the parameter from the parameter-list
in acv.a_parameter_spec. (The parameter-list will be created in the
procedure ak92parameter_list. The data of this list stands in varpart2.)
If no list found or a mistake is found in the parameter-description,
ak642parameter is called to describe the parameter.
.sp
In all other cases, use is made either of the information from 'd_colbuf', if
available, or of symbol-specific default values.
.sp
.in -11
After the field description has been determined, the stack entries must be
created; in the case of a parameter ('fr_describ' is 'true'), parse information
is created with A55_DESCRIB_VALUE (the value stack entry is entered with
VALUE_STACK_ENTRY). Otherwise, if numbers are specified, an attempt is made to
determine the length of the result (with S43LFRAC), so that calculations are
not always performed with the maximum length although the result is smaller. In
the processing of a 'LIKE' condition (of the search pattern on the right-hand
side), the wildcards are replaced by chr(255) and chr(254) in order to get
independency of the code type. Finally, a
distinction is also made as to whether a 'CREATE VIEW' statement is being
processed ('d_view') and whether the symbols 's_date', 's_time', 's_user' and
's_usergroup' have been specified. In these cases, the values must not be
determined until the VIEW is used. This special stack entry is created with
VIEW_STACK_ENTRY. In all other cases VALUE_STACK_ENTRY is called.
 
.sp 2
A64_COLINFO_INIT
.sp
Enters the standard values in the global variable A64_STANDARD_COLINFO.
.sp 2
VALUE_STACK_ENTRY
.sp
Enters in the stack a stack entry with stack type 'st_value' and a reference to
'part2', where the value begins and with what length.
.sp 2
VIEW_STACK_ENTRY
.sp
Creates, in the case of a CREATE VIEW and symbol 's_date', 's_time', 's_user'
and 's_usergroup', a stack entry that receives the symbol-specific type as the
stack type, the reference to 'part2' as epos, the expected length ('cinoutlen')
as 'elen_var' in order to keep space free, and the fill-byte as
'ecol_tab[ 2 ]'.
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_string                = true (* s49build_pattern *);
      c_value_to_be_truncated = true (* ak642value_stack_entry *);
 
 
(*------------------------------*) 
 
PROCEDURE
      ak642byte_string (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info;
            VAR frec   : tak_factorrec;
            VAR colinf : tak00_columninfo;
            act_node   : integer);
 
VAR
      leng            : integer;
      datatype_found  : boolean;
      new_n_symb      : tak_sc_symbol;
 
BEGIN
WITH acv, a_ap_tree^[ act_node ], dmli, frec DO
    IF  d_colptr <> NIL
    THEN
        WITH colinf DO
            BEGIN
            a061colinfo_to_var (d_colptr^, colinf);
            IF  g01unicode
            THEN
                leng := (n_length + 3) DIV 4
            ELSE
                leng := (n_length+1) DIV 2;
            (*ENDIF*) 
            IF  (((d_datatype = dchb) OR (d_datatype = dunknown))
                AND (cdatatyp = dchb))
            THEN
                BEGIN
                d_datatype := dchb;
                cdatalen := leng;
                cinoutlen := succ(leng)
                END
            ELSE
                fr_error := true
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    ELSE
        BEGIN
        colinf := a642standard_colinfo;
        datatype_found := false;
        new_n_symb := n_symb;
        ak642_is_long_literal (acv, dmli, colinf, new_n_symb, datatype_found);
        IF  NOT datatype_found
        THEN
            (* PTS 1118052 E.Z. *)
            IF  ((d_datatype = dunknown) OR
                (d_datatype = dnonumber) OR
                (d_datatype = dchb))
            THEN
                BEGIN
                d_datatype := dchb;
                WITH colinf DO
                    BEGIN
                    cdatatyp := dchb;
                    IF  g01unicode
                    THEN
                        cdatalen := (n_length + 3) DIV 4
                    ELSE
                        cdatalen := (n_length+1) DIV 2;
                    (*ENDIF*) 
                    cinoutlen := succ(cdatalen)
                    END
                (*ENDWITH*) 
                END
            ELSE
                fr_error := true
            (*ENDIF*) 
        ELSE
            IF  colinf.cdatatyp in [ dstra, dstrb, dstruni, dlonga, dlongb, dlonguni ]
            THEN
                BEGIN
                a56get_longlit (acv, dmli, colinf.cdatatyp, act_node);
                n_symb := new_n_symb;
                fr_describ := true;
                END
            ELSE
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak642constant (
            VAR acv   : tak_all_command_glob;
            VAR dmli  : tak_dml_info;
            VAR frec  : tak_factorrec;
            VAR colin : tak00_scolinf;
            act_node  : integer);
 
VAR
      use_datatype    : tsp00_DataType;
      colinf          : tak00_columninfo;
      startstack      : integer;
      first_same_node : integer;
      next_upper_node : integer;
      node_diff       : integer;
      param_count     : integer;
      save_symb       : tak_sc_symbol;
 
BEGIN
colinf.cdatatyp  := dunknown;
colinf.cinoutlen := 0;
WITH acv, a_ap_tree^[ act_node ], dmli, frec DO
    BEGIN
    save_symb := n_symb;
    CASE n_symb OF
        s_pi :
            IF  ((d_datatype <> dunknown) AND
                ( d_datatype <> dnumber ) AND
                ( d_datatype <> dfixed  ) AND
                ( d_datatype <> dfloat  ))
            THEN
                fr_error := true
            ELSE
                BEGIN
                d_datatype := dnumber;
                fr_getnumb := true;
                WITH colinf, ccolstack DO
                    BEGIN
                    colinf    := a642standard_colinfo;
                    cdatatyp  := dfloat;
                    cdatalen  := csp_fixed;
                    (* PTS 1107685 E.Z. *)
                    cdatafrac := csp_fixed-1+cak_frac_offset;
                    cinoutlen := NUMBER_MXGG04
                    END
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
        s_true, s_false :
            IF  NOT (d_datatype in [ dunknown, dboolean ])
            THEN
                fr_error := true
            ELSE
                BEGIN
                d_datatype := dboolean;
                WITH colinf DO
                    BEGIN
                    colinf := a642standard_colinfo;
                    cdatatyp := dboolean;
                    cdatalen := 1;
                    cinoutlen := succ(cdatalen)
                    END;
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
        s_byte_string :
            ak642byte_string (acv, dmli, frec, colinf, act_node);
        s_date :
            IF  NOT (d_datatype in [ dunknown, dnonumber,
                dcha, ddate, dunicode ])
            THEN
                fr_error := true
            ELSE
                BEGIN
                IF  a_init_ex_kind = only_parsing
                THEN
                    d_param_st_index := a_mblock.mb_qual^.mfirst_free;
                (*ENDIF*) 
                WITH colinf DO
                    BEGIN
                    colinf := a642standard_colinfo;
                    IF  (a_dt_format = dtf_normal) OR
                        (d_datatype <> dunicode)
                    THEN
                        cdatalen := mxsp_date
                    ELSE
                        cdatalen := mxsp_extdate;
                    (*ENDIF*) 
                    IF  d_colptr <> NIL
                    THEN
                        IF  d_colptr^.cdatalen < cdatalen
                        THEN
                            cdatalen := d_colptr^.cdatalen;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  d_datatype = dunicode
                    THEN
                        BEGIN
                        cdatatyp  := dunicode;
                        cinoutlen := succ(cdatalen*2)
                        END
                    ELSE
                        BEGIN
                        cdatatyp := ddate;
                        cinoutlen := succ(cdatalen)
                        END
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                IF  ((d_datatype = dunknown) OR
                    (d_datatype = dnonumber) OR
                    (d_datatype = dduration) OR
                    (d_datatype = dcha))
                THEN
                    d_datatype := ddate;
                (*ENDIF*) 
                IF  a_cmd_segment_header.sp1c_mess_type = sp1m_parse
                THEN
                    fr_describ := true
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        s_time, s_midnight :
            IF  NOT (d_datatype in [ dunknown, dnonumber,
                dcha, dtime, dunicode ])
            THEN
                fr_error := true
            ELSE
                BEGIN
                IF  a_init_ex_kind = only_parsing
                THEN
                    d_param_st_index := a_mblock.mb_qual^.mfirst_free;
                (*ENDIF*) 
                WITH colinf DO
                    BEGIN
                    colinf := a642standard_colinfo;
                    IF  (a_dt_format = dtf_normal) OR
                        (d_datatype <> dunicode)
                    THEN
                        cdatalen := mxsp_time
                    ELSE
                        cdatalen := mxsp_exttime;
                    (*ENDIF*) 
                    IF  d_colptr <> NIL
                    THEN
                        IF  d_colptr^.cdatalen < cdatalen
                        THEN
                            cdatalen := d_colptr^.cdatalen;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  d_datatype = dunicode
                    THEN
                        BEGIN
                        cdatatyp  := dunicode;
                        cinoutlen := succ(cdatalen*2)
                        END
                    ELSE
                        BEGIN
                        cdatatyp := dtime;
                        cinoutlen := succ(cdatalen)
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                IF  ((d_datatype = dunknown) OR
                    (d_datatype = dnonumber) OR
                    (d_datatype = dduration) OR
                    (d_datatype = dcha))
                THEN
                    d_datatype := dtime;
                (*ENDIF*) 
                IF  ((a_cmd_segment_header.sp1c_mess_type = sp1m_parse) AND
                    (n_symb = s_time))
                THEN
                    fr_describ := true
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (* PTS 1116175 E.Z. *)
        s_utcdate,
        s_timestamp :
            IF  NOT (d_datatype in [ dunknown, dnonumber,
                dcha, dtimestamp, dunicode (*, ddate, dtime*)
                ])
            THEN
                fr_error := true
            ELSE
                BEGIN
                IF  a_init_ex_kind = only_parsing
                THEN
                    d_param_st_index := a_mblock.mb_qual^.mfirst_free;
                (*ENDIF*) 
                WITH colinf DO
                    BEGIN
                    colinf   := a642standard_colinfo;
                    IF  (a_dt_format = dtf_normal) OR
                        (d_datatype <> dunicode)
                    THEN
                        cdatalen := mxsp_timestamp
                    ELSE
                        cdatalen := mxsp_exttimestamp;
                    (*ENDIF*) 
                    IF  d_colptr <> NIL
                    THEN
                        IF  d_colptr^.cdatalen < cdatalen
                        THEN
                            cdatalen := d_colptr^.cdatalen;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  d_datatype = dunicode
                    THEN
                        BEGIN
                        cdatatyp  := dunicode;
                        cinoutlen := succ(cdatalen*2)
                        END
                    ELSE
                        BEGIN
                        cdatatyp := dtimestamp;
                        cinoutlen := succ(cdatalen)
                        END
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                IF  ((d_datatype = dunknown) OR
                    (d_datatype = dnonumber) OR
                    (d_datatype = dduration) OR
                    (d_datatype = dcha))
                THEN
                    d_datatype := dtimestamp;
                (*ENDIF*) 
                IF  a_cmd_segment_header.sp1c_mess_type = sp1m_parse
                THEN
                    fr_describ := true
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (* PTS 1125159 E.Z. *)
        s_now :
            IF  NOT (d_datatype in [ dunknown, dnonumber,
                dcha, dtimestamp, dunicode, ddate, dtime ])
            THEN
                fr_error := true
            ELSE
                BEGIN
                IF  a_init_ex_kind = only_parsing
                THEN
                    d_param_st_index := a_mblock.mb_qual^.mfirst_free;
                (*ENDIF*) 
                WITH colinf DO
                    BEGIN
                    colinf   := a642standard_colinfo;
                    CASE d_datatype OF
                        ddate :
                            BEGIN
                            n_symb    := s_date;
                            cdatalen  := mxsp_date;
                            cinoutlen := succ(cdatalen);
                            cdatatyp  := ddate;
                            END;
                        dtime :
                            BEGIN
                            n_symb    := s_time;
                            cdatalen  := mxsp_time;
                            cinoutlen := succ(cdatalen);
                            cdatatyp  := dtime;
                            END;
                        OTHERWISE :
                            BEGIN
                            n_symb := s_timestamp;
                            IF  (a_dt_format = dtf_normal) OR
                                (d_datatype <> dunicode)
                            THEN
                                cdatalen := mxsp_timestamp
                            ELSE
                                cdatalen := mxsp_exttimestamp;
                            (*ENDIF*) 
                            IF  d_colptr <> NIL
                            THEN
                                IF  d_colptr^.cdatalen < cdatalen
                                THEN
                                    cdatalen := d_colptr^.cdatalen;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            IF  d_datatype = dunicode
                            THEN
                                BEGIN
                                cdatatyp  := dunicode;
                                cinoutlen := succ(cdatalen*2)
                                END
                            ELSE
                                BEGIN
                                cdatatyp := dtimestamp;
                                cinoutlen := succ(cdatalen)
                                END;
                            (*ENDIF*) 
                            IF  ((d_datatype = dunknown) OR
                                (d_datatype = dnonumber) OR
                                (d_datatype = dduration) OR
                                (d_datatype = dcha))
                            THEN
                                d_datatype := dtimestamp;
                            (*ENDIF*) 
                            END;
                        END;
                    (*ENDCASE*) 
                    END;
                (*ENDWITH*) 
                IF  a_cmd_segment_header.sp1c_mess_type = sp1m_parse
                THEN
                    fr_describ := true
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        s_timezone :
            IF  ((d_datatype <> dunknown) AND
                ( d_datatype <> dnumber ) AND
                ( d_datatype <> dfixed  ) AND
                ( d_datatype <> dfloat  ))
            THEN
                fr_error := true
            ELSE
                BEGIN
                d_datatype := dnumber;
                fr_getnumb := true;
                WITH colinf, ccolstack DO
                    BEGIN
                    colinf    := a642standard_colinfo;
                    cdatatyp  := dfixed;
                    cdatalen  := cak_time_durationlen;
                    (* PTS 1107685 E.Z. *)
                    cdatafrac := cak_frac_offset;
                    cinoutlen := ((cdatalen+1) DIV 2) + 2
                    END;
                (*ENDWITH*) 
                (* PTS 1109925 E.Z. *)
                IF  a_cmd_segment_header.sp1c_mess_type = sp1m_parse
                THEN
                    fr_describ := true
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (* PTS 1109925 E.Z. *)
        s_utcdiff :
            IF  ((d_datatype <> dunknown) AND
                ( d_datatype <> dnumber ) AND
                ( d_datatype <> dfixed  ) AND
                ( d_datatype <> dfloat  ))
            THEN
                fr_error := true
            ELSE
                BEGIN
                d_datatype := dnumber;
                fr_getnumb := true;
                WITH colinf, ccolstack DO
                    BEGIN
                    colinf    := a642standard_colinfo;
                    cdatatyp  := dfixed;
                    cdatalen  := cak_utcdiff_len;
                    cdatafrac := cak_utcdiff_frac + cak_frac_offset;
                    cinoutlen := ((cdatalen+1) DIV 2) + 2
                    END;
                (*ENDWITH*) 
                (* PTS 1109925 E.Z. *)
                IF  a_cmd_segment_header.sp1c_mess_type = sp1m_parse
                THEN
                    fr_describ := true
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        s_uid :
            IF  ((d_datatype <> dunknown) AND
                ( d_datatype <> dnumber ) AND
                ( d_datatype <> dfixed  ) AND
                ( d_datatype <> dfloat  ))
            THEN
                fr_error := true
            ELSE
                BEGIN
                d_datatype := dnumber;
                fr_getnumb := true;
                WITH colinf, ccolstack DO
                    BEGIN
                    colinf    := a642standard_colinfo;
                    cdatatyp  := dfixed;
                    cdatalen  := csp_resnum_deflen;
                    (* PTS 1107685 E.Z. *)
                    cdatafrac := cak_frac_offset;
                    cinoutlen := ((cdatalen+1) DIV 2) + 2
                    END
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
        s_string_literal, s_user, s_usergroup, s_current_schema,
        (* PTS 1111797 E.Z. *)
        s_sysdba, s_degree,
        s_database :
            ak642string_user (acv, dmli, frec, colinf, act_node);
        s_unsigned_integer,
        s_fixed_point_literal,
        s_floating_point_literal :
            BEGIN
            IF  ((d_datatype <> dunknown) AND
                ( d_datatype <> dnumber ) AND
                ( d_datatype <> dfixed  ) AND
                ( d_datatype <> dfloat  ))
            THEN
                fr_error := true
            ELSE
                BEGIN
                d_datatype := dnumber;
                fr_getnumb := true;
                IF  ((a_is_ddl <> ddl_create_table)  AND
                    ( a_is_ddl <> ddl_create_domain) AND
                    ( a_is_ddl <> ddl_alter_tab_add) AND
                    ( a_is_ddl <> ddl_alter_tab_alter))
                    OR
                    (d_colptr = NIL)
                THEN
                    WITH colinf, ccolstack DO
                        BEGIN
                        colinf    := a642standard_colinfo;
                        cdatatyp  := dvfloat;
                        cdatafrac := cak_ak_float;
                        cdatalen  := csp_fixed;
                        cinoutlen := ((cdatalen+1) DIV 2) + 2;
                        END
                    (*ENDWITH*) 
                ELSE
                    a061colinfo_to_var (d_colptr^, colinf);
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        s_parameter_name :
            ak642easy_parameter (acv, dmli, frec, colinf, act_node);
        s_null :
            WITH colinf DO
                BEGIN
                colinf      := a642standard_colinfo;
                ccolpropset := [ ctopt ];
                IF  (d_datatype = dunknown)
                THEN
                    BEGIN
                    a660fsame_pred (acv, act_node, first_same_node,
                          node_diff);
                    param_count := succ (node_diff);
&                   ifdef TRACE
                    t01int4 (ak_sem, 'first_same_n', first_same_node);
&                   endif
                    next_upper_node := a660lower_pred (acv,
                          first_same_node);
&                   ifdef TRACE
                    t01int4 (ak_sem, 'next_upper_n', next_upper_node);
&                   endif
                    WITH a_ap_tree^[ next_upper_node ] DO
                        IF  NOT ((n_proc = a60) AND
                            (n_subproc = cak_x_select_column))
                            AND
                            NOT ((n_proc = a641) AND
                            ((n_symb = s_decode) OR (n_symb = s_value)))
                        THEN
                            ak642search_for_null_type (acv, dmli,
                                  next_upper_node, param_count);
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    END;
&               ifdef TRACE
                (*ENDIF*) 
                t01int4 (ak_sem, 'd_datatype==', ord (d_datatype));
&               endif
                CASE d_datatype OF
                    dfixed, dfloat, dvfloat, dnumber :
                        cdatatyp := dfixed;
                    (* PTS 1105092 E.Z. *)
                    dcha,
                    dchb :
                        cdatatyp := d_datatype;
                    dunicode :
                        BEGIN
                        cdatatyp  := d_datatype;
                        cinoutlen := succ(2 * cdatalen);
                        ccolstack.elen_var := cinoutlen;
                        END;
                    ddate :
                        BEGIN
                        cdatatyp := ddate;
                        cdatalen := mxsp_date;
                        cinoutlen := succ (cdatalen)
                        END;
                    dtime :
                        BEGIN
                        cdatatyp := dtime;
                        cdatalen := mxsp_time;
                        cinoutlen := succ (cdatalen)
                        END;
                    dtimestamp :
                        BEGIN
                        cdatatyp := dtimestamp;
                        cdatalen := mxsp_timestamp;
                        cinoutlen := succ (cdatalen)
                        END;
                    dnonumber :
                        BEGIN
                        d_datatype := dcha;
                        cdatatyp   := dcha;
                        END;
                    OTHERWISE :
                        cdatatyp := dunknown;
                    END;
                (*ENDCASE*) 
                END;
            (*ENDWITH*) 
        s_default :
            BEGIN
            IF  (d_colptr <> NIL)
            THEN
                IF  d_colptr^.cdatatyp in
                    [ dstra, dstrb, dstruni,
                    dlonga, dlongb, dlonguni ]
                THEN
                    a07_b_put_error (acv, e_command_for_string_not_allow,
                          n_pos)
                ELSE
                    IF  ctdefault IN d_colptr^.ccolpropset
                    THEN
                        ak642_put_default_into_part2 (acv, dmli)
                    ELSE
                        a07_b_put_error (acv, e_default_spec_not_allowed,
                              n_pos)
                    (*ENDIF*) 
                (*ENDIF*) 
            ELSE
                a07_b_put_error (acv,e_default_spec_not_allowed, n_pos);
            (*ENDIF*) 
            END;
        s_transaction :
            IF  ((d_datatype <> dunknown) AND
                (d_datatype  <> dchb))
            THEN
                fr_error := true
            ELSE
                BEGIN
                d_datatype := dchb;
                WITH colinf DO
                    BEGIN
                    colinf := a642standard_colinfo;
                    cdatatyp := dchb;
                    WITH acv.a_transinf.tri_trans DO
                        cdatalen := sizeof(trTransId_gg00);
                    (*ENDWITH*) 
                    cinoutlen := succ(cdatalen)
                    END;
                (*ENDWITH*) 
                (* PTS 1122262 E.Z. *)
                IF  a_cmd_segment_header.sp1c_mess_type = sp1m_parse
                THEN
                    fr_describ := true
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        OTHERWISE
            BEGIN
&           ifdef TRACE
            t01int4 (ak_sem, 'act_node    ', act_node);
            t01int4 (ak_sem, 'n_proc      ', ord(n_proc));
            t01int4 (ak_sem, 'n_symb      ', ord(n_symb));
            t01int4 (ak_sem, 'n_length    ', n_length);
&           endif
            END
        END;
    (*ENDCASE*) 
&   ifdef TRACE
    t01int4 (ak_sem, 'dm_datatype ', ord(d_datatype));
    t01int4 (ak_sem, 'cdatatyp    ', ord(colinf.cdatatyp));
    t01int4 (ak_sem, 'cinoutlen   ', ord(colinf.cinoutlen));
    t01int4 (ak_sem, 'd_change_dat', ord(d_change_date_time));
    IF  fr_error
    THEN
        t01int4 (ak_sem, 'i_error     ', 1)
    ELSE
        t01int4 (ak_sem, 'no i_error  ', 0);
    (*ENDIF*) 
&   endif
    IF  (a_returncode = 0) AND
        (n_symb <> s_default)
    THEN
        IF  fr_error
        THEN
            BEGIN
            IF  d_datatype = dnonumber
            THEN
                a07_b_put_error (acv, e_function_not_allowed, n_pos)
            ELSE
                a07_b_put_error (acv, e_incompatible_datatypes, n_pos)
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            ak642constant_last_part (acv, dmli, frec, colin, colinf,
                  act_node);
            IF  ((d_datatype in [ ddate, dtime, dtimestamp ]) OR
                ((d_datatype = dunicode) AND
                ( colinf.cdatatyp in [ ddate, dtime, dtimestamp ])))
                AND
                d_change_date_time
            THEN
                BEGIN
                IF  d_datatype = dunicode
                THEN
                    use_datatype := colinf.cdatatyp
                ELSE
                    use_datatype := d_datatype;
                (*ENDIF*) 
                startstack := a_mblock.mb_qual^.mfirst_free;
                d_ch_datatype := use_datatype;
                a65ch_format (acv, dmli, startstack,
                      colin, use_datatype, use_datatype);
                colin.sci_iolen := colin.sci_len+1;
                IF  use_datatype = dunicode
                THEN
                    BEGIN
                    a641string_set_operator (acv, op_b_uni_trans,
                          succ(2*colin.sci_len), 0, chr(csp_ascii),
                          chr(csp_unicode));
                    WITH colin DO
                        BEGIN
                        sci_typ   := dunicode;
                        sci_iolen := (2*sci_len) + 1;
                        END
                    (*ENDWITH*) 
                    END
                (*ENDIF*) 
                END
            ELSE
                IF  (d_datatype = dunicode) AND
                    (n_symb in [ s_date, s_time, s_midnight, s_timezone ])
                    AND
                    d_change_date_time
                    AND
                    (a_ex_kind = only_parsing)
                THEN
                    BEGIN
                    CASE n_symb OF
                        s_date :
                            use_datatype := ddate;
                        s_time, s_midnight :
                            use_datatype := dtime;
                        s_timezone :
                            use_datatype := dtimestamp;
                        END;
                    (*ENDCASE*) 
                    a641string_set_operator (acv, op_b_uni_trans,
                          succ(colin.sci_len), 0, chr(csp_unicode),
                          chr(csp_ascii));
                    startstack := a_mblock.mb_qual^.mfirst_free;
                    d_ch_datatype := use_datatype;
                    a65ch_format (acv, dmli, startstack,
                          colin, use_datatype, use_datatype);
                    d_datatype := dunicode;
                    a641string_set_operator (acv, op_b_uni_trans,
                          succ(2*colin.sci_len), 0, chr(csp_ascii),
                          chr(csp_unicode));
                    WITH colin DO
                        BEGIN
                        sci_typ   := dunicode;
                        sci_iolen := (2*sci_len) + 1;
                        END
                    (*ENDWITH*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    n_symb := save_symb
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak642constant_last_part (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info;
            VAR frec   : tak_factorrec;
            VAR colin  : tak00_scolinf;
            VAR colinf : tak00_columninfo;
            act_node   : integer);
 
VAR
      patt_ok       : boolean;
      in_datapart   : boolean;
      leng          : integer;
      icolinlen     : integer;
      icolinfrac    : integer;
      icoliniolen   : integer;
      fieldno       : integer;
      curr_data_pos : tsp00_Int4;
      valstart      : tsp00_MoveObjPtr;
 
BEGIN
WITH acv, a_ap_tree^[ act_node ], dmli, frec DO
    BEGIN
    valstart := NIL;
    fieldno  := -1;
    colin.sci_cprops := colinf.ccolpropset;
    curr_data_pos := a_mblock.mb_data_len + 1;
    IF  (fr_describ) AND
        ((a_init_ddl = no_ddl) OR (a_is_ddl = ddl_create_as_select))
    THEN
        BEGIN
        leng := colinf.cinoutlen;
        IF  (dmli.d_pars_kind <> fp_limit_offset) AND
            (dmli.d_pars_kind <> fp_upper_limit)
        THEN
            IF  (a_variable_input AND
                NOT
                (n_symb in [ s_date, s_time, s_timestamp,
                s_utcdate, s_utcdiff, s_uid,
                s_user, s_usergroup, s_current_schema, s_database, s_sysdba,
                s_transaction,
                s_timezone ]))
            THEN
                BEGIN
                ak642value_stack_entry (acv, cgg_param_valuefieldlist, d_parameter_count,
                      NOT c_value_to_be_truncated);
                in_datapart := false
                END
            ELSE
                BEGIN
                ak642value_stack_entry (acv, curr_data_pos, leng,
                      NOT c_value_to_be_truncated);
                in_datapart := true
                END
            (*ENDIF*) 
        ELSE
            in_datapart := false;
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            a55_describe_value (acv, dmli, colinf, act_node, 0, in_datapart);
        (*ENDIF*) 
        colin.sci_len   := colinf.cdatalen;
        colin.sci_frac  := colinf.cdatafrac-cak_frac_offset;
        colin.sci_typ   := colinf.cdatatyp;
        colin.sci_iolen := colinf.cinoutlen;
        END
    ELSE
        BEGIN
        IF  (d_view OR (a_is_ddl in
            [ddl_create_table, ddl_create_trigger, ddl_create_procedure (* PTS 1112385 *)
            ]))
        THEN
            IF  (n_symb in [ s_date, s_time, s_timestamp,
                (* PTS 1116175 E.Z. *)
                s_utcdate,
                (* PTS 1109925 E.Z. *)
                s_utcdiff, s_uid, s_user,
                (* PTS 1111797 E.Z. *)
                s_usergroup, s_current_schema, s_database, s_sysdba,
                s_transaction,
                s_timezone (* PTS 1122262 E.Z. *)
                ])
            THEN
                leng := colinf.cinoutlen
            ELSE
                WITH a_mblock, mb_data^ DO
                    BEGIN
                    valstart := @mbp_buf[curr_data_pos];
                    IF  fr_minus_symb AND fr_getnumb
                    THEN
                        a05_constant_get (acv, fr_minus_n, colinf, dmli.d_like,
                              mb_data_size, mbp_buf, curr_data_pos, leng)
                    ELSE
                        a05_constant_get (acv, act_node, colinf, dmli.d_like,
                              mb_data_size, mbp_buf, curr_data_pos, leng)
                    (*ENDIF*) 
                    END
                (*ENDWITH*) 
            (*ENDIF*) 
        ELSE
            IF  (a_variable_input AND
                (a_init_ddl = no_ddl))
            THEN
                IF  fr_minus_symb AND fr_getnumb
                THEN
                    a05var_constant_get (acv, fr_minus_n, colinf, dmli.d_like,
                          fieldno, valstart, leng)
                ELSE
                    a05var_constant_get (acv, act_node, colinf, dmli.d_like,
                          fieldno, valstart, leng)
                (*ENDIF*) 
            ELSE
                WITH a_mblock, mb_data^ DO
                    BEGIN
                    valstart := @mbp_buf[curr_data_pos];
                    IF  fr_minus_symb AND fr_getnumb
                    THEN
                        a05_constant_get (acv, fr_minus_n, colinf, dmli.d_like,
                              mb_data_size, mbp_buf, curr_data_pos, leng)
                    ELSE
                        a05_constant_get (acv, act_node, colinf, dmli.d_like,
                              mb_data_size, mbp_buf, curr_data_pos, leng)
                    (*ENDIF*) 
                    END
                (*ENDWITH*) 
            (*ENDIF*) 
        (*ENDIF*) 
        ;
        IF  a_returncode = 0
        THEN
            BEGIN
            IF  NOT(a_ap_tree^[ act_node ].n_symb in
                [ s_unsigned_integer,
                s_fixed_point_literal,
                s_timezone, (* PTS 1141226 s_uid, *)
                s_floating_point_literal ])
            THEN
                BEGIN
                colin.sci_len   := colinf.cdatalen;
                colin.sci_frac  := colinf.cdatafrac-cak_frac_offset;
                colin.sci_typ   := colinf.cdatatyp;
                colin.sci_iolen := colinf.cinoutlen;
                END
            ELSE
                WITH colin DO
                    BEGIN
                    s43lfrac (valstart^, 2, leng-1, icolinlen,
                          icolinfrac, icoliniolen);
                    IF  icolinlen <= cak_default_precision
                    THEN
                        BEGIN
                        sci_len   := icolinlen;
                        sci_frac  := icolinfrac;
                        sci_iolen := succ(icoliniolen);
                        (* PTS 1105848 E.Z. *)
                        leng      := sci_iolen;
                        WHILE valstart^[ leng ] = csp_defined_byte DO
                            leng := pred(leng);
                        (*ENDWHILE*) 
                        IF  sci_frac = csp_float_frac
                        THEN
                            sci_typ := dfloat
                        ELSE
                            sci_typ := dfixed;
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        IF  n_length DIV a01char_size < cak_default_precision
                        THEN
                            colin.sci_len := cak_default_precision
                        ELSE
                            colin.sci_len := n_length DIV a01char_size;
                        (*ENDIF*) 
                        colin.sci_iolen := ((colin.sci_len+1) DIV 2) + 2;
                        colin.sci_frac  := colinf.cdatafrac-cak_frac_offset;
                        colin.sci_typ   := colinf.cdatatyp;
                        END;
                    (*ENDIF*) 
&                   ifdef TRACE
                    t01int4 (ak_sem, 'lenfrac len ', sci_len);
                    t01int4 (ak_sem, 'lenfrac frac', sci_frac);
                    t01int4 (ak_sem, 'lenfrac iole', sci_iolen);
&                   endif
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            patt_ok := true;
            IF  d_like AND
                NOT d_like_expression
            THEN
                IF  colinf.cdatatyp = dunicode
                THEN
                    s49uni_build_pattern (valstart^, 2, leng,
                          d_escape_char, d_escape, sqlm_ansi, patt_ok)
                ELSE
                    s49build_pattern (valstart^, 2, leng, d_escape_char[ 2 ],
                          d_escape, NOT c_string, sqlm_ansi, patt_ok);
                (*ENDIF*) 
            (*ENDIF*) 
            IF  NOT patt_ok
            THEN
                IF  a_sqlmode = sqlm_ansi
                THEN
                    a07_b_put_error (acv, e_illegal_escape_sequence, 1)
                ELSE
                    a07_b_put_error (acv, e_invalid_pattern, 1)
                (*ENDIF*) 
            ELSE
                IF  (d_view OR (a_is_ddl in
                    [ddl_create_table, ddl_create_trigger, ddl_create_procedure (* PTS 1112385 *)
                    ]))
                THEN
                    BEGIN
                    IF  (n_symb in [ s_date, s_time,
                        s_uid, s_user, s_usergroup, s_current_schema,
                        s_timestamp,
                        (* PTS 1116175 E.Z. *)
                        s_utcdate,
                        (* PTS 1109925 E.Z. *)
                        s_utcdiff,
                        (* PTS 1111797 E.Z. *)
                        s_sysdba, s_transaction,
                        s_timezone (* PTS 1122262 E.Z. *)
                        ])
                    THEN
                        ak642view_stack_entry (acv, curr_data_pos, dmli,
                              colinf, n_symb)
                    ELSE
                        ak642value_stack_entry (acv, curr_data_pos, leng,
                              NOT c_value_to_be_truncated);
                    (*ENDIF*) 
                    IF  a_returncode = 0
                    THEN
                        WITH a_mblock DO
                            mb_data_len := mb_data_len + leng
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    END
                ELSE
                    IF  (a_variable_input AND
                        (a_init_ddl = no_ddl))
                    THEN
                        ak642value_stack_entry (acv, cgg_literal_valuefieldlist, fieldno,
                              NOT c_value_to_be_truncated)
                    ELSE
                        BEGIN
                        ak642value_stack_entry (acv, curr_data_pos, leng,
                              NOT c_value_to_be_truncated);
                        IF  a_returncode = 0
                        THEN
                            WITH a_mblock DO
                                mb_data_len := mb_data_len + leng
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak642corr_column (
            VAR acv   : tak_all_command_glob;
            VAR dmli  : tak_dml_info;
            VAR frec  : tak_factorrec;
            VAR colin : tak00_scolinf;
            act_node  : integer);
 
BEGIN
WITH acv, a_ap_tree^[ act_node ], dmli, frec DO
    BEGIN
&   ifdef trace
    t01int4 (ak_sem, 'd_datatype I', ord (d_datatype));
    t01int4 (ak_sem, 'n_datatype  ', ord (n_datatype));
&   endif
    colin.sci_iolen  := n_length;
    colin.sci_cprops := a642standard_colinfo.ccolpropset;
    CASE n_datatype OF
        dfixed :
            IF  ((d_datatype <> dunknown) AND
                ( d_datatype <> dnumber))
            THEN
                fr_error := true
            ELSE
                BEGIN
                colin.sci_len  := (n_length - 2) * 2;
                colin.sci_frac := 0;
                colin.sci_typ  := dfixed;
                d_datatype     := dnumber;
                END;
            (*ENDIF*) 
        dfloat, dvfloat :
            IF  ((d_datatype <> dunknown) AND
                ( d_datatype <> dnumber))
            THEN
                fr_error := true
            ELSE
                BEGIN
                colin.sci_len  := (n_length - 2) * 2;
                colin.sci_frac := csp_float_frac;
                colin.sci_typ  := dfloat;
                d_datatype     := dnumber;
                END;
            (*ENDIF*) 
        dcha, ddate, dtime, dtimestamp :
            IF  ((d_datatype = dnumber) OR
                ( d_datatype = dchb))
            THEN
                fr_error := true
            ELSE
                BEGIN
                colin.sci_frac := 0;
                colin.sci_len  := pred (n_length);
                CASE  n_datatype OF
                    dcha, ddate, dtime, dtimestamp:
                        BEGIN
                        (* PTS 1001088 E.Z. *)
                        colin.sci_typ := n_datatype;
                        IF  (d_datatype = dunknown)  OR
                            (d_datatype = dnonumber)
                        THEN
                            (* PTS 1001088 E.Z. *)
                            d_datatype := colin.sci_typ
                        (*ENDIF*) 
                        END;
                    END
                (*ENDCASE*) 
                END;
            (*ENDIF*) 
        dchb :
            IF  ((d_datatype = dunknown)  OR
                ( d_datatype = dnonumber) OR
                ( d_datatype = dchb))
            THEN
                BEGIN
                colin.sci_len  := pred(n_length);
                colin.sci_frac := 0;
                colin.sci_typ  := dchb;
                d_datatype     := dchb
                END
            ELSE
                fr_error := true;
            (*ENDIF*) 
        dunicode :
            IF  ((d_datatype = dunknown)  OR
                ( d_datatype = dnonumber) OR
                ( d_datatype = dunicode))
            THEN
                BEGIN
                colin.sci_len  := (pred(n_length)) DIV 2;
                colin.sci_frac := 0;
                colin.sci_typ  := dunicode;
                d_datatype     := dunicode
                END
            ELSE
                fr_error := true;
            (*ENDIF*) 
        dboolean :
            IF  ((d_datatype <> dunknown) AND
                ( d_datatype <> dboolean))
            THEN
                fr_error := true
            ELSE
                BEGIN
                colin.sci_len  := 1;
                colin.sci_frac := cak_frac_offset;
                colin.sci_typ  := dboolean;
                d_datatype     := dboolean;
                END;
            (*ENDIF*) 
        OTHERWISE :
            fr_error := true
        END;
    (*ENDCASE*) 
&   ifdef trace
    t01int4 (ak_sem, 'd_datatype O', ord (d_datatype));
&   endif
    IF  fr_error
    THEN
        a07_b_put_error (acv, e_incompatible_datatypes, 1)
    ELSE
        ak642value_stack_entry (acv, n_pos, n_length,
              c_value_to_be_truncated);
    (*ENDIF*) 
    (* PTS 1001088 E.Z. *)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak642nextval_or_currval (
            VAR acv   : tak_all_command_glob;
            VAR dmli  : tak_dml_info;
            VAR frec  : tak_factorrec;
            VAR colin : tak00_scolinf;
            act_node  : integer);
 
CONST
      c_min_nextval_len = 38; (* PTS 1109819 *)
 
VAR
      numbercheck   : boolean;
      colinf        : tak00_columninfo;
      seq_buf       : tak_sysbufferaddress;
      username      : tsp00_KnlIdentifier;
      seq_name      : tsp00_KnlIdentifier;
 
BEGIN
WITH acv, a_ap_tree^[ act_node ], dmli, frec,
     d_sparr.pbasep^.sbase DO
    IF  a23exist_sequence (acv, a_ap_tree^[ act_node ].n_lo_level,
        n_symb = s_currval, seq_buf, username, seq_name)
    THEN
        IF  ((((btablekind = twithkey)
            OR (btablekind = twithoutkey)))
            OR
            ((btablekind = tonebase) AND
            ((bv_tablekind = twithkey) OR (bv_tablekind = twithoutkey))))
        THEN
            IF  ((d_datatype <> dunknown) AND
                ( d_datatype <> dnumber) AND
                ( d_datatype <> dfixed) AND
                ( d_datatype <> dfloat))
            THEN
                a07_b_put_error (acv, e_incompatible_datatypes, n_pos)
            ELSE
                BEGIN
                (* PTS 1117882 E.Z. *)
                IF  (dmli.d_maxcounttabs > 1) AND
                    (NOT d_wherepart) AND (NOT d_having)
                THEN
                    d_arith_where := true;
                (* PTS 1109819 E.Z. *)
                (*ENDIF*) 
                numbercheck := false;
                d_datatype := dfixed;
                IF  d_colptr = NIL
                THEN
                    BEGIN
                    colin.sci_len    := c_min_nextval_len;
                    colin.sci_frac   := 0;
                    colin.sci_typ    := dfixed;
                    colin.sci_iolen  := (colin.sci_len+1) DIV 2 + 2;
                    colin.sci_cprops := a642standard_colinfo.ccolpropset;
                    END
                ELSE
                    BEGIN
                    a061colinfo_to_var (d_colptr^, colinf);
                    colin.sci_len    := colinf.cdatalen;
                    colin.sci_frac   := colinf.cdatafrac-cak_frac_offset;
                    colin.sci_typ    := colinf.cdatatyp;
                    colin.sci_iolen  := colinf.cinoutlen;
                    colin.sci_cprops := colinf.ccolpropset;
                    IF  ((colinf.cdatalen < c_min_nextval_len+colinf.cdatafrac
                        - cak_frac_offset) AND
                        ( colinf.cdatafrac > 0))
                        OR
                        (colinf.cdatalen < c_min_nextval_len)
                    THEN
                        (* PTS 1109819 E.Z. *)
                        numbercheck := true
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  n_symb = s_nextval
                THEN
                    WITH a_mblock, mb_qual^ DO
                        IF  mfirst_free >= mb_st_max
                        THEN
                            a07_b_put_error (acv,
                                  e_too_many_mb_stackentries, -mb_st_max)
                        ELSE
                            BEGIN
                            WITH mb_st^ [mfirst_free] DO
                                BEGIN
                                etype := st_op;
                                eop   := op_nextval;
                                epos  := a_mblock.mb_data_len + 1;
                                elen_var      := 0;
                                ecol_tab[ 1 ] := chr(0);
                                ecol_tab[ 2 ] := chr(0)
                                END;
                            (*ENDWITH*) 
                            mqual_cnt   := succ (mqual_cnt);
                            mfirst_free := succ (mfirst_free);
                            END
                        (*ENDIF*) 
                    (*ENDWITH*) 
                ELSE
                    a641string_set_operator (acv, op_b_currval,
                          0, a_mblock.mb_data_len + 1, chr(0), chr(0));
                (*ENDIF*) 
                (* PTS 1109819 E.Z. *)
                IF  numbercheck
                THEN
                    WITH a_mblock, mb_qual^ DO
                        IF  mfirst_free >= mb_st_max
                        THEN
                            a07_b_put_error (acv,
                                  e_too_many_mb_stackentries, -mb_st_max)
                        ELSE
                            BEGIN
                            WITH mb_st^ [mfirst_free], colin DO
                                BEGIN
                                etype         := st_result;
                                eop           := op_order_asc;
                                epos          := sci_len;
                                elen_var      := sci_frac;
                                ecol_tab[ 1 ] := chr(0);
                                ecol_tab[ 2 ] := chr(0)
                                END;
                            (*ENDWITH*) 
                            mqual_cnt   := succ (mqual_cnt);
                            mfirst_free := succ (mfirst_free);
                            END;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (* END PTS 1109819 E.Z. *)
                (*ENDIF*) 
                WITH seq_buf^.ssequence, a_mblock, mb_data^ DO
                    BEGIN
                    IF  mb_data_len + sizeof (seq_surrogate) +
                        sizeof (seq_info) > mb_data_size
                    THEN
                        a07_b_put_error (acv, e_too_many_mb_data,
                              n_pos)
                    ELSE
                        BEGIN
                        SAPDB_PascalMove ('VAK642',   1,    
                              sizeof (seq_surrogate), mb_data_size,
                              @seq_surrogate, 1, @mbp_buf, mb_data_len + 1,
                              sizeof (seq_surrogate),
                              a_returncode);
                        mb_data_len := mb_data_len + sizeof (seq_surrogate);
                        SAPDB_PascalMove ('VAK642',   2,    
                              sizeof (seq_info), mb_data_size,
                              @seq_info, 1, @mbp_buf, mb_data_len + 1,
                              sizeof (seq_info),
                              a_returncode);
                        mb_data_len := mb_data_len + sizeof (seq_info)
                        END
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                END
            (*ENDIF*) 
        ELSE
            a07_b_put_error (acv, e_not_implemented,
                  acv.a_ap_tree^[ act_node ].n_pos);
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak642parameter (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info;
            VAR colinf : tak00_columninfo);
 
VAR
      m_expand : integer;
 
BEGIN
WITH acv, dmli, colinf DO
    IF  (d_datatype = dunknown)
    THEN
        a_returncode := cak_e_parameter
    ELSE
        IF  (NOT d_is_parameter_only) AND  (d_colptr <> NIL)
        THEN
            BEGIN
            a061colinfo_to_var (d_colptr^, colinf);
            IF  d_like
            THEN
                BEGIN
                IF  ( d_expand > 0 )
                THEN
                    cdatalen := d_expand
                ELSE
                    IF  a_mblock.mb_type <> m_select_row
                    THEN
                        (* PTS 1121285 E.Z. *)
                        (* PTS 1127245 E.Z. *)
                        IF  cdatalen <= 10
                        THEN
                            cdatalen := 2 * cdatalen
                        ELSE
                            IF  cdatalen <= 100
                            THEN
                                cdatalen := cdatalen + 20
                            ELSE
                                IF  cdatalen <= 200
                                THEN
                                    cdatalen := cdatalen + 40
                                ELSE
                                    BEGIN
                                    cdatalen := cdatalen + 100;
                                    IF  cdatatyp = dunicode
                                    THEN
                                        BEGIN
                                        IF  cdatalen * 2 > cak_maxdeffieldlength
                                        THEN
                                            cdatalen := 1 + cak_maxdeffieldlength DIV 2
                                        (*ENDIF*) 
                                        END
                                    ELSE
                                        IF  cdatalen > cak_maxdeffieldlength
                                        THEN
                                            cdatalen := 1 + cak_maxdeffieldlength;
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                    END;
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  cdatatyp = dunicode
                THEN
                    cinoutlen := succ(2*cdatalen)
                ELSE
                    cinoutlen := succ(cdatalen)
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            colinf      := a642standard_colinfo;
            ccolpropset := [ ctopt ];
            m_expand    := d_expand;
            IF  (NOT d_wherepart AND NOT d_having AND
                (d_expand = 0)                    AND
                ( a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc = a56)    AND
                a_insert_select                   AND
                ( a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc  =
                cak_x_insert_select) AND
                (dmli.d_subcount = 0))
            THEN
                WITH d_change.cr_columns[ d_outcolno ] DO
                    IF  ch_length = chr (ord (d_datatype))
                    THEN
                        d_expand := ch_startpos;
                    (*ENDIF*) 
                (*ENDWITH*) 
            (*ENDIF*) 
            CASE d_datatype OF
                dboolean :
                    BEGIN
                    cdatatyp := dboolean;
                    cdatalen := 1;
                    cinoutlen := succ (cdatalen)
                    END;
                dfixed, dfloat, dvfloat, dnumber :
                    BEGIN
                    (* PTS 1120988 E.Z. *)
                    IF  (d_expand > 0)
                    THEN
                        IF  (d_datatype = dfixed)
                        THEN
                            BEGIN
                            cdatatyp  := dfixed;
                            cdatalen  := d_expand DIV 100;
                            cdatafrac := d_expand MOD 100;
                            END
                        ELSE
                            BEGIN
                            cdatatyp  := dfloat;
                            cdatalen  := d_expand;
                            cdatafrac := cak_ak_float;
                            END
                        (*ENDIF*) 
                    ELSE
                        IF  (dmli.d_pars_kind in [fp_limit_offset, fp_upper_limit])
                            OR
                            (NOT a_rowno_allowed) (* h.b. PTS 1104314 *)
                            (* PTS 1106468 E.Z. *)
                            AND a_rowno_found
                        THEN
                            BEGIN
                            cdatatyp  := dfixed;
                            cdatalen  := 10;
                            cdatafrac := cak_frac_offset; (* h.b. PTS 1104470 *)
                            END
                        ELSE
                            BEGIN
                            cdatatyp  := dvfloat;
                            cdatalen  := csp_fixed;
                            cdatafrac := cak_ak_float;
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    cinoutlen := ((cdatalen+1) DIV 2) + 2;
                    END;
                dchb, dcha :
                    BEGIN
                    cdatatyp := d_datatype;
                    IF  ( d_expand > 0 )
                    THEN
                        cdatalen := d_expand
                    ELSE
                        IF  d_hex
                        THEN
                            cdatalen := cak_maxfieldlength DIV 2
                        ELSE
                            cdatalen := cak_maxfieldlength;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    cinoutlen := succ (cdatalen)
                    END;
                ddate :
                    BEGIN
                    cdatatyp := ddate;
                    (*IF  (a_dt_format <> dtf_normal)
                          THEN
                          cdatalen := mxsp_extdate;
                          ELSE*)
                    cdatalen := mxsp_date;
                    cinoutlen := succ (cdatalen)
                    END;
                dtime :
                    BEGIN
                    cdatatyp := dtime;
                    (*IF  (a_dt_format <> dtf_normal)
                          THEN
                          cdatalen := mxsp_exttime;
                          ELSE*)
                    cdatalen := mxsp_time;
                    cinoutlen := succ (cdatalen)
                    END;
                dtimestamp :
                    BEGIN
                    cdatatyp := dtimestamp;
                    (*IF  (a_dt_format <> dtf_normal)
                          THEN
                          cdatalen := mxsp_exttimestamp;
                          ELSE*)
                    cdatalen := mxsp_timestamp;
                    cinoutlen := succ (cdatalen)
                    END;
                dnonumber :
                    BEGIN
                    cdatatyp := dcha;
                    d_datatype := cdatatyp;
                    IF  d_hex
                    THEN
                        cdatalen := cak_maxfieldlength DIV 2
                    ELSE
                        cdatalen := cak_maxfieldlength;
                    (*ENDIF*) 
                    cinoutlen := succ (cdatalen)
                    END;
                dstra, dstrb, dstruni,
                dlonga, dlongb, dlonguni :
                    BEGIN
                    cdatatyp := d_datatype;
                    cdatalen := SURROGATE_MXGG00;
                    cinoutlen := succ(cdatalen)
                    END;
                dunicode :
                    BEGIN
                    cdatatyp := d_datatype;
                    IF  ( d_expand > 0 )
                    THEN
                        cdatalen := d_expand
                    ELSE
                        cdatalen := cak_maxfieldlength DIV 2;
                    (*ENDIF*) 
                    cinoutlen := succ(cdatalen * 2)
                    END;
                END;
            (*ENDCASE*) 
            d_expand := m_expand;
            END
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak642easy_parameter (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info;
            VAR frec   : tak_factorrec;
            VAR colinf : tak00_columninfo;
            act_node   : integer);
 
VAR
      act_param       : integer;  (* number of actual parameter *)
      in_param_list   : boolean;  (* act_param is in the list   *)
      number_set      : SET OF tsp00_DataType;
      char_set        : SET OF tsp00_DataType;
      easy            : boolean;
      plength         : tsp00_Int2;
      pfrac           : tsp00_Uint1;
 
BEGIN
easy       := true;
WITH acv, a_parameter_spec, dmli, frec DO
    BEGIN
    d_param_st_index   := a_mblock.mb_qual^.mfirst_free;
    act_param := a_ap_tree^ [ act_node ].n_length;
&   ifdef TRACE
    t01int4 (ak_sem, 'd_param_st_i', d_param_st_index);
    t01int4 (ak_sem, 'd_datatype  ', ord (d_datatype));
&   endif
    IF  ((a_cmd_segment_header.sp1c_mess_type = sp1m_parse) OR
        (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc = a43))
        (*explain*)
    THEN
        fr_describ := true;
    (*ENDIF*) 
    in_param_list := (act_param <= param_counter) AND
          (param_spec_ptr <> NIL);
    (* Error 1292 from Precompilers (16.07.96)                     *)
    (* If we are in an INSERT tab (col1, col2) SELECT :a, :b ...   *)
    (* and the precompiler has given some appl param descriptions, *)
    (* the kernel must ignore this and return the description of   *)
    (* the column, in which to insert.                             *)
    IF  NOT d_wherepart AND NOT d_having AND
        (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc = a56)   AND
        a_insert_select                  AND
        dmli.d_is_parameter_only         AND
        (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc =
        cak_x_insert_select)
    THEN
        in_param_list := false;
    (* do NOT write                                   *)
    (* 'if ((not in_param_list) or (param_spec_ptr^'..*)
    (* in case param_spec_ptr = nil, this may crash   *)
    (*ENDIF*) 
    IF  NOT in_param_list
    THEN
        ak642parameter (acv, dmli, colinf)
    ELSE
        IF  param_spec_ptr^[ act_param ].para_length = 0
        THEN
            ak642parameter (acv, dmli, colinf)
        ELSE
            BEGIN
            WITH colinf, param_spec_ptr^[ act_param ] DO
                BEGIN
                number_set := [ dfixed, dfloat, dvfloat, dnumber,
                      dsmallint, dinteger ];
                char_set   := [ dcha, dchb, dstra, dstrb,
                      dunicode, dstruni, dvarchara, dvarcharb ];
                pfrac   := ord (para_frac);
                plength := para_length;
                IF  (NOT d_is_parameter_only) AND (d_colptr <> NIL)
                THEN
                    BEGIN
                    a061colinfo_to_var (d_colptr^, colinf);
                    IF  in_param_list                           AND
                        (
                        (cdatatyp  IN number_set)           AND
                        (para_type IN number_set)           AND
                        (* with dfloat, the given length *)
                        (* of 6 often will be too short  *)
                        (para_type  <> dfloat)
                        OR
                        (cdatatyp  IN char_set)             AND
                        (para_type IN char_set)             AND
                        (d_like OR (plength < cdatalen))
                        )
                    THEN
                        BEGIN
                        cdatalen  := plength;
                        cdatafrac := cak_frac_offset;
                        IF  cdatatyp  IN number_set
                        THEN
                            cbinary := false;
                        (*ENDIF*) 
                        END
                    ELSE
                        easy := false
                    (*ENDIF*) 
                    END
                ELSE
                    (* PTS 1125272 E.Z. *)
                    IF  ((d_datatype in number_set) AND NOT (para_type in number_set))
                        OR
                        ((d_datatype in char_set  ) AND NOT (para_type in char_set))
                    THEN
                        ak642parameter (acv, dmli, colinf)
                    ELSE
                        BEGIN
                        colinf      := a642standard_colinfo;
                        ccolpropset := [ ctopt ];
                        cdatafrac   := cak_frac_offset;
                        (*   search type of parameter   *)
                        CASE para_type OF
                            dfixed, dsmallint, dinteger :
                                BEGIN
                                cdatatyp := dfixed;
                                cdatalen := plength;
                                END;
                            dfloat, dvfloat :
                                BEGIN
                                cdatatyp := dfloat;
                                (* PTS 1122740 E.Z. *)
                                cdatalen := plength;
                                END;
                            dcha, dchb, drowid,
                            dstra, dstrb,
                            ddate, dtime, dtimestamp,
                            dlonga, dlongb,
                            dboolean,
                            dunicode, dstruni, dlonguni,
                            dvarchara, dvarcharb :
                                BEGIN
                                cdatatyp := para_type;
                                cdatalen := plength;
                                END;
                            OTHERWISE :
                                BEGIN
                                easy := false;
                                ak642parameter (acv, dmli, colinf);
                                END;
                            END;
                        (*ENDCASE*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
            IF  easy
            THEN
                WITH colinf DO
                    (*   search io-length   *)
                    CASE cdatatyp OF
                        dfixed, dinteger, dsmallint :
                            BEGIN
                            cinoutlen := ((cdatalen + 1) DIV 2) + 2;
                            cdatafrac := pfrac + cak_frac_offset;
                            END;
                        dfloat, dvfloat :
                            BEGIN
                            cinoutlen := ((cdatalen + 1) DIV 2) + 2;
                            cdatafrac := csp_float_frac + cak_frac_offset;
                            END;
                        ddate:
                            BEGIN
                            cdatalen := mxsp_date;
                            cinoutlen := succ (cdatalen)
                            END;
                        dtime:
                            BEGIN
                            cdatalen := mxsp_time;
                            cinoutlen := succ (cdatalen)
                            END;
                        dtimestamp:
                            BEGIN
                            cdatalen := mxsp_timestamp;
                            cinoutlen := succ (cdatalen)
                            END;
                        dunicode :
                            BEGIN
                            cinoutlen := (2 * cdatalen) + 1;
                            (* bei EUC muessten es 3 * sein *)
                            END;
                        OTHERWISE:
                            cinoutlen := succ (cdatalen);
                        END;
                    (*ENDCASE*) 
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        IF  d_datatype in [ dunknown, dnonumber ]
        THEN
            IF  colinf.cdatatyp in [ dfixed, dsmallint, dinteger,
                dfloat, dvfloat ]
            THEN
                d_datatype := dnumber
            ELSE
                d_datatype := colinf.cdatatyp
            (*ENDIF*) 
        ELSE
            IF  (
                NOT d_wherepart                                         AND
                NOT d_having                                            AND
                (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc = a56) AND
                (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc  =
                cak_x_insert_select)                                    AND
                a_insert_select                                         AND
                (dmli.d_literalrec <> NIL)                              AND
                (dmli.d_subcount = 0)                                   AND
                (d_datatype in [ dstra, dstrb, dstruni, dlonga, dlongb, dlonguni ]))
            THEN
                a56get_longlit (acv, dmli, d_datatype, act_node);
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak642rowno (
            VAR acv   : tak_all_command_glob;
            VAR dmli  : tak_dml_info;
            VAR colin : tak00_scolinf;
            act_node  : integer);
 
BEGIN
WITH acv, a_ap_tree^[ act_node ], a_mblock, mb_qual^, dmli DO
    IF  NOT (d_datatype in [ dunknown, dnumber ])
    THEN
        IF  d_datatype = dnonumber
        THEN
            a07_b_put_error (acv, e_function_not_allowed, n_pos)
        ELSE
            a07_b_put_error (acv, e_incompatible_datatypes, n_pos)
        (*ENDIF*) 
    ELSE
        BEGIN
        WITH colin DO
            BEGIN
            sci_len := 10;
            sci_frac := 0;
            sci_typ := dfixed;
            sci_iolen := (sci_len+1) DIV 2 + 2;
            sci_cprops := [  ];
            END;
        (*ENDWITH*) 
        d_datatype := dnumber;
        d_colptr   := NIL;
        IF  mfirst_free >= mb_st_max
        THEN
            a07_b_put_error (acv, e_too_many_mb_stackentries, -mb_st_max)
        ELSE
            BEGIN
            WITH mb_st^ [mfirst_free] DO
                BEGIN
                etype         := st_rowno;
                eop           := op_none;
                epos          := 10;
                elen_var      := 0;
                ecol_tab[ 1 ] := chr (colin.sci_iolen);
                ecol_tab[ 2 ] := chr (0)
                END;
            (*ENDWITH*) 
            mqual_cnt   := succ (mqual_cnt);
            mfirst_free := succ (mfirst_free)
            END;
        (*ENDIF*) 
        a_rowno_allowed := false;
        IF  d_wherepart OR d_having
        THEN
            d_pars_kind := fp_rowno;
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak642search_for_null_type (
            VAR acv         : tak_all_command_glob;
            VAR dmli        : tak_dml_info;
            next_upper_node : integer;
            param_count     : integer);
 
VAR
      func_symbol      : tak_sc_symbol;
      oracle_functions : SET OF tak_sc_symbol;
      sql_db_functions : SET OF tak_sc_symbol;
 
BEGIN
oracle_functions := [ s_index, s_substr, s_lpad, s_rpad, s_next_day,
      s_add_months, s_to_char, s_to_24_char, s_to_number, s_new_time ];
sql_db_functions := [ s_fixed, s_index, s_substr, s_lfill, s_rfill,
      s_lpad, s_rpad, s_expand, s_mapchar, s_value, s_chr, s_func_char ];
WITH acv, dmli DO
    BEGIN
    func_symbol := a_ap_tree^[ next_upper_node ].n_symb;
    CASE func_symbol OF
        s_to_number :
            d_datatype := dnonumber;
        OTHERWISE :
            IF  (param_count = 1)
                OR
                ((a_sqlmode = sqlm_oracle) AND
                NOT (func_symbol IN oracle_functions))
                OR
                ((a_sqlmode = sqlm_internal) AND
                NOT (func_symbol IN sql_db_functions))
            THEN
                a65_look_for_datatypes (acv, dmli, next_upper_node)
            ELSE
                CASE a_sqlmode OF
                    sqlm_oracle :
                        CASE func_symbol OF
                            s_index :
                                IF  param_count = 2
                                THEN
                                    d_datatype := dnonumber
                                ELSE
                                    d_datatype := dnumber;
                                (*ENDIF*) 
                            s_substr, s_next_day, s_add_months :
                                d_datatype := dnumber;
                            s_to_char:
                                d_datatype := dnonumber;
                            s_new_time :
                                d_datatype := dcha;
                            s_lfill, s_rfill :
                                (*  lpad and rpad use these symbols.  *)
                                (*  Parameter nodes 2 and 3 are       *)
                                (*  replaced.                         *)
                                IF  param_count = 2
                                THEN
                                    d_datatype := dnonumber
                                ELSE
                                    d_datatype := dnumber;
                                (*ENDIF*) 
                            OTHERWISE :
                                a65_look_for_datatypes (acv,
                                      dmli, next_upper_node);
                            END;
                        (*ENDCASE*) 
                    sqlm_internal:
                        CASE func_symbol OF
                            s_fixed, s_expand:
                                d_datatype := dnumber;
                            s_lfill, s_rfill :
                                IF  param_count = 2
                                THEN
                                    d_datatype := dnonumber
                                ELSE
                                    d_datatype := dnumber;
                                (*ENDIF*) 
                            OTHERWISE :
                                a65_look_for_datatypes (acv,
                                      dmli, next_upper_node);
                            END;
                        (*ENDCASE*) 
                    OTHERWISE :
                        a65_look_for_datatypes (acv,
                              dmli, next_upper_node);
                    END;
                (*ENDCASE*) 
            (*ENDIF*) 
        END;
    (*ENDCASE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak642stamp (
            VAR acv   : tak_all_command_glob;
            VAR dmli  : tak_dml_info;
            VAR frec  : tak_factorrec;
            VAR colin : tak00_scolinf;
            act_node  : integer);
 
VAR
      colinf : tak00_columninfo;
 
BEGIN
WITH acv, a_ap_tree^[ act_node ], dmli, frec DO
    IF  ((d_datatype <> dunknown) AND
        (d_datatype <> dnonumber) AND
        (d_datatype <> dchb))
    THEN
        a07_b_put_error (acv, e_incompatible_datatypes, n_pos)
    ELSE
        BEGIN
        d_datatype := dchb;
        IF  d_colptr = NIL
        THEN
            WITH colin DO
                BEGIN
                sci_len    := SURROGATE_MXGG00;
                sci_frac   := 0;
                sci_typ    := dchb;
                sci_iolen  := succ (sci_len);
                sci_cprops := a642standard_colinfo.ccolpropset;
                END
            (*ENDWITH*) 
        ELSE
            BEGIN
            a061colinfo_to_var (d_colptr^, colinf);
            WITH colin, colinf DO
                BEGIN
                sci_len    := cdatalen;
                sci_frac   := cdatafrac-cak_frac_offset;
                sci_typ    := cdatatyp;
                sci_iolen  := cinoutlen;
                sci_cprops := ccolpropset;
                END;
            (*ENDWITH*) 
            IF  colinf.cdatalen < SURROGATE_MXGG00
            THEN
                a07_b_put_error (acv, e_incompatible_datatypes, n_pos)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        WITH a_mblock, mb_qual^ DO
            IF  mfirst_free >= mb_st_max
            THEN
                a07_b_put_error (acv,
                      e_too_many_mb_stackentries, -mb_st_max)
            ELSE
                BEGIN
                WITH mb_st^ [mfirst_free] DO
                    BEGIN
                    etype         := st_op;
                    eop           := op_stamp;
                    epos          := 0;
                    elen_var      := 0;
                    ecol_tab[ 1 ] := chr (ord (n_pos = 0));
                    (* ecol_tab[ 1 ] = '0' ==> normal stamp operation *)
                    (* ecol_tab[ 1 ] = '1' ==> assign zero stamp      *)
                    ecol_tab[ 2 ] := chr(0)
                    END;
                (*ENDWITH*) 
                mqual_cnt    := succ (mqual_cnt);
                mfirst_free  := succ (mfirst_free);
                mstack_state := mstack_state + [ssCopyRow_egg00];
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak642_is_long_literal (VAR acv    : tak_all_command_glob;
            VAR dmli           : tak_dml_info;
            VAR colinf         : tak00_columninfo;
            VAR n_symb         : tak_sc_symbol;
            VAR datatype_found : boolean);
 
VAR
      b_err              : tgg00_BasisError;
      litreckey          : tgg00_SysInfoKey;
      old_literalrec     : tak_sysbufferaddress;
 
BEGIN
WITH acv, dmli, colinf DO
    IF  ((d_datatype = dunknown)                                AND
        NOT d_wherepart                                         AND
        NOT d_having                                            AND
        (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc = a56) AND
        (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc  =
        cak_x_insert_select)                                    AND
        a_insert_select                                         AND
        (dmli.d_literalrec <> NIL)                              AND
        (dmli.d_subcount = 0))
    THEN
        IF  d_outcolno > d_change.cr_colcount
        THEN
            a07_b_put_error (acv, e_too_many_values, 1)
        ELSE
            BEGIN
            a56_datatype (d_change.cr_columns[ d_outcolno ].ch_length,
                  cdatatyp);
            IF  cdatatyp in [dstra, dstrb, dstruni,
                dlonga, dlongb, dlonguni ]
            THEN
                BEGIN
                cdatalen  := SURROGATE_MXGG00;
                cinoutlen := succ(SURROGATE_MXGG00);
                n_symb    := s_stamp;
                datatype_found := true;
                IF  (d_sparr.pparsp <> NIL) AND
                    (dmli.d_literalrec^.slongliteral.litentrytype = cak_edummy)
                THEN
                    BEGIN
                    (* stored with a10new, not as systembuffer *)
                    BEGIN
                    old_literalrec := dmli.d_literalrec;
                    litreckey := d_sparr.pparsp^.syskey;
                    WITH litreckey DO
                        sentrytyp := cak_elongliteral;
                    (*ENDWITH*) 
                    a10_nil_get_sysinfo (acv, litreckey, d_fix,
                          old_literalrec^.slongliteral.litreclen, d_literalrec, b_err);
                    IF  b_err <> e_ok
                    THEN
                        a07_b_put_error (acv, b_err, 1)
                    ELSE
                        BEGIN
                        SAPDB_PascalForcedMove (old_literalrec^.slongliteral.litreclen,
                              d_literalrec^.slongliteral.litreclen,
                              @(old_literalrec^), cak_sysbufferoffset+1,
                              @(d_literalrec^), cak_sysbufferoffset+1,
                              old_literalrec^.slongliteral.litreclen-cak_sysbufferoffset);
                        d_literalrec^.slongliteral.litdataptr :=
                              @(d_literalrec^.slongliteral.litdatabuf [
                              old_literalrec^.slongliteral.litreclen -
                              (sizeof(tak_longliteral_rec) - sizeof(tak_longlit_buf)) -
                              old_literalrec^.slongliteral.litsize + 1]);
                        d_sparr.pparsp^.sparsinfo.p_longliteral := true;
                        a10dispose (acv, old_literalrec);
                        END
                    (*ENDIF*) 
                    END
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak642string_user (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info;
            VAR frec   : tak_factorrec;
            VAR colinf : tak00_columninfo;
            act_node   : integer);
 
VAR
      ora_number_literal : boolean;
      pos                : integer;
      datatype_found     : boolean;
      new_n_symb         : tak_sc_symbol;
 
BEGIN
WITH acv, a_ap_tree^[ act_node ], dmli, frec DO
    BEGIN
    (* PTS 1110265 E.Z. *)
    IF  (
        (d_datatype in [dchb, dboolean])
        OR
        (
        (d_datatype = dnumber)                  AND
        ( d_is_parameter_only OR
        ( d_colptr = NIL)     OR
        NOT ((a_sqlmode = sqlm_oracle) OR
        (     a_comp_type = at_odbc)   OR
        (     a_comp_type = at_jdbc))
        ) )
        )
    THEN
        fr_error := true
    ELSE
        IF  (((n_symb = s_user)        OR
            (  n_symb = s_usergroup)   OR
            (  n_symb = s_current_schema) OR
            (* PTS 1111797 E.Z. *)
            (  n_symb = s_sysdba)      OR
            (  n_symb = s_database)    OR
            (  n_symb = s_degree))
            AND
            ((d_datatype = ddate) OR
            ( d_datatype = dtime) OR
            ( d_datatype = dtimestamp)))
        THEN
            CASE d_datatype OF
                dtime :
                    a07_b_put_error (acv, e_invalid_time, n_pos);
                ddate :
                    a07_b_put_error (acv, e_invalid_date, n_pos);
                dtimestamp :
                    a07_b_put_error (acv,
                          e_invalid_timestamp, n_pos);
                END
            (*ENDCASE*) 
        ELSE
            IF  (d_is_parameter_only) OR (d_colptr = NIL)
            THEN
                WITH colinf, ccolstack DO
                    BEGIN
                    colinf := a642standard_colinfo;
                    datatype_found := false;
                    new_n_symb := n_symb;
                    IF  n_symb = s_string_literal
                    THEN
                        ak642_is_long_literal (acv, dmli, colinf, new_n_symb, datatype_found);
                    (*ENDIF*) 
                    IF  NOT datatype_found
                    THEN
                        IF  (d_datatype = ddate)      OR
                            (d_datatype = dtime)      OR
                            (d_datatype = dtimestamp) OR
                            (d_datatype = dunicode)
                        THEN
                            cdatatyp := d_datatype
                        ELSE
                            IF  (g01unicode                  AND
                                (n_symb <> s_degree)         AND
                                ((d_datatype = dunicode) OR
                                ( d_datatype = dunknown) OR
                                ( d_datatype = dnonumber)))
                            THEN
                                cdatatyp := dunicode
                            ELSE
                                (* PTS 1117236 E.Z. *)
                                IF  (g01code.ctype = csp_ascii) OR
                                    (g01code.ctype = csp_unicode)
                                THEN
                                    BEGIN
                                    cdatatyp := dcha;
                                    IF  (g01unicode) AND
                                        (n_symb = s_string_literal)
                                    THEN
                                        BEGIN
                                        pos := abs(n_pos);
                                        WHILE (pos < n_pos + n_length) AND (cdatatyp = dcha) DO
                                            IF  a_cmd_part^.sp1p_buf[pos] <> csp_unicode_mark
                                            THEN
                                                cdatatyp := dunicode
                                            ELSE
                                                pos := pos + 2
                                            (*ENDIF*) 
                                        (*ENDWHILE*) 
                                        END;
                                    (*ENDIF*) 
                                    END;
&                               ifdef TRACE
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    t01int4 (ak_sem, 'new_datatype', ord(cdatatyp));
&                   endif
                    d_datatype := cdatatyp;
                    IF  cdatatyp in [ dstra, dstrb, dstruni, dlonga, dlongb, dlonguni ]
                    THEN
                        BEGIN
                        a56get_longlit (acv, dmli, cdatatyp, act_node);
                        n_symb := new_n_symb;
                        fr_describ := true;
                        END
                    ELSE
                        BEGIN
                        IF  n_symb = s_string_literal
                        THEN
                            IF  ((cdatatyp = dunicode) OR (cdatatyp = dcha)) AND
                                g01unicode
                            THEN
                                cdatalen := n_length DIV 2
                            ELSE
                                BEGIN
                                (* PTS 1105409 E.Z. *)
                                CASE cdatatyp OF
                                    ddate :
                                        cdatalen := mxsp_date;
                                    dtime :
                                        cdatalen := mxsp_time;
                                    dtimestamp :
                                        cdatalen := mxsp_timestamp;
                                    OTHERWISE
                                        cdatalen := n_length
                                    END;
                                (*ENDCASE*) 
                                IF  (cdatalen = 0) AND a_space_option
                                THEN
                                    cdatalen := 1;
                                (*ENDIF*) 
                                END
                            (*ENDIF*) 
                        ELSE
                            IF  n_symb = s_degree
                            THEN
                                cdatalen := mxsp_c3
                            ELSE
                                cdatalen := a01identifier_size DIV a01char_size;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        IF  cdatatyp = dunicode
                        THEN
                            cinoutlen := succ(cdatalen*2)
                        ELSE
                            cinoutlen := succ(cdatalen);
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END
                (*ENDWITH*) 
            ELSE
                (* PTS 1109806 E.Z. *)
                IF  d_colptr^.cdatatyp in
                    [ dstra, dstrb, dstruni,
                    dlonga, dlongb, dlonguni ]
                THEN
                    a07_b_put_error (acv, e_command_for_string_not_allow,
                          n_pos)
                ELSE
                    BEGIN
                    (* PTS 1105310 E.Z. *)
                    ora_number_literal := false;
                    a061colinfo_to_var (d_colptr^, colinf);
                    IF  ((n_symb = s_string_literal)
                        AND (colinf.cdatatyp <> ddate)
                        AND (colinf.cdatatyp <> dtime)
                        AND (colinf.cdatatyp <> dtimestamp))
                    THEN
                        BEGIN
                        IF  (
                            ((a_sqlmode = sqlm_oracle) OR
                            ( a_comp_type = at_odbc)   OR
                            ( a_comp_type = at_jdbc))
                            AND
                            ((colinf.cdatatyp = dfixed) OR
                            ( colinf.cdatatyp = dfloat) OR
                            ( colinf.cdatatyp = dvfloat) OR
                            ( colinf.cdatatyp = dsmallint) OR
                            ( colinf.cdatatyp = dinteger))
                            )
                        THEN
                            BEGIN
                            (* we need the original length for ak05one_number *)
                            (* PTS 1105310 E.Z. *)
                            ora_number_literal := true
                            END
                        ELSE
                            BEGIN
                            IF  (a_is_ddl <> ddl_create_table)  AND
                                (a_is_ddl <> ddl_create_domain) AND
                                (a_is_ddl <> ddl_alter_tab_add) AND
                                (a_is_ddl <> ddl_alter_tab_alter) AND
                                NOT (d_in_method_param)
                            THEN
                                IF  g01unicode
                                THEN
                                    colinf.cdatalen := n_length DIV 2
                                ELSE
                                    colinf.cdatalen := n_length;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            IF  (colinf.cdatalen = 0) AND a_space_option
                            THEN
                                colinf.cdatalen := 1;
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  colinf.cdatatyp = dtimestamp
                        THEN
                            colinf.cdatalen := mxsp_timestamp
                        ELSE
                            IF  n_symb = s_degree
                            THEN
                                colinf.cdatalen := mxsp_c3
                            ELSE
                                BEGIN
                                colinf.cdatalen := a01identifier_size DIV a01char_size (* PTS 1132280*);
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    (* PTS 1105310 E.Z. *)
                    IF  NOT ora_number_literal
                    THEN
                        IF  colinf.cdatatyp = dunicode
                        THEN
                            colinf.cinoutlen := succ(colinf.cdatalen*2)
                        ELSE
                            colinf.cinoutlen := succ(colinf.cdatalen)
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak642value_stack_entry (
            VAR acv               : tak_all_command_glob;
            start                 : integer;
            leng                  : integer;
            value_to_be_truncated : boolean);
 
BEGIN
IF  acv.a_returncode = 0
THEN
    WITH acv, a_mblock, mb_qual^ DO
        BEGIN
        IF  mfirst_free > mb_st_max
        THEN
            a07_b_put_error (acv, e_too_many_mb_stackentries, -mb_st_max)
        ELSE
            BEGIN
            mqual_cnt := succ (mqual_cnt);
            WITH mb_st^ [mfirst_free] DO
                BEGIN
                etype         := st_value;
                eop           := op_none;
                epos          := start;
                elen_var      := leng;
                IF  value_to_be_truncated
                THEN
                    ecol_tab[ 1 ] := cgg04_value_to_be_truncated
                ELSE
                    ecol_tab[ 1 ] := chr(0);
                (*ENDIF*) 
                ecol_tab[ 2 ] := chr(0);
                END;
            (*ENDWITH*) 
            mfirst_free := succ (mfirst_free)
            END
        (*ENDIF*) 
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak642view_stack_entry (
            VAR acv    : tak_all_command_glob;
            start      : integer;
            VAR dmli   : tak_dml_info;
            VAR colinf : tak00_columninfo;
            view_symb  : tak_sc_symbol);
 
BEGIN
IF  acv.a_returncode = 0
THEN
    WITH acv, a_mblock, mb_qual^ DO
        BEGIN
        dmli.d_const_value_expr := false;
        dmli.d_param_st_index   := 0;
        dmli.d_param_st_begin   := 0;
        IF  mfirst_free > mb_st_max
        THEN
            a07_b_put_error (acv, e_too_many_mb_stackentries, -mb_st_max)
        ELSE
            BEGIN
            mqual_cnt := succ (mqual_cnt);
            WITH mb_st^ [mfirst_free], dmli, colinf DO
                BEGIN
                CASE view_symb OF
                    s_date :
                        etype := st_date;
                    s_time :
                        etype := st_time;
                    s_timestamp :
                        etype := st_timestamp;
                    (* PTS 1116175 E.Z. *)
                    s_utcdate :
                        etype := st_utcdate;
                    (* PTS 1109925 E.Z. *)
                    s_utcdiff :
                        etype := st_utcdiff;
                    s_uid :
                        etype := st_uid;
                    s_user :
                        etype := st_user;
                    s_usergroup :
                        etype := st_usergroup;
                    s_current_schema :
                        etype := st_current_schema;
                    (* PTS 1111797 E.Z. *)
                    s_sysdba :
                        etype := st_sysdba;
                    s_transaction :
                        etype := st_transaction;
                    (* PTS 1122262 E.Z. *)
                    s_timezone :
                        etype := st_timezone;
                    END;
                (*ENDCASE*) 
                eop      := op_none;
                epos     := start;
                elen_var := cinoutlen;
                IF  a_is_ddl = ddl_create_table
                THEN
                    ecol_tab[ 1 ] := chr(2)
                ELSE
                    ecol_tab[ 1 ] := chr(0);
                (*ENDIF*) 
                IF  view_symb in [s_date, s_time, s_timestamp, s_utcdate,
                    s_utcdiff, s_transaction, s_timezone]
                THEN
                    ecol_tab[ 2 ] := csp_defined_byte
                ELSE
                    CASE cdatatyp OF
                        dcha :
                            ecol_tab[ 2 ] := csp_ascii_blank;
                        dunicode :
                            ecol_tab[ 2 ] := csp_unicode_def_byte;
                        OTHERWISE
                            ecol_tab[ 2 ] := csp_defined_byte
                        END
                    (*ENDCASE*) 
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
            mfirst_free := succ(mfirst_free)
            END
        (*ENDIF*) 
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a642colinfo_init;
 
BEGIN
WITH a642standard_colinfo, ccolstack DO
    BEGIN
    ccolumnn    := a01_il_b_identifier;
    ccolumnn_len:= chr(1);
    cextcolno   := 0;
    ccolpropset := [  ];
    cdatatyp    := dchb;
    cdatalen    := 1;
    cdatafrac   := cak_frac_offset;
    cinoutlen   := 2;
    cbinary     := false;
    etype         := st_fixcol;
    eop           := op_none;
    epos          := 1;
    elen_var      := 1;
    ecol_tab[ 1 ] := chr(0);
    ecol_tab[ 2 ] := chr(0);
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a642other_than_column (
            VAR acv   : tak_all_command_glob;
            VAR dmli  : tak_dml_info;
            VAR frec  : tak_factorrec;
            VAR colin : tak00_scolinf;
            act_node  : integer);
 
BEGIN
&ifdef TRACE
t01int4 (ak_sem, 'act_node    ', act_node);
IF  frec.fr_error
THEN
    t01int4 (ak_sem, 'i_error     ', 1)
ELSE
    t01int4 (ak_sem, 'no i_error  ', 0);
(*ENDIF*) 
&endif
WITH acv, a_ap_tree^[ act_node ], dmli, frec DO
    IF  n_symb = s_rowno
    THEN
        BEGIN
        d_const_value_expr := false;
        d_param_st_index   := 0;
        d_param_st_begin   := 0;
        ak642rowno (acv, dmli, colin, act_node);
        IF  NOT ( d_wherepart OR d_having )
        THEN
            (* we are in select list *)
            d_reuse := true;
        (*ENDIF*) 
        END
    ELSE
        IF  n_symb = s_stamp
        THEN
            BEGIN
            d_const_value_expr := false;
            d_param_st_index   := 0;
            d_param_st_begin   := 0;
            ak642stamp (acv, dmli, frec, colin, act_node)
            END
        ELSE
            IF  ((n_symb = s_nextval) OR
                ( n_symb = s_currval))
            THEN
                BEGIN
                d_const_value_expr := false;
                d_param_st_index   := 0;
                d_param_st_begin   := 0;
                ak642nextval_or_currval (acv, dmli, frec,
                      colin, act_node)
                END
            ELSE
                IF  n_proc = a67
                THEN
                    BEGIN
                    d_const_value_expr := false;
                    d_param_st_index   := 0;
                    d_param_st_begin   := 0;
                    ak642corr_column (acv, dmli, frec, colin, act_node)
                    END
                ELSE
                    ak642constant (acv, dmli, frec, colin, act_node)
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak642_put_default_into_part2 (
            VAR acv   : tak_all_command_glob;
            VAR dmli  : tak_dml_info);
 
VAR
      old_len  : integer;
 
BEGIN
WITH acv, dmli, d_sparr.pbasep^.sbase, d_colptr^ DO
    IF  (a_mblock.mb_qual^.mfirst_free > a_mblock.mb_st_max)
    THEN
        a07_b_put_error (acv, e_too_many_mb_stackentries,
              -a_mblock.mb_st_max)
    ELSE
        WITH a_mblock, mb_qual^ DO
            BEGIN
&           ifdef TRACE
            t01messblock (ak_sem, 'MBLOCK 642_p', a_mblock);
&           endif
            old_len := mb_data_len;
            a56one_default_value (acv, dmli, d_colptr^,
                  fp_val_all_without_l);
            mqual_cnt := succ (mqual_cnt);
            WITH mb_st^ [mfirst_free] DO
                BEGIN
                etype         := st_value;
                eop           := op_none;
                epos          := old_len + 1;
                elen_var      := mb_data_len - old_len;
                ecol_tab[ 1 ] := chr(0);
                ecol_tab[ 2 ] := chr(0);
                END;
            (*ENDWITH*) 
            mfirst_free := succ (mfirst_free);
            END
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
