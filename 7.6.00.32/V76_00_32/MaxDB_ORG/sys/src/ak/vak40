.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 2000-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-27
*****************************************************
modname : VAK40
changed : 2000-11-27
module  : AK_universal_show_tools
 
Author  : ThomasA
Created : 1985-10-16
*****************************************************
 
Purpose : Hilfsroutinen f?ur Show_functions..
 
Define  :
 
        VAR
              a40sqlmode : ARRAY[tsp00_SqlMode] OF tsp00_C8;
              a40yes_no  : ARRAY[boolean] OF tsp00_C3;
 
        PROCEDURE
              a40add_explain_record (
                    VAR acv     : tak_all_command_glob;
                    VAR exp_rec : tak71_explain_rec);
 
        PROCEDURE
              a40AppVarCol (
                    VAR a41v     : tak40_show_glob;
                    VAR col_name : tsp00_C32;
                    datatype     : tsp00_DataType;
                    data_len     : integer;
                    fraction     : integer (* PTS 1103569 *) );
 
        PROCEDURE
              a40column_description (
                    VAR acv      : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    tablekind    : tgg00_TableKind;
                    VAR col_info : tak00_columninfo;
                    opt_undef    : boolean);
 
        PROCEDURE
              a40comment_descriptor (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    comment_exist : boolean;
                    VAR tabid     : tgg00_Surrogate;
                    column_no     : integer;
                    comment_kind  : tak_comment_type);
 
        PROCEDURE
              a40datatype_code (
                    VAR col_info : tak00_columninfo;
                    is_oracle    : boolean;
                    comp_type    : tak_appl_type;
                    VAR datatype : tsp00_Sname;
                    VAR code     : tsp00_C10;
                    VAR datalen  : integer);
 
        PROCEDURE
              a40date_time_analyze (
                    VAR acv      : tak_all_command_glob;
                    VAR coldesc  : tak_vcolumndescription;
                    dt_format    : tgg00_DateTimeFormat;
                    VAR outbuf   : tsp00_MoveObj;
                    pos          : integer;
                    VAR aux1     : tsp00_C64;
                    VAR auxlen   : integer);
 
        PROCEDURE
              a40FinishTableScan (
                    VAR acv          : tak_all_command_glob;
                    VAR a41v         : tak40_show_glob);
 
        PROCEDURE
              a40get_catalog_table (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a40glob_init;
 
        PROCEDURE
              a40init_table_scan (
                    VAR acv          : tak_all_command_glob;
                    VAR a41v         : tak40_show_glob;
                    scan_temp        : boolean;
                    scan_private     : boolean;
                    scan_non_private : boolean;
                    scan_public      : boolean;
                    use_synonyms     : boolean;
                    all_base         : boolean);
 
        FUNCTION
              a40is_unique (
                    VAR acv           : tak_all_command_glob;
                    VAR distinct_tree : tgg00_FileId;
                    VAR tabid         : tgg00_Surrogate;
                    check_only        : boolean) : boolean;
 
        PROCEDURE
              a40join_expl_row (
                    VAR acv            : tak_all_command_glob;
                    VAR strat          : tsp00_C40;
                    VAR owner          : tsp00_KnlIdentifier;
                    VAR table          : tsp00_KnlIdentifier;
                    recs_found         : tsp00_Longreal;
                    multiplier         : tsp00_Longreal;
                    reverse_multiplier : tsp00_Longreal;
                    new_left_size      : tsp00_Longreal;
                    new_left_recs      : tsp00_Longreal;
                    costs              : tsp00_Longreal);
 
        FUNCTION
              a40next_table (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob) : boolean;
 
        PROCEDURE
              a40move (
                    VAR acv     : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    moveobj_ptr : tsp00_MoveObjPtr (*ptocSynonym void**);
                    move_len    : integer);
 
        PROCEDURE
              a40move_const (
                    VAR acv     : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    moveobj_ptr : tsp00_MoveObjPtr (*ptocSynonym void**);
                    move_len    : integer);
 
        PROCEDURE
              a40move_counter (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    val           : tsp00_8ByteCounter;
                    is_null       : boolean;
                    frac          : integer;
                    zero_to_undef : boolean);
 
        PROCEDURE
              a40move_guid (
                    VAR acv     : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    VAR guid    : tsp00_C16);
 
        PROCEDURE
              a40move_i4 (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    i4_val        : tsp00_Int4;
                    is_null       : boolean;
                    frac          : integer;
                    zero_to_undef : boolean);
 
        PROCEDURE
              a40move_ui4 (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    i4_val        : tsp00_Int4;
                    is_null       : boolean;
                    frac          : integer;
                    zero_to_undef : boolean);
 
        PROCEDURE
              a40move_real (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    val           : tsp00_Longreal;
                    is_null       : boolean;
                    frac          : integer);
 
        PROCEDURE
              a40ignore_down_error (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a40default (
                    VAR acv         : tak_all_command_glob;
                    VAR a41v        : tak40_show_glob;
                    VAR colinfo     : tak00_columninfo;
                    VAR defaultrec  : tak_defaultrecord);
 
        PROCEDURE
              a40_p_priv (
                    VAR pr  : tak_privilege;
                    VAR prn : tsp00_C40;
                    colno   : tsp00_Int2);
 
        PROCEDURE
              a40long_descriptor (
                    VAR acv      : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    VAR tabid    : tgg00_Surrogate;
                    column_no    : integer);
 
        PROCEDURE
              a40sequence_expl_row (
                    VAR acv  : tak_all_command_glob;
                    VAR line : tsp00_Line;
                    change_to_unicode : boolean);
 
        PROCEDURE
              a40site (
                    VAR acv              : tak_all_command_glob;
                    VAR a41v             : tak40_show_glob;
                    VAR siteserverdbname : tsp00_DbName;
                    VAR siteid           : tsp00_NodeId);
 
        PROCEDURE
              a40table_column_to_shbuf (
                    VAR acv      : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    base_ptr     : tak_sysbufferaddress;
                    colindex     : integer;
                    with_owner   : boolean);
 
        PROCEDURE
              a40put_date_time (
                    VAR acv             : tak_all_command_glob;
                    VAR a41v            : tak40_show_glob;
                    VAR datetime        : tsp00_Int4;
                    date                : boolean;
                    is_undef            : boolean);
 
        PROCEDURE
              a40put_one_value (
                    VAR acv      : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    VAR col_info : tak00_columninfo;
                    do_move      : boolean;
                    VAR valbuf   : tsp00_C256;
                    valpos       : integer;
                    vallen       : integer;
                    VAR destbuf  : tsp00_C256;
                    VAR destlen  : integer;
                    VAR ok       : boolean);
 
        PROCEDURE
              a40SetAllObjects(
                    VAR acv   : tak_all_command_glob;
                    VAR a41v  : tak40_show_glob);
 
        PROCEDURE
              a40username_from_syskey (
                    VAR sysk      : tgg00_SysInfoKey;
                    VAR user_name : tsp00_KnlIdentifier);
 
        FUNCTION
              a40usertab_next (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    use_tables    : boolean;
                    use_dbprocs   : boolean;
                    use_sequences : boolean;
                    VAR surrogate : tgg00_Surrogate;
                    VAR kind      : tgg00_TableKind) : boolean;
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
&       IFDEF TRACE
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01basis_error (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname;
                    b_err : tgg00_BasisError);
 
        PROCEDURE
              t01buf  (
                    layer    : tgg00_Debug;
                    VAR buf  : tak40_show_record;
                    startpos : integer;
                    endpos   : integer);
 
        PROCEDURE
              t01buf1 (
                    layer    : tgg00_Debug;
                    VAR buf  : tsp00_Buf;
                    startpos : integer;
                    endpos   : integer);
 
        PROCEDURE
              t01c64 (debug : tgg00_Debug; VAR msg : tsp00_C64);
 
        PROCEDURE
              t01moveobj (
                    layer    : tgg00_Debug;
                    VAR buf  : tak40_shinfo;
                    startpos : tsp00_Int4;
                    endpos   : tsp00_Int4);
 
        PROCEDURE
              t01int4 (
                    layer : tgg00_Debug;
                    nam : tsp00_Sname;
                    int : tsp00_Int4);
 
        PROCEDURE
              t01lidentifier (
                    layer      : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01qual (debug : tgg00_Debug; VAR part1 : tgg00_QualBuf);
 
        PROCEDURE
              t01surrogate (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR tabid : tgg00_Surrogate);
&       ENDIF
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01char_size       : integer;
              a01identifier_size : integer;
              a01sysnullkey      : tgg00_SysInfoKey;
              a01defaultkey      : tgg00_SysInfoKey;
              a01_i_domain       : tsp00_KnlIdentifier;
              a01_i_public       : tsp00_KnlIdentifier;
              a01_i_sys          : tsp00_KnlIdentifier;
              a01_i_system       : tsp00_KnlIdentifier;
              a01_i_tablekey     : tsp00_KnlIdentifier;
              a01_i_temp         : tsp00_KnlIdentifier;
              a01_il_b_identifier : tsp00_KnlIdentifier;
 
        PROCEDURE
              a01setl_identifier (
                    VAR id         : tsp00_KnlIdentifier;
                    set_identifier : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
&       IFDEF TRACE
        PROCEDURE
              a06td_priv (
                    p        : tak_privilege;
                    id       : tsp00_C18;
                    unpacked : boolean);
&       ENDIF
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06_systable_get (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR tableid  : tgg00_Surrogate;
                    VAR base_ptr : tak_sysbufferaddress;
                    get_all      : boolean;
                    VAR ok       : boolean);
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06det_user_id (
                    VAR acv      : tak_all_command_glob;
                    VAR authname : tsp00_KnlIdentifier;
                    VAR authid   : tgg00_Surrogate);
 
        FUNCTION
              a06_role_excluded (
                    VAR acv     : tak_all_command_glob;
                    VAR role_id : tgg00_Surrogate) : boolean;
 
        PROCEDURE
              a06rsend_mess_buf (
                    VAR acv     : tak_all_command_glob;
                    VAR mbuf    : tgg00_MessBlock;
                    return_req  : boolean;
                    VAR b_err   : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061add_name (
                    VAR acv      : tak_all_command_glob;
                    VAR base_rec : tak_baserecord;
                    VAR name     : tsp00_KnlIdentifier;
                    VAR p        : tsp00_KnlIdentifierPtr);
 
        PROCEDURE
              a061app_columnname (
                    VAR acv               : tak_all_command_glob;
                    VAR base_rec          : tak_baserecord;
                    VAR column            : tsp00_KnlIdentifier;
                    VAR index             : integer);
 
        PROCEDURE
              a061assign_colname (
                    value  : tsp00_C18;
                    VAR id : tsp00_KnlIdentifier);
 
        PROCEDURE
              a061sort (
                    VAR acv               : tak_all_command_glob;
                    VAR base_rec          : tak_baserecord;
                    last_used_expr_no     : integer;
                    VAR duplicate_column  : boolean;
                    VAR duplicate_colname : tsp00_KnlIdentifier);
&       ifdef trace
 
        PROCEDURE
              a061td_colinfo (
                    VAR colinfo : tak00_columninfo;
                    index : integer);
&       endif
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache   : VAK10;
 
        PROCEDURE
              a10add_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_key_del  (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10key_del  (
                    VAR acv         : tak_all_command_glob;
                    VAR  syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10_rel_sysinfo  (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10dispose (
                    VAR acv  : tak_all_command_glob;
                    VAR p    : tak_sysbufferaddress);
 
        PROCEDURE
              a10new (
                    VAR acv  : tak_all_command_glob;
                    obj_size : tsp00_Int4;
                    VAR p    : tak_sysbufferaddress);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
        FUNCTION
              a10is_fixed (
                    VAR acv : tak_all_command_glob;
                    p       : tak_sysbufferaddress) : boolean;
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
        FUNCTION
              a101_GetExtendedTempFileType(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tgg00_TfnTemp;
 
        PROCEDURE
              a101_SetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId;
                    sublevel       : tsp00_Int4(*ptocConst*));
 
        FUNCTION
              a101_GetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tsp00_Int4;
 
        FUNCTION
              a101_RegisterCurrentStatement (
                    VAR acv : tak_all_command_glob) : tsp00_Int4;
 
        PROCEDURE
              a101_UnregisterStatement (
                    VAR acv     : tak_all_command_glob;
                    statementId : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        FUNCTION
              a103ExistsSchema (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier (* ptocConst *)) : tak_sysbufferaddress;
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate (* ptocConst *);
                    VAR schemaName : tsp00_KnlIdentifier);
 
        PROCEDURE
              a103NextUser (
                    VAR acv      : tak_all_command_glob;
                    VAR userId   : tgg00_Surrogate;
                    VAR buf      : tak_userrecord;
                    userGroup    : boolean;
                    nonUserGroup : boolean;
                    VAR e        : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              AK_Table : VAK11;
 
        FUNCTION
              a11firstindex (
                    colcount    : integer;
                    VAR baserec : tak_baserecord) : tsp00_Int2;
 
        PROCEDURE
              a11sort (VAR base_rec : tak_baserecord);
 
        PROCEDURE
              a11put_date_time (
                    VAR date : tsp00_Int4;
                    VAR time : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_Data_Type_Options : VAK14;
 
        FUNCTION
              a14LengthOfDefaultValue (
                    VAR DefaultRec : tak_defaultrecord) : integer; (* PTS 1108428 *)
 
      ------------------------------ 
 
        FROM
              AK_Synonym : VAK23;
 
        FUNCTION
              a23is_sequence_synonym (VAR synrec : tak_synonymrecord) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Comment : VAK26;
 
        PROCEDURE
              a26get_comment_prefix (
                    VAR acv       : tak_all_command_glob;
                    VAR long_desc : tak_long_descriptor;
                    VAR buf       : tsp00_C256;
                    pos           : integer;
                    required_len  : integer);
 
      ------------------------------ 
 
        FROM
              SystemViews : VAK400;
 
        PROCEDURE
              a400SVDefSysViewTable(
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
      ------------------------------ 
 
        FROM
              Long-Support-Getval : VAK508;
 
        PROCEDURE
              a508get_definition_text (
                    VAR acv       : tak_all_command_glob;
                    VAR surrogate : tgg00_Surrogate;
                    show_kind     : tgg00_ShowKind;
                    colno         : integer;
                    bufSize       : integer;
                    VAR buf       : tgg00_SelectBuffer;
                    VAR textlen   : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Resultname_handling : VAK663;
 
        PROCEDURE
              a663create_result_file (
                    VAR acv      : tak_all_command_glob;
                    m_type       : tgg00_MessType;
                    VAR res_tree : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              Catalog_Select_Optimizer : VAK722;
 
        PROCEDURE
              a722add_col_qual (
                    VAR acv      : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    VAR mblock   : tgg00_MessBlock;
                    colno        : integer;
                    VAR startkey : tgg00_Lkey;
                    VAR stopkey  : tgg00_Lkey;
                    work_buf     : tak40_int2_arr_ptr);
 
        FUNCTION
              a722test_col_qual (
                    VAR acv   : tak_all_command_glob;
                    VAR a41v  : tak40_show_glob;
                    colname   : tak_oldidentifier;
                    def_byte  : char;
                    value_ptr : tsp00_MoveObjPtr;
                    value_len : integer;
                    work_buf  : tak40_int2_arr_ptr) : boolean;
 
        PROCEDURE
              a722init_epos_reccol_relation(
                    VAR acv       : tak_all_command_glob;
                    VAR pos_info  : tak40_int2_arr_ptr);
 
        PROCEDURE
              a722finalize_epos_reccol_relation(
                    VAR acv       : tak_all_command_glob;
                    VAR pos_info  : tak40_int2_arr_ptr);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code          : tgg04_CodeGlobals;
              g01glob          : tgg00_KernelGlobals;
              g01unicode       : boolean;
              g01vtrace        : tgg00_VtraceState;
 
        PROCEDURE
              g01datapart_init (
                    VAR mblock    : tgg00_MessBlock;
                    datapart_ptr  : tgg00_DataPartPtr;
                    datapart_size : tsp00_Int4);
 
        PROCEDURE
              g01mblock_init (
                    VAR source_trans : tgg00_TransContext;
                    mess_type  : tgg00_MessType;
                    mess2_type : tgg00_MessType2;
                    VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              g01stack_init (
                    VAR mblock : tgg00_MessBlock;
                    stack_ptr  : tgg00_StackListPtr;
                    stack_size : tsp00_Int4;
                    qual_ptr   : tgg00_QualBufPtr;
                    qual_size  : tsp00_Int4);
 
        PROCEDURE
              g01abort (
                    msg_no     : tsp00_Int4;
                    msg_label  : tsp00_C8;
                    msg_text   : tsp00_C24;
                    bad_value  : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Check-Date-Time : VGG03;
 
        PROCEDURE
              g03fdcheck_date (
                    VAR sbuf   : tsp00_C64;
                    VAR dbuf   : tsp00_C256;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              g03ftcheck_time (
                    VAR sbuf   : tsp00_C64;
                    VAR dbuf   : tsp00_C256;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              g03ftscheck_timestamp (
                    VAR sbuf   : tsp00_C64;
                    VAR dbuf   : tsp00_C256;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    language   : tsp00_C3;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              g03dchange_format_date (
                    VAR sbuf : tsp00_C256;
                    VAR dbuf  : tsp00_C256;
                    spos      : tsp00_Int4;
                    dpos      : tsp00_Int4;
                    format    : tgg00_DateTimeFormat;
                    VAR b_err : tgg00_BasisError);
 
        PROCEDURE
              g03tchange_format_time (
                    VAR sbuf : tsp00_C256;
                    VAR dbuf  : tsp00_C256;
                    spos      : tsp00_Int4;
                    dpos      : tsp00_Int4;
                    format    : tgg00_DateTimeFormat;
                    VAR b_err : tgg00_BasisError);
 
        PROCEDURE
              g03tschange_format_timestamp (
                    VAR sbuf : tsp00_C256;
                    VAR dbuf  : tsp00_C256;
                    spos      : tsp00_Int4;
                    dpos      : tsp00_Int4;
                    format    : tgg00_DateTimeFormat;
                    language  : tsp00_C3;
                    VAR b_err : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Trace_Help_Procedures : VGG041;
 
        PROCEDURE
              g041explain_trace (
                    VAR t      : tgg00_TransContext;
                    VAR shinfo : tak40_shinfo);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedUnicodeFill (
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2 );
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id   : tsp00_C6;
                    mod_num  : tsp00_Int4;
                    src_upb  : tsp00_Int4;
                    dest_upb : tsp00_Int4;
                    src      : tsp00_MoveObjPtr;
                    src_pos  : tsp00_Int4;
                    dest     : tsp00_MoveObjPtr;
                    dest_pos : tsp00_Int4;
                    length   : tsp00_Int4;
                    VAR err  : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17counter_to_line (
                    counter               : tsp00_8ByteCounter;
                    VAR ln_len            : integer;
                    VAR ln                : tsp00_Line);
 
        PROCEDURE
              g17hexto_line (
                    c          : char;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_C40);
 
      ------------------------------ 
 
        FROM
              KB_Logging : vkb560;
 
        PROCEDURE
              kb560GetSys2CatalogTreeId(
                    VAR treeId : tgg00_FileId);
 
        FUNCTION
              kb560IsCatalogTable(VAR tabId : tgg00_Surrogate) : boolean;
 
      ------------------------------ 
 
        FROM
              Single_Select_Part2 : VKB721;
 
        PROCEDURE
              k721catalog_add_into_result (
                    VAR m           : tgg00_MessBlock;
                    VAR sel         : tgg00_SelectFieldsParam;
                    VAR selrec      : tgg07_select_context;
                    VAR getrec      : tgg07_get_param;
                    VAR result_rec  : tak40_show_record;
                    VAR one_res_rec : tgg00_Rec;
                    VAR res_cnt     : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
              b01zerokey    : tsp00_Key;
 
        PROCEDURE
              b01tcreate_file (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              error_text_handling : VBD06;
 
        PROCEDURE
              b06get_errtxt (
                    VAR t        : tgg00_TransContext;
                    VAR errlen   : integer;
                    VAR err_type : tgg04_ErrorText;
                    VAR b_error  : tgg00_BasisError;
                    VAR errtxt   : tsp00_C256);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD07;
 
        PROCEDURE
              b07cadd_record (
                    VAR t    : tgg00_TransContext;
                    VAR curr : tgg00_FileId;
                    VAR b    : tak40_show_record);
 
        PROCEDURE
              b07cget_record (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Lkey;
                    VAR b       : tgg00_Rec);
 
      ------------------------------ 
 
        FROM
              GET-Conversions : VSP40;
 
        PROCEDURE
              s40gbyte (
                    VAR buf       : tsp00_C256;
                    pos           : tsp00_Int4;
                    len           : integer;
                    VAR dest      : tsp00_C256;
                    dpos          : tsp00_Int4;
                    dlen          : integer;
                    VAR truncated : boolean);
 
      ------------------------------ 
 
        FROM
              PUT-Conversions : VSP41;
 
        PROCEDURE
              s41plint (
                    VAR buf : tak40_shinfo;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
        PROCEDURE
              s41p8int (
                    VAR buf : tak40_shinfo;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Longint;
                    VAR res : tsp00_NumError);
 
        PROCEDURE
              s41plrel (
                    VAR buf : tak40_shinfo;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Longreal;
                    VAR res : tsp00_NumError);
 
        PROCEDURE
              s41pluns (
                    VAR buf : tak40_shinfo;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              GETSTRING-Conversions : VSP42;
 
        PROCEDURE
              s42gstr (
                    VAR buf  : tsp00_C256;
                    pos      : tsp00_Int4;
                    len      : integer;
                    frac     : integer;
                    origlen  : integer;
                    VAR dest : tsp00_C256;
                    dpos     : tsp00_Int4;
                    VAR dlen : integer;
                    VAR res  : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20int4_to_buf_swap (
                    val        : tsp00_Int4;
                    sourceswap : tsp00_SwapKind;
                    VAR dest   : tsp00_C4;
                    di         : tsp00_Int4;
                    destswap   : tsp00_SwapKind);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30eq (
                    VAR a,b : tsp00_KnlIdentifier;
                    bi,cnt : tsp00_Int4) : boolean;
 
        FUNCTION
              s30klen (
                    VAR str : tsp00_Sname;
                    val : char; cnt : integer) : integer;
 
        FUNCTION
              s30lnr (
                    VAR str : tsp00_KnlIdentifier;
                    val   : char;
                    start : tsp00_Int4;
                    cnt   : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30unilnr (
                    str       : tsp00_MoveObjPtr;
                    skip_val  : tsp00_C2;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80: VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              a103NextUser;
 
              tsp00_Buf tak_userrecord
 
        FUNCTION
              a103ExistsSchema;
 
              tgg00_VoidPtr  tak_sysbufferaddress
 
        PROCEDURE
              a722add_col_qual;
 
              tgg00_SysInfoKey tgg00_Lkey
 
        PROCEDURE
              a508get_definition_text;
 
              tsp00_MoveObj tgg00_SelectBuffer;
 
        PROCEDURE
              a26get_comment_prefix;
 
              tsp00_Buf tsp00_C256
 
        PROCEDURE
              g03fdcheck_date;
 
              tsp00_MoveObj tsp00_C64
              tsp00_MoveObj tsp00_C256
 
        PROCEDURE
              g03ftcheck_time;
 
              tsp00_MoveObj tsp00_C64
              tsp00_MoveObj tsp00_C256
 
        PROCEDURE
              g03ftscheck_timestamp;
 
              tsp00_MoveObj tsp00_C64
              tsp00_MoveObj tsp00_C256
 
        PROCEDURE
              g03tschange_format_timestamp;
 
              tsp00_MoveObj tsp00_C256
              tsp00_MoveObj tsp00_C256
 
        PROCEDURE
              g03tchange_format_time;
 
              tsp00_MoveObj tsp00_C256
              tsp00_MoveObj tsp00_C256
 
        PROCEDURE
              g03dchange_format_date;
 
              tsp00_MoveObj tsp00_C256
              tsp00_MoveObj tsp00_C256
 
        PROCEDURE
              g17hexto_line;
 
              tsp00_Line tsp00_C40
 
        PROCEDURE
              k721catalog_add_into_result;
 
              tgg00_Rec    tak40_show_record
 
        PROCEDURE
              b07cadd_record;
 
              tgg00_Rec   tak40_show_record
 
        PROCEDURE
              b07cappend_record;
 
              tgg00_Rec   tak40_show_record
 
        PROCEDURE
              t01buf;
 
              tsp00_Buf  tak40_show_record
 
        PROCEDURE
              t01moveobj;
 
              tsp00_MoveObj tak40_shinfo
 
        PROCEDURE
              s20int4_to_buf_swap;
 
              tsp00_MoveObj tsp00_C4
 
        PROCEDURE
              s30eq;
 
              tsp00_MoveObj    tsp00_KnlIdentifier
              tsp00_MoveObj    tsp00_KnlIdentifier
 
        FUNCTION
              s30lnr;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              s30klen;
 
              tsp00_MoveObj    tsp00_Sname
 
        PROCEDURE
              s42gstr;
 
              tsp00_MoveObj    tsp00_C256
              tsp00_MoveObj    tak40_shinfo
 
        PROCEDURE
              s40gbyte;
 
              tsp00_MoveObj    tsp00_C256
 
        PROCEDURE
              s41plint;
 
              tsp00_MoveObj tak40_shinfo
 
        PROCEDURE
              s41p8int;
 
              tsp00_MoveObj tak40_shinfo
 
        PROCEDURE
              s41plrel;
 
              tsp00_MoveObj tak40_shinfo
 
        PROCEDURE
              s41pluns;
 
              tsp00_MoveObj tak40_shinfo
 
        PROCEDURE
              g041explain_trace;
 
              tsp00_MoveObj tak40_shinfo
 
.CM *-END-* synonym -------------------------------------
***********************************************************
 
Description:
 
.cp 10
SHOW BEFEHLE :
.fo;.sp 2
Die Show-Befehle liefern wie die Select-Kommandos wiederverwendbare
und benennbare Ergebnismengen, die jedoch statt aus benutzerdefinierten
Tabellen aus den Systeminformationen erzeugt werden.
Im Gegensatz zu den Select-Kommandos ist kein getrenntes
Pars-Execute m?oglich.
Prinzipiell laufen alle Show-Kommandos nach demselben Schema ab :
.sp;.nf
.cp 10
    1) Syntaxerkennung
    2) Ergebnismengennamen bestimmen und in Liste
       der Ergebnisse eintragen. (==> a41_show_semantic)
    3) Showergebnisfile initialisieren
       (==> ak41init_showfile)
    4) Showlonginforecord holen (==> a40_get_show_longinfo)
       und Showergebnismenge gem?a?z Longinfo's aufbauen.
    5) Showergebnisfile schlie?zen und Informationen f?ur
       Fetch-Kommandos auf die Showergebnismenge bereit-
       stellen (==> a40_end_showfile).
.sp;.fo
.cp 2
Das Modul VAK40 enth?alt die Prozeduren, die von allen Showkommandos
ben?otigt werden :
.sp
.cp 9
PROCEDURE  A40_GET_SHOW_LONGINFO
.sp
Zu jedem Showbefehl existiert ein Longinforecord, das die Beschreibung
der S?atze der zu erzeugenden Ergebnistabelle enth?alt.
.br
Diese Showlonginforecords werden aus den permanenten Systeminformationen
gelesen. Falls die Records nach einem Init Config noch nicht in den
Systeminformationen stehen, m?ussen sie erst aufgebaut und eingef?ugt
werden. Hierzu dienen die folgenden Prozeduren :
.sp;
.in +4
.cp 2
A40_P_TABLE
.br
Aufbau des Longinforecords f?ur Show Table <Tabellenname>
.sp
.cp 2
A40_P_LISTTABLE
.br
Aufbau des Longinforecords f?ur Show Table mit '*'
.sp
.cp 2
A40_P_TRUNCTABLE
.br
Aufbau des Longinforecords f?ur Show Table quick
.sp
.cp 2
A40_P_COLUMN
.br
Aufbau des Longinforecords f?ur Show Column
.sp
.cp 2
A40_P_CONFIG
.br
Aufbau des Longinforecords f?ur Show Statistics Config
.sp
.cp 3
A40_P_MONITOR
.br
Aufbau des Longinforecords f?ur Show Statistics Monitor,
Column, Database, Log, Table, Index und Devspace
.sp
.cp 2
A40_P_ST_USER
.br
Aufbau des Longinforecords f?ur Show Statistics User
.sp
.cp 2
A40_PRIV_USER
.br
Aufbau des Longinforecords  f?ur Show Privileges User
.sp
.cp 3
A40_PRIV_TABLE
.br
Aufbau des Longinforecords f?ur Show Privileges Table
und Show Privileges Column
.sp
.cp 2
AK40PRIV_GRANTED_TO
.br
Aufbau des Longinforecords f?ur Show Privileges Granted To
.sp
.cp 2
A40_P_SYNONYM
.br
Aufbau des Longinforecords f?ur Show Synonym
.sp
.cp 2
A40_P_USER
.br
Aufbau des Longinforecords f?ur Show User
.sp
.cp 2
A40_P_VERSION
.br
Aufbau des Longinforecords f?ur Show Version
.sp
.cp 2
A40_P_VIEW
.br
Aufbau des Longinforecords f?ur Show View
.sp
.cp 2
A40_P_INDEX
.br
Aufbau des Longinforecords f?ur Show Index
.sp
.cp 2
A40_P_DOMAIN
.br
Aufbau des Longinforecords f?ur Show Domain
.in -4
.fo;.sp 4
.cp 7
PROCEDURE  CREATE_FETCH_HELP_RECORD
.sp
Um nach dem Aufbau der Showergebnismenge durch den Showbefehl
mit Fetch-Kommandos darauf zugreifen zu k?onnen, mu?z ein Parsinforecord
aufgebaut werden, das die Beschreibung der Showergebnismenge enth?alt.
Das Parsinforecord ist im wesentlichen identisch mit dem Showlonginforecord.
Nach dem Aufbau wird das Parsinforecord ins tempor?are Parsfile eingef?ugt.
.br
.cp 5
Zur Bearbeitung der Fetch-Kommandos wird ferner ein Reskeyrecord
ben?otigt, in dem die Informationen ?uber den n?achsten zu holenden Satz
stehen. Im Falle der Showergebnismengen wird der Record wie folgt
initialisiert:
.sp
.in +4
.cp 3
rescurrent := show_curr;
.br
Baumidentifikation, auf die sich das Fetch bezieht ist die des Showfiles.
.sp
.cp 2
res_nextkeys.reckey.len := 0;
.br
N?achster zu holende Satz ist hinter Zerokey zu suchen.
.sp
.cp 2
res_nextkeys.listkey.len := 0;
.br
Keine Invertierung.
.sp;.nf;.cp 3
res_prevkeys.reckey.len := 0;
.sp;.fo
.cp 2
res_nextpos := 0;
.br
Es wurde noch kein Record geholt
.sp
.cp 3
res_actres := show_last_key;
.br
Die Ergebnismenge besteht aus show_last_key Ergebnisrecords.
.sp
.cp 3
res_prevpos := 0;
.br
Beim Lesen der Ergebnismenge von hinten mu?z zuerst row not found kommen
.sp
.cp 2
res_ergname := show_fname;
.br
Ergebnismengenname
.sp
.cp 2
res_filename := showfile;
.br
Ergebnismengenfilename
.sp;.nf
.cp 4
res_order := True;
             bei sortierten Ergebnismengen.
res_order := False;
             bei nicht sortierten Ergebnismengen.
.sp;
.cp 2
res_build := True;
             Ergebnismenge ist aufgebaut.
.sp
res_erstat := [ teresult ]
.sp
.cp 2
res_desc   := False;
              Ascending Index
.sp
res_keylen := Keyl?ange der S?atze in der Showergebnismenge;
.sp
res_reclen := L?ange der S?atze in der Showergebnismenge;
 
.sp 4
.fo
.cp 8
PROCEDURE  A40_ADD_SHOW_RECORD
.sp
Die Prozedur wird benutzt, um Showergebniss?atze, die in der Reihenfolge
der Erstellung ausgegeben werden, in die Showergebnismenge einzuf?ugen.
Der aufgebaute Showrecord wird der Prozedur durch die globale
Variable a40v.shinfo ?ubergeben. Dieser Satz erh?alt einen 4 Bytes
langen Schl?ussel und wird anschlie?zend in die Showergebnismenge
eingef?ugt.
.sp 4
.cp 9
PROCEDURE  A40ADD_EXPLAIN_RECORD
.sp
Diese Prozedur wird benutzt, um Showergebniss?atze f?ur einen Explain -
Befehl in die Showergebnismenge einzuf?ugen.
Es wird ein Showrecord aufgebaut, in den die durch den Explain_Record
?ubergebenen Werte im Shinfo-Teil eingef?ugt werden. Der 4 Bytes lange
Sch?ussel wird mit show_last_key (als String) belegt.
.sp 4
.cp 9
PROCEDURE  A40_ADDKEY_SHOWRECORD
.sp
Diese Prozedur wird benutzt, um Showergebniss?atze, die nach einem
Sortierkriterium ausgegeben werden, in die Showergebnismenge einzuf?ugen.
In a40v.shinfo mu?z in diesem Fall der Satz mit dem Schl?ussel, nach dem
sortiert wird, aufgebaut sein. Der 4 Bytes lange Schl?ussel
kann mit einem Integerwert belegt werden, der dann als erstes
Sortierkriterium dient.
 
.CM *-END-* description ---------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      c_to_undef            = true;
      c_change_to_unicode   = true;
      c_with_owner          = true;
      showkeylen            = 4;
      shinfooffset          = cgg_rec_key_offset + showkeylen;
      ln_action                = 'ACTION            ';
      ln_active                = 'ACTIVE            ';
      ln_active_gc_taskid      = 'ACTIVE_GC_TASKID  ';  (* PTS 1115641 F.F. *)
      ln_activateCount         = 'ACTIVATE_COUNT    ';
      ln_alterdate             = 'ALTERDATE         ';
      ln_altertime             = 'ALTERTIME         ';
      ln_appl_process          = 'APPL_PROCESS      ';
      ln_appl_node             = 'APPL_NODEID       ';
      ln_archive               = 'ARCHIVE           ';
      ln_ascii_offset          = 'ASCII_OFFSET      ';
      ln_avgWaitForLockobj     = 'LOCKOBJAVGWAITTIME';
      ln_avgvarobjsize         = 'AVG_VAR_OBJ_SIZE  ';
      ln_avg_strbuf_read       = 'AVG_STRBUF_READ   ';
      ln_avg_strbuf_write      = 'AVG_STRBUF_WRITTEN';
      ln_avg_strrow_read       = 'AVG_STRROW_READ   ';
      ln_avg_strrow_write      = 'AVG_STRROW_WRITTEN';
      ln_bwhierarchy           = 'BWHIERARCHY       ';
      ln_virtualkey            = 'VIRTUALKEY        ';
      ln_cache_size            = 'CACHE_SIZE        ';
      ln_call_cnt              = 'CALL_CNT          ';
      ln_call_stack_id         = 'CALL_STACK_ID     ';
      ln_call_stack            = 'CALL_STACK        ';
      ln_cancelled             = 'CANCELLED         ';  (* PTS 1120151 FF 2003-01-29 *)
      ln_chain_id              = 'CHAIN_ID          ';  (* PTS 1115641 F.F. *)
      ln_checkpoints           = 'CHECKPOINTS       ';
      ln_close_version         = 'CLOSE_VERSION     ';
      ln_coclsid               = 'COCLSID           ';
      ln_code                  = 'CODE              ';
      ln_colcount              = 'COLCOUNT          ';
      ln_columnno              = 'COLUMNNO          ';
      ln_column_index          = 'COLUMN_OR_INDEX   ';
      ln_column_priv           = 'COLUMNPRIVILEGES  ';
      ln_comment               = 'COMMENT           ';
      (* PTS 1107717 E.Z. *)
      ln_component             = 'COMPONENT         ';
      ln_complex               = 'COMPLEX           ';
      ln_connect               = 'CONNECT           ';
      ln_consistent_view       = 'CONSISTENT_VIEW   ';
      ln_constraintname        = 'CONSTRAINTNAME    ';
      ln_container_sequel_no   = 'SEQUELCONTAINER   ';  (* PTS 1115641 F.F. *)
      ln_coordinator           = 'COORDINATOR       ';
      ln_costwarning           = 'COSTWARNING       ';
      ln_costlimit             = 'COSTLIMIT         ';
      ln_number                = 'NUMBER            ';
      ln_create_version        = 'CREATE_VERSION    ';
      ln_creator_trans         = 'CREATOR_TRANSCOUNT';  (* PTS 1125503 FF 2003-11-19 *)
      ln_cursor                = 'CURSOR            ';
      ln_cycle_flag            = 'CYCLE_FLAG        ';
      ln_class_id              = 'CLASS_ID          ';
      ln_date_format           = 'DATE_FORMAT       ';
      ln_dbfunction            = 'DBFUNCTION        ';
      ln_dbproc                = 'DBPROCEDURE       ';
      ln_defaultcode           = 'DEFAULTCODE       '; (* PTS 1117216 E.Z. *)
      ln_defaultrole           = 'DEFAULTROLE       '; (* PTS 1104069 *)
      ln_defaultfunction       = 'DEFAULTFUNCTION   ';
      ln_definition            = 'DEFINITION        ';
      ln_delete                = 'DELETE            ';
      ln_delete_flag           = 'DELETED           '; (* PTS 1115641 FF *)
      ln_delete_in_version     = 'DELETE_IN_VERSION ';
      ln_delete_obj            = 'DELETE_OBJ        ';
      ln_delete_oms            = 'OMS_DELETE        ';
      ln_delete_lc             = 'LC_DELETE         ';
      ln_delete_var_obj        = 'DELETE_VAR_OBJ    ';
      ln_delta_alloc_min       = 'DELTA_ALLOC_MIN   ';
      ln_delta_alloc_max       = 'DELTA_ALLOC_MAX   ';
      ln_delta_alloc_avg       = 'DELTA_ALLOC_AVG   ';
      ln_deref                 = 'DEREF             ';
      ln_deref_iter            = 'DEREF_ITERATOR_LC '; (* PTS 1107819 T.A 2000-09-13 *)
      ln_deref_lc              = 'DEREF_VIA_LC      ';
      ln_deref_key             = 'DEREF_VIA_KEY     ';
      ln_dimension             = 'DIMENSION         ';
      ln_deterministic         = 'DETERMINISTIC     ';
      ln_disabled              = 'DISABLED          ';
      ln_dist_values           = 'DISTINCTVALUES    ';
      ln_dispid                = 'DISPID            ';
      ln_domainowner           = 'DOMAINOWNER       ';
      ln_dropFile              = 'DROP_FILE         ';
      ln_drop_version          = 'DROP_VERSION      ';
      ln_dynamic               = 'DYNAMIC           ';
      ln_emergency             = 'EMERGENCYCHUNKSIZE';
      ln_emergencyInUse        = 'EMERGENCYINUSE    ';
      ln_emergencyMaxUsed      = 'EMERGENCYMAXUSED  ';
      ln_estimated_pages       = 'ESTIMATED_PAGES   ';
      ln_exceptions            = 'EXCEPTIONS        ';
      ln_execution_kind        = 'EXECUTION_KIND    ';
      ln_fact                  = 'FACT              ';
      ln_file                  = 'FILE              ';
      ln_file_empty            = 'FILE_EMPTY        ';
      ln_file_no               = 'FILE_NO           ';
      ln_file_id               = 'FILE_ID           ';
      ln_fileid                = 'FILEID            ';
      ln_filestate             = 'FILESTATE         ';
      ln_first_trans           = 'FIRST_TRANS       ';
      ln_first_trans_used      = 'FIRST_TRANS_USED  ';
      ln_free                  = 'BYTES_IN_FREELIST ';
      ln_free_cnt              = 'FREE_CNT          ';
      ln_free_max              = 'FREE_MAX          ';
      ln_free_min              = 'FREE_MIN          ';
      ln_free_sum              = 'FREE_SUM          ';
      ln_grantee               = 'GRANTEE           ';
      ln_granteeowner          = 'GRANTEEOWNER      ';
      ln_groupname             = 'GROUPNAME         ';
      ln_iid                   = 'IID               ';
      ln_increment             = 'INCREMENT_BY      ';
      ln_insert                = 'INSERT            ';
      ln_intern                = 'INTERN            ';
      ln_in_out                = 'IN/OUT-TYPE       ';
      ln_init_usage_date       = 'INIT_USAGE_DATE   ';
      ln_init_usage_time       = 'INIT_USAGE_TIME   ';
      ln_isolevel              = 'ISOLEVEL          ';
      ln_kb                    = 'HEAPSIZE (BYTES)  ';
      ln_kernel                = 'KERNEL            ';
      ln_keycolumnno           = 'KEYCOLUMNNO       ';
      ln_key_in_version        = 'DEREFKEYIN_VERSION';
      ln_key_part_count        = 'KEY_PARTITIONCOUNT';  (* PTS 1115641 F.F. *)
      ln_key_root              = 'KEY_ROOT          ';  (* PTS 1115641 F.F. *)
      ln_key_seq               = 'KEY_SEQ           ';
      ln_language              = 'LANGUAGE          ';
      ln_last_number           = 'LAST_NUMBER       ';
      ln_last_trans            = 'LAST_TRANS        ';
      ln_last_trans_used       = 'LAST_TRANS_USED   ';
      ln_last_used             = 'LAST_USED         ';
      ln_last_write            = 'LAST_WRITE        ';
      ln_level0                = 'CALL_STACK_LVL_0  ';
      ln_level1                = 'CALL_STACK_LVL_1  ';
      ln_level2                = 'CALL_STACK_LVL_2  ';
      ln_level3                = 'CALL_STACK_LVL_3  ';
      ln_level4                = 'CALL_STACK_LVL_4  ';
      ln_level5                = 'CALL_STACK_LVL_5  ';
      ln_level6                = 'CALL_STACK_LVL_6  ';
      ln_level7                = 'CALL_STACK_LVL_7  ';
      ln_level8                = 'CALL_STACK_LVL_8  ';
      ln_level9                = 'CALL_STACK_LVL_9  ';
      ln_loadvarobj            = 'LOAD_VAR_OBJ      ';
      ln_log_hops              = 'LC_LOG_HOPS       ';
      ln_log_hops_iter         = 'LC_LOG_HOPS_ITER  '; (* PTS 1107819 T.A 2000-09-13 *)
      ln_lock                  = 'LC_LOCK           ';
      ln_lock_handle           = 'LOCK_HANDLE       '; (* PTS 1110315 *)
      ln_lock_mode             = 'LOCK_MODE         ';
      ln_lock_state            = 'LOCK_STATE        ';
      ln_lock_timeout          = 'LOCK_TIMEOUT      ';
      ln_log_not_saved         = 'LOG_NOT_SAVED     ';
      ln_log_pages             = 'LOG_PAGES         ';
      ln_log_since_bup         = 'LOG_SINCE_BACKUP  ';
      ln_log_segment_size      = 'LOG_SEGMENT_SIZE  ';
      ln_max_chains            = 'MAX_CHAINS        ';  (* PTS 1115641 F.F. *)
      ln_max_obj_body_size     = 'MAX_OBJBODYSIZE   ';  (* PTS 1115641 F.F. *)
      ln_max_obj_per_page      = 'MAX_OBJPERPAGE    ';  (* PTS 1115641 F.F. *)
      ln_max_used_pages        = 'MAX_USED_PAGES    ';  (* PTS 1113689/1121965 *)
      ln_max_strbuf_read       = 'MAX_STRBUF_READ   ';
      ln_max_strbuf_write      = 'MAX_STRBUF_WRITTEN';
      ln_max_strrow_read       = 'MAX_STRROW_READ   ';
      ln_max_strrow_write      = 'MAX_STRROW_WRITTEN';
      ln_malloc_cnt            = 'MALLOC_CNT        ';
      ln_malloc_max            = 'MALLOC_MAX        ';
      ln_malloc_min            = 'MALLOC_MIN        ';
      ln_malloc_sum            = 'MALLOC_SUM        ';
      ln_mallocated            = 'USED_BY_OMS_MALLOC';
      ln_mapsetname            = 'MAPCHARSETNAME    ';
      ln_map_char              = 'MAP CHARACTER     ';
      ln_map_code              = 'MAP CODE          ';
      ln_marked                = 'MARKED            '; (* JA 1998-11-13 *)
      ln_max_pno               = 'MAX_DATA_PAGE_NO  ';
      ln_max_perm              = 'MAX_PERM_PAGES    ';
      ln_max_subtrans_lvl      = 'MAX_SUBTRANS_LEVEL';
      ln_max_value             = 'MAX_VALUE         ';
      ln_method                = 'METHODNAME        ';
      ln_min_strbuf_read       = 'MIN_STRBUF_READ   ';
      ln_min_strbuf_write      = 'MIN_STRBUF_WRITTEN';
      ln_min_strrow_read       = 'MIN_STRROW_READ   ';
      ln_min_strrow_write      = 'MIN_STRROW_WRITTEN';
      ln_min_value             = 'MIN_VALUE         ';
      ln_name                  = 'NAME              ';
      ln_name1                 = 'NAME1             ';
      ln_name2                 = 'NAME2             ';
      ln_new_old               = 'NEW/OLD_TYPE      ';
      ln_new_cons_view_avg     = 'NEWCONSVIEWAVGWAIT';
      ln_new_cons_view_max     = 'NEWCONSVIEWMAXWAIT';
      ln_new_cons_view_min     = 'NEWCONSVIEWMINWAIT';
      ln_no                    = 'NO                ';
      ln_nullable              = 'NULLABLE          ';
      ln_num_key_part          = 'KEY_PARTITION     ';  (* PTS 1115641 F.F. *)
      ln_num_value             = 'NUMERIC_VALUE     ';
      ln_objectcount           = 'OBJECTCOUNT       ';  (* PTS 1115641 F.F. *)
      ln_objectid              = 'OBJECTID          ';
      ln_objectname            = 'OBJECTNAME        ';
      ln_objecttype            = 'OBJECTTYPE        ';
      ln_offset                = 'OFFSET            ';
      ln_oms_avgHashChain      = 'OMS_AVG_HASH_CHAIN'; (* PTS 1133314 *)
      ln_oms_max_chain_len     = 'OMS_MAX_CHAIN_LEN '; (* PTS 1118855 *)
      ln_oms_read_cache_hit    = 'OMS_KEY_CACHE_HIT '; (* PTS 1117571 *)
      ln_oms_read_cache_miss   = 'OMS_KEY_CACHE_MISS'; (* PTS 1117571 *)
      ln_oms_read_version      = 'OMS_KEY_VERSION   '; (* PTS 1117571 *)
      ln_oms_rehash            = 'OMS_REHASH        '; (* PTS 1118855 *)
      ln_oms_log_pages         = 'OMS_LOG_USED      ';
      ln_oms_log_min_free      = 'OMS_LOG_MIN_FREE  ';
      ln_omsRelease            = 'OMS_RELEASE       '; (* PTS 1133314 *)
      ln_omsReleaseDone        = 'OMS_RELEASE_DONE  '; (* PTS 1133314 *)
      ln_oms_terminate         = 'OMS_TERMINATE     ';
      ln_open                  = 'OPEN              ';
      ln_open_date             = 'OPEN_DATE         ';
      ln_open_time             = 'OPEN_TIME         ';
      ln_open_trans            = 'OPEN_TRANS        ';
      ln_open_version          = 'OPEN_VERSION      ';
      ln_out_of_date           = 'OUT_OF_DATE       ';
      ln_owner                 = 'OWNER             ';
      ln_ownerid               = 'OWNERID           ';
      ln_owner_owner           = 'OWNER_OWNER       ';
      ln_order_flag            = 'ORDER_FLAG        ';
      ln_package               = 'PACKAGE           ';
      ln_pagecount             = 'PAGECOUNT         ';
      ln_param_no              = 'PARAM_NO          ';
      ln_parameter             = 'PARAMETER         ';
      ln_parametername         = 'PARAMETERNAME     ';
      ln_parameter1            = 'PARAM1            ';
      ln_parameter2            = 'PARAM2            ';
      ln_parameter3            = 'PARAM3            ';
      ln_parameter4            = 'PARAM4            ';
      ln_parameter5            = 'PARAM5            ';
      ln_parseid               = 'PARSEID           ';
      ln_partner               = 'PARTNER SERVERDB  ';
      ln_pct_log_not_saved     = 'PCT_LOG_NOT_SAVED ';
      ln_pct_unused            = 'PCT_PAGES_UNUSED  ';
      ln_pct_used_log          = 'PCT_LOGUSED       ';
      ln_pct_used_perm         = 'PCT_PERM_USED     ';
      ln_pct_used_temp         = 'PCT_TEMP_USED     ';
      ln_physicalcolno         = 'PHYSICAL_COLUMNNO ';
      ln_permpages             = 'PERMCOUNT         ';
      ln_precision             = 'PRECISION         ';
      ln_process               = 'PROCESS           ';
      ln_prog_id               = 'PROG_ID           ';
      ln_property              = 'PROPERTY          ';
      ln_public                = 'PUBLIC            ';
      ln_pwcreatedate          = 'PWCREATEDATE      ';
      ln_pwcreatetime          = 'PWCREATETIME      ';
      ln_radix                 = 'RADIX             ';
      ln_read_in_version       = 'DEREF_IN_VERSION  ';
      ln_read_only             = 'READONLY          ';
      ln_refcolumnname         = 'REFCOLUMNNAME     ';
      ln_refname               = 'REFNAME           ';
      ln_reftablen             = 'REFTABLENAME      ';
      ln_refowner              = 'REFOWNER          ';
      ln_refkind               = 'REFKIND           ';
      ln_refschemaname         = 'REFSCHEMANAME     ';
      ln_release_empty_pages   = 'RELEASEEMPTYPAGES ';  (* PTS 1115641 F.F. *)
      ln_relHistCreateObjFile  = 'HIST_CREATE_FILE  ';
      ln_relHistDeleteObj      = 'HIST_DELETE_OBJ   ';
      ln_relHistDropObjFile    = 'HIST_DROP_FILE    ';
      ln_relHistEntryNormal    = 'RELHIST_NORMAL    ';
      ln_relHistEntrySensitive = 'RELHIST_SENSITIVE ';
      ln_relHistEntryTrunc     = 'RELHIST_TRUNCATE  ';
      ln_relHistLockObj        = 'HIST_LOCK_OBJ     ';
      ln_relHistInsertObj      = 'HIST_INSERT_OBJ   ';
      ln_relHistNewObj         = 'HIST_NEW_OBJ      ';
      ln_relHistUpdateObj      = 'HIST_UPDATE_OBJ   ';
      ln_relPageEmpty          = 'RELPAGE_EMPTY     ';
      ln_relPageDrop           = 'RELPAGE_DROPFILE  ';
      ln_remote_loc            = 'REMOTE_LOCATION   ';
      ln_replication           = 'REPLICATION       ';
      ln_req_mode              = 'REQ_MODE          ';
      ln_req_state             = 'REQ_STATE         ';
      ln_req_timeout           = 'REQ_TIMEOUT       ';
      ln_reserved              = 'RESERVED          ';
      ln_role                  = 'ROLE              ';
      ln_roleid                = 'ROLEID            ';
      ln_root                  = 'ROOT              ';
      ln_rows                  = 'ROWS              ';
      ln_rowid                 = 'ROWID             ';
      ln_rowid_hex             = 'ROWID_HEX         ';
      ln_rowid_len             = 'ROWID_LENGTH      ';
      ln_rte                   = 'RUNTIMEENVIRONMENT';
      ln_rule                  = 'RULE              ';
      ln_runtime               = 'RUNTIME           ';
      ln_runtime_max           = 'RUNTIME_MAX       ';
      ln_runtime_min           = 'RUNTIME_MIN       ';
      ln_sample_percent        = 'SAMPLE_PERCENT    ';
      ln_sample_rows           = 'SAMPLE_ROWS       ';
      ln_savepoints            = 'SAVEPOINTS        ';
      ln_schemaname            = 'SCHEMANAME        ';
      ln_schemahandle          = 'SCHEMAHANDLE      '; (* PTS 1113287 *)
      ln_sequence_name         = 'SEQUENCE_NAME     ';
      ln_serverdb              = 'SERVERDB          ';
      ln_serverdb_full         = 'SERVERDB_FULL     ';
      ln_servernode            = 'SERVERNODE        ';
      ln_session               = 'SESSION           ';
      ln_session_roles         = 'SESSION_ROLES     ';
      ln_shortcol_pages        = 'SHORT_COLUMN_PAGES'; (* h.b. PTS 1107061 *)
      ln_size                  = 'SIZE              ';
      ln_sqlmode               = 'SQLMODE           ';
      ln_sql_support           = 'SQL_SUPPORT       ';
      ln_store                 = 'OMS_STORE         ';
      ln_store_lc              = 'LC_STORE          ';
      ln_storevarobj           = 'STORE_VAR_OBJ     ';
      ln_subroot               = 'SUBROOT           ';  (* PTS 1115641 F.F. *)
      ln_sub_commit            = 'SUBTRANS_COMMIT   ';
      ln_sub_rollback          = 'SUBTRANS_ROLLBACK ';
      ln_sub_trans             = 'SUB_TRANS         '; (* PTS 1108234 JA 2001-01-19 *)
      ln_store_in_version      = 'STORE_IN_VERSION  ';
      ln_strat                 = 'STRATEGY          ';
      ln_synowner              = 'SYNONYMOWNER      ';
      ln_sysinfokey            = 'SYSINFOKEY        ';
      ln_system                = 'SYSTEM            ';
      ln_tabletype             = 'TABLETYPE         ';
      ln_tabid                 = 'TABLEID           ';
      ln_taskid                = 'TASKID            ';
      ln_temppages             = 'TEMPCOUNT         ';
      ln_termid                = 'TERMID            ';
      ln_timeout               = 'TIMEOUT           ';
      ln_out_of_memory         = 'OUT_OF_MEMORY     ';
      ln_timeout_upb           = 'MAXTIMEOUT        ';
      ln_transid               = 'TRANSCOUNT        ';
      ln_transstate            = 'TRANSSTATE        ';
      ln_trans_version         = 'TRANSVERSION      ';
      ln_trigger               = 'TRIGGERNAME       ';
      ln_type_uid              = 'TYPE_UID          ';
      ln_unloaded              = 'UNLOADED          ';
      ln_unicode_offset        = 'UNICODE_OFFSET    ';
      ln_unused                = 'UNUSED_PAGES      ';
      ln_unused_byte_per_page  = 'UNUSED_BYTEPERPAGE'; (* PTS 1118335 FF *)
      ln_update                = 'UPDATE            ';
      ln_updated               = 'UPDATED_PERM_PAGES';
      ln_upddate               = 'UPDSTATDATE       ';
      ln_updtime               = 'UPDSTATTIME       ';
      ln_used                  = 'INDEX_USED        ';
      ln_used_blocks           = 'USED_BLOCKS       ';
      ln_used_log_pages        = 'USED_LOG_PAGES    ';
      ln_used_perm             = 'USED_PERM_PAGES   ';
      ln_used_temp             = 'USED_TEMP_PAGES   ';
      ln_user_cache            = 'CATALOG_CACHE_SIZE';
      ln_usermode              = 'USERMODE          ';
      ln_user_id               = 'USER_ID           ';
      ln_variable              = 'VARIABLE          ';
      ln_version_id            = 'OMS_VERSION_ID    ';
      ln_version_desc          = 'VERSION_DESC      '; (* PTS 1117690 *)
      ln_waitForChckpt         = 'WAIT_FOR_CHKPT    ';
      ln_wait_for_lockobj      = 'LOCKOBJ_WAITS     ';
      ln_withCheckOption       = 'WITH_CHECK_OPTION ';
      ln_write_trans           = 'WRITE_TRANS       '; (* PTS 1108234 JA 2001-01-19 *)
      ln_spinlock_name         = 'SPINLOCK_NAME     '; (* PTS 1109404 E.Z. *)
      ln_locks                 = 'LOCKS             '; (* PTS 1109404 E.Z. *)
      ln_total_spin_loops      = 'TOTAL_SPIN_LOOPS  '; (* PTS 1109404 E.Z. *)
      ln_total_yield_loops     = 'TOTAL_YIELD_LOOPS '; (* PTS 1109404 E.Z. *)
      ln_max_spin_loops        = 'MAX_SPIN_LOOPS    '; (* PTS 1109404 E.Z. *)
      ln_max_yield_loops       = 'MAX_YIELD_LOOPS   '; (* PTS 1109404 E.Z. *)
      ln_current_loops         = 'CURRENT_LOOPS     '; (* PTS 1109404 E.Z. *)
      ln_var_container         = 'VAROBJ_CONTAINER  '; (* PTS 1115641 F.F. *)
      ln_variable_columns      = 'VARIABLE_COLUMNS  '; (* PTS 1126711 E.Z. *)
      (*------------------ ctrl_configuration + dbm_state ------------------------*)
      ln_default_code          = 'DEFAULTCODE       ';
      ln_time_format           = 'DATETIMEFORMAT    ';
      ln_logmode               = 'LOGMODE           ';
      ln_mirrored_volumes      = 'MIRROREDVOLUMES   ';
      ln_database_full         = 'DATABASEFULL      ';
      (* PTS 1112568 E.Z. *)
      ln_log_full              = 'LOGFULL           ';
      ln_connect_possible      = 'CONNECTPOSSIBLE   ';
      ln_diagnose_monitor      = 'DIAGMONITOR       ';
      ln_monitor               = 'MONITOR           ';
      ln_knltrace              = 'KNLTRACE          ';
      ln_autosave_standby      = 'AUTOSAVESTANDBY   ';
      ln_autosave_media        = 'AUTOSAVEMEDIA     '; (* PTS 1000211, T.A. 1999-07-12 *)
      ln_checkpoint_wanted     = 'CHECKPOINTWANTED  ';
      ln_max_users             = 'MAXUSERS          ';
      ln_max_cpu               = 'MAXCPU            ';
      ln_no_of_log_volumes     = 'LOGVOLUMES        ';
      ln_no_of_data_volumes    = 'DATAVOLUMES       ';
      ln_no_of_bad_indexes     = 'BADINDEXES        ';
      ln_no_of_bad_volumes     = 'BADVOLUMES        ';
      ln_converter_cache_size  = 'CONVERTERCACHESIZE';
      ln_data_cache_size       = 'DATACACHESIZE     ';
      ln_data_oms_hitrate      = 'DATA_OMS_HITRATE  ';
      ln_log_oms_hitrate       = 'LOG_OMS_HITRATE   ';
      ln_log_queue_size        = 'LOGI/OQUEUESIZE   ';
      ln_pagesize_in_kb        = 'PAGESIZE_IN_KB    ';
      ln_active_sessions       = 'ACTIVE_SESSIONS   ';
      ln_datacache_hitrate     = 'DATACACHE_HITRATE ';
      (*------------------- ctrl_volumes ---------------------------*)
      ln_locklist_size         = 'MAXLOCKS          ';
      ln_volume_kind           = 'VOLUMEKIND        ';
      ln_volume_no             = 'VOLUMENO          ';
      ln_volume_name           = 'VOLUMENAME        ';
      ln_volume_size           = 'VOLUMESIZE        ';
      ln_volume_state          = 'VOLUMESTATE       ';
      (*------------------- ctrl_io_statistics -----------------------*)
      ln_object_name           = 'OBJECTNAME        ';
      ln_logical_io_read       = 'LOGICAL READ      ';
      ln_logical_io_write      = 'LOGICAL WRITE     ';
      ln_physical_io_read      = 'PHYSICAL READ     ';
      ln_physical_io_write     = 'PHYSICAL WRITE    ';
      (*------------------- ctrl_locks -------------------------------*)
      ln_max_entries        = 'MAXENTRIES        ';
      ln_avg_entries        = 'AVGENTRIES        ';
      ln_collisions         = 'COLLISIONS        ';
      ln_escalations        = 'ESCALATIONS       ';
      ln_row_locks          = 'ROWLOCKS          ';
      ln_table_entries      = 'TABLELOCKS        ';
      (*------------------- ctrl_log_statistics ----------------------*)
      ln_save_segm_size     = 'SAVE_SEGM_SIZE    ';
      ln_used_size          = 'USED_SIZE         ';
      ln_used_percent       = 'USED_SIZE_PERCENT ';
      ln_not_saved_size     = 'NOT_SAVED_SIZE    ';
      ln_not_saved_percent  = 'NOT_SAVED_PERCENT ';
      ln_last_data_backup   = 'LAST_DATA_BACKUP  ';
      ln_segm_completed     = 'SEGMENTS_COMPLETED';
      ln_physical_reads     = 'PHYSICAL_READS    ';
      ln_physical_writes    = 'PHYSICAL_WRITES   ';
      ln_queue_size         = 'QUEUE_SIZE        ';
      ln_queue_allocated    = 'QUEUE_ALLOCATED   ';
      ln_queue_entries      = 'QUEUE_ENTRIES     ';
      ln_queue_overflows    = 'QUEUE_OVERFLOWS   ';
      ln_group_commits      = 'GROUP_COMMITS     ';
      ln_wait_for_logwriter = 'WAIT_FOR_LOGWRITER';
      ln_max_waits          = 'MAX_WAITS         ';
      ln_avg_waits          = 'AVG_WAITS         ';
      ln_oms_log_used       = 'OMS_LOG_USED_PAGES';
      (*------------------- ctrl_cache_statistics ---------------------*)
      ln_cache_kind         = 'CACHE_KIND        ';
      ln_accesses           = 'ACCESSES          ';
      ln_accesses_succ      = 'ACCESSES_SUCCESS  ';
      ln_accesses_miss      = 'ACCESSES_UNSUCCESS';
      ln_hit_rate           = 'HIT_RATE_PERCENT  ';
      (* PTS 1114549 E.Z. *)
      ln_sysmon_taskindex          = 'TASKINDEX         ';
      ln_sysmon_uktid              = 'UKTID             ';
      ln_sysmon_applpid            = 'APPLPID           ';
      ln_sysmon_peerpid            = 'PEERPID           ';
      ln_sysmon_connectstate       = 'CONNECTSTATE      ';
      ln_sysmon_connecttime        = 'CONNECTTIME       ';
      ln_sysmon_remoteapplnode     = 'REMOTEAPPLNODE    ';
      (* PTS 1105189 E.Z. *)
      (* PTS 1111217 E.Z. names with 'TOT' in it *)
      (*------------------------ sysmon -------------------------------*)
      ln_sysmon_accesses           = 'ACCESSES          ';
      ln_sysmon_appid              = 'APPID             ';
      ln_sysmon_avgcmdexecutetime  = 'AVGCMDEXECUTETIME ';
      ln_sysmon_totcmdexecutetime  = 'TOTCMDEXECUTETIME ';
      ln_sysmon_avgcmdwaitreltime  = 'AVGCMDWAITRELTIME ';
      ln_sysmon_avgcmdwaitabstime  = 'AVGCMDWAITABSTIME ';
      ln_sysmon_totcmdwaitabstime  = 'TOTCMDWAITABSTIME ';
      ln_sysmon_totcmdwaitreltime  = 'TOTCMDWAITRELTIME ';
      ln_sysmon_backuppages        = 'BACKUPPAGES       ';
      ln_sysmon_backupreads        = 'BACKUPREADS       ';
      ln_sysmon_backupwrites       = 'BACKUPWRITES      ';
      ln_sysmon_bkpreadavgabstime  = 'BKPREADAVGABSTIME ';
      ln_sysmon_bkpreadavgreltime  = 'BKPREADAVGRELTIME ';
      ln_sysmon_bkpreadcnt         = 'BKPREADCNT        ';
      ln_sysmon_bkpreadpages       = 'BKPREADPAGES      ';
      ln_sysmon_bkpreadtotabstime  = 'BKPREADTOTABSTIME ';
      ln_sysmon_bkpreadtotreltime  = 'BKPREADTOTRELTIME ';
      ln_sysmon_bkpwriteavgabstime = 'BKPWRITEAVGABSTIME';
      ln_sysmon_bkpwriteavgreltime = 'BKPWRITEAVGRELTIME';
      ln_sysmon_bkpwritecnt        = 'BKPWRITECNT       ';
      ln_sysmon_bkpwritepages      = 'BKPWRITEPAGES     ';
      ln_sysmon_bkpwritetotabstime = 'BKPWRITETOTABSTIME';
      ln_sysmon_bkpwritetotreltime = 'BKPWRITETOTRELTIME';
      ln_sysmon_cancel_flag        = 'CANCEL_FLAG       ';
      ln_sysmon_cmdcnt             = 'CMDCNT            ';
      ln_sysmon_collision_rate     = 'COLLISION_RATE    ';
      ln_sysmon_collisions         = 'COLLISIONS        ';
      ln_sysmon_commandcnt         = 'COMMANDCNT        ';
      ln_sysmon_dbpid              = 'DBPID             ';
      ln_sysmon_desc               = 'DESC              ';
      ln_sysmon_deviceid           = 'DEVICEID          ';
      ln_sysmon_devicename         = 'DEVICENAME        ';
      ln_sysmon_dispatchcnt        = 'DISPATCHCNT       ';
      ln_sysmon_extendedtaskstate  = 'EXTENDEDTASKSTATE ';
      ln_sysmon_idlecount          = 'IDLECOUNT         ';
      ln_sysmon_iocnt              = 'IOCNT             ';
      ln_sysmon_ioreadavgabstime   = 'IOREADAVGABSTIME  ';
      ln_sysmon_ioreadavgreltime   = 'IOREADAVGRELTIME  ';
      ln_sysmon_ioreadcnt          = 'IOREADCNT         ';
      ln_sysmon_ioreadpages        = 'IOREADPAGES       ';
      ln_sysmon_ioreadtotabstime   = 'IOREADTOTABSTIME  ';
      ln_sysmon_ioreadtotreltime   = 'IOREADTOTRELTIME  ';
      ln_sysmon_iowriteavgabstime  = 'IOWRITEAVGABSTIME ';
      ln_sysmon_iowriteavgreltime  = 'IOWRITEAVGRELTIME ';
      ln_sysmon_iowritecnt         = 'IOWRITECNT        ';
      ln_sysmon_iowritepages       = 'IOWRITEPAGES      ';
      ln_sysmon_iowritetotabstime  = 'IOWRITETOTABSTIME ';
      ln_sysmon_iowritetotreltime  = 'IOWRITETOTRELTIME ';
      ln_sysmon_locked             = 'LOCKED            ';
      (* PTS 1115172 E.Z. *)
      ln_sysmon_lockedpageno       = 'LOCKEDPAGENO      ';
      (* PTS 1110956 E.Z. *)
      ln_sysmon_omscomroutinename  = 'OMSCOMROUTINENAME ';
      (* PTS 1111217 E.Z. *)
      ln_sysmon_omscallactive      = 'OMSCALLACTIVE     ';
      ln_sysmon_omscallbackcount   = 'OMSCALLBACKCOUNT  ';
      ln_sysmon_omscallbackmethod  = 'OMSCALLBACKMETHOD ';
      ln_sysmon_ospid              = 'OSPID             ';
      ln_sysmon_ownerdbpid         = 'OWNERDBPID        ';
      ln_sysmon_priocnt            = 'PRIOCNT           ';
      ln_sysmon_queuelen           = 'QUEUELEN          ';
      ln_sysmon_queuemax           = 'QUEUEMAX          ';
      ln_sysmon_reads              = 'READS             ';
      ln_sysmon_readpages          = 'READPAGES         ';
      ln_sysmon_regid              = 'REGID             ';
      ln_sysmon_regionaccesscnt    = 'REGIONACCESSCNT   ';
      ln_sysmon_regioncollcnt      = 'REGIONCOLLCNT     ';
      ln_sysmon_regionname         = 'REGIONNAME        ';
      ln_sysmon_regionwaitcnt      = 'REGIONWAITCNT     ';
      ln_sysmon_reqstdbpid         = 'REQSTDBPID        ';
      ln_sysmon_sioreadavgabstime  = 'SIOREADAVGABSTIME ';
      ln_sysmon_sioreadcnt         = 'SIOREADCNT        ';
      ln_sysmon_sioreadpages       = 'SIOREADPAGES      ';
      ln_sysmon_sioreadtotabstime  = 'SIOREADTOTABSTIME ';
      ln_sysmon_siowriteavgabstime = 'SIOWRITEAVGABSTIME';
      ln_sysmon_siowritecnt        = 'SIOWRITECNT       ';
      ln_sysmon_siowritepages      = 'SIOWRITEPAGES     ';
      ln_sysmon_siowritetotabstime = 'SIOWRITETOTABSTIME';
      ln_sysmon_special_flag       = 'SPECIAL_FLAG      ';
      ln_sysmon_statedesc          = 'STATEDESC         ';
      ln_sysmon_symbolresolvecnt   = 'SYMBOLRESOLVECNT  ';
      ln_sysmon_taskcluster        = 'TASKCLUSTER       ';
      ln_sysmon_taskiocnt          = 'TASKIOCNT         ';
      ln_sysmon_taskname           = 'TASKNAME          ';
      ln_sysmon_tasks_active       = 'TASKS_ACTIVE      ';
      ln_sysmon_tasks_total        = 'TASKS_TOTAL       ';
      ln_sysmon_taskselfsuspcnt    = 'TASKSELFSUSPCNT   ';
      ln_sysmon_taskswitchcnt      = 'TASKSWITCHCNT     ';
      ln_sysmon_tasktype           = 'TASKTYPE          ';
      ln_sysmon_test_and_set       = 'TEST_AND_SET      ';
      ln_sysmon_threadname         = 'THREADNAME        ';
      ln_sysmon_threadstate        = 'THREADSTATE       ';
      ln_sysmon_timeout            = 'TIMEOUT           ';
      ln_sysmon_usedrunqueuelength = 'USEDRUNQUEUELENGTH';
      ln_sysmon_usertaskreadcnt    = 'USERTASKREADCNT   ';
      ln_sysmon_usertaskwritecnt   = 'USERTASKWRITECNT  ';
      ln_sysmon_val                = 'VAL               ';
      ln_sysmon_vbegexcltascollcnt = 'VBEGEXCLTASCOLLCNT';
      ln_sysmon_vdesc              = 'VDESC             ';
      ln_sysmon_vendexcltascollcnt = 'VENDEXCLTASCOLLCNT';
      ln_sysmon_volumeid           = 'VOLUMEID          ';
      ln_sysmon_volumename         = 'VOLUMENAME        ';
      ln_sysmon_vrcvreplavgabstime = 'VRCVREPLAVGABSTIME';
      ln_sysmon_vrcvreplavgreltime = 'VRCVREPLAVGRELTIME';
      ln_sysmon_vrcvreplcnt        = 'VRCVREPLCNT       ';
      ln_sysmon_vreplrcvavgabstime = 'VREPLRCVAVGABSTIME';
      ln_sysmon_vreplrcvavgreltime = 'VREPLRCVAVGRELTIME';
      ln_sysmon_vreplrcvcnt        = 'VREPLRCVCNT       ';
      ln_sysmon_vsleepavgabstime   = 'VSLEEPAVGABSTIME  ';
      ln_sysmon_vsleepavgreltime   = 'VSLEEPAVGRELTIME  ';
      ln_sysmon_vsleepcnt          = 'VSLEEPCNT         ';
      ln_sysmon_vsleeptotabstime   = 'VSLEEPTOTABSTIME  ';
      ln_sysmon_vsleeptotreltime   = 'VSLEEPTOTRELTIME  ';
      ln_sysmon_vsuspendavgabstime = 'VSUSPENDAVGABSTIME';
      ln_sysmon_vsuspendavgreltime = 'VSUSPENDAVGRELTIME';
      ln_sysmon_vsuspendcnt        = 'VSUSPENDCNT       ';
      ln_sysmon_vsuspendtotabstime = 'VSUSPENDTOTABSTIME';
      ln_sysmon_vsuspendtotreltime = 'VSUSPENDTOTRELTIME';
      ln_sysmon_vwaitavgabstime    = 'VWAITAVGABSTIME   ';
      ln_sysmon_vwaitavgreltime    = 'VWAITAVGRELTIME   ';
      ln_sysmon_vwaitcnt           = 'VWAITCNT          ';
      ln_sysmon_vwaittotabstime    = 'VWAITTOTABSTIME   ';
      ln_sysmon_vwaittotreltime    = 'VWAITTOTRELTIME   ';
      ln_sysmon_waiting4root       = 'WAITING4ROOT      ';
      ln_sysmon_waiting4task       = 'WAITING4TASK      ';
      ln_sysmon_waits              = 'WAITS             ';
      ln_sysmon_writes             = 'WRITES            ';
      ln_sysmon_writepages         = 'WRITEPAGES        ';
      (* END PTS 1105189 E.Z. *)
 
TYPE
      tak40_role_arr = ARRAY[1..csp_maxint2] OF tgg00_Surrogate;
 
      tak40_role_info = RECORD
            rl_max  : integer;
            rl_ids  : tak40_role_arr;
      END;
 
      tak40_role_info_ptr = ^tak40_role_info;
 
      tak40_LongColIdentifier = RECORD
            CASE boolean OF
                true :
                    (lci_fileId : tsp00_Int4;
                    lci_rowId  : tsp00_Int4);
                false :
                    (lci_surrogate : tgg00_Surrogate);
                END;
            (*ENDCASE*) 
 
 
 
(*------------------------------*) 
 
PROCEDURE
      a40get_catalog_table (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      dup_col      : boolean;
      newBaseRec   : boolean;
      producer     : tsp1_producer;
      b_err        : tgg00_BasisError;
      aux_err      : tgg00_BasisError;
      ix           : integer;
      count        : integer;
      colindex     : integer;
      colname      : tsp00_KnlIdentifier;
      sysk         : tgg00_SysInfoKey;
 
BEGIN
newBaseRec := false;
aux_err    := a41v.a4b_err;
a41v.a4b_err    := e_ok;
IF  acv.a_returncode = 0
THEN
    BEGIN
    sysk := a01sysnullkey;
    IF  a41v.a4systab_select
    THEN
        BEGIN
        sysk.stableid  := cgg_zero_id;
        sysk.ssite     := cak_show_table_site;
        sysk.sshowkind := a41v.a4sh_kind
        END
    ELSE
        sysk.stempid := a101_GetTempFileIndex (acv,
              acv.a_resname_addr[cak_extern_pos]^.sresname.restreeid);
    (*ENDIF*) 
    sysk.sentrytyp := cak_eresult;
    sysk.slinkage  := cak_init_linkage;
    IF  NOT a41v.a4systab_select
    THEN
        a10_key_del (acv, sysk);
    (* END PTS 1115043 U.J. *)
    (*ENDIF*) 
    END;
(* PTS 1106617 E.Z. *)
(*ENDIF*) 
a41v.a4del_basetab := true;
IF  acv.a_returncode = 0
THEN
    BEGIN
    a10_nil_get_sysinfo (acv, sysk, d_fix,
          sizeof (tak_baserecord), a41v.a4p_arr.pinfop, b_err);
    IF  b_err <> e_ok
    THEN
        BEGIN
        (* PTS 1106617 E.Z. *)
        IF  a41v.a4systab_select AND (b_err = e_duplicate_sysinfo)
        THEN
            a41v.a4del_basetab := NOT (a10is_fixed (acv, a41v.a4p_arr.pinfop))
        ELSE
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        newBaseRec := true;
        WITH a41v.a4p_arr.pinfop^, sresult, sbase DO
            BEGIN
            bfirstindex := a11firstindex (MAX_COL_PER_TAB_GG00, sbase);
            blastindex  := bfirstindex - 1;
            IF  a41v.a4systab_select
            THEN
                bauthid := cak_sys_user_id
            ELSE
                bauthid := acv.a_curr_user_id;
            (*ENDIF*) 
            bschema  := bauthid;
            producer := acv.a_initial_segment_header.sp1c_producer;
            IF  a41v.a4systab_select          AND
                ((producer = sp1pr_installation) OR
                ((acv.a_comp_type = at_load) AND
                ( producer = sp1pr_internal_cmd)))
                AND
                (acv.a_current_user_kind <> usysdba)
            THEN
                BEGIN
                bsegmentid   := cak00_public_segment_id;
                END
            ELSE
                BEGIN
                bsegmentid   := cak00_local_segment_id;
                END;
            (*ENDIF*) 
            a061add_name (acv, sbase, a41v.a4showfile_name, btablen);
            IF  acv.a_returncode = 0
            THEN
                BEGIN
                btablekind       := tresult;
                blinkexist       := [  ];
                bmaxcol          := 0;
                bmaxreclen       := 0;
                IF  a41v.a4systab_select
                THEN
                    BEGIN
                    btreeid                := b01niltree_id;
                    btreeid.fileTabId_gg00 := sysk.stableid
                    END
                ELSE
                    btreeid := acv.a_resname_addr[ cak_extern_pos ]^.
                          sresname.restreeid;
                (*ENDIF*) 
                bkeycolcount     := 1;
                blenfixedcol     := 0;
                bvarcolcount     := 0;
                bcntdropcol      := 0;
                bstringcount     := 0;
                a11put_date_time (bdatecreate, btimecreate);
                bupdstatdate     := bdatecreate;
                bupdstattime     := btimecreate;
                bunloaded        := false;
                bindexexist      := false;
                bavgrowlen       := bmaxreclen;
                bv_level         := 0;
                bv_tabcount      := 1;
                bv_tablekind     := tresult;
                bv_checkopt      := false;
                bv_qualexist     := false;
                bv_distinct      := no_distinct;
                bv_viewlist      := false;
                bdef_stamp       := false;
                brows            := 100;
                bpages           := 1;
                blongvarcolcnt   := 0;
                bview_attributes := [];
                bsqlmode         := acv.a_sqlmode;
                bnamed_constr    := 0;
                bcomment         := false;
                balterdate       := bdatecreate;
                baltertime       := btimecreate;
                brecreate_view   := false;
                battributes      := [];
                bcolumnSplitIdx  := csp_maxint2;
                END;
            (*ENDIF*) 
            IF  acv.a_returncode = 0
            THEN
                a061app_columnname (acv, sbase,
                      a01_i_tablekey, colindex);
            (*ENDIF*) 
            WITH a103GetColumn (sbase, colindex )^, ccolstack DO
                BEGIN
                cextcolno     := 1;
                creccolno     := cextcolno;
                ctabno        := 1;
                ccolpropset   := [ ctkey, ctinvisible ];
                cdatalen      := 3;
                cdatafrac     := cak_frac_offset;
                cinoutlen     := 4;
                cdatatyp      := dchb;
                cshiftoutchar := chr(ord(false));
                etype         := st_varkey;
                eop           := op_none;
                epos          := 1;
                elen_var      := 4;
                ecol_tab[ 1 ] := chr(0);
                ecol_tab[ 2 ] := chr(0);
                bmaxreclen    := 0;
                blenfixedcol  := 0
                END;
            (*ENDWITH*) 
            END;
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    IF  (acv.a_returncode = 0) AND (b_err = e_ok)
    THEN
        BEGIN
        a41v.a4index := 1;
        a41v.a4pos   := 1;
        (* PTS 1116801 E.Z. *)
        a41v.a4long_desc_len := mxsp_long_desc;
        a41v.a4acv_ptr := @acv;
        CASE a41v.a4sh_kind OF
            sh_bad_index :
                ak40p_bad_index (a41v);
            sh_monitor_oms :
                ak40p_monitor_oms (a41v);
            sh_connect :
                ak40p_connect (a41v);
            sh_connect_param :
                ak40p_connect_param (a41v);
            sh_consistent_view : (* PTS 1106007 *)
                ak40p_consistent_view (a41v);
            sh_constraint, sh_all_constraint, sh_domain_constraints :
                ak40p_constraint (a41v);
            sh_container_roots :
                ak40p_container_roots(a41v);    (* PTS 1115641 FF *)
            sh_container_chains :
                ak40p_container_chains(a41v);   (* PTS 1115641 FF *)
            sh_container_keys :
                ak40p_container_keys(a41v);     (* PTS 1115641 FF *)
            sh_cons_columns, sh_all_cons_columns :
                ak40p_cons_columns (a41v);
            sh_ctrl_configuration :
                ak40p_ctrl_configuration (a41v);
            sh_ctrl_log :
                ak40p_ctrl_log_statistics (a41v);
            (* sh_ctrl_cache :
                  ak40p_ctrl_cache_statistics (a41v); *)
            (* PTS 1120445 D.T. *)
            sh_ctrl_devspaces :
                ak40p_ctrl_devspaces (a41v);
            sh_files_old :
                ak40p_files_old (a41v);
            sh_info_gc_stats :
                ak40p_info_gc_stats(a41v);
            sh_ctrl_io_statistics :
                ak40p_ctrl_io_statistics (a41v);
            sh_ctrl_locks :
                ak40p_ctrl_locks (a41v);
            (* PTS 1115043 E.Z. *)
            sh_dbm_state :
                ak40p_dbm_state (a41v);
            sh_oms_lock :
                ak40p_oms_lock_info (a41v); (* PTS 1110315 *)
            sh_oms_memory :
                ak40p_oms_memory(a41v);
            sh_heap_content :
                ak40p_heap_content(a41v);
            sh_history_info :
                ak40p_history_info(a41v);
            sh_dbfunctions :
                ak40p_dbfunction (a41v);
            sh_dbfunc_parameters, sh_param_dbproc, sh_param_trigger :
                ak40p_dbproc_param (a41v);
            sh_table_stat :
                ak40p_optimize_stat (a41v);
            sh_column, sh_all_column :
                ak40p_column (a41v);
            sh_odbc_columns :
                ak40p_odbc_column (a41v);
            sh_methods :
                ak40p_methods (a41v);
            sh_link, sh_all_foreign_key :
                ak40p_link (a41v);
            sh_mapset :
                ak40p_mapset (a41v);
            sh_new_privileges, sh_all_new_privileges :
                ak40privileges (a41v);
            sh_sequence, sh_all_sequences :
                ak40p_sequence (a41v);
            sh_serverdb :
                ak40p_serverdb (a41v);
            sh_object, sh_all_object :
                ak40p_objects (a41v);
            sh_oms_versions :
                ak40p_oms_versions (a41v);
            sh_procedure, sh_all_procedures :
                ak40p_procedure (a41v);
            sh_st_database :
                ak40p_serverdb_statistics (a41v);
            sh_st_monitor :
                ak40p_monitor (a41v);
            sh_st_config, sh_st_state :
                ak40p_config (a41v);
            sh_st_index, sh_odbc_st_index, sh_indexpages :
                ak40p_index_stat (a41v);
            sh_st_table, sh_odbc_st_table,
            sh_pages :
                ak40p_table_stat (a41v);
            sh_domain_data :
                ak40domain_data (a41v);
            sh_explain :
                CASE acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_length OF
                    cak_i_join :
                        ak40p_join_explain (a41v);
                    cak_i_sequence :
                        ak40p_sequence_explain (a41v);
                    OTHERWISE
                        ak40p_explain (a41v);
                    END;
                (*ENDCASE*) 
            sh_schema :
                ak40p_schema(a41v);
            sh_st_lock :
                ak40p_lock_statistics (a41v);
            sh_st_user :
                ak40p_st_user (a41v);
            sh_table, sh_all_table :
                ak40p_table (a41v);
            sh_trans :
                ak40p_trans (a41v);
            sh_trigger, sh_all_triggers :
                ak40p_trigger (a41v);
            sh_userroles :
                ak40p_user_roles (a41v);
            sh_all_roles :
                ak40p_db_roles(a41v);
            sh_roots :
                ak40p_root (a41v);
            sh_priv_granted_to, sh_all_priv_granted :
                ak40priv_granted_to (a41v);
            sh_p_prog :
                ak40privileges (a41v);
            sh_show_view :
                ak40p_show_view (a41v);
            sh_session_roles :
                ak40p_session_roles (a41v);
            sh_synonym, sh_all_synonyms :
                ak40p_synonym (a41v);
            sh_version_old   :
                ak40p_version_old  (a41v);
            sh_lock :
                ak40p_lock  (a41v);
            sh_view, sh_all_views :
                ak40p_view  (a41v);
            sh_index, sh_all_index, sh_odbc_index (* PTS 1114119 T.A. *) :
                ak40p_index (a41v);
            (* PTS 1115043 E.Z. *)
            sh_ref_column, sh_all_ref_columns :
                ak40p_referenced_column (a41v);
            (* PTS 1109995 E.Z. *)
            sh_u_domain  :
                ak40_u_domain (a41v);
            sh_view_uses_table, sh_all_view_uses_table :
                ak40p_view_uses_table (a41v);
            sh_running_cmds :
                ak40p_user_tasks (a41v);
            (* PTS 1114549 E.Z. *)
            sh_sysmon_connection :
                ak40p_s_connection (a41v);
            (* PTS 1105189 E.Z. *)
            sh_sysmon_region :
                ak40p_s_region (a41v);
            sh_sysmon_storage :
                ak40p_s_storage (a41v);
            sh_sysmon_ioaccess :
                ak40p_s_ioaccess (a41v);
            sh_sysmon_backupioaccess :
                ak40p_s_backupioaccess (a41v);
            sh_sysmon_specthread :
                ak40p_s_spec_thread (a41v);
            sh_sysmon_ukthread :
                ak40p_s_ukthread (a41v);
            sh_sysmon_deviothread :
                ak40p_s_deviothread (a41v);
            sh_sysmon_task,
            sh_sysmon_active_task,
            sh_sysmon_runnable,
            sh_sysmon_us,
            sh_sysmon_us_active,
            sh_sysmon_us_runnable,
            sh_sysmon_sv,
            sh_sysmon_sv_active,
            sh_sysmon_sv_runnable,
            sh_sysmon_dw,
            sh_sysmon_dw_active,
            sh_sysmon_dw_runnable :
                ak40p_s_task (a41v);
            sh_sysmon_totalcount :
                ak40p_s_totalcount (a41v);
            sh_sysmon_task_detail :
                ak40p_s_task_detail (a41v);
            (* END PTS 1105189 E.Z. *)
            (* PTS 1106167 E.Z. *)
            sh_parsinfos :
                ak40p_parsinfos (a41v);
            (* PTS 1107717 E.Z. *)
            sh_internal_state :
                ak40p_internal_state (a41v);
            (* PTS 1109404 E.Z. *)
            sh_spinlock :
                ak40p_spinlocks (a41v);
            sh_variables :
                ak40p_variables (a41v);
            OTHERWISE:
                a400SVDefSysViewTable( acv, a41v ); (* PTS 1115043 *)
            END;
        (*ENDCASE*) 
        IF  a41v.a4b_err <> e_ok
        THEN
            a07_b_put_error (acv, a41v.a4b_err, 1);
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            WITH a41v.a4p_arr.pinfop^.sresult DO
                BEGIN
                a061sort (acv, a41v.a4p_arr.pinfop^.sbase, 0, dup_col, colname);
                IF  dup_col
                THEN
                    a07_nb_put_error (acv,
                          e_duplicate_name, 1, colname);
                (*ENDIF*) 
                boutcolno := bmaxcol;
                FOR ix := 1 TO bmaxcol DO
                    bextcolindex [ix] := cak_cdropped;
                (*ENDFOR*) 
                count := 0;
                FOR ix := bfirstindex TO blastindex DO
                    WITH a103GetColumn (a41v.a4p_arr.pinfop^.sbase, ix)^, ccolstack DO
                        BEGIN
                        bextcolindex[cextcolno] := count;
                        count := succ(count);
                        END;
                    (*ENDWITH*) 
                (*ENDFOR*) 
                a11sort (a41v.a4p_arr.pinfop^.sbase);
                IF  a41v.a4sh_kind = sh_explain
                THEN
                    BEGIN
                    a10add_sysinfo (acv, a41v.a4p_arr.pinfop, b_err);
&                   ifdef trace
                    WITH a41v.a4p_arr.pinfop^.sbase DO
                        FOR ix := bfirstindex TO blastindex DO
                            a061td_colinfo (a103GetColumn (a41v.a4p_arr.pinfop^.sbase, ix)^, ix);
                        (*ENDFOR*) 
                    (*ENDWITH*) 
&                   endif
                    IF  b_err <> e_ok
                    THEN
                        a07_b_put_error (acv, b_err, 1)
                    ELSE
                        BEGIN
                        acv.a_resname_addr[ cak_extern_pos ]^.sresname.
                              resmaxlinkage := 1;
                        acv.a_resname_addr[ cak_extern_pos ]^.sresname.
                              resinfobuf := 0
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (acv.a_returncode <> 0) AND newBaseRec AND false
    THEN
        a10_key_del (acv, sysk);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    ak40new_row (a41v);
(*ENDIF*) 
a41v.a4b_err := aux_err;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40glob_init;
 
BEGIN
a40sqlmode[sqlm_ansi]   := 'ANSI    ';
a40sqlmode[sqlm_db2 ]   := 'DB2     ';
a40sqlmode[sqlm_oracle] := 'ORACLE  ';
a40sqlmode[sqlm_internal] := 'INTERNAL';
a40yes_no[true]         := 'YES';
a40yes_no[false]        := 'NO ';
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40app_column (
            VAR a41v     : tak40_show_glob;
            VAR col_name : tsp00_C32;
            colname_size : integer;
            datatype     : tsp00_DataType;
            data_len     : integer;
            fraction     : integer (* PTS 1103569 *) );
 
VAR
      ix       : integer;
      jx       : integer;
      colindex : integer;
      colname  : tsp00_KnlIdentifier;
      pLastCol : tak00_colinfo_ptr;
 
BEGIN
IF  a41v.a4index + 1 > MAX_SHOW_COLUMNS_GG04
THEN
    a41v.a4b_err := e_system_error
ELSE
    BEGIN
    colname := a01_il_b_identifier;
    jx      := a01char_size;
    FOR ix := 1 TO colname_size DO
        BEGIN
        colname[jx] := col_name[ix];
        jx          := jx + a01char_size
        END;
    (*ENDFOR*) 
    a061app_columnname (a41v.a4acv_ptr^, a41v.a4p_arr.pinfop^.sbase, colname, colindex);
    WITH a41v.a4p_arr.pinfop^.sbase,
         a103GetColumn (a41v.a4p_arr.pinfop^.sbase, colindex)^ DO
        BEGIN
        ccolpropset := [ctopt];
        cextcolno   := a41v.a4index + 1;
        creccolno   := cextcolno;
        ctabno      := 1;
        cdatatyp    := datatype;
        cdatalen    := data_len;
        IF  datatype in [dfixed, dfloat]
        THEN
            cinoutlen := (data_len + 1) DIV 2 + 2
        ELSE
            IF  g01unicode
                AND (datatype in [dcha])
            THEN
                BEGIN
                cdatatyp  := dunicode;
                cinoutlen := data_len * 2 + 1
                END
            ELSE
                cinoutlen := data_len + 1;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  cdatatyp = dfloat
        THEN
            cdatafrac := 0
        ELSE
            cdatafrac := cak_frac_offset + fraction;
        (*ENDIF*) 
        cshiftoutchar   := chr(ord(false));
        WITH ccolstack DO
            BEGIN
            etype    := st_fixcol;
            eop      := op_none;
            IF  a41v.a4index = 1
            THEN
                epos := 1
            ELSE
                BEGIN
                pLastCol := a103GetColumn (a41v.a4p_arr.pinfop^.sbase, blastindex - 1);
                epos     := pLastCol^.ccolstack.epos +
                      pLastCol^.ccolstack.elen_var;
                END;
            (*ENDIF*) 
            elen_var := cinoutlen;
            ecol_tab := cgg_zero_c2
            END;
        (*ENDWITH*) 
        blenfixedcol := blenfixedcol + cinoutlen;
        a41v.a4index := a41v.a4index + 1;
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40AppVarCol (
            VAR a41v     : tak40_show_glob;
            VAR col_name : tsp00_C32;
            datatype     : tsp00_DataType;
            data_len     : integer;
            fraction     : integer (* PTS 1103569 *) );
 
VAR
      ix       : integer;
      jx       : integer;
      colindex : integer;
      colname  : tsp00_KnlIdentifier;
      pLastCol : tak00_colinfo_ptr;
 
BEGIN
IF  a41v.a4index + 1 > MAX_SHOW_COLUMNS_GG04
THEN
    a41v.a4b_err := e_system_error
ELSE
    BEGIN
    colname := a01_il_b_identifier;
    jx      := a01char_size;
    ix      := 1;
    (* col_name is a 0 terminated string, copy into pascal variable *)
    WHILE  (ix <= sizeof(tsp00_C32)) AND
          (col_name[ix] <> chr(0)) DO
        BEGIN
        colname[jx] := col_name[ix];
        ix          := ix + 1;
        jx          := jx + a01char_size
        END;
    (*ENDWHILE*) 
    a061app_columnname (a41v.a4acv_ptr^, a41v.a4p_arr.pinfop^.sbase, colname, colindex);
    WITH a41v.a4p_arr.pinfop^.sbase, a103GetColumn (a41v.a4p_arr.pinfop^.sbase, colindex)^ DO
        BEGIN
        ccolpropset := [ctopt];
        cextcolno   := a41v.a4index + 1;
        creccolno   := cextcolno;
        ctabno      := 1;
        IF  (NOT g01unicode) AND (datatype = dunicode)
        THEN
            cdatatyp := dcha
        ELSE
            cdatatyp := datatype;
        (*ENDIF*) 
        cdatalen    := data_len;
        IF  cdatatyp in [dfixed, dfloat]
        THEN
            cinoutlen := (data_len + 1) DIV 2 + 2
        ELSE
            IF  (cdatatyp = dunicode)
            THEN
                cinoutlen := data_len * 2 + 1
            ELSE
                cinoutlen := data_len + 1;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  cdatatyp = dfloat
        THEN
            cdatafrac := 0
        ELSE
            cdatafrac := cak_frac_offset + fraction;
        (*ENDIF*) 
        cshiftoutchar   := chr(ord(false));
        WITH ccolstack DO
            BEGIN
            etype    := st_fixcol;
            eop      := op_none;
            IF  a41v.a4index = 1
            THEN
                epos := 1
            ELSE
                BEGIN
                pLastCol := a103GetColumn (a41v.a4p_arr.pinfop^.sbase, blastindex - 1);
                epos     := pLastCol^.ccolstack.epos +
                      pLastCol^.ccolstack.elen_var;
                END;
            (*ENDIF*) 
            elen_var := cinoutlen;
            ecol_tab := cgg_zero_c2
            END;
        (*ENDWITH*) 
        blenfixedcol := blenfixedcol + cinoutlen;
        a41v.a4index := a41v.a4index + 1;
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40byte_info (
            VAR a41v : tak40_show_glob;
            col_name : tak_oldidentifier;
            len      : integer);
 
VAR
      c32_ptr : ^tsp00_C32;
 
BEGIN
c32_ptr := @col_name;
ak40app_column (a41v, c32_ptr^, sizeof (col_name), dchb, len, 0)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40char_info (
            VAR a41v : tak40_show_glob;
            col_name : tak_oldidentifier;
            len      : integer);
 
VAR
      c32_ptr : ^tsp00_C32;
 
BEGIN
c32_ptr := @col_name;
ak40app_column (a41v, c32_ptr^, sizeof (col_name), dcha, len, 0)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40comment_info (VAR a41v : tak40_show_glob);
 
BEGIN
ak40long_info (a41v, ln_comment)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40date_info (
            VAR a41v : tak40_show_glob;
            col_name : tak_oldidentifier);
 
VAR
      c32_ptr : ^tsp00_C32;
 
BEGIN
c32_ptr := @col_name;
ak40app_column (a41v, c32_ptr^, sizeof (col_name), ddate, mxsp_extdate, 0)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40fixed_info (
            VAR a41v  : tak40_show_glob;
            col_name  : tak_oldidentifier;
            precision : integer;
            fraction  : integer);
 
VAR
      c32_ptr : ^tsp00_C32;
 
BEGIN
c32_ptr := @col_name;
ak40app_column (a41v, c32_ptr^, sizeof(col_name), dfixed, precision, fraction)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40float_info (
            VAR a41v : tak40_show_glob;
            col_name : tak_oldidentifier);
 
VAR
      c32_ptr : ^tsp00_C32;
 
BEGIN
c32_ptr := @col_name;
ak40app_column (a41v, c32_ptr^, sizeof (col_name), dfloat, 18, 0)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40identifier_info (
            VAR a41v : tak40_show_glob;
            col_name : tsp00_Name);
 
VAR
      data_len : integer;
 
BEGIN
data_len := a01identifier_size DIV a01char_size;
ak40char_info (a41v, col_name, data_len)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40long_info (
            VAR a41v  : tak40_show_glob;
            col_name  : tak_oldidentifier);
 
VAR
      c32_ptr  : ^tsp00_C32;
      ix       : integer;
      aux_name : tsp00_Name;
 
BEGIN
IF  NOT (a41v.a4sh_kind in [sh_heap_content, sh_memoryholders])
THEN
    BEGIN
    aux_name[1]     := 'C';
    aux_name[2]     := '_';
    FOR ix := 1 TO sizeof (aux_name) - 2 DO
        aux_name[ix + 2] := col_name[ix];
    (*ENDFOR*) 
    ak40char_info  (a41v, aux_name, cak_maxfieldlength);
    END;
(*ENDIF*) 
c32_ptr := @col_name;
IF  g01unicode
THEN
    ak40app_column (a41v, c32_ptr^, sizeof(col_name), dstruni, a41v.a4long_desc_len, 0)
ELSE
    ak40app_column (a41v, c32_ptr^, sizeof(col_name), dstra, a41v.a4long_desc_len, 0)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40numeric_info (
            VAR a41v  : tak40_show_glob;
            col_name  : tak_oldidentifier;
            precision : integer);
 
VAR
      c32_ptr  : ^tsp00_C32;
 
BEGIN
c32_ptr := @col_name;
IF  a41v.a4systab_select
THEN
    ak40app_column (a41v, c32_ptr^, sizeof(col_name), dfixed, precision, 0)
ELSE
    (* explain *)
    ak40app_column (a41v, c32_ptr^, sizeof(col_name), dcha, precision, 0)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40time_info (
            VAR a41v : tak40_show_glob;
            col_name : tak_oldidentifier);
 
VAR
      c32_ptr  : ^tsp00_C32;
 
BEGIN
c32_ptr := @col_name;
ak40app_column (a41v, c32_ptr^, sizeof(col_name), dtime, mxsp_exttime, 0)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40timestamp_info (
            VAR a41v : tak40_show_glob;
            col_name : tak_oldidentifier);
 
VAR
      c32_ptr  : ^tsp00_C32;
 
BEGIN
c32_ptr := @col_name;
(* Bleibt noch auszuprogrammieren! *)
ak40app_column (a41v, c32_ptr^, sizeof(col_name), dtimestamp, mxsp_timestamp, 0)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_monitor_oms (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info       (a41v, ln_iid,              mxsp_c40);
ak40numeric_info    (a41v, ln_dispid,           mxsp_c4);
ak40identifier_info (a41v, ln_method);
ak40numeric_info    (a41v, ln_call_cnt,         mxsp_c10);
ak40numeric_info    (a41v, ln_runtime,          mxsp_c10);
ak40numeric_info    (a41v, ln_runtime_min,      mxsp_c10);
ak40numeric_info    (a41v, ln_runtime_max,      mxsp_c10);
ak40numeric_info    (a41v, ln_deref,            mxsp_c20);
ak40numeric_info    (a41v, ln_deref_lc,         mxsp_c20);
ak40numeric_info    (a41v, ln_deref_key,        mxsp_c20);
ak40numeric_info    (a41v, ln_store,            mxsp_c20);
ak40numeric_info    (a41v, ln_store_lc,         mxsp_c20);
ak40numeric_info    (a41v, ln_delete_oms,       mxsp_c20);
ak40numeric_info    (a41v, ln_delete_lc,        mxsp_c20);
ak40numeric_info    (a41v, ln_lock,             mxsp_c20);
ak40numeric_info    (a41v, ln_deref_iter,       mxsp_c20); (* PTS 1107819 T.A 2000-09-13 *)
ak40numeric_info    (a41v, ln_log_hops,         mxsp_c20);
ak40numeric_info    (a41v, ln_log_hops_iter,    mxsp_c20); (* PTS 1107819 T.A 2000-09-13 *)
ak40numeric_info    (a41v, ln_exceptions,       mxsp_c20);
ak40numeric_info    (a41v, ln_out_of_date,      mxsp_c20);
ak40numeric_info    (a41v, ln_timeout,          mxsp_c20);
ak40numeric_info    (a41v, ln_out_of_memory,    mxsp_c20);
ak40numeric_info    (a41v, ln_sub_rollback,     mxsp_c20);
ak40numeric_info    (a41v, ln_sub_commit,       mxsp_c20);
ak40numeric_info    (a41v, ln_max_subtrans_lvl, mxsp_c20);
ak40numeric_info    (a41v, ln_loadvarobj,       mxsp_c20);
ak40numeric_info    (a41v, ln_storevarobj,      mxsp_c20);
ak40numeric_info    (a41v, ln_avgvarobjsize,    mxsp_c20);
ak40numeric_info    (a41v, ln_create_version,   mxsp_c20);
ak40numeric_info    (a41v, ln_open_version,     mxsp_c20);
ak40numeric_info    (a41v, ln_close_version,    mxsp_c20);
ak40numeric_info    (a41v, ln_drop_version,     mxsp_c20);
ak40numeric_info    (a41v, ln_store_in_version, mxsp_c20);
ak40numeric_info    (a41v, ln_delete_in_version,mxsp_c20);
ak40numeric_info    (a41v, ln_read_in_version,  mxsp_c20);
ak40numeric_info    (a41v, ln_key_in_version,   mxsp_c20);
ak40numeric_info    (a41v, ln_delete_var_obj,   mxsp_c20);
ak40numeric_info    (a41v, ln_new_cons_view_max,mxsp_c20);
ak40numeric_info    (a41v, ln_new_cons_view_min,mxsp_c20);
ak40numeric_info    (a41v, ln_new_cons_view_avg,mxsp_c20);
ak40numeric_info    (a41v, ln_malloc_min,       mxsp_c20);
ak40numeric_info    (a41v, ln_malloc_max,       mxsp_c20);
ak40numeric_info    (a41v, ln_malloc_sum,       mxsp_c20);
ak40numeric_info    (a41v, ln_malloc_cnt,       mxsp_c20);
ak40numeric_info    (a41v, ln_free_min,         mxsp_c20);
ak40numeric_info    (a41v, ln_free_max,         mxsp_c20);
ak40numeric_info    (a41v, ln_free_sum,         mxsp_c20);
ak40numeric_info    (a41v, ln_free_cnt,         mxsp_c20);
ak40numeric_info    (a41v, ln_delta_alloc_min,  mxsp_c20);
ak40numeric_info    (a41v, ln_delta_alloc_max,  mxsp_c20);
ak40numeric_info    (a41v, ln_delta_alloc_avg,  mxsp_c20);
ak40numeric_info    (a41v, ln_oms_terminate,    mxsp_c20); (* PTS 1112796 *)
ak40numeric_info    (a41v, ln_min_strbuf_read,  mxsp_c20);
ak40numeric_info    (a41v, ln_max_strbuf_read,  mxsp_c20);
ak40numeric_info    (a41v, ln_avg_strbuf_read,  mxsp_c20);
ak40numeric_info    (a41v, ln_min_strrow_read,  mxsp_c20);
ak40numeric_info    (a41v, ln_max_strrow_read,  mxsp_c20);
ak40numeric_info    (a41v, ln_avg_strrow_read,  mxsp_c20);
ak40numeric_info    (a41v, ln_min_strbuf_write, mxsp_c20);
ak40numeric_info    (a41v, ln_max_strbuf_write, mxsp_c20);
ak40numeric_info    (a41v, ln_avg_strbuf_write, mxsp_c20);
ak40numeric_info    (a41v, ln_min_strrow_write, mxsp_c20);
ak40numeric_info    (a41v, ln_max_strrow_write, mxsp_c20);
ak40numeric_info    (a41v, ln_avg_strrow_write, mxsp_c20);
ak40numeric_info    (a41v, ln_oms_read_cache_hit,  mxsp_c20); (* PTS 1117571 *)
ak40numeric_info    (a41v, ln_oms_read_cache_miss, mxsp_c20); (* PTS 1117571 *)
ak40numeric_info    (a41v, ln_oms_read_version,    mxsp_c20); (* PTS 1117571 *)
ak40numeric_info    (a41v, ln_oms_max_chain_len,   mxsp_c20); (* PTS 1118855 *)
ak40numeric_info    (a41v, ln_oms_rehash,          mxsp_c20); (* PTS 1118855 *)
ak40numeric_info    (a41v, ln_wait_for_lockobj, mxsp_c20);
ak40numeric_info    (a41v, ln_avgWaitForLockobj,mxsp_c20);
ak40fixed_info      (a41v, ln_oms_avgHashChain,    10, 2);    (* PTS 1133314 *)
ak40numeric_info    (a41v, ln_omsRelease,          mxsp_c20); (* PTS 1133314 *)
ak40numeric_info    (a41v, ln_omsReleaseDone,      mxsp_c20); (* PTS 1133314 *)
ak40numeric_info    (a41v, ln_cache_size,       mxsp_c20);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_connect (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, cak_ln_username);
ak40char_info       (a41v, ln_termid,       mxsp_termid);
ak40numeric_info    (a41v, ln_session,      mxsp_c10);
ak40numeric_info    (a41v, ln_user_cache,   mxsp_c10);
(* PTS 1115043 E.Z. *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_connect_param (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info       (a41v, ln_sqlmode,     mxsp_c8);
ak40numeric_info    (a41v, ln_isolevel,    mxsp_c10);
ak40numeric_info    (a41v, ln_timeout,     mxsp_c10);
(* PTS 1105303 E.Z. *)
ak40numeric_info    (a41v, ln_session,       mxsp_c10   );
(* Output of oracle like nls parameter. *)
ak40char_info       (a41v, ln_date_format,   mxsp_c50);
(* PTS 1115043 E.Z. *)
END;
 
(* PTS 1106007 *)
(*------------------------------*) 
 
PROCEDURE
      ak40p_consistent_view (VAR a41v : tak40_show_glob);
 
BEGIN
ak40byte_info    (a41v, ln_consistent_view, sizeof(tgg91_TransNo));
ak40char_info    (a41v, ln_creator_trans,   mxsp_c20);    (* PTS 1125503 FF 2003-11-19 *)
ak40byte_info    (a41v, ln_open_trans,      sizeof(tgg91_TransNo));
ak40date_info    (a41v, cak_ln_date);
ak40time_info    (a41v, cak_ln_time);
ak40numeric_info (a41v, ln_last_used, mxsp_c10);
ak40char_info    (a41v, ln_cancelled, 3);         (* PTS 1120151 FF 2003-01-29 *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_constraint (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
IF  a41v.a4sh_kind = sh_domain_constraints
THEN
    ak40identifier_info (a41v, cak_ln_domainname)
ELSE
    ak40identifier_info (a41v, cak_ln_tablename);
(*ENDIF*) 
ak40identifier_info (a41v, ln_owner);
ak40identifier_info (a41v, ln_constraintname);
IF  a41v.a4sh_kind <> sh_domain_constraints
THEN
    ak40byte_info (a41v, ln_objectid, SURROGATE_MXGG00 + 4);
(*ENDIF*) 
ak40long_info (a41v, ln_definition)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_cons_columns (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, cak_ln_tablename);
ak40identifier_info (a41v, ln_owner);
ak40identifier_info (a41v, ln_constraintname);
ak40char_info       (a41v, cak_ln_type,        mxsp_c12);
ak40identifier_info (a41v, cak_ln_columnname);
ak40numeric_info    (a41v, ln_columnno,        mxsp_c4);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_ctrl_configuration (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info    (a41v, ln_default_code,        mxsp_c8);
ak40char_info    (a41v, ln_time_format ,        mxsp_c8);
ak40char_info    (a41v, ln_logmode,             mxsp_c12);
ak40char_info    (a41v, ln_mirrored_volumes,    1);
ak40char_info    (a41v, ln_database_full,       1);
(* PTS 1112568 E.Z. *)
ak40char_info    (a41v, ln_log_full,            1);
ak40char_info    (a41v, ln_connect_possible,    1);
ak40char_info    (a41v, ln_diagnose_monitor,    1);
ak40char_info    (a41v, ln_monitor,             1);
ak40char_info    (a41v, ln_knltrace,            1);
ak40char_info    (a41v, ln_autosave_standby,    1);
ak40char_info    (a41v, ln_autosave_media,      mxsp_c64); (* PTS 1000211, T.A. 1999-07-12 *)
ak40char_info    (a41v, ln_checkpoint_wanted,   1);
ak40numeric_info (a41v, ln_max_users, 5);
ak40numeric_info (a41v, ln_max_cpu,   5);
ak40numeric_info (a41v, ln_no_of_log_volumes,   5);
ak40numeric_info (a41v, ln_no_of_data_volumes,  5);
ak40numeric_info (a41v, ln_no_of_bad_indexes, 5);
ak40numeric_info (a41v, ln_converter_cache_size, 10);
ak40numeric_info (a41v, ln_data_cache_size, 10);
ak40numeric_info (a41v, ln_log_queue_size, 10);
ak40numeric_info (a41v, ln_locklist_size, 10);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_ctrl_devspaces (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info    (a41v, ln_volume_kind,   mxsp_c8);
ak40numeric_info (a41v, ln_volume_no,     5);
ak40char_info    (a41v, ln_volume_name,   sizeof(tsp00_VFilename));
ak40numeric_info (a41v, ln_volume_size,   10);
ak40char_info    (a41v, ln_volume_state,  mxsp_c18);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_ctrl_io_statistics (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info    (a41v, ln_object_name,       mxsp_c10);
ak40numeric_info (a41v, ln_logical_io_read,   10);
ak40numeric_info (a41v, ln_logical_io_write,  10);
ak40numeric_info (a41v, ln_physical_io_read,  10);
ak40numeric_info (a41v, ln_physical_io_write, 10);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_ctrl_locks (VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info   (a41v, ln_max_entries,     mxsp_c10);
ak40numeric_info   (a41v, ln_avg_entries,     mxsp_c10);
ak40numeric_info   (a41v, ln_collisions,      mxsp_c10);
ak40numeric_info   (a41v, ln_escalations,     mxsp_c10);
ak40numeric_info   (a41v, ln_row_locks,       mxsp_c10);
ak40numeric_info   (a41v, ln_table_entries,   mxsp_c10);
ak40numeric_info   (a41v, ln_req_timeout,     mxsp_c10);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_ctrl_log_statistics (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info         (a41v, ln_logmode,       mxsp_c12);
ak40numeric_info      (a41v, ln_size,               mxsp_c10);
ak40numeric_info      (a41v, ln_save_segm_size,     mxsp_c10);
ak40numeric_info      (a41v, ln_used_size,          mxsp_c10);
ak40numeric_info      (a41v, ln_used_percent,       mxsp_c3);
ak40numeric_info      (a41v, ln_not_saved_size,     mxsp_c10);
ak40numeric_info      (a41v, ln_not_saved_percent,  mxsp_c3);
ak40numeric_info      (a41v, ln_last_data_backup,   mxsp_c10);
ak40numeric_info      (a41v, ln_segm_completed,     mxsp_c10);
ak40numeric_info      (a41v, ln_savepoints,         mxsp_c10);
ak40numeric_info      (a41v, ln_checkpoints,        mxsp_c10);
ak40numeric_info      (a41v, ln_physical_reads,     mxsp_c10);
ak40numeric_info      (a41v, ln_physical_writes,    mxsp_c10);
ak40numeric_info      (a41v, ln_queue_size,         mxsp_c10);
ak40numeric_info      (a41v, ln_queue_allocated,    mxsp_c10);
ak40numeric_info      (a41v, ln_queue_entries,      mxsp_c10);
ak40numeric_info      (a41v, ln_queue_overflows,    mxsp_c10);
ak40numeric_info      (a41v, ln_group_commits,      mxsp_c10);
ak40numeric_info      (a41v, ln_wait_for_logwriter, mxsp_c10);
ak40numeric_info      (a41v, ln_max_waits,          mxsp_c10);
ak40numeric_info      (a41v, ln_avg_waits,          mxsp_c10);
(* PTS 1103119 E.Z. *)
ak40numeric_info      (a41v, ln_oms_log_used,       mxsp_c10);
ak40numeric_info      (a41v, ln_oms_log_min_free,   mxsp_c10);
END;
 
(* PROCEDURE
      ak40p_ctrl_cache_statistics (VAR a41v : tak40_show_glob);
      BEGIN
      ak40char_info    (a41v, ln_cache_kind,    mxsp_c20);
      ak40numeric_info (a41v, ln_accesses,      mxsp_c10);
      ak40numeric_info (a41v, ln_accesses_succ, mxsp_c10);
      ak40numeric_info (a41v, ln_accesses_miss, mxsp_c10);
      ak40numeric_info (a41v, ln_hit_rate,      mxsp_c3);
      END; *)
(* PTS 1120445 D.T. *)
(*------------------------------*) 
 
PROCEDURE
      ak40domain_data (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info       (a41v, ln_action    , mxsp_c18);
ak40char_info       (a41v, ln_objecttype, mxsp_c18);
ak40identifier_info (a41v, ln_parameter1);
ak40identifier_info (a41v, ln_parameter2);
ak40identifier_info (a41v, ln_parameter3);
ak40identifier_info (a41v, ln_parameter4);
ak40identifier_info (a41v, ln_parameter5)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_dbfunction (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_dbfunction);
ak40date_info       (a41v, cak_ln_date);
ak40time_info       (a41v, cak_ln_time);
ak40identifier_info (a41v, ln_owner);
ak40char_info       (a41v, ln_prog_id, sizeof (tsp00_C64));
ak40comment_info    (a41v)
END;
 
(* PTS 1115043 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak40p_dbm_state (VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info    (a41v, ln_pagesize_in_kb,      mxsp_c5);
ak40numeric_info    (a41v, ln_max_users,           mxsp_c5);
ak40numeric_info    (a41v, ln_active_sessions,     mxsp_c5);
ak40numeric_info    (a41v, ln_datacache_hitrate,   mxsp_c3);
ak40char_info       (a41v, ln_database_full,       mxsp_c3);
ak40char_info       (a41v, ln_connect_possible,    mxsp_c3);
ak40char_info       (a41v, ln_diagnose_monitor,    mxsp_c3);
ak40char_info       (a41v, ln_monitor,             mxsp_c3);
ak40char_info       (a41v, ln_knltrace,            mxsp_c3);
ak40char_info       (a41v, ln_autosave_standby,    mxsp_c3);
ak40numeric_info    (a41v, ln_no_of_bad_indexes,   mxsp_c5);
ak40char_info       (a41v, ln_log_full,            mxsp_c3);
ak40numeric_info    (a41v, ln_no_of_bad_volumes,   mxsp_c5);
ak40numeric_info    (a41v, ln_data_oms_hitrate,    mxsp_c3);
ak40numeric_info    (a41v, ln_log_oms_hitrate,     mxsp_c3);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_files_old (VAR a41v : tak40_show_glob);
 
BEGIN
ak40byte_info       (a41v, ln_file_id, sizeof(tgg00_FileId));
ak40byte_info       (a41v, ln_tabid, SURROGATE_MXGG00);
ak40identifier_info (a41v, ln_owner);
ak40identifier_info (a41v, cak_ln_tablename);
ak40identifier_info (a41v, cak_ln_indexname);
ak40char_info       (a41v, cak_ln_type,  mxsp_c18);
ak40numeric_info    (a41v, ln_root,      mxsp_c10);
ak40numeric_info    (a41v, ln_pagecount, mxsp_c10);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_info_gc_stats(VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info    (a41v, ln_taskid,  mxsp_c10);
ak40char_info       (a41v, ln_active, 3);
ak40numeric_info    (a41v, ln_activateCount,         mxsp_c20);
ak40numeric_info    (a41v, ln_delete_obj,            mxsp_c20);
ak40numeric_info    (a41v, ln_relHistEntryNormal,    mxsp_c20);
ak40numeric_info    (a41v, ln_relHistEntrySensitive, mxsp_c20);
ak40numeric_info    (a41v, ln_relHistEntryTrunc,     mxsp_c20);
ak40numeric_info    (a41v, ln_relHistCreateObjFile,  mxsp_c20);
ak40numeric_info    (a41v, ln_relHistDeleteObj,      mxsp_c20);
ak40numeric_info    (a41v, ln_relHistDropObjFile,    mxsp_c20);
ak40numeric_info    (a41v, ln_relHistLockObj,        mxsp_c20);
ak40numeric_info    (a41v, ln_relHistInsertObj,      mxsp_c20);
ak40numeric_info    (a41v, ln_relHistNewObj,         mxsp_c20);
ak40numeric_info    (a41v, ln_relHistUpdateObj,      mxsp_c20);
ak40numeric_info    (a41v, ln_relPageEmpty,          mxsp_c20);
ak40numeric_info    (a41v, ln_relPageDrop,           mxsp_c20);
ak40numeric_info    (a41v, ln_dropFile,              mxsp_c20);
END;
 
(*------------------------------*) 
 
PROCEDURE                 (* PTS 1115641 FF *)
      ak40p_container_roots(VAR a41v : tak40_show_glob);
 
BEGIN
ak40byte_info       (a41v, ln_class_id,            mxsp_c8);
ak40numeric_info    (a41v, ln_container_sequel_no, mxsp_c10);
ak40numeric_info    (a41v, ln_root,                mxsp_c10);
ak40numeric_info    (a41v, ln_key_part_count,      mxsp_c10);
ak40char_info       (a41v, ln_var_container,       3);
ak40char_info       (a41v, ln_delete_flag,         3);
ak40numeric_info    (a41v, ln_max_obj_body_size,   mxsp_c10);
ak40numeric_info    (a41v, ln_max_obj_per_page,    mxsp_c10);
ak40numeric_info    (a41v, ln_max_chains,          mxsp_c10);
ak40numeric_info    (a41v, ln_unused_byte_per_page,mxsp_c10); (* PTS 1118335 FF *)
END;
 
(*------------------------------*) 
 
PROCEDURE                 (* PTS 1115641 FF *)
      ak40p_container_chains(VAR a41v : tak40_show_glob);
 
BEGIN
ak40byte_info       (a41v, ln_class_id,            mxsp_c8);
ak40numeric_info    (a41v, ln_container_sequel_no, mxsp_c10);
ak40numeric_info    (a41v, ln_chain_id,            mxsp_c10);
ak40numeric_info    (a41v, ln_subroot,             mxsp_c10);
ak40numeric_info    (a41v, ln_objectcount,         mxsp_c10);
ak40numeric_info    (a41v, ln_pagecount,           mxsp_c10);
ak40numeric_info    (a41v, ln_active_gc_taskid,    mxsp_c10);
ak40char_info       (a41v, ln_release_empty_pages, 3);
END;
 
(*------------------------------*) 
 
PROCEDURE                 (* PTS 1115641 FF *)
      ak40p_container_keys(VAR a41v : tak40_show_glob);
 
BEGIN
ak40byte_info       (a41v, ln_class_id,            mxsp_c8);
ak40numeric_info    (a41v, ln_num_key_part,        mxsp_c10);
ak40numeric_info    (a41v, ln_key_root,            mxsp_c10);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_mapset (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_mapsetname);
ak40char_info       (a41v, ln_code,       mxsp_c8);
(* PTS 1120720 E.Z. *)
ak40byte_info (a41v, ln_intern,   mxsp_c2);
ak40byte_info (a41v, ln_map_code, mxsp_c4);
ak40char_info (a41v, ln_map_char, mxsp_c2)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_methods (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_owner);
ak40identifier_info (a41v, cak_ln_type);
ak40identifier_info (a41v, ln_method  );
ak40char_info       (a41v, ln_prog_id, sizeof (tsp00_C64));
ak40numeric_info    (a41v, ln_dispid, mxsp_c10);
ak40byte_info       (a41v, ln_coclsid, mxsp_c16);
ak40byte_info       (a41v, ln_iid,     mxsp_c16)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_column (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, cak_ln_tablename);
ak40identifier_info (a41v, ln_owner);
ak40identifier_info (a41v, cak_ln_columnname);
ak40char_info       (a41v, cak_ln_columntype, mxsp_c3);
ak40char_info       (a41v, cak_ln_datatype,   mxsp_c10);
ak40char_info       (a41v, ln_code,           mxsp_c8);
ak40numeric_info    (a41v, cak_ln_length,     mxsp_c4);
ak40numeric_info    (a41v, cak_ln_frac,       mxsp_c3);
ak40char_info       (a41v, ln_column_priv,    mxsp_c8);
ak40char_info       (a41v, cak_ln_default,    cak_maxfieldlength);
ak40char_info       (a41v, ln_defaultfunction,mxsp_c12);
ak40identifier_info (a41v, ln_domainowner);
ak40identifier_info (a41v, cak_ln_domainname);
ak40numeric_info    (a41v, ln_columnno,       mxsp_c4);
ak40numeric_info    (a41v, ln_keycolumnno,    mxsp_c4);
ak40numeric_info    (a41v, ln_dist_values,    mxsp_c10);
ak40char_info       (a41v, cak_ln_type,       mxsp_c8);
ak40date_info       (a41v, cak_ln_date);
ak40time_info       (a41v, cak_ln_time);
ak40date_info       (a41v, ln_alterdate);
ak40time_info       (a41v, ln_altertime);
ak40comment_info    (a41v);
ak40byte_info       (a41v, ln_objectid,      SURROGATE_MXGG00);
ak40char_info       (a41v, ln_nullable,      mxsp_c3);
ak40numeric_info    (a41v, ln_physicalcolno, mxsp_c4);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_odbc_column (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info  (a41v, ln_schemaname);
ak40identifier_info  (a41v, cak_ln_tablename);
ak40identifier_info  (a41v, ln_owner);
ak40identifier_info  (a41v, cak_ln_columnname);
ak40char_info        (a41v, cak_ln_datatype,   mxsp_c10);
ak40numeric_info     (a41v, ln_precision,      mxsp_c4);
ak40numeric_info     (a41v, cak_ln_length,     mxsp_c4);
ak40numeric_info     (a41v, cak_ln_frac,       mxsp_c3);
ak40numeric_info     (a41v, ln_radix,          mxsp_c2);
ak40numeric_info     (a41v, ln_nullable,       1);
ak40numeric_info     (a41v, ln_columnno,       mxsp_c4);
ak40numeric_info     (a41v, ln_key_seq,        mxsp_c4);
ak40char_info        (a41v, ln_code,           mxsp_c8);
ak40char_info        (a41v, cak_ln_default,    cak_maxfieldlength);
ak40char_info        (a41v, ln_defaultfunction,mxsp_c12);
ak40comment_info     (a41v);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_referenced_column (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, cak_ln_tablename);
ak40identifier_info (a41v, cak_ln_columnname);
ak40identifier_info (a41v, ln_owner);
ak40identifier_info (a41v, ln_refschemaname);
ak40identifier_info (a41v, ln_reftablen);
ak40identifier_info (a41v, ln_refcolumnname);
ak40identifier_info (a41v, ln_refowner);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_root (VAR a41v : tak40_show_glob);
 
BEGIN
ak40byte_info       (a41v,     ln_tabid,     SURROGATE_MXGG00);
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, ln_owner);
ak40identifier_info (a41v, cak_ln_tablename);
ak40identifier_info (a41v, cak_ln_indexname);
ak40char_info       (a41v, cak_ln_type, mxsp_c18);
ak40numeric_info    (a41v, ln_root,     mxsp_c10)
END;
 
(* PTS 1104069 *)
(*------------------------------*) 
 
PROCEDURE
      ak40p_db_roles (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_owner);
ak40identifier_info (a41v, ln_role);
ak40identifier_info (a41v, ln_grantee);
ak40char_info       (a41v, ln_defaultrole,  mxsp_c3);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_history_info(VAR a41v : tak40_show_glob);
 
BEGIN
(* PTS 1112257 E.Z. *)
ak40numeric_info  (a41v, ln_file_no,          mxsp_c10);
ak40char_info     (a41v, ln_first_trans,      mxsp_c20);
ak40char_info     (a41v, ln_first_trans_used, mxsp_c3);
ak40char_info     (a41v, ln_last_trans,       mxsp_c20);
ak40char_info     (a41v, ln_last_trans_used,  mxsp_c3);
ak40numeric_info  (a41v, ln_pagecount,        mxsp_c10);
ak40char_info     (a41v, ln_file_empty,       mxsp_c3);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_user_roles (VAR a41v : tak40_show_glob);
 
BEGIN
ak40byte_info (a41v, ln_roleid, SURROGATE_MXGG00);
ak40char_info (a41v, ln_defaultrole,  mxsp_c3);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_link (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, cak_ln_tablename);
ak40identifier_info (a41v, cak_ln_columnname);
ak40identifier_info (a41v, ln_owner);
ak40identifier_info (a41v, ln_refname);
ak40identifier_info (a41v, ln_refschemaname);
ak40identifier_info (a41v, ln_reftablen);
ak40identifier_info (a41v, ln_refcolumnname);
ak40identifier_info (a41v, ln_refowner);
ak40char_info       (a41v, ln_rule, mxsp_c18);
ak40date_info       (a41v, cak_ln_date);
ak40time_info       (a41v, cak_ln_time);
ak40comment_info (a41v);
ak40numeric_info (a41v, ln_keycolumnno,    mxsp_c4)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_schema (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info    (a41v, ln_schemaname);
ak40numeric_info       (a41v, ln_schemahandle, mxsp_c10); (* PTS 1113287 *)
ak40date_info          (a41v, cak_ln_date);
ak40time_info          (a41v, cak_ln_time);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_sequence (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info    (a41v, ln_schemaname);
ak40identifier_info    (a41v, ln_sequence_name);
ak40identifier_info    (a41v, ln_owner);
ak40numeric_info       (a41v, ln_min_value,
      (sizeof (tsp00_Number) - 1) * 2);
ak40numeric_info       (a41v, ln_max_value,
      (sizeof (tsp00_Number) - 1) * 2);
ak40numeric_info       (a41v, ln_increment,
      (sizeof (tsp00_Number) - 1) * 2);
ak40char_info          (a41v, ln_cycle_flag,    mxsp_c1);
ak40char_info          (a41v, ln_order_flag,    mxsp_c1);
ak40numeric_info       (a41v, ln_cache_size,
      (sizeof (tsp00_Number) - 1) * 2);
ak40numeric_info       (a41v, ln_last_number,
      (sizeof (tsp00_Number) - 1) * 2);
ak40date_info          (a41v, cak_ln_date);
ak40time_info          (a41v, cak_ln_time);
ak40byte_info          (a41v, ln_no, SURROGATE_MXGG00);
ak40comment_info (a41v)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_serverdb (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info    (a41v, ln_serverdb,   DBNAME_MXSP00);
ak40char_info    (a41v, ln_servernode, NODEID_MXSP00);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_serverdb_statistics (VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info (a41v, ln_size,                 mxsp_c10);
ak40numeric_info (a41v, ln_max_pno,               mxsp_c10);
ak40numeric_info (a41v, ln_max_perm,              mxsp_c10);
(* PTS 1113689/1121965 *)
ak40numeric_info (a41v, ln_max_used_pages,        mxsp_c10);
ak40numeric_info (a41v, ln_used_perm,             mxsp_c10);
ak40numeric_info (a41v, ln_pct_used_perm,         mxsp_c10);
ak40numeric_info (a41v, ln_used_temp,             mxsp_c10);
ak40numeric_info (a41v, ln_pct_used_temp,         mxsp_c10);
ak40numeric_info (a41v, ln_unused,                mxsp_c10);
ak40numeric_info (a41v, ln_pct_unused,            mxsp_c10);
ak40numeric_info (a41v, ln_updated,               mxsp_c10);
ak40numeric_info (a41v, ln_used_blocks,           mxsp_c10);
ak40char_info    (a41v, ln_serverdb_full,         mxsp_c3);
ak40numeric_info (a41v, ln_log_pages,             mxsp_c10);
ak40numeric_info (a41v, ln_used_log_pages,        mxsp_c10);
ak40numeric_info (a41v, ln_pct_used_log,          mxsp_c10);
ak40numeric_info (a41v, ln_log_not_saved,         mxsp_c10);
ak40numeric_info (a41v, ln_pct_log_not_saved,     mxsp_c10);
ak40numeric_info (a41v, ln_log_since_bup,         mxsp_c10);
ak40numeric_info (a41v, ln_log_segment_size,      mxsp_c10);
ak40numeric_info (a41v, ln_savepoints,            mxsp_c10);
ak40numeric_info (a41v, ln_checkpoints,           mxsp_c10);
ak40date_info    (a41v, cak_ln_date);
ak40time_info    (a41v, cak_ln_time);
ak40numeric_info (a41v, ln_oms_log_pages,         mxsp_c10);
ak40numeric_info (a41v, ln_oms_log_min_free,      mxsp_c10);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_dbproc_param (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
CASE a41v.a4sh_kind OF
    sh_dbfunc_parameters :
        BEGIN
        ak40identifier_info (a41v, ln_dbfunction);
        ak40identifier_info (a41v, ln_owner);
        END;
    sh_param_dbproc :
        BEGIN
        ak40identifier_info (a41v, ln_dbproc);
        ak40identifier_info (a41v, ln_owner);
        END;
    sh_param_trigger :
        BEGIN
        ak40identifier_info (a41v, cak_ln_tablename);
        ak40identifier_info (a41v, ln_trigger);
        END;
    END;
(*ENDCASE*) 
ak40date_info    (a41v, cak_ln_date);
ak40time_info    (a41v, cak_ln_time);
ak40numeric_info (a41v, ln_param_no, mxsp_c4);
ak40identifier_info (a41v, ln_parametername);
IF  a41v.a4sh_kind = sh_param_trigger
THEN
    ak40char_info   (a41v, ln_new_old, mxsp_c3)
ELSE
    ak40char_info   (a41v, ln_in_out, mxsp_c6);
(*ENDIF*) 
ak40char_info       (a41v, cak_ln_datatype,   mxsp_c10);
ak40numeric_info    (a41v, cak_ln_length,     mxsp_c4);
ak40numeric_info    (a41v, cak_ln_frac,       mxsp_c3);
ak40numeric_info    (a41v, ln_offset,         mxsp_c4);
IF  a41v.a4sh_kind = sh_param_dbproc
THEN
    BEGIN
    ak40numeric_info (a41v, ln_ascii_offset,   mxsp_c4);
    ak40numeric_info (a41v, ln_unicode_offset, mxsp_c4);
    END;
(*ENDIF*) 
ak40char_info    (a41v, ln_code, mxsp_c8)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_objects (VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info    (a41v, ln_ownerid,   mxsp_c18);
ak40byte_info       (a41v, ln_objectid,  SURROGATE_MXGG00 + 4);
ak40identifier_info (a41v, ln_owner);
ak40identifier_info (a41v, ln_objectname);
ak40char_info       (a41v, cak_ln_type, mxsp_c8);
ak40date_info       (a41v, cak_ln_date);
ak40time_info       (a41v, cak_ln_time);
ak40date_info       (a41v, ln_alterdate);
ak40time_info       (a41v, ln_altertime)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_oms_lock_info (VAR a41v : tak40_show_glob); (* PTS 1110315 *)
 
BEGIN
ak40byte_info     (a41v, ln_lock_handle, mxsp_c8);
ak40numeric_info  (a41v, ln_process,     mxsp_c10);
ak40char_info     (a41v, ln_lock_mode,   mxsp_c14);
ak40char_info     (a41v, ln_req_mode,    mxsp_c14);
ak40char_info     (a41v, ln_req_timeout, mxsp_c10);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_heap_content(VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info (a41v, ln_number,           mxsp_c20);
ak40numeric_info (a41v, ln_size,             mxsp_c20);
ak40numeric_info (a41v, ln_call_stack_id,    mxsp_c10);
ak40char_info    (a41v, ln_level0,           255);
ak40char_info    (a41v, ln_level1,           255);
ak40char_info    (a41v, ln_level2,           255);
ak40char_info    (a41v, ln_level3,           255);
ak40char_info    (a41v, ln_level4,           255);
ak40char_info    (a41v, ln_level5,           255);
ak40char_info    (a41v, ln_level6,           255);
ak40char_info    (a41v, ln_level7,           255);
ak40char_info    (a41v, ln_level8,           255);
ak40char_info    (a41v, ln_level9,           255);
ak40long_info    (a41v, ln_call_stack);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_oms_memory (VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info (a41v, ln_kb,               mxsp_c20);
ak40numeric_info (a41v, ln_free,             mxsp_c20);
ak40numeric_info (a41v, ln_reserved,         mxsp_c20);
ak40numeric_info (a41v, ln_mallocated,       mxsp_c20);
ak40numeric_info (a41v, ln_emergency,        mxsp_c20);
ak40numeric_info (a41v, ln_emergencyInUse,   mxsp_c20);
ak40numeric_info (a41v, ln_emergencyMaxUsed, mxsp_c20);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_oms_versions (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info    (a41v, ln_version_id, sizeof (tak_oms_version_id));
ak40date_info    (a41v, cak_ln_date);
ak40time_info    (a41v, cak_ln_time);
ak40byte_info    (a41v, ln_trans_version, sizeof(tgg91_TransNo));
ak40date_info    (a41v, ln_open_date);
ak40time_info    (a41v, ln_open_time);
ak40char_info    (a41v, ln_open, 3);
ak40char_info    (a41v, ln_marked, 3);
ak40char_info    (a41v, ln_unloaded, 3);
ak40numeric_info (a41v, ln_kb, mxsp_c20);
ak40numeric_info (a41v, ln_pagecount, mxsp_c20); (* PTS 1112041 *)
ak40char_info    (a41v, ln_version_desc, sizeof (tak_oms_version_desc)); (* PTS 1117690 *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_procedure (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, ln_dbproc);
ak40identifier_info (a41v, ln_owner);
ak40identifier_info (a41v, ln_package);
ak40numeric_info    (a41v, ln_parameter, mxsp_c4);
ak40date_info       (a41v, cak_ln_date);
ak40time_info       (a41v, cak_ln_time);
ak40char_info       (a41v, ln_execution_kind, mxsp_c6);
ak40char_info       (a41v, cak_ln_type, mxsp_c8);
ak40identifier_info (a41v, ln_language);
ak40char_info       (a41v, ln_sql_support,   mxsp_c3);
ak40char_info       (a41v, ln_cursor,        mxsp_c3);
ak40char_info       (a41v, ln_deterministic, mxsp_c3);
ak40char_info       (a41v, ln_remote_loc, sizeof(tsp00_C132));
ak40char_info       (a41v, ln_file,    sizeof(tsp00_Path));
ak40numeric_info    (a41v, ln_dispid,  mxsp_c10);
ak40char_info       (a41v, ln_coclsid, mxsp_c40);
ak40char_info       (a41v, ln_iid,     mxsp_c40);
ak40char_info       (a41v, ln_waitForChckpt, mxsp_c3);
ak40long_info       (a41v, ln_definition);
ak40comment_info (a41v)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_explain (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info    (a41v, ln_owner);
ak40identifier_info    (a41v, cak_ln_tablename);
ak40identifier_info    (a41v, ln_column_index);
ak40char_info          (a41v, ln_strat,         mxsp_c40);
ak40numeric_info       (a41v, ln_pagecount,     mxsp_c10);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_join_explain (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info       (a41v, ln_strat, mxsp_c40);
ak40identifier_info (a41v, ln_owner);
ak40identifier_info (a41v, cak_ln_tablename);
ak40float_info      (a41v, 'MAX ADDNL. ROWS   ');
ak40float_info      (a41v, 'MULTIPLIER        ');
ak40float_info      (a41v, 'REVERSE MULTIPLIER'); (* h.b. PTS 1106350 *)
ak40float_info      (a41v, 'ADDITIONAL PAGES  ');
ak40float_info      (a41v, 'ADDITIONAL ROWS   ');
ak40float_info      (a41v, 'ACCUMULATED_COSTS ');
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_sequence_explain (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info (a41v, cak_ln_text, cak_maxtextlength)
END;
 
(* PTS 1109995 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak40p_optimize_stat (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v,  ln_schemaname);
ak40identifier_info (a41v,  cak_ln_tablename);
ak40identifier_info (a41v,  ln_owner);
ak40identifier_info (a41v,  cak_ln_columnname);
ak40identifier_info (a41v,  cak_ln_indexname);
ak40numeric_info    (a41v,  ln_dist_values,    mxsp_c10);
ak40numeric_info    (a41v,  ln_pagecount,      mxsp_c10);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_bad_index (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v,  ln_schemaname);
ak40identifier_info (a41v,  ln_owner);
ak40identifier_info (a41v,  cak_ln_tablename);
(* PTS 1115043 E.Z. *)
ak40identifier_info (a41v,  cak_ln_indexname)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_table (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, cak_ln_tablename);
ak40identifier_info (a41v, ln_owner);
ak40char_info       (a41v, cak_ln_privileges,  mxsp_c30);
ak40char_info       (a41v, cak_ln_type,        mxsp_c8);
ak40date_info       (a41v, cak_ln_date);
ak40time_info       (a41v, cak_ln_time);
ak40date_info       (a41v, ln_upddate);
ak40time_info       (a41v, ln_updtime);
ak40date_info    (a41v, ln_alterdate);
ak40time_info    (a41v, ln_altertime);
ak40byte_info    (a41v, ln_objectid,  SURROGATE_MXGG00);
ak40numeric_info (a41v, ln_rows,      mxsp_c10);
ak40numeric_info (a41v, ln_pagecount, mxsp_c10);
ak40char_info    (a41v, ln_sqlmode,   mxsp_c8);
ak40char_info    (a41v, ln_dynamic,   mxsp_c3);
ak40char_info    (a41v, ln_archive,   mxsp_c3); (* PTS 1117381 E.Z. *)
ak40char_info    (a41v, ln_read_only, mxsp_c3);
ak40char_info    (a41v, ln_unloaded,  mxsp_c3);
ak40char_info    (a41v, ln_fact,      mxsp_c3);
ak40char_info    (a41v, ln_dimension, mxsp_c3);
ak40char_info    (a41v, ln_bwhierarchy, mxsp_c3);
ak40char_info    (a41v, ln_variable_columns, mxsp_c3);  (* PTS 1126711 E.Z. *)
ak40char_info    (a41v, ln_virtualkey, mxsp_c3);
ak40char_info    (a41v, ln_withCheckOption, mxsp_c3);
ak40char_info    (a41v, ln_complex,         mxsp_c3);
ak40numeric_info (a41v, ln_root,      mxsp_c10);
ak40comment_info (a41v);
ak40numeric_info (a41v, ln_colcount,       mxsp_c4);
ak40char_info    (a41v, ln_tabletype,      mxsp_c8);
ak40numeric_info (a41v, ln_sample_percent, mxsp_c3);
ak40numeric_info (a41v, ln_sample_rows   , mxsp_c10)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_table_stat (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, cak_ln_tablename);
ak40identifier_info (a41v, ln_owner);
IF  a41v.a4sh_kind = sh_odbc_st_table
THEN
    BEGIN
    ak40numeric_info (a41v, ln_rows,      mxsp_c10);
    ak40numeric_info (a41v, ln_pagecount, mxsp_c10)
    END
ELSE
    ak40p_config  (a41v);
(*ENDIF*) 
IF  a41v.a4sh_kind = sh_pages
THEN
    BEGIN
    ak40numeric_info (a41v, ln_estimated_pages, mxsp_c10);
    (* h.b. PTS 1107061 *)
    ak40numeric_info (a41v, ln_shortcol_pages, mxsp_c10);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_lock (VAR a41v : tak40_show_glob);
 
BEGIN
ak40p_trans         (a41v);
ak40identifier_info (a41v,     ln_schemaname                   );
ak40identifier_info (a41v,     cak_ln_tablename            );
ak40identifier_info (a41v,     ln_owner                    );
ak40byte_info       (a41v,     ln_tabid,     SURROGATE_MXGG00);
ak40numeric_info    (a41v,     ln_rowid_len, mxsp_c4       );
ak40byte_info       (a41v,     ln_rowid_hex, mxsp_c64      );
ak40char_info       (a41v,     ln_rowid,     2*mxsp_c64    )
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_lock_statistics (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info (a41v, cak_ln_description, mxsp_c40);
ak40char_info (a41v, cak_ln_value, mxsp_c12)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_monitor (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info (a41v, cak_ln_type,        mxsp_c8);
ak40char_info    (a41v, cak_ln_description, mxsp_c40);
ak40numeric_info (a41v, cak_ln_value, mxsp_c20)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_config   (VAR a41v : tak40_show_glob);
 
VAR
      width : integer;
 
BEGIN
ak40char_info (a41v, cak_ln_description, mxsp_c40);
ak40numeric_info (a41v, ln_num_value, mxsp_c10);
IF  a41v.a4sh_kind in [sh_st_index, sh_st_table, sh_indexpages]
THEN
    width := mxsp_c12
ELSE
    IF  a41v.a4sh_kind = sh_st_config
    THEN
        width := sizeof(tsp00_VFilename)
    ELSE
        width := mxsp_c40;
    (*ENDIF*) 
(*ENDIF*) 
ak40char_info (a41v, cak_ln_value, width)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_session_roles (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_session_roles)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_synonym (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_synowner);
ak40identifier_info (a41v, cak_ln_synonymname);
ak40char_info (a41v, ln_public, mxsp_c3);
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, cak_ln_tablename);
ak40identifier_info (a41v, ln_owner);
ak40char_info       (a41v, cak_ln_type, mxsp_c8);
ak40date_info       (a41v, cak_ln_date);
ak40time_info       (a41v, cak_ln_time);
ak40byte_info       (a41v, ln_objectid, SURROGATE_MXGG00);
ak40char_info       (a41v, ln_system, mxsp_c3); (* PTS 1109242 *)
ak40comment_info    (a41v)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_user (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v,     cak_ln_username);
ak40identifier_info (a41v,     ln_groupname);
ak40identifier_info (a41v,     ln_owner);
ak40identifier_info (a41v, ln_owner_owner);
ak40char_info    (a41v,  ln_usermode,     mxsp_c8);
ak40char_info    (a41v,  ln_connect,      mxsp_c8);
ak40numeric_info (a41v,  ln_timeout_upb,  mxsp_c10);
ak40numeric_info (a41v,  ln_costwarning,  mxsp_c10);
ak40numeric_info (a41v,  ln_costlimit,    mxsp_c10);
(* PTS 1117216 E.Z. *)
ak40char_info    (a41v,  ln_defaultcode,  mxsp_c8);
ak40numeric_info (a41v, ln_user_id, mxsp_c10);
ak40date_info (a41v, cak_ln_date);
ak40time_info (a41v, cak_ln_time);
ak40date_info (a41v, ln_alterdate);
ak40time_info (a41v, ln_altertime);
ak40date_info (a41v, ln_pwcreatedate);
ak40time_info (a41v, ln_pwcreatetime);
ak40char_info (a41v, ln_serverdb,   DBNAME_MXSP00);
ak40char_info (a41v, ln_servernode, NODEID_MXSP00);
ak40char_info (a41v, ln_replication, mxsp_c3);
ak40comment_info (a41v);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_st_user (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v,    cak_ln_username);
ak40char_info      (a41v,    ln_usermode,      mxsp_c8);
(* PTS 1107952 E.Z. *)
ak40numeric_info   (a41v, ln_permpages,     mxsp_c10);
ak40numeric_info   (a41v, ln_temppages,     mxsp_c10)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_trans (VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info    (a41v,     ln_session,            mxsp_c10   );
ak40char_info       (a41v,     ln_transid,            mxsp_c20   );
ak40numeric_info    (a41v,     ln_sub_trans,          mxsp_c10   ); (* PTS 1108234 JA 2001-01-19 *)
ak40byte_info       (a41v,     ln_write_trans,        sizeof(tgg91_TransNo));   (* JA 2001-01-19 *)
ak40numeric_info    (a41v,     ln_process,            mxsp_c10   );
ak40identifier_info (a41v,     cak_ln_username);
ak40date_info       (a41v,     cak_ln_date);
ak40time_info       (a41v,     cak_ln_time);
ak40char_info       (a41v,     ln_termid,             mxsp_termid);
ak40char_info       (a41v,     ln_lock_timeout,       mxsp_c10   );
ak40char_info       (a41v,     ln_req_timeout,        mxsp_c10   );
ak40char_info       (a41v,     ln_last_write,         mxsp_c10   );
ak40char_info       (a41v,     ln_lock_mode,          mxsp_c14   );
ak40char_info       (a41v,     ln_lock_state,         mxsp_c10   );
ak40char_info       (a41v,     ln_req_mode,           mxsp_c14   );
ak40char_info       (a41v,     ln_req_state,          mxsp_c10   );
ak40byte_info       (a41v,     ln_consistent_view,    sizeof(tgg91_TransNo)); (* PTS 1106007 *)
ak40numeric_info    (a41v,     ln_appl_process,       mxsp_c10   );
ak40char_info       (a41v,     ln_appl_node,          NODEID_MXSP00)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_transfile (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info (a41v, ln_partner,     mxsp_c10);
ak40char_info (a41v, ln_session,     mxsp_c10);
ak40char_info (a41v, ln_transid,     mxsp_c10);
ak40char_info (a41v, ln_coordinator, mxsp_c10);
ak40char_info (a41v, ln_transstate,  mxsp_c10)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_trigger (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, cak_ln_tablename);
ak40identifier_info (a41v, ln_owner);
ak40identifier_info (a41v, ln_trigger);
ak40char_info (a41v, ln_insert, mxsp_c3);
ak40char_info (a41v, ln_update, mxsp_c3);
ak40char_info (a41v, ln_delete, mxsp_c3);
ak40identifier_info (a41v, ln_dbproc);
ak40char_info       (a41v, ln_prog_id, sizeof (tsp00_C64));
ak40date_info       (a41v, cak_ln_date);
ak40time_info       (a41v, cak_ln_time);
ak40long_info    (a41v, ln_definition);
ak40comment_info (a41v)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_show_view (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, cak_ln_tablename);
ak40identifier_info (a41v, ln_owner);
ak40char_info       (a41v, ln_definition, mxsp_c80)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_view (
            VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, cak_ln_tablename);
ak40identifier_info (a41v, ln_owner);
(* PTS 1120915 E.Z. *)
ak40numeric_info   (a41v, cak_ln_length,    mxsp_c5);
ak40long_info      (a41v, ln_definition)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_view_uses_table (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, cak_ln_tablename);
ak40identifier_info (a41v, ln_owner);
ak40char_info       (a41v, cak_ln_type, mxsp_c8);
ak40identifier_info (a41v, ln_refname);
ak40identifier_info (a41v, ln_reftablen);
ak40char_info       (a41v, ln_refkind, mxsp_c8)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_version_old (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info (a41v, ln_kernel,         mxsp_c40);
ak40char_info (a41v, ln_rte,            mxsp_c40);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_user_tasks (VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info (a41v, ln_taskid,  mxsp_c10);
ak40byte_info    (a41v, ln_parseid, mxsp_c12)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_index (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, cak_ln_tablename);
ak40identifier_info (a41v, ln_owner);
ak40identifier_info (a41v, cak_ln_indexname);
ak40byte_info       (a41v, ln_fileid,        mxsp_c8); (* PTS 1132536 M.Ki. *)
ak40char_info       (a41v, cak_ln_type,      mxsp_c6);
ak40identifier_info (a41v, cak_ln_columnname);
ak40char_info       (a41v, cak_ln_order,     mxsp_c4);
ak40date_info       (a41v, cak_ln_date);
ak40time_info       (a41v, cak_ln_time);
ak40numeric_info    (a41v, ln_columnno,      mxsp_c4);
ak40char_info       (a41v, cak_ln_datatype,  mxsp_c10);
ak40numeric_info    (a41v, cak_ln_length,    mxsp_c4);
(* PTS 1114498 E.Z. *)
ak40numeric_info    (a41v, ln_used,          mxsp_c10);
ak40date_info       (a41v, ln_init_usage_date);
ak40time_info       (a41v, ln_init_usage_time);
ak40char_info       (a41v, ln_filestate,     mxsp_c20); (* PTS 1132536 M.Ki. *)
ak40char_info       (a41v, ln_disabled,      mxsp_c3);
ak40comment_info    (a41v);
END;
 
(* PTS 1115043 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak40p_index_stat (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, cak_ln_tablename);
ak40identifier_info (a41v, ln_owner);
ak40identifier_info (a41v, cak_ln_indexname);
ak40identifier_info (a41v, cak_ln_columnname);
IF  a41v.a4sh_kind = sh_odbc_st_index
THEN
    BEGIN
    ak40numeric_info (a41v, ln_rows,      mxsp_c10);
    ak40numeric_info (a41v, ln_pagecount, mxsp_c10)
    END
ELSE
    ak40p_config  (a41v)
(*ENDIF*) 
END;
 
(* PTS 1114549 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak40p_s_connection (VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info    (a41v, ln_sysmon_taskindex      , mxsp_c10);
ak40numeric_info    (a41v, ln_sysmon_uktid          , mxsp_c10);
ak40numeric_info    (a41v, ln_sysmon_applpid        , mxsp_c10);
ak40numeric_info    (a41v, ln_sysmon_peerpid        , mxsp_c10);
ak40char_info       (a41v, ln_sysmon_taskname       , mxsp_c16);
ak40char_info       (a41v, ln_sysmon_connectstate   , 32);
ak40char_info       (a41v, ln_sysmon_connecttime    , 32);
ak40char_info       (a41v, ln_sysmon_remoteapplnode , mxsp_c64);
END;
 
(* PTS 1105189 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak40p_s_region (VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info    (a41v, ln_sysmon_regid          , mxsp_c10);
ak40char_info       (a41v, ln_sysmon_regionname     , mxsp_c16);
ak40numeric_info    (a41v, ln_sysmon_ownerdbpid     , mxsp_c10);
ak40numeric_info    (a41v, ln_sysmon_reqstdbpid     , mxsp_c10);
ak40numeric_info    (a41v, ln_sysmon_accesses       , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_test_and_set   , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_collisions     , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_collision_rate , 7, 2);
ak40numeric_info    (a41v, ln_sysmon_waits          , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_locked         , mxsp_c10);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_s_storage (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info       (a41v, ln_sysmon_desc           , mxsp_c64);
ak40numeric_info    (a41v, ln_sysmon_val            , mxsp_c10);
ak40char_info       (a41v, ln_sysmon_vdesc          , mxsp_c6);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_s_ioaccess (VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info    (a41v, ln_sysmon_deviceid       , mxsp_c10);
ak40char_info       (a41v, ln_sysmon_devicename     , sizeof(tsp00_VFilename));
ak40numeric_info    (a41v, ln_sysmon_reads          , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_readpages      , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_writes         , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_writepages     , mxsp_c20);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_s_backupioaccess (VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info    (a41v, ln_sysmon_deviceid       , mxsp_c10);
ak40char_info       (a41v, ln_sysmon_devicename     , sizeof(tsp00_VFilename));
ak40numeric_info    (a41v, ln_sysmon_backupreads    , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_backupwrites   , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_backuppages    , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_queuelen       , mxsp_c10);
ak40numeric_info    (a41v, ln_sysmon_queuemax       , mxsp_c10);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_s_spec_thread (VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info    (a41v, ln_sysmon_ospid          , mxsp_c10);
ak40char_info       (a41v, ln_sysmon_threadname     , mxsp_c16);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_s_ukthread (VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info    (a41v, ln_sysmon_ospid          , mxsp_c10);
ak40char_info       (a41v, ln_sysmon_threadname     , mxsp_c16);
ak40char_info       (a41v, ln_sysmon_threadstate    , mxsp_c16);
ak40numeric_info    (a41v, ln_sysmon_dispatchcnt    , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_taskswitchcnt  , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_idlecount      , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_commandcnt     , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_tasks_active   , mxsp_c10);
ak40numeric_info    (a41v, ln_sysmon_tasks_total    , mxsp_c10);
ak40numeric_info    (a41v, ln_sysmon_usedrunqueuelength, mxsp_c10);
ak40char_info       (a41v, ln_sysmon_taskcluster    , mxsp_c64);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_s_deviothread (VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info    (a41v, ln_sysmon_ospid          , mxsp_c10);
ak40char_info       (a41v, ln_sysmon_threadname     , mxsp_c16);
ak40numeric_info    (a41v, ln_sysmon_volumeid       , mxsp_c10);
ak40char_info       (a41v, ln_sysmon_volumename     , sizeof(tsp00_VFilename));
ak40numeric_info    (a41v, ln_sysmon_reads          , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_writes         , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_queuelen       , mxsp_c10);
ak40numeric_info    (a41v, ln_sysmon_queuemax       , mxsp_c10);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_s_task (VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info    (a41v, ln_sysmon_dbpid            , mxsp_c10);
ak40numeric_info    (a41v, ln_sysmon_ospid            , mxsp_c10);
ak40char_info       (a41v, ln_sysmon_tasktype         , mxsp_c16);
ak40numeric_info    (a41v, ln_sysmon_appid            , mxsp_c10);
ak40char_info       (a41v, ln_sysmon_statedesc        , mxsp_c16);
ak40char_info       (a41v, ln_sysmon_cancel_flag      , mxsp_c1);
(* PTS 1111217 E.Z. *)
ak40char_info       (a41v, ln_sysmon_omscallactive    , mxsp_c1);
ak40char_info       (a41v, ln_sysmon_special_flag     , mxsp_c1);
ak40numeric_info    (a41v, ln_sysmon_timeout          , mxsp_c10);
ak40numeric_info    (a41v, ln_sysmon_regid            , mxsp_c10);
ak40numeric_info    (a41v, ln_sysmon_waiting4task     , mxsp_c10);
ak40numeric_info    (a41v, ln_sysmon_waiting4root     , mxsp_c10);
(* PTS 1115172 E.Z. *)
ak40numeric_info    (a41v, ln_sysmon_lockedpageno     , mxsp_c10);
ak40char_info       (a41v, ln_sysmon_extendedtaskstate, mxsp_c64);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_s_task_detail (VAR a41v : tak40_show_glob);
 
BEGIN
(* PTS 1111216 E.Z. names with 'TOT' in it *)
ak40numeric_info    (a41v, ln_sysmon_dbpid             , mxsp_c10);
ak40char_info       (a41v, ln_sysmon_taskname          , mxsp_c16);
ak40char_info       (a41v, ln_sysmon_statedesc         , mxsp_c16);
ak40numeric_info    (a41v, ln_sysmon_uktid             , mxsp_c10);
ak40char_info       (a41v, ln_appl_node                , NODEID_MXSP00);
ak40numeric_info    (a41v, ln_appl_process             , mxsp_c10);
ak40numeric_info    (a41v, ln_sysmon_dispatchcnt       , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_commandcnt        , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_priocnt           , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_taskselfsuspcnt   , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_regionaccesscnt   , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_sioreadcnt        , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_sioreadpages      , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_sioreadavgabstime , mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_sioreadtotabstime , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_siowritecnt       , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_siowritepages     , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_siowriteavgabstime, mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_siowritetotabstime, mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_ioreadcnt         , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_ioreadpages       , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_ioreadavgreltime  , mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_ioreadtotreltime  , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_ioreadavgabstime  , mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_ioreadtotabstime  , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_iowritecnt        , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_iowritepages      , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_iowriteavgreltime , mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_iowritetotreltime , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_iowriteavgabstime , mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_iowritetotabstime , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_bkpreadcnt        , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_bkpreadpages      , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_bkpreadavgreltime , mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_bkpreadtotreltime , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_bkpreadavgabstime , mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_bkpreadtotabstime , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_bkpwritecnt       , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_bkpwritepages     , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_bkpwriteavgreltime, mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_bkpwritetotreltime, mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_bkpwriteavgabstime, mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_bkpwritetotabstime, mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_vsuspendcnt       , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_vsuspendavgreltime, mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_vsuspendtotreltime, mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_vsuspendavgabstime, mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_vsuspendtotabstime, mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_vwaitcnt          , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_vwaitavgreltime   , mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_vwaittotreltime   , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_vwaitavgabstime   , mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_vwaittotabstime   , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_vsleepcnt         , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_vsleepavgreltime  , mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_vsleeptotreltime  , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_vsleepavgabstime  , mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_vsleeptotabstime  , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_cmdcnt            , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_avgcmdexecutetime , mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_totcmdexecutetime , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_avgcmdwaitreltime , mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_totcmdwaitreltime , mxsp_c20);
ak40fixed_info      (a41v, ln_sysmon_avgcmdwaitabstime , mxsp_c20, 4);
ak40numeric_info    (a41v, ln_sysmon_totcmdwaitabstime , mxsp_c20);
(* PTS 1110965 E.Z. *)
ak40char_info       (a41v, ln_sysmon_omscomroutinename , mxsp_c64);
ak40numeric_info    (a41v, ln_sysmon_omscallbackcount  , mxsp_c20);
ak40char_info       (a41v, ln_sysmon_omscallbackmethod , 32);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_s_totalcount (VAR a41v : tak40_show_glob);
 
BEGIN
ak40numeric_info    (a41v, ln_sysmon_dispatchcnt       , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_commandcnt        , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_vwaitcnt          , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_vsuspendcnt       , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_vsleepcnt         , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_priocnt           , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_usertaskreadcnt   , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_usertaskwritecnt  , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_taskiocnt         , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_iocnt             , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_regionaccesscnt   , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_regioncollcnt     , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_regionwaitcnt     , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_vbegexcltascollcnt, mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_vendexcltascollcnt, mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_taskselfsuspcnt   , mxsp_c20);
ak40numeric_info    (a41v, ln_sysmon_symbolresolvecnt  , mxsp_c20);
END;
 
(* END PTS 1105189 E.Z. *)
(* PTS 1106167 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak40p_parsinfos (VAR a41v : tak40_show_glob);
 
BEGIN
ak40byte_info       (a41v, ln_sysinfokey,
      sizeof(tgg00_SysInfoKey) - cgg_rec_key_offset);
ak40byte_info       (a41v, ln_key_seq  , mxsp_c2);
ak40identifier_info (a41v, ln_name1);
ak40numeric_info    (a41v, ln_num_value, mxsp_c4);
ak40char_info       (a41v, ln_tabletype, mxsp_c12);
ak40numeric_info    (a41v, ln_size     , mxsp_c5);
END;
 
(* PTS 1107717 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak40p_internal_state (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info (a41v, ln_component,       mxsp_c20);
ak40char_info (a41v, cak_ln_description, mxsp_c40);
ak40char_info (a41v, cak_ln_value,       mxsp_c40);
END;
 
(* PTS 1107717 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak40p_spinlocks  (VAR a41v : tak40_show_glob);
 
BEGIN
ak40char_info    (a41v, ln_spinlock_name    , mxsp_c40);
ak40numeric_info (a41v, ln_locks            , mxsp_c20);
ak40numeric_info (a41v, ln_collisions       , mxsp_c20);
ak40numeric_info (a41v, ln_total_spin_loops , mxsp_c10);
ak40numeric_info (a41v, ln_total_yield_loops, mxsp_c10);
ak40numeric_info (a41v, ln_max_spin_loops   , mxsp_c10);
ak40numeric_info (a41v, ln_max_yield_loops  , mxsp_c10);
ak40numeric_info (a41v, ln_current_loops    , mxsp_c10);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40p_variables (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, cak_ln_tablename);
ak40identifier_info (a41v, ln_name);
ak40char_info       (a41v, cak_ln_type, mxsp_c8);
ak40identifier_info (a41v, ln_variable);
ak40char_info       (a41v, ln_property, mxsp_c6);
ak40char_info       (a41v, cak_ln_datatype,   mxsp_c10);
ak40numeric_info    (a41v, cak_ln_length,     mxsp_c4);
ak40numeric_info    (a41v, cak_ln_frac,       mxsp_c3);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40_u_domain (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_owner);
ak40identifier_info (a41v, cak_ln_domainname);
ak40char_info       (a41v, cak_ln_columntype, mxsp_c3);
ak40char_info       (a41v, cak_ln_datatype  , mxsp_c10);
ak40char_info       (a41v, ln_code          , mxsp_c8);
ak40numeric_info    (a41v, cak_ln_length,     mxsp_c4);
ak40numeric_info    (a41v, cak_ln_frac  ,     mxsp_c3);
ak40byte_info    (a41v, ln_type_uid, mxsp_c16);
ak40date_info    (a41v, cak_ln_date);
ak40time_info    (a41v, cak_ln_time);
ak40char_info    (a41v, cak_ln_default,    cak_maxfieldlength);
ak40char_info    (a41v, ln_defaultfunction,mxsp_c12);
ak40long_info (a41v, ln_definition);
ak40comment_info (a41v)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40privileges (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, ln_owner);
ak40identifier_info (a41v, ln_name1);
ak40identifier_info (a41v, ln_name2);
ak40char_info       (a41v, cak_ln_type,       mxsp_c8  );
ak40identifier_info (a41v, ln_grantee);
ak40identifier_info (a41v, ln_granteeowner);
ak40char_info       (a41v, cak_ln_privileges, mxsp_c30);
ak40identifier_info (a41v, cak_ln_grantor);
ak40date_info       (a41v, cak_ln_date);
ak40time_info       (a41v, cak_ln_time);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40priv_granted_to (VAR a41v : tak40_show_glob);
 
BEGIN
ak40identifier_info (a41v, ln_schemaname);
ak40identifier_info (a41v, cak_ln_tablename);
ak40identifier_info (a41v, cak_ln_columnname);
ak40identifier_info (a41v, cak_ln_username);
ak40char_info       (a41v, cak_ln_privileges, mxsp_c30);
ak40identifier_info (a41v, cak_ln_grantor);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40sequence_expl_row (
            VAR acv  : tak_all_command_glob;
            VAR line : tsp00_Line;
            change_to_unicode : boolean); (* h.b. PTS 1105127 *)
 
VAR
      j      : integer;
      row_no : integer;
      pos    : integer;
      ln     : tak40_show_record;
 
BEGIN
IF  acv.a_explain_kind = ex_sequence
THEN
    BEGIN
    acv.a_show_last_key := succ(acv.a_show_last_key);
    (* h.b. PTS 1105384 *)
    s20int4_to_buf_swap (acv.a_show_last_key, g01code.kernel_swap,
          ln.shkey, 1, sw_normal);
    (* h.b. PTS 1105127 *)
    pos := 1;
    IF  g01unicode
    THEN
        ln.shinfo [pos] := csp_unicode_def_byte
    ELSE
        ln.shinfo [pos] := bsp_c1;
    (*ENDIF*) 
    pos  := pos + 1;
    IF  g01unicode AND
        change_to_unicode
    THEN
        BEGIN
        FOR j := 1 TO cak_maxtextlength DO
            BEGIN
            ln.shinfo[pos  ] := csp_unicode_mark;
            ln.shinfo[pos+1] := line[j];
            pos := pos + 2;
            END;
        (*ENDFOR*) 
        END
    ELSE
        BEGIN
        SAPDB_PascalForcedMove (cak_maxtextlength, sizeof(ln.shinfo), @line, 1,
              @ln.shinfo, pos, cak_maxtextlength);
        pos := pos + cak_maxtextlength;
        IF  g01unicode
        THEN
            BEGIN
            SAPDB_PascalForcedUnicodeFill (sizeof(ln.shinfo), @ln.shinfo, pos,
                  cak_maxtextlength, csp_unicode_blank);
            pos := pos + cak_maxtextlength;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    ln.shsl := pos + shinfooffset - 1;
    ln.shkl := 4;
    ln.shvarcol_offset := 0;
    ln.shvarcol_cnt    := 0;
    ak40cadd_expl_record (acv, ln);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40SetAllObjects(
            VAR acv      : tak_all_command_glob;
            VAR a41v     : tak40_show_glob); (* PTS 1109359 *)
 
BEGIN
a41v.a4all_objects  := (a41v.a4sh_kind in [sh_all_object,    sh_all_column,
      sh_all_constraint,     sh_all_cons_columns, sh_all_foreign_key,
      sh_all_index,          sh_all_priv_granted,
      sh_all_procedures,     sh_all_sequences,    sh_all_synonyms,
      sh_all_table,          sh_all_triggers,     sh_all_user,
      sh_all_views,          sh_all_ref_columns,
      sh_all_new_privileges, sh_all_view_uses_table, sh_show_view])
      OR
      (
      (* PTS 1115025 E.Z. *)
      ( acv.a_comp_type = at_db_manager) AND
      (a41v.a4sh_kind in [ sh_object,    sh_column,
      sh_constraint,     sh_cons_columns, sh_link,
      sh_index,
      sh_procedure,      sh_sequence,     sh_synonym,
      sh_table,          sh_trigger,
      sh_view,           sh_ref_column,
      sh_new_privileges, sh_view_uses_table]))
      OR
      ((acv.a_curr_user_name = a01_i_domain) AND
      ( a41v.a4sh_kind = sh_table))
      OR
      ((a41v.a4sh_kind = sh_trigger) AND acv.a_isReplicationUser)
      OR
      (* PTS 1134676 M.Ki. *)
      ((acv.a_current_user_kind = usysdba) AND
      ( a41v.a4sh_kind in [sh_table, sh_index]))
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40site (
            VAR acv              : tak_all_command_glob;
            VAR a41v             : tak40_show_glob;
            VAR siteserverdbname : tsp00_DbName;
            VAR siteid           : tsp00_NodeId);
 
VAR
      h_db   : tsp00_DbName;
      h_node : tsp00_NodeId;
      i      : integer;
      j      : integer;
 
BEGIN
IF  g01unicode
THEN
    BEGIN
    j := 1;
    FOR i := 1 TO sizeof(siteserverdbname) DIV 2 DO
        BEGIN
        h_db [ j   ] := csp_unicode_mark;
        h_db [ j+1 ] := siteserverdbname[ i ];
        j := j + 2
        END;
    (*ENDFOR*) 
    a40move (acv, a41v, @h_db, sizeof(h_db));
    j := 1;
    FOR i := 1 TO sizeof(siteid) DIV 2 DO
        BEGIN
        h_node [ j   ] := csp_unicode_mark;
        h_node [ j+1 ] := siteid[ i ];
        j := j + 2
        END;
    (*ENDFOR*) 
    a40move (acv, a41v, @h_node, sizeof(h_node))
    END
ELSE
    BEGIN
    a40move (acv, a41v, @siteserverdbname,
          sizeof(siteserverdbname));
    a40move (acv, a41v, @siteid, sizeof (siteid))
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40add_explain_record (
            VAR acv     : tak_all_command_glob;
            VAR exp_rec : tak71_explain_rec);
 
VAR
      j      : integer;
      pos    : integer;
      c10    : tsp00_C10;
      ln     : tak40_show_record;
 
BEGIN
IF  ( acv.a_explain_kind = ex_default )
THEN
    BEGIN
    acv.a_show_last_key := succ( acv.a_show_last_key );
    (* h.b. PTS 1105384 *)
    s20int4_to_buf_swap( acv.a_show_last_key, g01code.kernel_swap,
          ln.shkey, 1, sw_normal );
    pos := 1;
    ak40add_expl_moveobj (ln, pos, @exp_rec.exp_user,
          a01identifier_size, NOT c_change_to_unicode);
    ak40add_expl_moveobj (ln, pos, @exp_rec.exp_table,
          a01identifier_size, NOT c_change_to_unicode);
    ak40add_expl_moveobj (ln, pos, @exp_rec.exp_column,
          a01identifier_size, NOT c_change_to_unicode);
    ak40add_expl_moveobj (ln, pos, @exp_rec.exp_strat,
          sizeof( exp_rec.exp_strat ), c_change_to_unicode);
    j := pos;
    IF  exp_rec.exp_pagecount < csp_maxint4
    THEN
        BEGIN
        IF  ( exp_rec.exp_pagecount < 0 )
        THEN
            BEGIN
            c10 := '          ';
            ak40add_expl_moveobj (ln, pos, @c10, mxsp_c10, c_change_to_unicode);
            END
        ELSE
            BEGIN
            ak40int4_to_shinfo( exp_rec.exp_pagecount,
                  pos, mxsp_c10, 0, false, ln.shinfo );
            pos := pos + a01char_size * mxsp_c10 + csp_attr_byte;
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        c10 := '   > 2 E10';
        ak40add_expl_moveobj( ln, pos, @c10, mxsp_c10, c_change_to_unicode );
        END;
    (*ENDIF*) 
    ln.shsl := pos + shinfooffset - 1;
    ln.shkl := 4;
    ln.shvarcol_offset := 0;
    ln.shvarcol_cnt    := 0;
    ak40cadd_expl_record (acv, ln);
    IF  g01vtrace.vtrStrategy_gg00
    THEN
        g041explain_trace (acv.a_transinf.tri_trans, ln.shinfo);
    (*ENDIF*) 
    IF  ( exp_rec.exp_flags <> [] )
    THEN
        BEGIN
        pos := j;
        c10 := '          ';
        ak40add_expl_moveobj (ln, pos, @c10, mxsp_c10, c_change_to_unicode);
        pos := 1;
        ak40add_expl_moveobj (ln, pos, @a01_il_b_identifier,
              a01identifier_size, NOT c_change_to_unicode);
        ak40add_expl_moveobj (ln, pos, @a01_il_b_identifier,
              a01identifier_size, NOT c_change_to_unicode);
        ak40add_expl_moveobj (ln, pos, @a01_il_b_identifier,
              a01identifier_size, NOT c_change_to_unicode);
        j := pos;
        IF  ( exp_only_inv in exp_rec.exp_flags )
        THEN
            BEGIN
            acv.a_show_last_key := succ( acv.a_show_last_key );
            s20int4_to_buf_swap( acv.a_show_last_key, g01code.kernel_swap,
                  ln.shkey, 1, sw_normal );
            pos := j;
            ak40add_expl_moveobj (ln, pos,
                  @'ONLY INDEX ACCESSED                     ',  40, c_change_to_unicode);
            ak40cadd_expl_record (acv, ln);
            END;
        (*ENDIF*) 
        IF  ( exp_distinct_A in exp_rec.exp_flags )
        THEN
            BEGIN
            acv.a_show_last_key := succ( acv.a_show_last_key );
            s20int4_to_buf_swap( acv.a_show_last_key, g01code.kernel_swap,
                  ln.shkey, 1, sw_normal );
            pos := j;
            ak40add_expl_moveobj (ln, pos,
                  @'DISTINCT OPTIMIZATION (A)               ', 40, c_change_to_unicode);
            ak40cadd_expl_record (acv, ln);
            END;
        (*ENDIF*) 
        IF  ( exp_distinct_P in exp_rec.exp_flags )
        THEN
            BEGIN
            acv.a_show_last_key := succ( acv.a_show_last_key );
            s20int4_to_buf_swap( acv.a_show_last_key, g01code.kernel_swap,
                  ln.shkey, 1, sw_normal );
            pos := j;
            ak40add_expl_moveobj (ln, pos,
                  @'DISTINCT OPTIMIZATION (P)               ', 40, c_change_to_unicode);
            ak40cadd_expl_record (acv, ln);
            END;
        (*ENDIF*) 
        IF  ( exp_distinct_C in exp_rec.exp_flags )
        THEN
            BEGIN
            acv.a_show_last_key := succ( acv.a_show_last_key );
            s20int4_to_buf_swap( acv.a_show_last_key, g01code.kernel_swap,
                  ln.shkey, 1, sw_normal );
            pos := j;
            ak40add_expl_moveobj (ln, pos,
                  @'DISTINCT OPTIMIZATION (C)               ', 40, c_change_to_unicode);
            ak40cadd_expl_record (acv, ln);
            END;
        (*ENDIF*) 
        IF  ( exp_distinct_K in exp_rec.exp_flags )
        THEN
            BEGIN
            acv.a_show_last_key := succ( acv.a_show_last_key );
            s20int4_to_buf_swap( acv.a_show_last_key, g01code.kernel_swap,
                  ln.shkey, 1, sw_normal );
            pos := j;
            ak40add_expl_moveobj (ln, pos,
                  @'DISTINCT OPTIMIZATION (K)               ', 40, c_change_to_unicode);
            ak40cadd_expl_record (acv, ln);
            END;
        (*ENDIF*) 
        IF  ( exp_temp_inv in exp_rec.exp_flags )
        THEN
            BEGIN
            acv.a_show_last_key := succ( acv.a_show_last_key );
            s20int4_to_buf_swap( acv.a_show_last_key, g01code.kernel_swap,
                  ln.shkey, 1, sw_normal );
            pos := j;
            ak40add_expl_moveobj (ln, pos,
                  @'TEMPORARY INDEX CREATED                 ', 40, c_change_to_unicode);
            ak40cadd_expl_record (acv, ln);
            END;
        (*ENDIF*) 
        IF  ( exp_qual_on_inv in exp_rec.exp_flags )
        THEN
            BEGIN
            acv.a_show_last_key := succ( acv.a_show_last_key );
            s20int4_to_buf_swap( acv.a_show_last_key, g01code.kernel_swap,
                  ln.shkey, 1, sw_normal );
            pos := j;
            ak40add_expl_moveobj (ln, pos,
                  @'ADDNL. QUALIFICATION ON INDEX           ', 40, c_change_to_unicode);
            ak40cadd_expl_record (acv, ln);
            END;
        (*ENDIF*) 
        IF  ( exp_MIN_MAX_opt in exp_rec.exp_flags ) OR
            ( exp_inv_key_MIN_MAX_opt in exp_rec.exp_flags )
        THEN
            BEGIN
            acv.a_show_last_key := succ( acv.a_show_last_key );
            s20int4_to_buf_swap( acv.a_show_last_key, g01code.kernel_swap,
                  ln.shkey, 1, sw_normal );
            pos := j;
            ak40add_expl_moveobj (ln, pos,
                  @'MIN/MAX OPTIMIZATION                    ', 40, c_change_to_unicode);
            ak40cadd_expl_record (acv, ln);
            END;
        (*ENDIF*) 
        IF  ( exp_parallel_index in exp_rec.exp_flags )
        THEN
            BEGIN
            acv.a_show_last_key := succ( acv.a_show_last_key );
            s20int4_to_buf_swap( acv.a_show_last_key, g01code.kernel_swap,
                  ln.shkey, 1, sw_normal );
            pos := j;
            ak40add_expl_moveobj (ln, pos,
                  @'PARALLEL INDEX ACCESS                   ', 40, c_change_to_unicode);
            ak40cadd_expl_record (acv, ln);
            END;
        (*ENDIF*) 
        IF  ( exp_hash_join in exp_rec.exp_flags )
        THEN
            BEGIN
            acv.a_show_last_key := succ( acv.a_show_last_key );
            s20int4_to_buf_swap( acv.a_show_last_key, g01code.kernel_swap,
                  ln.shkey, 1, sw_normal );
            pos := j;
            ak40add_expl_moveobj (ln, pos,
                  @'TABLE HASHED                            ', 40, c_change_to_unicode);
            ak40cadd_expl_record (acv, ln);
            END;
        (*ENDIF*) 
        IF  ( exp_sorted_access in exp_rec.exp_flags )
        THEN
            BEGIN
            acv.a_show_last_key := succ( acv.a_show_last_key );
            s20int4_to_buf_swap( acv.a_show_last_key, g01code.kernel_swap,
                  ln.shkey, 1, sw_normal );
            pos := j;
            ak40add_expl_moveobj (ln, pos,
                  @'TABLE TEMPORARY SORTED                  ', 40, c_change_to_unicode);
            ak40cadd_expl_record (acv, ln);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40add_expl_moveobj (
            VAR ln            : tak40_show_record;
            VAR pos           : integer;
            moveobj_ptr       : tsp00_MoveObjPtr;
            moveobj_len       : integer;
            change_to_unicode : boolean);
 
VAR
      e  : tgg00_BasisError;
      ix : integer;
 
BEGIN
(* PTS 1107655 ff. E.Z. *)
e := e_ok;
IF  g01unicode
THEN
    BEGIN
    ln.shinfo[pos] := csp_unicode_def_byte;
    IF  change_to_unicode
    THEN
        BEGIN
        pos            := pos + 1;
        FOR ix := 1 TO moveobj_len DO
            BEGIN
            ln.shinfo[pos  ] := csp_unicode_mark;
            ln.shinfo[pos+1] := moveobj_ptr^[ix];
            pos := pos + 2
            END;
        (*ENDFOR*) 
        END
    ELSE
        BEGIN
        SAPDB_PascalMove ('VAK40 ',   1,
              moveobj_len, sizeof(ln.shinfo), moveobj_ptr, 1,
              @ln.shinfo, pos + 1, moveobj_len, e);
        pos := pos + moveobj_len + 1
        END
    (*ENDIF*) 
    END
ELSE
    BEGIN
    ln.shinfo [pos] := bsp_c1;
    SAPDB_PascalMove ('VAK40 ',   2,
          moveobj_len, sizeof(ln.shinfo), moveobj_ptr, 1,
          @ln.shinfo, pos + 1, moveobj_len, e);
    pos := pos + moveobj_len + 1
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40cadd_expl_record (
            VAR acv      : tak_all_command_glob;
            VAR expl_rec : tak40_show_record);
 
BEGIN
IF  acv.a_resname_addr[cak_extern_pos] <> NIL
THEN
    BEGIN
&   IFDEF TRACE
    t01buf (ak_sem, expl_rec, 1, expl_rec.shsl);
&   ENDIF
    IF  acv.a_resname_addr[cak_extern_pos]^.sresname.restreeid.fileRoot_gg00 =
        NIL_PAGE_NO_GG00
    THEN
        BEGIN
        a663create_result_file (acv, m_create_table,
              acv.a_resname_addr[cak_extern_pos]^.sresname.restreeid);
        IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
        THEN
            WITH acv.a_resname_addr[cak_extern_pos]^.sresname DO
                BEGIN
                resstate         := resstate + [rs_result, rs_reuseable];
                reseparsk.p_kind := m_show
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    b07cadd_record (acv.a_transinf.tri_trans,
          acv.a_resname_addr[cak_extern_pos]^.sresname.restreeid,
          expl_rec)
    END
ELSE
    acv.a_transinf.tri_trans.trError_gg00 := e_sysinfo_not_found;
(*ENDIF*) 
IF  (acv.a_transinf.tri_trans.trError_gg00 <> e_ok)
THEN
    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40join_expl_row (
            VAR acv            : tak_all_command_glob;
            VAR strat          : tsp00_C40;
            VAR owner          : tsp00_KnlIdentifier;
            VAR table          : tsp00_KnlIdentifier;
            recs_found         : tsp00_Longreal;
            multiplier         : tsp00_Longreal;
            reverse_multiplier : tsp00_Longreal; (* h.b. PTS 1106350 *)
            new_left_size      : tsp00_Longreal;
            new_left_recs      : tsp00_Longreal;
            costs              : tsp00_Longreal);
 
CONST
      c_max_r = 6; (* h.b. PTS 1106350 *)
 
VAR
      res      : tsp00_NumError;
      j        : integer;
      pos      : integer;
      real_arr : ARRAY[1..c_max_r] OF tsp00_Longreal;
      ln       : tak40_show_record;
 
BEGIN
IF  acv.a_explain_kind = ex_join
THEN
    BEGIN
    acv.a_show_last_key := succ(acv.a_show_last_key);
    (* h.b. PTS 1105384 *)
    s20int4_to_buf_swap (acv.a_show_last_key, g01code.kernel_swap,
          ln.shkey, 1, sw_normal);
    pos               := 1;
    ak40add_expl_moveobj (ln, pos, @strat, sizeof(strat),
          c_change_to_unicode);
    ak40add_expl_moveobj (ln, pos, @owner, a01identifier_size,
          NOT c_change_to_unicode);
    ak40add_expl_moveobj (ln, pos, @table, a01identifier_size,
          NOT c_change_to_unicode);
    real_arr[1] := recs_found;
    real_arr[2] := multiplier;
    real_arr[3] := reverse_multiplier; (* h.b. PTS 1106350 *)
    real_arr[4] := new_left_size;
    real_arr[5] := new_left_recs;
    real_arr[6] := costs;
    FOR j := 1 TO c_max_r DO
        BEGIN
        ln.shinfo [pos] := csp_defined_byte;
        s41plrel (ln.shinfo, pos + 1, 18, csp_float_frac,
              real_arr[j], res);
        pos := pos + csp_attr_byte + (18+1) DIV 2 + 1
        END;
    (*ENDFOR*) 
    ln.shsl := pos + shinfooffset - 1;
    ln.shkl := 4;
    ln.shvarcol_offset := 0;
    ln.shvarcol_cnt    := 0;
    ak40cadd_expl_record (acv, ln)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40add_row (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      found : boolean;
      i     : integer;
 
BEGIN
a41v.a4sh_buf.shvarcol_offset := a41v.a4sh_buf.shsl;
a41v.a4sh_buf.shvarcol_cnt    := 0;
a41v.a4sh_buf.shkl  := a41v.a4sh_buf.shkl + showkeylen;
a41v.a4sh_buf.shsl  := cgg_rec_key_offset + a41v.a4sh_buf.shkl + a41v.a4sh_buf.shsl;
found := false;
i     := showkeylen;
REPEAT
    IF  ord(a41v.a4sh_key[ i ]) < 255
    THEN
        BEGIN
        found       := true;
        a41v.a4sh_key[i] := succ (a41v.a4sh_key[i]);
        END
    ELSE
        BEGIN
        a41v.a4sh_key[i] := chr(0);
        IF  i = 1
        THEN
            BEGIN
            a41v.a4sh_key[showkeylen] := chr(1);
            found := true;
            END
        ELSE
            i := i - 1
        (*ENDIF*) 
        END;
    (*ENDIF*) 
UNTIL
    found;
(*ENDREPEAT*) 
&ifdef trace
t01buf (ak_sem, a41v.a4sh_buf, 1, a41v.a4sh_buf.shsl);
&endif
&IFDEF TRACE
IF  a41v.a4mblock.mb_data^.mbp_reclen > 0
THEN
    t01buf1 (ak_sem, a41v.a4mblock.mb_data^.mbp_rec.buf, 1,
          a41v.a4mblock.mb_data^.mbp_reclen);
(*ENDIF*) 
t01qual (ak_sem, acv.a_mblock.mb_qual^);
&ENDIF
a41v.a4sh_buf.shkey                 := a41v.a4sh_key;
a41v.a4sel^.sfp_first_qual := true;
acv.a_mblock.mb_trns      := @acv.a_transinf.tri_trans;
k721catalog_add_into_result (acv.a_mblock, a41v.a4sel^,
      a41v.a4sel_param^, a41v.a4get_param^, a41v.a4sh_buf,
      a41v.a4res_buf_ptr^.mbp_rec, acv.a_show_last_key);
IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
THEN
    acv.a_show_last_key := succ(acv.a_show_last_key)
ELSE
    IF  acv.a_transinf.tri_trans.trError_gg00 <> e_duplicate_key
    THEN
        a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
    (*ENDIF*) 
(*ENDIF*) 
ak40new_row (a41v);
&ifdef trace
;
t01int4 (ak_sem, 'a4index 2   ', a41v.a4index);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40default (
            VAR acv         : tak_all_command_glob;
            VAR a41v        : tak40_show_glob;
            VAR colinfo     : tak00_columninfo;
            VAR defaultrec  : tak_defaultrecord);
 
CONST
      c_do_move = true;
      c_number_buffer_size = 1 + NUMBER_MXSP00;
 
VAR
      text         : tsp00_C20;
      functionText : tsp00_C12;
      c256         : tsp00_C256;
      number       : ARRAY[1..c_number_buffer_size] OF char;
      ix           : integer;
      valLen       : integer;
      pVal         : ^tsp00_C256;
      dummylen     : integer;
      dummyok      : boolean;
 
BEGIN
WITH colinfo DO
    BEGIN
    functionText := bsp_c12;
    IF  (defaultrec.dfdefault_function <> 0) (* h.b. PTS 1000978 *)
        AND NOT (cdatatyp in [dstra, dstrb,
        dlonga, dlongb, dlonguni, dstruni])
    THEN
        BEGIN
        (* PTS 1122484 E.Z. *)
        CASE defaultrec.dfdefault_function OF
            cak_x_date  :
                BEGIN
                text := 'DEFAULT DATE        ';
                functionText := 'DATE        ';
                END;
            cak_x_stamp :
                BEGIN
                text := 'DEFAULT STAMP       ';
                functionText := 'STAMP       ';
                END;
            cak_x_time  :
                BEGIN
                text := 'DEFAULT TIME        ';
                functionText := 'TIME        ';
                END;
            cak_x_timestamp :
                (* PTS 1105367 E.Z. *)
                IF  acv.a_sqlmode = sqlm_oracle
                THEN
                    BEGIN
                    text := 'DEFAULT DATE        ';
                    functionText := 'DATE        ';
                    END
                ELSE
                    BEGIN
                    text := 'DEFAULT TIMESTAMP   ';
                    functionText := 'TIMESTAMP   ';
                    END;
                (*ENDIF*) 
            cak_x_uid   :
                BEGIN
                text := 'DEFAULT UID         ';
                functionText := 'UID         ';
                END;
            cak_x_user  :
                BEGIN
                text := 'DEFAULT USER        ';
                functionText := 'USER        ';
                END;
            cak_x_transaction :
                BEGIN
                text := 'DEFAULT TRANSACTION ';
                functionText := 'TRANSACTION ';
                END;
            cak_x_true  :
                text := 'TRUE                ';
            cak_x_false :
                text := 'FALSE               ';
            cak_x_utcdate :
                BEGIN
                text := 'DEFAULT UTCDATE     ';
                functionText := 'UTCDATE     ';
                END;
            cak_x_utcdiff :
                BEGIN
                text := 'DEFAULT UTCDIFF     ';
                functionText := 'UTCDIFF     ';
                END;
            cak_x_timezone :
                BEGIN
                text := 'DEFAULT TIMEZONE    ';
                functionText := 'TIMEZONE    ';
                END;
            cak_x_sysdba :
                BEGIN
                text := 'DEFAULT SYSDBA      ';
                functionText := 'SYSDBA      ';
                END;
            OTHERWISE
                BEGIN
                text := 'DEFAULT USERGROUP   ';
                functionText := 'USERGROUP   ';
                END;
            END;
        (*ENDCASE*) 
        a40move_const (acv, a41v, @text, sizeof (text))
        END
    ELSE
        BEGIN
        (* PTS 1106642 *)
        valLen := a14LengthOfDefaultValue(defaultrec);
        IF  (colinfo.cdatatyp in [dfixed, dfloat]) AND
            (valLen <> colinfo.cinoutlen)
        THEN
            BEGIN
            FOR ix := 1 TO colinfo.cinoutlen DO
                number[ix] := chr(0);
            (*ENDFOR*) 
            FOR ix := 1 TO valLen DO
                number[ix] := defaultrec.dfvalues[ix+1];
            (*ENDFOR*) 
            valLen := colinfo.cinoutlen;
            pVal   := @number
            END
        ELSE
            BEGIN
            pVal   := @defaultrec.dfvalues[2];
            END;
        (*ENDIF*) 
        (* END PTS PTS 1106642 *)
        IF  valLen > 255
        THEN
            valLen := 255;
        (*ENDIF*) 
        a40put_one_value (acv, a41v, colinfo, c_do_move,
              pVal^, 1, valLen, c256, dummylen, dummyok)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  functionText <> bsp_c12
THEN
    a40move_const (acv, a41v, @functionText, sizeof (functionText))
ELSE
    a40move (acv, a41v, NIL, 0)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40put_one_value (
            VAR acv      : tak_all_command_glob;
            VAR a41v     : tak40_show_glob;
            VAR col_info : tak00_columninfo;
            do_move      : boolean;
            VAR valbuf   : tsp00_C256;
            valpos       : integer;
            vallen       : integer;
            VAR destbuf  : tsp00_C256;
            VAR destlen  : integer;
            VAR ok       : boolean);
 
CONST
      c_true   = 'TRUE        ';
      c_false  = 'FALSE       ';
 
VAR
      trunc     : boolean;
      e         : tgg00_BasisError;
      res       : tsp00_NumError;
      i         : integer;
      text      : tsp00_Sname;
      unihbuf   : tsp00_Buf;
      unierr    : tsp8_uni_error;
      unilen    : tsp00_Int4;
      unierrpos : tsp00_Int4;
 
BEGIN
ok := true;
WITH col_info DO
    CASE cdatatyp OF
        dboolean :
            BEGIN
            IF  valbuf [valpos + 1] = cgg04_truechar
            THEN
                text := c_true
            ELSE
                text := c_false;
            (*ENDIF*) 
            IF  do_move
            THEN
                a40move_const (acv, a41v, @text, sizeof (text))
            ELSE
                SAPDB_PascalMove ('VAK40 ',   3,
                      sizeof (text), sizeof (destbuf), @text, 1,
                      @destbuf, 1, sizeof (text),
                      acv.a_returncode);
            (*ENDIF*) 
            vallen := s30klen (text, bsp_c1, sizeof (text))
            END;
        dfixed, dfloat :
            BEGIN
            s42gstr (valbuf, valpos + 1, cdatalen,
                  cdatafrac - cak_frac_offset, cdatalen,
                  destbuf, 1, vallen, res);
            ok := (res = num_ok);
            IF  do_move
            THEN
                a40move_const (acv, a41v, @destbuf, vallen)
            (*ENDIF*) 
            END;
        dcha, ddate, dtime, dtimestamp, dstra, dlonga : (* h.b. PTS 1000978 *)
            BEGIN
            e       := e_ok;
            CASE cdatatyp OF
                ddate :
                    BEGIN
                    FOR i := 1 TO mxsp_extdate DO
                        destbuf[i] := bsp_c1;
                    (*ENDFOR*) 
                    g03dchange_format_date (valbuf,
                          destbuf, valpos + 1, 1, acv.a_dt_format, e);
                    IF  e = e_ok
                    THEN
                        BEGIN
                        vallen := mxsp_extdate;
                        WHILE destbuf[vallen] = bsp_c1 DO
                            vallen := pred(vallen)
                        (*ENDWHILE*) 
                        END
                    (*ENDIF*) 
                    END;
                dtime :
                    BEGIN
                    FOR i := 1 TO mxsp_exttime DO
                        destbuf[i] := bsp_c1;
                    (*ENDFOR*) 
                    g03tchange_format_time (valbuf,
                          destbuf, valpos + 1, 1, acv.a_dt_format, e);
                    IF  e = e_ok
                    THEN
                        BEGIN
                        vallen := mxsp_exttime;
                        WHILE destbuf[vallen] = bsp_c1 DO
                            vallen := pred(vallen)
                        (*ENDWHILE*) 
                        END;
                    (*ENDIF*) 
                    END;
                dtimestamp :
                    BEGIN
                    FOR i := 1 TO mxsp_exttimestamp DO
                        destbuf[i] := bsp_c1;
                    (*ENDFOR*) 
                    g03tschange_format_timestamp (valbuf,
                          destbuf, valpos + 1, 1, acv.a_dt_format,
                          acv.a_ak_language, e);
                    IF  e = e_ok
                    THEN
                        BEGIN
                        vallen := mxsp_exttimestamp;
                        WHILE destbuf[vallen] = bsp_c1 DO
                            vallen := pred(vallen)
                        (*ENDWHILE*) 
                        END;
                    (*ENDIF*) 
                    END;
                OTHERWISE
                    BEGIN (* h.b. PTS 1000978 *)
                    IF  NOT (cdatatyp in [dstra, dlonga])
                    THEN
                        BEGIN
                        valpos := valpos + 1;
                        vallen := vallen - 1;
                        END;
                    (*ENDIF*) 
                    IF  do_move AND (g01code.ctype = csp_ascii)
                    THEN
                        BEGIN
                        a40move_const (acv, a41v,
                              @valbuf[valpos], vallen);
                        do_move := false
                        END
                    ELSE
                        SAPDB_PascalMove ('VAK40 ',   4,
                              sizeof (valbuf), sizeof (destbuf),
                              @valbuf, valpos, @destbuf, 1, vallen,
                              acv.a_returncode)
                    (*ENDIF*) 
                    END;
                END;
            (*ENDCASE*) 
            ok := (e = e_ok);
            IF  e <> e_ok
            THEN
                BEGIN
                IF  do_move
                THEN
                    a07ak_system_error (acv, 40, 1);
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  do_move
                THEN
                    a40move_const (acv, a41v, @destbuf[1], vallen)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        dunicode, dlonguni, dstruni :
            BEGIN
            IF  NOT (cdatatyp in [dlonguni, dstruni])
            THEN
                BEGIN
                valpos := valpos + 1;
                vallen := vallen - 1;
                END;
            (*ENDIF*) 
            IF  do_move
            THEN
                a40move (acv, a41v, @valbuf[valpos], vallen)
            ELSE
                BEGIN
                unilen := sizeof (unihbuf);
                s80uni_trans (@valbuf[valpos], vallen, csp_unicode,
                      @unihbuf, unilen,
                      acv.a_cmd_packet_header.sp1h_mess_code,
                      [ ], unierr, unierrpos);
                IF  unierr = uni_ok
                THEN
                    SAPDB_PascalMove ('VAK40 ',   5,
                          sizeof (valbuf), sizeof (destbuf),
                          @valbuf, valpos, @destbuf, 1, vallen,
                          acv.a_returncode)
                ELSE
                    ok := (unierr = uni_ok);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        dchb, dstrb, dlongb : (* h.b. PTS 1000978 *)
            BEGIN
            s40gbyte (valbuf, valpos + 1, vallen - 1,
                  destbuf, 1, (vallen - 1) * 2, trunc);
            vallen := (vallen - 1) * 2;
            IF  do_move
            THEN
                a40move_const (acv, a41v, @destbuf[1], vallen)
            (*ENDIF*) 
            END;
        END;
    (*ENDCASE*) 
(*ENDWITH*) 
destlen := vallen;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40_p_priv (
            VAR pr  : tak_privilege;
            VAR prn : tsp00_C40;
            colno   : tsp00_Int2);
 
BEGIN
WITH pr DO
    BEGIN
&   IFDEF TRACE
    a06td_priv (pr, 'p_priv            ', true);
&   ENDIF
    prn := bsp_c40;
    IF  r_alter in priv_all_set
    THEN
        BEGIN
        prn[ 25 ] := 'A';
        prn[ 26 ] := 'L';
        prn[ 27 ] := 'T';
        IF  r_alter in priv_all_grant_set
        THEN
            prn[ 28 ] := '+'
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  r_index in priv_all_set
    THEN
        BEGIN
        prn[ 21 ] := 'I';
        prn[ 22 ] := 'N';
        prn[ 23 ] := 'D';
        IF  r_index in priv_all_grant_set
        THEN
            prn[ 24 ] := '+'
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  r_link in priv_all_set
    THEN
        BEGIN
        prn[ 17 ] := 'R';
        prn[ 18 ] := 'E';
        prn[ 19 ] := 'F';
        IF  r_link in priv_all_grant_set
        THEN
            prn[ 20 ] := '+'
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  r_ins  in priv_all_set
    THEN
        BEGIN
        prn[ 13 ] := 'I';
        prn[ 14 ] := 'N';
        prn[ 15 ] := 'S';
        IF  r_ins in priv_all_grant_set
        THEN
            prn[ 16 ] := '+'
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  r_del  in priv_all_set
    THEN
        BEGIN
        prn[  9 ] := 'D';
        prn[ 10 ] := 'E';
        prn[ 11 ] := 'L';
        IF  r_del in priv_all_grant_set
        THEN
            prn[ 12 ] := '+'
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  r_upd   in priv_all_set
    THEN
        BEGIN
        prn[ 5 ] := 'U';
        prn[ 6 ] := 'P';
        prn[ 7 ] := 'D';
        IF  r_upd in priv_all_grant_set
        THEN
            prn[ 8 ] := '+'
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  r_sel  in priv_all_set
    THEN
        BEGIN
        prn[ 1 ] := 'S';
        prn[ 2 ] := 'E';
        prn[ 3 ] := 'L';
        IF  r_sel in priv_all_grant_set
        THEN
            prn[ 4 ] := '+'
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  priv_col_exist <> [  ]
    THEN
        BEGIN
        IF  colno > 0
        THEN
            BEGIN
            IF  (priv_col_upd in priv_col_exist) OR
                (priv_col_upd_grant in priv_col_exist)
            THEN
                IF  colno  in priv_upd_set + priv_grant_upd_set
                THEN
                    BEGIN
                    prn[ 5 ] := 'U';
                    prn[ 6 ] := 'P';
                    prn[ 7 ] := 'D';
                    IF  priv_col_upd_grant in priv_col_exist
                    THEN
                        IF  colno in priv_grant_upd_set
                        THEN
                            prn[ 8 ] := '+'
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  (priv_col_sel in priv_col_exist) OR
                (priv_col_sel_grant in priv_col_exist)
            THEN
                IF  colno  in priv_sel_set + priv_grant_sel_set
                THEN
                    BEGIN
                    prn[ 1 ] := 'S';
                    prn[ 2 ] := 'E';
                    prn[ 3 ] := 'L';
                    IF  priv_col_sel_grant in priv_col_exist
                    THEN
                        IF  colno in priv_grant_sel_set
                        THEN
                            prn[ 4 ] := '+'
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  (priv_col_ref in priv_col_exist) OR
                (priv_col_ref_grant in priv_col_exist)
            THEN
                IF  colno  in priv_ref_set + priv_grant_ref_set
                THEN
                    BEGIN
                    prn[ 1 ] := 'R';
                    prn[ 2 ] := 'E';
                    prn[ 3 ] := 'F';
                    IF  priv_col_ref_grant in priv_col_exist
                    THEN
                        IF  colno in priv_grant_ref_set
                        THEN
                            prn[ 4 ] := '+'
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            IF  colno = 0
            THEN
                BEGIN
                IF  priv_col_upd in priv_col_exist
                THEN
                    BEGIN
                    prn[ 5 ] := 'U';
                    prn[ 6 ] := 'P';
                    prn[ 7 ] := 'D';
                    prn[ 8 ] := '-';
                    END;
                (*ENDIF*) 
                IF  priv_col_sel in priv_col_exist
                THEN
                    BEGIN
                    prn[ 1 ] := 'S';
                    prn[ 2 ] := 'E';
                    prn[ 3 ] := 'L';
                    prn[ 4 ] := '-';
                    END;
                (*ENDIF*) 
                IF  priv_col_ref in priv_col_exist
                THEN
                    BEGIN
                    prn[ 1 ] := 'R';
                    prn[ 2 ] := 'E';
                    prn[ 3 ] := 'F';
                    prn[ 4 ] := '-';
                    END;
                (*ENDIF*) 
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak40columnno (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            extcolno : integer) : integer;
 
VAR
      colindex : tsp00_Uint1;
      columnno : integer;
 
BEGIN
columnno := 1;
colindex := a41v.a4p_arr.pbasep^.sbase.bfirstcolind;
REPEAT
    WITH a103GetColumn (a41v.a4p_arr.pbasep^.sbase, colindex)^ DO
        IF  cextcolno = extcolno
        THEN
            colindex := 0
        ELSE
            BEGIN
            colindex := cnextind;
            IF  NOT ((ctdropped in ccolpropset) OR
                (ctinvisible in ccolpropset))
            THEN
                columnno := succ(columnno);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDWITH*) 
UNTIL
    (columnno > a41v.a4p_arr.pbasep^.sbase.bmaxcol)
    OR
    (colindex = 0);
(*ENDREPEAT*) 
IF  columnno <= a41v.a4p_arr.pbasep^.sbase.bmaxcol
THEN
    ak40columnno := columnno
ELSE
    BEGIN
    ak40columnno := a41v.a4p_arr.pbasep^.sbase.bmaxcol;
    a07ak_system_error (acv, 40, 2);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40column_description (
            VAR acv      : tak_all_command_glob;
            VAR a41v     : tak40_show_glob;
            tablekind    : tgg00_TableKind;
            VAR col_info : tak00_columninfo;
            opt_undef    : boolean);
 
VAR
      is_oracle      : boolean;
      pos            : integer;
      datalen        : integer;
      nam            : tsp00_Sname;
      datatype       : tsp00_Sname;
      code           : tsp00_C10;
 
BEGIN
WITH col_info DO
    BEGIN
    (* PTS 1105367 E.Z. *)
    is_oracle := acv.a_sqlmode = sqlm_oracle;
    IF  a41v.a4sh_kind in [sh_column, sh_all_column, sh_odbc_columns]
    THEN
        BEGIN
        SAPDB_PascalMove ('VAK40 ',   6,
              sizeof(ccolumnn), sizeof(a41v.a4sh_buf.shinfo), @ccolumnn, 1,
              @a41v.a4sh_buf.shinfo, 1, ord (ccolumnn_len),
              acv.a_returncode);
        IF  ord (ccolumnn_len) < sizeof (ccolumnn)
        THEN
            SAPDB_PascalMove ('VAK40 ',   7,
                  sizeof (a01_il_b_identifier), sizeof (a41v.a4sh_buf.shinfo),
                  @a01_il_b_identifier, 1, @a41v.a4sh_buf.shinfo, 1 + ord (ccolumnn_len),
                  sizeof (ccolumnn) - ord (ccolumnn_len),
                  acv.a_returncode);
        (*ENDIF*) 
        pos := csp_attr_byte + sizeof (ccolumnn);
        a40table_column_to_shbuf (acv, a41v, a41v.a4p_arr.pbasep, -1, c_with_owner)
        END;
    (*ENDIF*) 
    a40move (acv, a41v, @ccolumnn, ord (ccolumnn_len));
    IF  ((ctkey in ccolpropset) AND
        (tablekind in
        [ twithkey, twithoutkey, tonebase ])) OR
        (ctjoinviewkey in ccolpropset)
    THEN
        BEGIN
        opt_undef := false;
        nam := 'KEY         '
        END
    ELSE
        IF  NOT opt_undef
        THEN
            IF  (ctopt in ccolpropset    ) OR
                (ctdefault in ccolpropset)
            THEN
                nam := 'OPT         '
            ELSE
                nam := 'MAN         ';
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  opt_undef
    THEN
        a40move (acv, a41v, NIL, 0)
    ELSE
        a40move_const (acv, a41v, @nam, 3);
    (*ENDIF*) 
    a40datatype_code (col_info, is_oracle,
          acv.a_comp_type, datatype, code, datalen);
    IF  datatype[1] = bsp_c1
    THEN
        a40move (acv, a41v, NIL, 0)
    ELSE
        a40move_const (acv, a41v, @datatype, sizeof(datatype));
    (*ENDIF*) 
    a40move_const (acv, a41v, @code, sizeof (code));
    a40move_i4    (acv, a41v, datalen,
          datalen = csp_maxint4, 0, NOT c_to_undef);
    a40move_i4 (acv, a41v, cdatafrac - cak_frac_offset,
          cdatatyp <> dfixed, 0, NOT c_to_undef)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40comment_descriptor (
            VAR acv       : tak_all_command_glob;
            VAR a41v      : tak40_show_glob;
            comment_exist : boolean;
            VAR tabid     : tgg00_Surrogate;
            column_no     : integer;
            comment_kind  : tak_comment_type);
 
VAR
      ix          : integer;
      longdesc    : tak_long_descriptor;
      c256        : tsp00_C256;
 
BEGIN
FOR ix := 1 TO 2 DO
    BEGIN
    IF  comment_exist AND
        a41v.a4strategy.str_catalog.scat_col_needed[a41v.a4pos]
    THEN
        BEGIN
        WITH longdesc DO
            BEGIN
            lds_descriptor   := tabid;
            (* PTS 1105838 E.Z. *)
            lds_maxlen       := 0;
            ldc_comment_type := comment_kind;
            lds_state        := [ ld_short_scol ];
            lds_intern_pos   := 1;
            lds_infoset      := [ ld_is_comment ];
            lds_colno        := column_no;
            lds_valmode      := vm_nodata;
            lds_valpos       := -1;
            lds_vallen       := -1
            END;
        (*ENDWITH*) 
        IF  ix = 1
        THEN
            BEGIN
            a26get_comment_prefix (acv, longdesc, c256,
                  1, cak_maxfieldlength);
            a40move (acv, a41v, @c256, cak_maxfieldlength)
            END
        ELSE
            a40move (acv, a41v, @longdesc, sizeof (longdesc))
        (*ENDIF*) 
        END
    ELSE
        a40move (acv, a41v, NIL, 0)
    (*ENDIF*) 
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40datatype_code (
            VAR col_info : tak00_columninfo;
            is_oracle    : boolean;
            comp_type    : tak_appl_type;
            VAR datatype : tsp00_Sname;
            VAR code     : tsp00_C10;
            VAR datalen  : integer);
 
BEGIN
WITH col_info DO
    BEGIN
    code    := bsp_c10;
    datalen := cdatalen;
    CASE cdatatyp OF
        dboolean :
            datatype := 'BOOLEAN     ';
        dfixed :
            IF  is_oracle
            THEN
                datatype := 'NUMBER      '
            ELSE
                IF  cbinary AND (comp_type <> at_unknown)
                THEN
                    IF  cdatalen = 5
                    THEN
                        datatype := 'SMALLINT    '
                    ELSE
                        IF  cdatalen = 10
                        THEN
                            datatype := 'INTEGER     '
                        ELSE
                            datatype := 'FIXED       '
                        (*ENDIF*) 
                    (*ENDIF*) 
                ELSE
                    datatype := 'FIXED       ';
                (*ENDIF*) 
            (*ENDIF*) 
        dfloat, dvfloat :
            datatype := 'FLOAT       ';
        dcha, dchb :
            BEGIN
            CASE cdatatyp OF
                dcha :
                    code := 'ASCII     ';
                dchb :
                    code := 'BYTE      ';
                END;
            (*ENDCASE*) 
            IF  cshiftoutchar = chr(ord(true))
            THEN
                datatype := 'VARCHAR     '
            ELSE
                datatype := 'CHAR        '
            (*ENDIF*) 
            END;
        ddate  :
            BEGIN
            datalen  := mxsp_extdate;
            IF  is_oracle AND NOT g01glob.db_is_for_sapr3
            THEN
                datatype := bsp_sname
            ELSE
                datatype :='DATE        '
            (*ENDIF*) 
            END;
        dtime  :
            (* PTS 1124467 E.Z. *)
            IF  is_oracle AND NOT g01glob.db_is_for_sapr3
            THEN
                datatype := bsp_sname
            ELSE
                datatype :='TIME        ';
            (*ENDIF*) 
        dtimestamp  :
            IF  is_oracle
            THEN
                BEGIN
                datalen  := mxsp_extdate;
                datatype :='DATE        '
                END
            ELSE
                BEGIN
                datalen  := mxsp_exttimestamp;
                datatype :='TIMESTAMP   '
                END;
            (*ENDIF*) 
        drowid :
            datatype := 'ROWID       ';
        dstra, dstrb, dstruni, dlonga, dlongb, dlonguni :
            BEGIN
            IF  cdatatyp in [ dlonga, dlongb, dlonguni ]
            THEN
                datatype :='LONGFILE    '
            ELSE
                datatype :='LONG        ';
            (*ENDIF*) 
            datalen  := csp_maxint4;
            CASE cdatatyp OF
                dlonga, dstra  :
                    code := 'ASCII     ';
                dlongb, dstrb  :
                    BEGIN
                    code :='BYTE      ';
                    IF  is_oracle
                    THEN
                        datatype := 'LONG RAW    '
                    (*ENDIF*) 
                    END;
                dlonguni, dstruni :
                    code :='UNICODE   ';
                OTHERWISE;
                END;
            (*ENDCASE*) 
            END;
        dunicode :
            BEGIN
            IF  cshiftoutchar = chr(ord(true))
            THEN
                datatype := 'VARCHAR     '
            ELSE
                datatype := 'CHAR        ';
            (*ENDIF*) 
            code := 'UNICODE   '
            END;
        dudt :
            datatype := 'UDT         ';
        OTHERWISE
            datatype := 'UNKNOWN     ';
        END;
    (*ENDCASE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40date_time_analyze (
            VAR acv      : tak_all_command_glob;
            VAR coldesc  : tak_vcolumndescription;
            dt_format    : tgg00_DateTimeFormat;
            VAR outbuf   : tsp00_MoveObj;
            pos          : integer;
            VAR aux1     : tsp00_C64;
            VAR auxlen   : integer);
 
VAR
      c256_1         : tsp00_C256;
      c256_2         : tsp00_C256;
      c64            : tsp00_C64;
      b_err          : tgg00_BasisError;
      error          : tsp8_uni_error;
      uni_len        : tsp00_Int4;
      err_char_no    : tsp00_Int4;
      len            : integer;
 
BEGIN
WITH coldesc DO
    BEGIN
    uni_len := mxsp_exttimestamp;
    s80uni_trans (@outbuf[ pos ], vfromtabno, csp_unicode,
          @c64, uni_len, csp_ascii, [ ], error, err_char_no);
&   ifdef TRACE
    t01c64 (ak_sem, c64);
    t01int4 (ak_sem, 'dt_format   ', ord(dt_format));
&   endif
    SAPDB_PascalForcedFill (sizeof(c256_2), @c256_2, 1, mxsp_exttimestamp, bsp_c1);
    CASE vdatatype OF
        ddate :
            BEGIN
            g03fdcheck_date (c64, c256_1, 1, 1, uni_len,
                  dt_format, b_err);
            g03dchange_format_date (c256_1, c256_2,
                  1, 1, acv.a_dt_format, b_err);
            END;
        dtime :
            BEGIN
            g03ftcheck_time (c64, c256_1, 1, 1, uni_len,
                  dt_format, b_err);
            g03tchange_format_time (c256_1, c256_2,
                  1, 1, acv.a_dt_format, b_err);
            END;
        dtimestamp :
            BEGIN
            g03ftscheck_timestamp (c64, c256_1, 1, 1, uni_len,
                  dt_format, acv.a_ak_language, b_err);
            g03tschange_format_timestamp (c256_1,
                  c256_2, 1, 1, acv.a_dt_format, acv.a_ak_language, b_err);
            END;
        END;
    (*ENDCASE*) 
    len := mxsp_exttimestamp;
    WHILE c256_2[ len ] = bsp_c1 DO
        len := pred(len);
    (*ENDWHILE*) 
    uni_len := 2*len;
    s80uni_trans (@c256_2, len, csp_ascii,
          @aux1, uni_len, csp_unicode, [ ], error, err_char_no);
    auxlen := uni_len;
&   ifdef TRACE
    t01c64 (ak_sem, aux1);
    t01int4 (ak_sem, 'auxlen      ', auxlen);
&   endif
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40int4_to_shinfo (
            i4            : tsp00_Int4;
            pos           : integer;
            len           : integer;
            frac          : integer;
            zero_to_undef : boolean;
            VAR shinfo    : tak40_shinfo);
 
VAR
      c        : char;
      fraction : integer;
      i        : integer;
      j        : integer;
 
BEGIN
&ifdef trace
t01int4 (ak_sem, 'i1          ', i4);
&endif
IF  g01unicode
THEN
    len := len * 2;
(*ENDIF*) 
i := pos + len;
IF  ((i4 = -1) OR (i4 > 0) OR ((i4 = 0) AND NOT zero_to_undef))
    AND
    (i4 <> csp_maxint4)
THEN
    BEGIN
    c := bsp_c1;
    IF  g01unicode
    THEN
        shinfo[pos] := csp_unicode_def_byte
    ELSE
        shinfo[pos] := bsp_c1;
    (*ENDIF*) 
    fraction      := 0;
    REPEAT
        IF  i4 >= 0
        THEN
            BEGIN
            shinfo [ i ] := chr (i4 MOD 10 + ord ('0'));
            fraction     := succ(fraction);
            IF  fraction = frac
            THEN
                BEGIN
                IF  g01unicode
                THEN
                    BEGIN
                    i         := i - 1;
                    shinfo[i] := csp_unicode_mark;
                    END;
                (*ENDIF*) 
                i           := i - 1;
                shinfo[ i ] := '.'
                END;
            (*ENDIF*) 
            IF  g01unicode
            THEN
                BEGIN
                i         := i - 1;
                shinfo[i] := csp_unicode_mark;
                END;
            (*ENDIF*) 
            i4 := i4 DIV 10;
            i  := pred(i)
            END;
        (*ENDIF*) 
    UNTIL
        i4 <= 0;
    (*ENDREPEAT*) 
    END
ELSE
    BEGIN
    c             := chr(0);
    shinfo[ pos ] := csp_undef_byte
    END;
(*ENDIF*) 
IF  g01unicode AND (shinfo[pos] <> csp_undef_byte)
THEN
    BEGIN
    j := pos + 1;
    WHILE j <= i DO
        BEGIN
        shinfo[j  ] := csp_unicode_mark;
        shinfo[j+1] := bsp_c1;
        j := j + 2
        END;
    (*ENDWHILE*) 
    END
ELSE
    FOR j := pos + 1 TO i DO
        shinfo[ j ] := c;
    (*ENDFOR*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40long_descriptor (
            VAR acv      : tak_all_command_glob;
            VAR a41v     : tak40_show_glob;
            VAR tabid    : tgg00_Surrogate;
            column_no    : integer);
 
VAR
      textlen     : tsp00_Int4;
      ix          : integer;
      move_len    : integer;
      longdesc    : tak_long_descriptor;
      buf         : tgg00_SelectBuffer;
 
BEGIN
IF  a41v.a4sh_kind = sh_pseudo_long
THEN
    ix := 2
ELSE
    BEGIN
    ix := 1;
    a508get_definition_text (acv, tabid, a41v.a4sh_kind,
          column_no, sizeof(buf), buf, textlen);
    END;
(*ENDIF*) 
WHILE ix <= 2 DO
    BEGIN
    IF  a41v.a4strategy.str_catalog.scat_col_needed[a41v.a4pos]
    THEN
        IF  ix = 1
        THEN
            BEGIN
            IF  textlen > cak_maxfieldlength * a01char_size
            THEN
                move_len := cak_maxfieldlength * a01char_size
            ELSE
                move_len := textlen;
            (*ENDIF*) 
            a40move (acv, a41v, @buf, move_len)
            END
        ELSE
            BEGIN
            (* return long descriptor *)
            WITH longdesc DO
                BEGIN
                lds_descriptor  := tabid;
                (* PTS 1105838 E.Z. *)
                lds_maxlen      := 0;
                lds_show_kind   := a41v.a4sh_kind;
                lds_state       := [ ld_short_scol ];
                lds_intern_pos  := 1;
                lds_infoset     := [ ld_is_catalog ];
                lds_colno       := column_no;
                lds_valmode     := vm_nodata;
                lds_valpos      := -1;
                lds_vallen      := -1
                END;
            (*ENDWITH*) 
            a40move (acv, a41v, @longdesc, a41v.a4long_desc_len)
            END
        (*ENDIF*) 
    ELSE
        a40move (acv, a41v, NIL, 0);
    (*ENDIF*) 
    ix := ix +1
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40put_date_time (
            VAR acv             : tak_all_command_glob;
            VAR a41v            : tak40_show_glob;
            VAR datetime        : tsp00_Int4;
            date                : boolean;
            is_undef            : boolean);
 
VAR
      i        : integer;
      move_len : integer;
      dt_value : tsp00_Int4;
      c10char  : tsp00_C10;
 
BEGIN
IF  date
THEN
    move_len := mxsp_extdate
ELSE
    move_len := mxsp_exttime;
(*ENDIF*) 
IF  is_undef
THEN
    a40move (acv, a41v, NIL, move_len)
ELSE
    BEGIN
    c10char := bsp_c10;
    IF  (datetime <> 0) OR NOT (date)
    THEN
        BEGIN
        dt_value := datetime;
        FOR i := mxsp_date DOWNTO 1 DO
            BEGIN
            c10char[i] := chr(ord('0')+(dt_value MOD 10));
            dt_value   := dt_value DIV 10;
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    a40move_const (acv, a41v, @c10char, move_len)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40table_column_to_shbuf (
            VAR acv    : tak_all_command_glob;
            VAR a41v   : tak40_show_glob;
            base_ptr   : tak_sysbufferaddress;
            colindex   : integer;
            with_owner : boolean);
 
VAR
      pCol           : tak00_colinfo_ptr;
      identifier_len : integer;
      owner          : tsp00_KnlIdentifier;
      schema         : tsp00_KnlIdentifier;
 
BEGIN
WITH base_ptr^.sbase DO
    BEGIN
    IF  base_ptr^.sbase.btablekind = tsynonym
    THEN
        BEGIN
        a06determine_username (acv, base_ptr^.ssynonym.syn_owner, owner);
        IF  base_ptr^.ssynonym.syn_authid = cak_public_id
        THEN
            schema := a01_il_b_identifier 
        ELSE
            schema := owner;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        a06determine_username (acv, bauthid, owner);
        IF  bauthid = bschema
        THEN
            schema := owner
        ELSE
            a103GetSchemaName (acv, bschema, schema);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    identifier_len := sizeof (tsp00_KnlIdentifier);
    a40move (acv, a41v, @schema, identifier_len);
    IF  a41v.a4is_synonym
    THEN
        a40move (acv, a41v, @a41v.a4synname, identifier_len)
    ELSE
        BEGIN (* PTS 1115857 *)
        IF  base_ptr^.sbase.btablekind = tsynonym
        THEN
            a40move (acv, a41v, @base_ptr^.ssynonym.syn_tablen, identifier_len)
        ELSE
            a40move (acv, a41v, @btablen^, identifier_len);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  colindex >= 0
    THEN
        BEGIN
        pCol := a103GetColumn (base_ptr^.sbase, colindex);
        a40move (acv, a41v, @pCol^.ccolumnn, ord (pCol^.ccolumnn_len));
        END;
    (*ENDIF*) 
    IF  with_owner
    THEN
        a40move (acv, a41v, @owner,  identifier_len);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40get_sequence (
            VAR acv          : tak_all_command_glob;
            VAR a41v         : tak40_show_glob;
            VAR sequence_id  : tgg00_Surrogate;
            VAR ok           : boolean);
 
VAR
      b_err  : tgg00_BasisError;
      seqkey : tgg00_SysInfoKey;
 
BEGIN
seqkey           := a01defaultkey;
seqkey.stableid  := sequence_id;
seqkey.sentrytyp := cak_esequence;
a10get_sysinfo (acv, seqkey,
      d_fix, a41v.a4p_arr.pbasep, b_err);
ok := b_err = e_ok;
IF  ok
THEN
    a41v.a4p_arr.pcount := 1
ELSE
    BEGIN
    a41v.a4p_arr.pcount := 0;
    a07_b_put_error (acv, b_err, 1);
    a40ignore_down_error (acv)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40ignore_down_error (VAR acv : tak_all_command_glob);
 
VAR
      work_rolled_back : boolean;
      net_disconnected : boolean;
      b_err            : tgg00_BasisError;
      errlen           : integer;
      err_type         : tgg04_ErrorText;
      errtxt           : tsp00_C256;
 
BEGIN
&IFDEF TRACE
t01int4 (ak_sem, 'return_code ', acv.a_returncode);
&ENDIF
IF  acv.a_returncode <> 0
THEN
    BEGIN
    work_rolled_back := acv.a_returncode =
          a071_return_code (e_work_rolled_back, acv.a_sqlmode);
    (* PTS 1109290 E.Z. *)
    net_disconnected := false;
    IF  work_rolled_back OR net_disconnected
    THEN
        BEGIN (* work rolled back *)
        (* b_err must be initialized with expected error *)
        IF  work_rolled_back
        THEN
            BEGIN
            b_err := e_work_rolled_back;
            b06get_errtxt (acv.a_transinf.tri_trans, errlen,
                  err_type, b_err, errtxt);
            END;
        (*ENDIF*) 
        END
    ELSE
        IF  (acv.a_command_kind = show_command) AND
            (acv.a_returncode =
            a071_return_code (e_lock_collision, acv.a_sqlmode))
        THEN
            acv.a_returncode := 0;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
&IFDEF TRACE
(*ENDIF*) 
t01int4 (ak_sem, 'return_code ', acv.a_returncode);
&ENDIF
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40init_table_scan (
            VAR acv          : tak_all_command_glob;
            VAR a41v         : tak40_show_glob;
            scan_temp        : boolean;
            scan_private     : boolean;
            scan_non_private : boolean;
            scan_public      : boolean;
            use_synonyms     : boolean;
            all_base         : boolean);
 
BEGIN
a722init_epos_reccol_relation( acv, a41v.a4aux_buf_ptr );
(* finalization in a40FinishTableScan() *)
IF  a41v.a4authname <> a01_il_b_identifier
THEN
    a06det_user_id (acv, a41v.a4authname, a41v.a4owner_id)
ELSE
    a41v.a4owner_id := cgg_zero_id;
(*ENDIF*) 
IF  a41v.a4tablen = a01_il_b_identifier
THEN
    a41v.a4tab_len := 0;
(*ENDIF*) 
a41v.a4p_arr.pcount := 0;
a41v.a4all          := all_base;
a40SetAllObjects(acv, a41v); (* PTS 1109359 *)
IF  a41v.a4all_objects
THEN
    BEGIN
    a41v.a4temp         := false;
    a41v.a4private      := false;
    a41v.a4nonprivate   := false;
    a41v.a4public       := false;
    a41v.a4roles        := false;
    a41v.a4syns         := use_synonyms
    END
ELSE
    BEGIN
    a41v.a4temp         := scan_temp;
    a41v.a4private      := scan_private;
    a41v.a4nonprivate   := scan_non_private;
    a41v.a4public       := scan_public;
    a41v.a4syns         := use_synonyms;
    a41v.a4roles        := a41v.a4systab_select
    END;
(*ENDIF*) 
IF  a41v.a4temp
THEN
    IF  a41v.a4systab_select
    THEN
        BEGIN
        (* test, if owner TEMP may fulfill qualification *)
        a41v.a4temp := a722test_col_qual (acv, a41v,
              ln_schemaname, ' ', @a01_i_temp, sizeof (a01_i_temp), a41v.a4aux_buf_ptr )
        END
    ELSE
        a41v.a4temp := ((a41v.a4authname = a01_il_b_identifier) OR
              (a41v.a4authname = a01_i_temp ));
    (*ENDIF*) 
(*ENDIF*) 
IF  a41v.a4private
THEN
    IF  a41v.a4systab_select
    THEN
        BEGIN
        (* test, if curr user may fulfill owner qualification *)
        IF  a41v.a4sh_kind = sh_st_user
        THEN
            a41v.a4private := a722test_col_qual (acv, a41v,
                  cak_ln_username, ' ', @acv.a_curr_user_name,
                  sizeof (acv.a_curr_user_name), a41v.a4aux_buf_ptr)
        ELSE
            IF  NOT (a41v.a4sh_kind in [sh_synonym, sh_all_synonyms])
            THEN
                a41v.a4private := a722test_col_qual (acv, a41v,
                      ln_schemaname, ' ', @acv.a_curr_user_name,
                      sizeof(acv.a_curr_user_name), a41v.a4aux_buf_ptr)
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        a41v.a4private := ((a41v.a4authname = a01_il_b_identifier) OR
              (a41v.a4authname = acv.a_curr_user_name));
    (*ENDIF*) 
(*ENDIF*) 
a41v.a4syns := a41v.a4syns AND
      (((acv.a_session_sqlmode <> sqlm_oracle) AND NOT a41v.a4systab_select) OR
      (a41v.a4sh_kind in [sh_synonym, sh_all_synonyms,
      sh_table, sh_all_table, sh_object, sh_all_object, sh_odbc_columns]));
a41v.a4sys_tables := true;
IF  a41v.a4systab_select              AND
    (* PTS 1105367 E.Z. *)
    (acv.a_sqlmode <> sqlm_oracle) AND
    (a41v.a4sh_kind in [sh_column,
    sh_odbc_columns,
    sh_p_prog,
    sh_new_privileges,
    sh_table,
    sh_view_uses_table,
    sh_all_column,
    sh_all_new_privileges,
    sh_all_table,
    sh_all_view_uses_table])
THEN
    BEGIN
    (* check, if system tables are required *)
    a41v.a4sys_tables := a722test_col_qual (acv, a41v,
          cak_ln_type, ' ', @a01_i_system,
          sizeof (a01_i_system), a41v.a4aux_buf_ptr)
    END;
(*ENDIF*) 
a41v.a4use_base     := ak40use_base_tables     (a41v);
a41v.a4use_view     := ak40use_view_tables     (a41v);
a41v.a4b_err        := e_no_next_record;
a41v.a4usertab_buf  := NIL;
a41v.a4usertab_cnt  := cak_is_undefined;
a41v.a4treeid       := acv.a_into_tree;
a41v.a4unique       := a41v.a4systab_select        AND
      (a41v.a4authname <> acv.a_curr_user_name) AND
      (a41v.a4authname <> a01_i_temp );
IF  a41v.a4unique
    AND
    a101_IsExtendedTempFile (acv, a41v.a4strategy.str_result_id)
    AND
    (a101_GetExtendedTempFileType (acv, a41v.a4strategy.str_result_id)
    = ttfnInto_egg00)
THEN
    BEGIN
    (* cannot use a_into_tree as distinct file *)
    (* TODO: a101_SetTempFileIndex can be removed -unless it turns out *)
    (* that it needs to be grouped- since the file will be destroyed   *)
    (* later on (it will be destroyed in vak41)                        *)
    (* a101_SetTempFileIndex (acv, a41v.a4treeid,
          a101_GetTempFileIndex (acv, a41v.a4treeid) + 1);
          *)
    b01tcreate_file (acv.a_transinf.tri_trans, a41v.a4treeid);
    IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
    (*ENDIF*) 
    END;
(*ENDIF*) 
a41v.a4role_cnt := 0;
IF  a41v.a4nonprivate AND a41v.a4roles AND (acv.a_role_info <> role_none)
THEN
    ak40store_roles (acv, a41v);
(*ENDIF*) 
a41v.a4next_user    := cgg_zero_id;
a41v.a4next_user[1] := chr(255);
a41v.a4next_user[2] := chr(255);
a41v.a4next_owner   := a01_il_b_identifier;
a41v.a4usertab_pos  := 0;
a41v.a4commandId       := a101_RegisterCurrentStatement (acv);
acv.a_command_sequence := acv.a_command_sequence + 1;
acv.a_command_id       := acv.a_command_sequence;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40FinishTableScan (
            VAR acv          : tak_all_command_glob;
            VAR a41v         : tak40_show_glob);
 
BEGIN
a101_UnregisterStatement (acv, a41v.a4commandId);
acv.a_command_id := a41v.a4commandId;
a722finalize_epos_reccol_relation( acv, a41v.a4aux_buf_ptr );
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40new_row (VAR a41v : tak40_show_glob);
 
BEGIN
WITH a41v DO
    BEGIN
    a4sh_buf.shsl            := 0;
    a4sh_buf.shkl            := 0;
    a4sh_buf.shvarcol_offset := 0;
    a4sh_buf.shvarcol_cnt    := 0;
    a4pos                    := 1;
    a4index := a103GetColumn (a4p_arr.pinfop^.sbase, a4p_arr.pinfop^.sbase.bfirstcolind)^.cnextind
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a40next_table (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob) : boolean;
 
CONST
      c_use_dbprocs = true;
 
VAR
      exit_loop : boolean;
      ok        : boolean;
      is_mfetch : boolean;
      kind      : tgg00_TableKind;
      tabid     : tgg00_Surrogate;
      sysk      : tgg00_SysInfoKey;
 
BEGIN
(* this function returns the 'next' table, that fulfills the   *)
(* qualification given by a4authname and a4tablen.             *)
(* Depending on the state of a4temp, a4private, a4nonprivate   *)
(* and a4public, temporary tables, private tables, nonprivate  *)
(* tables and tables granted to public are analyzed.           *)
(* The current point of search is stored in the parameter a41v *)
(* The function returns TRUE, if a table that fulfills the     *)
(* qualification has been found. In this case a4next_owner and *)
(* a4next_tablen contain the name of the table found           *)
ok := false;
IF  acv.a_returncode = 0
THEN
    BEGIN
&   ifdef trace
    t01int4 (ak_sem, 'a4b_err     ', a41v.a4b_err);
    t01int4 (ak_sem, 'a4temp      ', ord (a41v.a4temp));
    t01int4 (ak_sem, 'a4private   ', ord (a41v.a4private));
    t01int4 (ak_sem, 'a4nonprivate', ord (a41v.a4nonprivate));
    t01int4 (ak_sem, 'a4public    ', ord (a41v.a4public));
&   endif
    acv.a_command_sequence := acv.a_command_sequence + 1;
    acv.a_command_id       := acv.a_command_sequence;
    IF  a41v.a4p_arr.pbasep <> a41v.a4p_arr.pinfop
    THEN (* don't release result description of current select *)
        a10rel_sysinfo (a41v.a4p_arr.pbasep);
    (*ENDIF*) 
    a41v.a4p_arr.pbasep := NIL;
    exit_loop      := false;
    REPEAT
        a41v.a4is_synonym  := false;
        a41v.a4is_systable := false;
        IF  (a41v.a4private OR a41v.a4all_objects) AND
            (a41v.a4usertab_buf <> NIL)
        THEN
            BEGIN
            a10_rel_sysinfo (acv, a41v.a4usertab_buf^.syskey);
            a41v.a4usertab_buf := NIL
            END;
        (*ENDIF*) 
        IF  a41v.a4b_err = e_no_next_record
        THEN
            ak40next_tabsearch_phase (acv, a41v, a41v.a4aux_buf_ptr);
        (*ENDIF*) 
        IF  a41v.a4temp OR a41v.a4private OR a41v.a4all_objects
        THEN
            BEGIN
            REPEAT
                a41v.a4is_synonym := false;
                is_mfetch    := true;
                ak40mfetch_next_table (acv, a41v, tabid, kind, a41v.a4aux_buf_ptr);
                ok := a41v.a4b_err = e_ok;
                IF  ok AND
                    (((a41v.a4sh_kind = sh_synonym) AND NOT a41v.a4is_synonym) OR
                    (  NOT a41v.a4sys_tables AND a41v.a4is_systable))
                THEN
                    a41v.a4b_err := e_key_not_found
                ELSE
                    IF  a41v.a4b_err = e_no_next_record
                    THEN
                        IF  a41v.a4temp
                        THEN
                            a41v.a4temp := false
                        ELSE
                            a41v.a4private := false;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            UNTIL
                (a41v.a4b_err = e_ok) OR (a41v.a4b_err = e_no_next_record) OR
                (acv.a_returncode <> 0);
            (*ENDREPEAT*) 
            END
        ELSE
            BEGIN
            is_mfetch := false;
            IF  a41v.a4nonprivate OR a41v.a4public OR a41v.a4roles
            THEN
                (* scan non-private and tables granted to public *)
                ok := a40usertab_next (acv, a41v,
                      NOT (a41v.a4sh_kind in [sh_sequence, sh_all_sequences]),
                      NOT c_use_dbprocs, ak40use_sequences (a41v),
                      tabid, kind);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  ok
        THEN
            BEGIN
            IF  kind = tempty
            THEN
                BEGIN
                (* sequence found *)
                ak40get_sequence (acv, a41v, tabid, ok);
                IF  acv.a_returncode = 0
                THEN
                    IF  is_mfetch OR
                        (a41v.a4p_arr.pbasep^.ssequence.seq_owner  <> acv.a_curr_user_id) OR
                        (a41v.a4p_arr.pbasep^.ssequence.seq_schema <> acv.a_curr_user_id)
                    THEN
                        exit_loop := true
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                IF  a41v.a4is_synonym AND
                    (a41v.a4sh_kind in [sh_object, sh_all_object])
                THEN
                    BEGIN
                    a41v.a4p_arr.pbasep := a41v.a4usertab_buf;
                    a41v.a4usertab_buf  := NIL;
                    exit_loop      := true
                    END
                ELSE
                    BEGIN
                    IF  a41v.a4is_synonym AND
                        (a41v.a4usertab_buf^.ssynonym.syn_tableid = cgg_zero_id)
                    THEN
                        a41v.a4p_arr.pcount := 0
                    ELSE
                        IF  a41v.a4is_synonym AND
                            a23is_sequence_synonym (a41v.a4usertab_buf^.ssynonym)
                        THEN
                            IF  a41v.a4sh_kind in [sh_synonym, sh_all_synonyms]
                            THEN
                                BEGIN
                                sysk           := a01defaultkey;
                                sysk.stableid  := tabid;
                                sysk.sentrytyp := cak_esequence;
                                a10get_sysinfo (acv, sysk, d_fix,
                                      a41v.a4p_arr.pbasep, a41v.a4b_err);
                                ok := a41v.a4b_err = e_ok
                                END
                            ELSE
                                ok := false
                            (*ENDIF*) 
                        ELSE
                            a06_systable_get (acv, d_fix, tabid,
                                  a41v.a4p_arr.pbasep, a41v.a4all, ok);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  NOT ok
                    THEN
                        BEGIN
                        a40ignore_down_error (acv);
                        IF  acv.a_returncode = 0
                        THEN
                            a41v.a4b_err := e_ok
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        exit_loop := true;
                        IF  (a41v.a4p_arr.pbasep <> NIL) AND
                            (a41v.a4p_arr.pbasep^.syskey.sentrytyp[2] = cak_ctable)
                        THEN
                            WITH a41v.a4p_arr.pbasep^.sbase.btreeid DO
                                IF  fileHandling_gg00 = [hsWithoutLock_egg00]
                                THEN (* system table *)
                                    IF  (kb560IsCatalogTable (fileTabId_gg00))
                                        AND (acv.a_comp_type <> at_util)
                                    THEN (* catalog tables are invisible *)
                                        exit_loop := false;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            exit_loop := a41v.a4b_err <> e_no_next_record;
        (*ENDIF*) 
    UNTIL
        exit_loop OR (acv.a_returncode <> 0);
    (*ENDREPEAT*) 
    IF  (a41v.a4b_err <> e_ok) AND (a41v.a4b_err <> e_key_not_found)
    THEN
        a07_b_put_error (acv, a41v.a4b_err, 1);
    (*ENDIF*) 
    END;
(*ENDIF*) 
a40next_table := ok AND (acv.a_returncode = 0);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40move (
            VAR acv     : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            moveobj_ptr : tsp00_MoveObjPtr;
            move_len    : integer);
 
VAR
      pos       : integer;
      fill_char : char;
      pLongDesc : ^tak_long_descriptor;
      pCol      : tak00_colinfo_ptr;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    WITH a41v.a4p_arr.pinfop^.sresult DO
        BEGIN
        pCol := a103GetColumn (a41v.a4p_arr.pinfop^.sbase, a41v.a4index);
        IF  pCol^.cextcolno - 1 <> a41v.a4pos
        THEN
            BEGIN
            a41v.a4index := bextcolindex[a41v.a4pos+1] + bfirstindex;
            pCol    := a103GetColumn (a41v.a4p_arr.pinfop^.sbase, a41v.a4index);
            END;
        (*ENDIF*) 
        WITH pCol^ DO
            BEGIN
&           ifdef trace
            t01int4        (ak_sem, 'a4pos       ', a41v.a4pos);
            a061td_colinfo (pCol^, a41v.a4index);
            IF  (a41v.a4pos <> cextcolno - 1)
                AND
                (moveobj_ptr <> NIL)
            THEN
                g01abort (csp3_a40_move, csp3_n_show,
                      'A40MOVE: INVALID POS    ', a41v.a4pos);
&           endif
            (*ENDIF*) 
            IF  a41v.a4strategy.str_catalog.scat_col_needed[a41v.a4pos]
            THEN
                BEGIN
                pos := ccolstack.epos + a41v.a4sh_buf.shkl;
                IF  moveobj_ptr = NIL
                THEN
                    BEGIN
                    move_len    := 0;
                    a41v.a4sh_buf.shinfo[pos] := csp_undef_byte;
                    fill_char   := csp_defined_byte
                    END
                ELSE
                    BEGIN
                    IF  move_len > cinoutlen - 1
                    THEN
                        move_len := cinoutlen - 1;
                    (*ENDIF*) 
                    CASE cdatatyp OF
                        dstruni :
                            BEGIN
                            fill_char := csp_defined_byte;
                            IF  acv.a_out_packet^.sp1_header.sp1h_mess_swap <> sw_normal
                            THEN
                                BEGIN
                                pLongDesc := @moveobj_ptr^;
                                pLongDesc^.lds_state := pLongDesc^.lds_state + [ld_use_ucs_2_swap];
                                END;
                            (*ENDIF*) 
                            END;
                        dchb, dfixed, dstra, dlonga, dlonguni :
                            fill_char := csp_defined_byte;
                        dunicode :
                            fill_char := csp_unicode_def_byte;
                        OTHERWISE
                            fill_char := bsp_c1;
                        END;
                    (*ENDCASE*) 
                    a41v.a4sh_buf.shinfo[pos] := fill_char;
                    SAPDB_PascalMove ('VAK40 ',   8,
                          move_len, sizeof(a41v.a4sh_buf.shinfo), moveobj_ptr, 1,
                          @a41v.a4sh_buf.shinfo, pos + 1, move_len,
                          acv.a_returncode)
                    END;
                (*ENDIF*) 
                IF  move_len + 1 < cinoutlen
                THEN
                    IF  cdatatyp = dunicode
                    THEN
                        SAPDB_PascalForcedUnicodeFill (
                              sizeof(a41v.a4sh_buf.shinfo),
                              @a41v.a4sh_buf.shinfo, 1 + pos + move_len,
                              cinoutlen - move_len - 1, csp_unicode_blank)
                    ELSE
                        SAPDB_PascalFill ('VAK40 ',   9,
                              sizeof(a41v.a4sh_buf.shinfo), @a41v.a4sh_buf.shinfo, 1 + pos + move_len,
                              cinoutlen - move_len - 1, fill_char,
                              acv.a_returncode);
                    (*ENDIF*) 
&               ifdef trace
                (*ENDIF*) 
                t01moveobj (ak_sem, a41v.a4sh_buf.shinfo, pos, pos + cinoutlen - 1);
&               endif
                END;
            (*ENDIF*) 
            IF  cextcolno = a41v.a4p_arr.pinfop^.sbase.bmaxcol
            THEN
                BEGIN
                a41v.a4sh_buf.shsl := ccolstack.epos + cinoutlen - 1;
                ak40add_row (acv, a41v)
                END
            ELSE
                BEGIN
                a41v.a4pos   := a41v.a4pos + 1;
                a41v.a4index := cnextind
&                     ifdef trace
                      ;
                t01int4 (ak_sem, 'a4index     ', a41v.a4index);
&               endif
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40move_const (
            VAR acv     : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            moveobj_ptr : tsp00_MoveObjPtr;
            move_len    : integer);
 
VAR
      ix        : integer;
      pos       : integer;
      p         : integer;
      fill_char : char;
      pCol      : tak00_colinfo_ptr;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    WITH a41v.a4p_arr.pinfop^.sresult DO
        BEGIN
        pCol := a103GetColumn (a41v.a4p_arr.pinfop^.sbase, a41v.a4index);
        IF  pCol^.cextcolno - 1 <> a41v.a4pos
        THEN
            BEGIN
            a41v.a4index := bextcolindex[a41v.a4pos+1] + bfirstindex;
            pCol    := a103GetColumn (a41v.a4p_arr.pinfop^.sbase, a41v.a4index);
            END;
        (*ENDIF*) 
        WITH pCol^ DO
            BEGIN
&           ifdef trace
            t01int4        (ak_sem, 'a4pos       ', a41v.a4pos);
            a061td_colinfo (pCol^, a41v.a4index);
            IF  ((cdatatyp = dfixed) OR (a41v.a4pos <> cextcolno - 1))
                AND
                (moveobj_ptr <> NIL)
            THEN
                g01abort (csp3_a40_move_const, csp3_n_show,
                      'A40MOVE_CON: INVALID POS', a41v.a4pos);
&           endif
            (*ENDIF*) 
            IF  a41v.a4strategy.str_catalog.scat_col_needed[a41v.a4pos]
            THEN
                BEGIN
                pos := ccolstack.epos + a41v.a4sh_buf.shkl;
                IF  moveobj_ptr = NIL
                THEN
                    BEGIN
                    move_len    := 0;
                    a41v.a4sh_buf.shinfo[pos] := csp_undef_byte;
                    fill_char   := csp_defined_byte
                    END
                ELSE
                    BEGIN
                    IF  move_len > cdatalen
                    THEN
                        move_len := cdatalen;
                    (*ENDIF*) 
                    IF  cdatatyp = dunicode
                    THEN
                        BEGIN
                        a41v.a4sh_buf.shinfo[pos] := csp_unicode_def_byte;
                        p           := pos + 1;
                        FOR ix := 1 TO move_len DO
                            BEGIN
                            a41v.a4sh_buf.shinfo[p  ] := csp_unicode_mark;
                            a41v.a4sh_buf.shinfo[p+1] := moveobj_ptr^[ix];
                            p           := p + 2
                            END;
                        (*ENDFOR*) 
                        FOR ix := move_len * 2 + 1 TO cinoutlen - 1 DO
                            BEGIN
                            a41v.a4sh_buf.shinfo[p  ] := csp_unicode_mark;
                            a41v.a4sh_buf.shinfo[p+1] := bsp_c1;
                            p           := p + 2
                            END;
                        (*ENDFOR*) 
                        move_len := cinoutlen - 1
                        END
                    ELSE
                        BEGIN
                        CASE cdatatyp OF
                            dchb, dstra, dlonga :
                                fill_char := csp_defined_byte;
                            OTHERWISE
                                fill_char := bsp_c1;
                            END;
                        (*ENDCASE*) 
                        a41v.a4sh_buf.shinfo[pos] := fill_char;
                        SAPDB_PascalMove ('VAK40 ',  10,
                              move_len, sizeof(a41v.a4sh_buf.shinfo), moveobj_ptr, 1,
                              @a41v.a4sh_buf.shinfo, pos + 1, move_len,
                              acv.a_returncode)
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  move_len + 1 < cinoutlen
                THEN
                    SAPDB_PascalFill ('VAK40 ',  11,
                          sizeof(a41v.a4sh_buf.shinfo), @a41v.a4sh_buf.shinfo, 1 + pos + move_len,
                          cinoutlen - move_len - 1, fill_char,
                          acv.a_returncode);
&               ifdef trace
                (*ENDIF*) 
                t01moveobj (ak_sem, a41v.a4sh_buf.shinfo, pos, pos + cinoutlen - 1);
&               endif
                END;
            (*ENDIF*) 
            IF  cextcolno = a41v.a4p_arr.pinfop^.sbase.bmaxcol
            THEN
                BEGIN
                a41v.a4sh_buf.shsl := ccolstack.epos + cinoutlen - 1;
                ak40add_row (acv, a41v)
                END
            ELSE
                BEGIN
                a41v.a4pos   := a41v.a4pos + 1;
                a41v.a4index := cnextind
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40move_counter (
            VAR acv       : tak_all_command_glob;
            VAR a41v      : tak40_show_glob;
            val           : tsp00_8ByteCounter;
            is_null       : boolean;
            frac          : integer;
            zero_to_undef : boolean);
 
VAR
      already_moved : boolean;
      res           : tsp00_NumError;
      pos           : integer;
      ln_len        : integer;
      ln            : tsp00_Line;
      pCol          : tak00_colinfo_ptr;
 
BEGIN
(* PTS 1103743 JA 1999-08-25 *)
already_moved := false;
IF  acv.a_returncode = 0
THEN
    WITH a41v.a4p_arr.pinfop^.sresult DO
        BEGIN
        pCol := a103GetColumn (a41v.a4p_arr.pinfop^.sbase, a41v.a4index);
        IF  pCol^.cextcolno - 1 <> a41v.a4pos
        THEN
            BEGIN
            a41v.a4index := bextcolindex[a41v.a4pos+1] + bfirstindex;
            pCol    := a103GetColumn (a41v.a4p_arr.pinfop^.sbase, a41v.a4index);
            END;
        (*ENDIF*) 
        WITH pCol^ DO
            BEGIN
&           ifdef trace
            t01int4        (ak_sem, 'a4pos       ', a41v.a4pos);
            a061td_colinfo (pCol^, a41v.a4index);
            IF  (a41v.a4pos <> cextcolno - 1)
            THEN
                g01abort (csp3_a40_move_i4, csp3_n_show,
                      'A40MOVE_I4: INVALID POS ', a41v.a4pos);
&           endif
            (*ENDIF*) 
            IF  a41v.a4strategy.str_catalog.scat_col_needed[a41v.a4pos]
            THEN
                BEGIN
                IF  cdatatyp in [dcha, dunicode]
                THEN
                    BEGIN
                    (* PTS 1105599 E.Z. *)
                    SAPDB_PascalFill ('VAK40 ',  12,
                          sizeof(ln), @ln, 1,
                          cdatalen, csp_ascii_blank,
                          acv.a_returncode);
                    ln_len := cdatalen;
                    g17counter_to_line (val, ln_len, ln);
                    a40move_const (acv, a41v,
                          @ln[ln_len + 1 - cdatalen], cdatalen);
                    already_moved := true
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDWITH*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  (acv.a_returncode = 0) AND NOT already_moved
THEN
    WITH a41v.a4p_arr.pinfop^.sresult DO
        BEGIN
        WITH pCol^ DO
            BEGIN
&           ifdef trace
            t01int4        (ak_sem, 'a4pos       ', a41v.a4pos);
            a061td_colinfo (pCol^, a41v.a4index);
            IF  (a41v.a4pos <> cextcolno - 1)
            THEN
                g01abort (csp3_a40_move_i4, csp3_n_show,
                      'A40MOVE_I4: INVALID POS ', a41v.a4pos);
&           endif
            (*ENDIF*) 
            IF  a41v.a4strategy.str_catalog.scat_col_needed[a41v.a4pos]
            THEN
                BEGIN
                pos := ccolstack.epos + a41v.a4sh_buf.shkl;
                IF  is_null
                THEN
                    BEGIN
                    a41v.a4sh_buf.shinfo[pos] := csp_undef_byte;
                    SAPDB_PascalFill ('VAK40 ',  13,
                          sizeof(a41v.a4sh_buf.shinfo), @a41v.a4sh_buf.shinfo, pos + 1,
                          cinoutlen - 1, csp_defined_byte,
                          acv.a_returncode)
                    END
                ELSE
                    BEGIN
                    a41v.a4sh_buf.shinfo[pos] := csp_defined_byte;
&                   ifdef BIT64
                    s41p8int (a41v.a4sh_buf.shinfo, pos + 1, cdatalen, frac, val, res);
&                   else
                    s41plrel (a41v.a4sh_buf.shinfo, pos + 1, cdatalen, frac, val, res);
&                   endif
                    END;
                (*ENDIF*) 
&               ifdef trace
                t01moveobj (ak_sem, a41v.a4sh_buf.shinfo, pos, pos + cinoutlen - 1);
&               endif
                END;
            (*ENDIF*) 
            IF  cextcolno = a41v.a4p_arr.pinfop^.sbase.bmaxcol
            THEN
                BEGIN
                a41v.a4sh_buf.shsl := ccolstack.epos + cinoutlen - 1;
                ak40add_row (acv, a41v)
                END
            ELSE
                BEGIN
                a41v.a4pos   := a41v.a4pos + 1;
                a41v.a4index := cnextind;
&               ifdef trace
                t01int4 (ak_sem, 'a4index     ', a41v.a4index);
&               endif
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40move_guid (
            VAR acv     : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            VAR guid    : tsp00_C16);
 
VAR
      ix       : integer;
      len      : integer;
      aux_guid : tsp00_C16;
      c40_guid : tsp00_C40;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    aux_guid := guid;
    IF  g01code.kernel_swap = sw_full_swapped
    THEN
        BEGIN
        aux_guid[1] := guid[4];
        aux_guid[2] := guid[3];
        aux_guid[3] := guid[2];
        aux_guid[4] := guid[1];
        aux_guid[5] := guid[6];
        aux_guid[6] := guid[5];
        aux_guid[7] := guid[8];
        aux_guid[8] := guid[7]
        END;
    (*ENDIF*) 
    c40_guid := bsp_c40;
    len      := 0;
    FOR ix := 1 TO sizeof (aux_guid) DO
        BEGIN
        g17hexto_line (aux_guid[ix], len, c40_guid);
        IF  (len = 8) OR (len = 13) OR (len = 18) OR (len = 23)
        THEN
            BEGIN
            len       := len + 1;
            c40_guid[len] := '-'
            END;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    (* PTS 1113711 T.A. *)
    a40move_const (acv, a41v, @c40_guid, sizeof (c40_guid))
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40move_i4 (
            VAR acv       : tak_all_command_glob;
            VAR a41v      : tak40_show_glob;
            i4_val        : tsp00_Int4;
            is_null       : boolean;
            frac          : integer;
            zero_to_undef : boolean);
 
CONST
      c_max_int_field_len = 12;
 
VAR
      res  : tsp00_NumError;
      pos  : integer;
      len  : integer;
      pCol : tak00_colinfo_ptr;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    WITH a41v.a4p_arr.pinfop^.sresult DO
        BEGIN
        pCol := a103GetColumn (a41v.a4p_arr.pinfop^.sbase, a41v.a4index);
        IF  pCol^.cextcolno - 1 <> a41v.a4pos
        THEN
            BEGIN
            a41v.a4index := bextcolindex[a41v.a4pos+1] + bfirstindex;
            pCol    := a103GetColumn (a41v.a4p_arr.pinfop^.sbase, a41v.a4index);
            END;
        (*ENDIF*) 
        WITH pCol^ DO
            BEGIN
&           ifdef trace
            t01int4        (ak_sem, 'a4pos       ', a41v.a4pos);
            a061td_colinfo (pCol^, a41v.a4index);
            IF  (a41v.a4pos <> cextcolno - 1)
            THEN
                g01abort (csp3_a40_move_i4, csp3_n_show,
                      'A40MOVE_I4: INVALID POS ', a41v.a4pos);
&           endif
            (*ENDIF*) 
            IF  a41v.a4strategy.str_catalog.scat_col_needed[a41v.a4pos]
            THEN
                BEGIN
                pos := ccolstack.epos + a41v.a4sh_buf.shkl;
                IF  is_null
                THEN
                    BEGIN
                    a41v.a4sh_buf.shinfo[pos] := csp_undef_byte;
                    SAPDB_PascalFill ('VAK40 ',  14,
                          sizeof(a41v.a4sh_buf.shinfo), @a41v.a4sh_buf.shinfo, pos + 1,
                          cinoutlen - 1, csp_defined_byte,
                          acv.a_returncode)
                    END
                ELSE
                    BEGIN
                    IF  cdatatyp in [dcha, dunicode]
                    THEN
                        BEGIN
                        (* write integer into character column *)
                        IF  i4_val < 0
                        THEN
                            i4_val := 0;
                        (*ENDIF*) 
                        IF  cdatalen > c_max_int_field_len
                        THEN
                            BEGIN
                            (* don't write integer to the right *)
                            (* of a long character field        *)
                            len := c_max_int_field_len;
                            IF  cdatatyp = dunicode
                            THEN
                                SAPDB_PascalForcedUnicodeFill (sizeof(a41v.a4sh_buf.shinfo),
                                      @a41v.a4sh_buf.shinfo, pos + len * 2 + 1,
                                      (cdatalen - len) * 2, csp_unicode_blank)
                            ELSE
                                SAPDB_PascalFill ('VAK40 ',  15,
                                      sizeof(a41v.a4sh_buf.shinfo), @a41v.a4sh_buf.shinfo,
                                      pos + len + 1,
                                      cdatalen - len, bsp_c1,
                                      acv.a_returncode)
                            (*ENDIF*) 
                            END
                        ELSE
                            len := cdatalen;
                        (*ENDIF*) 
                        ak40int4_to_shinfo (i4_val,
                              pos, len, frac, zero_to_undef, a41v.a4sh_buf.shinfo);
                        END
                    ELSE
                        BEGIN
                        a41v.a4sh_buf.shinfo[pos] := csp_defined_byte;
                        s41plint (a41v.a4sh_buf.shinfo, pos + 1,
                              cdatalen, csp_float_frac, i4_val, res);
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
&               ifdef trace
                t01moveobj (ak_sem, a41v.a4sh_buf.shinfo, pos, pos + cinoutlen - 1);
&               endif
                END;
            (*ENDIF*) 
            IF  cextcolno = a41v.a4p_arr.pinfop^.sbase.bmaxcol
            THEN
                BEGIN
                a41v.a4sh_buf.shsl := ccolstack.epos + cinoutlen - 1;
                ak40add_row (acv, a41v)
                END
            ELSE
                BEGIN
                a41v.a4pos   := a41v.a4pos + 1;
                a41v.a4index := cnextind
&                     ifdef trace
                      ;
                t01int4 (ak_sem, 'a4index     ', a41v.a4index);
&               endif
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40move_ui4 (
            VAR acv       : tak_all_command_glob;
            VAR a41v      : tak40_show_glob;
            i4_val        : tsp00_Int4;
            is_null       : boolean;
            frac          : integer;
            zero_to_undef : boolean);
 
CONST
      c_max_int_field_len = 12;
 
VAR
      res  : tsp00_NumError;
      pos  : integer;
      len  : integer;
      pCol : tak00_colinfo_ptr;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    WITH a41v.a4p_arr.pinfop^.sresult DO
        BEGIN
        pCol := a103GetColumn (a41v.a4p_arr.pinfop^.sbase, a41v.a4index);
        IF  pCol^.cextcolno - 1 <> a41v.a4pos
        THEN
            BEGIN
            a41v.a4index := bextcolindex[a41v.a4pos+1] + bfirstindex;
            pCol    := a103GetColumn (a41v.a4p_arr.pinfop^.sbase, a41v.a4index);
            END;
        (*ENDIF*) 
        WITH pCol^ DO
            BEGIN
&           ifdef trace
            t01int4        (ak_sem, 'a4pos       ', a41v.a4pos);
            a061td_colinfo (pCol^, a41v.a4index);
            IF  (a41v.a4pos <> cextcolno - 1)
            THEN
                g01abort (csp3_a40_move_i4, csp3_n_show,
                      'A40MOVE_I4: INVALID POS ', a41v.a4pos);
&           endif
            (*ENDIF*) 
            IF  a41v.a4strategy.str_catalog.scat_col_needed[a41v.a4pos]
            THEN
                BEGIN
                pos := ccolstack.epos + a41v.a4sh_buf.shkl;
                IF  is_null
                THEN
                    BEGIN
                    a41v.a4sh_buf.shinfo[pos] := csp_undef_byte;
                    SAPDB_PascalFill ('VAK40 ',  16,
                          sizeof(a41v.a4sh_buf.shinfo), @a41v.a4sh_buf.shinfo, pos + 1,
                          cinoutlen - 1, csp_defined_byte,
                          acv.a_returncode)
                    END
                ELSE
                    BEGIN
                    IF  cdatatyp in [dcha, dunicode]
                    THEN
                        BEGIN
                        a07_b_put_error (acv, e_not_implemented, 1)
                        END
                    ELSE
                        BEGIN
                        a41v.a4sh_buf.shinfo[pos] := csp_defined_byte;
                        s41pluns (a41v.a4sh_buf.shinfo, pos + 1,
                              cdatalen, csp_float_frac, i4_val, res);
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
&               ifdef trace
                t01moveobj (ak_sem, a41v.a4sh_buf.shinfo, pos, pos + cinoutlen - 1);
&               endif
                END;
            (*ENDIF*) 
            IF  cextcolno = a41v.a4p_arr.pinfop^.sbase.bmaxcol
            THEN
                BEGIN
                a41v.a4sh_buf.shsl := ccolstack.epos + cinoutlen - 1;
                ak40add_row (acv, a41v)
                END
            ELSE
                BEGIN
                a41v.a4pos   := a41v.a4pos + 1;
                a41v.a4index := cnextind
&                     ifdef trace
                      ;
                t01int4 (ak_sem, 'a4index     ', a41v.a4index);
&               endif
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40move_real (
            VAR acv       : tak_all_command_glob;
            VAR a41v      : tak40_show_glob;
            val           : tsp00_Longreal;
            is_null       : boolean;
            frac          : integer);
 
VAR
      res  : tsp00_NumError;
      pos  : integer;
      len  : integer;
      pCol : tak00_colinfo_ptr;
 
BEGIN
WITH a41v.a4p_arr.pinfop^.sresult DO
    BEGIN
    pCol := a103GetColumn (a41v.a4p_arr.pinfop^.sbase, a41v.a4index);
    IF  pCol^.cextcolno - 1 <> a41v.a4pos
    THEN
        BEGIN
        a41v.a4index := bextcolindex[a41v.a4pos+1] + bfirstindex;
        pCol    := a103GetColumn (a41v.a4p_arr.pinfop^.sbase, a41v.a4index);
        END;
    (*ENDIF*) 
    WITH pCol^ DO
        BEGIN
&       ifdef trace
        t01int4        (ak_sem, 'a4pos       ', a41v.a4pos);
        a061td_colinfo (pCol^, a41v.a4index);
        IF  (a41v.a4pos <> ord (cextcolno) - 1)
        THEN
            g01abort (csp3_a40_move_i4, csp3_n_show,
                  'A40MOVE_I4: INVALID POS ', a41v.a4pos);
&       endif
        (*ENDIF*) 
        IF  a41v.a4strategy.str_catalog.scat_col_needed[a41v.a4pos]
        THEN
            BEGIN
            pos := ccolstack.epos + a41v.a4sh_buf.shkl;
            IF  is_null
            THEN
                BEGIN
                a41v.a4sh_buf.shinfo[pos] := csp_undef_byte;
                SAPDB_PascalFill ('VAK40 ',  17,
                      sizeof(a41v.a4sh_buf.shinfo), @a41v.a4sh_buf.shinfo, pos + 1,
                      cinoutlen - 1, csp_defined_byte,
                      acv.a_returncode)
                END
            ELSE
                BEGIN
                IF  cdatatyp in [dcha, dunicode]
                THEN
                    a07_b_put_error (acv, e_not_implemented, 1)
                ELSE
                    BEGIN
                    a41v.a4sh_buf.shinfo[pos] := csp_defined_byte;
                    s41plrel (a41v.a4sh_buf.shinfo, pos + 1,
                          cdatalen, frac, val, res);
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
&           ifdef trace
            t01moveobj (ak_sem, a41v.a4sh_buf.shinfo, pos, pos + cinoutlen - 1);
&           endif
            END;
        (*ENDIF*) 
        IF  ord (cextcolno) = a41v.a4p_arr.pinfop^.sbase.bmaxcol
        THEN
            BEGIN
            a41v.a4sh_buf.shsl := ccolstack.epos + cinoutlen - 1;
            ak40add_row (acv, a41v)
            END
        ELSE
            BEGIN
            a41v.a4pos   := a41v.a4pos + 1;
            a41v.a4index := cnextind
&                 ifdef trace
                  ;
            t01int4 (ak_sem, 'a4index     ', a41v.a4index);
&           endif
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40mfetch_next_table (
            VAR acv   : tak_all_command_glob;
            VAR a41v  : tak40_show_glob;
            VAR tabid : tgg00_Surrogate;
            VAR kind  : tgg00_TableKind;
            work_buf  : tak40_int2_arr_ptr);
 
CONST
      c_check_only       = true;
      c_aux_st_max_index = 50;
 
VAR
      mm_type        : tgg00_MessType2;
      rec_len        : tsp_int_map_c2;
      key_len        : tsp_int_map_c2;
      id_len         : integer;
      synk           : tgg00_SysInfoKey;
      tableref       : tak_tablereference;
      aux_st         : ARRAY[1..c_aux_st_max_index] OF tgg00_StackEntry;
      fetch_desc     : tgg00_FetchDesc;
 
BEGIN
a41v.a4b_err      := e_ok;
&ifdef trace
t01int4 (ak_sem, 'mfetch_pos  ', a41v.a4mfetch_pos);
t01int4 (ak_sem, 'a4tab_len   ', a41v.a4tab_len);
t01int4 (ak_sem, 'a4mblock siz', a41v.a4mblock.mb_data_size);
t01int4 (ak_sem, 'a4mblock len', a41v.a4mblock.mb_data_len);
&endif
IF  a41v.a4mfetch_pos > a41v.a4mblock.mb_data_len
THEN
    WITH a41v.a4mblock DO
        BEGIN
        IF  a41v.a4mfetch_cnt = cak_is_undefined
        THEN
            mm_type := mm_first
        ELSE
            mm_type := mm_next;
        (*ENDIF*) 
        IF  a41v.a4b_err = e_ok
        THEN
            BEGIN
            g01mblock_init (acv.a_transinf.tri_trans,
                  m_fetch, mm_type, a41v.a4mblock);
            g01datapart_init (a41v.a4mblock, @a41v.a4data, sizeof (a41v.a4data));
            a41v.a4mblock.mb_data_len := cgg_rec_key_offset;
            g01stack_init    (a41v.a4mblock, @aux_st, sizeof (aux_st),
                  @fetch_desc, sizeof (fetch_desc));
            (* PTS 1116837 E.Z. *)
            acv.a_transinf.tri_trans.trRteCommPtr_gg00^.file_root       := NIL_PAGE_NO_GG00;
            acv.a_transinf.tri_trans.trRteCommPtr_gg00^.file_record_cnt := 1;
            IF  a41v.a4next_key.sentrytyp > cak_etemp
            THEN
                a41v.a4mblock.mb_qual^.mtree := acv.a_pars_curr
            ELSE
                kb560GetSys2CatalogTreeId (a41v.a4mblock.mb_qual^.mtree);
            (*ENDIF*) 
            (* mb_qual^ construction *)
            WITH mb_qual^.mf_desc DO
                BEGIN
                m_fetch_state := [];
                IF  mm_type = mm_first
                THEN
                    BEGIN
                    id_len := a41v.a4tab_len;
                    IF  id_len > 0
                    THEN
                        IF  g01unicode
                        THEN
                            id_len := s30unilnr (@a41v.a4next_key.sidentifier,
                                  csp_unicode_blank, 1, id_len)
                        ELSE
                            id_len :=
                                  s30lnr (a41v.a4next_key.sidentifier,
                                  bsp_c1, 1, id_len);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    id_len := a41v.a4next_key.skeylen - sizeof (a41v.a4next_key.sauthid) -
                          sizeof (a41v.a4next_key.sentrytyp) - sizeof (a41v.a4next_key.slinkage);
                (*ENDIF*) 
                m_startkeys.reckey.len :=
                      mxak_standard_sysk + id_len;
                SAPDB_PascalMove ('VAK40 ',  18,
                      sizeof(a41v.a4next_key),
                      sizeof(m_startkeys.reckey.k),
                      @a41v.a4next_key, cgg_rec_key_offset + 1,
                      @m_startkeys.reckey.k, 1,
                      m_startkeys.reckey.len, a41v.a4b_err);
                SAPDB_PascalFill ('VAK40 ',  19,
                      sizeof(m_startkeys.reckey.k),
                      @m_startkeys.reckey.k,
                      m_startkeys.reckey.len + 1,
                      sizeof (a41v.a4tablen) - a41v.a4tab_len, chr(0), a41v.a4b_err);
                m_startkeys.listkey.len := 0;
                m_startkeys.listkey.k   := b01zerokey;
                m_stopkeys.reckey.len   :=
                      mxak_standard_sysk + a41v.a4tab_len;
                SAPDB_PascalMove ('VAK40 ',  20,
                      sizeof(a41v.a4next_key),
                      sizeof(m_startkeys.reckey.k),
                      @a41v.a4next_key, cgg_rec_key_offset + 1,
                      @m_stopkeys.reckey.k, 1,
                      m_stopkeys.reckey.len, a41v.a4b_err);
                SAPDB_PascalFill ('VAK40 ',  21,
                      sizeof(m_stopkeys.reckey.k),
                      @m_stopkeys.reckey.k,
                      m_stopkeys.reckey.len + 1,
                      sizeof (a41v.a4tablen) - a41v.a4tab_len, chr(255), a41v.a4b_err);
                ak40add_ref_qualification (acv, a41v,
                      m_startkeys.reckey, m_stopkeys.reckey, work_buf);
                m_stopkeys.reckey.len :=
                      mxak_standard_sysk + sizeof (a41v.a4tablen);
                m_stopkeys.listkey  := m_startkeys.listkey;
                m_firstkeys.reckey  := m_startkeys.listkey;
                m_firstkeys.listkey := m_startkeys.listkey;
                m_start.len         := 0;
                m_start.k           := b01zerokey;
                m_dist_optim        := NO_DISTINCT_OPTIM_GG07;
                m_qual_kind         := primary_only;
                m_strat_info        := ir_v_acc;
                m_fns1              := mb_qual^.mtree;
                m_fns2              := b01niltree_id;
                m_fetch_state       := [ fs_use_stop, fs_use_recs ];
                m_leng              := sizeof (tak_tablereference);
                m_data              := NIL;
                (* h.b. PTS 1001366 *)
                m_rescnt            := -1;
                m_rowno             := -1;
                (* initialized here because used in k75_fetch *)
                m_searched_pages    := 1;
                IF  a41v.a4tab_len = sizeof (a41v.a4tablen)
                THEN
                    m_cnt := 1
                ELSE
                    m_cnt := (sizeof (a41v.a4data) - a41v.a4mblock.mb_data_len)
                          DIV m_leng;
                (*ENDIF*) 
&               ifdef trace
                t01int4 (ak_sem, 'm_cnt       ', m_cnt);
&               endif
                m_keylen := - cgg_rec_key_offset;
                IF  (a41v.a4mfetch_cnt <> cak_is_undefined) AND
                    (a41v.a4mfetch_cnt < m_cnt)
                THEN
                    a41v.a4b_err := e_no_next_record
                ELSE
                    BEGIN
                    mb_qual_len  := sizeof (mb_qual^.mf_desc);
                    a06rsend_mess_buf (acv, a41v.a4mblock,
                          cak_return_req, a41v.a4b_err);
                    END;
                (*ENDIF*) 
                IF  a41v.a4b_err = e_ok
                THEN
                    IF  m_cnt <= 0
                    THEN
                        a41v.a4b_err := e_no_next_record
                    ELSE
                        BEGIN
                        a41v.a4mfetch_pos := 1;
                        a41v.a4mfetch_cnt := m_cnt;
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  a41v.a4b_err = e_ok
THEN
    BEGIN
    rec_len.map_c2[1] := a41v.a4mblock.mb_data^.mbp_buf[a41v.a4mfetch_pos  ];
    rec_len.map_c2[2] := a41v.a4mblock.mb_data^.mbp_buf[a41v.a4mfetch_pos+1];
    key_len.map_c2[1] := a41v.a4mblock.mb_data^.mbp_buf[a41v.a4mfetch_pos+2];
    key_len.map_c2[2] := a41v.a4mblock.mb_data^.mbp_buf[a41v.a4mfetch_pos+3];
    SAPDB_PascalMove ('VAK40 ',  22,
          a41v.a4mblock.mb_data_size, sizeof(a41v.a4next_key),
          @a41v.a4mblock.mb_data^.mbp_buf, a41v.a4mfetch_pos, @a41v.a4next_key,
          1, cgg_rec_key_offset + key_len.map_int, a41v.a4b_err);
    tableref.rtablerefkey2 := a01_il_b_identifier;
    SAPDB_PascalMove ('VAK40 ',  23,
          a41v.a4mblock.mb_data_size, sizeof(tableref),
          @a41v.a4mblock.mb_data^.mbp_buf, a41v.a4mfetch_pos,
          @tableref, 1, cgg_rec_key_offset + key_len.map_int, a41v.a4b_err);
    SAPDB_PascalMove ('VAK40 ',  24,
          a41v.a4mblock.mb_data_size, sizeof(tableref),
          @a41v.a4mblock.mb_data^.mbp_buf,
          a41v.a4mfetch_pos + cgg_rec_key_offset + key_len.map_int,
          @tableref, sizeof (tableref.rtablerefkey1) +
          sizeof (tableref.rtablerefkey2) + 1,
          rec_len.map_int - cgg_rec_key_offset - key_len.map_int, a41v.a4b_err);
    (* mfetch delivers multiple records with a fix position *)
    a41v.a4mfetch_pos  := a41v.a4mfetch_pos + sizeof (tak_tablereference);
    a41v.a4next_tablen := tableref.rtablerefkey2;
    a41v.a4is_synonym  := tableref.rtablekind = tsynonym;
    tabid         := tableref.rtableid;
    kind          := tableref.rtablekind;
    (* PTS 1105367 E.Z. *)
    IF  ((acv.a_session_sqlmode = sqlm_oracle) AND NOT a41v.a4systab_select)
        OR ((acv.a_sqlmode = sqlm_oracle) AND a41v.a4systab_select)
    THEN
        a41v.a4is_systable := false
    ELSE
        a41v.a4is_systable := tableref.rsystable;
    (*ENDIF*) 
    IF  a41v.a4unique         AND
        NOT a41v.a4is_synonym AND
        (a41v.a4next_key.sentrytyp < cak_etemp)
    THEN
        IF  NOT a40is_unique (acv,
            a41v.a4treeid, tabid, NOT c_check_only)
        THEN
            IF  (NOT kb560IsCatalogTable (tabid)) AND
                (NOT a101_IsExtendedTempFile (acv, a41v.a4treeid))
            THEN
                a07ak_system_error (acv, 40, 3);
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a41v.a4is_synonym AND (a41v.a4b_err = e_ok)
    THEN
        BEGIN
        synk          := a01defaultkey;
        synk.stableid := tableref.rsynid;
        a10get_sysinfo (acv, synk, d_fix, a41v.a4usertab_buf, a41v.a4b_err);
        IF  a41v.a4b_err = e_ok
        THEN
            IF  (a41v.a4usertab_buf^.ssynonym.syn_tableid = cgg_zero_id)
                AND
                NOT (a41v.a4sh_kind in [sh_synonym, sh_all_synonyms])
            THEN
                a41v.a4b_err := e_key_not_found
            ELSE
                a41v.a4synname := a41v.a4usertab_buf^.ssynonym.syn_tablen
            (*ENDIF*) 
        ELSE
            a07_b_put_error (acv, a41v.a4b_err, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END
ELSE
    BEGIN
    IF  a41v.a4b_err <> e_no_next_record
    THEN
        a07_b_put_error (acv, a41v.a4b_err, 1);
    (*ENDIF*) 
    a40ignore_down_error (acv);
    IF  acv.a_returncode = 0
    THEN
        IF  mm_type = mm_first
        THEN (* try to read at least replicated tables *)
            BEGIN
            a41v.a4mblock.mb_data_len := 0;
            END
        ELSE
            a41v.a4b_err := e_no_next_record
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40next_tabsearch_phase (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            work_buf : tak40_int2_arr_ptr);
 
VAR
      found         : boolean;
      role_info_ptr : tak40_role_info_ptr;
      userbuf       : tak_sysbufferaddress;
      userInfo      : tak_userrecord;
 
BEGIN
(* start a new phase of search, i.e. switch from *)
(* temp --> private, private --> nonprivate or   *)
(* nonprivate --> public respectively            *)
&ifdef trace
t01int4 (ak_sem, 'a4temp      ', ord (a41v.a4temp));
t01int4 (ak_sem, 'a4private   ', ord (a41v.a4private));
t01int4 (ak_sem, 'a4nonprivate', ord (a41v.a4nonprivate));
t01int4 (ak_sem, 'a4public    ', ord (a41v.a4public));
t01int4 (ak_sem, 'a4all_obj   ', ord (a41v.a4all_objects));
&endif
a41v.a4next_key := a01defaultkey;
a41v.a4b_err    := e_ok;
IF  (a41v.a4temp OR a41v.a4private OR a41v.a4all_objects) AND
    (acv.a_returncode = 0)
THEN
    BEGIN
    (* search temporary tables or tables of current user *)
    IF  a41v.a4temp
    THEN
        BEGIN
        a41v.a4next_owner         := a01_i_temp ;
        a41v.a4next_key.sauthid   := cak_temp_user_id;
        a41v.a4next_key.sentrytyp := cak_etemptableref
        END
    ELSE
        IF  a41v.a4all_objects
        THEN
            BEGIN
            a41v.a4b_err := e_no_next_record;
            IF  a41v.a4authname <> a01_il_b_identifier
            THEN
                IF  a41v.a4next_owner = a01_il_b_identifier
                THEN
                    BEGIN
                    userbuf := a103ExistsSchema (acv, a41v.a4authname);
                    IF  userbuf <> NIL
                    THEN
                        BEGIN
                        userInfo    := userbuf^.suser;
                        a41v.a4next_user := userInfo.usurrogate;
                        a41v.a4b_err     := e_ok
                        END
                    (*ENDIF*) 
                    END
                ELSE
                    a41v.a4all_objects := false
                (*ENDIF*) 
            ELSE
                BEGIN
                found := false;
                REPEAT
                    a103NextUser (acv, a41v.a4next_user, userInfo, false, false, a41v.a4b_err);
                    IF  a41v.a4b_err = e_ok
                    THEN
                        BEGIN
                        IF  a722test_col_qual (acv, a41v,
                            ln_schemaname, ' ', @userInfo.username,
                            sizeof (userInfo.username), work_buf)
                        THEN
                            found := true;
                        (*ENDIF*) 
                        a41v.a4next_user := userInfo.usurrogate;
                        END;
                    (*ENDIF*) 
                UNTIL
                    (a41v.a4b_err <> e_ok) OR found;
                (*ENDREPEAT*) 
                END;
            (*ENDIF*) 
            IF  a41v.a4b_err = e_ok
            THEN
                BEGIN
                a41v.a4next_owner         := userInfo.username;
                a41v.a4next_key.sauthid   := a41v.a4next_user;
                a41v.a4next_key.sentrytyp := cak_etableref
                END
            ELSE
                a41v.a4all_objects := false
            (*ENDIF*) 
            END
        ELSE
            IF  a41v.a4authname <> a01_il_b_identifier
            THEN
                BEGIN
                a41v.a4next_owner          := a41v.a4authname;
                a41v.a4next_key.sauthid    := a41v.a4owner_id;
                a41v.a4next_key.sentrytyp  := cak_etableref;
                END
            ELSE
                BEGIN
                a41v.a4next_owner          := acv.a_curr_user_name;
                a41v.a4next_key.sauthid    := acv.a_curr_user_id;
                a41v.a4next_key.sentrytyp  := cak_etableref;
                a41v.a4next_key.sauthid[1] := chr(255);
                a41v.a4next_key.sauthid[2] := chr(255)
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    a41v.a4next_key.sidentifier := a41v.a4tablen;
    a41v.a4next_key.skeylen     := mxak_standard_sysk;
    a41v.a4mfetch_pos           := 1;
    a41v.a4mblock.mb_data_len   := 0;
    a41v.a4mfetch_cnt           := cak_is_undefined
    END
ELSE
    IF  (a41v.a4authname <> acv.a_curr_user_name)   AND
        (a41v.a4authname <> a01_i_temp ) AND
        (a41v.a4nonprivate OR a41v.a4public)         AND
        NOT a41v.a4all_objects                  AND
        (acv.a_returncode = 0)
    THEN
        BEGIN
        (* search nonprivate tables or tables granted to *)
        (* public                                        *)
        IF  a41v.a4nonprivate
        THEN
            BEGIN
            a41v.a4next_key.sauthid := acv.a_curr_user_id
            END
        ELSE
            BEGIN
            a41v.a4next_key.sauthid := cak_public_id;
            END;
        (*ENDIF*) 
        a41v.a4next_key.sentrytyp := cak_eusertab;
        a41v.a4usertab_cnt        := cak_is_undefined;
        a41v.a4usertab_pos        := 1;
        a10_key_del (acv, a41v.a4next_key)
        END
    ELSE
        BEGIN
&       ifdef trace
        t01int4 (ak_sem, 'a4role_cnt  ', a41v.a4role_cnt);
&       endif
        IF  a41v.a4role_cnt > 0
        THEN
            BEGIN
            a41v.a4b_err              := e_ok;
            role_info_ptr        := @a41v.a4row_ptr^;
            a41v.a4next_key.sauthid   := role_info_ptr^.rl_ids[a41v.a4role_cnt];
            a41v.a4next_key.sentrytyp := cak_eusertab;
            a41v.a4next_key.slinkage  := cak_init_linkage;
            a41v.a4role_cnt           := a41v.a4role_cnt - 1;
            a41v.a4usertab_cnt        := cak_is_undefined;
            a41v.a4usertab_pos        := 1;
            a10_key_del (acv, a41v.a4next_key)
            END
        ELSE
            BEGIN
            a41v.a4roles := false;
            IF  (a41v.a4sh_kind in [sh_synonym, sh_all_synonyms, sh_table,
                (* PTS 1104178 *)
                sh_object, sh_all_object])
                AND
                (a41v.a4next_owner <> a01_i_public)
            THEN (* look for public synonymns *)
                BEGIN
                a41v.a4private              := true;
                a41v.a4use_base             := false;
                a41v.a4use_view             := false;
                a41v.a4next_owner           := a01_i_public;
                a41v.a4next_key.sauthid     := cak_public_id;
                a41v.a4next_key.sentrytyp   := cak_etableref;
                a41v.a4next_key.sidentifier := a41v.a4tablen;
                a41v.a4next_key.skeylen     := mxak_standard_sysk;
                a41v.a4mfetch_pos           := 1;
                a41v.a4mblock.mb_data_len   := 0;
                a41v.a4mfetch_cnt           := cak_is_undefined
                END
            ELSE
                BEGIN
                (* end of search *)
                a41v.a4temp        := false;
                a41v.a4private     := false;
                a41v.a4nonprivate  := false;
                a41v.a4public      := false;
                a41v.a4b_err       := e_key_not_found;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a40is_unique (
            VAR acv           : tak_all_command_glob;
            VAR distinct_tree : tgg00_FileId;
            VAR tabid         : tgg00_Surrogate;
            check_only        : boolean) : boolean;
 
VAR
      key     : tgg00_Lkey;
      rec_buf : tgg00_Rec;
      ins_buf : tak40_show_record;
 
BEGIN
IF  check_only
THEN
    BEGIN
    key.len := SURROGATE_MXGG00;
    SAPDB_PascalForcedMove (sizeof (tabid), sizeof (key.k),
          @tabid, 1, @key.k, 1, sizeof (tabid));
    b07cget_record (acv.a_transinf.tri_trans, distinct_tree,
          key, rec_buf);
    IF  acv.a_transinf.tri_trans.trError_gg00 = e_key_not_found
    THEN
        a40is_unique := true
    ELSE
        BEGIN
        a40is_unique := false;
        IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END
ELSE
    BEGIN
    ins_buf.shsl            := cgg_rec_key_offset + SURROGATE_MXGG00;
    ins_buf.shkl            := SURROGATE_MXGG00;
    ins_buf.shvarcol_offset := 0;
    ins_buf.shvarcol_cnt    := 0;
    SAPDB_PascalForcedMove (sizeof (tabid), sizeof (ins_buf), @tabid, 1,
          @ins_buf, cgg_rec_key_offset+1, sizeof (tabid));
    b07cadd_record (acv.a_transinf.tri_trans,
          distinct_tree, ins_buf);
    IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
    THEN
        a40is_unique := true
    ELSE
        BEGIN
        a40is_unique := false;
        IF  acv.a_transinf.tri_trans.trError_gg00 <> e_duplicate_key
        THEN
            a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40store_roles (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      b_err       : tgg00_BasisError;
      ix          : integer;
      roletab_ptr : tak_sysbufferaddress;
      sysk        : tgg00_SysInfoKey;
 
BEGIN
IF  (acv.a_role_info <> role_except) AND
    (acv.a_role_ptr  <> NIL)
THEN
    BEGIN
    ix := 1;
    WHILE ix <= acv.a_role_ptr^.rctxt_cnt DO
        BEGIN
        ak40add_role   (acv, a41v, acv.a_role_ptr^.rctxt_roles[ix]);
        ak40scan_roles (acv, a41v, acv.a_role_ptr^.rctxt_roles[ix]);
        ix := ix + 1
        END;
    (*ENDWHILE*) 
    END
ELSE
    BEGIN
    sysk           := a01defaultkey;
    sysk.sauthid   := acv.a_curr_user_id;
    sysk.sentrytyp := cak_eroletab;
    REPEAT
        a10get_sysinfo (acv, sysk, d_fix,
              roletab_ptr, b_err);
        IF  b_err = e_ok
        THEN
            WITH roletab_ptr^.susertab DO
                BEGIN
                ix := 1;
                WHILE ix <= usertabcount DO
                    WITH usertabdef[ix] DO
                        BEGIN
                        IF  NOT ut_empty
                        THEN
                            IF  NOT a06_role_excluded (acv, ut_surrogate)
                            THEN
                                BEGIN
                                ak40add_role   (acv,a41v, ut_surrogate);
                                ak40scan_roles (acv,a41v, ut_surrogate)
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        ix := ix + 1;
                        END;
                    (*ENDWITH*) 
                (*ENDWHILE*) 
                IF  roletab_ptr^.susertab.usertabnext_exist
                THEN
                    a06inc_linkage (sysk.slinkage)
                ELSE
                    b_err := e_sysinfo_not_found
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  (b_err = e_sysinfo_not_found  ) AND
            (sysk.sauthid <> cak_public_id)
        THEN
            BEGIN
            b_err         := e_ok;
            sysk.sauthid  := cak_public_id;
            sysk.slinkage := cak_init_linkage
            END;
        (*ENDIF*) 
    UNTIL
        b_err <> e_ok;
    (*ENDREPEAT*) 
    IF  b_err <> e_sysinfo_not_found
    THEN
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
    END;
(*ENDIF*) 
END; { ak40store_roles }
 
(*------------------------------*) 
 
PROCEDURE
      ak40add_role (
            VAR acv     : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            VAR role_id : tgg00_Surrogate);
 
CONST
      c_init_role_info = 16;
 
VAR
      ix                : integer;
      p                 : tak_sysbufferaddress;
      role_info_ptr     : tak40_role_info_ptr;
      new_role_info_ptr : tak40_role_info_ptr;
 
BEGIN
&ifdef trace
t01surrogate (ak_sem, 'role_id     ', role_id);
&endif
IF  acv.a_returncode = 0
THEN
    IF  a41v.a4role_cnt = 0
    THEN
        BEGIN
        a10new (acv, sizeof (tak40_role_info) - sizeof (tak40_role_arr) +
              c_init_role_info * sizeof (tgg00_Surrogate), p);
        IF  p = NIL
        THEN
            a07_b_put_error (acv, e_no_more_memory, 1)
        ELSE
            BEGIN
            a41v.a4row_ptr        := @p^;
            role_info_ptr         := @p^;
            role_info_ptr^.rl_max := c_init_role_info
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    role_info_ptr   := @a41v.a4row_ptr^;
    a41v.a4role_cnt := a41v.a4role_cnt + 1;
    IF  a41v.a4role_cnt > role_info_ptr^.rl_max
    THEN
        BEGIN
        a10new (acv, sizeof (tak40_role_info) - sizeof (tak40_role_arr) +
              (role_info_ptr^.rl_max+c_init_role_info)*sizeof (tgg00_Surrogate),
              p);
        IF  p <> NIL
        THEN
            BEGIN
            a41v.a4row_ptr            := @p^;
            new_role_info_ptr         := @p^;
            new_role_info_ptr^.rl_max :=
                  role_info_ptr^.rl_max + c_init_role_info;
            FOR ix := 1 TO role_info_ptr^.rl_max DO
                new_role_info_ptr^.rl_ids[ix] := role_info_ptr^.rl_ids[ix];
            (*ENDFOR*) 
            p := @role_info_ptr^;
            a10dispose (acv, p);
            role_info_ptr := new_role_info_ptr
            END
        ELSE
            a07_b_put_error (acv, e_no_more_memory, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    role_info_ptr^.rl_ids[a41v.a4role_cnt] := role_id
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40scan_roles (
            VAR acv       : tak_all_command_glob;
            VAR a41v      : tak40_show_glob;
            role_id       : tgg00_Surrogate);
 
VAR
      b_err       : tgg00_BasisError;
      index       : integer;
      roletab_ptr : tak_sysbufferaddress;
      sysk        : tgg00_SysInfoKey;
 
BEGIN
index          := 0;
sysk           := a01defaultkey;
sysk.sauthid   := role_id;
sysk.sentrytyp := cak_eroletab;
REPEAT
    index := index + 1;
    a10get_sysinfo (acv, sysk, d_release,
          roletab_ptr, b_err);
    IF  b_err = e_ok
    THEN
        IF  index > roletab_ptr^.susertab.usertabcount
        THEN
            IF  roletab_ptr^.susertab.usertabnext_exist
            THEN
                a06inc_linkage (sysk.slinkage)
            ELSE
                b_err := e_sysinfo_not_found
            (*ENDIF*) 
        ELSE
            WITH roletab_ptr^.susertab.usertabdef[index] DO
                IF  NOT ut_empty
                THEN
                    BEGIN
                    ak40add_role   (acv, a41v, ut_surrogate);
                    ak40scan_roles (acv, a41v, ut_surrogate)
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
UNTIL
    b_err <> e_ok;
(*ENDREPEAT*) 
IF  b_err <> e_sysinfo_not_found
THEN
    a07_b_put_error (acv, b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a40usertab_next (
            VAR acv       : tak_all_command_glob;
            VAR a41v      : tak40_show_glob;
            use_tables    : boolean;
            use_dbprocs   : boolean;
            use_sequences : boolean;
            VAR surrogate : tgg00_Surrogate;
            VAR kind      : tgg00_TableKind) : boolean;
 
VAR
      ok                  : boolean;
      systable            : boolean;
      use_base_tables     : boolean;
      use_view_tables     : boolean;
      command_id          : tsp00_Int4;
 
BEGIN
IF  use_tables
THEN
    BEGIN
    use_base_tables     := a41v.a4use_base;
    use_view_tables     := a41v.a4use_view;
    END
ELSE
    BEGIN
    use_base_tables     := false;
    use_view_tables     := false;
    END;
(*ENDIF*) 
REPEAT
&   ifdef trace
    t01int4 (ak_sem, 'a4usertabpos', a41v.a4usertab_pos);
    t01int4 (ak_sem, 'a4usertabcnt', a41v.a4usertab_cnt);
&   endif
    a41v.a4usertab_pos := a41v.a4usertab_pos + 1;
    ok            := false;
    IF  a41v.a4usertab_pos > a41v.a4usertab_cnt
    THEN
        BEGIN (* get first / next usertab record *)
        IF  a41v.a4usertab_cnt <> cak_is_undefined
        THEN
            BEGIN
            IF  a41v.a4usertab_buf^.susertab.usertabnext_exist
            THEN
                a06inc_linkage (a41v.a4next_key.slinkage)
            ELSE
                a41v.a4b_err := e_no_next_record;
            (*ENDIF*) 
            a10key_del (acv, a41v.a4usertab_buf);
            END;
        (*ENDIF*) 
        IF  a41v.a4b_err = e_ok
        THEN
            BEGIN
            command_id       := acv.a_command_id;
            acv.a_command_id := a41v.a4commandId;
            a10get_sysinfo (acv, a41v.a4next_key,
                  d_fix, a41v.a4usertab_buf, a41v.a4b_err);
            acv.a_command_id := command_id;
            END;
        (*ENDIF*) 
        IF  a41v.a4b_err = e_ok
        THEN
            BEGIN
            a41v.a4usertab_pos := 1;
            a41v.a4usertab_cnt :=
                  a41v.a4usertab_buf^.susertab.usertabcount
            END
        ELSE
            IF  a41v.a4b_err = e_sysinfo_not_found
            THEN
                a41v.a4b_err := e_no_next_record
            ELSE
                IF  a41v.a4b_err <> e_no_next_record
                THEN
                    BEGIN
                    a07_b_put_error (acv, a41v.a4b_err, 1);
                    a40ignore_down_error (acv);
                    IF  acv.a_returncode = 0
                    THEN
                        a41v.a4b_err := e_no_next_record
                    (*ENDIF*) 
                    END;
&               ifdef trace
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        t01basis_error (ak_sem, 'a4b_err     ', a41v.a4b_err);
&       endif
        IF  a41v.a4b_err = e_no_next_record
        THEN
            IF  a41v.a4nonprivate
            THEN
                BEGIN
                IF  a41v.a4next_key.slinkage[ 1 ] >= chr (128)
                THEN
                    a41v.a4nonprivate := false
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                a41v.a4public := false;
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a41v.a4b_err = e_ok
    THEN
        WITH a41v.a4usertab_buf^.susertab.usertabdef[a41v.a4usertab_pos] DO
            BEGIN
            IF  NOT ut_empty
            THEN
                CASE ut_kind OF
                    ut_internal_systable  :
                        ok := a41v.a4sys_tables AND use_tables;
                    ut_table :
                        ok := use_tables;
                    ut_base_table :
                        ok := use_base_tables;
                    ut_view :
                        ok := use_view_tables;
                    ut_oracle_systable :
                        ok := a41v.a4sys_tables AND
                              use_tables AND
                              (* PTS 1105367 E.Z. *)
                              (acv.a_sqlmode = sqlm_oracle);
                    ut_sequence :
                        ok := use_sequences;
                    ut_procedure :
                        ok := use_dbprocs;
                    OTHERWISE;
                    END;
                (*ENDCASE*) 
            (*ENDIF*) 
            IF  ok AND use_tables AND
                NOT (ut_kind in [ut_sequence, ut_procedure])
            THEN
                BEGIN
                IF  a41v.a4unique
                THEN
                    ok := a40is_unique (acv,
                          a41v.a4treeid, ut_surrogate,
                          a41v.a4next_key.sauthid = cak_public_id)
                ELSE
                    ok := true;
                (*ENDIF*) 
                IF  ok
                THEN
                    BEGIN
                    a41v.a4is_systable := (ut_kind in
                          [ut_internal_systable, ut_oracle_systable])
                          (* PTS 1105367 E.Z. *)
                          AND
                          (acv.a_sqlmode <> sqlm_oracle);
                    a06_systable_get (acv, d_release, ut_surrogate,
                          a41v.a4p_arr.pbasep, false, ok);
                    a40ignore_down_error (acv)
                    END;
                (*ENDIF*) 
                IF  ok
                THEN
                    WITH a41v.a4p_arr.pbasep^.sbase DO
                        BEGIN
&                       ifdef trace
                        t01lidentifier (ak_sem, btablen^);
&                       endif
                        kind := btablekind;
                        systable := false;
                        ok := ((a41v.a4owner_id = cgg_zero_id) OR
                              ( a41v.a4owner_id = bschema))
                              AND
                              (a41v.a4owner_id <>
                              acv.a_curr_user_id)
                              AND
                              ((a41v.a4tablen = a01_il_b_identifier) OR
                              s30eq (btablen^, a41v.a4tablen,
                              1, a41v.a4tab_len))
                              AND
                              (NOT ((systable) AND
                              ((a41v.a4tab_len < 3*a01char_size) OR
                              (a41v.a4tablen = a01_il_b_identifier))));
                        IF  ok
                        THEN
                            BEGIN
                            a06determine_username (acv,
                                  bschema, a41v.a4next_owner);
                            IF  a41v.a4next_owner = a01_i_sys
                            THEN
                                (* PTS 1105367 E.Z. *)
                                IF  acv.a_sqlmode = sqlm_oracle
                                THEN
                                    BEGIN
                                    IF  (btablen^[1] = 'D') AND
                                        (btablen^[2] = 'B') AND
                                        (btablen^[3] = 'A') AND
                                        (btablen^[4] = '_') AND
                                        NOT (acv.a_current_user_kind
                                        in [ udba, usysdba,
                                        ucontroluser ])
                                    THEN
                                        ok := false;
                                    (*ENDIF*) 
                                    END
                                ELSE
                                    ok := false;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            surrogate     := ut_surrogate;
                            a41v.a4next_tablen := btablen^
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
                END
            ELSE
                IF  ok
                THEN (* sequence or dbproc *)
                    BEGIN
                    IF  a41v.a4unique
                    THEN
                        ok := a40is_unique (acv,
                              a41v.a4treeid, ut_surrogate,
                              a41v.a4next_key.sauthid = cak_public_id)
                    ELSE
                        ok := true;
                    (*ENDIF*) 
                    kind      := tempty;
                    surrogate := ut_surrogate;
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  (a41v.a4b_err = e_no_next_record) AND a41v.a4nonprivate
    THEN
        BEGIN
        a41v.a4next_key.slinkage      := cak_init_linkage;
        a41v.a4next_key.slinkage[ 1 ] := chr (128);
        a41v.a4usertab_pos := 1;
        a41v.a4usertab_cnt := cak_is_undefined;
        a41v.a4b_err       := e_ok;
        ok            := false
        END;
    (*ENDIF*) 
UNTIL
    ok OR (acv.a_returncode <> 0) OR (a41v.a4b_err <> e_ok);
(*ENDREPEAT*) 
a40usertab_next := ok AND (acv.a_returncode = 0)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a40username_from_syskey (
            VAR sysk      : tgg00_SysInfoKey;
            VAR user_name : tsp00_KnlIdentifier);
 
BEGIN
SAPDB_PascalForcedMove (sizeof(sysk), sizeof(user_name),
      @sysk, cgg_rec_key_offset + 1,
      @user_name, 1, SURROGATE_MXGG00);
SAPDB_PascalForcedMove (sizeof(sysk), sizeof(user_name),
      @sysk, cgg_rec_key_offset + SURROGATE_MXGG00 + 5,
      @user_name, SURROGATE_MXGG00 + 1, sizeof(user_name) - SURROGATE_MXGG00)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak40add_ref_qualification (
            VAR acv      : tak_all_command_glob;
            VAR a41v     : tak40_show_glob;
            VAR startkey : tgg00_Lkey;
            VAR stopkey  : tgg00_Lkey;
            work_buf     : tak40_int2_arr_ptr);
 
CONST
      c_objectname_colno  = 4;
      c_reftabname_colno  = 7;
      c_tabname_colno     = 2;
      c_priv_tabname_colno= 3;
 
VAR
      colno       : integer;
      sys_st      : integer;
      ix          : integer;
      kind_cnt    : integer;
      and_cnt     : integer;
      sys_len     : integer;
      stack_mark  : integer;
      i_index     : tsp00_KnlIdentifier;
 
      kind_arr : ARRAY[1..10] OF RECORD
            kkind  : tgg00_TableKind;
            kstpos : integer;
      END;
 
 
BEGIN
WITH a41v.a4mblock, mb_qual^ DO
    BEGIN
    mb_st^[ 1 ].etype          := st_jump_output;
    mb_st^[ 1 ].eop            := op_none;
    mb_st^[ 1 ].epos           := 2;
    mb_st^[ 1 ].elen_var       := 0;
    mb_st^[ 1 ].ecol_tab[ 1 ]  := chr(0);
    mb_st^[ 1 ].ecol_tab[ 2 ]  := chr(0);
    mb_st^[ 2 ]                := mb_st^[ 1 ];
    mb_st^[ 2 ].etype          := st_rec_output;
    mb_st^[ 2 ].epos           := 0;
    mqual_pos   := 1;
    mqual_cnt   := 2;
    mfirst_free := 3;
    sys_st      := 0;
    kind_cnt    := 0;
    and_cnt     := 0;
    IF  NOT a41v.a4temp
    THEN
        BEGIN
&       ifdef trace
        t01qual (ak_sem, a41v.a4mblock.mb_qual^);
&       endif
        IF  a41v.a4use_base
        THEN
            BEGIN (* base tables are required *)
            kind_cnt          := 2;
            kind_arr[1].kkind := twithkey;
            kind_arr[2].kkind := twithoutkey
            END;
        (*ENDIF*) 
        IF  a41v.a4use_view
        THEN
            BEGIN (* view tables are required *)
            kind_cnt                 := kind_cnt + 1;
            kind_arr[kind_cnt].kkind := tview
            END;
        (*ENDIF*) 
        IF  a41v.a4syns AND (a41v.a4sh_kind <> sh_no_kind)
        THEN
            BEGIN (* synonyms are required *)
            kind_cnt                 := kind_cnt + 1;
            kind_arr[kind_cnt].kkind := tsynonym;
            kind_cnt                 := kind_cnt + 1;
            kind_arr[kind_cnt].kkind := tempty
            END;
        (*ENDIF*) 
        IF  ak40use_sequences (a41v)
        THEN
            BEGIN (* sequences are required *)
            kind_cnt                 := kind_cnt + 1;
            kind_arr[kind_cnt].kkind := tempty
            END;
        (*ENDIF*) 
        FOR ix := 1 TO kind_cnt DO
            BEGIN
            mqual_cnt := mqual_cnt + 1;
            WITH mb_st^[mqual_cnt] DO
                BEGIN
                etype    := st_fixcol;
                eop      := op_none;
                epos     := 5;
                elen_var := 1;
                ecol_tab := cgg_zero_c2
                END;
            (*ENDWITH*) 
            mqual_cnt := mqual_cnt + 1;
            kind_arr[ix].kstpos := mqual_cnt;
            WITH mb_st^[mqual_cnt] DO
                BEGIN
                etype       := st_value;
                eop         := op_eq_all;
                elen_var    := 1;
                ecol_tab[1] := chr(0);
                ecol_tab[2] := chr(0);
                END;
            (*ENDWITH*) 
            IF  ix < kind_cnt
            THEN
                BEGIN
                mqual_cnt := mqual_cnt + 1;
                WITH mb_st^[mqual_cnt] DO
                    BEGIN
                    etype    := st_jump_true;
                    eop      := op_none;
                    epos     := (kind_cnt - ix) * 3 +
                          (kind_cnt - ix);
                    elen_var := 0;
                    ecol_tab := cgg_zero_c2
                    END;
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        FOR ix := 1 TO kind_cnt - 1 DO
            BEGIN
            mqual_cnt := mqual_cnt + 1;
            WITH mb_st^[mqual_cnt] DO
                BEGIN
                etype         := st_op;
                eop           := op_or;
                epos          := 0;
                elen_var      := 0;
                ecol_tab      := cgg_zero_c2
                END;
            (*ENDWITH*) 
            END;
        (*ENDFOR*) 
        IF  (sys_st > 0) AND (kind_cnt > 0)
        THEN
            BEGIN
            mqual_cnt := mqual_cnt + 1;
            WITH mb_st^[mqual_cnt] DO
                BEGIN
                etype         := st_op;
                eop           := op_and;
                epos          := 0;
                elen_var      := 0;
                ecol_tab      := cgg_zero_c2
                END;
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    mfirst_free := mqual_cnt + 1;
    FOR ix := 1 TO kind_cnt DO
        BEGIN
        mb_data_len                := mb_data_len  + 1;
        mb_data^.mbp_buf[ mb_data_len ] :=
              chr(ord(kind_arr[ix].kkind));
        mb_st^[kind_arr[ix].kstpos].epos := mb_data_len
        END;
    (*ENDFOR*) 
    IF  a41v.a4systab_select
    THEN
        BEGIN
        IF  mqual_cnt > 2
        THEN
            mfirst_free := mfirst_free + 1;
        (*ENDIF*) 
        stack_mark := mfirst_free;
        CASE a41v.a4sh_kind OF
            sh_link :
                colno := c_reftabname_colno;
            sh_object, sh_all_object :
                BEGIN
                a061assign_colname ('INDEX             ', i_index);
                a01setl_identifier (i_index, i_index);
                IF  a722test_col_qual (acv, a41v,
                    cak_ln_type, ' ', @i_index, 10, work_buf)
                THEN
                    colno := cak_is_undefined
                ELSE
                    colno := c_objectname_colno;
                (*ENDIF*) 
                END;
            sh_all_new_privileges,
            sh_new_privileges,
            sh_p_prog :
                colno := c_priv_tabname_colno;
            OTHERWISE
                colno := c_tabname_colno;
            END;
        (*ENDCASE*) 
        IF  colno <> cak_is_undefined
        THEN
            BEGIN
            a41v.a4mblock.mb_st_max := a41v.a4mblock.mb_st_max - 1;
            a722add_col_qual (acv, a41v, a41v.a4mblock, colno,
                  startkey, stopkey, work_buf);
            a41v.a4mblock.mb_st_max := a41v.a4mblock.mb_st_max + 1
            END;
        (*ENDIF*) 
        IF  (mfirst_free <> stack_mark) AND (stack_mark > 3)
        THEN
            BEGIN
            WITH mb_st^[stack_mark - 1] DO
                BEGIN
                etype    := st_jump_false;
                eop      := op_none;
                epos     := mfirst_free - stack_mark + 2;
                elen_var := 0;
                ecol_tab := cgg_zero_c2
                END;
            (*ENDWITH*) 
            WITH mb_st^[mfirst_free] DO
                BEGIN
                etype    := st_op;
                eop      := op_and;
                epos     := 0;
                elen_var := 0;
                ecol_tab := cgg_zero_c2
                END;
            (*ENDWITH*) 
            mqual_cnt := mqual_cnt + 1
            END;
        (*ENDIF*) 
        mfirst_free := mqual_cnt + 1;
&       ifdef trace
        t01qual (ak_sem, a41v.a4mblock.mb_qual^);
        t01buf1 (ak_sem, a41v.a4mblock.mb_qual^.buf, 1, a41v.a4mblock.mb_qual_len );
&       endif
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak40use_base_tables (VAR a41v : tak40_show_glob) : boolean;
 
BEGIN
ak40use_base_tables := a41v.a4sh_kind in
      [sh_no_kind,
      sh_column,
      sh_odbc_columns,
      sh_constraint,
      sh_cons_columns,
      sh_index,
      sh_odbc_index, (* PTS 1114119 T.A. *)
      sh_link,
      sh_new_privileges,
      sh_odbc_st_index,
      sh_odbc_st_table,
      sh_object,
      sh_optimizerinformation,
      sh_p_prog,
      sh_pages,
      sh_param_trigger,
      sh_priv_granted_to,
      sh_st_index,
      sh_indexpages,
      sh_st_table,
      sh_table,
      sh_table_stat,
      sh_trigger,
      sh_roots,
      sh_all_column,
      sh_all_constraint,
      sh_all_cons_columns,
      sh_all_foreign_key,
      sh_all_index,
      sh_all_new_privileges,
      sh_all_object,
      sh_all_priv_granted,
      sh_all_table,
      sh_all_triggers]
END;
 
(*------------------------------*) 
 
FUNCTION
      ak40use_sequences (VAR a41v : tak40_show_glob) : boolean;
 
BEGIN
ak40use_sequences := (a41v.a4sh_kind in
      [sh_no_kind,
      sh_object,
      sh_p_prog,
      sh_sequence,
      sh_new_privileges,
      sh_all_new_privileges,
      sh_all_object,
      sh_all_sequences])
END;
 
(*------------------------------*) 
 
FUNCTION
      ak40use_view_tables (VAR a41v : tak40_show_glob) : boolean;
 
BEGIN
ak40use_view_tables := a41v.a4sh_kind in
      [sh_no_kind,
      sh_column,
      sh_odbc_columns,
      sh_new_privileges,
      sh_object,
      sh_p_prog,
      sh_priv_granted_to,
      sh_ref_column,
      sh_show_view,
      sh_table,
      sh_view,
      sh_view_uses_table,
      sh_all_column,
      sh_all_new_privileges,
      sh_all_object,
      sh_all_priv_granted,
      sh_all_table,
      sh_all_views,
      sh_all_view_uses_table,
      sh_all_ref_columns]
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
