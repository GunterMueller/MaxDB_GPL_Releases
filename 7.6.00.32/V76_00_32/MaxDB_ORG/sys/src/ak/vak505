.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 2000-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-21
*****************************************************
modname : VAK505
changed : 2000-11-21
module  : Executing_loop_most
 
Author  : ElkeZ
Created : 1985-07-09
*****************************************************
 
Purpose : Module in which the loop for handling normal
          commands is processed.
 
Define  :
 
        PROCEDURE
              a505const_param_expression  (
                    VAR acv              : tak_all_command_glob;
                    VAR dmli             : tak_dml_info;
                    VAR mblock           : tgg00_MessBlock);
 
        PROCEDURE
              a505check_if_executed (
                    VAR acv        : tak_all_command_glob;
                    VAR test_name  : tsp00_KnlIdentifier;
                    VAR test_tree  : tgg00_FileId);
 
        PROCEDURE
              a505execute_link (
                    VAR acv   : tak_all_command_glob;
                    VAR parsk : tak_parskey;
                    pno       : integer);
 
        PROCEDURE
              a505fill_mess_buf (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    VAR erec   : tak_exec_rec; (* PTS 1112612 *)
                    VAR frec   : tak_fill_rec;
                    full_part2 : boolean);
 
        PROCEDURE
              a505get_change_rec (
                    VAR acv            : tak_all_command_glob;
                    VAR sparr          : tak_syspointerarr;
                    VAR change_rec     : tak_changerecord);
 
        PROCEDURE
              a505loop_most_execute (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    VAR change_rec : tak_changerecord;
                    VAR erec       : tak_exec_rec;
                    VAR parsk      : tak_parskey;
                    viewkeybuf     : tak_sysbufferaddress;
                    VAR series     : tak68_sequence;
                    VAR cinfo      : tak_corr_infos;
                    VAR old_cinfo  : tak_corr_infos;
                    inner_loop     : boolean);
 
        PROCEDURE
              a505most_execute (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    VAR change_rec : tak_changerecord;
                    VAR parsk      : tak_parskey;
                    VAR erec       : tak_exec_rec;
                    VAR cinfo      : tak_corr_infos;
                    VAR old_cinfo  : tak_corr_infos;
                    viewkeybuf     : tak_sysbufferaddress;
                    inner_loop     : boolean);
 
        PROCEDURE
              a505next_command (
                    VAR acv       : tak_all_command_glob;
                    VAR sparr     : tak_syspointerarr;
                    VAR old_parsk : tak_parskey;
                    ex_plus       : integer);
 
        PROCEDURE
              a505strategy_search (
                    VAR acv          : tak_all_command_glob;
                    VAR dmli         : tak_dml_info;
                    mtype            : tgg00_MessType;
                    VAR searchname   : tsp00_KnlIdentifier;
                    VAR act_res_tree : tgg00_FileId;
                    VAR ssr_rec      : tak71_select_strat_rec;
                    VAR qbufp        : tak_sysbufferaddress;
                    VAR parsk        : tak_parskey;
                    not_last         : boolean);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01sysnullkey        : tgg00_SysInfoKey;
              a01defaultkey        : tgg00_SysInfoKey;
              a01_zero_res_name    : tsp00_KnlIdentifier;
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05qualification_test (
                    VAR acv        : tak_all_command_glob;
                    VAR m          : tgg00_MessBlock;
                    result_wanted  : boolean;
                    check_new_rec  : boolean;
                    error_pos      : integer;
                    VAR rec        : tgg00_Rec;
                    VAR result_buf : tsp00_Buf;
                    resultBufSize  : tsp00_Int4;
                    VAR result_len : integer);
 
        PROCEDURE
              a05varqualification_test (
                    VAR acv        : tak_all_command_glob;
                    VAR m          : tgg00_MessBlock;
                    result_wanted  : boolean;
                    check_new_rec  : boolean;
                    error_pos      : integer;
                    fieldlistno    : integer;
                    VAR result_no  : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06cpy_mblock (
                    VAR acv        : tak_all_command_glob;
                    VAR src_mblock : tgg00_MessBlock;
                    VAR dst_mblock : tgg00_MessBlock;
                    withoutData    : boolean;
                    VAR e          : tgg00_BasisError);
 
        PROCEDURE
              a06drop_fieldlist_references (VAR fieldlists : tgg00_FieldLists);
 
        PROCEDURE
              a06drop_ex_fieldlist_refs (VAR fieldlists : tgg00_FieldLists);
 
        PROCEDURE
              a06retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
        PROCEDURE
              a06finish_curr_retpart (
                    VAR acv   : tak_all_command_glob;
                    part_kind : tsp1_part_kind;
                    arg_count : tsp00_Int2);
 
        PROCEDURE
              a06put_errtext (
                    VAR acv       : tak_all_command_glob;
                    b_err_in      : tgg00_BasisError;
                    err_type      : tgg04_ErrorText;
                    errtext_len   : integer;
                    VAR errtext   : tsp00_C256;
                    VAR b_err_out : tgg00_BasisError);
 
        PROCEDURE
              a06a_mblock_init (
                    VAR acv  : tak_all_command_glob;
                    mtype    : tgg00_MessType;
                    m2type   : tgg00_MessType2;
                    VAR tree : tgg00_FileId);
 
        PROCEDURE
              a06dml_send_mess_buf (
                    VAR acv    : tak_all_command_glob;
                    VAR mblock : tgg00_MessBlock;
                    VAR dmli   : tak_dml_info;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              a06subquery_del_result (
                    VAR acv           : tak_all_command_glob;
                    VAR dmli          : tak_dml_info;
                    VAR subquery_tree : tgg00_FileId;
                    prefix_len        : integer);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10_rel_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey);
 
        PROCEDURE
              a10key_del  (
                    VAR acv        : tak_all_command_glob;
                    VAR syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10invalidate_root (
                    VAR acv    : tak_all_command_glob;
                    VAR treeid : tgg00_FileId);
 
        PROCEDURE
              a10mblock_into_cache (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    VAR mblock   : tgg00_MessBlock;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10new (
                    VAR acv  : tak_all_command_glob;
                    obj_size : tsp00_Int4;
                    VAR p    : tgg00_StackListPtr);
 
        PROCEDURE
              a10dispose (
                    VAR acv : tak_all_command_glob;
                    VAR p : tgg00_StackListPtr);
 
        PROCEDURE
              a10repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
        FUNCTION
              a101_GetExtendedTempFileType(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tgg00_TfnTemp;
 
        PROCEDURE
              a101_SetTempFileLevel(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId;
                    level          : tsp00_Int2(*ptocConst*));
 
        FUNCTION
              a101_GetTempFileLevel(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tsp00_Int2;
 
        PROCEDURE
              a101_SetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId;
                    sublevel       : tsp00_Int4(*ptocConst*));
 
        FUNCTION
              a101_GetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tsp00_Int4;
 
        PROCEDURE
              a101_GetTempFileInstance(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
        PROCEDURE
              a101_GetLogicalFilename(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
        PROCEDURE
              a101_DestroyGroupedTempFile(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
        PROCEDURE
              a101_ExistsGroupedTempFile(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              SequenceWrapper : VAK104;
 
        FUNCTION
              ak104_CreateIncrementalMemorySequence (
                    allocator    : tgg00_VoidPtr;
                    refMode      : tak104_refcountMode;
                    VAR sequence : tsp00_MoveObjPtr;
                    msglist      : tak104_MsgList) : boolean;
 
        PROCEDURE
              ak104_TruncateField_IMS (
                    sequence : tsp00_MoveObjPtr;
                    index    : tsp00_Int4);
 
        FUNCTION
              ak104_GetReference_MS (
                    sequence     : tsp00_MoveObjPtr) : tsp00_MoveObjPtr;
 
        PROCEDURE
              ak104_DropReference_MS (
                    VAR sequence     : tsp00_MoveObjPtr);
 
      ------------------------------ 
 
        FROM
              AK_Comment : VAK26;
 
        PROCEDURE
              a26execute_comment (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
      ------------------------------ 
 
        FROM
              AK_update_statistics : VAK28;
 
        PROCEDURE
              a28sys_upd_statistics (
                    VAR acv     : tak_all_command_glob;
                    VAR tree    : tgg00_FileId;
                    mtype       : tgg00_MessType;
                    m2type      : tgg00_MessType2;
                    known_pages : tsp00_Int4;
                    found_pages : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Executing_complex : VAK502;
 
        PROCEDURE
              a502correlation_execute (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    VAR change_rec : tak_changerecord;
                    VAR erec       : tak_exec_rec;
                    VAR parsk      : tak_parskey;
                    VAR old_cinfo  : tak_corr_infos;
                    inner_loop     : boolean);
 
        PROCEDURE
              a502destroy_file (
                    VAR acv          : tak_all_command_glob;
                    VAR tree         : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              Executing_union : VAK503;
 
        PROCEDURE
              a503build_union_buffer (
                    VAR acv : tak_all_command_glob;
                    in_join : boolean);
 
      ------------------------------ 
 
        FROM
              Executing_values : VAK506;
 
        PROCEDURE
              a506fieldvalues (
                    VAR acv       : tak_all_command_glob;
                    VAR dmli      : tak_dml_info;
                    VAR frec      : tak_fill_rec;
                    viewkeybuf    : tak_sysbufferaddress;
                    VAR result    : tsp00_MoveObj;
                    resultBufSize : tsp00_Int4); (* PTS 1115085 *)
 
        PROCEDURE
              a506lock_fieldvalues (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    VAR frec   : tak_fill_rec;
                    viewkeybuf : tak_sysbufferaddress);
 
        PROCEDURE
              a506result_name (
                    VAR acv     : tak_all_command_glob;
                    VAR dmli    : tak_dml_info);
 
      ------------------------------ 
 
        FROM
              Executing_finish : VAK507;
 
        PROCEDURE
              a507last_command_part (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    VAR change     : tak_changerecord;
                    VAR parsk      : tak_parskey;
                    VAR resnam     : tsp00_KnlIdentifier;
                    VAR w_link     : boolean;
                    qbufp          : tak_sysbufferaddress;
                    VAR ssr_rec    : tak71_select_strat_rec;
                    pos            : integer;
                    mtype          : tgg00_MessType;
                    m2type         : tgg00_MessType2;
                    output_wanted  : boolean);
 
        PROCEDURE
              a507_putval (
                    VAR acv               : tak_all_command_glob;
                    startpos              : integer;
                    intern_call           : boolean;
                    last_longdesc         : boolean;
                    VAR not_finished_long : tsp00_LongDescriptor);
 
        PROCEDURE
              a507_literal (
                    VAR acv             : tak_all_command_glob;
                    VAR longliteralrec  : tak_longliteral_rec;
                    useliteralbuf       : boolean);
 
        FUNCTION
              a507optim_select_fetch (
                    VAR acv   : tak_all_command_glob;
                    VAR dmli  : tak_dml_info;
                    prepare   : boolean;
                    info_byte : tsp00_Uint1;
                    loop_cnt  : integer) : boolean;
 
      ------------------------------ 
 
        FROM
              Pseudo_fieldmap : VAK509;
 
        FUNCTION
              a509get_one_value (map_ptr : tsp00_MoveObjPtr;
                    value_no       : tsp00_Int2;
                    VAR value_ptr  : tsp00_MoveObjPtr;
                    VAR value_len  : tsp00_Int4;
                    VAR is_null    : boolean;
                    VAR is_default : boolean) : boolean;
 
        PROCEDURE
              a509set_value_to_null (map_ptr : tsp00_MoveObjPtr;
                    value_no : integer);
 
        FUNCTION
              a509value_cnt (map_ptr : tsp00_MoveObjPtr) : tsp00_Int2;
 
        FUNCTION
              a509is_long_value (map_ptr : tsp00_MoveObjPtr;
                    value_no : integer) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51_internal_trans (VAR acv : tak_all_command_glob;
                    VAR old_trans : tgg00_UnivTrans);
 
        PROCEDURE
              a51close_internal_trans (VAR acv : tak_all_command_glob;
                    VAR old_trans : tgg00_UnivTrans;
                    m_type        : tgg00_MessType);
 
      ------------------------------ 
 
        FROM
              AK_Lock_Commit_Rollback : VAK52;
 
        PROCEDURE
              a52init_subtrans_of_new_trans (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a52_rest_lock_statement (
                    VAR acv       : tak_all_command_glob;
                    VAR isparr    : tak_syspointerarr;
                    VAR back_lock : tak_ak_all_locks;
                    returncode    : boolean;
                    complicate    : boolean);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK54;
 
        PROCEDURE
              a54_dml_init (
                    VAR acv   : tak_all_command_glob;
                    VAR dmli  : tak_dml_info;
                    in_union  : boolean);
 
        PROCEDURE
              a54_dml_finalize (
                    VAR dmli         : tak_dml_info;
                    VAR TransContext : tgg00_TransContext);
 
        PROCEDURE
              a54_view_put_into (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
      ------------------------------ 
 
        FROM
              AK_Delete : VAK58;
 
        PROCEDURE
              a58destroy_linkfile (
                    VAR acv : tak_all_command_glob;
                    file_id : integer);
 
        PROCEDURE
              a58exec_link_caused_dml (
                    VAR acv     : tak_all_command_glob;
                    parsp       : tak_sysbufferaddress;
                    file_id     : tsp00_Int2;
                    VAR cascade : boolean;
                    self_ref    : boolean);
 
        PROCEDURE
              a58delete_with_link (
                    VAR acv     : tak_all_command_glob;
                    VAR tabid   : tgg00_Surrogate;
                    linkindex   : integer;
                    parsno      : integer;
                    use_file_id : integer);
 
      ------------------------------ 
 
        FROM
              DML-Join-View-Procedures : VAK59;
 
        PROCEDURE
              a59handle_qualification (
                    VAR acv     : tak_all_command_glob;
                    VAR rec_buf : tsp00_MoveObj;
                    VAR b_err   : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Select_Syntax : VAK60;
 
        PROCEDURE
              a60_change_results (
                    VAR acv        : tak_all_command_glob;
                    VAR data       : tsp00_MoveObj;
                    VAR change_rec : tak_changerecord;
                    startpos       : integer;
                    curr_resreclen : integer);
 
      ------------------------------ 
 
        FROM
              Resultname_handling : VAK663;
 
        PROCEDURE
              a663_get_result_info (
                    VAR acv          : tak_all_command_glob;
                    VAR resname      : tsp00_KnlIdentifier;
                    VAR modul_name   : tsp00_KnlIdentifier;
                    VAR resname_addr : tak_sysbufferaddress;
                    make_new_res     : boolean;
                    ftemptype        : tgg00_TfnTemp;
                    dstate           : tak_directory_state;
                    VAR f_ok         : boolean);
 
        PROCEDURE
              a663_resname (
                    VAR acv          : tak_all_command_glob;
                    VAR res_name     : tsp00_KnlIdentifier;
                    VAR modul_name   : tsp00_KnlIdentifier;
                    VAR resname_addr : tak_sysbufferaddress;
                    dstate           : tak_directory_state;
                    errorpos         : integer);
 
      ------------------------------ 
 
        FROM
              Join_Select_execution : VAK682;
 
        PROCEDURE
              a682_execute_join (
                    VAR acv         : tak_all_command_glob;
                    VAR dmli        : tak_dml_info;
                    VAR series      : tak68_sequence;
                    VAR res_tree    : tgg00_FileId;
                    VAR parsk       : tak_parskey;
                    VAR jvrec       : tak68_joinview_rec;
                    use_old_rescnt  : boolean;
                    MBlocks_created : boolean);
 
        PROCEDURE
              a682_only_ex_join (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    VAR parsk      : tak_parskey;
                    VAR res_tree   : tgg00_FileId;
                    use_old_rescnt : boolean);
 
        PROCEDURE
              a682join_MBlock_key (
                    VAR acv         : tak_all_command_glob;
                    VAR dmli        : tak_dml_info;
                    VAR parsk       : tak_parskey;
                    VAR jv_tabid    : tgg00_Surrogate;
                    seqno           : tsp00_Int2;
                    VAR syskey      : tgg00_SysInfoKey;
                    use_stmt_parsk  : boolean);
 
        PROCEDURE
              a682_execute_join_operator (
                    VAR acv             : tak_all_command_glob;
                    VAR dmli            : tak_dml_info;
                    VAR series          : tak68_sequence;
                    VAR res_tree        : tgg00_FileId;
                    VAR parsk           : tak_parskey;
                    VAR jvrec           : tak68_joinview_rec;
                    use_old_rescnt      : boolean;
                    MBlocks_created     : boolean);
 
      ------------------------------ 
 
        FROM
              Build_Strategy : VAK70;
 
        VAR
              a70glob_fetch_strats      : tgg07_StratEnumSet;
              a70glob_key_fetch_strats  : tgg07_StratEnumSet;
              a70glob_inv_fetch_strats  : tgg07_StratEnumSet;
 
        PROCEDURE
              a70_invkeylen (
                    VAR acv       : tak_all_command_glob;
                    VAR strat     : tgg07_StrategyInfo;
                    VAR invkeylen : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Build_Strategy_2 : VAK71;
 
        PROCEDURE
              a71turn_into_build_strat (
                    VAR acv      : tak_all_command_glob;
                    VAR strategy : tgg07_StratEnum);
 
      ------------------------------ 
 
        FROM
              Build_Strategy_4 : VAK721;
 
        PROCEDURE
              a721strategy (
                    VAR acv           : tak_all_command_glob;
                    VAR dmli          : tak_dml_info;
                    VAR gg_strategy   : tgg07_StrategyInfo;
                    VAR StratInfo_len : tsp00_Int2;
                    VAR parsk         : tak_parskey;
                    config            : tak00_access_configuration);
 
      ------------------------------ 
 
        FROM
              Hint_Handling   : VAK80;
 
        PROCEDURE
              a80get_access_hint(
                    VAR acv         : tak_all_command_glob;
                    parskey         : tak_parskey;
                    VAR access_hint : tak00_access_configuration );
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
        PROCEDURE
              b01empty_file (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              b01filestate (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_7 : VBD07;
 
        PROCEDURE
              b07cget_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Lkey;
                    VAR b       : tgg00_Rec);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code                  : tgg04_CodeGlobals;
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04build_temp_tree_id (
                    VAR curr : tgg00_FileId;
                    VAR t : tgg00_TransContext);
 
        PROCEDURE
              g04inbetween_change (
                    VAR mblock           : tgg00_MessBlock;
                    VAR finding_possible : boolean);
 
        PROCEDURE
              g04mblock_optimize_info (VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              g04spec_null_check (
                    VAR mblock : tgg00_MessBlock;
                    VAR b_err : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              GG_allocator_interface : VGG941;
 
        FUNCTION
              gg941Allocate(VAR TransContext : tgg00_TransContext;
                    wantedBytes : integer) : tsp00_Addr;
 
        PROCEDURE
              gg941Deallocate(VAR TransContext : tgg00_TransContext;
                    VAR p : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20int4_to_buf_swap (
                    val        : tsp00_Int4;
                    sourceswap : tsp00_SwapKind;
                    VAR dest   : tsp00_Key;
                    di         : tsp00_Int4;
                    destswap   : tsp00_SwapKind);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30lnr_defbyte (
                    str       : tsp00_MoveObjPtr;
                    defbyte   : char;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              GET-Conversions : VSP40;
 
        PROCEDURE
              s40g4int (
                    VAR buf  : tsp00_ResNum;
                    pos      : tsp00_Int4;
                    VAR dest : tsp00_Int4;
                    VAR res  : tsp00_NumError);
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01mess2type (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    mess2_type    : tgg00_MessType2);
 
        PROCEDURE
              t01surrogate (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname (*ptocSynonym const char**);
                    VAR tabid : tgg00_Surrogate);
 
        PROCEDURE
              t01bool (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    curr_bool: boolean);
 
        PROCEDURE
              t01knl_identifier (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01lidentifier (
                    level      : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01buf  (
                    level     : tgg00_Debug;
                    VAR buf   : tak_systembuffer;
                    pos_start : integer;
                    pos_end   : integer);
 
        PROCEDURE
              t01buf1 (
                    level     : tgg00_Debug;
                    VAR buf   : tsp00_Buf;
                    pos_start : integer;
                    pos_end   : integer);
 
        PROCEDURE
              t01name (
                    level : tgg00_Debug;
                    nam : tsp00_Name);
 
        PROCEDURE
              t01treeid (
                    level      : tgg00_Debug;
                    nam        : tsp00_Sname;
                    VAR treeid : tgg00_FileId);
 
        PROCEDURE
              t01longdescriptor (
                    debug     : tgg00_Debug;
                    long_desc : tsp00_LongDescriptor);
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR mblock    : tgg00_MessBlock);
 
        PROCEDURE
              t01moveobj (
                    debug       : tgg00_Debug;
                    VAR moveobj : tsp00_MoveObj;
                    startpos    : tsp00_Int4;
                    endpos      : tsp00_Int4);
 
        PROCEDURE
              t01stackentry (
                    debug          : tgg00_Debug;
                    VAR st         : tgg00_StackEntry;
                    entry_index    : integer);
 
        PROCEDURE
              t01qual_kind (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    qual_kind : tgg00_QualKind);
&       ENDIF
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              a10new;
 
              tak_sysbufferaddress tgg00_StackListPtr
 
        PROCEDURE
              a10dispose;
 
              tak_sysbufferaddress tgg00_StackListPtr
 
        PROCEDURE
              a101_GetModuleName;
 
              tgg00_VoidPtr tsp00_MoveObjPtr
 
        FUNCTION
              ak104_CreateIncrementalMemorySequence;
 
              tak104_Allocator tgg00_VoidPtr
              tak104_IncrementalMemorySequence tsp00_MoveObjPtr
 
        PROCEDURE
              ak104_TruncateField_IMS;
 
              tak104_IncrementalMemorySequence tsp00_MoveObjPtr
 
        FUNCTION
              ak104_GetReference_MS;
 
              tak104_MemorySequence tsp00_MoveObjPtr
 
        PROCEDURE
              ak104_DropReference_MS;
 
              tak104_MemorySequence tsp00_MoveObjPtr
 
        PROCEDURE
              a59handle_qualification;
 
              tgg00_Rec tsp00_MoveObj
 
        PROCEDURE
              s20int4_to_buf_swap;
 
              tsp00_MoveObj tsp00_Key
 
        PROCEDURE
              s40g4int;
 
              tsp00_MoveObj tsp00_ResNum
 
        PROCEDURE
              t01buf;
 
              tsp00_Buf tak_systembuffer
 
        PROCEDURE
              t01addr;
 
              tsp00_Buf tsp00_MoveObjPtr
 
.CM *-END-* synonym -------------------------------------
***********************************************************
 
Description:
 
A505LOOP_MOST_EXECUTE
-----------------------------
 
Helptree contains the file description for the result file that is to
be used for the last message buffer within this LOOP_MOST_EXECUTE.  This
file description is important in the case of an unnamed result set in
which this is already known or in the case of correlated
subqueries for which individual records are added to the existing file
again and again.
 
Roll_back_executed specifies whether a A06_PARTIAL_ROLLBACK must be
issued in the event of an error.  This is, of course, unnecessary in the
case of SELECTs.
 
View_check_after_dml is set to true if a change operation is executed,
i.e. the next join check follows, i.e. any error that has occurred
must be converted.
 
In a WHILE loop, all message-buffer information records up to the
number specified in erec.maxbufs are processed.  Except in the case of
correlated subqueries, this value is always the same as the
parse id.p_no passed in the SQL_PACKET.
 
Plus specifies the number of the first parse-information record to
be fetched.
 
The parse-information records fetched in A50DO_EXECUTE are released
(never deleted) and new records are fetched via NEXT_COMMAND.
 
If a join check must be carried out for a join-view change operation
(m_key, mm_nokey), the record jvrec must be initialized.
The join is processed via JOIN_VIEW_CHECK.  If it was the check after an
insert or update and the records do not fulfill the join conditions,
the error value_out_of_range is forced.
 
If no join check is to be executed, the subcntlevel (the level of the
subqueries) is determined, i.e. the number contained in all temporary
file names that can be deleted after this subcommand has been executed.
 
The subcommand is processed via A53_MOST_EXECUTE.  This procedure
supplies, among other things, the res_fn, i.e. the result file name of
the SELECT that has just been executed (internal help-file name, if
applicable).  This is later assigned old_res_fn so that it is also
known after the next loop run.
 
If the old_res_fn supplied by A53_MOST_EXECUTE of the previous loop
has the appearance of an internal help-file name for complicated SELECTs
(multiphase SELECTs, compare VAK66 two_phase, three_phase), the
associated file can now be deleted.
 
Internally, INSERT ... SELECT is always parsed and executed separately.
In such a case, however, the parse information for the link check is
not yet available.  For this reason, the link check for such
INSERT .. SELECTs must be carried out in VAK56 after the execution
of A50_DO_EXECUTE.  In all other cases, the link check now takes place.
If errors occur during this link check, a A06_PARTIAL_ROLLBACK is executed
immediately.  For this reason, a repeated partial_rollback
must be prevented (roll_back_executed).
 
The results of subqueries on a lower level are deleted.
 
In the case of SELECTs in which errors occured, as a precautionary
measure the last result file to be created is again deleted/emptied.
 
If an error occurs, a command rollback must be performed if it has not
already occurred (links) and is necessary (not with SELECTs).
 
A505MOST_EXECUTE
-----------------------------
 
This procedure builds a mess buffer with the aid of parse-information
records that are located in sparr and data that are contained in the
SQL_PACKET and sends this buffer to KB for the purpose of execution.
The procedure is called by VAK50 if a command that was previously parsed
needs only to be executed.
 
The variable not_last indicates whether this is the last mess
buffer to be processed for an entire command.  This can be queried
since plus contains the first number of the parse-information records
that is relevant for this part of the command, a maximum of 4
parse-information records exist for each mess buffer and maxbufs
specifies the largest of the parse-info numbers belonging to the
command.  If a correlated subquery is processed (use_cinfo),
not_last must not become true because this last parse info is
reached for each record that fulfills all the conditions and not just
once at the very end.
 
The record that contains the information conversions
(atch) is fetched from the parse information.
 
The stored mess buffer begins after that (compare VAK54).  From this
buffer, either
the first part only (A53_FILL_MESS_BUF, last parameter = false) or
everything is transferred to the mess buffer to be sent to KB.
Use_cinfo means that a correlated subquery is being processed and
the mess buffer no longer must be filled with data from the SQL_PACKET.
This already occured in VAK50 PARSINFO_WITH_VALUES.  Therefore,
the mess buffer is complete (except for the key fields or corr columns,
see VAK50) and can be copied 1:1.
 
If the message type m_fetch is found, this means that a correlated
subquery is beginning.  Via a previous select, a result set was built
that contains all records that fulfill the table conditions.  The
conditions that contain subqueries could not yet be checked.  In
A50_CORRELATION_EXECUTE, each individual record is now taken from this
result set, its corr-column values are used to check the correlated
subqueries and the record itself is checked as to whether it fulfills
the conditions containing subqueries and, therefore, is to be inserted
in the final result.
 
Use_cinfo indicates that a correlated subquery is to be processed.
For this purpose, in the first loop (compare A50_CORRELATION_EXECUTE) ,
the corr-column values must be transferred from the co_corr_buf to the
mess buffer; in the second loop, the key of the one record being
examined that must then be checked is transferred.
 
The tree description that is established for the second loop
(the file is generated when the first final result is entered.  All other
final results migrate to the file whose tree id is determined by it) is
moved to the strategy information.
 
In order for the calling routine (LOOP_MOST_EXECUTE, VAK50) to know
which result file was generated (and must later be deleted), the
name is fetched from the mess buffer.  There it is located in the
strategy as a second file name for single-table selects and is in part1
at the very beginning for joins.
 
For message types that are involved with LOCK entries, special rules
apply to the input of data since there is a special variant of the
mess buffer for this purpose whose record layout must be strictly
followed.  Therefore, LOCK_FIELDVALUES is branched to.
 
If it is an update or delete with key information, it could also be that
the key is specified by CURRENT OF.  The name of the result set must then
be fetched from the parse information and the key must be identified from
one of the two system-information records with the type ereskey via
A58_GET_CURRENTKEY.
It is ensured that the UPDATE or DELETE can only
be performed via the same table that was addressed for the SELECT.
For this purpose, the userid and the table name must also be passed.
 
For all message types, the data specified in the SQL_PACKET during
execution are written to the mess buffer via A53_FIELDVALUES.
 
The data still contained in the parsed mess buffer (e.g.
strategy-information records) are also transferred.
 
Part2.len should include exactly those data that are located directly
in the SET clause during the update and must not be
identified via expressions.  Part2.len is used to determine the area
of part2 to be entered in the log.
 
The mess buffer contains the fileversion of the table to be
processed and a state that specifies the lock mode present, whether
locks exist, etc. and the trans_no that contains, among other
things, the number of the transaction.  ACV contains the current value
of the trans_no and of the state.  These must be used without destroying
the fileversion (located in the mess buffer and correct due to copying).
In addition, it is still possible in the case of SELECT commands to
specify WITH LOCK or the like, i.e. to change/expand the state for this
command.  This must take place in the current mess buffer (and, after
the processing of the command, it must be reversed before this state that may
have been changed by KB is stored in the ACV).
 
At this stage, a join mess buffer contains only the result-file name
in part1 and the data in part2.  This file name is fetched, the command
itself is executed via A682_ONLY_EX_JOIN and it is specified for VAK50 via
strategynum = ord(fieldin) that the result set is being built.
 
If not identified via PARSINFO_WITH_VALUES for correlated subqueries,
the best possible strategy for single-table selects, set updates, set
deletes and INSERT..SELECT is determined via A53_STRATEGY_SEARCH.
This strategy is found as a result of the conditions found during
parsing and the data used for the execution.
 
In the case of DELETES (explicit or forced via LINKs), it is possible
that a record that is not to be deleted until this step has already
been deleted by link mechanisms.  This must not lead to an error.
 
The command is sent for processing to KB via A06_SEND_MESS_BUF.
 
In the case of SELECTs, the change that was forced by WITH LOCK
must be reversed.
 
In the event of an error (except in the special case of DELETE) an
error is sent to the user.  The buffer containing the mess buffer
(generated by A53_STRATEGY_SEARCH) necessary for a FETCH (applied to a
result set that has not been built) is deleted if necessary
and the SELECT is labelled as not having been executed.
 
If everything has run correctly, the transaction
number must be raised at the
start of a new transaction.
 
If, for an INSERT applied to a join view, the keys of the relevant base
records must still be saved for the subsequent check, this is achieved via
copying to vkeybuf.
 
If it is the last mess buffer of the command, the outputs of
single-set selects are done, system-information records for set selects
are formed, etc., in LAST_COMMAND_PART.
 
A505FILL_MESS_BUF
-----------------------------
 
In this procedure, the currently 44-byte long header, part1 and the
part of part2 that is required (normally only the first 4 bytes; all
of part2 only in the case of correlated subqueries, for which
no more data must be fetched from the SQL_PACKET) are transferred
from the parsed mess buffer to the actual mess buffer in the acv.
It must be ensured that all parts can be divided among several
parse-information records.
 
A505GET_ATCH
-----------------------------
 
This procedure is called by A505MOST_EXECUTE and
A50_CORRELATION_EXECUTE in order to transfer to atch the record
that might be distributed among two parse-information records and
contains information on conversions of SELECT
results.
 
A505NEXT_COMMAND
-----------------------------
 
This procedure serves to fetch to sparr the next parse-information records,
a maximum of 4, that are required to build the next
message buffer.
 
Plus specifies the number of the first relevant parse-information record.
 
AK505JOIN_VIEW_CHECK
-----------------------------
 
This procedure is called if the join condition must be checked
before/after a change operation applied to a join view
(P_MTYP = m_key in LOOP_MOST_EXECUTE).
A message buffer is formed that looks like the one for a normal join
as far as VAK68 is concerned.  Unlike the latter buffer, part2 of this
message buffer must have space at the beginning for the keys of the
underlying base tables (for only one key, but this must be
the longest key).  Data that belong to the view qualification are
entered in part2 (part1 is irrelevant, although it is also assigned
via A54_VIEW_PUT_INTO).
 
A682_EXECUTE_JOIN is called to carry out the join check.  The record
is passed that contains, among other things, the address of the buffer
containing the keys of the base-table records that must be entered in part2
one after the other.
 
A505STRATEGY_SEARCH
-----------------------------
 
This procedure is called by MOST_EXECUTE and VAK50 PARSINFO_WITH_VALUES.
It uses the information on possible strategies formed during parsing
and the data known for execution to choose the best possible strategy
and transfers a description of the strategy to the mess buffer.
 
The result-file name is identified from the strategy information and
passed externally so that the calling procedures know which file will
be generated (and must later be deleted accordingly).
 
If the strategy has not yet been established (strategy = eval_strat or
fe_eval_strat), the best possible strategy is determined via
A721STRATEGY and is stored in the mess buffer.
 
If it was a set select whose result set had not been built, the mess
buffer required for the FETCH must still be generated but not yet stored
under the result-set name.  For this purpose, an attempt is made to
simplify conditions that contain unsuitable values
(BETWEEN 'a' AND 'a' is converted to = 'a';
BETWEEN 'c' and 'a' results in a stack entry that says that the result
is always false and finding_possible could even be set to false if
the entire qualification can, for this reason, never become true).
 
A505EXECUTE_LINK
-----------------------------
 
This procedure is always called if a delete command has been applied
to a primary table of a link
or an update or insert command has been applied to
a secondary table of a link.  The procedure then ensures that
the follow-up operations (select, update, delete, key check)
determined by the links are executed in the proper sequence.
This task is fulfilled by the recursive procedure EXEC_LINK.
If a link condition is violated (a_returncode <> 0), the modifications
that have already been made must be reversed
(A06_PARTIAL_ROLLBACK).
 
AK505EXEC_LINK
-----------------------------
 
This procedure takes care of the execution of all follow-up commands
required due to the deletion of records in a primary table or the insertion
or modification of records in a secondary table.  At the time of the call,
the follow-up commands to be executed are in the form of
parse-information records, which essentially contain the message buffer
of the commands, stored in the parse file.  The parse-information records
are concatenated in the form of a tree in order to be able to determine the
correct sequence of execution (for information on the building of
the parse-information records,
see VAK58).  Each parse-information record has the following layout:
 
 
+---------+----------+--+--+--+------------------------------+
| parskey | slinkage |  |  |  | compressed message buffer    |
+---------+----------+--+--+--+------------------------------+
   46 B        2 B    2B 2B 2B  mess_header_length + part1_len +
                      |  |  |   part2_len
                      |  |  |
                      |  |  |
                      |  |  +- use_file_id
                      |  +----- sa_level_parse_id
                      +--------- lo_level_parse_id
 
 
The compressed message buffer does not yet contain any qualification
values since these are not known until the time of execution.
The use_file_id is an identifier of the temporary file from which
the qualification values are taken at the time the operation is
executed.
 
The sa_level_parse_id is the slinkage of the parse-information records
that is to be executed next if the parse infos specified by
lo_level_parse_id have been processed.
 
The lo_level_parse_id is the slinkage of the parse-information records
that is to be executed next (if <> 0).
 
When the procedure is called, the system key of the particular operation
to be executed is specified by pars_id.  This is sufficient since the
system keys of all parse-information records differ only in the component
slinkage.  The particular parse-information record is loaded in the cache
and use_file_id, sa_level_pars_id and lo_level_pars_id are determined.
The header of the message buffer is transferred to acv.mess_buf.
If the message type is m_verify, this means that a link relationship
of a self-referencing link is to be checked.  For this type of link,
a parse-execute operation is not possible.  The table name of the source
table is determined from the message buffer and the link conditions are
checked via A58DELETE_WITH_LINK as in the case of the request type ADBS.
 
Otherwise, the execution of the follow-up command whose message buffer is
allocated in the cache beginning at the address sysbuf is activated via
A58EXECUTE_LINK.
If records were deleted by this command (cascade = TRUE) and a lo_level
follow-up command exists (i.e. there is a cascade link to the
table where the deletion occurred), exec_link is called for the command
with the parse-information record with slinkage = lo_level_pars_id.
Otherwise, the while loop of the commands on the same level is
executed.
 
.CM *-END-* description ---------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      c_in_join            = true (* a503build_union_buffer *);
      c_complicate         = true (* a52_rest_lock_statement *);
      c_in_union           = true (* a54_dml_init *);
      c_act_rescnt         = true (* a58exec_link_caused_dml *);
      c_make_new_res       = true (* a663_get_result_info *);
      c_use_old_rescnt     = true (* a682_execute_join *);
      c_seqsearch_for_exec = false (* a682_execute_join *);
      c_result_wanted      = true (* a05qualification_test *);
      c_check_new_rec      = true (* a05qualification_test *);
      c_intern_call        = true (* a507_putval *);
 
 
(*------------------------------*) 
 
PROCEDURE
      a505check_if_executed (
            VAR acv        : tak_all_command_glob;
            VAR test_name  : tsp00_KnlIdentifier;
            VAR test_tree  : tgg00_FileId);
 
VAR
      b_err       : tgg00_BasisError;
      resname_buf : tak_sysbufferaddress;
      sysk        : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a_transinf.tri_trans DO
    BEGIN
    sysk := a01defaultkey;
    WITH sysk DO
        BEGIN
        sresentrytype  := cak_eresname;
        srestablen     := test_name;
        sresmodul_name := a_modul_name;
        skeylen        := sizeof (sauthid) + sizeof (sentrytyp) +
              sizeof (srestablen) + sizeof (sresmodul_name);
&       ifdef TRACE
        t01lidentifier (ak_sem, srestablen);
        t01lidentifier (ak_sem, sresmodul_name);
&       endif
        END;
    (*ENDWITH*) 
    a10get_sysinfo (acv, sysk, d_release, resname_buf, b_err);
    IF  b_err = e_ok
    THEN
        BEGIN
        IF  resname_buf^.sresname.restreeid.fileConstId_gg00 <>
            test_tree.fileConstId_gg00
        THEN
            b_err := e_old_fileversion
        ELSE
            IF  NOT resname_buf^.sresname.resexecuted
            THEN
                b_err := e_unknown_resultname
            ELSE
                test_tree := resname_buf^.sresname.restreeid
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        b_err := e_unknown_resultname;
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a505execute_link (
            VAR acv   : tak_all_command_glob;
            VAR parsk : tak_parskey;
            pno       : integer);
 
VAR
      mblock_buf          : tak_sysbufferaddress;
      init_parsk      : tak_parskey;
      syskey          : tgg00_SysInfoKey;
 
BEGIN
init_parsk          := parsk;
syskey              := a01sysnullkey;
syskey.sauthid[ 1 ] := cak_tempinfo_byte;
SAPDB_PascalForcedMove (sizeof(parsk), sizeof(syskey.sauthid), @parsk, 1,
      @syskey.sauthid, 2, mxak_parskey);
syskey.sauthid[ mxak_parskey+1 ] := chr(pno);
syskey.sentrytyp := cak_emessblock;
ak505exec_link (acv, syskey, mblock_buf, 1);
IF  acv.a_returncode <> 0
THEN
    BEGIN
    (* may be false in case of LONG-cols with 'vm_datapart' *)
    acv.a_in_internal_subtr := true;
    acv.a_part_rollback := true
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a505fill_mess_buf (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info;
            VAR erec   : tak_exec_rec; (* PTS 1112612 *)
            VAR frec   : tak_fill_rec;
            full_part2 : boolean);
 
VAR
      withoutData     : boolean;
      cmd_handling    : tgg00_HandlingSet;
      tree_handling   : tgg00_HandlingSet;
      b_err           : tgg00_BasisError;
      p               : tsp00_Addr;
      ke              : tgg00_SysInfoKey;
      pmbp            : tgg00_MessBlockPtr;
 
BEGIN
WITH frec DO
    BEGIN
    a06a_mblock_init (acv, m_nil, mm_nil, b01niltree_id);
&   IFDEF TRACE
    t01int4 (ak_sem, 'pos_in_parsb', dmli.d_pos_in_parsbuf);
&   ENDIF
    ke   := dmli.d_sparr.px[ 1 ]^.syskey;
    WITH ke DO
        BEGIN
        sauthid[ 1 + mxak_parskey + 1 ] :=
              a01sysnullkey.sauthid[ 1 + mxak_parskey + 1 ];
        sentrytyp := cak_emessblock;
        dmli.d_sparr.pcount := dmli.d_sparr.pcount + 1;
        a10get_sysinfo (acv, ke, d_fix,
              dmli.d_sparr.px[ dmli.d_sparr.pcount ], b_err);
        END;
    (*ENDWITH*) 
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    IF  (acv.a_returncode = 0)
    THEN
        BEGIN
        pmbp := @dmli.d_sparr.px[ dmli.d_sparr.pcount ]^.
              smessblock.mbr_mess_block;
        IF  acv.a_stored_proc_call
        THEN
            BEGIN (* PTS 1114109, T.A. *)
&           ifdef trace
            t01lidentifier (ak_sem, dmli.d_sparr.px[ 1 ]^.sparsinfo.p_resn);
&           endif
            acv.a_result_name := dmli.d_sparr.px[ 1 ]^.sparsinfo.p_resn;
            IF  pmbp^.mb_qual^.mspecial > 0
            THEN
                BEGIN
                (* allocate memory for parameter for dbprocedures that contain sql *)
                (* gg941Deallocate in a260exec_dialog                              *)
                p := gg941Allocate (acv.a_transinf.tri_trans, pmbp^.mb_qual^.mspecial);
                IF  p = NIL
                THEN
                    a07_b_put_error (acv, e_no_more_memory, 1)
                ELSE
                    BEGIN
                    acv.a_mblock.mb_data      := @p^;
                    erec.ex_mb_data       := acv.a_mblock.mb_data; (* PTS 1112599 *)
                    acv.a_mblock.mb_data_size := pmbp^.mb_qual^.mspecial
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        acv.a_mblock.mb_data_len := 0;
&       IFDEF TRACE
        t01messblock (ak_sem, 'MBLOCK ctlog', pmbp^);
&       ENDIF
        withoutData := (NOT full_part2 ) AND
              (pmbp^.mb_type <> m_fetch) AND
              (pmbp^.mb_data_len > 0   ) AND
              (pmbp^.mb_data <> NIL);
        a06cpy_mblock (acv, pmbp^, acv.a_mblock, withoutData, b_err);
        acv.a_mblock.mb_data_len := pmbp^.mb_data_len;
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (acv.a_mblock.mb_struct <> mbs_lock)
    THEN
        WITH dmli.d_sparr.px[ 1 ]^.sparsinfo, acv.a_mblock.mb_qual^ DO
            BEGIN
&           ifdef TRACE
            t01int4 (ak_sem, 'p_session_lv', p_session_isolevel);
            t01int4 (ak_sem, 'a_iso_level ', acv.a_iso_level);
            t01int4 (ak_sem, 'p_use_sesslv', ord(p_use_sess_isolevel));
&           endif
            IF  ((p_session_isolevel <> acv.a_iso_level) AND
                p_use_sess_isolevel AND
                (NOT a101_IsExtendedTempFile (acv, mtree)))
            THEN
                IF  NOT ((p_session_isolevel in [ 0, 1 ]) AND
                    (acv.a_iso_level in [ 0, 1 ]))
                THEN
                    a07_b_put_error (acv, e_old_parsid, 1)
                ELSE
                    BEGIN
                    (* R/3-command: SET ISOLATION LEVEL 0/1 was given between *)
                    (* parsing and executing                                  *)
                    cmd_handling  := p_handling_set - [hsNoLog_egg00, hsCreateFile_egg00];
                    tree_handling := mtree.fileHandling_gg00 - [hsNoLog_egg00, hsCreateFile_egg00];
                    IF  (tree_handling = cmd_handling) OR
                        (tree_handling =
                        (cmd_handling - [hsConsistentLock_egg00] + [hsCollisionTest_egg00]))
                    THEN
                        (* no special isolevel for internal use used *)
                        IF  acv.a_iso_level = 0
                        THEN
                            BEGIN
                            (* switched from isolevel 1 to 0 *)
                            IF  hsConsistentLock_egg00 in mtree.fileHandling_gg00
                            THEN
                                mtree.fileHandling_gg00 := mtree.fileHandling_gg00 - [ hsConsistentLock_egg00 ] +
                                      [ hsWithoutLock_egg00 ];
                            (*ENDIF*) 
                            IF  hsCollisionTest_egg00 in mtree.fileHandling_gg00
                            THEN
                                mtree.fileHandling_gg00 := mtree.fileHandling_gg00 - [ hsCollisionTest_egg00 ] +
                                      [ hsWithoutLock_egg00 ];
                            (*ENDIF*) 
                            END
                        ELSE
                            BEGIN
                            (* switched from isolevel 0 to 1 *)
                            IF  ((acv.a_mblock.mb_type = m_select_row) OR (acv.a_mblock.mb_type = m_select))
                            THEN
                                mtree.fileHandling_gg00 := mtree.fileHandling_gg00 + [ hsCollisionTest_egg00 ] -
                                      [ hsWithoutLock_egg00 ];
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  (full_part2 OR (acv.a_mblock.mb_type = m_fetch))
    THEN
        dmli.d_pos_in_parsbuf := acv.a_mblock.mb_data_len + 1
    ELSE
        dmli.d_pos_in_parsbuf := 1;
    (*ENDIF*) 
    IF  NOT full_part2
    THEN
        acv.a_mblock.mb_data_len := 0;
&   IFDEF TRACE
    (*ENDIF*) 
    t01messblock (ak_sem, 'MBLOCK 505fi', acv.a_mblock);
&   ENDIF
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a505get_change_rec (
            VAR acv            : tak_all_command_glob;
            VAR sparr          : tak_syspointerarr;
            VAR change_rec     : tak_changerecord);
 
VAR
      sysbuf : tak_sysbufferaddress;
      sysk   : tgg00_SysInfoKey;
      b_err  : tgg00_BasisError;
 
BEGIN
IF  sparr.px[ 1 ] <> NIL
THEN
    WITH sparr.px[ 1 ]^.sparsinfo DO
        BEGIN
&       ifdef trace
        t01buf (ak_sem, sparr.px[1]^, 1, sparr.px[1]^.b_sl);
&       endif
        IF  ( pi_changeinfos_exist in p_bool_states ) AND p_select AND p_single
        THEN
            BEGIN
            sysk := sparr.px[ 1 ]^.syskey;
            sysk.sentrytyp := cak_echangeinfos;
            a10get_sysinfo (acv, sysk, d_release, sysbuf, b_err);
            IF  b_err <> e_ok
            THEN
                IF  b_err = e_sysinfo_not_found
                THEN
                    change_rec.cr_colcount := 0
                ELSE
                    a07_b_put_error (acv, b_err, 2)
                (*ENDIF*) 
            ELSE
                WITH sysbuf^.schangeinfos, change_rec DO
                    BEGIN
&                   ifdef TRACE
                    t01buf (ak_sem, sysbuf^, 1, sysbuf^.b_sl);
&                   endif
                    cr_colcount := ci_colcount;
&                   ifdef TRACE
                    t01buf (ak_sem, sysbuf^, 1, sysbuf^.b_sl);
                    t01int4 (ak_sem, 'cr_colcount ', change_rec.cr_colcount);
&                   endif
                    SAPDB_PascalMove ('VAK505',   1,    
                          sizeof(ci_ch_columns),sizeof(change_rec.cr_columns),
                          @ci_ch_columns, 1,
                          @change_rec.cr_columns, 1,
                          change_rec.cr_colcount * sizeof(tak_change_colinfo),
                          acv.a_returncode)
                    END
                (*ENDWITH*) 
            (*ENDIF*) 
            END
        ELSE
            change_rec.cr_colcount := 0
        (*ENDIF*) 
        END
    (*ENDWITH*) 
ELSE
    change_rec.cr_colcount := 0;
(*ENDIF*) 
change_rec.cr_was_opt  := false;
change_rec.cr_filler   := false;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak505get_longlit_rec (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info);
 
VAR
      _alloc_size  : tsp00_Int4;
      _sysk        : tgg00_SysInfoKey;
      _sysbuf      : tak_sysbufferaddress;
      _b_err       : tgg00_BasisError;
      _aux_addr    : tsp00_Addr;
 
BEGIN
dmli.d_literalrec   := NIL;
dmli.d_longlitcount := 0;
IF  (dmli.d_sparr.px[ 1 ] <> NIL) AND
    (dmli.d_sparr.px[ 1 ]^.sparsinfo.p_longliteral)
THEN
    BEGIN
    _sysk := dmli.d_sparr.px[ 1 ]^.syskey;
    _sysk.sentrytyp := cak_elongliteral;
    a10get_sysinfo (acv, _sysk, d_fix, _sysbuf, _b_err);
    IF  _b_err <> e_ok
    THEN
        a07_b_put_error (acv, _b_err, 2)
    ELSE
        BEGIN
        _alloc_size := sizeof(tak_longliteral_rec) - sizeof(tak_longlit_buf)
              + (_sysbuf^.slongliteral.litcolcount * sizeof(tak_litcoldesc))
              + _sysbuf^.slongliteral.litsize;
        _aux_addr   := gg941Allocate (acv.a_transinf.tri_trans, _alloc_size);
        IF  _aux_addr = NIL
        THEN
            a07_b_put_error (acv, e_no_more_memory, 1)
        ELSE
            BEGIN
            dmli.d_literalrec := @_aux_addr^;
            SAPDB_PascalMove ('VAK505',   2,    
                  _sysbuf^.slongliteral.litreclen, _alloc_size,
                  @_sysbuf^,  1, @dmli.d_literalrec^, 1, _alloc_size,
                  acv.a_returncode);
            dmli.d_literalrec^.slongliteral.litdataptr  :=
                  @(dmli.d_literalrec^.slongliteral.litdatabuf
                  [dmli.d_literalrec^.slongliteral.litcolcount *
                  sizeof(tak_litcoldesc) + 1]);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak505release_longlit_rec (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info);
 
VAR
      _sysk        : tgg00_SysInfoKey;
      _aux_addr    : tsp00_Addr;
 
BEGIN
IF  (dmli.d_literalrec <> NIL)
THEN
    BEGIN
    _sysk := dmli.d_literalrec^.syskey;
    a10_rel_sysinfo ( acv, _sysk );
    _aux_addr := @dmli.d_literalrec^;
    gg941Deallocate  (acv.a_transinf.tri_trans, _aux_addr);
    dmli.d_literalrec   := NIL;
    dmli.d_longlitcount := 0;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a505loop_most_execute (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            VAR change_rec : tak_changerecord;
            VAR erec       : tak_exec_rec;
            VAR parsk      : tak_parskey;
            viewkeybuf     : tak_sysbufferaddress;
            VAR series     : tak68_sequence;
            VAR cinfo      : tak_corr_infos;
            VAR old_cinfo  : tak_corr_infos;
            inner_loop     : boolean);
 
VAR
      _sub_found         : boolean;
      _check_after_dml   : boolean;
      _tempTfn           : tgg00_TfnTemp;
      _aux_err           : tsp00_Int2;
      _err               : tgg04_Err;
      _intern_erec       : tak_exec_rec;
      _i                 : integer;
      _jvrec             : tak68_joinview_rec;
      _old_res_tree      : tgg00_FileId;
      _sub_del_help_tree : tgg00_FileId;
 
BEGIN
g04build_temp_tree_id (_sub_del_help_tree, acv.a_transinf.tri_trans);
_sub_del_help_tree.fileTfnTemp_gg00 := ttfnSubquery_egg00;
_intern_erec           := erec;
IF  erec.ex_parameter_fieldlist <> NIL
THEN
    _intern_erec.ex_parameter_fieldlist := ak104_GetReference_MS (erec.ex_parameter_fieldlist);
(*ENDIF*) 
IF  erec.ex_result_fieldlist <> NIL
THEN
    _intern_erec.ex_result_fieldlist := ak104_GetReference_MS (erec.ex_result_fieldlist);
(*ENDIF*) 
erec.ex_command_needed := true;
&IFDEF TRACE
t01int4 (ak_sem, 'plus        ', _intern_erec.ex_plus);
t01int4 (ak_sem, 'maxbufs     ', _intern_erec.ex_maxbufs);
t01int4 (ak_sem, '   START    ', 1);
&ENDIF
IF  (acv.a_command_kind <> single_command) AND
    (acv.a_union_cnt = 0)              AND
    (NOT inner_loop)
THEN
    _old_res_tree := acv.a_complex_tree
ELSE
    _old_res_tree := b01niltree_id;
(*ENDIF*) 
_intern_erec.ex_act_treeid := b01niltree_id;
WHILE ((acv.a_returncode = 0) AND
      (_intern_erec.ex_plus + 1 <= _intern_erec.ex_maxbufs)) DO
    BEGIN
    _intern_erec.ex_all_rescnt      := 0;
    _intern_erec.ex_act_treeid.fileRoot_gg00 := NIL_PAGE_NO_GG00;
    _sub_found          := false;
    _intern_erec.ex_plus            := _intern_erec.ex_plus + 1;
    IF  _intern_erec.ex_command_needed
    THEN
        BEGIN
        FOR _i := 1 TO dmli.d_sparr.pcount DO
            a10rel_sysinfo (dmli.d_sparr.px[_i]);
        (*ENDFOR*) 
        a505next_command (acv, dmli.d_sparr, parsk, _intern_erec.ex_plus);
        END
    ELSE
        _intern_erec.ex_command_needed := true;
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        IF  ((dmli.d_sparr.px[ 1 ]^.sparsinfo.p_mtyp = m_key) AND
            (dmli.d_sparr.px[ 1 ]^.sparsinfo.p_mtyp2 = mm_nokey))
        THEN
            BEGIN
            _jvrec.jv_keybuf       := viewkeybuf;
            _jvrec.jv_tabid        :=
                  dmli.d_sparr.px[ 1 ]^.sparsinfo.p_treeid.fileTabId_gg00;
            _jvrec.jv_maxkeyl      := dmli.d_sparr.px[ 1 ]^.sparsinfo.p_j_v_keylen;
            _jvrec.jv_checkview    := dmli.d_sparr.px[ 1 ]^.sparsinfo.p_reuse;
            _intern_erec.ex_with_link    := false;
            _check_after_dml :=
                  NOT(dmli.d_sparr.px[ 1 ]^.sparsinfo.p_select);
&           IFDEF TRACE
            t01int4 (ak_sem, 'check_after_', ord(_check_after_dml));
&           ENDIF
            ak505join_view_check (acv, _intern_erec.ex_act_treeid,
                  _jvrec, series,
                  dmli.d_sparr.px[ 1 ]^.sparsinfo.p_joinviewtabcnt);
            IF  ((acv.a_returncode = a071_return_code(e_row_not_found,
                acv.a_sqlmode))
                AND _check_after_dml)
            THEN
                BEGIN
                acv.a_returncode      := 0;
                _err.errtableid   :=
                      dmli.d_sparr.px[ 1 ]^.sparsinfo.p_tabid;
                a07_b_put_error (acv,
                      e_range_violation, 1);
                IF  dmli.d_sparr.px[ 1 ]^.sparsinfo.p_function_code =
                    csp1_insert_fc
                THEN
                    a06put_errtext (acv, e_range_violation,
                          errtext_surrogate,
                          SURROGATE_MXGG00+2 (*sitelength*),
                          _err.errt, acv.a_ak_b_err)
                ELSE
                    a06put_errtext (acv, e_no_next_record,
                          errtext_surrogate,
                          SURROGATE_MXGG00+2 (*sitelength*),
                          _err.errt, acv.a_ak_b_err);
                (*ENDIF*) 
                END
            ELSE
                IF  NOT (_check_after_dml) AND
                    (erec.ex_updjv_ptr <> NIL)
                THEN
                    SAPDB_PascalMove ('VAK505',   3,    
                          acv.a_mblock.mb_data_size,
                          sizeof(erec.ex_updjv_ptr^),
                          @acv.a_mblock.mb_data^.mbp_buf, 1,
                          @erec.ex_updjv_ptr^, 1,
                          acv.a_mblock.mb_data_len,
                          acv.a_returncode)
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            IF  dmli.d_sparr.px[ 1 ]^.sparsinfo.p_subcntlevel >= 0
            THEN
                BEGIN
                _sub_found                       := true;
                a101_SetTempFileLevel (acv, _sub_del_help_tree,
                      dmli.d_sparr.px[ 1 ]^.sparsinfo.p_subcntlevel);
                END;
            (*ENDIF*) 
            IF  _intern_erec.ex_plus + 1 > _intern_erec.ex_maxbufs
            THEN
                BEGIN
                _intern_erec.ex_all_rescnt := erec.ex_all_rescnt;
                _intern_erec.ex_act_treeid := erec.ex_act_treeid
                END;
&           IFDEF TRACE
            (*ENDIF*) 
            t01name (ak_sem, 'co_corr_buf       ');
            IF  cinfo.co_corr_buf = NIL
            THEN
                t01name (ak_sem, '    is NIL        ')
            ELSE
                t01buf1 (ak_sem, cinfo.co_corr_buf^, 1, 100);
            (*ENDIF*) 
&           ENDIF
            a505most_execute (acv, dmli, change_rec,
                  parsk, _intern_erec,
                  cinfo, old_cinfo, viewkeybuf, inner_loop)
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  (parsk.p_kind in [ m_select, m_select_row, m_delete, m_update ])
    THEN
        BEGIN
&       IFDEF TRACE
        t01treeid (ak_sem, 'old_res_tree', _old_res_tree);
        t01treeid (ak_sem, 'ierec.acttre', _intern_erec.ex_act_treeid);
&       ENDIF
        IF  a101_IsExtendedTempFile (acv, _old_res_tree)
        THEN
            _tempTfn := a101_GetExtendedTempFileType (acv, _old_res_tree)
        ELSE
            _tempTfn := ttfnNone_egg00;
        (*ENDIF*) 
        acv.a_from_select := acv.a_from_select OR (_tempTfn = ttfnFromSelect_egg00);
        acv.a_from_select := acv.a_from_select OR
              (a101_IsExtendedTempFile (acv, _old_res_tree) AND
              (a101_GetExtendedTempFileType (acv, _old_res_tree)
              = ttfnFromSelect_egg00));
        IF  ((_tempTfn = ttfnInternResult_egg00)
            OR
            ((acv.a_returncode <> 0) AND
            (acv.a_returncode <> 100)  AND
            (_tempTfn = ttfnUnion_egg00)))
        THEN
            a502destroy_file (acv, _old_res_tree);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    _old_res_tree := _intern_erec.ex_act_treeid;
    IF  (acv.a_command_kind <> single_command) AND
        (acv.a_union_cnt    <  2)
    THEN
        acv.a_complex_tree := _intern_erec.ex_act_treeid;
&   IFDEF TRACE
    (*ENDIF*) 
    t01name (ak_sem, 'end loop most ex. ');
    t01treeid (ak_sem, 'old_res_tree', _old_res_tree);
&   ENDIF
    IF  (_intern_erec.ex_with_link) AND (NOT inner_loop)
    THEN
        BEGIN
        a505execute_link (acv, parsk, _intern_erec.ex_plus);
        _intern_erec.ex_with_link := false;
        END;
&   IFDEF TRACE
    (*ENDIF*) 
    t01int4 (ak_sem, 'a_union_cnt.', acv.a_union_cnt);
    t01int4 (ak_sem, 'sub_found   ', ord (_sub_found));
&   ENDIF
    acv.a_sub_found := _sub_found;
    IF  ( _sub_found )
    THEN
        BEGIN
        acv.a_sub_found := false;
        a06subquery_del_result (acv,
              dmli, _sub_del_help_tree, TEMP_PREFIX_MXGG00 + 3);
        IF  a101_GetTempFileLevel (acv, _sub_del_help_tree) = 0
        THEN
            dmli.d_sublevel := csp_maxint1
        ELSE
            dmli.d_sublevel := a101_GetTempFileLevel (acv,
                  _sub_del_help_tree) - 1;
        (*ENDIF*) 
        END;
&   IFDEF TRACE
    (*ENDIF*) 
    IF  a101_IsExtendedTempFile (acv, _old_res_tree)
    THEN
        BEGIN
        t01int4 (ak_sem , 'ftemptype   ', ord(a101_GetExtendedTempFileType (
              acv, _old_res_tree)));
        _aux_err := acv.a_returncode;
        t01int4 (ak_sem , 'flevel[ 1 ] ',
              a101_GetTempFileLevel (acv, _old_res_tree));
        acv.a_returncode := _aux_err;
        END;
    (*ENDIF*) 
    t01int4 (ak_sem , 'd_sublevel  ', dmli.d_sublevel);
&   ENDIF
    IF  a101_IsExtendedTempFile (acv, _old_res_tree)
        AND (a101_GetExtendedTempFileType (acv, _old_res_tree) = ttfnSubquery_egg00)
    THEN
        IF  dmli.d_sublevel > a101_GetTempFileLevel (acv, _old_res_tree)
        THEN
            dmli.d_sublevel := a101_GetTempFileLevel (acv, _old_res_tree)
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  _intern_erec.ex_parameter_fieldlist <> NIL
THEN
    ak104_DropReference_MS (_intern_erec.ex_parameter_fieldlist);
(*ENDIF*) 
IF  _intern_erec.ex_result_fieldlist <> NIL
THEN
    ak104_DropReference_MS (_intern_erec.ex_result_fieldlist);
(*ENDIF*) 
IF  (parsk.p_kind in
    [ m_select, m_select_row, m_delete, m_update, m_insert_select ])
    AND
    (acv.a_command_kind = single_command)
    AND
    (acv.a_qualified_jv_upd = no_jv_upd)
THEN
    IF  a101_IsExtendedTempFile (acv, _intern_erec.ex_act_treeid)
        AND (a101_GetExtendedTempFileType (acv,
        _intern_erec.ex_act_treeid) = ttfnInternResult_egg00)
    THEN
        a502destroy_file (acv, _intern_erec.ex_act_treeid);
    (*ENDIF*) 
(*ENDIF*) 
IF  (_intern_erec.ex_with_link) AND (NOT inner_loop)
THEN
    BEGIN
    a505execute_link (acv, parsk, _intern_erec.ex_plus);
    _intern_erec.ex_with_link := false;
    END;
(*ENDIF*) 
erec.ex_plus      := _intern_erec.ex_plus;
erec.ex_with_link := _intern_erec.ex_with_link;
IF  acv.a_returncode = 0
THEN
    BEGIN
    erec.ex_act_treeid := _intern_erec.ex_act_treeid;
    erec.ex_all_rescnt := _intern_erec.ex_all_rescnt
    END;
(*ENDIF*) 
IF  (acv.a_returncode <> 0)         AND
    (acv.a_returncode <>
    a071_return_code (e_row_not_found, acv.a_sqlmode)) AND
    a101_IsExtendedTempFile (acv, _intern_erec.ex_act_treeid)
THEN
    IF  (a101_GetExtendedTempFileType (acv, _intern_erec.ex_act_treeid) = ttfnInto_egg00)
    THEN
        BEGIN
        a101_GetTempFileInstance (acv.a_transinf.tri_trans,
              _intern_erec.ex_act_treeid);
        b01empty_file (acv.a_transinf.tri_trans, _intern_erec.ex_act_treeid);
        END;
    (* act_treeid has to be unnamed_tree *)
&   IFDEF TRACE
    (*ENDIF*) 
(*ENDIF*) 
t01int4 (ak_sem , 'd_sublevel  ', dmli.d_sublevel);
t01int4 (ak_sem , 'returncode  ', acv.a_returncode);
&ENDIF
IF  acv.a_returncode <> 0
THEN
    BEGIN
    IF  dmli.d_sublevel < csp_maxint1
    THEN
        a06subquery_del_result (acv, dmli,
              _sub_del_help_tree, TEMP_PREFIX_MXGG00+2);
    (*ENDIF*) 
    IF  (parsk.p_kind <> m_select_row)          AND
        (parsk.p_kind <> m_select)              AND
        (acv.a_returncode <> cak_e_dbproc_call) AND (* PTS 1137969 *)
        (acv.a_returncode <>
        a071_return_code (e_row_not_found, acv.a_sqlmode))
    THEN
        acv.a_part_rollback := true;
    (*ENDIF*) 
    END;
&IFDEF TRACE
(*ENDIF*) 
t01messblock (ak_sem, 'MBLOCK loope', acv.a_mblock);
t01int4 (ak_sem, 'plus        ', _intern_erec.ex_plus);
t01int4 (ak_sem, 'maxbufs     ', _intern_erec.ex_maxbufs);
IF  a101_IsExtendedTempFile (acv, _old_res_tree)
THEN
    t01treeid (ak_sem, 'old_res_tree', _old_res_tree);
(*ENDIF*) 
t01treeid (ak_sem, 'mr_restree  ', acv.a_mblock.mb_qual^.mr_restree);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a505most_execute (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            VAR change_rec : tak_changerecord;
            VAR parsk      : tak_parskey;
            VAR erec       : tak_exec_rec;
            VAR cinfo      : tak_corr_infos;
            VAR old_cinfo  : tak_corr_infos;
            viewkeybuf     : tak_sysbufferaddress;
            inner_loop     : boolean);
 
CONST
      c_useLiteralBuf = true;
 
VAR
      _b_err                : tgg00_BasisError;
      _trans_b_err          : tgg00_BasisError;
      _not_last             : boolean;
      _last_and_single      : boolean;
      _last_single_no_union : boolean;
      _w_link               : boolean;
      _frec                 : tak_fill_rec;
      _i_length             : integer;
      _pos                  : integer;
      _ix                   : integer;
      _h_rescount           : tsp00_Int4;
      _h_rowno              : tsp00_Int4;
      _f_ok                 : boolean;
      _re                   : tsp00_NumError;
      _munion_cnt           : tsp00_Int4;
      _gg_strategy_ptr      : ^tgg07_StrategyInfo;
      _mtype                : tgg00_MessType;
      _m2type               : tgg00_MessType2;
      _trans_m_type         : tgg00_MessType;
      _resnam               : tsp00_KnlIdentifier;
      _searchname           : tsp00_KnlIdentifier;
      _join_parsk           : tak_parskey;
      _aux_treeid           : tgg00_FileId;
      _qbufp                : tak_sysbufferaddress;
      _ssr_rec              : tak71_select_strat_rec;
      _aux_tfn              : tgg00_TfnTemp;
      _pmbp                 : tgg00_MessBlockPtr;
      _pdbp                 : tgg00_DataPartPtr;
      _p                    : tsp00_Addr;
      _oldContext           : tgg00_UnivTrans;
      _aux_fieldlists       : tgg00_FieldLists;
 
BEGIN
_pos        := cak_extern_pos;
_h_rescount := 0;
_h_rowno    := dmli.d_rowno;
dmli.d_rowno := cgg04_no_rowno_predicate;
IF  acv.a_command_kind = last_command
THEN
    acv.a_command_kind := single_command;
(*ENDIF*) 
_not_last := ((erec.ex_plus + 1 <= erec.ex_maxbufs) OR cinfo.co_use_cinfo );
_last_and_single :=
      (NOT _not_last) AND ( acv.a_command_kind = single_command );
_last_single_no_union   := _last_and_single AND ( acv.a_union_cnt = 0 );
acv.a_intern_select_cnt := dmli.d_sparr.px[ 1 ]^.sparsinfo.p_int_res_cnt;
IF  _last_and_single AND (acv.a_max_intern_select = 0)
THEN
    acv.a_max_intern_select := acv.a_intern_select_cnt;
(*ENDIF*) 
;
&IFDEF TRACE
t01bool( ak_sem, '_not_last   ', _not_last );
t01bool( ak_sem, '_last_and_si', _last_and_single );
t01bool( ak_sem, '_last_sing_n', _last_single_no_union );
t01int4 (ak_sem, 'intern_selec', acv.a_intern_select_cnt);
t01int4 (ak_sem, 'max_intern_s', acv.a_max_intern_select);
t01name (ak_sem, 'co_corr_buf       ');
IF  ( cinfo.co_corr_buf = NIL )
THEN
    t01name( ak_sem, '    is NIL        ' )
ELSE
    t01buf1( ak_sem, cinfo.co_corr_buf^, 1, 100 );
(*ENDIF*) 
&ENDIF
a505get_change_rec( acv, dmli.d_sparr, change_rec );
ak505get_longlit_rec( acv, dmli);
_searchname := dmli.d_sparr.px[ 1 ]^.sparsinfo.p_searchname;
&ifdef trace
t01knl_identifier( ak_sem, '_searchname ', _searchname );
&endif
dmli.d_pos_in_parsbuf := 1;
IF  ( dmli.d_sparr.px[ 1 ]^.sparsinfo.p_select AND
    ( NOT dmli.d_sparr.px[ 1 ]^.sparsinfo.p_single ))
THEN
    BEGIN
    a506result_name( acv, dmli );
    IF  ( dmli.d_resname_found AND ( dmli.d_resname <> a01_zero_res_name ))
    THEN
        _resnam := dmli.d_resname
    ELSE
        _resnam := dmli.d_sparr.px[ 1 ]^.sparsinfo.p_resn;
    (*ENDIF*) 
    IF  ( _last_single_no_union )
    THEN
        BEGIN
        IF  ( _resnam = a01_zero_res_name )
        THEN
            BEGIN
            _aux_tfn := ttfnInternResult_egg00;
            _pos     := cak_intern_pos;
            END
        ELSE
            BEGIN
            _aux_tfn := ttfnUserResult_egg00;
            _pos     := cak_extern_pos;
            END;
        (*ENDIF*) 
        IF  ( dmli.d_repl_reskey )
        THEN
            BEGIN
            IF  ( dmli.d_mselect_loop_cnt = cgg04_first_of_all )
            THEN
                a663_resname( acv, _resnam,
                      acv.a_modul_name,
                      acv.a_resname_addr[ _pos ], d_fix, 1 );
            (* PTS 1001160 E.Z. *)
            (*ENDIF*) 
            IF  ( acv.a_resname_addr[ _pos ] = NIL )
            THEN
                a07ak_system_error( acv, 505, 1 );
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            a663_get_result_info( acv, _resnam,
                  acv.a_modul_name,
                  acv.a_resname_addr[ _pos ], c_make_new_res,
                  _aux_tfn, d_fix, _f_ok );
            IF  ( acv.a_return_segm^.sp1r_function_code = csp1_explain_fc )
            THEN
                acv.a_result_name := _resnam;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    acv.a_curr_res_id := acv.a_max_res_id;
    END;
(*ENDIF*) 
erec.ex_with_link     := false;
dmli.d_longdesc_found := false;
a505fill_mess_buf( acv, dmli, erec, _frec, cinfo.co_use_cinfo );
_w_link := ( acv.a_mblock.mb_qual^.mlink_cnt > 0 ) AND
      ((acv.a_mblock.mb_type = m_insert )        OR
      ( acv.a_mblock.mb_type = m_insert_select ) OR
      ( acv.a_mblock.mb_type = m_update )        OR
      ( acv.a_mblock.mb_type = m_delete ));
IF  ( acv.a_returncode = 0 )
THEN
    IF  acv.a_mblock.mb_type = m_fetch
    THEN
        a502correlation_execute (acv, dmli, change_rec, erec,
              parsk, cinfo, inner_loop)
    ELSE
        BEGIN
        IF  cinfo.co_use_cinfo
        THEN
            WITH cinfo DO
                BEGIN
&               IFDEF TRACE
                t01messblock (ak_sem, 'MBLOCK 505mo', acv.a_mblock);
                t01int4 (ak_sem, 'act_pos     ', co_act_pos);
                t01int4 (ak_sem, 'startkeyfiel', co_startkeyfields);
                t01int4 (ak_sem, 'one_key_len ', co_one_key_len);
                IF  cinfo.co_use_fields = keyfields
                THEN
                    t01int4 (ak_sem, 'use_keyfiel ', 1);
&               ENDIF
                (* PTS 1111978 E.Z. *)
                (*ENDIF*) 
                WITH dmli.d_sparr.px[ 1 ]^.sparsinfo DO
                    BEGIN
                    _i_length         := acv.a_mblock.mb_data_len;
                    _frec.fr_f_no     := 1;
                    _frec.fr_last_fno := p_cnt_infos;
                    IF  _frec.fr_last_fno >= _frec.fr_f_no
                    THEN
                        a506fieldvalues (acv, dmli, _frec,
                              viewkeybuf,
                              acv.a_mblock.mb_data^.mbp_buf, acv.a_mblock.mb_data_size);
                    (*ENDIF*) 
                    acv.a_mblock.mb_data_len := _i_length;
                    END;
                (*ENDWITH*) 
                IF  cinfo.co_use_fields = keyfields
                THEN
                    BEGIN
                    SAPDB_PascalMove ('VAK505',   4,    
                          sizeof(co_corr_buf^),
                          acv.a_mblock.mb_data_size,
                          @co_corr_buf^, co_act_pos + co_sel_keypos,
                          @acv.a_mblock.mb_data^.mbp_buf,
                          co_startkeyfields, co_upd_keylen,
                          acv.a_returncode);
                    IF  (acv.a_mblock.mb_type = m_update) OR
                        (acv.a_mblock.mb_type = m_delete)
                    THEN
                        WITH acv.a_mblock.mb_st^[ co_varkeyvalstack ],
                             acv.a_mblock.mb_data^ DO
                            elen_var := s30lnr_defbyte (@mbp_buf,
                                  mbp_buf [co_startkeyfields +
                                  co_minkeylen - 1],
                                  co_startkeyfields + co_minkeylen,
                                  elen_var - co_minkeylen) +
                                  co_minkeylen
                        (*ENDWITH*) 
                    ELSE
                        BEGIN
                        acv.a_mblock.mb_qual^.mtree := co_corr_current
                        END;
                    (*ENDIF*) 
                    _gg_strategy_ptr := @acv.a_mblock.mb_strat^[
                          acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].epos ];
                    _gg_strategy_ptr^.str_foundresults := erec.ex_all_rescnt;
                    _gg_strategy_ptr^.str_result_id    := erec.ex_act_treeid;
                    IF  (old_cinfo.co_corr_buf <> NIL) AND
                        (old_cinfo.co_use_fields <> no_fields)
                    THEN
                        SAPDB_PascalMove ('VAK505',   5,    
                              sizeof(old_cinfo.co_corr_buf^),
                              acv.a_mblock.mb_data_size,
                              @old_cinfo.co_corr_buf^,
                              old_cinfo.co_one_key_len + cgg_rec_key_offset +
                              old_cinfo.co_act_pos,
                              @acv.a_mblock.mb_data^.mbp_buf,
                              cgg_rec_key_offset+1,
                              old_cinfo.co_lcomp_len,
                              acv.a_returncode);
                    (*ENDIF*) 
                    END
                ELSE
                    IF  co_use_fields = corr_fields
                    THEN
                        SAPDB_PascalMove ('VAK505',   6,    
                              sizeof(co_corr_buf^),
                              acv.a_mblock.mb_data_size,
                              @co_corr_buf^,
                              co_one_key_len + cgg_rec_key_offset + co_act_pos,
                              @acv.a_mblock.mb_data^.mbp_buf,
                              cgg_rec_key_offset+1,
                              co_lcomp_len,
                              acv.a_returncode);
&                   IFDEF TRACE
                    (*ENDIF*) 
                (*ENDIF*) 
                t01int4 (ak_sem, 'co_one_key_l', co_one_key_len);
                t01int4 (ak_sem, 'co_act_pos  ', co_act_pos);
                t01int4 (ak_sem, 'co_lcomp_len', co_lcomp_len);
                t01messblock (ak_sem, 'MBLOCK 505mo', acv.a_mblock);
                t01int4 (ak_sem, 'act_pos     ', co_act_pos);
                t01int4 (ak_sem, 'startkeyfiel', co_startkeyfields);
                t01int4 (ak_sem, 'one_key_len ', co_one_key_len);
                IF  cinfo.co_use_fields = keyfields
                THEN
                    t01int4 (ak_sem, 'use_keyfiel ', 1);
&               ENDIF
                (*ENDIF*) 
                IF  ( acv.a_mblock.mb_type2 <> mm_with_join )
                THEN
                    BEGIN
                    _gg_strategy_ptr := @acv.a_mblock.mb_strat^[
                          acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].epos ];
                    erec.ex_act_treeid := _gg_strategy_ptr^.str_result_id;
                    END
                ELSE
                    BEGIN
                    SAPDB_PascalMove ('VAK505',   7,    
                          sizeof(acv.a_mblock.mb_qual^.buf),
                          sizeof(erec.ex_act_treeid),
                          @acv.a_mblock.mb_qual^.buf, 1,
                          @erec.ex_act_treeid, 1, FILE_ID_MXGG00,
                          acv.a_returncode);
                    END;
                (*ENDIF*) 
                END
            (*ENDWITH*) 
        ELSE
            WITH dmli.d_sparr.px[ 1 ]^.sparsinfo DO
                BEGIN
                CASE  acv.a_mblock.mb_type OF
                    m_lock, m_unlock,
                    m_commit, m_rollback :
                        BEGIN
                        (*  keep lock *)
                        IF  ((acv.a_mblock.mb_type = m_lock) AND
                            (dmli.d_execute_unlock))
                        THEN
                            BEGIN
                            acv.a_mblock.mb_type := m_unlock;
                            acv.a_max_intern_select := acv.a_intern_select_cnt;
                            END;
                        (*ENDIF*) 
                        a506lock_fieldvalues (acv, dmli, _frec,
                              viewkeybuf);
                        END;
                    OTHERWISE
                        BEGIN
                        _frec.fr_f_no     := 1;
                        _frec.fr_last_fno := p_cnt_infos;
                        IF  _frec.fr_last_fno >= _frec.fr_f_no
                        THEN
                            IF  erec.ex_updjv_ptr <> NIL
                            THEN
                                a506fieldvalues (acv, dmli, _frec,
                                      viewkeybuf, erec.ex_updjv_ptr^, sizeof(tsp00_Buf) (* see vak501 *))
                            ELSE
                                a506fieldvalues (acv, dmli, _frec,
                                      viewkeybuf,
                                      acv.a_mblock.mb_data^.mbp_buf, acv.a_mblock.mb_data_size)
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    END;
                (*ENDCASE*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            _pmbp := @dmli.d_sparr.px[ dmli.d_sparr.pcount ]^.
                  smessblock.mbr_mess_block;
            _pdbp := _pmbp^.mb_data;
&           IFDEF TRACE
            t01int4 (ak_sem, 'pos_in_parsb', dmli.d_pos_in_parsbuf);
            t01int4 (ak_sem, 'len         ', acv.a_mblock.mb_data_len);
            t01int4 (ak_sem, 'keylen      ', acv.a_mblock.mb_data^.mbp_keylen);
&           ENDIF
            IF  _pmbp^.mb_data_len >= dmli.d_pos_in_parsbuf
            THEN
                BEGIN
                _i_length := _pmbp^.mb_data_len -
                      dmli.d_pos_in_parsbuf + 1;
&               IFDEF TRACE
                t01int4 (ak_sem, 'pos_in_parsb', dmli.d_pos_in_parsbuf);
                t01int4 (ak_sem, 'i_length    ', _i_length);
                t01int4 (ak_sem, 'len         ', acv.a_mblock.mb_data_len);
                t01int4 (ak_sem, 'keylen      ', acv.a_mblock.mb_data^.mbp_keylen);
&               ENDIF
                SAPDB_PascalMove ('VAK505',   8,    
                      _pmbp^.mb_data_size, acv.a_mblock.mb_data_size,
                      @_pdbp^.mbp_buf, dmli.d_pos_in_parsbuf,
                      @acv.a_mblock.mb_data^.mbp_buf,
                      acv.a_mblock.mb_data_len+1, _i_length,
                      acv.a_returncode);
                acv.a_mblock.mb_data_len := acv.a_mblock.mb_data_len + _i_length;
                dmli.d_pos_in_parsbuf := dmli.d_pos_in_parsbuf +
                      _i_length;
                END;
            (*ENDIF*) 
            IF  acv.a_stored_proc_call
            THEN
                BEGIN
                IF  ( ssConstParamExpr_egg00 in
                    acv.a_mblock.mb_qual^.mstack_state )
                THEN
                    a505const_param_expression ( acv, dmli,
                          acv.a_mblock );
&               IFDEF TRACE
                (*ENDIF*) 
                t01messblock (ak_sem, 'MBLOCK 505mo', acv.a_mblock);
&               ENDIF
                acv.a_returncode := cak_e_dbproc_call (* PTS 1112612 *)
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            acv.a_mblock.mb_trns := @acv.a_transinf.tri_trans;
            _mtype  := acv.a_mblock.mb_type;
            _m2type := acv.a_mblock.mb_type2;
            _b_err  := e_ok;
            IF  _m2type = mm_ok_not_allowed
            THEN
                acv.a_mblock.mb_type2 := mm_compare_record
            ELSE
                IF  (_m2type IN [mm_empty,mm_trunc]) AND (_mtype = m_delete)
                THEN
                    _m2type := mm_qual;
                (*ENDIF*) 
            (*ENDIF*) 
            _qbufp := NIL;
            WITH dmli.d_sparr.px[ 1 ]^.sparsinfo DO
                IF  p_select AND
                    p_single AND
                    _last_single_no_union
                THEN
                    BEGIN
                    _h_rescount := dmli.d_mselect_rescnt;
                    dmli.d_mselect_rescnt := 0;
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
            IF  (acv.a_mblock.mb_fieldlists[cgg_idx_param_valuefieldlist] <> NIL) AND
                (erec.ex_plus + 1 <= erec.ex_maxbufs) (* another messblock will come *)
            THEN
                erec.ex_parameter_fieldlist :=
                      ak104_GetReference_MS (acv.a_mblock.mb_fieldlists[cgg_idx_param_valuefieldlist])
            ELSE
                IF  (acv.a_mblock.mb_fieldlists[cgg_idx_param_valuefieldlist] = NIL) AND
                    (erec.ex_parameter_fieldlist <> NIL)
                THEN
                    acv.a_mblock.mb_fieldlists[cgg_idx_param_valuefieldlist] :=
                          ak104_GetReference_MS (erec.ex_parameter_fieldlist);
                (*ENDIF*) 
            (*ENDIF*) 
            IF  (acv.a_mblock.mb_fieldlists[cgg_idx_ex_result_valuefieldlist] <> NIL) AND
                (erec.ex_plus + 1 <= erec.ex_maxbufs) (* another messblock will come *)
            THEN
                erec.ex_result_fieldlist :=
                      ak104_GetReference_MS (acv.a_mblock.mb_fieldlists[cgg_idx_ex_result_valuefieldlist])
            ELSE
                IF  (acv.a_mblock.mb_fieldlists[cgg_idx_ex_result_valuefieldlist] = NIL) AND
                    (erec.ex_result_fieldlist <> NIL)
                THEN
                    acv.a_mblock.mb_fieldlists[cgg_idx_ex_result_valuefieldlist] :=
                          ak104_GetReference_MS (erec.ex_result_fieldlist);
                (*ENDIF*) 
            (*ENDIF*) 
            IF  (_m2type = mm_with_join) AND
                (_mtype in [m_select, m_show])
            THEN
                BEGIN
                _munion_cnt   := acv.a_union_cnt;
                IF  _not_last
                THEN
                    acv.a_union_cnt := 0;
                (*ENDIF*) 
                _ssr_rec.ssr_old_strategynum := strat_inv_in;
                _ssr_rec.ssr_new_strategynum := strat_inv_in;
                _ssr_rec.ssr_invlen := 0;
                _ssr_rec.ssr_filler         := false;
                _ssr_rec.ssr_reverse_access := false;
                _join_parsk      := parsk;
                _join_parsk.p_no := erec.ex_plus;
                _aux_fieldlists := acv.a_mblock.mb_fieldlists;
                a682_only_ex_join (acv,
                      dmli, _join_parsk, erec.ex_act_treeid,
                      _last_single_no_union);
                a06drop_ex_fieldlist_refs (_aux_fieldlists);
                IF  ((acv.a_returncode =
                    a071_return_code (e_no_next_record, acv.a_sqlmode)) AND
                    erec.ex_output_wanted                    AND
                    dmli.d_sparr.px[ 1 ]^.sparsinfo.p_select AND
                    dmli.d_sparr.px[ 1 ]^.sparsinfo.p_single AND
                    ((dmli.d_mselect_loop_cnt <> cgg04_first_and_only_of_all) OR
                    ( _h_rescount > 0)))
                    (* MSELECT INTO FROM x,y *)
                THEN
                    BEGIN
                    acv.a_returncode := 0;
                    _b_err := e_no_next_record;
                    END;
                (*ENDIF*) 
                acv.a_union_cnt     := _munion_cnt;
                END
            ELSE
                IF  ((_mtype = m_lock)  OR
                    ( _mtype = m_unlock) OR
                    ( _mtype = m_commit) OR
                    ( _mtype = m_rollback))
                THEN
                    BEGIN
                    ak505dist_lock_mess_bufs (acv, _m2type = mm_nil)
                    END
                ELSE
                    BEGIN
                    IF  _last_single_no_union
                        AND
                        ((_mtype = m_insert)        OR
                        ( _mtype = m_insert_select) OR
                        ( _mtype = m_delete)        OR
                        ( _mtype = m_update))
                    THEN
                        dmli.d_mselect_rescnt := cak_is_undefined;
                    (*ENDIF*) 
                    IF  ( ssConstParamExpr_egg00 in
                        acv.a_mblock.mb_qual^.mstack_state )
                    THEN
                        a505const_param_expression ( acv, dmli,
                              acv.a_mblock );
                    (*ENDIF*) 
                    _trans_b_err := e_ok;
                    IF  dmli.d_sparr.px[ 1 ]^.sparsinfo.p_own_trans
                    THEN
                        BEGIN
                        a51_internal_trans (acv, _oldContext);
                        _trans_b_err := acv.a_transinf.tri_trans.trError_gg00;
                        IF  _trans_b_err <> e_ok
                        THEN
                            a07_b_put_error (acv, _trans_b_err, 1)
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  ((_mtype  in [ m_select, m_show ]) AND
                        ((_m2type = mm_nil)  OR
                        ( _m2type = mm_with_functions)))
                        OR
                        ((_m2type in [ mm_qual, mm_trunc, mm_empty ]) AND
                        ((_mtype  = m_update) OR (_mtype = m_delete)))
                        OR
                        (_mtype   = m_insert_select)
                    THEN
                        BEGIN
                        IF  _mtype = m_insert_select
                        THEN
                            acv.a_curr_res_id := acv.a_max_res_id;
                        (*ENDIF*) 
                        a505strategy_search (acv, dmli, _mtype,
                              _searchname, erec.ex_act_treeid,
                              _ssr_rec, _qbufp, parsk, _not_last);
                        IF  _last_single_no_union
                            AND (_mtype in [ m_select, m_show ])
                        THEN
                            BEGIN
&                           ifdef trace
                            t01int4 (ak_sem, 'loop_cnt    ', dmli.d_mselect_loop_cnt);
&                           endif
                            IF  (dmli.d_mselect_loop_cnt = cgg04_first_and_only_of_all)
                                OR
                                (((dmli.d_mselect_loop_cnt = cgg04_first_of_all) OR
                                (  dmli.d_mselect_loop_cnt = cgg04_first_and_only_of_this)) AND
                                NOT dmli.d_repl_reskey)
                            THEN
                                BEGIN
                                END
                            ELSE
                                BEGIN
                                _gg_strategy_ptr := @acv.a_mblock.mb_strat^[
                                      acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].epos ];
                                _gg_strategy_ptr^.str_result_id.
                                      fileHandling_gg00 := _gg_strategy_ptr^.
                                      str_result_id.fileHandling_gg00 - [ hsCreateFile_egg00 ];
                                END;
                            (*ENDIF*) 
                            IF  ( dmli.d_mselect_rescnt > 0 )
                            THEN
                                BEGIN
                                _gg_strategy_ptr := @acv.a_mblock.mb_strat^[
                                      acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].epos ];
                                _gg_strategy_ptr^.str_foundresults :=
                                      dmli.d_mselect_rescnt;
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  ((cinfo.co_use_cinfo) AND
                        (acv.a_union_cnt > 0 ) AND
                        ( ( (cinfo.co_use_fields = keyfields) AND
                        (  acv.a_rest_equal_second ))
                        OR
                        (   (cinfo.co_use_fields = no_fields) AND
                        (    NOT acv.a_rest_equal_second )   AND
                        (    erec.ex_plus + 1 > erec.ex_maxbufs ) ) ) )
                    THEN
                        a503build_union_buffer (acv, NOT c_in_join);
                    (*ENDIF*) 
                    IF  acv.a_returncode = 0
                    THEN
                        IF  ((_mtype = m_update_rec) AND
                            (_m2type <> mm_file))
                        THEN
                            a59handle_qualification (acv,
                                  erec.ex_updjv_ptr^, _b_err)
                        ELSE
                            IF  _mtype = m_shutdown
                            THEN
                                a26execute_comment (acv, dmli)
                            ELSE
                                WITH acv.a_mblock DO
                                    BEGIN
                                    IF  (mb_type     = m_delete) AND
                                        (mb_type2 IN [ mm_empty, mm_trunc ])
                                    THEN
                                        a10invalidate_root (acv,
                                              mb_qual^.mtree);
                                    (*ENDIF*) 
                                    _aux_treeid := mb_qual^.mtree;
&                                   IFDEF TRACE
                                    t01int4 (ak_sem, 'a_union_cnt*', acv.a_union_cnt);
&                                   ENDIF
                                    IF  (acv.a_mblock.mb_type = m_insert_select) AND (dmli.d_table_as_id <> cgg_zero_id)
                                    THEN
                                        BEGIN
&                                       ifdef trace
                                        t01surrogate (ak_sem, 'table as id ', dmli.d_table_as_id);
&                                       endif
                                        _gg_strategy_ptr := @acv.a_mblock.mb_strat^[
                                              acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].epos ];
                                        _gg_strategy_ptr^.str_result_id.fileTabId_gg00 := dmli.d_table_as_id;
                                        IF  a101_IsExtendedTempFile (acv,
                                            _gg_strategy_ptr^.str_result_id)
                                        THEN
                                            BEGIN
                                            (* fileTabId is that of    *)
                                            (* a temp file instance,   *)
                                            (* we have to make sure    *)
                                            (* the whole fileId is set *)
                                            (* accordingly (no         *)
                                            (* ROOT_CHECK etc.)        *)
                                            b01filestate (
                                                  acv.a_transinf.tri_trans,
                                                  _gg_strategy_ptr^.str_result_id);
                                            (* clear level/index info *)
                                            FOR _ix := 11 TO 15 DO
                                                _gg_strategy_ptr^
                                                      .str_result_id.fileName_gg00 [_ix] := chr (0);
                                            (*ENDFOR*) 
                                            (* set temp file type *)
                                            _gg_strategy_ptr^.str_result_id
                                                  .fileName_gg00[16] :=
                                                  chr (ord (ttfnTempTable_egg00));
                                            END;
                                        (*ENDIF*) 
                                        END;
                                    (*ENDIF*) 
                                    a06dml_send_mess_buf (acv,
                                          acv.a_mblock, dmli, _b_err);
                                    END;
                                (*ENDWITH*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  (dmli.d_sparr.px[ 1 ]^.sparsinfo.p_own_trans)
                        AND
                        (_trans_b_err = e_ok)
                    THEN
                        BEGIN
                        IF  acv.a_returncode = 0
                        THEN
                            _trans_m_type := m_commit
                        ELSE
                            _trans_m_type := m_rollback;
                        (*ENDIF*) 
                        acv.a_transinf.tri_trans.trError_gg00 := e_ok;
                        a51close_internal_trans (acv, _oldContext, _trans_m_type);
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  acv.a_returncode = 0
            THEN
                WITH dmli.d_sparr.px[ 1 ]^.sparsinfo DO
                    BEGIN
&                   ifdef trace
                    t01treeid (ak_sem, 'after dml_se', erec.ex_act_treeid);
                    t01int4    (ak_sem, 'p_select    ', ord (p_select));
                    t01int4    (ak_sem, 'p_single    ', ord (p_single));
                    t01int4    (ak_sem, 'last_single ', ord (_last_single_no_union));
                    t01int4    (ak_sem, 'd_dist_optim', dmli.d_dist_optim);
&                   endif
                    IF  (p_select AND NOT p_single)
                        AND
                        a101_IsExtendedTempFile (acv, erec.ex_act_treeid) AND
                        (a101_GetExtendedTempFileType (acv, erec.ex_act_treeid)
                        = ttfnUserResult_egg00)
                    THEN
                        BEGIN
                        a101_GetLogicalFilename (acv.a_transinf.tri_trans,
                              acv.a_resname_addr[ cak_extern_pos ]^.sresname
                              .restreeid);
                        a101_SetTempFileIndex (acv,
                              acv.a_resname_addr[ cak_extern_pos ]^.sresname
                              .restreeid, acv.a_curr_res_id);
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            IF  acv.a_returncode = 0
            THEN
                BEGIN
                IF  ((_b_err = e_no_next_record)              AND
                    erec.ex_output_wanted                    AND
                    dmli.d_sparr.px[ 1 ]^.sparsinfo.p_select AND
                    dmli.d_sparr.px[ 1 ]^.sparsinfo.p_single AND
                    ((dmli.d_mselect_loop_cnt <> cgg04_first_and_only_of_all) OR
                    ( _h_rescount > 0)))
                THEN
                    BEGIN
                    _b_err := e_ok;
                    _i_length := dmli.d_sparr.px[ 1 ]^.sparsinfo.p_resreclen;
                    SAPDB_PascalFill ('VAK505',   9,    
                          acv.a_mblock.mb_data_size,
                          @acv.a_mblock.mb_data^.mbp_buf, 1,
                          _i_length, csp_undef_byte,
                          acv.a_returncode);
                    acv.a_mblock.mb_data^.mbp_reclen := _i_length;
                    acv.a_mblock.mb_data^.mbp_keylen := 1;
                    acv.a_mblock.mb_qual^.mr_resnum := csp_rescnt_zero;
                    END;
                (*ENDIF*) 
                IF  _b_err <> e_ok
                THEN
                    BEGIN
                    IF  (_m2type = mm_compare_record) OR
                        (_m2type = mm_ok_not_allowed)
                    THEN
                        IF  _b_err = e_duplicate_record
                        THEN
                            _b_err := e_ok
                        ELSE
                            a07_b_put_error (acv,
                                  e_foreign_key_violation, 1)
                        (*ENDIF*) 
                    ELSE
                        BEGIN
                        IF  ((_b_err = e_no_next_record)  OR
                            (_b_err = e_key_not_found))
                            AND
                            (acv.a_mblock.mb_qual_len  =
                            MB_PART1_HEAD_MXGG00 + MB_PART1_RETURN_MXGG00) AND
                            (NOT a101_IsExtendedTempFile (acv, _aux_treeid)) AND
                            (_m2type <> mm_with_join)
                        THEN
                            WITH dmli.d_sparr.px[ 1 ]^.sparsinfo DO
                                IF  ((acv.a_mblock.mb_qual^.mr_pagecnt >
                                    cak68_updstat_minpages) AND
                                    (acv.a_mblock.mb_qual^.mr_pagecnt >
                                    p_pagecnt * cak68_updstat_factor))
                                THEN
                                    a28sys_upd_statistics (acv,
                                          _aux_treeid, _mtype, _m2type, p_pagecnt,
                                          acv.a_mblock.mb_qual^.mr_pagecnt);
                                (*ENDIF*) 
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        a07_b_put_error (acv, _b_err, 1)
                        END;
                    (*ENDIF*) 
                    IF  _qbufp <> NIL
                    THEN
                        a10key_del (acv, _qbufp);
                    (*ENDIF*) 
                    WITH dmli.d_sparr.px[ 1 ]^.sparsinfo DO
                        IF  p_select AND NOT p_single AND
                            _last_single_no_union
                        THEN
                            acv.a_resname_addr[ _pos ]^.sresname.
                                  resexecuted := false;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    END
                ELSE
                    BEGIN
                    IF  _m2type = mm_ok_not_allowed
                    THEN
                        a07_b_put_error (acv,
                              e_foreign_key_must_exist, 1)
                    ELSE
                        IF  (parsk.p_kind = m_commit) OR
                            (parsk.p_kind = m_rollback)
                            (*  with keep lock *)
                        THEN
                            a52init_subtrans_of_new_trans (acv)
                        ELSE
                            IF  _last_single_no_union
                            THEN
                                BEGIN
                                IF  _mtype in [ m_select, m_show ]
                                THEN
                                    WITH dmli.d_sparr.px[ 1 ]^.sparsinfo DO
                                        BEGIN
                                        s40g4int (acv.a_mblock.mb_qual^.mr_resnum, 2,
                                              dmli.d_mselect_rescnt, _re);
                                        IF  p_select AND p_single
                                        THEN
                                            dmli.d_mselect_rescnt :=
                                                  _h_rescount +
                                                  dmli.d_mselect_rescnt;
                                        (*ENDIF*) 
                                        END;
                                    (*ENDWITH*) 
                                (*ENDIF*) 
                                IF  dmli.d_longdesc_found
                                THEN
                                    ak505long_support (acv, dmli, _mtype, _m2type);
                                (*ENDIF*) 
                                IF  dmli.d_literalrec <> NIL
                                THEN
                                    a507_literal (acv,
                                          dmli.d_literalrec^.slongliteral,
                                          NOT c_useLiteralBuf);
&                               ifdef TRACE
                                (*ENDIF*) 
                                WITH dmli.d_sparr.px[ 1 ]^.sparsinfo DO
                                    t01int4 (ak_sem, 'pagecnt     ', p_pagecnt);
                                (*ENDWITH*) 
&                               endif
                                IF  (
                                    (((_mtype = m_select) AND
                                    (_m2type <> mm_with_join) AND
                                    acv.a_mblock.mb_qual^.mr_res_build) OR
                                    ((_mtype = m_select_row) AND
                                    (_m2type <> mm_direct)) OR
                                    ( _mtype = m_insert_select) OR
                                    ( (_mtype in [ m_update, m_delete])
                                    AND (_m2type in [ mm_qual,
                                    mm_trunc, mm_empty ]))) AND
                                    (NOT a101_IsExtendedTempFile (acv, _aux_treeid)))
                                THEN
                                    WITH dmli.d_sparr.px[ 1 ]^.sparsinfo DO
                                        IF  ((acv.a_mblock.mb_qual^.mr_pagecnt >
                                            cak68_updstat_minpages) AND
                                            (acv.a_mblock.mb_qual^.mr_pagecnt >
                                            p_pagecnt * cak68_updstat_factor))
                                        THEN
                                            a28sys_upd_statistics (acv,
                                                  _aux_treeid, _mtype, _m2type, p_pagecnt,
                                                  acv.a_mblock.mb_qual^.mr_pagecnt);
                                        (*ENDIF*) 
                                    (*ENDWITH*) 
                                (*ENDIF*) 
                                IF  acv.a_return_segm^.sp1r_function_code <> csp1_explain_fc
                                THEN
                                    IF  NOT ((_mtype = m_select) AND
                                        (dmli.d_mselect_loop_cnt <> cgg04_last_of_this) AND
                                        (dmli.d_mselect_loop_cnt <> cgg04_first_and_only_of_all) AND
                                        (dmli.d_mselect_loop_cnt <> cgg04_first_and_only_of_this) AND
                                        (dmli.d_mselect_loop_cnt <> cgg04_last_of_all))
                                    THEN
                                        (* = cgg04_first_of_all or > cgg04_last_of_this *)
                                        a507last_command_part (acv,
                                              dmli, change_rec,
                                              parsk, _resnam, _w_link, _qbufp,
                                              _ssr_rec, _pos, _mtype,
                                              _m2type, erec.ex_output_wanted)
                                    ELSE
                                        IF  (erec.ex_output_wanted AND
                                            dmli.d_sparr.px[ 1 ]^.sparsinfo.p_select AND
                                            dmli.d_sparr.px[ 1 ]^.sparsinfo.p_single)
                                        THEN
                                            BEGIN
                                            (* MSELECT INTO *)
&                                           ifdef TRACE
                                            t01int4 (ak_sem, 'MSELECT INTO',
                                                  dmli.d_sparr.px[ 1 ]^.sparsinfo.p_resinfolen);
&                                           endif
                                            IF  NOT dmli.d_local_massdata_part
                                            THEN
                                                BEGIN
                                                _p := gg941Allocate (acv.a_transinf.tri_trans,
                                                      acv.a_data_length);
                                                IF  _p = NIL
                                                THEN
                                                    a07_b_put_error (acv, e_no_more_memory, 1)
                                                ELSE
                                                    BEGIN
                                                    dmli.d_massdata_ptr        := @_p^;
                                                    SAPDB_PascalMove ('VAK505',  10,    
                                                       acv.a_data_length, acv.a_data_length,
                                                       @acv.a_data_ptr^, 1,
                                                       @dmli.d_massdata_ptr^, 1,
                                                       acv.a_data_length,
                                                       acv.a_returncode);
                                                    acv.a_data_ptr := dmli.d_massdata_ptr;
                                                    dmli.d_local_massdata_part := true;
                                                    END;
                                                (*ENDIF*) 
                                                END;
                                            (*ENDIF*) 
                                            IF  acv.a_returncode = 0
                                            THEN
                                                BEGIN
                                                acv.a_long_desc_pos := 0;
                                                IF  change_rec.cr_colcount > 0
                                                THEN
                                                    a60_change_results (acv, acv.a_mblock.mb_data^.mbp_buf,
                                                       change_rec, 0, acv.a_mblock.mb_data_len);
                                                (*ENDIF*) 
                                                _pos := cgg_rec_key_offset +
                                                      acv.a_mblock.mb_data^.mbp_keylen + 1;
                                                a06retpart_move (acv, @acv.a_mblock.mb_data^.mbp_buf [ _pos ],
                                                      dmli.d_sparr.px[ 1 ]^.sparsinfo.p_resinfolen);
                                                IF  (acv.a_returncode = 0) AND
                                                    ((dmli.d_mselect_loop_cnt = cgg04_last_of_this) OR
                                                    ( dmli.d_mselect_loop_cnt = cgg04_first_and_only_of_all) OR
                                                    ( dmli.d_mselect_loop_cnt = cgg04_first_and_only_of_this) OR
                                                    ( dmli.d_mselect_loop_cnt = cgg04_last_of_all))
                                                THEN
                                                    a06finish_curr_retpart (acv, sp1pk_data,
                                                       acv.a_curr_retpart^.sp1p_buf_len DIV
                                                       dmli.d_sparr.px[ 1 ]^.sparsinfo.p_resinfolen);
                                                (* do not use dmli.d_mselect_rescnt       *)
                                                (* it only counts real (NOT NULL) results *)
                                                (*ENDIF*) 
                                                END
                                            (*ENDIF*) 
                                            END
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                END
                            (* PTS 1123727 E.Z. *)
                            ELSE
                                IF  (parsk.p_kind = m_key)
                                THEN
                                    BEGIN
                                    IF  dmli.d_longdesc_found
                                    THEN
                                        ak505long_support (acv, dmli, _mtype, _m2type);
                                    (*ENDIF*) 
                                    IF  (dmli.d_literalrec <> NIL)
                                    THEN
                                        a507_literal (acv, dmli.d_literalrec^.slongliteral,
                                              NOT c_useLiteralBuf);
                                    (*ENDIF*) 
                                    END
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
dmli.d_rowno := _h_rowno;
a06drop_fieldlist_references (acv.a_mblock.mb_fieldlists);
erec.ex_with_link := _w_link;
ak505release_longlit_rec( acv, dmli);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a505next_command (
            VAR acv       : tak_all_command_glob;
            VAR sparr     : tak_syspointerarr;
            VAR old_parsk : tak_parskey;
            ex_plus       : integer);
 
VAR
      b_err         : tgg00_BasisError;
      ke            : tgg00_SysInfoKey;
 
BEGIN
ke     := a01sysnullkey;
ke.sauthid[ 1 ] := cak_tempinfo_byte;
SAPDB_PascalForcedMove (sizeof(old_parsk), sizeof(ke.sauthid), @old_parsk, 1,
      @ke.sauthid, 2, mxak_parskey);
ke.sauthid[ 1+mxak_parskey ] := chr(ex_plus);
ke.sentrytyp := cak_eparsinfo;
a10get_sysinfo (acv, ke, d_fix, sparr.px[ 1 ], b_err);
IF  b_err <> e_ok
THEN
    IF  b_err = e_sysinfo_not_found
    THEN
        a07_b_put_error (acv, e_old_fileversion, 1)
    ELSE
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
ELSE
    BEGIN
&   IFDEF TRACE
    t01buf (ak_sem, sparr.px[ 1 ]^, 1, sparr.px[ 1 ]^.b_sl);
&   ENDIF
    IF  acv.a_statement_parsid.pid_parsk.p_kind = m_sharedSQLParseid
    THEN
        BEGIN
        (* nothing to do, modulename has alread been read by a101_GetExecuteHandle *)
        END
    ELSE
        acv.a_modul_name := sparr.px[ 1 ]^.sparsinfo.p_modul_name;
    (*ENDIF*) 
    IF  ((acv.a_statement_kind = isql_commands) AND
        (sparr.px[ 1 ]^.sparsinfo.p_statement_kind <>
        icollisions))
    THEN
        acv.a_statement_kind :=
              sparr.px[ 1 ]^.sparsinfo.p_statement_kind;
    (*ENDIF*) 
    IF  ((acv.a_precomp_info_byte in
        [ csp1_p_mass_command,
        csp1_p_mselect_found,
        csp1_p_for_upd_mselect_found,
        csp1_p_reuse_mselect_found,
        csp1_p_reuse_upd_mselect_found ])              AND
        (acv.a_precomp_info_byte <>
        sparr.px[ 1 ]^.sparsinfo.p_precomp_info_byte) AND
        (sparr.px[ 1 ]^.sparsinfo.p_precomp_info_byte
        <> csp1_p_none))
    THEN
        a07_b_put_error (acv, e_invalid_command,
              mxak_parsid-1);
    (*ENDIF*) 
    acv.a_sqlmode := sparr.px[ 1 ]^.sparsinfo.p_sqlmode;
&   ifdef TRACE
    t01int4 (ak_sem, 'function_cod',
          sparr.px[ 1 ]^.sparsinfo.p_function_code);
&   endif
    acv.a_return_segm^.sp1r_function_code :=
          sparr.px[ 1 ]^.sparsinfo.p_function_code;
    IF  (acv.a_iso_level = cak_iso_level_stmt_consistent)               AND
        (acv.a_transinf.tri_trans.trConsistReadInfo_gg00 = CnsReadNone) AND
        (acv.a_return_segm^.sp1r_function_code in [csp1_select_fc,
        csp1_select_direct_fc,
        csp1_select_first_fc,
        csp1_select_last_fc,
        csp1_select_next_fc,
        csp1_select_prev_fc])
    THEN
        acv.a_transinf.tri_trans.trConsistReadInfo_gg00 := CnsReadStatement;
    (*ENDIF*) 
    IF  (acv.a_precomp_info_byte <> csp1_p_mass_command) AND
        (acv.a_return_segm^.sp1r_function_code
        in [ csp1_minsert_fc, csp1_mupdate_fc,
        csp1_mdelete_fc ])
    THEN
        acv.a_return_segm^.sp1r_function_code :=
              acv.a_return_segm^.sp1r_function_code
              - csp1_masscmd_fc_offset;
    (*ENDIF*) 
    sparr.pcount := 1;
    (* PTS 1104055 E.Z. *)
    (* PTS 1133623 E.Z. *)
    (* it cannot be that ALL following executions will use a_parsing_again := true *)
    (*
          IF  sparr.px[ 1 ]^.sparsinfo.p_parsing_again
          THEN
          BEGIN
          a_parsing_again := true;
          ( * sparr.px[ 1 ]^.sparsinfo.p_parsing_again := false;
          a10repl_sysinfo (acv, sparr.px[ 1 ], b_err) * )
          END;
          *)
    acv.a_cmd_id := sparr.px[ 1 ]^.sparsinfo.p_cmd_id;
    IF  ( pi_hint_exist in sparr.px[ 1 ]^.sparsinfo.p_bool_states )
    THEN
        (* mark existence of hint *)
        acv.a_sql_cmd_state :=
              acv.a_sql_cmd_state + [ csa_hint_exist ]
    ELSE
        (* remove earlier existence of hint *)
        acv.a_sql_cmd_state :=
              acv.a_sql_cmd_state - [ csa_hint_exist ]
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a505strategy_search (
            VAR acv          : tak_all_command_glob;
            VAR dmli         : tak_dml_info;
            mtype            : tgg00_MessType;
            VAR searchname   : tsp00_KnlIdentifier;
            VAR act_res_tree : tgg00_FileId;
            VAR ssr_rec      : tak71_select_strat_rec;
            VAR qbufp        : tak_sysbufferaddress;
            VAR parsk        : tak_parskey;
            not_last         : boolean);
 
VAR
      _finding_possible   : boolean;
      _isExtendedTempFile : boolean;
      _resTempTfn         : tgg00_TfnTemp;
      _StratInfo_len      : tsp00_Int2;
      _ix                 : tsp00_Int4;
      _jx                 : tsp00_Int4;
      _prev               : tsp00_Int4;
      _mv_strat_len       : tsp00_Int4;
      _gg_strategy_ptr    : ^tgg07_StrategyInfo;
      _old_strat_len      : tsp00_Int4;
      _b_err              : tgg00_BasisError;
      _ke                 : tgg00_SysInfoKey;
      _gg_strategy        : tgg07_StrategyInfo;
      _config             : tak00_access_configuration;
 
BEGIN
_gg_strategy_ptr := @acv.a_mblock.
      mb_strat^[ acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].epos ];
IF  a101_IsExtendedTempFile (acv, acv.a_mblock.mb_qual^.mtree)
THEN
    IF  a101_GetExtendedTempFileType (acv, acv.a_mblock.mb_qual^.mtree) =
        ttfnUserResult_egg00
    THEN
        a505check_if_executed (acv, searchname, acv.a_mblock.mb_qual^.mtree)
    ELSE
        IF  NOT (acv.a_recursive_state in
            [ rs_no_recursive_select, rs_first_select ])  AND
            (a101_GetExtendedTempFileType (acv, acv.a_mblock.mb_qual^.mtree) =
            ttfnRecursive_egg00)
        THEN
            a101_SetTempFileLevel (acv, acv.a_mblock.mb_qual^.mtree,
                  acv.a_recursive_no - 1);
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    IF  NOT not_last AND ( acv.a_union_cnt > 0 )
    THEN
        BEGIN
        a503build_union_buffer (acv, NOT c_in_join);
&       IFDEF TRACE
        t01messblock (ak_sem, 'MBLOCK 505st', acv.a_mblock);
&       ENDIF
        END;
&   ifdef trace
    (*ENDIF*) 
    t01treeid( ak_sem, 'act_res_tree', _gg_strategy_ptr^.str_result_id );
&   endif
    _isExtendedTempFile := a101_IsExtendedTempFile (acv, _gg_strategy_ptr^.str_result_id);
    IF  _isExtendedTempFile
    THEN
        _resTempTfn := a101_GetExtendedTempFileType (acv, _gg_strategy_ptr^.str_result_id)
    ELSE
        _resTempTfn := ttfnNone_egg00;
    (*ENDIF*) 
    acv.a_from_select := acv.a_from_select OR ( _resTempTfn = ttfnFromSelect_egg00);
    (* PTS 1000644 E.Z. *)
    IF  ( acv.a_init_ddl = ddl_create_table ) OR _isExtendedTempFile
    THEN
        BEGIN
        IF  ( acv.a_init_ddl = ddl_create_table )
        THEN
            _gg_strategy_ptr^.str_result_id.
                  fileVersion_gg00.ci2_gg00 := cgg_dummy_file_version;
        (*ENDIF*) 
        IF  _isExtendedTempFile
        THEN
            IF  _resTempTfn = ttfnInto_egg00
            THEN
                BEGIN
                _gg_strategy_ptr^.str_result_id := acv.a_into_tree;
                a101_GetLogicalFilename (
                      acv.a_transinf.tri_trans,
                      _gg_strategy_ptr^.str_result_id);
                END
            ELSE
                IF  (( _resTempTfn = ttfnUserResult_egg00 )
                    OR
                    (( _resTempTfn = ttfnTempTable_egg00) AND
                    ( acv.a_is_ddl = ddl_create_table )))
                THEN
                    BEGIN
                    IF  (_resTempTfn = ttfnUserResult_egg00) AND
                        NOT (
                        (dmli.d_sparr.px[ 1 ]^.sparsinfo.p_mtyp2 = mm_with_functions)  OR
                        ((_gg_strategy_ptr^.str_distinc  = no_distinct) AND
                        ( _gg_strategy_ptr^.str_key_len > RESCNT_MXGG04))              OR
                        ((_gg_strategy_ptr^.str_distinc <> no_distinct) AND
                        ( _gg_strategy_ptr^.str_key_len > HASHVAL_MXGG04+RESCNT_MXGG04))
                        )
                    THEN
                        IF  (dmli.d_rowno = cgg04_no_rowno_predicate) AND
                            (dmli.d_upper_limit <> cgg04_no_rowno_predicate)
                        THEN
                            IF  dmli.d_limit_offset <> cgg04_no_rowno_predicate
                            THEN
                                dmli.d_rowno := dmli.d_limit_offset + dmli.d_upper_limit
                            ELSE
                                dmli.d_rowno := dmli.d_upper_limit;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    a101_GetLogicalFilename (
                          acv.a_transinf.tri_trans,
                          _gg_strategy_ptr^.str_result_id);
                    a101_SetTempFileIndex (acv,
                          _gg_strategy_ptr^.str_result_id,
                          acv.a_curr_res_id);
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  ( acv.a_recursive_state = rs_recursive_select ) AND
        _isExtendedTempFile                             AND
        (_resTempTfn = ttfnRecursive_egg00)
    THEN
        BEGIN
        a101_SetTempFileLevel (acv,_gg_strategy_ptr^.str_result_id,
              acv.a_recursive_no);
        END;
    (* PTS 1108845 E.Z. *)
    (*ENDIF*) 
    ssr_rec.ssr_old_strategynum := _gg_strategy_ptr^.str_strategy;
    ssr_rec.ssr_reverse_access  := false;
&   IFDEF TRACE
    t01messblock (ak_sem, 'MBLOCK strat', acv.a_mblock);
&   ENDIF
    IF  ( acv.a_precomp_info_byte in
        [ csp1_p_mselect_found, csp1_p_for_upd_mselect_found,
        csp1_p_reuse_mselect_found, csp1_p_reuse_upd_mselect_found ] )
    THEN
        BEGIN
        a71turn_into_build_strat( acv, _gg_strategy_ptr^.str_strategy );
        _gg_strategy_ptr^.str_build_result := true;
        END;
    (* PTS 1108845 E.Z. *)
    (*ENDIF*) 
    IF  ( _gg_strategy_ptr^.str_strategy = strat_key_equal )
        AND
        ( dmli.d_only_table_scan )
    THEN
        BEGIN
        _gg_strategy_ptr^.str_strategy := strat_undecided;
        ssr_rec.ssr_old_strategynum := _gg_strategy_ptr^.str_strategy;
        END;
    (*ENDIF*) 
    IF  dmli.d_rowno <> cgg04_no_rowno_predicate
    THEN
        BEGIN
        (* get gg_strategy *)
        SAPDB_PascalMove  ('VAK505',  11,    
              acv.a_mblock.mb_strat_size, sizeof( _gg_strategy ),
              @acv.a_mblock.mb_strat^,
              acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].epos,
              @_gg_strategy, 1,
              STRATEGY_START_MXGG07,
              acv.a_returncode);
        (* change maxresults in case no special value (subquery, ...) is in *)
        IF  (_gg_strategy.str_rowno = cgg04_rowno_given_as_parameter)
            OR (dmli.d_rowno = 1) (* TOP 1 in subqueries may overwrite other rowno-values *)
        THEN
            _gg_strategy.str_rowno := dmli.d_rowno;
        (*ENDIF*) 
        SAPDB_PascalMove  ('VAK505',  12,    
              sizeof( _gg_strategy ), acv.a_mblock.mb_strat_size,
              @_gg_strategy, 1,
              @acv.a_mblock.mb_strat^,
              acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].epos,
              STRATEGY_START_MXGG07,
              acv.a_returncode);
        END;
    (*ENDIF*) 
    IF  ( _gg_strategy_ptr^.str_strategy = strat_undecided )
    THEN
        BEGIN
        (* get gg_strategy *)
        IF  dmli.d_rowno = cgg04_no_rowno_predicate
        THEN
            SAPDB_PascalMove  ('VAK505',  13,    
                  acv.a_mblock.mb_strat_size, sizeof( _gg_strategy ),
                  @acv.a_mblock.mb_strat^,
                  acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].epos,
                  @_gg_strategy, 1,
                  STRATEGY_START_MXGG07,
                  acv.a_returncode);
        (* initialize key access *)
        (*ENDIF*) 
        FOR _ix := 0 TO MAX_COLPOSARR_IDX_GG07 DO
            BEGIN
            _gg_strategy.str_key_in_range.skir_keystart[ _ix ] := 0;
            _gg_strategy.str_key_in_range.skir_keystop[ _ix ]  := 0;
            END;
        (*ENDFOR*) 
        a80get_access_hint( acv, parsk, _config );
        a721strategy( acv, dmli, _gg_strategy, _StratInfo_len,
              acv.a_statement_parsid.pid_parsk, _config );
        IF  ( _gg_strategy.str_strategy in
            [ strat_more_than_one, strat_undecided, strat_no_result ] )
        THEN
            _mv_strat_len := STRATEGY_START_MXGG07
        ELSE
            _mv_strat_len := _StratInfo_len;
        (*ENDIF*) 
        IF  ( acv.a_returncode = 0 )
        THEN
            BEGIN
            SAPDB_PascalMove  ('VAK505',  14,    
                  sizeof( _gg_strategy ), acv.a_mblock.mb_strat_size,
                  @_gg_strategy, 1,
                  @acv.a_mblock.mb_strat^,
                  acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].epos,
                  _mv_strat_len,
                  acv.a_returncode);
            IF  ( _gg_strategy.str_strategy <> strat_undecided )
            THEN
                acv.a_mblock.mb_strat_len := acv.a_mblock.
                      mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].epos +
                      _StratInfo_len - 1;
            (*ENDIF*) 
            acv.a_mblock.
                  mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].elen_var := _mv_strat_len;
            IF  NOT (( mtype = m_select ) AND
                ( dmli.d_mselect_loop_cnt <> cgg04_last_of_this ) AND
                ( dmli.d_mselect_loop_cnt <> cgg04_first_and_only_of_all ) AND
                ( dmli.d_mselect_loop_cnt <> cgg04_first_and_only_of_this ) AND
                ( dmli.d_mselect_loop_cnt <> cgg04_last_of_all ))
            THEN
                (* = cgg04_first_of_all, > cgg04_last_of_this *)
                a70_invkeylen( acv, _gg_strategy, ssr_rec.ssr_invlen )
            ELSE
                ssr_rec.ssr_invlen := 0;
            (*ENDIF*) 
            IF  (( _gg_strategy.str_strategy in a70glob_key_fetch_strats ) AND
                ( ksp_order_support_reverse in _gg_strategy.str_key_in_range.skir_strat_props ))
                OR
                (( _gg_strategy.str_strategy in a70glob_inv_fetch_strats ) AND
                ( isp_order_support_reverse in _gg_strategy.str_inv_in_range.siir_strat_props ))
            THEN
                BEGIN
                ssr_rec.ssr_reverse_access := true;
&               ifdef trace
                t01bool( ak_sem, 'rev access  ', ssr_rec.ssr_reverse_access );
&               endif
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    dmli.d_qual_kind := _gg_strategy_ptr^.str_qual_kind;
&   ifdef trace
    t01qual_kind( ak_sem, 'd_qual_kind ', dmli.d_qual_kind );
&   endif
    ssr_rec.ssr_new_strategynum := _gg_strategy_ptr^.str_strategy;
    IF  ( mtype = m_select )
    THEN
        BEGIN
        IF  dmli.d_sparr.px[ 1 ]^.sparsinfo.p_select       AND
            NOT dmli.d_sparr.px[ 1 ]^.sparsinfo.p_single
        THEN
            IF  NOT ( ssr_rec.ssr_new_strategynum in a70glob_fetch_strats ) AND
                (_gg_strategy_ptr^.str_rec_len > MAX_RECLEN_GG00)
            THEN
                a07_b_put_error (acv, e_output_columns_too_long, 3)
            ELSE
                IF  ( ssr_rec.ssr_new_strategynum in a70glob_fetch_strats ) AND
                    NOT not_last
                THEN
                    BEGIN
                    IF  a507optim_select_fetch (acv, dmli,
                        dmli.d_sparr.px[ 1 ]^.sparsinfo.p_prepare,
                        dmli.d_sparr.px[ 1 ]^.sparsinfo.p_precomp_info_byte,
                        dmli.d_mselect_loop_cnt)
                    THEN
                        BEGIN
                        (* PTS 1000514 E.Z. *)
                        _gg_strategy_ptr^.str_search_first := false;
&                       ifdef trace
                        t01name( ak_sem, 'select fetch optim' );
&                       endif
                        END;
                    (*ENDIF*) 
                    g04spec_null_check (acv.a_mblock, _b_err);
                    IF  ( _b_err <> e_ok )
                    THEN
                        a07_b_put_error (acv, _b_err, 1)
                    ELSE
                        BEGIN
                        g04inbetween_change( acv.a_mblock, _finding_possible );
                        _gg_strategy_ptr^.str_res_possible := _finding_possible;
                        _ke           := a01sysnullkey;
                        _ke.stempid   := a101_GetTempFileIndex (acv,
                              _gg_strategy_ptr^.str_result_id);
                        _ke.sentrytyp := cak_emessblock
                              ;
                        acv.a_mblock.mb_qual_len  := MB_PART1_HEAD_MXGG00;
                        IF  ( acv.a_mblock.mb_qual^.mqual_cnt > 0 ) AND
                            ( acv.a_mblock.
                            mb_st^[ acv.a_mblock.mb_qual^.mqual_pos ].etype = st_jump_output )
                        THEN
                            BEGIN
&                           ifdef trace
                            t01int4( ak_strat, 'str_key_len ',
                                  _gg_strategy_ptr^.str_key_len );
&                           endif
                            _prev := acv.a_mblock.mb_qual^.mqual_pos + 1;
                            FOR _ix := acv.a_mblock.mb_qual^.mqual_pos + 1 TO
                                  acv.a_mblock.mb_qual^.mqual_pos +
                                  acv.a_mblock.
                                  mb_st^[ acv.a_mblock.mb_qual^.mqual_pos ].epos - 1 DO
                                IF  acv.a_mblock.mb_st^[ _ix ].etype = st_output
                                THEN
                                    BEGIN
                                    IF  acv.a_mblock.mb_st^[_ix].epos <= cgg_rec_key_offset +
                                        _gg_strategy_ptr^.str_key_len
                                    THEN
                                        FOR _jx := _ix DOWNTO _prev DO
                                            acv.a_mblock.mb_st^[ _jx ].etype := st_dummy
                                        (*ENDFOR*) 
                                    ELSE
                                        IF  ( acv.a_mblock.mb_st^[ _ix ].eop_out = op_o_output_hold )
                                            AND
                                            ( acv.a_mblock.mb_st^[ _ix + 1 ].epos <=
                                            cgg_rec_key_offset +
                                            _gg_strategy_ptr^.str_key_len )
                                        THEN
                                            acv.a_mblock.mb_st^[ _ix ].eop_out :=
                                                  op_o_none;
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                    _prev := _ix + 1;
                                    END;
                                (*ENDIF*) 
                            (*ENDFOR*) 
                            acv.a_mblock.
                                  mb_st^[ acv.a_mblock.mb_qual^.mqual_pos ].elen_var :=
                                  cgg_rec_key_offset + _gg_strategy_ptr^.str_key_len + 1;
&                           ifdef trace
                            t01int4( ak_sem, 'output_offse', acv.a_mblock.
                                  mb_st^[ acv.a_mblock.mb_qual^.mqual_pos ].elen_var );
&                           endif
                            END;
                        (*ENDIF*) 
                        g04mblock_optimize_info( acv.a_mblock );
                        _old_strat_len := acv.a_mblock.mb_strat_len;
                        acv.a_mblock.mb_strat_len   := acv.a_mblock.
                              mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].epos - 1;
                        a10mblock_into_cache( acv,
                              _ke, acv.a_mblock, d_fix, qbufp, _b_err );
                        acv.a_mblock.mb_strat_len := _old_strat_len;
                        IF  ( _b_err <> e_ok )
                        THEN
                            a07_b_put_error (acv, _b_err, 1)
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    act_res_tree := _gg_strategy_ptr^.str_result_id;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak505vcalculate_param_expression  (
            VAR acv           : tak_all_command_glob;
            VAR mblock        : tgg00_MessBlock;
            index             : integer);
 
VAR
      _cal_begin  : tsp00_Int2;
      _cal_end    : tsp00_Int2;
      _restore_st : tgg00_StackEntry;
      _s_qpos     : tsp00_Int2;
      _s_qcnt     : tsp00_Int2;
      _msglist    : tak104_MsgList;
 
BEGIN
_cal_begin  := index + 1;
_cal_end    := index + ord(mblock.mb_st^[ index ].ecol_tab [ 2 ]) + 1;
&ifdef trace
t01int4 (ak_sem, 'cal_begin   ',_cal_begin);
t01int4 (ak_sem, 'cal_end     ',_cal_end);
&endif
_restore_st := mblock.mb_st^[ _cal_end ];
_s_qpos := mblock.mb_qual^.mqual_pos;
_s_qcnt := mblock.mb_qual^.mqual_cnt;
mblock.mb_qual^.mqual_pos  := _cal_begin;
mblock.mb_qual^.mqual_cnt  := _cal_end - _cal_begin + 1;
mblock.mb_st^[ _cal_end ].etype         := st_output;
mblock.mb_st^[ _cal_end ].eop_out       := op_o_output_not_fill;
mblock.mb_st^[ _cal_end ].epos          := cgg_ex_result_valuefieldlist;
mblock.mb_st^[ _cal_end ].elen_var      := cak_maxfieldlength+1;
mblock.mb_st^[ _cal_end ].ecol_tab[ 1 ] := chr(0);
mblock.mb_st^[ _cal_end ].ecol_tab[ 2 ] := chr(1);
mblock.mb_st^[ index ].ecol_tab[ 2 ] := chr(0);
mblock.mb_work_st        := acv.a_work_st_addr;
mblock.mb_work_st_max    := acv.a_work_st_max;
mblock.mb_workbuf        := acv.a_work_buf_addr;
mblock.mb_workbuf_size   := acv.a_work_buf_size;
IF  mblock.mb_fieldlists[cgg_idx_ex_result_valuefieldlist] = NIL
THEN
    BEGIN
    _msglist := NIL;
    IF  NOT ak104_CreateIncrementalMemorySequence ( acv.a_transinf.tri_trans.trAllocator_gg00,
        sessionCount_eak104, mblock.mb_fieldlists[cgg_idx_ex_result_valuefieldlist], _msglist)
    THEN
        a07_b_put_error (acv, e_no_more_memory, 1);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    a05varqualification_test (acv, mblock,
          c_result_wanted, c_check_new_rec, 1,
          cgg_idx_ex_result_valuefieldlist, mblock.mb_st^ [index].elen_var);
    mblock.mb_st^ [index].epos := cgg_ex_result_valuefieldlist;
    (* do not truncate values!                               *)
    (* at least for literal/pars_results and correlation     *)
    (* this causes 'ff' for non-first-usage of 'trunc' value *)
    IF  acv.a_returncode <> 0
    THEN
        acv.a_transinf.tri_trans.trState_gg00 := mblock.mb_trns^.trState_gg00;
    (*ENDIF*) 
    END;
(*ENDIF*) 
mblock.mb_qual^.mqual_pos  := _s_qpos;
mblock.mb_qual^.mqual_cnt  := _s_qcnt;
mblock.mb_st^[ _cal_end ] := _restore_st;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak505calculate_param_expression  (
            VAR acv           : tak_all_command_glob;
            VAR mblock        : tgg00_MessBlock;
            VAR result_buf    : tsp00_Buf;
            VAR len           : integer;
            index             : integer;
            VAR enough_place  : boolean);
 
VAR
      _i          : integer;
      _cal_begin  : tsp00_Int2;
      _cal_end    : tsp00_Int2;
      _param_pos  : tsp00_Int2;
      _part2_free : tsp00_Int2;
      _restore_st : tgg00_StackEntry;
      _s_qpos     : tsp00_Int2;
      _s_qcnt     : tsp00_Int2;
 
BEGIN
_cal_begin  := index + 1;
_cal_end    := index + ord(mblock.mb_st^[ index ].ecol_tab [ 2 ]) + 1;
&ifdef trace
t01int4 (ak_sem, 'cal_begin   ',_cal_begin);
t01int4 (ak_sem, 'cal_end     ',_cal_end);
&endif
(* PTS 1123051 E.Z. *)
_part2_free := 0;
_i := succ(index);
_param_pos := mblock.mb_st^[ index ].epos;
WHILE ( _i < _cal_end) AND
      ( mblock.mb_st^[ _i ].etype = st_value) AND
      ( mblock.mb_st^[ _i ].epos <> _param_pos) DO
    _i := succ(_i);
(*ENDWHILE*) 
WHILE _i < _cal_end  DO
    BEGIN
    IF  mblock.mb_st^[ _i ].etype = st_value
    THEN
        _part2_free := _part2_free + mblock.mb_st^[ _i ].elen_var
    ELSE
        IF  mblock.mb_st^[ _i ].etype = st_subquery
        THEN
            _part2_free := _part2_free + FILE_ID_MXGG00;
        (*ENDIF*) 
    (*ENDIF*) 
    _i := succ(_i);
    END;
(*ENDWHILE*) 
_restore_st := mblock.mb_st^[ _cal_end ];
_s_qpos := mblock.mb_qual^.mqual_pos;
_s_qcnt := mblock.mb_qual^.mqual_cnt;
mblock.mb_qual^.mqual_pos  := _cal_begin;
mblock.mb_qual^.mqual_cnt  := _cal_end - _cal_begin + 1;
mblock.mb_st^[ _cal_end ].etype         := st_output;
mblock.mb_st^[ _cal_end ].eop_out       := op_o_output_not_fill;
mblock.mb_st^[ _cal_end ].epos          := 1;
mblock.mb_st^[ _cal_end ].elen_var      := cak_maxfieldlength+1;
mblock.mb_st^[ _cal_end ].ecol_tab[ 1 ] := chr(0);
mblock.mb_st^[ _cal_end ].ecol_tab[ 2 ] := chr(1);
mblock.mb_st^[ index ].ecol_tab[ 2 ] := chr(0);
mblock.mb_work_st        := acv.a_work_st_addr;
mblock.mb_work_st_max    := acv.a_work_st_max;
mblock.mb_workbuf        := acv.a_work_buf_addr;
mblock.mb_workbuf_size   := acv.a_work_buf_size;
a05qualification_test (acv, mblock,
      c_result_wanted, c_check_new_rec, 1,
      mblock.mb_data^.mbp_rec, result_buf, sizeof(result_buf), len);
IF  acv.a_returncode <> 0
THEN
    acv.a_transinf.tri_trans.trState_gg00 :=
          mblock.mb_trns^.trState_gg00;
(*ENDIF*) 
mblock.mb_qual^.mqual_pos  := _s_qpos;
mblock.mb_qual^.mqual_cnt  := _s_qcnt;
(* PTS 1123051 E.Z. *)
&ifdef trace
t01int4 (ak_sem,'result len  ',len);
t01int4 (ak_sem,'free part2  ', _part2_free);
&endif
mblock.mb_st^[ _cal_end ] := _restore_st;
enough_place      := len <= _part2_free;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak505st_code_jump (
            VAR mblock    : tgg00_MessBlock;
            index         : tsp00_Int2;
            count         : tsp00_Int2);
 
VAR
      _i : integer;
 
BEGIN
&ifdef trace
t01int4 ( ak_sem, 'index       ',index);
t01int4 ( ak_sem, 'count       ',count);
&endif
mblock.mb_st^[ index ].etype         := st_jump_absolute;
mblock.mb_st^[ index ].eop           := op_none;
mblock.mb_st^[ index ].epos          := count ;
mblock.mb_st^[ index ].elen_var      := 0;
mblock.mb_st^[ index ].ecol_tab[ 1 ] := chr(0);
mblock.mb_st^[ index ].ecol_tab[ 2 ] := chr(0);
&ifdef trace
FOR _i := 1 TO count DO
    WITH mblock.mb_st^[ index + _i ] DO
        BEGIN
        etype := st_not_needed;
        eop   := op_none;
        END;
    (*ENDWITH*) 
(*ENDFOR*) 
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak505st_code_rollback_for_const_expr (
            VAR acv       : tak_all_command_glob;
            VAR mblock    : tgg00_MessBlock;
            index         : tsp00_Int2;
            expr_cnt      : tsp00_Int2;
            operator      : tgg00_StackOpType);
 
VAR
      _cal_begin   : tsp00_Int2;
      _cal_end     : tsp00_Int2;
 
BEGIN
_cal_begin  := index + 1;
_cal_end    := index + expr_cnt + 1;
SAPDB_PascalOverlappingMove ('VAK505',  15,    
      mblock.mb_st_size, mblock.mb_st_size,
      @mblock.mb_st^, STACK_ENTRY_MXGG00 * index + 1,
      @mblock.mb_st^, STACK_ENTRY_MXGG00 * (index - 1) + 1,
      STACK_ENTRY_MXGG00 * ( _cal_end - _cal_begin),
      acv.a_returncode);
(* PTS 1123051 E.Z. *)
IF  operator = op_none
THEN
    mblock.mb_st^[ _cal_end - 1].etype    := st_dummy
ELSE
    mblock.mb_st^[ _cal_end - 1].etype    := st_op;
(*ENDIF*) 
mblock.mb_st^[ _cal_end - 1].eop      := operator;
mblock.mb_st^[ _cal_end - 1].epos     := 0;
mblock.mb_st^[ _cal_end - 1].elen_var := 0;
mblock.mb_st^[ _cal_end - 1].ecol_tab[ 1 ] := chr(0);
mblock.mb_st^[ _cal_end - 1].ecol_tab[ 2 ] := chr(0);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak505make_st_entry (
            VAR mblock   : tgg00_MessBlock;
            index        : tsp00_Int2;
            e_type       : tgg00_StackEntryType;
            e_op         : tgg00_StackOpType;
            pos          : tsp00_Int2;
            len          : tsp00_Int2;
            tab1         : char;
            tab2         : char);
 
BEGIN
mblock.mb_st^[ index ].etype    := e_type;
mblock.mb_st^[ index ].eop      := e_op;
mblock.mb_st^[ index ].epos     := pos;
mblock.mb_st^[ index ].elen_var := len;
mblock.mb_st^[ index ].ecol_tab[ 1 ] := tab1;
mblock.mb_st^[ index ].ecol_tab[ 2 ] := tab2;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak505compare_output_expr (
            VAR acv      : tak_all_command_glob;
            VAR dmli     : tak_dml_info;
            VAR mblock   : tgg00_MessBlock;
            VAR index    : tsp00_Int2);
 
VAR
      _len          : integer;
      _expr_cnt     : tsp00_Int2;
      _enough_place : boolean;
      _result_buf   : tsp00_Buf;
      _operator     : tgg00_StackOpType;
 
BEGIN
_operator := mblock.mb_st^[ index ].eop;
_expr_cnt := ord(mblock.mb_st^[ index ].ecol_tab[ 2 ]);
IF  acv.a_variable_input
THEN
    BEGIN
    ak505vcalculate_param_expression ( acv, mblock, index);
    ak505make_st_entry (mblock, index, st_value, _operator,
          mblock.mb_st^[ index ].epos, mblock.mb_st^[ index ].elen_var, chr(0), chr(0));
    ak505st_code_jump (mblock, index + 1, _expr_cnt - 1);
    END
ELSE
    BEGIN
    ak505calculate_param_expression ( acv, mblock,
          _result_buf, _len, index, _enough_place);
    IF  _enough_place
    THEN
        BEGIN
        SAPDB_PascalMove ('VAK505',  16,    
              sizeof(_result_buf), mblock.mb_data_size,
              @_result_buf, 1,
              @mblock.mb_data^.mbp_buf, mblock.mb_st^[ index ].epos,
              _len, acv.a_returncode);
        ak505make_st_entry (mblock, index, st_value,
              _operator, mblock.mb_st^[ index ].epos, _len, chr(0), chr(0));
        ak505st_code_jump (mblock, index + 1, _expr_cnt - 1);
        END
    ELSE
        BEGIN
        ak505st_code_rollback_for_const_expr (acv, mblock,
              index, _expr_cnt, _operator);
        dmli.d_only_table_scan := true;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
index := index + ord(mblock.mb_st^[ index ].ecol_tab[ 2 ]) - 1;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak505between_expr (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info;
            VAR mblock : tgg00_MessBlock;
            VAR index  : tsp00_Int2);
 
VAR
      _enough_place : boolean;
      _i,_j          : integer;
      _len          : integer;
      _expr_cnt     : ARRAY [ 1..2 ] OF tsp00_Int2;
      _st_end       : tsp00_Int2;
      _end_jump     : tsp00_Int2;
      _roll_cnt     : tsp00_Int2;
      _result_buf   : tsp00_Buf;
      _operator     : tgg00_StackOpType;
      _store_entry  : tgg00_StackEntry;
      _expression   : ARRAY [ 1..2 ] OF boolean;
      _st_rollback  : ARRAY [ 1..2 ] OF boolean;
      _st_index     : ARRAY [ 1..2 ] OF tsp00_Int2;
 
BEGIN
_st_end := index + ord(mblock.mb_st^[ index + 1 ].ecol_tab[ 2 ]) + 1;
_st_rollback [ 1 ] := false;
_st_rollback [ 2 ] := false;
_expression [ 1 ]  :=
      (mblock.mb_st^[ index ].ecol_tab[ 1 ] = cgg04_param_in_between_expr);
_expression [ 2 ]  :=
      (mblock.mb_st^[ index + 1 ].ecol_tab[ 1 ] = cgg04_param_in_between_expr);
_end_jump          := ord( mblock.mb_st^[ index + 1 ].ecol_tab[ 2 ]);
IF  _expression [ 1 ]
THEN
    BEGIN
    _st_index [ 1 ] := index + 2;
    _st_index [ 2 ] := index + 3 + ord(mblock.mb_st^[ index + 2 ].ecol_tab[ 2 ]);
    END
ELSE
    BEGIN
    _st_index [ 1 ] := 0;
    _st_index [ 2 ] := index + 2;
    END;
(*ENDIF*) 
_expr_cnt[ 1 ] := ord( mblock.mb_st^[ _st_index [ 1 ] ].ecol_tab[ 2 ]);
_expr_cnt[ 2 ] := ord( mblock.mb_st^[ _st_index [ 2 ] ].ecol_tab[ 2 ]);
&ifdef trace
t01int4(ak_sem,'st_index[1] ',_st_index[1]);
t01int4(ak_sem,'st_index[2] ',_st_index[2]);
t01int4(ak_sem,'index       ',index);
&endif
_operator := op_none;
FOR _i := 1 TO 2 DO
    BEGIN
    IF  _expression [ _i ]
    THEN
        BEGIN
        IF  ( _expr_cnt [ _i ] <> 0 )
        THEN
            BEGIN
            IF  acv.a_variable_input
            THEN
                BEGIN
                ak505vcalculate_param_expression ( acv, mblock, _st_index [ _i ]);
                _len := mblock.mb_st^[_st_index [ _i ] ].elen_var;
                END
            ELSE
                BEGIN
                ak505calculate_param_expression ( acv, mblock, _result_buf,
                      _len, _st_index [ _i ], _enough_place);
                IF  _enough_place
                THEN
                    SAPDB_PascalMove ('VAK505',  17,    
                          sizeof(_result_buf), mblock.mb_data_size,
                          @_result_buf, 1,
                          @mblock.mb_data^.mbp_buf, mblock.mb_st^[ _st_index [ _i ] ].epos,
                          _len, acv.a_returncode)
                ELSE
                    _st_rollback[ _i ] := true;
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        ELSE
            _len := mblock.mb_st^[_st_index [ _i ] ].elen_var;
        (*ENDIF*) 
        IF  NOT _st_rollback[ _i ]
        THEN
            BEGIN
            ak505make_st_entry (mblock, index + _i - 1, st_value,
                  _operator, mblock.mb_st^[_st_index [ _i ] ].epos, _len,
                  chr(0) ,chr(0));
            ak505st_code_jump (mblock, _st_index [ _i ],
                  _expr_cnt [ _i ]);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    _operator := mblock.mb_st^[ index + 1 ].eop;
    END;
(*ENDFOR*) 
IF  NOT _st_rollback [ 1 ] AND NOT _st_rollback [ 2 ]
THEN
    index := index + 2;
(*ENDIF*) 
_roll_cnt    := 0;
_store_entry := mblock.mb_st^[ index + 1 ];
IF  _st_rollback [ 1 ]
THEN
    BEGIN
    _roll_cnt := succ(_roll_cnt);
    SAPDB_PascalOverlappingMove ('VAK505',  18,    
          mblock.mb_st_size, mblock.mb_st_size,
          @mblock.mb_st^, STACK_ENTRY_MXGG00 * (_st_index [ 1 ] ) + 1,
          @mblock.mb_st^, STACK_ENTRY_MXGG00 * (index - 1) + 1,
          STACK_ENTRY_MXGG00 *  _expr_cnt[ 1 ],
          acv.a_returncode);
    index := index + _expr_cnt[ 1 ];
    _end_jump := _end_jump - _expr_cnt[ 1 ] + 1;
    mblock.mb_st^[ index ] := _store_entry;
    mblock.mb_st^[ index ].ecol_tab[ 2 ] := chr(_end_jump);
    IF  NOT _st_rollback [ 2 ]
    THEN
        ak505st_code_jump (mblock, index + 1, _expr_cnt[ 2 ] + 2 );
    (*ENDIF*) 
    END
ELSE
    index := succ(index);
(*ENDIF*) 
IF  _st_rollback [ 2 ]
THEN
    BEGIN
    _roll_cnt := succ(_roll_cnt);
&   ifdef trace
    t01int4 (ak_sem, 'st_index[2] ',_st_index[ 2 ]);
    t01int4 (ak_sem, 'index       ',index);
    t01int4 (ak_sem, 'expr_cnt[2] ',_expr_cnt[ 2 ]);
&   endif
&   ifdef trace
    FOR _j := 1 TO mblock.mb_qual^.mfirst_free DO
        t01stackentry(ak_sem, mblock.mb_st^[ _j ], _j);
    (*ENDFOR*) 
&   endif
    SAPDB_PascalOverlappingMove ('VAK505',  19,    
          mblock.mb_st_size, mblock.mb_st_size,
          @mblock.mb_st^, STACK_ENTRY_MXGG00 * (_st_index [ 2 ] ) + 1,
          @mblock.mb_st^, STACK_ENTRY_MXGG00 * (index - 1) + 1,
          STACK_ENTRY_MXGG00 *  _expr_cnt[ 2 ],
          acv.a_returncode);
    index := index + _expr_cnt[ 2 ];
    _end_jump := _end_jump - _expr_cnt[ 2 ] + 1;
    ak505make_st_entry (mblock, index, st_op, _store_entry.eop,
          0, 0, chr(0), chr(_end_jump));
    IF  NOT _st_rollback [ 1 ]
    THEN
        ak505st_code_jump (mblock, index + 1, _expr_cnt[ 1 ] + 1)
    ELSE
        ak505st_code_jump (mblock, index + 1, 3);
    (*ENDIF*) 
&   ifdef trace
    FOR _j := 1 TO mblock.mb_qual^.mfirst_free DO
        t01stackentry(ak_sem, mblock.mb_st^[ _j ], _j);
    (*ENDFOR*) 
&   endif
    END;
(*ENDIF*) 
dmli.d_only_table_scan := _st_rollback[ 1 ] OR _st_rollback [ 2 ];
index := _st_end;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak505in_expr (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info;
            VAR mblock : tgg00_MessBlock;
            VAR index  : tsp00_Int2);
 
VAR
      _enough_place   : boolean;
      _st_rollback    : boolean;
      _real_entry_ptr : tsp00_Int2;
      _st_move_offset : tsp00_Int2;
      _st_begin       : tsp00_Int2;
      _st_end         : tsp00_Int2;
      _expr_cnt       : tsp00_Int2;
      _len            : integer;
      _result_buf     : tsp00_Buf;
      _stack_list     : tgg00_StackListPtr;
 
BEGIN
_st_begin    := index;
_st_rollback := false;
WHILE (mblock.mb_st^[ index ].etype <> st_op) AND
      (mblock.mb_st^[ index ].eop   <> op_in) DO
    BEGIN
    IF  (mblock.mb_st^[ index ].etype = st_value) AND
        (mblock.mb_st^[ index ].ecol_tab[ 1 ] = cgg04_param_in_in_expr)
    THEN
        BEGIN
        _real_entry_ptr := index + ord(mblock.mb_st^[ index ].ecol_tab[ 2 ]);
        _expr_cnt       := ord(mblock.mb_st^[ _real_entry_ptr ].ecol_tab[ 2 ]);
        IF  acv.a_variable_input
        THEN
            BEGIN
            ak505vcalculate_param_expression ( acv, mblock, _real_entry_ptr);
            ak505make_st_entry (mblock, index, st_value, op_none,
                  mblock.mb_st^[ _real_entry_ptr ].epos, mblock.mb_st^[ _real_entry_ptr ].elen_var,
                  chr(0), chr(0));
            ak505st_code_jump (mblock, _real_entry_ptr, _expr_cnt);
            END
        ELSE
            BEGIN
            ak505calculate_param_expression ( acv, mblock, _result_buf,
                  _len, _real_entry_ptr, _enough_place);
            IF  _enough_place
            THEN
                BEGIN
                SAPDB_PascalMove ('VAK505',  20,    
                      sizeof(_result_buf), mblock.mb_data_size,
                      @_result_buf, 1,
                      @mblock.mb_data^.mbp_buf, mblock.mb_st^[ _real_entry_ptr ].epos,
                      _len, acv.a_returncode);
                ak505make_st_entry (mblock, index, st_value,
                      op_none, mblock.mb_st^[_real_entry_ptr ].epos, _len,
                      chr(0) ,chr(0));
                ak505st_code_jump (mblock, _real_entry_ptr,
                      _expr_cnt);
                END
            ELSE
                BEGIN
                _st_rollback := true;
                mblock.mb_st^[ _real_entry_ptr ].ecol_tab[ 2 ] := chr (_expr_cnt);
                END;
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    index := succ(index);
    END;
(*ENDWHILE*) 
_st_end := index + ord( mblock.mb_st^[ index ].ecol_tab[ 2 ]) - 1;
IF  _st_rollback
THEN
    BEGIN
    index  := _st_begin;
    _st_move_offset := 0;
    WHILE (mblock.mb_st^[ index ].etype <> st_op) AND
          (mblock.mb_st^[ index ].eop   <> op_in) DO
        (*       and (index < mfirst_free) DO*)
        BEGIN
        IF  (mblock.mb_st^[ index ].etype = st_value) AND
            (mblock.mb_st^[ index ].ecol_tab[ 1 ] = cgg04_param_in_in_expr)
        THEN
            BEGIN
            _real_entry_ptr := index + ord(mblock.mb_st^[ index ].ecol_tab[ 2 ]) -
                  _st_move_offset;
            _expr_cnt       := ord(mblock.mb_st^[ _real_entry_ptr ].ecol_tab[ 2 ]);
            _st_move_offset := _st_move_offset + _expr_cnt - 1;
&           ifdef trace
            t01int4 ( ak_sem, 'st_rollback ',4711);
            t01int4 ( ak_sem, 'real_entry_p',_real_entry_ptr);
            t01int4 ( ak_sem, 'expr_cnt    ',_expr_cnt);
            t01int4 ( ak_sem, 'index       ',index);
&           endif
            a10new (acv, _expr_cnt * STACK_ENTRY_MXGG00, _stack_list);
            IF  _stack_list = NIL
            THEN
                a07_b_put_error (acv, e_no_more_memory, 1)
            ELSE
                BEGIN
                SAPDB_PascalMove ('VAK505',  21,    
                      mblock.mb_st_size, _expr_cnt*STACK_ENTRY_MXGG00,
                      @mblock.mb_st^, _real_entry_ptr * STACK_ENTRY_MXGG00 + 1,
                      @_stack_list^, 1, _expr_cnt * STACK_ENTRY_MXGG00,
                      acv.a_returncode);
                SAPDB_PascalOverlappingMove ('VAK505',  22,    
                      mblock.mb_st_size, mblock.mb_st_size,
                      @mblock.mb_st^, (index ) * STACK_ENTRY_MXGG00 + 1,
                      @mblock.mb_st^, (index  + _expr_cnt - 1 ) * STACK_ENTRY_MXGG00 + 1,
                      (_real_entry_ptr  - index - 1) * STACK_ENTRY_MXGG00,
                      acv.a_returncode);
                SAPDB_PascalMove ('VAK505',  23,    
                      _expr_cnt*STACK_ENTRY_MXGG00, mblock.mb_st_size,
                      @_stack_list^, 1,
                      @mblock.mb_st^, (index - 1) * STACK_ENTRY_MXGG00 + 1,
                      _expr_cnt * STACK_ENTRY_MXGG00,
                      acv.a_returncode);
                ak505st_code_jump (mblock,
                      _real_entry_ptr + _expr_cnt - 1, 1);
                a10dispose (acv, _stack_list);
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        index := succ(index);
        END;
    (*ENDWHILE*) 
    mblock.mb_st^[ index ].ecol_tab[ 2 ] :=
          chr(ord(mblock.mb_st^[ index ].ecol_tab[ 2 ]) -
          _st_move_offset - 1);
    END;
(*ENDIF*) 
index := _st_end;
dmli.d_only_table_scan := _st_rollback;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a505const_param_expression  (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info;
            VAR mblock : tgg00_MessBlock);
 
VAR
      _start             : tsp00_Int2;
      _last              : tsp00_Int2;
      _pos               : tsp00_Int2;
      _last_pos          : tsp00_Int2;
      _opt_ptr             : tsp00_MoveObjPtr;
      _m_opt_pos           : integer;
 
BEGIN
_opt_ptr := NIL;
IF  ( mblock.mb_qual^.mqual_pos < mblock.mb_qual^.mresqual_pos )
THEN
    BEGIN
    _start := mblock.mb_qual^.mqual_pos;
    _last  := mblock.mb_qual^.mqual_pos + mblock.mb_qual^.mqual_cnt - 1;
    _last_pos := mblock.mb_qual^.mresqual_pos;
    END
ELSE
    BEGIN
    _start := mblock.mb_qual^.mresqual_pos;
    _last  := mblock.mb_qual^.mresqual_pos + mblock.mb_qual^.mresqual_cnt - 1;
    _last_pos := mblock.mb_qual^.mqual_pos;
    END;
(*ENDIF*) 
IF  ( mblock.mb_qual^.mst_optimize_pos > 0 )
THEN
    _opt_ptr := @mblock.mb_data^.mbp_buf[mblock.mb_qual^.mst_optimize_pos];
(*ENDIF*) 
REPEAT
    _pos := _start;
    WHILE ( _pos <= _last ) DO
        BEGIN
        _m_opt_pos := 0;   (* h.b. PTS 1001399 *)
        IF  (mblock.mb_st^[ _pos ].etype = st_value) AND
            ((mblock.mb_st^[ _pos ].ecol_tab[ 1 ] in
            [ cgg04_param_in_between_expr, cgg04_param_in_in_expr]) OR
            ((mblock.mb_st^[ _pos ].ecol_tab[ 1 ] = chr(0)) AND
            (mblock.mb_st^[ _pos ].ecol_tab[ 2 ] <> chr(0))))
        THEN
            BEGIN
            IF  mblock.mb_qual^.mst_optimize_pos > 0 (* h.b. PTS 1001399 *)
            THEN (* invalidate optimize info *)
                BEGIN
                (* h.b. PTS 1001399 *)
                _m_opt_pos        := mblock.mb_qual^.mst_optimize_pos;
                mblock.mb_qual^.mst_optimize_pos := 0;
                (* PTS 1106590 E.Z. *)
                IF  ord(mblock.mb_st^[ _pos ].eop) =
                    ord(_opt_ptr^[_pos - mblock.mb_qual^.mqual_pos + 1])
                THEN
                    _opt_ptr^[_pos - mblock.mb_qual^.mqual_pos ] := chr(0);
                (*ENDIF*) 
                _opt_ptr^[_pos - mblock.mb_qual^.mqual_pos + 1] := chr(0);
                END;
            (*ENDIF*) 
            CASE mblock.mb_st^[ _pos ].ecol_tab [ 1 ] OF
                chr(0) :
                    ak505compare_output_expr ( acv, dmli, mblock, _pos);
                cgg04_param_in_between_expr :
                    BEGIN
                    IF  mblock.mb_st^[ _pos ].eop in
                        [ op_between, op_not_between ]
                    THEN
                        _pos := pred(_pos);
                    (*ENDIF*) 
                    ak505between_expr ( acv, dmli, mblock, _pos);
                    END;
                cgg04_param_in_in_expr :
                    ak505in_expr ( acv, dmli, mblock, _pos);
                OTHERWISE
                    mblock.mb_trns^.trError_gg00 := e_stack_type_illegal;
                END;
            (*ENDCASE*) 
            END;
        (*ENDIF*) 
        IF  ( _m_opt_pos > 0 ) (* h.b. PTS 1001399 *)
        THEN
            BEGIN
            mblock.mb_qual^.mst_optimize_pos := _m_opt_pos;
            _m_opt_pos        := 0;
            END;
        (*ENDIF*) 
        _pos := succ(_pos);
        END;
    (*ENDWHILE*) 
    IF  ( mblock.mb_trns^.trError_gg00 = e_ok )
    THEN
        BEGIN
        _pos := _start;
        WHILE ( _pos <= _last ) DO
            BEGIN
            IF  ( mblock.mb_st^[ _pos ].etype = st_jump_absolute ) AND
                ( mblock.mb_st^[ _pos +
                mblock.mb_st^[ _pos ].epos + 1 ].etype = st_jump_absolute )
            THEN
                BEGIN
&               ifdef trace
                WITH mblock.mb_st^[ _pos + mblock.mb_st^[ _pos ].epos + 1 ] DO
                    BEGIN
                    etype := st_not_needed;
                    eop   := op_none;
                    END;
                (*ENDWITH*) 
&               endif
                mblock.mb_st^[ _pos ].epos := mblock.mb_st^[ _pos ].epos +
                      mblock.mb_st^[ _pos + mblock.mb_st^[ _pos ].epos + 1 ].epos + 1;
                _pos := pred(_pos);
                END;
            (*ENDIF*) 
            _pos := succ(_pos);
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    ;
    (* now loop over next qualification part *)
    IF  ( mblock.mb_qual^.mqual_pos < mblock.mb_qual^.mresqual_pos )
    THEN
        BEGIN
        _start := mblock.mb_qual^.mresqual_pos;
        _last  := mblock.mb_qual^.mresqual_pos + mblock.mb_qual^.mresqual_cnt - 1;
        END
    ELSE
        BEGIN
        _start := mblock.mb_qual^.mqual_pos;
        _last  := mblock.mb_qual^.mqual_pos + mblock.mb_qual^.mqual_cnt - 1;
        END;
    (*ENDIF*) 
UNTIL
    ( _pos > _last_pos ) OR ( _start = 0 );
(*ENDREPEAT*) 
mblock.mb_qual^.mstack_state :=
      mblock.mb_qual^.mstack_state - [ ssConstParamExpr_egg00 ];
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak505dist_lock_mess_bufs (
            VAR acv       : tak_all_command_glob;
            return_result : boolean);
 
VAR
      i         : integer;
      isparr    : tak_syspointerarr;
      back_lock : tak_ak_all_locks;
 
BEGIN
WITH acv.a_mblock.mb_qual^ DO
    BEGIN
    back_lock.all_lock_count := mlock_cnt;
    FOR i := 1 TO mlock_cnt DO
        back_lock.all_locks[ i ] := mlock[ i ]
    (*ENDFOR*) 
    END;
(*ENDWITH*) 
a52_rest_lock_statement (acv, isparr, back_lock, return_result,
      NOT c_complicate)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak505exec_link (
            VAR acv        : tak_all_command_glob;
            VAR syskey     : tgg00_SysInfoKey;
            VAR mblock_buf : tak_sysbufferaddress;
            pars_id        : tsp00_Int2);
 
VAR
      b_err         : tgg00_BasisError;
      cascade       : boolean;
      init_ex_kind  : tak_execution_kind;
      lo_level      : tsp00_Int2;
      use_file_id   : tsp00_Int2;
      self_ref_info : tak_selfref_link_info;
 
BEGIN
use_file_id := 0;
WHILE (pars_id <> 0) AND (acv.a_returncode = 0) DO
    BEGIN
    syskey.sintlinkage := pars_id;
    a10get_sysinfo (acv, syskey, d_fix, mblock_buf, b_err);
    IF  b_err = e_ok
    THEN
        WITH mblock_buf^.smessblock.mbr_mess_block,
             mb_qual^.mlc_info DO
            BEGIN
            (*===========================================*)
            (* get parsid of next parsinfo on same level *)
            (* of the tree                               *)
            (*===========================================*)
            pars_id  := mlp_sa_level;
            lo_level := mlp_lo_level;
&           IFDEF TRACE
            t01int4 (ak_sem,'sa_level =  ', pars_id);
&           ENDIF
            (*=========================================*)
            (* get fileid of the temporary file, where *)
            (* the parameters of the command to be     *)
            (* executed are in                         *)
            (*===============================================*)
            use_file_id := mlp_use_fileid;
&           IFDEF TRACE
            t01int4 (ak_sem,'use_fide_id ', use_file_id);
&           ENDIF
            IF  mb_type = m_verify
            THEN
                (*===============================================*)
                (* With self-references and delete there is no   *)
                (* separated parsing and executing during next   *)
                (* commands                                      *)
                (*===============================================*)
                WITH acv, self_ref_info DO
                    BEGIN
                    a_mblock.mb_qual^.mtree := mb_qual^.mtree;
                    init_ex_kind              := a_ex_kind;
                    a_ex_kind                 := only_executing;
                    a_pars_last_key.p_id[1] :=
                          chr(ord(a_pars_last_key.p_id[1])+1);
                    SAPDB_PascalMove ('VAK505',  24,    
                          mb_qual_size, sizeof(self_ref_info),
                          @mb_qual^.buf, FILE_ID_MXGG00 + 1,
                          @self_ref_info, 1, sizeof(self_ref_info),
                          a_returncode);
                    use_file_id := sf_use_id;
                    a58delete_with_link (acv,
                          a_mblock.mb_qual^.mtree.fileTabId_gg00,
                          sf_index, sf_parsno, sf_use_id);
                    a_ex_kind := init_ex_kind;
                    cascade   := false
                    END
                (*ENDWITH*) 
            ELSE
                BEGIN
                a58exec_link_caused_dml (acv, mblock_buf,
                      use_file_id, cascade, NOT c_act_rescnt)
                END;
            (*ENDIF*) 
            IF  cascade
            THEN
                BEGIN
                (*=============================================*)
                (* get parsid of next parsinfo of lower level  *)
                (* of the tree. IF it is <> 0 then this is the *)
                (* next command to be executed                 *)
                (*=============================================*)
&               IFDEF TRACE
                t01int4 (ak_sem,'lo_level =  ', lo_level);
&               ENDIF
                IF  lo_level <> 0
                THEN
                    ak505exec_link (acv, syskey,  mblock_buf, lo_level);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    ELSE
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
a58destroy_linkfile (acv, use_file_id);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak505join_view_check (
            VAR acv          : tak_all_command_glob;
            VAR act_res_tree : tgg00_FileId;
            VAR jvrec        : tak68_joinview_rec;
            VAR series       : tak68_sequence;
            tabcnt           : integer);
 
VAR
      _dummy        : tak_parskey;
      _dmli         : tak_dml_info;
      _syskey       : tgg00_SysInfoKey;
      _catalog_ptr  : tak_sysbufferaddress;
      _b_err        : tgg00_BasisError;
 
BEGIN
act_res_tree := acv.a_into_tree;
a06a_mblock_init (acv, m_select, mm_with_join, b01niltree_id);
acv.a_mblock.mb_data_len := jvrec.jv_maxkeyl + cgg_rec_key_offset;
acv.a_mblock.mb_data^.mbp_keylen  := jvrec.jv_maxkeyl;
(*a54_base_dml_init (acv, dmli, NOT c_in_union);*)
a54_dml_init( acv, _dmli, NOT c_in_union );
;
_dmli.d_tabarr^[ 1 ].oview         := true;
_dmli.d_tabarr^[ 1 ].otreeid       := b01niltree_id;
_dmli.d_tabarr^[ 1 ].otreeid.fileTabId_gg00 := jvrec.jv_tabid;
_dmli.d_tabarr^[ 1 ].ofromtableid  := jvrec.jv_tabid;
_dmli.d_tabarr^[ 1 ].oall_priv     := true;
_dmli.d_cntfromtab  := tabcnt;
_dmli.d_acttabindex := 1;
_dmli.d_view      := true;
_dmli.d_single    := true;
_dmli.d_checkview := jvrec.jv_checkview;
;
a54_view_put_into (acv, _dmli);
;
(* join usually needs NULL-value for *)
(* its is-not-null qualifications    *)
acv.a_mblock.mb_data_len := succ (acv.a_mblock.mb_data_len );
acv.a_mblock.mb_data^.mbp_buf[ acv.a_mblock.mb_data_len ] := csp_undef_byte;
;
(* test for join implementation *)
_b_err := e_ok;
a682join_MBlock_key( acv, _dmli, _dummy, jvrec.jv_tabid, 1,
      _syskey, c_seqsearch_for_exec );
a10get_sysinfo( acv, _syskey, d_release, _catalog_ptr, _b_err );
IF  ( _b_err <> e_ok )
THEN
    a07ak_system_error( acv, 505, 2 )
ELSE
    BEGIN
&   ifdef trace
    t01mess2type( ak_sem, 'm2type MBLOC',
          _catalog_ptr^.smessblock.mbr_mess_block.mb_type2 );
&   endif
    IF  ( _catalog_ptr^.smessblock.mbr_mess_block.mb_type2 in
        [ mm_operator_join, mm_last_operator_join, mm_first_operator_join ])
    THEN
        BEGIN
        a682_execute_join_operator (acv,
              _dmli, series, act_res_tree, _dummy, jvrec,
              NOT c_use_old_rescnt, c_seqsearch_for_exec);
        END
    ELSE
        BEGIN
        a682_execute_join (acv,
              _dmli, series, act_res_tree, _dummy, jvrec,
              NOT c_use_old_rescnt, c_seqsearch_for_exec);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
a54_dml_finalize( _dmli, acv.a_transinf.tri_trans );
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak505long_support (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            mtype    : tgg00_MessType;
            m2type   : tgg00_MessType2);
 
VAR
      UnFinishedLong    : boolean;
      only_move         : boolean;
      defbyte           : tsp00_C1;
      cnt               : integer;
      curr_longval      : integer;
      out_cnt           : integer;
      desc_len          : integer;
      next_long_val     : integer;
      value_cnt         : integer;
      long_desc_pos     : tsp00_Int4;
      offset            : tsp00_Int4;
      long_desc         : tak_long_descriptor;
      not_finished_long : tak_long_descriptor;
      value_ptr         : tsp00_MoveObjPtr;
      value_len         : tsp00_Int4;
      is_null           : boolean;
      is_default        : boolean;
      rk                : tgg00_Lkey;
      b                 : tgg00_Rec;
      tempFileId        : tgg00_FileId;
 
BEGIN
WITH acv, dmli, long_desc DO
    BEGIN
    (* seems to be wrong for updateable joinviews; up to now, *)
    (* no updateable joinviews with longsupport are allowed   *)
&   ifdef trace
    t01int4 (ak_sem, 'cmd_length  ', a_cmd_part^.sp1p_buf_len);
    t01int4 (ak_sem, 'data_length ', a_data_length);
    t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, 1, a_cmd_part^.sp1p_buf_len);
    IF  a_data_ptr <> NIL
    THEN
        t01moveobj (ak_sem, a_data_ptr^, 1, a_data_length);
&   endif
    (* PTS 1116801 E.Z. *)
    (*ENDIF*) 
    desc_len := mxsp_long_desc;
    UnFinishedLong := false;
    value_cnt := 0;
    curr_longval := 0;
    IF  (mtype = m_insert) AND (a_returncode = 0)
    THEN
        BEGIN
        next_long_val := d_first_longdesc_pos;
        long_desc_pos := d_first_longdesc_pos;
        cnt := 0;
        IF  acv.a_variable_input
        THEN
            value_cnt := a509value_cnt (a_input_data_map);
        (*ENDIF*) 
        WHILE (cnt <= dmli.d_cnt_longdesc - 1) AND
              (acv.a_returncode = 0) DO
            BEGIN
            value_len := 0;
            value_ptr := NIL;
            IF  acv.a_variable_input
            THEN
                BEGIN
                WHILE (next_long_val <= value_cnt) AND
                      NOT a509is_long_value (a_input_data_map, next_long_val) DO
                    next_long_val := succ(next_long_val);
                (*ENDWHILE*) 
                IF  NOT a509get_one_value (a_input_data_map, next_long_val,
                    value_ptr, value_len, is_null, is_default)
                THEN
                    a07ak_system_error (acv, 505, 3)
                ELSE
                    IF  (NOT is_null) AND (NOT is_default)
                    THEN
                        BEGIN
                        SAPDB_PascalMove ('VAK505',  25,    
                              a_data_length, sizeof(long_desc),
                              @value_ptr^, 1, @long_desc, 1, value_len,
                              a_returncode);
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                next_long_val := succ(next_long_val);
                END
            ELSE
                BEGIN
                is_null    :=  (acv.a_data_ptr^[long_desc_pos] = csp_undef_byte);
                is_default :=  (acv.a_data_ptr^[long_desc_pos] = csp_default_byte);
                IF  (NOT is_null) AND (NOT is_default)
                THEN
                    SAPDB_PascalMove ('VAK505',  26,    
                          a_data_length, sizeof(long_desc),
                          @a_data_ptr^, long_desc_pos + 1,
                          @long_desc, 1, desc_len,
                          a_returncode);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
&           ifdef trace
            IF  (NOT is_null) AND (NOT is_default)
            THEN
                t01longdescriptor (ak_sem, long_desc.desc);
&           endif
            (*ENDIF*) 
            IF  (NOT is_null) AND (NOT is_default)                                AND
                (long_desc.lds_valmode in [vm_alldata, vm_datapart, vm_lastdata]) AND
                UnFinishedLong
            THEN
                BEGIN
                a07_b_put_error (acv, e_st_invalid_longhandling, 1);
                cnt := dmli.d_cnt_longdesc; (* end loop *)
                END;
            (*ENDIF*) 
            IF  (acv.a_returncode = 0)
            THEN
                BEGIN
                IF  (NOT is_null) AND (NOT is_default)     AND
                    NOT (ld_stream in long_desc.lds_state)
                THEN
                    UnFinishedLong := UnFinishedLong OR (long_desc.lds_valmode in [vm_datapart, vm_nodata]);
                (* -UJ- short column entry removed *)
                (*ENDIF*) 
                IF  a_execute_trigger                                   OR
                    ((NOT is_null) AND (NOT is_default)            AND
                    NOT (ld_without_shortcol in long_desc.lds_infoset))
                THEN
                    BEGIN
                    IF  a_execute_trigger
                    THEN
                        long_desc.lds_infoset := long_desc.lds_infoset +
                              [ ld_ex_trigger ];
                    (*ENDIF*) 
                    IF  (NOT is_null) AND (NOT is_default)                 AND
                        NOT (ld_without_shortcol in long_desc.lds_infoset)
                    THEN
                        long_desc.lds_state := long_desc.lds_state + [ld_first_insert];
                    (*ENDIF*) 
                    IF  (NOT is_null) AND (NOT is_default)
                    THEN
                        IF  acv.a_variable_input
                        THEN
                            SAPDB_PascalMove ('VAK505',  27,    
                                  sizeof(long_desc), a_data_length,
                                  @long_desc, 1, @value_ptr^, 1, value_len,
                                  a_returncode)
                        ELSE
                            BEGIN
                            SAPDB_PascalMove ('VAK505',  28,    
                                  sizeof(long_desc), a_data_length,
                                  @long_desc, 1,
                                  @a_data_ptr^, long_desc_pos + 1, desc_len,
                                  a_returncode);
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                long_desc_pos := long_desc_pos + 1 + desc_len;
                END;
            (*ENDIF*) 
            cnt := succ(cnt);
            END;
        (*ENDWHILE*) 
        END
    ELSE
        IF  ((mtype = m_update) AND (a_returncode = 0))
        THEN
            BEGIN
            next_long_val := d_first_longdesc_pos;
            cnt := 0;
            IF  acv.a_variable_input
            THEN
                value_cnt := a509value_cnt (a_input_data_map);
            (*ENDIF*) 
            WHILE (cnt <= dmli.d_cnt_longdesc - 1) AND
                  (acv.a_returncode = 0) DO
                BEGIN
                value_len := 0;
                value_ptr := NIL;
                IF  acv.a_variable_input
                THEN
                    BEGIN
                    WHILE (next_long_val <= value_cnt) AND
                          NOT a509is_long_value (a_input_data_map, next_long_val) DO
                        next_long_val := succ(next_long_val);
                    (*ENDWHILE*) 
                    IF  NOT a509get_one_value (a_input_data_map, next_long_val,
                        value_ptr, value_len, is_null, is_default)
                    THEN
                        a07ak_system_error (acv, 505, 4)
                    ELSE
                        IF  (NOT is_null) AND (NOT is_default)
                        THEN
                            BEGIN
                            SAPDB_PascalMove ('VAK505',  29,    
                                  a_data_length, sizeof(long_desc),
                                  @value_ptr^, 1, @long_desc, 1, value_len,
                                  a_returncode);
                            curr_longval := long_desc.lds_colno;
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    next_long_val := succ(next_long_val);
                    END
                ELSE
                    BEGIN
                    is_null    :=  (acv.a_data_ptr^[dmli.d_first_longdesc_pos +
                          cnt * (mxsp_long_desc + 1)] = csp_undef_byte);
                    is_default :=  (acv.a_data_ptr^[dmli.d_first_longdesc_pos +
                          cnt * (mxsp_long_desc + 1)] = csp_default_byte);
                    curr_longval := succ(curr_longval);
                    IF  (NOT is_null) AND (NOT is_default)
                    THEN
                        SAPDB_PascalMove ('VAK505',  30,    
                              a_data_length, sizeof(long_desc),
                              @a_data_ptr^, d_first_longdesc_pos + 1 +
                              cnt * (desc_len + 1), @long_desc, 1, desc_len,
                              a_returncode);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
&               ifdef trace
                IF  (NOT is_null) AND (NOT is_default)
                THEN
                    t01longdescriptor (ak_sem, long_desc.desc);
&               endif
                (*ENDIF*) 
                IF  (NOT is_null) AND (NOT is_default)                                AND
                    (long_desc.lds_valmode in [vm_alldata, vm_datapart, vm_lastdata]) AND
                    UnFinishedLong
                THEN
                    BEGIN
                    a07_b_put_error (acv, e_st_invalid_longhandling, 1);
                    cnt := dmli.d_cnt_longdesc; (* end loop *)
                    END;
                (*ENDIF*) 
                IF  (acv.a_returncode = 0)
                THEN
                    BEGIN
                    IF  (NOT is_null) AND (NOT is_default)    AND
                        NOT (ld_stream in long_desc.lds_state)
                    THEN
                        UnFinishedLong := UnFinishedLong OR (long_desc.lds_valmode in [vm_datapart, vm_nodata]);
                    (* non longs updated OR no rows updated *)
                    (*ENDIF*) 
                    lds_descriptor := cgg_zero_id;
                    IF  ((a_mblock.mb_struct = mbs_result) AND (a_mblock.mb_qual^.mr_resnum > csp_rescnt_zero))
                    THEN
                        BEGIN
                        IF  (a_mblock.mb_qual_len = MB_PART1_HEAD_MXGG00+MB_PART1_RETURN_MXGG00) AND
                            ((m2type = mm_qual) OR (m2type = mm_empty) OR (m2type = mm_trunc) OR (m2type = mm_trigger))
                        THEN
                            BEGIN
                            rk.len := INT4_MXSP00;
                            s20int4_to_buf_swap (1, g01code.kernel_swap, rk.k, 1, sw_normal);
                            g04build_temp_tree_id (tempFileId, acv.a_transinf.tri_trans);
                            tempFileId.fileTfnTemp_gg00 := ttfnlongsurrogates_egg00;
                            a101_GetTempFileInstance (acv.a_transinf.tri_trans,
                                  tempFileId);
                            b07cget_record (acv.a_transinf.tri_trans, tempFileId, rk, b);
                            IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
                            THEN
                                BEGIN
                                SAPDB_PascalMove ('VAK505',  31,    
                                      sizeof(b), a_mblock.mb_qual_size,
                                      @b.buf, cgg_rec_key_offset + INT4_MXSP00 + 1,
                                      @a_mblock.mb_qual^.buf,
                                      MB_PART1_HEAD_MXGG00 + MB_PART1_RETURN_MXGG00 + 1,
                                      b.len - cgg_rec_key_offset - INT4_MXSP00, a_returncode);
                                a_mblock.mb_qual_len := MB_PART1_HEAD_MXGG00+MB_PART1_RETURN_MXGG00 +
                                      b.len - cgg_rec_key_offset - INT4_MXSP00;
                                END
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  (NOT is_null) AND (NOT is_default)
                        THEN
                            IF  (a_mblock.mb_qual_len > MB_PART1_HEAD_MXGG00+MB_PART1_RETURN_MXGG00)
                            THEN
                                BEGIN
                                SAPDB_PascalMove ('VAK505',  32,    
                                      a_mblock.mb_qual_size, sizeof(lds_descriptor),
                                      @a_mblock.mb_qual^.buf,
                                      MB_PART1_HEAD_MXGG00 + MB_PART1_RETURN_MXGG00 +
                                      (curr_longval-1) * (1 + sizeof(lds_descriptor)) + 2,
                                      @lds_descriptor, 1, sizeof(lds_descriptor),
                                      a_returncode);
                                IF  dmli.d_sparr.px[ 1 ]^.sparsinfo.p_mtyp2 = mm_expand
                                THEN
                                    lds_intern_pos := cgg_eo_bytestr
                                ELSE
                                    IF  (ld_without_shortcol in lds_infoset) AND
                                        (a_mblock.mb_qual^.buf
                                        [ MB_PART1_HEAD_MXGG00 + MB_PART1_RETURN_MXGG00 +
                                        (curr_longval-1) * (1 + sizeof(lds_descriptor)) + 1] = chr(true))
                                    THEN
                                        lds_intern_pos := -1
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                END
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  lds_descriptor = cgg_zero_id
                    THEN
                        BEGIN
                        (* PTS 1001500 E.Z. *)
                        IF  (a_return_segm^.sp1r_function_code > csp1_masscmd_fc_offset)
                            AND
                            (NOT is_null) AND (NOT is_default)
                        THEN
                            offset := a_data_part^.sp1p_buf_len - a_data_length
                        ELSE
                            offset := 0;
                        (*ENDIF*) 
                        IF  NOT acv.a_variable_input
                        THEN
                            BEGIN
                            IF  (NOT is_null) AND (NOT is_default) AND
                                (a_input_data_pos < lds_valpos - offset + lds_vallen)
                            THEN
                                a_input_data_pos := lds_valpos - offset + lds_vallen;
                            (*ENDIF*) 
                            a_data_ptr^[ d_first_longdesc_pos +
                                  cnt * (desc_len + 1) ] :=
                                  csp_undef_byte
                            END
                        ELSE
                            a509set_value_to_null (a_input_data_map, d_first_longdesc_pos+cnt);
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  NOT acv.a_variable_input
                        THEN
                            a_data_ptr^[ d_first_longdesc_pos +
                                  cnt * (desc_len + 1) ] :=
                                  csp_defined_byte;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  a_execute_trigger
                    THEN
                        lds_infoset := long_desc.lds_infoset + [ ld_ex_trigger ];
                    (*ENDIF*) 
                    IF  NOT acv.a_variable_input
                    THEN
                        SAPDB_PascalMove ('VAK505',  33,    
                              sizeof(long_desc), a_data_length,
                              @long_desc, 1,
                              @a_data_ptr^, d_first_longdesc_pos + 1 +
                              cnt * (desc_len + 1), desc_len,
                              a_returncode)
                    ELSE
                        IF  (NOT is_null) AND (NOT is_default)
                        THEN
                            SAPDB_PascalMove ('VAK505',  34,    
                                  sizeof(long_desc), a_data_length,
                                  @long_desc, 1, @value_ptr^, 1, value_len,
                                  a_returncode)
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                cnt := succ(cnt);
                END;
            (*ENDWHILE*) 
            END;
&       ifdef trace
        (*ENDIF*) 
    (*ENDIF*) 
    t01moveobj (ak_sem, a_data_ptr^, 1, a_data_length);
    t01int4 (ak_sem, 'd_cnt_longde', d_cnt_longdesc);
&   endif
    only_move   := false;
    out_cnt     := 0;
    cnt         := 0;
    next_long_val := d_first_longdesc_pos;
    WHILE ((a_returncode = 0) AND
          NOT only_move                         AND
          (cnt < d_cnt_longdesc)) DO
        BEGIN
&       ifdef TRACE
        t01int4 (ak_sem, 'aktuellescnt', cnt);
        t01int4 (ak_sem, 'first_longde', d_first_longdesc_pos);
        t01int4 (ak_sem, 'only_move   ', ord(only_move));
        IF  (a_curr_retpart <> NIL) AND
            (a_curr_retpart^.sp1p_buf_len > 0)
        THEN
            BEGIN
            t01int4 (ak_sem, 'ret_buf_len ', a_curr_retpart^.sp1p_buf_len);
            t01moveobj (ak_sem, a_curr_retpart^.sp1p_buf,
                  1, a_curr_retpart^.sp1p_buf_len);
            END;
&       endif
        (*ENDIF*) 
        IF  acv.a_variable_input
        THEN
            BEGIN
            WHILE (next_long_val <= value_cnt) AND
                  NOT a509is_long_value (a_input_data_map, next_long_val) DO
                next_long_val := succ(next_long_val);
            (*ENDWHILE*) 
            IF  NOT a509get_one_value (a_input_data_map, next_long_val,
                value_ptr, value_len, is_null, is_default)
            THEN
                a07ak_system_error (acv, 505, 5)
            ELSE
                IF  (NOT is_null) AND (NOT is_default)
                THEN
                    BEGIN
                    a_data_part^.sp1p_arg_count := 1;
                    a_in_internal_subtr := false;
                    not_finished_long.lds_descriptor := cgg_zero_id;
                    a507_putval (acv, next_long_val,
                          c_intern_call, (cnt = d_cnt_longdesc-1), not_finished_long.desc );
                    IF  not_finished_long.lds_descriptor <> cgg_zero_id
                    THEN
                        only_move := true
                    ELSE
                        a_in_internal_subtr := true
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            next_long_val := succ(next_long_val);
            END
        ELSE
            IF  (a_data_ptr^[ d_first_longdesc_pos +
                cnt * (desc_len + 1) ] <> csp_undef_byte) AND
                (a_data_ptr^[ d_first_longdesc_pos +
                cnt * (desc_len + 1) ] <> csp_default_byte)
            THEN
                BEGIN
                a_data_part^.sp1p_arg_count := 1;
                a_in_internal_subtr := false;
                not_finished_long.lds_descriptor := cgg_zero_id;
                a507_putval (acv, d_first_longdesc_pos + cnt * (desc_len + 1),
                      c_intern_call, (cnt = d_cnt_longdesc-1), not_finished_long.desc );
                IF  not_finished_long.lds_descriptor <> cgg_zero_id
                THEN
                    only_move := true
                ELSE
                    a_in_internal_subtr := true
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        cnt := succ (cnt)
        END;
    (*ENDWHILE*) 
    IF  only_move
    THEN
        BEGIN
        out_cnt := 0;
        (* to avoid overwriting of longdescs in ak06destroy_input_ptr *)
        (* which is used for checking correct handling on input/output*)
        (* in one command_segment. Here we are sure that we just write*)
        (* to the left                                                *)
        a_cmd_segm  := NIL;
        a_in_packet := NIL;
        IF  NOT acv.a_variable_input
        THEN
            BEGIN
            cnt := pred(cnt);
            a_data_ptr^[ d_first_longdesc_pos + cnt * (desc_len + 1) ] := csp_defined_byte;
            SAPDB_PascalMove ('VAK505',  35,    
                  sizeof(not_finished_long), a_data_length,
                  @not_finished_long, 1,
                  @a_data_ptr^, d_first_longdesc_pos + 1 +
                  cnt * (desc_len + 1), desc_len,
                  a_returncode);
            WHILE ((a_returncode = 0) AND
                  (cnt < d_cnt_longdesc)) DO
                BEGIN
                IF  a_data_ptr^[ d_first_longdesc_pos +
                    cnt * (desc_len + 1) ] <> csp_undef_byte
                THEN
                    BEGIN
                    a06retpart_move (acv,
                          @a_data_ptr^[ d_first_longdesc_pos + cnt * (desc_len + 1)],
                          desc_len + 1);
                    out_cnt := succ (out_cnt);
                    END;
                (*ENDIF*) 
                cnt := succ (cnt)
                END;
            (*ENDWHILE*) 
            END
        ELSE
            BEGIN
            defbyte[ 1 ] := csp_defined_byte;
            a06retpart_move (acv, @defbyte, sizeof(defbyte));
            a06retpart_move (acv, @not_finished_long, desc_len);
            out_cnt := succ(out_cnt);
            WHILE ((a_returncode = 0) AND
                  (cnt < d_cnt_longdesc)) DO
                BEGIN
                WHILE (next_long_val <= value_cnt) AND
                      NOT a509is_long_value (a_input_data_map, next_long_val) DO
                    next_long_val := succ(next_long_val);
                (*ENDWHILE*) 
                IF  NOT a509get_one_value (a_input_data_map, next_long_val,
                    value_ptr, value_len, is_null, is_default)
                THEN
                    a07ak_system_error (acv, 505, 6)
                ELSE
                    IF  NOT is_null
                    THEN
                        BEGIN
                        a06retpart_move (acv, @defbyte, sizeof(defbyte));
                        a06retpart_move (acv, value_ptr, desc_len);
                        out_cnt := succ (out_cnt);
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                next_long_val := succ(next_long_val);
                cnt := succ (cnt)
                END;
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  out_cnt > 0
    THEN
        BEGIN
        a06finish_curr_retpart (acv, sp1pk_longdata, out_cnt);
        a_in_internal_subtr := false;
        a_execute_trigger   := false
        END
    ELSE
        BEGIN
        a_long_desc_pos := 0;
        IF  (mtype = m_update)
        THEN
            BEGIN
            g04build_temp_tree_id (tempFileId, acv.a_transinf.tri_trans);
            tempFileId.fileTfnTemp_gg00 := ttfnlongsurrogates_egg00;
            a101_ExistsGroupedTempFile (acv.a_transinf.tri_trans, tempFileId);
            IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
            THEN
                a101_DestroyGroupedTempFile (acv.a_transinf.tri_trans, tempFileId);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
