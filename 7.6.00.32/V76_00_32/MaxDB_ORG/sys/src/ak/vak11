.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-10-06
*****************************************************
modname : VAK11
changed : 2000-10-06
module  : AK_Table
 
Author  : ThomasA
Created : 1985-10-16
*****************************************************
 
Purpose :
 
Define  :
 
        PROCEDURE
              a11_call_semantic (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a11AddClusterUniqueColumn (
                    VAR acv          : tak_all_command_glob;
                    VAR Table        : tak_baserecord);
 
        PROCEDURE
              a11condition (
                    VAR acv           : tak_all_command_glob;
                    VAR a11v          : tak_a11_glob;
                    constraint_id     : integer;
                    end_pos           : tsp00_Int4);
 
        PROCEDURE
              a11constraint (
                    VAR acv       : tak_all_command_glob;
                    VAR a11v      : tak_a11_glob;
                    VAR base_rec  : tak_baserecord;
                    constraint_id : integer);
 
        PROCEDURE
              a11domain_usage (
                    VAR acv             : tak_all_command_glob;
                    VAR a11v            : tak_a11_glob;
                    VAR domain_owner_id : tgg00_Surrogate;
                    VAR domain_name     : tsp00_KnlIdentifier;
                    VAR domain_id       : tgg00_Surrogate;
                    colno               : integer);
 
        PROCEDURE
              a11drop_table  (
                    VAR acv       : tak_all_command_glob;
                    VAR tableid   : tgg00_Surrogate;
                    tablkind      : tgg00_TableKind;
                    succ_filevers : boolean);
 
        PROCEDURE
              a11del_usage_entry (
                    VAR acv       : tak_all_command_glob;
                    VAR usa_tabid : tgg00_Surrogate;
                    VAR del_tabid : tgg00_Surrogate);
 
        PROCEDURE
              a11end_create_table (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
        FUNCTION
              a11firstindex (
                    colcount    : integer;
                    VAR baserec : tak_baserecord) : tsp00_Int2;
 
        PROCEDURE
              a11get_check_table (
                    VAR acv          : tak_all_command_glob;
                    new_table        : boolean;
                    basetable        : boolean;
                    unload_allowed   : boolean;
                    required_priv    : tak00_PrivilegeSet;
                    any_priv         : boolean;
                    all_base_rec     : boolean;
                    d_state          : tak_directory_state;
                    VAR act_tree_ind : tsp00_Int4;
                    VAR auth         : tsp00_KnlIdentifier;
                    VAR tablen       : tsp00_KnlIdentifier;
                    VAR p_arr        : tak_syspointerarr);
 
        PROCEDURE
              a11getconstraintname (
                    VAR constraint_rec  : tak_constraintrecord;
                    VAR constraint_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a11glob_init (VAR acv : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
        PROCEDURE
              a11init_baserecord (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
        PROCEDURE
              a11one_column_def  (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
        PROCEDURE
              a11OneFixedLengthColumnDef  (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
        PROCEDURE
              a11put_date_time (
                    VAR date : tsp00_Int4;
                    VAR time : tsp00_Int4);
 
        PROCEDURE
              a11put_systemkey (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
        PROCEDURE
              a11sort (VAR base_rec : tak_baserecord);
 
        PROCEDURE
              a11table_reference (
                    VAR acv     : tak_all_command_glob;
                    VAR authid  : tgg00_Surrogate;
                    VAR tablen  : tsp00_KnlIdentifier;
                    tablekind   : tgg00_TableKind;
                    is_global   : boolean;
                    is_systable : boolean;
                    VAR tableid : tgg00_Surrogate);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Resultname_handling : VAK663;
 
        PROCEDURE
              a663pid_restable_get (
                    VAR acv       : tak_all_command_glob;
                    VAR pars_key  : tak_parskey;
                    dstate        : tak_directory_state;
                    VAR sparr     : tak_syspointerarr);
 
      ------------------------------ 
 
        FROM
              KB_Logging : vkb560;
 
        PROCEDURE
              kb560GetSys1CatalogTreeId(
                    VAR treeId : tgg00_FileId);
 
        PROCEDURE
              kb560GetSys2CatalogTreeId(
                    VAR treeId : tgg00_FileId);
 
        PROCEDURE
              kb560GetSys1CatalogTabId(
                    VAR tabId : tgg00_Surrogate);
 
        PROCEDURE
              kb560GetSys2CatalogTabId(
                    VAR tabId : tgg00_Surrogate);
 
        FUNCTION
              kb560IsSys1CatalogTable(VAR tabId : tgg00_Surrogate) : boolean;
 
        FUNCTION
              kb560IsSys2CatalogTable(VAR tabId : tgg00_Surrogate) : boolean;
 
        FUNCTION
              kb560IsCatalogTable(VAR tabId : tgg00_Surrogate) : boolean;
 
      ------------------------------ 
 
        FROM
              KB_temp_logging : VKB54;
 
        PROCEDURE
              k54create_drop_temp_file (
                    VAR t            : tgg00_TransContext;
                    create_drop_type : tgg00_MessType;
                    VAR temp_file    : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              KB_file_table_handling : VKB64;
 
        PROCEDURE
              k64CreateTable (
                    VAR t              : tgg00_TransContext;
                    VAR fileId         : tgg00_FileId;
                    mess2_type         : tgg00_MessType2;
                    eFiletypeSet       : tgg00_ExtendedFiletypeSet;
                    str_col_cnt        : tsp00_Int2;
                    createShortColFile : boolean);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code           : tgg04_CodeGlobals;
              g01glob           : tgg00_KernelGlobals;
              g01unicode        : boolean;
 
        FUNCTION
              g01columncompression : boolean;
 
        FUNCTION
              g01checktablewidth   : boolean;
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04build_temp_tree_id (
                    VAR curr                   : tgg00_FileId;
                    VAR t                      : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : vgg06;
 
        FUNCTION
              gg06IsNilRef (VAR PageRef : tgg91_PageRef): boolean;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id   : tsp00_C6;
                    mod_num  : tsp00_Int4;
                    src_upb  : tsp00_Int4;
                    dest_upb : tsp00_Int4;
                    src      : tsp00_MoveObjPtr;
                    src_pos  : tsp00_Int4;
                    dest     : tsp00_MoveObjPtr;
                    dest_pos : tsp00_Int4;
                    length   : tsp00_Int4;
                    VAR err  : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures  : VTA01;
 
        PROCEDURE
              t01stackentry (
                    debug          : tgg00_Debug;
                    VAR st         : tgg00_StackEntry;
                    entry_index    : integer);
 
        PROCEDURE
              t01name (debug : tgg00_Debug; nam  : tsp00_Name);
 
        PROCEDURE
              t01basis_error (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname;
                    b_err : tgg00_BasisError);
 
        PROCEDURE
              t01lidentifier (
                    layer      : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR m         : tgg00_MessBlock);
 
        PROCEDURE
              t01moveobj (
                    layer    : tgg00_Debug;
                    VAR buf  : tsp00_MoveObj;
                    startpos : tsp00_Int4;
                    endpos   : tsp00_Int4);
 
        PROCEDURE
              t01treeid (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname;
                    VAR treeid : tgg00_FileId);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01bool (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    curr_bool: boolean);
&       ENDIF
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01char_size            : integer;
              a01defaultkey           : tgg00_SysInfoKey;
              a01_i_internal          : tsp00_KnlIdentifier;
              a01_i_catalog           : tsp00_KnlIdentifier;
              a01_i_postupgradecheck  : tsp00_KnlIdentifier;
              a01_i_postupgradechecku : tsp00_KnlIdentifier;
              a01_i_syscat1           : tsp00_KnlIdentifier;
              a01_i_syscat2           : tsp00_KnlIdentifier;
              a01_i_sysmessages       : tsp00_KnlIdentifier;
              a01_i_sysmonitor        : tsp00_KnlIdentifier;
              a01_i_sysmondata        : tsp00_KnlIdentifier;
              a01_i_sysparseid        : tsp00_KnlIdentifier;
              a01_i_syscmd_analyze    : tsp00_KnlIdentifier;
              a01_i_sysdata_analyze   : tsp00_KnlIdentifier;
              a01_i_tablekey          : tsp00_KnlIdentifier;
              a01_i_temp              : tsp00_KnlIdentifier;
              a01_i_sysupdstatwanted  : tsp00_KnlIdentifier;
              a01_il_b_identifier     : tsp00_KnlIdentifier;
 
        PROCEDURE
              a01_call_put (
                    VAR acv    : tak_all_command_glob;
                    proc       : tak_procs;
                    subproc    : tsp00_Int2;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_init_command (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_next_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_put_node (
                    VAR acv    : tak_all_command_glob;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01setl_identifier (
                    VAR id         : tsp00_KnlIdentifier;
                    set_identifier : tsp00_KnlIdentifier);
 
        FUNCTION
              a01is_whitespace_char (
                    VAR m    : tsp00_MoveObj;
                    pos      : tsp00_Int4) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05surrogate_get (
                    VAR acv        : tak_all_command_glob;
                    VAR surrogate  : tgg00_Surrogate);
 
        PROCEDURE
              a05_unsigned_int2_get (
                    VAR acv  : tak_all_command_glob;
                    pos      : integer;
                    l        : tsp00_Int2;
                    err_code : tsp00_Int4;
                    VAR int  : tsp00_Int2);
 
        PROCEDURE
              a05_int4_unsigned_get (
                    VAR acv : tak_all_command_glob;
                    pos     : integer;
                    l       : tsp00_Int2;
                    VAR int : tsp00_Int4);
 
        PROCEDURE
              a05_identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06a_mblock_init (
                    VAR acv      : tak_all_command_glob;
                    mtype        : tgg00_MessType;
                    m2type       : tgg00_MessType2;
                    VAR tree     : tgg00_FileId);
 
        PROCEDURE
              a06det_user_id (
                    VAR acv      : tak_all_command_glob;
                    VAR authname : tsp00_KnlIdentifier;
                    VAR authid   : tgg00_Surrogate);
 
        FUNCTION
              a06exist_user (
                    VAR acv          : tak_all_command_glob;
                    VAR user_name    : tsp00_KnlIdentifier;
                    dstate           : tak_directory_state;
                    VAR user_rec_ptr : tak_sysbufferaddress) : boolean;
 
        PROCEDURE
              a06extcolno (
                    VAR baserec     : tak_baserecord;
                    extcolno        : integer;
                    VAR colinfo_ptr : tak00_colinfo_ptr);
 
        PROCEDURE
              a06get_username (
                    VAR acv        : tak_all_command_glob;
                    VAR tree_index : integer;
                    VAR username   : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        FUNCTION
              a06_table_exist (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR authid   : tsp00_KnlIdentifier;
                    VAR tablen   : tsp00_KnlIdentifier;
                    VAR d_sparr  : tak_syspointerarr;
                    get_all      : boolean) : boolean;
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06rsend_mess_buf (
                    VAR acv     : tak_all_command_glob;
                    VAR mbuf    : tgg00_MessBlock;
                    result_req  : boolean;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              a06_get_priv  (
                    VAR acv  : tak_all_command_glob;
                    VAR brec : tak_sysbufferaddress;
                    VAR priv : tak_privilege);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061add_name (
                    VAR acv      : tak_all_command_glob;
                    VAR base_rec : tak_baserecord;
                    VAR name     : tsp00_KnlIdentifier;
                    VAR p        : tsp00_KnlIdentifierPtr);
 
        PROCEDURE
              a061assign_colname (
                    value       : tsp00_C18;
                    VAR colname : tsp00_KnlIdentifier);
 
        FUNCTION
              a061identifier_len (VAR id : tsp00_KnlIdentifier) : integer;
 
        PROCEDURE
              a061old_to_new_identifier (
                    VAR old       : tak_oldidentifier;
                    VAR new_ident : tsp00_KnlIdentifier);
 
        PROCEDURE
              a061put_systemkey (
                    VAR acv      : tak_all_command_glob;
                    VAR base_rec : tak_baserecord);
 
        PROCEDURE
              a061sort (
                    VAR acv               : tak_all_command_glob;
                    VAR base_rec          : tak_baserecord;
                    last_used_expr_no     : integer;
                    VAR duplicate_column  : boolean;
                    VAR duplicate_colname : tsp00_KnlIdentifier);
 
        PROCEDURE
              a061app_columnname (
                    VAR acv               : tak_all_command_glob;
                    VAR base_rec          : tak_baserecord;
                    VAR column            : tsp00_KnlIdentifier;
                    VAR index             : integer);
 
        FUNCTION
              a061ExistColumnnameSequential (VAR base_rec : tak_baserecord;
                    VAR column      : tsp00_KnlIdentifier;
                    VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_kw_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    kw       : integer);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache   : VAK10;
 
        FUNCTION
              a10BaseRecPersistentOffset : integer;
 
        PROCEDURE
              a10_copy_catalog_rec (
                    VAR acv        : tak_all_command_glob;
                    VAR old_key    : tgg00_SysInfoKey;
                    del_old_rec    : boolean;
                    VAR new_key    : tgg00_SysInfoKey;
                    new_segment_id : tsp00_C2;
                    add_new_rec    : boolean;
                    VAR b_err      : tgg00_BasisError);
 
        PROCEDURE
              a10_add_repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    add_sysinfo  : boolean;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_key_del  (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10_lock_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey;
                    lockm      : tgg00_LockReqMode);
 
        PROCEDURE
              a10next_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    stop_prefix  : integer;
                    dstate       : tak_directory_state;
                    rec_kind     : tsp00_C2;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10add_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10del_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              a10_cache_delete (
                    VAR acv     : tak_all_command_glob;
                    is_rollback : boolean);
 
        PROCEDURE
              a10_rel_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
      ------------------------------ 
 
        FROM
              SQLManager : vak101;
 
        PROCEDURE
              a101_MapSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier;
                    pos            : integer);
 
        PROCEDURE
              a101_SetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId;
                    sublevel       : tsp00_Int4(*ptocConst*));
 
        PROCEDURE
              a101_AddGroupedTempFile(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId;
                    VAR instanceId : tgg00_Surrogate);
 
        PROCEDURE
              a101_InvalidateListAppend (
                    VAR acv       : tak_all_command_glob;
                    VAR SchemaId  : tgg00_Surrogate;
                    VAR Tablename : tsp00_KnlIdentifier);
 
        PROCEDURE
              a101_RemoveGroupedTempFile(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
        PROCEDURE
              a101_GetTempFileInstance(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103CheckCreateInPrivilege (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier (* ptocConst *);
                    errorPos       : integer);
 
        PROCEDURE
              a103CheckDropInPrivilege (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier (* ptocConst *);
                    errorPos       : integer);
 
        PROCEDURE
              a103GetSchemaId (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier (* ptocConst *);
                    errorPos       : integer;
                    VAR schemaId   : tgg00_Surrogate);
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate (* ptocConst *);
                    VAR schemaName : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              Drop_Table : VAK111;
 
        PROCEDURE
              a111drop_table (
                    VAR acv       : tak_all_command_glob;
                    VAR tabid     : tgg00_Surrogate;
                    tab_kind      : tgg00_TableKind;
                    succ_vers     : boolean;
                    do_cascade    : boolean;
                    no_references : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Domain : VAK12;
 
        PROCEDURE
              a12get_domain (
                    VAR acv         : tak_all_command_glob;
                    VAR owner       : tsp00_KnlIdentifier;
                    VAR domain_name : tsp00_KnlIdentifier;
                    ti              : integer;
                    VAR domain_ref  : tak_sysbufferaddress;
                    VAR domain_def  : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              AK_Data_Type_Options : VAK14;
 
        PROCEDURE
              a14constraint_check (
                    VAR acv       : tak_all_command_glob;
                    col_info      : tak00_columninfo;
                    constraint_id : integer;
                    error_pos     : integer);
 
        PROCEDURE
              a14default_spec  (
                    VAR acv          : tak_all_command_glob;
                    VAR a11v         : tak_a11_glob;
                    VAR col_info     : tak00_columninfo);
 
        PROCEDURE
              a14get_result_datatype  (
                    VAR acv          : tak_all_command_glob;
                    VAR a11v         : tak_a11_glob;
                    VAR col_info     : tak00_columninfo;
                    error_pos        : integer);
 
        PROCEDURE
              a14get_colname  (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob;
                    err_pos  : integer);
 
        PROCEDURE
              a14like_tablen (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
      ------------------------------ 
 
        FROM
              AK_View_semantic  : VAK16;
 
        PROCEDURE
              a16put_usage_def  (
                    VAR acv            : tak_all_command_glob;
                    VAR put_tableid    : tgg00_Surrogate;
                    VAR using_tableid  : tgg00_Surrogate;
                    using_tablekind    : tgg00_TableKind);
 
      ------------------------------ 
 
        FROM
              AK_SAVE_RESTORE_LOAD : VAK17;
 
        PROCEDURE
              a17beginload_save_nolog (
                    VAR acv      : tak_all_command_glob;
                    VAR a11v     : tak_a11_glob);
 
        PROCEDURE
              a17describe (
                    VAR acv    : tak_all_command_glob;
                    VAR a11v   : tak_a11_glob);
 
        PROCEDURE
              a17endload (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
        PROCEDURE
              a17saveinit (
                    VAR acv         : tak_all_command_glob;
                    VAR a11v        : tak_a11_glob;
                    is_short_string : boolean);
 
        PROCEDURE
              a17table_describe (
                    VAR acv    : tak_all_command_glob;
                    VAR a11v   : tak_a11_glob;
                    table_load : boolean);
 
      ------------------------------ 
 
        FROM
              AK_usertab_tools : VAK19;
 
        PROCEDURE
              a19add_usertab  (VAR acv : tak_all_command_glob;
                    VAR user       : tgg00_Surrogate;
                    VAR surrogate  : tgg00_Surrogate;
                    surrogate_desc : tak_usertab_descriptor);
 
      ------------------------------ 
 
        FROM
              AK_Synonym : VAK23;
 
        PROCEDURE
              a23create_sequence (VAR acv : tak_all_command_glob;
                    VAR sequence_id     : tgg00_Surrogate;
                    VAR sequence_schema : tgg00_Surrogate;
                    VAR sequence_name   : tsp00_KnlIdentifier;
                    VAR colinfo         : tak00_columninfo;
                    is_serial           : boolean;
                    is_temp_table       : boolean;
                    tree_index          : integer);
 
      ------------------------------ 
 
        FROM
              AK_Index : VAK24;
 
        PROCEDURE
              a24unique_spec (
                    VAR acv        : tak_all_command_glob;
                    unique_node    : integer);
 
      ------------------------------ 
 
        FROM
              AK_Link : VAK25;
 
        PROCEDURE
              a25foreign_key_spec (
                    VAR acv : tak_all_command_glob;
                    fk_node : integer);
 
        PROCEDURE
              a25pending_link (
                    VAR acv    : tak_all_command_glob;
                    VAR tablen : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_update_statistics : VAK28;
 
        PROCEDURE
              a28new_statistic_info (
                    VAR acv     : tak_all_command_glob;
                    base_ptr    : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              Catalog_Migration_2 : VAK362;
 
        VAR
              a362OnlineTaskId : tsp00_TaskId;
 
      ------------------------------ 
 
        FROM
              AK_Show_synonym_domain : VAK44;
 
        PROCEDURE
              a44constraint_into_moveobj (
                    VAR acv        : tak_all_command_glob;
                    base_ptr       : tak_sysbufferaddress;
                    VAR tabid      : tgg00_Surrogate;
                    object_type    : tak_object_type;
                    constraint_id  : integer;
                    tabno          : integer;
                    VAR moveobj    : tsp00_MoveObj;
                    moveobj_size   : tsp00_Int4;
                    VAR filled_len : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK54;
 
        PROCEDURE
              a54_dml_init (
                    VAR acv   : tak_all_command_glob;
                    VAR dmli  : tak_dml_info;
                    in_union  : boolean);
 
        PROCEDURE
              a54_dml_finalize (
                    VAR dmli         : tak_dml_info;
                    VAR TransContext : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542internal_packet (
                    VAR acv                 : tak_all_command_glob;
                    release_internal_packet : boolean;
                    required_len            : tsp00_Int4);
 
        PROCEDURE
              a542pop_packet (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              Where_Part : VAK63;
 
        PROCEDURE
              a63_asearch_condition (
                    VAR acv            : tak_all_command_glob;
                    VAR put_node       : tsp00_Int2;
                    VAR last_node      : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Execute_Where_Part : VAK65;
 
        PROCEDURE
              a65_search_condition (
                    VAR acv                 : tak_all_command_glob;
                    VAR dmli                : tak_dml_info;
                    VAR first_node          : integer);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20int4_to_buf (
                    val        : tsp00_Int4;
                    VAR destin : tgg00_Surrogate;
                    destin_pos : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              FileDir_Wrapper : VBD998;
 
        PROCEDURE
              bd998NewTempSharedFileNo (
                    VAR file_no : tgg00_Surrogate);
 
        PROCEDURE
              bd998NewTempFileNo (
                    VAR file_no : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        PROCEDURE
              s30cmp  (
                    VAR buf1     : tsp00_MoveObj;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tsp00_MoveObj;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vdattime (
                    VAR d   : tsp00_Date;
                    VAR t : tsp00_Time);
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              a05_identifier_get;
 
              tsp00_MoveObj  tsp00_KnlIdentifier
 
        PROCEDURE
              s20int4_to_buf;
 
              tsp00_MoveObj tgg00_Surrogate
 
.CM *-END-* synonym -------------------------------------
***********************************************************
.sp
.cp 10
.fo
.oc _/1
.pb '@'
Specification:
 
PROCEDURE  A11_CALL_SEMANTIC:
.sp;.fo
The procedure executes semantically the commands Create Table,
Drop Table, Beginload, Endload and Load. On entry into the procedure,
the syntax tree of the command has already been built.
.br
In the case of Create Table, the procedure ==> a11get_check_table checks
whether the table already exists (==> error message),
whereas otherwise the error situations are checked,
and the base records of the table are loaded into acv_p_arr1.
.br
Depending on the command, one of the following procedures is then called:
.sp
a11drop_table ensures that the table a1authid.a1tablen with all views and
synonyms dependent on it is deleted.
.br
a11_create_table ensures that the syntax tree is processed and that the
corresponding system information of the table is created.
.br
a11_like_tablen ensures the semantic processing of the create table like
command.
.br
a11_fastload provides a description of the table in the SQL packet (Load
command).
.br
a11_beginload informs KB of the beginning of a LOAD run.
.br
a11_endload informs KB of the end of a LOAD run.
.br
If an error occurs during the execution of the command,
the catalog changes that have been executed up to that point
are cancelled (a06_partial_rollback).
.br
The variable a11v agreed in a11_call_semantic is passed as a parameter to
virtually all procedures of the module. The individual components of
the record have the following significance:
.sp
.hi +15
a1a_loc^@@@@@@@: Location from which catalog information is to be fetched.
.br
a1add_locset^@@: Locations to which the requests for inserting,
deleting and updating catalog information are sent.
.br
a1authid^@@@@@@: User_id of the current table.
.br
a1tablen^@@@@@@: Name of the current table.
.br
a1tablid^@@@@@@: Table identification of the current table.
.br
a1coln^@@@@@@@@: Current column name;
.br
a1ci^@@@@@@@@@@: Index in bcolumn where the description of the current
column is stored.
.br
a1colsysp^@@@@@: Address of the catalog information in the cache where
the description of the current column is located.
.br
a1createtab^@@@: Some procedures from VAK11 are also used in Create
Domain. In this case  a1createtab is false; otherwise true.
.br
a1default_datatype : Default data type for character columns.
.br
a1extcolno^@@@@: External column number of the current column.
.br
a1inpkey^@@@@@@: True until the first non-key column occurs.
.br
a1keypos^@@@@@@: Position of the next key column in the record.
.br
a1reclen^@@@@@@: Current length of a record of the table.
.br
a1sysbuf^@@@@@@: tsysbufferaddress;
.br
a1sysk^@@@@@@@@: tsysinfokey;
.br
a1ti^@@@@@@@@@@: Current index in the syntax tree.
.br
a1valbufexist^@: boolean;
.br
a1valkey^@@@@@@:
.br
a1valsysp^@@@@@:
im Cache.
.br
a1strcolcount^@: Current number of string columns.
.br
a1range_default_pos : In Create Table, when defining columns, one encounters
the range information before all column information has been entered in the
base records. Only at this point, however, the positions of the columns
in the record are known which means that the
values catalog information can be built after all columns have
been executed. The
position of the range information in the SQL-packet is, therefore, placed
in intermediate storage in a1range_default_pos
and is not evaluated until in
a11end_create_table. If a1range_default_pos[ i ] = k, then the following
applies;
.sp
.hi -15;
.in +15
i)@@@a1liketable = false and k > 0
.br
.in +5
Range description of the external column i starts at position k in the
SQL-packet.
.br
.in -5
ii)@@a1liketable = false and k < 0
.br;.in +5
The external column i is described by a domain at position k in the
SQL-packet.
.br;.in -5
iii)@a1liketable = true
.in +5
.br
Range description of the external column i is the range description of the
external column k of the Like Table.
.in -20
.br
a1likeauthid   : User_id of the Like Table.
.br
a1liketablen   : Name of the Like Table.
.sp 4;.cp 5
PROCEDURE  A11_BEGINLOAD
.sp
.nf
Parameter : VAR acv      : all_command_glob
            VAR a11v     : a11_glob
.sp;.fo
The procedure informs KB of the beginning of a LOAD run.
For this purpose, KB
is sent a message buffer with message type m_load and the table
identification of the table a1authid.a1tablen.
In message 2 type, it is specified whether this is a table
with user-defined key (mm_key) or not (mm_nokey).
As the result, in part 2 of
the message buffer, KB supplies the largest key of the table, which is
transferred to part 1 of the SQL packet.
.br
By means of  b02init_load, the tree id as well as the page number of
the rightmost leaf required
by BD are determined and are transferred to part 2 of the SQL packet.
This tree id and this page number must subsequently also be specified each
time pages are sent. For safety reasons,
the pointers are written twice to the SQL packet in order
to be able to perform a minimal consistency test when the pages are sent.
.br
A special feature is the loading of the error-text table.
If an error occurs
during loading, an attempt must, of course, not be made to access the
corresponding error text. For this reason, in this case, the flag
errormsg_loading is set in the acv.
.sp 4;.cp 5
PROCEDURE  A11_ENDLOAD
.sp
.nf
Parameter : VAR acv      : all_command_glob
            VAR a11v     : a11_glob
.sp;.fo
The procedure informs KB of the end of a LOAD run.
The Load front end sends in
part 2 of the SQL packet the tree id and pointers as well as,
in the case of a table without user-defined key,
the last systemkey that was allocated. This information
is transferred to the message buffer and is sent to KB. If KB does
not report an error, the flag errormsg_loading can again be reset.
.sp 4;.cp 7
PROCEDURE  A11_GET_DATATYP
.sp
.nf
Parameter : acv      : all_command_glob
            a11v     : a11_glob
            col_info : tcolumninfo
            domain   : boolean
.sp
.fo
In the column description, entries are made for col_info cdatatyp, cdatalen and
cinoutlen on the basis of the description in the syntax tree at position a1ti.
In case the description of the data type is by means of a domain, the procedure
a11domain_datatyp is called, which determines the above information from the
domain system information. If the domain has a range or default specification,
range/default system information for the column col_info must be created in
a11end_create_table. This information is derived from the domain definition.
This is noted in a1range_default_pos.
.sp 4
PROCEDURE  A11TABLE_REFERENCE
.sp;.nf
Parameter : VAR acv     : all_command_glob;
            VAR authid  : user_id;
            VAR tablen  : name;
            tablekind   : ttablekind;
            is_global   : boolean;
            is_systable : boolean;
            VAR locset  : new_locnoset;
            VAR tableid : tsurrogate;
.sp;.fo
This procedure is called to determine a unique identifier for
authid.tablen which is either a base-table, view or synonym.
The identifier has a length of 8 bytes and corresponds with the
systemkey which is managed by KB. The new identifier must therefor
be required by a KB-call (a05surrogate_get). Since it must be possible
to identify some system tables by their table identification,
these tables have constant table identifications which cannot be
assigned by KB. In this cases no KB-call is needed to assign the
table identification.
.br
Since it must be possible to determine the tableid of a table
when a tablename is specified, the relationship between
authid.tablen and the tableid is stored in a catalog record
of type treferencerecord.
.br
The tableid determined by the procedure is returned in the
parameter tableid.
.sp 4
PROCEDURE  A11_CREATE_TABLE
.sp
.nf
Parameter : acv  : all_command_glob
            a11v : a11_glob
.sp
.fo
The procedure analyzes the column definitions on the basis of the
syntax tree and creates the corresponding catalog information.
First of all a unique table identification is assigned to the
table a1authid.a1tablen. This is done by a11table_reference where
the 8 Byte table identifier is determined by KB and a catalog
record of type treferencerecord is created to store the relation
between a1authid.a1tablen and the table identifier.
A table catalog information
record of type tbaserecord is allocated in the cache at address
acv_p_arr1.pbasep and is initialized by calling the procedure a11init_baserecor
If the table definition does not have a key specification,
a column description for
the system key is written to the table catalog information (==>
a11put_systemkey). The information of each specified column is inserted into
the table catalog information by (<==> a11one_column_def). By means of
a11end_create_table, the table system information is finally built and written
to system file 1.
.sp 4;.cp 11
PROCEDURE  A11DUPL_COL_ERROR
.sp
.nf
Parameter : acv          : all_command_glob
            coldef_ti    : integer
            dupl_colname : name
.sp;.fo
The procedure determines the position of the column name dupl_colname in the
Create Table definition string in part 1 of the SQL packet. This is necessary
so that, in the case of doubly defined column names, the correct error position
appears.
.sp 4;.cp 11
PROCEDURE  A11RANGE_DEFAULT
.sp
.nf
Parameter : acv       : all_command_glob
            a11v      : a11_glob
            col_info  : tcolumninfo
.sp;.fo
Range/default catalog information of type
tvaluesrecord is created for the
column specified by col_info. If a1range_default_pos is negative, the
range/default description is derived from a domain.
The name of the domain is
specified by ap_tree[ -a1range_default_pos(cextcono) ].
.br
If a1liketable is true, the range/default description is derived from the
range/default description of column a1range_default_pos of the Like Table.
.br
.sp 4;.cp 10
PROCEDURE  A11END_CREATE_TABLE
.sp
.nf
Parameter : acv       : all_command_glob
            a11v      : a11_glob
.sp
.fo
In the catalog information of type tbaserecord (acv_p_arr1),
the procedure makes
entries in the information that cannot be determined until all column
descriptions have been stored. This information comprises in particular:
.br
i.^@@The length of the string columns
.br
ii.^@The length of the columns of fixed length
.br
iii.^The position of the first column of variable length
.br
iv.^@The assignment of external => internal column number
.br
v.^@@The lengths of the individual tbaserecords
.br
vi.^@The estimated average column length and number of pages
.sp
The request to create the file representing the table is sent to KB and
the table name of the created table are store in the catalog record
of type tusertabrecord of the current user.
.br
If range/default definitions have to be performed for specific columns,
==> a11range_default is called for each column concerned. Finally,
the catalog record(s) of type tbaserecord are inserted into
system file 1. If the procedure is called outside
of Create Table, it is necessary for a1createtab, a1range_default_pos
and a1keypos to have correct entries in them.
.sp 4;.cp 10
PROCEDURE  A11SORT
.sp;.nf
Parameter : VAR p_arr : tsyspointerarr;
.sp;.fo
The procedure constructs a list of column informations in the
tbaserecords identified by p_arr, which represents the order in which
the columns are stored in the BD records representing the table.
The pointers to the next column info are implemented by the
fields cnextbuf and cnectindex. If cnextbuf is i and cnextindex is
j this means that the next column info can be found in bcolumn[ j ]
of the tbaserecord identified by p_arr.pbasep. The first column info
is identified by bfirstcolbuf and bfirstcolind stored in the
tbaserecord identified by p_arr.pa [ 1 ].
.sp 4;.cp 10
PROCEDURE  A11ONE_COLUMN_DEF
.sp
.nf
Parameter : acv       : all_command_glob
            a11v      : a11_glob
.sp
.fo
The procedure processes a column definition in the SQL-packet with the aid
of the syntax tree (starting at position a1ti) and creates the resulting catalog
information in the system information of type tbaserecord allocated in the
cache by acv_p_arr1.
.br
The column name is read from the SQL-packet and is inserted by
a061app_columnname as the last column definition into the last tbaserecord. By
means of a11_get_datatyp, the data type and length of the
column are written into the column information. The key or NOT NULL
characteristic of the column is entered, if applicable, and the stack entry of
the column is built, with it being determined, in particular, whether this is a
column of fixed length (length <= 20) or a column of variable length. If range
or default information exists for the column, the syntax-tree position of the
range/default information is entered in a1range_default_pos, which means that
the corresponding catalog information is created in a11end_create_table.
.sp 4;.cp 3
PROCEDURE  A11PUT_DATE_TIME
.sp
The procedure converts a c8 date and time into 2 4-Byte integers.
.sp;.cp 7
PROCEDURE  A11PUT_SYSTEMKEY
.sp
The procedure inserts a column description for the system key not visible to
the user into the catalog information of type tbaserecord
specified by acv_p_arr1.
The procedure is called only if a table is being created without key
specification.
.sp 4;.cp 8
PROCEDURE  AK11DOMAIN_DATATYP
.sp
.nf
Parameter : acv       : all_command_glob
            a11v      : a11_glob
            col_info  : tcolumninfo
.sp
.fo
The procedure transfers the domain definition to the column information
col_info.
.br;.cp 6
The domain name is read from the SQL-packet with the aid of the syntax
tree (index a1ti) and the domain catalog information is read into
the cache. The domain description is allocated to col_info and the
external column number is updated.
.sp 4
PROCEDURE  NEW_POS_IN_VALUESREC
.sp
.nf
Parameter : acv          : all_command_glob
            value_buf    : a11_glob
            column_info  : tcolumninfo
.sp
.fo
In the record of type tvaluesrecord allocated in the
cache starting at address value_buf, all column-description
stack entries are replaced by the stack entry from column_info.
.sp 4;.cp 4
PROCEDURE  A11DROP_TABLE :
.sp 2;.fo
The procedure performs the Drop Table command by calling the recursive
procedure DROP_TABLE.
.sp 4;.cp 20
PROCEDURE  DROP_TABLE
.sp 2
Parameter : VAR acv        : all_command_glob;
            tableid       : tsurrogate;
            table_loc     : location;
            tablkind      : ttablekind;
            from_tableid  : tsurrogate;
            from_table_loc: location;
            succ_filevers : boolean;
            first_drop_tab: boolean;
            VAR usakey    : tsysinfokey;
            VAR usabuf    : tsysbufferaddress;
.sp
This recursive procedure ensures that the table determined by tableid
and all views and synonyms dependent on it is deleted.
All views and synonyms directly dependent
on the table are determined on the basis
of the tusage record of the table identified by tableid. In
turn, DROP_TABLE is called for each entry that is found.
.cp 14
When the entire tusage record has been processed  i.e. when all views and
synonyms dependent on the table have already been deleted),
the table identified by tableid itself is
deleted. This is done by ak11del_synonymdef
 if it is a synonym or otherwise ak11erase_table.
The parameter first_drop_tab is true precisely on the
first call of the procedure; this shows whether the table to be deleted (view
or synonym) has to be deleted as the result of the deleting of another table,
or whether the table is the one specified in the Drop command.
.sp 4;.cp 14
PROCEDURE  A11DEL_USAGE_ENTRY
.sp;.nf;
Parameter : VAR acv        : all_command_glob;
            VAR usa_tabid : tsurrogate;
            VAR usa_loc   : location;
            VAR del_tabid : tsurrogate);
.sp;.fo
The view identified by del_tabid
is deleted from the catalog information of type
tusagerecord of the table identified by usa_tabid
and is restored in system file 2.
.sp 4;.cp 23
PROCEDURE  A11GET_CHECK_TABLE
.sp;.nf
Parameter : VAR acv          : all_command_glob;
            new_table        : boolean;
            basetable        : boolean;
            unload_allowed   : boolean;
            required_priv    : privilege_set;
            any_priv         : boolean;
            all_base_rec     : boolean;
            d_state          : directory_state;
            VAR act_tree_ind : integer;
            VAR authid       : user_id;
            VAR tablen       : name;
            VAR sparr        : tsyspointerarr;
.sp;.fo
The procedure loads a table name from the SQL-packed into authid and
tablen. If new_table has the value TRUE, the table authid.tablen is to be
created. In this case, it is checked whether the current user has the privilege
to create the table and whether the table already exists ==> error message. If
new_table has the value FALSE, the catalog information of
type tbaserecord of the table authid.tablen are
loaded into the cache (a06_table_exist). The following applies:
.sp;
basetable = TRUE ==> authid.tablen must be the base table
.br
unloaded_allowed = TRUE ==> authid.tablen may have been unloaded.
.br
required_priv contains the privileges that the user must have for
authid.tablen.
.br
any_priv = TRUE ==> it is sufficient if the current user has any privilege for
authid.tablen.
.br
all_base_rec = TRUE ==> all system information of type tbaserecord of table
authid.tablen is loaded into the cache.
.br
d_state determines whether the system information may (d_release) or may not
(d_fix) be shifted in the cache and possibly displaced.
.br
act_tree_id is, on entry into the procedure, the syntax-tree index that refers
to the table name; on exit from the procedure, it is the index that refers to
tablen.
.br
sparr contains the addresses of the system information of type tbaserecord of
authid.tablen in the cache.
.sp 4;.cp 8
PROCEDURE  A11INIT_BASERECORD
.sp;.nf
Parameter : VAR acv   : all_command_glob;
            VAR a11v  : a11_glob;
.sp;.fo
The free memory allocated in the cache starting at address
acv_p__arr1.pa[ 1 ] is initialized as tbaserecord.
The file version is initialized by a10_version.
.sp;.fo
.CM *-END-* specification -------------------------------
***********************************************************
 
.CM -lll-
 
Code    :
 
 
CONST
      cak11db2_min_float             =      8;
      cak11db2_max_float             =     16;
      cak11integer                   =     10;
      cak11default_fixed             =      5;
      cak11sample_rows               =  20000;
      cak11undef_sample              =  -1000;
      cak11default_float             =     16;
      cak11max_ext_precision         =     64;
      cak11max_intern_precision      =     38;
      cak11smallint                  =      5;
      cak11release_packet            =   true;
      cak11fixed_length              =   true;
      c_is_rollback                  =   true;
 
 
(*------------------------------*) 
 
PROCEDURE
      a11_call_semantic (VAR acv : tak_all_command_glob);
 
VAR
      base_table       : boolean;
      do_cascade       : boolean;
      new_table        : boolean;
      unload_allowed   : boolean;
      migration        : boolean;
      exit_loop        : boolean;
      rowid            : boolean;
      succ_filevers    : boolean;
      p1_length        : integer;
      p2_length        : integer;
      command          : integer;
      sub_command      : integer;
      sample           : tsp00_Int4;
      ti               : integer;
      required_priv    : tak00_PrivilegeSet;
      a11v             : tak_a11_glob;
      table_attr       : tak_table_attribute_set;
 
BEGIN
WITH acv, a11v DO
    BEGIN
    a_p_arr1.pbasep := NIL; (* PTS 1107987 *)
    a11glob_init (acv, a11v);
    a1ti         := a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_lo_level;
    sample       := cak11undef_sample;
    table_attr := [];
    (* PTS 1117216 E.Z. *)
    IF  acv.a_command_kind = internal_create_tab_command
    THEN
        IF  a_defaultcode = csp_unicode
        THEN
            a1default_datatype := dunicode
        ELSE
            a1default_datatype := dcha;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_initial_segment_header.sp1c_producer = sp1pr_installation
    THEN
        a1default_datatype := dcha;
    (*ENDIF*) 
    rowid     := false;
    exit_loop := false;
    WHILE NOT exit_loop DO
        WITH a_ap_tree^[a1ti] DO
            IF  n_proc = a11
            THEN
                BEGIN
                a1ti := n_lo_level;
                CASE n_subproc OF
                    cak_i_cluster :
                        a1clustered := true;
                    cak_i_packed :
                        a1ispacked := true;
                    cak_i_dynamic :
                        a1dynamic := true;
                    cak_i_internal :
                        a1systable := true;
                    cak_i_ignore :
                        a1nolog  := true;
                    cak_i_rowid :
                        rowid := true;
                    cak_i_sample :
                        BEGIN
                        a05_int4_unsigned_get (acv,
                              a_ap_tree^[n_sa_level].n_pos,
                              a_ap_tree^[n_sa_level].n_length,
                              sample);
                        IF  n_length = cak_i_percent
                        THEN
                            BEGIN
                            IF  (sample < 0) OR (sample > 100)
                            THEN
                                a07_b_put_error (acv,
                                      e_invalid_unsign_integer,
                                      a_ap_tree^[n_sa_level].n_pos)
                            ELSE
                                sample := -sample
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    cak_i_with :
                        a1global := true;
                    (* PTS 1126711 E.Z. *)
                    cak_i_fact :
                        table_attr := table_attr + [ ta_fact ];
                    cak_i_dimension :
                        table_attr := table_attr + [ ta_dimension ];
                    cak_i_bwhierarchy :
                        table_attr := table_attr + [ ta_bwhierarchy ];
                    (* PTS 1117381 E.Z. *)
                    cak_i_archive :
                        a1for_archive := true;
                    cak_i_length :
                        table_attr := table_attr + [ ta_no_fixed_length_column ];
                    OTHERWISE
                        exit_loop := true;
                    END;
                (*ENDCASE*) 
                END
            ELSE
                exit_loop := true;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDWHILE*) 
    WITH a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ] DO
        BEGIN
&       IFDEF TRACE
        t01int4 (ak_sem, 'subproc=    ', n_subproc);
&       ENDIF
        command          := n_subproc;
        sub_command      := n_length;
        migration        :=  (command = cak_x_restore) AND
              (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_length = cak_i_constraint);
        IF  (command <> cak_x_beginload)         AND
            (command <> cak_x_restore)           AND
            (command <> cak_x_restore_string)    AND
            (command <> cak_x_end_load)          AND
            (command <> cak_x_save_init)         AND
            (command <> cak_x_save_short_string)
        THEN
            a10_cache_delete (acv, NOT c_is_rollback);
        (*ENDIF*) 
        IF  command in [ cak_x_drop_table, cak_x_drop_view ]
        THEN
            required_priv := [ ]
        ELSE
            IF  command = cak_x_load
            THEN
                required_priv := [ r_ins ]
            ELSE
                IF  migration OR (command = cak_x_restore)
                THEN
                    required_priv := [  ]
                ELSE
                    required_priv := [ r_owner ];
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        p1_length := a_cmd_part^.sp1p_buf_len;
        p2_length := a_data_length;
        new_table :=
              (command = cak_x_create_table)   OR
              (command = cak_x_like);
        IF  new_table AND a1global AND
            (a_current_user_kind in [ unoprivate, uprivate ])
        THEN
            a07_kw_put_error (acv,
                  e_missing_privilege, 1, cak_i_resource)
        ELSE
            BEGIN
            base_table := (command = cak_x_drop_table) OR
                  (command = cak_x_load)               OR
                  (* PTS 1120287 E.Z. *)
                  (command = cak_x_describe_table)     OR
                  (* PTS 1111576 E.Z. *)
                  (* PTS 1120287 E.Z. *)
                  new_table;
            unload_allowed   := (command = cak_x_drop_table) OR
                  (command = cak_x_restore)                  OR
                  (command = cak_x_restore_string)           OR
                  (command = cak_x_describe_table);
            a1authname := acv.a_curr_schema;
&           IFDEF TRACE
            t01lidentifier (ak_sem, a1authname);
&           ENDIF
            ti := a1ti;
            a11get_check_table (acv, new_table, base_table,
                  unload_allowed, required_priv, false,
                  true, d_fix, a1ti,
                  a1authname, a1tablen, a_p_arr1);
            IF  (command = cak_x_create_table)       AND
                g01columncompression                 AND
                (a1authname <> a01_i_catalog  )      AND
                (a1tablen <> a01_i_postupgradecheck) AND
                (a1tablen <> a01_i_postupgradechecku)AND
                (a1tablen <> a01_i_sysmessages)      AND
                (a1tablen <> a01_i_sysparseid)       AND
                (a1tablen <> a01_i_sysmondata)       AND
                (a1tablen <> a01_i_sysmonitor)       AND
                (a1tablen <> a01_i_syscmd_analyze)   AND
                (a1tablen <> a01_i_sysdata_analyze)  AND
                (a1tablen <> a01_i_sysupdstatwanted) AND
                (a_init_ddl <> ddl_restore_schema)   AND
                NOT (a_initial_segment_header.sp1c_producer = sp1pr_installation)
            THEN
                table_attr := table_attr + [ ta_no_fixed_length_column ];
            (*ENDIF*) 
            a1temp_table := a1authname = a01_i_temp ;
            IF  a1temp_table
            THEN
                BEGIN
                IF  a1global
                THEN
                    a07_b_put_error (acv, e_not_allowed_in_temp_table,
                          a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_pos)
                ELSE
                    BEGIN (* temp logging for catalog required *)
                    IF  NOT a1nolog
                        OR  a_progusage_add
                        (* during the creation of a DBprocedure *)
                        (* or a precompiler program it must be  *)
                        (* possible to rollback the creation of *)
                        (* a temp table (subtrans rollback)     *)
                        (* even if the table is created with    *)
                        (* ignore rollback                      *)
                    THEN
                        a_pars_curr.fileHandling_gg00 := a_pars_curr.fileHandling_gg00 -
                              [ hsNoLog_egg00 ];
                    (*ENDIF*) 
                    a1authid := cak_temp_user_id
                    END;
                (*ENDIF*) 
                END
            ELSE
                IF  a1nolog
                THEN
                    a07_b_put_error (acv, e_table_must_be_temp, 1)
                ELSE
                    a103GetSchemaId (acv, a1authname,  a_ap_tree^[ti].n_pos, a1authid);
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  a_returncode =
            a071_return_code (e_missing_basetable, a_sqlmode)
        THEN
            WITH a_p_arr1.pbasep^, sbase DO
                IF  (syskey.stableid = btreeid.fileTabId_gg00) AND
                    (btablekind = tonebase)
                THEN
                    BEGIN
                    (* save schema table *)
                    a_returncode  := 0;
                    a_errorpos    := 0;
                    a_cmd_part^.sp1p_buf_len      := p1_length;
                    a_data_length     := p2_length;
                    a_input_data_pos  := 1;
                    a_output_data_pos := 1;
                    a_err_parm_cnt    := 0
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    (* PTS 1107987 *)
    (* PTS 1120287 E.Z. *)
    IF  a_returncode = 0
    THEN
        IF  (command = cak_x_drop_table   ) OR
            (command = cak_x_drop_view    ) (* PTS 1111576 E.Z. *)
        THEN
            WITH a_p_arr1.pbasep^.sbase DO
                BEGIN
                IF  command = cak_x_drop_view
                THEN
                    BEGIN
                    IF  ((sub_command = cak_i_view) AND
                        NOT (btablekind in
                        [ tonebase, tview, tcomplexview ]))
                        OR
                        ((sub_command = cak_i_db2) AND
                        (btablekind <> tdb2view))
                    THEN
                        a07_b_put_error (acv,
                              e_missing_viewtable, 1)
                    (*ENDIF*) 
                    END
                (* PTS 1123536 E.Z. *)
                ELSE
                    IF  ftsArchive_egg00 in btreeid.fileType_gg00 (* PTS 1111576 E.Z. *)
                    THEN
                        a07_b_put_error (acv, e_invalid_tabletype, 1)
                    ELSE
                        IF  (internal_trigger in blinkexist)
                        THEN
                            a07_b_put_error (acv, e_replicated_table_not_allowed , 1);
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  a_returncode = 0
                THEN
                    a103CheckDropInPrivilege (acv, a1authname, 1);
                (*ENDIF*) 
                IF  a_returncode = 0
                THEN
                    WITH a_p_arr1.pbasep^.sbase DO
                        BEGIN
                        (* PTS 1111432 E.Z. *)
                        do_cascade := a_sqlmode <> sqlm_ansi;
                        succ_filevers := true;
                        a1ti       := a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_sa_level;
                        IF  a1ti <> 0
                        THEN
                            BEGIN
                            WITH a_ap_tree^[a1ti] DO
                                IF  (n_subproc = cak_i_cascade) OR
                                    (n_subproc = cak_i_restrict)
                                THEN
                                    BEGIN
                                    do_cascade := n_subproc = cak_i_cascade;
                                    a1ti := a_ap_tree^[a1ti].n_sa_level;
                                    END;
                                (*ENDIF*) 
                            (*ENDWITH*) 
                            END;
                        (*ENDIF*) 
                        a111drop_table (acv, bsurrogate,
                              btablekind, succ_filevers, do_cascade, ta_no_references_view in battributes);
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
                END
            (*ENDWITH*) 
        ELSE
            CASE command OF
                cak_x_load :
                    a17table_describe (acv, a11v, true);
                cak_x_describe_table :
                    a17describe (acv, a11v);
                cak_x_beginload, cak_x_restore, cak_x_restore_string :
                    IF  a1authname = a01_i_temp
                    THEN
                        a07_b_put_error (acv, e_missing_privilege, 1)
                    ELSE
                        a17beginload_save_nolog (acv, a11v);
                    (*ENDIF*) 
                (* PTS 1120287 E.Z. *)
                cak_x_end_load :
                    a17endload (acv, a11v);
                (* PTS 1120287 E.Z. *)
                cak_x_save_init :
                    a17saveinit (acv, a11v, false);
                cak_x_save_short_string :
                    a17saveinit (acv, a11v, true);
                (* PTS 1120287 E.Z. *)
                OTHERWISE
                    BEGIN
                    a103CheckCreateInPrivilege (acv, a1authname, 1);
                    IF  a_returncode = 0
                    THEN
                        BEGIN
                        IF  command = cak_x_like
                        THEN
                            a14like_tablen (acv, a11v)
                        ELSE
                            ak11create_table (acv, a11v,
                                  table_attr, sample, rowid);
                        (*ENDIF*) 
                        IF  (a1authname <> acv.a_curr_user_name) AND NOT a1temp_table
                        THEN
                            a19add_usertab  (acv, acv.a_curr_user_id, a1tableid, ut_base_table);
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a1temp_table
    THEN
        a_pars_curr.fileHandling_gg00 := a_pars_curr.fileHandling_gg00 + [hsNoLog_egg00];
    (*ENDIF*) 
    IF  (command = cak_x_beginload) OR
        (command = cak_x_end_load )
    THEN
        BEGIN
        IF  a_returncode <> 0
        THEN
            a_rollback_info := [ trans_rollback, new_trans ]
        (*ENDIF*) 
        END
    ELSE
        IF  (command <> cak_x_load     )         AND
            (command <> cak_x_describe_table )   AND
            (command <> cak_x_save_init)         AND
            (command <> cak_x_save_short_string) AND
            (command <> cak_x_restore)           AND
            (command <> cak_x_restore_string)
        THEN
            IF  a_returncode <> 0
            THEN
                a_part_rollback := true
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak11get_datatyp (
            VAR acv        : tak_all_command_glob;
            VAR a11v       : tak_a11_glob;
            isProcVariable : boolean;
            VAR col_info   : tak00_columninfo;
            VAR domain     : boolean);
 
VAR
      unknownLength   : boolean;
      in_installation : boolean;
      i               : integer;
      err_pos         : integer;
      tsa             : integer;
      max_length      : integer;
      datalen         : tsp00_Int2;
      datafrac        : tsp00_Int2;
 
BEGIN
WITH acv, a11v, col_info DO
    IF  a_returncode = 0
    THEN
        BEGIN
        in_installation := a_initial_segment_header.sp1c_producer = sp1pr_installation;
        cbinary      := false;
        cudtdatatype := cgg_zero_c2;
        domain       := false;
        WITH a_ap_tree^[ a1ti ] DO
            BEGIN
            i   := n_lo_level;
            tsa := n_sa_level
            END;
        (*ENDWITH*) 
        err_pos := i;
        CASE a_ap_tree^[ a1ti ].n_symb OF
            s_authid, s_identifier :
                BEGIN
                (* domainname *)
                IF  a_ap_tree^[ a1ti ].n_symb = s_authid
                THEN
                    tsa := a_ap_tree^[tsa].n_sa_level;
                (*ENDIF*) 
                ak11domain_datatyp (acv, a11v, col_info);
                domain := true;
                END;
            s_graphic :
                BEGIN (* graphic and vargraphic *)
                IF  i = 0
                THEN
                    datalen := 1
                ELSE
                    WITH a_ap_tree^[ i ] DO
                        a05_unsigned_int2_get (acv,
                              n_pos, n_length, e_invalid_datalength, datalen);
                    (*ENDWITH*) 
                (*ENDIF*) 
                cdatalen := datalen + datalen;
                cdatatyp := dchb;
                IF  (cdatalen < 1) OR (cdatalen > cak_maxfieldlength)
                THEN
                    a07_nb_put_error (acv, e_invalid_length_of_datatyp,
                          a_ap_tree^[ err_pos ].n_pos, a1coln)
                ELSE
                    cinoutlen := cdatalen + 1
                (*ENDIF*) 
                END;
            s_character, s_varchar, s_long_varchar :
                BEGIN
                unknownLength := false;
                cshiftoutchar :=
                      chr(ord(a_ap_tree^[ a1ti ].n_symb <>
                      s_character));
                IF  i = 0
                THEN
                    BEGIN
                    IF  a_ap_tree^[a1ti].n_pos = -1
                    THEN (* dbfunction varchar parameter of unknown length *)
                        unknownLength := true;
                    (*ENDIF*) 
                    datalen := 1
                    END
                ELSE
                    WITH a_ap_tree^[ i ] DO
                        a05_unsigned_int2_get (acv,
                              n_pos, n_length, e_invalid_datalength, datalen);
                    (*ENDWITH*) 
                (*ENDIF*) 
                WITH a_ap_tree^[ a1ti ] DO
                    IF  n_length = ord(s_ascii)
                    THEN
                        cdatatyp := dcha
                    ELSE
                        (* PTS 1122828 E.Z. *)
                        IF  n_length = ord(s_byte)
                        THEN
                            cdatatyp := dchb
                        ELSE
                            IF  (n_length = ord(s_unicode)) OR
                                (in_installation AND
                                g01unicode)
                            THEN
                                cdatatyp := dunicode
                            ELSE
                                cdatatyp := a1default_datatype;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDWITH*) 
                CASE a_sqlmode OF
                    sqlm_db2 :
                        max_length := cak_maxdb2fieldlength;
                    sqlm_oracle :
                        max_length := cak_maxorafieldlength;
                    sqlm_internal :
                        max_length := cak_maxdeffieldlength;
                    OTHERWISE
                        max_length := cak_maxfieldlength;
                    END;
                (*ENDCASE*) 
                IF  cdatatyp = dunicode
                THEN
                    IF  NOT g01unicode AND (a362OnlineTaskId = UNDEF_SP00)
                    THEN
                        a07_b_put_error (acv, e_invalid_datatype,
                              a_ap_tree^[ a1ti ].n_pos)
                    ELSE
                        IF  (datalen < 1) OR
                            ((datalen > cak_maxdeffieldlength DIV 2) AND NOT isProcVariable) OR
                            (datalen > max_length)
                        THEN
                            a07_nb_put_error (acv, e_invalid_length_of_datatyp,
                                  a_ap_tree^[ err_pos ].n_pos, a1coln)
                        ELSE
                            BEGIN
                            cdatalen  := datalen;
                            cinoutlen := 2 * cdatalen + 1;
                            END
                        (*ENDIF*) 
                    (*ENDIF*) 
                ELSE
                    IF  ((datalen < 1) OR (datalen > max_length))
                        AND
                        NOT in_installation
                    THEN
                        a07_nb_put_error (acv,
                              e_invalid_length_of_datatyp,
                              a_ap_tree^[ err_pos ].n_pos, a1coln)
                    ELSE
                        BEGIN
                        IF  a_ap_tree^[ a1ti ].n_symb = s_long_varchar
                        THEN
                            cdatalen := cak_is_undefined
                        ELSE
                            cdatalen  := datalen;
                        (*ENDIF*) 
                        cinoutlen := datalen + 1;
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  unknownLength
                THEN
                    BEGIN
                    cdatalen  := -1;
                    cinoutlen := 0;
                    END
                (*ENDIF*) 
                END;
            s_vargraphic, s_long_vargraphic :
                BEGIN (* graphic *)
                IF  i = 0
                THEN
                    datalen := 1
                ELSE
                    WITH a_ap_tree^[ i ] DO
                        a05_unsigned_int2_get (acv,
                              n_pos, n_length, e_invalid_datalength, datalen);
                    (*ENDWITH*) 
                (*ENDIF*) 
                cdatalen := datalen + datalen;
                cdatatyp := dchb;
                IF  (cdatalen < 1) OR
                    (cdatalen > cak_maxdeffieldlength)
                THEN
                    a07_nb_put_error (acv, e_invalid_length_of_datatyp,
                          a_ap_tree^[ err_pos ].n_pos, a1coln)
                ELSE
                    BEGIN
                    cshiftoutchar := chr(ord(true));
                    cinoutlen     := cdatalen + 1;
                    IF  a_ap_tree^[a1ti].n_symb = s_long_vargraphic
                    THEN
                        cdatalen := cak_is_undefined
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            s_date :
                BEGIN
                cdatatyp  := ddate;
                cdatalen  := mxsp_date;
                cinoutlen := cdatalen + 1;
                END;
            s_fixed, s_binary, s_float, s_double_precision, s_real :
                BEGIN
                IF  i > 0
                THEN
                    WITH a_ap_tree^[ i ] DO
                        BEGIN
                        (* PTS 1116204 E.Z. *)
                        IF  (n_symb = s_asterisk)
                        THEN
                            IF  a_sqlmode = sqlm_ansi
                            THEN
                                datalen := cak11default_float
                            ELSE
                                datalen := cak_default_precision
                            (*ENDIF*) 
                        ELSE
                            BEGIN
                            a05_unsigned_int2_get (acv, n_pos, n_length,
                                  e_invalid_datalength, datalen);
                            IF  ((a_ap_tree^[ a1ti ].n_symb = s_float)    AND
                                (a_sqlmode in [ sqlm_ansi, sqlm_oracle ]) AND
                                (datalen >= 1) AND (datalen <= 126))
                            THEN
                                IF  a_sqlmode = sqlm_ansi
                                THEN
                                    datalen := cak11default_float
                                ELSE
                                    datalen := cak_default_precision
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  (a_sqlmode = sqlm_db2) AND
                            (a_ap_tree^[ a1ti ].n_symb = s_float)
                        THEN
                            IF  datalen <= 21
                            THEN
                                datalen := cak11db2_min_float
                            ELSE
                                datalen := cak11db2_max_float
                            (*ENDIF*) 
                        ELSE
                            IF  (a_sqlmode <> sqlm_internal) OR
                                (a_ap_tree^[ a1ti ].n_symb = s_float)
                            THEN
                                IF  (datalen > cak11max_intern_precision)
                                    AND
                                    (datalen <= cak11max_ext_precision)
                                THEN
                                    datalen := cak11max_intern_precision;
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                        i := n_sa_level;
                        END
                    (*ENDWITH*) 
                ELSE
                    IF  (a_ap_tree^[ a1ti ].n_symb = s_float) OR
                        (a_ap_tree^[ a1ti ].n_symb = s_real)
                    THEN
                        CASE a_sqlmode OF
                            sqlm_ansi :
                                datalen := cak11default_float;
                            sqlm_db2 :
                                IF  a_ap_tree^[a1ti].n_symb = s_real
                                THEN
                                    datalen := cak11db2_min_float
                                ELSE
                                    datalen := cak11db2_max_float;
                                (*ENDIF*) 
                            sqlm_oracle :
                                datalen := cak_default_precision
                            OTHERWISE
                                datalen := cak11default_float
                            END
                        (*ENDCASE*) 
                    ELSE
                        IF  (a_sqlmode = sqlm_db2) AND
                            (a_ap_tree^[a1ti].n_symb =
                            s_double_precision)
                        THEN
                            datalen := cak11db2_max_float
                        ELSE
                            IF  (a_sqlmode = sqlm_oracle) OR
                                (a_ap_tree^[a1ti].n_symb =
                                s_double_precision)
                            THEN
                                datalen := cak_default_precision
                            ELSE
                                datalen := cak11default_fixed;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                CASE a_ap_tree^[ a1ti ].n_symb OF
                    s_binary, s_fixed :
                        BEGIN
                        IF  i = 0
                        THEN
                            datafrac := 0
                        ELSE
                            BEGIN
                            err_pos := i;
                            WITH a_ap_tree^[ i ] DO
                                a05_unsigned_int2_get (acv, n_pos,
                                      n_length, e_invalid_datalength, datafrac)
                            (*ENDWITH*) 
                            END;
                        (*ENDIF*) 
                        cdatatyp := dfixed;
                        END;
                    s_float, s_double_precision, s_real :
                        BEGIN
                        cdatatyp := dfloat;
                        datafrac := csp_float_frac;
                        END;
                    END;
                (*ENDCASE*) 
                IF  (datalen < 1) OR ( datalen > csp_fixed)
                    OR (datalen < datafrac)
                THEN
                    a07_nb_put_error (acv, e_invalid_length_of_datatyp,
                          a_ap_tree^[ err_pos ].n_pos, a1coln)
                ELSE
                    BEGIN
                    cdatalen  := datalen;
                    cdatafrac := datafrac + cak_frac_offset;
                    cinoutlen := (datalen + 1) DIV 2 + 2;
                    END;
                (*ENDIF*) 
                END;
            s_integer :
                BEGIN
                cdatatyp := dfixed;
                IF  a_sqlmode = sqlm_oracle
                THEN
                    cdatalen := cak_default_precision
                ELSE
                    BEGIN
                    cdatalen  := cak11integer;
                    cbinary   := true
                    END;
                (*ENDIF*) 
                cinoutlen := (cdatalen + 1) DIV 2 + 2
                END;
            s_number :
                BEGIN (* dbfunction parameter of undefined length *)
                cdatatyp  := dfixed;
                cdatalen  := -1;
                cinoutlen := 0;
                END;
            s_rowid :
                BEGIN
                IF  a_sqlmode = sqlm_oracle
                THEN
                    cdatatyp  := dchb
                ELSE
                    cdatatyp  := drowid;
                (*ENDIF*) 
                cdatalen  := SURROGATE_MXGG00;
                cinoutlen := SURROGATE_MXGG00 + 1
                END;
            s_smallint :
                BEGIN
                cdatatyp := dfixed;
                IF  a_sqlmode = sqlm_oracle
                THEN
                    cdatalen := cak_default_precision
                ELSE
                    BEGIN
                    cdatalen := cak11smallint;
                    cbinary  := true
                    END;
                (*ENDIF*) 
                cinoutlen := (cdatalen + 1) DIV 2 + 2
                END;
            s_serial  :
                IF  a1serial_node = 0
                THEN
                    BEGIN
                    a1serial_node := a1ti;
                    cdatatyp      := dfixed;
                    cdatalen      := 10;
                    cinoutlen     := (cdatalen + 1) DIV 2 + 2;
                    ccolpropset   := ccolpropset + [ctserial]
                    END
                ELSE
                    a07_b_put_error (acv, e_too_many_serials,
                          a_ap_tree^[a1ti].n_pos);
                (*ENDIF*) 
            s_time :
                BEGIN
                cdatatyp  := dtime;
                cdatalen  := mxsp_time;
                cinoutlen := mxsp_time + 1;
                END;
            s_timestamp :
                BEGIN
                cdatatyp  := dtimestamp;
                cdatalen  := mxsp_timestamp;
                cinoutlen := mxsp_timestamp+1;
                END;
            s_old_long :
                IF  a1temp_table
                    (* replicated longs
                          OR a1global
                          *)
                THEN
                    a07_b_put_error (acv,
                          e_command_for_string_not_allow,
                          a_ap_tree^[ a1ti ].n_pos)
                ELSE
                    BEGIN
                    err_pos := a1ti;
                    WITH a_ap_tree^[ a1ti ] DO
                        IF  n_length = ord(s_ascii)
                        THEN
                            cdatatyp := dstra
                        ELSE
                            (* PTS 1122828 E.Z. *)
                            IF  n_length = ord(s_byte)
                            THEN
                                cdatatyp := dstrb
                            ELSE
                                IF  (n_length = ord(s_unicode)) OR
                                    (in_installation AND
                                    g01unicode)
                                THEN
                                    cdatatyp := dstruni
                                ELSE
                                    BEGIN
                                    CASE a1default_datatype OF
                                        dcha :
                                            cdatatyp := dstra;
                                        dunicode :
                                            cdatatyp := dstruni
                                        END;
                                    (*ENDCASE*) 
                                    END;
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    IF  (NOT g01unicode) AND
                        (cdatatyp = dstruni)
                    THEN
                        a07_b_put_error (acv, e_invalid_datatype,
                              a_ap_tree^[ a1ti ].n_pos)
                    ELSE
                        BEGIN
                        cdatalen  := cgg04_str_col_entry_size;
                        cinoutlen := cgg04_str_col_entry_size + 1;
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            s_file :
                IF  a1temp_table OR a1global
                THEN
                    a07_b_put_error (acv,
                          e_command_for_string_not_allow,
                          a_ap_tree^[ a1ti ].n_pos)
                ELSE
                    BEGIN
                    err_pos := a1ti;
                    WITH a_ap_tree^[ a1ti ] DO
                        IF  n_length = ord(s_ascii)
                        THEN
                            cdatatyp := dlonga
                                  (* PTS 1122828 E.Z. *)
                        ELSE
                            IF  n_length = ord(s_byte)
                            THEN
                                cdatatyp := dlongb
                            ELSE
                                IF  (n_length = ord(s_unicode)) OR
                                    (in_installation AND
                                    g01unicode)
                                THEN
                                    cdatatyp := dlonguni
                                ELSE
                                    BEGIN
                                    CASE a1default_datatype OF
                                        dcha :
                                            cdatatyp := dlonga;
                                        dunicode :
                                            cdatatyp := dlonguni
                                        END;
                                    (*ENDCASE*) 
                                    END;
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    IF  (NOT g01unicode) AND
                        (cdatatyp = dlonguni)
                    THEN
                        a07_b_put_error (acv, e_invalid_datatype,
                              a_ap_tree^[ a1ti ].n_pos)
                    ELSE
                        BEGIN
                        cdatalen  := cgg04_str_col_entry_size;
                        cinoutlen := cgg04_str_col_entry_size + 1;
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            s_boolean :
                BEGIN
                cdatatyp  := dboolean;
                cdatalen  := 1;
                cinoutlen := cdatalen + 1;
                END;
            OTHERWISE
                a07_b_put_error (acv, e_invalid_datatype,
                      a_ap_tree^[ a1ti ].n_pos);
            END;
        (*ENDCASE*) 
        a1ti := tsa;
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a11getconstraintname (
            VAR constraint_rec  : tak_constraintrecord;
            VAR constraint_name : tsp00_KnlIdentifier);
 
VAR
      e : tgg00_BasisError;
 
BEGIN
a061old_to_new_identifier (constraint_rec.ccname, constraint_name);
IF  (constraint_rec.csuffixlen > 0) AND
    (constraint_rec.csuffixlen <=
    sizeof (constraint_name) - sizeof (constraint_rec.ccname))
THEN
    SAPDB_PascalForcedMove (
          sizeof (constraint_rec.csuffix), sizeof (constraint_name),
          @constraint_rec.csuffix, 1, @constraint_name,
          sizeof (constraint_rec.ccname)+1, constraint_rec.csuffixlen)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak11GetTableSurrogate (VAR acv : tak_all_command_glob;
            VAR tableid : tgg00_Surrogate);
 
BEGIN
a05surrogate_get (acv, tableid);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a11table_reference (
            VAR acv     : tak_all_command_glob;
            VAR authid  : tgg00_Surrogate;
            VAR tablen  : tsp00_KnlIdentifier;
            tablekind   : tgg00_TableKind;
            is_global   : boolean;
            is_systable : boolean;
            VAR tableid : tgg00_Surrogate);
 
VAR
      temp_table : boolean;
      b_err      : tgg00_BasisError;
      sysp       : tak_sysbufferaddress;
 
      tabid       : RECORD
            CASE integer OF
                1 :
                    ( s : tgg00_Surrogate);
                2 :
                    (temp_loc : tgg00_ServerdbNo;
                    filler    : tsp00_Int2;
                    i4        : tsp00_Int4);
                3 :
                    (ssite    : tgg00_ServerdbNo;
                    ssession  : tgg91_SessionNo;
                    stemptype : tgg00_TfnTemp;
                    sfill     : tsp00_C1);
                END;
            (*ENDCASE*) 
 
      sysk        : tgg00_SysInfoKey;
 
BEGIN
temp_table := authid = cak_temp_user_id;
(* PTS 1111576 E.Z. *)
IF  temp_table OR (tablekind in [tview])
THEN
    sysk.sentrytyp := cak_etemptableref
ELSE
    sysk.sentrytyp := cak_etableref;
(*ENDIF*) 
sysk.sauthid     := authid;
sysk.sidentifier := tablen;
sysk.slinkage    := cak_init_linkage;
sysk.skeylen     := mxak_standard_sysk + sizeof (tablen);
a10_nil_get_sysinfo (acv, sysk,
      d_release, sizeof (tak_tablereference), sysp, b_err);
IF  b_err = e_ok
THEN
    WITH acv, sysp^.stableref DO
        BEGIN
        IF  NOT temp_table
        THEN
            a101_InvalidateListAppend (acv, authid, tablen);
        (*ENDIF*) 
        sysp^.b_sl := sizeof (tak_tablereference);
        rsystable  := is_systable;
        rfiller    := false;
        IF  is_global
        THEN
            rsegmentid := cak00_public_segment_id
        ELSE
            rsegmentid := cak00_local_segment_id;
        (*ENDIF*) 
        IF  authid = g01glob.sysuser_id
        THEN
            BEGIN
            IF  tablen = a01_i_syscat1
            THEN
                kb560GetSys1CatalogTabId (tabid.s)
            ELSE
                IF  tablen = a01_i_syscat2
                THEN
                    kb560GetSys2CatalogTabId (tabid.s)
                ELSE
                    IF  (tablen = a01_i_sysparseid      ) OR
                        (tablen = a01_i_sysmonitor      ) OR
                        (tablen = a01_i_sysmondata      ) OR
                        (tablen = a01_i_syscmd_analyze  ) OR
                        (tablen = a01_i_sysdata_analyze )
                    THEN
                        BEGIN
                        bd998NewTempSharedFileNo (tabid.s);
                        END
                    ELSE
                        BEGIN
                        a05surrogate_get (acv, tabid.s);
                        IF  tablen = a01_i_sysmessages
                        THEN
                            g01glob.sysmsg_may_exist := true
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            IF  temp_table
            THEN
                BEGIN
                (* create temp table *)
                tabid.s        := cgg_zero_id;
                tabid.temp_loc := cak_temp_table_site;
                tabid.i4       := acv.a_max_res_id
                END
            ELSE
                ak11GetTableSurrogate (acv, tabid.s);
            (*ENDIF*) 
        (*ENDIF*) 
        rtablekind := tablekind;
        IF  tablekind = tsynonym
        THEN
            BEGIN
            rtableid := tableid;
            rsynid   := tabid.s;
            END
        ELSE
            BEGIN
            rtableid   := tabid.s;
            sysp^.b_sl := sizeof (tak_tablereference) - 8;
            END;
        (*ENDIF*) 
        tableid  := tabid.s;
        IF  acv.a_is_ddl in
            [no_ddl, ddl_create_domain]
        THEN
            BEGIN
            a10_key_del (acv, sysp^.syskey);
            b_err := e_ok
            END
        ELSE
            BEGIN
            a10add_sysinfo (acv, sysp, b_err);
            IF  temp_table
            THEN (* flush record *)
                a10_key_del (acv, sysp^.syskey)
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  b_err <> e_ok
THEN
    IF  b_err = e_duplicate_sysinfo
    THEN
        a07_b_put_error (acv, e_duplicate_tablename, 1)
    ELSE
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
&ifdef TRACE
(*ENDIF*) 
t01name(ak_sem, '<a11table_referenc');
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a11AddClusterUniqueColumn (
            VAR acv          : tak_all_command_glob;
            VAR Table        : tak_baserecord);
 
VAR
      colIdx : integer;
      pos    : integer;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    pos := 1;
    FOR colIdx := Table.bfirstindex TO Table.blastindex DO
        WITH Table.bcolumn[colIdx]^ DO
            IF  ctkey in ccolpropset
            THEN
                IF  ccolstack.epos + ccolstack.elen_var > pos
                THEN
                    pos := ccolstack.epos + ccolstack.elen_var;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDFOR*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    a061app_columnname (acv, Table, a01_i_internal, colIdx);
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    WITH Table, bcolumn[colIdx]^, ccolstack DO
        BEGIN
        cextcolno     := Table.bmaxcol;
        creccolno     := cextcolno;
        ctabno        := 1;
        ccolpropset   := [ ctkey, ctinvisible ];
        cdatafrac     := cak_frac_offset;
        cinoutlen     := 0;
        eop           := op_none;
        eop_out       := op_o_output_cluster_key;
        ecol_tab[ 1 ] := chr(0);
        ecol_tab[ 2 ] := chr(0);
        cbinary       := false;
        cbinary       := false;
        cudtdatatype  := cgg_zero_c2;
        cdatatyp      := dchb;
        cdatalen      := sizeof(tgg00_UniquePrimId) - 1;
        cinoutlen     := sizeof(tgg00_UniquePrimId);
        cshiftoutchar := chr(ord(false));
        etype         := st_varkey;
        epos          := pos;
        elen_var      := cinoutlen;
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak11create_table (
            VAR acv          : tak_all_command_glob;
            VAR a11v         : tak_a11_glob;
            VAR table_attr   : tak_table_attribute_set;
            sample           : tsp00_Int4;
            rowid            : boolean);
 
VAR
      keyexist         : boolean;
      curr_n           : tsp00_Int2;
      tlo              : integer;
      i                : integer;
      j                : integer;
      offset           : integer;
      col              : integer;
      colcount         : integer;
      keycolcnt        : integer;
      coldef_ti        : integer;
      key_col          : tsp00_KnlIdentifier;
 
BEGIN
&ifdef TRACE
t01int4(ak_sem, 'sample      ', sample);
t01bool(ak_sem, 'rowid       ', rowid);
&endif
WITH acv, a11v DO
    BEGIN
    keyexist := false;
    IF  a_is_ddl = ddl_create_as_select
    THEN
        a663pid_restable_get (acv, a_pars_last_key, d_fix, a_p_arr2);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        a1createtab := true;
        WITH a_ap_tree^[ a1ti ] DO
            BEGIN
            IF  n_sa_level = 0
            THEN
                j := a1ti;
            (*ENDIF*) 
            a1ti := n_sa_level
            END;
        (*ENDWITH*) 
        colcount           := 0;
        keycolcnt          := 0;
        i                  := a1ti;
&       IFDEF TRACE
        t01int4 (ak_sem, 'a1ti        ', a1ti);
&       ENDIF
        IF  i <> 0
        THEN
            REPEAT
                CASE a_ap_tree^[ i ].n_symb OF
                    s_identifier :
                        BEGIN
                        colcount := colcount + 1;
                        j := a_ap_tree^[ i ].n_sa_level;
                        WHILE j <> 0 DO
                            BEGIN
                            IF  a_ap_tree^[ j ].n_symb = s_key
                            THEN
                                (* PTS 1122050 E.Z. *)
                                IF  a1for_archive
                                THEN
                                    a07_b_put_error (acv, e_invalid_tabletype,  a_ap_tree^[ i ].n_pos)
                                ELSE
                                    BEGIN
                                    keycolcnt := succ(keycolcnt);
                                    keyexist := true;
                                    END;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            j := a_ap_tree^[ j ].n_sa_level
                            END;
                        (*ENDWHILE*) 
                        END;
                    s_between :
                        BEGIN
                        a1constraint_cnt := a1constraint_cnt + 1;
                        IF  a1constraint_cnt > cak_max_constraints
                        THEN
                            a07_b_put_error (acv, e_too_many_constraints, 1)
                        ELSE
                            WITH a1constraint_info[ a1constraint_cnt ] DO
                                BEGIN
                                tree_index := i;
                                extcolno := -1
                                END;
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        END;
                    s_key, s_stamp :
                        IF  a1key_node = 0
                        THEN
                            BEGIN
                            IF  a_ap_tree^[ i ].n_symb = s_stamp
                            THEN
                                BEGIN
                                a1clustered := true;
                                table_attr := table_attr + [ta_cluster_key];
                                END;
                            (*ENDIF*) 
                            IF  rowid
                            THEN
                                BEGIN
                                IF  a1unique_node = 0
                                THEN
                                    a1unique_node := i;
                                (*ENDIF*) 
                                a_ap_tree^[i].n_symb    := s_rowno;
                                a_ap_tree^[i].n_subproc := cak_i_unique
                                END;
                            (* PTS 1122050 E.Z. *)
                            (*ENDIF*) 
                            IF  a1for_archive
                            THEN
                                a07_b_put_error (acv, e_invalid_tabletype,  a_ap_tree^[ i ].n_pos)
                            ELSE
                                BEGIN
&                               ifdef LONGREC
                                a1key_node := a_ap_tree^[ i ].n_sa_level;
                                REPEAT
                                    keycolcnt := succ(keycolcnt);
                                    a1key_node := a_ap_tree^[ a1key_node ].n_sa_level;
                                UNTIL
                                    a1key_node = 0;
                                (*ENDREPEAT*) 
&                               endif
&                               ifdef vers80
                                IF  a1unique_node = 0
                                THEN
                                    a1unique_node := i;
                                (*ENDIF*) 
                                a_ap_tree^[i].n_subproc := cak_i_unique
&                                     else
                                      a1key_node := a_ap_tree^[ i ].n_sa_level;
&                               endif
                                END
                            (*ENDIF*) 
                            END
                        ELSE
                            a07_b_put_error (acv, e_key_not_allowed,
                                  a_ap_tree^[ i ].n_pos);
                        (*ENDIF*) 
                    s_index :
                        IF  a1temp_table (* PTS 1118863 M.Ki. *)
                        THEN
                            a07_b_put_error (acv,
                                  e_not_allowed_in_temp_table,
                                  a_ap_tree^[ i ].n_pos)
                        ELSE
                            IF  a1unique_node = 0
                            THEN
                                a1unique_node := i;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    OTHERWISE
                        IF  a1temp_table
                        THEN
                            a07_b_put_error (acv,
                                  e_not_allowed_in_temp_table,
                                  a_ap_tree^[ i ].n_pos)
                        ELSE
                            IF  a1foreign_key_node = 0
                            THEN
                                a1foreign_key_node := i
                            (*ENDIF*) 
                        (*ENDIF*) 
                    END;
                (*ENDCASE*) 
                j := i;
                i := a_ap_tree^[ i ].n_lo_level
            UNTIL
                (i = 0) OR
                (a_returncode <> 0)
            (*ENDREPEAT*) 
        ELSE
            a1ti := j;
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            IF  (colcount = 0) AND (a_is_ddl = ddl_create_as_select)
            THEN (* insert dummy entries into syntax tree *)
                BEGIN
                a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc := a14;
                a_scv.sc_symb     := s_identifier;
                a_scv.sc_sypos    := 0;
                a_scv.sc_sylength := 0;
                FOR i := 1 TO a_p_arr2.pbasep^.sresult.bmaxcol - 1 DO
                    BEGIN
                    a01_put_node (acv, curr_n);
                    a_ap_tree^[j].n_lo_level := a_scv_index;
                    j := curr_n
                    END;
                (*ENDFOR*) 
                END;
            (*ENDIF*) 
            IF  keyexist AND (a1key_node <> 0)
            THEN
                a07_b_put_error (acv,
                      e_key_not_allowed, a_ap_tree^[ a1key_node ].n_pos)
            ELSE
                a11init_baserecord (acv, a11v);
            (*ENDIF*) 
            IF  rowid
            THEN
                a1key_node := 0;
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                a1inpkey      := true;
                a1keypos      := 1;
                a_p_arr1.pbasep^.sbase.bsample     := sample;
                a_p_arr1.pbasep^.sbase.battributes := table_attr;
&               ifdef vers80
                a11put_systemkey (acv, a11v);
                keycolcnt := 1;
&               else
                IF  NOT keyexist AND (a1key_node = 0)
                THEN
                    BEGIN
                    a11put_systemkey (acv, a11v);
                    keycolcnt := 1;
                    IF  rowid
                    THEN
                        WITH a_p_arr1.pbasep^.sbase,
                             bcolumn[blastkeyind]^ DO
                            IF  g01unicode (* PTS 1134727 *)
                            THEN
                                BEGIN
                                ccolumnn[2]  := 'R';
                                ccolumnn[4]  := 'O';
                                ccolumnn[6]  := 'W';
                                ccolumnn[8]  := 'I';
                                ccolumnn[10]  := 'D';
                                ccolumnn_len := chr(10)
                                END
                            ELSE
                                BEGIN
                                ccolumnn[1]  := 'R';
                                ccolumnn[2]  := 'O';
                                ccolumnn[3]  := 'W';
                                ccolumnn[4]  := 'I';
                                ccolumnn[5]  := 'D';
                                ccolumnn_len := chr(5)
                                END;
                            (*ENDIF*) 
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    END
                ELSE
                    a_p_arr1.pbasep^.sbase.btablekind := twithkey;
                (*ENDIF*) 
&               endif
                coldef_ti := a1ti;
                REPEAT
                    IF  (a_p_arr1.pbasep^.sbase.bmaxcol >= MAX_COL_PER_TAB_GG00)
                        AND
                        (a_ap_tree^[a1ti].n_symb = s_identifier)
                    THEN
                        a07_b_put_error (acv,
                              e_too_many_columns, 1)
                    ELSE
                        BEGIN
&                       ifdef LONGREC
                        IF  (a_p_arr1.pbasep^.sbase.bmaxcol = keycolcnt) AND
                            (NOT a1systable)                             AND
                            (a1tablen <> a01_i_sysmessages)              AND
                            (a1tablen <> a01_i_sysparseid)               AND
                            (a1tablen <> a01_i_sysmondata)               AND
                            (a1tablen <> a01_i_sysmonitor)               AND
                            (a1tablen <> a01_i_syscmd_analyze)           AND
                            (a1tablen <> a01_i_sysdata_analyze)          AND
                            (a1tablen <> a01_i_sysupdstatwanted)         AND
                            (a_init_ddl <> ddl_restore_schema)           AND
                            NOT (a_is_ddl = ddl_create_as_select)
                        THEN
                            ak11my_special_column (acv, a11v);
&                       endif
                        (*ENDIF*) 
                        WITH a_ap_tree^[ a1ti ] DO
                            BEGIN
                            tlo := n_lo_level;
                            i   := a1ti;
                            IF  n_symb = s_identifier
                            THEN
                                a11one_column_def (acv, a11v);
                            (*ENDIF*) 
                            a1ti := tlo;
                            END;
                        (*ENDWITH*) 
&                       ifdef LONGREC
                        IF  (a1ti = 0) AND
                            (a_p_arr1.pbasep^.sbase.bmaxcol = keycolcnt) AND
                            (NOT a1systable)                             AND
                            (a1tablen <> a01_i_sysmessages)              AND
                            (a1tablen <> a01_i_sysparseid)               AND
                            (a1tablen <> a01_i_sysmondata)               AND
                            (a1tablen <> a01_i_sysmonitor)               AND
                            (a1tablen <> a01_i_syscmd_analyze)           AND
                            (a1tablen <> a01_i_sysdata_analyze)          AND
                            (a1tablen <> a01_i_sysupdstatwanted)         AND
                            (a_init_ddl <> ddl_restore_schema)           AND
                            NOT (a_is_ddl = ddl_create_as_select)
                        THEN
                            ak11my_special_column (acv, a11v);
&                       endif
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                UNTIL
                    (a1ti = 0) OR (a_returncode <> 0);
                (*ENDREPEAT*) 
                IF  ( ta_cluster_key in table_attr )
                THEN
                    a11AddClusterUniqueColumn (acv, acv.a_p_arr1.pbasep^.sbase);
                (*ENDIF*) 
                IF  (a_is_ddl = ddl_create_as_select) AND
                    (a_returncode = 0)
                THEN
                    BEGIN
                    IF  a_p_arr1.pbasep^.sbase.btablekind = twithkey
                    THEN
                        offset := 0
                    ELSE
                        offset := 1;
                    (*ENDIF*) 
                    IF  a_p_arr1.pbasep^.sbase.bmaxcol - offset <
                        a_p_arr2.pbasep^.sresult.bmaxcol - 1
                    THEN
                        a07_b_put_error (acv, e_too_few_columns,
                              a_ap_tree^[ i ].n_pos);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  (a1key_node > 0) AND (a_returncode = 0)
                THEN
                    BEGIN
                    a1keypos := 1;
                    i        := a1key_node;
                    j := 1;
&                   ifdef TRACE
                    t01int4(ak_sem, 'a1key_node  ', a1key_node);
&                   endif
                    REPEAT
                        WITH a_ap_tree^[ i ] DO
                            IF  n_pos > 0
                            THEN
                                BEGIN
                                a05_identifier_get (acv, i,
                                      sizeof (key_col), key_col);
                                a07_nb_put_error (acv,
                                      e_unknown_columnname,
                                      n_pos, key_col);
                                i := 0
                                END
                            ELSE
                                BEGIN
                                i           := n_sa_level;
                                col         := n_subproc;
                                n_lo_level  := 0;
                                WITH a_p_arr1.pbasep^.sbase.
                                     bcolumn[col]^ DO
                                    BEGIN
                                    ccolstack.epos := a1keypos;
                                    a1keypos := a1keypos + cinoutlen
                                    END;
                                (*ENDWITH*) 
                                END;
                            (*ENDIF*) 
                        (*ENDWITH*) 
                    UNTIL
                        i = 0;
                    (*ENDREPEAT*) 
                    END;
                (*ENDIF*) 
                IF  a_returncode = 0
                THEN
                    BEGIN
                    a1ti        := coldef_ti;
                    a1sort      := true;
                    a1createtab := true;
                    a11end_create_table (acv, a11v);
                    IF  a_link_pending
                    THEN
                        a25pending_link (acv, a1tablen);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
t01name(ak_sem, '<ak11create_table ');
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a11domain_usage (
            VAR acv             : tak_all_command_glob;
            VAR a11v            : tak_a11_glob;
            VAR domain_owner_id : tgg00_Surrogate;
            VAR domain_name     : tsp00_KnlIdentifier;
            VAR domain_id       : tgg00_Surrogate;
            colno               : integer);
 
VAR
      b_err         : tgg00_BasisError;
      required_len  : integer;
      usageref_buf  : tak_sysbufferaddress;
      usage_sysk    : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a11v, a_p_arr1.pbasep^.sbase DO
    BEGIN
    (* store table in domain reference info *)
    a16put_usage_def (acv, domain_id, bsurrogate, btablekind);
    IF  a_returncode = 0
    THEN
        BEGIN
        usage_sysk             := a01defaultkey;
        usage_sysk.stableid    := bsurrogate;
        usage_sysk.sentrytyp   := cak_edomainusage;
        usage_sysk.slinkage[1] := chr (colno DIV 256);
        usage_sysk.slinkage[2] := chr (colno MOD 256);
        required_len           := sizeof (tak_col_uses_dom);
        a10_nil_get_sysinfo (acv, usage_sysk, d_release,
              required_len, usageref_buf, b_err);
        IF  b_err = e_ok
        THEN
            WITH usageref_buf^.scol_uses_dom DO
                BEGIN
                cud_segmentid := bsegmentid;
                cud_owner     := domain_owner_id;
                cud_name      := domain_name;
                cud_filler1   := cgg_zero_c2;
                a10add_sysinfo (acv, usageref_buf, b_err);
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak11dupl_col_error (
            VAR acv          : tak_all_command_glob;
            coldef_ti        : integer;
            VAR dupl_colname : tsp00_KnlIdentifier);
 
VAR
      found   : boolean;
      colname : tsp00_KnlIdentifier;
 
BEGIN
found := false;
WITH acv DO
    IF  (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc = a11) OR
        (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc = a13)
    THEN
        BEGIN
        found := a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc <> a11;
        WHILE coldef_ti <> 0 DO
            BEGIN
            IF  (a_ap_tree^[ coldef_ti ].n_proc = no_proc) AND
                (a_ap_tree^[ coldef_ti ].n_symb = s_identifier)
            THEN
                BEGIN
                a05_identifier_get (acv, coldef_ti,
                      sizeof (colname), colname);
                IF  colname = dupl_colname
                THEN
                    IF  found
                    THEN
                        BEGIN
                        a07_nb_put_error (acv, e_duplicate_columnname,
                              a_ap_tree^[coldef_ti].n_pos, dupl_colname);
                        coldef_ti := 0
                        END
                    ELSE
                        found := true;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                coldef_ti := a_ap_tree^[ coldef_ti ].n_lo_level;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
a07_b_put_error (acv, e_duplicate_columnname, 1)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a11condition (
            VAR acv           : tak_all_command_glob;
            VAR a11v          : tak_a11_glob;
            constraint_id     : integer;
            end_pos           : tsp00_Int4);
 
VAR
      old_range      : boolean;
      b_err          : tgg00_BasisError;
      init_ex_kind   : tak_execution_kind;
      is_ddl         : tak_ddl_descriptor;
      pos            : integer;
      i              : integer;
      jx             : integer;
      min            : integer;
      min_i          : integer;
      movelen        : integer;
      required_len   : integer;
      p1_pos         : integer;
      domain_pos     : integer;
      aux            : tak_vcolumndescription;
      syskey         : tgg00_SysInfoKey;
      dmli           : tak_dml_info;
 
BEGIN
WITH acv, a11v  DO
    IF  a_returncode = 0
    THEN
        BEGIN
&       IFDEF TRACE
        t01int4 (ak_sem, 'a1ti        ', a1ti);
&       ENDIF
        old_range := false;
        IF  a_is_ddl = ddl_create_domain
        THEN
            BEGIN
            p1_pos := 1;
            IF  a1ti <> 0
            THEN
                domain_pos := a_ap_tree^[ a1ti ].n_pos
            ELSE
                domain_pos := 1;
            (*ENDIF*) 
&           IFDEF TRACE
            t01int4 (ak_sem, 'domain_pos  ', domain_pos);
&           ENDIF
            end_pos := a_cmd_part^.sp1p_buf_len
            END
        ELSE
            BEGIN
            p1_pos     := a_ap_tree^[a1ti].n_pos;
            domain_pos := 1;
            (* end position is stored in info node *)
            IF  end_pos <= 0
            THEN
                end_pos := a_ap_tree^[a1ti+1].n_pos
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        (* PTS 1105437 GG *)
        WHILE a01is_whitespace_char( a_cmd_part^.sp1p_buf, end_pos ) DO
            end_pos := end_pos - a01char_size;
        (*ENDWHILE*) 
        WHILE a01is_whitespace_char( a_cmd_part^.sp1p_buf, p1_pos ) DO
            p1_pos := p1_pos + a01char_size;
        (*ENDWHILE*) 
&       IFDEF TRACE
        t01int4 (ak_sem, 'domain_pos  ', domain_pos);
        t01int4 (ak_sem, 'p1_pos      ', p1_pos);
        t01int4 (ak_sem, 'end_pos     ', end_pos);
        t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, p1_pos, end_pos);
&       ENDIF
        IF  a1ti <> 0
        THEN
            BEGIN
            old_range := a_ap_tree^[ a1ti ].n_proc = a64;
            a1ti      := a_ap_tree^[ a1ti ].n_lo_level
            END;
        (*ENDIF*) 
        a54_dml_init (acv, dmli, false);
        WITH dmli DO
            BEGIN
            d_sparr       := a_p_arr1;
            d_cntfromtab  := 1;
            d_acttabindex := 1;
            WITH d_tabarr^[ 1 ] DO
                BEGIN
                ospecs_needed := ons_only_tablename;
                oall_priv     := true;
                ouser         := a_curr_user_name;
                otable        := a1tablen;
                oreference    := a01_il_b_identifier;
                END;
            (*ENDWITH*) 
            END;
        (*ENDWITH*) 
        syskey := a_p_arr1.pbasep^.syskey;
        IF  a1temp_table
        THEN
            syskey.sentrytyp := cak_etempviewdesc
        ELSE
            syskey.sentrytyp := cak_eviewdesc;
        (*ENDIF*) 
        IF  a_is_ddl = ddl_create_trigger
        THEN
            syskey.slinkage[ 1 ] := chr(255)
        ELSE
            syskey.slinkage[ 1 ] := chr(constraint_id DIV 256);
        (*ENDIF*) 
        syskey.slinkage[ 2 ] := chr (constraint_id MOD 256);
        IF  a_is_ddl <> ddl_create_trigger
        THEN
            a10_key_del (acv, syskey);
        (*ENDIF*) 
        required_len := sizeof (tak_viewdescrecord);
        a10_nil_get_sysinfo (acv, syskey, d_fix,
              required_len, dmli.d_linkbuf, b_err);
        IF  b_err = e_ok
        THEN
            WITH dmli.d_linkbuf^.sviewdesc DO
                BEGIN
                vdesc_cnt   := 0;
                vdesc_next  := false;
                vdesc_fill1 := false;
                vdesc_fill2 := 0;
                vsegmentid  := a_p_arr1.pbasep^.sbase.bsegmentid
                END
            (*ENDWITH*) 
        ELSE
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        IF  (acv.a_returncode = 0) AND (a1ti <> 0)
        THEN
            BEGIN
            a06a_mblock_init (acv, m_select, mm_nil, b01niltree_id);
            a_rowno_allowed := false;
            init_ex_kind    := a_ex_kind;
            a_ex_kind       := parsing_executing;
            is_ddl          := a_is_ddl;
            IF  a_is_ddl = ddl_create_as_select
            THEN
                a_is_ddl := ddl_create_table; (* force viewdesc info (create table as select ) *)
            (*ENDIF*) 
            a65_search_condition (acv, dmli, a1ti);
            a_is_ddl  := is_ddl;
            a_ex_kind := init_ex_kind
            END;
        (*ENDIF*) 
        IF  (acv.a_returncode = 0) AND (a1ti <> 0) AND
            (acv.a_is_ddl <> ddl_create_trigger)
        THEN
            ak11store_qualification (acv, a11v,
                  dmli.d_linkbuf^, old_range, end_pos);
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            WITH dmli.d_linkbuf^, sviewdesc DO
                BEGIN
&               IFDEF TRACE
                t01int4 (ak_sem, 'vdesc_cnt   ', vdesc_cnt);
                t01int4 (ak_sem, 'oldrange    ', ord(old_range));
&               ENDIF
                IF  NOT old_range
                THEN
                    BEGIN
                    (* Copy defintion string without column   *)
                    (* names into catalog, store amount moved *)
                    (* before each column to be able to       *)
                    (* reconstruct the original defintion     *)
                    ;
                    (* sort descriptions by position in sql statement *)
                    FOR i := 1 TO vdesc_cnt - 1 DO
                        BEGIN
                        min := csp_maxint2;
                        FOR jx := i TO vdesc_cnt DO
                            IF  vdescription[jx].vn_pos < min
                            THEN
                                BEGIN
                                min   := vdescription[jx].vn_pos;
                                min_i := jx
                                END;
                            (*ENDIF*) 
                        (*ENDFOR*) 
                        IF  min_i <> i
                        THEN
                            BEGIN
                            aux                 := vdescription[i];
                            vdescription[i]     := vdescription[min_i];
                            vdescription[min_i] := aux
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDFOR*) 
                    i   := 1;
                    pos := cak_viewdesc_offset +
                          vdesc_cnt * mxak_vcolumndesc + 3;
                    WHILE i <= vdesc_cnt DO
                        BEGIN
&                       IFDEF TRACE
                        t01int4 (ak_sem, 'vn_pos      ',
                              vdescription[ i ].vn_pos);
                        t01int4 (ak_sem, 'vfromextcol ',
                              vdescription[ i ].vfromextcolno);
                        t01int4 (ak_sem, 'p1_pos      ', p1_pos);
&                       ENDIF
                        a_scv.sc_newpos := vdescription[i].vn_pos;
&                       IFDEF TRACE
                        t01moveobj (ak_sem, a_cmd_part^.sp1p_buf,
                              1, a_scv.sc_newpos+39);
&                       ENDIF
                        a01_next_symbol (acv);
                        IF  a_scv.sc_double_quote > 0
                        THEN
                            vdescription[i].vn_pos :=
                                  vdescription[i].vn_pos + a01char_size;
                        (*ENDIF*) 
                        movelen := vdescription[ i ].vn_pos - p1_pos;
&                       IFDEF TRACE
                        t01int4 (ak_sem, 'vn_pos      ',
                              vdescription[ i ].vn_pos);
                        t01int4 (ak_sem, 'p1_pos      ', p1_pos);
                        t01int4 (ak_sem, 'movelen     ', movelen);
&                       ENDIF
                        vdescription[ i ].vfromtabno := movelen;
                        IF  movelen > 0
                        THEN
                            BEGIN
&                           IFDEF TRACE
                            t01moveobj (ak_sem, a_cmd_part^.sp1p_buf,
                                  p1_pos, p1_pos + movelen-1);
&                           ENDIF
                            SAPDB_PascalMove ('VAK11 ',   1,    
                                  acv.a_cmd_part^.sp1p_buf_size,
                                  sizeof (dmli.d_linkbuf^),
                                  @acv.a_cmd_part^.sp1p_buf, p1_pos,
                                  @dmli.d_linkbuf^, pos, movelen,
                                  acv.a_returncode);
                            pos := pos + movelen
                            END;
                        (*=-=-=- skip column name =-=-=-=*)
                        (*ENDIF*) 
                        IF  a_scv.sc_double_quote > 0
                        THEN
                            p1_pos := a_scv.sc_newpos - a01char_size
                        ELSE
                            p1_pos := a_scv.sc_newpos;
                        (*ENDIF*) 
                        vdescription[i].vn_pos := 0;
                        i := i + 1
                        END;
                    (*ENDWHILE*) 
                    END
                ELSE (* old_range *)
                    BEGIN
                    vdescription[ 1 ].vfromtabno := 0;
                    pos        := cak_viewdesc_offset +
                          mxak_vcolumndesc + 3;
                    IF  g01unicode
                    THEN
                        IF  domain_pos = 1
                        THEN
                            domain_pos := 0
                        ELSE
                            domain_pos := domain_pos - 2
                        (*ENDIF*) 
                    ELSE
                        domain_pos := domain_pos - 1;
                    (*ENDIF*) 
                    IF  a_is_ddl <> ddl_create_domain
                    THEN
                        p1_pos := p1_pos - a01char_size
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                vdescription [ vdesc_cnt+1 ].vfromtabno := domain_pos;
&               IFDEF TRACE
                t01int4 (ak_sem, 'pos         ', pos);
                t01int4 (ak_sem, 'end_pos     ', end_pos);
                t01int4 (ak_sem, 'p1_pos      ', p1_pos);
&               ENDIF
                SAPDB_PascalMove ('VAK11 ',   2,    
                      acv.a_cmd_part^.sp1p_buf_size,
                      sizeof (dmli.d_linkbuf^),
                      @acv.a_cmd_part^.sp1p_buf, p1_pos,
                      @dmli.d_linkbuf^, pos, end_pos - p1_pos + 1, b_err);
                b_sl := pos + end_pos - p1_pos;
                IF  b_err = e_ok
                THEN
                    a10_add_repl_sysinfo (acv, dmli.d_linkbuf, a1add_rec, b_err);
                (*ENDIF*) 
                IF  b_err <> e_ok
                THEN
                    a07_b_put_error (acv, b_err, 1)
                ELSE
                    a10_rel_sysinfo (acv, dmli.d_linkbuf^.syskey)
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        a54_dml_finalize( dmli, acv.a_transinf.tri_trans );
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak11check_clause (
            VAR acv  : tak_all_command_glob;
            VAR a11v : tak_a11_glob);
 
VAR
      user_def_name   : boolean;
      b_err           : tgg00_BasisError;
      buf             : tak_sysbufferaddress;
      i               : integer;
      cnt             : integer;
      constraint_cnt  : integer;
      len             : integer;
      startpos        : integer;
      domainname      : tsp00_KnlIdentifier;
      owner           : tsp00_KnlIdentifier;
      sysk            : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a11v DO
    BEGIN
    cnt                := a_p_arr1.pbasep^.sbase.bnamed_constr;
    constraint_cnt     := 0;
    a1constraint_index := 1;
&   IFDEF TRACE
    t01int4 (ak_sem, 'constraint_c', a1constraint_cnt);
&   ENDIF
    WHILE (a1constraint_index <= a1constraint_cnt) AND
          (a_returncode = 0) DO
        BEGIN
&       IFDEF TRACE
        t01int4 (ak_sem, 'tree_index  ',
              a1constraint_info[ a1constraint_index ].tree_index);
        t01int4 (ak_sem, 'extcolno    ',
              a1constraint_info[ a1constraint_index ].extcolno);
&       ENDIF
        a1domainbuf   := NIL;
        user_def_name := false;
        IF  a1constraint_info[ a1constraint_index ].tree_index > 0
        THEN
            BEGIN
            a1constraint_name := a01_il_b_identifier;
            a1ti              := a_ap_tree^ [ a1constraint_info[
                  a1constraint_index ].tree_index ].n_sa_level;
&           IFDEF TRACE
            t01int4 (ak_sem, 'a1ti        ', a1ti);
&           ENDIF
            WITH a_ap_tree^[ a1ti ] DO
                IF  (n_symb = s_identifier) OR (n_symb = s_columnname)
                THEN
                    BEGIN
                    user_def_name := n_symb = s_identifier;
                    a05_identifier_get (acv, a1ti,
                          sizeof (a1constraint_name), a1constraint_name);
                    a1ti := n_sa_level
&                         IFDEF TRACE
                          ;
                    t01int4 (ak_sem, 'a1ti        ', a1ti);
&                   ENDIF
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
            END
        ELSE
            BEGIN
            a1ti := -a1constraint_info[ a1constraint_index ].tree_index;
            a12get_domain (acv, owner,
                  domainname, a1ti, a1sysbuf, a1domainbuf);
            a1constraint_name := domainname
            END;
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            REPEAT
                BEGIN
                IF  a1constraint_name = a01_il_b_identifier
                THEN
                    BEGIN
                    constraint_cnt    := constraint_cnt + 1;
                    IF  constraint_cnt > 99
                    THEN
                        len := 3
                    ELSE
                        IF  constraint_cnt > 9
                        THEN
                            len := 2
                        ELSE
                            len := 1;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    a061assign_colname ('CONSTRAINT        ',
                          a1constraint_name);
                    startpos := 10;
                    i        := constraint_cnt;
                    WHILE i > 0 DO
                        BEGIN
                        a1constraint_name [ startpos+len ] :=
                              chr (i MOD 10 + ord ('0'));
                        len := len - 1;
                        i   := i DIV 10
                        END;
                    (*ENDWHILE*) 
                    IF  g01unicode
                    THEN
                        a01setl_identifier (a1constraint_name,
                              a1constraint_name);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                cnt  := cnt + 1;
                IF  cnt > cak_max_constraints
                THEN
                    a07_b_put_error (acv, e_too_many_constraints, 1)
                ELSE
                    BEGIN
                    sysk := a_p_arr1.pbasep^.syskey;
                    IF  a1temp_table
                    THEN
                        sysk.sentrytyp := cak_etmpconstraintname
                    ELSE
                        sysk.sentrytyp := cak_econstraintname;
                    (*ENDIF*) 
                    sysk.sidentifier   := a1constraint_name;
                    sysk.skeylen       :=
                          mxak_standard_sysk + sizeof (sysk.sidentifier);
                    a10_nil_get_sysinfo (acv, sysk, d_release,
                          sizeof (tak_constraintnamerecord), buf, b_err);
                    IF  b_err = e_ok
                    THEN
                        WITH buf^.sconstrname DO
                            BEGIN
                            cnsegmentid :=
                                  a_p_arr1.pbasep^.sbase.bsegmentid;
                            cnid        := cnt;
                            a10add_sysinfo (acv, buf, b_err)
                            END;
                        (*ENDWITH*) 
&                   IFDEF TRACE
                    (*ENDIF*) 
                    t01basis_error (ak_sem, 'b_err       ', b_err);
&                   ENDIF
                    IF  b_err <> e_ok
                    THEN
                        IF  b_err = e_duplicate_sysinfo
                        THEN
                            IF  user_def_name
                            THEN
                                a07_b_put_error (acv, e_duplicate_name, 1)
                            ELSE
                                BEGIN
                                a1constraint_name := a01_il_b_identifier;
                                cnt               := cnt - 1
                                END
                            (*ENDIF*) 
                        ELSE
                            a07_b_put_error (acv, b_err, 1)
                        (*ENDIF*) 
                    ELSE
                        BEGIN
                        IF  a1domainbuf = NIL
                        THEN
                            a11condition (acv, a11v, cnt, cak_is_undefined)
                        ELSE
                            WITH a1constraint_info[ a1constraint_index ] DO
                                ak11domain_constraint (acv,
                                      a11v, cnt, extcolno);
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            UNTIL
                (b_err <> e_duplicate_sysinfo) OR (a_returncode <> 0);
            (*ENDREPEAT*) 
        (*ENDIF*) 
        a1constraint_index := a1constraint_index + 1;
        END;
    (*ENDWHILE*) 
    a_p_arr1.pbasep^.sbase.bnamed_constr := cnt
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak11domain_constraint (
            VAR acv       : tak_all_command_glob;
            VAR a11v      : tak_a11_glob;
            constraint_id : integer;
            extcolno      : integer);
 
VAR
      b_err       : tgg00_BasisError;
      i           : integer;
      j           : integer;
      offset      : integer;
      st_ptr      : integer;
      col_ptr     : tak00_colinfo_ptr;
      oldb        : tak_sysbufferaddress;
      constrbuf   : tak_sysbufferaddress;
      descbuf     : tak_sysbufferaddress;
      newkey      : tgg00_SysInfoKey;
      oldkey      : tgg00_SysInfoKey;
      sysk        : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a11v DO
    BEGIN
    oldkey           := a01defaultkey;
    oldkey.stableid  := a1sysbuf^.sdomainref.dsurrogate;
    oldkey.sentrytyp := cak_eviewdesc;
    a10get_sysinfo (acv,
          oldkey, d_fix, oldb, b_err);
    IF  b_err = e_ok
    THEN
        BEGIN
        sysk           := oldkey;
        sysk.sentrytyp := cak_econstraint;
        a10get_sysinfo (acv,
              sysk, d_release, constrbuf, b_err)
        END;
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        BEGIN
        newkey           := oldkey;
        newkey.stableid  := a1tableid;
        newkey.slinkage[1] := chr(constraint_id DIV 256);
        newkey.slinkage[2] := chr(constraint_id MOD 256);
        a10_nil_get_sysinfo (acv, newkey, d_fix,
              oldb^.b_sl, descbuf, b_err);
        a10_rel_sysinfo (acv, oldkey)
        END;
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        BEGIN
        SAPDB_PascalMove ('VAK11 ',   3,    
              sizeof (oldb^.sviewdesc), sizeof (descbuf^.sviewdesc),
              @oldb^, cak_sysbufferoffset + 3,
              @descbuf^, cak_sysbufferoffset + 3,
              oldb^.b_sl - cak_sysbufferoffset - 2, b_err);
        descbuf^.sconstraint.csegmentid :=
              a_p_arr1.pbasep^.sbase.bsegmentid;
        descbuf^.b_sl := oldb^.b_sl;
        WITH descbuf^.sviewdesc DO
            BEGIN
            offset := vdescription[ vdesc_cnt+1 ].vfromtabno -1;
&           IFDEF TRACE
            t01int4 (ak_sem, 'offset      ', offset);
&           ENDIF
            FOR j := 1 TO vdesc_cnt DO
                WITH vdescription[ j ] DO
                    BEGIN
                    vfromextcolno := extcolno;
                    IF  (j = 1) AND NOT constrbuf^.sconstraint.coldrange
                    THEN
                        vfromtabno := vfromtabno - offset;
&                   IFDEF TRACE
                    (*ENDIF*) 
                    t01int4 (ak_sem, 'vfromtabno  ', vfromtabno);
&                   ENDIF
                    END;
                (*ENDWITH*) 
            (*ENDFOR*) 
            j := cak_viewdesc_offset +
                  vdesc_cnt * mxak_vcolumndesc + 2;
            SAPDB_PascalOverlappingMove ('VAK11 ',   4,    
                  sizeof (descbuf^.sviewdesc), sizeof (descbuf^.sviewdesc),
                  @descbuf^, j + offset + 1,
                  @descbuf^, j + 1, descbuf^.b_sl -j -offset, b_err);
            descbuf^.b_sl := cak_viewdesc_offset +
                  vdesc_cnt * mxak_vcolumndesc + 2 +
                  descbuf^.b_sl - j - offset;
            vdescription[ vdesc_cnt+1 ].vfromtabno := 1
            END;
        (*ENDWITH*) 
        IF  b_err = e_ok
        THEN
            a10add_sysinfo (acv, descbuf, b_err)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        WITH constrbuf^.sconstraint DO
            BEGIN
            a06extcolno (a_p_arr1.pbasep^.sbase, extcolno, col_ptr);
            a06a_mblock_init (acv, m_select, mm_nil, b01niltree_id);
            st_ptr := cstackstart;
            FOR i := 1 TO cstack_cnt DO
                BEGIN
                IF  cstack[st_ptr].etype = st_varcol
                THEN
                    BEGIN
                    a_mblock.mb_st^ [i]    := col_ptr^.ccolstack;
                    a_mblock.mb_st^[i].eop := cstack[st_ptr].eop
                    END
                ELSE
                    a_mblock.mb_st^ [i] := cstack[st_ptr];
                (*ENDIF*) 
                st_ptr := st_ptr + 1
                END;
            (*ENDFOR*) 
            a_mblock.mb_qual^.mqual_pos   := 1;
            a_mblock.mb_qual^.mqual_cnt   := cstack_cnt;
            a_mblock.mb_qual^.mfirst_free := cstack_cnt + 1;
            a_mblock.mb_data_len          := cgg_rec_key_offset +
                  constrbuf^.b_sl - cvalue_pos + 1;
            SAPDB_PascalMove ('VAK11 ',   5,    
                  sizeof (constrbuf^),
                  a_mblock.mb_data_size,
                  @constrbuf^, cvalue_pos,
                  @a_mblock.mb_data^.mbp_buf,
                  cgg_rec_key_offset + 1,
                  a_mblock.mb_data_len - cgg_rec_key_offset,
                  a_returncode);
            ak11store_qualification (acv, a11v,
                  descbuf^, coldrange, 1);
            a10_rel_sysinfo (acv, newkey)
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak11store_qualification (
            VAR acv            : tak_all_command_glob;
            VAR a11v           : tak_a11_glob;
            VAR constraint_def : tak_systembuffer;
            old_range          : boolean;
            error_pos          : integer);
 
VAR
      one_col_constraint : boolean;
      res                : tsp00_LcompResult;
      b_err              : tgg00_BasisError;
      i                  : integer;
      stpointer          : integer;
      id_len             : integer;
      oid_ptr            : ^tak_oldidentifier;
      col_ptr            : tak00_colinfo_ptr;
      constraintbuf      : tak_sysbufferaddress;
      sysk               : tgg00_SysInfoKey;
      ix                 : integer;
      iy                 : integer;
      iz                 : integer;
 
BEGIN
WITH acv, a11v DO
    BEGIN
&   IFDEF TRACE
    t01messblock (ak_sem, 'store qual  ', a_mblock);
    t01int4 (ak_sem, 'old_range   ', ord (old_range));
&   ENDIF
    sysk := constraint_def.syskey;
    IF  a1temp_table
    THEN
        sysk.sentrytyp := cak_etempconstraint
    ELSE
        sysk.sentrytyp := cak_econstraint;
    (*ENDIF*) 
    a10_key_del (acv, sysk);
    a10_nil_get_sysinfo (acv, sysk,
          d_release, mxak_constraintrec, constraintbuf, b_err);
    IF  b_err = e_ok
    THEN
        WITH constraintbuf^, sconstraint,
             constraint_def.sviewdesc, a_mblock, mb_qual^ DO
            BEGIN
            coldrange   := old_range;
            csegmentid  := a_p_arr1.pbasep^.sbase.bsegmentid;
            id_len      := a061identifier_len (a1constraint_name);
            oid_ptr     := @a1constraint_name;
            ccname      := oid_ptr^;
            cstackstart := 1;
            IF  id_len > sizeof (ccname)
            THEN
                BEGIN
                csuffixlen  := id_len - sizeof (ccname);
                SAPDB_PascalMove ('VAK11 ',   6,    
                      sizeof (a1constraint_name), sizeof (csuffix),
                      @a1constraint_name, sizeof (ccname) + 1,
                      @csuffix, 1, csuffixlen, b_err);
                cstackstart := (csuffixlen - 1) DIV sizeof (cstack[1]) + 2;
                END
            ELSE
                csuffixlen := 0;
            (*ENDIF*) 
            ccolset    := [  ];
            IF  old_range
            THEN
                BEGIN
                ccolset := [ vdescription[ 1 ].vfromextcolno ];
                one_col_constraint := true;
                IF  mb_st^ [mqual_cnt].eop in [op_between, op_not_between]
                THEN
                    BEGIN
                    ix := -1;
                    iy := 0;
                    iz := mqual_cnt;
                    WHILE (iz > 0) DO
                        IF  mb_st^ [iz].etype = st_op
                        THEN
                            iz := pred(iz)
                        ELSE
                            IF  (ix = -1)
                            THEN
                                BEGIN
                                ix := mqual_cnt - iz;
                                iz := pred(iz);
                                END
                            ELSE
                                BEGIN
                                iy := mqual_cnt - iz;
                                iz := 0;
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDWHILE*) 
                    s30cmp (mb_data^.mbp_buf,
                          mb_st^ [mqual_cnt-iy].epos,
                          mb_st^ [mqual_cnt-iy].elen_var,
                          mb_data^.mbp_buf,
                          mb_st^ [mqual_cnt-ix].epos,
                          mb_st^ [mqual_cnt-ix].elen_var,
                          res);
                    IF  res = l_greater
                    THEN
                        a07_b_put_error (acv,
                              e_invalid_range, error_pos)
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                one_col_constraint := false;
                IF  vdesc_cnt > 0
                THEN
                    BEGIN
                    one_col_constraint := true;
                    FOR i := 1 TO vdesc_cnt DO
                        BEGIN
                        IF  (i > 1) AND one_col_constraint
                        THEN
                            one_col_constraint :=
                                  vdescription[ 1 ].vfromextcolno =
                                  vdescription[ i ].vfromextcolno;
                        (*ENDIF*) 
                        ccolset := ccolset +
                              [ vdescription[ i ].vfromextcolno ];
                        END;
                    (*ENDFOR*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            b_sl       := cak_sysbufferoffset +
                  8 + sizeof (ccolset) + sizeof (ccname) + 4 +
                  (cstackstart - 1) * STACK_ENTRY_MXGG00;
            stpointer  := mqual_pos;
            cstack_cnt := 0;
            cfunction  := false;
            WHILE (stpointer < mqual_pos+mqual_cnt) AND
                  (b_err = e_ok) DO
                BEGIN
                IF  cstack_cnt < cak_maxconstraintstack
                THEN
                    BEGIN
                    cstack_cnt := cstack_cnt + 1;
                    cstack[cstackstart+cstack_cnt-1] := mb_st^ [stpointer];
                    WITH mb_st^ [stpointer] DO
                        IF  (etype = st_date     ) OR
                            (etype = st_time     ) OR
                            (etype = st_timestamp) OR
                            (* PTS 1116175 E.Z. *)
                            (etype = st_utcdate) OR
                            (* PTS 1109925 E.Z. *)
                            (etype = st_utcdiff  ) OR
                            (etype = st_user     ) OR
                            (etype = st_usergroup) OR
                            (etype = st_current_schema)
                        THEN
                            cfunction := true;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    b_sl      := b_sl + STACK_ENTRY_MXGG00;
                    stpointer := succ(stpointer)
                    END
                ELSE
                    b_err := e_buffer_limit;
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            IF  b_sl + mb_data_len - cgg_rec_key_offset <=
                mxak_constraintrec
            THEN
                BEGIN
                cvalue_pos := b_sl + 1;
                SAPDB_PascalMove ('VAK11 ',   7,    
                      mb_data_size, sizeof (constraintbuf^),
                      @mb_data^.mbp_buf, cgg_rec_key_offset+1,
                      @constraintbuf^, b_sl + 1,
                      mb_data_len - cgg_rec_key_offset, b_err);
                b_sl := b_sl +
                      mb_data_len - cgg_rec_key_offset
                END
            ELSE
                b_err := e_buffer_limit
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        a10_add_repl_sysinfo (acv, constraintbuf, a1add_rec, b_err);
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        IF  b_err = e_buffer_limit
        THEN
            a07_b_put_error (acv, e_too_complicated_constr, 1)
        ELSE
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
    ELSE
        IF  one_col_constraint
        THEN
            BEGIN
            WITH constraint_def.sviewdesc DO
                i := vdescription[ 1 ].vfromextcolno;
            (*ENDWITH*) 
            a06extcolno (acv.a_p_arr1.pbasep^.sbase, i, col_ptr);
            a14constraint_check (acv, col_ptr^,
                  ord(constraint_def.syskey.slinkage[1]) * 256 +
                  ord(constraint_def.syskey.slinkage[2]), error_pos);
            IF  (a_returncode = 0) AND
                (a_is_ddl = ddl_alter_tab_add )
            THEN (* constraint containing a column added *)
                a1constraint_info[ a1constraint_index ].tree_index :=
                      ord(constraint_def.syskey.slinkage[1]) * 256 +
                      ord(constraint_def.syskey.slinkage[2]);
            (*ENDIF*) 
            END
        ELSE
            IF  a_is_ddl = ddl_alter_tab_add
            THEN
                a1constraint_info[ a1constraint_index ].tree_index :=
                      ord(constraint_def.syskey.slinkage[1]) * 256 +
                      ord(constraint_def.syskey.slinkage[2]);
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak11create_tree (
            VAR acv         : tak_all_command_glob;
            base_ptr        : tak_sysbufferaddress;
            string_cnt      : integer;
            new_long_cnt    : integer;
            is_dynamic      : boolean;
            is_nolog        : boolean;
            is_clustered    : boolean;
            is_packed       : boolean;
            for_archive     : boolean);
 
VAR
      b_err               : tgg00_BasisError;
      catalog_table       : boolean;
      createShortColFile  : boolean;
      create_file         : boolean;
      extendedFileTypeSet : tgg00_ExtendedFiletypeSet;
      m_type2             : tgg00_MessType2;
      treeid              : tgg00_FileId;
 
BEGIN
WITH acv, base_ptr^, sbase DO
    BEGIN
    catalog_table := kb560IsCatalogTable (btreeid.fileTabId_gg00);
    create_file := (btablekind <> tdb2view)
          AND NOT catalog_table;
    IF  btreeid.fileTfn_gg00 <> tfnTemp_egg00
    THEN
        a28new_statistic_info (acv, base_ptr);
    (*ENDIF*) 
    IF  create_file
    THEN
        BEGIN
        (* create BD-file representing the table *)
        bpages := (bavgrowlen * brows) DIV cak_page80percent;
        btreeid.fileLeafNodes_gg00 := bpages;
&       ifdef trace
        t01treeid (ak_sem, 'btreeid     ',
              base_ptr^.sbase.btreeid);
&       endif
        IF  (btablekind   = twithkey)
        THEN
            m_type2 := mm_nil
        ELSE
            m_type2 := mm_nokey;
        (*ENDIF*) 
        treeid := btreeid;
        IF  is_dynamic
        THEN
            treeid.fileType_gg00 := treeid.fileType_gg00 + [ftsDynamic_egg00];
        (* PTS 1117381 E.Z. *)
        (*ENDIF*) 
        IF  for_archive
        THEN
            treeid.fileType_gg00 := treeid.fileType_gg00 + [ftsArchive_egg00];
        (*ENDIF*) 
        createShortColFile  := (string_cnt > 0) AND (string_cnt > new_long_cnt);
        IF  is_packed
        THEN
            extendedFileTypeSet := [eftsRecordsPacked_egg00]
        ELSE
            extendedFileTypeSet := [];
        (*ENDIF*) 
        IF  is_clustered
        THEN
            extendedFileTypeSet := extendedFileTypeSet + [eftsClustered_egg00];
        (*ENDIF*) 
        IF  ftsTemp_egg00 in treeid.fileType_gg00
        THEN
            k54create_drop_temp_file (acv.a_transinf.tri_trans, m_create_table, treeid)
        ELSE
            k64CreateTable (acv.a_transinf.tri_trans,
                  treeid, m_type2, extendedFileTypeSet, string_cnt, createShortColFile);
        (*ENDIF*) 
        b_err := acv.a_transinf.tri_trans.trError_gg00;
        IF  b_err = e_ok
        THEN
            BEGIN
            btreeid := treeid;
            IF  a_mblock.mb_qual^.mtree.fileTfn_gg00 = tfnTemp_egg00
            THEN
                btreeid.fileRoot_gg00 := NIL_PAGE_NO_GG00;
            (*ENDIF*) 
            IF  is_nolog
                AND NOT a_progusage_add
                (* during the creation of a DBprocedure *)
                (* or a precompiler program it must be  *)
                (* possible to rollback the creation of *)
                (* a temp table (subtrans rollback)     *)
                (* even if the table is created with    *)
                (* ignore rollback                      *)
            THEN
                btreeid.fileHandling_gg00 := btreeid.fileHandling_gg00 +
                      [ hsNoLog_egg00 ]
            ELSE
                btreeid.fileHandling_gg00 := btreeid.fileHandling_gg00 -
                      [ hsNoLog_egg00 ];
            (*ENDIF*) 
            IF  (btablen^[ 1 ] = 'S') AND
                (btablen^[ 2 ] = 'Y') AND
                (btablen^[ 3 ] = 'S')
            THEN
                btreeid.fileHandling_gg00 := btreeid.fileHandling_gg00 +
                      [ hsWithoutLock_egg00 ];
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            a07_b_put_error (acv, b_err, 1);
            IF  btreeid.fileTfn_gg00 = tfnTemp_egg00
            THEN
                (* this will fail if the temp table was one of the shared *)
                (* system temp tables, but that should not matter         *)
                a101_RemoveGroupedTempFile (acv.a_transinf.tri_trans,
                      btreeid);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        btreeid.fileLeafNodes_gg00 := cgg_nil_leafnodes
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
t01name(ak_sem, '<ak11create_tree  ');
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a11drop_table  (
            VAR acv       : tak_all_command_glob;
            VAR tableid   : tgg00_Surrogate;
            tablkind      : tgg00_TableKind;
            succ_filevers : boolean);
 
CONST
      c_no_references = true;
 
BEGIN
a111drop_table (acv, tableid, tablkind, succ_filevers, true, NOT c_no_references)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a11end_create_table (
            VAR acv  : tak_all_command_glob;
            VAR a11v : tak_a11_glob);
 
CONST
      c_is_serial = true;
 
VAR
      varcolexist   : boolean;
      dupl_col      : boolean;
      catalog_table : boolean;
      init_ddl      : tak_ddl_descriptor;
      b_err         : tgg00_BasisError;
      j             : integer;
      count         : integer;
      rest_len      : integer;
      avgrowlen     : tsp00_Int4;
      stringcollen  : integer;
      varpos        : tsp00_Int2;
      serial_col    : tak00_colinfo_ptr;
      dupl_colname  : tsp00_KnlIdentifier;
 
BEGIN
WITH acv, a11v, a_p_arr1 DO
    BEGIN
    b_err := e_ok;
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  kb560IsSys1CatalogTable (pbasep^.syskey.stableid)
        THEN
            BEGIN
            catalog_table         := true;
            kb560GetSys1CatalogTreeId (pbasep^.sbase.btreeid)
            END
        ELSE
            IF  kb560IsSys2CatalogTable (pbasep^.syskey.stableid)
            THEN
                BEGIN
                catalog_table         := true;
                kb560GetSys2CatalogTreeId (pbasep^.sbase.btreeid)
                END
            ELSE
                catalog_table := false;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  a1global
        THEN
            pbasep^.sbase.bsegmentid := cak00_public_segment_id
        ELSE
            pbasep^.sbase.bsegmentid := cak00_local_segment_id;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (a_returncode = 0) AND (a1sort)
    THEN
        BEGIN
        a061sort (acv, a_p_arr1.pbasep^.sbase,
              0, dupl_col, dupl_colname);
        IF  dupl_col
        THEN
            ak11dupl_col_error (acv, a1ti, dupl_colname);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        stringcollen := 0;
        avgrowlen    := 0;
        WITH pbasep^, syskey, sbase DO
            BEGIN
            bdef_stamp := false;
            IF  a1createtab
            THEN
                BEGIN
                stringcollen := a1strcolcount *
                      (cgg04_str_col_entry_size + 1);
                blenfixedcol   := blenfixedcol + stringcollen;
                varcolexist    := (bvarcolcount = 0);
                varpos         := blenfixedcol;
                bstringcount   := a1strcolcount;
                blongvarcolcnt := a1longcharcnt;
                (*==========================================*)
                (* insert table into usertab records and    *)
                (* create file                              *)
                (*==========================================*)
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        WITH pbasep^.sbase DO
            FOR j := bfirstindex TO blastindex DO
                WITH bcolumn[ j ]^, ccolstack DO
                    BEGIN
                    IF  ctserial in ccolpropset
                    THEN
                        serial_col := bcolumn[j];
                    (*ENDIF*) 
                    IF  cdatalen = cak_is_undefined
                    THEN
                        BEGIN
                        rest_len := MAX_RECLEN_GG00 - a1reclen;
                        IF  rest_len < cak_maxfieldlength
                        THEN
                            cdatalen := rest_len + 1
                        ELSE
                            cdatalen := rest_len;
                        (*ENDIF*) 
                        IF  cdatalen > cak_maxdeffieldlength
                        THEN
                            cdatalen := cak_maxdeffieldlength;
                        (*ENDIF*) 
                        IF  cdatalen < 1
                        THEN
                            a07_b_put_error (acv,
                                  e_too_long_record, 1)
                        ELSE
                            cinoutlen := cdatalen + 1;
                        (*ENDIF*) 
                        a1reclen  := a1reclen + cinoutlen;
                        IF  cinoutlen > cak_maxfieldlength + 1
                        THEN
                            BEGIN
                            ak11dec_elen_var (acv, elen_var);
                            etype         := st_varlongchar;
                            a1longcharcnt := succ(a1longcharcnt);
                            ecolno        := a1longcharcnt;
                            bvarcolcount  := bvarcolcount - 1
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDFOR*) 
        (*ENDWITH*) 
        count := 0;
        a1default_stamp := false;
        IF  (a_is_ddl = ddl_create_table) OR
            (a_is_ddl = ddl_alter_tab_add)
        THEN
            IF  a1reclen > MAX_RECLEN_GG00
            THEN
                a_p_arr1.pbasep^.sbase.bmaxreclen := MAX_RECLEN_GG00
            ELSE
                a_p_arr1.pbasep^.sbase.bmaxreclen := a1reclen;
            (*ENDIF*) 
        (*ENDIF*) 
        WITH pbasep^.sbase DO
            BEGIN
            FOR j := bfirstindex TO blastindex DO
                WITH bcolumn[ j ]^, ccolstack DO
                    BEGIN
                    bextcolindex[cextcolno] := count;
                    count := succ(count);
                    CASE etype OF
                        st_fixkey, st_varkey :
                            avgrowlen := avgrowlen +
                                  cinoutlen;
                        st_varcol, st_varlongchar :
                            avgrowlen := avgrowlen +
                                  cinoutlen DIV 2;
                        OTHERWISE;
                        END;
                    (*ENDCASE*) 
                    IF  a1createtab
                    THEN
                        BEGIN
&                       ifdef vers80
                        IF  (etype = st_column)    AND
                            (cdatatyp <> dstra)    AND
                            (cdatatyp <> dstrb)    AND
                            (cdatatyp <> dstruni)  AND
                            (cdatatyp <> dlonga)   AND
                            (cdatatyp <> dlongb)   AND
                            (cdatatyp <> dlonguni)
                        THEN
                            ecolno := ecolno - MAX_COL_PER_TAB_GG00 + a1strcolcount;
&                       else
                        (*ENDIF*) 
                        IF  (etype = st_fixcol)    AND
                            (cdatatyp <> dstra)    AND
                            (cdatatyp <> dstrb)    AND
                            (cdatatyp <> dstruni)  AND
                            (cdatatyp <> dlonga)   AND
                            (cdatatyp <> dlongb)   AND
                            (cdatatyp <> dlonguni) AND
                            (btablekind <> tdb2view)
                        THEN
                            epos := epos + stringcollen;
&                       endif
                        (*ENDIF*) 
                        IF  catalog_table
                        THEN
                            BEGIN (* h.b. PTS 1105136 *)
                            ccolpropset := ccolpropset +
                                  [ ctcatalog ];
                            IF  etype = st_varlongchar
                            THEN
                                BEGIN
                                cdatalen  := 8080;
                                elen_var  := cdatalen + 1;
                                cinoutlen := elen_var
                                END
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDFOR*) 
            END;
        (*ENDWITH*) 
        (*==============================*)
        (* change last key to st_varkey *)
        (*==============================*)
        a11sort (a_p_arr1.pbasep^.sbase);
        IF  a1createtab
        THEN
            WITH pbasep^.sbase DO
                IF  bkeycolcount > 0
                THEN
                    bcolumn[ blastkeyind ]^.ccolstack.etype:= st_varkey;
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
        WITH pbasep^.sbase DO
            BEGIN
            bdef_stamp := a1default_stamp;
            bavgrowlen := avgrowlen + blenfixedcol-1 + cgg_rec_key_offset;
            IF  a1createtab
            THEN
                BEGIN
                brows      := cak_initrows;
                IF  bsample = cak11undef_sample
                THEN
                    BEGIN (* PTS 1137889 M.Ki. *)
                    IF  NOT a1dynamic
                    THEN
                        bsample := cak11sample_rows
                    ELSE
                        bsample := 0;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  a_returncode = 0
                THEN
                    (* PTS 1117381 E.Z. *)
                    ak11create_tree (acv, a_p_arr1.pbasep,
                          a1strcolcount, a1long_col_cnt, a1dynamic, a1nolog, a1clustered, a1ispacked, a1for_archive);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        IF  (a1constraint_cnt > 0)
            AND
            (a1createtab OR
            (a_is_ddl = ddl_create_domain )  OR
            (a_is_ddl = ddl_alter_tab_add )  OR
            (a_is_ddl = ddl_alter_tab_alter) OR
            (a_is_ddl = ddl_add_constraint))
        THEN
            ak11check_clause (acv, a11v);
        (*ENDIF*) 
        IF  (a1unique_node <> 0) AND
            (a1createtab OR (a_is_ddl = ddl_alter_tab_add))
        THEN
            a24unique_spec (acv, a1unique_node);
        (*ENDIF*) 
        IF  a1serial_node <> 0
        THEN
            BEGIN
            IF  a1serial_node > 0
            THEN
                a1serial_node := a_ap_tree^[a1serial_node].n_lo_level;
            (*ENDIF*) 
            a23create_sequence (acv, pbasep^.sbase.bsurrogate, pbasep^.sbase.bschema,
                  a01_il_b_identifier, serial_col^,
                  c_is_serial, a1temp_table, a1serial_node)
            END;
        (*ENDIF*) 
        IF  a_is_ddl <> ddl_create_domain
        THEN (* store tbaserecord *)
            a10_add_repl_sysinfo (acv, pbasep, a1add_rec, b_err);
        (*ENDIF*) 
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1)
        ELSE
            IF  (a1foreign_key_node <> 0)
                AND (a1createtab OR (a_is_ddl = ddl_alter_tab_add))
            THEN
                BEGIN
                init_ddl := a_is_ddl;
                a_is_ddl := ddl_create_link;
                a25foreign_key_spec (acv, a1foreign_key_node);
                a_is_ddl := init_ddl
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
t01name(ak_sem, '<a11end_create_tab');
&endif
END;
 
(*------------------------------*) 
 
FUNCTION
      a11firstindex (
            colcount    : integer;
            VAR baserec : tak_baserecord) : tsp00_Int2;
 
BEGIN
a11firstindex := (colcount * sizeof (baserec.bextcolindex[1]) + sizeof (baserec.bcolumn[1]) - 1)
      DIV sizeof (baserec.bcolumn[1]) + 1;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a11sort (VAR base_rec : tak_baserecord);
 
VAR
      i            : integer;
      count        : integer;
      j            : integer;
      last_key_pos : integer;
      (* PTS 1111574 E.Z. *)
      min          : tsp00_Int4;
      min_index    : integer;
      aux          : tak_colsort;
      col_sort     : tak_colsortarr;
 
BEGIN
count        := 0;
last_key_pos := 0;
&ifdef trace
t01int4 (ak_sem, 'bfirstindex ', base_rec.bfirstindex );
t01int4 (ak_sem, 'blastindex  ', base_rec.blastindex );
t01int4 (ak_sem, 'bmaxcol     ', base_rec.bmaxcol );
&endif
FOR j := base_rec.bfirstindex TO base_rec.blastindex DO
    WITH base_rec.bcolumn[ j ]^ DO
        BEGIN
        count := succ(count);
        col_sort[ count ].colind := j;
&       ifdef trace
        t01stackentry( ak_sem, ccolstack, count );
&       endif
        CASE ccolstack.etype OF
            st_fixkey, st_varkey :
                BEGIN
                col_sort[ count ].colpos := ccolstack.epos;
                IF  (ccolstack.epos > last_key_pos)
                    AND
                    ((ctkey in ccolpropset         ) OR
                    ( ctjoinviewkey in ccolpropset))
                THEN
                    BEGIN
                    last_key_pos := ccolstack.epos;
                    base_rec.blastkeyind := j
                    END;
                (*ENDIF*) 
                IF  ctabno > 1
                THEN
                    IF  NOT (ctjoinviewkey in ccolpropset)
                    THEN
                        col_sort[ count ].colpos :=
                              col_sort[ count ].colpos +
                              PERM_KEY_MXSP00
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            st_fixcol :
                col_sort[ count ].colpos := ccolstack.epos +
                      PERM_KEY_MXSP00 + PERM_KEY_MXSP00;
            st_varcol :
                col_sort[ count ].colpos :=
                      ccolstack.ecolno + PERM_KEY_MXSP00 + PERM_KEY_MXSP00 +
                      MAX_RECLEN_GG00;
            st_varlongchar :
                col_sort[ count ].colpos :=
                      ccolstack.ecolno +
                      PERM_KEY_MXSP00 + PERM_KEY_MXSP00 +
                      MAX_RECLEN_GG00 + MAX_RECLEN_GG00;
            st_column :
                col_sort[ count ].colpos := ccolstack.ecolno + 1; (* SYSKEY *)
            OTHERWISE
                col_sort[ count ].colpos := csp_maxint2 - 1;
            END;
        (*ENDCASE*) 
        END;
    (*ENDWITH*) 
(*ENDFOR*) 
FOR i := 1 TO base_rec.bmaxcol DO
    BEGIN
    (* PTS 1111574 E.Z. *)
    min       := csp_maxint4;
    min_index := 0;
    FOR j := i TO base_rec.bmaxcol DO
        IF  col_sort[ j ].colpos < min
        THEN
            BEGIN
            min       := col_sort[ j ].colpos;
            min_index := j;
            END;
        (*ENDIF*) 
    (*ENDFOR*) 
    aux                   := col_sort[ i ];
    col_sort[ i ]         := col_sort[ min_index ];
    col_sort[ min_index ] := aux;
    END;
(*ENDFOR*) 
base_rec.bfirstcolind := col_sort[ 1 ].colind;
&ifdef trace
t01int4 (ak_sem, 'bfirstcolind', base_rec.bfirstcolind );
&endif
FOR i := 1 TO base_rec.bmaxcol - 1 DO
    WITH col_sort[ i ], base_rec.bcolumn[ colind ]^ DO
        cnextind := col_sort[ i+1 ].colind;
    (*ENDWITH*) 
(*ENDFOR*) 
WITH col_sort[ base_rec.bmaxcol ], base_rec.bcolumn[ colind ]^ DO
    cnextind := 0;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a11one_column_def  (
            VAR acv  : tak_all_command_glob;
            VAR a11v : tak_a11_glob);
 
BEGIN
ak11OneColumnDef (acv, a11v, acv.a_is_ddl = ddl_create_trigger);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a11OneFixedLengthColumnDef  (
            VAR acv  : tak_all_command_glob;
            VAR a11v : tak_a11_glob);
 
VAR
      temp : boolean;
 
BEGIN
temp              := a11v.a1temp_table;
a11v.a1temp_table := false;
ak11OneColumnDef (acv, a11v, cak11fixed_length);
a11v.a1temp_table := temp;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak11OneColumnDef  (
            VAR acv                   : tak_all_command_glob;
            VAR a11v                  : tak_a11_glob;
            mustBeFixedColumn         : boolean);
 
VAR
      domain        : boolean;
      is_key        : boolean;
      string        : boolean;
      aux           : integer;
      err_pos       : integer;
      key_err_pos   : integer;
      len_byte      : integer;
      ref_index     : integer;
      key_node      : integer;
      colinfo_ptr   : tak00_colinfo_ptr;
      key_col       : tsp00_KnlIdentifier;
 
BEGIN
WITH acv, a11v , a_p_arr1 DO
    BEGIN
    IF  a_returncode = 0
    THEN
        BEGIN
        WITH a_ap_tree^[ a1ti ] DO
            IF  n_pos > 0
            THEN
                BEGIN
                a05_identifier_get (acv, a1ti,
                      sizeof (a1coln), a1coln);
                ref_index := n_lo_level;
                err_pos   := n_pos;
                IF  a1coln = a01_i_tablekey
                THEN
                    a07_b_put_error (acv,
                          e_reserved_identifier, err_pos)
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                err_pos := 1;
                IF  a_init_ddl = ddl_create_as_select
                THEN
                    a14get_colname (acv, a11v, err_pos)
                ELSE
                    a1coln := a01_il_b_identifier
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
        IF  mustBeFixedColumn
        THEN
            BEGIN
            IF  a061ExistColumnnameSequential (a_p_arr1.pbasep^.sbase, a1coln, colinfo_ptr)
            THEN
                a07_nb_put_error (acv, e_duplicate_columnname, err_pos, a1coln)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a061app_columnname (acv, a_p_arr1.pbasep^.sbase, a1coln, a1ci)
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        WITH a_p_arr1.pbasep^.sbase, bcolumn[a1ci]^, ccolstack DO
            BEGIN
&           IFDEF TRACE
            t01lidentifier (ak_sem, a1tablen);
            t01lidentifier (ak_sem, a1coln);
&           ENDIF
            a1colptr      := bcolumn[a1ci];
            a1ti          := a_ap_tree^[ a1ti ].n_sa_level;
            cextcolno     := a_p_arr1.pbasep^.sbase.bmaxcol;
            a1extcolno    := cextcolno;
            creccolno     := cextcolno;
            ctabno        := 1;
            ccolpropset   := [  ];
            cdatafrac     := cak_frac_offset;
            cinoutlen     := 0;
            eop           := op_none;
            ecol_tab[ 1 ] := chr(0);
            ecol_tab[ 2 ] := chr(0);
            cbinary       := false;
            domain        := false;
            IF  a_is_ddl = ddl_create_as_select
            THEN
                a14get_result_datatype (acv, a11v, bcolumn[ a1ci ]^, err_pos)
            ELSE
                ak11get_datatyp (acv, a11v, mustBeFixedColumn, bcolumn[ a1ci ]^,
                      domain);
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                string := (cdatatyp in [ dstra, dstrb, dstruni,
                      dlonga, dlongb, dlonguni ]);
                IF  string
                THEN
                    BEGIN
                    a1strcolcount := a1strcolcount + 1;
                    IF  mustBeFixedColumn
                    THEN
                        BEGIN
                        bcolumn[ a1ci ]^.cdatalen  := LONG_DESC_MXSP00;
                        bcolumn[ a1ci ]^.cinoutlen := 1 + bcolumn[ a1ci ]^.cdatalen;
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  cdatatyp in [dlonga, dlongb, dlonguni]
                THEN
                    a1long_col_cnt := a1long_col_cnt + 1;
                (*ENDIF*) 
                is_key := false;
                IF  (a_ap_tree^[ a1ti ].n_symb = s_key) OR (a1key_node <> 0)
                THEN
                    BEGIN (* column may be key column *)
                    IF  (NOT a1inpkey AND (a1key_node = 0))
                        OR
                        ((a_ap_tree^[ a1ti ].n_symb = s_key) AND
                        ((a1key_node <> 0) OR NOT a1createtab OR string))
                    THEN
                        a07_b_put_error (acv, e_key_not_allowed,
                              a_ap_tree^[ a1ti ].n_pos)
                    ELSE
                        IF  a1key_node <> 0
                        THEN
                            BEGIN (* check if column is in primaray key *)
                            key_node := a1key_node;
                            REPEAT
                                WITH a_ap_tree^[ key_node ] DO
                                    BEGIN
                                    a05_identifier_get (acv, key_node,
                                          sizeof (key_col), key_col);
&                                   IFDEF TRACE
                                    t01int4  (ak_sem,
                                          'key_node    ', key_node);
                                    t01lidentifier (ak_sem, key_col);
                                    t01lidentifier (ak_sem, a1coln);
&                                   ENDIF
                                    IF  key_col = a1coln
                                    THEN
                                        (* PTS 1113259 E.Z. *)
                                        IF  string
                                        THEN
                                            BEGIN
                                            a07_b_put_error (acv, e_key_not_allowed, n_pos);
                                            key_node := 0
                                            END
                                        ELSE
                                            IF  n_pos > 0
                                            THEN
                                                BEGIN (* key column *)
                                                key_err_pos      := n_pos;
                                                n_pos            := -n_pos;
                                                key_node         := 0;
                                                n_subproc        := a1ci;
                                                is_key           := true
                                                END
                                            ELSE
                                                BEGIN
                                                a07_nb_put_error (acv,
                                                      e_duplicate_columnname,
                                                      abs (n_pos), key_col);
                                                key_node := 0
                                                END
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                    ELSE
                                        key_node := n_sa_level
                                    (*ENDIF*) 
                                    END;
                                (*ENDWITH*) 
                            UNTIL
                                key_node = 0;
                            (*ENDREPEAT*) 
                            END
                        ELSE
                            BEGIN
                            key_err_pos := a_ap_tree^[ a1ti ].n_pos;
                            is_key      := true
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
&                   IFDEF TRACE
                    t01int4  (ak_sem, 'is_key      ', ord (is_key));
&                   ENDIF
                    IF  is_key
                    THEN
                        BEGIN
                        bkeycolcount := bkeycolcount + 1;
                        IF  domain
                        THEN
                            ccolpropset := ccolpropset +
                                  [ ctkey ] - [ ctopt ]
                        ELSE
                            ccolpropset := ccolpropset + [ ctkey ];
                        (*ENDIF*) 
                        etype    := st_fixkey;
                        epos     := a1keypos;
                        a1keypos := a1keypos + cinoutlen;
                        (* do not worry, will be changed some line down *)
                        elen_var := cinoutlen;
                        IF  (a1keypos - 1 > PERM_KEY_MXSP00) OR
                            (bkeycolcount > cak_maxkeyfields)
                        THEN
                            a07_nb_put_error (acv, e_too_long_key,
                                  key_err_pos, a1coln);
                        (*ENDIF*) 
                        IF  a1key_node = 0
                        THEN
                            a1ti := a_ap_tree^[ a1ti ].n_sa_level;
                        (*ENDIF*) 
                        IF  a_ap_tree^[ a1ti ].n_symb = s_not_null
                        THEN
                            a1ti := a_ap_tree^[ a1ti ].n_sa_level
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  NOT is_key
                THEN
                    IF  a_ap_tree^[ a1ti ].n_symb = s_not_null
                    THEN
                        BEGIN
                        IF  a_ap_tree^[ a1ti ].n_length = cak_i_with
                        THEN (* not null with default *)
                            BEGIN
                            aux  := a1ti;
                            a1ti := -a1ti;
                            a14default_spec (acv,
                                  a11v, bcolumn[ a1ci ]^);
                            a1ti := aux
                            END
                        ELSE
                            (* PTS 1121018 M.Ki. *)
                            (* if a default is defined it is always *)
                            (* stored in the next node              *)
                            IF  ((NOT a1createtab)
                                AND
                                (a_ap_tree^[ a_ap_tree^[ a1ti ].n_sa_level ]
                                .n_proc <> a14))
                            THEN
                                a07_b_put_error (acv,
                                      e_not_null_not_allowed,
                                      a_ap_tree^[ a1ti ].n_pos);
                            (*ENDIF*) 
                        (*ENDIF*) 
                        a1inpkey := false;
                        a1ti     := a_ap_tree^[ a1ti ].n_sa_level;
                        IF  domain
                        THEN
                            ccolpropset := ccolpropset - [ ctopt ];
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        IF  NOT domain AND NOT (ctserial in ccolpropset)
                        THEN
                            ccolpropset := ccolpropset + [ ctopt ];
                        (*ENDIF*) 
                        a1inpkey := false;
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                len_byte := 0;
&               ifndef vers80
                IF  NOT is_key
                THEN
&                   endif
                    IF  string
                    THEN
                        BEGIN
                        IF  a1createtab OR mustBeFixedColumn
                        THEN
                            BEGIN
&                           ifdef vers80
                            etype    := st_column;
                            ecolno   := a1strcolcount;
                            elen_var := cinoutlen;
&                           else
                            etype    := st_fixcol;
                            IF  mustBeFixedColumn
                            THEN
                                BEGIN
                                epos         := blenfixedcol;
                                blenfixedcol := blenfixedcol + cinoutlen;
                                END
                            ELSE
                                epos  := (a1strcolcount-1) * cinoutlen + 1;
                            (*ENDIF*) 
&                           endif
                            END
                        ELSE
                            BEGIN
                            (* PTS 1115206 M.Ki. *)
                            (* define string column as column of variable length *)
                            (* first if not in CREATE TABLE; during              *)
                            (* ALTER TABLE ADD ... LONG the correct entry will   *)
                            (* be generated in ak13modfiy                        *)
                            etype        := st_varcol;
                            bvarcolcount := bvarcolcount + 1;
                            ecolno       := pbasep^.sbase.bvarcolcount;
                            len_byte     := 1
                            END;
                        (*ENDIF*) 
                        elen_var := cinoutlen;
                        CASE cdatatyp OF
                            dstra   :
                                ecol_tab[ 1 ] := chr(1);
                            dstrb   :
                                ecol_tab[ 1 ] := chr(2);
                            dstruni :
                                ecol_tab[ 1 ] := chr(4);
                            OTHERWISE
                                BEGIN
                                END;
                            END;
                        (*ENDCASE*) 
                        END
                    ELSE
&                       ifdef vers80
                        IF  mustBeFixedColumn
                        THEN
                            BEGIN
                            (* column of fixed length *)
                            etype        := st_fixcol;
                            epos         := blenfixedcol;
                            blenfixedcol := blenfixedcol + cinoutlen;
                            elen_var     := cinoutlen;
                            END
                        ELSE
                            BEGIN
                            etype    := st_column;
                            ecolno   := MAX_COL_PER_TAB_GG00 + cextcolno - a1strcolcount;
                            elen_var := cinoutlen;
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
&               else
                (*ENDIF*) 
                IF  cdatatyp = dudt
                THEN
                    BEGIN
                    (* column of fixed length *)
                    etype := st_fixcol;
                    epos  := blenfixedcol;
                    blenfixedcol := blenfixedcol +
                          cinoutlen;
                    elen_var := cinoutlen;
                    END
                ELSE
                    IF  (cinoutlen > cak_maxfieldlength + 1) AND
                        (acv.a_is_ddl <> ddl_create_trigger) AND
                        NOT mustBeFixedColumn
                    THEN
                        BEGIN
                        a1longcharcnt := succ(a1longcharcnt);
                        etype         := st_varlongchar;
                        ecolno        := a1longcharcnt;
                        elen_var      := cinoutlen;
                        len_byte := 2
                        END
                    ELSE
                        IF  (
                            (   cinoutlen > cak_maxconstlength + 1)
                            (* PTS 1126711 E.Z. *)
                            OR (ta_no_fixed_length_column in battributes)
                            OR (NOT a1createtab)
                            OR (cvarchar                   AND
                            (   cdatatyp <> dfixed)        AND
                            ((  cdatalen > 2) OR
                            (   cdatalen = cak_is_undefined)))
                            OR (a_is_ddl = ddl_create_domain)
                            )
                            AND
                            (acv.a_is_ddl <> ddl_create_trigger)
                            AND
                            NOT mustBeFixedColumn
                        THEN
                            BEGIN
                            (* column of variable length *)
                            etype  := st_varcol;
                            bvarcolcount  :=
                                  bvarcolcount + 1;
                            ecolno :=  pbasep^.
                                  sbase.bvarcolcount;
                            elen_var := cinoutlen;
                            len_byte := 1
                            END
                        ELSE
                            BEGIN
                            (* column of fixed length *)
                            etype        :=  st_fixcol;
                            epos         := blenfixedcol;
                            blenfixedcol := blenfixedcol + cinoutlen;
                            elen_var     := cinoutlen;
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
&               endif
                IF  ((a_sqlmode <> sqlm_oracle) AND g01checktablewidth)
                    OR (len_byte = 0)
                THEN
                    a1reclen := a1reclen + cinoutlen + len_byte
                ELSE
                    a1reclen := a1reclen + len_byte;
                (*ENDIF*) 
&               IFDEF TRACE
                t01int4  (ak_sem, 'a1reclen    ', a1reclen);
&               ENDIF
                IF  (a1reclen > MAX_RECLEN_GG00) AND
                    NOT (a_is_ddl in [ddl_create_procedure, ddl_create_trigger])
                THEN
                    a07_b_put_error (acv, e_too_long_record, err_pos)
                ELSE
                    BEGIN
                    IF  (a1ti <> 0)
                    THEN
                        IF  (ctserial in bcolumn[a1ci]^.ccolpropset)
                        THEN
                            a07_b_put_error (acv,
                                  e_default_not_allowed, err_pos)
                        ELSE
                            a14default_spec (acv,
                                  a11v, bcolumn [ a1ci ]^)
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
&ifdef LONGREC
(*------------------------------*) 
 
PROCEDURE
      ak11my_special_column  (
            VAR acv  : tak_all_command_glob;
            VAR a11v : tak_a11_glob);
 
VAR
      err_pos       : integer;
 
BEGIN
WITH acv, a11v , a_p_arr1 DO
    BEGIN
    IF  a_returncode = 0
    THEN
        BEGIN
        a1coln := a01_i_internal;
        err_pos := 4711;
        a061app_columnname (acv, a_p_arr1.pbasep^.sbase, a1coln, a1ci);
        IF  a_returncode = 0
        THEN
            WITH a_p_arr1.pbasep^.sbase, bcolumn[a1ci]^, ccolstack DO
                BEGIN
                bcntdropcol   := 1;
&               IFDEF TRACE
                t01lidentifier (ak_sem, a1tablen);
                t01lidentifier (ak_sem, a1coln);
&               ENDIF
                a1colptr      := bcolumn[a1ci];
                cextcolno     := a_p_arr1.pbasep^.sbase.bmaxcol;
                a1extcolno    := cextcolno;
                creccolno     := cextcolno;
                ctabno        := 1;
                ccolpropset   := [ ctopt, ctdropped ];
                cdatafrac     := cak_frac_offset;
                cinoutlen     := 0;
                eop           := op_none;
                ecol_tab[ 1 ] := chr(0);
                ecol_tab[ 2 ] := chr(0);
                cbinary       := false;
                cbinary      := false;
                cudtdatatype := cgg_zero_c2;
                cdatatyp      := dcha;
                (* PTS 1111574 E.Z. *)
                cdatalen      := 3075;
                cinoutlen     := 3076;
                cshiftoutchar := chr(ord(false));
                (* column of fixed length *)
                etype := st_fixcol;
                epos  := blenfixedcol;
                blenfixedcol := blenfixedcol +
                      cinoutlen;
                elen_var := cinoutlen;
                a1reclen := a1reclen + cinoutlen;
&               IFDEF TRACE
                t01int4  (ak_sem, 'a1reclen    ', a1reclen);
&               ENDIF
                IF  (a1reclen > MAX_RECLEN_GG00)
                THEN
                    a07_b_put_error (acv, e_too_long_record, err_pos)
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
&endif
(*------------------------------*) 
 
PROCEDURE
      a11put_date_time (
            VAR date : tsp00_Int4;
            VAR time : tsp00_Int4);
 
VAR
      p            : tsp00_Int4;
      i            : integer;
      c8date       : tsp00_Date;
      c8time       : tsp00_Time;
 
BEGIN
vdattime (c8date, c8time);
date := 0;
p    := 1;
FOR i := mxsp_date DOWNTO 1 DO
    BEGIN
    date := date + (ord(c8date[ i ]) - ord('0')) * p;
    p    := p * 10;
    END;
(*ENDFOR*) 
time := 0;
p    := 1;
FOR i := mxsp_time DOWNTO 1 DO
    BEGIN
    time := time + (ord(c8time[ i ]) - ord('0')) * p;
    p    := p * 10;
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a11constraint (
            VAR acv       : tak_all_command_glob;
            VAR a11v      : tak_a11_glob;
            VAR base_rec  : tak_baserecord;
            constraint_id : integer);
 
VAR
      obj_type        : tak_object_type;
      constraint_node : tsp00_Int2;
      dummy           : tsp00_Int2;
 
BEGIN
WITH acv, a11v DO
    BEGIN
    a542internal_packet (acv, NOT cak11release_packet, MAX_RECLEN_GG00);
    IF  a_returncode = 0
    THEN
        BEGIN
        a_cmd_part^.sp1p_buf_len := 0;
        IF  base_rec.btreeid.fileTfn_gg00 = tfnTemp_egg00
        THEN
            obj_type := obj_temp_table
        ELSE
            obj_type := obj_table;
        (*ENDIF*) 
        a44constraint_into_moveobj (acv, @base_rec,
              base_rec.btreeid.fileTabId_gg00,
              obj_type, constraint_id, 1,
              a_cmd_part^.sp1p_buf, a_cmd_part^.sp1p_buf_size,
              a_cmd_part^.sp1p_buf_len);
        IF  a_returncode = 0
        THEN
            BEGIN
            IF  g01unicode
            THEN
                BEGIN
                a_cmd_part^.sp1p_buf_len := a_cmd_part^.sp1p_buf_len + 1;
                a_cmd_part^.sp1p_buf[a_cmd_part^.sp1p_buf_len] := csp_unicode_mark;
                END;
            (*ENDIF*) 
            a_cmd_part^.sp1p_buf_len := a_cmd_part^.sp1p_buf_len + 1;
            a_cmd_part^.sp1p_buf[a_cmd_part^.sp1p_buf_len] := bsp_c1;
&           IFDEF TRACE
            t01moveobj (ak_sem,
                  a_cmd_part^.sp1p_buf, 1, a_cmd_part^.sp1p_buf_len);
&           ENDIF
            a01_init_command (acv);
            a01_call_put (acv, a63, 1, constraint_node);
            a_ap_tree^[ 0 ].n_lo_level := constraint_node;
            a1ti := constraint_node;
            a63_asearch_condition (acv,
                  a_ap_tree^[ a1ti ].n_lo_level, dummy);
            a11condition (acv, a11v, constraint_id,
                  a_cmd_part^.sp1p_buf_len - a01char_size)
            END;
        (*ENDIF*) 
        a542pop_packet (acv)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a11put_systemkey (
            VAR acv  : tak_all_command_glob;
            VAR a11v : tak_a11_glob);
 
BEGIN
WITH acv, a11v DO
    BEGIN
    a1inpkey := false;
    a061put_systemkey (acv, a_p_arr1.pbasep^.sbase);
    WITH a_p_arr1.pbasep^.sbase, bcolumn[blastkeyind]^ DO
        BEGIN
        a1reclen := a1reclen + cinoutlen;
        END;
    (*ENDWITH*) 
    a1extcolno   := 1
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak11domain_datatyp (
            VAR acv      : tak_all_command_glob;
            VAR a11v     : tak_a11_glob;
            VAR col_info : tak00_columninfo);
 
VAR
      b_err       : tgg00_BasisError;
      domain_def  : tak_sysbufferaddress;
      dummy       : tak_sysbufferaddress;
      owner_id    : tgg00_Surrogate;
      domain_name : tsp00_KnlIdentifier;
      owner       : tsp00_KnlIdentifier;
      new_sysk    : tgg00_SysInfoKey;
      old_sysk    : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a11v DO
    BEGIN
    IF  a_returncode = 0
    THEN
        a12get_domain (acv, owner,
              domain_name, a1ti, dummy, domain_def);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        WITH col_info DO
            BEGIN
            cdatatyp      := domain_def^.sdomain.dom_colinfo.cdatatyp;
            cdatalen      := domain_def^.sdomain.dom_colinfo.cdatalen;
            cdatafrac     := domain_def^.sdomain.dom_colinfo.cdatafrac;
            cinoutlen     := domain_def^.sdomain.dom_colinfo.cinoutlen;
            ccolpropset   :=
                  domain_def^.sdomain.dom_colinfo.ccolpropset +
                  [ctdomain] - [ctcomment];
            cshiftoutchar :=
                  domain_def^.sdomain.dom_colinfo.cshiftoutchar;
            IF  cdatatyp = dudt
            THEN
                BEGIN
                cudtdatatype[1] := domain_def^.sdomain.dom_surrogate[7];
                cudtdatatype[2] := domain_def^.sdomain.dom_surrogate[8]
                END;
            (*ENDIF*) 
            IF  ctdefault in ccolpropset
            THEN
                BEGIN
                old_sysk               := domain_def^.syskey;
                old_sysk.sentrytyp     := cak_edefault;
                old_sysk.slinkage[1]   := chr(0);
                old_sysk.slinkage[2]   := chr(1);
                new_sysk               := a_p_arr1.pbasep^.syskey;
                new_sysk.stableid      := a1tableid;
                new_sysk.sentrytyp     := cak_edefault;
                new_sysk.slinkage[1]   := chr (cextcolno DIV 256);
                new_sysk.slinkage[2]   := chr (cextcolno MOD 256);
                IF  NOT a1add_rec
                THEN
                    a10del_sysinfo (acv, new_sysk, b_err);
                (*ENDIF*) 
                a10_copy_catalog_rec (acv, old_sysk, false,
                      new_sysk, a_p_arr1.pbasep^.sbase.bsegmentid,
                      true, b_err);
                IF  b_err <> e_ok
                THEN
                    a07_b_put_error (acv, b_err, 1)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  a_p_arr1.pbasep^.syskey.sentrytyp < cak_etemp
            THEN
                BEGIN
                a103GetSchemaId (acv, owner, 1, owner_id);
                a11domain_usage (acv, a11v, owner_id, domain_name,
                      domain_def^.sdomain.dom_surrogate,
                      cextcolno)
                END;
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                IF  domain_def^.sdomain.dom_constraint
                THEN
                    BEGIN
                    a1constraint_cnt := a1constraint_cnt + 1;
                    IF  a1constraint_cnt > cak_max_constraints
                    THEN
                        a07_b_put_error (acv, e_too_many_constraints, 1)
                    ELSE
                        WITH a1constraint_info[ a1constraint_cnt ] DO
                            BEGIN
                            tree_index := -a1ti;
                            extcolno   := col_info.cextcolno
                            END;
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  ctserial in ccolpropset
                THEN
                    IF  a1serial_node > 0
                    THEN
                        a07_b_put_error (acv, e_too_many_columns, 1)
                    ELSE
                        a1serial_node := -a1ti
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak11dec_elen_var (
            VAR acv   : tak_all_command_glob;
            var_colno : integer);
 
VAR
      j : integer;
 
BEGIN
FOR j := acv.a_p_arr1.pbasep^.sbase.bfirstindex TO
      acv.a_p_arr1.pbasep^.sbase.blastindex DO
    WITH acv.a_p_arr1.pbasep^.sbase.bcolumn[ j ]^ DO
        IF  (ccolstack.etype = st_varcol) AND
            (ccolstack.elen_var > var_colno)
        THEN
            ccolstack.ecolno := ccolstack.ecolno - 1;
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a11del_usage_entry (
            VAR acv       : tak_all_command_glob;
            VAR usa_tabid : tgg00_Surrogate;
            VAR del_tabid : tgg00_Surrogate);
 
VAR
      ignore_call  : boolean;
      upd_rec      : boolean;
      next_exist   : boolean;
      b_err        : tgg00_BasisError;
      move_entries : integer;
      i            : integer;
      usabuf       : tak_sysbufferaddress;
      nextbuf      : tak_sysbufferaddress;
      tabid        : tgg00_Surrogate;
      usakey       : tgg00_SysInfoKey;
 
BEGIN
tabid       := del_tabid;
(* copy del_tabid, otherwise problems occur, if *)
(* del_tabid is address of usa_tableid          *)
ignore_call := false;
next_exist  := false;
upd_rec     := false;
usakey      := a01defaultkey;
WITH usakey DO
    BEGIN
    sauthid     := usa_tabid;
    sentrytyp   := cak_eusage;
    ignore_call := ssite = cak_show_table_site
    END;
(*ENDWITH*) 
IF  (acv.a_returncode = 0) AND NOT (ignore_call)
THEN
    (* PTS 1109081 *)
    a10_lock_sysinfo (acv, usakey, lckRowExcl_egg00);
(*ENDIF*) 
IF  (acv.a_returncode = 0) AND NOT (ignore_call)
THEN
    BEGIN
    REPEAT
        a10get_sysinfo (acv, usakey, d_fix, usabuf, b_err);
        IF  b_err = e_ok
        THEN
            WITH usabuf^.susage DO
                BEGIN
                next_exist := usagenext_exist;
                i          := 1;
                WHILE i <= usagecount DO
                    WITH usagedef [ i ] DO
                        IF  usa_tableid = tabid
                        THEN
                            BEGIN
                            IF  i < usagecount
                            THEN
                                SAPDB_PascalOverlappingMove ('VAK11 ',   8,    
                                      sizeof (tak_usagerecord),
                                      sizeof (tak_usagerecord),
                                      @usagedef[ i+1 ], 1, @usagedef[ i ],
                                      1, (usagecount-i) * mxak_usagedef,
                                      b_err);
                            (*ENDIF*) 
                            usagecount := pred(usagecount);
                            upd_rec    := true;
                            END
                        ELSE
                            i := succ(i);
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (*ENDWHILE*) 
                a06inc_linkage (usakey.slinkage)
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
    UNTIL
        NOT next_exist OR upd_rec;
    (*ENDREPEAT*) 
    IF  upd_rec
    THEN
        BEGIN
        WHILE (next_exist) AND (b_err = e_ok) DO
            BEGIN
            a10get_sysinfo (acv, usakey, d_fix,
                  nextbuf, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                move_entries := cak_max_usage -
                      usabuf^.susage.usagecount;
                IF  move_entries > nextbuf^.susage.usagecount
                THEN
                    move_entries := nextbuf^.susage.usagecount;
                (*ENDIF*) 
                WITH usabuf^.susage DO
                    BEGIN
                    SAPDB_PascalMove ('VAK11 ',   9,    
                          sizeof (tak_usagerecord),
                          sizeof (tak_usagerecord),
                          @nextbuf^.susage.usagedef[ 1 ], 1,
                          @usagedef[ usagecount+1 ], 1,
                          move_entries * mxak_usagedef, b_err);
                    usagecount := usagecount + move_entries;
                    END;
                (*ENDWITH*) 
                WITH nextbuf^.susage DO
                    BEGIN
                    usagecount := usagecount - move_entries;
                    IF  usagecount > 0
                    THEN
                        BEGIN
                        SAPDB_PascalOverlappingMove ('VAK11 ',  10,    
                              sizeof (tak_usagerecord),
                              sizeof (tak_usagerecord),
                              @usagedef[ move_entries+1 ], 1,
                              @usagedef[ 1 ], 1,
                              usagecount * mxak_usagedef, b_err);
                        next_exist := usagenext_exist;
                        END
                    ELSE
                        BEGIN
                        usabuf^.susage.usagenext_exist := false;
                        IF  b_err = e_ok
                        THEN
                            a10del_sysinfo (acv, usakey, b_err);
                        (*ENDIF*) 
                        next_exist := false;
                        upd_rec    := false;
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            IF  b_err = e_ok
            THEN
                WITH usabuf^, susage DO
                    BEGIN
                    b_sl := cak_sysbufferoffset + mxak_usage_offset +
                          usagecount * mxak_usagedef;
                    a10repl_sysinfo (acv, usabuf, b_err);
                    a10_rel_sysinfo (acv, usabuf^.syskey);
                    usabuf := nextbuf;
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            a06inc_linkage (usakey.slinkage)
            END;
        (*ENDWHILE*) 
        IF  (upd_rec) AND (b_err = e_ok)
        THEN
            WITH usabuf^, susage DO
                BEGIN
                b_sl := cak_sysbufferoffset + mxak_usage_offset +
                      usagecount * mxak_usagedef;
                a10repl_sysinfo (acv, usabuf, b_err);
                a10_rel_sysinfo (acv, usabuf^.syskey);
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (b_err <> e_ok) AND (b_err <> e_sysinfo_not_found)
    THEN
        a07_b_put_error ( acv, b_err, 1);
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a11get_check_table (
            VAR acv          : tak_all_command_glob;
            new_table        : boolean;
            basetable        : boolean;
            unload_allowed   : boolean;
            required_priv    : tak00_PrivilegeSet;
            any_priv         : boolean;
            all_base_rec     : boolean;
            d_state          : tak_directory_state;
            VAR act_tree_ind : tsp00_Int4;
            VAR auth         : tsp00_KnlIdentifier;
            VAR tablen       : tsp00_KnlIdentifier;
            VAR p_arr        : tak_syspointerarr);
 
VAR
      check_priv   : boolean;
      owner_spec   : boolean;
      kw_index     : integer;
      e            : tgg00_BasisError;
      error_no     : tgg00_BasisError;
      pUser        : tak_sysbufferaddress;
      priv         : tak_privilege;
      syn_name     : tsp00_KnlIdentifier;
      sysk         : tgg00_SysInfoKey;
      errmsg_nb    : boolean;
 
BEGIN
WITH acv DO
    BEGIN
&   ifdef trace
    t01int4 (ak_sem, 'a_is_ddl    ', ord (a_is_ddl));
&   endif
    check_priv    := false;
    error_no      := e_ok;
    errmsg_nb     := true;
    owner_spec    := true;
    kw_index      := cak_i_no_keyword;
    WITH a_ap_tree^[ act_tree_ind ] DO
        IF  n_symb = s_authid
        THEN
            BEGIN
            a06get_username    (acv, act_tree_ind, auth);
            a101_MapSchemaName (acv, auth, n_pos);
            END
        ELSE
            BEGIN
            owner_spec := false;
            IF  NOT (new_table AND
                ((a_is_ddl = ddl_rename_table)   OR
                ( a_is_ddl = ddl_rename_synonym) OR
                ( a_is_ddl = ddl_rename_view)))
            THEN
                auth := acv.a_curr_schema;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDWITH*) 
    IF  (
        (new_table)                                OR
        ((NOT new_table) AND
        (* PTS 1111576 E.Z. *)
        (a_is_ddl = ddl_create_view))
        )
        AND
        (
        ((a_current_user_kind = unoprivate) AND (basetable) AND
        (auth <> a01_i_temp ))
        OR
        (a_current_user_kind = usuperdba)
        )
    THEN
        IF  acv.a_isReplicationSession
        THEN
            BEGIN
            IF  a06exist_user (acv, auth, d_release, pUser)
            THEN
                BEGIN
                IF  NOT pUser^.suser.ureplication
                THEN
                    BEGIN
                    kw_index  := cak_i_replication;
                    error_no  := e_missing_privilege;
                    errmsg_nb := false
                    END;
                (*ENDIF*) 
                END
            ELSE
                a07_nb_put_error (acv, e_unknown_user, act_tree_ind, auth);
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            IF  (a_current_user_kind = unoprivate) AND (basetable)
            THEN
                kw_index := cak_i_resource
            ELSE
                kw_index := cak_i_userid;
            (*ENDIF*) 
            error_no  := e_missing_privilege;
            errmsg_nb := false
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  error_no = e_ok
    THEN
        BEGIN
        a05_identifier_get (acv, act_tree_ind, sizeof (tablen), tablen);
        syn_name := tablen
        END;
    (*ENDIF*) 
    IF  error_no = e_ok
    THEN
        BEGIN
        IF  a06_table_exist (acv, d_state,
            auth, tablen, p_arr, all_base_rec AND NOT(new_table))
        THEN
            BEGIN
            IF  new_table
            THEN
                error_no := e_duplicate_tablename
            ELSE
                IF  (a_is_ddl = ddl_rename_synonym) AND
                    p_arr.psynfound
                THEN
                    BEGIN
                    tablen     := syn_name;
                    check_priv := false
                    END
                ELSE
                    IF  p_arr.pbasep^.syskey.sentrytyp > cak_etemp
                    THEN
                        IF  (a_is_ddl = ddl_alter_tab_add    ) OR
                            (a_is_ddl = ddl_alter_key        ) OR
                            (a_is_ddl = ddl_alter_tab_alter  ) OR
                            (a_is_ddl = ddl_alter_tab_drop   ) OR
                            (a_is_ddl = ddl_create_index     ) OR
                            (a_is_ddl = ddl_create_link      ) OR
                            ((a_is_ddl = ddl_create_synonym) AND
                            NOT (p_arr.pbasep^.sbase.btablekind in
                            [tdb2view, tcatalog_table])) OR
                            (a_is_ddl = ddl_create_trigger   ) OR
                            (a_is_ddl = ddl_grant_privilege  ) OR
                            (a_is_ddl = ddl_rename_column    ) OR
                            (a_is_ddl = ddl_rename_table     ) OR
                            (a_is_ddl = ddl_save_restore_cmd ) OR
                            (a_is_ddl = ddl_update_statistics)
                        THEN
                            error_no := e_temp_table_not_allowed
                        ELSE
                            check_priv := false
                        (*ENDIF*) 
                    ELSE
                        check_priv := true
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            IF  new_table
            THEN
                BEGIN
                IF  (auth = a01_i_temp ) AND
                    (a_is_ddl = ddl_create_view)
                THEN
                    error_no := e_temp_table_not_allowed
                (*ENDIF*) 
                END
            ELSE
                error_no := e_unknown_tablename;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  check_priv
    THEN
        BEGIN
        IF  (required_priv <> [  ]) OR any_priv
        THEN
            BEGIN
            a06_get_priv (acv, p_arr.pbasep, priv);
            WITH priv DO
                BEGIN
                IF  (priv_all_set = [  ]) AND (priv_col_exist = [  ])
                THEN
                    error_no := e_unknown_tablename
                ELSE
                    IF  NOT (any_priv)
                    THEN
                        BEGIN
                        IF  priv_all_set * required_priv = [  ]
                        THEN
                            BEGIN
                            error_no := e_missing_privilege;
                            IF  priv_col_exist <> [  ]
                            THEN
                                BEGIN
                                IF  r_sel in required_priv
                                THEN
                                    IF  priv_sel_set <> [  ]
                                    THEN
                                        error_no := e_ok;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                IF  r_upd in required_priv
                                THEN
                                    IF  priv_upd_set <> [  ]
                                    THEN
                                        error_no := e_ok;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                IF  r_link in required_priv
                                THEN
                                    IF  priv_ref_set <> [  ]
                                    THEN
                                        error_no := e_ok;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (error_no = e_ok) AND NOT new_table
    THEN
        WITH p_arr.pbasep^, sbase DO
            BEGIN
            a103GetSchemaName (acv, bschema, auth);
            IF  a_is_ddl <> ddl_rename_synonym
            THEN
                tablen := btablen^;
            (*ENDIF*) 
            IF  (btablekind <> twithkey)
                AND (btablekind <> twithoutkey)
                AND (basetable)
            THEN
                error_no := e_missing_basetable
            ELSE
                IF  (bunloaded) AND NOT (unload_allowed)
                THEN
                    error_no := e_table_is_unloaded;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  (error_no = e_missing_privilege) AND
        acv.a_isReplicationSession       AND
        (acv.a_is_ddl = ddl_drop_table)
    THEN
        BEGIN
        sysk           := a01defaultkey;
        sysk.sauthid   := p_arr.pbasep^.sbase.bauthid;
        sysk.sentrytyp := cak_euser;
        a10get_sysinfo (acv, sysk, d_release, pUser, e);
        IF  (e = e_ok) AND pUser^.suser.ureplication
        THEN
            error_no := e_ok;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  error_no <> e_ok
    THEN
        IF  errmsg_nb
        THEN
            a07_nb_put_error (acv, error_no,
                  a_ap_tree^[ act_tree_ind ].n_pos, tablen)
        ELSE
            a07_kw_put_error (acv, error_no,
                  a_ap_tree^[ act_tree_ind ].n_pos, kw_index)
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a11glob_init (VAR acv : tak_all_command_glob;
            VAR a11v : tak_a11_glob);
 
BEGIN
WITH a11v DO
    BEGIN
    a1authid            := cgg_zero_id;
    a1tableid           := cgg_zero_id;
    a1likeid            := cgg_zero_id;
    a1authname          := a01_il_b_identifier;
    a1likename          := a01_il_b_identifier;
    a1tablen            := a01_il_b_identifier;
    a1coln              := a01_il_b_identifier;
    a1liketablen        := a01_il_b_identifier;
    a1constraint_name   := a01_il_b_identifier;
    a1sysk              := a01defaultkey;
    a1valkey            := a01defaultkey;
    a1colsysp           := NIL;
    a1sysbuf            := NIL;
    a1valsysp           := NIL;
    a1domainbuf         := NIL;
    a1ti                := 2;
    a1ci                := 0;
    a1reclen            := cgg_rec_key_offset;
    a1longcharcnt       := 0;
    a1foreign_key_node  := 0;
    a1constraint_cnt    := 0;
    a1extcolno          := 0;
    a1keypos            := 0;
    a1strcolcount       := 0;
    a1part2_pos         := 0;
    (* PTS 1117216 E.Z. *)
    IF  acv.a_defaultcode = csp_unicode
    THEN
        a1default_datatype := dunicode
    ELSE
        a1default_datatype := dcha;
    (*ENDIF*) 
    a1inpkey            := false;
    a1valbufexist       := false;
    a1createtab         := false;
    a1liketable         := false;
    a1sort              := false;
    a1default_stamp     := false;
    a1like_temp_table   := false;
    a1temp_table        := false;
    a1global            := false;
    a1nolog             := false;
    a1dynamic           := false;
    a1systable          := false;
    a1for_archive       := false;   (* PTS 1117381 E.Z. *)
    a1ispacked          := false;
    a1clustered         := false;
    a1add_rec           := true;
    a1key_node          := 0;
    a1unique_node       := 0;
    a1init_colcount     := 0;
    a1long_col_cnt      := 0;
    a1serial_node       := 0;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a11init_baserecord (
            VAR acv    : tak_all_command_glob;
            VAR a11v   : tak_a11_glob);
 
VAR
      global     : boolean;
      b_err      : tgg00_BasisError;
      i          : integer;
      table_kind : tgg00_TableKind;
      instanceId : tgg00_Surrogate;
      new_treeid : tgg00_FileId;
 
BEGIN
WITH acv, a11v DO
    BEGIN
    global := a1global;
    table_kind := twithoutkey;
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  a1temp_table
        THEN
            BEGIN
            (* *** range:
                  cak_intern_res_fid + 1 ... csp_maxint4
                  *** *)
            acv.a_max_res_id :=
                  ((acv.a_max_res_id - cak_intern_res_fid)
                  MOD (csp_maxint4 - cak_intern_res_fid))
                  + succ (cak_intern_res_fid);
            g04build_temp_tree_id (new_treeid,
                  a_transinf.tri_trans);
            IF  a1nolog
                AND NOT a_progusage_add
                (* during the creation of a DBprocedure *)
                (* or a precompiler program it must be  *)
                (* possible to rollback the creation of *)
                (* a temp table (subtrans rollback)     *)
                (* even if the table is created with    *)
                (* ignore rollback                      *)
            THEN
                new_treeid.fileHandling_gg00 := new_treeid.fileHandling_gg00 +
                      [ hsNoLog_egg00 ]
            ELSE
                new_treeid.fileHandling_gg00 := new_treeid.fileHandling_gg00 -
                      [ hsNoLog_egg00 ];
            (*ENDIF*) 
            new_treeid.fileTfnTemp_gg00 := ttfnTempTable_egg00;
            a101_SetTempFileIndex (acv, new_treeid, a_max_res_id);
            (* quite ugly, but this must be done here because during *)
            (* ak11create_tree we cannot distinguish between regular *)
            (* temp tables and shared system temp tables any more    *)
            bd998NewTempFileNo (instanceId);
            a101_AddGroupedTempFile (
                  acv.a_transinf.tri_trans,
                  new_treeid,
                  instanceId);
            (* retrieve correct file id for temp file instance, *)
            (* ignore error that file does not exist            *)
            a101_GetTempFileInstance (acv.a_transinf.tri_trans,
                  new_treeid);
            acv.a_transinf.tri_trans.trError_gg00 := e_ok;
            (* mark new_treeid as fileid of an instantiated temp file *)
            (* (as opposed to a logical temp file id)              *)
            new_treeid.fileTabId_gg00     := instanceId;
            new_treeid.fileRootCheck_gg00 := NIL_PAGE_NO_GG00;
            IF  (a_is_ddl = ddl_create_as_select) AND
                (a_error_tableid <> cgg_zero_id )
            THEN
                s20int4_to_buf (new_treeid.fileTempCnt_gg00, a_error_tableid, 5);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a11table_reference (acv, a1authid, a1tablen,
              table_kind, global, a1systable, a1tableid);
        a1sysk.stableid := a1tableid;
        IF  a1temp_table
        THEN
            a1sysk.sentrytyp  := cak_eresult;
        (*ENDIF*) 
        a10_nil_get_sysinfo (acv, a1sysk, d_fix,
              sizeof (tak_baserecord), a_p_arr1.pbasep, b_err);
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        WITH a_p_arr1.pbasep^, sbase DO
            BEGIN
            SAPDB_PascalForcedFill (sizeof (tak_baserecord), @sbase,
                  cak_sysbufferoffset + mxak_base_offset + 1,
                  a10BaseRecPersistentOffset -  (* PTS 1105713, T.A. 24.02.2000 *)
                  cak_sysbufferoffset - mxak_base_offset, chr(0));
            IF  a1global
            THEN
                BEGIN
                bsegmentid   := cak00_public_segment_id
                END
            ELSE
                BEGIN
                IF  global
                THEN
                    bsegmentid   := cak00_public_segment_id
                ELSE
                    bsegmentid   := cak00_local_segment_id
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            bfirstindex    := a11firstindex (MAX_COL_PER_TAB_GG00, sbase);
            blastindex     := bfirstindex - 1;
            bauthid        := acv.a_curr_user_id;
            bschema        := a1authid;
            bschemacontext := acv.a_curr_schema_id;
            a061add_name (acv, sbase, a1tablen, btablen);
            btablekind     := table_kind;
            a11put_date_time (bdatecreate, btimecreate);
            bupdstatdate    := bdatecreate;
            bupdstattime    := btimecreate;
            balterdate      := bdatecreate;
            baltertime      := btimecreate;
            blinkexist      := [  ];
            bindexexist     := false;
            bunloaded       := false;
            bv_checkopt     := false;
            btreeid         := b01niltree_id;
            bsqlmode        := a_sqlmode;
            bnamed_constr   := 0;
            brecreate_view  := false;
            bcolumnSplitIdx := csp_maxint2;
            WITH btreeid DO
                IF  a1temp_table
                THEN
                    btreeid := new_treeid
                ELSE
                    BEGIN
                    (* PTS 1104393 E.Z. *)
                    IF  (a1tablen = a01_i_sysparseid      ) OR
                        (a1tablen = a01_i_sysmondata      ) OR
                        (a1tablen = a01_i_sysmonitor      ) OR
                        (a1tablen = a01_i_syscmd_analyze  ) OR
                        (a1tablen = a01_i_sysdata_analyze )
                    THEN
                        btreeid.fileType_gg00 :=
                              [ftsTemp_egg00, ftsConcurrent_egg00, ftsShared_egg00]
                    ELSE
                        btreeid.fileType_gg00 := [ftsPerm_egg00, ftsConcurrent_egg00];
                    (*ENDIF*) 
                    IF  ftsTemp_egg00 in btreeid.fileType_gg00
                    THEN
                        fileTfn_gg00 := tfnTemp_egg00
                    ELSE
                        fileTfn_gg00 := tfnTable_egg00;
                    (*ENDIF*) 
                    IF  NOT gg06IsNilRef (a_user_perm_ref)
                    THEN
                        fileUserRef_gg00 := a_user_perm_ref;
                    (*ENDIF*) 
                    fileVersion_gg00.ci2_gg00 := cgg_dummy_file_version;
                    fileTabId_gg00            := a1tableid;
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
            bpriv_all_set    := [  ];
            bpriv_col_exist  := [  ];
            bmaxcol          := 0;
            bkeycolcount     := 0;
            blenfixedcol     := 1;
            bvarcolcount     := 0;
            bv_tablekind     := tempty;
            bv_qualexist     := false;
            bv_level         := 0;
            bv_tabcount      := 1;
            bcntdropcol      := 0;
            bv_distinct      := no_distinct;
            bv_viewlist      := false;
            bstringcount     := 0;
            bdef_stamp       := false;
            bview_attributes := [];
            bpages           := cak_initpages;
            brows            := cak_initrows;
            battributes      := [];
            FOR i := 1 TO MAX_COL_PER_TAB_GG00 DO
                bextcolindex [ i ] := cak_cdropped;
            (*ENDFOR*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
t01name(ak_sem, '<a11init_baserecor');
&endif
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
