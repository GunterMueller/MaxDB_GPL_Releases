.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-08-29
*****************************************************
modname : VAK61
changed : 2000-08-29
module  : Select_List
 
Author  : ElkeZ
Created : 1985-02-21
*****************************************************
 
Purpose : Processing of the select-list, an ORDER BY- or
          FOR UPDATE-clause
 
Define  :
 
        PROCEDURE
              a61_check_val_params (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    sel_node : integer;
                    par_node : integer);
 
        PROCEDURE
              a61_search_table (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a61_search_table_by_columnindex (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a61_set_jump (
                    VAR mess_block : tgg00_MessBlock;
                    stentrynr : integer;
                    operatortype  : tgg00_StackEntryType);
 
        PROCEDURE
              a61_p_short_info (
                    VAR acv    : tak_all_command_glob;
                    VAR sparr  : tak_syspointerarr;
                    VAR colinf : tak00_columninfo;
                    i          : integer;
                    fix_bufpos : integer);
 
        PROCEDURE
              a61_rel_old_table (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    i        : integer);
 
        PROCEDURE
              a61_is_orderfield (
                    VAR acv       : tak_all_command_glob;
                    VAR dmli      : tak_dml_info;
                    VAR colinf    : tak00_columninfo;
                    order_ptr     : tak00_ord_fields_ptr;
                    single_column : boolean;
                    e_convert_t   : tak_convert_type;
                    curr_n        : tsp00_Int2;
                    VAR col       : tsp00_KnlIdentifier);
 
        PROCEDURE
              a61_update_column (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    VAR minkeylen  : integer;
                    curr_n         : integer);
 
        PROCEDURE
              a61_put_last_func (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a61_is_group_field (
                    VAR acv       : tak_all_command_glob;
                    VAR dmli      : tak_dml_info;
                    VAR fieldname : tsp00_KnlIdentifier;
                    extcolno      : tsp00_Int2;
                    reccolno      : tsp00_Int2;
                    is_expression : boolean;
                    expression_n  : tsp00_Int2;
                    errorpos      : integer);
 
        PROCEDURE
              a61_p_long_info (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    VAR colinf : tak00_columninfo);
 
        PROCEDURE
              a61columnnames (
                    VAR acv     : tak_all_command_glob;
                    VAR sparr   : tak_syspointerarr;
                    VAR refname : tsp00_KnlIdentifier;
                    VAR colinf  : tak00_columninfo);
 
        PROCEDURE
              a61get_column_expression (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    VAR colinf : tak00_columninfo;
                    errpos     : integer);
 
        PROCEDURE
              a61_new_expr_no (
                    VAR colinf : tak00_columninfo;
                    VAR exprno : tsp00_Int2);
 
        PROCEDURE
              a61_var_col_stackentry (
                    VAR acv          : tak_all_command_glob;
                    VAR dmli         : tak_dml_info;
                    VAR colinf       : tak00_columninfo;
                    may_be_together  : boolean;
                    VAR put_together : boolean;
                    VAR output_len   : integer;
                    is_corr_column   : boolean;
                    convert_t        : tak_convert_type;
                    convert_type     : tsp00_DataType);
 
        PROCEDURE
              a61_format_change (
                    VAR acv     : tak_all_command_glob;
                    VAR dmli    : tak_dml_info;
                    stackpos    : integer;
                    cdatatyp    : tsp00_DataType;
                    VAR datalen : tsp00_Int2);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01sysnullkey        : tgg00_SysInfoKey;
              a01defaultkey        : tgg00_SysInfoKey;
              a01_i_public         : tsp00_KnlIdentifier;
              a01_i_temp           : tsp00_KnlIdentifier;
              a01_il_b_identifier  : tsp00_KnlIdentifier;
              a01_i_expression     : tsp00_KnlIdentifier;
              a01_l_expression     : tsp00_Int2;
              a01_i_internal       : tsp00_KnlIdentifier;
              a01_i_rowno          : tsp00_KnlIdentifier;
              a01_i_domain         : tsp00_KnlIdentifier;
              a01_i_sys            : tsp00_KnlIdentifier;
 
        PROCEDURE
              a01_dt_put_datatype_node (
                    VAR acv    : tak_all_command_glob;
                    VAR curr_n : tsp00_Int2;
                    data_type  : tsp00_DataType;
                    datalen    : tsp00_Int2;
                    datafrac   : tsp00_Int2;
                    inoutlen   : integer);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06extcolno (
                    VAR baserec  : tak_baserecord;
                    extcolno     : integer;
                    VAR col_ptr  : tak00_colinfo_ptr);
 
        PROCEDURE
              a06get_username (
                    VAR acv        : tak_all_command_glob;
                    VAR tree_index : integer;
                    VAR username   : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06_systable_get (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR tableid  : tgg00_Surrogate;
                    VAR base_ptr : tak_sysbufferaddress;
                    all          : boolean;
                    VAR ok       : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061app_columnname (
                    VAR acv               : tak_all_command_glob;
                    VAR base_rec          : tak_baserecord;
                    VAR column            : tsp00_KnlIdentifier;
                    VAR index             : integer);
 
        PROCEDURE
              a061colinfo_to_var (
                    VAR src : tak00_columninfo;
                    VAR dst : tak00_columninfo);
 
        PROCEDURE
              a061eval_colname_len (VAR src : tak00_columninfo);
 
        FUNCTION
              a061exist_columnname (
                    VAR base_rec : tak_baserecord;
                    VAR column  : tsp00_KnlIdentifier;
                    VAR colptr  : tak00_colinfo_ptr) : boolean;
 
        FUNCTION
              a061exist_columnindex (VAR base_rec : tak_baserecord;
                    extcolno        : integer;
                    VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
        PROCEDURE
              a061copy_colinfo (
                    VAR src : tak00_columninfo;
                    VAR dst : tak00_columninfo);
 
        PROCEDURE
              a061get_colname (
                    VAR col_info : tak00_columninfo;
                    VAR colname  : tsp00_KnlIdentifier);
 
        FUNCTION
              a061identifier_len (VAR id : tsp00_KnlIdentifier) : integer;
 
        PROCEDURE
              a061sort (
                    VAR acv               : tak_all_command_glob;
                    VAR base_rec          : tak_baserecord;
                    last_used_expr_no     : integer;
                    VAR duplicate_column  : boolean;
                    VAR duplicate_colname : tsp00_KnlIdentifier);
&       ifdef trace
 
        PROCEDURE
              a061td_colinfo (
                    VAR colinfo : tak00_columninfo;
                    index : integer);
&       endif
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_hex_uni_error (
                    VAR acv     : tak_all_command_glob;
                    uni_err     : tsp8_uni_error;
                    err_code    : tsp00_Int4;
                    to_unicode  : boolean;
                    bytestr     : tsp00_MoveObjPtr;
                    len         : tsp00_Int4 );
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
        PROCEDURE
              a07_tb_put_error (
                    VAR acv    : tak_all_command_glob;
                    b_err      : tgg00_BasisError;
                    err_code   : tsp00_Int4;
                    VAR tab_id : tgg00_Surrogate);
 
        PROCEDURE
              a07put_error_pos (
                    VAR acv : tak_all_command_glob;
                    err_pos : tsp00_Int4);
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10new (
                    VAR acv  : tak_all_command_glob;
                    obj_size : tsp00_Int4;
                    VAR p    : tak_sysbufferaddress);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              SQLManager : vak101;
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
        FUNCTION
              a101_GetExtendedTempFileType(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tgg00_TfnTemp;
 
        FUNCTION
              a101_GetTempFileLevel(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tsp00_Int2;
 
        FUNCTION
              a101_GetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
      ------------------------------ 
 
        FROM
              AK_View_semantic : VAK16;
 
        PROCEDURE
              a16col_to_view_description (
                    VAR acv      : tak_all_command_glob;
                    VAR dmli     : tak_dml_info;
                    VAR col_info : tak00_columninfo;
                    use_extcolno : boolean);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK54;
 
        PROCEDURE
              a54_internal_function (
                    VAR acv : tak_all_command_glob;
                    VAR m : tgg00_MessBlock;
                    st_no : integer);
 
        FUNCTION
              a54_optim_select_fetch (VAR acv : tak_all_command_glob) : boolean;
 
        PROCEDURE
              a54_fixedpos (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a54datetime_parsinfo (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    stackpos : integer);
 
      ------------------------------ 
 
        FROM
              Execute_factor_col_function: VAK641;
 
        PROCEDURE
              a641add_mapchar (
                    VAR acv            : tak_all_command_glob;
                    VAR dmli           : tak_dml_info;
                    VAR colin          : tak00_scolinf;
                    VAR setname        : tsp00_KnlIdentifier;
                    curr_n             : integer;
                    first_int          : integer);
 
        PROCEDURE
              a641get_mapcharset (
                    VAR acv            : tak_all_command_glob;
                    VAR mapcharsetname : tsp00_KnlIdentifier;
                    error_pos          : integer;
                    VAR max_maplen     : integer;
                    VAR sysbuf         : tak_sysbufferaddress);
 
        PROCEDURE
              a641string_set_operator (
                    VAR acv      : tak_all_command_glob;
                    operator     : tgg00_StackOpBuildIn;
                    destlength   : integer;
                    sourcelength : integer;
                    tab1         : char;
                    tab2         : char);
 
        PROCEDURE
              a641l_push_language (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a641f_push_format (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
      ------------------------------ 
 
        FROM
              Execute_Where_Part : VAK65;
 
        PROCEDURE
              a65ch_format (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    VAR startstack : integer;
                    VAR colin      : tak00_scolinf;
                    left_type      : tsp00_DataType;
                    d_type         : tsp00_DataType);
 
        PROCEDURE
              a65_val_expr (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    VAR colin  : tak00_scolinf;
                    first_node : integer);
 
        PROCEDURE
              a65_look_for_datatypes (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    first_node : integer);
 
        FUNCTION
              a65_datatypes_ok (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    VAR dm_type    : tsp00_DataType;
                    VAR dm_iolen   : tsp00_Int2;
                    ctype          : tsp00_DataType;
                    is_subquery    : boolean;
                    first_node     : integer;
                    error_pos      : tsp00_Int4;
                    convert        : boolean;
                    VAR convert_t  : tak_convert_type) : boolean;
 
        PROCEDURE
              a65_convert (
                    VAR acv   : tak_all_command_glob;
                    operator  : tak_convert_type;
                    maxlength : integer);
 
        PROCEDURE
              a65subq_get_val (
                    VAR acv    : tak_all_command_glob;
                    first_node : integer;
                    iolen      : integer);
 
      ------------------------------ 
 
        FROM
              Execute_Select_Expression : VAK660;
 
        FUNCTION
              a660pos_pred (
                    VAR acv  : tak_all_command_glob;
                    pos_node : integer) : integer;
 
      ------------------------------ 
 
        FROM
              Subquery_handling : VAK661;
 
        PROCEDURE
              a661_build_t_fromsel_tableid (
                    VAR syskey_tableid  : tgg00_Surrogate;
                    VAR fn_tableid      : tgg00_Surrogate;
                    VAR curr_ex_parskey : tak_parskey;
                    site                : tgg00_ServerdbNo;
                    from_select_no      : tsp00_Int2);
 
        PROCEDURE
              a661_get_from_select_table (
                    VAR acv     : tak_all_command_glob;
                    VAR tableid : tgg00_Surrogate;
                    VAR pbasep  : tak_sysbufferaddress;
                    dstate      : tak_directory_state;
                    all         : boolean;
                    VAR f_ok    : boolean);
 
        FUNCTION
              a661_is_fromsel_table (
                    VAR acv     : tak_all_command_glob;
                    VAR ftreeid : tgg00_FileId) : boolean;
 
      ------------------------------ 
 
        FROM
              Resultname_handling : VAK663;
 
        PROCEDURE
              a663get_result_records (
                    VAR acv    : tak_all_command_glob;
                    dstate     : tak_directory_state;
                    resid      : tsp00_Int4;
                    VAR pbasep : tak_sysbufferaddress;
                    VAR ok     : boolean);
 
        PROCEDURE
              a663restable_get (
                    VAR acv    : tak_all_command_glob;
                    dstate     : tak_directory_state;
                    VAR tablen : tsp00_KnlIdentifier;
                    VAR sparr  : tak_syspointerarr;
                    VAR ok     : boolean);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id      : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code           : tgg04_CodeGlobals;
              g01unicode        : boolean;
              g01glob           : tgg00_KernelGlobals;
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        FUNCTION
              g04isnull_value (VAR stackentry : tgg00_StackEntry;
                    VAR mblock        : tgg00_MessBlock) : boolean;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove   (
                    mod_id         : tsp00_C6;
                    mod_intern_num : tsp00_Int4;
                    size1          : tsp00_Int4;
                    size2          : tsp00_Int4;
                    val1           : tsp00_MoveObjPtr;
                    p1             : tsp00_Int4;
                    val2           : tsp00_MoveObjPtr;
                    p2             : tsp00_Int4;
                    cnt            : tsp00_Int4;
                    VAR e          : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30unilnr (
                    str       : tsp00_MoveObjPtr;
                    skip_val  : tsp00_C2;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
        PROCEDURE
              s30cmp (
                    VAR buf1     : tsp00_MoveObj;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tsp00_MoveObj;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
        PROCEDURE
              s30cmp1 (
                    VAR buf1     : tsp00_MoveObj;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tsp00_LongDescriptor;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
        PROCEDURE
              s30cmp2 (
                    VAR buf1     : tsp00_KnlIdentifier;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tsp00_KnlIdentifier;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
        FUNCTION
              s30eq (
                    VAR a, b: tsp00_KnlIdentifier;
                    bi, cnt : tsp00_Int4): boolean;
 
        FUNCTION
              s30klen (
                    VAR str : tsp00_KnlIdentifier;
                    val : char;
                    cnt : integer) : integer;
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80 : VSP80;
 
        PROCEDURE
              s80uni_trans (
                    src_ptr         : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01recursive_state (
                    debug           : tgg00_Debug;
                    nam             : tsp00_Sname;
                    recursive_state : tak_recursive_state);
 
        PROCEDURE
              t01trace_symbol(
                    debug   : tgg00_Debug;
                    name    : tsp00_Sname;
                    symb    : tak_sc_symbol);
 
        PROCEDURE
              t01knl_identifier (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01moveobj (
                    debug       : tgg00_Debug;
                    VAR moveobj : tsp00_MoveObj;
                    startpos    : tsp00_Int4;
                    endpos      : tsp00_Int4);
 
        PROCEDURE
              t01bool (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    curr_bool: boolean);
 
        PROCEDURE
              t01buf (
                    debug   : tgg00_Debug;
                    VAR buf : tak_systembuffer;
                    pos     : integer;
                    endpos  : integer);
 
        PROCEDURE
              t01buf1 (
                    debug   : tgg00_Debug;
                    VAR buf : tsp00_KnlIdentifier;
                    pos     : integer;
                    endpos  : integer);
 
        PROCEDURE
              t01stackentry (
                    debug          : tgg00_Debug;
                    VAR st         : tgg00_StackEntry;
                    entry_index    : integer);
 
        PROCEDURE
              t01surrogate (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR tabid : tgg00_Surrogate);
 
        PROCEDURE
              t01name (
                    level : tgg00_Debug;
                    nam : tsp00_Name);
 
        PROCEDURE
              t01lidentifier (
                    level      : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR m         : tgg00_MessBlock);
 
        PROCEDURE
              t01aptree (
                    layer         : tgg00_Debug;
                    VAR a_ap_tree : tak_ap_max_tree;
                    node_cnt      : integer;
                    hint_node     : tsp00_Int2);
 
        PROCEDURE
              t01command_kind (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    command_kind : tak_commandkind);
&       ENDIF
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              s30cmp1;
 
              tsp00_MoveObj tsp00_LongDescriptor
 
        PROCEDURE
              s30cmp2;
 
              tsp00_MoveObj tsp00_KnlIdentifier
              tsp00_MoveObj tsp00_KnlIdentifier
 
        FUNCTION
              s30eq;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        FUNCTION
              s30klen;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              t01buf;
 
              tsp00_Buf tak_systembuffer
 
        PROCEDURE
              t01buf1;
 
              tsp00_Buf tsp00_KnlIdentifier
 
        PROCEDURE
              t01aptree;
 
              tsp00_MoveObj tak_ap_max_tree
 
.CM *-END-* synonym -------------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      c_all             = true (* a06_systable_get   *);
      (*                          a661_get_from_select_table *)
      c_use_extcolno    = true (* a16col_to_view_description *);
      c_subquery_get    = true (* ak61sel_val_expr   *);
      c_join            = true (* ak61_comp_part_tree *);
      c_is_expression   = true (* a61_is_group_field *);
      c_single_column   = true (* a61_is_orderfield  *);
      c_is_corr_column  = true (* a61_var_col_stackentry *);
      c_convert         = true (* a65_datatypes_ok   *);
      c_is_subquery     = true (* a65_datatypes_ok   *);
      (*                                             *)
      c_trans_to_uni    = true (* a07_hex_uni_error  *);
      c_unicode_wid     = 2    (* a07_hex_uni_error  *);
 
TYPE
      ak61_group = ARRAY [ 0.. cak00_maxordercolumns ] OF boolean;
 
 
(*------------------------------*) 
 
PROCEDURE
      ak61all_columns (
            VAR acv       : tak_all_command_glob;
            VAR dmli      : tak_dml_info;
            VAR col_index : integer);
 
VAR
      _is_output_column     : boolean;
      _long_column_found    : boolean;
      _newlong_column_found : boolean;
      _extdatetime          : boolean;
      _is_corr_subq         : boolean;
      _is_io                : boolean;
      _oflw_op              : tgg00_StackOpOutput;
      _put_together         : boolean;
      _together_allowed     : boolean;
      _cntpar               : integer;
      _dummy_len            : integer;
      _fieldno              : integer;
      _output_index         : integer;
      _new_col_ptr          : tak00_colinfo_ptr;
      _st_index             : integer;
      _colname              : tsp00_KnlIdentifier;
      _colinf               : tak00_columninfo;
      _convert_t            : tak_convert_type;
 
BEGIN
&IFDEF TRACE
t01int4 (ak_sem, 'init_ex_kind', ord (acv.a_init_ex_kind));
&ENDIF
_fieldno              := 1;
_output_index         := 0;
_st_index             := acv.a_mblock.mb_qual^.mfirst_free;
acv.a_long_desc_pos      := 0;
_is_corr_subq         := dmli.d_subquery AND (dmli.d_corr <> no_correlation);
WHILE ((_fieldno <= dmli.d_sparr.pbasep^.sbase.bmaxcol)
      AND (acv.a_returncode = 0)) DO
    BEGIN
    _convert_t := conv_none;
    _extdatetime := false;
&   IFDEF TRACE
    t01int4 (ak_sem, 'output_pos  ', acv.a_output_data_pos);
    t01int4 (ak_sem, 'fieldno     ', _fieldno);
    t01int4 (ak_sem, 'd_cntpar    ', dmli.d_cntpar);
    t01int4 (ak_sem, 'a_outer_join', ord(acv.a_outer_join));
    t01int4 (ak_sem, 'd_outer_join', ord(dmli.d_outer_join));
    t01int4 (ak_sem, 'a_internalsq', ord(acv.a_internal_sql));
&   ENDIF
    WITH dmli.d_sparr.pbasep^.sbase DO
        BEGIN
        a06extcolno (dmli.d_sparr.pbasep^.sbase,
              _fieldno, dmli.d_colbuf);
        _oflw_op    := op_o_none;
        (* PTS 1111576 E.Z. *)
        IF  btablekind in [ tonebase, tview, tresult, tcomplexview  ]
        THEN
            IF  acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].
                n_proc in [ a62, a63, a16 ]
            THEN
                _oflw_op := op_o_output_oflw;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    a061colinfo_to_var (dmli.d_colbuf^, _colinf);
    WITH _colinf DO
        BEGIN
        (* PTS 1106508 E.Z. *)
        _long_column_found :=
              (cdatatyp in [ dstra, dstrb, dstruni ]);
        _newlong_column_found :=
              (cdatatyp in [ dlonga, dlongb, dlonguni ]);
        _is_output_column := NOT (ctdropped in ccolpropset)
              AND
              NOT (ctinvisible in ccolpropset)
              AND (* PTS 1105795 M.Ki. *)
              (* PTS 112080 E.Z. *)
              (
              NOT (
              (dmli.d_sparr.pbasep^.sbase.btablekind = tonebase)         AND
              (dmli.d_sparr.pbasep^.sbase.bv_tablekind = tcatalog_table) AND
              (cdatatyp in [ dlonga, dlongb,
              dlonguni, dstruni, dstra, dstrb ])     AND
              (acv.a_insert_select OR (acv.a_init_ddl = ddl_create_as_select))  )
              )
              AND
              (((ccolpropset <> [ ctkey, ctopt ]) (* column isn't SYSKEY *)
              AND
              (ccolpropset <> [ ctkey, ctopt, ctmulti ]))
              (* PTS 1111576 E.Z. *)
              );
        _cntpar := dmli.d_cntpar;
        IF  _cntpar <= 0
        THEN
            BEGIN
            IF  _is_output_column
            THEN
                IF  (dmli.d_subquery OR NOT dmli.d_single) AND
                    (NOT acv.a_from_select)
                THEN
                    a07_b_put_error (acv,
                          e_select_col_list_too_long, dmli.d_vppos)
                ELSE
                    WITH acv.a_transinf.tri_trans DO
                        trWarning_gg00 := trWarning_gg00 + [ warn0_exist,
                              warn3_output_not_into_columns ];
                    (*ENDWITH*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            ak61iolen_get (acv, dmli, _extdatetime, _is_io,
                  cdatatyp, cdatalen, cinoutlen);
        (*ENDIF*) 
        IF  _is_output_column AND (_cntpar > 0)
        THEN
            BEGIN
            a061get_colname (_colinf, dmli.d_column);
            ak61outparam_typecheck (acv, dmli, _colinf);
            ak61col_long_shortinfo (acv, dmli, _colinf);
            IF  ((acv.a_returncode = 0) AND NOT dmli.d_single)
            THEN
                BEGIN
                a16col_to_view_description (acv, dmli,
                      _colinf, c_use_extcolno);
                ak61build_colinfo (acv, dmli, _colinf,
                      _new_col_ptr, _convert_t, col_index);
                END;
            (*ENDIF*) 
            END;
&       IFDEF TRACE
        (*ENDIF*) 
        t01int4  (ak_sem, 'cntpar@@@@@@', _cntpar);
        t01int4  (ak_sem, 'is_output_co', ord (_is_output_column));
        t01int4  (ak_sem, 'long_column_', ord (_long_column_found));
        t01int4  (ak_sem, 'newlong_col ', ord (_newlong_column_found));
        t01int4  (ak_sem, 'cdatatyp    ', ord (cdatatyp));
        t01messblock (ak_sem, 'all_columns1', acv.a_mblock);
&       ENDIF
        IF  (acv.a_returncode = 0) AND
            (_long_column_found OR _newlong_column_found) AND
            (dmli.d_distinct <> no_distinct)
        THEN
            a07_nb_put_error (acv,
                  e_command_for_string_not_allow,
                  dmli.d_vppos, dmli.d_column);
        (*ENDIF*) 
        IF  (acv.a_returncode = 0) AND
            (_cntpar > 0)      AND
            _is_output_column
        THEN
            BEGIN
            (* PTS 1000985/1001162 E.Z. *)
            _together_allowed := false;
            IF  ((ccolstack.etype = st_fixkey) OR
                ( ccolstack.etype = st_fixcol))
            THEN (* output column of fixed length *)
                BEGIN
                (* PTS 1107681 E.Z. *)
                _st_index := acv.a_mblock.mb_qual^.mfirst_free;
                a61_var_col_stackentry (acv, dmli, _colinf,
                      _together_allowed, _put_together,
                      _dummy_len, NOT c_is_corr_column, _convert_t, dunknown);
                (* END OF PTS 1000985/1001162 E.Z. *)
                (* PTS 1106343 E.Z. *)
                (* always true, may be the next column *)
                (* will be appended                    *)
                _put_together := true;
&               ifdef TRACE
                t01int4 (ak_sem, 'd_inoutpos 1', dmli.d_inoutpos);
                t01int4 (ak_sem, 'cdatalen    ', cdatalen);
&               endif
                END
            ELSE (* etype = st_varkey, st_varcol, st_longvarchar *)
                (* or first column of (later) concatenated ones *)
                BEGIN
                (* PTS 1111575 E.Z. *)
                (* PTS 1106343 E.Z. *)
                a61_var_col_stackentry (acv, dmli, _colinf,
                      _together_allowed, _put_together,
                      _dummy_len, NOT c_is_corr_column,
                      (* PTS 1000985/1001162 E.Z. *)
                      _convert_t, dunknown);
                END;
            (*ENDIF*) 
&           ifdef TRACE
            t01messblock (ak_sem, 'all_columns2', acv.a_mblock);
&           endif
            IF  (acv.a_returncode = 0) AND
                (_cntpar > 0)      AND
                _is_output_column
            THEN
                BEGIN
                IF  (acv.a_returncode = 0) AND
                    dmli.d_use_order                          AND
                    NOT _is_corr_subq
                THEN
                    a61_is_orderfield (acv, dmli, _colinf, @dmli.d_order_cols,
                          NOT _put_together, _convert_t, 0, dmli.d_column);
                (*ENDIF*) 
                IF  ((acv.a_returncode = 0) AND dmli.d_group)
                THEN
                    BEGIN
                    a061get_colname (dmli.d_colbuf^, _colname);
                    a61_is_group_field (acv, dmli, _colname,
                          dmli.d_colbuf^.cextcolno, dmli.d_colbuf^.creccolno,
                          NOT c_is_expression, 0, dmli.d_vppos)
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  dmli.d_use_order AND _is_corr_subq
            THEN
                a61_is_orderfield (acv, dmli, _colinf, @dmli.d_order_cols,
                      c_single_column, _convert_t, 0, dmli.d_column);
&           ifdef TRACE
            (*ENDIF*) 
            t01messblock (ak_sem, 'all_columns3', acv.a_mblock);
&           endif
            END;
        (*ENDIF*) 
        IF  _is_output_column
        THEN
            col_index := succ (col_index);
        (*ENDIF*) 
        IF  _extdatetime OR NOT (_is_output_column)
        THEN (* restrict concatenation with next column *)
            _colinf.ccolstack.etype := st_varcol;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    _fieldno := succ(_fieldno);
    END;
(*ENDWHILE*) 
END;
 
(* PTS 1111576 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak61build_colinfo (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            VAR colinf     : tak00_columninfo;
            VAR col_ptr    : tak00_colinfo_ptr;
            VAR convert_t  : tak_convert_type;
            col_index      : integer);
 
VAR
      _col        : tsp00_KnlIdentifier;
      _index      : integer;
      _colno      : integer;
      _dtype_n    : integer;
      _types_ok   : boolean;
      _level_node : tsp00_Int2;
 
BEGIN
&ifdef TRACE
t01bool (ak_sem, 'd_subquery  ', dmli.d_subquery);
t01bool (ak_sem, 'd_use_sub   ', dmli.d_use_sub );
t01int4 (ak_sem, 'a_union_cnt ', acv.a_union_cnt);
t01command_kind (ak_sem, 'command_kind', acv.a_command_kind);
t01int4 (ak_sem, 'act_node    ', dmli.d_act_node);
t01recursive_state( ak_sem, 'a_recursive_', acv.a_recursive_state );
&endif
col_ptr := NIL;
IF  (NOT dmli.d_subquery) OR dmli.d_first_union OR acv.a_from_select
THEN
    BEGIN
&   ifdef trace
    t01int4 (ak_sem, 'a_intern_sel', acv.a_intern_select_cnt );
    t01int4 (ak_sem, 'a_max_intern', acv.a_max_intern_select );
&   endif
    IF  (acv.a_intern_select_cnt = acv.a_max_intern_select) OR
        (acv.a_union_cnt         > 0)                   OR
        (acv.a_fromsel_n         > 0)                   OR
        (acv.a_recursive_state = rs_first_select)
    THEN
        BEGIN
&       ifdef trace
        t01bool (ak_sem, 'd_union     ', dmli.d_union);
        t01bool (ak_sem, 'd_first_unio', dmli.d_first_union);
        t01int4 (ak_sem, 'a_union_cnt ', acv.a_union_cnt);
&       endif
        IF  (dmli.d_view OR (acv.a_recursive_state = rs_check_select_list)) AND
            dmli.d_view_col_list AND
            NOT dmli.d_subquery
        THEN
            IF  dmli.d_view_col_node > 0
            THEN
                BEGIN
                a05identifier_get (acv,
                      dmli.d_view_col_node, sizeof (_col), _col);
                dmli.d_view_col_node := acv.a_ap_tree^[dmli.d_view_col_node].n_sa_level
                END
            ELSE
                a07_b_put_error (acv, e_select_col_list_too_long, dmli.d_vppos)
            (*ENDIF*) 
        ELSE
            IF  NOT dmli.d_view_col_list AND (dmli.d_refname <> a01_il_b_identifier)
            THEN
                _col := dmli.d_refname
            ELSE (* no expression *)
                _col := colinf.ccolumnn;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  acv.a_returncode = 0 (* purify *)
        THEN
            IF  dmli.d_esparr.pbasep^.sbase.bmaxcol >= MAX_COL_PER_TAB_GG00
            THEN
                a07_b_put_error (acv, e_select_col_list_too_long, 1)
            ELSE
                a061app_columnname (acv, dmli.d_esparr.pbasep^.sbase,
                      _col, _index);
            (*ENDIF*) 
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            col_ptr := a103GetColumn (dmli.d_esparr.pbasep^.sbase, _index);
            WITH col_ptr^, ccolstack DO
                BEGIN
                IF  dmli.d_refname <> a01_il_b_identifier
                THEN
                    ccolpropset := ccolpropset +
                          [ ctviewname ];
                (*ENDIF*) 
                IF  (dmli.d_view) AND (dmli.d_phase_cnt < 4)
                THEN
                    BEGIN
                    a061copy_colinfo (colinf, col_ptr^);
                    cextcolno := dmli.d_esparr.pbasep^.sbase.bmaxcol;
                    ctabno   := ctabno +
                          dmli.d_tabarr^[ dmli.d_acttabindex ].ocounttabs;
                    ecol_tab[ 2 ] := chr(ctabno);
                    END
                ELSE
                    BEGIN
                    IF  ctopt in colinf.ccolpropset
                    THEN
                        ccolpropset := [ ctopt ]
                    ELSE
                        ccolpropset := [  ];
                    (*ENDIF*) 
                    etype         := st_fixcol;
                    eop           := op_none;
                    ecol_tab[ 1 ] := chr(0);
                    cextcolno     := dmli.d_outcolno;
                    creccolno     := cextcolno;
                    ctabno        := 1;
                    cdatatyp      := colinf.cdatatyp;
                    cdatalen      := colinf.cdatalen;
                    cdatafrac     := colinf.cdatafrac;
                    cinoutlen     := colinf.cinoutlen;
                    cshiftoutchar := colinf.cshiftoutchar;
                    epos          := dmli.d_inoutpos - cgg_rec_key_offset - dmli.d_keylen;
                    elen_var      := cinoutlen;
                    ecol_tab[ 2 ] := chr(ctabno);
                    (* PTS 1116837 E.Z. *)
                    cnextind     := 0;
                    cudtdatatype := cak_edummy;
                    cfiller02    := chr(0);
                    END
                (*ENDIF*) 
                END
            (*ENDWITH*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
ELSE
    BEGIN
    IF  acv.a_union_cnt <= 1
    THEN
        BEGIN
        IF  (dmli.d_use_sub OR (acv.a_command_kind = union_in_sub_command))
        THEN
            BEGIN
            (* PTS 1000985/1001162 E.Z. *)
            (* look if there is a corresponding datatype_node *)
            (* if, then check, else insert one *)
            _colno := 1;
            _dtype_n := dmli.d_act_node;
&           ifdef TRACE
            t01int4 (ak_sem, 'd_outcolno  ', dmli.d_outcolno);
            t01int4 (ak_sem, 'colno       ', _colno);
            t01int4 (ak_sem, 'dtype_n     ', _dtype_n);
&           endif
            WHILE (_colno < dmli.d_outcolno) AND
                  (acv.a_ap_tree^[ _dtype_n ].n_sa_level <> 0) DO
                BEGIN
                _colno := succ(_colno);
                _dtype_n := acv.a_ap_tree^[ _dtype_n ].n_sa_level;
&               ifdef TRACE
                t01int4 (ak_sem, 'colno       ', _colno);
                t01int4 (ak_sem, 'dtype_n     ', _dtype_n);
&               endif
                END;
            (*ENDWHILE*) 
            IF  (_colno = dmli.d_outcolno) AND
                (_dtype_n <> 0)
            THEN
                BEGIN
                _types_ok := a65_datatypes_ok (acv, dmli,
                      acv.a_ap_tree^[ _dtype_n ].n_datatype,
                      acv.a_ap_tree^[ _dtype_n ].n_length,
                      colinf.cdatatyp, c_is_subquery,
                      dmli.d_act_node, acv.a_ap_tree^[ dmli.d_act_node ].n_pos,
                      NOT c_convert, convert_t);
                END
            ELSE
                BEGIN
                WITH colinf DO
                    (* Create a node with datatype and length... *)
                    a01_dt_put_datatype_node (acv,
                          _level_node, cdatatyp, cdatalen, cdatafrac, cinoutlen);
                (*ENDWITH*) 
                acv.a_ap_tree^[ _dtype_n ].n_sa_level := _level_node
                END
            (*ENDIF*) 
            END
        ELSE
            BEGIN (* try to go to 'col_index'th node; be aware that *)
            (*       there can be only one dtype node (e.g. exists) *)
            _dtype_n  := acv.a_ap_tree^[ dmli.d_act_node ].n_sa_level;
&           ifdef TRACE
            t01int4 (ak_sem, 'col_index   ', col_index);
            t01int4 (ak_sem, 'dtype_n     ', _dtype_n);
&           endif
            _index := col_index;
            WHILE (_index > 1) AND
                  (acv.a_ap_tree^[ _dtype_n ].n_sa_level <> 0) DO
                BEGIN
                _index   := pred (_index);
                _dtype_n := acv.a_ap_tree^[ _dtype_n ].n_sa_level
                END;
            (*ENDWHILE*) 
&           ifdef TRACE
            t01int4 (ak_sem, 'col_index   ', _index);
            t01int4 (ak_sem, 'dtype_n     ', _dtype_n);
&           endif
            (* PTS 1000985/1001162 E.Z. *)
            _types_ok := a65_datatypes_ok (acv, dmli,
                  acv.a_ap_tree^[ _dtype_n ].n_datatype,
                  acv.a_ap_tree^[ _dtype_n ].n_length,
                  colinf.cdatatyp, c_is_subquery,
                  dmli.d_act_node, acv.a_ap_tree^[ dmli.d_act_node ].n_pos,
                  NOT c_convert, convert_t);
            IF  convert_t = conv_ascii_to_unicode
            THEN
                WITH colinf DO
                    BEGIN
                    cdatatyp := dunicode;
                    cinoutlen := (2*cdatalen) + 1
                    END
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak61exist_columnname (
            VAR base_rec    : tak_baserecord;
            VAR column      : tsp00_KnlIdentifier;
            VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
VAR
      _found        : boolean;
      _res          : tsp00_LcompResult;
      _i            : integer;
      _colname_len  : integer;
      _col_ptr      : tak00_colinfo_ptr;
 
BEGIN
&ifdef trace
t01lidentifier (ak_sem, column);
t01int4 (ak_sem, 'firstindex  ', base_rec.bfirstindex);
t01int4 (ak_sem, ' lastindex  ', base_rec.blastindex);
&endif
_colname_len := a061identifier_len (column);
_found       := false;
colinfo_ptr := NIL;
_i := base_rec.bfirstindex;
WHILE NOT _found AND (_i <= base_rec.blastindex) DO
    BEGIN
    _col_ptr := a103GetColumn (base_rec, _i);
&   IFDEF TRACE
    a061td_colinfo (_col_ptr^, _i);
&   endif
    s30cmp2 (_col_ptr^.ccolumnn, 1, ord (_col_ptr^.ccolumnn_len),
          column, 1, _colname_len, _res);
    IF  _res = l_equal
    THEN
        _found := true
    ELSE
        _i := succ(_i)
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
&IFDEF TRACE
IF  _found
THEN
    a061td_colinfo (_col_ptr^, _i);
&endif
(*ENDIF*) 
colinfo_ptr := _col_ptr;
ak61exist_columnname := _found
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61iolen_get (
            VAR acv         : tak_all_command_glob;
            VAR dmli        : tak_dml_info;
            VAR extdatetime : boolean;
            VAR is_io       : boolean;
            d_typ           : tsp00_DataType;
            VAR d_len       : tsp00_Int2;
            VAR d_iolen     : tsp00_Int2);
 
BEGIN
extdatetime := false;
is_io       := false;
IF  (
    ((acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_proc in [ a63, a62 ]) OR
    (( acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_proc    = a43) AND
    (  acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc = cak_x_explain)))
    AND
    NOT dmli.d_subquery
    AND
    (NOT acv.a_from_select OR
    ( d_typ in  [ dstra, dstrb, dstruni, dlonga, dlongb, dlonguni ]))
    AND
    NOT (acv.a_is_ddl = ddl_create_as_select)
    (* PTS 1106654 E.Z. *)
    AND
    ((acv.a_intern_select_cnt = acv.a_max_intern_select) OR
    ( d_typ in  [ dstra, dstrb, dstruni,
    dlonga, dlongb, dlonguni ]))
    )
    OR
    dmli.d_first_union
THEN
    BEGIN
    is_io := true;
    CASE d_typ OF
        ddate, dtimestamp :
            BEGIN
            (* PTS 1111575 E.Z. *)
            extdatetime := true;
            IF  d_typ = ddate
            THEN
                BEGIN
                IF  d_len < mxsp_extdate
                THEN
                    d_len := mxsp_extdate
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  d_len < mxsp_exttimestamp
                THEN
                    d_len := mxsp_exttimestamp;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  (acv.a_out_packet^.sp1_header.sp1h_mess_code in
                [ csp_unicode_swap, csp_unicode ])
                (* PTS 1113800 E.Z. *)
                AND
                NOT dmli.d_view
                AND
                NOT dmli.d_subquery
                AND
                (acv.a_intern_select_cnt = acv.a_max_intern_select)
                AND
                (acv.a_qualified_jv_upd = no_jv_upd)
                AND
                NOT acv.a_ascii_in_and_output (* new feature *)
            THEN
                d_iolen := succ(2*d_len)
            ELSE
                d_iolen := d_len + 1
            (*ENDIF*) 
            END;
        dtime :
            BEGIN
            IF  (acv.a_out_packet^.sp1_header.sp1h_mess_code in
                [ csp_unicode_swap, csp_unicode ])
                (* PTS 1113800 E.Z. *)
                AND
                NOT dmli.d_view
                AND
                NOT dmli.d_subquery
                AND
                (acv.a_intern_select_cnt = acv.a_max_intern_select)
                AND
                (acv.a_qualified_jv_upd = no_jv_upd)
                AND
                NOT acv.a_ascii_in_and_output (* new feature *)
            THEN
                d_iolen := succ(2*d_len);
            (* PTS 1111575 E.Z. *)
            (*ENDIF*) 
            END;
        dunicode :
            BEGIN
            (* even with a_max_codewidth > 2 *)
            (* the inoutlen has to be odd    *)
            (* to allow g20unifill for the   *)
            (* output before uni_transing it *)
            IF  acv.a_max_codewidth > 2
            THEN
                d_iolen := ((((((d_iolen-1) DIV 2) *
                      acv.a_max_codewidth)+1) DIV 2) * 2) + 1;
            (* PTS 1111575 E.Z. *)
            (*ENDIF*) 
            END;
        dcha, dvarchara :
            IF  (acv.a_out_packet^.sp1_header.sp1h_mess_code in
                [ csp_unicode_swap, csp_unicode ])
                (* PTS 1113800 E.Z. *)
                AND
                NOT dmli.d_view
                AND
                NOT dmli.d_subquery
                AND
                (acv.a_intern_select_cnt = acv.a_max_intern_select)
                AND
                (acv.a_qualified_jv_upd = no_jv_upd)
                AND
                NOT acv.a_ascii_in_and_output (* new feature *)
            THEN
                d_iolen := succ(2*d_len)
            ELSE
                IF  NOT (acv.a_out_packet^.sp1_header.sp1h_mess_code in
                    [ csp_unicode_swap, csp_unicode ])
                    AND
                    (d_iolen = succ(2*d_len))
                    (* column out of dbproc, prepared with unicode order interface *)
                THEN
                    d_iolen := succ(d_len)
                (*ENDIF*) 
            (*ENDIF*) 
        OTHERWISE
            IF  (NOT dmli.d_view) OR (dmli.d_phase_cnt >= 4)
            THEN
                BEGIN
                IF  (d_typ in [ dstra, dstrb, dstruni,
                    dlonga, dlongb, dlonguni ])
                THEN
                    BEGIN
                    (* PTS 1116801 E.Z. *)
                    d_len := mxsp_long_desc;
                    d_iolen   := d_len + 1;
                    (* PTS 1111575 E.Z. *)
                    IF  acv.a_return_segm^.sp1r_function_code = csp1_mselect_into_fc
                    THEN
                        BEGIN
                        acv.a_return_segm^.sp1r_function_code := csp1_select_into_fc;
                        acv.a_precomp_info_byte := csp1_p_none
                        END;
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        END;
    (*ENDCASE*) 
    END
ELSE (* PTS 1105795 M.Ki. *)
    IF  ((acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_proc = a56)
        AND
        NOT (dmli.d_subquery OR acv.a_from_select)
        AND
        NOT (acv.a_is_ddl = ddl_create_as_select)
        AND
        NOT dmli.d_pseudo_ins_select
        AND
        ((acv.a_intern_select_cnt = acv.a_max_intern_select) OR
        ( d_typ in  [ dstra, dstrb, dstruni,
        dlonga, dlongb, dlonguni ]))
        )
    THEN
        BEGIN
&       IFDEF TRACE
        t01int4  (ak_sem, 'we are in   ', 1);
&       ENDIF
        IF  (NOT dmli.d_view) OR (dmli.d_phase_cnt >= 4)
        THEN
            BEGIN
            IF  (d_typ in [ dstra, dstrb, dstruni,
                dlonga, dlongb, dlonguni ])
                (* PTS 1120890 E.Z. *)
                AND (d_len < 2 * SURROGATE_MXGG00)
            THEN
                BEGIN
                (* in case of insert/select we need to store both the *)
                (* file surrogate and the table surrogate to be able  *)
                (* to copy the LONG value later                       *)
                d_len     := 2 * SURROGATE_MXGG00;
                d_iolen   := d_len + 1;
                (* PTS 1111575 E.Z. *)
                IF  acv.a_return_segm^.sp1r_function_code = csp1_mselect_into_fc
                THEN
                    BEGIN
                    acv.a_return_segm^.sp1r_function_code := csp1_select_into_fc;
                    acv.a_precomp_info_byte := csp1_p_none
                    END;
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    ELSE
        IF  (
            (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_proc = a16)
            AND
            NOT dmli.d_subquery
            AND
            (NOT acv.a_from_select OR
            ( d_typ in  [ dstra, dstrb, dstruni, dlonga, dlongb, dlonguni ]))
            AND
            NOT (acv.a_is_ddl = ddl_create_as_select)
            (* PTS 1106654 E.Z. *)
            AND
            ((acv.a_intern_select_cnt = acv.a_max_intern_select) OR
            ( d_typ in  [ dstra, dstrb, dstruni,
            dlonga, dlongb, dlonguni ]))
            )
            OR
            dmli.d_first_union
        THEN
            BEGIN
            is_io := true;
            IF  (NOT dmli.d_view) OR (dmli.d_phase_cnt >= 4)
            THEN
                BEGIN
                IF  (d_typ in [ dstra, dstrb, dstruni,
                    dlonga, dlongb, dlonguni ])
                THEN
                    BEGIN
                    (* PTS 1116801 E.Z. *)
                    d_len := mxsp_long_desc;
                    d_iolen   := d_len + 1;
                    (* PTS 1111575 E.Z. *)
                    IF  acv.a_return_segm^.sp1r_function_code = csp1_mselect_into_fc
                    THEN
                        BEGIN
                        acv.a_return_segm^.sp1r_function_code := csp1_select_into_fc;
                        acv.a_precomp_info_byte := csp1_p_none
                        END;
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61long_ins_sel_st_entries (
            VAR acv          : tak_all_command_glob;
            VAR dmli         : tak_dml_info;
            VAR st_pos       : integer);
 
VAR
      _tabid  : tgg00_Surrogate;
      (* PTS 1105795 M.Ki. *)
 
BEGIN
(* put table id for this LONG in stack entry *)
IF  st_pos + 4 > acv.a_mblock.mb_st_max
THEN
    a07_b_put_error (acv, e_too_many_mb_stackentries,
          -acv.a_mblock.mb_st_max)
ELSE
    BEGIN
    st_pos  := st_pos + 2;
    WITH acv.a_mblock.mb_st^ [st_pos] DO
        BEGIN
        etype           := st_value;
        eop             := op_none;
        epos            := acv.a_mblock.mb_data_len + 1;
        elen_var        := SURROGATE_MXGG00 + 1;
        ecol_tab[ 1 ]   := chr(0);
        ecol_tab[ 2 ]   := chr(0);
        acv.a_mblock.mb_qual^.mqual_cnt   :=
              acv.a_mblock.mb_qual^.mqual_cnt   + 2;
        acv.a_mblock.mb_qual^.mfirst_free :=
              acv.a_mblock.mb_qual^.mfirst_free + 2;
        END;
    (*ENDWITH*) 
&   IFDEF TRACE
    t01surrogate (ak_sem, 'btreeidtabid',
          dmli.d_sparr.pbasep^.sbase.btreeid.fileTabId_gg00);
&   ENDIF
    WITH dmli.d_sparr.pbasep^.sbase DO
        BEGIN
        IF  acv.a_mblock.mb_data_len +
            acv.a_mblock.mb_st^ [st_pos].elen_var >
            acv.a_mblock.mb_data_size
        THEN
            a07_b_put_error (acv, e_too_many_mb_data, 1)
        ELSE
            BEGIN (* *** filling part2 *** *)
            IF  (dmli.d_sparr.pbasep^.sbase.btablekind = tview)
            THEN
                ak61get_long_tabid (acv, dmli,
                      ord(acv.a_mblock.mb_st^ [st_pos - 1].ecol_tab[2]),
                      _tabid)
            ELSE
                _tabid := btreeid.fileTabId_gg00;
            (*ENDIF*) 
            acv.a_mblock.mb_data^.mbp_buf [acv.a_mblock.mb_data_len+1] :=
                  csp_defined_byte;
            SAPDB_PascalMove ('VAK61 ',   1,    
                  SURROGATE_MXGG00, acv.a_mblock.mb_data_size,
                  @_tabid, 1,
                  @acv.a_mblock.mb_data^.mbp_buf,
                  acv.a_mblock.mb_data_len+2,
                  SURROGATE_MXGG00,
                  acv.a_returncode);
            acv.a_mblock.mb_data_len := acv.a_mblock.mb_data_len +
                  acv.a_mblock.mb_st^ [st_pos].elen_var;
            acv.a_long_desc_pos := st_pos;
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    a641string_set_operator (acv, op_b_concat,
          2 * SURROGATE_MXGG00 + 1,
          mxsp_c8 + acv.a_mblock.mb_st^ [st_pos].elen_var - 1,
          chr(3), chr(0));
    acv.a_mblock.mb_qual^.mqual_cnt   :=
          pred (acv.a_mblock.mb_qual^.mqual_cnt);
    acv.a_mblock.mb_qual^.mfirst_free :=
          pred (acv.a_mblock.mb_qual^.mfirst_free);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61long_desc_st_entries (
            VAR acv          : tak_all_command_glob;
            VAR dmli         : tak_dml_info;
            VAR colinf       : tak00_columninfo;
            VAR st_pos       : integer);
 
VAR
      _ld         : tsp00_LongDescriptor;
      _cmp_result : tsp00_LcompResult;
 
BEGIN
(* PTS 1116801 E.Z. *)
IF  acv.a_mblock.mb_st^ [st_pos + 1].elen_var < mxsp_long_desc + 1
THEN
    BEGIN
&   IFDEF TRACE
    t01int4  (ak_sem, 'st_pos      ', st_pos);
    t01int4  (ak_sem, 'mfirst_free ', acv.a_mblock.mb_qual^.mfirst_free);
    t01int4  (ak_sem, 'mqual_cnt   ', acv.a_mblock.mb_qual^.mqual_cnt);
&   ENDIF
    (* 1123503 E.Z. *)
    IF  g04isnull_value (acv.a_mblock.mb_st^ [st_pos+1], acv.a_mblock)
        OR
        ((colinf.ccolstack.elen_var > 0) AND
        ( colinf.ccolstack.etype = st_func))
    THEN
        BEGIN
        acv.a_mblock.mb_qual^.mfirst_free :=
              pred(acv.a_mblock.mb_qual^.mfirst_free);
        acv.a_mblock.mb_qual^.mqual_cnt :=
              pred(acv.a_mblock.mb_qual^.mqual_cnt)
        END;
    (*ENDIF*) 
    IF  st_pos + 4 > acv.a_mblock.mb_st_max
    THEN
        a07_b_put_error (acv, e_too_many_mb_stackentries,
              -acv.a_mblock.mb_st_max)
    ELSE
        BEGIN
        st_pos               := st_pos + 2;
        WITH acv.a_mblock.mb_st^ [st_pos] DO
            BEGIN
            etype           := st_value;
            eop             := op_none;
            epos            := acv.a_mblock.mb_data_len + 1;
            (* PTS 1116801 E.Z. *)
            elen_var        := mxsp_long_desc - SURROGATE_MXGG00 + 1;
            ecol_tab[ 1 ]   := chr(0);
            ecol_tab[ 2 ]   := chr(0);
            END;
        (*ENDWITH*) 
        acv.a_mblock.mb_qual^.mqual_cnt   :=
              acv.a_mblock.mb_qual^.mqual_cnt   + 2;
        acv.a_mblock.mb_qual^.mfirst_free :=
              acv.a_mblock.mb_qual^.mfirst_free + 2;
&       IFDEF TRACE
        t01surrogate (ak_sem, 'btreeidtabid',
              dmli.d_sparr.pbasep^.sbase.btreeid.fileTabId_gg00);
&       ENDIF
        WITH dmli.d_sparr.pbasep^.sbase DO
            BEGIN
            IF  acv.a_mblock.mb_data_len +
                acv.a_mblock.mb_st^ [st_pos].elen_var >
                acv.a_mblock.mb_data_size
            THEN
                a07_b_put_error (acv, e_too_many_mb_data, 1)
            ELSE
                BEGIN (* *** filling part2 *** *)
                _ld.ld_descriptor := cgg_zero_id;
                _ld.ld_used_in_ak := ' ';
                IF  (dmli.d_sparr.pbasep^.sbase.btablekind = tview)
                THEN
                    ak61get_long_tabid (acv, dmli,
                          ord(acv.a_mblock.mb_st^ [st_pos - 1].ecol_tab[2]),
                          _ld.ld_tabid)
                ELSE
                    _ld.ld_tabid := btreeid.fileTabId_gg00;
                (*ENDIF*) 
                (* PTS 1105838 E.Z. *)
                _ld.ld_maxlen         := 0;
                IF  colinf.cdatatyp in [ dstra, dstrb, dstruni ]
                THEN
                    BEGIN
                    _ld.ld_state      := [ ld_short_scol ];
                    _ld.ld_infoset    := [ ];
                    END
                ELSE
                    BEGIN
                    _ld.ld_state      := [ ];
                    _ld.ld_infoset    := [ ld_without_shortcol ];
                    END;
                (*ENDIF*) 
                IF  (colinf.cdatatyp in [ dstra, dlonga ])
                    AND
                    (acv.a_out_packet^.sp1_header.sp1h_mess_code
                    in [csp_unicode, csp_unicode_swap])
                    AND
                    NOT acv.a_ascii_in_and_output (* new feature *)
                THEN
                    _ld.ld_state := _ld.ld_state +
                          [ ld_use_toascii ];
                (*ENDIF*) 
                IF  (colinf.cdatatyp in [ dstruni, dlonguni ])
                    AND
                    (
                    (acv.a_out_packet^.sp1_header.sp1h_mess_swap <> sw_normal) OR
                    (acv.a_dbproc_level + acv.a_trigger_level > 0)
                    )
                THEN
                    _ld.ld_state := _ld.ld_state +
                          [ ld_use_ucs_2_swap ];
                (*ENDIF*) 
                _ld.ld_intern_pos :=  1;
                IF  colinf.cdatatyp in [dstruni, dlonguni]
                THEN
                    _ld.ld_infoset := _ld.ld_infoset + [ld_unicode];
                (*ENDIF*) 
                _ld.ld_valmode    := vm_nodata;
                _ld.ld_valind     := 0;
                _ld.ld_unused_2   := 0;
                _ld.ld_valpos     := -1;
                _ld.ld_vallen     := -1;
                _cmp_result       := l_less;
                IF  acv.a_long_desc_pos > 0
                THEN
                    s30cmp1 (acv.a_mblock.mb_data^.mbp_buf,
                          acv.a_mblock.mb_st^ [st_pos].epos+cgg_rec_key_offset,
                          acv.a_mblock.mb_st^ [st_pos].elen_var,
                          _ld, 1, acv.a_mblock.mb_st^ [st_pos].elen_var,
                          _cmp_result);
                (*ENDIF*) 
                IF  (_cmp_result <> l_equal)
                THEN
                    BEGIN
                    acv.a_mblock.mb_data^.
                          mbp_buf [acv.a_mblock.mb_data_len+1] := csp_defined_byte;
                    SAPDB_PascalMove ('VAK61 ',   2,    
                          sizeof(_ld), acv.a_mblock.mb_data_size,
                          @_ld, SURROGATE_MXGG00 + 1,
                          @acv.a_mblock.mb_data^.mbp_buf,
                          acv.a_mblock.mb_data_len+2,
                          acv.a_mblock.mb_st^ [st_pos].elen_var - 1,
                          acv.a_returncode);
                    acv.a_mblock.mb_data_len := acv.a_mblock.mb_data_len +
                          acv.a_mblock.mb_st^ [st_pos].elen_var;
                    acv.a_long_desc_pos := st_pos;
                    END
                ELSE
                    acv.a_mblock.mb_st^[ st_pos ] :=
                          acv.a_mblock.mb_st^ [acv.a_long_desc_pos];
                (*ENDIF*) 
&               ifdef trace
                IF  ld_use_ucs_2_swap IN _ld.ld_state
                THEN
                    t01int4 (ak_sem, 'ld_swap_ucs2', ord (ld_use_ucs_2_swap));
&               endif
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        (* PTS 1116801 E.Z. *)
        a641string_set_operator (acv, op_b_concat,
              mxsp_long_desc + 1,
              mxsp_c8 + acv.a_mblock.mb_st^ [st_pos].elen_var - 1,
              chr(3), chr(0));
        acv.a_mblock.mb_qual^.mqual_cnt   :=
              pred (acv.a_mblock.mb_qual^.mqual_cnt);
        acv.a_mblock.mb_qual^.mfirst_free :=
              pred (acv.a_mblock.mb_qual^.mfirst_free);
        END;
    (*ENDIF*) 
    END;
(* PTS 1116801 E.Z. *)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61one_star_table_check (
            VAR acv       : tak_all_command_glob;
            VAR dmli      : tak_dml_info;
            curr_n        : integer;
            VAR col_index : integer);
 
VAR
      _fieldno    : integer;
      _new_col_ptr: tak00_colinfo_ptr;
&     ifdef trace
      _i          : tsp00_Int2;
&     endif
 
BEGIN
IF  acv.a_returncode = 0
THEN
    IF  dmli.d_tabarr^[ dmli.d_acttabindex ].oall_priv  AND
        NOT (dmli.d_sparr.pbasep^.sbase.btablekind in
        [ tonebase, tview ])                      AND
        NOT (dmli.d_view)                              AND
        NOT (dmli.d_union)                             AND
        NOT (dmli.d_first_union)                       AND
        NOT (acv.a_recursive_state in
        [ rs_first_select, rs_recursive_select ]) AND
        ((NOT acv.a_insert_select) OR
        acv.a_from_select          OR
        dmli.d_subquery)
    THEN
        BEGIN
        ak61all_columns (acv, dmli, col_index)
        END
    ELSE
        BEGIN
        _fieldno   := 1;
&       ifdef trace
        t01int4 (ak_sem, 'btablekind  ',
              ord (dmli.d_sparr.pbasep^.sbase.btablekind));
        t01int4 (ak_sem, 'bmaxcol     ',
              dmli.d_sparr.pbasep^.sbase.bmaxcol);
        t01int4 (ak_sem, 'bfirstindex ',
              dmli.d_sparr.pbasep^.sbase.bfirstindex);
        FOR _i := 1 TO dmli.d_sparr.pbasep^.sbase.bmaxcol DO
            BEGIN
            t01int4 (ak_sem, 'bextcolind[]',
                  dmli.d_sparr.pbasep^.sbase.bextcolindex[_i]);
            END;
        (*ENDFOR*) 
&       endif
        IF  (dmli.d_sparr.pbasep^.sbase.btablekind
            in [twithoutkey, tcomplexview])
        THEN
            _fieldno := 2
        ELSE
            IF  dmli.d_sparr.pbasep^.sbase.btablekind = tresult
            THEN
                IF  NOT (
                    (acv.a_recursive_state = rs_check_select_list) AND
                    (dmli.d_sparr.pbasep^.sbase.btablen^ = acv.a_result_name)
                    )
                THEN
                    _fieldno := 2;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        WHILE ((_fieldno <= dmli.d_sparr.pbasep^.sbase.bmaxcol) AND
              (acv.a_returncode = 0)) DO
            BEGIN
&           IFDEF TRACE
            t01int4 (ak_sem, 'fieldno     ', _fieldno);
            t01int4 (ak_sem, 'd_cntpar    ', dmli.d_cntpar);
&           ENDIF
            IF  ((_fieldno in dmli.d_tabarr^[ dmli.d_acttabindex ].oprivset) OR
                dmli.d_tabarr^[ dmli.d_acttabindex ].oall_priv)
            THEN
                WITH  dmli.d_sparr.pbasep^.sbase DO
                    BEGIN
                    a06extcolno (dmli.d_sparr.pbasep^.sbase,
                          _fieldno, dmli.d_colbuf);
                    WITH dmli.d_colbuf^ DO
                        IF  (NOT (ctdropped   in ccolpropset)) AND
                            (NOT (ctinvisible in ccolpropset))
                        THEN
                            (* PTS 1105795 M.Ki. *)
                            (* PTS 1120891 E.Z. *)
                            IF  (NOT ((cdatatyp in
                                [ dlonga, dlongb, dlonguni,
                                dstruni, dstra, dstrb ])  AND
                                (btablekind = tonebase)         AND
                                (bv_tablekind = tcatalog_table) AND
                                (acv.a_insert_select OR
                                ( acv.a_init_ddl     = ddl_create_as_select))))
                            THEN
                                IF  (cdatatyp in
                                    [ dlonga, dlongb, dlonguni,
                                    dstruni, dstra, dstrb ])  AND
                                    (dmli.d_distinct <> no_distinct)
                                THEN
                                    a07_nb_put_error (acv,
                                          e_command_for_string_not_allow,
                                          dmli.d_vppos, dmli.d_column)
                                ELSE
                                    BEGIN
                                    a061get_colname (dmli.d_colbuf^, dmli.d_column);
                                    ak61one_select_column (acv, dmli,
                                          dmli.d_colbuf^, _new_col_ptr, curr_n,
                                          col_index);
                                    dmli.d_n_pos := 0
                                    END
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            _fieldno   := succ (_fieldno);
            END
        (*ENDWHILE*) 
        END
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61put_checknull_func (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info);
 
VAR
      _j : integer;
 
BEGIN
(* this procedure describes a 1-byte column, in which *)
(* defined byte or undef byte will be written to show *)
(* if null-values were eliminated during set function *)
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  acv.a_mblock.mb_qual^.mfirst_free >= acv.a_mblock.mb_st_max
    THEN
        a07_b_put_error (acv, e_too_many_mb_stackentries, -acv.a_mblock.mb_st_max)
    ELSE
        BEGIN
        acv.a_mblock.mb_qual^.mqual_cnt := acv.a_mblock.mb_qual^.mqual_cnt + 2;
        WITH acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free] DO
            BEGIN
            etype    := st_func;
            eop_func := op_f_check_null;
            _j := acv.a_mblock.mb_qual^.mfirst_free - 1;
            WHILE ((_j > 1) AND (acv.a_mblock.mb_st^ [_j].etype <> st_func)) DO
                _j := pred(_j);
            (*ENDWHILE*) 
            epos := acv.a_mblock.mb_qual^.mfirst_free - _j;
            elen_var := 1;
            ecol_tab[ 1 ] := chr(0);
            ecol_tab[ 2 ] := chr(1)
            END;
        (*ENDWITH*) 
        WITH acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free + 1] DO
            BEGIN
            etype := st_output;
            eop   := op_none;
            epos  := dmli.d_inoutpos;
            elen_var := 1;
            ecol_pos := 0;
            END;
        (*ENDWITH*) 
        acv.a_mblock.mb_qual^.mfirst_free := acv.a_mblock.mb_qual^.mfirst_free + 2;
        WITH dmli.d_change DO
            IF  cr_colcount = MAX_COL_PER_TAB_GG00
            THEN
                a07_b_put_error (acv, e_select_col_list_too_long,
                      dmli.d_vppos)
            ELSE
                BEGIN
                cr_colcount := succ(cr_colcount);
                WITH cr_columns[ cr_colcount ] DO
                    BEGIN
                    ch_startpos := dmli.d_inoutpos;
                    ch_length   := chr(1);
                    ch_type  := [ ch_to_warn2 ];
                    END
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
        dmli.d_inoutpos := succ(dmli.d_inoutpos);
        dmli.d_check_null_byte := true;
        IF  dmli.d_distinct = full_distinct
        THEN
            dmli.d_distinct := distinct_without_warning_byte;
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(* PTS 1118056 E.Z. *)
(*------------------------------*) 
 
FUNCTION
      ak61static_value (
            VAR acv     : tak_all_command_glob;
            old_stackcnt : integer) : boolean;
 
VAR
      _index        : integer;
      _static_value : boolean;
 
BEGIN
_static_value := true;
WITH acv.a_mblock, mb_qual^ DO
    FOR _index := old_stackcnt TO mfirst_free - 1 DO
        IF  mb_st^ [_index].etype <= st_column
        THEN
            _static_value := false;
        (*ENDIF*) 
    (*ENDFOR*) 
(*ENDWITH*) 
ak61static_value := _static_value;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61select_column_check (
            VAR acv       : tak_all_command_glob;
            VAR dmli      : tak_dml_info;
            curr_col      : integer;
            VAR col_index : integer);
 
VAR
      _curr_n      : integer;
      _node        : integer;
      _m_cntpar    : integer;
      _old_stackcnt: integer;
      _new_col_ptr : tak00_colinfo_ptr;
 
BEGIN
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    _curr_n := acv.a_ap_tree^[ curr_col ].n_lo_level;
    _node   := _curr_n;
    dmli.d_user   := a01_il_b_identifier;
    dmli.d_table  := a01_il_b_identifier;
    dmli.d_column := a01_il_b_identifier;
    dmli.d_vppos := acv.a_ap_tree^[ _curr_n ].n_pos;
&   ifdef trace
    t01int4 (ak_sem, '_curr_n     ', _curr_n);
    t01trace_symbol(ak_sem, '[curr_n].n_s', acv.a_ap_tree^[ _curr_n ].n_symb );
&   endif
    CASE acv.a_ap_tree^[ _curr_n ].n_symb OF
        s_authid, s_tablename, s_columnname, s_columnid :
            BEGIN
            dmli.d_n_pos := acv.a_ap_tree^[ _curr_n ].n_pos;
            a06get_username( acv, _curr_n, dmli.d_user );
            WITH acv.a_ap_tree^[ _curr_n ] DO
                IF  n_symb = s_tablename
                THEN
                    BEGIN
                    a05identifier_get( acv,
                          _curr_n, sizeof( dmli.d_table ), dmli.d_table );
                    _curr_n := n_sa_level;
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
            WITH acv.a_ap_tree^[ _curr_n ] DO
                IF  ( n_symb = s_columnname ) OR
                    ( (n_symb = s_columnid) AND (n_columnindex>0) )
                THEN
                    BEGIN
                    IF  ( n_symb = s_columnname ) (* PTS 1128197 D.T. *)
                    THEN
                        BEGIN
                        a05identifier_get( acv,
                              _curr_n, sizeof ( dmli.d_column ), dmli.d_column );
                        a61_search_table (acv, dmli);
                        END
                    ELSE
                        BEGIN
                        (* s_columnid *)
                        dmli.d_fromtabnode := acv.a_ap_tree^[ _curr_n ].n_fromtabnode;
                        dmli.d_columnindex := acv.a_ap_tree^[ _curr_n ].n_columnindex;
                        a61_search_table_by_columnindex (acv, dmli);
                        END;
                    (*ENDIF*) 
                    IF  ( acv.a_returncode <> 0 )
                    THEN
                        a07put_error_pos( acv, n_pos )
                    ELSE
                        ak61one_select_column( acv, dmli, dmli.d_colbuf^,
                              _new_col_ptr, _curr_n, col_index );
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    IF  ( (n_symb = s_columnid) AND (n_columnindex=cak_qrewrite_ref_star) )
                    THEN
                        BEGIN
                        dmli.d_fromtabnode := n_fromtabnode;
                        dmli.d_columnindex := n_columnindex;
                        a61_search_table_by_columnindex( acv, dmli );
                        END
                    ELSE
                        BEGIN
                        a61_search_table( acv, dmli );
                        END;
                    (*ENDIF*) 
                    IF  ( acv.a_returncode <> 0 )
                    THEN
                        a07put_error_pos( acv, n_pos )
                    ELSE
                        BEGIN
                        _m_cntpar := dmli.d_cntpar;
                        dmli.d_n_pos  := - dmli.d_n_pos;
                        ak61one_star_table_check( acv, dmli, _curr_n, col_index );
                        IF  ((dmli.d_cntpar = _m_cntpar) AND
                            (_m_cntpar > 0))
                        THEN
                            BEGIN
                            acv.a_error_tableid := dmli.d_sparr.pbasep^.syskey.stableid;
                            a07_b_put_error( acv,
                                  e_missing_privilege, dmli.d_vppos );
                            END
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
            END;
        s_asterisk :
            ak61check_star_tables( acv, dmli, _curr_n, col_index );
        s_reference_name :
            BEGIN
            a05identifier_get( acv,
                  _curr_n, sizeof( dmli.d_refname ), dmli.d_refname );
            IF  ( acv.a_returncode = 0 )
            THEN
                BEGIN
                _curr_n  := acv.a_ap_tree^[ _curr_n ].n_sa_level;
                _node    := _curr_n;
                dmli.d_n_pos := acv.a_ap_tree^[ _curr_n ].n_pos;
                a06get_username( acv, _curr_n, dmli.d_user );
                WITH acv.a_ap_tree^[ _curr_n ] DO
                    IF  n_symb = s_tablename
                    THEN
                        BEGIN
                        a05identifier_get (acv,
                              _curr_n, sizeof (dmli.d_table), dmli.d_table);
                        _curr_n := n_sa_level;
                        END;
                    (*ENDIF*) 
                (*ENDWITH*) 
                WITH acv.a_ap_tree^[ _curr_n ] DO
                    BEGIN
                    IF  (n_symb = s_columnname) OR
                        (n_symb = s_columnid) (* PTS 1128197 D.T. *)
                    THEN
                        BEGIN
                        IF  (n_symb = s_columnname)
                        THEN
                            BEGIN
                            a05identifier_get (acv,
                                  _curr_n, sizeof (dmli.d_column), dmli.d_column);
                            a61_search_table (acv, dmli);
                            END
                        ELSE
                            BEGIN (* s_columnid *)
                            dmli.d_fromtabnode := acv.a_ap_tree^[ _curr_n ].n_fromtabnode;
                            dmli.d_columnindex := acv.a_ap_tree^[ _curr_n ].n_columnindex;
                            a61_search_table_by_columnindex (acv, dmli);
                            END;
                        (*ENDIF*) 
                        IF  acv.a_returncode <> 0
                        THEN
                            a07put_error_pos (acv, n_pos)
                        ELSE
                            ak61one_select_column (acv, dmli, dmli.d_colbuf^,
                                  _new_col_ptr, _curr_n, col_index);
                        (*ENDIF*) 
                        IF  acv.a_returncode <> 0
                        THEN
                            a07put_error_pos (acv, n_pos)
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  n_symb = s_unknown
                        THEN
                            BEGIN
&                           ifdef TRACE
                            t01int4 (ak_sem, 'curr_n      ', _curr_n);
                            t01aptree (ak_sem, acv.a_ap_tree^, acv.a_scv_index,
                                  acv.a_first_hint_node);
&                           endif
                            _old_stackcnt := acv.a_mblock.mb_qual^.mfirst_free;
                            IF  ((acv.a_ap_tree^[ _curr_n ].n_proc = a63query_spec) AND
                                ( acv.a_ap_tree^[ _curr_n ].n_subproc = cak_is_undefined))
                                OR
                                ((acv.a_ap_tree^[ _curr_n ].n_proc = a63) AND
                                ( acv.a_ap_tree^[ _curr_n ].n_subproc = cak_x_start_union))
                            THEN
                                BEGIN
                                ak61sel_val_expr (acv, dmli, _curr_n, col_index,
                                      c_subquery_get);
                                IF  (acv.a_returncode = 0) AND dmli.d_group
                                THEN
                                    a61_is_group_field (acv, dmli, dmli.d_column, 0, 0,
                                          c_is_expression, _curr_n, dmli.d_vppos);
                                (*ENDIF*) 
                                END
                            ELSE
                                IF  acv.a_ap_tree^[ _curr_n ].n_proc = a67
                                THEN
                                    ak61sel_val_expr (acv, dmli, _curr_n, col_index, NOT c_subquery_get)
                                ELSE
                                    a07_b_put_error (acv, e_not_implemented, dmli.d_vppos);
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END
                        ELSE
                            BEGIN
                            (* PTS 1118056 E.Z. *)
                            _old_stackcnt := acv.a_mblock.mb_qual^.mfirst_free;
                            ak61sel_val_expr (acv, dmli, _curr_n, col_index,
                                  NOT c_subquery_get);
                            IF  (acv.a_returncode = 0)            AND
                                dmli.d_group                                        AND
                                NOT (acv.a_ap_tree^ [ _curr_n ].n_symb in
                                [ s_sum, s_min, s_max, s_count, s_all_count, s_avg,
                                s_stddev, s_variance, s_dis_sum, s_dis_count,
                                s_dis_avg, s_dis_stddev, s_dis_variance ])          AND
                                NOT ak61static_value (acv, _old_stackcnt)
                            THEN
                                BEGIN
                                dmli.d_column := a01_il_b_identifier;
                                a61_is_group_field (acv, dmli, dmli.d_column, 0, 0,
                                      c_is_expression, _curr_n, dmli.d_vppos);
                                END
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    dmli.d_refname := a01_il_b_identifier
                    END
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            END;
        s_point : (* select without select list in case *)
            (* of qualified delete orders for     *)
            (* updatable join views               *)
            BEGIN
            END;
        s_unknown :
            BEGIN
&           ifdef TRACE
            t01int4 (ak_sem, 'curr_n      ', _curr_n);
            t01aptree (ak_sem, acv.a_ap_tree^, acv.a_scv_index,
                  acv.a_first_hint_node);
&           endif
            IF  ((acv.a_ap_tree^[ _curr_n ].n_proc = a63query_spec) AND
                ( acv.a_ap_tree^[ _curr_n ].n_subproc = cak_is_undefined))
                OR
                ((acv.a_ap_tree^[ _curr_n ].n_proc = a63) AND
                ( acv.a_ap_tree^[ _curr_n ].n_subproc = cak_x_start_union))
            THEN
                BEGIN
                ak61sel_val_expr (acv, dmli, _curr_n, col_index,
                      c_subquery_get);
                IF  (acv.a_returncode = 0) AND dmli.d_group
                THEN
                    a61_is_group_field (acv, dmli, dmli.d_column, 0, 0,
                          c_is_expression, _curr_n, dmli.d_vppos);
                (*ENDIF*) 
                END
            ELSE
                IF  acv.a_ap_tree^[ _curr_n ].n_proc = a67
                THEN
                    ak61sel_val_expr (acv, dmli, _curr_n, col_index, NOT c_subquery_get)
                ELSE
                    a07_b_put_error (acv, e_not_implemented, dmli.d_vppos);
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        OTHERWISE
            BEGIN
            (* PTS 1118056 E.Z. *)
            _old_stackcnt := acv.a_mblock.mb_qual^.mfirst_free;
            ak61sel_val_expr (acv, dmli, _curr_n, col_index, NOT c_subquery_get);
            IF  (acv.a_returncode = 0)            AND
                dmli.d_group                                        AND
                NOT (acv.a_ap_tree^ [ _curr_n ].n_symb in
                [ s_sum, s_min, s_max, s_count, s_all_count, s_avg,
                s_stddev, s_variance, s_dis_sum, s_dis_count,
                s_dis_avg, s_dis_stddev, s_dis_variance ])          AND
                NOT ak61static_value (acv, _old_stackcnt)
            THEN
                a61_is_group_field (acv, dmli, dmli.d_column, 0, 0,
                      c_is_expression, _curr_n, dmli.d_vppos);
            (*ENDIF*) 
            END
        END
    (*ENDCASE*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61check_star_tables (
            VAR acv       : tak_all_command_glob;
            VAR dmli      : tak_dml_info;
            curr_n        : integer;
            VAR col_index : integer);
 
VAR
      _i        : integer;
      _m_cntpar : integer;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
&   ifdef trace
    t01int4 (ak_sem, 'd_cntfromtab', dmli.d_cntfromtab);
    t01int4 (ak_sem, 'd_acttabinde', dmli.d_acttabindex);
&   endif
    dmli.d_n_pos := 0;
    _i        := 0;
    WHILE ((_i < dmli.d_cntfromtab) AND (acv.a_returncode = 0)) DO
        BEGIN
        _m_cntpar := dmli.d_cntpar;
        _i := succ(_i);
        IF  dmli.d_acttabindex <> _i
        THEN
            a61_rel_old_table (acv, dmli, _i);
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            ak61one_star_table_check (acv, dmli, curr_n, col_index);
        (*ENDIF*) 
        IF  (acv.a_returncode = 0) AND
            ((_m_cntpar = dmli.d_cntpar) AND (_m_cntpar > 0))
        THEN
            BEGIN
            acv.a_error_tableid := dmli.d_sparr.pbasep^.syskey.stableid;
            a07_b_put_error (acv, e_missing_privilege, dmli.d_vppos);
            END
        (*ENDIF*) 
        END
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61outparam_typecheck (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info;
            VAR colinf : tak00_columninfo);
 
BEGIN
IF  (acv.a_proc_compile <> pct_none)                      AND
    (acv.a_parameter_spec.param_spec_ptr <> NIL)          AND
    (dmli.d_parnum <= acv.a_parameter_spec.param_counter) AND
    (NOT dmli.d_subquery)                                 AND
    (acv.a_intern_select_cnt = acv.a_max_intern_select)   AND
    (acv.a_mblock.mb_type <> m_insert_select)             AND
    (NOT acv.a_insert_select)
THEN
    BEGIN
    IF  acv.a_parameter_spec.param_spec_ptr^[dmli.d_parnum].para_length <> 0
    THEN
        IF  acv.a_parameter_spec.param_spec_ptr^[dmli.d_parnum].para_type
            <> colinf.cdatatyp
        THEN
            BEGIN
&           ifdef TRACE
            t01int4 (ak_sem, 'param_type  ',
                  ord(acv.a_parameter_spec.param_spec_ptr^[dmli.d_parnum].para_type));
            t01int4 (ak_sem, 'columntype  ', ord(colinf.cdatatyp));
&           endif
            CASE acv.a_parameter_spec.param_spec_ptr^[dmli.d_parnum].para_type OF
                dfixed, dsmallint, dinteger, dfloat :
                    IF  NOT (colinf.cdatatyp in
                        [dfixed, dsmallint, dinteger, dfloat, dvfloat,
                        dboolean (* ODB/KNL *)
                        ])
                    THEN
                        a07_nb_put_error (acv,
                              e_incompatible_datatypes, dmli.d_vppos, colinf.ccolumnn);
                    (*ENDIF*) 
                dcha, dvarchara :
                    IF  NOT (colinf.cdatatyp in [dcha, dvarchara,
                        dunicode, dvarcharuni,
                        ddate, dtime, dtimestamp (* ODB/KNL *)
                        ])
                    THEN
                        a07_nb_put_error (acv,
                              e_incompatible_datatypes, dmli.d_vppos, colinf.ccolumnn);
                    (*ENDIF*) 
                dchb, dvarcharb :
                    IF  NOT (colinf.cdatatyp in [dchb, dvarcharb])
                    THEN
                        a07_nb_put_error (acv,
                              e_incompatible_datatypes, dmli.d_vppos, colinf.ccolumnn);
                    (*ENDIF*) 
                dunicode, dvarcharuni :
                    IF  NOT (colinf.cdatatyp in [dunicode, dvarcharuni,
                        dcha, dvarchara])
                    THEN
                        a07_nb_put_error (acv,
                              e_incompatible_datatypes, dmli.d_vppos, colinf.ccolumnn);
                    (*ENDIF*) 
                OTHERWISE
                    a07_nb_put_error (acv,
                          e_incompatible_datatypes, dmli.d_vppos, colinf.ccolumnn);
                END;
            (*ENDCASE*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61col_long_shortinfo (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info;
            VAR colinf : tak00_columninfo);
 
BEGIN
IF  (NOT dmli.d_subquery) AND (NOT acv.a_from_select)
THEN
    (* PTS 1115646 E.Z. *)
    IF  (acv.a_mblock.mb_type <> m_insert_select)
        AND (NOT acv.a_insert_select)
    THEN
        BEGIN
        IF  (dmli.d_single AND (acv.a_ex_kind = only_parsing))
        THEN
            BEGIN
            IF  acv.a_info_output
            THEN
                a61_p_long_info (acv, dmli, colinf)
            ELSE
                IF  dmli.d_parnum <= acv.a_count_variab
                THEN
                    a61_p_short_info (acv, dmli.d_sparr, colinf,
                          dmli.d_parnum, 0);
                (* PTS 1111575 E.Z. *)
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            IF  acv.a_info_output
            THEN
                a61_p_long_info (acv, dmli, colinf)
            ELSE
                IF  acv.a_init_info_output OR
                    a54_optim_select_fetch( acv )
                THEN
                    a61_p_short_info (acv, dmli.d_sparr, colinf, dmli.d_parnum,
                          dmli.d_inoutpos - cgg_rec_key_offset - dmli.d_keylen);
                (* PTS 1111575 E.Z. *)
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        dmli.d_parnum := succ(dmli.d_parnum)
        END;
    (*ENDIF*) 
(*ENDIF*) 
dmli.d_cntpar := pred(dmli.d_cntpar);
&ifdef trace
t01int4 (ak_sem, 'd_cntpar--  ', dmli.d_cntpar);
&endif
dmli.d_outcolno := succ(dmli.d_outcolno);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61fill_change_info (
            VAR acv       : tak_all_command_glob;
            VAR dmli      : tak_dml_info;
            VAR colinf    : tak00_columninfo;
            num_changeset : tak_number_changetype_set);
 
CONST
      maxonebytelen = 255;
 
VAR
      _restlen : integer;
      _startpos : integer;
 
BEGIN
WITH dmli.d_change, colinf DO
    BEGIN
    _restlen  := cinoutlen;
    _startpos := dmli.d_inoutpos;
    IF  (cdatatyp = dunicode)
        OR
        (
        (cdatatyp in [ dcha, dvarchara, ddate, dtime, dtimestamp ])
        AND
        ((
        (acv.a_out_packet^.sp1_header.sp1h_mess_code in
        [ csp_unicode_swap, csp_unicode ]) AND
        NOT acv.a_ascii_in_and_output (* new feature *)
        )
        OR
        (
        (cinoutlen > succ(cdatalen)) AND
        (
        (acv.a_out_packet^.sp1_header.sp1h_mess_code < csp_unicode_swap) OR
        acv.a_ascii_in_and_output (* new feature *)
        )
        ))
        )
    THEN
        BEGIN
        (* to make a distinction between one loooong unicode and *)
        (* two following each other (don't translate def-byte !!)*)
        (* startpos is 1 real byte before !! compare vak61       *)
        _startpos := _startpos + 1;
        _restlen := _restlen - 1
        END;
&   ifdef TRACE
    (*ENDIF*) 
    IF  (cdatatyp in [ dlonga, dlongb, dlonguni,
        dstra, dstrb, dstruni ])
    THEN
        t01int4 (ak_sem, 'slongs@@@@@@', cinoutlen);
&   endif
    (*ENDIF*) 
    WHILE ((_restlen > 0) AND (acv.a_returncode = 0)) DO
        IF  cr_colcount = MAX_COL_PER_TAB_GG00
        THEN
            a07_b_put_error (acv, e_select_col_list_too_long, dmli.d_vppos)
        ELSE
            BEGIN
            cr_colcount := succ(cr_colcount);
            WITH cr_columns[ cr_colcount ] DO
                BEGIN
                ch_type  := [  ];
                IF  (cdatatyp in [ dcha, dvarchara, ddate, dtime, dtimestamp ])
                THEN
                    BEGIN
                    IF  (
                        (acv.a_out_packet^.sp1_header.sp1h_mess_code in
                        [ csp_unicode_swap, csp_unicode ]) AND
                        NOT acv.a_ascii_in_and_output (* new feature *)
                        )
                        OR
                        (
                        (cinoutlen > succ(cdatalen)) AND
                        (
                        (acv.a_out_packet^.sp1_header.sp1h_mess_code < csp_unicode_swap) OR
                        acv.a_ascii_in_and_output (* new feature *)
                        )
                        )
                    THEN
                        ch_type := [ ch_to_multibyte_set ]
                    (*ENDIF*) 
                    END
                ELSE
                    IF  cdatatyp = dunicode
                    THEN
                        ch_type := [ ch_to_multibyte_set ];
                    (*ENDIF*) 
                (*ENDIF*) 
                ch_startpos := _startpos;
                IF  _restlen <= maxonebytelen
                THEN
                    ch_length   := chr(_restlen)
                ELSE
                    ch_length   := chr(maxonebytelen);
                (*ENDIF*) 
                _restlen  := _restlen - ord(ch_length);
                _startpos := _startpos + ord(ch_length);
                CASE cdatatyp OF
                    ddate :
                        ch_type := ch_type + [ ch_date ];
                    dtime :
                        ch_type := ch_type + [ ch_time_or_timestamp ];
                    dtimestamp :
                        ch_type := ch_type + [ ch_time_or_timestamp ];
                    dlonga, dlongb, dlonguni,
                    dstra, dstrb, dstruni :
                        ch_type := ch_type + [ ch_to_longsupport ];
                    dfixed, dfloat, dvfloat,
                    dsmallint, dinteger :
                        BEGIN
                        IF  dmli.d_optimize_setfunction
                        THEN
                            ch_type := ch_type + [ ch_number_change_in_next_entry ];
                        (*ENDIF*) 
                        END;
                    OTHERWISE
                        BEGIN
                        END;
                    END;
                (*ENDCASE*) 
&               IFDEF TRACE
                t01int4 (ak_sem, 'ch_startpos ', ch_startpos);
                t01int4 (ak_sem, 'ch_length   ', ord(ch_length));
                IF  ch_date in ch_type
                THEN
                    t01name (ak_sem, 'change date       ');
                (*ENDIF*) 
                IF  ch_time_or_timestamp in ch_type
                THEN
                    t01name (ak_sem, 'change time(stamp)');
                (*ENDIF*) 
                IF  ch_to_ascii in ch_type
                THEN
                    t01name (ak_sem, 'change to ascii   ');
                (*ENDIF*) 
                IF  ch_to_multibyte_set in ch_type
                THEN
                    t01name (ak_sem, 'change to swap uni');
                (*ENDIF*) 
                IF  ch_to_longsupport in ch_type
                THEN
                    t01name (ak_sem, 'ch_to_longsupport ');
                (*ENDIF*) 
                IF  ch_number_change_in_next_entry in ch_type
                THEN
                    t01name (ak_sem, 'ch_number         ');
&               ENDIF
                (*ENDIF*) 
                IF  ((cr_colcount > 1) AND
                    (_restlen = 0) AND
                    NOT cr_was_opt AND
                    NOT(ctopt in colinf.ccolpropset))
                    AND (NOT acv.a_outer_join)
                    AND (NOT dmli.d_outer_join)
                    AND NOT (ch_number_change_in_next_entry in ch_type)
                THEN
                    IF  (
                        (ch_type = [ ch_to_ascii ])                                 AND
                        (cr_columns[ cr_colcount - 1 ].ch_type = ch_type)           AND
                        (cr_columns[ cr_colcount - 1 ].ch_startpos +
                        ord(cr_columns[ cr_colcount - 1 ].ch_length) = ch_startpos) AND
                        (ord(cr_columns[ cr_colcount - 1 ].ch_length) +
                        ord(ch_length) <= maxonebytelen)
                        )
                    THEN
                        BEGIN
                        cr_columns[ cr_colcount - 1 ].ch_length :=
                              chr(ord(cr_columns[ cr_colcount - 1 ].ch_length) +
                              ord(ch_length));
                        cr_colcount := pred(cr_colcount)
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  ch_number_change_in_next_entry in ch_type
                THEN
                    IF  cr_colcount = MAX_COL_PER_TAB_GG00
                    THEN
                        a07_b_put_error (acv, e_select_col_list_too_long, dmli.d_vppos)
                    ELSE
                        BEGIN
                        IF  (dmli.d_pos_result = cak_extern_pos) OR
                            (dmli.d_pos_result = cak_intern_pos)
                        THEN
                            WITH acv.a_resname_addr[ dmli.d_pos_result ]^.sresname DO
                                resstate := resstate - [rs_reuseable];
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        cr_colcount := succ(cr_colcount);
                        WITH cr_columns[ cr_colcount ] DO
                            BEGIN
                            ch_number_type := num_changeset;
                            ch_startpos    := 0;
                            ch_length      := chr(0);
                            END
                        (*ENDWITH*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                cr_was_opt := ctopt in colinf.ccolpropset
                END
            (*ENDWITH*) 
            END
        (*ENDIF*) 
    (*ENDWHILE*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61one_select_column (
            VAR acv         : tak_all_command_glob;
            VAR dmli        : tak_dml_info;
            VAR colinf      : tak00_columninfo;
            VAR new_col_ptr : tak00_colinfo_ptr;
            curr_n          : integer;
            VAR col_index   : integer);
 
VAR
      _put_together     : boolean;
      _together_allowed : boolean;
      _is_io            : boolean;
      _convert_type     : tsp00_DataType;
      _hdatatyp         : tsp00_DataType;
      _hetype           : tgg00_StackEntryType;
      _convert_t        : tak_convert_type;
      _uconvert_t       : tak_convert_type;
      _aux_name         : tsp00_KnlIdentifier;
      _i                : integer;
      _oldmfirst_free   : integer;
      _oldinoutpos      : integer;
      _output_len       : integer;
      _col_no           : integer;
      _extdatetime      : boolean;
      _curr_union_col   : tak00_colinfo_ptr;
      _pCol             : tak00_colinfo_ptr;
      _hcolinf          : tak00_columninfo;
 
BEGIN
a061colinfo_to_var (colinf, _hcolinf);
ak61iolen_get (acv, dmli, _extdatetime, _is_io,
      _hcolinf.cdatatyp, _hcolinf.cdatalen, _hcolinf.cinoutlen);
&IFDEF TRACE
a061td_colinfo (_hcolinf, 1);
&endif
_convert_t    := conv_none;
_uconvert_t   := conv_none;
_hdatatyp     := dunknown;
_convert_type := dunknown;
IF  (dmli.d_union OR
    (acv.a_recursive_state in [ rs_first_select, rs_recursive_select ]))
THEN
    BEGIN
    _col_no                  := acv.a_unionrec_ptr^.sunionrec.ucolpos;
    _curr_union_col          := a103GetColumn (acv.a_p_arr1.pbasep^.sbase, _col_no);
    _hdatatyp                := _hcolinf.cdatatyp;
    _hcolinf.cdatatyp        := _curr_union_col^.cdatatyp;
    _hcolinf.cdatalen        := _curr_union_col^.cdatalen;
    _hcolinf.cdatafrac       := _curr_union_col^.cdatafrac;
    _hcolinf.cinoutlen       := _curr_union_col^.cinoutlen;
    _hcolinf.ccolumnn        := _curr_union_col^.ccolumnn;
    _hcolinf.ccolpropset     := _curr_union_col^.ccolpropset;
    _hcolinf.cbinary         := _curr_union_col^.cbinary;
    _hcolinf.ccolumnn_len    := _curr_union_col^.ccolumnn_len;
    a061get_colname (_curr_union_col^, _hcolinf.ccolumnn);
    _hetype                  := _hcolinf.ccolstack.etype;
    _hcolinf.ccolstack.etype := _curr_union_col^.ccolstack.etype;
    ak61get_convert_type (_hdatatyp, _hcolinf.cdatatyp, _uconvert_t);
&   IFDEF TRACE
    t01int4 (ak_sem, 'colstacketyp', ord (_hcolinf.ccolstack.etype));
    t01int4 (ak_sem, 'hetype      ', ord (_hetype));
    t01int4 (ak_sem, 'cdatatyp 613', ord (_hcolinf.cdatatyp));
    t01int4 (ak_sem, 'hdatatyp    ', ord (_hdatatyp));
    t01int4 (ak_sem, 'ucolpos     ', acv.a_unionrec_ptr^.sunionrec.ucolpos);
    t01int4 (ak_sem, 'col_no      ', _col_no);
    t01int4 (ak_sem, 'hcol_iolen  ', _hcolinf.cinoutlen);
&   ENDIF
    IF  (_hdatatyp in [ ddate, dtime, dtimestamp ]) AND
        (_hcolinf.cdatatyp <> _hdatatyp)
    THEN
        _convert_type := _hdatatyp;
    (*ENDIF*) 
    acv.a_unionrec_ptr^.sunionrec.ucolpos := succ(acv.a_unionrec_ptr^.sunionrec.ucolpos)
    END ;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    ak61outparam_typecheck (acv, dmli, _hcolinf);
    IF  dmli.d_cntpar > 0
    THEN
        ak61col_long_shortinfo (acv, dmli, _hcolinf)
    ELSE
        IF  dmli.d_refname[ 1 ] <> '@'
            (*for update *)
        THEN
            IF  (dmli.d_subquery OR NOT dmli.d_single) AND (NOT acv.a_from_select)
            THEN
                a07_b_put_error (acv, e_select_col_list_too_long,
                      dmli.d_vppos)
            ELSE
                WITH acv.a_transinf.tri_trans DO
                    trWarning_gg00 := trWarning_gg00 + [ warn0_exist,
                          warn3_output_not_into_columns ];
                (*ENDWITH*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ((colinf.ctabno > cak00_maxsources) AND
    (dmli.d_allowed <> tabs_with_arith))
THEN (* expression-column, prepare two_phase-SELECT *)
    dmli.d_allowed := are_more_tabs;
(*ENDIF*) 
IF  colinf.ccolstack.etype = st_func
THEN
    BEGIN
    _i := 0;
    WITH acv.a_ap_tree^[ curr_n ] DO
        BEGIN
        n_proc := no_proc;
        REPEAT
            n_proc := succ(n_proc);
            _i      := succ(_i);
        UNTIL
            _i = dmli.d_acttabindex;
        (*ENDREPEAT*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
IF  ((acv.a_returncode = 0) AND NOT dmli.d_single)
THEN
    BEGIN
    a16col_to_view_description (acv,
          dmli, _hcolinf, NOT(dmli.d_subquery));
&   IFDEF TRACE
    a061td_colinfo (_hcolinf, 2);
&   endif
    ak61build_colinfo (acv, dmli, _hcolinf, new_col_ptr,
          _convert_t, col_index);
&   IFDEF TRACE
    a061td_colinfo (_hcolinf, 3);
&   endif
    END;
(*ENDIF*) 
;
(* PTS 1111575 E.Z. *)
&IFDEF TRACE
t01name (ak_sem, 'AK61: FSD false   ');
&ENDIF
(* PTS 1107681 E.Z. *)
_together_allowed := false;
IF  (dmli.d_union OR
    (acv.a_recursive_state in [ rs_first_select, rs_recursive_select ]))
THEN
    BEGIN
    _hcolinf.ccolstack.etype := _hetype;
    IF  (_convert_t <> conv_none)
    THEN
        BEGIN
        a65_convert (acv, _convert_t, _hcolinf.cinoutlen);
        _convert_t := conv_none;
        END
    ELSE
        _convert_t := _uconvert_t;
    (*ENDIF*) 
    END;
(*ENDIF*) 
_oldinoutpos := dmli.d_inoutpos;
(* PTS 1106343 E.Z. *)
_put_together := false;
a61_var_col_stackentry (acv, dmli, _hcolinf,
      _together_allowed, _put_together,
      _output_len, NOT c_is_corr_column, _convert_t, _convert_type);
IF  ((acv.a_returncode = 0)     AND
    (acv.a_union_cnt > 0)       AND
    (NOT dmli.d_union)          AND
    NOT (acv.a_recursive_state in
    [ rs_first_select, rs_recursive_select ]) AND
    (_output_len <> 0))
THEN
    IF  acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free - 2].etype = st_func
    THEN
        new_col_ptr^.ccolstack.ecol_tab[ 1 ] :=
              chr(_output_len);
    (*ENDIF*) 
(*ENDIF*) 
IF  ((acv.a_returncode = 0) AND
    (acv.a_union_cnt > 0)                     AND
    (dmli.d_union OR
    (acv.a_recursive_state in
    [ rs_first_select, rs_recursive_select ])))
THEN
    IF  acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free - 2].etype = st_func
    THEN
        WITH acv.a_p_arr1.pbasep^.sresult DO
            BEGIN
            _pCol := a103GetColumn ( acv.a_p_arr1.pbasep^.sbase, _col_no );
&           ifdef TRACE
            t01int4 (ak_sem, 'bcol ecol[1]',
                  ord(_pCol^.ccolstack.ecol_tab[ 1 ]));
            t01int4 (ak_sem, 'hcol cinoutl', _hcolinf.cinoutlen);
            t01int4 (ak_sem, 'd_inoutpos  ', dmli.d_inoutpos);
            t01int4 (ak_sem, 'oldinoutpos ', _oldinoutpos);
&           endif
            IF  ((_pCol^.ccolstack.ecol_tab[ 1 ] <> chr(0)) AND
                (dmli.d_inoutpos - _oldinoutpos <>
                ord(_pCol^.ccolstack.ecol_tab[ 1 ])) AND
                (ord(_pCol^.ccolstack.ecol_tab[ 1 ]) >
                _hcolinf.cinoutlen))
            THEN
                BEGIN
&               ifdef TRACE
                t01int4 (ak_sem, 'd_inoutpos 1', dmli.d_inoutpos);
&               endif
                dmli.d_inoutpos :=
                      ord(_pCol^.ccolstack.ecol_tab[ 1 ])
                      + _oldinoutpos;
                WITH acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free - 1] DO
                    elen_var :=
                          ord(_pCol^.ccolstack.ecol_tab[ 1 ])
                          (*-
                          _hcolinf.cinoutlen
                          *)
                          ;
                (*ENDWITH*) 
                _hcolinf.cinoutlen :=
                      ord(_pCol^.ccolstack.ecol_tab[ 1 ]) ;
&               ifdef TRACE
                t01int4 (ak_sem, 'd_inoutpos 2', dmli.d_inoutpos);
                t01int4 (ak_sem, 'elen_var    ',
                      acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free - 1].elen_var);
&               endif
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDIF*) 
_oldmfirst_free := acv.a_mblock.mb_qual^.mfirst_free;
IF  (dmli.d_union OR
    (acv.a_recursive_state in [ rs_first_select, rs_recursive_select ]))
    AND dmli.d_subquery
THEN
    _put_together := false;
(*ENDIF*) 
IF  ((acv.a_returncode = 0) AND dmli.d_use_order)
THEN
    a61_is_orderfield (acv, dmli, _hcolinf, @dmli.d_order_cols,
          NOT _put_together, _convert_t, curr_n, dmli.d_column);
(*ENDIF*) 
IF  ((acv.a_returncode = 0) AND dmli.d_group)
THEN
    BEGIN
    a061get_colname (colinf, _aux_name);
    a61_is_group_field (acv, dmli, _aux_name, colinf.cextcolno,
          colinf.creccolno, NOT c_is_expression, 0, dmli.d_vppos)
    END;
(*ENDIF*) 
IF  ( acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_proc
    in [ a63, a62, a16 ] ) AND
    ( dmli.d_tabarr^[ dmli.d_acttabindex ].oview OR
    (oresfile in dmli.d_tabarr^[ dmli.d_acttabindex ].ospecialname) ) AND
    NOT (dmli.d_subquery OR acv.a_from_select) AND
    NOT _put_together
THEN
    IF  ( acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free - 1].etype = st_output )
    THEN
        IF  ( acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free - 1].eop = op_none )
        THEN
            acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free - 1].eop_out := op_o_output_oflw;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
col_index := succ (col_index);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61sel_val_expr (
            VAR acv       : tak_all_command_glob;
            VAR dmli      : tak_dml_info;
            curr_n        : tsp00_Int2;
            VAR col_index : integer;
            subquery_get  : boolean);
 
VAR
      _overflow_allow   : boolean;
      _put_together     : boolean;
      _together_allowed : boolean;
      _extdatetime      : boolean;
      _is_io            : boolean;
      _convert_type     : tsp00_DataType;
      _hdatatyp         : tsp00_DataType;
      _col_no           : integer;
      _oldinoutpos      : integer;
      _output_len       : integer;
      _datatype_n       : integer;
      _colinf           : tak00_columninfo;
      _colin            : tak00_scolinf;
      _new_col_ptr      : tak00_colinfo_ptr;
      _pCol             : tak00_colinfo_ptr;
      _convert_t        : tak_convert_type;
      _uconvert_t       : tak_convert_type;
 
BEGIN
(* select_list contains other expr. than 'single columns' or '*' *)
(* PTS 1111575 E.Z. *)
&IFDEF TRACE
t01name (ak_sem, 'AK61: FSD false   ');
&ENDIF
dmli.d_const_value_expr  := true;
dmli.d_param_st_begin    := 0;
dmli.d_param_st_index    := 0;
dmli.d_is_parameter_only := false;
_colin.sci_len       := 0;
_colin.sci_cprops    := []; (* h.b. PTS 1105136 *)
dmli.d_datatype          := dunknown;
dmli.d_colptr            := NIL;
dmli.d_first_tab         := 0;
dmli.d_pars_kind         := fp_val_all_without_l;
dmli.d_change_date_time  := false;
IF  subquery_get
THEN
    BEGIN
    _datatype_n := acv.a_ap_tree^[curr_n].n_sa_level;
    (* PTS 1121191 E.Z. *)
    IF  _datatype_n = 0
    THEN
        a07_b_put_error (acv, e_corelated_subquery_not_allowe,
              acv.a_ap_tree^[ curr_n ].n_pos)
    ELSE
        WITH acv.a_ap_tree^[_datatype_n], _colin DO
            BEGIN
            sci_typ      := n_datatype;
            dmli.d_datatype := n_datatype;
            IF  sci_typ = dfixed
            THEN
                BEGIN
                sci_len      := n_pos DIV 100;
                (* PTS 1122971 E.Z. *)
                sci_frac     := (n_pos MOD 100) - cak_frac_offset;
                END
            ELSE
                BEGIN
                sci_len      := n_pos;
                IF  (sci_typ = dfloat) OR
                    (sci_typ = dvfloat)
                THEN
                    sci_frac := csp_float_frac
                ELSE
                    sci_frac     := 0
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            sci_iolen    := n_length;
            sci_cprops   := [ ctopt ];
            (*
                  sci_dttyp    :=
                  sci_com_type :=
                  sci_udt_id   :=
                  *)
            a65subq_get_val (acv, curr_n, sci_iolen);
            END
        (*ENDWITH*) 
    (*ENDIF*) 
    END
ELSE
    BEGIN
    a65_val_expr (acv, dmli, _colin, curr_n);
    IF  acv.a_returncode = cak_e_parameter
    THEN
        BEGIN
        acv.a_returncode := 0;
        dmli.d_is_parameter_only := true;
        a65_look_for_datatypes (acv, dmli, curr_n);
        IF  dmli.d_datatype = dunknown
        THEN
            a07_b_put_error (acv, e_without_datatypes,
                  acv.a_ap_tree^[ curr_n ].n_pos)
        ELSE
            IF  acv.a_returncode = 0
            THEN
                BEGIN
                _colin.sci_len := 0;
                a65_val_expr (acv, dmli, _colin, curr_n)
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
dmli.d_change_date_time := true;
_convert_t          := conv_none;
_uconvert_t         := conv_none;
_hdatatyp           := dunknown;
IF  acv.a_returncode = 0
THEN
    BEGIN
    WITH _colinf, _colin DO
        BEGIN
        cbinary := false;
        (* PTS 1116837 E.Z. *)
        IF  NOT (dmli.d_union OR
            (acv.a_recursive_state in [ rs_first_select, rs_recursive_select ]))
        THEN
            BEGIN
            IF  (acv.a_union_cnt < 1) AND (sci_typ = dunknown) AND
                (NOT dmli.d_subquery) AND (NOT acv.a_insert_select)
            THEN
                BEGIN
                (* NULL in select_list *)
                sci_typ := dchb
                END;
            (*ENDIF*) 
            IF  dmli.d_refname = a01_il_b_identifier
            THEN
                IF  acv.a_ap_tree^[ curr_n ].n_symb = s_rowno
                THEN
                    ccolumnn := a01_i_rowno
                ELSE
                    a61_new_expr_no (_colinf, dmli.d_exprno)
                (*ENDIF*) 
            ELSE
                ccolumnn := dmli.d_refname;
            (*ENDIF*) 
            ccolpropset := sci_cprops;
            END
        ELSE
            WITH acv.a_unionrec_ptr^.sunionrec DO
                BEGIN
                _col_no := ucolpos;
                WITH acv.a_p_arr1.pbasep^.sresult DO
                    BEGIN
                    _pCol        := a103GetColumn (acv.a_p_arr1.pbasep^.sbase, _col_no);
                    ccolpropset := _pCol^.ccolpropset;
                    a061get_colname (_pCol^, ccolumnn);
&                   IFDEF TRACE
                    ;
                    t01int4 (ak_sem, 'cdatatyp r  ', ord (cdatatyp));
                    t01int4 (ak_sem, 'ucolpos     ', ucolpos);
                    t01int4 (ak_sem, 'col_no      ', _col_no);
&                   ENDIF
                    END
                (*ENDWITH*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        a061eval_colname_len (_colinf);
        _overflow_allow := false;
        ak61iolen_get (acv, dmli, _extdatetime, _is_io,
              sci_typ, sci_len, sci_iolen);
        IF  _is_io
        THEN
            IF  ( acv.a_ap_tree^[ curr_n ].n_symb in
                [ s_mult, s_div, s_divide,
                s_mod, s_plus, s_minus,
                s_abs, s_fixed, s_num, s_noround,
                s_round, s_trunc, s_length, s_float,
                s_ceil, s_floor, s_sign, s_sqrt, s_power,
                s_min, s_max, s_avg, s_dis_avg, s_dis_sum,
                s_sum, s_count, s_dis_count, s_all_count,
                s_stddev, s_dis_stddev, s_variance, s_dis_variance,
                s_value, s_greatest, s_least, s_decode,
                s_cos, s_sin, s_tan, s_acos, s_asin, s_atan,
                s_atan2, s_exp, s_log, s_log10, s_ln ] ) AND
                (acv.a_sqlmode in [ sqlm_internal, sqlm_db2 ])
            THEN
                BEGIN
                _overflow_allow := true;
                IF  NOT ( acv.a_ap_tree^[ curr_n ].n_symb in
                    [ s_count, s_dis_count, s_all_count ] )
                THEN
                    ccolpropset := ccolpropset + [ ctopt ];
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        a061get_colname (_colinf, dmli.d_column);
        cextcolno   := 0;
        creccolno   := 1;
        IF  subquery_get
        THEN
            ctabno := 0
        ELSE
            ctabno := dmli.d_acttabindex;
        (*ENDIF*) 
        IF  (dmli.d_union OR
            (acv.a_recursive_state in [ rs_first_select, rs_recursive_select ]))
        THEN
            WITH acv.a_unionrec_ptr^.sunionrec DO
                BEGIN
                WITH acv.a_p_arr1.pbasep^.sresult DO
                    BEGIN
                    _hdatatyp  := sci_typ;
                    _pCol      := a103GetColumn (acv.a_p_arr1.pbasep^.sbase, _col_no);
                    cdatatyp  := _pCol^.cdatatyp;
                    cdatalen  := _pCol^.cdatalen;
                    cdatafrac := _pCol^.cdatafrac;
                    cinoutlen := _pCol^.cinoutlen;
                    ak61get_convert_type (_hdatatyp, cdatatyp, _uconvert_t);
                    END;
                (*ENDWITH*) 
                ucolpos := succ(ucolpos)
                END
            (*ENDWITH*) 
        ELSE
            BEGIN
&           IFDEF TRACE
            t01int4 (ak_sem, 'cdatatyp   1', ord (cdatatyp));
            t01int4 (ak_sem, 'typ        1', ord (sci_typ));
&           ENDIF
            cdatatyp  := sci_typ;
            cdatalen  := sci_len;
            cdatafrac := sci_frac + cak_frac_offset;
            cinoutlen := sci_iolen;
            END;
        (*ENDIF*) 
&       IFDEF TRACE
        t01int4 (ak_sem, 'colin   len ', sci_len);
        t01int4 (ak_sem, 'colin   frac', sci_frac);
        t01int4 (ak_sem, 'colin   iole', sci_iolen);
        t01int4 (ak_sem, 'colinf cdlen', cdatalen);
        t01int4 (ak_sem, 'colinf cdfra', cdatafrac - cak_frac_offset);
        t01int4 (ak_sem, 'colinf ciole', cinoutlen);
&       ENDIF
        WITH ccolstack DO
            BEGIN
            etype    := st_fixcol;
            eop      := op_none;
            epos     := 0;
            elen_var := 0;
            ecol_tab[ 1 ] := chr(0);
            ecol_tab[ 2 ] := chr(0)
            END
        (*ENDWITH*) 
        END;
    (*ENDWITH*) 
    IF  (dmli.d_union OR
        (acv.a_recursive_state in
        [ rs_first_select, rs_recursive_select ])) AND
        (_hdatatyp in [ ddate, dtime, dtimestamp ]) AND
        (_colinf.cdatatyp <> _hdatatyp)
    THEN
        _convert_type := _hdatatyp
    ELSE
        (* ???
              IF  dmli.d_union AND
              (_colinf.cdatatyp = dunicode) AND
              (_hdatatyp <> dunicode)
              THEN
              _convert_type := dunicode
              ELSE
              *)
        _convert_type := dunknown;
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        ak61outparam_typecheck (acv, dmli, _colinf);
        IF  dmli.d_cntpar > 0
        THEN
            ak61col_long_shortinfo (acv, dmli, _colinf)
        ELSE
            IF  (dmli.d_subquery OR NOT dmli.d_single) AND (NOT acv.a_from_select)
            THEN
                a07_b_put_error (acv, e_select_col_list_too_long,
                      acv.a_ap_tree^[ curr_n ].n_pos)
            ELSE
                WITH acv.a_transinf.tri_trans DO
                    trWarning_gg00 := trWarning_gg00 + [ warn0_exist,
                          warn3_output_not_into_columns ];
                (*ENDWITH*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  ((acv.a_returncode = 0) AND NOT dmli.d_single)
    THEN
        ak61build_colinfo (acv, dmli, _colinf, _new_col_ptr,
              _convert_t, col_index);
    (*ENDIF*) 
    _together_allowed := false;
    IF  (dmli.d_union OR
        (acv.a_recursive_state in [ rs_first_select, rs_recursive_select ]))
    THEN
        IF  (_convert_t <> conv_none)
        THEN
            BEGIN
            a65_convert (acv, _convert_t, _colinf.cinoutlen);
            _convert_t := conv_none;
            END
        ELSE
            _convert_t := _uconvert_t;
        (*ENDIF*) 
    (*ENDIF*) 
    _oldinoutpos := dmli.d_inoutpos;
    (* PTS 1106343 E.Z. *)
    a61_var_col_stackentry (acv, dmli, _colinf, _together_allowed, _put_together,
          _output_len, NOT c_is_corr_column, _convert_t, _convert_type);
    IF  ((acv.a_returncode = 0)     AND
        (acv.a_union_cnt > 0)                         AND
        (NOT dmli.d_union)                             AND
        NOT (acv.a_recursive_state in
        [ rs_first_select, rs_recursive_select ]) AND
        (_output_len <> 0))
    THEN
        _new_col_ptr^.ccolstack.ecol_tab[ 1 ] :=
              chr(_output_len);
&   ifdef TRACE
    (*ENDIF*) 
    t01int4 (ak_sem, 'a_union_cnt ', acv.a_union_cnt);
    t01int4 (ak_sem, 'd_union     ', ord(dmli.d_union));
    t01messblock (ak_sem, 'sel_val_expr', acv.a_mblock);
&   endif
    IF  ((acv.a_returncode = 0) AND
        (acv.a_union_cnt > 0)  AND
        (dmli.d_union OR
        (acv.a_recursive_state in [ rs_first_select, rs_recursive_select ])))
    THEN
        WITH acv.a_p_arr1.pbasep^.sresult DO
            BEGIN
            _pCol := a103GetColumn (acv.a_p_arr1.pbasep^.sbase, _col_no);
&           ifdef TRACE
            t01int4 (ak_sem, 'bcol ecol[1]',
                  ord(_pCol^.ccolstack.ecol_tab[ 1 ]));
            t01int4 (ak_sem, ' col cinoutl', _colinf.cinoutlen);
            t01int4 (ak_sem, 'd_inoutpos  ', dmli.d_inoutpos);
            t01int4 (ak_sem, 'oldinoutpos ', _oldinoutpos);
&           endif
            IF  ((_pCol^.ccolstack.ecol_tab[ 1 ] <> chr(0)) AND
                (dmli.d_inoutpos - _oldinoutpos <>
                ord(_pCol^.ccolstack.ecol_tab[ 1 ])) AND
                (ord(_pCol^.ccolstack.ecol_tab[ 1 ]) >
                _colinf.cinoutlen))
            THEN
                BEGIN
&               ifdef TRACE
                t01int4 (ak_sem, 'd_inoutpos 1', dmli.d_inoutpos);
&               endif
                dmli.d_inoutpos :=
                      ord(_pCol^.ccolstack.ecol_tab[ 1 ])
                      + _oldinoutpos;
                WITH acv.a_mblock, mb_qual^,
                     mb_st^ [mfirst_free - 1] DO
                    elen_var :=
                          ord(_pCol^.ccolstack.ecol_tab[ 1 ])
                          (*-
                          _colinf.cinoutlen
                          *)
                          ;
                (*ENDWITH*) 
                _colinf.cinoutlen :=
                      ord(_pCol^.ccolstack.ecol_tab[ 1 ]) ;
                (*
                      elen_var :=
                      ord(_pCol^.ccolstack.ecol_tab[ 1 ]) -
                      _colinf.cinoutlen;
                      *)
&               ifdef TRACE
                t01int4 (ak_sem, 'd_inoutpos 2', dmli.d_inoutpos);
                WITH acv.a_mblock, mb_qual^ DO
                    t01int4 (ak_sem, 'elen_var    ',
                          mb_st^ [mfirst_free - 1].elen_var);
                (*ENDWITH*) 
&               endif
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  ((acv.a_returncode = 0) AND dmli.d_use_order)
    THEN
        a61_is_orderfield (acv, dmli, _colinf, @dmli.d_order_cols,
              c_single_column, _convert_t, curr_n, dmli.d_column);
    (*ENDIF*) 
    IF  _overflow_allow
    THEN
        WITH acv.a_mblock, mb_qual^ DO
            IF  ( mb_st^ [mfirst_free - 1].etype = st_output )
            THEN
                IF  ( mb_st^ [mfirst_free - 1].eop_out in
                    [ op_o_none, op_o_output ] )
                THEN
                    mb_st^ [mfirst_free - 1].eop_out := op_o_output_oflw
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
col_index := succ(col_index);
END;
 
&ifdef LONGREC
(*------------------------------*) 
 
PROCEDURE
      ak61my_special_column (
            VAR acv       : tak_all_command_glob;
            VAR dmli      : tak_dml_info;
            VAR col_index : integer);
 
VAR
      _col_found     : boolean;
      _is_corr_subq  : boolean;
      _i             : integer;
      _new_col_ptr   : tak00_colinfo_ptr;
 
BEGIN
a61_rel_old_table (acv, dmli, 1);
dmli.d_column := a01_i_internal;
_col_found := a061exist_columnname (dmli.d_sparr.pbasep^.sbase,
      dmli.d_column, dmli.d_colbuf);
IF  _col_found
THEN
    BEGIN
    _is_corr_subq    := dmli.d_subquery AND (dmli.d_corr <> no_correlation);
    t01int4 (ak_sem, 'is_corr_subq', ord(_is_corr_subq));
    t01int4 (ak_sem, 'd_use_order ', ord(dmli.d_use_order));
    IF  (acv.a_returncode = 0) AND
        dmli.d_use_order                          AND
        NOT _is_corr_subq
    THEN
        WITH dmli.d_order_cols DO
            BEGIN
            t01int4 (ak_sem, 'ocntord     ', ocntord);
            FOR _i := 1 TO ocntord DO
                BEGIN
                t01int4 (ak_sem, 'i           ', _i);
                t01int4 (ak_sem, 'ofno        ', ofield[ _i ].ofno);
                IF  ofield[ _i ].ofno > 0
                THEN
                    ofield[ _i ].ofno := succ(ofield[ _i ].ofno);
                (*ENDIF*) 
                END;
            (*ENDFOR*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    dmli.d_colbuf^.ccolpropset := dmli.d_colbuf^.ccolpropset - [ ctdropped ];
    ak61one_select_column (acv, dmli, dmli.d_colbuf^,
          _new_col_ptr, 1, col_index);
    dmli.d_colbuf^.ccolpropset := dmli.d_colbuf^.ccolpropset + [ ctdropped ];
    END
(*ENDIF*) 
END;
 
&endif
(*------------------------------*) 
 
PROCEDURE
      a61_check_val_params (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            sel_node : integer;
            par_node : integer);
 
VAR
      _double_col      : boolean;
      _curr_col        : integer;
      _curr_par        : integer;
      _col_index       : integer;
      _i               : integer;
      _jumpstackentry  : integer;
      _m_qual_cnt      : integer;
      _double_col_name : tsp00_KnlIdentifier;
 
BEGIN
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
&   ifdef TRACE
    t01int4 (ak_sem, 'sel_node    ', sel_node);
&   endif
    dmli.d_allowed         := may_more_tabs;
    dmli.d_wherepart       := false;
    dmli.d_having          := false;
    dmli.d_expand          := 0;
    acv.a_long_desc_pos    := 0;
    acv.a_output_data_pos  := 1;
    acv.a_allow_functions  := tf_no_func;
    _col_index := 1;
    IF  ( acv.a_mblock.mb_qual^.mqual_pos = 0 )
    THEN
        acv.a_mblock.mb_qual^.mqual_pos := acv.a_mblock.mb_qual^.mfirst_free;
    (*ENDIF*) 
    acv.a_mblock.mb_qual^.mqual_cnt := succ( acv.a_mblock.mb_qual^.mqual_cnt );
    _m_qual_cnt     := acv.a_mblock.mb_qual^.mqual_cnt;
    _jumpstackentry := acv.a_mblock.mb_qual^.mfirst_free;
    acv.a_mblock.mb_qual^.mfirst_free :=
          succ( acv.a_mblock.mb_qual^.mfirst_free );
    IF  ( NOT dmli.d_subquery )
    THEN
        BEGIN
        IF  ((acv.a_ap_tree^[ par_node ].n_proc = a60) AND
            (acv.a_ap_tree^[ par_node ].n_subproc = cak_x_single_select))
        THEN
            BEGIN
            dmli.d_cntpar := 1;
            _curr_par := acv.a_ap_tree^[ par_node ].n_lo_level;
            dmli.d_parnum := acv.a_ap_tree^[ _curr_par ].n_length;
            WHILE acv.a_ap_tree^[ _curr_par ].n_sa_level <> 0 DO
                BEGIN
                _curr_par := acv.a_ap_tree^[ _curr_par ].n_sa_level;
                dmli.d_cntpar := succ(dmli.d_cntpar)
                END;
            (*ENDWHILE*) 
            (* PTS 1103681 E.Z. *)
            IF  (acv.a_precomp_info_byte >= csp1_p_mass_command) AND
                (acv.a_return_segm^.sp1r_function_code >= csp1_masscmd_fc_offset) AND
                (dmli.d_cntpar = acv.a_count_variab)
            THEN
                BEGIN
                acv.a_precomp_info_byte := acv.a_precomp_info_byte - csp1_p_mass_command;
                acv.a_return_segm^.sp1r_function_code :=
                      acv.a_return_segm^.sp1r_function_code - csp1_masscmd_fc_offset
                END;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            dmli.d_parnum := acv.a_count_variab + 1;
            dmli.d_cntpar := acv.a_count_variab + MAX_COL_PER_TAB_GG00;
&           ifdef LONGREC
            IF  NOT(acv.a_ap_tree^[ sel_node ].n_symb in
                [ s_count, s_sum ])                          AND
                (NOT dmli.d_view)                                 AND
                (acv.a_recursive_state = rs_no_recursive_select) AND
                (NOT dmli.d_group)                                AND
                (acv.a_fromsel_n = 0)                            AND
                (acv.a_union_cnt = 0)                            AND
                (acv.a_max_intern_select = 0)                    AND
                ((acv.a_ap_tree^[ acv.a_ap_tree^[0].n_lo_level ].n_proc <> a56) OR
                ( acv.a_ap_tree^[ acv.a_ap_tree^[0].n_lo_level ].n_subproc
                <> cak_x_insert_select))                     AND
                NOT (acv.a_is_ddl = ddl_create_as_select)
            THEN
                ak61my_special_column (acv, dmli, _col_index);
&           endif
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  acv.a_ap_tree^[ sel_node ].n_symb = s_count
    THEN
        acv.a_mblock.mb_type2 := mm_with_functions;
    (*ENDIF*) 
    _curr_col := acv.a_ap_tree^[ sel_node ].n_lo_level;
    dmli.d_exprno := 0;
    dmli.d_refname := a01_il_b_identifier;
    REPEAT
&       IFDEF TRACE
        t01int4 (ak_sem, 'output_pos  ', acv.a_output_data_pos);
        t01int4 (ak_sem, 'd_cntpar    ', dmli.d_cntpar);
        t01int4 (ak_sem, 'curr_col    ', _curr_col);
&       ENDIF
        ak61select_column_check( acv, dmli, _curr_col, _col_index );
        _curr_col  := acv.a_ap_tree^[ _curr_col ].n_sa_level
    UNTIL
        ((_curr_col = 0) OR (dmli.d_cntpar <= 0) OR
        (acv.a_returncode <> 0));
    (*ENDREPEAT*) 
    (* PTS 1111576 E.Z. *)
    IF  (acv.a_returncode = 0)
    THEN
        IF  ((dmli.d_cntpar <= 0) AND (_curr_col <> 0))
        THEN
            IF  (dmli.d_subquery OR NOT dmli.d_single) AND (NOT acv.a_from_select)
            THEN
                a07_b_put_error (acv, e_select_col_list_too_long,
                      acv.a_ap_tree^[ _curr_col ].n_pos)
            ELSE
                WITH acv.a_transinf.tri_trans DO
                    trWarning_gg00 := trWarning_gg00 + [ warn0_exist,
                          warn3_output_not_into_columns ]
                (*ENDWITH*) 
            (*ENDIF*) 
        ELSE
            BEGIN
            IF  ((acv.a_ap_tree^[ par_node ].n_proc = a60) AND
                (acv.a_ap_tree^[ par_node ].n_subproc = cak_x_single_select) AND
                (dmli.d_cntpar > 0))
            THEN
                BEGIN
                WITH acv.a_transinf.tri_trans DO
                    trWarning_gg00 := trWarning_gg00 + [ warn0_exist,
                          warn3_output_not_into_columns ];
                (*ENDWITH*) 
                IF  acv.a_ex_kind = only_parsing
                THEN
                    FOR _i := 0 TO dmli.d_cntpar - 1 DO
                        WITH dmli.d_sparr.pinfop^.sshortinfo.
                             siinfo[ dmli.d_parnum + _i ] DO
                            BEGIN (* superfluous out_parameter *)
                            sp1i_mode       := [ sp1ot_optional ];
                            sp1i_io_type    := sp1io_output;
                            sp1i_data_type  := dunknown;
                            sp1i_frac       := 0;
                            sp1i_length     := 1;
                            sp1i_in_out_len := 1;
                            sp1i_bufpos     := 1
                            END
                        (*ENDWITH*) 
                    (*ENDFOR*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  ((acv.a_mblock.mb_type2 = mm_with_functions) AND
        ( acv.a_union_cnt = 0) AND
        NOT dmli.d_view         AND
        NOT dmli.d_subquery)
    THEN
        ak61put_checknull_func (acv, dmli);
    (*ENDIF*) 
    IF  acv.a_mblock.mb_type2 = mm_with_functions
    THEN
        a61_put_last_func (acv);
    (*ENDIF*) 
    a61_set_jump( acv.a_mblock, _jumpstackentry, st_jump_output );
    acv.a_mblock.mb_st^[ _jumpstackentry ].epos :=
          acv.a_mblock.mb_st^[ _jumpstackentry ].epos + _m_qual_cnt;
    _double_col := false;
    _double_col_name := a01_il_b_identifier;
    IF  (dmli.d_view                   OR
        (acv.a_recursive_state = rs_check_select_list)) AND
        dmli.d_view_col_list                             AND
        NOT dmli.d_subquery
    THEN
        BEGIN
        IF  dmli.d_view_col_node > 0
        THEN
            a07_b_put_error (acv, e_view_col_list_too_long,
                  acv.a_ap_tree^[dmli.d_view_col_node].n_pos);
        (*ENDIF*) 
        dmli.d_view_col_list := false
        END;
    (*ENDIF*) 
    IF  (NOT dmli.d_single AND NOT dmli.d_subquery) AND
        ( NOT dmli.d_first_union ) AND
        ((acv.a_intern_select_cnt = acv.a_max_intern_select)
        OR (acv.a_fromsel_n > 0)
        OR (acv.a_recursive_state = rs_first_select))
    THEN
        BEGIN
        a061sort (acv, dmli.d_esparr.pbasep^.sbase,
              dmli.d_exprno, _double_col, _double_col_name);
        IF  (dmli.d_pos_result = cak_extern_pos) OR
            (dmli.d_pos_result = cak_intern_pos)
        THEN
            acv.a_resname_addr[ dmli.d_pos_result ]^.sresname.resmaxlinkage := 1
        (*ENDIF*) 
        END;
    (* Double columns only allowed in unnamed result sets assuming that *)
    (* these sets are provided to ad hoc user                           *)
    (* EXPLAIN has a named reult set, therefor we make an exception     *)
    (* For all other named result sets (internal also user named sets)  *)
    (* it is not allowed to have double column names                    *)
    (*ENDIF*) 
    IF  _double_col AND
        (* PTS 1138343 D.T. *)
        (NOT (dmli.d_specialjoinfromselect AND acv.a_queryrewrite_modified))
        AND
        (
        (dmli.d_resname_found AND
        (* PTS 1115986 E.Z. *)
        ( NOT acv.a_intern_explain )) OR
        (acv.a_fromsel_n > 0) OR
        (* PTS 1105363 E.Z. *)
        dmli.d_view
        )
    THEN
        a07_nb_put_error (acv, e_duplicate_columnname,
              acv.a_ap_tree^[ sel_node ].n_pos, _double_col_name);
    (*ENDIF*) 
    IF  dmli.d_allowed = are_more_tabs
    THEN
        BEGIN
        IF  acv.a_ap_tree^[ sel_node ].n_symb <> s_sum
        THEN
            acv.a_ap_tree^[ sel_node ].n_symb := s_count;
        (*ENDIF*) 
        END
    ELSE
        IF  dmli.d_allowed = tabs_with_arith
        THEN
            acv.a_ap_tree^[ sel_node ].n_symb := s_sum;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  acv.a_allow_functions = tf_no_func
    THEN
        acv.a_allow_functions := tf_unknown;
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a61_format_change (
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info;
            stackpos    : integer;
            cdatatyp    : tsp00_DataType;
            VAR datalen : tsp00_Int2);
 
VAR
      _init_first_free : tsp00_Int4;
 
BEGIN
IF  (acv.a_dt_format <> dtf_oracle_date) OR (cdatatyp <> dtimestamp)
THEN
    BEGIN
    IF  stackpos <= acv.a_mblock.mb_st_max
    THEN
        BEGIN
        acv.a_date_time_used := true;
        WITH acv.a_mblock.mb_st^ [stackpos] DO
            BEGIN
            etype        := st_build_in_func;
            eop_build_in := op_b_format_change;
            eformat      := acv.a_dt_format;
            edatatype    := cdatatyp;
            elanguage    := acv.a_ak_language;
            CASE cdatatyp OF
                ddate :
                    elength := mxsp_extdate + 1;
                dtime :
                    elength := mxsp_exttime + 1;
                dtimestamp :
                    BEGIN
                    elength := mxsp_exttimestamp + 1;
                    IF  acv.a_dt_format = dtf_oracle_date
                    THEN
                        eformat := dtf_oracle_date
                    ELSE
                        IF  acv.a_dt_format = dtf_ts_eur
                        THEN
                            eformat := acv.a_dt_format
                        ELSE
                            (* PTS 1112472 E.Z. *)
                            IF  acv.a_dt_format = dtf_iso
                            THEN
                                eformat := acv.a_dt_format
                            ELSE
                                eformat := dtf_eur
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                END;
            (*ENDCASE*) 
            datalen := elength - 1
            END;
        (*ENDWITH*) 
        acv.a_mblock.mb_qual^.mfirst_free :=
              succ(acv.a_mblock.mb_qual^.mfirst_free);
        acv.a_mblock.mb_qual^.mqual_cnt   :=
              succ(acv.a_mblock.mb_qual^.mqual_cnt);
        END
    (*ENDIF*) 
    END
ELSE
    BEGIN (* Conversion to oracle date is done by TO_DATE build in *)
    IF  stackpos+2 <= acv.a_mblock.mb_st_max
    THEN
        BEGIN
&       ifdef trace
        t01int4 (ak_sem, 'stackpos    ', stackpos);
        t01int4 (ak_sem, 'mfirst_free ', acv.a_mblock.mb_qual^.mfirst_free);
&       endif
        IF  stackpos <> acv.a_mblock.mb_qual^.mfirst_free
        THEN      (* stackpos isn't always at the end of the stack, *)
            BEGIN (* but the push procedure work only there...      *)
            _init_first_free := acv.a_mblock.mb_qual^.mfirst_free;
            acv.a_mblock.mb_qual^.mfirst_free     := stackpos
            END
        ELSE
            _init_first_free := 0;
        (*ENDIF*) 
        a641f_push_format   (acv, dmli); (* Push nls_date_format and *)
        a641l_push_language (acv, dmli); (* acv.a_ak_language on stack.  *)
        a641string_set_operator (acv, op_b_to_char,
              mxsp_exttimestamp+1, 0, chr (0), chr(0));
        IF  _init_first_free > 0
        THEN
            acv.a_mblock.mb_qual^.mfirst_free := _init_first_free+3;
        (*ENDIF*) 
        datalen := mxsp_exttimestamp
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61get_convert_type (
            sourcetyp     : tsp00_DataType;
            desttyp       : tsp00_DataType;
            VAR convert_t : tak_convert_type);
 
BEGIN
CASE sourcetyp OF
    dcha, ddate, dtime, dtimestamp:
        IF  desttyp = dunicode
        THEN
            convert_t := conv_ascii_to_unicode
        ELSE
            IF  desttyp in [ dfixed, dfloat, dvfloat ]
            THEN
                convert_t := conv_ascii_to_num;
            (*ENDIF*) 
        (*ENDIF*) 
    dunicode:
        IF  desttyp in [ dcha, ddate, dtime, dtimestamp ]
        THEN
            convert_t := conv_unicode_to_ascii
        ELSE
            IF  desttyp in [ dfixed, dfloat, dvfloat ]
            THEN
                convert_t := conv_unicode_to_num;
            (*ENDIF*) 
        (*ENDIF*) 
    dfixed, dfloat, dvfloat :
        IF  desttyp = dcha
        THEN
            convert_t := conv_num_to_ascii
        ELSE
            IF  desttyp = dunicode
            THEN
                convert_t := conv_num_to_unicode;
            (*ENDIF*) 
        (*ENDIF*) 
    OTHERWISE
        BEGIN
        END
    END
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a61_is_group_field (
            VAR acv       : tak_all_command_glob;
            VAR dmli      : tak_dml_info;
            VAR fieldname : tsp00_KnlIdentifier;
            extcolno      : tsp00_Int2;
            reccolno      : tsp00_Int2;
            is_expression : boolean;
            expression_n  : tsp00_Int2;
            errorpos      : integer);
 
VAR
      _found      : boolean;
      _i          : integer;
      _err_pos    : integer;
      _group_used : ak61_group;
 
BEGIN
&ifdef TRACE
t01int4 (ak_sem, 'is_expressio', ord(is_expression));
t01lidentifier (ak_sem, fieldname);
t01int4 (ak_sem, 'expression_n', expression_n);
&endif
_err_pos := errorpos;
_found   := false;
IF  NOT is_expression
THEN
    BEGIN
    _i := 1;
    WHILE ((_i <= dmli.d_group_cols.ocntord) AND NOT _found) DO
        BEGIN
&       ifdef TRACE
        t01int4 (ak_sem, 'acttabindex ', dmli.d_acttabindex);
        t01int4 (ak_sem, 'tabno       ', dmli.d_group_cols.ofield[ _i ].oftabno);
        t01lidentifier (ak_sem, dmli.d_group_cols.ofield[ _i ].ofname);
        t01bool (ak_sem, 'expression  ',
              is_val_expression in dmli.d_group_cols.ofield[ _i ].ofasc);
        t01int4 (ak_sem, 'reccolno    ', reccolno);
        t01int4 (ak_sem, 'extcolno    ', extcolno);
        t01int4 (ak_sem, 'offno       ', dmli.d_group_cols.ofield[ _i ].offno);
        t01int4 (ak_sem, 'is oview    ', ord(dmli.d_tabarr^[ dmli.d_acttabindex ].oview));
        t01int4 (ak_sem, 'is joinview ',
              ord(oisjoinview in dmli.d_tabarr^[ dmli.d_acttabindex ].ospecialname));
&       endif
        _found := NOT (is_val_expression in dmli.d_group_cols.ofield[ _i ].ofasc)
              AND
              (
              (
              ((dmli.d_acttabindex = dmli.d_group_cols.ofield[ _i ].oftabno) OR
              (                  0 = dmli.d_group_cols.ofield[ _i ].oftabno))    AND
              (fieldname = dmli.d_group_cols.ofield[ _i ].ofname)
              )
              OR
              (
              (dmli.d_acttabindex = dmli.d_group_cols.ofield[ _i ].oftabno)     AND
              (* PTS 1128197 D.T. *)
              (
              ((extcolno   = dmli.d_group_cols.ofield[ _i ].offno)   AND
              ( dmli.d_tabarr^[ dmli.d_acttabindex ].oview)          AND
              ( oisjoinview in dmli.d_tabarr^[ dmli.d_acttabindex ].ospecialname))
              OR
              ((reccolno   = dmli.d_group_cols.ofield[ _i ].offno)  AND
              NOT ((dmli.d_tabarr^[ dmli.d_acttabindex ].oview) AND
              (oisjoinview in dmli.d_tabarr^[ dmli.d_acttabindex ].ospecialname)))
              )
              )
              );
        IF  _found
        THEN
            BEGIN
            dmli.d_group_cols.ofield[ _i ].oftabno := dmli.d_acttabindex;
            dmli.d_group_cols.ofield[ _i ].offill  := extcolno;
            END;
        (*ENDIF*) 
        _i     := succ(_i);
        END;
    (*ENDWHILE*) 
    END
ELSE
    WITH acv.a_ap_tree^[ expression_n ] DO
        IF  ((n_proc = no_proc) AND
            (n_symb in [s_null, s_true, s_false, s_rowno]))
        THEN
            _found := true
        ELSE
            BEGIN
            FOR _i := 0 TO dmli.d_group_cols.ocntord DO
                _group_used [ _i ] := false;
            (*ENDFOR*) 
            IF  dmli.d_group_cols.ocntord = 0
            THEN
                ak61_search_node (acv, dmli, _group_used, 0, expression_n,
                      0, _err_pos, _found)
            ELSE
                BEGIN
                _i := 1;
                WHILE ((_i <= dmli.d_group_cols.ocntord) AND NOT _found) DO
                    BEGIN
&                   ifdef TRACE
                    t01int4 (ak_sem, 'cntord      ', dmli.d_group_cols.ocntord);
                    t01int4 (ak_sem, 'i           ', _i);
                    t01int4 (ak_sem, 'return_code ', acv.a_returncode);
&                   endif
                    ak61_search_node ( acv, dmli, _group_used, dmli.d_group_cols.ofield[ _i ].ofnode,
                          expression_n, _i, _err_pos, _found);
                    _i := succ(_i);
                    IF  (NOT _found AND (_i <= dmli.d_group_cols.ocntord))
                    THEN
                        acv.a_returncode := 0
                    (*ENDIF*) 
                    END;
                (*ENDWHILE*) 
                IF  NOT _found
                THEN
                    ak61_search_node (acv, dmli, _group_used, 0, expression_n,
                          0, _err_pos, _found)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDIF*) 
IF  NOT _found
THEN
    a07_nb_put_error (acv, e_output_field_must_be_group,
          _err_pos, fieldname);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak61node_compare (
            VAR acv   : tak_all_command_glob;
            tree1_node : tsp00_Int2;
            tree2_node : tsp00_Int2): boolean;
 
VAR
      _cmp_result : tsp00_LcompResult;
      _result     : boolean;
 
BEGIN
WITH acv.a_ap_tree^[ tree1_node ] DO
    BEGIN
    IF  (n_proc = acv.a_ap_tree^[ tree2_node].n_proc) AND
        (n_symb = acv.a_ap_tree^[ tree2_node].n_symb)
    THEN
        BEGIN
        IF  n_symb in
            [ s_authid, s_tablename, s_columnname, s_unsigned_integer,
            s_string_literal, s_byte_string, s_fixed_point_literal,
            s_floating_point_literal, s_identifier,
            s_special_identifier, s_sequence,
            s_reference_name, s_hostfilename]
        THEN
            BEGIN
            s30cmp ( acv.a_cmd_part^.sp1p_buf, n_pos, n_length,
                  acv.a_cmd_part^.sp1p_buf,
                  acv.a_ap_tree^[ tree2_node ].n_pos,
                  acv.a_ap_tree^[ tree2_node ].n_length, _cmp_result);
            _result := _cmp_result = l_equal;
            END
        ELSE
            IF  n_symb = s_columnid (* PTS 1128197 D.T. *)
            THEN
                BEGIN
                IF  (n_fromtabnode = acv.a_ap_tree^[ tree2_node ].n_fromtabnode) AND
                    (n_columnindex = acv.a_ap_tree^[ tree2_node ].n_columnindex)
                THEN
                    _result := true
                ELSE
                    _result := false;
                (*ENDIF*) 
                END
            ELSE
                _result := true;
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        _result := false;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
ak61node_compare := _result;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61comp_part_tree (
            VAR acv   : tak_all_command_glob;
            tree1_node : tsp00_Int2;
            tree2_node : tsp00_Int2;
            join       : boolean;
            VAR equal  : boolean);
 
BEGIN
equal := true;
WITH acv DO
    IF  (tree1_node <> 0) AND (tree2_node <> 0)
    THEN
        IF   ak61node_compare ( acv, tree1_node, tree2_node)
        THEN
            BEGIN
            IF  (acv.a_ap_tree^[ tree1_node ].n_sa_level <> 0) AND
                (acv.a_ap_tree^[ tree2_node ].n_sa_level <> 0)
            THEN
                ak61comp_part_tree (acv,
                      acv.a_ap_tree^[ tree1_node ].n_sa_level,
                      acv.a_ap_tree^[ tree2_node ].n_sa_level, join, equal);
            (*ENDIF*) 
            IF  equal AND
                (acv.a_ap_tree^[ tree1_node ].n_lo_level <> 0) AND
                (acv.a_ap_tree^[ tree2_node ].n_lo_level <> 0)
            THEN
                ak61comp_part_tree (acv,
                      acv.a_ap_tree^[ tree1_node ].n_lo_level,
                      acv.a_ap_tree^[ tree2_node ].n_lo_level, join, equal);
            (*ENDIF*) 
            END
        ELSE
            WITH acv.a_ap_tree^[ tree1_node ] DO
                IF  NOT((n_symb in [ s_authid, s_tablename,
                    s_columnname ]) AND
                    (acv.a_ap_tree^[ tree2_node ].n_symb in
                    [ s_authid, s_tablename, s_columnname ]) AND
                    (n_symb <> acv.a_ap_tree^ [ tree2_node ].n_symb)
                    AND NOT join)
                THEN
                    equal := false
                ELSE
                    CASE n_symb OF
                        s_authid:
                            IF  acv.a_ap_tree^[ tree2_node ].n_symb = s_tablename
                            THEN
                                ak61comp_part_tree (acv, n_sa_level,
                                      tree2_node, join, equal)
                            ELSE
                                ak61comp_part_tree (acv,
                                      acv.a_ap_tree^[ n_sa_level ].n_sa_level,
                                      tree2_node, join, equal);
                            (*ENDIF*) 
                        s_tablename:
                            IF  acv.a_ap_tree^[ tree2_node ].n_symb = s_authid
                            THEN
                                ak61comp_part_tree (acv, tree1_node,
                                      acv.a_ap_tree^[ tree2_node ].n_sa_level,
                                      join, equal)
                            ELSE
                                ak61comp_part_tree (acv, n_sa_level,
                                      tree2_node, join, equal);
                            (*ENDIF*) 
                        s_columnname:
                            IF  acv.a_ap_tree^[ tree2_node ].n_symb = s_tablename
                            THEN
                                ak61comp_part_tree (acv, tree1_node,
                                      acv.a_ap_tree^[ tree2_node ].n_sa_level,
                                      join, equal)
                            ELSE
                                ak61comp_part_tree (acv, tree1_node,
                                      acv.a_ap_tree^[ acv.a_ap_tree^[ tree2_node ].n_sa_level ].n_sa_level,
                                      join, equal);
                            (*ENDIF*) 
                        END;
                    (*ENDCASE*) 
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61_search_node (
            VAR acv       : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            VAR group_used : ak61_group;
            search_n       : integer;
            tree_n         : integer;
            group_index    : integer;
            VAR errorpos   : integer;
            VAR found      : boolean);
 
VAR
      _i         : integer;
      _node      : integer;
      _fieldname : tsp00_KnlIdentifier;
 
BEGIN
&ifdef TRACE
t01int4(ak_sem,'search_n    ',search_n);
t01int4(ak_sem,'tree_n      ',tree_n);
&endif
group_used [ group_index ] := true;
_fieldname := a01_il_b_identifier;
IF  ((search_n <> 0) OR (group_index = 0)) AND (tree_n <> 0)
THEN
    BEGIN
    IF   acv.a_ap_tree^ [ tree_n ].n_symb in
        [ s_sum, s_min, s_max, s_count, s_all_count, s_avg,
        s_stddev, s_variance, s_dis_sum, s_dis_count,
        s_dis_avg, s_dis_stddev, s_dis_variance ]
    THEN
        BEGIN
        IF  acv.a_ap_tree^ [ tree_n ].n_sa_level <> 0
        THEN
            ak61_search_node ( acv, dmli, group_used, search_n,
                  acv.a_ap_tree^ [ tree_n ].n_sa_level,
                  group_index, errorpos, found);
        (*ENDIF*) 
        found := acv.a_returncode = 0;
        END
    ELSE
        BEGIN
        found := false;
        IF   (group_index <> 0) AND
            ak61node_compare ( acv, search_n, tree_n)
        THEN
            BEGIN
            ak61comp_part_tree ( acv,
                  acv.a_ap_tree^ [ search_n ].n_lo_level,
                  acv.a_ap_tree^ [ tree_n ].n_lo_level, NOT c_join,
                  found);
            IF  (acv.a_ap_tree^ [ tree_n ].n_sa_level <> 0) AND
                found
            THEN
                ak61_search_node ( acv, dmli, group_used, search_n,
                      acv.a_ap_tree^ [ tree_n ].n_sa_level,
                      group_index, errorpos, found);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  NOT found
        THEN
            BEGIN
            IF  acv.a_ap_tree^ [ tree_n ].n_symb in
                [ s_authid, s_tablename, s_columnname, s_columnid ]
            THEN
                BEGIN
                _node := tree_n;
                WITH acv.a_ap_tree^[ tree_n ] DO
                    BEGIN
                    dmli.d_user  := a01_il_b_identifier;
                    dmli.d_vppos := n_pos;
                    dmli.d_n_pos := n_pos;
                    a06get_username (acv, tree_n, dmli.d_user);
                    END;
                (*ENDWITH*) 
                IF  tree_n > 0
                THEN
                    BEGIN
                    WITH acv.a_ap_tree^[ tree_n ] DO
                        IF  n_symb = s_tablename
                        THEN
                            BEGIN
                            a05identifier_get (acv,
                                  tree_n, sizeof (dmli.d_table), dmli.d_table);
                            tree_n := n_sa_level;
                            END;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    WITH acv.a_ap_tree^[ tree_n ] DO
                        IF  (n_symb = s_columnname) (* PTS 1128197 D.T. *)
                        THEN
                            BEGIN
                            a05identifier_get (acv,
                                  tree_n, sizeof (dmli.d_column), dmli.d_column);
                            a61_search_table ( acv, dmli);
                            END
                        ELSE
                            BEGIN (* s_columnid *)
                            dmli.d_fromtabnode := n_fromtabnode;
                            dmli.d_columnindex := n_columnindex;
                            a61_search_table_by_columnindex ( acv, dmli);
                            END;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    _fieldname := dmli.d_column;
                    IF  acv.a_returncode = 0
                    THEN
                        a61_is_group_field ( acv, dmli, _fieldname,
                              dmli.d_colbuf^.cextcolno,
                              dmli.d_colbuf^.creccolno,
                              NOT c_is_expression, 0,
                              acv.a_ap_tree^ [ tree_n ].n_pos);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                found := acv.a_returncode = 0;
                END
            ELSE
                IF  (acv.a_ap_tree^ [ tree_n ].n_symb in
                    [ s_unsigned_integer, s_string_literal,
                    s_byte_string, s_fixed_point_literal,
                    s_floating_point_literal,
                    s_parameter_name,
                    s_null, (* PTS 1122892 E.Z. *)
                    (* PTS 1140747 *)
                    s_date,
                    s_time,
                    s_timestamp,
                    s_timezone,
                    s_midnight,
                    s_now,
                    s_utcdiff,
                    s_utcdate,
                    s_user,
                    s_usergroup,
                    s_sysdba,
                    s_uid,
                    s_pi,
                    s_true,
                    s_false,
                    s_transaction,
                    s_currval,
                    s_current_schema
                    ])
                    OR
                    (acv.a_ap_tree^ [tree_n].n_proc = a63query_spec)
                    OR
                    ((acv.a_ap_tree^ [tree_n].n_proc    = a63) AND
                    ( acv.a_ap_tree^ [tree_n].n_subproc = cak_x_start_union))
                THEN
                    found := true;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  acv.a_ap_tree^ [ tree_n ].n_symb in
                [ s_mult, s_plus, s_minus, s_div, s_mod, s_divide,
                s_concat ]
            THEN
                BEGIN
                ak61_search_node ( acv, dmli, group_used, search_n,
                      acv.a_ap_tree^ [ tree_n ].n_lo_level,
                      group_index, errorpos, found);
&               ifdef TRACE
                t01int4 (ak_sem, 'found x     ', ord(found));
                t01int4 (ak_sem, 'tree_n      ', tree_n);
                t01int4 (ak_sem, 'und rechts ?',
                      acv.a_ap_tree^ [ tree_n ].n_sa_level);
&               endif
                IF  found
                THEN
                    BEGIN
                    _node := acv.a_ap_tree^ [ tree_n ].n_lo_level;
                    IF  acv.a_ap_tree^[ _node ].n_symb = s_authid
                    THEN
                        _node := acv.a_ap_tree^[ _node ].n_sa_level;
                    (*ENDIF*) 
                    IF  acv.a_ap_tree^[ _node ].n_symb = s_tablename
                    THEN
                        _node := acv.a_ap_tree^[ _node ].n_sa_level;
                    (*ENDIF*) 
                    _node := acv.a_ap_tree^[ _node ].n_sa_level;
                    ak61_search_node ( acv, dmli, group_used, search_n, _node,
                          group_index, errorpos, found);
                    END;
                (* PTS 1117523 E.Z. *)
                (*ENDIF*) 
                IF  (acv.a_ap_tree^ [ tree_n ].n_sa_level <> 0) AND found
                THEN
                    ak61_search_node ( acv, dmli, group_used,
                          search_n, acv.a_ap_tree^ [ tree_n ].n_sa_level,
                          group_index, errorpos, found);
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                _i := 1;
                WHILE ((_i <= dmli.d_group_cols.ocntord) AND NOT found) DO
                    BEGIN
                    IF  (_i <> group_index) AND
                        NOT group_used [ _i ] AND
                        (is_val_expression in dmli.d_group_cols.ofield[ _i ].ofasc)
                    THEN
                        ak61_search_node ( acv, dmli, group_used,
                              dmli.d_group_cols.ofield[ _i ].ofnode,
                              tree_n, _i, errorpos, found);
                    (*ENDIF*) 
                    _i := succ(_i);
                    END;
                (*ENDWHILE*) 
                IF  NOT found
                THEN
                    BEGIN
                    WITH acv.a_ap_tree^ [ tree_n ] DO
                        BEGIN
                        IF  (n_lo_level <> 0)
                        THEN
                            ak61_search_node ( acv, dmli, group_used,
                                  search_n, n_lo_level,
                                  group_index, errorpos, found)
                                  (*ELSE
                                  found := true*)
                                  ;
                        (*ENDIF*) 
                        IF  (n_sa_level <> 0) AND found
                        THEN
                            ak61_search_node ( acv, dmli, group_used,
                                  search_n, n_sa_level,
                                  group_index, errorpos, found);
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  NOT found
    THEN
        errorpos := acv.a_ap_tree^ [ tree_n ].n_pos;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a61_is_orderfield (
            VAR acv       : tak_all_command_glob;
            VAR dmli      : tak_dml_info;
            VAR colinf    : tak00_columninfo;
            order_ptr     : tak00_ord_fields_ptr;
            single_column : boolean;
            e_convert_t   : tak_convert_type;
            curr_n        : tsp00_Int2;
            VAR col       : tsp00_KnlIdentifier);
 
CONST
      c_to_upper = true;
 
VAR
      _do_more      : boolean;
      _found        : boolean;
      _equal        : boolean;
      _types_ok     : boolean;
      _change_type  : boolean;
      _is_corr_subq : boolean;
      _aux_d_join   : boolean;
      _convert_t    : tak_convert_type;
      _i            : integer;
      _pos          : integer;
      _startstack   : integer;
      _col_index    : integer;
      _store_jcnt   : tsp00_Int2;
      _st_pos       : tsp00_Int2;
      _start_st_pos : tsp00_Int2;
      _dtype_n      : tsp00_Int2;
      _hmqual_cnt   : tsp00_Int2;
      _hmfirst_free : tsp00_Int2;
      _out_len      : integer;
      _max_map_len  : integer;
      _dummy_buf    : tak_sysbufferaddress;
      _out_entry    : tgg00_StackEntry;
      _colin        : tak00_scolinf;
      _expression   : tsp00_KnlIdentifier;
      _this_is_ok   : boolean;
      _this_len     : integer;
      _is_expr_list : boolean;
 
BEGIN
WITH order_ptr^, acv.a_mblock, mb_qual^, colinf DO
    BEGIN
&   ifdef trace
    t01int4 (ak_sem, 'single_colum', ord (single_column));
    t01int4 (ak_sem, 'curr_n      ', curr_n);
    t01lidentifier (ak_sem, col);
    t01lidentifier (ak_sem, dmli.d_refname);
    t01int4 (ak_sem, 'd_subquery  ', ord(dmli.d_subquery));
    t01int4 (ak_sem, 'd_corr      ', ord(dmli.d_corr    ));
    t01int4 (ak_sem, 'd_act_node  ', dmli.d_act_node);
&   endif
    _is_corr_subq    := dmli.d_subquery AND (dmli.d_corr <> no_correlation);
    _colin.sci_len   := cdatalen;
    _colin.sci_iolen := cinoutlen;
    _colin.sci_typ   := cdatatyp;
    _pos          := 1;
    _do_more      := true;
    _found        := false;
    _is_expr_list := false;
    dmli.d_param_st_index := 0;
    IF  dmli.d_subquery AND (dmli.d_corr <> no_correlation) AND (dmli.d_act_node <> 0)
    THEN (* Is this a corelated subquery for an expression list? *)
        WITH acv.a_ap_tree^[ dmli.d_act_node ] DO
            IF  n_sa_level <> 0
            THEN (* there must be at least two datatype nodes. *)
                WITH acv.a_ap_tree^[ n_sa_level ] DO
                    _is_expr_list := (n_sa_level <> 0) AND
                          (n_proc = no_proc) AND (n_symb = s_unknown);
                (*ENDWITH*) 
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    WHILE _do_more DO
        WITH ofield[ _pos ] DO
            BEGIN
&           ifdef trace
            t01lidentifier (ak_sem, ofname);
            t01int4 (ak_sem, 'ofno        ', ofno);
            t01int4 (ak_sem, 'ofstno      ', ofstno);
            IF  is_order_asc in ofasc
            THEN
                t01name (ak_sem, 'ASCENDING         ');
            (*ENDIF*) 
            IF  is_opt in ofasc
            THEN
                t01name (ak_sem, 'OPTIONAL          ');
            (*ENDIF*) 
            IF  is_possible_oflw_field in ofasc
            THEN
                t01name (ak_sem, 'POSSIBLE OVERFLOW ');
            (*ENDIF*) 
            IF  is_val_expression in ofasc
            THEN
                t01name (ak_sem, 'VALUE EXPRESSION  ');
            (*ENDIF*) 
            IF  is_not_definite in ofasc
            THEN
                t01name (ak_sem, 'MISSING DEFINITE  ');
            (* PTS 1112977 E.Z. *)
            (*ENDIF*) 
            IF  is_col_only_specified in ofasc
            THEN
                t01name (ak_sem, 'COL ONLY SPECIFIED');
            (*ENDIF*) 
            t01int4 (ak_sem, 'oftabno     ', oftabno);
            t01int4 (ak_sem, 'ofapos      ', ofapos);
            t01int4 (ak_sem, 'offno       ', offno);
            t01int4 (ak_sem, 'ofnode      ', ofnode);
&           endif
            IF  (curr_n <> 0) AND (is_val_expression in ofasc) AND
                NOT (is_nls_column in ofasc)
            THEN
                BEGIN
                _equal := false;
                ak61comp_part_tree ( acv, curr_n, ofnode, dmli.d_join,
                      _equal );
                IF  _equal
                THEN
                    BEGIN
                    ofno   := dmli.d_outcolno;
                    ofname := dmli.d_column;
                    ofasc  := ofasc - [ is_val_expression ];
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            _this_is_ok := false;
            (* PTS 1112977 E.Z. *)
            (* a refname is used which is the same as a column name *)
            (* the columnname was found during a66_order_by.        *)
            (* But now the reference name wins                      *)
            IF  (dmli.d_refname = ofname)               AND
                (dmli.d_refname <> a01_il_b_identifier) AND
                (is_col_only_specified in ofasc)
            THEN
                IF  ofstno = 0
                THEN
                    (* PTS 1113255 E.Z. *)
                    IF  (dmli.d_union AND
                        (dmli.d_order_or_group_cols <> @dmli.d_group_cols))
                    THEN
                        BEGIN
                        ofasc  := ofasc - [ is_col_only_specified ];
                        ofname := a01_il_b_identifier;
                        ofno   := dmli.d_outcolno;
                        acv.a_ap_tree^[ofnode].n_symb := s_equal;
                        acv.a_ap_tree^[ofnode].n_pos  := pred(dmli.d_outcolno);
                        END
                    ELSE
                        BEGIN
                        ofasc    := ofasc - [ is_opt, is_val_expression,
                              is_nls_column ];
                        oftabno  := dmli.d_acttabindex;
                        offno    := 0;
                        END
                    (*ENDIF*) 
                ELSE
                    a07_b_put_error (acv, e_missing_column_definite, ofapos);
                (*ENDIF*) 
            (*ENDIF*) 
            IF  (dmli.d_refname = a01_il_b_identifier) AND
                (col = ofname) AND
                (is_not_definite in ofasc) AND
                (dmli.d_acttabindex <> oftabno) AND
                (0 <> oftabno)
            THEN
                a07_b_put_error (acv, e_missing_column_definite, ofapos)
            ELSE
                (* PTS 1112977 E.Z. *)
                IF  (
                    ((
                    (* PTS 1113255 E.Z. *)
                    (
                    (col = ofname)                         AND
                    (dmli.d_refname = a01_il_b_identifier) AND
                    (NOT dmli.d_union OR (dmli.d_order_or_group_cols = @dmli.d_group_cols))
                    )
                    OR
                    ((is_col_only_specified in ofasc) AND
                    ( dmli.d_refname = ofname)        AND
                    ( dmli.d_refname <> a01_il_b_identifier))
                    )
                    AND
                    ((dmli.d_acttabindex = oftabno) OR (0 = oftabno))
                    )
                    OR
                    (dmli.d_outcolno = ofno)
                    )
                THEN
                    IF  ((col = a01_i_rowno)
                        (* PTS 1104857 E.Z. *)
                        AND (acv.a_sqlmode = sqlm_internal)
                        AND NOT dmli.d_subquery)
                    THEN
                        a07_b_put_error (acv, e_rowno_not_allowed, ofapos)
                    ELSE
                        IF  _found
                        THEN
                            BEGIN
                            FOR _i := _pos + 1 TO ocntord DO
                                ofield[ _i-1 ] := ofield[ _i ];
                            (*ENDFOR*) 
                            _pos     := pred(_pos);
                            ocntord := pred(ocntord)
                            END
                        ELSE
                            IF  ofstno = 0
                            THEN
                                _this_is_ok := true
                                      (* PTS 1112977 E.Z. *)
                            ELSE
                                IF  is_col_only_specified in ofasc
                                THEN
                                    (* PTS 1119114 E.Z. *)
                                    IF  (dmli.d_acttabindex <> oftabno) OR
                                        ((dmli.d_acttabindex = oftabno) AND (offno = 0))
                                    THEN
                                        a07_b_put_error (acv, e_missing_column_definite, ofapos);
                                    (*ENDIF*) 
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            IF  _this_is_ok
            THEN
                BEGIN
                _expression := a01_i_expression;
                IF  (ofno > 0)                                 AND
                    (dmli.d_outcolno = ofno)                        AND
                    (col <> a01_i_rowno)                       AND
                    (dmli.d_refname = a01_il_b_identifier)          AND
                    NOT s30eq( col, _expression, 1,
                    a01_l_expression)    AND
                    (ofname = a01_il_b_identifier)             AND
                    (dmli.d_colbuf <> NIL)                          AND
                    (offno = 0)                                AND
                    NOT dmli.d_union                                AND
                    NOT (acv.a_recursive_state in [ rs_first_select, rs_recursive_select ])
                THEN
                    WITH dmli.d_colbuf^,
                         dmli.d_tabarr^[ dmli.d_acttabindex ] DO
                        BEGIN
                        oftabno := dmli.d_acttabindex;
                        IF  ((ccolstack.etype <> st_func) OR
                            (* LASTFUNCTION *)
                            ((ccolstack.etype = st_func) AND
                            (ccolstack.eop_func = op_f_none)))
                        THEN
                            IF  (oview) AND (oisjoinview in ospecialname)
                            THEN
                                offno := cextcolno
                            ELSE
                                offno := creccolno
                            (*ENDIF*) 
                        ELSE
                            a07_nb_put_error (acv, e_invalid_view_column,
                                  _pos, dmli.d_column);
                        (*ENDIF*) 
                        IF  ctopt in ccolpropset
                        THEN
                            ofasc := ofasc + [ is_opt ];
                        (*ENDIF*) 
                        ofname := dmli.d_column;
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
                _found  := true;
                _i      := mfirst_free - 1;
                _st_pos := _i;
                _start_st_pos := _st_pos;
                IF  single_column
                THEN
                    mb_st^ [_i].eop_out := op_o_output_hold;
                (*ENDIF*) 
                IF  ((single_column AND (_i >= mb_st_max)) OR
                    ((NOT single_column) AND (_i >= mb_st_max - 1)))
                THEN
                    a07_b_put_error (acv, e_too_many_mb_stackentries, -mb_st_max)
                ELSE
                    BEGIN
                    IF  is_not_definite in ofasc
                    THEN
                        oftabno := dmli.d_acttabindex;
                    (*ENDIF*) 
                    _out_len := cinoutlen;
                    IF  NOT single_column
                    THEN
                        BEGIN
                        IF  ccolstack.etype = st_func
                        THEN
                            BEGIN
                            a61get_column_expression (acv, dmli, colinf, ofapos);
                            offno := -offno;
                            _i := mfirst_free - 1
                            END
                        ELSE
                            IF  is_val_expression in ofasc
                            THEN
                                BEGIN
                                _colin.sci_len      := 0;
                                _colin.sci_iolen    := 0;
                                dmli.d_datatype         := dunknown;
                                dmli.d_colptr           := NIL;
                                dmli.d_first_tab        := 0;
                                dmli.d_pars_kind        := fp_val_all_without_l;
                                _change_type        := dmli.d_change_date_time;
                                dmli.d_change_date_time := false;
                                _store_jcnt         := dmli.d_joins.jrc_cnt;
                                dmli.d_joins.jrc_cnt    := 0;
                                _aux_d_join         := dmli.d_join;
                                dmli.d_join             := false;
                                a65_val_expr (acv, dmli, _colin, ofnode);
                                _out_len            := _colin.sci_iolen;
                                dmli.d_joins.jrc_cnt    := _store_jcnt;
                                dmli.d_join             := _aux_d_join;
                                oftabno            := dmli.d_acttabindex;
                                _do_more            := false;
                                _i                  := pred(mfirst_free);
                                dmli.d_change_date_time := _change_type;
                                offno              := -offno;
                                END
                            ELSE
                                BEGIN
                                _i                  := succ(_i);
                                _st_pos             := _i;
                                _start_st_pos       := _i;
                                mqual_cnt          := succ(mqual_cnt);
                                mfirst_free        := succ(mfirst_free);
                                mb_st^ [_i]     := ccolstack;
                                mb_st^ [_i].ecol_tab [2] :=
                                      chr(dmli.d_tabarr^[ dmli.d_acttabindex ].ocounttabs
                                      + ctabno);
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        _st_pos := _i;
                        IF  (dmli.d_subquery) AND
                            NOT (dmli.d_view) AND
                            (NOT acv.a_outer_join) AND
                            ( acv.a_union_cnt = 0 ) AND
                            (cdatatyp in [ ddate, dtime, dtimestamp ]) AND
                            NOT acv.a_insert_select
                        THEN
                            BEGIN
                            _startstack := mfirst_free;
                            a65ch_format (acv, dmli, _startstack, _colin,
                                  dunknown, cdatatyp);
                            cinoutlen := _colin.sci_len + 1;
                            ak61upd_dtype_node (acv, dmli, colinf, _pos);
                            _out_len   := cinoutlen;
                            _i := pred(mfirst_free);
                            END;
                        (*ENDIF*) 
                        IF  e_convert_t <> conv_none
                        THEN
                            BEGIN
                            _hmfirst_free := mfirst_free;
                            a65_convert (acv, e_convert_t, cinoutlen);
                            _i := _i + mfirst_free - _hmfirst_free;
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  _is_expr_list
                    THEN
                        BEGIN
                        _dtype_n   := acv.a_ap_tree^[ dmli.d_act_node ].n_sa_level;
                        _col_index := _pos;
                        WHILE (_col_index > 1) AND
                              (acv.a_ap_tree^[ _dtype_n ].n_sa_level <> 0) DO
                            BEGIN (* go to 'pos'th dtype node. *)
                            _dtype_n   := acv.a_ap_tree^[ _dtype_n ].n_sa_level;
                            _col_index := pred (_col_index)
                            END;
                        (*ENDWHILE*) 
                        _this_len := acv.a_ap_tree^[ _dtype_n ].n_length;
&                       ifdef trace
                        t01int4 (ak_sem, 'this_len    ', _this_len);
&                       endif
                        IF  _this_len > 0
                        THEN
                            BEGIN
                            IF  single_column
                            THEN      (* A single column was pushed on the  *)
                                BEGIN (* stack and the last entry is an OUT.*)
                                (* We must operate the expand entry before  *)
                                (* the out, since everyone expect the out   *)
                                (* entry on top of stack.                   *)
                                _out_entry   := mb_st^ [_i];
                                _i           := pred (_i);
                                mqual_cnt   := pred (mqual_cnt);
                                mfirst_free := pred (mfirst_free)
                                END;
                            (*ENDIF*) 
                            _hmqual_cnt := mqual_cnt;
                            _types_ok := a65_datatypes_ok (acv, dmli,
                                  acv.a_ap_tree^[ _dtype_n ].n_datatype,
                                  acv.a_ap_tree^[ _dtype_n ].n_length,
                                  cdatatyp, c_is_subquery, ofnode,
                                  acv.a_ap_tree^[ ofnode ].n_pos,
                                  c_convert, _convert_t);
                            IF  _convert_t <> conv_none
                            THEN
                                BEGIN
                                CASE _convert_t OF
                                    conv_unicode_to_ascii :
                                        dmli.d_datatype := dcha;
                                    conv_ascii_to_unicode :
                                        dmli.d_datatype := dunicode;
                                    OTHERWISE
                                        BEGIN
                                        END
                                    END;
                                (*ENDCASE*) 
                                IF  dmli.d_datatype = dunicode
                                THEN
                                    _colin.sci_iolen := (2*_colin.sci_len)+1
                                ELSE
                                    _colin.sci_iolen := _colin.sci_len+1;
                                (*ENDIF*) 
                                _colin.sci_typ := dmli.d_datatype;
                                END;
                            (* Expand operand to width of corresp. value. *)
                            (*ENDIF*) 
                            a641string_set_operator (acv, op_b_expand,
                                  _this_len, _out_len, chr(1), chr(0));
                            _out_len := _this_len;
                            _i := _i + mqual_cnt - _hmqual_cnt;
                            IF  single_column
                            THEN      (* A single column is on top of stack *)
                                BEGIN (* so push the OUT HOLD on that one.  *)
                                _i             := succ (_i);
                                mb_st^ [_i]    := _out_entry;
                                mqual_cnt     := succ (mqual_cnt);
                                mfirst_free   := succ (mfirst_free);
                                (* PTS 1107400 E.Z. *)
                                dmli.d_inoutpos := dmli.d_inoutpos - mb_st^ [_i].elen_var + _out_len;
                                mb_st^ [_i].elen_var := _out_len
                                END
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  cdatatyp = dunicode
                        THEN
                            BEGIN
                            IF  acv.a_max_codewidth > 2
                            THEN
                                BEGIN
                                (* out_len has external length,     *)
                                (* in case of euc it will be longer *)
                                (* than internal length needed now  *)
                                _out_len := (_out_len-1) DIV acv.a_max_codewidth;
                                _out_len := _out_len * 2 + 1;
                                END;
&                           ifdef TRACE
                            (*ENDIF*) 
                            t01int4 (ak_sem, 'out_len 3   ', _out_len);
&                           endif
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  NOT (acv.a_nls_params.nls_binary) AND
                        (_colin.sci_typ = dcha) AND
                        NOT dmli.d_subquery         AND
                        NOT _is_corr_subq
                    THEN
                        BEGIN (* order by with nls support *)
                        a641get_mapcharset (acv, acv.a_nls_params.nls_sort,
                              1, _max_map_len, _dummy_buf);
                        _hmqual_cnt := mqual_cnt;
                        IF  _max_map_len = 2
                        THEN
                            IF  _colin.sci_len <= 10
                            THEN
                                _colin.sci_len := _colin.sci_len * 2
                            ELSE
                                _colin.sci_len := _colin.sci_len + 10;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        _out_len := _colin.sci_len + 1;
                        a641add_mapchar (acv,
                              dmli, _colin, acv.a_nls_params.nls_sort,
                              1, _colin.sci_len);
                        mb_st^[_i+1].ecol_tab[1] := chr (c_to_upper);
                        _i      := _i + mqual_cnt - _hmqual_cnt;
                        _st_pos := _i
                        END;
                    (*ENDIF*) 
                    _i           := succ(_i);
                    mqual_cnt   := succ(mqual_cnt);
                    mfirst_free := succ(mfirst_free);
                    WITH mb_st^ [_i] DO
                        BEGIN
                        etype := st_output;
                        IF  is_order_asc in ofasc
                        THEN
                            IF  dmli.d_subquery
                            THEN
                                eop_out := op_o_output_no_oflw
                            ELSE
                                eop_out := op_o_output
                            (*ENDIF*) 
                        ELSE
                            eop_out := op_o_output_order;
                        (*ENDIF*) 
                        epos     := 0;
&                       ifdef trace
                        t01int4 (ak_sem, 'curr_stack_i', _i);
                        t01int4 (ak_sem, 'out_len     ', _out_len);
&                       endif
                        IF  single_column AND
                            NOT _is_expr_list AND
                            (cdatatyp = dcha) AND
                            (succ(_colin.sci_len * 2) = _out_len) (* unicode-output *)
                        THEN
                            elen_var := succ(_colin.sci_len)
                        ELSE
                            elen_var := _out_len;
                        (*ENDIF*) 
                        IF  (dmli.d_union OR
                            (acv.a_recursive_state in [ rs_first_select, rs_recursive_select ]))
                        THEN
                            ak61_upd_union_column (acv, _st_pos, elen_var);
                        (*ENDIF*) 
                        cinoutlen := _out_len;
                        ecol_pos  := 0;
                        ofstno    := _i;
                        IF  (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_proc
                            in [ a63, a62, a16 ])
                            AND
                            ( dmli.d_tabarr^[ dmli.d_acttabindex ].oview OR
                            (oresfile in dmli.d_tabarr^[ dmli.d_acttabindex ].ospecialname)) AND
                            NOT (dmli.d_subquery OR acv.a_from_select)
                        THEN
                            ofasc := ofasc + [ is_possible_oflw_field ]
                        (*ENDIF*) 
                        END
                    (*ENDWITH*) 
                    END;
                (*ENDIF*) 
                IF  (offno > 0) AND
                    (
                    (_start_st_pos + 1 <> ofstno)
                    (* there are stackentries between          *)
                    (* the column- and the output-stackentries *)
                    OR
                    ((mb_st^ [ _start_st_pos   ].etype = st_output) AND
                    ( mb_st^ [ _start_st_pos-1 ].etype > st_filler4))
                    OR
                    ((mb_st^ [ _start_st_pos ].etype > st_filler4) AND
                    ( mb_st^ [ _start_st_pos ].etype <> st_output))
                    (* no column-stackentry, no output-hold *)
                    )
                THEN
                    offno := -offno (* used column but with internal expressions *);
                (*ENDIF*) 
                END;
&           ifdef trace
            (*ENDIF*) 
            t01int4 (ak_sem, 'end offno   ',offno);
&           endif
            _pos := succ(_pos);
            IF  _pos > ocntord
            THEN
                _do_more := false;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDWHILE*) 
&   ifdef TRACE
    t01messblock (ak_sem, 'is_orderfiel', acv.a_mblock);
&   endif
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a61_new_expr_no (
            VAR colinf : tak00_columninfo;
            VAR exprno : tsp00_Int2);
 
VAR
      _chardiff        : integer;
      _len             : integer;
 
BEGIN
WITH colinf DO
    BEGIN
    ccolumnn := a01_i_expression;
    IF  g01unicode
    THEN
        _chardiff := 2
    ELSE
        _chardiff := 1;
    (*ENDIF*) 
    _len := a01_l_expression * _chardiff;
    ccolpropset :=  ccolpropset + [ ctexpression ];
    exprno := succ(exprno);
    IF  exprno < 10
    THEN
        BEGIN
        ccolumnn[ _len+_chardiff ] := chr(exprno + ord('0'));
        END
    ELSE
        IF  exprno < 100
        THEN
            BEGIN
            ccolumnn[ _len+  _chardiff ] := chr(exprno DIV 10 + ord('0'));
            ccolumnn[ _len+2*_chardiff ] := chr(exprno MOD 10 + ord('0'))
            END
        ELSE
            IF  exprno < 1000
            THEN
                BEGIN
                ccolumnn[ _len+2*_chardiff ] := chr((exprno DIV  100)        + ord('0'));
                ccolumnn[ _len+3*_chardiff ] := chr((exprno DIV   10) MOD 10 + ord('0'));
                ccolumnn[ _len+4*_chardiff ] := chr((exprno         ) MOD 10 + ord('0'))
                END
            ELSE
                IF  exprno < 10000
                THEN
                    BEGIN
                    ccolumnn[ _len+  _chardiff ] := chr((exprno DIV 1000)        + ord('0'));
                    ccolumnn[ _len+2*_chardiff ] := chr((exprno DIV  100) MOD 10 + ord('0'));
                    ccolumnn[ _len+3*_chardiff ] := chr((exprno DIV   10) MOD 10 + ord('0'));
                    ccolumnn[ _len+4*_chardiff ] := chr((exprno         ) MOD 10 + ord('0'))
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    a061eval_colname_len (colinf)
    END
(*ENDWITH*) 
END;
 
(* PTS 1111575 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a61_p_long_info (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info;
            VAR colinf : tak00_columninfo);
 
BEGIN
a61columnnames (acv, dmli.d_sparr, dmli.d_refname, colinf);
IF  acv.a_returncode = 0
THEN
    IF  acv.a_ex_kind = only_parsing
    THEN
        IF  dmli.d_single
            (* PTS 1112770 E.Z. *)
            OR
            (* a73 for 'where pos of <restablename> *)
            (acv.a_ap_tree^[acv.a_ap_tree^[0].n_lo_level].n_proc in [a62, a73])
        THEN
            a61_p_short_info (acv, dmli.d_sparr, colinf, dmli.d_parnum,
                  dmli.d_inoutpos - cgg_rec_key_offset - dmli.d_keylen)
        ELSE
            a61_p_short_info (acv, dmli.d_sparr, colinf,
                  acv.a_count_variab+dmli.d_sparr.pcolnamep^.scolnames.cncount,
                  dmli.d_inoutpos - cgg_rec_key_offset - dmli.d_keylen)
        (*ENDIF*) 
    ELSE
        a61_p_short_info (acv, dmli.d_sparr, colinf,
              dmli.d_sparr.pcolnamep^.scolnames.cncount,
              dmli.d_inoutpos - cgg_rec_key_offset - dmli.d_keylen);
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a61columnnames (
            VAR acv     : tak_all_command_glob;
            VAR sparr   : tak_syspointerarr;
            VAR refname : tsp00_KnlIdentifier;
            VAR colinf  : tak00_columninfo);
 
VAR
      _error       : tsp8_uni_error;
      _namelen     : integer;
      _buf_pos     : integer;
      _length      : tsp00_Int4;
      _err_char_no : tsp00_Int4;
      _name_ptr    : tsp00_KnlIdentifierPtr;
      _name        : tsp00_KnlIdentifier;
      _aux         : tsp00_C256;
 
BEGIN
WITH sparr, pcolnamep^.scolnames DO
    IF  cncount >= MAX_COL_PER_TAB_GG00
    THEN
        a07_b_put_error (acv, e_select_col_list_too_long, 1)
    ELSE
        BEGIN
        IF  refname = a01_il_b_identifier
        THEN
            a061get_colname (colinf, _name)
        ELSE
            _name := refname;
        (*ENDIF*) 
        IF  g01unicode
        THEN
            BEGIN
            _namelen := s30unilnr (@_name, csp_unicode_blank,
                  1, sizeof(_name));
            _length := (_namelen DIV 2) * acv.a_max_codewidth;
            s80uni_trans (@_name, _namelen, csp_unicode, @_aux, _length,
                  acv.a_out_packet^.sp1_header.sp1h_mess_code,
                  [ ], _error, _err_char_no);
            IF  _error <> uni_ok
            THEN
                a07_hex_uni_error (acv, _error, 1, NOT c_trans_to_uni,
                      @_name [_err_char_no], c_unicode_wid);
            (*ENDIF*) 
            _namelen  := _length;
            _name_ptr := @_aux
            END
        ELSE
            BEGIN
            _namelen  := s30klen (_name, bsp_c1, sizeof(_name));
            _name_ptr := @_name;
            END;
        (*ENDIF*) 
        cnfullen := cnfullen + 1 + _namelen;
        _buf_pos  := cnlast^.b_sl - cak_sysbufferoffset -
              sizeof (cnlast^.scolnames.cnbit64fill) + 1;
        IF  cnlast^.b_sl + 1 + _namelen > MAX_RECLEN_GG00
        THEN
            BEGIN
            a10new (acv, sizeof (tak_columnnamesrecord),
                  cnlast^.scolnames.cnnext);
            IF  cnlast^.scolnames.cnnext = NIL
            THEN
                a07_b_put_error (acv, e_no_more_memory, 1)
            ELSE
                BEGIN
                cnfullen := cnfullen +
                      cgg_rec_key_offset + cnlast^.b_kl + sizeof (cnlast^.scolnames.cnbit64fill);
                SAPDB_PascalMove ('VAK61 ',   3,    
                      sizeof (cnlast^.scolnames),
                      sizeof (cnlast^.scolnames),
                      @cnlast^.scolnames, 1,
                      @cnlast^.scolnames.cnnext^.scolnames, 1,
                      cgg_rec_key_offset + cnlast^.b_kl,
                      acv.a_returncode);
                a06inc_linkage (cnlast^.scolnames.cnnext^.
                      syskey.slinkage);
                IF  _buf_pos <= sizeof (cnlast^.scolnames.cnbuf)
                THEN
                    BEGIN
                    cnlast^.scolnames.cnbuf[_buf_pos] := chr(_namelen);
                    _length := sizeof (cnlast^.scolnames.cnbuf) - _buf_pos;
                    SAPDB_PascalMove ('VAK61 ',   4,    
                          sizeof(_name), sizeof(cnlast^.scolnames.cnbuf),
                          @_name_ptr^, 1, @cnlast^.scolnames.cnbuf,
                          _buf_pos + 1, _length,
                          acv.a_returncode);
                    _name_ptr     := @_name_ptr^[_length+1];
                    _namelen      := _namelen - _length;
                    cnlast^.b_sl := MAX_RECLEN_GG00;
                    cnlast       := cnlast^.scolnames.cnnext;
                    _buf_pos      := 0
                    END
                ELSE
                    BEGIN
                    cnlast  := cnlast^.scolnames.cnnext;
                    _buf_pos := 1;
                    cnlast^.scolnames.cnbuf[_buf_pos] := chr(_namelen)
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        ELSE
            cnlast^.scolnames.cnbuf[_buf_pos] := chr(_namelen);
        (*ENDIF*) 
        SAPDB_PascalMove ('VAK61 ',   5,    
              sizeof(_name_ptr^), sizeof(cnbuf),
              @_name_ptr^, 1, @cnlast^.scolnames.cnbuf, _buf_pos + 1,
              _namelen, acv.a_returncode);
        cnlast^.b_sl := cgg_rec_key_offset + cnlast^.b_kl +
              sizeof (cnlast^.scolnames.cnbit64fill) +
              _buf_pos + _namelen;
&       ifdef trace
        t01buf (ak_sem, cnlast^, 1, cnlast^.b_sl);
&       endif
        cncount      := succ(cncount);
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a61_p_short_info (
            VAR acv    : tak_all_command_glob;
            VAR sparr  : tak_syspointerarr;
            VAR colinf : tak00_columninfo;
            i          : integer;
            fix_bufpos : integer);
 
BEGIN
IF  i > cak_maxparams
THEN
    a07_b_put_error (acv, e_too_many_variables, 1)
ELSE
    IF  sparr.pinfop <> NIL
    THEN
        WITH acv, colinf, sparr.pinfop^.sshortinfo, siinfo[ i ] DO
            BEGIN
            IF  i > sicount
            THEN
                sicount := i;
            (*ENDIF*) 
            IF  NOT (ctopt in ccolpropset)
            THEN
                sp1i_mode := [ sp1ot_mandatory ]
            ELSE
                sp1i_mode := [ sp1ot_optional ];
            (*ENDIF*) 
            sp1i_io_type := sp1io_output;
            IF  cdatatyp in [ dfloat, dvfloat ]
            THEN
                sp1i_frac := 0
            ELSE
                sp1i_frac := cdatafrac - cak_frac_offset;
            (*ENDIF*) 
            sp1i_length     := cdatalen;
            sp1i_in_out_len := cinoutlen;
            IF  fix_bufpos > 0
            THEN
                sp1i_bufpos := fix_bufpos
            ELSE
                WITH acv DO
                    BEGIN
                    sp1i_bufpos       := a_output_data_pos;
                    a_output_data_pos := a_output_data_pos + cinoutlen;
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            CASE cdatatyp OF
                dfloat, dvfloat,
                dstra, dstrb, dstruni,
                drowid :
                    sp1i_data_type := cdatatyp;
                ddate, dtime, dtimestamp :
                    BEGIN
                    sp1i_data_type := cdatatyp;
                    IF  (sp1i_in_out_len > succ(sp1i_length)) AND
                        (
                        (a_out_packet^.sp1_header.sp1h_mess_code < csp_unicode_swap) OR
                        acv.a_ascii_in_and_output (* new feature *)
                        )
                    THEN
                        BEGIN
                        sp1i_in_out_len := succ(sp1i_length);
                        sp1i_bufpos := sp1i_bufpos + sp1i_length;
                        END;
                    (*ENDIF*) 
                    END;
                dlonga :
                    sp1i_data_type := dstra;
                dlongb :
                    sp1i_data_type := dstrb;
                dlonguni :
                    sp1i_data_type := dstruni;
                dboolean :
                    IF  a_comp_type <> at_unknown
                    THEN
                        sp1i_data_type := cdatatyp
                    ELSE
                        sp1i_data_type := dchb;
                    (*ENDIF*) 
                dfixed :
                    IF  (cbinary AND (a_comp_type <> at_unknown))
                    THEN
                        BEGIN
                        IF  cdatalen = 5
                        THEN
                            sp1i_data_type := dsmallint
                        ELSE
                            IF  cdatalen = 10
                            THEN
                                sp1i_data_type := dinteger
                            ELSE
                                sp1i_data_type := dfixed;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    ELSE
                        sp1i_data_type := dfixed;
                    (*ENDIF*) 
                dcha :
                    (* PTS 1121482 E.Z. *)
                    BEGIN
                    IF  (sp1i_in_out_len > succ(sp1i_length)) AND
                        (
                        (a_out_packet^.sp1_header.sp1h_mess_code < csp_unicode_swap) OR
                        acv.a_ascii_in_and_output (* new feature *)
                        )
                    THEN
                        BEGIN
                        sp1i_in_out_len := succ(sp1i_length);
                        sp1i_bufpos := sp1i_bufpos + sp1i_length;
                        END;
                    (*ENDIF*) 
                    IF  ((cshiftoutchar = cgg04_truechar)
                        AND (a_comp_type <> at_unknown))
                    THEN
                        sp1i_data_type := dvarchara
                    ELSE
                        sp1i_data_type := dcha;
                    (*ENDIF*) 
                    END;
                dchb :
                    IF  ((cshiftoutchar = cgg04_truechar)
                        AND (a_comp_type <> at_unknown))
                    THEN
                        sp1i_data_type := dvarcharb
                    ELSE
                        sp1i_data_type := dchb;
                    (*ENDIF*) 
                dudt :
                    sp1i_data_type := dchb;
                dunicode : (* PTS 1107651 *)
                    IF  ((cshiftoutchar = cgg04_truechar)
                        AND (a_comp_type <> at_unknown))
                    THEN
                        sp1i_data_type := dvarcharuni
                    ELSE
                        sp1i_data_type := dunicode;
                    (*ENDIF*) 
                OTHERWISE
                    sp1i_data_type := dunknown
                END;
            (*ENDCASE*) 
            END
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a61_put_last_func (VAR acv : tak_all_command_glob);
 
VAR
      _j : integer;
 
BEGIN
IF  acv.a_mblock.mb_qual^.mfirst_free > acv.a_mblock.mb_st_max
THEN
    a07_b_put_error (acv, e_too_many_mb_stackentries, -acv.a_mblock.mb_st_max)
ELSE
    BEGIN
    (* write LASTFUNCTION stack entry *)
    acv.a_mblock.mb_qual^.mqual_cnt := succ(acv.a_mblock.mb_qual^.mqual_cnt);
    WITH acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free] DO
        BEGIN
        etype    := st_func;
        eop_func := op_f_none;
        _j := acv.a_mblock.mb_qual^.mfirst_free - 1;
        WHILE ((_j > 1) AND (acv.a_mblock.mb_st^ [_j].etype <> st_func)) DO
            _j := pred(_j);
        (*ENDWHILE*) 
        epos := acv.a_mblock.mb_qual^.mfirst_free - _j;
        elen_var := 0;
        ecol_tab[ 1 ] := chr(0);
        ecol_tab[ 2 ] := chr(0)
        END;
    (*ENDWITH*) 
    acv.a_mblock.mb_qual^.mfirst_free := succ(acv.a_mblock.mb_qual^.mfirst_free)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a61_rel_old_table (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            i        : integer);
 
VAR
      _temp_file_index : tsp00_Int4;
      _f_ok            : boolean;
      _syskey_tableid  : tgg00_Surrogate;
      _fn_tableid      : tgg00_Surrogate;
 
BEGIN
acv.a_long_desc_pos := 0;
WITH dmli.d_tabarr^[ i ] DO
    IF  dmli.d_acttabindex <> i
    THEN
        BEGIN
        IF  dmli.d_acttabindex > 0
        THEN
            a10rel_sysinfo (dmli.d_sparr.pbasep);
        (*ENDIF*) 
        ;
        (* !!! changes within following command flow have to *)
        (*     take over in a684get_relation_info()      !!! *)
        IF  a661_is_fromsel_table (acv, otreeid)
        THEN
            BEGIN
            dmli.d_sparr.psynfound := false;
            dmli.d_sparr.pcount    := 0;
            a661_build_t_fromsel_tableid (_syskey_tableid,
                  _fn_tableid,
                  acv.a_curr_ex_parskey, cak_fromseltab_site,
                  a101_GetTempFileLevel (acv, otreeid));
            a661_get_from_select_table (acv,
                  _syskey_tableid, dmli.d_sparr.pbasep, d_fix, c_all, _f_ok);
            END
        ELSE
            IF  oresfile in ospecialname
            THEN
                BEGIN
                a663restable_get (acv, d_fix, otable, dmli.d_sparr, _f_ok);
                END
            ELSE
                IF  oview
                THEN
                    a06_systable_get (acv, d_fix, ofromtableid,
                          dmli.d_sparr.pbasep, c_all, _f_ok)
                ELSE
                    IF  ouser = a01_i_temp
                    THEN
                        a06_systable_get (acv, d_fix, ofromtableid,
                              dmli.d_sparr.pbasep, c_all, _f_ok)
                    ELSE
                        a06_systable_get (acv, d_fix,
                              otreeid.fileTabId_gg00,
                              dmli.d_sparr.pbasep, c_all, _f_ok);
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  NOT _f_ok
        THEN
            BEGIN
            IF  oview
            THEN
                BEGIN
                a07_tb_put_error (acv, e_unknown_tablename, 1, ofromtableid);
                acv.a_error_tableid := ofromtableid;
                END
            ELSE
                BEGIN
                a07_tb_put_error (acv, e_unknown_tablename, 1,
                      otreeid.fileTabId_gg00);
                acv.a_error_tableid := otreeid.fileTabId_gg00
                END
            (*ENDIF*) 
            END
        ELSE
            dmli.d_acttabindex := i
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak61maybe_cor_column (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info) : boolean;
 
BEGIN
IF  (dmli.d_subcount > 0)
    AND (dmli.d_corr = no_correlation)
THEN
    BEGIN
    CASE acv.a_precomp_info_byte OF
        csp1_p_mass_command :
            BEGIN
            IF  acv.a_return_segm^.sp1r_function_code <>
                csp1_mselect_into_fc
            THEN
                acv.a_precomp_info_byte := csp1_p_none;
            (*ENDIF*) 
            IF  acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc = cak_x_mupdate
            THEN
                acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc := cak_x_update
            ELSE
                IF  acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc = cak_x_mdelete
                THEN
                    acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc := cak_x_delete
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        csp1_p_mselect_found :
            acv.a_precomp_info_byte := csp1_p_mass_select_found;
        csp1_p_for_upd_mselect_found :
            acv.a_precomp_info_byte := csp1_p_select_for_update_found;
        csp1_p_reuse_mselect_found :
            acv.a_precomp_info_byte := csp1_p_reuse_mass_select_found;
        csp1_p_reuse_upd_mselect_found :
            acv.a_precomp_info_byte := csp1_p_reuse_update_sel_found;
        OTHERWISE
            BEGIN
            END
        END;
    (*ENDCASE*) 
    a07_b_put_error (acv, e_corelated_subquery_not_allowe, dmli.d_vppos);
    ak61maybe_cor_column := true;
    END
ELSE
    ak61maybe_cor_column := false;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE (* PTS 1128197 D.T. *)
      ak61check_found_column (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info);
 
BEGIN
WITH dmli.d_colbuf^ DO
    IF  (cdatatyp in [dlonga, dlongb,
        dlonguni, dstruni, dstra, dstrb])
        AND
        NOT dmli.d_view
        AND
        (* PTS 1123714 E.Z. *)
        NOT dmli.d_wherepart
        AND
        NOT dmli.d_having
        AND
        (
        (acv.a_sqlmode = sqlm_ansi)                                       OR
        (* *** no subquery with exists *** *)
        (dmli.d_subquery AND (dmli.d_rowno <> cgg04_at_least_one_record)) OR
        (dmli.d_distinct <> no_distinct)
        )
    THEN
        a07_nb_put_error (acv,
              e_command_for_string_not_allow,
              dmli.d_vppos, dmli.d_column)
    ELSE
        BEGIN
&       ifdef trace
        t01int4(ak_sem, 'ctabno      ', ctabno);
        t01int4(ak_sem, '[]ocounttabs',
              dmli.d_tabarr^[dmli.d_acttabindex].ocounttabs);
&       endif
        dmli.d_basetabno := ctabno +
              dmli.d_tabarr^[dmli.d_acttabindex].ocounttabs;
        IF  ( ctabno = 0 )
        THEN
            (* constant expression *)
            dmli.d_basetabno := succ(dmli.d_basetabno);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a61_search_table (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info);
 
VAR
      _all_ok        : boolean;
      _tab_ok        : boolean;
      _col_found     : boolean;
      _i             : integer;
      _i_ok          : integer;
      _tab_index     : integer;
      _start         : integer;
      _itab          : integer;
 
BEGIN
_all_ok          := false;
_i               := dmli.d_acttabindex;
&ifdef trace
t01int4 (ak_sem, 'd_acttabinde',dmli.d_acttabindex);
t01knl_identifier (ak_sem, 'a_curr_user_', acv.a_curr_user_name);
t01knl_identifier (ak_sem, 'd_user      ', dmli.d_user);
t01knl_identifier (ak_sem, 'd_table     ', dmli.d_table);
t01knl_identifier (ak_sem, 'd_column    ', dmli.d_column);
&endif
_i_ok                := 0;
_start               := dmli.d_acttabindex;
_itab                := 0;
acv.a_long_desc_pos := 0;
IF  (dmli.d_table = a01_il_b_identifier) AND
    (dmli.d_column = a01_il_b_identifier)
THEN
    a07_b_put_error (acv, e_unknown_columnname, dmli.d_vppos);
(*ENDIF*) 
IF  (acv.a_returncode = 0)
THEN
    REPEAT
&       IFDEF TRACE
        WITH dmli.d_tabarr^[ _i ] DO
            BEGIN
            t01int4(ak_sem, 'i           ', _i);
            t01knl_identifier (ak_sem, '[i]ouser    ', ouser);
            t01knl_identifier (ak_sem, '[i]orefernec', oreference);
            t01knl_identifier (ak_sem, '[i]otable   ', otable);
            END;
        (*ENDWITH*) 
&       ENDIF
        IF  dmli.d_table = a01_il_b_identifier
        THEN
            _tab_ok := true
        ELSE
            BEGIN
            _tab_ok := false;
            WITH dmli.d_tabarr^[ _i ] DO
                IF  ((dmli.d_table = oreference)
                    AND
                    ((dmli.d_user = a01_il_b_identifier) OR
                    (dmli.d_user = acv.a_curr_user_name)))
                THEN
                    BEGIN
                    _start := (_i MOD dmli.d_cntfromtab) + 1;
                    _tab_ok := true
                    END
                ELSE
                    IF  NOT (oisreference in ospecialname)
                    THEN
                        IF  (dmli.d_table = otable)
                            AND
                            (dmli.d_user = ouser)
                        THEN
                            BEGIN
                            _start := (_i MOD dmli.d_cntfromtab) + 1;
                            _tab_ok := true
                            END
                        ELSE
                            IF  (dmli.d_table = otable)
                                AND
                                (dmli.d_user = a01_il_b_identifier)
                                AND
                                ((ospecs_needed = ons_only_tablename) OR
                                (dmli.d_column <> a01_il_b_identifier))
                            THEN
                                _tab_ok := true
                            ELSE
                                IF  ((dmli.d_table = otable)
                                    AND
                                    (dmli.d_user = a01_il_b_identifier)
                                    AND
                                    (
                                    (ouser = acv.a_curr_schema)                                    OR
                                    (NOT acv.a_curr_schema_set                                 AND
                                    ((ouser = acv.a_acc_dbaname)                            OR
                                    ( ouser = g01glob.sysuser_name)                         OR
                                    ( ouser = a01_i_public)                                 OR
                                    ((acv.a_sqlmode = sqlm_oracle) AND (ouser = a01_i_sys)) OR
                                    (((acv.a_sqlmode = sqlm_internal) OR g01glob.db_is_for_sapr3) AND (ouser = a01_i_domain)) ))
                                    ))
                                THEN
                                    _tab_ok := true;
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
        IF  _tab_ok
        THEN
            BEGIN
            _i_ok := _i;
&           ifdef trace
            t01int4(ak_sem, 'found on idx', _i);
&           endif
            a61_rel_old_table (acv, dmli, _i);
            IF  dmli.d_column = a01_il_b_identifier
            THEN
                BEGIN
                IF  _all_ok
                THEN
                    a07_b_put_error (acv,
                          e_missing_tablename_definite,
                          dmli.d_vppos)
                ELSE
                    BEGIN
                    _tab_index := dmli.d_acttabindex;
                    _all_ok := true
                    END
                (*ENDIF*) 
                END
            ELSE
                IF  acv.a_returncode = 0
                THEN
                    BEGIN
                    _col_found := a061exist_columnname (dmli.d_sparr.pbasep^.sbase,
                          dmli.d_column, dmli.d_colbuf);
                    IF  (NOT _col_found) AND
                        NOT (acv.a_recursive_state in
                        [ rs_no_recursive_select, rs_first_select]) AND
                        (dmli.d_sparr.pbasep^.sbase.bentrytype = cak_eresult)
                    THEN
                        (* the recursive table is not and *)
                        (* may not be sorted in alphabetically order *)
                        _col_found := ak61exist_columnname ( dmli.d_sparr.pbasep^.sbase,
                              dmli.d_column, dmli.d_colbuf);
                    (*ENDIF*) 
                    IF  _col_found
                    THEN
                        BEGIN
                        _col_found := false;
                        IF  NOT (ctinvisible in dmli.d_colbuf^.ccolpropset)
                        THEN
                            IF  dmli.d_tabarr^[ dmli.d_acttabindex ].oall_priv
                            THEN
                                _col_found := true
                            ELSE
                                BEGIN
                                IF  dmli.d_colbuf^.cextcolno in
                                    dmli.d_tabarr^[dmli.d_acttabindex].osetallpriv
                                THEN
                                    _itab := _i;
                                (*ENDIF*) 
                                IF  dmli.d_colbuf^.cextcolno in
                                    dmli.d_tabarr^[dmli.d_acttabindex].oprivset
                                THEN
                                    _col_found := true
                                (*ENDIF*) 
                                END
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  _col_found
                    THEN
                        IF  _all_ok
                        THEN
                            a07_nb_put_error (acv,
                                  e_missing_column_definite,
                                  dmli.d_vppos, dmli.d_column)
                        ELSE
                            BEGIN
                            _all_ok    := true;
                            _tab_index := dmli.d_acttabindex;
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    ;
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  _i = dmli.d_cntfromtab
        THEN
            _i := 1
        ELSE
            _i := succ(_i);
        (*ENDIF*) 
    UNTIL
        ((_i = _start) OR (acv.a_returncode <> 0));
    (*ENDREPEAT*) 
(*ENDIF*) 
IF  _i_ok = 0
THEN
    BEGIN
    IF  NOT ak61maybe_cor_column (acv, dmli)
    THEN
        a07_b_put_error (acv,
              e_table_not_in_from_list, dmli.d_vppos)
    (*ENDIF*) 
    END
ELSE
    IF  NOT _all_ok
    THEN
        BEGIN
        (* PTS 1122898 E.Z. *)
        IF  (dmli.d_table <> a01_il_b_identifier)
        THEN
            a07_nb_put_error (acv, e_unknown_columnname,
                  dmli.d_vppos, dmli.d_column)
        ELSE
            IF  NOT ak61maybe_cor_column (acv, dmli)
            THEN
                IF  _itab <> 0
                THEN
                    a07_nb_put_error (acv, e_missing_privilege,
                          dmli.d_vppos, dmli.d_column)
                ELSE
                    a07_nb_put_error (acv, e_unknown_columnname,
                          dmli.d_vppos, dmli.d_column)
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            a61_rel_old_table (acv, dmli, _tab_index);
&           ifdef trace
            t01int4(ak_sem, 'tab_index   ', _tab_index);
&           endif
            END;
        (*ENDIF*) 
        dmli.d_basetabno := 1;
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            _col_found := a061exist_columnname (dmli.d_sparr.pbasep^.sbase,
                  dmli.d_column, dmli.d_colbuf);
            IF  (NOT _col_found) AND
                (acv.a_recursive_state = rs_check_select_list) AND
                (dmli.d_sparr.pbasep^.sbase.bentrytype = cak_eresult)
            THEN
                (* the recursive table is not and *)
                (* may not be sorted in alphabetically order *)
                _col_found := ak61exist_columnname ( dmli.d_sparr.pbasep^.sbase,
                      dmli.d_column, dmli.d_colbuf);
            (*ENDIF*) 
            IF  _col_found
            THEN
                ak61check_found_column(acv, dmli);
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
&ifdef trace
t01int4(ak_sem, 'd_basetabno ', dmli.d_basetabno);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE (* PTS 1128197 D.T. *)
      a61_search_table_by_columnindex (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info);
 
VAR
      _tabno         : integer;
      _col_found     : boolean;
      _i             : integer;
      _start         : integer;
 
BEGIN
_tabno     := -1;
_col_found := false;
_start     := dmli.d_acttabindex;
_i         := _start;
REPEAT
    IF  (dmli.d_fromtabnode = dmli.d_tabarr^[ _i ].otab_node)
    THEN
        _tabno := _i
    ELSE
        _i := (_i MOD dmli.d_cntfromtab) + 1;
    (*ENDIF*) 
UNTIL
    (_tabno>=0) OR (_i=_start);
(*ENDREPEAT*) 
IF  (_tabno>=0)
THEN
    BEGIN
    IF  ( dmli.d_acttabindex <> _tabno )
    THEN
        a61_rel_old_table (acv, dmli, _tabno);
    (*ENDIF*) 
    IF  (acv.a_returncode = 0) AND
        (dmli.d_columnindex > 0)
    THEN
        BEGIN
        _col_found := a061exist_columnindex(dmli.d_sparr.pbasep^.sbase,
              dmli.d_columnindex, dmli.d_colbuf);
        dmli.d_column := a01_il_b_identifier;
        IF  _col_found
        THEN
            BEGIN
            dmli.d_table  := dmli.d_sparr.pbasep^.sbase.btablen^;
            (* dmli.d_column := dmli.d_colbuf^.ccolumnn; *)
            (* this doesn't work as ccolname is not expanded... *)
            SAPDB_PascalMove ('VAK61 ',   6,    
                  ord(dmli.d_colbuf^.ccolumnn_len),
                  sizeof(dmli.d_column),
                  @dmli.d_colbuf^.ccolumnn, 1,
                  @dmli.d_column, 1,
                  ord(dmli.d_colbuf^.ccolumnn_len),
                  acv.a_returncode);
            ak61check_found_column(acv, dmli);
            END
        ELSE
            a07_nb_put_error (acv, e_unknown_columnname,
                  dmli.d_vppos, dmli.d_column);
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
ELSE
    IF  NOT ak61maybe_cor_column (acv, dmli)
    THEN
        a07_b_put_error (acv,
              e_table_not_in_from_list, dmli.d_vppos);
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a61_set_jump (
            VAR mess_block : tgg00_MessBlock;
            stentrynr : integer;
            operatortype  : tgg00_StackEntryType);
 
BEGIN
WITH mess_block, mb_qual^, mb_st^ [stentrynr] DO
    BEGIN
    etype := operatortype;
    eop := op_none;
    epos := mqual_pos + mqual_cnt - stentrynr;
    elen_var := 0;
    ecol_tab[ 1 ] := chr(0);
    ecol_tab[ 2 ] := chr(0)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a61_update_column (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            VAR minkeylen  : integer;
            curr_n         : integer);
 
VAR
      _double_col       : boolean;
      _muse_order       : boolean;
      _put_together     : boolean;
      _together_allowed : boolean;
      _md_changecollen  : char;
      _convert_t        : tak_convert_type;
      _dummy_len        : integer;
      _fieldno          : integer;
      _m_cntpar         : integer;
      _md_colcount      : integer;
      _md_outcolno      : integer;
      _hcolinf          : tak00_columninfo;
      _double_col_name  : tsp00_KnlIdentifier;
 
BEGIN
WITH dmli DO
    BEGIN
    _md_outcolno := d_outcolno;
    _md_colcount := d_change.cr_colcount;
    IF  _md_colcount > 0
    THEN
        _md_changecollen := d_change.cr_columns[ _md_colcount ].ch_length
    ELSE
        _md_changecollen := chr(0);
    (*ENDIF*) 
    _m_cntpar    := d_cntpar;
    d_cntpar    := 0;
    _double_col  := false;
&   ifdef trace
    t01int4 (ak_sem, 'd_cntpar:=0 ', d_cntpar);
&   endif
    _muse_order  := d_use_order;
    d_use_order := false;
    _fieldno     := 1;
    minkeylen   := 0;
    d_colbuf := a103GetColumn (d_sparr.pbasep^.sbase,
          d_sparr.pbasep^.sbase.bfirstcolind);
    WITH _hcolinf, ccolstack DO
        BEGIN
        ccolumnn      := a01_il_b_identifier;
        ccolumnn[1]   := '@';
        ccolumnn[2]   := '@';
        ccolumnn[3]   := '@';
        ccolumnn[4]   := chr(1);
        ccolumnn_len  := chr(4);
        ccolpropset   := [ ctinvisible ];
        cextcolno     := 1;
        creccolno     := 1;
        ctabno        := 1;
        cdatatyp      := dchb;
        cdatalen      := 0;
        cinoutlen     := 0;
        cdatafrac     := 0;
        cnextind      := 0;
        cbinary       := false;
        etype         := st_fixkey;
        eop           := op_none;
        epos          := 1;
        elen_var      := 0;
        ecol_pos      := 0
        END;
    (*ENDWITH*) 
    _convert_t := conv_none;
    _together_allowed  := false;
    IF  d_sparr.pbasep^.sbase.bkeycolcount > 1
    THEN
        BEGIN
        WHILE (_fieldno < d_sparr.pbasep^.sbase.bkeycolcount) DO
            BEGIN
            WITH d_colbuf^ DO
                BEGIN
                _hcolinf.cinoutlen :=  _hcolinf.cinoutlen + cinoutlen;
                IF  cnextind > 0
                THEN
                    d_colbuf := a103GetColumn (d_sparr.pbasep^.sbase, cnextind)
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
            _fieldno := succ(_fieldno)
            END;
        (*ENDWHILE*) 
        _hcolinf.cdatalen :=  _hcolinf.cinoutlen - 1;
        _hcolinf.ccolstack.elen_var :=  _hcolinf.cinoutlen;
        a61_var_col_stackentry (acv, dmli, _hcolinf, _together_allowed, _put_together,
              _dummy_len, NOT c_is_corr_column, _convert_t, dunknown);
        END;
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        a061colinfo_to_var (d_colbuf^, _hcolinf);
        WITH _hcolinf DO
            BEGIN
            minkeylen    := ccolstack.epos;
            ccolumnn     := a01_il_b_identifier;
            ccolumnn[1]  := '@';
            ccolumnn[2]  := '@';
            ccolumnn[3]  := '@';
            ccolumnn[4]  := chr(2);
            ccolumnn_len := chr(4);
            ccolpropset  := [ ctinvisible ];
            END;
        (*ENDWITH*) 
        a61_var_col_stackentry (acv, dmli, _hcolinf, _together_allowed, _put_together,
              _dummy_len, NOT c_is_corr_column, _convert_t, dunknown);
        END;
    (*ENDIF*) 
    d_cntpar        := _m_cntpar;
&   ifdef trace
    t01int4 (ak_sem, 'd_cntpar:=mc', d_cntpar);
&   endif
    d_use_order     := _muse_order;
    d_outcolno      := _md_outcolno;
    d_change.cr_colcount := _md_colcount;
    IF  _md_colcount > 0
    THEN
        d_change.cr_columns[ _md_colcount ].ch_length := _md_changecollen;
    (*ENDIF*) 
    WITH acv.a_mblock, mb_qual^ DO
        mb_st^ [mqual_pos].epos := mqual_cnt + 1;
    (*ENDWITH*) 
    IF  (NOT d_single AND NOT d_subquery) AND
        (acv.a_intern_select_cnt = acv.a_max_intern_select)
        OR acv.a_from_select
    THEN
        BEGIN
        a061sort (acv, d_esparr.pbasep^.sbase,
              d_exprno, _double_col, _double_col_name);
        IF  ((d_pos_result > 0) AND (d_pos_result <= cak_maxresulttables))
        THEN
            acv.a_resname_addr[ d_pos_result ]^.sresname.resmaxlinkage := 1
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (_double_col AND (acv.a_fromsel_n > 0))
    THEN
        a07_nb_put_error (acv, e_duplicate_columnname,
              acv.a_ap_tree^[ curr_n ].n_pos, _double_col_name);
    (* double_col will not come except for join-views *)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61upd_dtype_node (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info;
            VAR colinf : tak00_columninfo;
            fieldno    : integer);
 
VAR
      _dtype_n    : integer; (* Current datatype node. *)
      _curr_index : integer; (* Index of dtype_n.      *)
 
BEGIN
IF  dmli.d_act_node <> 0
THEN
    WITH colinf, acv.a_ap_tree^[ dmli.d_act_node ] DO
        IF  (n_proc = a63query_spec) AND (n_sa_level <> 0)
        THEN      (* We must store the new length in n_length of    *)
            BEGIN (* the corresponding ('fieldno'th) datatype node. *)
            IF  fieldno = MAX_COL_PER_TAB_GG00
            THEN      (* We don't know the current position in node *)
                BEGIN (* list, so we set it to <list_length>, if we *)
                (*       have not a corelated subquery (we are just *)
                (*       constructing the list), otherwise to       *)
                (*       <list_length-dmli.d_cntpar>                *)
                _dtype_n    := acv.a_ap_tree^[ dmli.d_act_node ].n_sa_level;
                _curr_index := 0;
                WHILE _dtype_n <> 0 DO
                    BEGIN
                    _dtype_n    := acv.a_ap_tree^[ _dtype_n ].n_sa_level;
                    _curr_index := succ (_curr_index)
                    END;
                (*ENDWHILE*) 
                IF  acv.a_corr_select
                THEN
                    fieldno := _curr_index - dmli.d_cntpar
                ELSE
                    fieldno := _curr_index
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            _dtype_n    := acv.a_ap_tree^[ dmli.d_act_node ].n_sa_level;
            _curr_index := 1;
            WHILE (acv.a_ap_tree^[ _dtype_n ].n_sa_level <> 0) AND
                  (_curr_index < fieldno) DO
                BEGIN
                _dtype_n    := acv.a_ap_tree^[ _dtype_n ].n_sa_level;
                _curr_index := succ (_curr_index)
                END;
            (*ENDWHILE*) 
            acv.a_ap_tree^[ _dtype_n ].n_length := cinoutlen;
&           ifdef trace
            t01int4 (ak_sem, 'fieldno     ', fieldno);
            t01int4 (ak_sem, 'd_cntpar    ', dmli.d_cntpar);
            t01int4 (ak_sem, 'changed_len ', cinoutlen);
            t01int4 (ak_sem, 'dtype_n     ', _dtype_n);
&           endif
            END
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a61_var_col_stackentry (
            VAR acv          : tak_all_command_glob;
            VAR dmli         : tak_dml_info;
            VAR colinf       : tak00_columninfo;
            may_be_together  : boolean;
            VAR put_together : boolean;
            VAR output_len   : integer;
            (* PTS 1001088 E.Z. *)
            is_corr_column   : boolean;
            convert_t        : tak_convert_type;
            convert_type     : tsp00_DataType);
 
VAR
      _expr_col_found       : boolean;
      _change_union_types   : boolean;
      _long_column_found    : boolean;
      _newlong_column_found : boolean;
      _oflw_op              : tgg00_StackOpOutput;
      _add                  : integer;
      _codewidth            : integer;
      _hmfirst_free         : integer;
      _index                : integer;
      _columnstackindex     : integer;  (* PTS 1116474 E.Z. *)
      _i                    : tsp00_Int2;
      _pred_node            : tsp00_Int2;
      _ccolin               : tak00_scolinf;
      _startstack           : integer;
      _stst                 : integer;
      _num_change_set       : tak_number_changetype_set;
 
BEGIN
WITH acv.a_mblock, mb_qual^, colinf DO
    IF  acv.a_returncode = 0
    THEN
        BEGIN
&       ifdef TRACE
        t01int4 (ak_sem, 'may_be_toget', ord(may_be_together));
&       endif
        put_together      := false;
        _add               := 0;
        _index             := mfirst_free - 1;
        _expr_col_found    := false;
        (* PTS 1106508 E.Z. *)
        _long_column_found :=
              (cdatatyp in [ dstra, dstrb, dstruni ]);
        _newlong_column_found :=
              (cdatatyp in [ dlonga, dlongb, dlonguni ]);
        IF  _index + 2 > mb_st_max
        THEN
            a07_b_put_error (acv, e_too_many_mb_stackentries, -mb_st_max)
        ELSE
            BEGIN
&           ifdef trace
            t01stackentry (ak_sem, ccolstack, 1);
&           endif
            _num_change_set := [];
            (* PTS 1116474 E.Z. *)
            _columnstackindex := 0;
            IF  (ccolstack.elen_var > 0) AND
                (ccolstack.etype <> st_func)
            THEN
                BEGIN
                _columnstackindex := _index + 1;
                mb_st^ [_index + 1] := ccolstack;
                mb_st^ [_index + 1].ecol_tab [2] :=
                      chr(dmli.d_tabarr^[ dmli.d_acttabindex ].ocounttabs +
                      ctabno)
                END
            ELSE
                BEGIN
                IF  ccolstack.elen_var > 0
                THEN
                    BEGIN
                    a61get_column_expression (acv, dmli, colinf, dmli.d_vppos);
                    IF  ccolstack.eop_func in [ op_f_sum, op_f_avg ]
                    THEN
                        BEGIN
                        _index := mfirst_free - 1;
                        IF  mb_st^ [_index].etype <> st_func
                        THEN
                            dmli.d_allowed := tabs_with_arith;
                        (*ENDIF*) 
                        WHILE ((_index > 1) AND (acv.a_mblock.mb_st^ [_index].etype <> st_func)) DO
                            _index := pred(_index);
                        (*ENDWHILE*) 
                        _i := _index - 1;
                        WHILE ((_i > 1) AND (acv.a_mblock.mb_st^ [_i].etype <> st_func)) DO
                            _i := pred(_i);
                        (*ENDWHILE*) 
                        acv.a_mblock.mb_st^ [_index].epos := _index - _i;
                        END;
                    (*ENDIF*) 
                    _expr_col_found := true;
                    IF  cdatatyp in [ dfloat, dfixed, dvfloat ]
                    THEN
                        dmli.d_datatype := dnumber
                    ELSE
                        dmli.d_datatype := dunknown;
                    (*ENDIF*) 
                    _index := mfirst_free - 1;
                    END;
                (* op_fixed and op_f_max have the same ord-value ! *)
                (*ENDIF*) 
                IF  (cdatatyp in [ dfloat, dfixed, dvfloat ])           AND
                    (mb_st^ [_index].etype <> st_result)                AND
                    (mb_st^ [_index].etype <> st_sum_length)            AND
                    (
                    ( mb_st^ [_index].etype <> st_build_in_func)      OR
                    ((mb_st^ [_index].etype =  st_build_in_func)   AND
                    ( mb_st^ [_index].eop_build_in <> op_b_decode) AND
                    ( mb_st^ [_index].eop_build_in <> op_b_datetime))
                    )                                                   AND
                    (
                    ( mb_st^ [_index].etype <> st_func)               OR
                    ((mb_st^ [_index].etype =  st_func)            AND
                    ( mb_st^ [_index].eop_func in [op_f_min, op_f_max]))
                    )
                THEN
                    IF  (NOT (
                        (mb_st^ [_index].etype = st_func) OR
                        (mb_st^ [_index].etype = st_build_in_func)
                        ))
                        AND
                        (
                        (mb_st^ [_index].eop = op_fixed) OR
                        (mb_st^ [_index].eop = op_days)
                        )
                    THEN
                        BEGIN
                        dmli.d_datatype := dunknown;
                        _index      := pred(_index)
                        END
                    ELSE
                        IF  mb_st^ [_index].etype = st_noround
                        THEN
                            WITH mb_st^ [_index] DO
                                BEGIN
                                epos          := cdatalen;
                                elen_var      := cdatafrac - cak_frac_offset;
                                _index := pred(_index)
                                END
                            (*ENDWITH*) 
                        ELSE
                            WITH mb_st^ [_index + 1] DO
                                BEGIN
                                etype         := st_result;
                                eop           := op_none;
                                epos          := cdatalen;
                                elen_var      := cdatafrac - cak_frac_offset;
                                ecol_tab[ 1 ] := chr(0);
                                ecol_tab[ 2 ] := chr(0)
                                END
                            (*ENDWITH*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                ELSE
                    BEGIN
                    dmli.d_datatype := dunknown;
                    _index      := pred(_index)
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
&           IFDEF TRACE
            t01int4 (ak_sem, 'convert_type', ord(convert_type));
            t01int4 (ak_sem, 'convert_t   ', ord(convert_t));
            t01int4 (ak_sem, 'cdatatyp    ', ord(cdatatyp));
            t01int4 (ak_sem, 'd_datatype  ', ord(dmli.d_datatype));
            t01int4 (ak_sem, 'd_subquery  ', ord(dmli.d_subquery));
            t01int4 (ak_sem, 'd_use_sub   ', ord(dmli.d_use_sub));
            t01int4 (ak_sem, 'cdatalen    ', cdatalen);
            t01int4 (ak_sem, 'reclen      ', mb_data^.mbp_reclen);
            t01int4 (ak_sem, 'datalen     ', mb_data_len);
            t01int4 (ak_sem, 'd_inoutpos  ', dmli.d_inoutpos);
&           ENDIF
            IF  (cdatatyp in [ ddate, dtime, dtimestamp ]) AND
                dmli.d_subquery         AND
                (* PTS 1001088 E.Z. *)
                NOT is_corr_column AND
                NOT dmli.d_view         AND
                NOT acv.a_outer_join    AND
                (acv.a_union_cnt = 0)
                (* PTS 1123040 E.Z. *)
            THEN
                BEGIN
                _pred_node := a660pos_pred (acv, acv.a_select_node);
                IF  (NOT acv.a_insert_select )
                    OR
                    (acv.a_insert_select               AND
                    (dmli.d_subcount <> 0)             AND      (* not the upper select *)
                    ((dmli.d_subcount DIV cak_maxsubcnt_per_level <> 1) OR
                    ( acv.a_ap_tree^[_pred_node].n_symb <> s_select)))
                THEN
                    BEGIN
                    _startstack := _index + 2;
                    _stst       := _startstack;
                    a65ch_format (acv, dmli, _startstack , _ccolin,
                          dunknown, cdatatyp);
                    _expr_col_found := true;
                    cinoutlen      := succ (_ccolin.sci_len);
                    ak61upd_dtype_node (acv, dmli, colinf, MAX_COL_PER_TAB_GG00);
                    IF  (_startstack - _stst) > 0
                    THEN
                        _index := _index + _startstack - _stst;
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  (dmli.d_union OR
                (acv.a_recursive_state in
                [ rs_first_select, rs_recursive_select ]))     AND
                NOT (cdatatyp in [ ddate, dtime, dtimestamp ]) AND
                (convert_type in [ ddate, dtime, dtimestamp ])
            THEN
                BEGIN
                IF  acv.a_dt_format <> dtf_normal
                THEN
                    BEGIN
                    _index    := succ (_index);
                    a61_format_change (acv, dmli, _index + 1, convert_type, _i);
                    (* PTS 1001092 E.Z. *)
                    IF  (acv.a_dt_format = dtf_oracle_date) AND
                        (convert_type = dtimestamp)
                    THEN
                        _index := _index + 2;
                    (*ENDIF*) 
                    END;
&               ifdef TRACE
                (*ENDIF*) 
                t01int4 (ak_sem, 'datalen     ', colinf.cdatalen);
                t01int4  (ak_sem, 'cinoutlen u!', colinf.cinoutlen);
&               endif
                convert_type   := cdatatyp;
                _expr_col_found := true;
                END;
            (*ENDIF*) 
            IF  convert_t <> conv_none
            THEN
                BEGIN
                (* PTS 1113800 E.Z. new: codewidth *)
                IF  (dmli.d_view OR
                    (acv.a_intern_select_cnt < acv.a_max_intern_select))
                THEN
                    _codewidth := 1
                ELSE
                    _codewidth := acv.a_max_codewidth;
                (*ENDIF*) 
                WITH colinf DO
                    CASE convert_t OF
                        conv_ascii_to_unicode :
                            BEGIN
                            cdatatyp  := dunicode;
                            cinoutlen := (2*cdatalen) + 1
                            END;
                        conv_unicode_to_ascii :
                            BEGIN
                            cdatatyp := dcha;
                            cinoutlen := cdatalen * _codewidth + 1
                            END;
                        (* PTS 1000985/1001162 E.Z. *)
                        conv_ascii_to_num,
                        conv_unicode_to_num :
                            BEGIN
                            cdatatyp := dfloat;
                            cdatalen := csp_fixed;
                            cdatafrac := csp_float_frac;
                            cinoutlen := succ(mxsp_number)
                            END;
                        conv_num_to_ascii,
                        conv_num_to_unicode :
                            BEGIN
                            IF  cdatatyp in [ dfloat, dvfloat ]
                            THEN
                                IF  (cdatalen = 1)
                                THEN
                                    cdatalen := 6
                                ELSE
                                    cdatalen := cdatalen + 6
                                (*ENDIF*) 
                            ELSE
                                IF  cdatatyp = dfixed
                                THEN
                                    IF  (cdatalen = cdatafrac)
                                    THEN
                                        cdatalen := cdatalen + 3
                                    ELSE
                                        IF  (cdatafrac <> 0)
                                        THEN
                                            cdatalen := cdatalen + 2
                                        ELSE
                                            cdatalen := succ (cdatalen);
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                (*ENDIF*) 
                            (*ENDIF*) 
                            IF  convert_t = conv_num_to_unicode
                            THEN
                                BEGIN
                                cdatatyp := dunicode;
                                cinoutlen := 2 * cdatalen + 1
                                END
                            ELSE
                                BEGIN
                                cinoutlen := succ(cdatalen);
                                cdatatyp := dcha
                                END
                            (*ENDIF*) 
                            END;
                        OTHERWISE
                            BEGIN
                            END
                        END;
                    (*ENDCASE*) 
                (*ENDWITH*) 
                IF  (acv.a_out_packet^.sp1_header.sp1h_mess_code in
                    [ csp_unicode_swap, csp_unicode ])
                    (* PTS 1113800 E.Z. *)
                    AND
                    NOT dmli.d_view
                    AND
                    (acv.a_intern_select_cnt = acv.a_max_intern_select)
                    AND
                    (acv.a_qualified_jv_upd = no_jv_upd)
                    AND
                    (cdatatyp = dcha)
                    AND
                    NOT acv.a_ascii_in_and_output (* new feature *)
                THEN
                    colinf.cinoutlen := succ(2*colinf.cdatalen);
                (*ENDIF*) 
                _hmfirst_free := mfirst_free;
                mfirst_free  := _index + 2;
                a65_convert (acv, convert_t, colinf.cinoutlen);
                mfirst_free := _hmfirst_free + mfirst_free - _index - 2;
                _index       := _index + mfirst_free - _hmfirst_free;
                _expr_col_found := true;
                END;
&           ifdef TRACE
            (*ENDIF*) 
            t01messblock (ak_sem, 'var_col_st 1', acv.a_mblock);
            t01int4 (ak_sem, 'datalen     ', colinf.cdatalen);
            t01int4  (ak_sem, 'cinoutlen   ', colinf.cinoutlen);
            t01int4 (ak_sem, 'ecol_tab[1] ', ord(colinf.ccolstack.ecol_tab[ 1 ]));
&           endif
            IF  (_long_column_found OR _newlong_column_found) AND
                (* PTS 1106508 E.Z. *)
                (NOT (dmli.d_view) OR (dmli.d_phase_cnt >= 4))   AND
                (* PTS 1105795 M.Ki. *)
                NOT ((acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc
                = cak_x_insert_select) AND dmli.d_pseudo_ins_select)    AND
                (dmli.d_sparr.pbasep^.sbase.btablekind <> tresult)      AND
                (NOT dmli.d_subquery)
            THEN
                IF  (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc
                    <> cak_x_insert_select) OR
                    dmli.d_pseudo_ins_select
                THEN
                    (* PTS 1116474 E.Z. *)
                    IF  dmli.d_sparr.pbasep^.sbase.btablekind = tcomplexview
                    THEN
                        BEGIN
                        colinf.cdatalen  := mxsp_long_desc;
                        colinf.cinoutlen := succ(colinf.cdatalen);
                        colinf.ccolstack.elen_var          := colinf.cinoutlen;
                        mb_st^ [_columnstackindex].elen_var := colinf.cinoutlen;
                        END
                    ELSE
                        ak61long_desc_st_entries (acv, dmli, colinf, _index)
                    (*ENDIF*) 
                ELSE (* PTS 1105795 M.Ki. *)
                    (* PTS 1116474 E.Z. *)
                    IF  dmli.d_sparr.pbasep^.sbase.btablekind = tcomplexview
                    THEN
                        BEGIN
                        colinf.cdatalen  := 2 * SURROGATE_MXGG00;
                        colinf.cinoutlen := succ(colinf.cdatalen);
                        colinf.ccolstack.elen_var          := colinf.cinoutlen;
                        mb_st^ [_columnstackindex].elen_var := colinf.cinoutlen;
                        END
                    ELSE
                        BEGIN
                        IF  (ccolstack.elen_var = 0 (* value, no column *)
                            ) AND
                            (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc
                            = cak_x_insert_select)
                        THEN
                            BEGIN
                            a07_b_put_error (acv, e_command_for_string_not_allow, dmli.d_vppos);
                            mqual_cnt   := pred(mqual_cnt);
                            mfirst_free := pred(mfirst_free);
                            END
                        ELSE
                            ak61long_ins_sel_st_entries (acv, dmli, _index);
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
&           ifdef TRACE
            (*ENDIF*) 
            t01messblock (ak_sem, 'var_col_st 2', acv.a_mblock);
&           endif
            WITH mb_st^ [_index + 2] DO
                BEGIN
                etype   := st_output;
                (* PTS 1000985/1001162 E.Z. *)
                WITH dmli.d_sparr.pbasep^.sbase DO
                    BEGIN
                    _oflw_op    := op_o_none;
                    (* PTS 1111576 E.Z. *)
                    IF  btablekind in [ tonebase, tview, tresult,
                        tcomplexview  ]
                    THEN
                        IF  acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].
                            n_proc in [ a62, a63, a16 ]
                        THEN
                            _oflw_op := op_o_output_oflw;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                eop_out := _oflw_op;
                epos  := dmli.d_inoutpos + _add;
                IF  ((mb_st^ [_index + 1].etype = st_func)
                    AND
                    ((mb_st^ [_index + 1].eop_func = op_f_count) OR
                    (mb_st^ [_index + 1].eop_func = op_f_dis_count))
                    AND
                    (NOT dmli.d_union))
                THEN
                    elen_var := mb_st^ [_index + 1].elen_var
                ELSE
                    elen_var := cinoutlen;
                (*ENDIF*) 
                ecol_pos := 0;
                IF  dmli.d_union AND (NOT dmli.d_first_union)
                THEN
                    _change_union_types := (acv.a_union_cnt = 1)
                ELSE
                    _change_union_types := false;
                (*ENDIF*) 
&               IFDEF TRACE
                t01bool (ak_sem, 'a61_fill 2  ', _change_union_types);
                t01bool (ak_sem, 'd_first_unio', dmli.d_first_union);
                t01bool (ak_sem, 'd_union     ', dmli.d_union);
                t01int4 (ak_sem, 'acv_unioncnt', acv.a_union_cnt);
&               ENDIF
                output_len := 0;
                IF  mb_st^ [_index + 1].etype = st_func
                THEN
                    BEGIN
                    _add := 0;
                    CASE  mb_st^ [_index + 1].eop_func OF
                        op_f_min, op_f_max :
                            BEGIN
                            _add := 0;
                            output_len := elen_var
                            END;
                        op_f_count, op_f_dis_count :
                            IF  elen_var >= mxsp_resnum
                            THEN
                                BEGIN
                                output_len := elen_var;
                                IF  dmli.d_union
                                THEN
                                    cinoutlen := elen_var;
                                (*ENDIF*) 
                                IF  ((acv.a_mblock.mb_type <> m_insert_select) AND
                                    (dmli.d_single AND (acv.a_ex_kind = only_parsing)))
                                THEN
                                    acv.a_output_data_pos := acv.a_output_data_pos +
                                          elen_var - mxsp_resnum;
                                (*ENDIF*) 
                                END
                            ELSE
                                BEGIN
                                _add := mxsp_resnum - elen_var;
                                output_len := mxsp_resnum
                                END;
                            (*ENDIF*) 
                        op_f_sum, op_f_dis_sum :
                            BEGIN
                            END;
                        op_f_avg, op_f_dis_avg :
                            BEGIN
                            IF  NOT dmli.d_union
                            THEN
                                _add := mxsp_resnum;
                            (*ENDIF*) 
                            output_len := NUMBER_MXGG04+mxsp_resnum;
                            IF  dmli.d_optimize_setfunction
                            THEN
                                _num_change_set := _num_change_set +
                                      [ nch_div_by_count ]
                            ELSE
                                mb_st^ [_index + 1].ecol_tab[1] := chr(true);
                            (*ENDIF*) 
                            END;
                        op_f_stddev, op_f_dis_stddev,
                        op_f_variance, op_f_dis_variance  :
                            BEGIN
                            IF  NOT dmli.d_union
                            THEN
                                _add := mxsp_resnum;
                            (*ENDIF*) 
                            output_len := NUMBER_MXGG04+mxsp_resnum;
                            END;
                        OTHERWISE
                            BEGIN
                            END;
                        END;
                    (*ENDCASE*) 
                    IF  ((acv.a_mblock.mb_type <> m_insert_select) AND
                        (dmli.d_single AND (acv.a_ex_kind = only_parsing)))
                    THEN
                        acv.a_output_data_pos := acv.a_output_data_pos + _add;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  (
                    (cdatatyp in [ ddate, dtime, dtimestamp, dunicode,
                    dlonga, dlongb, dlonguni,
                    dstra, dstrb, dstruni ])
                    OR
                    ((acv.a_out_packet^.sp1_header.sp1h_mess_code in
                    [ csp_unicode_swap, csp_unicode ]) AND
                    (cdatatyp in [ dcha, dvarchara ]))
                    OR
                    _long_column_found
                    OR
                    _newlong_column_found
                    OR
                    (_num_change_set <> [])
                    )
                    AND NOT dmli.d_subquery
                    (* PTS 1103004 E.Z. *)
                    AND NOT acv.a_insert_select
                    AND ((acv.a_union_cnt = 0) OR _change_union_types)
                    AND (acv.a_intern_select_cnt = acv.a_max_intern_select)
                THEN
                    ak61fill_change_info (acv, dmli, colinf, _num_change_set);
                (*ENDIF*) 
                dmli.d_inoutpos := dmli.d_inoutpos + elen_var + _add;
&               ifdef TRACE
                t01int4 (ak_sem, 'd_inoutpos 2', dmli.d_inoutpos);
                t01int4 (ak_sem, '     add    ',       _add);
                t01int4 (ak_sem, 'cdatalen    ', cdatalen);
                t01int4 (ak_sem, 'output_len  ', output_len);
&               endif
                IF  (dmli.d_inoutpos > MAX_RECLEN_GG00+1) AND
                    (mb_st^ [_index+2].etype <> st_output_catalog)
                THEN
                    IF  dmli.d_reuse                                      OR
                        (dmli.d_cntfromtab > 1)                           OR
                        dmli.d_subquery                                   OR
                        dmli.d_union                                      OR
                        (acv.a_union_cnt > 0)                             OR
                        acv.a_insert_select                               OR
                        (acv.a_recursive_state <> rs_no_recursive_select) OR
                        (dmli.d_corr <> no_correlation)                   OR
                        (acv.a_mblock.mb_type2 = mm_with_functions)       OR
                        (acv.a_max_intern_select > 0)                     OR
                        (acv.a_mblock.mb_type = m_show)
                    THEN
                        a07_b_put_error (acv,
                              e_output_columns_too_long, dmli.d_vppos)
                    ELSE
                        IF  dmli.d_inoutpos > MAX_INT2_SP00
                        THEN
                            a07_b_put_error (acv,
                                  e_output_columns_too_long, dmli.d_vppos);
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  acv.a_returncode = 0
                THEN
                    BEGIN
                    (* PTS 1107681 E.Z. *)
&                   IFDEF TRACE
                    t01int4 (ak_sem, 'cdatatyp 61 ', ord (cdatatyp));
&                   ENDIF
                    ecol_pos := 0;
                    mfirst_free := _index+3;
                    mqual_cnt   := mfirst_free - mqual_pos;
                    END;
                (*ENDIF*) 
                END
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
&       ifdef TRACE
        t01bool (ak_sem, 'put_together', put_together);
&       endif
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a61get_column_expression (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info;
            VAR colinf : tak00_columninfo;
            errpos     : integer);
 
VAR
      _b_err         : tgg00_BasisError;
      _first_data    : boolean;
      _intern_func   : boolean;
      _aux_len       : integer;
      _i             : integer;
      _move_len      : integer;
      _rest_len      : integer;
      _firstdataoffs : integer;
      _tab_offset    : integer;
      _start         : integer;
      _read_idx      : integer;
      _rel_pos       : integer;
      _exprbuf       : tak_sysbufferaddress;
      _colname       : tsp00_KnlIdentifier;
      _exprkey       : tgg00_SysInfoKey;
 
BEGIN
&ifdef trace
t01buf1( ak_sem, colinf.ccolumnn, 1, ord( colinf.ccolumnn_len ) );
t01int4 (ak_sem, 'ocounttabs  ',
      dmli.d_tabarr^[ dmli.d_acttabindex ].ocounttabs );
&endif
_tab_offset := dmli.d_tabarr^[ dmli.d_acttabindex ].ocounttabs;
IF  (( dmli.d_wherepart OR dmli.d_is_function_column OR
    ( dmli.d_cntfromtab > 1 ) ) AND
    ( colinf.ccolstack.eop_func in [ op_f_sum, op_f_avg ] ))
THEN
    BEGIN
    a061get_colname (colinf, _colname);
    a07_nb_put_error (acv, e_invalid_view_column, errpos, _colname);
    END
ELSE
    IF  acv.a_mblock.mb_qual^.mfirst_free + colinf.ccolstack.elen_var -
        colinf.ccolstack.epos > acv.a_mblock.mb_st_max
    THEN
        a07_b_put_error (acv, e_too_many_mb_stackentries,
              -acv.a_mblock.mb_st_max)
    ELSE
        BEGIN
        IF  (( colinf.ccolstack.eop_func in [ op_f_sum, op_f_avg ] ) AND
            ( acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_proc
            in [ a63, a56 ] ))
        THEN
            acv.a_mblock.mb_type2 := mm_with_functions;
        (*ENDIF*) 
        _exprkey           := a01sysnullkey;
        _exprkey.stableid  := dmli.d_tabarr^[ dmli.d_acttabindex ].ofromtableid;
        _exprkey.sentrytyp := cak_eviewqual_expcol;
        _exprkey.slinkage[ 2 ] := colinf.ccolstack.ecol_tab[ 1 ];
        a10get_sysinfo (acv, _exprkey, d_release, _exprbuf, _b_err);
        IF  _b_err <> e_ok
        THEN
            a07_b_put_error (acv, _b_err, 1)
        ELSE
            WITH acv.a_mblock, mb_qual^ DO
                BEGIN
                _move_len    := 0;
                _first_data  := true;
                _intern_func := false;
                _start       := mfirst_free;
                _read_idx    := colinf.ccolstack.epos;
&               ifdef trace
                t01int4( ak_sem, 'epos        ', colinf.ccolstack.epos );
                t01int4( ak_sem, 'elen_var    ', colinf.ccolstack.elen_var );
&               endif
                FOR _i := colinf.ccolstack.epos TO colinf.ccolstack.epos +
                      ( colinf.ccolstack.elen_var - 1 ) DO
                    BEGIN
                    IF  _read_idx > cak_max_viewqual_stack
                    THEN
                        (* record overflow handling *)
                        BEGIN
                        a06inc_linkage( _exprkey.slinkage );
                        a10get_sysinfo( acv, _exprkey, d_release,
                              _exprbuf, _b_err );
                        _read_idx := 1;
                        END;
                    (*ENDIF*) 
                    IF  _b_err = e_ok
                    THEN
                        BEGIN
                        mb_st^[ mfirst_free ] := _exprbuf^.sviewqual_stack.
                              vstack[ _read_idx ];
                        IF  ( mb_st^[ mfirst_free ].etype in
                            [ st_value, st_language, st_format,
                            st_date, st_time, st_timestamp,
                            (* PTS 1116175 E.Z. *)
                            st_utcdate,
                            (* PTS 1109925 E.Z. *)
                            st_utcdiff,
                            st_user, st_usergroup, st_current_schema, st_uid,
                            st_sysdba, st_localsysdba, st_transaction,
                            st_timezone (* PTS 1122262 E.Z. *)
                            ] )
                        THEN
                            BEGIN
                            IF  NOT dmli.d_view AND
                                ( mb_st^[ mfirst_free ].etype <> st_value )
                            THEN
                                _intern_func := true;
                            (*ENDIF*) 
                            IF  _first_data
                            THEN
                                BEGIN
                                _firstdataoffs := mb_st^[ mfirst_free ].epos;
&                               ifdef trace
                                t01int4( ak_sem, '_firstdataof',
                                      _firstdataoffs );
&                               endif
                                _first_data   := false;
                                IF  ( _exprbuf^.sviewqual_stack.vdatapos = 0 ) OR
                                    ( _exprbuf^.sviewqual_stack.vdatalen = 0 )
                                THEN
                                    a07ak_system_error( acv, 61, 1 );
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            ;
                            (* calculate relative position to first data *)
                            mb_st^[ mfirst_free ].epos :=
                                  mb_st^[ mfirst_free ].epos + mb_data_len + 1
                                  - _firstdataoffs;
                            _move_len := _move_len +
                                  mb_st^[ mfirst_free ].elen_var;
                            END
                        ELSE
                            IF  mb_st^[ mfirst_free ].etype in
                                [ st_fixkey, st_varkey,
                                st_fixcol, st_varcol,
                                st_varlongchar ]
                            THEN
                                mb_st^[ mfirst_free ].ecol_tab[ 2 ] :=
                                      chr( ord( mb_st^[ mfirst_free ].
                                      ecol_tab[ 2 ] ) + _tab_offset );
&                           ifdef trace
                            (*ENDIF*) 
                        (*ENDIF*) 
                        t01stackentry( ak_sem, mb_st^[ mfirst_free ], mfirst_free );
&                       endif
                        mfirst_free := succ( mfirst_free );
                        mqual_cnt   := succ( mqual_cnt );
                        _read_idx   := succ( _read_idx );
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDFOR*) 
                IF  _move_len > 0
                THEN
                    IF  mb_data_len + _move_len > mb_data_size
                    THEN
                        a07_b_put_error( acv, e_too_many_mb_data, 1 )
                    ELSE
                        BEGIN
                        (* get catalog record with data for expressions *)
                        _rel_pos := _exprbuf^.sviewqual_stack.vdatapos +
                              _firstdataoffs;
                        _exprkey.slinkage := cak_init_linkage;
&                       ifdef trace
                        t01int4( ak_sem, 'data length ', _move_len );
                        t01int4( ak_sem, 'vdatapos    ',
                              _exprbuf^.sviewqual_stack.vdatapos );
                        t01int4( ak_sem, '_rel_pos    ', _rel_pos );
&                       endif
                        WHILE _rel_pos > cak_max_viewqual_data DO
                            BEGIN
                            a06inc_linkage( _exprkey.slinkage );
                            _rel_pos := _rel_pos - cak_max_viewqual_data;
                            END;
                        (*ENDWHILE*) 
                        a10get_sysinfo( acv, _exprkey, d_release,
                              _exprbuf, _b_err );
                        _rest_len := _move_len;
                        WHILE ( _rest_len > 0 ) AND ( _b_err = e_ok ) DO
                            BEGIN
                            IF  _rest_len >
                                sizeof( _exprbuf^.sviewqual_stack.vdata ) -
                                ( _rel_pos - 1 )
                            THEN
                                _move_len   :=
                                      sizeof( _exprbuf^.sviewqual_stack.vdata ) -
                                      ( _rel_pos - 1 )
                            ELSE
                                _move_len := _rest_len;
                            (*ENDIF*) 
&                           ifdef trace
                            t01int4( ak_sem, '_rest_len   ', _rest_len );
                            t01int4( ak_sem, '_rel_pos    ', _rel_pos );
                            t01int4( ak_sem, '_move_len   ', _move_len );
&                           endif
                            SAPDB_PascalMove ('VAK61 ',   7,    
                                  sizeof( _exprbuf^.sviewqual_stack.vdata ),
                                  mb_data_size,
                                  @_exprbuf^.sviewqual_stack.vdata, _rel_pos,
                                  @mb_data^.mbp_buf, mb_data_len + 1,
                                  _move_len, _b_err );
&                           ifdef trace
                            t01moveobj( ak_sem, mb_data^.mbp_buf,
                                  mb_data_len + 1, mb_data_len + 1 +
                                  ( _move_len - 1 ) );
&                           endif
                            mb_data_len := mb_data_len + _move_len;
                            _rest_len   := _rest_len - _move_len;
                            IF  _rest_len > 0
                            THEN
                                (* record overflow handling *)
                                BEGIN
                                _rel_pos := 1;
                                a06inc_linkage( _exprkey.slinkage );
                                a10get_sysinfo( acv, _exprkey, d_release,
                                      _exprbuf, _b_err );
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDWHILE*) 
                        IF  _b_err <> e_ok
                        THEN
                            a07_b_put_error( acv, _b_err, 1 )
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  ( _intern_func AND
                    ( acv.a_returncode = 0 ) )
                THEN
                    FOR _i := _start TO mfirst_free - 1 DO
                        IF  ( mb_st^[ _i ].etype in
                            [ st_format, st_language,
                            st_date, st_time, st_timestamp,
                            (* PTS 1116175 E.Z. *)
                            st_utcdate,
                            (* PTS 1109925 E.Z. *)
                            st_utcdiff,
                            st_user, st_usergroup,
                            st_current_schema, st_uid,
                            st_sysdba, st_localsysdba,
                            st_transaction,
                            st_timezone (* PTS 1122262 E.Z. *)
                            ] )
                        THEN
                            IF  (( acv.a_cmd_segment_header.sp1c_mess_type = sp1m_parse ) AND
                                (
                                (* PTS 1122262 E.Z. *)
                                ( mb_st^[ _i ].etype = st_date )       OR
                                ( mb_st^[ _i ].etype = st_time )       OR
                                ( mb_st^[ _i ].etype = st_timestamp)   OR
                                ( mb_st^[ _i ].etype = st_utcdate )    OR
                                ( mb_st^[ _i ].etype = st_utcdiff )    OR
                                ( mb_st^[ _i ].etype = st_transaction) OR
                                ( mb_st^[ _i ].etype = st_timezone)    OR
                                ( mb_st^[ _i ].etype = st_current_schema)
                                ))
                            THEN (* PTS 1117563 *)
                                BEGIN
                                _aux_len := acv.a_mblock.mb_data_len;
                                acv.a_mblock.mb_data_len := mb_st^[ _i ].epos - 1;
                                a54_fixedpos( acv, dmli );
                                acv.a_mblock.mb_data^.mbp_buf [mb_st^[ _i ].epos] :=
                                      csp_default_byte;
                                acv.a_mblock.mb_data_len := _aux_len;
                                a54datetime_parsinfo( acv, dmli, _i );
                                END
                            ELSE
                                a54_internal_function( acv, acv.a_mblock, _i );
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDFOR*) 
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61_upd_union_column (
            VAR acv      : tak_all_command_glob;
            st_pos       : tsp00_Int2;
            VAR inoutlen : tsp00_Int2);
 
VAR
      _i           : integer;
      _oldi        : integer;
 
BEGIN
WITH acv.a_mblock.mb_st^ [st_pos] DO
    BEGIN
&   ifdef trace
    t01messblock (ak_sem, 'upd_union   ', acv.a_mblock);
    t01int4 (ak_sem, 'mfirst_free ', acv.a_mblock.mb_qual^.mfirst_free);
    t01stackentry (ak_sem, acv.a_mblock.mb_st^[st_pos], st_pos);
&   endif
    _i := pred (acv.a_mblock.mb_qual^.mfirst_free);
    _oldi := 1;
    WHILE (_i > acv.a_mblock.mb_qual^.mqual_pos) DO
        BEGIN
        IF  _oldi = _i
        THEN
            _i := 0
        ELSE
            BEGIN
            _oldi := _i;
            IF  (acv.a_mblock.mb_st^ [_i].etype         = etype)    AND
                (acv.a_mblock.mb_st^ [_i].epos          = epos)     AND
                (acv.a_mblock.mb_st^ [_i].elen_var      = elen_var) AND
                (acv.a_mblock.mb_st^ [_i].ecol_tab[ 2 ] = ecol_tab [2])
            THEN
                BEGIN
                _i := succ (_i);
                WHILE (_i             <  st_pos) AND
                      (acv.a_mblock.mb_st^ [_i].etype <> st_output) DO
                    _i := succ (_i);
                (*ENDWHILE*) 
&               ifdef trace
                t01stackentry (ak_sem, acv.a_mblock.mb_st^[_i], _i);
&               endif
                IF  (acv.a_mblock.mb_st^ [_i].etype = st_output)
                THEN
                    BEGIN
                    IF  (acv.a_mblock.mb_st^ [_i].elen_var > elen_var)
                    THEN
                        inoutlen := acv.a_mblock.mb_st^ [_i].elen_var;
                    (*ENDIF*) 
                    _i := 0; (* exit while *)
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            _i := pred (_i);
            END
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak61get_long_tabid (
            VAR acv   : tak_all_command_glob;
            VAR dmli  : tak_dml_info;
            tabno     : integer;
            VAR ltabid : tgg00_Surrogate);
 
VAR
      _e         : tgg00_BasisError;
      _viewp     : tak_sysbufferaddress;
      _ke        : tgg00_SysInfoKey;
 
BEGIN
_ke           := a01defaultkey;
_ke.stableid  := dmli.d_tabarr^[ dmli.d_acttabindex ].ofromtableid;
_ke.sentrytyp := cak_eviewqual_basis;
a10get_sysinfo (acv, _ke, d_fix, _viewp, _e);
IF  _e = e_ok
THEN
    WITH _viewp^.sviewqual_basis, vtable[ tabno ] DO
        BEGIN
        ltabid := vttableid;
&       ifdef trace
        t01surrogate (ak_sem, 'base tabid  ', vttableid);
&       endif
        a10rel_sysinfo( _viewp );
        END
    (*ENDWITH*) 
ELSE
    a07_b_put_error (acv, _e, 1);
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
