.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-16
*****************************************************
modname : VAK54
changed : 2000-11-16
module  : DML_Help_Procedures
 
Author  : ElkeZ
Created : 1985-02-22
*****************************************************
 
Purpose : Module for help procedures that cannot be assigned to
          any of the DML commands
 
Define  :
 
        PROCEDURE
              a54_dml_init (
                    VAR acv   : tak_all_command_glob;
                    VAR dmli  : tak_dml_info;
                    in_union  : boolean);
 
        PROCEDURE
              a54_dml_finalize (
                    VAR dmli         : tak_dml_info;
                    VAR TransContext : tgg00_TransContext);
 
        PROCEDURE
              a54_base_dml_init (
                    VAR acv   : tak_all_command_glob;
                    VAR dmli  : tak_dml_info;
                    in_union  : boolean);
 
        PROCEDURE
              a54_init;
 
        PROCEDURE
              a54_in_buf (
                    VAR acv         : tak_all_command_glob;
                    VAR dmli        : tak_dml_info;
                    VAR vqual_stack : tak_sysbufferaddress;
                    viewdatalen     : integer;
                    qual_pos        : integer;
                    stcount         : integer;
                    viewdatapos     : integer;
                    plustabpos      : integer);
 
        PROCEDURE
              a54_put_indices_in_mess_buf (
                    VAR acv     : tak_all_command_glob;
                    VAR basebuf : tak_baserecord;
                    VAR dfa     : tak_dfarr;
                    all_indices : boolean);
 
        PROCEDURE
              a54_store_parsinfo (
                    VAR acv   : tak_all_command_glob;
                    VAR sparr : tak_syspointerarr);
 
        PROCEDURE
              a54_get_pparsp_pinfop (
                    VAR acv   : tak_all_command_glob;
                    VAR sparr : tak_syspointerarr;
                    mtype     : tgg00_MessType);
 
        PROCEDURE
              a54_last_part (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    last_pars_part : boolean);
 
        PROCEDURE
              a54_select_last_part (
                    VAR acv              : tak_all_command_glob;
                    VAR dmli             : tak_dml_info;
                    VAR user_result_tree : tgg00_FileId;
                    last_pars_part       : boolean);
 
        PROCEDURE
              a54_view_put_into (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a54_fixedpos (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a54_joinview_baserecords (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a54_subquery (
                    VAR acv          : tak_all_command_glob;
                    VAR isparr       : tak_syspointerarr;
                    start_node       : tsp00_Int2;
                    mtype            : tgg00_MessType;
                    VAR is_join_view : boolean);
 
        PROCEDURE
              a54_sel_store_parsinfo (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    VAR change_rec : tak_changerecord;
                    last_pars_part : boolean);
 
        PROCEDURE
              a54_shortinfo_to_varpart (
                    VAR acv   : tak_all_command_glob;
                    store_cmd : boolean;
                    VAR infop : tak_sysbufferaddress);
 
        PROCEDURE
              a54_internal_function (
                    VAR acv : tak_all_command_glob;
                    VAR m : tgg00_MessBlock;
                    st_no : integer);
 
        PROCEDURE
              a54InternalFunction (
                    VAR acv           : tak_all_command_glob;
                    VAR StackEntry    : tgg00_StackEntry;
                    VAR dataBuf       : tsp00_MoveObj;
                    dataBufSize       : integer;
                    dataBufPos        : integer;
                    use_acv_timestamp : boolean);
 
        PROCEDURE
              a54set_complex_entry (
                    VAR acv     : tak_all_command_glob;
                    call_reason : tak_complex_call_reason);
 
        PROCEDURE
              a54complicated_view (
                    VAR acv      : tak_all_command_glob;
                    VAR dmli     : tak_dml_info;
                    VAR tableid  : tgg00_Surrogate);
 
        PROCEDURE
              a54add_next_temp_lock (
                    VAR acv           : tak_all_command_glob;
                    VAR tabid         : tgg00_Surrogate;
                    globstate         : tgg00_HandlingSet);
 
        PROCEDURE
              a54_loc_temp_locks (
                    VAR acv   : tak_all_command_glob;
                    globstate : tgg00_HandlingSet;
                    VAR sparr : tak_syspointerarr);
 
        PROCEDURE
              a54datetime_parsinfo (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    stackpos : integer);
 
        PROCEDURE
              a54return_parsid (
                    VAR acv     : tak_all_command_glob;
                    VAR parskey : tak_parskey);
 
        FUNCTION
              a54_optim_select_fetch (VAR acv : tak_all_command_glob) : boolean;
 
        PROCEDURE
              a54init_lock_parsinfo (
                    VAR acv      : tak_all_command_glob;
                    tempinfo_buf : tak_sysbufferaddress);
 
        PROCEDURE
              a54trunc_complex_record (
                    VAR acv      : tak_all_command_glob;
                    comp_cnt_old : integer);
 
        FUNCTION
              a54get_complex_cnt (VAR acv : tak_all_command_glob) : integer;
 
        PROCEDURE
              a54expand_tabarr(
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a54expand_tabarr_ex(
                    VAR acv      : tak_all_command_glob;
                    VAR dmli     : tak_dml_info;
                    new_capacity : tsp00_Int4);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01diag_monitor_on   : boolean;
              a01sysnullkey        : tgg00_SysInfoKey;
              a01defaultkey        : tgg00_SysInfoKey;
              a01fullset           : tak_columnset;
              a01_il_b_identifier  : tsp00_KnlIdentifier;
              a01_zero_res_name    : tsp00_KnlIdentifier;
              a01identifier_size   : integer;
              a01char_size         : integer;
 
        PROCEDURE
              a01_call_put (
                    VAR acv    : tak_all_command_glob;
                    proc       : tak_procs;
                    subproc    : tsp00_Int2;
                    VAR curr_n : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05_transaction_get (
                    VAR acv    : tak_all_command_glob;
                    VAR dest   : tsp00_MoveObj;
                    destpos    : integer;
                    mv_dest    : integer);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06drop_fieldlist_references (VAR fieldlists : tgg00_FieldLists);
 
        PROCEDURE
              a06extcolno (
                    VAR baserec     : tak_baserecord;
                    extcolno        : integer;
                    VAR colinfo_ptr : tak00_colinfo_ptr);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06_systable_get (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR tableid  : tgg00_Surrogate;
                    VAR base_ptr : tak_sysbufferaddress;
                    get_all      : boolean;
                    VAR ok       : boolean);
 
        PROCEDURE
              a06dml_send_mess_buf (
                    VAR acv   : tak_all_command_glob;
                    VAR mbuf  : tgg00_MessBlock;
                    VAR dmli  : tak_dml_info;
                    VAR b_err : tgg00_BasisError);
 
        PROCEDURE
              a06init_curr_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06finish_curr_retpart (
                    VAR acv   : tak_all_command_glob;
                    part_kind : tsp1_part_kind;
                    arg_count : tsp00_Int2);
 
        PROCEDURE
              a06retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
        PROCEDURE
              a06rsend_mess_buf (
                    VAR acv     : tak_all_command_glob;
                    VAR mbuf    : tgg00_MessBlock;
                    return_req  : boolean;
                    VAR e       : tgg00_BasisError);
 
        FUNCTION
              a06uid (VAR user_id : tgg00_Surrogate) : tsp00_Int4;
 
        PROCEDURE
              a06a_mblock_init (
                    VAR acv      : tak_all_command_glob;
                    mtype        : tgg00_MessType;
                    m2type       : tgg00_MessType2;
                    VAR tree     : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_tb_put_error (
                    VAR acv    : tak_all_command_glob;
                    b_err      : tgg00_BasisError;
                    err_code   : tsp00_Int4;
                    VAR tab_id : tgg00_Surrogate);
 
        PROCEDURE
              a07_uni_error (
                    VAR acv  : tak_all_command_glob;
                    uni_err  : tsp8_uni_error;
                    err_code : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10mblock_into_cache (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    VAR mblock   : tgg00_MessBlock;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10del_sysinfo (
                    VAR acv     : tak_all_command_glob;
                    VAR syskey  : tgg00_SysInfoKey;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a10_add_repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    add_sysinfo  : boolean;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_fix_len_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    required_len : integer;
                    plus         : integer;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_key_del (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10_rel_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10add_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10new (
                    VAR acv  : tak_all_command_glob;
                    obj_size : tsp00_Int4;
                    VAR p    : tak_eop_arr_ptr);
 
        PROCEDURE
              a10dispose (
                    VAR acv : tak_all_command_glob;
                    VAR p : tak_eop_arr_ptr);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              SQLManager : vak101;
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
        FUNCTION
              a101_GetExtendedTempFileType(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tgg00_TfnTemp;
 
      ------------------------------ 
 
        FROM
              AK_Index : VAK24;
 
        PROCEDURE
              a24init_index_scan (
                    VAR acv            : tak_all_command_glob;
                    VAR tabid          : tgg00_Surrogate;
                    VAR index_scan_rec : tak_index_scan_record);
 
        PROCEDURE
              a24finish_index_scan (
                    VAR acv            : tak_all_command_glob;
                    VAR index_scan_rec : tak_index_scan_record);
 
        FUNCTION
              a24FunctionParameterCount (
                    VAR index_def : tak_multindex) : integer;
 
        FUNCTION
              a24IsFunctionBasedIndex(VAR index_def : tak_multindex) : boolean;
 
        FUNCTION
              a24next_named_index (
                    VAR acv            : tak_all_command_glob;
                    VAR index_scan_rec : tak_index_scan_record) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_update_statistics : VAK28;
 
        FUNCTION
              a28prim_pages (
                    VAR acv     : tak_all_command_glob;
                    VAR baserec : tak_baserecord) : tsp00_Int4;
 
        PROCEDURE
              a28sys_upd_statistics (
                    VAR acv     : tak_all_command_glob;
                    VAR tree    : tgg00_FileId;
                    mtype       : tgg00_MessType;
                    m2type      : tgg00_MessType2;
                    known_pages : tsp00_Int4;
                    found_pages : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Executing_dispatcher : VAK501;
 
        PROCEDURE
              a501do_execute (
                    VAR acv                 : tak_all_command_glob;
                    VAR dmli                : tak_dml_info;
                    VAR parsk               : tak_parskey;
                    output_during_execution : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Lock_Commit_Rollback : VAK52;
 
        PROCEDURE
              a52_rest_lock_statement (
                    VAR acv       : tak_all_command_glob;
                    VAR isparr    : tak_syspointerarr;
                    VAR back_lock : tak_ak_all_locks;
                    return_result : boolean;
                    complicate    : boolean);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542add_intern_file (
                    VAR acv           : tak_all_command_glob;
                    VAR tableid       : tgg00_Surrogate;
                    VAR owner         : tgg00_Surrogate;
                    correlated_view   : boolean;
                    sqlmode           : tsp00_SqlMode;
                    VAR schemacontext : tgg00_Surrogate;
                    ptr               : tak_sysbufferaddress);
 
        FUNCTION
              a542cmplex_view_stored (
                    VAR acv     : tak_all_command_glob;
                    VAR view_id : tgg00_Surrogate) : boolean;
 
        PROCEDURE
              a542cmd_shinfo_store (
                    VAR acv        : tak_all_command_glob;
                    VAR parsk      : tak_parskey;
                    short_info_ptr : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              diagnose monitor : VAK545;
 
        PROCEDURE
              a545diag_parse_info (
                    VAR acv        : tak_all_command_glob;
                    VAR parsid     : tak_parsid;
                    VAR sel_parsid : tak_parsid);
 
        PROCEDURE
              a545sm_param_info (
                    VAR acv    : tak_all_command_glob;
                    VAR parsid : tak_parsid);
 
      ------------------------------ 
 
        FROM
              DML_Parts : VAK55;
 
        PROCEDURE
              a55realloc_parsinfo (
                    VAR acv          : tak_all_command_glob;
                    VAR parsinfo_ptr : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              AK_Insert : VAK56;
 
        PROCEDURE
              a56insert_upd_with_link (
                    VAR acv        : tak_all_command_glob;
                    VAR linkbuf     : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              AK_Update : VAK57;
 
        PROCEDURE
              a57_b_update_string (
                    VAR acv         : tak_all_command_glob;
                    VAR dmli        : tak_dml_info;
                    VAR dfa         : tak_dfarr;
                    VAR isparr      : tak_syspointerarr;
                    start_node      : tsp00_Int2;
                    VAR sr_rec      : tak71_strat_rec;
                    VAR all_done    : boolean;
                    new_parsinfo    : boolean;
                    VAR linkbuf     : tak_sysbufferaddress;
                    VAR with_commit : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Delete : VAK58;
 
        PROCEDURE
              a58_b_delete_string (
                    VAR acv         : tak_all_command_glob;
                    VAR dmli        : tak_dml_info;
                    VAR dfa         : tak_dfarr;
                    VAR isparr      : tak_syspointerarr;
                    start_node      : tsp00_Int2;
                    VAR sr_rec      : tak71_strat_rec;
                    VAR all_done    : boolean;
                    new_parsinfo    : boolean;
                    VAR with_commit : boolean);
 
        PROCEDURE
              a58delete_with_link (
                    VAR acv     : tak_all_command_glob;
                    VAR tabid   : tgg00_Surrogate;
                    linkindex   : integer;
                    parsno      : integer;
                    use_file_id : integer);
 
      ------------------------------ 
 
        FROM
              Select_List : VAK61;
 
        PROCEDURE
              a61_set_jump (
                    VAR mblock : tgg00_MessBlock;
                    stentrynr : integer;
                    operator  : tgg00_StackEntryType);
 
        PROCEDURE
              a61_rel_old_table (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    i        : integer);
 
      ------------------------------ 
 
        FROM
              Execute_Where_Part : VAK65;
 
        PROCEDURE
              a65_set_operator (
                    VAR acv  : tak_all_command_glob;
                    operator : tgg00_StackOpType);
 
      ------------------------------ 
 
        FROM
              Execute_Select_Expression : VAK660;
 
        PROCEDURE
              a660_search_one_table (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    table_node     : integer;
                    all            : boolean;
                    check_teresult : boolean;
                    lock_spec      : tak_lockenum;
                    wanted_priv    : tak00_PrivR);
 
        PROCEDURE
              a660_new_pparsp (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    first_parsinfo : boolean;
                    complicate     : boolean);
 
        PROCEDURE
              a660_prefix_delete (
                    VAR acv       : tak_all_command_glob;
                    VAR parsk     : tak_parskey;
                    VAR del_cnt   : integer;
                    prefix_length : integer);
 
      ------------------------------ 
 
        FROM
              Subquery_handling : VAK661;
 
        PROCEDURE
              a661_sub_build (
                    VAR acv            : tak_all_command_glob;
                    VAR dmli           : tak_dml_info;
                    sub_n              : integer;
                    filled_part2_bytes : integer;
                    VAR sr_rec         : tak71_strat_rec);
 
        PROCEDURE
              a661_corr_sub (
                    VAR acv                     : tak_all_command_glob;
                    VAR dmli                    : tak_dml_info;
                    s_n                         : integer;
                    filled_part2_bytes          : integer;
                    VAR sr_rec                  : tak71_strat_rec;
                    VAR pseudo_resultset_select : boolean;
                    last_corr_query             : boolean;
                    level                       : integer;
                    no_in_level                 : integer);
 
        PROCEDURE
              a661_update_keys_of_parsrecords
                    (VAR acv    : tak_all_command_glob;
                    old_p_id    : tsp00_C1;
                    VAR lowpars : tsp00_Uint1;
                    old_lowpars : tsp00_Uint1);
 
        PROCEDURE
              a661_fdelete_fromtab_results (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              Resultname_handling : VAK663;
 
        FUNCTION
              a663parse_for_execute (VAR acv : tak_all_command_glob) : boolean;
 
      ------------------------------ 
 
        FROM
              Part2_Select_Expression : VAK67;
 
        PROCEDURE
              a67_bextcolindex (
                    VAR d_esparr : tak_syspointerarr;
                    outcolno : integer);
 
      ------------------------------ 
 
        FROM
              Join_Select : VAK680;
 
        PROCEDURE
              a680multiplier_get (
                    VAR acv             : tak_all_command_glob;
                    base_ptr            : tak_sysbufferaddress;
                    VAR col_info        : tak00_columninfo;
                    jpropset            : tak_jcolpropset;
                    VAR jmultiplier     : tsp00_Int4;
                    VAR do_col_upd_stat : boolean);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              join_trace_routines : VAK683;
 
        PROCEDURE
              a683_output (
                    debug    : tgg00_Debug;
                    VAR joins : tak_joinrec);
&       endif
 
      ------------------------------ 
 
        FROM
              Join2_Select_help_routines : VAK685;
 
        PROCEDURE
              a685init_joinarr(
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info);
 
        PROCEDURE
              a685expand_joinarr_ex(
                    VAR acv      : tak_all_command_glob;
                    VAR dmli     : tak_dml_info;
                    new_capacity : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Deal-With-User-Commands : VAK92;
 
        PROCEDURE
              a92find_return_part (
                    VAR acv      : tak_all_command_glob;
                    part_kind    : tsp1_part_kind;
                    VAR part_ptr : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01glob                : tgg00_KernelGlobals;
              g01diag_moni_parse_on  : boolean;
              g01unicode             : boolean;
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04mblock_optimize_info (VAR mblock : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              GG_allocator_interface : VGG941;
 
        FUNCTION
              gg941Allocate(
                    VAR TransContext : tgg00_TransContext;
                    wantedBytes      : integer) : tsp00_Addr;
 
        PROCEDURE
              gg941Deallocate(
                    VAR TransContext : tgg00_TransContext;
                    VAR p            : tsp00_Addr);
 
        FUNCTION
              gg941ReAllocate(
                    VAR TransContext : tgg00_TransContext;
                    wantedBytes      : integer;
                    hint             : tsp00_Addr) : tsp00_Addr;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30klen (
                    VAR str : tsp00_KnlIdentifier;
                    val : char;
                    cnt : integer) : integer;
 
        FUNCTION
              s30unilnr (
                    str       : tsp00_MoveObjPtr;
                    skip_val  : tsp00_C2;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80: VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vtimestamp (VAR ts : tsp00_Timestamp);
 
        PROCEDURE
              vUTCtimestamp (VAR timestamp : tsp00_Timestamp);
 
        FUNCTION
              vTimeZoneDelta : tsp00_Longreal; (* PTS 1109925 *)
&       IFDEF TRACE
 
        PROCEDURE
              vdebug_break (debug_break_pos : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01stackdesc (
                    debug          : tgg00_Debug;
                    nam            : tsp00_Sname;
                    stack_addr     : tgg00_StackListPtr;
                    VAR stack_desc : tgg00_StackDesc);
 
        PROCEDURE
              t01handling (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname;
                    s     : tgg00_HandlingSet);
 
        PROCEDURE
              t01addr (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    bufaddr  : tsp00_Addr);
 
        PROCEDURE
              t01fp_kind (
                    debug   : tgg00_Debug;
                    nam     : tsp00_Sname;
                    fp_kind : tak_fp_kind_type_ptr);
 
        PROCEDURE
              t01command_kind (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    command_kind : tak_commandkind);
 
        PROCEDURE
              t01messtype (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    mess_type    : tgg00_MessType);
 
        PROCEDURE
              t01sname (
                    debug   : tgg00_Debug;
                    nam     : tsp00_Sname);
 
        PROCEDURE
              t01moveobj (
                    debug       : tgg00_Debug;
                    VAR moveobj : tak_viewbuf;
                    startpos    : tsp00_Int4;
                    endpos      : tsp00_Int4);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01buf  (
                    level     : tgg00_Debug;
                    VAR buf   : tak_systembuffer;
                    pos_start : integer;
                    pos_end   : integer);
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR m         : tgg00_MessBlock);
 
        PROCEDURE
              t01real (debug : tgg00_Debug;
                    nam    : tsp00_Sname;
                    re     : tsp00_Longreal;
                    digits : integer);
&       ENDIF
 
      ------------------------------ 
 
        FROM
              PUT-Conversions: VSP41;
 
        PROCEDURE
              s41plint (
                    VAR buf : tsp00_MoveObj;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
        PROCEDURE
              s41plrel (VAR buf : tsp00_MoveObj;
                    pos         : tsp00_Int4;
                    len         : integer;
                    frac        : integer;
                    source      : tsp00_Longreal;
                    VAR res     : tsp00_NumError);
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              a10new;
 
              tak_sysbufferaddress tak_eop_arr_ptr
 
        PROCEDURE
              a10dispose;
 
              tak_sysbufferaddress tak_eop_arr_ptr
 
        FUNCTION
              s30klen;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              t01buf;
 
              tsp00_Buf tak_systembuffer
 
        PROCEDURE
              t01moveobj;
 
              tsp00_MoveObj tak_viewbuf
 
        PROCEDURE
              t01addr;
 
              tsp00_BufAddr tsp00_Addr
 
.CM *-END-* synonym -------------------------------------
***********************************************************
 
Specification:
.sp 2;.of 14
A54_SUBQUERY: Generation of information records for
subqueries in updates and deletes, of
the updates and deletes themselves and,
if appropriate, execution of subqueries and modifications
.CM *-END-* specification -------------------------------
***********************************************************
 
Description:
.sp 2
A54_SUBQUERY
.sp
Subqueries are indicated by a pointer from n_sa_level of the 1st
node to a special part of the parse tree in which pointers to
the subquery-select are in.
.br;The procedure AK54INTERN_SUB is called, which provides all
information
for execution.  The execution itself, however, does not yet take place.
This is in order to save the stack since local variables of
AK54INTERN_SUB are not on the stack at the time of execution.
.br
If the user has requested execution (m_ex_kind <> only_parsing),
first all subqueries and then the update or delete are executed via
A50_DO_EXECUTE and the stored parse-information records are deleted
via A66_PREFIX_DELETE.
.sp 2
AK54INTERN_SUB
.sp
This procedure is called by A54_SUBQUERY.
.br;Via a call by A66_SUB_BUILD, parse-information records are created
and stored for all underlying subqueries.  The search is not yet
executed.
.br
A57_B_UPDATE_STRING generates the parse-information records for the update,
A58_B_DELETE_STRING generates the parse-information records for the delete.
These are stored with A54_LAST_PART.
.CM *-END-* description ---------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      c_get_all         = true (* a06_systable_get      *);
      (*                          a660_search_one_table *)
      c_output_during_execution= true (* a501do_execute *);
      c_return_result   = true (* a52_rest_lock_statement *);
      c_complicate      = true (* a52_rest_lock_statement *);
      (*                          a660_new_pparsp         *)
      c_in_union        = true (* a54_dml_init *);
      c_last_pars_part  = true (* a54_last_part *);
      c_new_parsinfo    = true (* a57_b_update_string *);
      (*                          a58_b_delete_string *)
      c_check_teresult  = true (* a660_search_one_table *);
      c_first_parsinfo  = true (* a660_new_pparsp *);
      c_last_corr_query = true (* a661_corr_sub *);
 
VAR
      a54dmli   : tak_dml_info;
      a54onetab : tak_one_table;
 
 
(*------------------------------*) 
 
PROCEDURE
      ak54complexrec_get (VAR acv : tak_all_command_glob);
 
VAR
      add   : boolean;
      e     : tgg00_BasisError;
      parsk : tak_parskey;
      ke    : tgg00_SysInfoKey;
 
BEGIN
add := false;
ke := a01sysnullkey;
&IFDEF TRACE
t01command_kind( ak_sem,'command_kind', acv.a_command_kind );
&ENDIF
CASE acv.a_command_kind OF
    complex_view_command :
        BEGIN
        parsk        := acv.a_pars_last_key;
        parsk.p_kind := m_complex;
        IF  acv.a_intern_select_cnt <= 1
        THEN
            BEGIN
            acv.a_first_parskey := parsk.p_id[ 1 ];
&           IFDEF TRACE
            t01int4( ak_sem,'first_psk 2 ', ord( acv.a_first_parskey ));
&           ENDIF
            WITH ke DO
                BEGIN
                sauthid[ 1 ] := cak_tempinfo_byte;
                SAPDB_PascalForcedMove( sizeof( parsk ), sizeof( sauthid ),
                      @parsk, 1, @sauthid, 2, mxak_parskey );
                sentrytyp := cak_ecomplex
                END;
            (*ENDWITH*) 
            a10_nil_get_sysinfo( acv, ke, d_release,
                  mxak_complexrecminlength, acv.a_ptr2, e );
            IF  e <> e_ok
            THEN
                a07_b_put_error( acv, e, acv.a_cmd_part^.sp1p_buf_len )
            ELSE
                WITH acv.a_ptr2^, scomplexrec DO
                    BEGIN
                    compcnt := 1;
                    add        := true;
                    WITH comparr[ compcnt ] DO
                        BEGIN
                        cparsk       := acv.a_pars_last_key;
                        cnextpars    := compcnt + 1;
                        IF  acv.a_intern_select_cnt = acv.a_max_intern_select
                            (*
                                  (NOT acv.a_recursive_loop OR
                                  (acv.a_recursive_state <> rs_first_select ))
                                  *)
                        THEN
                            centryinfo := [ ci_lastpars ]
                        ELSE
                            centryinfo := [ ];
                        (*ENDIF*) 
                        cqual_jv_upd  := acv.a_qualified_jv_upd;
                        END;
                    (*ENDWITH*) 
                    END
                (*ENDWITH*) 
            (*ENDIF*) 
            END
        ELSE
            BEGIN (* intern_select_cnt > 1 *)
            parsk.p_id[ 1 ] := acv.a_first_parskey;
            parsk.p_no      := 0;
            WITH ke DO
                BEGIN
                sauthid[ 1 ] := cak_tempinfo_byte;
                SAPDB_PascalForcedMove( sizeof( parsk ), sizeof( sauthid ),
                      @parsk, 1, @sauthid, 2, mxak_parskey );
                sentrytyp := cak_ecomplex
                END;
            (*ENDWITH*) 
            a10_fix_len_get_sysinfo( acv, ke, d_release,
                  cak_sysbufferoffset + 4 + FILE_ID_MXGG00 +
                  acv.a_intern_select_cnt * mxak_complex_entry,
                  0, acv.a_ptr2, e );
            IF  e <> e_ok
            THEN
                a07_b_put_error( acv, e, acv.a_cmd_part^.sp1p_buf_len )
            ELSE
                WITH acv.a_ptr2^, scomplexrec DO
                    BEGIN
                    add := false;
&                   IFDEF TRACE
                    t01int4( ak_sem, 'complexcnt  ', compcnt );
                    t01int4( ak_sem, 'intern_selcn', acv.a_intern_select_cnt );
                    t01buf( ak_sem, acv.a_ptr2^, 1,
                          cak_sysbufferoffset + 4 + FILE_ID_MXGG00 +
                          compcnt * mxak_complex_entry );
&                   ENDIF
                    compcnt := acv.a_intern_select_cnt;
                    WITH comparr[ compcnt ] DO
                        BEGIN
                        cparsk       := acv.a_pars_last_key;
                        cnextpars    := compcnt + 1;
                        IF  acv.a_intern_select_cnt = acv.a_max_intern_select
                        THEN
                            centryinfo := [ ci_lastpars ]
                        ELSE
                            centryinfo := [ ];
                        (*ENDIF*) 
                        cqual_jv_upd  := acv.a_qualified_jv_upd;
                        END;
                    (*ENDWITH*) 
                    IF  b_sl < cak_sysbufferoffset + 4 + FILE_ID_MXGG00 +
                        (compcnt - 1) * mxak_complex_entry
                    THEN
                        BEGIN
                        WITH comparr[ compcnt - 1] DO
                            BEGIN
                            cparsk        := acv.a_pars_last_key;
                            cparsk.p_kind := m_nil;
                            cnextpars     := compcnt + 1;
                            centryinfo    := [ ];
                            cqual_jv_upd  := acv.a_qualified_jv_upd;
                            END;
                        (*ENDWITH*) 
                        END;
                    (*ENDIF*) 
                    END
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    subquery_command, sub_in_complex_command, sub_in_union_command,
    link_command(*, corr_in_union_command *):
        BEGIN
        parsk        := acv.a_pars_last_key;
        parsk.p_kind := m_complex;
        IF  acv.a_command_kind = sub_in_complex_command
        THEN
            BEGIN
            IF  acv.a_intern_select_cnt <= 1
            THEN
                WITH parsk DO
                    IF  ord( p_id[ 1 ]) < cak00_maxsubqueries
                    THEN
                        p_id[ 1 ] := chr( ord( p_id[ 1 ]) + 1 )
                    ELSE
                        a07_b_put_error( acv, e_too_many_subqueries, 1 );
                    (*ENDIF*) 
                (*ENDWITH*) 
            (*ENDIF*) 
            acv.a_command_kind := complex_view_command;
            ak54complexrec_get( acv );
            IF  acv.a_returncode = 0
            THEN
                BEGIN
                add := false;
                acv.a_command_kind := sub_in_complex_command;
                acv.a_pars_last_key.p_id[ 1 ] := parsk.p_id[ 1 ];
                acv.a_first_parsid        := parsk.p_id[ 1 ];
                WITH acv.a_ptr2^, scomplexrec DO
                    BEGIN
&                   IFDEF TRACE
                    t01int4( ak_sem, 'first_pid 2 ', ord( acv.a_first_parsid ));
                    t01int4( ak_sem, 'complexcnt  ', compcnt );
                    t01buf( ak_sem, acv.a_ptr2^, 1,
                          cak_sysbufferoffset + 4 + FILE_ID_MXGG00 +
                          compcnt * mxak_complex_entry );
&                   ENDIF
                    comparr[ compcnt ].cparsk := parsk;
                    END;
                (*ENDWITH*) 
                END
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            IF  (( acv.a_command_kind = sub_in_union_command ) (*OR
                  ( acv.a_command_kind = corr_in_union_command )*)
                )
            THEN
                acv.a_first_parsid  := parsk.p_id[ 1 ]
            ELSE
                acv.a_first_parskey := parsk.p_id[ 1 ];
            (*ENDIF*) 
            END;
        (*ENDIF*) 
&       IFDEF TRACE
        t01int4( ak_sem, 'first_pid 4 ', ord( acv.a_first_parsid ));
        t01int4( ak_sem, 'first_psk 1 ', ord( acv.a_first_parskey ));
&       ENDIF
        WITH ke DO
            BEGIN
            sauthid[ 1 ] := cak_tempinfo_byte;
            SAPDB_PascalForcedMove( sizeof( parsk ), sizeof( sauthid ),
                  @parsk, 1, @sauthid, 2, mxak_parskey );
            sentrytyp := cak_ecomplex
            END;
        (*ENDWITH*) 
        a10_nil_get_sysinfo( acv, ke, d_release,
              mxak_complexrecminlength, acv.a_ptr2, e );
        IF  e <> e_ok
        THEN
            a07_b_put_error( acv, e, acv.a_cmd_part^.sp1p_buf_len )
        ELSE
            WITH acv.a_ptr2^, scomplexrec DO
                BEGIN
                add        := true;
                compcnt := 1;
&               IFDEF TRACE
                t01command_kind( ak_sem, 'command_kind', acv.a_command_kind );
&               ENDIF
                WITH comparr[ compcnt ] DO
                    BEGIN
                    cparsk       := acv.a_pars_last_key;
                    cnextpars    := compcnt + 1;
                    centryinfo   := [ ];
                    cqual_jv_upd := acv.a_qualified_jv_upd;
                    END;
                (*ENDWITH*) 
                END
            (*ENDWITH*) 
        (*ENDIF*) 
        END
    END;
(*ENDCASE*) 
IF  ( acv.a_returncode = 0 )
THEN
    WITH acv.a_ptr2^, scomplexrec DO
        BEGIN
        compcreateaseltree := b01niltree_id;
        b_sl        := cak_sysbufferoffset + 4 + FILE_ID_MXGG00 +
              compcnt * mxak_complex_entry;
        compmax_sel_cnt := acv.a_max_intern_select;
&       IFDEF TRACE
        t01int4( ak_sem, 'max_intern54', acv.a_max_intern_select );
        t01int4( ak_sem, 'complexcnt  ', compcnt );
        t01buf( ak_sem, acv.a_ptr2^, 1, b_sl );
&       ENDIF
        acv.a_complex_key := acv.a_ptr2^.syskey.sauthid;
        a10_add_repl_sysinfo( acv, acv.a_ptr2, add, e );
        IF  ( e <> e_ok )
        THEN
            a07_b_put_error( acv, e, 1 );
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54datetime_parsinfo (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            stackpos : integer);
 
BEGIN
IF  NOT dmli.d_only_sem_check
THEN
    BEGIN
    WITH dmli.d_sparr.pparsp^.sparsinfo DO
        IF  p_cnt_infos >= p_max_infos
        THEN
            a55realloc_parsinfo( acv, dmli.d_sparr.pparsp );
        (*ENDIF*) 
    (*ENDWITH*) 
    IF  acv.a_returncode = 0
    THEN
        WITH acv, a_mblock.mb_st^ [ stackpos ],
             dmli, d_sparr.pparsp^.sparsinfo,
             p_pars_infos[ p_cnt_infos + 1 ] DO
            BEGIN
            CASE etype OF
                st_date :
                    BEGIN
                    fp_datatyp                    := ddate;
                    fp_len_and_frac_v2.lf_datalen := mxsp_extdate;
                    fp_inoutlen_v2                := succ( fp_len_and_frac_v2.lf_datalen );
                    fp_frompos_v2                 := cak_fp_date;
                    END;
                st_time :
                    BEGIN
                    fp_datatyp                    := dtime;
                    fp_len_and_frac_v2.lf_datalen := mxsp_exttime;
                    fp_inoutlen_v2                := succ( fp_len_and_frac_v2.lf_datalen );
                    fp_frompos_v2                 := cak_fp_time;
                    END;
                st_timestamp :
                    BEGIN
                    fp_datatyp                    := dtimestamp;
                    fp_len_and_frac_v2.lf_datalen := mxsp_exttimestamp;
                    fp_inoutlen_v2                := succ( fp_len_and_frac_v2.lf_datalen );
                    fp_frompos_v2                 := cak_fp_timestamp;
                    END;
                (* PTS 1122262 E.Z. *)
                st_utcdate :
                    BEGIN
                    fp_datatyp                    := dtimestamp;
                    fp_len_and_frac_v2.lf_datalen := mxsp_exttimestamp;
                    fp_inoutlen_v2                := succ( fp_len_and_frac_v2.lf_datalen );
                    fp_frompos_v2                 := cak_fp_utcdate;
                    END;
                st_utcdiff :
                    BEGIN
                    fp_datatyp                          := dfixed;
                    fp_len_and_frac_v2.lf_fixed_datalen := cak_utcdiff_len;
                    fp_len_and_frac_v2.lf_frac          := cak_utcdiff_frac + cak_frac_offset;
                    fp_inoutlen_v2                      := ((cak_utcdiff_len+1) DIV 2) + 2;
                    fp_frompos_v2                       := cak_fp_utcdiff;
                    END;
                st_transaction :
                    BEGIN
                    fp_datatyp                    := dchb;
                    fp_len_and_frac_v2.lf_datalen := sizeof(acv.a_transinf.tri_trans.trTransId_gg00);
                    ;
                    fp_inoutlen_v2                := succ( fp_len_and_frac_v2.lf_datalen );
                    fp_frompos_v2                 := cak_fp_transaction;
                    END;
                st_timezone :
                    BEGIN
                    fp_datatyp                          := dfixed;
                    fp_len_and_frac_v2.lf_fixed_datalen := cak_time_durationlen;
                    fp_len_and_frac_v2.lf_frac          := cak_frac_offset;
                    fp_inoutlen_v2                      := ((cak_time_durationlen+1) DIV 2) + 2;
                    fp_frompos_v2                       := cak_fp_timezone;
                    END;
                st_current_schema :
                    BEGIN
                    IF  g01unicode
                    THEN
                        fp_datatyp                := dunicode
                    ELSE
                        fp_datatyp                := dcha;
                    (*ENDIF*) 
                    fp_len_and_frac_v2.lf_datalen := a01identifier_size DIV a01char_size;
                    ;
                    fp_inoutlen_v2                := succ( sizeof(acv.a_curr_schema) );
                    fp_frompos_v2                 := cak_fp_current_schema;
                    END;
                END;
            (*ENDCASE*) 
            fp_kind          := fp_val_all_without_l;
            fp_etype         := etype;
            etype            := st_value;
            fp_colset        := [  ];
            fp_movebefore_v2 := 0;
            fp_stackpos      := stackpos;
            p_cnt_infos      := succ( p_cnt_infos );
            END
        (*ENDWITH*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54init_lock_parsinfo (
            VAR acv      : tak_all_command_glob;
            tempinfo_buf : tak_sysbufferaddress);
 
BEGIN
WITH acv, tempinfo_buf^.sparsinfo, p_temp_lock DO
    BEGIN
    p_cnt_infos                := 0;
    p_max_infos                := 0;
    p_mtyp                     := m_nil;
    p_mtyp2                    := mm_nil;
    p_pagecnt                  := csp_maxint4;
    p_int_res_cnt              := 0;
    p_p_no                     := 0;
    p_sqlmode                  := acv.a_sqlmode;
    p_own_trans                := false;
    p_reuse                    := false;
    p_single                   := false;
    p_select                   := false;
    p_longliteral              := false;
    (* sharedSQL couldn't change parseinfo at execution *)
    IF  a_parsingForSharedSql
    THEN
        p_parsing_again        := false
    ELSE
        p_parsing_again        := a_parsing_again;
    (*ENDIF*) 
    p_subcntlevel              := - 1;
    p_temp_lock_atch           := 0;
    p_temp_lock.all_lock_count := 0;
    p_searchname               := a01_il_b_identifier;
    p_modul_name               := a_modul_name;
    p_statement_kind           := a_statement_kind;
    p_filler1                  := false;
    p_function_code            := a_return_segm^.sp1r_function_code;
    p_bool_states              := [];
    p_session_isolevel         := a_iso_level;
    p_use_sess_isolevel        := false;
    a_isolation_info := temp_lock_rec_get;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak54intern_sub (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info;
            VAR isparr : tak_syspointerarr;
            start_node : tsp00_Int2;
            mtype      : tgg00_MessType);
 
VAR
      b_err            : tgg00_BasisError;
      all_done         : boolean;
      pseudo_resultset : boolean;
      del_with_link    : boolean;
      with_commit      : boolean;
      i                : integer;
      low_first        : integer;
      act_node         : integer;
      m_p_id           : tsp00_C1;
      sr_rec           : tak71_strat_rec;
      linkbuf          : tak_sysbufferaddress;
      prim_tab_id      : tgg00_Surrogate;
      parsk            : tak_parskey;
      sysk             : tgg00_SysInfoKey;
      dfa              : tak_dfarr;
 
BEGIN
linkbuf := NIL;
dmli.d_use_sub := true;
dmli.d_subquery := true;
dmli.d_oldlowpars := csp_maxint1;
dmli.d_pos_result := cak_maxresulttables + 1;
dmli.d_sparr.px[ 1 ] := NIL;
dmli.d_sparr.pbasep  := NIL;
acv.a_info_output := false;
sr_rec.sr_reverse_access := false;
low_first := 1;
(* PTS 1000785 E.Z. *)
dmli.d_subquery_node := 1;
with_commit := false;
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    act_node := acv.a_ap_tree^[ start_node ].n_lo_level;
    (* step to search clause *)
    WHILE (acv.a_ap_tree^[ act_node ].n_sa_level > 0) AND
          (acv.a_ap_tree^[ act_node ].n_proc <> a52) DO
        act_node := acv.a_ap_tree^[ act_node ].n_sa_level;
    (*ENDWHILE*) 
    IF  (acv.a_ap_tree^[ act_node ].n_proc = a52) AND
        (acv.a_ap_tree^[ act_node ].n_subproc = cak_x_commit)
    THEN
        a07_b_put_error (acv, e_not_implemented, 1);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    IF  acv.a_corr_select
    THEN
        acv.a_ap_tree^[ start_node ].n_symb := s_sum;
    (*ENDIF*) 
    IF  acv.a_ap_tree^[ start_node ].n_symb = s_sum
    THEN
        BEGIN
        acv.a_corr_select := true;
        (* correlated subquery *)
        IF  ( NOT ( hsTempLock_egg00 in dmli.d_globstate ) AND
            NOT ( hsPermLock_egg00 in dmli.d_globstate ))
        THEN
            BEGIN
            i := acv.a_ap_tree^[ start_node ].n_lo_level;
            i := acv.a_ap_tree^[ i ].n_sa_level;
            IF  mtype = m_update
            THEN
                i := acv.a_ap_tree^[ i ].n_sa_level;
            (*ENDIF*) 
            IF  i <> 0
            THEN
                BEGIN
                i := acv.a_ap_tree^[ i ].n_lo_level;
                WITH acv.a_ap_tree^[ i ] DO
                    IF  NOT
                        (( n_proc = a55 )
                        AND
                        (( n_subproc = cak_x_keyspec_list ) OR
                        ( n_subproc = cak_x_current_of )   OR
                        ( n_subproc = cak_x_pos_of )))
                    THEN
                        BEGIN
                        dmli.d_globstate := dmli.d_globstate + [ hsTempLock_egg00 ];
                        dmli.d_unchanged_globstate := dmli.d_unchanged_globstate
                              + [ hsTempLock_egg00 ];
                        IF  acv.a_isolation_info <> temp_lock_rec_get
                        THEN
                            acv.a_isolation_info := temp_lock_rec_needed;
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                (*ENDWITH*) 
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        ak54rebuild_parse_tree( acv, start_node );
        dmli.d_use_sub := false;
        dmli.d_subquery := false;
        dmli.d_level[ 1 ] := 1;
        dmli.d_corr := first_correlation;
        all_done := false;
        IF  acv.a_command_kind = complex_view_command
        THEN
            acv.a_command_kind := sub_in_complex_command
        ELSE
            IF  acv.a_command_kind <> sub_in_complex_command
            THEN
                acv.a_command_kind := subquery_command;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  hsConsistentLock_egg00 in dmli.d_globstate
        THEN
            IF  hsTempLock_egg00 in dmli.d_globstate
            THEN
                BEGIN
                dmli.d_globstate := dmli.d_globstate - [ hsConsistentLock_egg00 ]
                      + [ hsWithoutLock_egg00 ];
                dmli.d_unchanged_globstate := dmli.d_unchanged_globstate -
                      [ hsConsistentLock_egg00 ] + [ hsWithoutLock_egg00 ]
                END
            ELSE
                dmli.d_unchanged_globstate := dmli.d_unchanged_globstate -
                      [ hsConsistentLock_egg00 ] + [ hsCollisionTest_egg00 ];
            (*ENDIF*) 
        (*ENDIF*) 
        CASE mtype OF
            m_update :
                a57_b_update_string( acv, dmli, dfa, isparr, start_node,
                      sr_rec, all_done, c_new_parsinfo, linkbuf, with_commit );
            m_delete :
                a58_b_delete_string( acv, dmli, dfa, isparr, start_node,
                      sr_rec, all_done, c_new_parsinfo, with_commit );
            END;
        (*ENDCASE*) 
        del_with_link := false;
        IF  (( acv.a_returncode = 0 ) AND
            ( NOT dmli.d_only_sem_check ))
        THEN
            WITH acv.a_mblock, mb_data^, isparr.pbasep^.sbase DO
                BEGIN
                a54_last_part( acv, isparr, NOT c_last_pars_part );
                IF  mtype = m_delete
                THEN
                    IF  ( is_primary_table in
                        isparr.pbasep^.sbase.blinkexist )
                    THEN
                        BEGIN
                        del_with_link := true;
                        prim_tab_id   := isparr.pbasep^.sbase.bsurrogate
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        dmli.d_subquery := true;
        dmli.d_corr     := correlation;
        m_p_id     := acv.a_pars_last_key.p_id;
        pseudo_resultset := false;
        IF  (( acv.a_returncode = 0 ) AND
            ( NOT dmli.d_only_sem_check ))
        THEN
            a661_corr_sub( acv, dmli,
                  acv.a_ap_tree^[ start_node ].n_sa_level,
                  dmli.d_filled_bytes, sr_rec, pseudo_resultset,
                  c_last_corr_query, 2, 1 );
        (*ENDIF*) 
        IF  (( acv.a_returncode = 0 ) AND
            ( dmli.d_lowpars < csp_maxint1 ))
            AND NOT ( dmli.d_only_sem_check )
        THEN
            a661_update_keys_of_parsrecords( acv, m_p_id,
                  dmli.d_lowpars, csp_maxint1 );
        (*ENDIF*) 
        IF  (( acv.a_returncode = 0 ) AND
            ( NOT dmli.d_only_sem_check ))
        THEN
            a54set_complex_entry( acv, c_set_last_pars );
        (*ENDIF*) 
        IF  (( acv.a_init_ex_kind = only_parsing ) AND
            ( acv.a_returncode = 0 ) AND
            ( acv.a_intern_select_cnt = acv.a_max_intern_select ))
        THEN
            a54_shortinfo_to_varpart( acv, acv.a_initial_segment_header.sp1c_prepare,
                  dmli.d_sparr.pinfop );
        (*ENDIF*) 
        IF  del_with_link
        THEN
            a58delete_with_link( acv, prim_tab_id, 0, 1, 0 )
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        IF  acv.a_command_kind = complex_view_command
        THEN
            acv.a_command_kind := sub_in_complex_command
        ELSE
            IF  acv.a_command_kind <> sub_in_complex_command
            THEN
                acv.a_command_kind := subquery_command;
            (*ENDIF*) 
        (*ENDIF*) 
        acv.a_pars_last_key.p_kind := mtype;
        IF  start_node <> acv.a_ap_tree^[ 0 ].n_lo_level
        THEN
            BEGIN
            a660_new_pparsp( acv, dmli.d_sparr,
                  NOT c_first_parsinfo, c_complicate );
            IF  acv.a_returncode = 0
            THEN
                BEGIN
                a54set_complex_entry( acv, c_set_last_pars );
                sysk := a01sysnullkey;
                WITH sysk, parsk DO
                    BEGIN
                    sauthid[ 1 ] := cak_tempinfo_byte;
                    p_count   := acv.a_pars_last_key.p_count;
                    p_id[ 1 ] := acv.a_first_parsid;
                    p_kind    := m_fetch;
                    p_no      := 0;
                    sentrytyp := cak_eshortinfo;
                    SAPDB_PascalForcedMove( sizeof( parsk ), sizeof( sauthid ),
                          @parsk, 1, @sauthid, 2, mxak_parskey );
                    END;
                (*ENDWITH*) 
                a10get_sysinfo( acv, sysk, d_fix, dmli.d_sparr.pinfop, b_err );
                IF  b_err <> e_ok
                THEN
                    a07_b_put_error( acv, b_err, 1 );
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        ELSE
            a54_get_pparsp_pinfop( acv, dmli.d_sparr, mtype );
        (*ENDIF*) 
        acv.a_mblock.mb_data_len         := cgg_rec_key_offset;
        acv.a_mblock.mb_data^.mbp_reclen := 0;
        acv.a_mblock.mb_data^.mbp_keylen := 0;
        a661_sub_build( acv, dmli, acv.a_ap_tree^[ start_node ].n_sa_level,
              cgg_rec_key_offset, sr_rec );
        IF  (acv.a_returncode = 0) AND (acv.a_main_returncode <> 0)
        THEN
            BEGIN
            acv.a_returncode := acv.a_main_returncode;
            acv.a_errorpos   := acv.a_main_errorpos;
            acv.a_main_returncode := 0;
            acv.a_main_errorpos   := 0;
            END;
        (*ENDIF*) 
        dmli.d_subquery := false;
        IF  ( acv.a_returncode = 0 ) AND
            ( acv.a_intern_select_cnt = acv.a_max_intern_select )
        THEN
            BEGIN
            a660_new_pparsp( acv, dmli.d_sparr,
                  NOT c_first_parsinfo, c_complicate );
            IF  acv.a_returncode = 0
            THEN
                BEGIN
                dmli.d_parameter_count:= 0;
                dmli.d_sparr.pparsp^.sparsinfo.p_subcntlevel := 1;
                a54set_complex_entry( acv, c_set_last_pars );
                IF  acv.a_returncode = 0
                THEN
                    BEGIN
                    dmli.d_subcount := 0;
                    all_done := false;
                    CASE mtype OF
                        m_update :
                            a57_b_update_string( acv, dmli, dfa, isparr,
                                  start_node, sr_rec, all_done,
                                  NOT c_new_parsinfo, linkbuf, with_commit );
                        m_delete :
                            a58_b_delete_string( acv, dmli, dfa, isparr,
                                  start_node, sr_rec, all_done,
                                  NOT c_new_parsinfo, with_commit );
                        END;
                    (*ENDCASE*) 
                    END;
                (*ENDIF*) 
                IF  acv.a_returncode = 0
                THEN
                    WITH acv.a_mblock, mb_data^ DO
                        BEGIN
                        a54_last_part( acv, isparr,
                              c_last_pars_part );
                        IF  mtype = m_delete
                        THEN
                            IF  ( is_primary_table in
                                isparr.pbasep^.sbase.blinkexist )
                            THEN
                                WITH isparr.pbasep^.syskey DO
                                    a58delete_with_link( acv, stableid, 0, 1, 0 );
                                (*ENDWITH*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    (*ENDWITH*) 
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        ELSE
            IF  (acv.a_returncode      = cak_e_corelated_subquery_not_allowed) OR
                (acv.a_main_returncode = cak_e_corelated_subquery_not_allowed)
            THEN
                BEGIN
                acv.a_ap_tree^[ start_node ].n_symb := s_sum;
                (* PTS 1000843 E.Z. *)
                IF  mtype = m_update
                THEN
                    BEGIN
                    (* look for 'current of' *)
                    act_node := acv.a_ap_tree^[ start_node ].n_lo_level;
                    act_node := acv.a_ap_tree^[ act_node ].n_sa_level;
                    act_node := acv.a_ap_tree^[ act_node ].n_sa_level;
                    IF  act_node > 0
                    THEN
                        BEGIN
                        WITH acv.a_ap_tree^[ act_node ] DO
                            IF  (( n_proc = a55 ) AND
                                ( n_subproc = cak_x_search_clause ))
                            THEN
                                act_node := acv.a_ap_tree^[ act_node ].n_lo_level;
                            (*ENDIF*) 
                        (*ENDWITH*) 
                        WITH acv.a_ap_tree^[ act_node ] DO
                            IF  (( n_proc = a55 ) AND
                                (( n_subproc = cak_x_current_of ) OR
                                ( n_subproc = cak_x_pos_of )))
                            THEN
                                BEGIN
                                acv.a_returncode := 0;
                                a07_b_put_error( acv, e_not_implemented, n_pos )
                                END
                            (*ENDIF*) 
                        (*ENDWITH*) 
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  linkbuf <> NIL
    THEN
        a56insert_upd_with_link( acv, linkbuf );
    (*ENDIF*) 
    IF  (( acv.a_returncode = 0 ) AND
        ( acv.a_isolation_info = temp_lock_rec_get ))
    THEN
        a54_loc_temp_locks( acv, dmli.d_globstate, dmli.d_sparr );
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak54rebuild_parse_tree (
            VAR acv    : tak_all_command_glob;
            start_node : tsp00_Int2);
 
VAR
      keyspecl_node : tsp00_Int2;
      keyspec1_node : tsp00_Int2;
      keyspec2_node : tsp00_Int2;
      search_node   : tsp00_Int2;
      where_node    : tsp00_Int2;
 
BEGIN
(* PTS 1000843 E.Z. *)
(* keyspeclist is transformed into usual search_condition *)
search_node := acv.a_ap_tree^[ start_node ].n_lo_level;
search_node := acv.a_ap_tree^[ search_node ].n_sa_level;
IF  acv.a_ap_tree^[ start_node ].n_proc = a57 (* update *)
THEN
    search_node := acv.a_ap_tree^[ search_node ].n_sa_level;
(*ENDIF*) 
where_node := search_node;
keyspecl_node := acv.a_ap_tree^[ search_node ].n_lo_level;
IF  (( acv.a_ap_tree^[ keyspecl_node ].n_proc = a55 ) AND
    ( acv.a_ap_tree^[ keyspecl_node ].n_subproc = cak_x_keyspec_list ))
THEN
    BEGIN
    keyspec1_node := acv.a_ap_tree^[ keyspecl_node ].n_lo_level;
    a01_call_put( acv, a64, cak_x_and_operator,
          acv.a_ap_tree^[ search_node ].n_lo_level );
    search_node := acv.a_ap_tree^[ search_node ].n_lo_level;
    IF  acv.a_ap_tree^[ keyspecl_node ].n_sa_level = 0
    THEN
        BEGIN
        WITH acv.a_ap_tree^[ search_node ] DO
            BEGIN
            n_lo_level := keyspec1_node;
            n_symb := s_and
            END;
        (*ENDWITH*) 
        IF  acv.a_ap_tree^[ keyspec1_node ].n_sa_level = 0
        THEN (* one keycolumn *)
            acv.a_ap_tree^[ where_node ].n_lo_level := keyspec1_node
        ELSE
            acv.a_ap_tree^[ where_node ].n_lo_level := keyspecl_node;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        where_node := acv.a_ap_tree^[ keyspecl_node ].n_sa_level;
        WITH acv.a_ap_tree^[ search_node ] DO
            BEGIN
            n_lo_level := where_node;
            n_symb := s_and
            END;
        (*ENDWITH*) 
        IF  acv.a_ap_tree^[ keyspec1_node ].n_sa_level = 0
        THEN (* one keycolumn *)
            acv.a_ap_tree^[ where_node ].n_sa_level := keyspec1_node
        ELSE
            acv.a_ap_tree^[ where_node ].n_sa_level := keyspecl_node;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  acv.a_ap_tree^[ keyspec1_node ].n_sa_level > 0
    THEN (* more than one keycolumn *)
        BEGIN
        WITH acv.a_ap_tree^[ keyspecl_node ] DO
            BEGIN
            n_proc    := a64;
            n_subproc := cak_x_and_operator;
            n_symb    := s_and;
            n_sa_level := 0
            END;
        (*ENDWITH*) 
        keyspec2_node := acv.a_ap_tree^[ keyspec1_node ].n_sa_level;
        WHILE acv.a_ap_tree^[ keyspec2_node ].n_sa_level <> 0 DO
            BEGIN
            a01_call_put( acv, a64, cak_x_and_operator,
                  acv.a_ap_tree^[ keyspec1_node ].n_sa_level );
            WITH acv.a_ap_tree^[ keyspec1_node ] DO
                BEGIN
                acv.a_ap_tree^[ n_sa_level ].n_symb := s_and;
                n_proc    := a64;
                n_subproc := cak_x_predicate;
                n_symb    := s_equal;
                (* up to now = s_identifier *)
                acv.a_ap_tree^[ n_lo_level ].n_symb := s_columnname;
                keyspec1_node := n_sa_level;
                END;
            (*ENDWITH*) 
            acv.a_ap_tree^[ keyspec1_node ].n_lo_level := keyspec2_node;
            keyspec1_node := keyspec2_node;
            keyspec2_node := acv.a_ap_tree^[ keyspec2_node ].n_sa_level
            END;
        (*ENDWHILE*) 
        WITH acv.a_ap_tree^[ keyspec2_node ] DO
            BEGIN
            n_proc    := a64;
            n_subproc := cak_x_predicate;
            n_symb    := s_equal;
            acv.a_ap_tree^[ n_lo_level ].n_symb := s_columnname;
            END;
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    WITH acv.a_ap_tree^[ keyspec1_node ] DO
        BEGIN
        n_proc    := a64;
        n_subproc := cak_x_predicate;
        n_symb    := s_equal;
        acv.a_ap_tree^[ n_lo_level ].n_symb := s_columnname;
        END;
    (*ENDWITH*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak54viewjoin_get (
            VAR acv         : tak_all_command_glob;
            VAR dmli        : tak_dml_info;
            VAR vqual_basis : tak_sysbufferaddress;
            plus_stackcnt   : integer;
            plus_tabcnt     : integer);
 
VAR
      _i               : integer;
      _j               : integer;
      _multiplier      : tsp00_Int4;
      _read_idx        : integer;
      _col_ptr         : tak00_colinfo_ptr;
      _catalog_ptr     : tak_sysbufferaddress;
      _catalog_key     : tgg00_SysInfoKey;
      _do_upd_col_stat : boolean;
      _f_ok            : boolean;
      _b_err           : tgg00_BasisError;
 
BEGIN
_b_err := e_ok;
_catalog_key           := vqual_basis^.syskey;
IF  ( dmli.d_checkview )
THEN
    _catalog_key.sentrytyp := cak_eviewqual_join_check
ELSE
    _catalog_key.sentrytyp := cak_eviewqual_join;
(*ENDIF*) 
a10get_sysinfo( acv, _catalog_key, d_fix, _catalog_ptr, _b_err );
IF  _b_err <> e_ok
THEN
    a07_b_put_error( acv, _b_err, 1 )
ELSE
    BEGIN
&   ifdef trace
    t01int4( ak_sem, 'join cond   ', dmli.d_joins.jrc_cnt );
    t01int4( ak_sem, 'addnl. jcond', _catalog_ptr^.sviewqual_join.vjoincount );
&   endif
    a685expand_joinarr_ex( acv, dmli, 1 (* we have to reserve one free item *) +
          dmli.d_joins.jrc_cnt + _catalog_ptr^.sviewqual_join.vjoincount );
    IF  ( acv.a_returncode = 0 )
    THEN
        BEGIN
        _read_idx := 1;
        FOR _i := 1 TO _catalog_ptr^.sviewqual_join.vjoincount DO
            BEGIN
&           ifdef TRACE
            t01int4 (ak_sem, '_i          ', _i);
&           endif
            IF  _read_idx > cak_max_viewqual_join
            THEN
                (* record overflow handling *)
                BEGIN
                a10rel_sysinfo( _catalog_ptr );
                a06inc_linkage( _catalog_key.slinkage );
                a10get_sysinfo( acv, _catalog_key, d_fix, _catalog_ptr, _b_err );
                IF  _b_err <> e_ok
                THEN
                    a07_b_put_error( acv, _b_err, 1 );
                (*ENDIF*) 
                _read_idx := 1;
                END;
            (*ENDIF*) 
            IF  ( acv.a_returncode = 0 )
            THEN
                WITH dmli.d_joins.jrc_joinarr^[ dmli.d_joins.jrc_cnt ],
                     _catalog_ptr^.sviewqual_join.vjoin[ _read_idx ] DO
                    BEGIN
                    jo_recs[ 1 ].jop_outer_join := false;
                    jo_recs[ 1 ].jop_tableno    := j1tableno + plus_tabcnt;
                    jo_recs[ 1 ].jop_fieldno    := j1fieldno;
                    jo_recs[ 1 ].jop_startstack := j1startstack + plus_stackcnt;
                    jo_recs[ 1 ].jop_cntstack   := j1cntstack;
                    jo_recs[ 1 ].jop_propset    := j1propset;
                    jo_recs[ 1 ].jop_inoutlen   := j1inoutlen;
                    jo_recs[ 1 ].jop_outpos     := j1outpos;
                    jo_recs[ 1 ].jop_datatyp    := j1datatype;
                    jo_recs[ 1 ].jop_multiplier := csp_maxint4;
                    jo_op           := j12operator;
                    jo_col_upd_stat := 0;
                    jo_partno       := j12partno;
                    jo_no_join      := false;
                    dmli.d_joins.jrc_col_upd    := false;
                    jo_recs[ 2 ].jop_outer_join := false;
                    IF  ( j2tableno <> cak68_join_value )
                    THEN
                        jo_recs[ 2 ].jop_tableno    := j2tableno + plus_tabcnt
                    ELSE
                        jo_recs[ 2 ].jop_tableno    := j2tableno;
                    (*ENDIF*) 
                    jo_recs[ 2 ].jop_fieldno    := j2fieldno;
                    jo_recs[ 2 ].jop_startstack := j1startstack + j1cntstack +
                          plus_stackcnt;
                    jo_recs[ 2 ].jop_cntstack   := j2cntstack;
                    jo_recs[ 2 ].jop_propset    := j2propset;
                    jo_recs[ 2 ].jop_inoutlen   := j2inoutlen;
                    jo_recs[ 2 ].jop_outpos     := j2outpos;
                    jo_recs[ 2 ].jop_datatyp    := j2datatype;
                    jo_recs[ 2 ].jop_multiplier := csp_maxint4;
                    IF  ( jo_op = op_eq ) AND ( acv.a_ex_kind <> only_executing )
                    THEN
                        BEGIN
                        FOR _j := 1 TO 2 DO
                            IF  ( jo_recs[ _j ].jop_tableno <> cak68_join_value )
                                AND
                                ( acv.a_returncode = 0 )
                            THEN
                                WITH jo_recs[ _j ], vqual_basis^.sviewqual_basis.
                                     vtable[ jop_tableno - plus_tabcnt ] DO
                                    BEGIN
&                                   ifdef TRACE
                                    t01int4 (ak_sem, '_j          ', _j);
&                                   endif
                                    a10rel_sysinfo( dmli.d_sparr.pbasep );
                                    a06_systable_get( acv, d_release,
                                          vttableid, dmli.d_sparr.pbasep,
                                          c_get_all, _f_ok );
                                    IF  _f_ok
                                    THEN
                                        BEGIN
                                        a06extcolno( dmli.d_sparr.pbasep^.
                                              sbase, jop_fieldno, _col_ptr );
                                        a680multiplier_get( acv,
                                              dmli.d_sparr.pbasep,
                                              _col_ptr^, jop_propset,
                                              _multiplier, _do_upd_col_stat );
                                        IF  _do_upd_col_stat
                                        THEN
                                            BEGIN
                                            jo_col_upd_stat :=
                                                  jo_col_upd_stat + _j;
                                            dmli.d_joins.jrc_col_upd := true;
                                            END;
                                        (*ENDIF*) 
                                        jop_multiplier := _multiplier;
                                        END
                                    ELSE
                                        a07_tb_put_error( acv,e_unknown_tablename,
                                              1, vttableid )
                                    (*ENDIF*) 
                                    END;
                                (*ENDWITH*) 
                            (*ENDIF*) 
                        (*ENDFOR*) 
                        a06_systable_get( acv, d_fix,
                              dmli.d_tabarr^[ dmli.d_acttabindex ].ofromtableid,
                              dmli.d_sparr.pbasep, c_get_all, _f_ok );
                        IF  NOT _f_ok
                        THEN
                            a07_tb_put_error( acv, e_unknown_tablename,
                                  1, dmli.d_tabarr^[ dmli.d_acttabindex ].ofromtableid );
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    dmli.d_joins.jrc_cnt := succ( dmli.d_joins.jrc_cnt );
                    _read_idx := succ( _read_idx );
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        dmli.d_join := true;
&       IFDEF TRACE
        a683_output( ak_sem, dmli.d_joins );
&       ENDIF
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54_base_dml_init (
            VAR acv   : tak_all_command_glob;
            VAR dmli  : tak_dml_info;
            in_union  : boolean);
 
VAR
      _ix : integer;
 
BEGIN
IF  NOT in_union
THEN
    BEGIN
    (* PTS 1000785 E.Z. *)
    SAPDB_PascalForcedMove( sizeof( a54dmli ), sizeof( dmli ), @a54dmli, 1, @dmli, 1,
          mxak_full_dml_init );
    dmli.d_subquery_node := -1
    END
ELSE
    BEGIN
    SAPDB_PascalForcedMove( sizeof( a54dmli ), sizeof( dmli ), @a54dmli, 1, @dmli, 1,
          mxak_part_dml_init );
    dmli.d_sparr.psynfound := false;
    dmli.d_sparr.psystable := false;
    dmli.d_sparr.pbasep    := NIL;
    dmli.d_sparr.pcount    := 0;
    dmli.d_sparr.psynid    := bsp_c8;
    FOR _ix := 1 TO 3 DO
        dmli.d_sparr.px[ _ix ] := NIL;
    (*ENDFOR*) 
    dmli.d_sparr.pparsp := NIL;
    END;
(*ENDIF*) 
dmli.d_tabarr^[ 1 ] := a54onetab;
dmli.d_change.cr_colcount  := 0;
dmli.d_change.cr_was_opt   := false;
dmli.d_order_cols.ocntord  := 0;
dmli.d_group_cols.ocntord  := 0;
dmli.d_order_or_group_cols := @dmli.d_order_cols;
(* the following record-parts should be in the upper part of *)
(* dmli, because they will partly be initialized             *)
(* PTS 1111575 E.Z. *)
dmli.d_with_lock_clause   := false;
dmli.d_first_longdesc_pos := 0; (* PTS 1116837 M.Ki *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54_dml_init (
            VAR acv   : tak_all_command_glob;
            VAR dmli  : tak_dml_info;
            in_union  : boolean);
 
CONST
      c_initial_chunksize = 2;
 
VAR
 
      _cast         : RECORD
            CASE integer OF
                1 :
                    (addr: tsp00_Addr);
                3 :
                    (ptr : tak_all_from_tables_ptr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
a685init_joinarr( acv, dmli );
dmli.d_tabarr_capacity := cak_init_join_tab_size;
dmli.d_tabarr          := @dmli.d_init_tabarr;
a54_base_dml_init( acv, dmli, in_union )
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54_fixedpos (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info);
 
VAR
      new_parsinfo : boolean;
      parsinfo_ptr : ^tak_parsinforecord;
 
BEGIN
IF  NOT ( dmli.d_only_sem_check )
THEN
    BEGIN
&   ifdef trace
    t01int4( ak_sem, 'mb_data_len ', acv.a_mblock.mb_data_len );
    t01int4( ak_sem, 'd_maxlen    ', dmli.d_maxlen );
&   endif
    parsinfo_ptr := @dmli.d_sparr.pparsp^.sparsinfo;
    WITH acv.a_mblock, mb_data^ DO
        BEGIN
        dmli.d_movebefore := 0;
        new_parsinfo := true;
        IF  ( parsinfo_ptr^.p_cnt_infos > 0 )
        THEN
            WITH parsinfo_ptr^.p_pars_infos[ parsinfo_ptr^.p_cnt_infos ] DO
                BEGIN
&               ifdef trace
                t01fp_kind( ak_sem, 'fp_kind     ', @fp_kind );
&               endif
                IF  fp_kind = fp_fill_part2_to_len
                THEN
                    BEGIN
&                   ifdef trace
                    t01int4( ak_sem, 'fp_len      ', fp_len );
&                   endif
                    IF  fp_len = dmli.d_maxlen + mb_data_len
                    THEN
                        new_parsinfo := false;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  new_parsinfo
        THEN
            BEGIN
            IF  parsinfo_ptr^.p_cnt_infos >= parsinfo_ptr^.p_max_infos
            THEN
                BEGIN
                a55realloc_parsinfo( acv, dmli.d_sparr.pparsp );
                IF  acv.a_returncode = 0
                THEN
                    parsinfo_ptr := @dmli.d_sparr.pparsp^.sparsinfo
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  acv.a_returncode = 0
            THEN
                WITH parsinfo_ptr^.p_pars_infos[ parsinfo_ptr^.p_cnt_infos+1 ] DO
                    BEGIN
                    fp_kind        := fp_fill_part2_to_len;
                    fp_etype       := st_dummy;
                    fp_datatyp     := dunknown;
                    fp_colset      := [  ];
                    fp_fill_71     := csp_maxint4;
                    fp_fill_72     := csp_maxint4;
                    fp_fill_73     := csp_maxint2;
                    fp_len         := dmli.d_maxlen + mb_data_len;
                    dmli.d_maxlen  := 0;
                    mb_data_len := fp_len;
                    parsinfo_ptr^.p_cnt_infos := parsinfo_ptr^.p_cnt_infos + 1
                    END
                (*ENDWITH*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDWITH*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a54_optim_select_fetch ( VAR acv : tak_all_command_glob) : boolean;
 
BEGIN
WITH acv DO
    a54_optim_select_fetch :=
          (
          a_check_scrollableoption                     OR
          ((NOT a_check_scrollableoption)         AND
          a_initial_segment_header.sp1c_prepare   AND
          ( a_sqlmode = sqlm_oracle ))
          )
          AND
          (a_init_ex_kind = only_parsing)
          AND
          ((a_precomp_info_byte = csp1_p_mselect_found )       OR
          (* ( a_precomp_info_byte = csp1_p_reuse_mselect_found ) OR *)
          ( a_precomp_info_byte = csp1_p_mass_select_found )   (* OR
          ( a_precomp_info_byte = csp1_p_reuse_mass_select_found ) *) )
          AND
          (acv.a_recursive_state <> rs_check_select_list)
          AND
          (a_max_intern_select = a_intern_select_cnt)
          AND
          ( a_comp_type <> at_unknown )
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54_get_pparsp_pinfop (
            VAR acv   : tak_all_command_glob;
            VAR sparr : tak_syspointerarr;
            mtype     : tgg00_MessType);
 
VAR
      e       : tgg00_BasisError;
      i       : integer;
      start   : integer;
      count   : integer;
      ke      : tgg00_SysInfoKey;
      tempkey : tgg00_SysInfoKey;
      maxlen  : integer;
 
BEGIN
&IFDEF TRACE
t01messtype( ak_sem, 'old p_kind  ', acv.a_pars_last_key.p_kind );
t01int4( ak_sem, 'iso_info    ', ord( acv.a_isolation_info ));
&ENDIF
IF  ord( acv.a_pars_last_key.p_id[ 1 ]) < cak00_maxsubqueries
THEN
    acv.a_pars_last_key.p_id[ 1 ] := chr( ord( acv.a_pars_last_key.p_id[ 1 ]) + 1 )
ELSE
    a07_b_put_error( acv, e_too_many_subqueries, 1 );
(*ENDIF*) 
acv.a_pars_last_key.p_kind    := mtype;
acv.a_pars_last_key.p_no      := 0;
IF  acv.a_command_kind <> union_in_sub_command
THEN
    acv.a_first_parsid := acv.a_pars_last_key.p_id[ 1 ];
&IFDEF TRACE
(*ENDIF*) 
t01int4( ak_sem, 'first_pid 1 ', ord( acv.a_first_parsid ));
t01messtype( ak_sem, 'new p_kind  ', acv.a_pars_last_key.p_kind );
&ENDIF
IF  ( acv.a_command_kind = complex_view_command )   OR
    ( acv.a_command_kind = subquery_command )       OR
    ( acv.a_command_kind = sub_in_complex_command ) OR
    ( acv.a_command_kind = sub_in_union_command )   OR
    ( acv.a_command_kind = link_command )           (*OR
          ( acv.a_command_kind = corr_in_union_command )*)
THEN
    ak54complexrec_get( acv );
(*ENDIF*) 
ke              := a01sysnullkey;
ke.sentrytyp    := cak_eparsinfo;
ke.sauthid[ 1 ] := cak_tempinfo_byte;
SAPDB_PascalForcedMove( sizeof( acv.a_pars_last_key ), sizeof( ke.sauthid ),
      @acv.a_pars_last_key, 1, @ke.sauthid, 2, mxak_parskey );
IF  ( acv.a_isolation_info = temp_lock_rec_needed )
    AND
    ( acv.a_returncode = 0 )
THEN
    BEGIN
    tempkey          := ke;
    tempkey.sauthid  := cgg_zero_id;
    tempkey.slinkage := cak_temp_info_linkage;
    a10_nil_get_sysinfo( acv, tempkey, d_release,
          cak_sysbufferoffset + mxak_pars_header + 8, sparr.pparsp, e );
    IF  e = e_ok
    THEN
        BEGIN
        a54init_lock_parsinfo( acv, sparr.pparsp );
        a10add_sysinfo( acv, sparr.pparsp, e );
        END;
    (*ENDIF*) 
    IF  e <> e_ok
    THEN
        a07_b_put_error( acv, e, acv.a_cmd_part^.sp1p_buf_len )
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    maxlen := sizeof( tak_parsinforecord ) -
          sizeof( sparr.pparsp^.sparsinfo.p_pars_infos ) +
          ( acv.a_count_variab + cak_additional_parsinfos +
          2*acv.a_no_of_likes ) * sizeof( tak_field_pars );
    IF  maxlen > sizeof( tak_parsinforecord )
    THEN
        maxlen := sizeof( tak_parsinforecord );
    (* *)
    (* no_of_likes : the number of parameters which may *)
    (* be in the parsinfo three times because of like   *)
    (* with parameter and with column on the left side  *)
    (* *)
    (*ENDIF*) 
    a10_nil_get_sysinfo( acv, ke, d_fix, maxlen, sparr.pparsp, e );
    IF  ( e <> e_ok )
    THEN
        a07_b_put_error( acv, e, acv.a_cmd_part^.sp1p_buf_len )
    ELSE
        BEGIN
&       IFDEF TRACE
        t01buf( ak_sem, sparr.pparsp^, 4, 12 );
&       ENDIF
        sparr.pparsp^.sparsinfo.p_sqlmode   := acv.a_sqlmode;
        sparr.pparsp^.sparsinfo.p_own_trans := false;
        (* sharedSQL couldn't change parseinfo at execution *)
        IF  acv.a_parsingForSharedSql
        THEN
            sparr.pparsp^.sparsinfo.p_parsing_again := false
        ELSE
            sparr.pparsp^.sparsinfo.p_parsing_again := acv.a_parsing_again;
        (*ENDIF*) 
        IF  ( mtype <> m_begin ) AND
            ( mtype <> m_close ) AND
            ( mtype <> m_partial_rollback )
        THEN
            BEGIN
            WITH sparr.pparsp^.sparsinfo DO
                BEGIN
                p_cnt_infos        := 0;
                p_max_infos        :=
                      ( maxlen - ( sizeof( tak_parsinforecord ) -
                      sizeof( sparr.pparsp^.sparsinfo.p_pars_infos ))) DIV
                      sizeof( tak_field_pars );
                p_mtyp             := m_nil;
                p_mtyp2            := mm_nil;
                p_int_res_cnt      := acv.a_intern_select_cnt;
                p_p_no             := 0;
                p_reuse            := false;
                p_single           := false;
                p_longliteral      := false;
                p_subcntlevel      := - 1;
                p_searchname       := a01_il_b_identifier;
                p_modul_name       := acv.a_modul_name;
                p_statement_kind   := acv.a_statement_kind;
                p_function_code    := acv.a_return_segm^.sp1r_function_code;
                p_prepare          := acv.a_initial_segment_header.sp1c_prepare;
                p_bool_states      := [];
                p_filler1          := false;
                p_session_isolevel := acv.a_iso_level;
                p_use_sess_isolevel:= false;
                IF  ( NOT ( mtype in [ m_commit, m_rollback,
                    m_lock, m_unlock, m_fetch, m_mfetch,
                    m_describe, m_stamp,
                    (* PTS 1102256 E.Z. *)
                    (* PTS 1110021 E.Z. *)
                    (* PTS 1120287 E.Z. *)
                    m_flush, m_get_object ]))
                    AND
                    ( sparr.pbasep <> NIL )
                THEN
                    WITH sparr.pbasep^ DO
                        BEGIN
&                       IFDEF TRACE
                        FOR i := 1 TO KEY_MXSP00 + sbase.blenfixedcol DO
                            acv.a_mblock.mb_data^.mbp_buf[ cgg_rec_key_offset+i ] :=
                                  csp_defined_byte;
                        (*ENDFOR*) 
&                       ENDIF
                        (* PTS 1124835 E.Z. *)
                        p_use_sess_isolevel:= true;
                        p_treeid      := sbase.btreeid;
                        p_pagecnt     := a28prim_pages( acv, sbase );
                        p_tabid     := syskey.stableid;
                        END
                    (*ENDWITH*) 
                ELSE
                    BEGIN
                    p_treeid      := b01niltree_id;
                    p_pagecnt     := csp_maxint4;
                    p_tabid       := cgg_zero_id;
                    END;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
            ke.sentrytyp := cak_eshortinfo;
            (* PTS 1103425 E.Z. *)
            IF  ( acv.a_union_cnt = 0 )
                AND
                ( acv.a_recursive_state <> rs_recursive_select )
                AND
                ( acv.a_recursive_state <> rs_last_select )
            THEN
                BEGIN
                IF  ( acv.a_qualified_jv_upd = no_jv_upd )
                    AND (acv.a_shortinfo_key = cgg_zero_id)
                THEN
                    BEGIN
                    acv.a_shortinfo_key := ke.sauthid;
&                   IFDEF TRACE
                    t01int4( ak_sem, 'count_variab', acv.a_count_variab );
&                   ENDIF
                    (* PTS 1105338 E.Z. *)
                    IF  acv.a_init_info_output OR
                        a54_optim_select_fetch( acv )
                        OR
                        ((acv.a_recursive_state = rs_first_select) AND acv.a_check_scrollableoption)
                    THEN
                        BEGIN
                        maxlen := acv.a_count_variab + MAX_COL_PER_TAB_GG00;
                        IF  maxlen > cak_maxparams
                        THEN
                            maxlen := cak_maxparams;
                        (*ENDIF*) 
                        END
                    ELSE
                        maxlen := acv.a_count_variab;
                    (*ENDIF*) 
                    a10_nil_get_sysinfo( acv, ke, d_fix,
                          sizeof( tak_shortinforecord ) - sizeof( tak_paraminfoarr ) +
                          maxlen * sizeof( tsp1_param_info ),
                          sparr.pinfop, e );
                    IF  ( e = e_ok )
                    THEN
                        BEGIN
                        sparr.pinfop^.sshortinfo.sicount := 0;
                        sparr.pinfop^.sshortinfo.sisl    := acv.a_count_variab;
                        IF  acv.a_variable_input
                        THEN
                            WITH sparr.pinfop^.sshortinfo DO
                                FOR i := 1 TO acv.a_count_variab DO
                                    BEGIN
                                    IF  i > acv.a_first_output_param
                                    THEN
                                        siinfo[ i ].sp1i_param_no  := i - acv.a_count_output_params
                                    ELSE
                                        siinfo[ i ].sp1i_param_no  := i;
                                    (*ENDIF*) 
                                    siinfo[ i ].sp1i_read_only := false;
                                    siinfo[ i ].sp1i_serial    := false;
                                    END;
                                (*ENDFOR*) 
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    ke.sauthid := acv.a_shortinfo_key;
                    a10_fix_len_get_sysinfo( acv, ke, d_fix,
                          0, sizeof( tsp1_param_info ) * acv.a_count_variab,
                          sparr.pinfop, e );
                    END;
                (*ENDIF*) 
                IF  ( e <> e_ok )
                THEN
                    BEGIN
                    a10_key_del( acv, sparr.pparsp^.syskey );
&                   ifdef trace
                    sparr.pparsp := NIL;
&                   endif
                    a07_b_put_error( acv, e,
                          acv.a_cmd_part^.sp1p_buf_len )
                    END
                ELSE
                    WITH sparr.pinfop^.sshortinfo DO
                        BEGIN
                        start := sicount + 1;
                        count := sicount + acv.a_count_variab;
                        FOR i := start TO count DO
                            siinfo[ i ].sp1i_data_type := dunknown;
                        (*ENDFOR*) 
                        IF  acv.a_variable_input
                        THEN
                            FOR i := start TO count DO
                                BEGIN
                                IF  i > acv.a_first_output_param
                                THEN
                                    siinfo[ i ].sp1i_param_no  := i - acv.a_count_output_params
                                ELSE
                                    siinfo[ i ].sp1i_param_no  := i;
                                (*ENDIF*) 
                                siinfo[ i ].sp1i_read_only := false;
                                siinfo[ i ].sp1i_serial    := false;
                                END;
                            (*ENDFOR*) 
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54_in_buf (
            VAR acv         : tak_all_command_glob;
            VAR dmli        : tak_dml_info;
            VAR vqual_stack : tak_sysbufferaddress;
            viewdatalen     : integer;
            qual_pos        : integer;
            stcount         : integer;
            viewdatapos     : integer;
            plustabpos      : integer);
 
VAR
      _b_err       : tgg00_BasisError;
      _catalog_key : tgg00_SysInfoKey;
      _catalog_ptr : tak_sysbufferaddress;
      _firstpos    : integer;
      _rel_pos     : integer;
      _aux_len     : integer;
      _move_len    : integer;
      _j           : integer;
      _mb_data_pos : tsp00_Int4;
      _rest_len    : integer;
 
BEGIN
IF  ( vqual_stack = NIL ) OR
    ( acv.a_mblock.mb_data_len + viewdatalen > acv.a_mblock.mb_data_size )
THEN
    BEGIN
    IF  vqual_stack = NIL
    THEN
        a07_b_put_error( acv, e_sysinfo_not_found, 1 )
    ELSE
        a07_b_put_error( acv, e_too_many_mb_data, 1 );
    (*ENDIF*) 
    END
ELSE
    BEGIN
&   ifdef trace
    t01int4( ak_sem, 'vdatalen    ', viewdatalen );
    t01int4( ak_sem, 'vdatapos    ', viewdatapos );
    t01int4( ak_sem, 'stcount     ', stcount );
    t01int4( ak_sem, 'qual_pos    ', qual_pos );
    t01messblock( ak_sem, 'in_buf am 1 ', acv.a_mblock );
&   endif
    IF  ( viewdatalen > 0 )
    THEN
        BEGIN
        (* get correct catalog record *)
        _rel_pos := vqual_stack^.sviewqual_stack.vdatapos;
        _catalog_key           := vqual_stack^.syskey;
        _catalog_key.slinkage  := cak_init_linkage;
        WHILE _rel_pos > cak_max_viewqual_data DO
            BEGIN
            a06inc_linkage( _catalog_key.slinkage );
            (* calculate relative position in record *)
            _rel_pos := _rel_pos - cak_max_viewqual_data;
            END;
        (*ENDWHILE*) 
&       ifdef trace
        t01int4( ak_sem, 'rel recpos  ', _rel_pos );
&       endif
        a10get_sysinfo( acv, _catalog_key, d_release, _catalog_ptr, _b_err );
        _rest_len    := viewdatalen;
        _mb_data_pos := acv.a_mblock.mb_data_len + 1;
        WHILE ( _rest_len > 0 ) AND ( _b_err = e_ok ) DO
            BEGIN
            IF  _rest_len > cak_max_viewqual_data - ( _rel_pos - 1 )
            THEN
                _move_len := cak_max_viewqual_data - ( _rel_pos - 1 )
            ELSE
                _move_len := _rest_len;
            (*ENDIF*) 
&           ifdef trace
            t01int4( ak_sem, 'move length ', _move_len );
            t01int4( ak_sem, 'rest length ', _rest_len );
            t01moveobj( ak_sem, _catalog_ptr^.sviewqual_stack.vdata,
                  _rel_pos, _rel_pos + _move_len - 1 );
&           endif
            SAPDB_PascalMove ('VAK54 ',   1,    
                  sizeof( vqual_stack^.sviewqual_stack.vdata ),
                  acv.a_mblock.mb_data_size,
                  @_catalog_ptr^.sviewqual_stack.vdata, _rel_pos,
                  @acv.a_mblock.mb_data^.mbp_buf, _mb_data_pos, _move_len,
                  acv.a_returncode );
            _rest_len    := _rest_len - _move_len;
            _mb_data_pos := _mb_data_pos + _move_len;
            _rel_pos     := 1;
            IF  _rest_len > 0
            THEN
                BEGIN
                a06inc_linkage( _catalog_key.slinkage );
                a10get_sysinfo( acv, _catalog_key, d_release, _catalog_ptr, _b_err );
                END;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        IF  _b_err <> e_ok
        THEN
            a07_b_put_error( acv, _b_err, 1 );
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    _firstpos := 0;
    FOR _j := qual_pos TO qual_pos + stcount - 1 DO
        WITH acv.a_mblock.mb_st^[ _j ] DO
            IF  etype in [ st_fixkey, st_varkey, st_fixcol, st_varcol,
                st_varlongchar ]
            THEN
                ecol_tab[ 2 ] := chr( ord( ecol_tab[ 2 ] ) + plustabpos )
            ELSE
                IF  ( etype in [ st_value, st_date, st_time, st_timestamp,
                    (* PTS 1116175 E.Z. *)
                    st_utcdate,
                    (* PTS 1109925 E.Z. *)
                    st_utcdiff,
                    st_uid, st_user, st_usergroup, st_current_schema, st_localsysdba,
                    st_sysdba, st_language, st_format, st_transaction,
                    st_timezone (* PTS 1122262 E.Z. *)
                    ,
                    st_dummy])
                THEN
                    BEGIN
                    IF  _firstpos = 0
                    THEN
                        _firstpos := epos;
                    (*ENDIF*) 
                    epos := epos - _firstpos + acv.a_mblock.mb_data_len + 1;
                    IF  (NOT (etype in [st_value, st_dummy]) AND
                        NOT dmli.d_view )
                    THEN
                        IF  (( acv.a_ex_kind = only_parsing ) AND
                            (
                            (* PTS 1122262 E.Z. *)
                            ( etype = st_date )       OR
                            ( etype = st_time )       OR
                            ( etype = st_timestamp)   OR
                            ( etype = st_utcdate )    OR
                            ( etype = st_utcdiff )    OR
                            ( etype = st_transaction) OR
                            ( etype = st_timezone)    OR
                            ( etype = st_current_schema)
                            ))
                        THEN
                            BEGIN
                            _aux_len := acv.a_mblock.mb_data_len;
                            acv.a_mblock.mb_data_len := epos - 1;
                            a54_fixedpos( acv, dmli );
                            acv.a_mblock.mb_data_len := _aux_len;
                            a54datetime_parsinfo( acv, dmli, _j );
                            END
                        ELSE
                            a54_internal_function( acv, acv.a_mblock, _j );
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDFOR*) 
    acv.a_mblock.mb_data_len := acv.a_mblock.mb_data_len + viewdatalen;
&   ifdef TRACE
    t01messblock( ak_sem, 'in_buf am 2 ', acv.a_mblock );
&   endif
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54_init;
 
VAR
      i : integer;
 
BEGIN
WITH a54dmli DO
    BEGIN
    d_upd_set    := [  ];
    d_foundset   := [  ];
    d_user       := a01_il_b_identifier;
    d_table      := a01_il_b_identifier;
    d_column     := a01_il_b_identifier;
    d_refname    := a01_il_b_identifier;
    d_fromtabnode:= 0; (* PTS 1128197 D.T. *)
    d_columnindex:= 0;
    d_colptr     := NIL;
    d_colbuf     := NIL;
    WITH d_sparr DO
        BEGIN
        psynfound := false;
        psystable := false;
        pcount    := 0;
        psynid    := bsp_c8;
        FOR i := 1 TO cak_maxpcount DO
            px[ i ] := NIL;
        (*ENDFOR*) 
        pparsp    := NIL;
        pbasep    := NIL;
        pinfop    := NIL;
        (* PTS 1111575 E.Z. *)
        pcolnamep := NIL;
        END;
    (*ENDWITH*) 
    d_esparr             := d_sparr;
    d_pargeslen          := 0;
    d_movebefore         := cgg_rec_key_offset;
    d_maxlen             := 0;
    d_index              := 0;
    d_inoutpos           := 0;
    d_vppos              := 0;
    d_parnum             := 0;
    d_cntfromtab         := 0;
    d_acttabindex        := 0;
    d_fieldno            := 0;
    d_keylen             := 0;
    d_outcolno           := 0;
    d_checkview          := false;
    d_join_dml           := false;
    d_pseudo_ins_select  := false;
    d_exprno             := 0;
    d_colindex           := 0;
    d_first_tab          := 0;
    d_reclen             := 0;
    d_standard           := false;
    d_wherepart          := false;
    d_range              := false;
    d_nullkey            := false;
    d_like               := false;
    d_like_optimize      := false;
    d_key                := false;
    d_single             := false;
    d_use_order          := false;
    d_arith_where        := false;
    d_join               := false;
    d_reuse              := false;
    d_group              := false;
    d_having             := false;
    d_all_count          := false;
    d_repl_reskey        := false;
    d_datatype           := dunknown;
    d_udt_datatype       := cgg_zero_c2;
    d_allowed            := only_one_tab;
    d_pars_kind          := fp_val_varcol_with_len;
    d_maxcounttabs       := 0;
    d_basetabno          := 0;
    d_topos              := 0;
    d_in_method_param    := false;
    d_corr               := no_correlation;
    d_lowpars            := csp_maxint1;
    FOR i := 1 TO cak_maxcorlevel DO
        d_level[ i ] := 0;
    (*ENDFOR*) 
    d_oldlowpars   := 0;
    d_filled_bytes := 0;
    d_n_pos        := 0;
    d_expand       := 0;
    d_concat       := false;
    d_hex          := false;
    d_first_union  := false;
    d_resbuf_addr  := NIL;
    d_qual_kind    := primary_only;
    d_dist_optim   := NO_DISTINCT_OPTIM_GG07;
    d_single_expr      := false;
    d_like_expression  := false;
    d_prep_corr_cols   := false;
    d_escape_char      := csp_unicode_blank;
    d_escape           := false;
    d_execute_unlock   := false;
    d_change_date_time := true;
    d_mselect_loop_cnt := cgg04_first_and_only_of_all;
    d_mselect_rescnt   := 0;
    d_viewdesc_linkage := cak_init_linkage;
    d_view_col_list    := false;
    d_view_col_node    := 0;
    d_massdata_ptr        := NIL;
    d_local_massdata_part := false;
    d_further_fill1       := false;
    d_longlitcount        := 0;
    d_union_limit_n       := 0;
    d_initial_ex_parskey.p_count[1] := chr(0);
    d_initial_ex_parskey.p_count[2] := chr(0);
    d_initial_ex_parskey.p_count[3] := chr(0);
    d_resname             := a01_zero_res_name;
    d_oj_tables           := [  ];
    (* initialisations used when NOT in_union *)
    d_globstate           := [  ];
    d_unchanged_globstate := [  ];
    d_tableid             := b01niltree_id.fileTabId_gg00;
    d_table_as_id         := b01niltree_id.fileTabId_gg00;
    d_viewusername        := a01_il_b_identifier;
    d_viewtablen          := a01_il_b_identifier;
    d_use_sub             := false;
    d_resname_found       := false;
    d_distinct            := no_distinct;
    d_view                := false;
    d_subquery            := false;
    d_only_sem_check      := false;
    d_cntpar              := 0;
    d_rowno               := cgg04_no_rowno_predicate; (* PTS 1122921 E.Z. *)
    d_limit_offset        := cgg04_no_rowno_predicate;
    d_upper_limit         := cgg04_no_rowno_predicate;
    d_subcount            := 0;
    d_sublevel            := csp_maxint1;
    d_phase_cnt           := 1;
    d_pos_result          := 0;
    d_global_pos_result   := cak_is_undefined;
    d_viewtextbuf         := NIL;
    d_act_node            := 0;
    d_union_order_n       := 0;
    d_linkbuf             := NIL;
    d_viewdescbuf         := NIL;
    d_literalrec          := NIL;
    d_union               := false;
    d_union_insert        := false;
    d_outer_join          := false;
    d_repl_nokey_ins_sel  := false;
    d_is_function_column  := false;
    d_longdesc_found      := false;
    d_first_longdesc_pos  := 0;
    d_cnt_longdesc        := 0;
    d_with_lock_clause    := false;
    d_in_case_function    := false;
    d_where_corr          := false;
    d_type_long_allowed   := false;
    d_optimize_setfunction:= true;
    d_only_table_scan     := false;
    d_const_value_expr    := false;
    d_is_parameter_only   := false;
    d_strat_info          := ir_v_acc;
    d_truncate            := false;
    d_one_join_phase      := false;
    d_check_null_byte     := false;
    d_ins_sel_tabid       := cgg_zero_id;
    d_align_fill1         := false;
    d_specialjoinfromselect   := false; (* PTS 1138343 D.T. *)
    d_parameter_count     := 0;
    d_where_subquery       := false;
    d_where_corr_subquery  := false;
    d_having_subquery      := false;
    d_having_corr_subquery := false;
    END;
(*ENDWITH*) 
WITH a54onetab DO
    BEGIN
    ouser         := a01_il_b_identifier;
    otable        := a01_il_b_identifier;
    ospecialname  := [  ];
    oview         := false;
    otreeid       := b01niltree_id;
    ofromtableid  := otreeid.fileTabId_gg00;
    oprivset      := [  ];
    osetallpriv   := [  ];
    oall_priv     := false;
    ospecs_needed := ons_only_tablename;
    ocomplex_view := false;
    ocounttabs    := 0;
    oattributes   := [  ];
    ounused0      := 0;
    ounused1      := 0;
    ounused2      := 0;
    oreference    := a01_il_b_identifier;
    oviewqual     := false;
    oviewcheck    := false
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54_internal_function (
            VAR acv : tak_all_command_glob;
            VAR m : tgg00_MessBlock;
            st_no : integer);
 
CONST
      c_use_acv_timestamp = true;
 
BEGIN
&ifdef trace
t01int4( ak_sem, 'st_no       ', st_no );
t01int4( ak_sem, 'epos        ', m.mb_st^[ st_no ].epos );
t01int4( ak_sem, 'df_length   ', acv.a_nls_params.df_length );
&endif
(* PTS 1113244 *)
a54InternalFunction (acv, m.mb_st^[ st_no ], m.mb_data^.mbp_buf,
      m.mb_data_size, m.mb_st^[ st_no ].epos, c_use_acv_timestamp);
m.mb_st^[ st_no ].etype := st_value
END;
 
(* PTS 1113244 *)
(*------------------------------*) 
 
PROCEDURE
      a54InternalFunction (
            VAR acv           : tak_all_command_glob;
            VAR StackEntry    : tgg00_StackEntry;
            VAR dataBuf       : tsp00_MoveObj;
            dataBufSize       : integer;
            dataBufPos        : integer;
            use_acv_timestamp : boolean);
 
VAR
      i            : tsp00_Int4;
      l            : tsp00_Int4;
      maxlen       : tsp00_Int4;
      data_len     : integer;
      utcdiff      : tsp00_Longreal;
      utctimestamp : tsp00_Timestamp;
      identifier   : tsp00_KnlIdentifier;
      num_err      : tsp00_NumError;
      srccode      : tsp00_Int2;
      destcode     : tsp00_Int2;
      err_char_no  : tsp00_Int4;
      uni_err      : tsp8_uni_error;
      timestamp    : tsp00_Timestamp;
 
BEGIN
WITH StackEntry DO
    BEGIN
    IF  ( etype = st_date ) OR
        ( etype = st_time ) OR
        ( etype = st_timestamp )
    THEN
        IF  use_acv_timestamp
        THEN
            BEGIN
            IF  acv.a_timestamp = bsp_c20
            THEN
                vtimestamp( acv.a_timestamp );
            (*ENDIF*) 
            timestamp := acv.a_timestamp
            END
        ELSE
            vtimestamp( timestamp );
        (*ENDIF*) 
    (*ENDIF*) 
    l := 0;
    CASE etype OF
        st_date :
            BEGIN
            dataBuf[ dataBufPos ] := csp_ascii_blank;
            l := mxsp_date;
            SAPDB_PascalMove('VAK54 ',   2,    
                  sizeof( timestamp ), dataBufSize,
                  @timestamp, 1, @dataBuf, dataBufPos + 1, l,
                  acv.a_returncode );
            END;
        st_time :
            BEGIN
            dataBuf[ dataBufPos ] := csp_ascii_blank;
            l := mxsp_time;
            dataBuf[ dataBufPos + 1 ] := '0';
            dataBuf[ dataBufPos + 2 ] := '0';
            SAPDB_PascalMove('VAK54 ',   3,    
                  sizeof( timestamp ), dataBufSize,
                  @timestamp, mxsp_date + 1,
                  @dataBuf, dataBufPos + 3, l - 2,
                  acv.a_returncode );
            END;
        st_timestamp :
            BEGIN
            dataBuf[ dataBufPos ] := csp_ascii_blank;
            l := mxsp_timestamp;
            SAPDB_PascalMove('VAK54 ',   4,    
                  sizeof( timestamp ), dataBufSize,
                  @timestamp, 1, @dataBuf, dataBufPos + 1, l,
                  acv.a_returncode );
            END;
        (* PTS 1116175 E.Z. *)
        st_utcdate :
            BEGIN
            vUTCtimestamp (utctimestamp);
            dataBuf[ dataBufPos ] := csp_ascii_blank;
            l := mxsp_timestamp;
            SAPDB_PascalMove('VAK54 ',   5,    
                  sizeof( utctimestamp ), dataBufSize,
                  @utctimestamp, 1, @dataBuf, dataBufPos + 1, l,
                  acv.a_returncode );
            END;
        (* PTS 1109925 E.Z. *)
        st_utcdiff :
            BEGIN
            dataBuf[ dataBufPos ] := csp_defined_byte;
            l := (cak_utcdiff_len + 1) DIV 2 + 2;
            utcdiff := vTimeZoneDelta;
&           ifdef TRACE
            t01real (ak_sem, 'utcdiff     ', utcdiff, cak_utcdiff_len);
&           endif
            s41plrel (dataBuf, dataBufPos + 1, cak_utcdiff_len, cak_utcdiff_frac,
                  utcdiff, num_err);
            IF  num_err <> num_ok
            THEN
                a07_b_put_error(  acv, e_num_invalid, 1 );
            (*ENDIF*) 
            elen_var := l
            END;
        (* PTS 1122262 E.Z. *)
        st_timezone :
            BEGIN
            l := cak_time_durationlen;
            utcdiff := vTimeZoneDelta;
            (* from fixed (4,2) example 8,5 --> duration example 083000 *)
            utcdiff := trunc(utcdiff) * 10000 +
                  (utcdiff - trunc(utcdiff)) * 6000;
            s41plrel (dataBuf, dataBufPos + 1, cak_time_durationlen, 0,
                  utcdiff, num_err);
            IF  num_err <> num_ok
            THEN
                a07_b_put_error(  acv, e_num_invalid, 1 );
            (*ENDIF*) 
            elen_var := l
            END;
        st_format :
            BEGIN (* Note, that date_format includes the defined byte. *)
            l := acv.a_nls_params.df_length;
            SAPDB_PascalMove('VAK54 ',   6,    
                  sizeof( acv.a_nls_params.date_format ), dataBufSize,
                  @acv.a_nls_params.date_format, 1,
                  @dataBuf, dataBufPos, l,
                  acv.a_returncode );
            elen_var := l
            END;
        st_language :
            BEGIN
            dataBuf[ dataBufPos ] := csp_ascii_blank;
            l := mxsp_c3;
            IF  acv.a_sqlmode = sqlm_oracle
            THEN
                SAPDB_PascalMove('VAK54 ',   7,    
                      sizeof( acv.a_nls_params.date_language ),
                      dataBufSize, @acv.a_nls_params.date_language, 1,
                      @dataBuf, dataBufPos + 1, l,
                      acv.a_returncode )
            ELSE
                SAPDB_PascalMove('VAK54 ',   8,    
                      sizeof( acv.a_ak_language ), dataBufSize,
                      @acv.a_ak_language, 1, @dataBuf,
                      dataBufPos + 1, l, acv.a_returncode );
            (*ENDIF*) 
            END;
        st_user,
        st_usergroup,
        st_localsysdba,
        st_sysdba,
        st_current_schema :
            BEGIN
            CASE etype OF
                st_user :
                    identifier := acv.a_acc_user;
                st_usergroup :
                    identifier := acv.a_curr_user_name;
                (* PTS 1111797 E.Z. *)
                st_localsysdba, st_sysdba :
                    identifier := g01glob.sysuser_name;
                st_current_schema :
                    identifier := acv.a_curr_schema;
                END;
            (*ENDCASE*) 
            dataBuf[ dataBufPos ] := ecol_tab[ 2 ];
            IF  g01unicode
            THEN
                BEGIN
                l := s30unilnr( @identifier, csp_unicode_blank,
                      1, sizeof( identifier ));
                srccode := csp_unicode;
                IF  ecol_tab[ 2 ] = csp_unicode_def_byte
                THEN
                    destcode := csp_unicode
                ELSE
                    destcode := csp_ascii
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                l := s30klen( identifier, bsp_c1, sizeof( identifier ));
                srccode := csp_ascii;
                IF  ecol_tab[ 2 ] = csp_unicode_def_byte
                THEN
                    destcode := csp_unicode
                ELSE
                    destcode := csp_ascii
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  srccode <> destcode
            THEN
                BEGIN
                maxlen := sizeof( tsp00_KnlIdentifier );
                s80uni_trans( @identifier, l, srccode,
                      @dataBuf[ dataBufPos + 1 ],
                      maxlen, destcode,
                      [ ], uni_err, err_char_no );
                IF  uni_err <> uni_ok
                THEN
                    a07_uni_error( acv, uni_err, 1 );
                (*ENDIF*) 
                l := maxlen
                END
            ELSE
                SAPDB_PascalMove('VAK54 ',   9,    
                      sizeof( identifier ), dataBufSize,
                      @identifier, 1, @dataBuf, dataBufPos + 1, l,
                      acv.a_returncode );
            (*ENDIF*) 
            elen_var := l + 1;
            ecol_tab[ 2 ] := chr( 0 )
            END;
        st_uid :
            BEGIN
            dataBuf[ dataBufPos ] := ecol_tab[ 2 ];
            data_len := ( elen_var - 2 ) * 2;
            s41plint( dataBuf, dataBufPos + 1, data_len, 0,
                  a06uid( acv.a_acc_user_id ), num_err );
            IF  num_err <> num_ok
            THEN
                a07_b_put_error(  acv, e_num_invalid, 1 )
            ELSE
                ecol_tab[ 2 ] := chr( 0 );
            (*ENDIF*) 
            END;
        st_transaction :
            BEGIN
            dataBuf[ dataBufPos ] := csp_defined_byte;
            WITH acv.a_transinf.tri_trans DO
                l := sizeof( trTransId_gg00 );
            (*ENDWITH*) 
            a05_transaction_get( acv, dataBuf,
                  dataBufPos+1, dataBufSize );
            END;
        END;
    (*ENDCASE*) 
    IF  ( ecol_tab[ 2 ] = csp_unicode_def_byte ) AND
        ( etype in [ st_date, st_time, st_timestamp ])
    THEN
        BEGIN
        FOR i := l DOWNTO 1 DO
            BEGIN
            dataBuf[ dataBufPos+2*i   ] := dataBuf[ dataBufPos+i ];
            dataBuf[ dataBufPos+2*i-1 ] := csp_unicode_mark;
            END;
        (*ENDFOR*) 
        ecol_tab[ 2 ] := chr( 0 );
        dataBuf[ dataBufPos ] := csp_unicode_def_byte;
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54_joinview_baserecords (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info);
 
VAR
      _ok        : boolean;
      _e         : tgg00_BasisError;
      _i         : integer;
      _viewp     : tak_sysbufferaddress;
      _base_ptr  : tak_sysbufferaddress;
      _ke        : tgg00_SysInfoKey;
 
BEGIN
a10rel_sysinfo( dmli.d_sparr.pbasep );
dmli.d_sparr.pbasep := NIL;
dmli.d_acttabindex  := dmli.d_cntfromtab;
IF  ( dmli.d_maxcounttabs > dmli.d_tabarr_capacity )
THEN
    a54expand_tabarr_ex( acv, dmli, dmli.d_maxcounttabs );
(*ENDIF*) 
WHILE (( dmli.d_acttabindex >= 1 ) AND ( acv.a_returncode = 0 )) DO
    BEGIN
    IF  NOT ( oisjoinview in dmli.d_tabarr^[ dmli.d_acttabindex ].ospecialname )
    THEN
        dmli.d_tabarr^[ dmli.d_tabarr^[ dmli.d_acttabindex ].ocounttabs + 1 ] :=
              dmli.d_tabarr^[ dmli.d_acttabindex ]
    ELSE
        BEGIN
        _ke           := a01defaultkey;
        _ke.stableid  := dmli.d_tabarr^[ dmli.d_acttabindex ].ofromtableid;
        _ke.sentrytyp := cak_eviewqual_basis;
        a10get_sysinfo( acv, _ke, d_fix, _viewp, _e );
        IF  _e = e_ok
        THEN
            WITH _viewp^.sviewqual_basis DO
                BEGIN
                _i := 1;
                WHILE ( _i <= vbasetabcnt ) AND ( _e = e_ok ) DO
                    WITH dmli.d_tabarr^[ dmli.d_tabarr^[ dmli.d_acttabindex ].
                         ocounttabs + _i ], vtable[ _i ] DO
                        BEGIN
                        ouser         := dmli.d_tabarr^[ dmli.d_acttabindex ].ouser;
                        otable        := dmli.d_tabarr^[ dmli.d_acttabindex ].otable;
                        ospecialname  := [ oispartjoinview ];
                        oview         := false;
                        ofromtableid  :=
                              dmli.d_tabarr^[ dmli.d_acttabindex ].ofromtableid;
                        oprivset      := a01fullset;
                        osetallpriv   := a01fullset;
                        oall_priv     := true;
                        ospecs_needed := ons_only_tablename;
                        ocomplex_view := false;
                        oreference    := a01_il_b_identifier;
                        oviewqual     := false;
                        oviewcheck    := false;
                        ocounttabs    := dmli.d_tabarr^[ dmli.d_acttabindex ].
                              ocounttabs + _i - 1;
                        a06_systable_get( acv, d_release, vttableid,
                              _base_ptr, NOT c_get_all, _ok );
                        IF  _ok
                        THEN
                            BEGIN
                            IF  _base_ptr^.sbase.bv_tablekind =
                                tcatalog_table
                            THEN
                                ospecialname :=
                                      ospecialname + [ oisshowview ];
                            (*ENDIF*) 
                            otreeid     := _base_ptr^.sbase.btreeid;
                            oattributes := _base_ptr^.sbase.battributes;
                            IF  ((( hsTempLock_egg00 in dmli.d_globstate ) OR
                                ( hsPermLock_egg00 in dmli.d_globstate )) AND
                                (NOT a101_IsExtendedTempFile (acv,
                                _base_ptr^.sbase.btreeid)) AND
                                (( _base_ptr^.sbase.btablekind = twithkey ) OR
                                ( _base_ptr^.sbase.btablekind = twithoutkey ) OR
                                ( _base_ptr^.sbase.btablekind = tonebase )))
                            THEN
                                a54add_next_temp_lock( acv, otreeid.fileTabId_gg00,
                                      dmli.d_globstate );
                            (*ENDIF*) 
                            END
                        ELSE
                            _e := e_sysinfo_not_found;
                        (*ENDIF*) 
                        _i := succ( _i );
                        END;
                    (*ENDWITH*) 
                (*ENDWHILE*) 
                IF  _e = e_ok
                THEN
                    a10_rel_sysinfo( acv, _viewp^.syskey )
                ELSE
                    a07_b_put_error( acv, _e, 1 );
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    dmli.d_acttabindex := pred( dmli.d_acttabindex );
    END;
(*ENDWHILE*) 
dmli.d_cntfromtab := dmli.d_maxcounttabs;
FOR _i := 1 TO dmli.d_cntfromtab DO
    dmli.d_tabarr^[ _i ].ocounttabs := _i - 1;
(*ENDFOR*) 
dmli.d_acttabindex := 3;
a61_rel_old_table( acv, dmli, 1 );
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54_last_part (
            VAR acv        : tak_all_command_glob;
            VAR sparr      : tak_syspointerarr;
            last_pars_part : boolean);
 
VAR
      e             : tgg00_BasisError;
      aux_m_type    : tgg00_MessType;
      aux_m2_type   : tgg00_MessType2;
      aux_treeid    : tgg00_FileId;
 
BEGIN
(* The parameters have to be this way because of column command *)
(* During read and write command the systeminformation is not known *)
WITH acv.a_mblock, sparr DO
    BEGIN
    WITH mb_qual^.mtree DO
        BEGIN
        IF  acv.a_isolation_info = temp_lock_rec_get
        THEN
            IF  hsPermLock_egg00 in fileHandling_gg00
            THEN
                fileHandling_gg00 := ( fileHandling_gg00 +
                      [ hsWithoutLock_egg00 ]) - [ hsPermLock_egg00 ]
            ELSE
                fileHandling_gg00 := fileHandling_gg00 - [ hsTempLock_egg00 ]
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    IF  acv.a_ex_kind = only_parsing
    THEN
        BEGIN
        WITH pparsp^.sparsinfo DO
            BEGIN
            IF  (( acv.a_mblock.mb_type = m_update ) OR
                ( acv.a_mblock.mb_type = m_delete ))
                AND
                ( acv.a_mblock.mb_type2 <> mm_file )
            THEN
                p_pagecnt := a28prim_pages( acv, sparr.pbasep^.sbase );
            (*ENDIF*) 
            p_single    := false;
            IF  p_mtyp <> m_key
            THEN
                p_select := false;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        a54_store_parsinfo( acv, sparr );
        IF  last_pars_part
        THEN
            a54_shortinfo_to_varpart( acv, acv.a_initial_segment_header.sp1c_prepare, pinfop )
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        aux_m_type := acv.a_mblock.mb_type;
        aux_m2_type := acv.a_mblock.mb_type2;
        IF  aux_m2_type = mm_ok_not_allowed
        THEN
            acv.a_mblock.mb_type2 := mm_compare_record;
        (*ENDIF*) 
        aux_treeid := acv.a_mblock.mb_qual^.mtree;
        a06rsend_mess_buf( acv, acv.a_mblock, cak_return_req, e );
        IF  e = e_ok
        THEN
            BEGIN
            IF  aux_m2_type = mm_ok_not_allowed
            THEN
                a07_b_put_error( acv, e_foreign_key_must_exist, 1 );
            (*ENDIF*) 
            IF  sparr.pbasep <> NIL
            THEN
                BEGIN
                (* for column write and so on not allowed *)
                a28sys_upd_statistics( acv,
                      aux_treeid, aux_m_type, aux_m2_type,
                      a28prim_pages( acv, sparr.pbasep^.sbase ),
                      acv.a_mblock.mb_qual^.mr_pagecnt )
                END
            (*ENDIF*) 
            END
        ELSE
            IF  e = e_duplicate_record
            THEN
                e := e_ok
            ELSE
                IF  ( e = e_duplicate_key ) AND
                    ( aux_m2_type = mm_compare_record )
                THEN
                    a07_b_put_error( acv, e_foreign_key_violation, 1 )
                ELSE
                    BEGIN
                    IF  (( e = e_no_next_record ) OR
                        ( e = e_key_not_found ))
                        AND
                        ( acv.a_mblock.mb_qual_len  = MB_PART1_HEAD_MXGG00 +
                        MB_PART1_RETURN_MXGG00 )
                        AND
                        ( sparr.pbasep <> NIL )
                    THEN
                        BEGIN
                        (* if not column write and so on *)
                        a28sys_upd_statistics( acv,
                              aux_treeid, aux_m_type, aux_m2_type,
                              a28prim_pages( acv, sparr.pbasep^.sbase ),
                              acv.a_mblock.mb_qual^.mr_pagecnt )
                        END;
                    (*ENDIF*) 
                    IF  ( e = e_no_next_record ) OR
                        ( e = e_key_not_found )
                    THEN
                        a07_b_put_error( acv, e, 1 )
                    ELSE
                        a07_b_put_error( acv, e,
                              acv.a_cmd_part^.sp1p_buf_len )
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54_loc_temp_locks (
            VAR acv   : tak_all_command_glob;
            globstate : tgg00_HandlingSet;
            VAR sparr : tak_syspointerarr);
 
VAR
      commands         : tak_complexrecord;
      e                : tgg00_BasisError;
      i                : integer;
      complex_lock_cnt : integer;
      tempinfo_buf     : tak_sysbufferaddress;
      parsk            : tak_parskey;
      ke               : tgg00_SysInfoKey;
      ke1              : tgg00_SysInfoKey;
 
BEGIN
IF  acv.a_intern_select_cnt = acv.a_max_intern_select
THEN
    BEGIN
    ke1 := a01sysnullkey;
    WITH ke1 DO
        BEGIN
        stableid  := cgg_zero_id;
        sentrytyp := cak_eparsinfo;
        slinkage  := cak_temp_info_linkage
        END;
    (*ENDWITH*) 
    a10get_sysinfo( acv, ke1, d_fix, tempinfo_buf, e );
    IF  e <> e_ok
    THEN
        a07_b_put_error( acv, e, 1 )
    ELSE
        IF  tempinfo_buf^.sparsinfo.p_temp_lock.all_lock_count = 0
        THEN
            BEGIN
            a10del_sysinfo( acv, tempinfo_buf^.syskey, e );
&           ifdef trace
            tempinfo_buf := NIL;
&           endif
            IF  e <> e_ok
            THEN
                a07_b_put_error( acv, e, 1 )
            ELSE
                acv.a_isolation_info := temp_lock_rec_not_needed
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            parsk             := acv.a_pars_last_key;
            parsk.p_no        := 0;
            parsk.p_id[ 1 ]   := acv.a_first_parskey;
            parsk.p_kind      := m_complex;
            ke                := a01sysnullkey;
            ke.sauthid[ 1 ]   := cak_tempinfo_byte;
            SAPDB_PascalForcedMove( sizeof( parsk ), sizeof( ke.sauthid ),
                  @parsk, 1, @ke.sauthid, 2, mxak_parskey );
            ke.sentrytyp      := cak_ecomplex;
            acv.a_complex_key := ke.stableid;
            a10get_sysinfo( acv, ke, d_release, acv.a_ptr2, e );
            IF  e <> e_ok
            THEN
                a07_b_put_error( acv, e, 1 )
            ELSE
                BEGIN
&               IFDEF TRACE
                t01buf( ak_sem, acv.a_ptr2^, 1, acv.a_ptr2^.b_sl );
&               ENDIF
                commands.compcnt := acv.a_ptr2^.scomplexrec.compcnt;
                SAPDB_PascalMove('VAK54 ',  10,    
                      sizeof( acv.a_ptr2^.scomplexrec.comparr ),
                      sizeof( commands.comparr ),
                      @acv.a_ptr2^.scomplexrec.comparr, 1,
                      @commands.comparr, 1, commands.compcnt * mxak_complex_entry,
                      acv.a_returncode );
                WITH acv, a_ptr2^, scomplexrec DO
                    BEGIN
                    compcnt := 0;
                    b_sl    := mxak_complexrecminlength - mxak_complex_entry
                    END;
                (*ENDWITH*) 
&               IFDEF TRACE
                t01buf( ak_sem, acv.a_ptr2^, 1, acv.a_ptr2^.b_sl );
&               ENDIF
                a10repl_sysinfo( acv, acv.a_ptr2, e );
                IF  e <> e_ok
                THEN
                    a07_b_put_error( acv, e, acv.a_cmd_part^.sp1p_buf_len )
                ELSE
                    BEGIN
                    a660_new_pparsp( acv, sparr,
                          NOT c_first_parsinfo, c_complicate );
                    IF  acv.a_returncode = 0
                    THEN
                        BEGIN
                        a06a_mblock_init( acv,
                              m_lock, mm_first, b01niltree_id );
                        a52_rest_lock_statement( acv, sparr,
                              tempinfo_buf^.sparsinfo.p_temp_lock,
                              NOT c_return_result, c_complicate );
                        a10del_sysinfo( acv, tempinfo_buf^.syskey, e );
&                       ifdef trace
                        tempinfo_buf := NIL;
&                       endif
                        IF  e <> e_ok
                        THEN
                            a07_b_put_error( acv, e, 1 )
                        ELSE
                            acv.a_isolation_info := temp_lock_rec_not_needed
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  acv.a_returncode = 0
            THEN
                BEGIN
                a10get_sysinfo( acv, ke, d_release, acv.a_ptr2, e );
                IF  e <> e_ok
                THEN
                    a07_b_put_error( acv, e, acv.a_cmd_part^.sp1p_buf_len )
                ELSE
                    BEGIN
&                   IFDEF TRACE
                    t01buf( ak_sem, acv.a_ptr2^, 1, acv.a_ptr2^.b_sl );
&                   ENDIF
                    IF  hsTempLock_egg00 in globstate
                    THEN
                        complex_lock_cnt := acv.a_ptr2^.scomplexrec.compcnt
                    ELSE
                        complex_lock_cnt := 0;
                    (*ENDIF*) 
                    (* PTS 1001432 E.Z. *)
                    IF  acv.a_ptr2^.scomplexrec.compcnt +
                        commands.compcnt + complex_lock_cnt > cak_maxcomplex
                    THEN
                        a07_b_put_error( acv, e_too_many_intern_cmd, 1 )
                    ELSE
                        BEGIN
                        a10_fix_len_get_sysinfo( acv, ke, d_release,
                              0, ( commands.compcnt + complex_lock_cnt )*mxak_complex_entry,
                              acv.a_ptr2, e );
                        IF  e <> e_ok
                        THEN
                            a07_b_put_error( acv, e, acv.a_cmd_part^.sp1p_buf_len )
                        ELSE
                            WITH acv.a_ptr2^, scomplexrec DO
                                BEGIN
                                SAPDB_PascalMove('VAK54 ',  11,    
                                      sizeof( commands.comparr ), sizeof( comparr ),
                                      @commands.comparr, 1, @comparr,
                                      ( compcnt * mxak_complex_entry ) + 1,
                                      commands.compcnt * mxak_complex_entry,
                                      acv.a_returncode );
                                IF  acv.a_returncode = 0
                                THEN
                                    BEGIN
                                    FOR i := 1 TO commands.compcnt DO
                                        WITH comparr[ compcnt + i ] DO
                                            cnextpars := cnextpars + compcnt;
                                        (*ENDWITH*) 
                                    (*ENDFOR*) 
                                    compcnt := compcnt + commands.compcnt;
                                    comparr[ compcnt ].centryinfo :=
                                          comparr[ compcnt ].centryinfo + [ ci_lastpars ];
                                    IF  hsTempLock_egg00 in globstate
                                    THEN
                                        BEGIN
                                        SAPDB_PascalOverlappingMove('VAK54 ',  12,    
                                              sizeof( comparr ), sizeof( comparr ),
                                              @comparr, 1, @comparr,
                                              ( compcnt * mxak_complex_entry ) + 1,
                                              complex_lock_cnt * mxak_complex_entry,
                                              acv.a_returncode );
                                        IF  acv.a_returncode = 0
                                        THEN
                                            FOR i := 1 TO complex_lock_cnt DO
                                                WITH comparr[ compcnt + i ] DO
                                                    BEGIN
                                                    centryinfo := centryinfo + [ ci_unlock ];
                                                    cnextpars := compcnt + i + 1
                                                    END;
                                                (*ENDWITH*) 
                                            (*ENDFOR*) 
                                        (*ENDIF*) 
                                        compcnt := compcnt + complex_lock_cnt;
                                        END;
                                    (*ENDIF*) 
                                    WITH acv.a_ptr2^ DO
                                        b_sl := mxak_complexrecminlength +
                                              ( compcnt - 1 ) * mxak_complex_entry;
                                    (*ENDWITH*) 
&                                   IFDEF TRACE
                                    t01buf( ak_sem, acv.a_ptr2^, 1, acv.a_ptr2^.b_sl );
&                                   ENDIF
                                    a10repl_sysinfo( acv, acv.a_ptr2, e );
                                    IF  e <> e_ok
                                    THEN
                                        a07_b_put_error( acv, e,
                                              acv.a_cmd_part^.sp1p_buf_len )
                                    (*ENDIF*) 
                                    END
                                (*ENDIF*) 
                                END
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54_put_indices_in_mess_buf (
            VAR acv     : tak_all_command_glob;
            VAR basebuf : tak_baserecord;
            VAR dfa     : tak_dfarr;
            all_indices : boolean);
 
CONST
      c_found = csp_maxint2;
 
VAR
      is_first       : boolean;
      use_index      : boolean;
      ix             : integer;
      colCount       : integer;
      index_scan_rec : tak_index_scan_record;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    WITH index_scan_rec, basebuf DO
        BEGIN
        (* put multiple column index descriptions into *)
        (* message buffer                              *)
        is_first := true;
        a24init_index_scan( acv, btreeid.fileTabId_gg00,
              index_scan_rec );
        WHILE a24next_named_index( acv, index_scan_rec ) DO
            WITH isr_buf^.smindex.indexdef[ isr_index ] DO
                BEGIN
                use_index := true;
                IF  use_index AND NOT all_indices
                THEN
                    BEGIN
                    (* check if any column of index has been updated *)
                    IF  a24IsFunctionBasedIndex(isr_buf^.smindex.indexdef[ isr_index ])
                    THEN
                        colCount := a24FunctionParameterCount (isr_buf^.smindex.indexdef[ isr_index ])
                    ELSE
                        colCount := icount;
                    (*ENDIF*) 
&                   ifdef trace
                    t01int4 (ak_sem, 'colCount    ', colCount);
&                   endif
                    ix := 1;
                    WHILE ix <= colCount DO
                        IF  dfa[ icolseq[ ix ] ].dml_node <> 0
                        THEN
                            ix := c_found
                        ELSE
                            ix := ix + 1;
                        (*ENDIF*) 
                    (*ENDWHILE*) 
                    use_index := ix = c_found
                    END;
                (*ENDIF*) 
                IF  use_index
                THEN
                    WITH acv.a_mblock, mb_qual^ DO
                        BEGIN
                        IF  is_first
                        THEN
                            BEGIN
                            is_first  := false;
                            mmult_pos := mfirst_free
                            END;
                        (*ENDIF*) 
                        IF  mfirst_free + icount <= mb_st_max
                        THEN
                            BEGIN
&                           ifdef TRACE
                            t01messblock( ak_sem, 'put_indiz 1 ', acv.a_mblock );
&                           endif
                            SAPDB_PascalMove('VAK54 ',  13,    
                                  sizeof( icolstack ), mb_st_size,
                                  @icolstack, 1,
                                  @mb_st^, ( mfirst_free - 1 ) *
                                  STACK_ENTRY_MXGG00 + 1,
                                  icount * STACK_ENTRY_MXGG00,
                                  acv.a_returncode );
                            mmult_cnt   := mmult_cnt   + icount;
                            mfirst_free := mfirst_free + icount;
&                           ifdef TRACE
                            t01messblock( ak_sem, 'put_indiz 2 ', acv.a_mblock );
&                           endif
                            END
                        ELSE
                            a07_b_put_error( acv, e_too_many_mb_stackentries,
                                  -mb_st_max )
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDWHILE*) 
        a24finish_index_scan( acv, index_scan_rec )
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54_sel_store_parsinfo (
            VAR acv        : tak_all_command_glob;
            VAR sparr      : tak_syspointerarr;
            VAR change_rec : tak_changerecord;
            last_pars_part : boolean);
 
VAR
      e                 : tgg00_BasisError;
      store_changeinfos : boolean;
      full_length       : integer;
      ke                : tgg00_SysInfoKey;
      sysbuf            : tak_sysbufferaddress;
 
BEGIN
&IFDEF TRACE
t01int4( ak_sem, 'cr_colcount ', change_rec.cr_colcount );
&ENDIF
IF  ( last_pars_part )
THEN
    BEGIN
    IF  ( change_rec.cr_colcount > 0 )
    THEN
        sparr.pparsp^.sparsinfo.p_bool_states :=
              sparr.pparsp^.sparsinfo.p_bool_states + [ pi_changeinfos_exist ]
    ELSE
        sparr.pparsp^.sparsinfo.p_bool_states :=
              sparr.pparsp^.sparsinfo.p_bool_states - [ pi_changeinfos_exist ]
    (*ENDIF*) 
    END
ELSE
    sparr.pparsp^.sparsinfo.p_bool_states :=
          sparr.pparsp^.sparsinfo.p_bool_states - [ pi_changeinfos_exist ];
(*ENDIF*) 
store_changeinfos :=
      pi_changeinfos_exist in sparr.pparsp^.sparsinfo.p_bool_states;
ke := sparr.pparsp^.syskey;
a54_store_parsinfo( acv, sparr );
IF  ( store_changeinfos )
THEN
    BEGIN
    ke.sentrytyp := cak_echangeinfos;
    full_length := sizeof( tak_changeinfos ) -
          sizeof( sysbuf^.schangeinfos.ci_ch_columns ) +
          change_rec.cr_colcount * sizeof( tak_change_colinfo );
    a10_nil_get_sysinfo( acv, ke, d_release,
          full_length, sysbuf, e );
    IF  e <> e_ok
    THEN
        a07_b_put_error( acv, e, acv.a_cmd_part^.sp1p_buf_len )
    ELSE
        WITH sysbuf^.schangeinfos DO
            BEGIN
            ci_rec_len  := full_length;
            ci_fullen   := full_length;
            ci_colcount := change_rec.cr_colcount;
            ci_filler   := 0;
            SAPDB_PascalMove('VAK54 ',  14,    
                  sizeof( change_rec.cr_columns ), sizeof( ci_ch_columns ),
                  @change_rec.cr_columns, 1, @ci_ch_columns, 1,
                  change_rec.cr_colcount * sizeof( tak_change_colinfo ),
                  acv.a_returncode );
            a10add_sysinfo( acv, sysbuf, e );
            IF  e <> e_ok
            THEN
                a07_b_put_error( acv, e, acv.a_cmd_part^.sp1p_buf_len )
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54_select_last_part (
            VAR acv              : tak_all_command_glob;
            VAR dmli             : tak_dml_info;
            VAR user_result_tree : tgg00_FileId;
            last_pars_part       : boolean);
 
VAR
      _e           : tgg00_BasisError;
      _mtype       : tgg00_MessType;
      _m2type      : tgg00_MessType2;
      _col_ptr     : tak00_colinfo_ptr;
      _aux_treeid  : tgg00_FileId;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  NOT a101_IsExtendedTempFile (acv, acv.a_mblock.mb_qual^.mtree)
    THEN
        BEGIN
        acv.a_mblock.mb_qual^.mtree.fileHandling_gg00 := dmli.d_globstate;
&       ifdef trace
        t01handling( ak_sem, 'd_globstate ', dmli.d_globstate );
&       endif
        IF  acv.a_isolation_info = temp_lock_rec_get
        THEN
            IF  hsPermLock_egg00 in acv.a_mblock.mb_qual^.mtree.fileHandling_gg00
            THEN
                BEGIN
                acv.a_mblock.mb_qual^.mtree.fileHandling_gg00 :=
                      acv.a_mblock.mb_qual^.mtree.fileHandling_gg00 -
                      [ hsPermLock_egg00, hsConsistentLock_egg00,
                      hsCollisionTest_egg00 ];
                IF  NOT ( hsIntentExcl_egg00 in acv.a_mblock.mb_qual^.mtree.fileHandling_gg00 )
                THEN
                    acv.a_mblock.mb_qual^.mtree.fileHandling_gg00 :=
                          acv.a_mblock.mb_qual^.mtree.fileHandling_gg00 + [ hsWithoutLock_egg00 ]
                (*ENDIF*) 
                END
            ELSE
                acv.a_mblock.mb_qual^.mtree.fileHandling_gg00 :=
                      acv.a_mblock.mb_qual^.mtree.fileHandling_gg00 - [ hsTempLock_egg00 ];
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  acv.a_ex_kind = only_parsing
    THEN
        BEGIN
        WITH  dmli.d_sparr.pparsp^.sparsinfo DO
            BEGIN
            p_select    := true;
            p_single    := dmli.d_single OR ( dmli.d_rowno = cgg04_one_record_at_most_internal );
            p_resreclen  := dmli.d_reclen;
            (* PTS 1001487 E.Z. *)
            IF  (( acv.a_returncode = 0 ) AND NOT dmli.d_single AND
                NOT ( dmli.d_subquery ) AND last_pars_part AND
                (( acv.a_intern_select_cnt = acv.a_max_intern_select ) OR
                ( acv.a_fromsel_n > 0 )))
            THEN
                BEGIN
                a67_bextcolindex( dmli.d_esparr, dmli.d_outcolno );
                a06extcolno( dmli.d_esparr.pbasep^.sbase,
                      dmli.d_esparr.pbasep^.sresult.bmaxcol, _col_ptr );
                p_resinfolen := _col_ptr^.ccolstack.epos +
                      _col_ptr^.ccolstack.elen_var - 1
                END
            ELSE
                BEGIN
                p_resinfolen := dmli.d_reclen - cgg_rec_key_offset - dmli.d_keylen;
                IF  dmli.d_check_null_byte
                THEN
                    p_resinfolen := pred( p_resinfolen );
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            p_reuse     := dmli.d_reuse;
            p_pagecnt := a28prim_pages( acv, dmli.d_sparr.pbasep^.sbase );
&           IFDEF TRACE
            t01buf( ak_sem, dmli.d_sparr.pbasep^, 1,
                  dmli.d_sparr.pbasep^.b_sl );
&           ENDIF
            IF  ( dmli.d_cntfromtab = 1 )
            THEN
                IF  oresfile in dmli.d_tabarr^[ 1 ].ospecialname
                THEN
                    p_searchname := dmli.d_tabarr^[ 1 ].otable;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  ( NOT p_single )      AND
                ( NOT acv.a_from_select ) AND
                last_pars_part
            THEN
                BEGIN
                IF  dmli.d_cntfromtab = 1
                THEN
                    IF  oresfile in dmli.d_tabarr^[ 1 ].ospecialname
                    THEN
                        p_searchname := dmli.d_tabarr^[ 1 ].otable;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  ( dmli.d_pos_result = cak_extern_pos ) OR
                    ( dmli.d_pos_result = cak_intern_pos )
                THEN
                    BEGIN
                    p_resn       :=
                          acv.a_resname_addr[ dmli.d_pos_result ]^.sresname.reskey_name;
                    p_modul_name :=
                          acv.a_resname_addr[ dmli.d_pos_result ]^.sresname.reskey_modul_name
                    END
                ELSE
                    BEGIN
                    p_resn       := a01_zero_res_name;
                    p_modul_name := acv.a_modul_name;
                    END
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                p_resn       := a01_zero_res_name;
                p_modul_name := acv.a_modul_name;
                END;
            (*ENDIF*) 
            p_use_sess_isolevel := NOT dmli.d_with_lock_clause;
            p_session_isolevel  := acv.a_iso_level;
            p_handling_set      := dmli.d_unchanged_globstate;
&           ifdef trace
            t01handling( ak_sem, 'p_handling_s', p_handling_set );
&           endif
            END;
        (*ENDWITH*) 
        IF  acv.a_intern_explain AND a663parse_for_execute( acv )
        THEN
            BEGIN
            a10del_sysinfo( acv,
                  dmli.d_sparr.pparsp^.syskey, _e );
            dmli.d_sparr.pparsp := NIL;
            IF  _e <> e_ok
            THEN
                a07_b_put_error( acv, _e, 1 )
            (*ENDIF*) 
            END
        ELSE
            a54_sel_store_parsinfo( acv,
                  dmli.d_sparr, dmli.d_change, last_pars_part );
        (*ENDIF*) 
        IF  ( last_pars_part AND
            NOT dmli.d_subquery AND ( dmli.d_subcount = 0 ) AND
            ( dmli.d_corr <> first_correlation )            AND
            (* PTS 1111575 E.Z. *)
            NOT acv.a_from_select)
        THEN
            a54_shortinfo_to_varpart( acv, acv.a_initial_segment_header.sp1c_prepare OR
                  ( acv.a_intern_explain AND a663parse_for_execute( acv )),
                  dmli.d_sparr.pinfop );
        (*ENDIF*) 
        END
    ELSE
        (* PTS 1111575 E.Z. *)
        IF  NOT acv.a_intern_explain (* h.b. PTS 1105331 *)
        THEN
            BEGIN
            _aux_treeid := acv.a_mblock.mb_qual^.mtree;
            _mtype := acv.a_mblock.mb_type;
            _m2type := acv.a_mblock.mb_type2;
            g04mblock_optimize_info( acv.a_mblock );
            a06dml_send_mess_buf( acv, acv.a_mblock, dmli, _e );
            IF  _e <> e_ok
            THEN
                IF  _e = e_too_many_resultsets
                THEN
                    a07_b_put_error( acv, _e, 1 )
                ELSE
                    a07_b_put_error( acv, _e, 1 )
                (*ENDIF*) 
            ELSE
                (* PTS 1104644 E.Z. *)
                IF  acv.a_returncode = 0
                THEN
                    BEGIN
                    IF  ( acv.a_mblock.mb_type = m_return_result ) AND
                        ( acv.a_mblock.mb_type2 = mm_file )
                    THEN
                        BEGIN
                        (* message buffer contains result tree_id *)
                        IF  a101_IsExtendedTempFile (acv,
                            acv.a_mblock.mb_qual^.mr_restree) AND
                            ( a101_GetExtendedTempFileType (acv,
                            acv.a_mblock.mb_qual^.mr_restree)
                            = ttfnUserResult_egg00 )
                        THEN
                            user_result_tree := acv.a_mblock.mb_qual^.mr_restree
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    a28sys_upd_statistics( acv,
                          _aux_treeid, _mtype, _m2type,
                          a28prim_pages( acv, dmli.d_sparr.pbasep^.sbase ),
                          acv.a_mblock.mb_qual^.mr_pagecnt );
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(* PTS 1108761 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a54_shortinfo_to_varpart (
            VAR acv   : tak_all_command_glob;
            store_cmd : boolean;
            VAR infop : tak_sysbufferaddress);
 
VAR
      i             : integer;
      parsk         : tak_parskey;
      parsid        : tak_parsid;
      dummy_parsid  : tak_parsid;
      infocnt       : integer;
 
BEGIN
WITH infop^, sshortinfo DO
    IF  ( acv.a_init_ex_kind = only_parsing )
    THEN
        BEGIN
        parsk := acv.a_pars_last_key;
        (* PTS 1122398 E.Z. *)
        IF  ( acv.a_command_kind <> single_command ) AND
            ( acv.a_command_kind <> show_command )   AND
            ( acv.a_command_kind <> union_command )
        THEN
            BEGIN
            parsk.p_id[ 1 ] := acv.a_first_parskey;
            parsk.p_no      := 0;
            IF  NOT acv.a_intern_explain
            THEN
                parsk.p_kind := m_complex;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (( acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_proc    = a56 ) AND
            ( acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc =
            cak_x_insert_select ))
        THEN
            BEGIN
            acv.a_input_data_pos := 1;
            FOR i := 1 TO sicount DO
                BEGIN
&               ifdef TRACE
                t01int4( ak_sem, 'input_data_p', acv.a_input_data_pos );
                t01int4( ak_sem, 'typ         ',
                      ord( siinfo[ i ].sp1i_data_type ));
                t01int4( ak_sem, 'len         ',
                      siinfo[ i ].sp1i_length );
                t01int4( ak_sem, 'inoutlen    ',
                      siinfo[ i ].sp1i_in_out_len );
&               endif
                IF  siinfo[ i ].sp1i_data_type in
                    [ dstra, dstrb, dstruni ]
                THEN
                    (* PTS 1116801 E.Z. *)
                    acv.a_input_data_pos := acv.a_input_data_pos + mxsp_long_desc + 1
                ELSE
                    IF  siinfo[ i ].sp1i_data_type in
                        [ dlonga, dlongb, dlonguni ]
                    THEN
                        acv.a_input_data_pos := acv.a_input_data_pos + mxsp_long_desc + 1
                    ELSE
                        acv.a_input_data_pos := acv.a_input_data_pos + siinfo[ i ].sp1i_in_out_len;
                    (*ENDIF*) 
                (*ENDIF*) 
&               ifdef TRACE
                t01int4( ak_sem, 'input_data_p', acv.a_input_data_pos );
&               endif
                END;
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        IF  store_cmd
        THEN
            a542cmd_shinfo_store( acv, parsk, infop );
        (*ENDIF*) 
        parsid.pid_session.ci4_gg00 := acv.a_transinf.tri_trans.trSessionId_gg00.ci4_gg00;
        parsid.pid_parsk        := parsk;
        parsid.pid_appl_info[ 1 ] := chr( acv.a_precomp_info_byte );
        IF  acv.a_date_time_used
        THEN
            parsid.pid_dtime_info[ 1 ] := chr( ord( acv.a_dt_format ))
        ELSE
            parsid.pid_dtime_info[ 1 ] := chr( ord( dtf_none ));
        (*ENDIF*) 
        IF  g01diag_moni_parse_on AND ( acv.a_precomp_info_byte <> csp1_p_dialog_call )
        THEN
            BEGIN
            dummy_parsid.pid_session.ci4_gg00 := cgg_nil_session;
            a545diag_parse_info( acv, parsid, dummy_parsid )
            END;
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            BEGIN (*==== return shortfield info's ======*)
            a06init_curr_retpart( acv );
            infocnt := sicount;
            IF  infocnt > 0
            THEN
                BEGIN
                (* PTS 1105338 E.Z. *)
                IF  NOT acv.a_init_info_output        AND
                    (infocnt > sisl )             AND
                    a54_optim_select_fetch( acv )
                THEN
                    BEGIN
                    a06retpart_move( acv,
                          @sshortinfo.siinfo[ sisl+1 ],
                          ( sicount-sisl ) * sizeof( tsp1_param_info ));
                    a06finish_curr_retpart( acv, sp1pk_output_cols_no_parameter,
                          sicount-sisl );
                    a06init_curr_retpart( acv );
                    infocnt := sisl;
                    END;
                (*ENDIF*) 
                IF  infocnt > 0
                THEN
                    a06retpart_move( acv, @sshortinfo.siinfo,
                          infocnt * sizeof( tsp1_param_info ));
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            a06finish_curr_retpart( acv, sp1pk_shortinfo, infocnt );
            (* PTS 1102360 E.Z. *)
            IF  a01diag_monitor_on
            THEN
                a545sm_param_info( acv, parsid )
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            BEGIN (*===== return parse-id ==========*)
            a54return_parsid( acv, parsk );
            WITH infop^ DO
                BEGIN
                b_sl := sizeof( tak_shortinforecord ) - sizeof( tak_paraminfoarr ) +
                      sshortinfo.sicount * sizeof( tsp1_param_info );
                sshortinfo.sifullen := b_sl;
                a10_key_del( acv, infop^.syskey );
                END;
            (*ENDWITH*) 
            (* PTS 1108761 E.Z. *)
            infop := NIL;
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54_store_parsinfo (
            VAR acv   : tak_all_command_glob;
            VAR sparr : tak_syspointerarr);
 
VAR
      e           : tgg00_BasisError;
      ke          : tgg00_SysInfoKey;
      messp       : tak_sysbufferaddress;
 
BEGIN
IF  ( acv.a_intern_select_cnt = acv.a_max_intern_select )
THEN
    sparr.pparsp^.sparsinfo.p_precomp_info_byte := acv.a_precomp_info_byte
ELSE
    sparr.pparsp^.sparsinfo.p_precomp_info_byte := csp1_p_none;
(*ENDIF*) 
sparr.pparsp^.sparsinfo.p_cmd_id := acv.a_cmd_id;
sparr.pparsp^.b_sl := cak_sysbufferoffset +
      sparr.pparsp^.sparsinfo.p_cnt_infos * sizeof( tak_field_pars ) +
      mxak_pars_header;
sparr.pparsp^.sparsinfo.p_fullen  := sparr.pparsp^.b_sl;
&IFDEF TRACE
t01int4( ak_sem, 'function_cod', sparr.pparsp^.sparsinfo.p_function_code );
t01buf( ak_sem, sparr.pparsp^, 1, sparr.pparsp^.b_sl );
&ENDIF
a10add_sysinfo( acv, sparr.pparsp, e );
IF  ( e <> e_ok )
THEN
    a07_b_put_error( acv, e, acv.a_cmd_part^.sp1p_buf_len )
ELSE
    BEGIN
    ke := sparr.pparsp^.syskey;
    a10_rel_sysinfo( acv, sparr.pparsp^.syskey );
    ke.sauthid[ 1 + mxak_parskey + 1 ] :=
          a01sysnullkey.sauthid[ 1 + mxak_parskey + 1 ];
    ke.sentrytyp := cak_emessblock;
    END;
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    a10mblock_into_cache( acv, ke, acv.a_mblock, d_release, messp, e );
    IF  ( e <> e_ok )
    THEN
        a07_b_put_error( acv, e,
              acv.a_cmd_part^.sp1p_buf_len )
    ELSE
        BEGIN
        a10add_sysinfo( acv, messp, e );
        IF  e <> e_ok
        THEN
            a07_b_put_error( acv, e, acv.a_cmd_part^.sp1p_buf_len );
        (*ENDIF*) 
        ;
&       ifdef TRACE
        t01messblock( ak_sem, 'mess_block >',
              messp^.smessblock.mbr_mess_block );
        t01messblock( ak_sem, 'store_parsb ', acv.a_mblock );
&       endif
        END;
    (*ENDIF*) 
    a06drop_fieldlist_references (acv.a_mblock.mb_fieldlists);
    END;
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    sparr.pparsp := NIL;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54_subquery (
            VAR acv          : tak_all_command_glob;
            VAR isparr       : tak_syspointerarr;
            start_node       : tsp00_Int2;
            mtype            : tgg00_MessType;
            VAR is_join_view : boolean);
 
VAR
      is_from_select : boolean;
      mcommand       : tak_commandkind;
      del_cnt        : integer;
      tab_node       : integer;
      parsk          : tak_parskey;
      dmli           : tak_dml_info;
 
BEGIN
a54_dml_init( acv, dmli, NOT c_in_union );
dmli.d_acttabindex := 1;
dmli.d_cntfromtab  := 1;
(* PTS 1111511 E.Z. *)
is_from_select := acv.a_from_select;
(* PTS 1110742 E.Z. *)
acv.a_from_select       := false;
acv.a_fromsel_n         := 0;
acv.a_union_cnt         := 0;
tab_node := acv.a_ap_tree^[ acv.a_ap_tree^[ start_node ].n_lo_level ].n_lo_level;
IF  mtype = m_update
THEN
    a660_search_one_table( acv, dmli,
          tab_node, NOT c_get_all, c_check_teresult, no_lock, r_upd )
ELSE
    a660_search_one_table( acv, dmli,
          tab_node, NOT c_get_all, c_check_teresult, no_lock, r_del );
(*ENDIF*) 
is_join_view := false;
IF  acv.a_returncode = 0
THEN
    IF  dmli.d_sparr.pbasep^.sbase.btablekind = tview
    THEN
        is_join_view := true
    ELSE
        BEGIN
        a10_rel_sysinfo( acv, dmli.d_sparr.pbasep^.syskey );
        acv.a_ex_kind := only_parsing;
        mcommand  := acv.a_command_kind;
        dmli.d_globstate := acv.a_transinf.tri_global_state;
        IF  ( mtype = m_delete ) AND
            NOT ( hsPermLock_egg00 in dmli.d_globstate ) AND
            ( is_primary_table in
            dmli.d_sparr.pbasep^.sbase.blinkexist )
        THEN
            dmli.d_globstate :=
                  dmli.d_globstate + [ hsTempLock_egg00 ];
        (*ENDIF*) 
        dmli.d_unchanged_globstate := dmli.d_globstate;
        IF  (( hsTempLock_egg00 in dmli.d_globstate ) OR
            ( hsPermLock_egg00 in dmli.d_globstate ))
            AND ( acv.a_isolation_info <> temp_lock_rec_get )
        THEN
            acv.a_isolation_info := temp_lock_rec_needed;
        (*ENDIF*) 
        ak54intern_sub( acv, dmli, isparr, start_node, mtype );
        IF  acv.a_init_ex_kind <> only_parsing
        THEN
            BEGIN
            IF  ( acv.a_returncode = 0 ) AND
                ( acv.a_intern_select_cnt = acv.a_max_intern_select )
            THEN
                BEGIN
                IF  acv.a_command_kind <> single_command
                THEN
                    BEGIN
                    parsk           := acv.a_pars_last_key;
                    parsk.p_id[ 1 ] := acv.a_first_parskey;
                    parsk.p_kind    := m_complex;
                    parsk.p_no      := 0
                    END
                ELSE
                    parsk := acv.a_pars_last_key;
                (*ENDIF*) 
                acv.a_ex_kind := only_executing;
                a501do_execute( acv, dmli, parsk,
                      c_output_during_execution );
                END
            (* PTS 1106167 E.Z. *)
            ELSE
                parsk := acv.a_pars_last_key;
            (*ENDIF*) 
            IF  (acv.a_returncode      = cak_e_corelated_subquery_not_allowed) OR
                (acv.a_main_returncode = cak_e_corelated_subquery_not_allowed)
            THEN
                a660_prefix_delete( acv, parsk, del_cnt, cak_intern_prefix )
            ELSE
                a660_prefix_delete( acv, parsk, del_cnt, cak_complete_prefix );
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        acv.a_command_kind := mcommand;
        acv.a_ex_kind      := acv.a_init_ex_kind
        END;
    (*ENDIF*) 
(* PTS 1111511 E.Z. *)
(*ENDIF*) 
IF  (is_from_select
    AND
    ((acv.a_ex_kind <> only_parsing) OR
    ( acv.a_intern_explain)          OR
    (acv.a_returncode <> 0)))
THEN
    a661_fdelete_fromtab_results (acv);
(*ENDIF*) 
a54_dml_finalize( dmli, acv.a_transinf.tri_trans );
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54_view_put_into (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info);
 
CONST
      c_pos_error       = 3;
      c_owner_varcol_no = 1;
 
VAR
      _and_arr          : tak_eop_arr_ptr;
      _e                : tgg00_BasisError;
      _put_into         : boolean;
      _and_count        : integer;
      _j                : integer;
      _jump_stentry_pos : integer;
      _l                : integer;
      _st_pos           : integer;
      _data_len         : integer;
      _qual_pos         : integer;
      _stcount          : integer;
      _rest_cnt         : integer;
      _copy_cnt         : integer;
      _op               : tgg00_StackOpType;
      _vqual_basis      : tak_sysbufferaddress;
      _vqual_stack      : tak_sysbufferaddress;
      _catalog_ptr      : tak_sysbufferaddress;
      _ke               : tgg00_SysInfoKey;
 
BEGIN
&ifdef trace
t01messblock( ak_sem, 'before mbloc', acv.a_mblock );
&endif
_vqual_basis := NIL;
_vqual_stack := NIL;
_data_len  := 0;
_put_into  := false;
_stcount   := 0;
_and_count := 0;
_and_arr   := NIL;
_ke        := a01defaultkey;
_ke.stableid  := dmli.d_tabarr^[ dmli.d_acttabindex ].ofromtableid;
_ke.sentrytyp := cak_eviewqual_basis;
a10get_sysinfo( acv, _ke, d_fix, _vqual_basis, _e );
IF  _e <> e_ok
THEN
    a07_b_put_error( acv, _e, 1 )
ELSE
    BEGIN
    _put_into := true;
    IF  ( _vqual_basis^.sviewqual_basis.vbasetabcnt = 1 ) AND
        ( _vqual_basis^.sviewqual_basis.vtable[ 1 ].vttableid = _ke.stableid )
    THEN
        BEGIN
&       ifdef trace
        t01sname( ak_sem, 'save scheme ' );
&       endif
        (*==========================================*)
        (* Current table is save scheme table. If   *)
        (* only the columns ERROR_CODE and (or)     *)
        (* USERID are selected, the condition where *)
        (* USERID = USER is not used                *)
        (*==========================================*)
        IF  acv.a_cmd_segment_header.sp1c_producer = sp1pr_internal_cmd
        THEN
            _put_into := false;
        (*ENDIF*) 
        IF  ( acv.a_mblock.
            mb_st^[ acv.a_mblock.mb_qual^.mqual_pos ].etype = st_jump_output )
            AND ( _put_into )
        THEN
            BEGIN
            _put_into := false;
            _j        := acv.a_mblock.mb_qual^.mqual_pos + 1;
            WHILE _j < acv.a_mblock.mb_qual^.mqual_pos +
                  acv.a_mblock.
                  mb_st^[ acv.a_mblock.mb_qual^.mqual_pos ].epos - 1 DO
                (* step over output columns *)
                BEGIN
                IF  acv.a_mblock.mb_st^[ _j ].etype in
                    [ st_fixkey, st_varkey, st_fixcol, st_varcol,
                    st_varlongchar ]
                THEN
                    CASE acv.a_mblock.mb_st^[ _j ].etype OF
                        st_fixkey, st_varkey,
                        st_varlongchar :
                            _put_into := true;
                        st_varcol :
                            IF  acv.a_mblock.mb_st^[ _j ].ecolno <>
                                c_owner_varcol_no
                            THEN
                                _put_into := true;
                            (*ENDIF*) 
                        st_fixcol :
                            IF  acv.a_mblock.mb_st^[ _j ].epos <>
                                c_pos_error
                            THEN
                                _put_into := true;
                            (*ENDIF*) 
                        END;
                    (*ENDCASE*) 
                (*ENDIF*) 
                _j := succ( _j );
                END;
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  _put_into
THEN
    BEGIN
    _jump_stentry_pos := 0;
    IF  acv.a_mblock.mb_qual^.mqual_pos = 0
    THEN
        acv.a_mblock.mb_qual^.mqual_pos := acv.a_mblock.mb_qual^.mfirst_free;
    (*ENDIF*) 
    _qual_pos  := acv.a_mblock.mb_qual^.mqual_pos +
          acv.a_mblock.mb_qual^.mqual_cnt;
    _op        := op_and;
    IF  _vqual_basis^.sviewqual_basis.vstack_exists
    THEN
        BEGIN
        (* linkage already cak_init_linkage *)
        _ke.sentrytyp := cak_eviewqual_stack;
        a10get_sysinfo( acv, _ke, d_fix, _vqual_stack, _e );
        IF  ( _e <> e_ok ) OR
            ( acv.a_mblock.mb_qual^.mfirst_free +
            _vqual_stack^.sviewqual_stack.vstcount + 1 >
            acv.a_mblock.mb_st_max )
        THEN
            BEGIN
            IF  _e <> e_ok
            THEN
                a07_b_put_error( acv, _e, 1 )
            ELSE
                a07_b_put_error( acv, e_too_many_mb_stackentries, 1 );
            (*ENDIF*) 
            END
        ELSE
            _stcount := _vqual_stack^.sviewqual_stack.vstcount;
        (*ENDIF*) 
        IF  _e = e_ok
        THEN
            BEGIN
            IF  acv.a_mblock.mb_qual^.mqual_cnt > 0
            THEN
                IF  NOT (( acv.a_mblock.
                    mb_st^[ acv.a_mblock.mb_qual^.mqual_pos ].etype = st_jump_output )
                    AND ( acv.a_mblock.
                    mb_st^[ acv.a_mblock.mb_qual^.mqual_pos ].epos =
                    acv.a_mblock.mb_qual^.mqual_cnt + 1 ))
                THEN
                    BEGIN
                    (* IF a View_qualification is inserted *)
                    (* into the stack, it will be connected*)
                    (* with an and_operator to the existing*)
                    (* stack. This leads to an illegal     *)
                    (* stackstructure ( not postfix ). So  *)
                    (* the existing operators (AND) must be*)
                    (* collected and inserted after the view*)
                    (* qualification afterwards and the    *)
                    (* jump_positions must be changed      *)
&                   ifdef trace
                    t01sname( ak_sem, 'connect qual' );
&                   endif
                    _j := _qual_pos - 1;
                    WHILE acv.a_mblock.mb_st^[ _j ].eop in [ op_and, op_upd_view_and ] DO
                        _j := pred( _j );
                    (*ENDWHILE*) 
                    _and_count := 0;
                    IF  _qual_pos - 1 - _j > 0
                    THEN
                        BEGIN
                        a10new( acv, ( _qual_pos - 1 - _j ) *
                              sizeof( tgg00_StackOpType ), _and_arr );
                        IF  _and_arr = NIL
                        THEN
                            a07_b_put_error( acv, e_no_more_memory, 1 )
                        ELSE
                            WHILE _qual_pos - 1 > _j DO
                                BEGIN
                                _qual_pos   := _qual_pos - 1;
                                acv.a_mblock.mb_qual^.mqual_cnt   :=
                                      acv.a_mblock.mb_qual^.mqual_cnt - 1;
                                acv.a_mblock.mb_qual^.mfirst_free :=
                                      acv.a_mblock.mb_qual^.mfirst_free - 1;
                                _and_count  := _and_count + 1;
                                _and_arr^[ _and_count ] :=
                                      acv.a_mblock.mb_st^ [ _qual_pos ].eop
                                END
                            (*ENDWHILE*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    ;
                    (* create place for st_jump_false stack entry *)
                    _jump_stentry_pos := acv.a_mblock.mb_qual^.mfirst_free;
                    acv.a_mblock.mb_qual^.mqual_cnt         :=
                          acv.a_mblock.mb_qual^.mqual_cnt  + 1;
                    acv.a_mblock.mb_qual^.mfirst_free       :=
                          acv.a_mblock.mb_qual^.mfirst_free + 1;
                    IF  acv.a_mblock.mb_qual^.mview_cnt > 0
                    THEN
                        acv.a_mblock.mb_qual^.mview_cnt :=
                              acv.a_mblock.mb_qual^.mview_cnt + 1;
                    (*ENDIF*) 
                    _qual_pos := _qual_pos + 1;
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  ( acv.a_mblock.mb_qual^.mview_pos = 0 ) AND
                ((( acv.a_mblock.mb_type  = m_select ) AND
                ( acv.a_is_ddl = no_ddl )) OR
                dmli.d_tabarr^[ dmli.d_acttabindex ].oviewcheck )
            THEN
                BEGIN
                acv.a_mblock.mb_qual^.mview_pos := _qual_pos +
                      _vqual_stack^.sviewqual_stack.vview_offs;
                _op := op_upd_view_and;
                END;
            (*ENDIF*) 
            IF  acv.a_mblock.mb_qual^.mview_pos > 0
            THEN
                acv.a_mblock.mb_qual^.mview_cnt :=
                      acv.a_mblock.mb_qual^.mview_cnt + _stcount -
                      _vqual_stack^.sviewqual_stack.vview_offs;
            (*ENDIF*) 
            _rest_cnt := _stcount;
            _st_pos   := ( _qual_pos - 1 ) * sizeof( tgg00_StackEntry ) + 1;
&           ifdef trace
            t01int4( ak_sem, 'append on   ', _qual_pos );
&           endif
            _catalog_ptr := _vqual_stack;
            WHILE ( _e = e_ok ) AND ( _rest_cnt > 0 ) DO
                BEGIN
                IF  _rest_cnt > cak_max_viewqual_stack
                THEN
                    _copy_cnt := cak_max_viewqual_stack
                ELSE
                    _copy_cnt := _rest_cnt;
                (*ENDIF*) 
                SAPDB_PascalMove('VAK54 ',  15,    
                      sizeof( _catalog_ptr^.sviewqual_stack.vstack ),
                      acv.a_mblock.mb_st_size,
                      @_catalog_ptr^.sviewqual_stack.vstack, 1,
                      @acv.a_mblock.mb_st^, _st_pos,
                      _copy_cnt * STACK_ENTRY_MXGG00,
                      acv.a_returncode );
                _st_pos   := _st_pos + _copy_cnt * sizeof( tgg00_StackEntry );
                _rest_cnt := _rest_cnt - _copy_cnt;
                IF  _rest_cnt > 0
                THEN
                    BEGIN
                    _ke := _catalog_ptr^.syskey;
                    a06inc_linkage( _ke.slinkage );
                    a10get_sysinfo( acv, _ke, d_release, _catalog_ptr, _e );
                    IF  _e <> e_ok
                    THEN
                        a07_b_put_error( acv, _e, 1 )
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            acv.a_mblock.mb_qual^.mfirst_free :=
                  acv.a_mblock.mb_qual^.mfirst_free + _stcount;
            acv.a_mblock.mb_qual^.mqual_cnt   :=
                  acv.a_mblock.mb_qual^.mqual_cnt + _stcount;
&           ifdef trace
            t01stackdesc( ak_sem, 'appended    ', acv.a_mblock.mb_st,
                  acv.a_mblock.mb_qual^.mstack_desc );
&           endif
            IF  _jump_stentry_pos > 0
            THEN
                BEGIN
&               ifdef trace
                t01sname( ak_sem, 'set op_upd_v' );
                t01int4( ak_sem, '_jump_stentr', _jump_stentry_pos );
&               endif
                (* set operator op_upd_view_and *)
                _l := acv.a_mblock.mb_qual^.mqual_cnt;
                a65_set_operator( acv, _op );
                IF  ( _l < acv.a_mblock.mb_qual^.mqual_cnt ) AND
                    ( acv.a_mblock.mb_qual^.mview_cnt > 0 )
                THEN
                    acv.a_mblock.mb_qual^.mview_cnt :=
                          acv.a_mblock.mb_qual^.mview_cnt + 1;
                (*ENDIF*) 
                a61_set_jump( acv.a_mblock,
                      _jump_stentry_pos, st_jump_false );
                IF  _and_count > 0
                THEN
                    (* The collected operators are inserted *)
                    (* and Jumps to the old end of Stack    *)
                    (* (before view_put_into) are changed   *)
                    BEGIN
                    FOR _j := _and_count DOWNTO 1 DO
                        a65_set_operator( acv, _and_arr^[ _j ] );
                    (*ENDFOR*) 
                    a10dispose( acv, _and_arr );
                    FOR _j := 1 TO _qual_pos - 2 DO
                        BEGIN
                        IF  acv.a_mblock.mb_st^ [ _j ].etype = st_jump_false
                        THEN
                            BEGIN
                            IF  ( ( _j + acv.a_mblock.mb_st^ [ _j ].epos ) >
                                _jump_stentry_pos )
                            THEN
                                BEGIN
&                               ifdef trace
                                t01int4( ak_sem, 'adjust jump ', _j );
&                               endif
                                acv.a_mblock.mb_st^ [ _j ].epos :=
                                      acv.a_mblock.mb_st^ [ _j ].epos +
                                      _stcount + 2;
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDFOR*) 
                    END;
                (*ENDIF*) 
                IF  NOT ( dmli.d_tabarr^[ dmli.d_acttabindex ].oviewcheck )
                    AND ( acv.a_mblock.mb_qual^.mview_pos > 0 )
                THEN
                    BEGIN
                    acv.a_mblock.mb_st^[ _jump_stentry_pos ].eop := op_jmp_ins_upd;
                    acv.a_mblock.mb_st^[ _jump_stentry_pos ].elen_var :=
                          acv.a_mblock.mb_st^ [ _jump_stentry_pos ].epos;
                    END
                ELSE
                    IF  ( dmli.d_tabarr^[ dmli.d_acttabindex ].oviewcheck )
                        AND ( _vqual_stack^.sviewqual_stack.vview_offs > 0 )
                    THEN
                        BEGIN
                        acv.a_mblock.mb_st^[ _jump_stentry_pos ].eop :=
                              op_jmp_ins_upd;
                        acv.a_mblock.mb_st^[ _jump_stentry_pos ].elen_var :=
                              _vqual_stack^.sviewqual_stack.vview_offs;
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            a54_in_buf( acv, dmli, _vqual_stack,
                  _vqual_stack^.sviewqual_stack.vdatalen, _qual_pos,
                  _stcount, _vqual_stack^.sviewqual_stack.vdatapos,
                  dmli.d_tabarr^[ dmli.d_acttabindex ].ocounttabs );
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    ;
&   ifdef trace
    t01messblock( ak_sem, 'tmp1        ', acv.a_mblock );
&   endif
    IF  ( _vqual_basis^.sviewqual_basis.vjoin_exists AND
        ( acv.a_returncode = 0 ) )
    THEN
        ak54viewjoin_get( acv, dmli, _vqual_basis, _qual_pos - 1,
              dmli.d_tabarr^[ dmli.d_acttabindex ].ocounttabs );
    (*ENDIF*) 
    END;
(*ENDIF*) 
a10rel_sysinfo( _vqual_basis );
a10rel_sysinfo( _vqual_stack );
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54add_next_temp_lock (
            VAR acv           : tak_all_command_glob;
            VAR tabid         : tgg00_Surrogate;
            globstate         : tgg00_HandlingSet);
 
VAR
      e            : tgg00_BasisError;
      found        : boolean;
      i            : integer;
      tempinfo_buf : tak_sysbufferaddress;
      ke           : tgg00_SysInfoKey;
 
BEGIN
ke := a01sysnullkey;
WITH ke DO
    BEGIN
    stableid  := cgg_zero_id;
    sentrytyp := cak_eparsinfo;
    slinkage  := cak_temp_info_linkage
    END;
(*ENDWITH*) 
a10_fix_len_get_sysinfo( acv, ke, d_release,
      cak_sysbufferoffset + mxak_pars_header + 8 + LOCK_MXGG04,
      LOCK_MXGG04, tempinfo_buf, e );
IF  e = e_sysinfo_not_found
THEN
    a54init_lock_parsinfo( acv, tempinfo_buf );
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    found := false;
    WITH tempinfo_buf^.sparsinfo, p_temp_lock DO
        FOR i := 1 TO all_lock_count DO
            WITH all_locks[ i ] DO
                IF  lockTabId_gg00 = tabid
                THEN
                    found := true;
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDFOR*) 
    (*ENDWITH*) 
    IF  NOT found
    THEN
        IF  tempinfo_buf^.sparsinfo.p_temp_lock.all_lock_count =
            MAX_QUALBUF_LOCKS_GG00
        THEN
            a07_b_put_error( acv, e_too_many_lockunits_specified, 1 )
        ELSE
            BEGIN
            WITH tempinfo_buf^.sparsinfo, p_temp_lock DO
                all_lock_count := succ( all_lock_count );
            (*ENDWITH*) 
            WITH tempinfo_buf^.sparsinfo, p_temp_lock,
                 all_locks[ all_lock_count ] DO
                BEGIN
                lockTabId_gg00        := tabid;
                lockKeyLen_gg00       := 0;
                lockMode_gg00         := lckTabShare_egg00;
                IF  hsPermLock_egg00 in globstate
                THEN
                    lockState_gg00   := [  ]
                ELSE
                    lockState_gg00   := [ lrsTemp_egg00 ];
                (*ENDIF*) 
                lockKeyPos_gg00 := 0;
                END;
            (*ENDWITH*) 
            IF  e = e_ok
            THEN
                WITH tempinfo_buf^ DO
                    b_sl := b_sl + LOCK_MXGG04;
                (*ENDWITH*) 
            (*ENDIF*) 
            a10_add_repl_sysinfo( acv, tempinfo_buf, e <> e_ok, e );
            IF  e <> e_ok
            THEN
                a07_b_put_error( acv, e, acv.a_cmd_part^.sp1p_buf_len )
            (*ENDIF*) 
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54complicated_view (
            VAR acv      : tak_all_command_glob;
            VAR dmli     : tak_dml_info;
            VAR tableid  : tgg00_Surrogate);
 
VAR
      b_err             : tgg00_BasisError;
      sqlmode           : tsp00_SqlMode;
      complicated_found : boolean;
      correlated_view   : boolean;
      tabcnt            : integer;
      tabno             : integer;
      basebuf           : tak_sysbufferaddress;
      owner             : tgg00_Surrogate;
      next_tableid      : tgg00_Surrogate;
      schemacontext     : tgg00_Surrogate;
      viewtextkey       : tgg00_SysInfoKey;
 
BEGIN
(* store current globstate which has to be used when *)
(* underlying complex view will be build             *)
acv.a_cmd_globstate := dmli.d_globstate;
viewtextkey := a01defaultkey;
WITH viewtextkey DO
    BEGIN
    stableid  := tableid;
    sentrytyp := cak_eviewtext;
    END;
(*ENDWITH*) 
tabcnt    := 0;
tabno  := 1;
correlated_view := false;
sqlmode         := sqlm_internal;
REPEAT
    a10get_sysinfo( acv, viewtextkey, d_release, dmli.d_viewtextbuf, b_err );
    IF  b_err = e_ok
    THEN
        WITH dmli.d_viewtextbuf^.sviewtext DO
            BEGIN
            complicated_found := false;
            tabcnt            := vttabcount;
            WHILE ( tabno <= vttabcount )
                  AND ( NOT complicated_found ) DO
                IF  vttab[ tabno ].vttcomplex_view
                THEN
                    IF  a542cmplex_view_stored( acv,
                        vttab[ tabno ].vtttableid )
                    THEN
                        tabno := tabno + 1
                    ELSE
                        complicated_found := true
                    (*ENDIF*) 
                ELSE
                    tabno := tabno + 1;
                (*ENDIF*) 
            (*ENDWHILE*) 
            IF  complicated_found
            THEN
                BEGIN
                WITH vttab[ tabno ] DO
                    BEGIN
                    (* otherwise next get_sysinfo *)
                    (* could overwite these values*)
                    next_tableid := vtttableid;
                    END;
                (*ENDWITH*) 
                a10_rel_sysinfo( acv, viewtextkey );
                a54complicated_view( acv, dmli, next_tableid )
                END;
            (*ENDIF*) 
            tabno := succ( tabno );
            END
        (*ENDWITH*) 
    ELSE
        a07_b_put_error( acv, b_err, 1 );
    (*ENDIF*) 
UNTIL
    ( tabno > tabcnt + 1 ) OR ( b_err <> e_ok );
(*ENDREPEAT*) 
IF  b_err = e_ok
THEN (* prevent viewtext catalog record from being removed from cache *)
    a10get_sysinfo( acv, viewtextkey, d_fix, dmli.d_viewtextbuf, b_err );
(*ENDIF*) 
IF  b_err = e_ok
THEN
    BEGIN
    viewtextkey.sentrytyp := cak_etable;
    a10get_sysinfo( acv, viewtextkey, d_release, basebuf, b_err );
    a10_rel_sysinfo( acv, dmli.d_viewtextbuf^.syskey );
    IF  b_err = e_ok
    THEN
        BEGIN
        owner := basebuf^.sbase.bauthid;
        correlated_view := va_correlation in basebuf^.sbase. bview_attributes;
        sqlmode         := basebuf^.sbase.bsqlmode;
        schemacontext   := basebuf^.sbase.bschemacontext;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  b_err <> e_ok
THEN
    a07_b_put_error( acv, b_err, 1 )
ELSE
    a542add_intern_file( acv, tableid, owner,
          correlated_view, sqlmode, schemacontext, dmli.d_viewtextbuf );
(*ENDIF*) 
END;
 
(* PTS 1113924 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a54trunc_complex_record (
            VAR acv      : tak_all_command_glob;
            comp_cnt_old : integer);
 
VAR
      e   : tgg00_BasisError;
      ke  : tgg00_SysInfoKey;
 
BEGIN
IF  ( acv.a_returncode = 0 ) AND
    ( acv.a_complex_key <> cgg_zero_id )
THEN
    BEGIN
    ke           := a01sysnullkey;
    ke.sauthid   := acv.a_complex_key;
    ke.sentrytyp := cak_ecomplex;
    a10get_sysinfo( acv, ke, d_release, acv.a_ptr2, e );
    IF  e = e_ok
    THEN
        BEGIN
        acv.a_ptr2^.scomplexrec.compcnt := comp_cnt_old;
        acv.a_ptr2^.b_sl := cak_sysbufferoffset + 4 +
              FILE_ID_MXGG00 + comp_cnt_old * mxak_complex_entry;
&       IFDEF TRACE
        t01buf( ak_sem, acv.a_ptr2^, 1, acv.a_ptr2^.b_sl );
&       ENDIF
        a10repl_sysinfo( acv, acv.a_ptr2, e )
        END;
    (*ENDIF*) 
    IF  e <> e_ok
    THEN
        a07_b_put_error( acv, e, 1 )
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a54get_complex_cnt (VAR acv : tak_all_command_glob) : integer;
 
VAR
      e   : tgg00_BasisError;
      ke  : tgg00_SysInfoKey;
      i   : integer;
 
BEGIN
i := 0;
IF  ( acv.a_returncode = 0 ) AND
    ( acv.a_complex_key <> cgg_zero_id )
THEN
    BEGIN
    ke           := a01sysnullkey;
    ke.sauthid   := acv.a_complex_key;
    ke.sentrytyp := cak_ecomplex;
    a10get_sysinfo( acv, ke, d_release, acv.a_ptr2, e );
    IF  e = e_ok
    THEN
        i := acv.a_ptr2^.scomplexrec.compcnt
    ELSE
        a07_b_put_error( acv, e, 1 );
    (*ENDIF*) 
    END;
(*ENDIF*) 
a54get_complex_cnt := i
END;
 
(* END PTS 1113924 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a54set_complex_entry (
            VAR acv     : tak_all_command_glob;
            call_reason : tak_complex_call_reason);
 
VAR
      e   : tgg00_BasisError;
      add : integer;
      ke  : tgg00_SysInfoKey;
 
BEGIN
&IFDEF TRACE
CASE call_reason OF
    c_increment :
        t01int4( ak_sem, 'c_increment ', ord( c_increment ));
    c_set_last_key :
        t01int4( ak_sem, 'c_set_last_k', ord( c_set_last_key ));
    c_set_last_pars :
        t01int4( ak_sem, 'c_set_last_p', ord( c_set_last_pars ));
    c_set_p_no :
        t01int4( ak_sem, 'c_set_p_no  ', ord( c_set_p_no ));
    END;
(*ENDCASE*) 
&ENDIF
IF  ( acv.a_returncode = 0 ) AND
    ( acv.a_complex_key <> cgg_zero_id )
THEN
    BEGIN
    ke           := a01sysnullkey;
    ke.sauthid   := acv.a_complex_key;
    ke.sentrytyp := cak_ecomplex;
    IF  call_reason = c_increment
    THEN
        add := mxak_complex_entry
    ELSE
        add := 0;
    (*ENDIF*) 
    a10_fix_len_get_sysinfo( acv, ke, d_release,
          0, add, acv.a_ptr2, e );
    IF  e = e_ok
    THEN
        WITH acv.a_ptr2^.scomplexrec DO
            BEGIN
&           IFDEF TRACE
            t01buf( ak_sem, acv.a_ptr2^, 1, acv.a_ptr2^.b_sl );
&           ENDIF
            CASE call_reason OF
                c_increment :
                    BEGIN
                    IF  compcnt > 0
                    THEN
                        comparr[ compcnt ].centryinfo :=
                              comparr[ compcnt ].centryinfo - [ ci_lastpars ];
                    (*ENDIF*) 
                    compcnt := succ( compcnt );
                    IF  compcnt > cak_maxcomplex
                    THEN
                        a07_b_put_error( acv, e_too_many_intern_cmd, 1 )
                    ELSE
                        WITH comparr[ compcnt ] DO
                            BEGIN
                            cparsk       := acv.a_pars_last_key;
                            cnextpars    := compcnt + 1;
                            centryinfo   := [ ];
                            cqual_jv_upd := no_jv_upd;
                            END;
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    END;
                c_set_last_key :
                    comparr[ compcnt ].cparsk := acv.a_pars_last_key;
                c_set_last_pars :
                    WITH comparr[ compcnt ] DO
                        BEGIN
                        centryinfo   := centryinfo + [ ci_lastpars ];
                        cqual_jv_upd := acv.a_qualified_jv_upd;
                        END;
                    (*ENDWITH*) 
                c_set_p_no :
                    WITH comparr[ compcnt ] DO
                        IF  cparsk.p_kind <> m_union
                        THEN
                            cparsk.p_no := acv.a_pars_last_key.p_no;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                c_set_recursive :
                    WITH comparr[ compcnt ] DO
                        centryinfo := centryinfo + [ ci_recursive ];
                    (*ENDWITH*) 
                END;
            (*ENDCASE*) 
            acv.a_ptr2^.b_sl := cak_sysbufferoffset + 4 +
                  FILE_ID_MXGG00 + compcnt * mxak_complex_entry;
&           IFDEF TRACE
            t01buf( ak_sem, acv.a_ptr2^, 1, acv.a_ptr2^.b_sl );
&           ENDIF
            a10repl_sysinfo( acv, acv.a_ptr2, e )
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  e <> e_ok
    THEN
        a07_b_put_error( acv, e, 1 )
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54return_parsid (
            VAR acv     : tak_all_command_glob;
            VAR parskey : tak_parskey);
 
VAR
      old_parsid_part : tsp1_part_ptr;
      parsid          : tak_parsid;
 
BEGIN
parsid.pid_session.ci4_gg00 := acv.a_transinf.tri_trans.trSessionId_gg00.ci4_gg00;
parsid.pid_parsk        := parskey;
parsid.pid_appl_info[ 1 ] := chr( acv.a_precomp_info_byte );
IF  acv.a_date_time_used
THEN
    parsid.pid_dtime_info[ 1 ] := chr( ord( acv.a_dt_format ))
ELSE
    parsid.pid_dtime_info[ 1 ] := chr( ord( dtf_none ));
(*ENDIF*) 
a92find_return_part( acv, sp1pk_parsid, old_parsid_part );
IF  old_parsid_part <> NIL
THEN
    SAPDB_PascalForcedMove( sizeof( parsid ), old_parsid_part^.sp1p_buf_len,
          @parsid, 1, @old_parsid_part^.sp1p_buf, 1, sizeof( parsid ))
ELSE
    BEGIN
    a06retpart_move( acv, @parsid, sizeof( parsid ));
    a06finish_curr_retpart( acv, sp1pk_parsid, 1 )
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54_dml_finalize (
            VAR dmli         : tak_dml_info;
            VAR TransContext : tgg00_TransContext);
 
VAR
 
      _cast         : RECORD
            CASE integer OF
                1 :
                    (addr: tsp00_Addr);
                2 :
                    (jptr : tak_joinarr_ptr);
                3 :
                    (tptr : tak_all_from_tables_ptr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  ( dmli.d_tabarr <> NIL ) AND (dmli.d_tabarr_capacity > cak_init_join_tab_size)
THEN
    BEGIN
    _cast.tptr := dmli.d_tabarr;
&   ifdef trace
    t01int4( ak_sem, 'tabarr capac', dmli.d_tabarr_capacity );
    t01addr( ak_sem, 'd_tabarr    ', _cast.addr );
&   endif
    gg941Deallocate( TransContext, _cast.addr );
    END;
(*ENDIF*) 
dmli.d_tabarr_capacity := cak_init_join_tab_size;
;
IF  ( dmli.d_joins.jrc_joinarr <> NIL ) AND ( dmli.d_joins.jrc_capacity > 1 )
THEN
    BEGIN
    _cast.jptr := dmli.d_joins.jrc_joinarr;
&   ifdef trace
    t01int4( ak_join, 'join capac  ', dmli.d_joins.jrc_capacity );
    t01addr( ak_sem, 'jrc_joinarr ', _cast.addr );
&   endif
    gg941Deallocate( TransContext, _cast.addr );
    END;
(*ENDIF*) 
dmli.d_joins.jrc_cnt      := 0;
dmli.d_joins.jrc_capacity := 1;
dmli.d_joins.jrc_joinarr  := @dmli.d_jrc_initial_arr;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54expand_tabarr(
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info);
 
CONST
      c_chunksize = 4;
 
VAR
      _ix           : integer;
      _old_capacity : tsp00_Int4;
 
      _cast         : RECORD
            CASE boolean OF
                true :
                    (addr: tsp00_Addr);
                false :
                    (ptr : tak_all_from_tables_ptr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
_old_capacity := dmli.d_tabarr_capacity;
&ifdef diagnose
IF  ( dmli.d_tabarr_capacity < cak00_maxsources )
THEN
    dmli.d_tabarr_capacity := dmli.d_tabarr_capacity + 1
ELSE
    a07_b_put_error( acv, e_too_many_sourcetables, 1 );
(*ENDIF*) 
&else
IF  ( cak00_maxsources - c_chunksize >= dmli.d_tabarr_capacity )
THEN
    dmli.d_tabarr_capacity := dmli.d_tabarr_capacity + c_chunksize
ELSE
    BEGIN
    IF  ( dmli.d_tabarr_capacity = cak00_maxsources )
    THEN
        a07_b_put_error( acv, e_too_many_sourcetables, 1 )
    ELSE
        dmli.d_tabarr_capacity := cak00_maxsources;
    (*ENDIF*) 
    END;
(*ENDIF*) 
&endif
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
&   ifdef trace
    t01int4( ak_sem, 'old capacity', _old_capacity );
    t01int4( ak_sem, 'new capacity', dmli.d_tabarr_capacity );
&   endif
    IF  _old_capacity = cak_init_join_tab_size
    THEN
        _cast.addr := gg941Allocate( acv.a_transinf.tri_trans,
              dmli.d_tabarr_capacity * sizeof(tak_one_table) )
    ELSE
        BEGIN
        _cast.ptr  := dmli.d_tabarr;
        _cast.addr := gg941ReAllocate( acv.a_transinf.tri_trans,
              dmli.d_tabarr_capacity * sizeof(tak_one_table), _cast.addr );
        END;
    (*ENDIF*) 
    dmli.d_tabarr := _cast.ptr;
    ;
    IF   ( dmli.d_tabarr = NIL )
    THEN
        BEGIN
        dmli.d_tabarr_capacity := _old_capacity;
        a07_b_put_error( acv, e_no_more_memory, 1 );
        END
    ELSE
        IF  _old_capacity = cak_init_join_tab_size
        THEN
            FOR _ix := 1 TO cak_init_join_tab_size DO
                dmli.d_tabarr^[_ix] := dmli.d_init_tabarr[_ix];
            (*ENDFOR*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a54expand_tabarr_ex(
            VAR acv      : tak_all_command_glob;
            VAR dmli     : tak_dml_info;
            new_capacity : tsp00_Int4);
 
VAR
      _ix           : integer;
      _old_capacity : tsp00_Int4;
 
      _cast         : RECORD
            CASE boolean OF
                true :
                    (addr: tsp00_Addr);
                false :
                    (ptr : tak_all_from_tables_ptr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  ( new_capacity > cak00_maxsources )
THEN
    a07_b_put_error( acv, e_too_many_sourcetables, 1 )
ELSE
    BEGIN
    _old_capacity := dmli.d_tabarr_capacity;
    dmli.d_tabarr_capacity := new_capacity;
&   ifdef trace
    t01int4( ak_sem, 'old capacity', _old_capacity );
    t01int4( ak_sem, 'new capacity', dmli.d_tabarr_capacity );
&   endif
    IF  _old_capacity = cak_init_join_tab_size
    THEN
        BEGIN
        IF  new_capacity > cak_init_join_tab_size
        THEN
            _cast.addr := gg941Allocate( acv.a_transinf.tri_trans,
                  dmli.d_tabarr_capacity * sizeof(tak_one_table) )
        ELSE
            BEGIN
            dmli.d_tabarr_capacity := cak_init_join_tab_size;
            _cast.ptr              := dmli.d_tabarr;
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        _cast.ptr  := dmli.d_tabarr;
        _cast.addr := gg941ReAllocate( acv.a_transinf.tri_trans,
              dmli.d_tabarr_capacity * sizeof(tak_one_table), _cast.addr );
        END;
    (*ENDIF*) 
    dmli.d_tabarr := _cast.ptr;
    IF  ( dmli.d_tabarr = NIL )
    THEN
        BEGIN
        dmli.d_tabarr_capacity := _old_capacity;
        a07_b_put_error( acv, e_no_more_memory, 1 );
        END
    ELSE
        IF  _old_capacity = cak_init_join_tab_size
        THEN
            FOR _ix := 1 TO cak_init_join_tab_size DO
                dmli.d_tabarr^[_ix] := dmli.d_init_tabarr[_ix];
            (*ENDFOR*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
