.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 2000-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-14
*****************************************************
modname : VAK660
changed : 2000-11-14
module  : Execute_Select_Expression
 
Author  : ElkeZ
Created : 1985-10-16
*****************************************************
 
Purpose : First part of processing mass selects
 
Define  :
 
        PROCEDURE
              a660_select (
                    VAR acv   : tak_all_command_glob;
                    startnode : tsp00_Int2);
 
        PROCEDURE
              a660select (
                    VAR acv                     : tak_all_command_glob;
                    startnode                   : tsp00_Int2;
                    VAR dmli                    : tak_dml_info;
                    VAR pseudo_resultset_select : boolean);
 
        PROCEDURE
              a660_explain (
                    VAR acv   : tak_all_command_glob;
                    startnode : tsp00_Int2);
 
        PROCEDURE
              a660build_view_treeid (
                    VAR acv     : tak_all_command_glob;
                    VAR tableid : tgg00_Surrogate;
                    VAR tree    : tgg00_FileId);
 
        PROCEDURE
              a660construct_subtree (
                    VAR acv      : tak_all_command_glob;
                    VAR sub_tree : tgg00_FileId;
                    sub_count    : integer);
 
        PROCEDURE
              a660_short_first_part (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR tree : tgg00_FileId);
 
        PROCEDURE
              a660_search_one_table (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    table_node     : integer;
                    all            : boolean;
                    check_teresult : boolean;
                    lock_spec      : tak_lockenum;
                    wanted_priv    : tak00_PrivR);
 
        PROCEDURE
              a660_new_pparsp (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    needs_twuseold : boolean;
                    complicate     : boolean);
 
        PROCEDURE
              a660_lowpars_pparsp (
                    VAR acv        : tak_all_command_glob;
                    VAR pparsp     : tak_sysbufferaddress;
                    needs_twuseold : boolean;
                    to_release     : boolean;
                    lowpars        : tsp00_Uint1);
 
        PROCEDURE
              a660_prefix_delete (
                    VAR acv       : tak_all_command_glob;
                    VAR parsk     : tak_parskey;
                    VAR del_cnt   : integer;
                    prefix_length : integer);
 
        PROCEDURE
              a660_from_part (
                    VAR acv   : tak_all_command_glob;
                    VAR dmli  : tak_dml_info;
                    from_node : integer);
 
        PROCEDURE
              a660_lock (
                    VAR acv        : tak_all_command_glob;
                    lock_n         : integer;
                    VAR lock_state : tgg00_HandlingSet);
 
        PROCEDURE
              a660_isolevel (
                    VAR acv        : tak_all_command_glob;
                    isolation_n    : tsp00_Int2;
                    VAR lock_state : tgg00_HandlingSet);
 
        PROCEDURE
              a660_query_execute (
                    VAR acv                     : tak_all_command_glob;
                    VAR dmli                    : tak_dml_info;
                    s_n                         : integer;
                    new_parsinfo                : boolean;
                    filled_part2_bytes          : integer;
                    VAR sr_rec                  : tak71_strat_rec;
                    VAR pseudo_resultset_select : boolean;
                    level                       : integer;
                    no_in_level                 : integer;
                    from_sel_found              : boolean);
 
        PROCEDURE
              a660_first_sel_part (
                    VAR acv                     : tak_all_command_glob;
                    VAR dmli                    : tak_dml_info;
                    VAR select_rec              : tak_select_record;
                    VAR pseudo_resultset_select : boolean);
 
        FUNCTION
              a660same_pred (
                    VAR acv   : tak_all_command_glob;
                    same_node : integer) : integer;
 
        PROCEDURE
              a660fsame_pred (
                    VAR acv             : tak_all_command_glob;
                    same_node           : integer;
                    VAR first_same_node : integer;
                    VAR node_diff       : integer);
 
        FUNCTION
              a660lower_pred (
                    VAR acv    : tak_all_command_glob;
                    lower_node : integer) : integer;
 
        FUNCTION
              a660pos_pred (
                    VAR acv  : tak_all_command_glob;
                    pos_node : integer) : integer;
 
        PROCEDURE
              a660set_subq_info (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a660output_tablename (
                    VAR acv  : tak_all_command_glob);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Resultname_handling : VAK663;
 
        PROCEDURE
              a663get_result_records (
                    VAR acv    : tak_all_command_glob;
                    dstate     : tak_directory_state;
                    resid      : tsp00_Int4;
                    VAR pbasep : tak_sysbufferaddress;
                    VAR ok     : boolean);
 
        PROCEDURE
              a663_get_result_info (
                    VAR acv          : tak_all_command_glob;
                    VAR resname      : tsp00_KnlIdentifier;
                    VAR modul_name   : tsp00_KnlIdentifier;
                    VAR resname_addr : tak_sysbufferaddress;
                    make_new_res     : boolean;
                    ftemptype        : tgg00_TfnTemp;
                    dstate           : tak_directory_state;
                    VAR f_ok         : boolean);
 
        PROCEDURE
              a663_make_res_buf (
                    VAR acv      : tak_all_command_glob;
                    VAR dmli     : tak_dml_info;
                    VAR res_name : tsp00_KnlIdentifier;
                    VAR res_tree : tgg00_FileId);
 
        PROCEDURE
              a663restable_get (
                    VAR acv    : tak_all_command_glob;
                    dstate     : tak_directory_state;
                    VAR tablen : tsp00_KnlIdentifier;
                    VAR sparr  : tak_syspointerarr;
                    VAR ok     : boolean);
 
        FUNCTION
              a663parse_for_execute (VAR acv : tak_all_command_glob) : boolean;
 
        PROCEDURE
              a663_intern_resname_drop (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01sysnullkey      : tgg00_SysInfoKey;
              a01defaultkey      : tgg00_SysInfoKey;
              a01fullset         : tak_columnset;
              a01_i_tablekey     : tsp00_KnlIdentifier;
              a01_i_temp         : tsp00_KnlIdentifier;
              a01_il_b_identifier: tsp00_KnlIdentifier;
              a01_zero_res_name  : tsp00_KnlIdentifier;
              a01_into_res_name  : tsp00_KnlIdentifier;
              a01_i_internal     : tsp00_KnlIdentifier;
              a01_i_sysdd        : tsp00_KnlIdentifier;
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05_unsigned_int2_get (
                    VAR acv  : tak_all_command_glob;
                    pos      : integer;
                    l        : tsp00_Int2;
                    err_code : tsp00_Int4;
                    VAR int  : tsp00_Int2);
 
        PROCEDURE
              a05int4_get (
                    VAR acv            : tak_all_command_glob;
                    pos                : integer;
                    length             : tsp00_Int2;
                    VAR int            : tsp00_Int4);
 
        PROCEDURE
              a05identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06finish_curr_retpart (
                    VAR acv   : tak_all_command_glob;
                    part_kind : tsp1_part_kind;
                    arg_count : tsp00_Int2);
 
        PROCEDURE
              a06GetBaseTreeid (
                    VAR acv     : tak_all_command_glob;
                    VAR baseRec : tak_baserecord;
                    VAR tree    : tgg00_FileId);
 
        PROCEDURE
              a06retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
        PROCEDURE
              a06a_mblock_init (
                    VAR acv      : tak_all_command_glob;
                    mtype        : tgg00_MessType;
                    m2type       : tgg00_MessType2;
                    VAR tree     : tgg00_FileId);
 
        PROCEDURE
              a06cpy_mblock (
                    VAR acv        : tak_all_command_glob;
                    VAR src_mblock : tgg00_MessBlock;
                    VAR dst_mblock : tgg00_MessBlock;
                    withoutData    : boolean;
                    VAR e          : tgg00_BasisError);
 
        FUNCTION
              a06_table_exist (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR authname : tsp00_KnlIdentifier;
                    VAR tablen   : tsp00_KnlIdentifier;
                    VAR sparr    : tak_syspointerarr;
                    get_all      : boolean) : boolean;
 
        PROCEDURE
              a06get_username (
                    VAR acv        : tak_all_command_glob;
                    VAR tree_index : integer;
                    VAR username   : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06get_priv  (
                    VAR acv       : tak_all_command_glob;
                    VAR brec      : tak_sysbufferaddress;
                    required_priv : tak00_PrivilegeSet;
                    VAR priv      : tak_privilege);
 
        PROCEDURE
              a06det_user_id (
                    VAR acv      : tak_all_command_glob;
                    VAR authname : tsp00_KnlIdentifier;
                    VAR authid   : tgg00_Surrogate);
 
        PROCEDURE
              a06drop_fieldlist_references (VAR fieldlists : tgg00_FieldLists);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061app_columnname (
                    VAR acv               : tak_all_command_glob;
                    VAR base_rec          : tak_baserecord;
                    VAR column            : tsp00_KnlIdentifier;
                    VAR index             : integer);
 
        FUNCTION
              a061exist_columnname (
                    VAR base_rec    : tak_baserecord;
                    VAR column      : tsp00_KnlIdentifier;
                    VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
        FUNCTION
              a061exist_columnindex (VAR base_rec : tak_baserecord;
                    extcolno        : integer;
                    VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
        PROCEDURE
              a061get_colname (VAR col_info : tak00_columninfo;
                    VAR colname  : tsp00_KnlIdentifier);
&       ifdef trace
 
        PROCEDURE
              a061td_colinfo (
                    VAR colinfo : tak00_columninfo;
                    index : integer);
&       endif
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_const_b_put_error (
                    VAR acv    : tak_all_command_glob;
                    b_err      : tgg00_BasisError;
                    err_code   : tsp00_Int4;
                    param_addr : tsp00_MoveObjPtr;
                    const_len  : integer);
 
        PROCEDURE
              a07_kw_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    kw       : integer);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
        PROCEDURE
              a07put_error_pos (
                    VAR acv : tak_all_command_glob;
                    err_pos : tsp00_Int4);
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10mblock_into_cache (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    VAR mblock   : tgg00_MessBlock;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_copy_catalog_rec (
                    VAR acv         : tak_all_command_glob;
                    VAR old_key     : tgg00_SysInfoKey;
                    del_old_rec     : boolean;
                    VAR new_key     : tgg00_SysInfoKey;
                    new_segment_id  : tsp00_C2;
                    add_new_rec     : boolean;
                    VAR b_err       : tgg00_BasisError);
 
        PROCEDURE
              a10repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10del_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              a10_rel_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10add_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10prefix_parsid_delete (
                    VAR acv       : tak_all_command_glob;
                    VAR parsk     : tak_parskey;
                    VAR del_cnt   : integer;
                    prefix_length : integer);
 
        PROCEDURE
              a10new (
                    VAR acv  : tak_all_command_glob;
                    obj_size : tsp00_Int4;
                    VAR p    : tak_sysbufferaddress);
 
        PROCEDURE
              a10dispose (
                    VAR acv : tak_all_command_glob;
                    VAR p : tak_sysbufferaddress);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              SQLManager : vak101;
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
        FUNCTION
              a101_GetExtendedTempFileType(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tgg00_TfnTemp;
 
        PROCEDURE
              a101_MapSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier;
                    pos            : integer);
 
        PROCEDURE
              a101_SetTempFileLevel(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId;
                    level          : tsp00_Int2(*ptocConst*));
 
        PROCEDURE
              a101_SetTempFileSublevel(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId;
                    sublevel       : tsp00_Int2(*ptocConst*));
 
        PROCEDURE
              a101_SetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId;
                    sublevel       : tsp00_Int4(*ptocConst*));
 
        FUNCTION
              a101_GetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tsp00_Int4;
 
        PROCEDURE
              a101_GetLogicalFilename(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
        FUNCTION
              a101_StoreTableInfo (
                    VAR acv              : tak_all_command_glob;
                    VAR SchemaID         : tgg00_Surrogate;
                    VAR TableName        : tsp00_KnlIdentifier;
                    WithSpecifiedSchema  : boolean;
                    prepareHandle        : tgg00_VoidPtr) : boolean;
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103CatalogSchemaId (
                    VAR catalogSchemaId : tgg00_Surrogate);
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
      ------------------------------ 
 
        FROM
              SequenceWrapper : VAK104;
 
        PROCEDURE
              ak104_DropReference_MS (
                    VAR sequence     : tsp00_MoveObjPtr);
 
      ------------------------------ 
 
        FROM
              AK_View_semantic : VAK16;
 
        PROCEDURE
              a16col_to_view_description (
                    VAR acv      : tak_all_command_glob;
                    VAR dmli     : tak_dml_info;
                    VAR col_info : tak00_columninfo;
                    use_extcolno : boolean);
 
      ------------------------------ 
 
        FROM
              AK_data_dictionary : VAK38;
 
        PROCEDURE
              a38_add_progusage (
                    VAR acv   : tak_all_command_glob;
                    progtyp   : tak_progusagetyp;
                    VAR authn : tsp00_KnlIdentifier;
                    VAR tabln : tsp00_KnlIdentifier;
                    VAR coln  : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_universal_show_tools : VAK40;
 
        PROCEDURE
              a40add_explain_record (
                    VAR acv  : tak_all_command_glob;
                    VAR expl : tak71_explain_rec);
 
      ------------------------------ 
 
        FROM
              Executing_dispatcher : VAK501;
 
        PROCEDURE
              a501get_resname (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
      ------------------------------ 
 
        FROM
              Executing_complex : VAK502;
 
        PROCEDURE
              a502destroy_file (
                    VAR acv          : tak_all_command_glob;
                    VAR tree         : tgg00_FileId);
 
        PROCEDURE
              a502empty_result (
                    VAR acv      : tak_all_command_glob;
                    VAR dmli     : tak_dml_info;
                    VAR res_tree : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK54;
 
        PROCEDURE
              a54_dml_init (
                    VAR acv   : tak_all_command_glob;
                    VAR dmli  : tak_dml_info;
                    in_union  : boolean);
 
        PROCEDURE
              a54_dml_finalize (
                    VAR dmli         : tak_dml_info;
                    VAR TransContext : tgg00_TransContext);
 
        PROCEDURE
              a54_get_pparsp_pinfop (
                    VAR acv   : tak_all_command_glob;
                    VAR sparr : tak_syspointerarr;
                    mtype     : tgg00_MessType);
 
        PROCEDURE
              a54_select_last_part (
                    VAR acv              : tak_all_command_glob;
                    VAR dmli             : tak_dml_info;
                    VAR user_result_tree : tgg00_FileId;
                    last_pars_part       : boolean);
 
        PROCEDURE
              a54_fixedpos (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a54complicated_view (
                    VAR acv      : tak_all_command_glob;
                    VAR dmli     : tak_dml_info;
                    VAR tableid  : tgg00_Surrogate);
 
        PROCEDURE
              a54set_complex_entry (
                    VAR acv     : tak_all_command_glob;
                    call_reason : tak_complex_call_reason);
 
        PROCEDURE
              a54add_next_temp_lock (
                    VAR acv           : tak_all_command_glob;
                    VAR tabid         : tgg00_Surrogate;
                    globstate         : tgg00_HandlingSet);
 
        PROCEDURE
              a54_loc_temp_locks (
                    VAR acv   : tak_all_command_glob;
                    globstate : tgg00_HandlingSet;
                    VAR sparr : tak_syspointerarr);
 
        PROCEDURE
              a54expand_tabarr(
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a54expand_tabarr_ex(
                    VAR acv      : tak_all_command_glob;
                    VAR dmli     : tak_dml_info;
                    new_capacity : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              DML_Parts : VAK55;
 
        PROCEDURE
              a55realloc_parsinfo (
                    VAR acv          : tak_all_command_glob;
                    VAR parsinfo_ptr : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              Select_Syntax : VAK60;
 
        PROCEDURE
              a60_get_longinfobuffer (
                    VAR acv   : tak_all_command_glob;
                    VAR sparr : tak_syspointerarr;
                    col_cnt   : integer;
                    resultno  : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Select_List : VAK61;
 
        PROCEDURE
              a61_check_val_params (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    sel_node : integer;
                    par_node : integer);
 
        PROCEDURE
              a61_search_table (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info
                    );
 
        PROCEDURE
              a61_search_table_by_columnindex (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a61_update_column (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    VAR minkeylen  : integer;
                    curr_n         : integer);
 
        PROCEDURE
              a61_set_jump (
                    VAR mblock : tgg00_MessBlock;
                    stentrynr : integer;
                    operator  : tgg00_StackEntryType);
 
        PROCEDURE
              a61_put_last_func (VAR acv : tak_all_command_glob);
&       ifdef LONGREC
 
        PROCEDURE
              a61_rel_old_table (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    i        : integer);
&       endif
 
      ------------------------------ 
 
        FROM
              Execute_Factor : VAK640;
 
        PROCEDURE
              a640factor (
                    VAR acv      : tak_all_command_glob;
                    VAR dmli     : tak_dml_info;
                    VAR colin    : tak00_scolinf;
                    VAR act_node : integer);
 
      ------------------------------ 
 
        FROM
              Execute_Where_Part : VAK65;
 
        PROCEDURE
              a65_search_condition (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    VAR first_node : integer);
 
        PROCEDURE
              a65_set_operator (
                    VAR acv  : tak_all_command_glob;
                    operator : tgg00_StackOpType);
 
      ------------------------------ 
 
        FROM
              Subquery_handling : VAK661;
 
        PROCEDURE
              a661get_from_select_table (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    table_node : tsp00_Int2;
                    all        : boolean);
 
        PROCEDURE
              a661a_subquery (
                    VAR acv                     : tak_all_command_glob;
                    VAR dmli                    : tak_dml_info;
                    VAR sr_rec                  : tak71_strat_rec;
                    curr_n                      : tsp00_Int2;
                    VAR pseudo_resultset_select : boolean);
 
        PROCEDURE
              a661_build_t_fromsel_tableid (
                    VAR syskey_tableid  : tgg00_Surrogate;
                    VAR fn_tableid      : tgg00_Surrogate;
                    VAR curr_ex_parskey : tak_parskey;
                    site                : tgg00_ServerdbNo;
                    from_select_no      : tsp00_Int2);
 
        PROCEDURE
              a661_fdelete_fromtab_results (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a661exec_sub (
                    VAR acv                 : tak_all_command_glob;
                    VAR dmli                : tak_dml_info;
                    VAR parsk               : tak_parskey;
                    curr_n                  : tsp00_Int2;
                    VAR del_cnt             : integer;
                    m_acv_info_output       : boolean;
                    pseudo_resultset_select : boolean);
 
      ------------------------------ 
 
        FROM
              Union_handling : VAK662;
 
        PROCEDURE
              a662realloc_new_unionrec (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a662_union_select (
                    VAR acv   : tak_all_command_glob;
                    startnode : tsp00_Int2;
                    VAR dmli  : tak_dml_info);
 
        PROCEDURE
              a662_start_union_select (
                    VAR acv                     : tak_all_command_glob;
                    startnode                   : tsp00_Int2;
                    VAR dmli                    : tak_dml_info;
                    VAR pseudo_resultset_select : boolean;
                    VAR parsk                   : tak_parskey);
 
        PROCEDURE
              a662_recursive_select (
                    VAR acv  : tak_all_command_glob;
                    startnode : tsp00_Int2;
                    VAR dmli  : tak_dml_info);
 
      ------------------------------ 
 
        FROM
              Complex_View_Optimization : VAK664;
 
        PROCEDURE
              a664new_optimize_info (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    table_node : integer;
                    end_node   : integer);
 
      ------------------------------ 
 
        FROM
              Part2_Select_Expression : VAK67;
 
        PROCEDURE
              a67_s_sel_second_part (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    VAR select_rec : tak_select_record;
                    VAR sr_rec     : tak71_strat_rec);
 
        PROCEDURE
              a67_update_atinoutpos (
                    VAR acv          : tak_all_command_glob;
                    VAR dmli         : tak_dml_info;
                    update_changepos : boolean;
                    output_n         : tsp00_Int2);
 
        PROCEDURE
              a67_sel2_second_part (
                    VAR acv            : tak_all_command_glob;
                    VAR dmli           : tak_dml_info;
                    VAR res_tree       : tgg00_FileId;
                    is_not_corr_search : boolean;
                    last_pars_part     : boolean;
                    view_done          : boolean;
                    VAR sr_rec         : tak71_strat_rec);
 
        PROCEDURE
              a67_sel3_second_part (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    VAR select_rec : tak_select_record;
                    VAR sr_rec     : tak71_strat_rec);
 
        PROCEDURE
              a67_put_all_views_into (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a67_first_corr (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a67_corr_search (
                    VAR acv         : tak_all_command_glob;
                    VAR dmli        : tak_dml_info;
                    only_having_columns_get : boolean;
                    VAR starttabno  : integer;
                    only_split      : boolean;
                    predefined_pno  : integer;
                    VAR old_infolen : integer;
                    VAR rtree       : tgg00_FileId);
 
        PROCEDURE
              a67_bextcolindex (
                    VAR d_esparr : tak_syspointerarr;
                    outcolno     : integer);
 
      ------------------------------ 
 
        FROM
              Build_Strategy : VAK70;
 
        PROCEDURE
              a70_strategy_search (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    VAR rtree  : tgg00_FileId;
                    VAR sr_rec : tak71_strat_rec);
 
      ------------------------------ 
 
        FROM
              Join_Select : VAK680;
 
        FUNCTION
              a680is_outer_predicate (
                    VAR dmli   : tak_dml_info;
                    st_pos     : tsp00_Int2) : boolean;
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              join_trace_routines : VAK683;
 
        PROCEDURE
              a683_output (
                    debug    : tgg00_Debug;
                    VAR joins : tak_joinrec);
&       endif
 
      ------------------------------ 
 
        FROM
              Resulttable : VAK73;
 
        PROCEDURE
              a73_close_execute (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    VAR res_name   : tsp00_KnlIdentifier;
                    VAR modul_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a73parsid_describe_semantic (VAR acv : tak_all_command_glob;
                    inclusive_output : boolean;
                    VAR infop        : tak_sysbufferaddress;
                    VAR columnnamep  : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              Hint_Handling : VAK80;
 
        PROCEDURE
              a80store_cmd_hint_info(
                    VAR acv     : tak_all_command_glob;
                    VAR dmli    : tak_dml_info;
                    select_node : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              filesysteminterface_7 : VBD07;
 
        PROCEDURE
              b07cget_record (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Lkey;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b07cnext_record (
                    VAR t          : tgg00_TransContext;
                    VAR file_id    : tgg00_FileId;
                    VAR rk         : tgg00_Lkey;
                    VAR set_result : tgg00_BdSetResultRecord;
                    VAR tree_pos   : tgg00_FilePos;
                    VAR b          : tsp00_MoveObj);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01ConsistentReadEnabled  : boolean;
              g01nil_stack_desc         : tgg00_StackDesc;
              g01unicode                : boolean;
 
        FUNCTION
              g01one_join_phase : boolean;
 
        PROCEDURE
              g01opmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C24;
                    msg_value : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04check_if_top_level (
                    VAR st_addr   : tgg00_StackListPtr;
                    stpos         : integer;
                    maxstpos      : integer;
                    VAR top_level : boolean);
 
        PROCEDURE
              g04build_temp_tree_id (
                    VAR curr : tgg00_FileId;
                    VAR t : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove   (
                    mod_id         : tsp00_C6;
                    mod_intern_num : tsp00_Int4;
                    size1          : tsp00_Int4;
                    size2          : tsp00_Int4;
                    val1           : tsp00_MoveObjPtr;
                    p1             : tsp00_Int4;
                    val2           : tsp00_MoveObjPtr;
                    p2             : tsp00_Int4;
                    cnt            : tsp00_Int4;
                    VAR e          : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove  (
                    mod_id         : tsp00_C6;
                    mod_intern_num : tsp00_Int4;
                    size1          : tsp00_Int4;
                    size2          : tsp00_Int4;
                    b1             : tsp00_MoveObjPtr;
                    pos1           : tsp00_Int4;
                    b2             : tsp00_MoveObjPtr;
                    p2             : tsp00_Int4;
                    cnt            : tsp00_Int4;
                    VAR e          : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalFill  (
                    mod_id         : tsp00_C6;
                    mod_intern_num : tsp00_Int4;
                    size           : tsp00_Int4;
                    m              : tsp00_MoveObjPtr;
                    pos            : tsp00_Int4;
                    len            : tsp00_Int4;
                    fillchar       : char;
                    VAR e          : tgg00_BasisError);
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01handling (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname;
                    s     : tgg00_HandlingSet);
 
        PROCEDURE
              t01stackentry (
                    debug          : tgg00_Debug;
                    VAR st         : tgg00_StackEntry;
                    entry_index    : integer);
 
        PROCEDURE
              t01stdesc (
                    debug          : tgg00_Debug;
                    nam            : tsp00_Sname;
                    VAR stack_desc : tgg00_StackDesc);
 
        PROCEDURE
              t01p2bool (
                    debug : tgg00_Debug;
                    nam_1 : tsp00_Sname;
                    bool1 : boolean;
                    nam_2 : tsp00_Sname;
                    bool2 : boolean);
 
        PROCEDURE
              t01sname (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname);
 
        PROCEDURE
              t01p2int4 (
                    debug : tgg00_Debug;
                    nam_1 : tsp00_Sname;
                    int_1 : tsp00_Int4;
                    nam_2 : tsp00_Sname;
                    int_2 : tsp00_Int4);
 
        PROCEDURE
              t01recursive_state (
                    debug           : tgg00_Debug;
                    nam             : tsp00_Sname;
                    recursive_state : tak_recursive_state);
 
        PROCEDURE
              t01knl_identifier (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01corr_type (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    corr_type : tak_corr_type);
 
        PROCEDURE
              t01execution_kind (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    ex_kind   : tak_execution_kind);
 
        PROCEDURE
              t01bool (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    curr_bool: boolean);
 
        PROCEDURE
              t01command_kind (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    command_kind : tak_commandkind);
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR m         : tgg00_MessBlock);
 
        PROCEDURE
              t01name (
                    level : tgg00_Debug;
                    nam : tsp00_Name);
 
        PROCEDURE
              t01lidentifier (
                    level      : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01treeid (
                    layer      : tgg00_Debug;
                    nam        : tsp00_Sname;
                    VAR treeid : tgg00_FileId);
 
        PROCEDURE
              t01stqual (
                    debug      : tgg00_Debug;
                    VAR qual   : tgg00_QualBuf;
                    stack_addr : tgg00_StackListPtr);
 
        PROCEDURE
              t01buf1 (
                    level     : tgg00_Debug;
                    VAR buf   : tgg00_SysInfoKey;
                    pos_start : integer;
                    pos_end   : integer);
 
        PROCEDURE
              t01surrogate (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR tabid : tgg00_Surrogate);
 
        PROCEDURE
              t01trace_symbol(
                    debug   : tgg00_Debug;
                    name    : tsp00_Sname;
                    symb    : tak_sc_symbol);
&       ENDIF
 
      ------------------------------ 
 
        FROM
              Packet_handling: VSP26;
 
        PROCEDURE
              s26find_part (
                    VAR segm         : tsp1_segment;
                    part_kind        : tsp1_part_kind;
                    VAR part_ptr     : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30: VSP30;
 
        FUNCTION
              s30klen (
                    VAR str : tsp00_KnlIdentifier;
                    val : char; cnt : integer) : integer;
 
        FUNCTION
              s30unilnr (
                    str       : tsp00_MoveObjPtr;
                    skip_val  : tsp00_C2;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80: VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              ak104_DropReference_MS;
 
              tak104_MemorySequence tsp00_MoveObjPtr
 
        PROCEDURE
              s30klen;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              t01buf1;
 
              tsp00_Buf tgg00_SysInfoKey
 
.CM *-END-* synonym -------------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      c_del_old_rec      = true (* a10_copy_catalog_rec *);
      c_add_new_rec      = true (* a10_copy_catalog_rec *);
      c_use_extcolno     = true (* a16col_to_view_description *);
      c_in_union         = true (* a54_dml_init *);
      c_having_part      = true (* ak660two_phase *);
      c_store_infos      = true (* ak660endpart *);
      (*                           ak660two_phase *)
      c_repl_only        = true (* ak660move_in_hbuf *);
      c_where_done       = true (* ak660two_repl_complex_output *);
      c_functions_not_single_fields = true;
      (*                           ak660qual_part_transfer *)
      (*                           ak660two_repl_complex_output *)
      c_output           = true (* ak660where_transfer *);
      c_needs_twuseold   = true (* a660_new_pparsp *);
      (*                           a660_lowpars_pparsp *)
      c_from_sel_found   = true (* a660_query_execute *);
      c_check_teresult   = true (* a660_search_one_table *);
      c_make_new_res     = true (* a663_get_result_info *);
      c_only_having_columns_get = true (* a67_corr_search *);
      c_only_split       = true (* a67_corr_search *);
      c_is_not_corr_search=true (* a67_sel2_second_part *);
      c_last_pars_part   = true (* a67_sel2_second_part *);
      c_update_changepos = true (* a67_update_atinoutpos *);
      c_no_predefined_pno= 0    (* a67_corr_search *);
      c_without_data     = true (* a06cpy_mblock *);
      c_inclusive_output = true (* a73parsid_describe_semantic *);
 
TYPE
 
      t_where_rec = RECORD
            start  : tsp00_Int2;
            length : tsp00_Int2
      END;
 
      t_where_array = ARRAY [ 1..4096 ] OF t_where_rec;
      t_where_arr_ptr = ^t_where_array;
      (* PTS 1113318 E.Z. *)
 
      t_store_for_endpart = RECORD
            ke              : tgg00_SysInfoKey;
            param_parskey   : tgg00_SysInfoKey;
            hinoutpos       : integer;
            hkeylen         : integer;
            hreclen         : integer;
            first_res       : boolean;
            h_use_rowno     : boolean;
            hd_distinct     : tgg04_Distinct;
            hd_single       : boolean;
            hd_colcount     : integer;
            hd_rowno        : integer;
            hdm_union       : boolean;
            messbuf_stored  : boolean;
            lowpars         : tsp00_Uint1;
            m2type          : tgg00_MessType2;
            old_subcntlevel : tsp00_Int2;
            last_res_tree   : tgg00_FileId;
            hmbp            : tgg00_MessBlockPtr;
            hqbp            : tgg00_QualBufPtr;
            hbuf            : tak_sysbufferaddress;
      END;
 
 
 
(*------------------------------*) 
 
PROCEDURE
      ak660check_update_columns (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            update_n : integer);
 
VAR
      _curr_n    : integer;
      _found      : boolean;
      _column     : tsp00_KnlIdentifier;
 
BEGIN
_curr_n := update_n;
dmli.d_foundset := [  ];
WHILE ((_curr_n <> 0) AND (acv.a_returncode = 0)) DO
    BEGIN
    dmli.d_column := a01_il_b_identifier;
    IF  (acv.a_comp_type = at_odbc) OR (acv.a_comp_type = at_jdbc)
    THEN
        BEGIN
        dmli.d_user   := a01_il_b_identifier;
        dmli.d_table  := a01_il_b_identifier;
        WITH acv.a_ap_tree^[ _curr_n ] DO
            IF  n_symb in [ s_tablename, s_authid ]
            THEN
                BEGIN
                dmli.d_vppos := acv.a_ap_tree^[ _curr_n ].n_pos;
                dmli.d_n_pos := dmli.d_vppos;
                a06get_username (acv, _curr_n, dmli.d_user);
                WITH acv.a_ap_tree^[ _curr_n ] DO
                    IF  n_symb = s_tablename
                    THEN
                        BEGIN
                        a05identifier_get (acv, _curr_n,
                              sizeof (dmli.d_table), dmli.d_table);
                        _curr_n := n_sa_level;
                        END;
                    (*ENDIF*) 
                (*ENDWITH*) 
                a61_search_table (acv, dmli);
                END
            (*ENDIF*) 
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        WITH acv.a_ap_tree^[ _curr_n ] DO
            BEGIN
            _found := false;
            IF  ( n_symb = s_columnid ) (* PTS 1128197 D.T. *)
            THEN
                BEGIN
                dmli.d_fromtabnode := acv.a_ap_tree^[ _curr_n ].n_fromtabnode;
                dmli.d_columnindex := acv.a_ap_tree^[ _curr_n ].n_columnindex;
                _found := a061exist_columnindex (dmli.d_sparr.pbasep^.sbase,
                      dmli.d_columnindex, dmli.d_colbuf);
                END
            ELSE
                BEGIN
                a05identifier_get (acv,
                      _curr_n, sizeof (dmli.d_column), dmli.d_column);
                _found := a061exist_columnname (dmli.d_sparr.pbasep^.sbase,
                      dmli.d_column, dmli.d_colbuf);
                END;
            (*ENDIF*) 
            IF  _found
            THEN
                BEGIN
                IF  ((ctinvisible in dmli.d_colbuf^.ccolpropset) OR
                    ((NOT dmli.d_tabarr^[ dmli.d_acttabindex ].oall_priv) AND
                    NOT (dmli.d_colbuf^.cextcolno
                    in dmli.d_tabarr^[ dmli.d_acttabindex ].osetallpriv)))
                THEN
                    BEGIN
                    IF  ( n_symb = s_columnid )
                    THEN
                        BEGIN
                        a061get_colname (dmli.d_colbuf^, _column);
                        a07_nb_put_error (acv, e_unknown_columnname,
                              n_pos, _column);
                        END
                    ELSE
                        a07_nb_put_error (acv, e_unknown_columnname,
                              n_pos, dmli.d_column);
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    dmli.d_foundset := dmli.d_foundset + [dmli.d_colbuf^.cextcolno];
                    END
                (*ENDIF*) 
                END
            ELSE
                a07_nb_put_error (acv, e_unknown_columnname,
                      n_pos, dmli.d_column);
            (*ENDIF*) 
            _curr_n := acv.a_ap_tree^[ _curr_n ].n_sa_level
            END
        (*ENDWITH*) 
    (*ENDIF*) 
    END
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660close_used_resultname (VAR acv : tak_all_command_glob);
 
VAR
      _name_n   : integer;
      _n        : tsp00_KnlIdentifier;
      _mret     : integer;
      _merr     : integer;
      _mex_kind : tak_execution_kind;
      _sparr    : tak_syspointerarr;
 
BEGIN
_name_n := 0;
REPEAT
    _name_n := acv.a_ap_tree^[ _name_n ].n_lo_level
UNTIL
    ((acv.a_ap_tree^[ _name_n ].n_proc = a63)              AND
    ((acv.a_ap_tree^[ _name_n ].n_subproc = cak_x_mass_select) OR
    (acv.a_ap_tree^[ _name_n ].n_subproc  = cak_x_decl_cursor)));
(*ENDREPEAT*) 
_name_n := acv.a_ap_tree^[ _name_n ].n_lo_level;
IF  ((acv.a_ap_tree^[ _name_n ].n_proc   = a63) AND
    (acv.a_ap_tree^[ _name_n ].n_subproc = cak_x_distinct))
THEN
    BEGIN
    _name_n         := acv.a_ap_tree^[ _name_n ].n_lo_level;
    END;
(*ENDIF*) 
_n := a01_il_b_identifier;
WITH acv.a_ap_tree^[ _name_n ] DO
    IF  n_symb = s_identifier
    THEN
        a05identifier_get (acv, _name_n, sizeof (_n), _n);
    (*ENDIF*) 
(*ENDWITH*) 
_mret        := acv.a_returncode;
_merr        := acv.a_errorpos;
acv.a_returncode := 0;
_mex_kind    := acv.a_ex_kind;
acv.a_ex_kind   := parsing_executing;
a73_close_execute (acv, _sparr, _n, acv.a_modul_name);
IF  acv.a_returncode =
    a071_return_code (e_unknown_resultname, acv.a_sqlmode)
THEN
    BEGIN
    acv.a_returncode := 0;
    acv.a_errorpos   := 0;
    acv.a_err_parm_cnt := 0;
    END;
(*ENDIF*) 
acv.a_ex_kind   := _mex_kind;
acv.a_returncode := _mret;
acv.a_errorpos   := _merr;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660describe_resultname (
            VAR acv          : tak_all_command_glob;
            VAR dmli         : tak_dml_info;
            VAR sel_res_name : tsp00_KnlIdentifier;
            tree_index       : integer);
 
VAR
      _index : integer;
      _len   : integer;
 
BEGIN
sel_res_name := a01_il_b_identifier;
(* PTS 1122027 E.Z. *)
IF  NOT dmli.d_only_sem_check
THEN
    BEGIN
    IF  dmli.d_sparr.pparsp^.sparsinfo.p_cnt_infos >=
        dmli.d_sparr.pparsp^.sparsinfo.p_max_infos
    THEN
        a55realloc_parsinfo (acv, dmli.d_sparr.pparsp);
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        _len := sizeof (sel_res_name);
        IF  g01unicode
        THEN
            _len := _len DIV 2;
        (*ENDIF*) 
        _index := acv.a_ap_tree^[tree_index].n_length;
        WITH dmli.d_sparr.pinfop^.sshortinfo, siinfo[_index],
             dmli.d_sparr.pparsp^.sparsinfo DO
            BEGIN
            IF  _index > sicount
            THEN
                sicount := _index;
            (*ENDIF*) 
            IF  g01unicode
            THEN
                sp1i_data_type := dunicode
            ELSE
                sp1i_data_type := dcha;
            (*ENDIF*) 
            sp1i_mode        := [ sp1ot_mandatory ];
            sp1i_io_type     := sp1io_input;
            sp1i_frac        := 0;
            sp1i_length      := _len;
            IF  g01unicode
            THEN
                sp1i_in_out_len  := _len * 2 + 1
            ELSE
                sp1i_in_out_len  := _len * acv.a_max_codewidth + 1;
            (*ENDIF*) 
            p_cnt_infos := p_cnt_infos + 1;
            WITH  p_pars_infos[ p_cnt_infos ] DO
                BEGIN
                fp_kind         := fp_result_name;
                IF  NOT acv.a_variable_input
                THEN
                    BEGIN
                    sp1i_bufpos   := acv.a_input_data_pos;
                    fp_fromposv14 := acv.a_input_data_pos
                    END
                ELSE
                    fp_fromposv14 := sp1i_param_no;
                (*ENDIF*) 
                acv.a_input_data_pos := acv.a_input_data_pos + sp1i_in_out_len;
                fp_datalenv14   := _len;
                IF  g01unicode
                THEN
                    fp_dataiolenv14 := _len * 2 + 1
                ELSE
                    fp_dataiolenv14 := _len * acv.a_max_codewidth + 1
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
            END;
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(* PTS 1113318 E.Z. parameter-list *)
(*------------------------------*) 
 
PROCEDURE
      ak660endpart (
            VAR acv           : tak_all_command_glob;
            VAR dmli          : tak_dml_info;
            VAR sfe_rec       : t_store_for_endpart;
            order_n           : integer;
            last_pars_part    : boolean;
            store_infos       : boolean;
            use_lowpars       : boolean;
            VAR res_tree      : tgg00_FileId;
            VAR select_rec    : tak_select_record;
            VAR sr_rec        : tak71_strat_rec);
 
VAR
      (* PTS 1113318 E.Z. *)
      _b_err           : tgg00_BasisError;
      _store_parsinfos : boolean;
      _aux_data_len    : integer;
      _i               : integer;
      _dropped_pinfos  : integer;
      _hbuf            : tak_sysbufferaddress;
      _param_parsbptr  : tak_sysbufferaddress;
      _m_command_kind  : tak_commandkind;
      _strat_ptr       : ^tgg07_StrategyInfo;
 
BEGIN
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    dmli.d_inoutpos  := sfe_rec.hinoutpos;
    dmli.d_keylen    := sfe_rec.hkeylen;
    dmli.d_reclen    := sfe_rec.hreclen;
    dmli.d_use_order := order_n <> 0;
    _hbuf := NIL;
    IF  ((acv.a_mblock.mb_qual^.mr_resnum <> csp_rescnt_zero) OR
        (acv.a_ex_kind = only_parsing) OR
        (sfe_rec.m2type = mm_with_functions))
    THEN
        BEGIN
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            a10get_sysinfo (acv, sfe_rec.ke, d_release, _hbuf, _b_err);
            IF  _b_err <> e_ok
            THEN
                a07_b_put_error (acv, _b_err, 1)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            WITH acv.a_mblock DO
                BEGIN
                sfe_rec.hmbp          := @_hbuf^.smessblock.mbr_mess_block;
                sfe_rec.hqbp          := sfe_rec.hmbp^.mb_qual;
                _aux_data_len         := acv.a_mblock.mb_data_len;
                acv.a_mblock.mb_data_len := 0;
                a06cpy_mblock (acv, sfe_rec.hmbp^, acv.a_mblock, NOT c_without_data, _b_err);
                acv.a_mblock.mb_data_len := _aux_data_len;
                IF  _b_err <> e_ok
                THEN
                    a07_b_put_error (acv, _b_err, 1)
                ELSE
                    BEGIN
&                   ifdef TRACE
                    t01messblock (ak_sem, '1. mblock   ', acv.a_mblock);
&                   endif
                    acv.a_mblock.mb_struct      := mbs_stack_addr;
                    acv.a_mblock.mb_qual^.mtree := res_tree;
                    END;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        sr_rec.sr_must_result := true;
        a70_strategy_search (acv, dmli, sfe_rec.last_res_tree, sr_rec);
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            _store_parsinfos := true;
            IF  acv.a_insert_select     AND
                (acv.a_intern_select_cnt = acv.a_max_intern_select) AND
                (NOT dmli.d_subquery)    AND
                (NOT acv.a_from_select) AND
                (acv.a_fromsel_n = 0)
            THEN
                IF  acv.a_mblock.mb_type2 <> mm_with_functions
                THEN
                    WITH acv.a_mblock.mb_qual^.mtree DO
                        IF  a101_IsExtendedTempFile (acv,
                            acv.a_mblock.mb_qual^.mtree) AND
                            (a101_GetExtendedTempFileType (acv,
                            acv.a_mblock.mb_qual^.mtree)
                            <> ttfnUserResult_egg00)
                        THEN
                            _store_parsinfos:= true
                        ELSE
                            BEGIN
                            (* PTS 1000514 E.Z. *)
                            _strat_ptr := @acv.a_mblock.mb_strat^[
                                  acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].epos ];
                            IF  ((_strat_ptr^.str_distinc = no_distinct)
                                AND
                                ( NOT _strat_ptr^.str_use_rowno )
                                AND
                                (_strat_ptr^.str_qual_kind <> inv_only)
                                AND
                                (NOT
                                (a101_IsExtendedTempFile (acv,
                                _strat_ptr^.str_result_id) AND
                                ( a101_GetExtendedTempFileType (acv,
                                _strat_ptr^.str_result_id)
                                = ttfnComplexSelect_egg00))))
                            THEN
                                _store_parsinfos := false
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (*ENDIF*) 
            (*ENDIF*) 
            IF  _store_parsinfos
            THEN
                BEGIN
                IF  acv.a_ex_kind = only_parsing
                THEN
                    BEGIN
&                   ifdef TRACE
                    t01int4 (ak_sem, 'd_corr      ', ord(dmli.d_corr));
                    t01int4 (ak_sem, 'd_lowpars   ', dmli.d_lowpars);
                    t01int4 (ak_sem, 'endpart_lowp', 1);
&                   endif
                    (* PTS 1111978 E.Z. *)
                    IF  ((dmli.d_corr <> no_correlation) AND
                        use_lowpars)
                    THEN
                        a660_lowpars_pparsp (acv, dmli.d_sparr.pparsp,
                              NOT c_needs_twuseold,
                              NOT dmli.d_only_sem_check, sfe_rec.lowpars + 1)
                    ELSE
                        BEGIN
                        _m_command_kind := acv.a_command_kind;
                        IF  (select_rec.sel_has_subquery
                            AND (acv.a_command_kind = union_command)
                            (* subquery below this query *)
                            ) OR
                            (acv.a_command_kind = union_in_sub_command)
                        THEN
                            acv.a_command_kind := sub_in_complex_command;
                        (*ENDIF*) 
                        a660_new_pparsp (acv, dmli.d_sparr,
                              dmli.d_corr = no_correlation,
                              (* PTS 1000184 *)
                              (dmli.d_lowpars=csp_maxint1) AND
                              ((dmli.d_subquery AND (_m_command_kind <> union_in_sub_command))
                              OR (_m_command_kind = sub_in_union_command)));
                        acv.a_command_kind := _m_command_kind
                        END;
                    (*ENDIF*) 
                    IF  acv.a_returncode = 0
                    THEN
                        WITH dmli.d_sparr.pparsp^.sparsinfo DO
                            BEGIN
                            p_subcntlevel := sfe_rec.old_subcntlevel;
                            (* PTS 1111978 E.Z. *)
                            IF  dmli.d_corr <> no_correlation
                            THEN
                                BEGIN
                                a10get_sysinfo (acv, sfe_rec.param_parskey, d_release,
                                      _param_parsbptr, _b_err);
                                IF  _b_err <> e_ok
                                THEN
                                    a07_b_put_error (acv, _b_err, 1)
                                ELSE
                                    BEGIN
                                    _dropped_pinfos := 0;
                                    FOR _i := 1 TO _param_parsbptr^.sparsinfo.p_cnt_infos DO
                                        BEGIN
                                        p_pars_infos [ _i - _dropped_pinfos ] :=
                                              _param_parsbptr^.sparsinfo.p_pars_infos [ _i ];
                                        WITH p_pars_infos [ _i - _dropped_pinfos ] DO
                                            IF  fp_kind = fp_fill_part2_to_len
                                            THEN
                                                IF  fp_len > acv.a_mblock.mb_data_len
                                                THEN
                                                    _dropped_pinfos := succ(_dropped_pinfos);
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                        (*ENDWITH*) 
                                        END;
                                    (*ENDFOR*) 
                                    p_cnt_infos := _param_parsbptr^.sparsinfo.p_cnt_infos - _dropped_pinfos;
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  store_infos
                THEN
                    a54_select_last_part (acv,
                          dmli, sfe_rec.last_res_tree, last_pars_part);
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    ELSE
        IF  NOT dmli.d_single
        THEN
            BEGIN
            a502empty_result (acv, dmli, sfe_rec.last_res_tree);
            IF  acv.a_returncode = 0
            THEN
                acv.a_mblock.mb_qual^.mr_restree := sfe_rec.last_res_tree;
            (*ENDIF*) 
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660join_query_execute (
            VAR acv                     : tak_all_command_glob;
            VAR dmli                    : tak_dml_info;
            s_n                         : integer;
            VAR sr_rec                  : tak71_strat_rec;
            VAR pseudo_resultset_select : boolean);
 
VAR
      _e                 : tgg00_BasisError;
      _m_acv_info_output : boolean;
      _m_ex_kind         : tak_execution_kind;
      _cnt               : integer;
      _parsk             : tak_parskey;
      _m_command_kind    : tak_commandkind;
 
BEGIN
a660_prefix_delete (acv, acv.a_pars_last_key, _cnt,
      cak_complete_prefix + 1);
_e := e_ok;
IF  dmli.d_esparr.pbasep <> NIL
THEN
    BEGIN
    a10del_sysinfo (acv, dmli.d_esparr.pbasep^.syskey, _e);
&   ifdef trace
    dmli.d_esparr.pbasep := NIL
&         endif
    END;
(*ENDIF*) 
IF  _e <> e_ok
THEN
    a07_b_put_error (acv, _e, 1)
ELSE
    BEGIN
    IF  acv.a_isolation_info <> temp_lock_rec_get
    THEN
        acv.a_isolation_info := temp_lock_rec_needed;
    (*ENDIF*) 
    _m_command_kind    := acv.a_command_kind;
    acv.a_command_kind    := subquery_command;
    _m_acv_info_output := acv.a_info_output;
&   IFDEF TRACE
    t01bool (ak_sem, 'new m_info  ', _m_acv_info_output);
&   ENDIF
    acv.a_info_output           := false;
    _m_ex_kind               := acv.a_ex_kind;
    acv.a_ex_kind               := only_parsing;
    pseudo_resultset_select := _m_acv_info_output
          AND (_m_ex_kind <> only_parsing);
    a660_query_execute (acv, dmli, s_n, NOT acv.a_from_select,
          cgg_rec_key_offset, sr_rec, pseudo_resultset_select, 1, 1,
          NOT c_from_sel_found);
    a54set_complex_entry (acv, c_set_last_pars);
    _parsk           := acv.a_pars_last_key;
    _parsk.p_id[ 1 ] := acv.a_first_parskey;
    _parsk.p_kind    := m_complex;
    _parsk.p_no      := 0;
&   IFDEF TRACE
    t01int4 (ak_sem, 's_n         ', s_n);
    t01execution_kind (ak_sem, 'm_ex_kind   ', _m_ex_kind);
    t01bool (ak_sem, 'd_only_sem_c', dmli.d_only_sem_check);
&   ENDIF
    IF  (acv.a_returncode = 0) AND
        (NOT acv.a_from_select)
    THEN
        a54_loc_temp_locks (acv, dmli.d_globstate, dmli.d_sparr);
    (*ENDIF*) 
    IF  (acv.a_returncode = 0) AND
        ((_m_ex_kind <> only_parsing) AND (NOT dmli.d_only_sem_check))
    THEN
        a661exec_sub (acv, dmli, _parsk, s_n,
              _cnt, _m_acv_info_output, pseudo_resultset_select)
    ELSE
        IF  acv.a_returncode <> 0
        THEN
            BEGIN
            IF  (acv.a_returncode      = cak_e_corelated_subquery_not_allowed) OR
                (acv.a_main_returncode = cak_e_corelated_subquery_not_allowed)
            THEN
                BEGIN
                IF  (acv.a_ex_kind <> only_parsing)
                THEN
                    a660_prefix_delete (acv, _parsk, _cnt, cak_intern_prefix);
                (*ENDIF*) 
                acv.a_ap_tree^[ s_n ].n_symb := s_sum;
                END
            ELSE
                a660_prefix_delete (acv, _parsk, _cnt, cak_complete_prefix);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    acv.a_ex_kind := _m_ex_kind;
&   IFDEF TRACE
    t01bool (ak_sem, 'again m_info', _m_acv_info_output);
&   ENDIF
    acv.a_info_output  := _m_acv_info_output;
    acv.a_command_kind := _m_command_kind;
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660keycolumn (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info);
 
VAR
      _ci      : integer;
      _coln    : tsp00_KnlIdentifier;
 
BEGIN
dmli.d_keylen := RESCNT_MXGG04;
IF  ((dmli.d_distinct <> no_distinct) OR dmli.d_union)
THEN
    dmli.d_keylen := dmli.d_keylen + HASHVAL_MXGG04;
(*ENDIF*) 
dmli.d_inoutpos         := cgg_rec_key_offset + 1 + dmli.d_keylen;
IF  ((acv.a_intern_select_cnt = acv.a_max_intern_select) OR
    (acv.a_fromsel_n > 0)                                OR
    (acv.a_recursive_state = rs_first_select)            OR
    (acv.a_union_cnt > 0 ))
    AND
    NOT(dmli.d_view AND (dmli.d_phase_cnt < cak_complex_view_indicator))
THEN
    BEGIN
    _coln := a01_i_tablekey;
    a061app_columnname (acv, dmli.d_esparr.pbasep^.sbase, _coln, _ci);
&   IFDEF TRACE
    t01int4 (ak_sem, 'ci          ', _ci);
&   ENDIF
    WITH a103GetColumn ( dmli.d_esparr.pbasep^.sbase, _ci )^ DO
        BEGIN
        (* PTS 1116837 E.Z. *)
        dmli.d_esparr.pbasep^.sbase.bkeycolcount := 1;
        cextcolno    := 1;
        creccolno    := 1;
        ctabno       := 1;
        cdatatyp     := dchb;
        ccolpropset  := [ ctkey, ctinvisible ];
        cdatalen     := dmli.d_keylen;
        cdatafrac    := cak_frac_offset;
        cinoutlen    := cdatalen;
        cbinary      := false;
        cnextind     := 0;
        cudtdatatype := cak_edummy;
        cfiller02    := chr(0);
        WITH ccolstack DO
            BEGIN
            etype         := st_fixkey;
            eop           := op_none;
            epos          := 1;
            elen_var      := cdatalen;
            ecol_tab[ 1 ] := chr (0);
            ecol_tab[ 2 ] := chr (0);
            END;
        (*ENDWITH*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660later_output (VAR acv : tak_all_command_glob);
 
VAR
      _stop  : integer;
      _i     : integer;
 
BEGIN
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    _i := acv.a_mblock.mb_qual^.mqual_pos;
    IF  ( acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mqual_pos ].etype = st_jump_output )
    THEN
        _stop := acv.a_mblock.mb_qual^.mqual_pos +
              acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mqual_pos ].epos - 2
    ELSE
        _stop := acv.a_mblock.mb_qual^.mqual_pos;
    (*ENDIF*) 
    WHILE ( _i <= _stop ) DO
        BEGIN
        IF  ( acv.a_mblock.mb_st^[ _i ].etype = st_output ) AND
            (* ORDER BY and output column *)
            ( acv.a_mblock.mb_st^[ _i ].eop_out = op_o_output_hold )
        THEN
            acv.a_mblock.mb_st^[ _i + 1 ].eop_out := op_o_output_later;
        (*ENDIF*) 
        _i:= succ(_i);
        END;
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
END;
 
(* PTS 1113318 E.Z. parameter-list *)
(*------------------------------*) 
 
PROCEDURE
      ak660move_in_hbuf (
            VAR acv     : tak_all_command_glob;
            VAR sfe_rec : t_store_for_endpart;
            no_of_hbuf  : integer;
            repl_only   : boolean);
 
VAR
      _b_err          : tgg00_BasisError;
      _init_mstack_state : tgg00_StackState;
      _i              : integer;
      _aux_data_len   : integer;
 
BEGIN
_init_mstack_state := acv.a_mblock.mb_qual^.mstack_state;
acv.a_mblock.mb_qual_len        := MB_PART1_HEAD_MXGG00;
IF  acv.a_returncode = 0
THEN
    BEGIN
    sfe_rec.ke := a01sysnullkey;
    FOR _i := 1 TO SURROGATE_MXGG00 DO
        sfe_rec.ke.sauthid[ _i ] := cak_tempinfo_byte;
    (*ENDFOR*) 
    sfe_rec.ke.sentrytyp     := cak_emessblock;
    sfe_rec.ke.slinkage[ 2 ] := chr(no_of_hbuf);
    IF  repl_only
    THEN
        a10del_sysinfo (acv, sfe_rec.ke, _b_err);
    (*ENDIF*) 
    _aux_data_len             := acv.a_mblock.mb_data_len;
    acv.a_mblock.mb_data_len := cgg_rec_key_offset;
    a10mblock_into_cache (acv, sfe_rec.ke, acv.a_mblock, d_fix,
          sfe_rec.hbuf, _b_err);
    acv.a_mblock.mb_data_len := _aux_data_len;
    IF  _b_err = e_ok
    THEN
        BEGIN
&       ifdef TRACE
        t01messblock (ak_sem, 'mess_block >', sfe_rec.hbuf^.smessblock.mbr_mess_block);
        t01messblock (ak_sem, 'MESSBLOCK   ', acv.a_mblock);
&       endif
        IF  repl_only
        THEN
            a10add_sysinfo (acv, sfe_rec.hbuf, _b_err);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  _b_err <> e_ok
    THEN
        a07_b_put_error (acv, _b_err, 1)
    ELSE
        BEGIN
        IF  NOT repl_only
        THEN
            BEGIN
            (* initialize messblock for first phase *)
&           ifdef trace
            t01name (ak_sem, 'initialize a_mbloc');
&           endif
            acv.a_mblock.mb_qual_len           := MB_PART1_HEAD_MXGG00;
            acv.a_mblock.mb_qual^.mstack_desc  := g01nil_stack_desc;
            acv.a_mblock.mb_qual^.mqual_pos    := 1;
            acv.a_mblock.mb_qual^.mqual_cnt    := 1;
            acv.a_mblock.mb_qual^.mfirst_free  := 2;
            acv.a_mblock.mb_qual^.mstack_state := _init_mstack_state;
            acv.a_mblock.mb_qual^.mst_max      := acv.a_stack_size DIV
                  sizeof (tgg00_StackEntry);
            acv.a_mblock.mb_st_max          := acv.a_mblock.mb_qual^.mst_max;
            acv.a_mblock.mb_qual^.mst_addr  := acv.a_stack_addr;
            acv.a_mblock.mb_st              := acv.a_stack_addr;
            acv.a_mblock.mb_st_size         := acv.a_stack_size;
            END;
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660order_by (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            order_n  : tsp00_Int2;
            output_n : tsp00_Int2);
 
VAR
      _curr_n       : integer;
      _node         : integer;
      _o_node       : integer;
      _old_error    : integer;
      _old_return   : integer;
      _pos          : integer;
      _s_node       : integer;
&     ifdef LONGREC
      _col_found    : boolean;
&     endif
 
BEGIN
WITH dmli.d_order_or_group_cols^ DO
    BEGIN
    ocntord := 0;
    IF  ((acv.a_ap_tree^[ order_n ].n_proc = a63)
        AND
        ((acv.a_ap_tree^[ order_n ].n_subproc = cak_x_order) OR
        ( acv.a_ap_tree^[ order_n ].n_subproc = cak_x_group_by)))
    THEN
        BEGIN
        _curr_n  := acv.a_ap_tree^[ order_n ].n_lo_level;
        WHILE ((_curr_n <> 0) AND (acv.a_returncode = 0)) DO
            BEGIN
            ocntord := succ(ocntord);
            IF  ocntord > cak00_maxordercolumns
            THEN
                (* oocntord is ok, see vak07 isunipos *)
                a07_b_put_error (acv, e_too_many_order_columns,
                      -ocntord)
            ELSE
                WITH ofield[ ocntord ] DO
                    BEGIN
                    ofname   := a01_il_b_identifier;
                    ofno     := 0;
                    offno    := 0;
                    ofstno   := 0;
                    ofasc    := [ is_order_asc ];
                    oftabno  := 0;
                    ofapos   := 0;
                    ofnode   := 0;
                    offill   := 0;
                    dmli.d_user   := a01_il_b_identifier;
                    dmli.d_table  := a01_il_b_identifier;
                    dmli.d_column := a01_il_b_identifier;
                    _o_node   := acv.a_ap_tree^[ _curr_n ].n_lo_level;
&                   ifdef trace
                    t01trace_symbol( ak_sem, '[_o_node].sy',
                          acv.a_ap_tree^[ _o_node ].n_symb);
&                   endif
                    CASE acv.a_ap_tree^[ _o_node ].n_symb OF
                        s_unsigned_integer :
                            WITH acv.a_ap_tree^[ _o_node ] DO
                                BEGIN
                                (* is not possible in GROUP BY        *)
                                (* asc and desc are not possible, too *)
                                a05_unsigned_int2_get (acv, n_pos,
                                      n_length, e_unknown_ordercolumn, ofno);
                                ofno := succ(ofno)
                                END;
                            (*ENDWITH*) 
                        s_equal :
                            ofno := succ(acv.a_ap_tree^[ _o_node ].n_pos);
                        s_authid,
                        s_tablename,
                        s_columnname,
                        s_columnid:
                            (* PTS 1113255 E.Z. *)
                            IF  (dmli.d_union AND
                                (acv.a_ap_tree^[ _o_node ].n_symb <> s_columnname) AND
                                (acv.a_ap_tree^[ _o_node ].n_symb <> s_columnid))  (* PTS 1128197 D.T. *)
                            THEN
                                a07_b_put_error (acv,
                                      e_order_col_must_be_number,
                                      acv.a_ap_tree^[ _o_node ].n_pos)
                            ELSE
                                BEGIN
                                _node := _o_node;
                                WITH acv.a_ap_tree^[ _o_node ] DO
                                    BEGIN
                                    dmli.d_vppos := n_pos;
                                    dmli.d_n_pos := n_pos;
                                    a06get_username (acv, _o_node, dmli.d_user);
                                    END;
                                (*ENDWITH*) 
                                WITH acv.a_ap_tree^[ _o_node ] DO
                                    IF  n_symb = s_tablename
                                    THEN
                                        BEGIN
                                        a05identifier_get (acv, _o_node,
                                              sizeof(dmli.d_table), dmli.d_table);
                                        _o_node := n_sa_level;
                                        END;
                                    (*ENDIF*) 
                                (*ENDWITH*) 
                                WITH acv.a_ap_tree^[ _o_node ] DO
                                    IF  n_symb = s_columnid (* PTS 1128197 D.T. *)
                                    THEN
                                        BEGIN (* s_columnid *)
                                        _pos := acv.a_ap_tree^[ _o_node ].n_pos;
                                        dmli.d_fromtabnode := acv.a_ap_tree^[ _o_node ].n_fromtabnode;
                                        dmli.d_columnindex := acv.a_ap_tree^[ _o_node ].n_columnindex;
                                        END
                                    ELSE
                                        BEGIN (* s_columnname *)
                                        _pos     := n_pos;
                                        a05identifier_get (acv, _o_node,
                                              sizeof(dmli.d_column), dmli.d_column);
                                        END;
                                    (*ENDIF*) 
                                (*ENDWITH*) 
                                _old_return := acv.a_returncode;
                                _old_error  := acv.a_errorpos;
                                (* PTS 1112977 E.Z. *)
                                IF  (dmli.d_user  = a01_il_b_identifier)
                                    AND
                                    (dmli.d_table = a01_il_b_identifier)
                                    AND
                                    NOT (acv.a_ap_tree^[ _o_node ].n_symb = s_columnid) (* PTS 1128197 D.T. *)
                                THEN
                                    ofasc := ofasc + [ is_col_only_specified ];
                                (* PTS 1113255 E.Z. *)
                                (*ENDIF*) 
                                IF  dmli.d_union
                                THEN
                                    BEGIN
                                    ofnode  := _o_node;
                                    a07_b_put_error (acv, e_unknown_columnname, _pos)
                                    END
                                ELSE
                                    BEGIN
                                    IF  acv.a_ap_tree^[ _o_node ].n_symb = s_columnid (* PTS 1128197 D.T. *)
                                    THEN
                                        a61_search_table_by_columnindex(acv, dmli)
                                    ELSE
                                        a61_search_table (acv, dmli);
                                    (*ENDIF*) 
                                    END;
                                (*ENDIF*) 
                                IF  acv.a_returncode <> 0
                                THEN
                                    BEGIN
                                    IF  (
                                        (acv.a_returncode =
                                        a071_return_code (e_unknown_columnname,
                                        acv.a_sqlmode))                   OR
                                        ((acv.a_returncode =
                                        a071_return_code (e_missing_column_definite,
                                        acv.a_sqlmode))   AND
                                        (dmli.d_order_or_group_cols = @dmli.d_order_cols))
                                        )
                                        AND
                                        (dmli.d_user  = a01_il_b_identifier)
                                        AND
                                        (dmli.d_table = a01_il_b_identifier)
                                        AND
                                        NOT (acv.a_ap_tree^[ _o_node ].n_symb = s_columnid) (* PTS 1128197 D.T. *)
                                        (*unknown_columnname =>
                                              reference_name*)
                                    THEN
                                        BEGIN
                                        IF  acv.a_returncode =
                                            a071_return_code (e_missing_column_definite,
                                            acv.a_sqlmode)
                                        THEN
                                            ofasc := ofasc + [ is_not_definite ];
                                        (*ENDIF*) 
                                        acv.a_returncode := _old_return;
                                        acv.a_errorpos   := _old_error;
                                        ofname      := dmli.d_column;
                                        END
                                    ELSE
                                        a07put_error_pos (acv, _pos)
                                    (*ENDIF*) 
                                    END
                                ELSE
                                    BEGIN
                                    a16col_to_view_description (acv, dmli,
                                          dmli.d_colbuf^, NOT c_use_extcolno);
                                    WITH dmli.d_colbuf^,
                                         dmli.d_tabarr^[ dmli.d_acttabindex ] DO
                                        BEGIN
                                        oftabno := dmli.d_acttabindex;
                                        IF  ((ccolstack.etype <> st_func) OR
                                            (* LASTFUNCTION *)
                                            ((ccolstack.etype = st_func) AND
                                            (ccolstack.eop_func = op_f_none)))
                                        THEN
                                            BEGIN
                                            IF  (oview) AND
                                                (oisjoinview in ospecialname)
                                            THEN
                                                offno := cextcolno
                                            ELSE
                                                offno := creccolno;
                                            (*ENDIF*) 
                                            END
                                        ELSE
                                            IF  (acv.a_ap_tree^[ order_n ].n_subproc = cak_x_order)
                                            THEN
                                                BEGIN
                                                ofnode  := _o_node;
                                                ofasc   := ofasc + [ is_val_expression ];
                                                acv.a_ap_tree^[ order_n ].n_symb := s_sum;
                                                END
                                            ELSE
                                                a07_nb_put_error (acv,
                                                      e_invalid_view_column,
                                                      _pos, dmli.d_column);
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                        IF  ctopt in ccolpropset
                                        THEN
                                            ofasc := ofasc + [ is_opt ];
                                        (*ENDIF*) 
                                        ofnode := _o_node;
                                        IF  (cdatatyp = dcha) AND
                                            (NOT acv.a_nls_params.nls_binary) AND
                                            (acv.a_ap_tree^[order_n].n_subproc = cak_x_order)
                                        THEN
                                            BEGIN
                                            ofnode := _node;
                                            ofasc  := ofasc +
                                                  [is_val_expression,
                                                  is_nls_column]
                                            END
                                        ELSE
                                            ofname := dmli.d_column
                                        (*ENDIF*) 
                                        END
                                    (*ENDWITH*) 
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                        OTHERWISE
                            IF  dmli.d_union
                            THEN
                                a07_b_put_error (acv,
                                      e_order_col_must_be_number,
                                      acv.a_ap_tree^[ _o_node ].n_pos)
                            ELSE
                                BEGIN
                                oftabno := dmli.d_acttabindex;
                                ofnode  := _o_node;
                                ofasc   := ofasc + [ is_val_expression ];
                                END;
                            (*ENDIF*) 
                        END;
                    (*ENDCASE*) 
                    WITH acv.a_ap_tree^[ _o_node ] DO
                        BEGIN
                        _s_node := n_sa_level;
                        ofapos := n_pos
                        END;
                    (*ENDWITH*) 
                    WHILE _s_node <> 0 DO
                        BEGIN
                        IF  acv.a_ap_tree^[ _s_node ].n_symb = s_desc
                        THEN
                            ofasc := ofasc - [ is_order_asc ];
                        (*ENDIF*) 
                        _s_node := acv.a_ap_tree^[ _s_node ].n_sa_level
                        END;
                    (*ENDWHILE*) 
                    _curr_n := acv.a_ap_tree^[ _curr_n ].n_sa_level
                    END
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
&       ifdef LONGREC
        IF  (acv.a_returncode = 0)                           AND
            NOT(acv.a_ap_tree^[ output_n ].n_symb in
                [ s_count, s_sum ])                          AND
            NOT dmli.d_subquery                              AND
            (ocntord < cak00_maxordercolumns)                AND
            (NOT dmli.d_view)                                AND
            (acv.a_recursive_state = rs_no_recursive_select) AND
            (acv.a_fromsel_n = 0)                            AND
            (acv.a_union_cnt = 0)                            AND
            (acv.a_max_intern_select = 0)                    AND
            ((acv.a_ap_tree^[ acv.a_ap_tree^[0].n_lo_level ].n_proc <> a56) OR
            ( acv.a_ap_tree^[ acv.a_ap_tree^[0].n_lo_level ].n_subproc
            <> cak_x_insert_select))                     AND
            NOT (acv.a_is_ddl = ddl_create_as_select)
        THEN
            BEGIN
            a61_rel_old_table (acv, dmli, 1);
            dmli.d_column := a01_i_internal;
            _col_found := a061exist_columnname (dmli.d_sparr.pbasep^.sbase,
                  dmli.d_column, dmli.d_colbuf);
            IF  _col_found
            THEN
                BEGIN
                ocntord := succ(ocntord);
                WITH ofield[ ocntord ] DO
                    BEGIN
                    ofname   := a01_il_b_identifier;
                    ofno     := 0;
                    offno    := 0;
                    ofstno   := 0;
                    ofasc    := [ is_order_asc ];
                    oftabno  := 0;
                    ofapos   := 0;
                    ofnode   := 0;
                    offill   := 0;
                    (*
                          _o_node   := acv.a_ap_tree^[ _curr_n ].n_lo_level;
                          *)
                    a16col_to_view_description (acv, dmli,
                          dmli.d_colbuf^, NOT c_use_extcolno);
                    WITH dmli.d_colbuf^,
                         dmli.d_tabarr^[ dmli.d_acttabindex ] DO
                        BEGIN
                        oftabno := dmli.d_acttabindex;
                        IF  ((ccolstack.etype <> st_func) OR
                            (* LASTFUNCTION *)
                            ((ccolstack.etype = st_func) AND
                            (ccolstack.eop_func = op_f_none)))
                        THEN
                            BEGIN
                            IF  (oview) AND
                                (oisjoinview in ospecialname)
                            THEN
                                offno := cextcolno
                            ELSE
                                offno := creccolno;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  ctopt in ccolpropset
                        THEN
                            ofasc := ofasc + [ is_opt ];
                        (*ENDIF*) 
                        ofnode := _o_node;
                        ofname := dmli.d_column
                        END;
                    (*ENDWITH*) 
                    WITH acv.a_ap_tree^[ _o_node ] DO
                        BEGIN
                        _s_node := n_sa_level;
                        ofapos := n_pos
                        END;
                    (*ENDWITH*) 
                    END
                (*ENDWITH*) 
                END
            (*ENDIF*) 
            END;
&       endif
&       IFDEF TRACE
        (*ENDIF*) 
        t01int4 (ak_sem, 'cntord      ', ocntord);
        t01int4 (ak_sem, 'curr_n      ', _curr_n);
&       ENDIF
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660qual_part_transfer (
            VAR acv                     : tak_all_command_glob;
            VAR dmli                    : tak_dml_info;
            VAR hbuf                    : tak_sysbufferaddress;
            functions_not_single_fields : boolean;
            start_pos                   : integer;
            end_pos                     : integer);
 
VAR
      _function_stackentry_cnt : integer;
      _next_pos                : integer;
      _qual_end                : integer;
      _act_pos                : integer;
      _start_function_pos      : integer;
      _start_for_update_epos   : integer;
      _hmbp                    : tgg00_MessBlockPtr;
      _hqbp                    : tgg00_QualBufPtr;
      _update_filledbyte       : boolean;
 
BEGIN
&ifdef trace
t01p2int4( ak_sem, 'start_pos   ', start_pos,
      'end_pos     ', end_pos );
t01bool (ak_sem, 'functions?  ', functions_not_single_fields);
t01int4  (ak_sem, 'd_keylen    ', dmli.d_keylen);
&endif
_act_pos := start_pos;
_qual_end := end_pos;
IF  functions_not_single_fields
THEN
    (* functions_not_single_fields = 'true' from ak660three_phase() *)
    _start_function_pos := 0
ELSE
    (* functions_not_single_fields = 'false' from ak660phase_division() *)
    (* functions_not_single_fields = 'false' from ak660where_transfer() *)
    _start_function_pos := _qual_end + 1;
(*ENDIF*) 
_function_stackentry_cnt := 0;
_start_for_update_epos := acv.a_mblock.mb_qual^.mfirst_free;
_hmbp                  := @hbuf^.smessblock.mbr_mess_block;
_hqbp                  := _hmbp^.mb_qual;
_update_filledbyte     := false;
WHILE _act_pos <= _qual_end DO
    BEGIN
&   IFDEF TRACE
    t01int4 (ak_sem, 'd_inoutpos  ', dmli.d_inoutpos);
    t01int4 (ak_sem, '_act_pos    ', _act_pos);
    t01int4 (ak_sem, 'first_free  ', acv.a_mblock.mb_qual^.mfirst_free);
    t01bool (ak_sem, 'work for 3. ', _start_function_pos < _act_pos );
&   ENDIF
    IF  ( _start_function_pos < _act_pos )
    THEN
        BEGIN
        _next_pos := _act_pos - 1;
        (* step to next function *)
        REPEAT
            _next_pos := succ(_next_pos)
        UNTIL
            (((_hmbp^.mb_st^[ _next_pos ].etype = st_func) AND
            (_hmbp^.mb_st^[ _next_pos ].eop_func <> op_f_none))
            (* any function, not LASTFUNCTION *)
            OR
            (_next_pos = _qual_end));
        (*ENDREPEAT*) 
        IF  ( _hmbp^.mb_st^[ _next_pos ].etype <> st_func )
        THEN
            (* no function found *)
            _start_function_pos := _qual_end + 1
        ELSE
            BEGIN
            (* LASTFUNCTION on qual end found *)
            IF  _hmbp^.mb_st^[ _next_pos ].eop = op_none
            THEN
                _hmbp^.mb_st^[ _next_pos ].etype := st_dummy;
            (*ENDIF*) 
            _function_stackentry_cnt :=
                  ord(_hmbp^.mb_st^[ _next_pos ].ecol_tab[ 2 ]);
            _start_function_pos := _next_pos + 1 -
                  _function_stackentry_cnt
            END;
        (*ENDIF*) 
&       IFDEF TRACE
        t01int4 (ak_sem, 'start_funct ', _start_function_pos);
&       ENDIF
        END;
    (*ENDIF*) 
    IF  (( _start_function_pos = _act_pos ) AND
        ( _function_stackentry_cnt > 0 ))
    THEN
        (* function searched and found *)
        BEGIN
        IF  ( acv.a_mblock.mb_qual^.mfirst_free + _function_stackentry_cnt >
            acv.a_mblock.mb_st_max )
        THEN
            BEGIN
            a07_b_put_error (acv, e_too_many_mb_stackentries, 1);
            _act_pos := _qual_end + 1;
            END
        ELSE
            BEGIN
            (* copy function to messblock *)
            SAPDB_PascalMove ('VAK660',   1,    
                  _hmbp^.mb_st_size, acv.a_mblock.mb_st_size,
                  @_hmbp^.mb_st^,
                  (_start_function_pos - 1) * STACK_ENTRY_MXGG00 + 1,
                  @acv.a_mblock.mb_st^,
                  (acv.a_mblock.mb_qual^.mfirst_free-1) * STACK_ENTRY_MXGG00 + 1,
                  _function_stackentry_cnt * STACK_ENTRY_MXGG00,
                  acv.a_returncode);
            acv.a_mblock.mb_qual^.mfirst_free :=
                  acv.a_mblock.mb_qual^.mfirst_free + _function_stackentry_cnt + 1;
            acv.a_mblock.mb_qual^.mqual_cnt   :=
                  acv.a_mblock.mb_qual^.mqual_cnt + _function_stackentry_cnt + 1;
            _next_pos    := acv.a_mblock.mb_qual^.mfirst_free - 3;
            (* step to previous function *)
            WHILE ((_next_pos > 1) AND
                  (acv.a_mblock.mb_st^ [_next_pos].etype <> st_func)) DO
                _next_pos := pred(_next_pos);
            (*ENDWHILE*) 
            ;
            (* (mfirst_free-2) = SET-function stack entry *)
            (* (mfirst_free-1) = output stack entry       *)
            (* write position to next function in previous function *)
            acv.a_mblock.mb_st^[acv.a_mblock.mb_qual^.mfirst_free - 2].
                  epos := acv.a_mblock.mb_qual^.mfirst_free - 2 - _next_pos;
            (* create output stack entry *)
            acv.a_mblock.mb_st^[acv.a_mblock.mb_qual^.mfirst_free - 1].
                  etype := st_output;
            IF  ((acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].
                n_proc = a63)
                OR (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].
                n_proc = a62))
                AND
                (NOT dmli.d_subquery)
            THEN
                acv.a_mblock.mb_st^[acv.a_mblock.mb_qual^.mfirst_free - 1].
                      eop_out := op_o_output_oflw
            ELSE
                acv.a_mblock.mb_st^[acv.a_mblock.mb_qual^.mfirst_free - 1].
                      eop_out := op_o_none;
            (*ENDIF*) 
            ;
            (* get output length from SET-function *)
            ;
            (* get output length from SET-function *)
            acv.a_mblock.mb_st^[acv.a_mblock.mb_qual^.mfirst_free - 1].
                  elen_var      := acv.a_mblock.
                  mb_st^[acv.a_mblock.mb_qual^.mfirst_free - 2].elen_var;
            acv.a_mblock.mb_st^[acv.a_mblock.mb_qual^.mfirst_free - 1].
                  epos          := dmli.d_inoutpos;
            acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free - 1].
                  ecol_tab[ 1 ] :=
                  acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free - 2].ecol_tab [1];
            acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free - 1].
                  ecol_tab[ 2 ] := chr(0);
            (* wipe out function from original stack *)
            FOR _next_pos := _start_function_pos TO
                  _start_function_pos + _function_stackentry_cnt - 2 DO
                BEGIN
                _hmbp^.mb_st^[ _next_pos ].etype := st_dummy;
                _hmbp^.mb_st^[ _next_pos ].eop   := op_none
                END;
            (*ENDFOR*) 
            _hmbp^.mb_st^[ _start_function_pos +
                  _function_stackentry_cnt - 1 ].etype := st_fixcol;
            _hmbp^.mb_st^[ _start_function_pos +
                  _function_stackentry_cnt - 1 ].eop   := op_none;
            _hmbp^.mb_st^[ _start_function_pos +
                  _function_stackentry_cnt - 1 ].epos  :=
                  dmli.d_inoutpos - cgg_rec_key_offset - RESCNT_MXGG04;
            IF  acv.a_mblock.
                mb_st^ [acv.a_mblock.mb_qual^.mfirst_free - 2].eop_func in
                [ op_f_avg, op_f_dis_avg,
                op_f_stddev, op_f_dis_stddev,
                op_f_variance, op_f_dis_variance ]
            THEN
                dmli.d_inoutpos := dmli.d_inoutpos + mxsp_resnum;
            (*ENDIF*) 
            IF  acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free - 2].
                eop_func in [ op_f_count, op_f_dis_count, op_f_all_count ]
            THEN
                IF  acv.a_mblock.
                    mb_st^ [acv.a_mblock.mb_qual^.mfirst_free - 1].
                    elen_var <= mxsp_resnum
                THEN
                    _hmbp^.mb_st^[ _start_function_pos +
                          _function_stackentry_cnt - 1 ].elen_var := mxsp_resnum
                ELSE
                    _hmbp^.mb_st^[ _start_function_pos +
                          _function_stackentry_cnt - 1 ].elen_var := acv.a_mblock.
                          mb_st^ [acv.a_mblock.mb_qual^.mfirst_free - 1].elen_var
                (*ENDIF*) 
            ELSE
                _hmbp^.mb_st^[ _start_function_pos +
                      _function_stackentry_cnt - 1 ].elen_var := acv.a_mblock.
                      mb_st^ [acv.a_mblock.mb_qual^.mfirst_free - 1].elen_var;
            (*ENDIF*) 
            _hmbp^.mb_st^[ _start_function_pos +
                  _function_stackentry_cnt - 1 ].ecol_tab[ 1 ] := chr(0);
            _hmbp^.mb_st^[ _start_function_pos +
                  _function_stackentry_cnt - 1 ].ecol_tab[ 2 ] := chr(1);
            dmli.d_inoutpos := dmli.d_inoutpos + acv.a_mblock.
                  mb_st^ [acv.a_mblock.mb_qual^.mfirst_free - 1].elen_var;
            (* PTS 1000960 E.Z. *)
            dmli.d_filled_bytes := dmli.d_filled_bytes +
                  acv.a_mblock.
                  mb_st^ [acv.a_mblock.mb_qual^.mfirst_free - 1].elen_var;
            _update_filledbyte := true;
            (* reset _act_pos for next loop *)
            _act_pos := _start_function_pos + _function_stackentry_cnt;
            END;
        (*ENDIF*) 
        END
    ELSE
        (* no function searched or found *)
        BEGIN
        IF  (_hmbp^.mb_st^[ _act_pos ].etype in
            [ st_fixkey, st_varkey, st_fixcol, st_varcol, st_varlongchar ])
            OR
            ((_hmbp^.mb_st^[ _act_pos   ].etype = st_value)     AND
            ( _hmbp^.mb_st^[ _act_pos   ].eop   = op_order_asc) AND
            ( _hmbp^.mb_st^[ _act_pos+1 ].etype = st_output))
            (* corr-columns, which are passed through *)
        THEN
            BEGIN
            IF  ( acv.a_mblock.mb_qual^.mfirst_free + 2 > acv.a_mblock.mb_st_max )
            THEN
                BEGIN
                a07_b_put_error (acv, e_too_many_mb_stackentries, 1);
                _act_pos := _qual_end + 1;
                END
            ELSE
                BEGIN
                IF  (_hmbp^.mb_st^[ _act_pos+1 ].etype <> st_output)
                    (* possible arithmetics on output column or qualification *)
                    OR
                    (_hmbp^.mb_st^[ _act_pos ].eop <> op_none )
                    (* condition on column in qual, e.g. [col][col=]         *)
                    (* function on column in output or qual, e.g. LOWER(col) *)
                THEN
                    BEGIN
&                   ifdef trace
                    t01sname (ak_sem, 'special col ');
&                   endif
                    (* write column for 1. phase *)
                    acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free] :=
                          _hmbp^.mb_st^[ _act_pos ];
                    (* wipe out function *)
                    IF  (_hmbp^.mb_st^[ _act_pos ].eop <> op_none )
                    THEN
                        acv.a_mblock.
                              mb_st^ [acv.a_mblock.mb_qual^.mfirst_free].
                              eop := op_none;
                    (*ENDIF*) 
                    ;
                    (* write output column for 1. phase *)
                    acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free + 1].
                          etype := st_output;
                    IF  (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].
                        n_proc in [ a62, a63 ] )
                        AND
                        ( NOT dmli.d_subquery )
                    THEN
                        acv.a_mblock.
                              mb_st^[ acv.a_mblock.mb_qual^.mfirst_free + 1 ].
                              eop_out := op_o_output_oflw
                    ELSE
                        acv.a_mblock.
                              mb_st^[ acv.a_mblock.mb_qual^.mfirst_free + 1 ].
                              eop_out := op_o_none;
                    (*ENDIF*) 
                    acv.a_mblock.mb_st^[acv.a_mblock.mb_qual^.mfirst_free + 1].
                          epos := dmli.d_inoutpos;
                    acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mfirst_free + 1 ].
                          elen_var := _hmbp^.mb_st^[ _act_pos ].elen_var;
                    acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free + 1].
                          ecol_pos := 0;
                    ;
                    dmli.d_filled_bytes := dmli.d_filled_bytes + acv.a_mblock.
                          mb_st^[ acv.a_mblock.mb_qual^.mfirst_free + 1 ].
                          elen_var;
                    _update_filledbyte := true;
                    (* set _next_pos to column *)
                    _next_pos := _act_pos;
                    END
                ELSE
                    (* (_hmbp^.mb_st^[ _act_pos+1 ].etype = st_output) AND
                          (_hmbp^.mb_st^[ _act_pos ].eop = op_none )*)
                    (* pure output column found *)
                    BEGIN
&                   ifdef trace
                    t01sname (ak_sem, 'normal col  ');
&                   endif
                    (* set _next_pos to output *)
                    _next_pos := _act_pos + 1;
                    (* write column for 1. phase *)
                    acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free] :=
                          _hmbp^.mb_st^[ _act_pos ];
                    (* write output column for 1. phase *)
                    acv.a_mblock.
                          mb_st^ [acv.a_mblock.mb_qual^.mfirst_free + 1] :=
                          _hmbp^.mb_st^[ _next_pos ];
                    acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mfirst_free + 1 ].
                          epos := dmli.d_inoutpos;
                    acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mfirst_free + 1 ].
                          eop_out := op_o_none;
                    IF  ( _hmbp^.mb_st^[ _next_pos ].etype = st_output ) AND
                        ( _hmbp^.mb_st^[ _next_pos ].eop_out = op_o_output_hold )
                    THEN
                        _next_pos := succ( _next_pos );
                    (*ENDIF*) 
                    ;
&                   ifdef trace
                    t01sname (ak_sem, '1. phase col');
                    t01stackentry( ak_sem, acv.a_mblock.
                          mb_st^[ acv.a_mblock.mb_qual^.mfirst_free ],
                          acv.a_mblock.mb_qual^.mfirst_free );
                    t01stackentry( ak_sem, acv.a_mblock.
                          mb_st^[ acv.a_mblock.mb_qual^.mfirst_free + 1 ],
                          acv.a_mblock.mb_qual^.mfirst_free + 1 );
&                   endif
                    END;
                (*ENDIF*) 
                ;
                (* - common part - *)
                (* write fixcol for 2. phase *)
                _hmbp^.mb_st^[ _act_pos ].etype := st_fixcol;
                _hmbp^.mb_st^[ _act_pos ].epos  := acv.a_mblock.
                      mb_st^ [ acv.a_mblock.mb_qual^.mfirst_free + 1 ].epos -
                      cgg_rec_key_offset - RESCNT_MXGG04;
                _hmbp^.mb_st^[ _act_pos ].elen_var := acv.a_mblock.
                      mb_st^[ acv.a_mblock.mb_qual^.mfirst_free + 1 ].elen_var;
                _hmbp^.mb_st^[ _act_pos ].ecol_tab[ 1 ] := chr(0);
                _hmbp^.mb_st^[ _act_pos ].ecol_tab[ 2 ] := chr(1);
&               ifdef trace
                t01sname (ak_sem, '2. phase col');
                t01stackentry( ak_sem, _hmbp^.mb_st^[ _act_pos ], _act_pos );
&               endif
                dmli.d_inoutpos := dmli.d_inoutpos + acv.a_mblock.
                      mb_st^[ acv.a_mblock.mb_qual^.mfirst_free + 1 ].
                      elen_var;
                acv.a_mblock.mb_qual^.mfirst_free :=
                      acv.a_mblock.mb_qual^.mfirst_free + 2;
                acv.a_mblock.mb_qual^.mqual_cnt   :=
                      acv.a_mblock.mb_qual^.mqual_cnt + 2;
                _act_pos    := _next_pos + 1;
&               IFDEF TRACE
                t01int4 (ak_sem, 'd_inoutpos q', dmli.d_inoutpos);
                t01stdesc (ak_sem, '1. phase    ', acv.a_mblock.mb_qual^.mstack_desc );
                t01stdesc (ak_sem, '2. phase    ',_hqbp^.mstack_desc );
&               ENDIF
                END;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
&           ifdef trace
            t01stackentry( ak_sem, _hmbp^.mb_st^[ _act_pos ], _act_pos );
            t01sname (ak_sem, 'skip entry  ');
&           endif
            IF  ( _hmbp^.mb_st^[ _act_pos ].etype = st_output )
            THEN
                BEGIN
                IF  ( _update_filledbyte )
                THEN
                    BEGIN
                    dmli.d_filled_bytes := dmli.d_filled_bytes -
                          _hmbp^.mb_st^ [ _act_pos ].elen_var;
                    _update_filledbyte := false
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            _act_pos := succ(_act_pos);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  ( dmli.d_inoutpos > MAX_RECLEN_GG00 )
    THEN
        BEGIN
        a07_b_put_error (acv, e_too_long_record, dmli.d_inoutpos);
        _act_pos := _qual_end + 1;
        END;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
;
&ifdef TRACE
t01int4 (ak_sem, 'd_inoutpos  ', dmli.d_inoutpos);
t01int4 (ak_sem, 'd_filled_by1', dmli.d_filled_bytes);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660subquery (
            VAR acv                     : tak_all_command_glob;
            VAR dmli                    : tak_dml_info;
            VAR sr_rec                  : tak71_strat_rec;
            curr_n                      : tsp00_Int2;
            VAR pseudo_resultset_select : boolean);
 
CONST
      csurrogate_pid_pos = 5;
 
VAR
      _m_command_kind    : tak_commandkind;
      _m_first_parskey   : char;
      _m_complex_pid     : char;
 
BEGIN
_m_command_kind  := acv.a_command_kind;
_m_first_parskey := acv.a_first_parskey;
_m_complex_pid   := acv.a_complex_key[ csurrogate_pid_pos ];
IF  acv.a_returncode = 0
THEN
    BEGIN
&   IFDEF TRACE
    t01bool(ak_sem, 'd_union     ', dmli.d_union);
    t01bool(ak_sem, 'a_insert_sel', acv.a_insert_select);
    t01bool(ak_sem, 'a_from_selec', acv.a_from_select);
    t01int4(ak_sem, 'a_fromsel_n ', acv.a_fromsel_n);
    t01command_kind(ak_sem, 'command_kind', acv.a_command_kind);
    t01int4(ak_sem, 'a_first_pkey', ord (acv.a_first_parskey));
&   endif
    a661a_subquery (acv, dmli, sr_rec, curr_n, pseudo_resultset_select);
    IF  (_m_first_parskey > chr (0)) AND
        (_m_command_kind  = union_in_sub_command)
    THEN
        BEGIN
        acv.a_first_parskey                     := _m_first_parskey;
        acv.a_complex_key[ csurrogate_pid_pos ] := _m_complex_pid;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(* PTS 1117747 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a660set_subq_info (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info);
 
VAR
      _subquery_node   : integer;
 
BEGIN
(* in case a from-select includes a correlated subquery *)
(* and the select holding the from_select includes      *)
(* correlated subqueries itself, it will not work       *)
(* after subquery-execution in ak661s_corr_start the    *)
(* d_..._subquery := false, but this procedure here will*)
(* not be called again (and does not know if from_select*)
(* has to be checked or ignored                         *)
_subquery_node        := dmli.d_subquery_node;
dmli.d_where_subquery       := false;
dmli.d_where_corr_subquery  := false;
dmli.d_having_subquery      := false;
dmli.d_having_corr_subquery := false;
&ifdef TRACE
t01int4 (ak_sem, 'subquerynode', _subquery_node);
&endif
WITH acv.a_ap_tree^[_subquery_node] DO
    IF  ( n_proc = a63)                          AND
        (
        (n_subproc = cak_x_subquery)         OR
        (n_subproc = cak_x_one_val_subquery) OR
        (n_subproc = cak_x_corr_subquery   ) OR
        (n_subproc = cak_x_one_val_corr_sub)
        )
    THEN
        _subquery_node := n_lo_level
    ELSE
        _subquery_node := n_sa_level;
    (*ENDIF*) 
(*ENDWITH*) 
IF  _subquery_node <> 0
THEN
    WITH acv.a_ap_tree^[_subquery_node] DO
        IF  (n_proc = a92fromsel)
        THEN
            _subquery_node := n_lo_level;
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDIF*) 
WHILE _subquery_node <> 0 DO
    WITH acv.a_ap_tree^[_subquery_node] DO
        BEGIN
        IF  ((n_subproc = cak_x_subquery)         OR
            ( n_subproc = cak_x_one_val_subquery))
        THEN
            (* PTS 1123051 E.Z. *)
            IF  (n_symb = s_where) OR (n_symb = s_select)
            THEN
                dmli.d_where_subquery := true
            ELSE
                dmli.d_having_subquery := true
            (*ENDIF*) 
        ELSE
            (* PTS 1123051 E.Z. *)
            IF  (n_symb = s_where) OR (n_symb = s_select)
            THEN
                dmli.d_where_corr_subquery := true
            ELSE
                dmli.d_having_corr_subquery := true;
            (*ENDIF*) 
        (*ENDIF*) 
        _subquery_node := acv.a_ap_tree^[_subquery_node].n_sa_level;
        END;
    (*ENDWITH*) 
(*ENDWHILE*) 
IF  (dmli.d_where_subquery OR dmli.d_where_corr_subquery)
THEN
    dmli.d_where_corr := true;
&ifdef TRACE
(*ENDIF*) 
t01int4 (ak_sem, 'wheresubq   ', ord(dmli.d_where_subquery));
t01int4 (ak_sem, 'corwheresubq', ord(dmli.d_where_corr_subquery));
t01int4 (ak_sem, 'havingsubq  ', ord(dmli.d_having_subquery));
t01int4 (ak_sem, 'corhavingsub', ord(dmli.d_having_corr_subquery));
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660three_phase (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            VAR select_rec : tak_select_record;
            VAR sr_rec     : tak71_strat_rec);
 
VAR
      (* PTS 1113318 E.Z. *)
      _b_err           : tgg00_BasisError;
      _hd_union        : boolean;
      _res_file_exists : boolean;
      _h_cpt           : tak_cmd_part_type;
      _corr_type       : tak_corr_type;
      _curr_n          : integer;
      _hd_maxcounttabs : integer;
      _i               : integer;
      _index           : integer;
      _m_filled_bytes  : integer;
      _aux_return      : tsp00_Int2;
      _aux_errorpos    : tsp00_Int4;
      _m_data_len      : integer;
      _next_n          : integer;
      _where_n         : integer;
      _aux_data_len    : integer;
      _old_infolen     : integer;
      _start_tabno     : integer;
      _new_res_tree    : tgg00_FileId;
      _sfe_rec         : t_store_for_endpart;
      _inner_sfe_rec   : t_store_for_endpart;
      _aux_fieldlists   : tgg00_FieldLists;
 
BEGIN
_old_infolen := 0;
_sfe_rec.old_subcntlevel := - 1;
_sfe_rec.m2type          := mm_nil;
_sfe_rec.hd_single       := false;
_sfe_rec.hd_distinct     := no_distinct;
_sfe_rec.lowpars         := csp_maxint1;
_sfe_rec.last_res_tree   := select_rec.sel_res_tree;
_sfe_rec.h_use_rowno     := sr_rec.sr_use_rowno;
_sfe_rec.hreclen         := 0;
_sfe_rec.hkeylen         := 0;
IF  ( dmli.d_phase_cnt < 3 )
THEN
    dmli.d_phase_cnt := 3;
(*ENDIF*) 
dmli.d_reuse         := true;
sr_rec.sr_use_rowno  := false;
_res_file_exists     := false;
_hd_maxcounttabs     := dmli.d_maxcounttabs;
_next_n              := -1;
_hd_union            := false;
_m_filled_bytes      := -1;
_corr_type           := no_correlation;
&IFDEF TRACE
t01bool (ak_sem, 'd_Group     ', dmli.d_group);
&ENDIF
IF  ((acv.a_returncode = 0) AND dmli.d_use_order)
THEN
    a67_update_atinoutpos (acv, dmli, c_update_changepos, select_rec.sel_output_n);
(*ENDIF*) 
dmli.d_group := true;
dmli.d_join  := false;
_curr_n  := acv.a_ap_tree^[ select_rec.sel_output_n ].n_sa_level;
IF  ((acv.a_ap_tree^[ _curr_n ].n_proc = a60) AND
    (acv.a_ap_tree^[ _curr_n ].n_subproc = cak_x_single_select))
THEN
    _curr_n := acv.a_ap_tree^[ _curr_n ].n_sa_level;
&IFDEF TRACE
(*ENDIF*) 
t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
t01int4 (ak_sem, 'd_inoutpos  ', dmli.d_inoutpos);
t01int4 (ak_sem, 'sel_having_n', select_rec.sel_having_n);
&ENDIF
_sfe_rec.hinoutpos := dmli.d_inoutpos;
&IFDEF TRACE
t01bool (ak_sem, 'd_Group     ', dmli.d_group);
&ENDIF
(* PTS 1117747 E.Z. *)
IF  ((acv.a_returncode = 0) AND
    ( dmli.d_corr <> no_correlation) AND
    ( NOT acv.a_from_select))
THEN
    a660set_subq_info (acv, dmli);
(*ENDIF*) 
IF  ((acv.a_returncode = 0) AND (select_rec.sel_having_n <> 0))
THEN
    BEGIN
    dmli.d_having := true;
    IF  (dmli.d_corr <> no_correlation) AND
        (NOT acv.a_from_select)
    THEN
        IF  (dmli.d_corr = first_correlation)
        THEN
            BEGIN
            a67_first_corr (acv, dmli);
            a660set_subq_info (acv, dmli);
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  ((dmli.d_corr in [ first_correlation, correlation ]) AND
        (acv.a_returncode = 0)) AND
        (NOT acv.a_from_select)
    THEN
        BEGIN
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            _h_cpt      := acv.a_cpart_type;
            acv.a_cpart_type := cpt_in_having_clause;
&           ifdef TRACE
            t01messblock (ak_sem, 'MESSBLOCK   ', acv.a_mblock);
            t01int4 (ak_sem, 'd_inoutpos b', dmli.d_inoutpos);
            t01int4 (ak_sem, 'd_keylen   b', dmli.d_keylen);
            t01messblock (ak_sem, 'MESSBLOCK   ', acv.a_mblock);
&           ENDIF
&           ifdef TRACE
            t01int4 (ak_sem, 'd_lowpars  1', dmli.d_lowpars);
            t01int4 (ak_sem, 'd_lowpars  1', dmli.d_oldlowpars);
&           ENDIF
            (* PTS 1117747 E.Z. *)
            a67_corr_search (acv, dmli, c_only_having_columns_get,
                  _start_tabno, NOT c_only_split, c_no_predefined_pno,
                  _old_infolen, _sfe_rec.last_res_tree);
            (* _old_infolen : length of 'wholes'*)
            (* because of avg, variance        *)
&           ifdef TRACE
            t01int4 (ak_sem, 'old_infolen1', _old_infolen);
&           endif
            _old_infolen := dmli.d_inoutpos - 1 - cgg_rec_key_offset -
                  dmli.d_keylen + _old_infolen;
&           ifdef TRACE
            t01int4 (ak_sem, 'd_lowpars  2', dmli.d_lowpars);
            t01int4 (ak_sem, 'd_lowpars  2', dmli.d_oldlowpars);
            t01int4 (ak_sem, 'old_infolen2', _old_infolen);
            t01int4 (ak_sem, 'd_reclen 2  ', dmli.d_reclen);
            t01int4 (ak_sem, 'd_inoutpos h', dmli.d_inoutpos);
            t01int4 (ak_sem, 'd_keylen   h', dmli.d_keylen);
            t01int4 (ak_sem, 'fill_byte 1a', dmli.d_filled_bytes);
            t01messblock (ak_sem, 'MESSBLOCK   ', acv.a_mblock);
&           ENDIF
            _m_filled_bytes := dmli.d_filled_bytes;
            acv.a_cpart_type     := _h_cpt;
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    _next_n   := acv.a_ap_tree^[ select_rec.sel_having_n ].n_lo_level;
    IF  acv.a_ex_kind = only_parsing
    THEN
        a54_fixedpos (acv, dmli);
    (*ENDIF*) 
    a65_search_condition (acv, dmli, _next_n);
    dmli.d_having     := false;
    dmli.d_joins.jrc_cnt := 0;
    END;
&IFDEF TRACE
(*ENDIF*) 
t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
t01int4 (ak_sem, 'd_inoutpos  ', dmli.d_inoutpos);
t01messblock (ak_sem, 'MESSBLOCK   ', acv.a_mblock);
t01bool (ak_sem, 'd_only_sem_c', dmli.d_only_sem_check);
&ENDIF
_sfe_rec.messbuf_stored := false;
_sfe_rec.hqbp           := nil;
_sfe_rec.hd_rowno       := 0;
_sfe_rec.hd_single      := false;
_sfe_rec.hd_colcount    := 0;
_aux_fieldlists := acv.a_mblock.mb_fieldlists;
(* PTS 1111978 E.Z. *)
IF  ((acv.a_ex_kind = only_parsing) AND
    NOT (dmli.d_only_sem_check) AND
    (dmli.d_sparr.pparsp <> NIL))
THEN
    _sfe_rec.param_parskey := dmli.d_sparr.pparsp^.syskey;
(*ENDIF*) 
IF  ( dmli.d_only_sem_check )
THEN
    _sfe_rec.hd_single := false
ELSE
    BEGIN
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        (* PTS 1113318 E.Z. *)
        ak660move_in_hbuf (acv, _sfe_rec, 1, NOT c_repl_only);
        IF  ( acv.a_returncode = 0 )
        THEN
            BEGIN
            _sfe_rec.messbuf_stored  := true;
            _sfe_rec.hmbp            := @_sfe_rec.hbuf^.smessblock.mbr_mess_block;
            _sfe_rec.hqbp            := _sfe_rec.hmbp^.mb_qual;
            _sfe_rec.hmbp^.mb_type   := m_select;
            _sfe_rec.hmbp^.mb_type2  := mm_nil;
            _sfe_rec.hqbp^.mstack_state := acv.a_mblock.mb_qual^.mstack_state;
            END;
        (*ENDIF*) 
        IF  ( select_rec.sel_group_n <> 0 )
        THEN
            BEGIN
            dmli.d_use_order := true;
            dmli.d_order_or_group_cols := @dmli.d_group_cols;
            END
        ELSE
            dmli.d_use_order := false
        (*ENDIF*) 
        END;
&   IFDEF TRACE
    (*ENDIF*) 
    t01name (ak_sem, 'nach group        ');
    t01stdesc (ak_sem, '1. phase    ', acv.a_mblock.mb_qual^.mstack_desc );
    IF  ( acv.a_returncode = 0 )
    THEN
        t01stdesc (ak_sem, '2. phase    ', _sfe_rec.hqbp^.mstack_desc );
    (*ENDIF*) 
    t01bool (ak_sem, 'd_Group     ', dmli.d_group);
&   ENDIF
    IF  ( acv.a_returncode = 0 )
    THEN
        BEGIN
        _m_data_len := 0;
        _i :=  acv.a_mblock.mb_qual^.mqual_pos +
              acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mqual_pos ].epos - 2;
        FOR _index := acv.a_mblock.mb_qual^.mqual_pos TO _i DO
            IF  (acv.a_mblock.mb_st^[ _index ].etype = st_output)
            THEN
                IF  acv.a_mblock.mb_st^[ _index ].epos > _m_data_len
                THEN
                    _m_data_len := acv.a_mblock.mb_st^[ _index ].epos + acv.a_mblock.mb_st^[ _index ].elen_var - 1;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDFOR*) 
        IF  _m_data_len < dmli.d_reclen (* avg/stddev/variance in the end *)
        THEN
            BEGIN
            dmli.d_reclen   := _m_data_len;
            dmli.d_inoutpos := succ(_m_data_len);
            END;
        (*ENDIF*) 
        _sfe_rec.lowpars := dmli.d_lowpars;
        acv.a_where_corr_info.uci_oldlowpars := dmli.d_lowpars;
        IF  ( dmli.d_corr <> no_correlation )
        THEN
            BEGIN
            _sfe_rec.lowpars   := dmli.d_lowpars - 1;
            dmli.d_lowpars := dmli.d_lowpars - 1;
            (* PTS 1117747 E.Z. *)
            acv.a_where_corr_info.uci_oldlowpars := dmli.d_lowpars;
            IF  ( dmli.d_where_subquery OR dmli.d_where_corr_subquery ) AND
                ( dmli.d_having_corr_subquery )
            THEN
                (* do NOT change lowpars *)
                dmli.d_lowpars := dmli.d_lowpars - 2;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        ;
&       ifdef TRACE
        t01int4 (ak_sem, 'thre lowpars', _sfe_rec.lowpars);
&       endif
        _sfe_rec.hkeylen     := dmli.d_keylen;
        _sfe_rec.hreclen     := dmli.d_reclen;
        _sfe_rec.hd_distinct := dmli.d_distinct;
        _hd_union            := dmli.d_union;
        _sfe_rec.hd_single   := dmli.d_single;
        _sfe_rec.hd_colcount := dmli.d_change.cr_colcount;
        _sfe_rec.hd_rowno    := dmli.d_rowno;
        dmli.d_inoutpos      := cgg_rec_key_offset + RESCNT_MXGG04 + 1;
        dmli.d_keylen        := RESCNT_MXGG04;
        dmli.d_reclen        := dmli.d_inoutpos - 1;
        dmli.d_distinct      := no_distinct;
        dmli.d_union         := false;
        dmli.d_single        := false;
        dmli.d_change.cr_colcount := 0;
        dmli.d_rowno         := cgg04_no_rowno_predicate;
&       ifdef trace
        t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
        t01int4 (ak_sem, 'd_inoutpos  ', dmli.d_inoutpos);
&       endif
        (* seperate 3. phase *)
        ak660two_repl_complex_output (acv, dmli, _sfe_rec.hbuf,
              NOT c_where_done, select_rec.sel_view_done,
              c_functions_not_single_fields);
        IF  ( acv.a_mblock.mb_type2 = mm_with_functions )
        THEN
            a61_put_last_func (acv);
        (*ENDIF*) 
        a61_set_jump (acv.a_mblock, 1, st_jump_output);
        acv.a_mblock.mb_st^[1].epos := succ(acv.a_mblock.mb_st^ [1].epos);
        IF  ((acv.a_returncode = 0) AND (select_rec.sel_group_n <> 0) AND
            (dmli.d_maxcounttabs = 1))
        THEN
            BEGIN
            (* next statements necessary for DML018 in NIST-Test version 3 *)
            IF  NOT (acv.a_ap_tree^[ select_rec.sel_output_n ].n_symb in
                [ s_count, s_sum ])
            THEN  (* only atgroup *)
                dmli.d_distinct := full_distinct;
            (*ENDIF*) 
            a67_update_atinoutpos (acv, dmli, NOT c_update_changepos, select_rec.sel_output_n);
            END
        (*ENDIF*) 
        ;
&       ifdef trace
        t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
        t01int4 (ak_sem, 'd_inoutpos  ', dmli.d_inoutpos);
&       endif
        END;
    (*ENDIF*) 
    _next_n  := acv.a_ap_tree^[ _curr_n ].n_sa_level;
    dmli.d_group := false;
    IF  ( acv.a_returncode = 0 )
    THEN
        BEGIN
        a10add_sysinfo (acv, _sfe_rec.hbuf, _b_err);
        IF  ( _b_err <> e_ok )
        THEN
            a07_b_put_error (acv, _b_err, 1)
        ELSE
            a10_rel_sysinfo (acv, _sfe_rec.hbuf^.syskey)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (acv.a_ap_tree^[ _curr_n ].n_proc    = a66)             AND
    (acv.a_ap_tree^[ _curr_n ].n_subproc = cak_x_given_sequence)
THEN
    _curr_n := _next_n;
(*ENDIF*) 
_next_n  := acv.a_ap_tree^[ _curr_n ].n_sa_level;
dmli.d_group := false;
IF  ((acv.a_returncode = 0) AND (_next_n <> 0))
THEN
    IF  (acv.a_ap_tree^[ _next_n ].n_proc = a63) AND
        (acv.a_ap_tree^[ _next_n ].n_subproc  = cak_x_search_condition)
    THEN
        BEGIN
        IF  dmli.d_maxcounttabs = 1
        THEN
            BEGIN
            _next_n := acv.a_ap_tree^[ _next_n ].n_lo_level;
            IF  acv.a_ex_kind = only_parsing
            THEN
                a54_fixedpos (acv, dmli);
            (*ENDIF*) 
            a65_search_condition (acv, dmli, _next_n);
            END
        ELSE
            BEGIN
&           ifdef trace
            t01sname (ak_sem, 'maxtab <> 1 ');
&           endif
            dmli.d_group       := false;
            dmli.d_join        := true;
            dmli.d_joins.jrc_cnt  := 0;
            _where_n       := _next_n;
            _next_n        := acv.a_ap_tree^[ _next_n ].n_lo_level;
            IF  acv.a_ex_kind = only_parsing
            THEN
                a54_fixedpos (acv, dmli);
            (*ENDIF*) 
            a65_search_condition (acv, dmli, _next_n);
            dmli.d_join := false;
            END;
        (*ENDIF*) 
        select_rec.sel_where_done := true
        END;
    (*ENDIF*) 
(*ENDIF*) 
;
&IFDEF TRACE
t01name (ak_sem, 'vor two_phase     ');
&ENDIF
IF  ((dmli.d_maxcounttabs > dmli.d_cntfromtab) AND
    (acv.a_returncode = 0))
THEN
    BEGIN
    a67_put_all_views_into (acv, dmli);
    select_rec.sel_view_done := true
    END;
(*ENDIF*) 
_sfe_rec.first_res := (acv.a_returncode = 0);
dmli.d_group   := (select_rec.sel_group_n <> 0);
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  ((acv.a_ex_kind = only_parsing) AND
        NOT (dmli.d_only_sem_check) AND
        (dmli.d_sparr.pparsp <> NIL))
    THEN
        WITH dmli.d_sparr.pparsp^.sparsinfo DO
            BEGIN
            (* The position given in parsinfos is not correct any more.  *)
            (* It is destroyed. This results in values of maximum length.*)
            _sfe_rec.old_subcntlevel := p_subcntlevel;
            p_subcntlevel   := - 1;
            FOR _i := 1 TO p_cnt_infos DO
                IF  p_pars_infos[ _i ].fp_kind = fp_val_all_without_l
                THEN
                    p_pars_infos[ _i ].fp_stackpos := 0
                (*ENDIF*) 
            (*ENDFOR*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    g04build_temp_tree_id (select_rec.sel_res_tree, acv.a_transinf.tri_trans);
    select_rec.sel_res_tree.fileTfnTemp_gg00   := ttfnComplexSelect_egg00;
    a101_SetTempFileLevel (acv, select_rec.sel_res_tree,
          acv.a_pars_last_key.p_no);
    a101_SetTempFileSublevel (acv, select_rec.sel_res_tree, 0);
    _m_data_len := acv.a_mblock.mb_data_len;
    _corr_type := dmli.d_corr;
    (* PTS 1117747 E.Z. *)
    IF  ((dmli.d_corr in [ first_correlation, correlation ])
        AND NOT dmli.d_where_corr_subquery AND NOT dmli.d_where_subquery)
    THEN
        dmli.d_corr := no_correlation;
&   ifdef TRACE
    (*ENDIF*) 
    t01int4 (ak_sem, 'd_lowpars 2a', dmli.d_lowpars);
    t01int4 (ak_sem, 'd_lowpars 2a', dmli.d_oldlowpars);
&   endif
    IF  ((dmli.d_maxcounttabs = 1) AND
        NOT (dmli.d_corr in [ first_correlation, correlation ]))
    THEN
        BEGIN
        dmli.d_corr := no_correlation;
        a67_sel2_second_part (acv, dmli, select_rec.sel_res_tree,
              c_is_not_corr_search, NOT c_last_pars_part,
              select_rec.sel_view_done, sr_rec);
        END
    ELSE
        BEGIN
        (* PTS 1117747 E.Z. *)
        IF  (dmli.d_where_corr_subquery OR dmli.d_where_subquery) AND
            (select_rec.sel_having_n <> 0)
            (* a67_first_corr was done *)
        THEN
            dmli.d_corr := correlation;
&       ifdef TRACE
        (*ENDIF*) 
        t01int4 (ak_sem, 'd_corr      ', ord(dmli.d_corr));
        t01int4 (ak_sem, 'fill_byte 2a', dmli.d_filled_bytes);
&       endif
        _m_filled_bytes := dmli.d_filled_bytes;
        (* PTS 1113318 E.Z. *)
&       ifdef TRACE
        t01int4 (ak_sem, 'd_inoutpos a', dmli.d_inoutpos);
        t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
        t01int4 (ak_sem, 'd_keylen    ', dmli.d_keylen);
&       endif
        dmli.d_join := true;
        IF  ((acv.a_returncode = 0) AND
            (* don't use a67_upd.., if called by ak660three_phase.. *)
            (* in a special case *)
            NOT (dmli.d_group AND (dmli.d_maxcounttabs = 1)) AND
            (
            (dmli.d_group AND (dmli.d_group_cols.ocntord > 0)) OR
            ((acv.a_ap_tree^[ select_rec.sel_output_n ].n_symb = s_sum) AND dmli.d_use_order))
            )
        THEN
            a67_update_atinoutpos (acv, dmli, NOT c_having_part, select_rec.sel_output_n);
        (*ENDIF*) 
        ;
&       ifdef TRACE
        t01int4 (ak_sem, 'd_inoutpos b', dmli.d_inoutpos);
        t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
        t01int4 (ak_sem, 'd_keylen    ', dmli.d_keylen);
        t01int4 (ak_sem, 'd_inoutpos b', _sfe_rec.hinoutpos);
        t01int4 (ak_sem, 'd_reclen    ', _sfe_rec.hreclen);
        t01int4 (ak_sem, 'd_keylen    ', _sfe_rec.hkeylen);
&       endif
        IF  ( acv.a_returncode = 0 )
        THEN
            BEGIN
            (* devide 1. phase generated by previous *)
            (* ak660two_repl_complex_output()        *)
            (* could be optimized to one phase       *)
            (**)
            (* dmli.d_one_join_phase := false; *)
            dmli.d_one_join_phase := g01one_join_phase AND
                  ( dmli.d_corr = no_correlation );
            (* dmli.d_one_join_phase := ???? *)
            ak660phase_division (acv, dmli, select_rec, sr_rec, _inner_sfe_rec );
            (**)
            (**)
            (**)
            (**)
&           ifdef TRACE
            t01int4 (ak_sem, 'd_inoutpos b', dmli.d_inoutpos);
            t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
            t01int4 (ak_sem, 'd_keylen    ', dmli.d_keylen);
            t01int4 (ak_sem, 'd_inoutpos b', _inner_sfe_rec.hinoutpos);
            t01int4 (ak_sem, 'd_reclen    ', _inner_sfe_rec.hreclen);
            t01int4 (ak_sem, 'd_keylen    ', _inner_sfe_rec.hkeylen);
&           endif
            IF  ( dmli.d_one_join_phase )
            THEN
                BEGIN
                dmli.d_inoutpos := _inner_sfe_rec.hinoutpos;
                dmli.d_reclen   := dmli.d_inoutpos - 1;
                dmli.d_keylen   := _inner_sfe_rec.hkeylen;
                ak660one_phase( acv, dmli, select_rec,
                      sr_rec, _inner_sfe_rec )
                END
            ELSE
                ak660two_phase (acv, dmli, select_rec, sr_rec,
                      _inner_sfe_rec, c_store_infos);
            (*ENDIF*) 
            (**)
            (**)
            (**)
            (**)
            END;
        (* END PTS 1113318 E.Z. *)
        (*ENDIF*) 
        ;
&       ifdef TRACE
        t01int4 (ak_sem, 'd_lowpars 2b', dmli.d_lowpars);
        t01int4 (ak_sem, 'd_lowpars 2b', dmli.d_oldlowpars);
        t01int4 (ak_sem, 'fill_byte 3a', dmli.d_filled_bytes);
        t01int4 (ak_sem, 'd_inoutpos  ', dmli.d_inoutpos);
        t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
        t01int4 (ak_sem, 'd_keylen    ', dmli.d_keylen);
&       endif
        END;
    (*ENDIF*) 
    dmli.d_corr := _corr_type;
    (* PTS 1117747 E.Z. *)
    acv.a_where_corr_info.uci_lowpars := dmli.d_lowpars;
    acv.a_where_corr_info.uci_pid     := acv.a_pars_last_key.p_id;
    IF  ((acv.a_ex_kind <> only_parsing) AND NOT dmli.d_only_sem_check)
    THEN
        BEGIN
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            select_rec.sel_res_tree := acv.a_mblock.mb_qual^.mr_restree;
            _res_file_exists :=
                  ((acv.a_mblock.mb_qual^.mr_resnum = csp_rescnt_zero) AND
                  (_sfe_rec.m2type <> mm_with_functions))
            END
        ELSE
            a502destroy_file (acv, select_rec.sel_res_tree);
        (*ENDIF*) 
        END;
    (* PTS 1128182 E.Z. *)
    (*ENDIF*) 
    IF  NOT dmli.d_only_sem_check
    THEN
        acv.a_mblock.mb_data_len := _m_data_len;
&   IFDEF TRACE
    (*ENDIF*) 
    t01name (ak_sem, 'nach two_phase    ');
    t01messblock (ak_sem, 'MESSBLOCK   ', acv.a_mblock);
    IF  (acv.a_ex_kind = only_parsing) AND NOT (dmli.d_only_sem_check)
    THEN
        IF  dmli.d_sparr.pparsp <> NIL
        THEN
            t01buf1 (ak_sem, dmli.d_sparr.pparsp^.syskey, 1, 16);
        (*ENDIF*) 
    (*ENDIF*) 
    t01int4 (ak_sem, 'd_reclen  3 ', dmli.d_reclen);
    t01int4 (ak_sem, 'd_inoutpos  ', dmli.d_inoutpos);
    t01int4 (ak_sem, 'd_keylen    ', dmli.d_keylen);
    t01int4 (ak_sem, 'd_reclen  3 ', _sfe_rec.hreclen);
    t01int4 (ak_sem, 'd_inoutpos  ', _sfe_rec.hinoutpos);
    t01int4 (ak_sem, 'd_keylen    ', _sfe_rec.hkeylen);
&   ENDIF
    END;
(*ENDIF*) 
IF  ((acv.a_returncode = 0 ) AND NOT dmli.d_only_sem_check)
THEN
    BEGIN
    IF  ( acv.a_returncode = 0 )
    THEN
        BEGIN
        dmli.d_single             := _sfe_rec.hd_single;
        dmli.d_change.cr_colcount := _sfe_rec.hd_colcount;
        dmli.d_rowno              := _sfe_rec.hd_rowno;
        dmli.d_distinct           := _sfe_rec.hd_distinct;
        dmli.d_union              := _hd_union
        END;
    (*ENDIF*) 
    sr_rec.sr_use_rowno := _sfe_rec.h_use_rowno;
    (* PTS 1117747 E.Z. *)
    IF  ( dmli.d_having_corr_subquery )
    THEN
        BEGIN
        IF  ( acv.a_returncode = 0 )
        THEN
            BEGIN
            a10get_sysinfo (acv, _sfe_rec.ke, d_release, _sfe_rec.hbuf, _b_err);
            IF  ( _b_err <> e_ok )
            THEN
                a07_b_put_error (acv, _b_err, 1)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  ( acv.a_returncode = 0 )
        THEN
            BEGIN
            a06drop_fieldlist_references (_aux_fieldlists);
            _sfe_rec.hmbp := @_sfe_rec.hbuf^.smessblock.mbr_mess_block;
            _sfe_rec.hqbp := _sfe_rec.hmbp^.mb_qual;
            _aux_data_len         := acv.a_mblock.mb_data_len;
            acv.a_mblock.mb_data_len := 0;
            a06cpy_mblock (acv, _sfe_rec.hmbp^, acv.a_mblock, NOT c_without_data, _b_err);
            acv.a_mblock.mb_data_len := _aux_data_len;
            IF  ( _b_err <> e_ok )
            THEN
                a07_b_put_error (acv, _b_err, 1)
            ELSE
                BEGIN
&               ifdef TRACE
                t01messblock (ak_sem, 'mess_block <', _sfe_rec.hmbp^);
                t01messblock (ak_sem, 'MESSBLOCK   ', acv.a_mblock);
&               endif
                END;
            (*ENDIF*) 
            acv.a_mblock.mb_struct      := mbs_stack_addr;
            acv.a_mblock.mb_qual^.mtree := select_rec.sel_res_tree;
            IF  acv.a_mblock.mb_type2 = mm_nil
            THEN
                dmli.d_maxcounttabs := 1;
            (*ENDIF*) 
            END;
&       ifdef TRACE
        (*ENDIF*) 
        t01int4 (ak_sem, 'd_reclen 4  ', dmli.d_reclen);
        t01int4 (ak_sem, 'd_inoutpos  ', dmli.d_inoutpos);
        t01int4 (ak_sem, 'd_keylen    ', dmli.d_keylen);
        t01messblock (ak_sem, 'MESSBLOCK   ', acv.a_mblock);
&       ENDIF
        dmli.d_inoutpos            := _sfe_rec.hinoutpos;
        dmli.d_keylen              := _sfe_rec.hkeylen;
        dmli.d_reclen              := _sfe_rec.hreclen;
&       ifdef TRACE
        t01int4 (ak_sem, 'fill_byte 4a', dmli.d_filled_bytes);
&       endif
        dmli.d_filled_bytes        := _m_filled_bytes;
&       ifdef TRACE
        t01int4 (ak_sem, 'fill_byte 5a', dmli.d_filled_bytes);
&       endif
        _new_res_tree := dmli.d_tabarr^[ 1 ].otreeid;
        dmli.d_tabarr^[ 1 ].otreeid := select_rec.sel_res_tree;
        dmli.d_where_corr := false;
        (* PTS 1117747 E.Z. *)
&       ifdef TRACE
        t01int4 (ak_sem, 'd_lowpars  3', dmli.d_lowpars);
        t01int4 (ak_sem, 'd_lowpars  3', dmli.d_oldlowpars);
&       endif
        IF  (dmli.d_where_subquery OR dmli.d_where_corr_subquery)
        THEN
            a67_corr_search (acv, dmli, NOT c_only_having_columns_get,
                  _start_tabno, c_only_split,
                  dmli.d_lowpars + 2 + 1, _old_infolen, _sfe_rec.last_res_tree)
        ELSE
            a67_corr_search (acv, dmli, NOT c_only_having_columns_get,
                  _start_tabno, c_only_split, c_no_predefined_pno,
                  _old_infolen, _sfe_rec.last_res_tree);
        (*ENDIF*) 
&       ifdef TRACE
        t01int4 (ak_sem, 'd_lowpars  4', dmli.d_lowpars);
        t01int4 (ak_sem, 'd_lowpars  4', dmli.d_oldlowpars);
        t01int4 (ak_sem, 'hav oldlowpa', dmli.d_oldlowpars);
        t01int4 (ak_sem, 'hav lowpars ', dmli.d_lowpars);
&       endif
        dmli.d_oldlowpars          := dmli.d_lowpars;
        dmli.d_tabarr^[ 1 ].otreeid := _new_res_tree;
&       ifdef TRACE
        t01messblock (ak_sem, 'MESSBLOCK   ', acv.a_mblock);
        t01name (ak_sem, 'nach corr_search  ');
        IF  (dmli.d_sparr.pparsp <> NIL) AND
            NOT (dmli.d_only_sem_check)
        THEN
            t01buf1 (ak_sem, dmli.d_sparr.pparsp^.syskey, 1, 16);
&       endif
        (*ENDIF*) 
        IF  ( acv.a_returncode = 0 )
        THEN
            (* PTS 1113318 E.Z. *)
            ak660move_in_hbuf (acv, _sfe_rec, 1, c_repl_only);
        (*ENDIF*) 
        a10repl_sysinfo (acv, _sfe_rec.hbuf, _b_err)
        END;
    (*ENDIF*) 
    IF  (NOT dmli.d_subquery)    AND
        (NOT dmli.d_union)       AND
        (NOT acv.a_from_select) AND
        (acv.a_intern_select_cnt = acv.a_max_intern_select) AND
        (NOT acv.a_insert_select)
    THEN
        select_rec.sel_last_pars_part := true;
&   ifdef TRACE
    (*ENDIF*) 
    t01messblock (ak_sem, 'MESSBLOCK   ', acv.a_mblock);
    t01name (ak_sem, 'vor endpart       ');
    IF  (dmli.d_sparr.pparsp <> NIL) AND
        NOT (dmli.d_only_sem_check)
    THEN
        t01buf1 (ak_sem, dmli.d_sparr.pparsp^.syskey, 1, 16);
    (*ENDIF*) 
    t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
    t01int4 (ak_sem, 'd_inoutpos  ', dmli.d_inoutpos);
&   endif
    (* PTS 1113318 E.Z. *)
    ak660endpart (acv, dmli, _sfe_rec, select_rec.sel_order_n,
          select_rec.sel_last_pars_part, c_store_infos,
          (_corr_type <> no_correlation),
          select_rec.sel_res_tree, select_rec, sr_rec);
    dmli.d_inoutpos := _sfe_rec.hinoutpos;
&   IFDEF TRACE
    t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
    t01int4 (ak_sem, 'd_inoutpos  ', dmli.d_inoutpos);
&   ENDIF
    _new_res_tree           := select_rec.sel_res_tree;
    select_rec.sel_res_tree := _sfe_rec.last_res_tree;
    IF  ( acv.a_union_cnt <= 1 )
    THEN
        a67_sel3_second_part (acv, dmli, select_rec, sr_rec);
    (*ENDIF*) 
    dmli.d_maxcounttabs := _hd_maxcounttabs;
    IF  (_sfe_rec.first_res AND _res_file_exists AND
        (acv.a_ex_kind <> only_parsing))
    THEN
        BEGIN
        a502destroy_file (acv, _new_res_tree);
        IF  ( acv.a_transinf.tri_trans.trError_gg00 <> e_ok )
        THEN
            a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ( _sfe_rec.messbuf_stored )
THEN
    BEGIN
    _aux_return   := acv.a_returncode;
    _aux_errorpos := acv.a_errorpos;
    acv.a_returncode := 0;
    a10del_sysinfo (acv, _sfe_rec.ke, _b_err);
    IF  ( _aux_return <> 0 )
    THEN
        BEGIN
        acv.a_returncode := _aux_return;
        acv.a_errorpos   := _aux_errorpos;
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
;
&ifdef TRACE
t01command_kind (ak_sem, 'ACOMMANDKIND', acv.a_command_kind);
&endif
IF  ((acv.a_returncode <> 0) AND
    NOT (dmli.d_only_sem_check) AND
    ( acv.a_command_kind = sub_in_union_command))
THEN
    BEGIN
    _aux_return   := acv.a_returncode;
    _aux_errorpos := acv.a_errorpos;
    acv.a_returncode := 0;
    a10del_sysinfo (acv, dmli.d_sparr.pparsp^.syskey, _b_err);
    IF  ( _aux_return <> 0 )
    THEN
        BEGIN
        acv.a_returncode := _aux_return;
        acv.a_errorpos   := _aux_errorpos;
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(* PTS 1113318 E.Z. parameter-list *)
(*------------------------------*) 
 
PROCEDURE
      ak660one_phase (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            VAR select_rec : tak_select_record;
            VAR sr_rec     : tak71_strat_rec;
            VAR sfe_rec    : t_store_for_endpart);
 
VAR
      _res_file_exists : boolean;
      _ix              : integer;
 
BEGIN
_res_file_exists     := false;
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    IF  ( ( sfe_rec.hqbp^.mfirst_free - sfe_rec.hqbp^.mqual_pos ) +
        acv.a_mblock.mb_qual^.mfirst_free < acv.a_mblock.mb_st_max )
    THEN
        (* shift qualification to make space on top for result qualification *)
        BEGIN
        SAPDB_PascalOverlappingMove ('VAK660',   2,    
              acv.a_mblock.mb_st_size, acv.a_mblock.mb_st_size,
              @acv.a_mblock.mb_st^,
              (acv.a_mblock.mb_qual^.mqual_pos - 1) * STACK_ENTRY_MXGG00 + 1,
              @acv.a_mblock.mb_st^,
              (acv.a_mblock.mb_qual^.mqual_pos +
              ( sfe_rec.hqbp^.mfirst_free - sfe_rec.hqbp^.mqual_pos ) - 1) *
              STACK_ENTRY_MXGG00 + 1,
              acv.a_mblock.mb_qual^.mqual_cnt * STACK_ENTRY_MXGG00,
              acv.a_returncode);
        _ix := acv.a_mblock.mb_qual^.mqual_pos;
        acv.a_mblock.mb_qual^.mqual_pos := acv.a_mblock.mb_qual^.mqual_pos +
              sfe_rec.hqbp^.mfirst_free - sfe_rec.hqbp^.mqual_pos;
        ;
        acv.a_mblock.mb_qual^.mresqual_pos := _ix;
        acv.a_mblock.mb_qual^.mresqual_cnt := sfe_rec.hqbp^.mfirst_free -
              sfe_rec.hqbp^.mqual_pos;
        (* *** copy 2 phase mblock *** *)
        SAPDB_PascalMove ('VAK660',   3,    
              sfe_rec.hmbp^.mb_st_size, acv.a_mblock.mb_st_size,
              @sfe_rec.hmbp^.mb_st^,
              (sfe_rec.hqbp^.mqual_pos - 1) * STACK_ENTRY_MXGG00 + 1,
              @acv.a_mblock.mb_st^,
              ( acv.a_mblock.mb_qual^.mresqual_pos - 1 )* STACK_ENTRY_MXGG00 + 1,
              acv.a_mblock.mb_qual^.mresqual_cnt * STACK_ENTRY_MXGG00,
              acv.a_returncode);
        acv.a_mblock.mb_qual^.mfirst_free := acv.a_mblock.mb_qual^.mfirst_free +
              acv.a_mblock.mb_qual^.mresqual_cnt;
        IF   ( acv.a_returncode = 0 )
        THEN
            BEGIN
            (* update jop_startstack positions in jrc_joinarr *)
            (* because of shifting of qualification           *)
            FOR _ix := 0 TO dmli.d_joins.jrc_cnt - 1 DO
                BEGIN
                dmli.d_joins.jrc_joinarr^ [ _ix ].jo_recs[ 1 ].jop_startstack :=
                      dmli.d_joins.jrc_joinarr^ [ _ix ].jo_recs[ 1 ].
                      jop_startstack + acv.a_mblock.mb_qual^.mresqual_cnt;
                dmli.d_joins.jrc_joinarr^ [ _ix ].jo_recs[ 2 ].jop_startstack :=
                      dmli.d_joins.jrc_joinarr^ [ _ix ].jo_recs[ 2 ].
                      jop_startstack + acv.a_mblock.mb_qual^.mresqual_cnt;
                END;
            (*ENDFOR*) 
&           ifdef TRACE
            t01int4 (ak_sem, 'd_keylen    ', dmli.d_keylen);
            t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
            t01messblock (ak_sem, '1 phase mblo', acv.a_mblock);
&           endif
            (* PTS 1113318 E.Z. *)
            dmli.d_single             := sfe_rec.hd_single;
            dmli.d_rowno              := sfe_rec.hd_rowno;
            dmli.d_change.cr_colcount := sfe_rec.hd_colcount;
            dmli.d_distinct           := sfe_rec.hd_distinct;
            dmli.d_union              := sfe_rec.hdm_union;
            sr_rec.sr_use_rowno       := sfe_rec.h_use_rowno;
            (* END PTS 1113318 E.Z. *)
            select_rec.sel_res_tree := sfe_rec.last_res_tree;
            a67_sel2_second_part (acv, dmli, select_rec.sel_res_tree,
                  c_is_not_corr_search, select_rec.sel_last_pars_part AND
                  (NOT dmli.d_subquery),
                  select_rec.sel_view_done, sr_rec);
            (* *** a67_sel3_second_part *** *)
            dmli.d_inoutpos := dmli.d_reclen + 1;
            ak660cleanup_more_phase( acv, dmli, sfe_rec );
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        g01opmsg( sp3p_knldiag, sp3m_warning, csp3_msg,
              csp3_n_move, 'ONE PHASE: LOW MB STACK ',
              (( sfe_rec.hqbp^.mfirst_free - sfe_rec.hqbp^.mqual_pos ) *
              sizeof(tgg00_StackEntry) ));
        dmli.d_one_join_phase := false;
        ak660two_phase( acv, dmli, select_rec, sr_rec, sfe_rec, c_store_infos );
        END;
    (*ENDIF*) 
    IF  dmli.d_view
    THEN
        dmli.d_phase_cnt := cak_complex_view_indicator;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660phase_division (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            VAR select_rec : tak_select_record;
            VAR sr_rec     : tak71_strat_rec;
            VAR sfe_rec    : t_store_for_endpart);
 
VAR
      _b_err           : tgg00_BasisError;
      _curr_n          : integer;
      _next_n          : integer;
 
BEGIN
&ifdef TRACE
t01bool (ak_sem, 'd_one_join_p', dmli.d_one_join_phase );
t01int4 (ak_sem, 'd_keylen    ', dmli.d_keylen);
t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
t01messblock (ak_sem, 'MESSBLOCK   ', acv.a_mblock);
&endif
sfe_rec.old_subcntlevel := -1;
sfe_rec.m2type          := mm_nil;
sfe_rec.last_res_tree   := select_rec.sel_res_tree;
sfe_rec.h_use_rowno     := sr_rec.sr_use_rowno;
sr_rec.sr_use_rowno     := false;
sfe_rec.messbuf_stored  := false;
sfe_rec.lowpars         := csp_maxint1;
_curr_n  := acv.a_ap_tree^[ select_rec.sel_from_n ].n_sa_level;
IF  (( acv.a_ap_tree^[ _curr_n ].n_proc <> a63 ) OR
    ( acv.a_ap_tree^[ _curr_n ].n_subproc <> cak_x_search_condition ))
THEN
    _curr_n := 0;
(*ENDIF*) 
dmli.d_join := true;
IF  ((NOT select_rec.sel_where_done) AND (NOT select_rec.sel_view_done))
THEN
    dmli.d_joins.jrc_cnt := 0;
(*ENDIF*) 
;
(* store original stackentries as mblock #2        *)
(* these messblock will be the second phase mblock *)
ak660move_in_hbuf (acv, sfe_rec, 2, NOT c_repl_only (* don't store *));
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    sfe_rec.messbuf_stored := true;
    sfe_rec.hmbp           := @sfe_rec.hbuf^.smessblock.mbr_mess_block;
    sfe_rec.hqbp           := sfe_rec.hmbp^.mb_qual;
    sfe_rec.hmbp^.mb_type  := m_select;
    IF  sfe_rec.hmbp^.mb_type2 = mm_with_join
    THEN
        sfe_rec.hmbp^.mb_type2 := mm_nil;
    (*ENDIF*) 
    sfe_rec.m2type  := sfe_rec.hmbp^.mb_type2;
    (* was not in one_phase *)
    sfe_rec.lowpars := dmli.d_lowpars;
    IF  ( dmli.d_corr <> no_correlation )
    THEN
        BEGIN
        sfe_rec.lowpars   := dmli.d_lowpars - 1;
        dmli.d_lowpars := dmli.d_lowpars - 1;
        END;
&   ifdef TRACE
    (*ENDIF*) 
    t01int4 (ak_sem, 'two  lowpars', sfe_rec.lowpars);
&   endif
    sfe_rec.hinoutpos         := dmli.d_inoutpos;
    sfe_rec.hkeylen           := dmli.d_keylen;
    sfe_rec.hreclen           := dmli.d_reclen;
    sfe_rec.hd_distinct       := dmli.d_distinct;
    sfe_rec.hdm_union         := dmli.d_union;
    sfe_rec.hd_single         := dmli.d_single;
    sfe_rec.hd_rowno          := dmli.d_rowno;
    sfe_rec.hd_colcount       := dmli.d_change.cr_colcount;
    dmli.d_distinct           := no_distinct;
    dmli.d_union              := false;
    dmli.d_single             := false;
    dmli.d_rowno              := cgg04_no_rowno_predicate;
    dmli.d_change.cr_colcount := 0;
    dmli.d_inoutpos           := cgg_rec_key_offset + RESCNT_MXGG04 + 1;
    IF  ( NOT dmli.d_one_join_phase )
    THEN
        dmli.d_keylen         := RESCNT_MXGG04;
    (*ENDIF*) 
    ;
    (* save key length of result record *)
    IF  ( sfe_rec.hbuf^.smessblock.mbr_mess_block.
        mb_st^[ sfe_rec.hbuf^.smessblock.mbr_mess_block.mb_qual^.mqual_pos ].
        etype = st_jump_output )
    THEN
        sfe_rec.hbuf^.smessblock.mbr_mess_block.
              mb_st^[ sfe_rec.hbuf^.smessblock.mbr_mess_block.mb_qual^.mqual_pos ].
              elen_var := sfe_rec.hkeylen;
    (*ENDIF*) 
    ak660two_repl_complex_output (acv, dmli, sfe_rec.hbuf,
          select_rec.sel_where_done, select_rec.sel_view_done,
          NOT c_functions_not_single_fields);
&   ifdef TRACE
    t01int4 (ak_sem, 'd_inoutpos c', dmli.d_inoutpos);
    t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
&   endif
    IF  ( acv.a_returncode = 0 )
    THEN
        BEGIN
        a10add_sysinfo (acv, sfe_rec.hbuf, _b_err);
        IF  ( _b_err <> e_ok )
        THEN
            a07_b_put_error (acv, _b_err, 1)
        ELSE
            a10_rel_sysinfo (acv, sfe_rec.hbuf^.syskey)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
dmli.d_group := false;
IF  (( acv.a_returncode = 0 ) AND ( _curr_n <> 0 ) AND
    NOT select_rec.sel_where_done )
THEN
    BEGIN
    IF  ((acv.a_ap_tree^[ _curr_n ].n_proc = a63) AND
        (acv.a_ap_tree^[ _curr_n ].n_subproc = cak_x_search_condition))
    THEN
        BEGIN
        _next_n := acv.a_ap_tree^[ _curr_n ].n_lo_level;
        IF  acv.a_ex_kind = only_parsing
        THEN
            a54_fixedpos (acv, dmli);
        (*ENDIF*) 
        a65_search_condition (acv, dmli, _next_n);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
sfe_rec.first_res := ( acv.a_returncode = 0 );
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    IF  (( acv.a_ex_kind = only_parsing ) AND
        NOT ( dmli.d_only_sem_check ) AND
        ( dmli.d_sparr.pparsp <> NIL ))
    THEN
        BEGIN
        (* PTS 1111975 E.Z. *)
        sfe_rec.param_parskey := dmli.d_sparr.pparsp^.syskey;
        END;
    (*ENDIF*) 
    g04build_temp_tree_id( select_rec.sel_res_tree, acv.a_transinf.tri_trans );
    select_rec.sel_res_tree.fileTfnTemp_gg00    := ttfnComplexSelect_egg00;
    a101_SetTempFileLevel (acv, select_rec.sel_res_tree,
          acv.a_pars_last_key.p_no);
    IF  a101_IsExtendedTempFile (acv, sfe_rec.last_res_tree) AND
        (a101_GetExtendedTempFileType (acv, sfe_rec.last_res_tree)
        = ttfnComplexSelect_egg00)
    THEN
        a101_SetTempFileSublevel (acv, sfe_rec.last_res_tree, 1)
    ELSE
        a101_SetTempFileSublevel (acv, select_rec.sel_res_tree, 0);
    (*ENDIF*) 
    END;
&ifdef TRACE
(*ENDIF*) 
t01int4 (ak_sem, 'd_keylen    ', dmli.d_keylen);
t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
&endif
END;
 
(* END PTS 1113318 E.Z. *)
(* PTS 1113318 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak660two_phase (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            VAR select_rec : tak_select_record;
            VAR sr_rec     : tak71_strat_rec;
            VAR sfe_rec    : t_store_for_endpart;
            store_infos    : boolean);
 
VAR
      _res_file_exists : boolean;
      _m_data_len      : integer;
 
BEGIN
&ifdef TRACE
t01int4 (ak_sem, 'd_inoutpos d', dmli.d_inoutpos);
t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
t01int4 (ak_sem, 'd_keylen    ', dmli.d_keylen);
&endif
_res_file_exists := false;
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    (* END PTS 1113318 E.Z. *)
    IF  (acv.a_ex_kind = only_parsing) AND
        (acv.a_union_cnt = 0) AND
        NOT (dmli.d_only_sem_check)
    THEN
        WITH dmli.d_sparr.pparsp^.sparsinfo DO
            BEGIN
            sfe_rec.old_subcntlevel := p_subcntlevel;
            p_subcntlevel   := - 1
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    _m_data_len := acv.a_mblock.mb_data_len;
    a67_sel2_second_part (acv, dmli, select_rec.sel_res_tree,
          c_is_not_corr_search, NOT c_last_pars_part,
          select_rec.sel_view_done, sr_rec);
&   ifdef TRACE
    t01int4 (ak_sem, 'd_inoutpos e', dmli.d_inoutpos);
    t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
    t01int4 (ak_sem, 'd_keylen    ', dmli.d_keylen);
&   endif
    IF  ((acv.a_ex_kind <> only_parsing) AND NOT dmli.d_only_sem_check)
    THEN
        BEGIN
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            select_rec.sel_res_tree := acv.a_mblock.mb_qual^.mr_restree;
            _res_file_exists :=
                  ((acv.a_mblock.mb_qual^.mr_resnum = csp_rescnt_zero) AND
                  (sfe_rec.m2type <> mm_with_functions))
            END
        ELSE
            a502destroy_file (acv, select_rec.sel_res_tree);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    acv.a_mblock.mb_data_len := _m_data_len;
    dmli.d_single             := sfe_rec.hd_single;
    dmli.d_rowno              := sfe_rec.hd_rowno;
    dmli.d_change.cr_colcount := sfe_rec.hd_colcount;
    dmli.d_distinct           := sfe_rec.hd_distinct;
    dmli.d_union              := sfe_rec.hdm_union;
    (* PTS 1115729 E.Z. *)
    sr_rec.sr_use_rowno := sfe_rec.h_use_rowno;
    END;
(*ENDIF*) 
IF  ( acv.a_returncode = 0 ) AND ( NOT dmli.d_only_sem_check )
THEN
    BEGIN
    IF  acv.a_mblock.mb_data_len = 0
    THEN
        acv.a_mblock.mb_data_len := cgg_rec_key_offset;
    (* PTS 1113318 E.Z. *)
    (*ENDIF*) 
    ak660endpart (acv, dmli, sfe_rec, select_rec.sel_order_n,
          select_rec.sel_last_pars_part, store_infos,
          (dmli.d_corr <> no_correlation),
          select_rec.sel_res_tree, select_rec, sr_rec);
&   ifdef TRACE
    t01int4 (ak_sem, 'd_inoutpos e', dmli.d_inoutpos);
    t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
&   endif
    IF  (sfe_rec.first_res AND _res_file_exists AND
        (acv.a_ex_kind <> only_parsing))
    THEN
        BEGIN
        a502destroy_file (acv, select_rec.sel_res_tree);
        IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    select_rec.sel_res_tree := sfe_rec.last_res_tree
    END;
(*ENDIF*) 
ak660cleanup_more_phase( acv, dmli, sfe_rec );
IF  dmli.d_view
THEN
    dmli.d_phase_cnt := cak_complex_view_indicator;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660two_repl_complex_output (
            VAR acv                     : tak_all_command_glob;
            VAR dmli                    : tak_dml_info;
            VAR hbuf                    : tak_sysbufferaddress;
            where_done                  : boolean;
            view_done                   : boolean;
            functions_not_single_fields : boolean);
 
VAR
      _end_pos   : integer;
      _start_pos : integer;
 
      _where_arr : RECORD
            CASE boolean OF
                true :
                    (w_arr : t_where_arr_ptr);
                false :
                    (sbuf : tak_sysbufferaddress)
                END;
            (*ENDCASE*) 
 
 
BEGIN
&IFDEF TRACE
t01p2bool( ak_sem, 'where done  ', where_done,
      'view done   ', view_done );
&ENDIF
_start_pos := hbuf^.smessblock.mbr_mess_block.mb_qual^.mqual_pos + 1;
_end_pos   := hbuf^.smessblock.mbr_mess_block.
      mb_st^[ hbuf^.smessblock.mbr_mess_block.mb_qual^.mqual_pos ].epos +
      hbuf^.smessblock.mbr_mess_block.mb_qual^.mqual_pos - 2;
(* transfer necessary output columns *)
ak660qual_part_transfer (acv, dmli, hbuf, functions_not_single_fields,
      _start_pos, _end_pos);
(* calculate start/stop of qualification *)
_start_pos := hbuf^.smessblock.
      mbr_mess_block.mb_st^[ hbuf^.smessblock.mbr_mess_block.
      mb_qual^.mqual_pos ].epos + hbuf^.smessblock.mbr_mess_block.mb_qual^.
      mqual_pos - 1;
_end_pos   := hbuf^.smessblock.mbr_mess_block.mb_qual^.mqual_pos +
      hbuf^.smessblock.mbr_mess_block.mb_qual^.mqual_cnt - 1;
&ifdef trace
t01p2int4( ak_sem, '_start_pos  ', _start_pos,
      '_end_pos    ', _end_pos );
&endif
IF  ((acv.a_returncode = 0) AND functions_not_single_fields AND
    (_start_pos <= _end_pos))
THEN
    BEGIN
    (* functions_not_single_fields = 'true' from ak660three_phase() *)
&   IFDEF TRACE
    t01name (ak_sem, 'middle1 of two_rep');
    t01name (ak_sem, '3. phase-orig. mb ');
    t01stqual (ak_sem, hbuf^.smessblock.mbr_mess_block.mb_qual^,
          hbuf^.smessblock.mbr_mess_block.mb_st);
    t01sname (ak_sem, '1./2.phase  ');
    t01stqual (ak_sem, acv.a_mblock.mb_qual^, acv.a_mblock.mb_st);
&   ENDIF
    ak660qual_part_transfer (acv, dmli, hbuf, functions_not_single_fields,
          _start_pos (* WHERE qual start *), _end_pos);
    END;
(*ENDIF*) 
a61_set_jump (acv.a_mblock, 1, st_jump_output);
acv.a_mblock.mb_st^[1].epos := succ(acv.a_mblock.mb_st^[1].epos);
IF  ((acv.a_returncode = 0) AND (where_done OR view_done) AND
    (_start_pos <= _end_pos))
THEN
    BEGIN
&   IFDEF TRACE
    t01name (ak_sem, 'middle2 of two_rep');
    IF  ( functions_not_single_fields )
    THEN
        t01name (ak_sem, '1./2. phase mblock')
    ELSE
        t01name (ak_sem, '1. phase mblock   ');
    (*ENDIF*) 
    t01stqual (ak_sem, acv.a_mblock.mb_qual^, acv.a_mblock.mb_st);
    IF  ( functions_not_single_fields )
    THEN
        t01name (ak_sem, '3. phase mblock   ')
    ELSE
        t01name (ak_sem, '2. phase mblock   ');
    (*ENDIF*) 
    t01stqual (ak_sem, hbuf^.smessblock.mbr_mess_block.mb_qual^,
          hbuf^.smessblock.mbr_mess_block.mb_st);
&   ENDIF
    a10new (acv, (((_end_pos-_start_pos) DIV 4) + 2) *
          sizeof(t_where_rec), _where_arr.sbuf);
    IF  ( _where_arr.sbuf = NIL )
    THEN
        a07_b_put_error (acv, e_no_more_memory, 1)
    ELSE
        BEGIN
        _where_arr.w_arr^[ 1 ].start := 0;
        ak660where_transfer (acv, dmli, hbuf, c_output,
              _start_pos (* WHERE qual start *), _end_pos, _where_arr.w_arr);
        a61_set_jump (acv.a_mblock, 1, st_jump_output);
        acv.a_mblock.mb_st^[1].epos := succ(acv.a_mblock.mb_st^[1].epos);
&       IFDEF TRACE
        t01name (ak_sem, 'middle3 of two_rep');
        IF  ( functions_not_single_fields )
        THEN
            t01name (ak_sem, '1./2. phase mblock')
        ELSE
            t01name (ak_sem, '1. phase mblock   ');
        (*ENDIF*) 
        t01stqual (ak_sem, acv.a_mblock.mb_qual^, acv.a_mblock.mb_st);
        IF  ( functions_not_single_fields )
        THEN
            t01name (ak_sem, '3. phase mblock   ')
        ELSE
            t01name (ak_sem, '2. phase mblock   ');
        (*ENDIF*) 
        t01stqual (ak_sem, hbuf^.smessblock.mbr_mess_block.mb_qual^,
              hbuf^.smessblock.mbr_mess_block.mb_st);
&       ENDIF
        IF  ( acv.a_returncode = 0 )
        THEN
            ak660where_transfer (acv, dmli, hbuf, NOT c_output,
                  _start_pos(* WHERE qual start *), _end_pos, _where_arr.w_arr);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    a10dispose (acv, _where_arr.sbuf);
    END;
(*ENDIF*) 
IF  ( NOT functions_not_single_fields
    (* call from ak660phase_division() *)
    AND
    ( acv.a_mblock.mb_type2 = mm_with_functions ))
THEN
    acv.a_mblock.mb_type2 := mm_nil;
(*ENDIF*) 
;
&IFDEF TRACE
t01name (ak_sem, 'end of two_repl   ');
IF  ( functions_not_single_fields )
THEN
    t01name (ak_sem, '1./2. phase mblock')
ELSE
    t01name (ak_sem, '1. phase mblock   ');
(*ENDIF*) 
t01stqual (ak_sem, acv.a_mblock.mb_qual^, acv.a_mblock.mb_st);
IF  ( functions_not_single_fields )
THEN
    t01name (ak_sem, '3. phase mblock   ')
ELSE
    t01name (ak_sem, '2. phase mblock   ');
(*ENDIF*) 
t01stqual (ak_sem, hbuf^.smessblock.mbr_mess_block.mb_qual^,
      hbuf^.smessblock.mbr_mess_block.mb_st);
&ENDIF
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660where_transfer (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            VAR hbuf       : tak_sysbufferaddress;
            create_output  : boolean;
            sourcestartpos : integer;
            sourcestoppos  : integer;
            VAR w_arr      : t_where_arr_ptr);
 
TYPE
      t_and_array   = PACKED ARRAY [ 1..4096 ] OF tsp00_Int2;
      t_and_arr_ptr = ^t_and_array;
 
VAR
      _col_output   : boolean;
      _corr_sub     : boolean;
      _into_w_arr   : boolean;
      _put_op_and   : boolean;
      _top_level    : boolean; (* either no top level test or we are on top level *)
      _is_n_null    : boolean;
      _and_pos      : integer;
      _col_tab      : integer;
      _i            : integer;
      _deststartpos : integer;
      _endpos       : integer;
      _joinpos      : integer;
      _act_pos      : integer;
      _qual_end     : integer;
      _stackcnt     : integer;
      _stackpos     : integer;
      _L1term_start : integer;
      _w_pos        : integer;
 
      _and_arr : RECORD
            CASE boolean OF
                true :
                    (and_ptr : t_and_arr_ptr);
                false :
                    (sbuf : tak_sysbufferaddress)
                END;
            (*ENDCASE*) 
 
 
BEGIN
&IFDEF TRACE
a683_output( ak_sem, dmli.d_joins );
t01bool( ak_sem, 'create_outpu', create_output );
&ENDIF
_deststartpos := acv.a_mblock.mb_qual^.mfirst_free;
_act_pos      := sourcestartpos;
_qual_end     := sourcestoppos;
_put_op_and   := false;
_w_pos        := 1;
_joinpos      := 0;
_and_pos      := 0;
a10new (acv, (((sourcestoppos-sourcestartpos) DIV 4) + 2) *
      sizeof(tsp00_Int2), _and_arr.sbuf);
IF  ( _and_arr.sbuf = NIL )
THEN
    a07_b_put_error (acv, e_no_more_memory, 1)
ELSE
    BEGIN
    WHILE ((_act_pos <= _qual_end) AND (acv.a_returncode = 0)) DO
        BEGIN
&       ifdef trace
        t01int4 (ak_sem, '_act_pos   a', _act_pos);
        t01name (ak_sem, 'step over AND arr ');
&       endif
        _top_level := false;
        WHILE w_arr^[ _w_pos ].start = _act_pos DO
            BEGIN
            (* already processed with ak660where_transfer(), skip term *)
            _act_pos := _act_pos + w_arr^[ _w_pos ].length;
            _w_pos   := succ(_w_pos);
            END;
        (*ENDWHILE*) 
        (*
&             ifdef trace
              t01int4 (ak_sem, '_act_pos   b', _act_pos);
&             endif
              *)
        IF  ( _act_pos <= _qual_end )
        THEN
            BEGIN
            _into_w_arr   := false;
            _L1term_start := _act_pos;
            (*
&                 ifdef trace
                  t01name (ak_sem, 'step to column    ');
&                 endif
                  *)
            (* step to next colunm, rowno, bool, subquery, AND *)
            WHILE ((_act_pos <= _qual_end) AND
                  NOT (hbuf^.smessblock.mbr_mess_block.mb_st^[ _act_pos ].etype in
                  [ st_fixkey, st_varkey, st_fixcol, st_varcol,
                  st_varlongchar,
                  st_rowno, st_subquery, st_bool (*old st_rowno*)
                  , st_jump_false ])) DO
                _act_pos := succ(_act_pos);
            (*ENDWHILE*) 
            (*
&                 ifdef trace
                  t01int4 (ak_sem, '_act_pos   c', _act_pos);
&                 endif
                  *)
            IF  ( _act_pos <= _qual_end )
            THEN
                (* found what we are looking for *)
                BEGIN
                _corr_sub := false;
                _col_tab  := 0;
                IF  hbuf^.smessblock.mbr_mess_block.mb_st^[ _act_pos ].etype in
                    [ st_fixkey, st_varkey, st_fixcol, st_varcol,
                    st_varlongchar ]
                THEN
                    (* get table no. *)
                    _col_tab := ord(hbuf^.smessblock.mbr_mess_block.
                          mb_st^[ _act_pos ].ecol_tab[2]);
                (*ENDIF*) 
                _col_output := false;
                (* PTS 1113318 E.Z. *)
                _is_n_null := false;
                (* look for 'top level AND', i.e. loop over *)
                (* one level-1 predicate or level-1 term    *)
                WHILE ((_act_pos <= _qual_end) AND NOT _top_level) DO
                    BEGIN
                    (*
&                         ifdef trace
                          t01int4 (ak_sem, '_act_pos   d', _act_pos);
&                         endif
                          *)
                    IF  hbuf^.smessblock.mbr_mess_block.mb_st^[ _act_pos ].etype in
                        [ st_fixkey, st_varkey, st_fixcol, st_varcol,
                        st_varlongchar ]
                    THEN
                        BEGIN
                        IF  _col_tab = 0
                        THEN
                            _col_tab := ord(hbuf^.smessblock.mbr_mess_block.
                                  mb_st^[ _act_pos ].ecol_tab[2])
                        ELSE
                            IF  ord(hbuf^.smessblock.mbr_mess_block.
                                mb_st^[ _act_pos ].ecol_tab[2]) <> _col_tab
                            THEN
                                _col_tab := -1;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        (* PTS 1113318 E.Z. *)
                        IF  ( hbuf^.smessblock.mbr_mess_block.
                            mb_st^[ _act_pos ].etype = st_value )
                            AND
                            ( hbuf^.smessblock.mbr_mess_block.
                            mb_st^[ _act_pos ].eop in [ op_null, op_not_null ] )
                            AND
                            NOT a680is_outer_predicate(dmli, _act_pos)
                        THEN
                            (* 'col is NULL', this is handled after join *)
                            _is_n_null := true;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  (( dmli.d_corr in [ first_correlation, correlation ] )
                        AND
                        ( hbuf^.smessblock.mbr_mess_block.
                        mb_st^[ _act_pos ].etype = st_subquery ))
                    THEN
                        _corr_sub := true;
                    (*ENDIF*) 
                    IF  ( hbuf^.smessblock.mbr_mess_block.
                        mb_st^[ _act_pos ].etype = st_jump_false )
                    THEN
                        BEGIN
                        g04check_if_top_level(hbuf^.smessblock.mbr_mess_block.
                              mb_st, _act_pos, _qual_end, _top_level);
                        (*
&                             ifdef trace
                              t01bool( ak_sem, 'TOPLEVEL CHK', _top_level );
&                             endif
                              *)
                        END;
                    (*ENDIF*) 
                    ;
                    (*
&                         ifdef trace
                          t01int4 (ak_sem, '_col_tab    ', _col_tab);
                          t01bool( ak_sem, '_corr_sub   ', _corr_sub );
                          t01bool( ak_sem, '_is_n_null  ', _is_n_null  );
&                         endif
                          *)
                    IF  NOT _top_level
                    THEN
                        _act_pos := succ(_act_pos);
                    (*ENDIF*) 
                    ;
                    (* exit if L1 term ends *)
                    END;
                (*ENDWHILE*) 
                (*
&                     ifdef trace
                      t01int4 (ak_sem, '_act_pos   e', _act_pos);
&                     endif
                      *)
                IF  (( _col_tab = -1 ) AND dmli.d_join )
                THEN
                    FOR _i := 1 TO dmli.d_joins.jrc_cnt DO
                        IF  ( dmli.d_joins.jrc_joinarr^[ _i - 1 ].
                            jo_recs[ 1 ].jop_startstack >= _L1term_start )
                            AND
                            ( dmli.d_joins.jrc_joinarr^[ _i - 1 ].
                            jo_recs[ 1 ].jop_startstack +
                            dmli.d_joins.jrc_joinarr^[ _i - 1 ].
                            jo_recs[ 1 ].jop_cntstack <= _act_pos )
                        THEN
                            (* join on level 1 found *)
                            _col_tab := 0;
                        (*ENDIF*) 
                    (*ENDFOR*) 
                (*ENDIF*) 
                ;
                (* PTS 1113318 E.Z. *)
                IF  (( _col_tab = -1 ) OR
                    (* columns for an OR-join *)
                    ( _is_n_null AND dmli.d_outer_join ))
                    (* for outer join 'col is NULL' has *)
                    (* to be processed after join       *)
                THEN
                    _col_output := true;
                (*ENDIF*) 
                IF  ( _corr_sub )
                THEN
                    _col_output := false;
                (*ENDIF*) 
                IF  ( _col_output )
                THEN
                    BEGIN
&                   ifdef trace
                    t01sname (ak_sem, 'col out!    ');
&                   endif
                    IF  ( create_output )
                    THEN
                        BEGIN
                        IF  ( _act_pos > _qual_end )
                        THEN
                            ak660qual_part_transfer (acv, dmli, hbuf,
                                  NOT c_functions_not_single_fields,
                                  _L1term_start, _qual_end)
                        ELSE
                            ak660qual_part_transfer (acv, dmli, hbuf,
                                  NOT c_functions_not_single_fields,
                                  _L1term_start, _act_pos);
                        (*ENDIF*) 
                        _into_w_arr := true;
&                       IFDEF TRACE
                        t01int4 (ak_sem, '_L1term_star', _L1term_start);
&                       ENDIF
                        WHILE (( dmli.d_joins.jrc_joinarr^[ _joinpos ].
                              jo_recs[ 1 ].jop_startstack < _L1term_start )
                              AND
                              ( _joinpos < dmli.d_joins.jrc_cnt )) DO
                            _joinpos := succ(_joinpos);
                        (*ENDWHILE*) 
                        IF  ( _joinpos < dmli.d_joins.jrc_cnt )
                        THEN
                            BEGIN
                            IF  ( dmli.d_joins.jrc_joinarr^[ _joinpos ].
                                jo_recs[ 1 ].jop_startstack = _L1term_start )
                            THEN
                                (* IS NULL found, remove it *)
                                BEGIN
                                FOR _i := _joinpos TO
                                      dmli.d_joins.jrc_cnt-2 DO
                                    dmli.d_joins.jrc_joinarr^[ _i ] :=
                                          dmli.d_joins.jrc_joinarr^[ _i+1 ];
                                (*ENDFOR*) 
                                dmli.d_joins.jrc_cnt :=
                                      pred( dmli.d_joins.jrc_cnt );
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    (* not _col_output, i.e.                     *)
                    (* subquery found OR                         *)
                    (* ( _col_tab = 0 (i.e. join found ) AND     *)
                    (* NOT ( _is_n_null AND dmli.d_outer_join )) *)
                    BEGIN
&                   ifdef trace
                    t01sname (ak_sem, 'no col out! ');
&                   endif
                    IF  ( NOT create_output )
                    THEN
                        BEGIN
&                       ifdef trace
                        t01bool( ak_sem, '_put_op_and ', _put_op_and );
&                       endif
                        IF  ( _put_op_and )
                        THEN
                            IF  ( acv.a_mblock.mb_qual^.mfirst_free <=
                                acv.a_mblock.mb_st_max )
                            THEN
                                BEGIN
                                (* The actual stackposition is stored  *)
                                (* in _and_arr, so that after processing*)
                                (* all and_operands the jumps and      *)
                                (* operators can be inserted in the    *)
                                (* stack. This means that the postfix  *)
                                (* stackstructure is again generated,  *)
                                (* see also VAK54, VAK65               *)
                                _and_pos        := succ (_and_pos);
                                _and_arr.and_ptr^[ _and_pos ] :=
                                      acv.a_mblock.mb_qual^.mfirst_free;
                                acv.a_mblock.mb_qual^.mqual_cnt      :=
                                      succ(acv.a_mblock.mb_qual^.mqual_cnt);
                                acv.a_mblock.mb_qual^.mfirst_free    :=
                                      succ (acv.a_mblock.mb_qual^.mfirst_free)
                                END
                            ELSE
                                a07_b_put_error (acv,
                                      e_too_many_mb_stackentries, 1);
                            (*ENDIF*) 
                        (*ENDIF*) 
                        _endpos := pred( _act_pos );
                        (* position before operator if we on an AND operator *)
                        WHILE (( hbuf^.smessblock.mbr_mess_block.
                              mb_st^[ _endpos ].etype = st_op )
                              AND
                              ( hbuf^.smessblock.mbr_mess_block.
                              mb_st^[ _endpos ].eop in
                              [ op_and, op_upd_view_and ] )) DO
                            _endpos := pred( _endpos );
                        (*ENDWHILE*) 
                        IF  ( hbuf^.smessblock.mbr_mess_block.
                            mb_st^[ _endpos ].eop in
                            [ op_and, op_upd_view_and ] )
                        THEN
                            hbuf^.smessblock.mbr_mess_block.
                                  mb_st^[ _endpos ].eop := op_none;
                        (*ENDIF*) 
                        IF  ( acv.a_mblock.mb_qual^.mfirst_free +
                            _endpos - _L1term_start > acv.a_mblock.mb_st_max )
                        THEN
                            BEGIN
                            a07_b_put_error (acv, e_too_many_mb_stackentries, 1);
                            _act_pos := _qual_end + 1;
                            END
                        ELSE
                            BEGIN
                            _stackcnt := _endpos - _L1term_start + 1;
                            IF  (( hbuf^.smessblock.mbr_mess_block.mb_qual^.
                                mview_pos > 0 )
                                AND
                                ( hbuf^.smessblock.mbr_mess_block.mb_qual^.
                                mview_cnt > 0 )
                                AND
                                ( _L1term_start >= hbuf^.smessblock.mbr_mess_block.
                                mb_qual^.mview_pos )
                                AND
                                ( _L1term_start <= hbuf^.smessblock.mbr_mess_block.
                                mb_qual^.mview_pos + hbuf^.smessblock.mbr_mess_block.
                                mb_qual^.mview_cnt - 1 ))
                            THEN
                                BEGIN
                                IF  ( acv.a_mblock.mb_qual^.mview_pos = 0 )
                                THEN
                                    acv.a_mblock.mb_qual^.mview_pos :=
                                          acv.a_mblock.mb_qual^.mfirst_free;
                                (*ENDIF*) 
                                acv.a_mblock.mb_qual^.mview_cnt :=
                                      acv.a_mblock.mb_qual^.mview_cnt + _stackcnt;
                                END;
                            (*ENDIF*) 
                            SAPDB_PascalMove ('VAK660',   4,    
                                  hbuf^.smessblock.mbr_mess_block.
                                  mb_qual^.mst_max * STACK_ENTRY_MXGG00,
                                  acv.a_mblock.mb_st_size,
                                  @hbuf^.smessblock.mbr_mess_block.mb_st^,
                                  (_L1term_start - 1) * STACK_ENTRY_MXGG00 + 1,
                                  @acv.a_mblock.mb_st^,
                                  (acv.a_mblock.mb_qual^.mfirst_free - 1) *
                                  STACK_ENTRY_MXGG00 + 1,
                                  _stackcnt*STACK_ENTRY_MXGG00,
                                  acv.a_returncode);
&                           ifdef trace
                            t01int4 (ak_sem, '_L1term_star', _L1term_start);
                            t01int4 (ak_sem, '_endpos     ', _endpos );
                            FOR _i := _L1term_start TO _L1term_start + _stackcnt - 1 DO
                                BEGIN
                                t01stackentry( ak_sem, hbuf^.smessblock.
                                      mbr_mess_block.mb_st^[ _i ], _i );
                                END;
                            (*ENDFOR*) 
&                           endif
                            IF  ( acv.a_returncode = 0 )
                            THEN
                                BEGIN
                                WHILE (( dmli.d_joins.jrc_joinarr^[ _joinpos ].
                                      jo_recs[ 1 ].jop_startstack < _L1term_start )
                                      AND
                                      ( _joinpos < dmli.d_joins.jrc_cnt )) DO
                                    _joinpos := succ( _joinpos );
                                (*ENDWHILE*) 
                                IF  ( _joinpos < dmli.d_joins.jrc_cnt )
                                THEN
                                    IF  ( dmli.d_joins.jrc_joinarr^[ _joinpos ].
                                        jo_recs[ 1 ].jop_startstack = _L1term_start )
                                    THEN
                                        BEGIN
                                        dmli.d_joins.jrc_joinarr^[ _joinpos ].
                                              jo_recs[ 2 ].jop_startstack :=
                                              acv.a_mblock.mb_qual^.mfirst_free
                                              +
                                              ( dmli.d_joins.
                                              jrc_joinarr^[ _joinpos ].
                                              jo_recs[ 2 ].jop_startstack -
                                              dmli.d_joins.
                                              jrc_joinarr^[ _joinpos ].
                                              jo_recs[ 1 ].jop_startstack );
                                        dmli.d_joins.jrc_joinarr^[ _joinpos ].
                                              jo_recs[ 1 ].jop_startstack :=
                                              acv.a_mblock.mb_qual^.mfirst_free;
                                        _joinpos := succ( _joinpos );
                                        END;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                acv.a_mblock.mb_qual^.mfirst_free :=
                                      acv.a_mblock.mb_qual^.mfirst_free + _stackcnt;
                                acv.a_mblock.mb_qual^.mqual_cnt   :=
                                      acv.a_mblock.mb_qual^.mqual_cnt + _stackcnt;
                                (* for 2. phase wipe out predicate *)
                                FOR _stackpos := _L1term_start TO _endpos - 1 DO
                                    BEGIN
                                    hbuf^.smessblock.mbr_mess_block.
                                          mb_st^[ _stackpos ].etype := st_dummy;
                                    hbuf^.smessblock.mbr_mess_block.
                                          mb_st^[ _stackpos ].eop   := op_none
                                    END;
                                (*ENDFOR*) 
                                ;
                                (* eliminate operator, jump true/false *)
                                hbuf^.smessblock.mbr_mess_block.
                                      mb_st^[ _endpos ].etype    := st_bool;
                                hbuf^.smessblock.mbr_mess_block.
                                      mb_st^[ _endpos ].eop      := op_none;
                                hbuf^.smessblock.mbr_mess_block.
                                      mb_st^[ _endpos ].epos     := 1;
                                hbuf^.smessblock.mbr_mess_block.
                                      mb_st^[ _endpos ].elen_var := 0;
                                hbuf^.smessblock.mbr_mess_block.
                                      mb_st^[ _endpos ].ecol_pos := 0;
                                _put_op_and := true
                                END
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            ;
            (* loop over term border and operator *)
            WHILE (( _act_pos <= _qual_end )
                  AND
                  ( hbuf^.smessblock.mbr_mess_block.mb_st^[ _act_pos ].
                  etype in [ st_jump_true, st_jump_false, st_op ] )) DO
                _act_pos := succ(_act_pos);
            (*ENDWHILE*) 
            IF  ( _into_w_arr )
            THEN
                (* _col_output AND create_output *)
                BEGIN
                w_arr^[ _w_pos ].start  := _L1term_start;
                w_arr^[ _w_pos ].length := _act_pos - _L1term_start;
                _w_pos                := succ(_w_pos);
                w_arr^[ _w_pos ].start := 0
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    FOR _stackpos := _and_pos DOWNTO 1 DO
        BEGIN
        (* The stored positions for jumps and operators are filled *)
        a65_set_operator ( acv, op_and);
        a61_set_jump( acv.a_mblock, _and_arr.and_ptr^[ _stackpos ], st_jump_false)
        END;
    (*ENDFOR*) 
    a10dispose( acv, _and_arr.sbuf );
    END;
(*ENDIF*) 
&IFDEF TRACE
a683_output (ak_sem, dmli.d_joins);
&ENDIF
END;
 
(*------------------------------*) 
 
PROCEDURE
      a660fsame_pred (
            VAR acv            : tak_all_command_glob;
            same_node          : integer;
            VAR first_same_node : integer;
            VAR node_diff      : integer);
 
VAR
      _act_node    : integer;
 
BEGIN
(*   a660fsame_pred searchs for the first node in same level.   *)
(*   This node is called first_same_node. The logical space     *)
(*   between first_same_node and same_node is called node_diff. *)
_act_node  := same_node;
node_diff := 0;
REPEAT
    first_same_node := _act_node;
    _act_node       := a660same_pred (acv, first_same_node);
    IF  _act_node <> 0
    THEN
        node_diff := node_diff + 1;
    (*ENDIF*) 
UNTIL
    (_act_node = 0);
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a660same_pred (
            VAR acv   : tak_all_command_glob;
            same_node : integer) : integer;
 
VAR
      _act_node : integer;
 
BEGIN
a660same_pred := 0;
_act_node       := 1;
WHILE _act_node <= acv.a_scv_index DO
    WITH acv.a_ap_tree^[ _act_node ] DO
        IF  ni_skip_node in n_special
        THEN
            (* end of current piece of tree, skip to next *)
            (* valid index                                *)
            _act_node := n_pos
        ELSE
            IF  n_sa_level = same_node
            THEN (* The predecessor on the same level is found. *)
                BEGIN
                a660same_pred := _act_node;
                _act_node       := csp_maxint2
                END
            ELSE
                IF  ni_info_node in n_special
                THEN
                    _act_node := _act_node + 2
                ELSE
                    _act_node := _act_node + 1;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a660lower_pred (
            VAR acv    : tak_all_command_glob;
            lower_node : integer) : integer;
 
VAR
      _act_node : integer;
 
BEGIN
a660lower_pred := 0;
_act_node       := 1;
WHILE _act_node <= acv.a_scv_index DO
    WITH acv.a_ap_tree^[ _act_node ] DO
        IF  ni_skip_node in n_special
        THEN
            (* end of current piece of tree, skip to next *)
            (* valid index                                *)
            _act_node := n_pos
        ELSE
            IF  n_lo_level = lower_node
            THEN (* The predecessor on the same level is found. *)
                BEGIN
                a660lower_pred := _act_node;
                _act_node       := csp_maxint2
                END
            ELSE
                IF  ni_info_node in n_special
                THEN
                    _act_node := _act_node + 2
                ELSE
                    _act_node := _act_node + 1;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a660pos_pred (
            VAR acv  : tak_all_command_glob;
            pos_node : integer) : integer;
 
VAR
      _act_node : integer;
 
BEGIN
a660pos_pred := 0;
_act_node       := 1;
WHILE _act_node <= acv.a_scv_index DO
    WITH acv.a_ap_tree^[ _act_node ] DO
        IF  ni_skip_node in n_special
        THEN
            (* end of current piece of tree, skip to next *)
            (* valid index                                *)
            _act_node := n_pos
        ELSE
            (* PTS 1117747 E.Z. *)
            IF  ( n_proc = a63)                          AND
                (
                (n_subproc = cak_x_subquery)         OR
                (n_subproc = cak_x_one_val_subquery) OR
                (n_subproc = cak_x_corr_subquery   ) OR
                (n_subproc = cak_x_one_val_corr_sub)
                )                                        AND
                ( n_pos = pos_node)
            THEN (* The node pointing to the current select_node is found. *)
                BEGIN
                a660pos_pred := _act_node;
                _act_node     := csp_maxint2
                END
            ELSE
                IF  ni_info_node in n_special
                THEN
                    _act_node := _act_node + 2
                ELSE
                    _act_node := _act_node + 1;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a660_explain (
            VAR acv   : tak_all_command_glob;
            startnode : tsp00_Int2);
 
VAR
      _m_acv_info_output : boolean;
      _mex_kind          : tak_execution_kind;
      _expl              : tak71_explain_rec;
      _del_cnt           : integer;
      _pos_result        : integer;
 
BEGIN
&ifdef trace
t01execution_kind (ak_sem, 'a_ex_kind   ', acv.a_ex_kind);
&endif
acv.a_pars_explain  := (acv.a_ex_kind = only_parsing);
_mex_kind           := acv.a_ex_kind;
acv.a_ex_kind       := only_parsing;
_m_acv_info_output  := acv.a_info_output;
acv.a_info_output   := false;
acv.a_costcheck     := true;
acv.a_intern_explain:= true;
a660_select (acv, startnode);
&ifdef trace
t01int4 (ak_sem, 'Intern_selec', acv.a_intern_select_cnt);
t01int4 (ak_sem, 'Max_intern_s', acv.a_max_intern_select);
&endif
IF  acv.a_intern_select_cnt = acv.a_max_intern_select
THEN
    BEGIN
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        _expl.exp_user         := a01_il_b_identifier;
        _expl.exp_column       := a01_il_b_identifier;
        _expl.exp_flags        := [];
        _pos_result            := cak_intern_pos;
        IF  acv.a_resname_addr[ cak_intern_pos ] = NIL
        THEN
            _pos_result   := cak_extern_pos;
        (*ENDIF*) 
        WITH acv.a_resname_addr[ _pos_result ]^.sresname DO
            BEGIN
            IF  (acv.a_expl_resname <> a01_zero_res_name)
            THEN
                _expl.exp_table := acv.a_expl_resname
            ELSE
                _expl.exp_table := a01_il_b_identifier;
            (*ENDIF*) 
            IF  ((rs_intinvnoresult in resstate) OR
                (rs_noresult in resstate))
            THEN
                _expl.exp_strat := '   RESULT IS NOT COPIED , COSTVALUE IS  '
            ELSE
                _expl.exp_strat := '     RESULT IS COPIED   , COSTVALUE IS  ';
            (*ENDIF*) 
            resmaxlinkage := 0;
            END;
        (*ENDWITH*) 
        _expl.exp_pagecount := acv.a_costsum;
        IF  ( _expl.exp_pagecount = 0 )
        THEN
            _expl.exp_pagecount := 1;
        (*ENDIF*) 
        IF  NOT acv.a_pars_explain
        THEN
            BEGIN
            a40add_explain_record (acv, _expl);
            (* PTS 1128197 D.T. *)
            IF  acv.a_cmd_segment_header.sp1c_producer = sp1pr_view_optimizer
            THEN
                acv.a_queryrewrite_done := Statement_Rewrite;
            (*ENDIF*) 
            IF  ( acv.a_queryrewrite_mode <> No_Rewrite )
            THEN
                BEGIN
                _expl.exp_pagecount := cak_is_undefined;
                IF  ( acv.a_queryrewrite_mode = Statement_Rewrite )
                THEN
                    BEGIN
                    IF  ( acv.a_queryrewrite_done = Statement_Rewrite )
                    THEN
                        BEGIN
                        _expl.exp_strat := 'QUERYREWRITE MODE : STATEMENT           ';
                        a40add_explain_record (acv, _expl);
                        _expl.exp_strat := '   Merge Complexview                    ';
                        a40add_explain_record (acv, _expl);
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  ( acv.a_queryrewrite_mode = Operator_Rewrite )
                THEN
                    BEGIN
                    IF  ( acv.a_queryrewrite_done = Operator_Rewrite )
                    THEN
                        BEGIN
                        _expl.exp_strat := 'QUERYREWRITE MODE : OPERATOR            ';
                        a40add_explain_record (acv, _expl);
                        IF  ( qrwMergeF in acv.a_queryrewrite_exec )
                        THEN
                            BEGIN
                            _expl.exp_strat := '   MergeFromSelectOrView                ';
                            a40add_explain_record (acv, _expl);
                            END;
                        (*ENDIF*) 
                        IF  ( qrwMergeE in acv.a_queryrewrite_exec )
                        THEN
                            BEGIN
                            _expl.exp_strat := '   MergeExistentialSubquery             ';
                            a40add_explain_record (acv, _expl);
                            END;
                        (*ENDIF*) 
                        IF  ( qrwConvertExist in acv.a_queryrewrite_exec )
                        THEN
                            BEGIN
                            _expl.exp_strat := '   ConvertExistentialSubquery           ';
                            a40add_explain_record (acv, _expl);
                            END;
                        (*ENDIF*) 
                        IF  ( qrwConvertToExist in acv.a_queryrewrite_exec )
                        THEN
                            BEGIN
                            _expl.exp_strat := '   ConvertToExistentialSubquery         ';
                            a40add_explain_record (acv, _expl);
                            END;
                        (*ENDIF*) 
                        IF  ( qrwDistinctPullUp in acv.a_queryrewrite_exec )
                        THEN
                            BEGIN
                            _expl.exp_strat := '   DistinctPullUp                       ';
                            a40add_explain_record (acv, _expl);
                            END;
                        (*ENDIF*) 
                        IF  ( qrwDistinctPushDownTo in acv.a_queryrewrite_exec )
                        THEN
                            BEGIN
                            _expl.exp_strat := '   DistinctPushDownTo                   ';
                            a40add_explain_record (acv, _expl);
                            END;
                        (*ENDIF*) 
                        IF  ( qrwDistinctPushDownFrom in acv.a_queryrewrite_exec )
                        THEN
                            BEGIN
                            _expl.exp_strat := '   DistinctPushDownFrom                 ';
                            a40add_explain_record (acv, _expl);
                            END;
                        (*ENDIF*) 
                        IF  ( qrwDistinctForSubqueries in acv.a_queryrewrite_exec )
                        THEN
                            BEGIN
                            _expl.exp_strat := '   DistinctForSubqueries                ';
                            a40add_explain_record (acv, _expl);
                            END;
                        (*ENDIF*) 
                        IF  ( qrwSimplifyPredicates in acv.a_queryrewrite_exec )
                        THEN
                            BEGIN
                            _expl.exp_strat := '   SimplifiyPredicates                  ';
                            a40add_explain_record (acv, _expl);
                            END;
                        (*ENDIF*) 
                        IF  ( qrwOptimizeSubquery in acv.a_queryrewrite_exec )
                        THEN
                            BEGIN
                            _expl.exp_strat := '   OptimizeSubquery                     ';
                            a40add_explain_record (acv, _expl);
                            END;
                        (*ENDIF*) 
                        IF  ( qrwEliminateGroupByOrDistinct in acv.a_queryrewrite_exec )
                        THEN
                            BEGIN
                            _expl.exp_strat := '   EliminateGroupByOrDistinct           ';
                            a40add_explain_record (acv, _expl);
                            END;
                        (*ENDIF*) 
                        IF  ( qrwEliminateOrderBy in acv.a_queryrewrite_exec )
                        THEN
                            BEGIN
                            _expl.exp_strat := '   EliminateOrderBy                     ';
                            a40add_explain_record (acv, _expl);
                            END;
                        (*ENDIF*) 
                        IF  ( qrwPushDownPredicates in acv.a_queryrewrite_exec )
                        THEN
                            BEGIN
                            _expl.exp_strat := '   PushDownPredicates                   ';
                            a40add_explain_record (acv, _expl);
                            END;
                        (*ENDIF*) 
                        IF  ( qrwPushDownProjection in acv.a_queryrewrite_exec )
                        THEN
                            BEGIN
                            _expl.exp_strat := '   PushDownProjection                   ';
                            a40add_explain_record (acv, _expl);
                            END;
                        (*ENDIF*) 
                        IF  ( qrwPushDownQuantifier in acv.a_queryrewrite_exec )
                        THEN
                            BEGIN
                            _expl.exp_strat := '   PushDownQuantifier                   ';
                            a40add_explain_record (acv, _expl);
                            END;
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    acv.a_info_output := _m_acv_info_output;
    acv.a_ex_kind     := _mex_kind;
    IF  (acv.a_ex_kind <> only_parsing)
    THEN
        a660_prefix_delete (acv, acv.a_pars_last_key,
              _del_cnt, cak_complete_prefix);
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a660_first_sel_part (
            VAR acv                     : tak_all_command_glob;
            VAR dmli                    : tak_dml_info;
            VAR select_rec              : tak_select_record;
            VAR pseudo_resultset_select : boolean);
 
VAR
      _syskey_tableid : tgg00_Surrogate;
 
BEGIN
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    pseudo_resultset_select :=
          pseudo_resultset_select
          OR (
          (acv.a_max_intern_select > 0) AND
          (acv.a_max_intern_select = acv.a_intern_select_cnt) AND
          (acv.a_init_ex_kind <> only_parsing) AND
          ((hsTempLock_egg00 in dmli.d_globstate) OR
          ( hsPermLock_egg00 in dmli.d_globstate)) AND
          (NOT dmli.d_view) AND
          (NOT dmli.d_subquery)
          );
&   ifdef TRACE
    t01bool (ak_sem, 'pseudo_resul', pseudo_resultset_select);
    t01bool (ak_sem, 'd_subquery  ', dmli.d_subquery);
    t01bool (ak_sem, 'max_inter >0', (acv.a_max_intern_select > 0));
    t01bool (ak_sem, 'info_output ', acv.a_info_output);
    t01execution_kind (ak_sem, 'a_ex_kind   ', acv.a_ex_kind );
    t01bool (ak_sem, 'lock in stat',
          ((hsTempLock_egg00 in dmli.d_globstate) OR
          ( hsPermLock_egg00 in dmli.d_globstate)));
    t01command_kind (ak_sem, 'command_kind', acv.a_command_kind);
    t01bool (ak_sem, 'd_view      ', dmli.d_view);
    t01int4 (ak_sem, 'a_union_cnt ', acv.a_union_cnt);
&   endif
    select_rec.sel_output_n := acv.a_ap_tree^[ select_rec.sel_output_n ].n_lo_level;
    WITH acv.a_ap_tree^[ select_rec.sel_output_n ] DO
        IF  ((n_proc = a63) AND (n_subproc = cak_x_distinct))
        THEN
            BEGIN
            dmli.d_distinct     := full_distinct;
            select_rec.sel_output_n   := n_lo_level;
            END
        ELSE
            IF  NOT dmli.d_union
            THEN
                dmli.d_distinct := no_distinct;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDWITH*) 
    dmli.d_inoutpos           := 1;
    (* PTS 1122903 E.Z. *)
    IF  NOT (
        (dmli.d_subquery ) AND
        (acv.a_command_kind = union_in_sub_command) AND
        (acv.a_union_cnt > 0)
        )
    THEN
        dmli.d_rowno              := cgg04_no_rowno_predicate;
    (*ENDIF*) 
    IF  NOT acv.a_insert_select
    THEN
        dmli.d_change.cr_colcount := 0;
    (*ENDIF*) 
    dmli.d_outcolno           := 1;
    dmli.d_exprno             := 1;
    dmli.d_refname            := a01_il_b_identifier;
    dmli.d_like               := false;
    dmli.d_movebefore         := cgg_rec_key_offset;
    dmli.d_pargeslen          := 0;
    dmli.d_range              := false;
    dmli.d_maxlen             := 0;
    select_rec.sel_last_pars_part   := false;
    dmli.d_globstate          := dmli.d_unchanged_globstate;
    dmli.d_order_cols.ocntord := 0;
    dmli.d_order_or_group_cols := @dmli.d_order_cols;
    IF  ( dmli.d_subquery )
    THEN
        BEGIN
        dmli.d_globstate := dmli.d_globstate - [ hsIntentExcl_egg00 ];
        IF  hsConsistentLock_egg00 in dmli.d_globstate
        THEN
            BEGIN
            dmli.d_globstate := dmli.d_globstate - [ hsConsistentLock_egg00 ];
            IF  ((hsPermLock_egg00 in dmli.d_globstate) OR
                (hsTempLock_egg00 in dmli.d_globstate))
            THEN
                dmli.d_globstate := dmli.d_globstate + [ hsWithoutLock_egg00 ]
            ELSE
                dmli.d_globstate := dmli.d_globstate + [ hsCollisionTest_egg00 ];
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a660construct_subtree (acv, select_rec.sel_res_tree, dmli.d_subcount);
        IF  (acv.a_command_kind = union_in_sub_command) AND
            (acv.a_union_cnt > 0)
        THEN
            BEGIN
            IF  acv.a_union_cnt > 1
            THEN
                a101_SetTempFileIndex (acv, select_rec.sel_res_tree,
                      acv.a_union_cnt);
            (*ENDIF*) 
            select_rec.sel_res_name := a01_zero_res_name;
            a663_make_res_buf (acv, dmli, select_rec.sel_res_name, select_rec.sel_res_tree)
            END;
        (*ENDIF*) 
        dmli.d_single := false;
        dmli.d_keylen := HASHVAL_MXGG04 + RESCNT_MXGG04;
        (* always 8 Bytes, in correlated Subquery in sub_op_set *)
        (* not possible to decide if new_atdistinct, bv_distinct *)
        (* will be in underlying subquery *)
        dmli.d_inoutpos := cgg_rec_key_offset + 1 + dmli.d_keylen;
        select_rec.sel_into_n := acv.a_ap_tree^[ select_rec.sel_output_n ].n_sa_level;
        select_rec.sel_from_n := select_rec.sel_into_n
        END
    ELSE
        BEGIN
        IF  hsIntentExcl_egg00 in dmli.d_globstate
        THEN
            dmli.d_globstate := dmli.d_globstate -
                  [ hsConsistentLock_egg00, hsWithoutLock_egg00 ];
        (*ENDIF*) 
        IF  ( acv.a_union_cnt > 1 )
        THEN
            WITH acv.a_unionrec_ptr^.sunionrec DO
                BEGIN
                select_rec.sel_res_name := ures_name;
                g04build_temp_tree_id( select_rec.sel_res_tree,
                      acv.a_transinf.tri_trans );
                select_rec.sel_res_tree.fileTfnTemp_gg00    := ttfnUnion_egg00;
                a101_SetTempFileLevel (acv, select_rec.sel_res_tree,
                      acv.a_union_cnt);
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  ( acv.a_union_cnt <= 1 )
        THEN
            BEGIN
            select_rec.sel_res_name := a01_il_b_identifier;
&           IFDEF TRACE
            t01int4 (ak_sem, 'a_int_sel_cn', acv.a_intern_select_cnt);
            t01int4 (ak_sem, 'a_max_intern', acv.a_max_intern_select);
&           ENDIF
            IF  ( acv.a_intern_select_cnt < acv.a_max_intern_select )
            THEN
                select_rec.sel_res_name := a01_zero_res_name;
            (*ENDIF*) 
            ;
&           ifdef TRACE
            t01int4( ak_sem, 'sel_output_n', select_rec.sel_output_n );
&           endif
            IF  ( NOT dmli.d_view )
            THEN
                BEGIN
                IF  acv.a_intern_explain AND a663parse_for_execute( acv ) AND
                    (acv.a_recursive_state = rs_no_recursive_select)
                THEN
                    BEGIN
                    select_rec.sel_res_name    := acv.a_result_name;
                    dmli.d_resname_found := true;
                    WITH acv.a_ap_tree^[ select_rec.sel_output_n ] DO
                        IF  (n_proc <> a60) OR
                            (n_subproc <> cak_x_select_list)
                        THEN
                            select_rec.sel_output_n := n_sa_level;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    ;
&                   ifdef trace
                    t01int4 (ak_sem, 'sel_output_n', select_rec.sel_output_n);
                    t01lidentifier (ak_sem, select_rec.sel_res_name);
&                   endif
                    END
                ELSE
                    WITH acv.a_ap_tree^[ select_rec.sel_output_n ] DO
                        IF  (n_proc = a60)     AND
                            (n_subproc  = cak_x_select_list)
                        THEN
                            BEGIN
                            (* CR 1000220 E.Z. *)
                            IF  (acv.a_init_ex_kind = parsing_executing)       AND
                                NOT (acv.a_from_select OR acv.a_insert_select) AND
                                (acv.a_intern_select_cnt = acv.a_max_intern_select)
                            THEN
                                BEGIN
                                IF  acv.a_resname_part <> NIL
                                THEN
                                    BEGIN
                                    a501get_resname (acv, dmli);
                                    select_rec.sel_res_name := dmli.d_resname;
                                    dmli.d_resname_found := true;
                                    END
                                ELSE
                                    dmli.d_resname_found := false;
                                (*ENDIF*) 
                                END
                            ELSE
                                dmli.d_resname_found := false;
                            (*ENDIF*) 
                            END
                        ELSE
                            BEGIN
                            dmli.d_resname_found := true;
                            IF  n_symb = s_identifier
                            THEN
                                a05identifier_get (acv, select_rec.sel_output_n,
                                      sizeof (select_rec.sel_res_name),
                                      select_rec.sel_res_name)
                            ELSE
                                ak660describe_resultname (acv,
                                      dmli, select_rec.sel_res_name, select_rec.sel_output_n);
                            (*ENDIF*) 
                            IF  acv.a_from_select OR
                                acv.a_insert_select
                            THEN
                                a07_nb_put_error (acv,
                                      e_no_resulttable_allowed,
                                      n_pos, select_rec.sel_res_name)
                            ELSE
                                select_rec.sel_output_n := n_sa_level
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  ( acv.a_from_select OR acv.a_insert_select )
            THEN
                BEGIN
                dmli.d_resname_found    := false;
                select_rec.sel_res_name := a01_zero_res_name
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  ( acv.a_returncode = 0 )
        THEN
            BEGIN
            (* PTS 1114017 E.Z. *)
            IF  acv.a_from_select OR
                ((acv.a_command_kind = union_in_sub_command) AND (acv.a_fromsel_n > 0))
            THEN
                BEGIN
                g04build_temp_tree_id (select_rec.sel_res_tree,
                      acv.a_transinf.tri_trans);
                (* PTS 1111510 E.Z. *)
                select_rec.sel_res_tree.fileTfnTemp_gg00 := ttfnFromSelect_egg00;
                a101_SetTempFileLevel (acv, select_rec.sel_res_tree,
                      acv.a_ap_tree^[ acv.a_fromsel_n ].n_pos);
                a661_build_t_fromsel_tableid (_syskey_tableid,
                      select_rec.sel_res_tree.fileTabId_gg00,
                      acv.a_curr_ex_parskey, cgg_zero_c2,
                      acv.a_ap_tree^[ acv.a_fromsel_n ].n_pos);
                a101_SetTempFileLevel (acv, select_rec.sel_res_tree,
                      acv.a_ap_tree^[ acv.a_fromsel_n ].n_pos);
                IF  (acv.a_command_kind = union_in_sub_command)
                THEN
                    BEGIN
                    IF  acv.a_union_cnt > 1
                    THEN
                        a101_SetTempFileIndex (acv, select_rec.sel_res_tree,
                              acv.a_union_cnt);
                    (*ENDIF*) 
                    select_rec.sel_res_name := a01_zero_res_name;
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            select_rec.sel_into_n := acv.a_ap_tree^[ select_rec.sel_output_n ].n_sa_level;
            WITH acv.a_ap_tree^[ select_rec.sel_into_n ] DO
                IF  (n_proc    = a60)            AND
                    (n_subproc = cak_x_single_select)
                THEN
                    BEGIN
                    IF  ( pseudo_resultset_select OR acv.a_intern_explain )
                    THEN
                        BEGIN
&                       ifdef trace
                        t01sname (ak_sem, 'pseudo/expl ');
&                       endif
                        select_rec.sel_res_name := a01_zero_res_name;
                        dmli.d_single     :=
                              acv.a_intern_explain    AND
                              NOT acv.a_parsing_again AND
                              a663parse_for_execute (acv);
                        a663_make_res_buf( acv, dmli, select_rec.sel_res_name,
                              select_rec.sel_res_tree );
                        dmli.d_global_pos_result := dmli.d_pos_result
                        END
                    ELSE
                        BEGIN
                        dmli.d_single     := true;
                        dmli.d_pos_result := cak_maxresulttables + 1;
                        dmli.d_keylen     := RESCNT_MXGG04;
                        IF  (dmli.d_distinct <> no_distinct)
                        THEN
                            BEGIN
                            dmli.d_keylen := dmli.d_keylen + HASHVAL_MXGG04;
                            END;
                        (*ENDIF*) 
                        dmli.d_inoutpos := cgg_rec_key_offset + 1 + dmli.d_keylen;
                        select_rec.sel_res_tree  := acv.a_into_tree;
                        a101_GetLogicalFilename (acv.a_transinf.tri_trans,
                              select_rec.sel_res_tree);
                        acv.a_curr_res_id := cak_into_res_fid
                        END;
                    (*ENDIF*) 
                    select_rec.sel_from_n := acv.a_ap_tree^[select_rec.sel_into_n ].n_sa_level;
                    (* h.b. PTS 1119078 *)
                    IF  hsConsistentLock_egg00 in dmli.d_globstate
                    THEN
                        BEGIN
                        dmli.d_globstate := dmli.d_globstate - [ hsConsistentLock_egg00 ];
                        IF  (hsPermLock_egg00 in dmli.d_globstate) OR
                            (hsTempLock_egg00 in dmli.d_globstate)
                        THEN
                            BEGIN
                            IF  NOT (hsIntentExcl_egg00 in dmli.d_globstate)
                            THEN
                                dmli.d_globstate := dmli.d_globstate
                                      + [ hsWithoutLock_egg00 ]
                            (*ENDIF*) 
                            END
                        ELSE
                            dmli.d_globstate := dmli.d_globstate
                                  + [ hsCollisionTest_egg00 ];
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    IF  hsConsistentLock_egg00 in dmli.d_globstate
                    THEN
                        BEGIN
                        dmli.d_globstate := dmli.d_globstate - [ hsConsistentLock_egg00 ];
                        IF  (hsPermLock_egg00 in dmli.d_globstate) OR
                            (hsTempLock_egg00 in dmli.d_globstate)
                        THEN
                            BEGIN
                            IF  NOT (hsIntentExcl_egg00 in dmli.d_globstate)
                            THEN
                                dmli.d_globstate := dmli.d_globstate
                                      + [ hsWithoutLock_egg00 ]
                            (*ENDIF*) 
                            END
                        ELSE
                            dmli.d_globstate := dmli.d_globstate
                                  + [ hsCollisionTest_egg00 ];
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    pseudo_resultset_select := false;
                    dmli.d_single           := false;
                    select_rec.sel_from_n   := select_rec.sel_into_n;
                    a663_make_res_buf( acv, dmli, select_rec.sel_res_name,
                          select_rec.sel_res_tree );
                    END
                (*ENDIF*) 
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  ( acv.a_union_cnt = 1 )
    THEN
        WITH acv.a_unionrec_ptr^.sunionrec DO
            BEGIN
            IF  NOT dmli.d_subquery
            THEN
                ures_name   := select_rec.sel_res_name;
            (*ENDIF*) 
            umodul_name := acv.a_modul_name;
            ures_tree   := select_rec.sel_res_tree
            END;
        (*ENDWITH*) 
&   IFDEF TRACE
    (*ENDIF*) 
    t01treeid (ak_sem, 'res_tree    ', select_rec.sel_res_tree);
    t01knl_identifier( ak_sem, 'sel_res_name', select_rec.sel_res_name );
    t01int4 (ak_sem, 'a_max_intern', acv.a_max_intern_select);
&   ENDIF
    select_rec.sel_res_b := acv.a_returncode;
    IF  ( acv.a_returncode = 0 )
    THEN
        BEGIN
        IF  ( acv.a_ap_tree^[ select_rec.sel_from_n ].n_proc = a66 )
        THEN
            BEGIN
            (* '<'  <table_list>  '>'  specified *)
&           ifdef TRACE
            t01name( ak_sem, 'ordered table sequ' );
&           endif
            dmli.d_standard := true;
            select_rec.sel_from_n := acv.a_ap_tree^[ select_rec.sel_from_n ].n_sa_level
            END
        ELSE
            dmli.d_standard := false;
        (*ENDIF*) 
        a660_from_part( acv, dmli, select_rec.sel_from_n );
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a660_from_part (
            VAR acv   : tak_all_command_glob;
            VAR dmli  : tak_dml_info;
            from_node : integer);
 
VAR
      _all              : boolean;
      _is_insert_select : boolean;
      _m_distinct       : tgg04_Distinct;
      _b_err            : tgg00_BasisError;
      _curr_n           : integer;
      _i                : integer;
      _next_n           : integer;
      _fs_n             : integer;
      _p                : tak_sysbufferaddress;
      _sysk             : tgg00_SysInfoKey;
 
BEGIN
&IFDEF TRACE
t01int4 (ak_sem, 'from_node=  ', from_node);
&ENDIF
WITH acv.a_ap_tree^[ from_node ] DO
    IF  ((n_proc = a66) AND
        (n_subproc = cak_x_select_in_from_part))
    THEN
        BEGIN
        acv.a_fromsel_n := from_node;
        _next_n      := from_node;
        END
    ELSE
        _next_n := acv.a_ap_tree^[ from_node ].n_lo_level;
    (*ENDIF*) 
(*ENDWITH*) 
_i              := _next_n;
_all            := false;
dmli.d_cntfromtab   := 0;
dmli.d_maxcounttabs := 0;
&IFDEF TRACE
t01int4 (ak_sem, 'next_n      ', _next_n);
&ENDIF
REPEAT
    dmli.d_cntfromtab := succ( dmli.d_cntfromtab );
    _i                 := acv.a_ap_tree^[ _i ].n_sa_level
UNTIL
    _i = 0;
(*ENDREPEAT*) 
&IFDEF TRACE
t01int4 (ak_sem, 'd_cntfromtab', dmli.d_cntfromtab);
&ENDIF
IF  dmli.d_cntfromtab > cak00_maxsources
THEN
    (* -d_cntfromtab is ok, see vak07 isunipos *)
    a07_b_put_error (acv, e_too_many_sourcetables, -dmli.d_cntfromtab)
ELSE
    BEGIN
    IF  ( dmli.d_cntfromtab > dmli.d_tabarr_capacity )
    THEN
        a54expand_tabarr_ex( acv, dmli, dmli.d_cntfromtab );
    (*ENDIF*) 
    IF  (((hsTempLock_egg00 in dmli.d_globstate) OR
        (hsPermLock_egg00 in dmli.d_globstate)) AND
        (acv.a_command_kind = single_command) AND
        (dmli.d_cntfromtab > 1) AND NOT dmli.d_view)
    THEN
        acv.a_returncode := cak_e_isolation_join;
    (*ENDIF*) 
    dmli.d_acttabindex            := 1;
    dmli.d_tabarr^[ 1 ].ocounttabs := 0;
    _m_distinct := dmli.d_distinct;
    IF  (dmli.d_view) AND (dmli.d_corr = no_correlation) AND
        (acv.a_returncode = 0)
    THEN
        BEGIN
        _sysk           := a01defaultkey;
        _sysk.stableid  := dmli.d_tableid;
        _sysk.sentrytyp := cak_etempviewtext;
        a10get_sysinfo (acv, _sysk, d_release, _p, _b_err);
        IF  _b_err = e_ok
        THEN
            BEGIN
            WITH _p^.sviewtext DO
                vtfromtabcnt := dmli.d_cntfromtab;
            (*ENDWITH*) 
            a10repl_sysinfo (acv, _p, _b_err)
            END;
        (*ENDIF*) 
        IF  _b_err <> e_ok
        THEN
            a07_b_put_error (acv, _b_err, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    WHILE ((dmli.d_acttabindex <= dmli.d_cntfromtab) AND
          (acv.a_returncode = 0)) DO
        BEGIN
        IF  dmli.d_acttabindex = dmli.d_cntfromtab
        THEN
            _all := true;
&       IFDEF TRACE
        (*ENDIF*) 
        t01int4 (ak_sem, 'acttabindex ', dmli.d_acttabindex);
        t01int4 (ak_sem, 'cntfromtab  ', dmli.d_cntfromtab);
&       ENDIF
        _curr_n := acv.a_ap_tree^[ _next_n ].n_lo_level;
        WITH dmli.d_tabarr^[ dmli.d_acttabindex ], acv.a_ap_tree^[ _next_n ] DO
            BEGIN
            otab_node := _next_n;  (* D.T. QueryRewrite *)
            IF  (n_proc = a66) AND
                (n_subproc  = cak_x_select_in_from_part)
            THEN
                BEGIN
                _fs_n := _next_n;
&               IFDEF TRACE
                t01int4 (ak_sem, 'curr_n      ', _curr_n);
                t01int4 (ak_sem, 'fs_n        ', _fs_n);
&               ENDIF
                a661get_from_select_table (acv, dmli,
                      acv.a_ap_tree^[ _fs_n ].n_pos, _all);
                IF  (acv.a_ap_tree^[ _curr_n ].n_sa_level <> 0) AND
                    (acv.a_returncode                  =  0) AND
                    (NOT acv.a_queryrewrite_modified)
                THEN
                    BEGIN
                    a05identifier_get (acv,
                          acv.a_ap_tree^[ _curr_n ].n_sa_level,
                          sizeof(oreference), oreference);
                    ospecialname := ospecialname + [ oisreference ];
                    _i := 1;
                    WHILE (acv.a_returncode = 0)     AND
                          (_i           < dmli.d_acttabindex) DO
                        BEGIN
                        IF  dmli.d_tabarr^[ _i ].oreference = oreference
                        THEN
                            a07_b_put_error (acv, e_duplicate_referencename, n_pos)
                        ELSE
                            IF  dmli.d_tabarr^[ _i ].otable = oreference
                            THEN
                                a07_b_put_error (acv, e_duplicate_tablename, n_pos);
                            (*ENDIF*) 
                        (*ENDIF*) 
                        _i := succ(_i)
                        END;
                    (*ENDWHILE*) 
                    END;
                (*ENDIF*) 
                ;
&               IFDEF TRACE
                t01int4 (ak_sem, 'returncode  ', acv.a_returncode);
&               ENDIF
                END
            ELSE
                a660_search_one_table( acv, dmli, _curr_n,
                      _all, c_check_teresult, no_lock, r_sel );
            (*ENDIF*) 
&           ifdef trace
            t01int4 (ak_sem, 'a_max_intern', acv.a_max_intern_select);
&           endif
            END;
        (*ENDWITH*) 
        _next_n := acv.a_ap_tree^[ _next_n ].n_sa_level;
        dmli.d_acttabindex  := succ(dmli.d_acttabindex)
        END;
    (*ENDWHILE*) 
    IF  ((dmli.d_cntfromtab > 1) AND
        (dmli.d_distinct <> no_distinct) AND (_m_distinct = no_distinct))
    THEN
        a07_b_put_error (acv, e_not_implemented, 1)
    ELSE
        IF  acv.a_intern_select_cnt = 0
        THEN
            _is_insert_select :=
                  (acv.a_ap_tree^[acv.a_ap_tree^[ 0 ].n_lo_level].n_proc = a56) AND
                  (acv.a_ap_tree^[acv.a_ap_tree^[ 0 ].n_lo_level].n_subproc =
                  cak_x_insert_select);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  dmli.d_union
    THEN
        dmli.d_distinct := _m_distinct;
    (*ENDIF*) 
    IF  (acv.a_returncode = 0) AND
        (dmli.d_maxcounttabs > cak00_maxsources)
    THEN
        (* -dmli.d_maxcounttabs is ok, see vak07 isunipos *)
        a07_b_put_error (acv, e_too_many_sourcetables,
              -dmli.d_maxcounttabs)
    ELSE
        IF  ((acv.a_returncode = 0) AND
            ((hsTempLock_egg00 in dmli.d_globstate) OR
            (hsPermLock_egg00 in dmli.d_globstate)) AND
            (acv.a_command_kind = single_command) AND
            (dmli.d_maxcounttabs > 1) AND NOT dmli.d_view )
        THEN
            acv.a_returncode := cak_e_isolation_join;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  acv.a_outer_join AND dmli.d_subquery
    THEN
        acv.a_outer_join := false;
    (*ENDIF*) 
    END;
(*ENDIF*) 
dmli.d_acttabindex := dmli.d_cntfromtab;
IF  acv.a_returncode = 0
THEN
    BEGIN
    _curr_n := 1;
    WHILE _curr_n < dmli.d_cntfromtab DO
        WITH dmli.d_tabarr^[ _curr_n ] DO
            BEGIN
            _next_n := _curr_n + 1;
            WHILE _next_n <= dmli.d_cntfromtab DO
                BEGIN
                IF  ((dmli.d_tabarr^[ _next_n ].otable = otable) AND
                    (oreference =
                    a01_il_b_identifier) AND
                    (dmli.d_tabarr^[ _next_n ].oreference =
                    a01_il_b_identifier))
                THEN
                    BEGIN
                    ospecs_needed                    := ons_with_username;
                    dmli.d_tabarr^[ _next_n ].ospecs_needed := ons_with_username
                    END;
                (*ENDIF*) 
                _next_n := succ(_next_n)
                END;
            (*ENDWHILE*) 
            _curr_n := succ(_curr_n)
            END
        (*ENDWITH*) 
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
IF  acv.a_max_intern_select > 0
THEN
    IF  acv.a_intern_select_cnt = 0
    THEN
        BEGIN
&       ifdef trace
        t01sname (ak_sem, 'set semcheck');
&       endif
        acv.a_info_output    := false;
        dmli.d_only_sem_check := true
        END;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a660_isolevel (
            VAR acv        : tak_all_command_glob;
            isolation_n    : tsp00_Int2;
            VAR lock_state : tgg00_HandlingSet);
 
VAR
      _isolevel : tsp00_Int2;
 
BEGIN
WITH acv.a_ap_tree^[ isolation_n ] DO
    BEGIN
    a05_unsigned_int2_get (acv, n_pos, n_length, e_invalid_unsign_integer, _isolevel);
    IF  (acv.a_iso_level = csp_maxint1)
        AND
        ((_isolevel <= 30) OR (g01ConsistentReadEnabled AND
        (_isolevel in [cak_iso_level_stmt_consistent, cak_iso_level_trans_consistent])))
    THEN
        acv.a_iso_level := _isolevel;
    (*ENDIF*) 
    CASE _isolevel OF
        9, 10, 15, 20, 30 :
            IF  acv.a_sqlmode <> sqlm_internal
            THEN
                a07_b_put_error (acv, e_invalid_unsign_integer, n_pos);
            (*ENDIF*) 
        0, 1, 2, 3 :
            _isolevel := _isolevel * 10;
        cak_iso_level_stmt_consistent, cak_iso_level_trans_consistent :
            IF  NOT g01ConsistentReadEnabled
            THEN
                a07_b_put_error (acv, e_invalid_unsign_integer, n_pos);
            (*ENDIF*) 
        OTHERWISE
            a07_b_put_error (acv, e_invalid_unsign_integer, n_pos)
        END;
    (*ENDCASE*) 
    IF  acv.a_returncode = 0
    THEN
        CASE _isolevel OF
            0 :
                lock_state := [ hsWithoutLock_egg00 ];
            9 :
                BEGIN
                lock_state := [ hsWithoutLock_egg00 ];
                acv.a_check_lock := true
                END;
            10 :
                lock_state := [ hsConsistentLock_egg00 ];
            15 :
                lock_state := [ hsConsistentLock_egg00,
                      hsTempLock_egg00 ];
            20 :
                lock_state := [ hsTempLock_egg00 ];
            30 :
                lock_state := [ hsPermLock_egg00 ];
            cak_iso_level_stmt_consistent :
                lock_state := [ hsWithoutLock_egg00 ];
            cak_iso_level_trans_consistent :
                acv.a_transinf.tri_trans.trConsistReadInfo_gg00 := CnsReadTransaction;
            END
        (*ENDCASE*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a660_lock (
            VAR acv        : tak_all_command_glob;
            lock_n         : integer;
            VAR lock_state : tgg00_HandlingSet);
 
VAR
      _curr_n          : integer;
      _init_lockstate  : tgg00_HandlingSet;
 
BEGIN (* PTS 1108174 *)
(* **************************************************************** *)
(* This procedure handles syntax nodes for lock option              *)
(* build by a60_await_option                                        *)
(* **************************************************************** *)
&IFDEF TRACE
t01int4 (ak_sem, 'lock_n      ', lock_n);
&ENDIF
_curr_n := lock_n;
IF  ((acv.a_ap_tree^[ lock_n ].n_proc = a51) AND
    (acv.a_ap_tree^[ lock_n ].n_subproc = cak_i_isolation))
THEN
    BEGIN
    _curr_n := acv.a_ap_tree^[ lock_n ].n_lo_level;
    a660_isolevel (acv, _curr_n, lock_state);
    _curr_n := acv.a_ap_tree^[ _curr_n ].n_lo_level;
    END;
(*ENDIF*) 
_init_lockstate := lock_state;
&ifdef trace
t01handling( ak_sem, 'init_locksta', lock_state );
&endif
IF  _curr_n > 0
THEN
    IF  ((acv.a_ap_tree^[ _curr_n ].n_proc = a60) AND
        (acv.a_ap_tree^[ _curr_n ].n_subproc = cak_x_lock_exclusive))
    THEN
        BEGIN
        lock_state := lock_state + [ hsIntentExcl_egg00 ];
        _curr_n := acv.a_ap_tree^[ _curr_n ].n_lo_level
        END
    ELSE
        IF  ((acv.a_ap_tree^[ _curr_n ].n_proc = a60) AND
            (acv.a_ap_tree^[ _curr_n ].n_subproc = cak_x_lock_optimistic))
        THEN
            BEGIN
            IF  ((lock_state <> [ hsTempLock_egg00 ]) AND
                ( lock_state <> [ hsPermLock_egg00 ]))
            THEN
                lock_state := lock_state + [ hsOptimisticLock_egg00 ];
            (*ENDIF*) 
            _curr_n := acv.a_ap_tree^[ _curr_n ].n_lo_level
            END
        ELSE
            IF  ((acv.a_ap_tree^[ _curr_n ].n_proc = a60) AND
                (acv.a_ap_tree^[ _curr_n ].n_subproc = cak_x_lock_share))
            THEN
                BEGIN
                lock_state := [  ];
                _curr_n := acv.a_ap_tree^[ _curr_n ].n_lo_level
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
IF  _curr_n > 0
THEN
    BEGIN
    IF  ((acv.a_ap_tree^[ _curr_n ].n_proc = a60) AND
        (acv.a_ap_tree^[ _curr_n ].n_subproc = cak_x_lock_nowait))
    THEN
        lock_state := lock_state + [ hsNoWait_egg00 ]
    ELSE
        IF  ((acv.a_ap_tree^[ _curr_n ].n_proc = a60) AND
            (acv.a_ap_tree^[ _curr_n ].n_subproc = cak_x_lock_ignore))
        THEN
            IF  (_init_lockstate = [ hsConsistentLock_egg00 ])
            THEN
                lock_state := lock_state + [hsIgnoreLock_egg00, hsNoWait_egg00]
            ELSE
                a07_b_put_error (acv, e_invalid_keyword,
                      acv.a_ap_tree^[ _curr_n ].n_pos);
            (*ENDIF*) 
&       ifdef trace
        (*ENDIF*) 
    (*ENDIF*) 
    t01handling( ak_sem, 'lock_state  ', lock_state );
&   endif
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a660_lowpars_pparsp (
            VAR acv        : tak_all_command_glob;
            VAR pparsp     : tak_sysbufferaddress;
            needs_twuseold : boolean;
            to_release     : boolean;
            lowpars        : tsp00_Uint1);
 
VAR
      _b_err  : tgg00_BasisError;
      _maxlen : integer;
      _ke     : tgg00_SysInfoKey;
 
BEGIN
IF  acv.a_pars_last_key.p_no >= lowpars
THEN
    a07_b_put_error (acv, e_too_many_subqueries, 1)
ELSE
    BEGIN
    IF  (to_release) AND (pparsp <> NIL)
    THEN
        BEGIN
        a10_rel_sysinfo (acv, pparsp^.syskey);
        END;
    (*ENDIF*) 
    _ke              := a01sysnullkey;
    _ke.sauthid[ 1 ] := cak_tempinfo_byte;
    SAPDB_PascalForcedMove (sizeof(acv.a_pars_last_key), sizeof(_ke.sauthid),
          @acv.a_pars_last_key, 1, @_ke.sauthid, 2, mxak_parskey);
    _ke.sauthid[ mxak_parskey + 1 ] := chr(lowpars);
    _ke.sentrytyp                   := cak_eparsinfo;
    _maxlen := sizeof(tak_parsinforecord) -
          sizeof (pparsp^.sparsinfo.p_pars_infos) +
          (acv.a_count_variab + cak_additional_parsinfos +
          2*acv.a_no_of_likes) * sizeof(tak_field_pars);
    IF  _maxlen > sizeof(tak_parsinforecord)
    THEN
        _maxlen := sizeof(tak_parsinforecord);
    (*ENDIF*) 
    a10_nil_get_sysinfo (acv, _ke, d_fix, _maxlen, pparsp, _b_err);
    IF  _b_err <> e_ok
    THEN
        a07_b_put_error (acv, _b_err,
              acv.a_cmd_part^.sp1p_buf_len)
    ELSE
        WITH pparsp^.sparsinfo DO
            BEGIN
            p_mtyp             := m_nil;
            p_mtyp2            := mm_nil;
            (* PTS 1117747 E.Z. *)
            p_select           := false;
            p_single           := false;
            p_pagecnt          := csp_maxint4;
            p_int_res_cnt      := acv.a_intern_select_cnt;
            p_p_no             := 0;
            p_subcntlevel      := - 1;
            p_cnt_infos        := 0;
            p_max_infos        :=
                  (_maxlen - (sizeof(tak_parsinforecord) -
                  sizeof (pparsp^.sparsinfo.p_pars_infos))) DIV
                  sizeof(tak_field_pars);
            p_bool_states      := [];
            p_sqlmode          := acv.a_sqlmode;
            p_own_trans        := false;
            p_searchname       := a01_il_b_identifier;
            p_modul_name       := acv.a_modul_name;
            p_statement_kind   := acv.a_statement_kind;
            p_function_code    := acv.a_return_segm^.sp1r_function_code;
            p_prepare          := acv.a_initial_segment_header.sp1c_prepare;
            p_session_isolevel := acv.a_iso_level;
            p_use_sess_isolevel:= false;
            p_longliteral      := false;
            (* sharedSQL couldn't change parseinfo at execution *)
            IF  acv.a_parsingForSharedSql
            THEN
                p_parsing_again    := false
            ELSE
                p_parsing_again    := acv.a_parsing_again;
            (*ENDIF*) 
            IF  needs_twuseold
            THEN
                BEGIN
                p_cnt_infos := 1;
                WITH p_pars_infos [ 1 ] DO
                    BEGIN
                    fp_kind    := fp_use_old_values_up_to_len;
                    fp_etype   := st_dummy;
                    fp_datatyp := dunknown;
                    fp_colset  := [  ];
                    fp_fill_71 := csp_maxint4;
                    fp_fill_72 := csp_maxint4;
                    fp_fill_73 := csp_maxint2;
                    (*
                          IF  acv.a_mblock.mb_qual^.mstrat_pos > 0
                          THEN
                          fp_len := acv.a_mblock.mb_st^
                          [ acv.a_mblock.mb_qual^.mstrat_pos ].epos - 1
                          ELSE
                          *)
                    fp_len := acv.a_mblock.mb_data_len;
                    END
                (*ENDWITH*) 
                END
            ELSE
                p_cnt_infos := 0
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a660_new_pparsp (
            VAR acv        : tak_all_command_glob;
            VAR sparr      : tak_syspointerarr;
            needs_twuseold : boolean;
            complicate     : boolean);
 
VAR
      _b_err : tgg00_BasisError;
      _ke    : tgg00_SysInfoKey;
      _maxlen: integer;
 
BEGIN
&ifdef trace
t01int4 (ak_sem, 'complicate  ', ord(complicate));
t01int4 (ak_sem, 'union_cnt   ', acv.a_union_cnt);
t01int4 (ak_sem, 'command_kind', ord(acv.a_command_kind));
&endif
IF  complicate
THEN
    BEGIN
    WITH acv.a_pars_last_key DO
        BEGIN
        IF  ord (p_id[ 1 ]) < cak00_maxsubqueries
        THEN
            p_id[ 1 ] := succ (p_id[ 1 ])
        ELSE
            a07_b_put_error (acv, e_too_many_subqueries, 1);
        (*ENDIF*) 
        p_no      := 0
        END;
    (*ENDWITH*) 
    a54set_complex_entry (acv, c_increment);
    END
ELSE
    IF  acv.a_pars_last_key.p_no + 1 > cak00_maxsubqueries
    THEN
        a07_b_put_error (acv, e_too_many_subqueries, 1)
    ELSE
        BEGIN
        WITH acv.a_pars_last_key DO
            p_no := p_no + 1;
        (*ENDWITH*) 
        IF  ( acv.a_command_kind in
            [ complex_view_command, subquery_command,
            sub_in_complex_command ] )
            (* AND
                  (acv.a_union_cnt = 0)
                  *)
        THEN
            a54set_complex_entry (acv, c_set_p_no);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    _ke              := a01sysnullkey;
    _ke.sauthid[ 1 ] := cak_tempinfo_byte;
    SAPDB_PascalForcedMove (sizeof(acv.a_pars_last_key), sizeof(_ke.sauthid),
          @acv.a_pars_last_key, 1, @_ke.sauthid, 2, mxak_parskey);
    _ke.sentrytyp := cak_eparsinfo;
    _maxlen := sizeof(tak_parsinforecord) -
          sizeof (sparr.pparsp^.sparsinfo.p_pars_infos) +
          (acv.a_count_variab + cak_additional_parsinfos +
          2*acv.a_no_of_likes) * sizeof(tak_field_pars);
    IF  _maxlen > sizeof(tak_parsinforecord)
    THEN
        _maxlen := sizeof(tak_parsinforecord);
    (*ENDIF*) 
    a10_nil_get_sysinfo (acv, _ke, d_fix, _maxlen,
          sparr.pparsp, _b_err);
    IF  _b_err <> e_ok
    THEN
        a07_b_put_error (acv, _b_err,
              acv.a_cmd_part^.sp1p_buf_len)
    ELSE
        WITH sparr.pparsp^.sparsinfo DO
            BEGIN
            p_mtyp             := m_nil;
            p_mtyp2            := mm_nil;
            p_treeid           := b01niltree_id;
            p_pagecnt          := csp_maxint4;
            p_int_res_cnt      := acv.a_intern_select_cnt;
            p_p_no             := 0;
            p_subcntlevel      := - 1;
            p_sqlmode          := acv.a_sqlmode;
            p_own_trans        := false;
            p_searchname       := a01_il_b_identifier;
            p_select           := false;
            p_single           := false;
            p_longliteral      := false;
            (* sharedSQL couldn't change parseinfo at execution *)
            IF  acv.a_parsingForSharedSql
            THEN
                p_parsing_again    := false
            ELSE
                p_parsing_again    := acv.a_parsing_again;
            (*ENDIF*) 
            p_modul_name       := acv.a_modul_name;
            p_statement_kind   := acv.a_statement_kind;
            p_filler1          := false;
            p_function_code    := acv.a_return_segm^.sp1r_function_code;
            p_prepare          := acv.a_initial_segment_header.sp1c_prepare;
            p_bool_states      := [];
            p_session_isolevel := acv.a_iso_level;
            p_use_sess_isolevel:= false;
            p_max_infos        :=
                  (_maxlen - (sizeof(tak_parsinforecord) -
                  sizeof (sparr.pparsp^.sparsinfo.p_pars_infos))) DIV
                  sizeof(tak_field_pars);
            IF  needs_twuseold
            THEN
                BEGIN
                p_cnt_infos := 1;
                WITH p_pars_infos [ 1 ] DO
                    BEGIN
                    fp_kind    := fp_use_old_values_up_to_len;
                    fp_etype   := st_dummy;
                    fp_datatyp := dunknown;
                    fp_colset  := [  ];
                    fp_fill_71 := csp_maxint4;
                    fp_fill_72 := csp_maxint4;
                    fp_fill_73 := csp_maxint2;
                    (*
                          IF  acv.a_mblock.mb_qual^.mstrat_pos > 0
                          THEN
                          fp_len     := acv.a_mblock.mb_st^
                          [acv.a_mblock.mb_qual^.mstrat_pos].epos-1
                          ELSE
                          *)
                    fp_len     := acv.a_mblock.mb_data_len;
                    END
                (*ENDWITH*) 
                END
            ELSE
                p_cnt_infos := 0
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a660_prefix_delete (
            VAR acv       : tak_all_command_glob;
            VAR parsk     : tak_parskey;
            VAR del_cnt   : integer;
            prefix_length : integer);
 
VAR
      _e            : tgg00_BasisError;
      _e1           : tgg00_BasisError;
      _set_result   : tgg00_BdSetResultRecord;
      _imap         : tsp_int_map_c2;
      _aux_return   : tsp00_Int2;
      _aux_errorpos : tsp00_Int4;
      _i            : integer;
      _pos          : integer;
      _tree_pos     : tgg00_FilePos;
      _curr_key     : tgg00_Lkey;
      _skey         : tgg00_SysInfoKey;
 
BEGIN
&IFDEF TRACE
t01int4 (ak_sem, 'prefix_len  ', prefix_length);
&ENDIF
_aux_return   := acv.a_returncode;
_aux_errorpos := acv.a_errorpos;
acv.a_returncode := 0;
del_cnt               := 0;
a10prefix_parsid_delete (acv, parsk, del_cnt, prefix_length);
_skey            := a01sysnullkey;
_e               := e_buffer_limit;
_curr_key.k[ 1 ] := cak_tempinfo_byte;
SAPDB_PascalMove ('VAK660',   5,    
      sizeof(parsk), sizeof(_curr_key.k), @parsk, 1,
      @_curr_key.k, 2, prefix_length, _e);
_curr_key.len := prefix_length + 1;
_pos := 0;
REPEAT
    _pos := succ(_pos);
UNTIL
    (_pos > sizeof(acv.a_shortinfo_key)) OR
    (_pos > succ(prefix_length)) OR
    (acv.a_shortinfo_key[_pos] <> _curr_key.k[_pos]);
(*ENDREPEAT*) 
IF  _pos > succ(prefix_length)
THEN
    acv.a_shortinfo_key := cgg_zero_id;
(*ENDIF*) 
WITH _set_result DO
    BEGIN
    bd_key_check_len := prefix_length + 1;
    bd_max_rec_cnt   := csp_maxint2;
    bd_max_fill_len  := acv.a_mblock.mb_data_size;
    bd_next          := true;
    END;
(*ENDWITH*) 
WHILE _e = e_buffer_limit DO
    BEGIN
    _tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
    b07cnext_record (acv.a_transinf.tri_trans, acv.a_pars_curr,
          _curr_key, _set_result, _tree_pos, acv.a_mblock.mb_data^.mbp_buf);
    IF  acv.a_transinf.tri_trans.trError_gg00 = e_key_not_found
    THEN
        _e := e_ok
    ELSE
        _e := acv.a_transinf.tri_trans.trError_gg00;
    (*ENDIF*) 
    IF  ((_e = e_ok) OR (_e = e_buffer_limit))
    THEN
        BEGIN
        _i   := 1;
        _pos := 1;
        _e1  := e_ok;
        _imap.map_int := 0;
        WHILE ((_e1 = e_ok) AND (_i <= _set_result.bd_rec_cnt)) DO
            BEGIN
            SAPDB_PascalMove ('VAK660',   6,    
                  acv.a_mblock.mb_data_size, sizeof(_skey),
                  @acv.a_mblock.mb_data^.mbp_buf, _pos + 2,
                  @_skey, 3, mxak_standard_sysk + cgg_rec_key_offset - 2, _e1);
            a10del_sysinfo (acv, _skey, _e1);
            del_cnt          := succ(del_cnt);
            _i                := succ(_i);
            _imap.map_c2[ 1 ] := acv.a_mblock.mb_data^.mbp_buf[ _pos ];
            _imap.map_c2[ 2 ] := acv.a_mblock.mb_data^.mbp_buf[ _pos + 1 ];
            _pos              := _pos + _imap.map_int;
            END;
        (*ENDWHILE*) 
        IF  _e1 <> e_ok
        THEN
            _e := _e1;
        (*ENDIF*) 
        IF  _i = _set_result.bd_rec_cnt + 1
        THEN
            BEGIN
            _pos := _pos - _imap.map_int;
            SAPDB_PascalMove ('VAK660',   7,    
                  acv.a_mblock.mb_data_size, sizeof(_curr_key.k),
                  @acv.a_mblock.mb_data^.mbp_buf, _pos + cgg_rec_key_offset,
                  @_curr_key.k, 1, mxak_standard_sysk, _e);
            _curr_key.len := mxak_standard_sysk
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  _e <> e_ok
THEN
    IF  (_e = e_no_next_record) OR
        (_e = e_buffer_limit)
    THEN
        _e := e_ok
    ELSE
        a07_b_put_error (acv, _e, 1);
    (*ENDIF*) 
(*ENDIF*) 
IF  (acv.a_returncode =  0) OR
    ((_aux_return       <> 0) AND
    ( _aux_return       <> 100)  )
THEN
    BEGIN
    acv.a_returncode := _aux_return;
    acv.a_errorpos   := _aux_errorpos;
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a660_query_execute (
            VAR acv                     : tak_all_command_glob;
            VAR dmli                    : tak_dml_info;
            s_n                         : integer;
            new_parsinfo                : boolean;
            filled_part2_bytes          : integer;
            VAR sr_rec                  : tak71_strat_rec;
            VAR pseudo_resultset_select : boolean;
            level                       : integer;
            no_in_level                 : integer;
            from_sel_found              : boolean);
 
VAR
      _is_updateable    : boolean;
      _old_atgroup      : boolean;
      _md_union         : boolean;
      _f_ok             : boolean;
      _set_change_found : boolean;
      _stamp_found      : boolean;
      _delete_resinfo   : boolean;
      _notgrouped_output: boolean;
      _b_err            : tgg00_BasisError;
      _bytes_to_fill    : integer;
      _fetch_only_n     : integer;
      _i                : integer;
      _next_n           : integer;
      _reuse_n          : integer;
      _resdel_n         : integer;
      _in_n             : integer;
      _id_n             : integer;
      _op_n             : integer;
      _exists_n         : integer;
      _update_n         : integer;
      _where_n          : integer;
      _aux_return       : tsp00_Int2;
      _aux_errorpos     : tsp00_Int4;
      _modul_name       : tsp00_KnlIdentifier;
      _p_arr            : tak_syspointerarr;
      _h_symb           : tak_sc_symbol;
      _select_rec       : tak_select_record;
      _sfe_rec          : t_store_for_endpart;
      _messagetype      : tgg00_MessType;
      _aux_fieldlists   : tgg00_FieldLists;
 
BEGIN
&IFDEF TRACE
t01execution_kind( ak_sem, 'init_ex_kind', acv.a_init_ex_kind );
t01execution_kind( ak_sem, 'ex_kind     ', acv.a_ex_kind );
t01int4 (ak_sem, 's_n         ', s_n);
&ENDIF
IF  ( NOT dmli.d_only_sem_check )
THEN
    BEGIN
    acv.a_cmd_id := succ( acv.a_cmd_id );
&   ifdef trace
    t01int4 (ak_sem, 'add cmd id  ', acv.a_cmd_id );
&   endif
    END;
(*ENDIF*) 
_select_rec.sel_is_not_corr_search := true;
_update_n      := -1;    (* to silence var-not-init warning *)
_is_updateable := false; (* to silence var-not-init warning *)
_stamp_found   := false; (* to silence var-not-init warning *)
FOR _i := 1 TO sizeof( _modul_name ) DO
    _modul_name[ _i ] := bsp_c1; (* is correct for _modul_name*)
(*ENDFOR*) 
;
_select_rec.sel_output_n     := s_n;
IF  acv.a_ap_tree^[ s_n ].n_sa_level <> 0
THEN
    (* useful only with UNION *)
    _select_rec.sel_has_subquery := true
ELSE
    _select_rec.sel_has_subquery := false;
(*ENDIF*) 
dmli.d_reuse          := false;
dmli.d_level[ level ] := no_in_level;
dmli.d_oldlowpars     := dmli.d_lowpars;
dmli.d_one_join_phase := false;
dmli.d_parameter_count:= 0;
_fetch_only_n     := 0;
_select_rec.sel_res_b        := 2; (* something <> 0 *)
_select_rec.sel_parinf_b     := 2; (* something <> 0 *)
(* PTS 1106167 E.Z. *)
_delete_resinfo   := false;
IF  (( dmli.d_subquery AND ( dmli.d_corr = no_correlation )) OR
    (acv.a_insert_select) AND ( acv.a_command_kind <> sub_in_union_command ))
    AND
    ( acv.a_command_kind <> union_in_sub_command )
    AND
    ( NOT acv.a_from_select )
THEN
    BEGIN
    _select_rec.sel_res_name := a01_zero_res_name;
    a06a_mblock_init (acv, m_nil, mm_nil, b01niltree_id);
    dmli.d_pos_result := cak_intern_pos;
    a663_get_result_info (acv, _select_rec.sel_res_name, _modul_name,
          acv.a_resname_addr[ dmli.d_pos_result ],
          c_make_new_res, ttfnInternResult_egg00, d_fix, _f_ok);
    (* PTS 1106167 E.Z. *)
    (*_delete_resinfo := _f_ok           AND
          (dmli.d_subquery                AND
          (dmli.d_corr = no_correlation));*)
    END;
(*ENDIF*) 
IF  (acv.a_ex_kind = only_parsing) AND new_parsinfo
THEN
    BEGIN
    IF  acv.a_insert_select
    THEN
        _messagetype := m_insert_select
    ELSE
        IF  acv.a_intern_explain
        THEN
            _messagetype := m_show
        ELSE
            _messagetype := m_select;
        (*ENDIF*) 
    (*ENDIF*) 
    a54_get_pparsp_pinfop( acv, dmli.d_sparr, _messagetype );
    _select_rec.sel_parinf_b := acv.a_returncode
    END;
(*ENDIF*) 
a660_first_sel_part( acv, dmli, _select_rec, pseudo_resultset_select );
;
IF  (( acv.a_first_hint_node <> csp_minint2 ) AND NOT dmli.d_only_sem_check )
THEN
    a80store_cmd_hint_info( acv, dmli, acv.a_select_node );
(*ENDIF*) 
IF  ( acv.a_returncode <> cak_e_isolation_join )
THEN
    BEGIN
    IF  ( dmli.d_corr <> no_correlation )
    THEN
        acv.a_from_select := false;
    (*ENDIF*) 
    dmli.d_optimize_setfunction := (dmli.d_distinct = no_distinct);
    IF  ( dmli.d_subquery )
    THEN
        BEGIN
        IF  (acv.a_command_kind <> union_in_sub_command) OR
            (acv.a_union_cnt = 0)
        THEN
            BEGIN
            (* PTS 1122921 E.Z. *)
            dmli.d_rowno  := cgg04_no_rowno_predicate;
            _op_n := a660pos_pred (acv, s_n);
            IF  (_op_n > 0) AND
                (acv.a_ap_tree^[_op_n].n_proc = a63) AND
                (acv.a_ap_tree^[_op_n].n_subproc = cak_x_one_val_subquery)
            THEN
                BEGIN
                dmli.d_cntpar := 1;
                dmli.d_rowno  := cgg04_subquery_one_record
                END
            ELSE
                BEGIN
                _in_n := a660same_pred (acv, s_n);
                _op_n := a660lower_pred (acv, s_n);
                IF  ((acv.a_ap_tree^[ _in_n ].n_proc = a63) AND
                    ( acv.a_ap_tree^[ _in_n ].n_subproc >= cak_x_start_union)AND
                    ( acv.a_ap_tree^[ _in_n ].n_subproc <= cak_x_intersect_all))
                    OR
                    ((acv.a_ap_tree^[ _op_n ].n_proc = a63) AND
                    ( acv.a_ap_tree^[ _op_n ].n_subproc >= cak_x_start_union)AND
                    ( acv.a_ap_tree^[ _op_n ].n_subproc <= cak_x_intersect_all))
                THEN
                    BEGIN
                    END
                ELSE
                    IF  acv.a_from_select
                    THEN
                        dmli.d_cntpar := MAX_COL_PER_TAB_GG00
                    ELSE      (* subqueries must return one column, except the  *)
                        BEGIN (* oracle style 'WHERE (a,b,...) IN (SELECT ...)' *)
                        (*   and except 'UPDATE..SET(x,y,...) = (SELECT...)'*)
                        _in_n     := a660same_pred (acv, s_n);
                        WITH acv.a_ap_tree^[ _in_n ] DO
                            IF  (n_proc = no_proc) AND (n_symb in [s_any, s_all])
                            THEN (* e.g. WHERE ... = ANY SELECT ... *)
                                _in_n := a660same_pred  (acv, _in_n);
&                           ifdef TRACE
                            (*ENDIF*) 
                        (*ENDWITH*) 
                        t01int4 (ak_sem, 's_n         ', s_n);
                        t01int4 (ak_sem, 'in_n        ', _in_n);
&                       endif
                        WITH acv.a_ap_tree^[ _in_n ] DO
                            BEGIN
                            IF  (n_proc = a56) AND (n_subproc = cak_x_value_list)
                            THEN (* e.g. (x,y) IN ((x,y), ...) *)
                                dmli.d_cntpar := n_length
                            ELSE
                                IF  (n_proc = a56) AND (n_subproc = cak_x_column_list)
                                THEN (* e.g. SET (x,y) = (SELECT ...) *)
                                    dmli.d_cntpar := n_length
                                ELSE
                                    dmli.d_cntpar := 1;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END
                        (*ENDWITH*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
&               ifdef TRACE
                t01int4 (ak_sem, 'd_cntpar    ', dmli.d_cntpar);
&               endif
                _id_n := a660same_pred  (acv, s_n);
                a660fsame_pred (acv, _id_n, _op_n, _i);
                _op_n := a660lower_pred (acv, _op_n);
                IF  (_id_n <> 0) AND (_op_n <> 0) AND
                    (NOT ((acv.a_ap_tree^[ _id_n ].n_proc = no_proc)
                    AND
                    (     (acv.a_ap_tree^[ _id_n ].n_symb = s_any) OR
                    (      acv.a_ap_tree^[ _id_n ].n_symb = s_all)))
                    AND
                    NOT ((acv.a_ap_tree^[ _op_n ].n_proc = a64) AND
                    (     acv.a_ap_tree^[ _op_n ].n_symb in [ s_in, s_notin ])))
                THEN
                    dmli.d_rowno  := cgg04_subquery_one_record  (* compare VKB72, VKB74 *)
                ELSE
                    BEGIN
                    _exists_n := a660lower_pred (acv, s_n);
                    IF  ((_exists_n <> 0) AND
                        (acv.a_ap_tree^[ _exists_n ].n_symb = s_exists))
                    THEN
                        BEGIN
                        dmli.d_rowno  := cgg04_at_least_one_record;
                        dmli.d_cntpar := acv.a_count_variab + MAX_COL_PER_TAB_GG00
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        dmli.d_reuse := true;
        END;
&   ifdef trace
    (*ENDIF*) 
    t01int4( ak_sem, 'd_cntpar    ', dmli.d_cntpar );
    t01bool( ak_sem, 'a_insert_sel', acv.a_insert_select );
    t01int4 (ak_sem, 'a_max_intern', acv.a_max_intern_select);
&   endif
    IF  ( pseudo_resultset_select )
    THEN
        dmli.d_rowno := cgg04_one_record_at_most_internal;
    (*ENDIF*) 
    IF  ( acv.a_returncode = 0 )
    THEN
        WITH dmli.d_tabarr^[ 1 ] DO
            BEGIN
            dmli.d_join := false;
            IF  ( dmli.d_maxcounttabs = 1 )
            THEN
                IF  oisshowview in ospecialname
                THEN
                    BEGIN
                    a06a_mblock_init( acv, m_show, mm_nil, b01niltree_id );
                    acv.a_mblock.mb_struct := mbs_stack_addr;
                    END
                ELSE
                    BEGIN
                    a06a_mblock_init( acv, m_select, mm_nil, otreeid );
                    END
                (*ENDIF*) 
            ELSE
                a06a_mblock_init( acv, m_select, mm_with_join, b01niltree_id );
            (*ENDIF*) 
            IF  (acv.a_insert_select AND
                (dmli.d_corr = no_correlation))
            THEN
                WITH acv.a_mblock, mb_data^ DO
                    BEGIN (* insert select *)
                    mb_data_len             := cgg_rec_key_offset +
                          2 + SURROGATE_MXGG00;
                    dmli.d_movebefore            := dmli.d_movebefore + 1;
                    mbp_info.rb_ins_sel_info := csp_defined_byte;
                    mbp_info.rb_into_temp    := false
                    END
                (*ENDWITH*) 
            ELSE
                BEGIN
&               ifdef trace
                t01int4( ak_sem, 'filled_part2', filled_part2_bytes );
&               endif
                acv.a_mblock.mb_data_len := filled_part2_bytes;
                IF  ( filled_part2_bytes > 0 )
                THEN
                    BEGIN
                    _bytes_to_fill := filled_part2_bytes - cgg_rec_key_offset;
                    IF  ( _bytes_to_fill > 0 )
                    THEN
                        SAPDB_PascalFill ('VAK660',   8,    
                              acv.a_mblock.mb_data_size,
                              @acv.a_mblock.mb_data^.mbp_buf,
                              filled_part2_bytes - _bytes_to_fill + 1,
                              _bytes_to_fill, csp_default_byte,
                              acv.a_returncode)
                              (* because of subqueries, z_parameter, vak71 *)
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  ((acv.a_returncode = 0) AND
        acv.a_info_output       AND
        (dmli.d_corr = no_correlation) AND
        NOT(dmli.d_only_sem_check))
    THEN
        a60_get_longinfobuffer( acv, dmli.d_sparr, MAX_COL_PER_TAB_GG00,
              acv.a_curr_res_id );
    (*ENDIF*) 
    IF  ( acv.a_returncode = 0 )
    THEN
        BEGIN
        IF  NOT ((acv.a_ex_kind = only_parsing) AND new_parsinfo)
        THEN
            _select_rec.sel_parinf_b := acv.a_returncode;
        (*ENDIF*) 
        IF  ( acv.a_sqlmode = sqlm_db2 )
        THEN
            BEGIN
            _fetch_only_n := _select_rec.sel_from_n;
            REPEAT
                _fetch_only_n := acv.a_ap_tree^[ _fetch_only_n ].n_sa_level
            UNTIL
                ((_fetch_only_n = 0) OR
                ((acv.a_ap_tree^[ _fetch_only_n ].n_proc = a63) AND
                ( acv.a_ap_tree^[ _fetch_only_n ].n_subproc  =
                cak_x_for_fetch_only)))
            (*ENDREPEAT*) 
            END;
        (*ENDIF*) 
        IF  ( NOT dmli.d_union )
        THEN
            BEGIN
            _select_rec.sel_limit_n := _select_rec.sel_from_n;
            REPEAT
                _select_rec.sel_limit_n := acv.a_ap_tree^[ _select_rec.sel_limit_n ].n_sa_level
            UNTIL
                ((_select_rec.sel_limit_n = 0) OR
                ((acv.a_ap_tree^[ _select_rec.sel_limit_n ].n_proc = a60) AND
                ( acv.a_ap_tree^[ _select_rec.sel_limit_n ].n_subproc  = cak_x_limit)))
            (*ENDREPEAT*) 
            END
        ELSE
            _select_rec.sel_limit_n := dmli.d_union_limit_n;
        (*ENDIF*) 
        IF  ( NOT dmli.d_union )
        THEN
            BEGIN
            _select_rec.sel_order_n := _select_rec.sel_from_n;
            REPEAT
                _select_rec.sel_order_n := acv.a_ap_tree^[ _select_rec.sel_order_n ].n_sa_level
            UNTIL
                ((_select_rec.sel_order_n = 0) OR
                ((acv.a_ap_tree^[ _select_rec.sel_order_n ].n_proc = a63) AND
                ( acv.a_ap_tree^[ _select_rec.sel_order_n ].n_subproc  = cak_x_order)))
            (*ENDREPEAT*) 
            END
        ELSE
            _select_rec.sel_order_n := dmli.d_union_order_n;
        (*ENDIF*) 
        dmli.d_use_order     := _select_rec.sel_order_n <> 0;
        dmli.d_order_cols.ocntord := 0;
        _select_rec.sel_group_n     := _select_rec.sel_from_n;
        REPEAT
            _select_rec.sel_group_n := acv.a_ap_tree^[ _select_rec.sel_group_n ].n_sa_level
        UNTIL
            ((_select_rec.sel_group_n = 0) OR
            ((acv.a_ap_tree^[ _select_rec.sel_group_n ].n_proc    = a63) AND
            ( acv.a_ap_tree^[ _select_rec.sel_group_n ].n_subproc = cak_x_group_by)));
        (*ENDREPEAT*) 
        dmli.d_group := false;
        dmli.d_group_cols.ocntord := 0;
        IF  (
            (NOT (
            (* SET-function *)
            ( acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_count)     OR
            (* SET-function with arithmetic *)
            ( acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_sum)) AND
            (acv.a_union_cnt > 0) AND
            (_select_rec.sel_group_n <> 0))
            OR
            (
            ((acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_count)     OR
            ( acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_sum)) AND
            (acv.a_union_cnt > 0) AND
            (_select_rec.sel_group_n = 0))
            )
        THEN
            BEGIN
            dmli.d_distinct := full_distinct;
            END;
        (*ENDIF*) 
        IF  _select_rec.sel_group_n <> 0
        THEN
            _select_rec.sel_having_n := _select_rec.sel_group_n
        ELSE
            _select_rec.sel_having_n := _select_rec.sel_from_n;
        (*ENDIF*) 
        REPEAT
            _select_rec.sel_having_n := acv.a_ap_tree^[ _select_rec.sel_having_n ].n_sa_level
        UNTIL
            ((_select_rec.sel_having_n = 0) OR
            ((acv.a_ap_tree^[ _select_rec.sel_having_n ].n_proc    = a63) AND
            ( acv.a_ap_tree^[ _select_rec.sel_having_n ].n_subproc = cak_x_having)));
        (*ENDREPEAT*) 
        IF  ((_select_rec.sel_group_n = 0) AND
            ( _select_rec.sel_having_n > 0))
        THEN
            IF  acv.a_ap_tree^[ _select_rec.sel_having_n ].n_symb = s_count
                (* SET-function in having *)
            THEN
                _select_rec.sel_group_n := _select_rec.sel_having_n;
            (*ENDIF*) 
        (*ENDIF*) 
        dmli.d_optimize_setfunction := dmli.d_optimize_setfunction         AND
              (acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb <> s_sum) AND
              (NOT dmli.d_union)                   AND
              (acv.a_union_cnt = 0)                AND
              (_select_rec.sel_having_n = 0)       AND
              NOT dmli.d_use_order                 AND
              NOT dmli.d_subquery;
        dmli.d_having := false;
        IF  ((dmli.d_single AND (acv.a_sqlmode <> sqlm_oracle))
            OR
            ((dmli.d_sparr.pbasep^.sbase.btablekind = tview) AND
            (acv.a_sqlmode <> sqlm_internal))
            OR
            (dmli.d_distinct <> no_distinct)
            OR
            dmli.d_subquery
            OR
            (* acv.a_from_select indicates that we are in a from select
                  not that we are working on a from select *)
            (dmli.d_sparr.pbasep^.sbase.btablekind = tresult)
            OR
            acv.a_insert_select
            OR
            dmli.d_union
            OR
            dmli.d_view
            OR
            (dmli.d_cntfromtab > 1)
            OR
            pseudo_resultset_select
            OR
            ((_select_rec.sel_order_n <> 0) AND (acv.a_sqlmode = sqlm_ansi))
            OR
            (_select_rec.sel_group_n <> 0)
            OR
            (_select_rec.sel_having_n <> 0)
            OR
            (_fetch_only_n <> 0)
            OR
            (oresfile in dmli.d_tabarr^[ 1 ].ospecialname)
            OR
            (oisshowview in dmli.d_tabarr^[ 1 ].ospecialname)
            OR
            dmli.d_tabarr^[ 1 ].ocomplex_view
            OR
            ((_select_rec.sel_res_name = a01_il_b_identifier) AND
            (acv.a_qualified_jv_upd = no_jv_upd) AND
            (acv.a_sqlmode <> sqlm_oracle)       AND
            NOT (((acv.a_comp_type = at_odbc) OR (acv.a_comp_type = at_jdbc)) AND
            (     acv.a_init_ex_kind = only_parsing)) )
            OR
            (acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_count)
            OR
            (acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_sum))
        THEN
            _is_updateable := false
        ELSE
            _is_updateable := true;
        (*ENDIF*) 
        _update_n := _select_rec.sel_from_n;
        REPEAT
            _update_n := acv.a_ap_tree^[ _update_n ].n_sa_level
        UNTIL
            ((_update_n = 0) OR
            ((acv.a_ap_tree^[ _update_n ].n_proc = a63) AND
            ( acv.a_ap_tree^[ _update_n ].n_subproc  = cak_x_for_update)));
        (*ENDREPEAT*) 
        END;
    (* PTS 1116837 E.Z. *)
    (*ENDIF*) 
    IF  ((acv.a_returncode = 0) AND (_update_n <> 0))
    THEN
        BEGIN
        IF  acv.a_qualified_jv_upd = no_jv_upd
        THEN
            dmli.d_globstate := dmli.d_globstate - [ hsWithoutLock_egg00,
                  hsConsistentLock_egg00, hsCollisionTest_egg00 ];
        (*ENDIF*) 
        IF  NOT _is_updateable
        THEN
            a07_b_put_error (acv, e_update_not_allowed, 1)
        ELSE
            IF  (acv.a_returncode = 0) AND
                (acv.a_ap_tree^[ _update_n ].n_lo_level <> 0)
            THEN
                ak660check_update_columns (acv, dmli,
                      acv.a_ap_tree^[ _update_n ].n_lo_level);
            (*ENDIF*) 
        (*ENDIF*) 
        IF  (acv.a_returncode = 0)
            AND
            (acv.a_cmd_segment_header.sp1c_producer <> sp1pr_kernel)
            AND
            (acv.a_cmd_segment_header.sp1c_producer <> sp1pr_view_optimizer)
            AND
            (acv.a_cmd_segment_header.sp1c_producer <> sp1pr_complex_view_handling)
        THEN
            ak660put_tablename (acv, dmli)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  ( acv.a_returncode = 0 )
    THEN
        BEGIN
        _reuse_n := _select_rec.sel_from_n;
        REPEAT
            _reuse_n := acv.a_ap_tree^[ _reuse_n ].n_sa_level
        UNTIL
            ((_reuse_n = 0) OR
            ((acv.a_ap_tree^[ _reuse_n ].n_proc    = a63) AND
            ( acv.a_ap_tree^[ _reuse_n ].n_subproc = cak_x_for_reuse)));
        (*ENDREPEAT*) 
        dmli.d_optimize_setfunction := dmli.d_optimize_setfunction AND
              (_reuse_n = 0);
        IF  ((dmli.d_maxcounttabs > 1) OR (_reuse_n <> 0))
        THEN
            dmli.d_reuse := true;
        (*ENDIF*) 
        _resdel_n := _select_rec.sel_from_n;
        REPEAT
            _resdel_n := acv.a_ap_tree^[ _resdel_n ].n_sa_level
        UNTIL
            ((_resdel_n = 0) OR
            ((acv.a_ap_tree^[ _resdel_n ].n_proc    = a63) AND
            ((acv.a_ap_tree^[ _resdel_n ].n_subproc = cak_x_res_delete) OR
            ( acv.a_ap_tree^[ _resdel_n ].n_subproc = cak_x_res_no_delete))));
        (*ENDREPEAT*) 
        IF  _resdel_n <> 0
        THEN
            IF  (acv.a_ap_tree^[ _resdel_n ].n_subproc = cak_x_res_no_delete)
            THEN
                acv.a_resname_addr[ dmli.d_pos_result ]^.sresname.
                      resdecresdel := dr_db2_with_hold;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  ((NOT new_parsinfo) OR pseudo_resultset_select)
        THEN (* subqueries and last select of a subquery - select *)
            dmli.d_reuse := true;
        (*ENDIF*) 
        IF  dmli.d_view AND
            ((_select_rec.sel_group_n <> 0) OR (_select_rec.sel_having_n <> 0) OR
            (dmli.d_distinct <> no_distinct))
            OR
            ((dmli.d_maxcounttabs > 1) AND
            (acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_sum))
        THEN
            dmli.d_phase_cnt := cak_complex_view_indicator;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  ( acv.a_returncode = 0 )
        AND
        ( NOT dmli.d_single )
        AND
        (( NOT dmli.d_subquery ) OR acv.a_from_select )
    THEN
        ak660keycolumn( acv, dmli );
    (*ENDIF*) 
    IF  ( acv.a_returncode = 0 )
    THEN
        ak660limit (acv, dmli, _select_rec);
    (* PTS 1116837 E.Z. *)
    (*ENDIF*) 
    IF  ((acv.a_returncode = 0) AND
        (_select_rec.sel_group_n <> 0))
    THEN
        BEGIN
        _md_union := dmli.d_union;
        dmli.d_union  := false;
        dmli.d_group  := true;
        dmli.d_order_or_group_cols := @dmli.d_group_cols;
        ak660order_by( acv, dmli, _select_rec.sel_group_n, _select_rec.sel_output_n );
        dmli.d_group := false;
        dmli.d_union := _md_union;
        END;
    (* PTS 1116837 E.Z. *)
    (*ENDIF*) 
    IF  ((acv.a_returncode = 0) AND dmli.d_use_order)
    THEN
        BEGIN
        dmli.d_order_or_group_cols := @dmli.d_order_cols;
        ak660order_by (acv, dmli, _select_rec.sel_order_n, _select_rec.sel_output_n);
        END;
    (*ENDIF*) 
    _h_symb := acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb;
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        IF  (acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_count)     OR
            (acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_sum)       OR
            (_select_rec.sel_group_n <> 0)
        THEN
            BEGIN
&           ifdef trace
            t01sname (ak_sem, 'set d_group ');
&           endif
            dmli.d_reuse := true;
            dmli.d_group := true
            END;
        (*ENDIF*) 
        ;
&       IFDEF TRACE
        t01bool (ak_sem, 'd_GROUp     ', dmli.d_group);
&       ENDIF
        IF  (acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_count)     OR
            (acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_sum)
        THEN
            acv.a_mblock.mb_type2 := mm_with_functions;
        (*ENDIF*) 
        a61_check_val_params (acv, dmli,
              _select_rec.sel_output_n, _select_rec.sel_into_n);
        (* check result_len for all non-fetch-strategies *)
        IF  ((dmli.d_inoutpos > MAX_RECLEN_GG00+1) AND
            (acv.a_mblock.mb_st^ [acv.a_mblock.mb_qual^.mfirst_free-1].etype <> st_output_catalog))
            AND
            (
            (dmli.d_distinct <> no_distinct)
            OR
            dmli.d_subquery
            OR
            (dmli.d_sparr.pbasep^.sbase.btablekind = tresult)
            OR
            acv.a_insert_select
            OR
            dmli.d_union
            OR
            dmli.d_view
            OR
            (dmli.d_cntfromtab > 1)
            OR
            pseudo_resultset_select
            OR
            ((_select_rec.sel_order_n <> 0) AND (acv.a_sqlmode = sqlm_ansi))
            OR
            (_select_rec.sel_group_n <> 0)
            OR
            (_select_rec.sel_having_n <> 0)
            OR
            (oresfile in dmli.d_tabarr^[ 1 ].ospecialname)
            OR
            (oisshowview in dmli.d_tabarr^[ 1 ].ospecialname)
            OR
            dmli.d_tabarr^[ 1 ].ocomplex_view
            )
        THEN
            a07_b_put_error (acv,
                  e_output_columns_too_long, dmli.d_vppos);
        (*ENDIF*) 
        IF  acv.a_mblock.mb_type2 = mm_with_functions
        THEN
            _is_updateable := false;
        (*ENDIF*) 
        IF  _update_n <> 0
        THEN
            BEGIN
            IF  NOT _is_updateable
            THEN
                a07_b_put_error (acv, e_update_not_allowed, 1)
            (*ENDIF*) 
            END
        ELSE
            IF  _is_updateable AND (acv.a_is_ddl <> ddl_create_as_select)
            THEN
                BEGIN
                IF  (acv.a_sqlmode = sqlm_ansi)
                    OR
                    (acv.a_sqlmode = sqlm_db2)
                THEN
                    BEGIN
                    CASE acv.a_precomp_info_byte OF
                        csp1_p_mass_select_found :
                            acv.a_precomp_info_byte := csp1_p_select_for_update_found;
                        csp1_p_mselect_found :
                            acv.a_precomp_info_byte := csp1_p_for_upd_mselect_found;
                        csp1_p_reuse_mass_select_found :
                            acv.a_precomp_info_byte := csp1_p_reuse_update_sel_found;
                        csp1_p_reuse_mselect_found :
                            acv.a_precomp_info_byte := csp1_p_reuse_upd_mselect_found;
                        OTHERWISE
                            BEGIN
                            END
                        END;
                    (*ENDCASE*) 
                    _update_n := 1;
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        _stamp_found := false;
        IF  ((acv.a_returncode = 0) AND
            acv.a_insert_select)
        THEN
            WITH acv.a_mblock, mb_qual^ DO
                FOR _i := mqual_pos TO mfirst_free - 1 DO
                    IF  ((mb_st^ [_i].etype = st_op) AND
                        ( mb_st^ [_i].eop = op_stamp))
                    THEN
                        _stamp_found := true;
                    (*ENDIF*) 
                (*ENDFOR*) 
            (*ENDWITH*) 
        (*ENDIF*) 
        sr_rec.sr_use_rowno := NOT acv.a_rowno_allowed;
        dmli.d_reclen       := dmli.d_inoutpos - 1;
        IF  _select_rec.sel_group_n = 0
        THEN
            dmli.d_group := false
        ELSE
            IF  sr_rec.sr_use_rowno
            THEN
                acv.a_mblock.mb_type2 := mm_with_functions;
&           IFDEF TRACE
            (*ENDIF*) 
        (*ENDIF*) 
        t01bool (ak_sem, 'd_GROUp     ', dmli.d_group);
        t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
        t01int4 (ak_sem, 'd_inoutpos  ', dmli.d_inoutpos);
&       ENDIF
        END;
    (*ENDIF*) 
    IF  (acv.a_main_returncode <> 0) AND
        (acv.a_returncode = 0)
    THEN
        BEGIN
        acv.a_returncode := acv.a_main_returncode;
        acv.a_errorpos   := acv.a_main_errorpos;
        END;
    (*ENDIF*) 
    dmli.d_joins.jrc_cnt := 0;
    IF  ((acv.a_returncode = 0) AND (_update_n <> 0))
    THEN
        a61_update_column (acv, dmli, _i, _select_rec.sel_output_n);
    (* _set_change_found = true, if set_function for date, time *)
    (* or timestamp found and format has to be changed because *)
    (* of date_time_format <> internal. Two_phase must be used *)
    (* otherwise, MAX(DATE) in format EUR will result in murks *)
    (*ENDIF*) 
    _set_change_found := false;
    (* PTS 1116837 E.Z. *)
    IF  ((acv.a_returncode = 0) AND
        (acv.a_mblock.mb_type2 = mm_with_functions))
    THEN
        WITH acv.a_mblock, mb_qual^ DO
            BEGIN
            _i := mqual_pos;
            WHILE _i < mqual_pos + mqual_cnt - 1 DO
                IF  ((mb_st^ [_i].etype          = st_func) AND
                    ( mb_st^ [_i+1].etype        = st_build_in_func) AND
                    ( mb_st^ [_i+1].eop_build_in = op_b_format_change))
                THEN
                    BEGIN
                    _set_change_found := true;
                    _i := mqual_pos + mqual_cnt
                    END
                ELSE
                    _i := succ(_i);
                (*ENDIF*) 
            (*ENDWHILE*) 
            END;
        (*ENDWITH*) 
    (* PTS 1116837 E.Z. *)
    (*ENDIF*) 
    IF  ( acv.a_returncode = 0 )                                        AND
        ( dmli.d_use_order OR dmli.d_subquery )                         AND
        ( dmli.d_distinct = no_distinct )                               AND
        ( dmli.d_maxcounttabs = 1 )                                     AND
        ( _select_rec.sel_group_n = 0 )                                 AND
        ( _select_rec.sel_having_n = 0 )                                AND
        ( NOT _set_change_found )                                       AND
        (* SET FUNCTION *)
        ( acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_count ) AND
        NOT (( dmli.d_corr in [ first_correlation, correlation ] ))
    THEN
        ak660later_output(acv);
    (*ENDIF*) 
    _select_rec.sel_where_done := false;
    _select_rec.sel_view_done  := false;
    acv.a_outer_join   := false; (* set by a65_search_cond *)
&   IFDEF TRACE
    t01int4 (ak_sem, 'sel_from_n  ', _select_rec.sel_from_n);
&   ENDIF
    IF  ( acv.a_returncode = 0 )
    THEN
        BEGIN
        _notgrouped_output := false;
        IF  _select_rec.sel_group_n <> 0
        THEN
            WITH dmli.d_group_cols DO
                FOR _i := 1 TO ocntord DO
                    WITH ofield[ _i ] DO
                        IF  ofstno = 0
                        THEN
                            _notgrouped_output := true;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (*ENDFOR*) 
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  (
            (* SET-function with arithmetic *)
            (acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_sum)
            OR
            (acv.a_ap_tree^[ _select_rec.sel_order_n  ].n_symb = s_sum)
            OR
            (acv.a_ap_tree^[ _select_rec.sel_order_n  ].n_symb = s_count)
            OR
            (* SET-function on distinct column values ? *)
            ((dmli.d_distinct <> no_distinct) AND
            (acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_count))
            OR
            ((dmli.d_distinct <> no_distinct) AND _notgrouped_output)
            OR
            (* HAVING clause *)
            (_select_rec.sel_having_n <> 0)
            OR
            (
            (dmli.d_use_order OR dmli.d_subquery)                         AND
            (acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_count) AND
            ((dmli.d_corr in [ first_correlation, correlation ]) OR
            ( _select_rec.sel_group_n <> 0)    OR
            ( acv.a_union_cnt > 0)             OR
            ( _set_change_found)               OR
            ( dmli.d_maxcounttabs > 1))
            )
            OR
            ((acv.a_union_cnt > 0) AND
            ( _select_rec.sel_group_n <> 0))
            )
            AND
            ((acv.a_command_kind <> union_in_sub_command) OR
            (NOT dmli.d_only_sem_check))
        THEN
            BEGIN
            IF  ((acv.a_union_cnt > 0) AND ( _select_rec.sel_group_n <> 0))
            THEN
                sr_rec.sr_distinct_bytes := false;
            (* for Queries like :             *)
            (* SELECT 'a' FROM t HAVING 0 = 0 *)
            (* (one of those SAGSIS-errors)   *)
            (*ENDIF*) 
            IF  ((_select_rec.sel_having_n <> 0) AND
                ( _select_rec.sel_group_n  =  0) AND
                (acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb <> s_sum) AND
                (acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb <> s_count))
            THEN
                dmli.d_rowno := cgg04_at_least_one_record;
            (*ENDIF*) 
            _aux_fieldlists := acv.a_mblock.mb_fieldlists;
            ak660three_phase (acv, dmli, _select_rec, sr_rec);
&           ifdef trace
            t01int4 (ak_sem, 'a_fromsel_n ', acv.a_fromsel_n);
&           endif
            IF  (NOT dmli.d_subquery AND (NOT dmli.d_single ) AND
                ((acv.a_intern_select_cnt = acv.a_max_intern_select) OR
                (acv.a_fromsel_n > 0)) AND ( dmli.d_esparr.pbasep <> NIL ))
            THEN
                a67_bextcolindex( dmli.d_esparr, dmli.d_outcolno );
            (*ENDIF*) 
            ;
            (*
                  a06drop_fieldlist_references (_aux_fieldlists);
                  *)
            END
        ELSE
            BEGIN
            _where_n := acv.a_ap_tree^[ _select_rec.sel_from_n ].n_sa_level;
&           ifdef trace
            t01int4 (ak_sem, '_where_n    ', _where_n);
&           endif
            IF  ((dmli.d_maxcounttabs > 1) AND (acv.a_returncode = 0) AND
                (acv.a_ap_tree^[ _where_n ].n_proc = a63) AND
                (acv.a_ap_tree^[ _where_n ].n_subproc = cak_x_search_condition))
            THEN
                (* WHERE condition with join *)
                BEGIN
                _old_atgroup := dmli.d_group;
                dmli.d_group     := false;
                dmli.d_join      := true;
                _next_n      := acv.a_ap_tree^[ _where_n ].n_lo_level;
                IF  (acv.a_ex_kind = only_parsing)
                THEN
                    a54_fixedpos (acv, dmli);
                (*ENDIF*) 
                a65_search_condition (acv, dmli, _next_n);
                IF  (dmli.d_outer_join AND
                    (acv.a_allow_functions = tf_func))
                THEN
                    (* outer join with functions    *)
                    (* for columns in select_list   *)
                    (* therefore functions must be  *)
                    (* processed after outer join   *)
                    (* one phase or two/three phase *)
                    BEGIN
                    dmli.d_arith_where := true;
&                   ifdef trace
                    t01sname (ak_sem, 'set d_arith_');
&                   endif
                    END;
                (*ENDIF*) 
                dmli.d_join         := false;
                dmli.d_group        := _old_atgroup;
                _select_rec.sel_where_done := true
                END;
            (*ENDIF*) 
            IF  ((dmli.d_maxcounttabs > dmli.d_cntfromtab) AND
                (acv.a_returncode = 0))
            THEN
                BEGIN
                a67_put_all_views_into (acv, dmli);
                _select_rec.sel_view_done := true
                END;
            (* PTS 1113318 E.Z. *)
            (*ENDIF*) 
            _sfe_rec.messbuf_stored := false;
&           ifdef TRACE
            t01int4 (ak_sem, 'd_maxtcount ', dmli.d_maxcounttabs);
            t01bool (ak_sem, 'sel_view_don', _select_rec.sel_view_done);
            t01int4 (ak_sem, 'd_phase_cnt ', dmli.d_phase_cnt);
            t01bool (ak_sem, 'mb_type2=fkt', acv.a_mblock.mb_type2 = mm_with_functions);
            t01bool (ak_sem, 'stamp_found ', _stamp_found);
            t01bool (ak_sem, '= s_count   ',
                  acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_count);
            t01corr_type (ak_sem, 'd_corr      ',  dmli.d_corr);
            t01bool (ak_sem, 'd_arith_wher', dmli.d_arith_where);
&           endif
            IF  (
                (( dmli.d_maxcounttabs > 1 ) AND
                (( _select_rec.sel_view_done AND ( dmli.d_phase_cnt > 1 ))
                OR ( acv.a_mblock.mb_type2 = mm_with_functions)
                OR dmli.d_arith_where
                OR _stamp_found
                OR ( acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_count )
                ))
                OR
                (
                (dmli.d_maxcounttabs = 1)                      AND
                (acv.a_mblock.mb_type2 = mm_with_functions)    AND
                (dmli.d_corr in [ first_correlation, correlation ])
                )
                )
            THEN
                BEGIN
                IF  (dmli.d_view) AND (dmli.d_phase_cnt <= 2)
                THEN
                    BEGIN
                    IF  ((dmli.d_maxcounttabs <= dmli.d_cntfromtab) AND
                        (acv.a_returncode = 0))
                    THEN
                        BEGIN
                        a67_put_all_views_into (acv, dmli);
                        _select_rec.sel_view_done := true
                        END;
                    (*ENDIF*) 
                    dmli.d_phase_cnt := 2;
                    END
                ELSE
                    BEGIN
                    IF  ( NOT dmli.d_union )
                        AND
                        (( from_sel_found AND
                        ( dmli.d_corr = no_correlation )) OR
                        ( NOT from_sel_found ))
                        AND
                        ( acv.a_intern_select_cnt = acv.a_max_intern_select )
                        AND
                        ( NOT acv.a_insert_select )
                    THEN
                        _select_rec.sel_last_pars_part := true;
                    (* PTS 1113318 E.Z. *)
                    (*ENDIF*) 
                    dmli.d_join := true;
                    (* no GROUP BY and no correlation *)
                    dmli.d_one_join_phase := g01one_join_phase AND
                          ( dmli.d_corr = no_correlation );
&                   ifdef TRACE
                    t01int4 (ak_sem, 'd_inoutpos a', dmli.d_inoutpos);
                    t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
                    t01bool (ak_sem, 'd_use_order ', dmli.d_use_order);
&                   endif
                    IF  (( acv.a_returncode = 0 )
                        AND
                        (* NOT (d_group AND (d_maxcounttabs = 1) AND *)
                        (* having_part) AND --> always true          *)
                        (
                        ( dmli.d_group AND (dmli.d_group_cols.ocntord > 0 ))
                        OR (( _select_rec.sel_view_done OR
                        ( acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb = s_sum )
                        ) AND dmli.d_use_order )
                        OR ( dmli.d_use_order )))
                    THEN
                        a67_update_atinoutpos (acv, dmli, NOT (NOT c_having_part), _select_rec.sel_output_n);
                    (*ENDIF*) 
                    ;
&                   ifdef TRACE
                    t01int4 (ak_sem, 'd_inoutpos b', dmli.d_inoutpos);
                    t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
&                   endif
                    IF  ( acv.a_returncode = 0 )
                    THEN
                        ak660phase_division (acv, dmli, _select_rec,
                              sr_rec, _sfe_rec);
                    (*ENDIF*) 
                    IF  ( dmli.d_one_join_phase )
                    THEN
                        BEGIN
                        ak660one_phase( acv, dmli, _select_rec,
                              sr_rec, _sfe_rec );
                        END
                    ELSE
                        BEGIN
                        ak660two_phase( acv, dmli, _select_rec, sr_rec,
                              _sfe_rec, c_store_infos );
                        END;
                    (*ENDIF*) 
                    (* PTS 1113318 E.Z. *)
                    ;
                    IF  ( acv.a_intern_explain AND NOT acv.a_parsing_again )
                    THEN
                        dmli.d_single := false;
&                   ifdef TRACE
                    (*ENDIF*) 
                    t01int4 (ak_sem, 'd_inoutpos f', dmli.d_inoutpos);
                    t01int4 (ak_sem, 'd_reclen    ', dmli.d_reclen);
                    t01bool (ak_sem, 'd_single 660', dmli.d_single);
                    t01bool (ak_sem, 'd_only_sem_c', dmli.d_only_sem_check);
&                   endif
                    IF  NOT (dmli.d_only_sem_check)
                        AND
                        ( acv.a_union_cnt <= 1)
                    THEN
                        a67_sel3_second_part (acv, dmli, _select_rec, sr_rec)
                    ELSE
                        BEGIN
                        IF  (NOT dmli.d_subquery) AND ( NOT dmli.d_single ) AND
                            ( acv.a_intern_select_cnt = acv.a_max_intern_select )
                        THEN
                            BEGIN
                            a67_bextcolindex( dmli.d_esparr, dmli.d_outcolno );
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                (* only atgroup *)
                IF  (acv.a_rowno_allowed AND
                    (NOT (acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb in
                    [ s_count, s_sum ])) AND
                    (_select_rec.sel_group_n <> 0))
                THEN
                    _select_rec.sel_new_atdistinct := full_distinct
                ELSE
                    _select_rec.sel_new_atdistinct := no_distinct;
                (*ENDIF*) 
                IF  NOT dmli.d_subquery
                THEN
                    BEGIN
                    IF  NOT ((dmli.d_distinct <> no_distinct) OR
                        dmli.d_use_order OR
                        (_select_rec.sel_new_atdistinct <> no_distinct) OR
                        (dmli.d_maxcounttabs > 1) OR
                        (acv.a_mblock.mb_type2 = mm_with_functions))
                    THEN
                        sr_rec.sr_use_rowno := false;
                    (*ENDIF*) 
                    IF  (NOT dmli.d_union)                 AND
                        ((from_sel_found     AND
                        (dmli.d_corr = no_correlation)   ) OR
                        (NOT from_sel_found))         AND
                        (acv.a_intern_select_cnt = acv.a_max_intern_select) AND
                        (NOT acv.a_insert_select)
                    THEN
                        _select_rec.sel_last_pars_part := true
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                a67_s_sel_second_part (acv, dmli, _select_rec, sr_rec)
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        a67_sel3_second_part (acv, dmli, _select_rec,
              sr_rec);
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        IF  NOT(acv.a_insert_select AND
            (NOT dmli.d_subquery) AND
            (NOT acv.a_from_select))
        THEN
            BEGIN
&           ifdef TRACE
            t01int4 (ak_sem, 'I hate it : ', 1);
            t01bool (ak_sem, 'a_insert_sel', acv.a_insert_select);
            t01int4 (ak_sem, 'a_intern_sel', acv.a_intern_select_cnt);
            t01int4 (ak_sem, 'a_max_intern', acv.a_max_intern_select);
            t01int4 (ak_sem, 'a_union_cnt ', acv.a_union_cnt);
            t01bool (ak_sem, 'd_subquery  ', dmli.d_subquery);
            t01bool (ak_sem, 'a_from_selec', acv.a_from_select);
&           endif
            (* INSERT..SELECT needs d_sparr as it is *)
            a10rel_sysinfo (dmli.d_sparr.pbasep)
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    acv.a_ap_tree^[ _select_rec.sel_output_n ].n_symb := _h_symb
    END;
(* PTS 1106167 E.Z. *)
(*ENDIF*) 
IF  _delete_resinfo
THEN
    BEGIN
    _aux_return   := acv.a_returncode;
    _aux_errorpos := acv.a_errorpos;
    acv.a_returncode := 0;
    a10del_sysinfo (acv, acv.a_resname_addr[ dmli.d_pos_result ]^.syskey, _b_err);
    acv.a_returncode := _aux_return;
    acv.a_errorpos   := _aux_errorpos;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a660_search_one_table (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            table_node     : integer;
            all            : boolean;
            check_teresult : boolean;
            lock_spec      : tak_lockenum;
            wanted_priv    : tak00_PrivR);
 
VAR
      _complicated_view : boolean;
      _f_ok             : boolean;
      _found            : boolean;
      _syn_found        : boolean;
      _withoutSchema    : boolean;
      _ddl              : tak_ddl_descriptor;
      _dst              : tak_directory_state;
      _b_err            : tgg00_BasisError;
      _i                : integer;
      _ix               : integer;
      _kw_index         : integer;
      _next_n           : integer;
      _p                : tak_sysbufferaddress;
      _synid            : tgg00_Surrogate;
      _catalogSchemaId  : tgg00_Surrogate;
      _err_msg          : tsp00_C24;
      _privs            : tak_privilege;
      _sysk             : tgg00_SysInfoKey;
      _needed_privs     : tak00_PrivilegeSet;
      _schema           : tgg00_Surrogate;
 
BEGIN
_withoutSchema := false;
IF  ( dmli.d_acttabindex > dmli.d_tabarr_capacity )
THEN
    a54expand_tabarr( acv, dmli );
&ifdef trace
(*ENDIF*) 
t01int4 (ak_sem, 'd_acttabinde', dmli.d_acttabindex );
&endif
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    WITH dmli.d_tabarr^[ dmli.d_acttabindex ] DO
        BEGIN
        _syn_found        := false;
        ouser            := a01_il_b_identifier;
        otable           := a01_il_b_identifier;
        ospecialname     := [  ];
        (*  otreeid      :=   *)
        (*  ofromtableid :=   *)
        oattributes      := [  ];
        oprivset         := [  ];
        osetallpriv      := [  ];
        oall_priv        := false;
        ospecs_needed    := ons_with_username;
        oview            := false;
        ocomplex_view    := false;
        oviewqual        := false;
        oviewcheck       := false;
        oreference       := a01_il_b_identifier;
        _complicated_view := false;
        (*        otab_node        := table_node; *)
        (* D.T. QueryRewrite *)
        IF  dmli.d_acttabindex = 1
        THEN
            ocounttabs := 0;
        (*ENDIF*) 
        dmli.d_upd_set := [  ];
&       IFDEF TRACE
        t01int4 (ak_sem, 'table_node  ', table_node);
&       ENDIF
        WITH acv.a_ap_tree^[ table_node ] DO
            BEGIN
            dmli.d_n_pos := n_pos;
            IF  n_symb = s_authid
            THEN
                BEGIN
                _next_n     := table_node;      (* remember table_node *)
                a06get_username (acv, table_node, ouser);
                IF  dmli.d_view OR
                    (acv.a_proc_compile <> pct_none)
                THEN
                    a101_MapSchemaName (acv, ouser, dmli.d_n_pos);
                (*ENDIF*) 
                table_node := _next_n;          (* reset table_node    *)
                _next_n     := acv.a_ap_tree^[ table_node ].n_sa_level
                END
            ELSE
                BEGIN
                _withoutSchema   := true;
                _next_n          := table_node;
                END
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        a05identifier_get (acv, _next_n, sizeof (otable), otable);
        WITH acv.a_ap_tree^[ _next_n ] DO
            BEGIN
            IF  ((n_sa_level <> 0) AND (lock_spec = no_lock))
            THEN
                BEGIN
                _next_n := n_sa_level;
                a05identifier_get (acv, _next_n,
                      sizeof (oreference), oreference);
                ospecialname := ospecialname + [ oisreference ];
                IF  (NOT acv.a_queryrewrite_modified)
                THEN
                    BEGIN
                    _i := 1;
                    WHILE _i < dmli.d_acttabindex DO
                        BEGIN
                        IF  dmli.d_tabarr^[ _i ].oreference = oreference
                        THEN
                            a07_b_put_error (acv, e_duplicate_referencename, n_pos)
                        ELSE
                            (* PTS 1129653 E.Z. *)
                            IF  (dmli.d_tabarr^[ _i ].otable = oreference) AND
                                NOT (oisreference in dmli.d_tabarr^[ _i ].ospecialname)
                            THEN
                                a07_b_put_error (acv, e_duplicate_tablename, n_pos);
                            (*ENDIF*) 
                        (*ENDIF*) 
                        _i := succ(_i);
                        END;
                    (*ENDWHILE*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
&       IFDEF TRACE
        t01knl_identifier (ak_sem, 'user        ', ouser);
        t01knl_identifier (ak_sem, 'table       ', otable);
        t01knl_identifier (ak_sem, 'reference   ', oreference);
&       ENDIF
        IF  (dmli.d_pos_result = cak_extern_pos) OR
            (dmli.d_pos_result = cak_intern_pos)
        THEN
            _f_ok := acv.a_resname_addr[ dmli.d_pos_result ]^.sresname.
                  reskey_name <> otable
        ELSE
            _f_ok := true;
        (*ENDIF*) 
        _found := false;
        IF  (
            (wanted_priv = r_sel) AND
            (lock_spec = no_lock) AND
            (* PTS 1114103 E.Z. *)
            ((ouser = a01_il_b_identifier) OR
            (ouser = acv.a_curr_user_name)) AND
            (acv.a_returncode = 0)  AND
            ((acv.a_sqlmode = sqlm_internal) OR (acv.a_sqlmode = sqlm_oracle))
            )
        THEN
            IF  _f_ok
            THEN
                BEGIN
                _f_ok := true;
                a663restable_get (acv, d_fix, otable, dmli.d_sparr, _f_ok);
                _found := _f_ok;
                IF  _f_ok
                THEN
                    BEGIN
                    IF  (dmli.d_view OR
                        ((acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_proc = a62) AND
                        NOT dmli.d_subquery))
                    THEN
                        a07_nb_put_error (acv, e_no_resulttable_allowed,
                              acv.a_ap_tree^[ table_node ].n_pos, otable)
                    ELSE
                        BEGIN
&                       ifdef TRACE
                        FOR _ix := dmli.d_sparr.pbasep^.sbase.bfirstindex TO
                              dmli.d_sparr.pbasep^.sbase.blastindex DO
                            a061td_colinfo (a103GetColumn (dmli.d_sparr.pbasep^.
                                  sbase, _ix)^, _ix);
                        (*ENDFOR*) 
&                       endif
                        (* don't use statement referencing result table for shared sql *)
                        acv.a_parsingForSharedSql := false;
                        IF  check_teresult
                        THEN
                            IF  (NOT (rs_result in
                                dmli.d_sparr.presnp^.sresname.resstate) AND
                                NOT (rs_show in dmli.d_sparr.presnp^.
                                sresname.resstate))
                                OR
                                NOT (rs_reuseable in dmli.d_sparr.presnp^.
                                sresname.resstate)
                            THEN
                                a07_nb_put_error (acv, e_missing_reuseable,
                                      acv.a_ap_tree^[ table_node ].n_pos, otable);
                            (*ENDIF*) 
                        (*ENDIF*) 
                        ;
&                       IFDEF TRACE
                        IF  dmli.d_pos_result = cak_intern_pos
                        THEN
                            t01int4  (ak_sem, 'intern_resu1', dmli.d_pos_result)
                        ELSE
                            IF  dmli.d_pos_result = cak_extern_pos
                            THEN
                                t01int4  (ak_sem, 'user_result1', dmli.d_pos_result)
                            ELSE
                                t01int4  (ak_sem, 'd_pos_resul1', dmli.d_pos_result);
                            (*ENDIF*) 
                        (*ENDIF*) 
&                       ENDIF
                        IF  acv.a_returncode = 0
                        THEN
                            BEGIN
                            IF  (wanted_priv = r_sel) AND (NOT dmli.d_single)
                            THEN
                                IF  (dmli.d_pos_result = cak_extern_pos) OR
                                    (dmli.d_pos_result = cak_intern_pos)
                                THEN
                                    acv.a_resname_addr[ dmli.d_pos_result ]^.
                                          sresname.resstate :=
                                          acv.a_resname_addr[ dmli.d_pos_result ]^.
                                          sresname.resstate + [ rs_nobase ];
                                (*ENDIF*) 
                            (*ENDIF*) 
                            otreeid        := dmli.d_sparr.presnp^.sresname.restreeid;
                            ofromtableid       := otreeid.fileTabId_gg00;
                            ospecialname       := ospecialname + [ oresfile ];
                            ouser              := acv.a_curr_user_name;
                            oall_priv          := true;
                            oprivset           := [  ];
                            osetallpriv        := [  ];
                            oattributes        := [  ];
                            ospecs_needed      := ons_only_tablename;
                            IF  dmli.d_acttabindex < dmli.d_cntfromtab
                            THEN
                                dmli.d_tabarr^[ dmli.d_acttabindex + 1 ].ocounttabs := ocounttabs + 1
                            ELSE
                                dmli.d_maxcounttabs := ocounttabs + 1;
                            (*ENDIF*) 
                            _found := true;
                            END
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  ((NOT _found) AND (acv.a_returncode = 0))
        THEN
            IF  (acv.a_proc_compile <> pct_none) AND
                (acv.a_intern_select_cnt = 0)    AND
                (ouser = a01_il_b_identifier) (* PTS 1125862 *)
            THEN
                a07_nb_put_error (acv, e_owner_must_be_specified,
                      acv.a_ap_tree^[ table_node ].n_pos, otable)
            ELSE
                BEGIN
                IF  all
                THEN
                    _dst := d_fix
                ELSE
                    _dst := d_release;
                (*ENDIF*) 
&               IFDEF TRACE
                t01knl_identifier (ak_sem, 'user        ', ouser);
                t01knl_identifier (ak_sem, 'table       ', otable);
                t01knl_identifier (ak_sem, 'reference   ', oreference);
                t01int4(ak_sem, 'dst         ', ord (_dst));
&               ENDIF
                IF  NOT a06_table_exist (acv, _dst,
                    ouser, otable, dmli.d_sparr, all)
                THEN
                    a07_nb_put_error (acv, e_unknown_tablename,
                          acv.a_ap_tree^[ table_node ].n_pos, otable)
                ELSE
                    BEGIN
                    _syn_found := dmli.d_sparr.psynfound;
                    IF  _syn_found
                    THEN
                        BEGIN
                        IF  acv.a_proc_compile <> pct_none
                        THEN
                            a07_nb_put_error (acv, e_synonym_not_allowed,
                                  acv.a_ap_tree^[ table_node ].n_pos, otable)
                        ELSE
                            _synid := dmli.d_sparr.psynid;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  dmli.d_view
                    THEN
                        BEGIN
                        IF  (ouser = dmli.d_viewusername) AND (otable = dmli.d_viewtablen)
                        THEN
                            a07_nb_put_error (acv, e_unknown_tablename,
                                  acv.a_ap_tree^[ table_node ].n_pos, otable)
                        ELSE
                            IF  ouser = a01_i_temp
                            THEN
                                a07_b_put_error (acv, e_temp_table_not_allowed,
                                      acv.a_ap_tree^[ table_node ].n_pos)
                            ELSE
                                IF  dmli.d_sparr.pbasep^.sbase.btablekind in
                                    [tdb2view]
                                THEN
                                    dmli.d_phase_cnt  := cak_complex_view_indicator
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        IF  ((dmli.d_sparr.pbasep^.sbase.btablekind in
                            [ tview, tcomplexview ]) AND
                            (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_proc = a62) AND
                            NOT dmli.d_subquery)
                        THEN
                            a07_b_put_error (acv, e_missing_basetable,
                                  acv.a_ap_tree^[ table_node ].n_pos);
                        (*ENDIF*) 
                        IF  ((wanted_priv <> r_sel) AND
                            (dmli.d_sparr.pbasep^.sbase.btablekind = tview) AND
                            (acv.a_sqlmode <> sqlm_internal))
                        THEN
                            a07_b_put_error (acv, e_missing_privilege,
                                  acv.a_ap_tree^[ table_node ].n_pos);
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  acv.a_returncode = 0
                THEN
                    WITH dmli.d_sparr, pbasep^, sbase DO
                        BEGIN
                        IF  _syn_found
                        THEN
                            BEGIN
                            ospecialname := ospecialname + [ oissynonym ];
                            ak660syn_owner (acv, _synid, ouser)
                            END;
                        (*ENDIF*) 
                        IF  btablekind = tcatalog_table
                        THEN
                            ospecialname := ospecialname + [ oisshowview ];
                        (*ENDIF*) 
                        oattributes   := battributes;
                        ofromtableid  := syskey.stableid;
                        a06GetBaseTreeid (acv, dmli.d_sparr.pbasep^.sbase, otreeid);
                        ospecs_needed := ons_only_tablename;
                        IF  ouser = a01_i_temp
                        THEN (* don't use statement referencing temp table for shared sql *)
                            acv.a_parsingForSharedSql := false;
                        (*ENDIF*) 
                        IF  dmli.d_acttabindex < dmli.d_cntfromtab
                        THEN
                            dmli.d_tabarr^[ dmli.d_acttabindex + 1 ].ocounttabs := ocounttabs + bv_tabcount
                        ELSE
                            dmli.d_maxcounttabs := ocounttabs + bv_tabcount;
                        (*ENDIF*) 
                        IF  ( acv.a_cmd_segm^.sp1c_producer = sp1pr_view_optimizer ) OR
                            ( (acv.a_queryrewrite_modified) AND
                            (qcn_RightsChecked in acv.a_ap_tree^[ table_node ].n_querycheck) )
                        THEN
                            _privs.priv_all_set := [wanted_priv]
                        ELSE
                            BEGIN
                            CASE lock_spec OF
                                no_lock :
                                    IF  wanted_priv = r_upd
                                    THEN
                                        _needed_privs := [ r_sel, r_upd ]
                                    ELSE
                                        _needed_privs := [ wanted_priv ];
                                    (*ENDIF*) 
                                read_lock :
                                    _needed_privs := [ r_sel ];
                                write_lock :
                                    IF  acv.a_sqlmode = sqlm_oracle
                                    THEN
                                        _needed_privs := [ r_sel, r_ins, r_upd, r_del ]
                                    ELSE
                                        _needed_privs := [ r_ins, r_upd, r_del ];
                                    (*ENDIF*) 
                                no_lock_string :
                                    _needed_privs := [ wanted_priv ];
                                optimistic_lock :
                                    _needed_privs := [ r_sel ];
                                OTHERWISE
                                    _needed_privs := [ r_sel ];
                                END;
                            (*ENDCASE*) 
                            a06get_priv (acv, pbasep, _needed_privs, _privs);
                            END;
                        (*ENDIF*) 
                        IF  _privs.priv_all_set <> [  ]
                        THEN
                            osetallpriv := a01fullset
                        ELSE
                            osetallpriv := _privs.priv_sel_set +
                                  _privs.priv_upd_set;
                        (*ENDIF*) 
                        IF  (
                            (wanted_priv in _privs.priv_all_set)
                            OR
                            ((lock_spec = write_lock)  AND
                            ([ r_ins, r_upd, r_del ] * _privs.priv_all_set <> []))
                            OR
                            ((lock_spec = write_lock)  AND
                            ( acv.a_sqlmode = sqlm_oracle) AND
                            ([ r_ins, r_upd, r_del, r_sel ] * _privs.priv_all_set <> []))
                            )
                        THEN
                            IF  ((acv.a_sqlmode = sqlm_ansi)
                                AND
                                NOT (r_sel in _privs.priv_all_set)
                                AND
                                ((wanted_priv = r_upd) OR
                                ( wanted_priv = r_del)))
                            THEN
                                BEGIN
                                oall_priv := false;
                                oprivset := _privs.priv_sel_set;
                                dmli.d_upd_set := a01fullset;
                                END
                            ELSE
                                oall_priv := true
                            (*ENDIF*) 
                        ELSE
                            IF  (((_privs.priv_sel_set = [  ]) AND (wanted_priv = r_sel))
                                OR
                                ((_privs.priv_upd_set = [  ]) AND (wanted_priv = r_upd))
                                OR
                                (wanted_priv = r_ins)
                                OR
                                (wanted_priv = r_del)
                                OR
                                ((_privs.priv_upd_set + _privs.priv_sel_set = []) AND
                                (lock_spec = write_lock)))
                            THEN
                                IF  ((osetallpriv = [  ]) AND
                                    (_privs.priv_upd_set = [  ]) AND
                                    (_privs.priv_sel_set = [  ]))
                                THEN
                                    BEGIN
                                    IF  (acv.a_is_ddl <> no_ddl) AND
                                        (acv.a_role_info <> role_none)
                                    THEN
                                        BEGIN
                                        _ddl      := acv.a_is_ddl;
                                        acv.a_is_ddl := no_ddl;
                                        a06get_priv (acv,
                                              pbasep, _needed_privs, _privs);
                                        acv.a_is_ddl := _ddl
                                        END;
                                    (*ENDIF*) 
                                    IF  (acv.a_is_ddl <> no_ddl) AND
                                        ((_privs.priv_all_set <> [  ]) OR
                                        (priv_col_sel in _privs.priv_col_exist))
                                    THEN
                                        BEGIN
                                        _err_msg :=
                                              'ROLE DEFINED PRIVILEGE  ';
                                        a07_const_b_put_error (acv,
                                              e_missing_privilege,
                                              acv.a_ap_tree^[ table_node ].n_pos,
                                              @_err_msg, sizeof (_err_msg))
                                        END
                                    ELSE
                                        a07_nb_put_error (acv, e_unknown_tablename,
                                              acv.a_ap_tree^[ table_node ].n_pos,
                                              otable)
                                    (*ENDIF*) 
                                    END
                                ELSE
                                    BEGIN
                                    IF  r_ins in _needed_privs
                                    THEN
                                        _kw_index := cak_i_insert
                                    ELSE
                                        IF  r_del in _needed_privs
                                        THEN
                                            _kw_index := cak_i_delete
                                        ELSE
                                            IF  r_upd in _needed_privs
                                            THEN
                                                _kw_index := cak_i_update
                                            ELSE
                                                IF  r_sel in _needed_privs
                                                THEN
                                                    _kw_index := cak_i_select
                                                ELSE
                                                    _kw_index := cak_i_no_keyword;
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                    a07_kw_put_error (acv, e_missing_privilege,
                                          acv.a_ap_tree^[ table_node ].n_pos,
                                          _kw_index)
                                    END
                                (*ENDIF*) 
                            ELSE
                                BEGIN
                                oall_priv := false;
                                IF  wanted_priv = r_sel
                                THEN
                                    oprivset := _privs.priv_sel_set
                                ELSE
                                    BEGIN
                                    IF  r_sel in _privs.priv_all_set
                                    THEN
                                        oprivset := a01fullset
                                    ELSE
                                        IF  acv.a_sqlmode = sqlm_ansi
                                        THEN
                                            oprivset := _privs.priv_upd_set
                                        ELSE
                                            oprivset := _privs.priv_upd_set +
                                                  _privs.priv_sel_set;
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                    dmli.d_upd_set := _privs.priv_upd_set
                                    END
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        IF  acv.a_returncode = 0
                        THEN
                            IF  (bunloaded AND (NOT dmli.d_view))
                            THEN
                                a07_b_put_error (acv, e_file_unloaded,
                                      acv.a_ap_tree^[ table_node ].n_pos)
                            ELSE
                                BEGIN
                                IF  acv.a_progusage_add
                                THEN
                                    BEGIN
                                    a38_add_progusage (acv, p_table, ouser,
                                          otable, a01_il_b_identifier);
                                    END;
&                               IFDEF TRACE
                                (*ENDIF*) 
                                IF  hsTempLock_egg00 in dmli.d_globstate
                                THEN
                                    t01name(ak_sem, 'temp_lock         ');
                                (*ENDIF*) 
                                IF  hsPermLock_egg00 in dmli.d_globstate
                                THEN
                                    t01name(ak_sem, 'perm_lock         ');
                                (*ENDIF*) 
                                t01int4 (ak_sem, 'isolation_in', ord(acv.a_isolation_info));
                                t01int4 (ak_sem, 'btablekind  ', ord(btablekind));
&                               ENDIF
                                IF  (((hsTempLock_egg00 in dmli.d_globstate) OR
                                    (hsPermLock_egg00 in dmli.d_globstate))      AND
                                    (acv.a_isolation_info = temp_lock_rec_get)  AND
                                    (NOT a101_IsExtendedTempFile (acv, btreeid)) AND
                                    ((btablekind = twithkey)    OR
                                    ( btablekind = twithoutkey) OR
                                    ( btablekind = tonebase)))
                                THEN
                                    BEGIN
                                    a103CatalogSchemaId (_catalogSchemaId);
                                    IF  _catalogSchemaId <> bschema
                                    THEN
                                        a54add_next_temp_lock (acv, btreeid.fileTabId_gg00,
                                              dmli.d_globstate);
                                    (*ENDIF*) 
                                    END;
                                (*ENDIF*) 
                                IF  btablekind in [ tpartition, tonebase,
                                    tview, tcomplexview ]
                                THEN
                                    BEGIN
                                    oviewqual  := bv_qualexist;
                                    oviewcheck := bv_checkopt;
                                    IF  btablekind <> tcomplexview
                                    THEN
                                        BEGIN
                                        IF  bv_level > dmli.d_phase_cnt
                                        THEN
                                            dmli.d_phase_cnt := bv_level;
                                        (*ENDIF*) 
                                        IF  (bv_distinct <> no_distinct)
                                        THEN
                                            dmli.d_distinct := bv_distinct;
                                        (*ENDIF*) 
                                        IF  btablekind in [tpartition, tonebase]
                                        THEN
                                            BEGIN
                                            IF  bv_tablekind = tcatalog_table
                                            THEN
                                                ospecialname := ospecialname +
                                                      [ oisshowview ];
                                            (*ENDIF*) 
                                            END
                                        ELSE
                                            ospecialname := ospecialname +
                                                  [ oisjoinview ];
                                        (*ENDIF*) 
                                        END
                                    ELSE
                                        BEGIN
&                                       ifdef trace
                                        t01sname (ak_sem, 'complex view');
&                                       endif
                                        ocomplex_view := true;
                                        IF  acv.a_intern_select_cnt= 0
                                        THEN
                                            BEGIN
                                            IF  bv_level > dmli.d_phase_cnt
                                            THEN
                                                dmli.d_phase_cnt := bv_level;
                                            (*ENDIF*) 
                                            _complicated_view := true;
                                            IF  NOT (dmli.d_view) AND
                                                (lock_spec = no_lock)
                                            THEN
                                                a54complicated_view(acv,
                                                      dmli, syskey.stableid);
                                            (*ENDIF*) 
                                            IF  acv.a_queryrewrite_mode
                                                = Statement_Rewrite (* PTS 1128197 D.T. *)
                                            THEN
                                                BEGIN
                                                IF  (dmli.d_cntfromtab = 1) AND
                                                    ((acv.a_statement_kind = iselects)
                                                    OR acv.a_intern_explain)
                                                    AND NOT (acv.a_from_select)
                                                    AND (acv.a_union_cnt = 0)
                                                THEN
                                                    a664new_optimize_info (acv,
                                                       dmli, table_node, _next_n);
                                                (*ENDIF*) 
                                                END;
                                            (*ENDIF*) 
                                            END
                                        ELSE
                                            a660build_view_treeid (acv,
                                                  syskey.stableid, otreeid)
                                        (*ENDIF*) 
                                        END;
                                    (*ENDIF*) 
                                    oview := true;
                                    END
                                (*ENDIF*) 
                                END
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    (*ENDWITH*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  (acv.a_returncode = 0) AND (NOT acv.a_queryrewrite_modified)
        THEN
            BEGIN
            _i := 1;
            WHILE _i < dmli.d_acttabindex DO
                BEGIN
                IF  (((dmli.d_tabarr^[ _i ].ouser      = ouser)   AND
                    (  dmli.d_tabarr^[ _i ].otable     = otable)  AND
                    (  dmli.d_tabarr^[ _i ].oreference = oreference (*= blankname*)
                    ))
                    OR
                    ((oisreference in dmli.d_tabarr^[ _i ].ospecialname) AND
                    NOT (oisreference in ospecialname) AND
                    (dmli.d_tabarr^[ _i ].oreference = otable)))
                THEN
                    a07_b_put_error (acv, e_duplicate_tablename,
                          acv.a_ap_tree^[ table_node ].n_pos);
                (*ENDIF*) 
                _i := succ(_i)
                END
            (*ENDWHILE*) 
            END;
&       IFDEF TRACE
        (*ENDIF*) 
        t01int4 (ak_sem, 'd_view      ', ord(dmli.d_view));
&       ENDIF
        IF  (acv.a_returncode = 0)                 AND
            NOT (dmli.d_view)                      AND
            (acv.a_parsingForSharedSql)            AND
            (acv.a_prepareHandle <> NIL)           AND
            (acv.a_queryrewrite_done = No_Rewrite)
        THEN
            BEGIN
            _schema := cgg_zero_id;
            IF  (ouser <> a01_il_b_identifier)
            THEN
                a06det_user_id (acv, ouser, _schema);
&           ifdef trace
            (*ENDIF*) 
            t01surrogate (ak_sem, 'TableInfo   ', _schema);
            t01lidentifier (ak_sem, otable);
&           endif
            IF  NOT a101_StoreTableInfo (acv, _schema, otable, NOT _withoutSchema, acv.a_prepareHandle)
            THEN
                acv.a_parsingForSharedSql := false; (* a07ak_system_error (acv, 660, 2) *)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (acv.a_returncode = 0) AND
            (dmli.d_view) AND (dmli.d_phase_cnt <= cak_complex_view_indicator)
        THEN
            BEGIN
            _sysk           := a01defaultkey;
            _sysk.stableid  := dmli.d_tableid;
            _sysk.sentrytyp := cak_etempviewtext;
            a10get_sysinfo (acv, _sysk, d_release, _p, _b_err);
            IF  _b_err = e_ok
            THEN
                BEGIN
                _i := 1;
                WHILE _i <= _p^.sviewtext.vttabcount DO
                    IF  _p^.sviewtext.vttab[ _i ].vtttab_n_pos = dmli.d_n_pos
                    THEN (* table already inserted in viewtext record *)
                        _i := csp_maxint2
                    ELSE
                        _i := _i + 1;
                    (*ENDIF*) 
                (*ENDWHILE*) 
                IF  _i < csp_maxint2
                THEN
                    BEGIN
                    _p^.sviewtext.vttabcount := succ(_p^.sviewtext.vttabcount);
                    _p^.sviewtext.vttab[ _p^.sviewtext.vttabcount ].vtttableid := ofromtableid;
                    _p^.sviewtext.vttab[ _p^.sviewtext.vttabcount ].vttfromTableInfo := fti_none;
                    IF  oissynonym in ospecialname
                    THEN
                        BEGIN
                        _p^.sviewtext.vttab[ _p^.sviewtext.vttabcount ].vttfromTableInfo := fti_synonym;
                        _p^.sviewtext.vttab[ _p^.sviewtext.vttabcount ].vttreftabid := _synid
                        END
                    ELSE
                        BEGIN
                        _p^.sviewtext.vttab[ _p^.sviewtext.vttabcount ].vttreftabid := cgg_zero_id;
                        IF  _withoutSchema
                        THEN
                            _p^.sviewtext.vttab[ _p^.sviewtext.vttabcount ].vttfromTableInfo := fti_withoutSchema;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    _p^.sviewtext.vttab[ _p^.sviewtext.vttabcount ].vtttabcount      := ocounttabs;
                    _p^.sviewtext.vttab[ _p^.sviewtext.vttabcount ].vttrefname       := oisreference in ospecialname;
                    _p^.sviewtext.vttab[ _p^.sviewtext.vttabcount ].vttcomplex_view  := _complicated_view;
                    _p^.sviewtext.vttab[ _p^.sviewtext.vttabcount ].vtttab_n_pos     := dmli.d_n_pos;
                    a10repl_sysinfo (acv, _p, _b_err);
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  _b_err <> e_ok
            THEN
                a07_b_put_error (acv, _b_err, 1)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a660_select (
            VAR acv   : tak_all_command_glob;
            startnode : tsp00_Int2);
 
VAR
      _execute_select          : boolean;
      _complex_select          : boolean;
      _init_info_output        : boolean;
      _is_from_select          : boolean;
      _is_outer_join           : boolean;
      _pseudo_resultset_select : boolean;
      _complex_for_locks       : boolean;
      _init_ex_kind            : tak_execution_kind;
      _lock_n                  : integer;
      _dummy                   : integer;
      _parsk                   : tak_parskey;
      _dmli                    : tak_dml_info;
 
BEGIN
a54_dml_init( acv, _dmli, NOT c_in_union );
acv.a_unionrec_ptr      := NIL;
acv.a_p_arr1.px[ 1 ]    := NIL;
acv.a_p_arr1.pbasep     := NIL;
acv.a_p_arr1.pcount     := 0;
_is_from_select         := acv.a_from_select;
acv.a_from_select       := false;
acv.a_fromsel_n         := 0;
acv.a_union_cnt         := 0;
_dmli.d_outer_join      := ( _dmli.d_outer_join OR acv.a_outer_join );
_is_outer_join          := _dmli.d_outer_join;
_pseudo_resultset_select:= false;
_execute_select         := false;
_complex_select         := false;
_init_ex_kind           := acv.a_ex_kind;
_init_info_output       := acv.a_info_output;
_lock_n                 := startnode;
IF  ( acv.a_ap_tree^[ _lock_n ].n_proc = a63 ) AND
    ( acv.a_ap_tree^[ _lock_n ].n_subproc = cak_x_recursive_select )
THEN
    BEGIN
    _lock_n := acv.a_ap_tree^[ _lock_n ].n_lo_level; (*collist*)
    _lock_n := acv.a_ap_tree^[ _lock_n ].n_sa_level; (*'union'start*)
    _lock_n := acv.a_ap_tree^[ _lock_n ].n_sa_level; (*last select*)
    END;
(*ENDIF*) 
REPEAT
    _lock_n := acv.a_ap_tree^[ _lock_n ].n_lo_level
UNTIL
    (((acv.a_ap_tree^[ _lock_n ].n_proc = a60) AND
    (  acv.a_ap_tree^[ _lock_n ].n_subproc  = cak_x_select_list))
    OR (acv.a_ap_tree^[ _lock_n ].n_proc = no_proc))
    (* resulttablename *);
(*ENDREPEAT*) 
REPEAT
    _lock_n := acv.a_ap_tree^[ _lock_n ].n_sa_level
UNTIL
    ((_lock_n = 0) OR
    ((acv.a_ap_tree^[ _lock_n ].n_proc = a60) AND
    (acv.a_ap_tree^[ _lock_n ].n_subproc in
    [ cak_x_lock_exclusive, cak_x_lock_share,
    cak_x_lock_nowait, cak_x_lock_optimistic, cak_x_lock_ignore ])) OR
    ((acv.a_ap_tree^[ _lock_n ].n_proc = a51) AND
    (acv.a_ap_tree^[ _lock_n ].n_subproc = cak_i_isolation)));
(*ENDREPEAT*) 
&ifdef trace
t01execution_kind( ak_sem, '_init_ex_kin', acv.a_ex_kind );
t01int4 (ak_sem, '_lock_n     ', _lock_n );
t01int4( ak_sem, 'a_max_intern', acv.a_max_intern_select );
&endif
IF  acv.a_intern_explain
THEN
    _dmli.d_globstate := [ hsWithoutLock_egg00 ]
ELSE
    BEGIN
    _dmli.d_globstate := acv.a_transinf.tri_global_state;
    IF  _lock_n <> 0
    THEN
        BEGIN
        _dmli.d_with_lock_clause := true;
        a660_lock( acv, _lock_n, _dmli.d_globstate );
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_max_intern_select > 0
THEN
    BEGIN
    (* restore globstate stored during select in     *)
    (* which this complex view (build now) was found *)
    _dmli.d_globstate := acv.a_cmd_globstate;
    END;
(*ENDIF*) 
IF  (acv.a_max_intern_select > 0) AND (acv.a_ex_kind <> only_parsing)
THEN
    IF  ((hsTempLock_egg00 in _dmli.d_globstate) OR
        (hsPermLock_egg00 in _dmli.d_globstate))
    THEN
        BEGIN
        acv.a_ex_kind     := only_parsing;
        acv.a_info_output := false;
        _complex_select    :=
              acv.a_intern_select_cnt = acv.a_max_intern_select;
        _execute_select    := true
        END;
    (*ENDIF*) 
(*ENDIF*) 
;
&IFDEF TRACE
t01command_kind( ak_sem, 'command_kind', acv.a_command_kind );
&ENDIF
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    _dmli.d_unchanged_globstate := _dmli.d_globstate;
    _complex_for_locks          := false;
    IF  (acv.a_ap_tree^[ startnode ].n_proc = a63) AND
        (acv.a_ap_tree^[ startnode ].n_subproc = cak_x_recursive_select)
    THEN
        BEGIN
        acv.a_ex_kind      := only_parsing;
        acv.a_info_output  := false;
        _complex_select := true;
        _execute_select := (_init_ex_kind <> only_parsing) AND
              ((NOT _complex_select) OR
              (acv.a_intern_select_cnt = acv.a_max_intern_select));
        a662_recursive_select (acv, startnode, _dmli);
        IF  (acv.a_returncode = 0)              AND
            (acv.a_init_ex_kind = only_parsing) AND
            (acv.a_init_info_output)            AND
            (acv.a_return_segm^.sp1r_function_code <> csp1_explain_fc)      AND
            (acv.a_return_segm^.sp1r_function_code <> csp1_select_into_fc)  AND
            (acv.a_return_segm^.sp1r_function_code <> csp1_mselect_into_fc) AND
            ((acv.a_intern_select_cnt = 0) OR
            ( acv.a_max_intern_select = acv.a_intern_select_cnt))
        THEN
            BEGIN
            s26find_part (acv.a_return_segm^,
                  sp1pk_parsid, acv.a_data_part);
            IF  acv.a_data_part <> NIL
            THEN
                BEGIN
                acv.a_data_ptr     := @acv.a_data_part^.sp1p_buf[ 1 ];
                acv.a_data_length  := acv.a_data_part^.sp1p_buf_len;
                acv.a_count_variab := 0;
                a73parsid_describe_semantic (acv, c_inclusive_output,
                      _dmli.d_sparr.pinfop,  _dmli.d_sparr.pcolnamep);
                acv.a_data_ptr := NIL;
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        IF  (acv.a_ap_tree^[ startnode ].n_proc = a63) AND
            (acv.a_ap_tree^[ startnode ].n_subproc in
            [ cak_x_start_union, cak_x_union, cak_x_union_all, cak_x_except,
            cak_x_except_all,
            cak_x_intersect, cak_x_intersect_all ])
        THEN
            BEGIN
            IF  acv.a_ap_tree^[ startnode ].n_subproc = cak_x_start_union
            THEN
                BEGIN
                IF  ((hsTempLock_egg00 in _dmli.d_globstate) OR
                    (hsPermLock_egg00 in _dmli.d_globstate)) AND
                    (acv.a_command_kind = single_command)
                THEN
                    BEGIN (* force union select to use a complex record *)
                    acv.a_ex_kind      := only_parsing;
                    acv.a_info_output  := false;
                    IF  acv.a_isolation_info <> temp_lock_rec_get
                    THEN
                        acv.a_isolation_info := temp_lock_rec_needed;
                    (*ENDIF*) 
                    acv.a_command_kind := subquery_command;
                    _complex_for_locks  := true;
                    _complex_select     := true
                    END;
                (*ENDIF*) 
                _execute_select := (_init_ex_kind <> only_parsing) AND
                      ((NOT _complex_select) OR
                      (acv.a_intern_select_cnt = acv.a_max_intern_select));
                a662_start_union_select (acv, startnode,
                      _dmli, _pseudo_resultset_select(*out*), _parsk(*out*));
                IF  _complex_for_locks
                THEN
                    a54set_complex_entry (acv, c_set_last_pars);
                (*ENDIF*) 
                IF  (acv.a_returncode = 0)              AND
                    (acv.a_init_ex_kind = only_parsing) AND
                    (acv.a_init_info_output)            AND
                    (acv.a_return_segm^.sp1r_function_code <> csp1_explain_fc)      AND
                    (acv.a_return_segm^.sp1r_function_code <> csp1_select_into_fc)  AND
                    (acv.a_return_segm^.sp1r_function_code <> csp1_mselect_into_fc) AND
                    ((acv.a_intern_select_cnt = 0) OR
                    ( acv.a_max_intern_select = acv.a_intern_select_cnt))
                THEN
                    BEGIN
                    s26find_part (acv.a_return_segm^,
                          sp1pk_parsid, acv.a_data_part);
                    IF  acv.a_data_part <> NIL
                    THEN
                        BEGIN
                        acv.a_data_ptr     := @acv.a_data_part^.sp1p_buf[ 1 ];
                        acv.a_data_length  := acv.a_data_part^.sp1p_buf_len;
                        acv.a_count_variab := 0;
                        a73parsid_describe_semantic (acv, c_inclusive_output,
                              _dmli.d_sparr.pinfop, _dmli.d_sparr.pcolnamep);
                        acv.a_data_ptr := NIL;
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            ELSE
                a07_b_put_error (acv, e_invalid_command,
                      acv.a_ap_tree^[ startnode ].n_pos)
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            a660select( acv, startnode, _dmli, _pseudo_resultset_select );
            _parsk := acv.a_pars_last_key;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    acv.a_info_output := _init_info_output;
    IF  (acv.a_isolation_info      = temp_lock_rec_get) AND
        (acv.a_returncode = 0)                 AND
        (acv.a_qualified_jv_upd    = no_jv_upd)
    THEN
        BEGIN
        a54_loc_temp_locks (acv,
              acv. a_transinf.tri_global_state, acv.a_p_arr1);
        END;
&   IFDEF TRACE
    (*ENDIF*) 
    t01bool( ak_sem, 'complex_for_', _complex_for_locks );
    t01command_kind( ak_sem, 'command_kind', acv.a_command_kind );
    t01bool( ak_sem, 'execute_sele', _execute_select );
    t01int4( ak_sem, 'a_first_pars', ord( acv.a_first_parskey ));
    t01bool( ak_sem, 'complex_sele', _complex_select );
&   ENDIF
    IF  (acv.a_returncode = 0)
    THEN
        IF  _execute_select AND ( NOT _dmli.d_only_sem_check )
        THEN
            BEGIN
            IF  _complex_select
            THEN
                BEGIN
                _parsk           := acv.a_pars_last_key;
                _parsk.p_no      := 0;
                _parsk.p_id[ 1 ] := acv.a_first_parskey;
                _parsk.p_kind    := m_complex
                END;
            (*ENDIF*) 
            a661exec_sub (acv, _dmli, _parsk, startnode, _dummy,
                  acv.a_info_output, _pseudo_resultset_select)
            END
        (*ENDIF*) 
    (*ENDIF*) 
    ;
    acv.a_ex_kind := _init_ex_kind;
    (* PTS 1111511 E.Z. *)
    IF  (_is_from_select
        AND
        (
        (acv.a_ex_kind <> only_parsing)    OR
        (acv.a_intern_explain)             OR
        ((acv.a_intern_select_cnt = 0) AND
        ( acv.a_max_intern_select > 0))    OR
        (acv.a_returncode <> 0)))
    THEN
        a661_fdelete_fromtab_results (acv);
    (* PTS 1106025 E.Z. *)
    (*ENDIF*) 
    IF  _is_from_select
        OR
        ((acv.a_intern_select_cnt > 0) AND
        ( acv.a_intern_select_cnt < acv.a_max_intern_select))
    THEN
        a663_intern_resname_drop (acv);
    (*ENDIF*) 
    END
ELSE
    ak660close_used_resultname (acv);
(*ENDIF*) 
&IFDEF TRACE
IF  _dmli.d_pos_result = cak_intern_pos
THEN
    t01int4  (ak_sem, 'intern_resul', _dmli.d_pos_result)
ELSE
    IF  _dmli.d_pos_result = cak_extern_pos
    THEN
        t01int4  (ak_sem, 'user_result ', _dmli.d_pos_result)
    ELSE
        t01int4  (ak_sem, 'd_pos_result', _dmli.d_pos_result);
    (*ENDIF*) 
(*ENDIF*) 
&ENDIF
acv.a_from_select   := _is_from_select;
acv.a_outer_join    := _is_outer_join;
acv.a_part_rollback := (acv.a_returncode <> 0) AND
      (acv.a_returncode <> 100);
&IFDEF TRACE
t01int4 (ak_sem, 'iso lvl ak66', ord(acv.a_isolation_info));
&ENDIF
a54_dml_finalize( _dmli, acv.a_transinf.tri_trans );
END;
 
(*------------------------------*) 
 
PROCEDURE
      a660_short_first_part (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            VAR tree : tgg00_FileId);
 
VAR
      _resname : tsp00_KnlIdentifier;
 
BEGIN
dmli.d_distinct           := no_distinct;
dmli.d_resname_found      := false;
dmli.d_inoutpos           := 1;
dmli.d_change.cr_colcount := 0;
dmli.d_outcolno           := 1;
dmli.d_exprno             := 1;
dmli.d_refname            := a01_il_b_identifier;
dmli.d_view               := false;
dmli.d_like               := false;
dmli.d_movebefore         := cgg_rec_key_offset;
dmli.d_pargeslen          := 0;
dmli.d_range              := false;
dmli.d_maxlen             := 0;
dmli.d_single             := false;
_resname := a01_into_res_name;
a663_make_res_buf (acv, dmli, _resname, tree);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a660build_view_treeid (
            VAR acv     : tak_all_command_glob;
            VAR tableid : tgg00_Surrogate;
            VAR tree    : tgg00_FileId);
 
VAR
      _k   : tgg00_Lkey;
      _buf : tgg00_Rec;
 
BEGIN
tree := acv.a_intern_res_tree;
SAPDB_PascalForcedMove (sizeof(tableid), sizeof(_k.k), @tableid, 1,
      @_k.k, 1, SURROGATE_MXGG00);
_k.len := SURROGATE_MXGG00;
b07cget_record (acv.a_transinf.tri_trans, acv.a_intern_cmd_tree, _k,
      _buf);
IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
THEN
    BEGIN
    a101_SetTempFileLevel (acv, tree, ord(_buf.info[ SURROGATE_MXGG00 + 1 ]));
    a101_SetTempFileSublevel (acv, tree, ord(_buf.info[ SURROGATE_MXGG00 + 2 ]));
    END
ELSE
    IF  acv.a_transinf.tri_trans.trError_gg00 = e_key_not_found
    THEN
        a07ak_system_error (acv, 660, 1)
    ELSE
        a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a660construct_subtree (
            VAR acv      : tak_all_command_glob;
            VAR sub_tree : tgg00_FileId;
            sub_count    : integer);
 
BEGIN
g04build_temp_tree_id (sub_tree, acv.a_transinf.tri_trans);
sub_tree.fileTfnTemp_gg00   := ttfnSubquery_egg00;
a101_SetTempFileLevel    (acv, sub_tree, sub_count DIV cak_maxsubcnt_per_level);
a101_SetTempFileSublevel (acv, sub_tree, sub_count MOD cak_maxsubcnt_per_level);
sub_tree.fileResultSite_gg00 := cgg04_nil_site;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a660select (
            VAR acv                     : tak_all_command_glob;
            startnode                   : tsp00_Int2;
            VAR dmli                    : tak_dml_info;
            VAR pseudo_resultset_select : boolean);
 
VAR
      _b_err         : tgg00_BasisError;
      _m_use_sub     : boolean;
      _no_subq       : boolean;
      _curr_n        : integer;
      _ix            : integer;
      _input_data_pos: tsp00_Int4;
      _parsk         : tak_parskey;
      _sr_rec        : tak71_strat_rec;
      _m_curr_res_id : tsp00_Int4;
 
BEGIN
&IFDEF TRACE
t01int4 (ak_sem, 'startnode   ', startnode);
t01bool (ak_sem, 'a_from_selec', acv.a_from_select);
t01int4 (ak_sem, 'a_fromsel_n ', acv.a_fromsel_n);
t01int4 (ak_sem, 'startn n_pos', acv.a_ap_tree^[ startnode ].n_pos);
t01bool (ak_sem, 'd_union     ', dmli.d_union);
t01int4 (ak_sem, 'a_union_cnt ', acv.a_union_cnt);
t01recursive_state (ak_sem, 'recurs state', acv.a_recursive_state);
t01command_kind (ak_sem, 'command_kind', acv.a_command_kind);
&ENDIF
_sr_rec.sr_use_rowno      := false;
_sr_rec.sr_reverse_access := false;
_sr_rec.sr_invkeylen      := csp_maxint2;
(* PTS 1138343 D.T. *)
(* WITHOUT QUERYREWRITE we want to have the same behaviour as before *)
IF  qcn_ContainsSJFromSelect in acv.a_ap_tree^[ startnode ].n_querycheck
THEN
    BEGIN
    IF  NOT acv.a_queryrewrite_modified
    THEN
        a07_kw_put_error (acv, e_wanted_keyword,
              acv.a_ap_tree^[ startnode ].n_refback, cak_i_select)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  qcn_SpecialJoinFromSelect in acv.a_ap_tree^[ startnode ].n_querycheck
THEN
    BEGIN
    IF  acv.a_queryrewrite_modified
    THEN
        dmli.d_specialjoinfromselect := true
    ELSE
        a07_kw_put_error (acv, e_wanted_keyword,
              acv.a_ap_tree^[ startnode ].n_pos, cak_i_select)
    (*ENDIF*) 
    END
ELSE
    BEGIN
    dmli.d_specialjoinfromselect := false
    END;
(*ENDIF*) 
IF  (acv.a_ap_tree^[ startnode ].n_proc = a63) AND
    (acv.a_ap_tree^[ startnode ].n_subproc in
    [ cak_x_start_union, cak_x_union, cak_x_union_all, cak_x_except,
    cak_x_except_all,
    cak_x_intersect, cak_x_intersect_all ])
THEN
    BEGIN
    IF  (acv.a_ap_tree^[ startnode ].n_subproc = cak_x_start_union)
    THEN
        BEGIN
        _m_curr_res_id := acv.a_union_res_id;
&       IFDEF TRACE
        t01int4 (ak_sem, 'a_curr_resi*', acv.a_curr_res_id);
        t01int4 (ak_sem, 'm_curr_resi*', _m_curr_res_id);
&       ENDIF
        a662_start_union_select(acv, startnode, dmli,
              pseudo_resultset_select, _parsk);
&       IFDEF TRACE
        t01int4 (ak_sem, 'a_curr_resi*', acv.a_curr_res_id);
        t01int4 (ak_sem, 'm_curr_res**', _m_curr_res_id);
&       ENDIF
        acv.a_union_res_id := _m_curr_res_id;
        END
    ELSE
        a662_union_select(acv, startnode, dmli)
    (*ENDIF*) 
    END
ELSE
    BEGIN
    IF  ( dmli.d_union )
    THEN
        BEGIN
        (* init one UNION entry *)
        acv.a_unionrec_ptr^.sunionrec.
              uselect_arr[ acv.a_unionrec_ptr^.sunionrec.uselect_cnt ].
              ufirstsel     := 0;
        acv.a_unionrec_ptr^.sunionrec.
              uselect_arr[ acv.a_unionrec_ptr^.sunionrec.uselect_cnt ].
              usecondsel    := 0;
        acv.a_unionrec_ptr^.sunionrec.
              uselect_arr[ acv.a_unionrec_ptr^.sunionrec.uselect_cnt ].
              uis_kind      := uis_none;
        acv.a_unionrec_ptr^.sunionrec.
              uselect_arr[ acv.a_unionrec_ptr^.sunionrec.uselect_cnt ].
              uis_all       := false;
        acv.a_unionrec_ptr^.sunionrec.uselect_cnt:=
              succ (acv.a_unionrec_ptr^.sunionrec.uselect_cnt);
        acv.a_union_cnt   := succ (acv.a_union_cnt);
&       IFDEF TRACE
        t01int4 (ak_sem, 'uselect_cnt ', acv.a_unionrec_ptr^.sunionrec.uselect_cnt);
&       ENDIF
        IF  acv.a_unionrec_ptr^.sunionrec.uselect_cnt > cak_max_union
        THEN
            a07_b_put_error (acv, e_too_many_intern_cmd, acv.a_unionrec_ptr^.sunionrec.uselect_cnt)
        ELSE
            a662realloc_new_unionrec (acv);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    _curr_n := startnode;
    IF  ( acv.a_command_kind <> union_in_sub_command )
    THEN
        dmli.d_act_node := startnode;
    (*ENDIF*) 
    acv.a_rowno_allowed      := true;
    _sr_rec.sr_distinct_bytes := true;
    _no_subq                  := true;
    IF  (acv.a_ap_tree^[ _curr_n ].n_sa_level <> 0) AND
        (acv.a_returncode = 0)
    THEN
        IF  (acv.a_ap_tree^[ acv.a_ap_tree^[ _curr_n ].n_sa_level ].n_symb <>
            s_identifier)
        THEN
            BEGIN
&           ifdef trace
            t01int4 (ak_sem, 'a_union_resi', acv.a_union_res_id);
&           endif
            (* Subqueries and correlated subqueries *)
            ak660subquery (acv, dmli, _sr_rec, _curr_n,
                  pseudo_resultset_select);
            _no_subq := false;
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  (acv.a_returncode = 0) AND _no_subq
    THEN
        BEGIN
        _m_use_sub := dmli.d_use_sub;
        IF  acv.a_command_kind = union_in_sub_command
        THEN
            BEGIN
            dmli.d_use_sub              := true
            END;
        (*ENDIF*) 
        pseudo_resultset_select := false;
        IF  dmli.d_view AND acv.a_outer_join
        THEN
            dmli.d_phase_cnt := cak_complex_view_indicator;
        (*ENDIF*) 
        ;
&       IFDEF TRACE
        t01bool (ak_sem, 'a_from_selec', acv.a_from_select);
        t01bool (ak_sem, 'd_only_sem_c', dmli.d_only_sem_check);
        IF  ( dmli.d_sparr.pparsp <> NIL )
        THEN
            t01int4 (ak_sem, 'p_subcntleve', ord (
                  dmli.d_sparr.pparsp^.sparsinfo.p_subcntlevel));
        (*ENDIF*) 
        t01int4 (ak_sem, 'd_subcount  ', dmli.d_subcount);
&       ENDIF
        (* PTS 1124799 E.Z. *)
        _input_data_pos := acv.a_input_data_pos;
        FOR _ix := 0 TO cgg_idx_max_valuefieldlist DO
            acv.a_mblock.mb_fieldlists[_ix] := NIL;
        (*ENDFOR*) 
        a660_query_execute( acv, dmli, _curr_n,
              ( NOT ( acv.a_from_select OR dmli.d_only_sem_check )),
              cgg_rec_key_offset, _sr_rec, pseudo_resultset_select, 1, 1,
              NOT c_from_sel_found );
        IF  dmli.d_only_sem_check
        THEN
            a06drop_fieldlist_references (acv.a_mblock.mb_fieldlists);
        (*ENDIF*) 
        dmli.d_use_sub     := _m_use_sub;
        dmli.d_outer_join  := dmli.d_outer_join OR acv.a_outer_join;
        IF  ( acv.a_returncode = cak_e_isolation_join )
        THEN
            BEGIN
            acv.a_input_data_pos := _input_data_pos;
            acv.a_returncode := 0;
            ak660join_query_execute( acv, dmli, _curr_n,
                  _sr_rec, pseudo_resultset_select );
            IF  dmli.d_only_sem_check
            THEN
                a06drop_fieldlist_references (acv.a_mblock.mb_fieldlists);
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (acv.a_returncode = 0) AND
        (* if acv.a_returncode <> 0,
              sel3_second should delete d_esparr.pa *)
        (acv.a_max_intern_select > 0) AND
        (acv.a_intern_select_cnt = 0) AND
        (NOT dmli.d_union)                 AND
        (NOT acv.a_from_select)
    THEN
        BEGIN
        IF  dmli.d_esparr.pbasep <> NIL
        THEN
            BEGIN
            (* PTS 1118139 E.Z. *)
            a10del_sysinfo (acv, dmli.d_esparr.pbasep^.syskey, _b_err);
            IF  _b_err <> e_ok
            THEN
                a07_b_put_error (acv, _b_err, 1);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        dmli.d_esparr.pbasep := NIL;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660syn_owner (
            VAR acv   : tak_all_command_glob;
            VAR synid : tgg00_Surrogate;
            VAR owner : tsp00_KnlIdentifier);
 
VAR
      _b_err : tgg00_BasisError;
      _p     : tak_sysbufferaddress;
      _sysk  : tgg00_SysInfoKey;
 
BEGIN
owner         := acv.a_curr_user_name;
_sysk          := a01defaultkey;
_sysk.stableid := synid;
a10get_sysinfo (acv, _sysk, d_release, _p, _b_err);
IF  _b_err = e_ok
THEN
    BEGIN
    IF  _p^.ssynonym.syn_owner <> acv.a_curr_user_id
    THEN (* public synonym *)
        a06determine_username (acv,
              _p^.ssynonym.syn_owner, owner)
    (*ENDIF*) 
    END
ELSE
    a07_b_put_error (acv, _b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a660output_tablename (
            VAR acv  : tak_all_command_glob);
 
BEGIN
IF  acv.a_update_tableowner <> a01_il_b_identifier
THEN
    BEGIN
    ak660put_sep (acv, '"');
    ak660one_identifier (acv, acv.a_update_tableowner);
    ak660put_sep (acv, '"');
    ak660put_sep (acv, '.');
    END;
(*ENDIF*) 
ak660put_sep (acv, '"');
ak660one_identifier (acv, acv.a_update_tablename);
ak660put_sep (acv, '"');
IF  (acv.a_returncode = 0)
THEN
    a06finish_curr_retpart (acv, sp1pk_tablename, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660put_tablename (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info);
 
BEGIN
&ifdef TRACE
t01name (ak_sem, 'TAB BY SEL FOR UPD');
t01int4 (ak_sem, ' table count', dmli.d_cntfromtab);
t01lidentifier (ak_sem, dmli.d_tabarr^ [ dmli.d_cntfromtab ].ouser);
t01lidentifier (ak_sem, dmli.d_tabarr^ [ dmli.d_cntfromtab ].otable);
&endif
IF  (dmli.d_cntfromtab = 1)
THEN
    WITH dmli.d_tabarr^ [ dmli.d_cntfromtab ] DO
        BEGIN
        acv.a_update_table_set := true;
        IF  ouser <> a01_il_b_identifier
        THEN
            acv.a_update_tableowner := ouser;
        (*ENDIF*) 
        acv.a_update_tablename := otable;
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660one_identifier (
            VAR acv : tak_all_command_glob;
            VAR id : tsp00_KnlIdentifier);
 
VAR
      _name_buf     : tsp00_C256;
      _name_len     : tsp00_Int4;
      _name_ptr     : tsp00_MoveObjPtr;
      _id_len       : tsp00_Int4;
      _e            : tsp8_uni_error;
      _err_char_no  : tsp00_Int4;
 
BEGIN
_name_len := -1; (* to silence var-not-init warning *)
IF  g01unicode
THEN
    BEGIN
    _name_ptr := @_name_buf;
    _id_len := s30unilnr (@id, csp_unicode_blank, 1, sizeof(id));
    IF  (_id_len > 0)
    THEN
        BEGIN
        _name_len := sizeof(_name_buf);
        s80uni_trans (@id, _id_len, csp_unicode,
              @_name_buf, _name_len,
              acv.a_out_packet^.sp1_header.sp1h_mess_code, [ ],
              _e, _err_char_no);
        END
    (*ENDIF*) 
    END
ELSE
    BEGIN
    _id_len   := s30klen (id, bsp_c1, sizeof(id));
    _name_ptr := @id;
    _name_len := _id_len;
    END;
(*ENDIF*) 
IF  (_name_len > 0)
THEN
    a06retpart_move (acv, _name_ptr, _name_len);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660put_sep (
            VAR acv : tak_all_command_glob;
            sep : char);
 
VAR
      _uni_char     : tsp00_C2;
      _out_char     : tsp00_C4;
      _len          : tsp00_Int4;
      _e            : tsp8_uni_error;
      _err_char_no  : tsp00_Int4;
 
BEGIN
IF  g01unicode
THEN
    BEGIN
    _uni_char[1] := csp_unicode_mark;
    _uni_char[2] := sep;
    _len         := sizeof (_out_char);
    s80uni_trans (@_uni_char, sizeof (_uni_char), csp_unicode,
          @_out_char , _len,
          acv.a_out_packet^.sp1_header.sp1h_mess_code, [ ],
          _e, _err_char_no);
    END
ELSE
    BEGIN
    _out_char[ 1 ] := sep;
    _len           := 1
    END;
(*ENDIF*) 
IF  (_len > 0)
THEN
    a06retpart_move (acv, @_out_char, _len);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660cleanup_more_phase(
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info;
            VAR sfe_rec : t_store_for_endpart);
 
VAR
      _aux_return   : tsp00_Int2;
      _aux_errorpos : tsp00_Int4;
      _b_err        : tgg00_BasisError;
 
BEGIN
IF  ( sfe_rec.messbuf_stored )
THEN
    BEGIN
    _aux_return   := acv.a_returncode;
    _aux_errorpos := acv.a_errorpos;
    acv.a_returncode := 0;
    a10del_sysinfo (acv, sfe_rec.ke, _b_err);
    IF  ( _aux_return <> 0 )
    THEN
        BEGIN
        acv.a_returncode := _aux_return;
        acv.a_errorpos   := _aux_errorpos;
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (( acv.a_returncode <> 0 ) AND
    ( NOT dmli.d_only_sem_check ) AND
    ( acv.a_command_kind = sub_in_union_command ))
THEN
    BEGIN
    _aux_return   := acv.a_returncode;
    _aux_errorpos := acv.a_errorpos;
    acv.a_returncode := 0;
    a10del_sysinfo (acv, dmli.d_sparr.pparsp^.syskey, _b_err);
    IF  ( _aux_return <> 0 )
    THEN
        BEGIN
        acv.a_returncode := _aux_return;
        acv.a_errorpos   := _aux_errorpos;
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660limit_param (VAR acv  : tak_all_command_glob;
            VAR dmli     : tak_dml_info;
            VAR act_node : integer);
 
VAR
      colin    : tak00_scolinf;
 
BEGIN
WITH colin DO
    BEGIN
    sci_len := 10;
    sci_frac := 0;
    sci_typ := dfixed;
    sci_iolen := (sci_len+1) DIV 2 + 2;
    sci_cprops := [  ];
    END;
(*ENDWITH*) 
dmli.d_datatype := dnumber;
dmli.d_colptr   := NIL;
a640factor (acv, dmli, colin, act_node);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak660limit (VAR acv  : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            VAR select_rec : tak_select_record);
 
VAR
      curr_n : integer;
      m_kind : tak_fp_kind_type;
 
BEGIN
IF  select_rec.sel_limit_n <> 0
THEN
    BEGIN
    curr_n := acv.a_ap_tree^[select_rec.sel_limit_n].n_lo_level;
    m_kind := dmli.d_pars_kind;
    IF  acv.a_ap_tree^[curr_n].n_symb = s_parameter_name
    THEN
        BEGIN
        IF  acv.a_ap_tree^[curr_n].n_sa_level <> 0
        THEN
            dmli.d_pars_kind := fp_limit_offset
        ELSE
            dmli.d_pars_kind := fp_upper_limit;
        (*ENDIF*) 
        ak660limit_param (acv, dmli, curr_n);
        dmli.d_upper_limit := cgg04_rowno_given_as_parameter;
        END
    ELSE
        a05int4_get (acv, acv.a_ap_tree^[curr_n].n_pos,
              acv.a_ap_tree^[curr_n].n_length, dmli.d_upper_limit);
    (*ENDIF*) 
    IF  acv.a_ap_tree^[curr_n].n_sa_level <> 0
    THEN
        BEGIN
        dmli.d_limit_offset := dmli.d_upper_limit;
        curr_n := acv.a_ap_tree^[curr_n].n_sa_level;
        IF  acv.a_ap_tree^[curr_n].n_symb = s_parameter_name
        THEN
            BEGIN
            dmli.d_pars_kind := fp_upper_limit;
            ak660limit_param (acv, dmli, curr_n);
            dmli.d_upper_limit := cgg04_rowno_given_as_parameter;
            END
        ELSE
            a05int4_get (acv, acv.a_ap_tree^[curr_n].n_pos,
                  acv.a_ap_tree^[curr_n].n_length, dmli.d_upper_limit);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  acv.a_ap_tree^[select_rec.sel_limit_n].n_subproc = cak_x_top_percent
    THEN
        a07_b_put_error (acv, e_not_implemented,
              acv.a_ap_tree^[select_rec.sel_limit_n].n_pos);
    (*ENDIF*) 
    dmli.d_pars_kind := m_kind;
    END
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
