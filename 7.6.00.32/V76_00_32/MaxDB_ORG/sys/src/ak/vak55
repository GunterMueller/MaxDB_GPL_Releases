.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK55$
.tt 2 $$$
.TT 3 $ElkeZ$DML_Parts$$2000-08-29$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : DML_Parts
=========
.sp
Purpose : Modul for processing a key specification
          and for describing parsed data
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a55_asearch_clause (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a55_akey_spec_list (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a55_aselectinto_key_spec_list (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a55_build_key (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR dfa  : tak_dfarr;
                    keynode  : integer);
 
        PROCEDURE
              a55_named_values (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR dfa  : tak_dfarr;
                    curr_n   : integer);
 
        PROCEDURE
              a55_found_one_value (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR dfa  : tak_dfarr);
 
        PROCEDURE
              a55_nullvalue (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR dfa  : tak_dfarr);
 
        PROCEDURE
              a55_describe_value (
                    VAR acv       : tak_all_command_glob;
                    VAR dmli      : tak_dml_info;
                    VAR colinfo   : tak00_columninfo;
                    nodeno        : integer;
                    res_buf_index : integer;
                    in_datapart   : boolean);
 
        PROCEDURE
              a55_const_from_resbuf (
                    VAR acv      : tak_all_command_glob;
                    VAR result   : tsp00_Buf;
                    VAR col_info : tak00_columninfo;
                    pars_kind    : tak_fp_kind_type;
                    VAR start    : integer;
                    VAR leng     : integer;
                    result_index : integer);
 
        PROCEDURE
              a55_current_or_pos_of_resname (
                    VAR acv                    : tak_all_command_glob;
                    VAR current_or_pos_allowed : tak_allow_type;
                    VAR put_node               : tsp00_Int2;
                    VAR last_node              : tsp00_Int2);
 
        PROCEDURE
              a55realloc_parsinfo (
                    VAR acv          : tak_all_command_glob;
                    VAR parsinfo_ptr : tak_sysbufferaddress);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01kw                : tak_keywordtab;
              a01_i_tablekey       : tsp00_KnlIdentifier;
              a01identifier_size   : integer;
              a01char_size         : integer;
 
        PROCEDURE
              a01_next_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_call_put (
                    VAR acv    : tak_all_command_glob;
                    proc       : tak_procs;
                    subproc    : tsp00_Int2;
                    VAR curr_n : tsp00_Int2);
 
        FUNCTION
              a01_eqkey (
                    VAR a      : tak_keyword;
                    sqlmode    : tsp00_SqlMode;
                    VAR b      : tsp00_MoveObj;
                    VAR scv    : tak_scanner_glob) : boolean;
 
        FUNCTION
              a01mandatory_keyword (
                    VAR acv          : tak_all_command_glob;
                    required_keyword : integer) : boolean;
 
        PROCEDURE
              a01_force_symbol (
                    VAR acv         : tak_all_command_glob;
                    expected_symbol : tak_sc_symbol;
                    VAR node1       : tsp00_Int2;
                    VAR node2       : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_syntax_tools : VAK02;
 
        PROCEDURE
              a02_n_acolumnname (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a02_aresulttablename (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a02_s_aparameterspec (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_syntax_values_tools : VAK03;
 
        PROCEDURE
              a03_avalue_spec (
                    VAR acv         : tak_all_command_glob;
                    null_allowed    : boolean;
                    stamp_allowed   : boolean;
                    default_allowed : boolean;
                    sysuser_allowed : boolean;
                    VAR put_node    : tsp00_Int2;
                    VAR last_node   : tsp00_Int2);
 
        PROCEDURE
              a03_anumeric_literal (
                    VAR acv           : tak_all_command_glob;
                    VAR put_node      : tsp00_Int2;
                    VAR last_node     : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05_constant_get (
                    VAR acv       : tak_all_command_glob;
                    ni            : integer;
                    VAR colinfo   : tak00_columninfo;
                    may_be_longer : boolean;
                    mv_dest       : integer;
                    VAR dest      : tsp00_MoveObj;
                    destpos       : integer;
                    VAR actlen    : integer);
 
        PROCEDURE
              a05identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
        PROCEDURE
              a05serial (
                    VAR acv        : tak_all_command_glob;
                    VAR colinfo    : tak00_columninfo;
                    VAR treeid     : tgg00_FileId;
                    VAR moveobj    : tsp00_MoveObj;
                    moveobj_size   : tsp00_Int4;
                    number_pos     : tsp00_Int4;
                    VAR number_len : integer;
                    with_retpart   : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling  : VAK061;
 
        FUNCTION
              a061exist_columnname (
                    VAR base_rec : tak_baserecord;
                    VAR column  : tsp00_KnlIdentifier;
                    VAR col_ptr : tak00_colinfo_ptr) : boolean;
 
        FUNCTION
              a061exist_columnindex (
                    VAR base_rec    : tak_baserecord;
                    extcolno        : integer;
                    VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
        PROCEDURE
              a061get_colname (
                    VAR col_info : tak00_columninfo;
                    VAR colname  : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
        PROCEDURE
              a07_error (
                    VAR acv   : tak_all_command_glob;
                    errorcode : tgg00_BasisError;
                    VAR nod1  : tsp00_Int2;
                    VAR nod2  : tsp00_Int2);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
&       ifdef trace
        FUNCTION
              a10is_fixed (
                    VAR acv : tak_all_command_glob;
                    p : tak_sysbufferaddress) : boolean;
&       endif
 
        PROCEDURE
              a10_fix_len_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    required_len : integer;
                    plus         : integer;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
      ------------------------------ 
 
        FROM
              AK_Synonym : VAK23;
 
        PROCEDURE
              a23put_sequence_info (
                    VAR acv    : tak_all_command_glob;
                    VAR mblock : tgg00_MessBlock;
                    tree_index : integer);
 
      ------------------------------ 
 
        FROM
              Where_Part : VAK63;
 
        PROCEDURE
              a63_asearch_condition (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01unicode        : boolean;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalUnicodeFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30lnr_defbyte (
                    str       : tsp00_MoveObjPtr;
                    defbyte   : char;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01buf (
                    layer    : tgg00_Debug;
                    VAR buf  : tsp00_Buf;
                    startpos : integer;
                    endpos   : integer);
 
        PROCEDURE
              t01name (
                    level : tgg00_Debug;
                    nam : tsp00_Name);
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR m         : tgg00_MessBlock);
 
        PROCEDURE
              t01moveobj (
                    layer    : tgg00_Debug;
                    VAR buf  : tsp00_MoveObj;
                    startpos : tsp00_Int4;
                    endpos   : tsp00_Int4);
&       endif
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ElkeZ
.sp
.cp 3
Created : 1985-01-22
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-08-29
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
 
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_null_allowed    = true (* a03_avalue_spec *);
      c_stamp_allowed   = true (* a03_avalue_spec *);
      c_default_allowed = true (* a03_avalue_spec *);
      c_sysuser_allowed = true (* a03_avalue_spec *);
      c_may_be_longer   = true (* a05_constant_get *);
      c_in_datapart     = true (* a55_describe_value *);
 
 
(*------------------------------*) 
 
PROCEDURE
      ak55akey_spec (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      _curr_n : tsp00_Int2;
      _last_n : tsp00_Int2;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    a01_call_put (acv, a55, cak_x_keyspec, _curr_n);
    a02_n_acolumnname (acv, acv.a_ap_tree^[ _curr_n ].n_lo_level, _last_n);
    a01_force_symbol (acv, s_equal, put_node, last_node);
    a03_avalue_spec (acv, NOT c_null_allowed,
          NOT c_stamp_allowed, NOT c_default_allowed,
          c_sysuser_allowed,
          acv.a_ap_tree^[ _last_n ].n_sa_level, _last_n);
    put_node := _curr_n;
    last_node := _curr_n
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak55set_clause (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            VAR dfa  : tak_dfarr;
            joinview : boolean;
            curr_n   : integer);
 
VAR
      _name_n   : integer;
      _val_n    : integer;
      _start_n  : integer;
      _column   : tsp00_KnlIdentifier;
      _col_ptr  : tak00_colinfo_ptr;
      _found    : boolean;
 
BEGIN
_name_n := acv.a_ap_tree^[ curr_n ].n_lo_level;
_val_n  := acv.a_ap_tree^[ _name_n ].n_sa_level;
_start_n:= acv.a_ap_tree^[ 0 ].n_lo_level;
(* update ... where pos of ... *)
IF  acv.a_ap_tree^[ _start_n ].n_proc = a73
THEN
    _start_n := acv.a_ap_tree^[ _start_n ].n_sa_level;
(*ENDIF*) 
_found := false;
IF  acv.a_ap_tree^[ _name_n ].n_symb = s_columnid
THEN
    BEGIN
    _found := a061exist_columnindex (dmli.d_sparr.pbasep^.sbase,
          dmli.d_columnindex, _col_ptr);
    IF  _found
    THEN
        a061get_colname (dmli.d_colbuf^, _column);
    (*ENDIF*) 
    END
ELSE
    BEGIN
    a05identifier_get (acv, _name_n, sizeof (_column), _column);
    _found := a061exist_columnname (dmli.d_sparr.pbasep^.sbase, _column, _col_ptr);
    END;
(*ENDIF*) 
IF  NOT _found
THEN
    a07_nb_put_error (acv, e_unknown_columnname,
          acv.a_ap_tree^[ _name_n ].n_pos, _column)
ELSE
    IF  ctinvisible in _col_ptr^.ccolpropset
    THEN
        a07_nb_put_error (acv, e_unknown_columnname,
              acv.a_ap_tree^[ _name_n ].n_pos, _column);
    (*ENDIF*) 
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    WITH dmli.d_tabarr^[ dmli.d_acttabindex ] DO
        IF  NOT oall_priv AND
            NOT (_col_ptr^.cextcolno in oprivset)
        THEN
            IF  _col_ptr^.cextcolno in osetallpriv
            THEN
                a07_nb_put_error (acv, e_missing_privilege,
                      acv.a_ap_tree^[ _name_n ].n_pos, _column)
            ELSE
                a07_nb_put_error (acv, e_unknown_columnname,
                      acv.a_ap_tree^[ _name_n ].n_pos, _column)
            (*ENDIF*) 
        ELSE
            IF  (_col_ptr^.cdatatyp in
                [ dstra, dstrb, dstruni,
                dlonga, dlongb, dlonguni ])
            THEN
                IF  ((acv.a_sqlmode = sqlm_ansi) OR dmli.d_key
                    OR ((acv.a_ap_tree^[ _start_n ].n_proc = a56) AND
                    (acv.a_ap_tree^[ _start_n ].n_subproc =
                    cak_x_insert_select))
                    OR ((acv.a_ap_tree^[ _start_n ].n_proc = a57) AND
                    ( dmli.d_corr <> no_correlation))
                    OR ((acv.a_ap_tree^[ _start_n ].n_proc <> a56) AND
                    ( acv.a_ap_tree^[ _start_n ].n_proc <> a57)))
                THEN
                    a07_nb_put_error (acv, e_command_for_string_not_allow,
                          acv.a_ap_tree^[ _name_n ].n_pos, _column)
                ELSE
                    (* PTS 1115483 E.Z. *)
                    IF  (acv.a_ap_tree^[ _start_n ].n_proc = a57) AND
                        (acv.a_ap_tree^[ _val_n ].n_symb <> s_null)
                    THEN
                        dmli.d_longdesc_found := true;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDIF*) 
IF   acv.a_returncode = 0
THEN
    IF  ((acv.a_ap_tree^[ _start_n ].n_proc = a56) AND
        (_column = a01_i_tablekey ))
    THEN
        a07_b_put_error (acv, e_col_must_be_no_keycolumn,
              acv.a_ap_tree^[ _name_n ].n_pos)
    ELSE
        BEGIN
        IF  joinview
        THEN
            dmli.d_fieldno := _col_ptr^.cextcolno
        ELSE
            dmli.d_fieldno := _col_ptr^.creccolno;
        (*ENDIF*) 
        IF  dmli.d_key
        THEN
            IF  NOT (ctkey in _col_ptr^.ccolpropset)
            THEN
                a07_nb_put_error (acv, e_column_must_be_keycolumn,
                      acv.a_ap_tree^[ _name_n ].n_pos, _column);
            (*ENDIF*) 
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            WITH dfa[ dmli.d_fieldno ] DO
                IF  dml_node <> 0
                THEN
                    a07_nb_put_error (acv, e_duplicate_columnname,
                          acv.a_ap_tree^[ _name_n ].n_pos, _column)
                ELSE
                    BEGIN
                    IF  dmli.d_key
                    THEN
                        dmli.d_foundset := dmli.d_foundset -
                              [ _col_ptr^.creccolno]
                    ELSE
                        dmli.d_foundset := dmli.d_foundset -
                              [ _col_ptr^.cextcolno ];
                    (*ENDIF*) 
                    dml_node              := _val_n;
                    dml_colno_in_subquery := 1;
                    dml_col_ptr           := _col_ptr
                    END
                (*ENDIF*) 
            (*ENDWITH*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a55_akey_spec_list (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      _curr_n : tsp00_Int2;
      _last_n : tsp00_Int2;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    a01_call_put (acv, a55, cak_x_keyspec_list, _curr_n);
    a01_next_symbol (acv);
    ak55akey_spec (acv, acv.a_ap_tree^[ _curr_n ].n_lo_level, _last_n);
    WHILE acv.a_scv.sc_symb = s_comma DO
        BEGIN
        a01_next_symbol (acv);
        ak55akey_spec (acv, acv.a_ap_tree^[ _last_n ].n_sa_level, _last_n)
        END;
    (*ENDWHILE*) 
    put_node := _curr_n;
    last_node := _curr_n
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a55_current_or_pos_of_resname (
            VAR acv                    : tak_all_command_glob;
            VAR current_or_pos_allowed : tak_allow_type;
            VAR put_node               : tsp00_Int2;
            VAR last_node              : tsp00_Int2);
 
VAR
      _fetch_node : tsp00_Int2;
      _scvh       : tak_scanner_glob;
 
BEGIN
IF  a01_eqkey (a01kw[ cak_i_current ], acv.a_sqlmode,
    acv.a_cmd_part^.sp1p_buf, acv.a_scv)
THEN
    IF  current_or_pos_allowed = at_not_allowed
    THEN
        a07_error (acv, e_invalid_keyword, put_node, last_node)
    ELSE
        BEGIN
        a01_next_symbol (acv);
        IF  a01mandatory_keyword (acv, cak_i_of)
        THEN
            BEGIN
            current_or_pos_allowed := at_not_allowed;
            a01_call_put (acv, a55, cak_x_current_of, put_node);
            a02_aresulttablename (acv,
                  acv.a_ap_tree^[ put_node ].n_lo_level, last_node);
            last_node := put_node
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
ELSE
    (* PTS 1114511 E.Z. *)
    IF  a01_eqkey (a01kw[ cak_i_pos ], acv.a_sqlmode,
        acv.a_cmd_part^.sp1p_buf, acv.a_scv)
    THEN
        BEGIN
        _scvh := acv.a_scv;
        a01_next_symbol (acv);
        IF  a01_eqkey (a01kw[ cak_i_of ], acv.a_sqlmode,
            acv.a_cmd_part^.sp1p_buf, acv.a_scv)
        THEN
            IF  current_or_pos_allowed = at_not_allowed
            THEN
                a07_error (acv, e_invalid_keyword, put_node, last_node)
            ELSE
                BEGIN
                current_or_pos_allowed := at_not_allowed;
                a01_call_put (acv, a55, cak_x_current_of, put_node);
                a01_next_symbol (acv);
                a02_aresulttablename (acv,
                      acv.a_ap_tree^[ put_node ].n_lo_level, last_node);
                a01_call_put (acv, a73, cak_x_fetch, _fetch_node);
                acv.a_ap_tree^[ _fetch_node ].n_sa_level :=
                      acv.a_ap_tree^[ 0 ].n_lo_level;
                acv.a_ap_tree^[ 0 ].n_lo_level := _fetch_node;
                a01_call_put (acv, a73, cak_x_pos,
                      acv.a_ap_tree^[ _fetch_node ].n_lo_level);
                _fetch_node := acv.a_ap_tree^[ _fetch_node ].n_lo_level;
                acv.a_ap_tree^[ _fetch_node ].n_sa_level :=
                      acv.a_ap_tree^[ put_node ].n_lo_level;
                IF  acv.a_returncode = 0
                THEN
                    IF  a01mandatory_keyword (acv, cak_i_is)
                    THEN
                        CASE acv.a_scv.sc_symb OF
                            s_parameter_name :
                                a02_s_aparameterspec (acv,
                                      acv.a_ap_tree^[ _fetch_node ].n_lo_level, last_node);
                            s_unsigned_integer :
                                a03_anumeric_literal (acv,
                                      acv.a_ap_tree^[ _fetch_node ].n_lo_level, last_node);
                            OTHERWISE
                                a07_error (acv, e_missing_value_spec,
                                      put_node, last_node);
                            END;
                        (*ENDCASE*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                last_node := put_node
                END
            (*ENDIF*) 
        ELSE
            acv.a_scv := _scvh;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  current_or_pos_allowed = at_has_to_be_there
THEN
    a07_error (acv, e_missing_keyword, put_node, last_node)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a55_asearch_clause (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      _key_found              : boolean;
      _curr_n                 : tsp00_Int2;
      _last_n                 : tsp00_Int2;
      _old_count_variab       : tsp00_Int2;
      _current_or_pos_allowed : tak_allow_type;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    a01_call_put (acv, a55, cak_x_search_clause, _curr_n);
    put_node := _curr_n;
    last_node := _curr_n;
    _key_found := false;
    IF  ((a01_eqkey (a01kw[ cak_i_key ], acv.a_sqlmode,
        acv.a_cmd_part^.sp1p_buf, acv.a_scv)) AND
        (acv.a_sqlmode = sqlm_internal))
    THEN
        BEGIN
        _key_found := true;
        _old_count_variab := acv.a_count_variab;
        a55_akey_spec_list (acv, acv.a_ap_tree^[ _curr_n ].n_lo_level,
              _last_n);
        acv.a_ap_tree^[ acv.a_ap_tree^[ _curr_n ].n_lo_level ].n_length :=
              acv.a_count_variab - _old_count_variab;
        END;
    (*ENDIF*) 
    IF  a01_eqkey (a01kw[ cak_i_where ], acv.a_sqlmode,
        acv.a_cmd_part^.sp1p_buf, acv.a_scv)
    THEN
        BEGIN
        a01_next_symbol (acv);
        IF  _key_found
        THEN
            _current_or_pos_allowed := at_not_allowed
        ELSE
            _current_or_pos_allowed := at_may_be_there;
        (*ENDIF*) 
        a55_current_or_pos_of_resname (acv,
              _current_or_pos_allowed,
              acv.a_ap_tree^[ _curr_n ].n_lo_level, _last_n);
        IF  (_current_or_pos_allowed = at_may_be_there) OR
            _key_found
        THEN
            BEGIN
            acv.a_allow_functions := tf_no_func;
            (* PTS 1124863 E.Z. *)
            IF  _key_found
            THEN
                acv.a_rowno_allowed := false
            ELSE
                acv.a_rowno_allowed := true;
            (*ENDIF*) 
            acv.a_cpart_type := cpt_in_where_clause;
            (* PTS 1116169 E.Z. *)
            acv.a_oneval_subq_allowed := true;
            IF  _current_or_pos_allowed = at_may_be_there
            THEN
                a63_asearch_condition (acv,
                      acv.a_ap_tree^[ _curr_n ].n_lo_level, _last_n)
            ELSE
                a63_asearch_condition (acv,
                      acv.a_ap_tree^[ _last_n ].n_sa_level, _last_n);
            (*ENDIF*) 
            (* PTS 1116169 E.Z. *)
            acv.a_oneval_subq_allowed := false;
            acv.a_cpart_type := cpt_unknown
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a55_aselectinto_key_spec_list (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      _and_found : boolean;
      _curr_n    : tsp00_Int2;
      _last_n    : tsp00_Int2;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    a01_call_put (acv, a55, cak_x_keyspec_list, _curr_n);
    a01_next_symbol (acv);
    _and_found := true;
    ak55akey_spec (acv, acv.a_ap_tree^[ _curr_n ].n_lo_level, _last_n);
    REPEAT
        IF  acv.a_scv.sc_symb = s_identifier
        THEN
            IF  a01_eqkey (a01kw[ cak_i_and ], acv.a_sqlmode,
                acv.a_cmd_part^.sp1p_buf, acv.a_scv)
            THEN
                BEGIN
                a01_next_symbol (acv);
                ak55akey_spec (acv, acv.a_ap_tree^[ _last_n ].n_sa_level, _last_n)
                END
            ELSE
                _and_found := false
            (*ENDIF*) 
        ELSE
            _and_found := false;
        (*ENDIF*) 
    UNTIL
        NOT _and_found;
    (*ENDREPEAT*) 
    put_node := _curr_n;
    last_node := _curr_n
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a55_build_key (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            VAR dfa  : tak_dfarr;
            keynode  : integer);
 
VAR
      _joinview   : boolean;
      _i          : integer;
      _col_index  : integer;
      _varkey_pos : integer;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    dmli.d_foundset := [  ];
    dmli.d_range    := false;
    dmli.d_nullkey  := true;
    FOR _i := 1 TO dmli.d_sparr.pbasep^.sbase.bmaxcol DO
        dfa[ _i ].dml_node := 0;
    (*ENDFOR*) 
    dmli.d_key := true;
    a55_named_values (acv, dmli, dfa, keynode);
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        _col_index  := dmli.d_sparr.pbasep^.sbase.bfirstcolind;
        _i          := 1;
        _varkey_pos := cgg_rec_key_offset+1;
        IF  dmli.d_sparr.pbasep^.sbase.btablekind = tview
        THEN
            _joinview := true
        ELSE
            _joinview := false;
        (*ENDIF*) 
        WHILE ((_i <= dmli.d_sparr.pbasep^.sbase.bkeycolcount) AND
              (acv.a_returncode = 0)) DO
            WITH a103GetColumn (dmli.d_sparr.pbasep^.sbase, _col_index)^ DO
                BEGIN
                IF  _joinview
                THEN
                    dmli.d_fieldno := cextcolno
                ELSE
                    dmli.d_fieldno := creccolno;
                (*ENDIF*) 
                IF  dfa[ dmli.d_fieldno ].dml_node = 0
                THEN
                    a07_b_put_error (acv,
                          e_missing_keyfield, 1)
                ELSE
                    BEGIN
                    a55_found_one_value(acv, dmli, dfa);
                    IF  _i = dmli.d_sparr.pbasep^.sbase.bkeycolcount - 1
                    THEN
                        _varkey_pos := acv.a_mblock.mb_data_len + 1;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                _i         := succ(_i);
                _col_index := cnextind;
                END;
            (*ENDWITH*) 
        (*ENDWHILE*) 
        IF  (acv.a_returncode = 0)
            AND (acv.a_ex_kind <> only_parsing)
            (* PTS 1111575 E.Z. *)
        THEN
            BEGIN
            (* trailing def_bytes must be truncated *)
            acv.a_mblock.mb_data_len := _varkey_pos +
                  s30lnr_defbyte (@acv.a_mblock.mb_data^.mbp_buf,
                  acv.a_mblock.mb_data^.mbp_buf [_varkey_pos],
                  _varkey_pos + 1,
                  acv.a_mblock.mb_data_len - _varkey_pos);
&           IFDEF TRACE
            t01name    (ak_sem, 'trunc key mb_part2');
            t01moveobj (ak_sem, acv.a_mblock.mb_data^.mbp_buf, 1, acv.a_mblock.mb_data_len)
&                 ENDIF
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a55_const_from_resbuf (
            VAR acv      : tak_all_command_glob;
            VAR result   : tsp00_Buf;
            VAR col_info : tak00_columninfo;
            pars_kind    : tak_fp_kind_type;
            VAR start    : integer;
            VAR leng     : integer;
            result_index : integer);
 
VAR
      _do_fill    : boolean;
      _i          : integer;
      _pos        : integer;
      _init_start : integer;
 
BEGIN
WITH col_info DO
    BEGIN
&   ifdef trace
    t01int4    (ak_sem, 'result_index', result_index);
    t01buf     (ak_sem, result, 1, 100);
    t01moveobj (ak_sem, acv.a_mblock.mb_data^.mbp_buf, 1, acv.a_mblock.mb_data_len);
&   endif
    _init_start := start;
    _do_fill    := false;
    _pos        := 1;
    _i          := 0;
    leng       := 0;
    REPEAT
        _pos  := _pos + leng;
        leng := ord(result[ _pos ]) + 1;
        _i    := succ(_i);
    UNTIL
        _i = result_index;
    (*ENDREPEAT*) 
    IF  (pars_kind <> fp_val_all_with_len) AND
        (ccolstack.etype <> st_varcol)
    THEN
        BEGIN
        _do_fill := ccolstack.etype <> st_varkey;
        _pos     := succ (_pos);
        leng    := pred (leng)
        END
    ELSE
        start := succ (start);
    (*ENDIF*) 
&   ifdef TRACE
    t01int4 (ak_sem, 'pos         ', _pos);
    t01int4 (ak_sem, 'init_start  ', _init_start);
    t01int4 (ak_sem, 'leng        ', leng);
    t01int4 (ak_sem, 'cinoutlen   ', cinoutlen);
&   endif
    IF  (acv.a_mblock.mb_type = m_insert)
        AND
        ((_init_start + leng > MAX_RECLEN_GG00) OR
        (_do_fill AND (_init_start + cinoutlen > MAX_RECLEN_GG00)))
    THEN
        a07_b_put_error (acv, e_too_long_record, -MAX_RECLEN_GG00)
    ELSE
        BEGIN
        SAPDB_PascalMove ('VAK55 ',   1,    
              sizeof(result), acv.a_mblock.mb_data_size,
              @result, _pos, @acv.a_mblock.mb_data^.mbp_buf, _init_start, leng,
              acv.a_returncode);
        IF  _do_fill
        THEN
            BEGIN
            IF  g01unicode AND
                (acv.a_mblock.mb_data^.mbp_buf[ start ] = csp_unicode_def_byte)
            THEN
                SAPDB_PascalUnicodeFill ('VAK55 ',   2,    
                      acv.a_mblock.mb_data_size, @acv.a_mblock.mb_data^.mbp_buf,
                      _init_start + leng, cinoutlen - leng, csp_unicode_blank,
                      acv.a_returncode)
            ELSE
                SAPDB_PascalFill ('VAK55 ',   3,    
                      acv.a_mblock.mb_data_size, @acv.a_mblock.mb_data^.mbp_buf, _init_start + leng,
                      cinoutlen - leng, acv.a_mblock.mb_data^.mbp_buf[ start ],
                      acv.a_returncode);
            (*ENDIF*) 
            leng := cinoutlen
            END;
        (*ENDIF*) 
        IF  pars_kind = fp_val_varcol_with_len
        THEN
            IF  (ccolstack.etype = st_fixkey) OR
                (ccolstack.etype = st_varkey)
            THEN
                acv.a_mblock.mb_data^.mbp_keylen :=
                      acv.a_mblock.mb_data^.mbp_keylen + leng;
&           ifdef trace
            (*ENDIF*) 
        (*ENDIF*) 
        t01moveobj (ak_sem, acv.a_mblock.mb_data^.mbp_buf, 1, _init_start+leng-1);
&       endif
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a55_describe_value (
            VAR acv       : tak_all_command_glob;
            VAR dmli      : tak_dml_info;
            VAR colinfo   : tak00_columninfo;
            nodeno        : integer;
            res_buf_index : integer;
            in_datapart   : boolean);
 
VAR
      _ansi_change  : boolean;
      _escape_val   : boolean;
      _si_index     : integer;
      _extdatalen   : integer;
      _extiolen     : integer;
      _start_n      : integer;
 
BEGIN
IF  NOT dmli.d_only_sem_check
THEN
    BEGIN
    IF  dmli.d_sparr.pparsp^.sparsinfo.p_cnt_infos >=
        dmli.d_sparr.pparsp^.sparsinfo.p_max_infos
    THEN
        a55realloc_parsinfo (acv, dmli.d_sparr.pparsp);
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        WITH dmli.d_sparr.pparsp^.sparsinfo,
             p_pars_infos[ p_cnt_infos+1 ],
             colinfo, ccolstack DO
            BEGIN
            IF  acv.a_mblock.mb_data_len + dmli.d_maxlen + cinoutlen + 2 > acv.a_mblock.mb_data_size
            THEN
                a07_b_put_error (acv, e_too_many_mb_data,
                      acv.a_ap_tree^[ nodeno ].n_pos)
            ELSE
                BEGIN
&               ifdef TRACE
                IF  (dmli.d_sparr.pparsp^.syskey.sentrytyp <> cak_eparsinfo)
                    OR NOT a10is_fixed (acv, dmli.d_sparr.pparsp)
                THEN
                    a07ak_system_error (acv, 55, 1);
                (*ENDIF*) 
                t01name (ak_sem, 'one descr block : ');
                t01int4 (ak_sem, ' dm_parskind', ord(dmli.d_pars_kind));
                t01int4 (ak_sem, ' reclen     ', acv.a_mblock.mb_data^.mbp_reclen);
                t01int4 (ak_sem, ' data_len   ', acv.a_mblock.mb_data_len);
                t01int4 (ak_sem, ' dm_movebefo', dmli.d_movebefore);
                t01int4 (ak_sem, ' dm_maxlen  ', dmli.d_maxlen);
                t01int4 (ak_sem, ' dm_topos   ', dmli.d_topos);
&               endif
                _start_n:= acv.a_ap_tree^[ 0 ].n_lo_level;
                (* update ... where pos of ... *)
                IF  acv.a_ap_tree^[ _start_n ].n_proc = a73
                THEN
                    _start_n := acv.a_ap_tree^[ _start_n ].n_sa_level;
                (*ENDIF*) 
                IF  ((cdatatyp = ddate ) OR
                    (cdatatyp = dtime ) OR
                    (cdatatyp = dtimestamp))
                THEN
                    BEGIN
                    CASE cdatatyp OF
                        ddate :
                            _extdatalen := mxsp_extdate;
                        dtime :
                            _extdatalen := mxsp_exttime;
                        dtimestamp :
                            _extdatalen := mxsp_exttimestamp;
                        END;
                    (*ENDCASE*) 
                    IF  (acv.a_out_packet^.sp1_header.sp1h_mess_code in
                        [ csp_unicode_swap, csp_unicode ])
                        AND
                        NOT acv.a_ascii_in_and_output (* new feature *)
                    THEN
                        _extiolen := succ(2*_extdatalen)
                    ELSE
                        _extiolen := succ(_extdatalen)
                    (*ENDIF*) 
                    END
                ELSE
                    IF  ((cdatatyp = dstra)    OR
                        ( cdatatyp = dstrb)    OR
                        ( cdatatyp = dstruni)  OR
                        ( cdatatyp = dlonga)   OR
                        ( cdatatyp = dlongb)   OR
                        ( cdatatyp = dlonguni))
                        AND
                        ((acv.a_ap_tree^[ _start_n ].n_proc = a56) OR
                        ( acv.a_ap_tree^[ _start_n ].n_proc = a57))
                    THEN
                        BEGIN
                        (* PTS 1116801 E.Z. *)
                        _extdatalen := mxsp_long_desc;
                        _extiolen := succ(_extdatalen);
                        END
                    ELSE
                        IF  cdatatyp = dunicode
                        THEN
                            BEGIN
                            (* PTS 1111575 E.Z. *)
                            _extdatalen := cdatalen;
                            _extiolen   := cinoutlen;
                            END
                        ELSE
                            IF  (acv.a_out_packet^.sp1_header.sp1h_mess_code in
                                [ csp_unicode_swap, csp_unicode ]) AND
                                (cdatatyp in [ dcha, dvarchara ]) AND
                                NOT acv.a_ascii_in_and_output (* new feature *)
                            THEN
                                BEGIN
                                _extdatalen := cdatalen;
                                _extiolen   := succ(2*cdatalen)
                                END
                            ELSE
                                BEGIN
                                _extdatalen := cdatalen;
                                _extiolen := cinoutlen
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                fp_etype := etype;
                IF  (dmli.d_pars_kind <> fp_val_all_without_l) AND
                    (dmli.d_pars_kind <> fp_rowno)             AND
                    (dmli.d_pars_kind <> fp_limit_offset)      AND
                    (dmli.d_pars_kind <> fp_upper_limit)       AND
                    (cinoutlen   > 0)
                THEN
                    IF  (res_buf_index <> 0) OR
                        NOT(acv.a_ap_tree^[ nodeno ].n_symb in
                        [ s_nextval, s_currval ])
                    THEN
                        dmli.d_maxlen := dmli.d_maxlen + cinoutlen;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  cdatatyp = dfixed
                THEN
                    (* This is very defensive, since there are corrupted *)
                    (* catalogs with cbinary set for e.g. FIXED (13,2).  *)
                    IF  cbinary                             AND
                        (acv.a_comp_type <> at_unknown)         AND
                        ((cdatalen = 5) OR (cdatalen = 10)) AND
                        (* PTS 1107680 E.Z. *)
                        (cdatafrac = 0 + cak_frac_offset)
                    THEN
                        IF  cdatalen = 5
                        THEN
                            fp_datatyp := dsmallint
                        ELSE
                            fp_datatyp := dinteger
                        (*ENDIF*) 
                    ELSE
                        fp_datatyp := dfixed
                    (*ENDIF*) 
                ELSE
                    fp_datatyp := cdatatyp;
                (*ENDIF*) 
                fp_colset := [ fp_opt ];
                IF  dmli.d_range
                THEN
                    BEGIN
                    IF  NOT (ctopt in ccolpropset)
                    THEN
                        fp_colset := fp_colset - [ fp_opt ]
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  ctdefault in ccolpropset
                THEN
                    fp_colset := fp_colset + [ fp_default ];
                (* PTS 1105106 E.Z. *)
                (*ENDIF*) 
                IF  (ctserial in ccolpropset) AND
                    (dmli.d_pars_kind <> fp_val_all_with_len) AND
                    (dmli.d_pars_kind <> fp_val_all_without_l)
                THEN
                    fp_colset := fp_colset + [fp_serial];
                (*ENDIF*) 
                IF  dmli.d_like AND NOT dmli.d_like_expression
                THEN
                    BEGIN
                    fp_colset := fp_colset + [ fp_like ];
                    IF  dmli.d_like_optimize
                    THEN
                        CASE dmli.d_like_part OF
                            1 :
                                fp_colset := fp_colset + [ fp_like1 ];
                            2 :
                                fp_colset := fp_colset + [ fp_like2 ];
                            OTHERWISE
                                BEGIN
                                END;
                            END;
                        (*ENDCASE*) 
                    (*ENDIF*) 
                    END;
                (* fp_like is an indicator to change *)
                (* '*', '_', '??', '%' *)
                (*ENDIF*) 
                _escape_val := false;
                IF  dmli.d_escape
                THEN
                    BEGIN
                    IF  NOT dmli.d_like_expression
                    THEN
                        fp_colset := fp_colset + [ fp_escape ];
                    (*ENDIF*) 
                    IF  dmli.d_expand = 1
                    THEN
                        BEGIN
                        _escape_val := true;
                        IF  cdatatyp = dunicode
                        THEN
                            _extiolen := 3
                        ELSE
                            _extiolen   := acv.a_max_codewidth+1;
                        (*ENDIF*) 
                        _extdatalen := 1;
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  ctcatalog in ccolpropset (* h.b. PTS 1105136 *)
                THEN
                    BEGIN
                    fp_kind         := fp_catalog_column;
                    IF  cdatatyp in [ dfixed, dfloat, dsmallint, dinteger ]
                    THEN
                        BEGIN
                        fp_len_and_frac_v1.lf_fixed_datalen := _extdatalen;
                        fp_len_and_frac_v1.lf_frac          := cdatafrac
                        END
                    ELSE
                        fp_len_and_frac_v1.lf_datalen := _extdatalen;
                    (*ENDIF*) 
                    fp_inoutlen_v1  := _extiolen
                    END
                ELSE
                    BEGIN
                    fp_kind := dmli.d_pars_kind;
                    IF  cdatatyp in [ dfixed, dfloat, dsmallint, dinteger ]
                    THEN
                        BEGIN
                        fp_len_and_frac_v1.lf_fixed_datalen := _extdatalen;
                        fp_len_and_frac_v1.lf_frac          := cdatafrac
                        END
                    ELSE
                        fp_len_and_frac_v1.lf_datalen := _extdatalen;
                    (*ENDIF*) 
                    fp_inoutlen_v1 := _extiolen;
                    IF  res_buf_index > 0
                    THEN
                        BEGIN
                        (* PTS 1110277 E.Z. *)
                        IF  ((dmli.d_pars_kind = fp_val_all_with_len) OR
                            (etype = st_varcol) OR
                            (elen_var > cak_maxvarcoliolen))
                        THEN
                            BEGIN
                            dmli.d_maxlen := succ(dmli.d_maxlen);
                            IF  (elen_var > cak_maxvarcoliolen)
                            THEN
                                dmli.d_maxlen := succ(dmli.d_maxlen);
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        fp_kind             := fp_val_from_res_buffer;
                        fp_rangeextcolno_v6 := creccolno;
                        fp_movebefore_v6    := dmli.d_movebefore;
                        fp_glob_fp_kind     := dmli.d_pars_kind;
                        fp_res_buf_index    := res_buf_index
                        END
                    ELSE
                        IF  dmli.d_pars_kind in [ fp_val_varcol_with_len,
                            fp_val_all_with_len ]
                        THEN
                            BEGIN
                            (* PTS 1110277 E.Z. *)
                            IF  ((dmli.d_pars_kind = fp_val_all_with_len) OR
                                (etype = st_varcol) OR
                                (elen_var > cak_maxvarcoliolen))
                            THEN
                                BEGIN
                                dmli.d_maxlen := succ(dmli.d_maxlen);
                                IF  (elen_var > cak_maxvarcoliolen)
                                THEN
                                    dmli.d_maxlen := succ(dmli.d_maxlen);
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            fp_rangeextcolno := creccolno;
                            dmli.d_pargeslen := dmli.d_pargeslen+_extiolen;
                            fp_movebefore_v1 := dmli.d_movebefore
                            END
                        ELSE
                            IF  (dmli.d_pars_kind = fp_val_all_without_l) OR
                                (dmli.d_pars_kind = fp_rowno)             OR
                                (dmli.d_pars_kind = fp_limit_offset)      OR
                                (dmli.d_pars_kind = fp_upper_limit) 
                            THEN
                                BEGIN
                                fp_stackpos := acv.a_mblock.mb_qual^.mfirst_free-1;
                                fp_movebefore_v2 := acv.a_mblock.mb_data_len;
                                IF   (acv.a_variable_input AND NOT in_datapart)
                                THEN
                                    dmli.d_parameter_count := succ(dmli.d_parameter_count)
                                ELSE
                                    BEGIN
                                    acv.a_mblock.mb_data^.
                                          mbp_buf [acv.a_mblock.mb_data_len+1] := csp_default_byte;
                                    acv.a_mblock.mb_data_len := acv.a_mblock.mb_data_len+cinoutlen
                                    END
                                (*ENDIF*) 
                                END
                            ELSE
                                IF  dmli.d_pars_kind = fp_lock_val
                                THEN
                                    BEGIN
                                    fp_movebefore_v3 := dmli.d_movebefore;
                                    END
                                ELSE
                                    BEGIN
                                    IF  dmli.d_pars_kind = fp_selord_val_no_len
                                    THEN
                                        fp_stackpos := dmli.d_topos
                                    ELSE
                                        fp_stackpos := 0;
                                    (*ENDIF*) 
                                    dmli.d_pargeslen := dmli.d_pargeslen+_extiolen;
                                    fp_movebefore_v2 := dmli.d_movebefore
                                    END;
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  (acv.a_sqlmode = sqlm_ansi)
                    AND
                    NOT (((acv.a_mblock.mb_type = m_insert) AND
                    (  dmli.d_pars_kind = fp_val_varcol_with_len))
                    OR
                    ( (acv.a_mblock.mb_type = m_update) AND
                    (  dmli.d_pars_kind = fp_val_all_with_len)))
                THEN
                    _ansi_change := true
                ELSE
                    _ansi_change := false;
                (*ENDIF*) 
                dmli.d_movebefore := 0;
                IF  acv.a_ap_tree^[ nodeno ].n_symb = s_parameter_name
                THEN
                    BEGIN
&                   ifdef trace
                    IF  (dmli.d_sparr.pinfop^.syskey.sentrytyp<>cak_eshortinfo)
                        OR NOT a10is_fixed (acv, dmli.d_sparr.pinfop)
                    THEN
                        a07ak_system_error (acv, 55, 2);
&                   endif
                    (*ENDIF*) 
                    _si_index := acv.a_ap_tree^[ nodeno ].n_length;
                    WITH dmli.d_sparr.pinfop^.sshortinfo, siinfo[ _si_index ] DO
                        BEGIN
                        IF  _si_index > sicount
                        THEN
                            sicount := _si_index;
                        (*ENDIF*) 
                        IF  sp1i_data_type = dunknown
                        THEN
                            BEGIN
                            sp1i_mode := [ ];
                            IF  (dmli.d_range AND
                                (ctdefault in ccolpropset))
                            THEN
                                sp1i_mode := sp1i_mode + [ sp1ot_default ];
                            (*ENDIF*) 
                            IF  dmli.d_range AND
                                NOT (ctopt in ccolpropset)
                            THEN
                                sp1i_mode := sp1i_mode + [ sp1ot_mandatory ]
                            ELSE
                                sp1i_mode := sp1i_mode + [ sp1ot_optional ];
                            (*ENDIF*) 
                            IF  _escape_val
                            THEN
                                sp1i_mode := [ sp1ot_escape_char ];
                            (*ENDIF*) 
                            sp1i_io_type := sp1io_input;
                            IF  NOT acv.a_variable_input
                            THEN
                                BEGIN
                                fp_frompos_v1 := acv.a_input_data_pos;
                                sp1i_bufpos   := fp_frompos_v1;
                                END
                            ELSE
                                fp_frompos_v1 := sp1i_param_no;
                            (*ENDIF*) 
                            acv.a_input_data_pos := acv.a_input_data_pos+_extiolen;
                            sp1i_frac    := 0;
                            IF  cdatatyp in [dstra, dstrb, dstruni,
                                dlonga, dlongb, dlonguni ]
                            THEN
                                BEGIN
                                sp1i_length := _extdatalen;
                                sp1i_in_out_len := succ(_extdatalen)
                                END
                            ELSE
                                BEGIN
                                sp1i_length := _extdatalen;
                                IF  NOT((cdatatyp in [ dfloat, dvfloat ]) OR
                                    _ansi_change)
                                THEN
                                    sp1i_frac := cdatafrac - cak_frac_offset;
                                (*ENDIF*) 
                                sp1i_in_out_len := _extiolen;
                                END;
                            (*ENDIF*) 
                            CASE cdatatyp OF
                                dboolean,
                                ddate,
                                dtime,
                                dtimestamp,
                                dstra,
                                dstrb,
                                dstruni :
                                    sp1i_data_type := cdatatyp;
                                dfixed :
                                    IF  _ansi_change
                                    THEN
                                        sp1i_data_type := dfloat
                                    ELSE
                                        IF  (cbinary AND
                                            (acv.a_comp_type <> at_unknown))
                                        THEN
                                            BEGIN
                                            IF  cdatalen = 5
                                            THEN
                                                sp1i_data_type := dsmallint
                                            ELSE
                                                IF  cdatalen = 10
                                                THEN
                                                    sp1i_data_type := dinteger
                                                ELSE
                                                    sp1i_data_type := dfixed;
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                            END
                                        ELSE
                                            sp1i_data_type := dfixed;
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                dfloat, dvfloat :
                                    sp1i_data_type := dfloat;
                                dcha :
                                    IF  ((cshiftoutchar = cgg04_truechar) AND
                                        (acv.a_comp_type <> at_unknown))
                                    THEN
                                        sp1i_data_type := dvarchara
                                    ELSE
                                        sp1i_data_type := cdatatyp;
                                    (*ENDIF*) 
                                dchb :
                                    IF  ((cshiftoutchar = cgg04_truechar) AND
                                        (acv.a_comp_type <> at_unknown))
                                    THEN
                                        sp1i_data_type := dvarcharb
                                    ELSE
                                        sp1i_data_type := cdatatyp;
                                    (*ENDIF*) 
                                dunicode : (* PTS 1126516 E.Z. *)
                                    IF  ((cshiftoutchar = cgg04_truechar) AND
                                        (acv.a_comp_type <> at_unknown))
                                    THEN
                                        sp1i_data_type := dvarcharuni
                                    ELSE
                                        sp1i_data_type := cdatatyp;
                                    (*ENDIF*) 
                                dlonga :
                                    sp1i_data_type := dstra;
                                dlongb :
                                    sp1i_data_type := dstrb;
                                dlonguni :
                                    sp1i_data_type := dstruni;
                                dabaptabhandle :
                                    sp1i_data_type := dabaptabhandle;
                                OTHERWISE
                                    sp1i_data_type := dunknown;
                                END;
                            (*ENDCASE*) 
                            END
                        ELSE
                            IF  acv.a_variable_input
                            THEN
                                fp_frompos_v1 := sp1i_param_no
                            ELSE
                                fp_frompos_v1 := sp1i_bufpos
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                    END
                ELSE
                    IF  res_buf_index = 0
                    THEN
                        CASE acv.a_ap_tree^[ nodeno ].n_symb OF
                            s_date :
                                IF  ((cdatalen < mxsp_date)
                                    OR NOT (cdatatyp in [ dcha,
                                    dunicode, ddate ]))
                                THEN
                                    a07_b_put_error (acv,
                                          e_const_incompatible_with_typ,
                                          acv.a_ap_tree^[ nodeno ].n_pos)
                                ELSE
                                    fp_frompos_v1 := cak_fp_date;
                                (*ENDIF*) 
                            s_time :
                                IF  ((cdatalen < mxsp_time)
                                    OR NOT (cdatatyp in [ dcha,
                                    dunicode, dtime ]))
                                THEN
                                    a07_b_put_error (acv,
                                          e_const_incompatible_with_typ,
                                          acv.a_ap_tree^[ nodeno ].n_pos)
                                ELSE
                                    fp_frompos_v1 := cak_fp_time;
                                (*ENDIF*) 
                            s_timestamp :
                                IF  ((cdatalen < mxsp_timestamp)
                                    OR NOT (cdatatyp in [ dcha,
                                    dunicode, dtimestamp ]))
                                THEN
                                    a07_b_put_error (acv,
                                          e_const_incompatible_with_typ,
                                          acv.a_ap_tree^[ nodeno ].n_pos)
                                ELSE
                                    fp_frompos_v1 := cak_fp_timestamp;
                                (*ENDIF*) 
                            s_now :
                                IF  cdatatyp = ddate
                                THEN
                                    fp_frompos_v1 := cak_fp_date
                                ELSE
                                    IF  cdatatyp = dtime
                                    THEN
                                        fp_frompos_v1 := cak_fp_time
                                    ELSE
                                        IF  ((cdatalen < mxsp_timestamp)
                                            OR NOT (cdatatyp in [ dcha,
                                            dunicode, dtimestamp ]))
                                        THEN
                                            a07_b_put_error (acv,
                                                  e_const_incompatible_with_typ,
                                                  acv.a_ap_tree^[ nodeno ].n_pos)
                                        ELSE
                                            fp_frompos_v1 := cak_fp_timestamp;
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                (*ENDIF*) 
                            (* PTS 1116175 E.Z. *)
                            s_utcdate :
                                IF  ((cdatalen < mxsp_timestamp)
                                    OR NOT (cdatatyp in [ dcha,
                                    dunicode, dtimestamp ]))
                                THEN
                                    a07_b_put_error (acv,
                                          e_const_incompatible_with_typ,
                                          acv.a_ap_tree^[ nodeno ].n_pos)
                                ELSE
                                    fp_frompos_v1 := cak_fp_utcdate;
                                (*ENDIF*) 
                            s_utcdiff :
                                IF  (cdatatyp in [ dfixed, dfloat, dvfloat ])
                                    AND
                                    (cdatalen >= cak_utcdiff_len)
                                    AND
                                    ((cdatafrac = cak_ak_float)                     OR
                                    ((cdatalen - (cdatafrac - cak_frac_offset) >=
                                    cak_utcdiff_len - cak_utcdiff_frac) AND
                                    ( cdatafrac - cak_frac_offset >= cak_utcdiff_frac)))
                                THEN
                                    fp_frompos_v1 := cak_fp_utcdiff
                                ELSE
                                    a07_b_put_error (acv,
                                          e_const_incompatible_with_typ,
                                          acv.a_ap_tree^[ nodeno ].n_pos);
                                (*ENDIF*) 
                            s_timezone :
                                IF  ((cdatalen < cak_time_durationlen)
                                    OR NOT (cdatatyp in [ dfixed, dfloat ]))
                                THEN
                                    a07_b_put_error (acv,
                                          e_const_incompatible_with_typ,
                                          acv.a_ap_tree^[ nodeno ].n_pos)
                                ELSE
                                    fp_frompos_v1 := cak_fp_timezone;
                                (*ENDIF*) 
                            s_stamp :
                                IF  ((cdatalen < SURROGATE_MXGG00)
                                    OR NOT (cdatatyp in [dchb,
                                    dstra, dstruni, dstrb,
                                    dlonga, dlonguni, dlongb]))
                                THEN
                                    a07_b_put_error (acv,
                                          e_const_incompatible_with_typ,
                                          acv.a_ap_tree^[ nodeno ].n_pos)
                                ELSE
                                    fp_frompos_v1 := cak_fp_stamp;
                                (*ENDIF*) 
                            s_transaction :
                                IF  ((cdatalen < sizeof(acv.a_transinf.tri_trans.trTransId_gg00))
                                    OR NOT (cdatatyp = dchb))
                                THEN
                                    a07_b_put_error (acv,
                                          e_const_incompatible_with_typ,
                                          acv.a_ap_tree^[ nodeno ].n_pos)
                                ELSE
                                    fp_frompos_v1 := cak_fp_transaction;
                                (*ENDIF*) 
                            s_nextval, s_currval :
                                IF  ((cdatatyp <> dfixed) AND
                                    ( cdatatyp <> dfloat))
                                THEN
                                    a07_b_put_error (acv,
                                          e_const_incompatible_with_typ,
                                          acv.a_ap_tree^[ nodeno ].n_pos)
                                          (* PTS 1109766 E.Z. *)
                                ELSE
                                    IF  (ctserial in ccolpropset) AND
                                        (dmli.d_pars_kind <> fp_val_all_with_len) AND
                                        (dmli.d_pars_kind <> fp_val_all_without_l)
                                    THEN
                                        a07_b_put_error (acv, e_invalid_unsign_integer,
                                              acv.a_ap_tree^[ nodeno ].n_pos)
                                    ELSE
                                        BEGIN
&                                       ifdef trace
                                        t01int4 (ak_sem, 'len         ',
                                              acv.a_mblock.mb_data_len);
&                                       endif
                                        fp_frompos_v1 := -(acv.a_mblock.mb_data_len+1) +
                                              cak_fp_nextval;
                                        (* cak_fp_nextval is negative! *)
                                        a23put_sequence_info (acv,
                                              acv.a_mblock, nodeno)
                                        END;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                            s_serial :
                                BEGIN
                                fp_frompos_v1 := -(acv.a_mblock.mb_data_len+1) +
                                      cak_fp_nextval;
                                fp_colset := fp_colset + [fp_serial]
                                END;
                            s_current_schema :
                                IF  ((cdatalen < a01identifier_size DIV a01char_size)
                                    OR NOT (cdatatyp in [ dcha, dunicode ]))
                                THEN
                                    a07_b_put_error (acv,
                                          e_const_incompatible_with_typ,
                                          acv.a_ap_tree^[ nodeno ].n_pos)
                                ELSE
                                    fp_frompos_v1 := cak_fp_current_schema;
                                (*ENDIF*) 
                            END;
                        (*ENDCASE*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                p_cnt_infos := succ(p_cnt_infos);
&               ifdef TRACE
                t01messblock (ak_sem, 'describe_val', acv.a_mblock);
&               endif
                END
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a55_found_one_value (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            VAR dfa  : tak_dfarr);
 
VAR
      _describe_serial : boolean;
      _symb            : tak_sc_symbol;
      _lendiff         : integer;
      _leng            : integer;
      _aux_io_len      : integer;
      _res_index       : integer;
      _start           : integer;
      _ic2             : tsp_int_map_c2;
      _colname         : tsp00_KnlIdentifier;
 
BEGIN
WITH dfa[ dmli.d_fieldno ], acv.a_ap_tree^[ dml_node ] DO
    BEGIN
    IF  ((acv.a_cmd_segment_header.sp1c_mess_type = sp1m_parse) AND
        (n_symb in [ s_parameter_name,
        s_date, s_time, s_stamp, s_nextval, s_currval, s_timestamp,
        (* PTS 1116983 E.Z. *)
        s_utcdate, s_utcdiff, s_timezone, s_transaction, s_now, s_current_schema ]))
        OR
        (dmli.d_join_dml AND (dml_res_index > 0) AND
        (acv.a_ex_kind = only_parsing))
    THEN
        BEGIN
        IF  dmli.d_join_dml
        THEN
            _res_index := dml_res_index
        ELSE
            _res_index := 0;
        (*ENDIF*) 
        a55_describe_value (acv, dmli, dml_col_ptr^, dml_node, _res_index, NOT c_in_datapart);
        (* PTS 1111575 E.Z. *)
        END
    ELSE
        (* PTS 1111575 E.Z. *)
        BEGIN
        _lendiff         := 0;
        _describe_serial := false;
        IF  NOT (dmli.d_join_dml AND (dml_res_index > 0))
        THEN
            WITH dml_col_ptr^, ccolstack DO
                CASE dmli.d_pars_kind OF
                    fp_val_varcol_with_len :
                        IF  etype = st_varcol
                        THEN
                            _lendiff := 1
                        ELSE
                            IF  etype = st_varlongchar
                            THEN
                                _lendiff := 2;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    fp_val_all_with_len :
                        IF  (dml_col_ptr^.cinoutlen > cak_maxvarcoliolen)
                            OR (etype = st_column)
                        THEN
                            _lendiff := 2
                        ELSE
                            _lendiff := 1;
                        (*ENDIF*) 
                    OTHERWISE
                        BEGIN
                        END
                    END;
                (*ENDCASE*) 
            (*ENDWITH*) 
        (*ENDIF*) 
        acv.a_mblock.mb_data_len := acv.a_mblock.mb_data_len + _lendiff;
        IF  acv.a_mblock.mb_data_len + dmli.d_pargeslen + dml_col_ptr^.cinoutlen >
            acv.a_mblock.mb_data_size
        THEN
            a07_b_put_error (acv, e_too_many_mb_data, n_pos)
        ELSE
            BEGIN
            _start := acv.a_mblock.mb_data_len + 1;
            IF  acv.a_returncode = 0
            THEN
                BEGIN
                IF  dmli.d_join_dml AND (dml_res_index > 0)
                THEN
                    a55_const_from_resbuf (acv, dmli.d_resbuf_addr^,
                          dml_col_ptr^,
                          dmli.d_pars_kind, _start, _leng, dml_res_index)
                ELSE
                    BEGIN
                    IF  (acv.a_mblock.mb_type = m_insert)
                    THEN
                        BEGIN
                        a05_constant_get (acv, dml_node, dml_col_ptr^,
                              NOT c_may_be_longer,
                              MAX_RECLEN_GG00, acv.a_mblock.mb_data^.mbp_buf,
                              _start, _leng);
                        IF  a071_return_code (e_too_many_mb_data, acv.a_sqlmode)
                            = acv.a_returncode
                        THEN
                            BEGIN
                            acv.a_returncode := 0;
                            a07_b_put_error (acv, e_too_long_record, -MAX_RECLEN_GG00)
                            END
                        (*ENDIF*) 
                        END
                    ELSE
                        a05_constant_get (acv, dml_node, dml_col_ptr^,
                              NOT c_may_be_longer,
                              acv.a_mblock.mb_data_size,
                              acv.a_mblock.mb_data^.mbp_buf, _start, _leng);
                    (*ENDIF*) 
                    IF  acv.a_returncode = 0
                    THEN
                        IF  (ctserial in dml_col_ptr^.ccolpropset) AND
                            (dmli.d_sparr.pbasep <> NIL)
                        THEN
                            BEGIN
                            a05serial (acv, dml_col_ptr^,
                                  dmli.d_sparr.pbasep^.sbase.btreeid,
                                  acv.a_mblock.mb_data^.mbp_buf,
                                  acv.a_mblock.mb_data_size, _start, _leng,
                                  (acv.a_mblock.mb_type = m_insert));
                            IF  acv.a_ex_kind = only_parsing
                            THEN
                                BEGIN
                                IF  acv.a_mblock.mb_data^.
                                    mbp_buf[_start+1] = csp_zero_exponent
                                THEN
                                    BEGIN (* assign value at execution time *)
                                    _leng    := 0;
                                    acv.a_mblock.mb_data_len := acv.a_mblock.mb_data_len - _lendiff;
                                    _lendiff := 0;
                                    _symb    := n_symb;
                                    n_symb  := s_serial;
                                    IF  dmli.d_join_dml
                                    THEN
                                        _res_index := dml_res_index
                                    ELSE
                                        _res_index := 0;
                                    (*ENDIF*) 
                                    a55_describe_value (acv, dmli,
                                          dml_col_ptr^, dml_node, _res_index, NOT c_in_datapart);
                                    n_symb := _symb
                                    END
                                ELSE
                                    _describe_serial := true
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  acv.a_returncode = 0
                THEN
                    WITH dml_col_ptr^ DO
                        IF  acv.a_mblock.mb_data^.
                            mbp_buf [acv.a_mblock.mb_data_len+1] = csp_undef_byte
                        THEN
                            BEGIN
                            IF  NOT dmli.d_nullkey
                                AND
                                NOT (ctopt in ccolpropset)
                            THEN
                                BEGIN
                                a061get_colname (dml_col_ptr^,
                                      _colname);
                                IF  dml_col_ptr^.ccolstack.etype in
                                    [ st_fixkey, st_varkey ]
                                THEN
                                    a07_nb_put_error (acv,
                                          e_null_value_illegal,
                                          1, _colname)
                                ELSE
                                    a07_nb_put_error (acv,
                                          e_mandatory_field_is_null,
                                          1, _colname)
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (*ENDIF*) 
                IF  acv.a_returncode = 0
                THEN
                    BEGIN
                    IF  _lendiff = 1
                    THEN
                        acv.a_mblock.mb_data^.
                              mbp_buf [acv.a_mblock.mb_data_len] := chr(_leng)
                    ELSE
                        IF  _lendiff = 2
                        THEN
                            BEGIN
                            _ic2.map_int := _leng;
                            acv.a_mblock.mb_data^.
                                  mbp_buf [acv.a_mblock.mb_data_len-1] := _ic2.map_c2 [1];
                            acv.a_mblock.mb_data^.
                                  mbp_buf [acv.a_mblock.mb_data_len  ] := _ic2.map_c2 [2]
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    acv.a_mblock.mb_data_len := acv.a_mblock.mb_data_len + _leng;
                    IF  acv.a_ex_kind = only_parsing
                    THEN
                        BEGIN
                        dmli.d_movebefore := dmli.d_movebefore +
                              _leng + _lendiff;
                        IF  _describe_serial
                        THEN
                            BEGIN
                            _symb                   := n_symb;
                            n_symb                 := s_serial;
                            _aux_io_len             :=
                                  dml_col_ptr^.cinoutlen;
                            dml_col_ptr^.cinoutlen := -_leng;
                            a55_describe_value (acv, dmli,
                                  dml_col_ptr^, dml_node, 0, NOT c_in_datapart);
                            n_symb                 := _symb;
                            dml_col_ptr^.cinoutlen := _aux_io_len
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a55_named_values (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            VAR dfa  : tak_dfarr;
            curr_n   : integer);
 
VAR
      _joinview : boolean;
      _lo_n     : integer;
 
BEGIN
IF  dmli.d_sparr.pbasep^.sbase.btablekind = tview
THEN
    _joinview := true
ELSE
    _joinview := false;
(*ENDIF*) 
_lo_n := acv.a_ap_tree^[ curr_n ].n_lo_level;
REPEAT
    ak55set_clause (acv, dmli, dfa, _joinview, _lo_n);
    _lo_n := acv.a_ap_tree^[ _lo_n ].n_sa_level
UNTIL
    ((_lo_n = 0) OR (acv.a_returncode <> 0))
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a55_nullvalue (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            VAR dfa  : tak_dfarr);
 
VAR
      _ic2 : tsp_int_map_c2;
 
BEGIN
WITH dfa[ dmli.d_fieldno ] DO
    BEGIN
&   ifdef TRACE
    t01int4 (ak_sem, 'dm_fieldno  ', dmli.d_fieldno);
    t01int4 (ak_sem, 'dm_index    ', dml_index);
&   endif
    WITH dml_col_ptr^, ccolstack DO
        BEGIN
&       ifdef TRACE
        t01int4 (ak_sem, 'etype       ', ord(etype));
&       endif
        CASE etype OF
            st_varcol :
                IF  (acv.a_mblock.mb_type = m_insert) AND
                    (acv.a_mblock.mb_data_len + 2 > MAX_RECLEN_GG00)
                THEN
                    a07_b_put_error (acv, e_too_long_record,
                          -MAX_RECLEN_GG00)
                ELSE
                    BEGIN
                    acv.a_mblock.mb_data^.
                          mbp_buf [acv.a_mblock.mb_data_len+1] := chr(1);
                    acv.a_mblock.mb_data^.
                          mbp_buf [acv.a_mblock.mb_data_len+2] := csp_undef_byte;
                    acv.a_mblock.mb_data_len := acv.a_mblock.mb_data_len+2;
                    IF  acv.a_ex_kind = only_parsing
                    THEN
                        dmli.d_movebefore := dmli.d_movebefore + 2
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            st_fixcol :
                IF  (acv.a_mblock.mb_type = m_insert) AND
                    (acv.a_mblock.mb_data_len + elen_var > MAX_RECLEN_GG00)
                THEN
                    a07_b_put_error (acv, e_too_long_record,
                          -MAX_RECLEN_GG00)
                ELSE
                    BEGIN
                    acv.a_mblock.mb_data^.
                          mbp_buf [acv.a_mblock.mb_data_len+1] := csp_undef_byte;
                    SAPDB_PascalFill ('VAK55 ',   4,    
                          acv.a_mblock.mb_data_size,
                          @acv.a_mblock.mb_data^.mbp_buf,
                          acv.a_mblock.mb_data_len+2,
                          elen_var-1, csp_defined_byte,
                          acv.a_returncode);
                    acv.a_mblock.mb_data_len :=
                          acv.a_mblock.mb_data_len+elen_var;
                    IF  acv.a_ex_kind = only_parsing
                    THEN
                        dmli.d_movebefore := dmli.d_movebefore+elen_var
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            st_varlongchar :
                IF  (acv.a_mblock.mb_type = m_insert) AND
                    (acv.a_mblock.mb_data_len + 3 > MAX_RECLEN_GG00)
                THEN
                    a07_b_put_error (acv, e_too_long_record,
                          -MAX_RECLEN_GG00)
                ELSE
                    BEGIN
                    _ic2.map_int   := 1;
                    acv.a_mblock.mb_data^.
                          mbp_buf [acv.a_mblock.mb_data_len+1] := _ic2.map_c2 [1];
                    acv.a_mblock.mb_data^.
                          mbp_buf [acv.a_mblock.mb_data_len+2] := _ic2.map_c2 [2];
                    acv.a_mblock.mb_data_len := acv.a_mblock.mb_data_len+3;
                    acv.a_mblock.mb_data^.
                          mbp_buf [acv.a_mblock.mb_data_len] := csp_undef_byte;
                    IF  acv.a_ex_kind = only_parsing
                    THEN
                        dmli.d_movebefore := dmli.d_movebefore + 3
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            st_column :
                BEGIN
                acv.a_mblock.mb_data^.
                      mbp_buf [acv.a_mblock.mb_data_len+1] := csp_undef_byte;
                acv.a_mblock.mb_data_len := acv.a_mblock.mb_data_len+1;
                acv.a_mblock.mb_data^.mbp_rec.columnoffset_gg00 [ecolno + 1] :=
                      acv.a_mblock.mb_data_len - RSN_RECHEAD_MXGG00;
                END;
            OTHERWISE
                a07_b_put_error (acv, e_null_value_illegal,
                      dmli.d_fieldno)
            END;
        (*ENDCASE*) 
        END
    (*ENDWITH*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a55realloc_parsinfo (
            VAR acv          : tak_all_command_glob;
            VAR parsinfo_ptr : tak_sysbufferaddress);
 
CONST
      c_supplement = 20;
 
VAR
      _b_err      : tgg00_BasisError;
      _supplement : integer;
 
BEGIN
&ifdef trace
t01int4 (ak_sem, 'p_cnt_infos ',
      parsinfo_ptr^.sparsinfo.p_cnt_infos);
t01int4 (ak_sem, 'p_max_infos ',
      parsinfo_ptr^.sparsinfo.p_max_infos);
&endif
IF  parsinfo_ptr^.sparsinfo.p_cnt_infos < cak_maxparsfields
THEN
    BEGIN
    parsinfo_ptr^.b_sl := cak_sysbufferoffset + mxak_pars_header +
          parsinfo_ptr^.sparsinfo.p_max_infos *
          sizeof (parsinfo_ptr^.sparsinfo.p_pars_infos[1]);
    IF  parsinfo_ptr^.sparsinfo.p_cnt_infos + c_supplement >
        cak_maxparsfields
    THEN
        _supplement := cak_maxparsfields - parsinfo_ptr^.sparsinfo.p_cnt_infos
    ELSE
        _supplement := c_supplement;
    (*ENDIF*) 
    a10_fix_len_get_sysinfo (acv, parsinfo_ptr^.syskey,
          d_fix, cak_is_undefined,
          sizeof (parsinfo_ptr^.sparsinfo.p_pars_infos[1]) * _supplement,
          parsinfo_ptr, _b_err);
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        parsinfo_ptr^.sparsinfo.p_max_infos :=
              parsinfo_ptr^.sparsinfo.p_max_infos + _supplement;
        parsinfo_ptr^.b_sl := cak_sysbufferoffset + mxak_pars_header +
              parsinfo_ptr^.sparsinfo.p_max_infos *
              sizeof (parsinfo_ptr^.sparsinfo.p_pars_infos[1])
        END
    (*ENDIF*) 
    END
ELSE
    a07_b_put_error (acv, e_too_many_intern_parsinfos, 1)
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
