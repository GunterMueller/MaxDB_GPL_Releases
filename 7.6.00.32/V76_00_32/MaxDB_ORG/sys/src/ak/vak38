.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.tt 1 $SQL$Project Distributed Database System$VAK38$
.tt 2 $$$
.tt 3 $ThomasA$AK_data_dictionary$1999-10-07$
***********************************************************
.nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
.nf
.sp
Module  : AK_data_dictionary
=========
.sp
Purpose : Schreibt Progusageinformationen in Datei.
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a38_add_progusage (VAR acv  : tak_all_command_glob;
                    refobjtype      : tak_progusagetyp;
                    VAR refuser     : tsp00_KnlIdentifier;
                    VAR refobj1name : tsp00_KnlIdentifier;
                    VAR refobj2name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a38column_drop (
                    VAR acv         : tak_all_command_glob;
                    VAR owner       : tsp00_KnlIdentifier;
                    VAR schemaName  : tsp00_KnlIdentifier;
                    VAR table_name  : tsp00_KnlIdentifier;
                    VAR column_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a38comment_parameters (VAR acv : tak_all_command_glob;
                    VAR object_type : tak_keyword; (* always ascii *)
                    VAR object_id1  : tsp00_KnlIdentifier;
                    VAR object_id2  : tsp00_KnlIdentifier;
                    VAR object_id3  : tsp00_KnlIdentifier;
                    VAR object_id4  : tsp00_KnlIdentifier);
 
        PROCEDURE
              a38domain_drop (VAR acv : tak_all_command_glob;
                    VAR owner       : tsp00_KnlIdentifier;
                    VAR domain_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a38DropSystemTrigger (
                    VAR acv : tak_all_command_glob;
                    VAR ReplicationUser : tsp00_KnlIdentifier;
                    VAR SchemaName      : tsp00_KnlIdentifier;
                    VAR TableName       : tsp00_KnlIdentifier);
 
        PROCEDURE
              a38index_drop (VAR acv : tak_all_command_glob;
                    VAR owner       : tsp00_KnlIdentifier;
                    VAR table_name  : tsp00_KnlIdentifier;
                    VAR index_name  : tsp00_KnlIdentifier;
                    VAR column_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a38fk_drop (VAR acv : tak_all_command_glob;
                    VAR owner           : tsp00_KnlIdentifier;
                    VAR table_name      : tsp00_KnlIdentifier;
                    VAR constraint_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a38rename (VAR acv : tak_all_command_glob;
                    objtype      : integer;
                    VAR owner    : tsp00_KnlIdentifier;
                    VAR name1    : tsp00_KnlIdentifier;
                    VAR name2    : tsp00_KnlIdentifier;
                    VAR new_name : tsp00_KnlIdentifier;
                    VAR schemaId : tsp00_KnlIdentifier);
 
        PROCEDURE
              a38table_drop (VAR acv : tak_all_command_glob;
                    VAR baserec : tak_baserecord);
 
        PROCEDURE
              a38user_drop (VAR acv : tak_all_command_glob;
                    VAR user_name   : tsp00_KnlIdentifier;
                    VAR groupid     : tgg00_Surrogate;
                    usergroup       : boolean;
                    VAR ownerid     : tgg00_Surrogate;
                    uid             : tsp00_Int4);
 
        PROCEDURE
              a38insert_parameters (VAR acv : tak_all_command_glob;
                    key_prefix     : tsp00_Int4;
                    VAR objecttype : tsp00_Name;
                    VAR username   : tsp00_KnlIdentifier;
                    VAR name1      : tsp00_KnlIdentifier;
                    VAR name2      : tsp00_KnlIdentifier;
                    VAR name3      : tsp00_KnlIdentifier);
 
        PROCEDURE
              a38create_parameter_file (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a38_ausage_statement (VAR acv : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a38_call_semantic  (VAR acv : tak_all_command_glob);
 
.CM *-END-* define --------------------------------------
.sp
.cp 3
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01kw                : tak_keywordtab;
              a01_il_b_identifier  : tsp00_KnlIdentifier;
 
        PROCEDURE
              a01_next_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_get_keyword (VAR acv : tak_all_command_glob;
                    VAR index : integer;
                    VAR reserved : boolean);
 
        PROCEDURE
              a01_call_put (VAR acv : tak_all_command_glob;
                    proc     : tak_procs;
                    subproc  : tsp00_Int2;
                    VAR curr_n : tsp00_Int2);
 
        FUNCTION
              a01mandatory_keyword (VAR acv : tak_all_command_glob;
                    required_keyword : integer) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06determine_username (VAR acv : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_error (VAR acv : tak_all_command_glob;
                    err : tgg00_BasisError;
                    VAR nod1 : tsp00_Int2;
                    VAR nod2 : tsp00_Int2);
 
        PROCEDURE
              a07_b_put_error (VAR acv : tak_all_command_glob;
                    b_err : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_uni_error (VAR acv : tak_all_command_glob;
                    uni_err  : tsp8_uni_error;
                    err_code : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10_cache_delete (VAR acv : tak_all_command_glob;
                    is_rollback : boolean);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate (* ptocConst *);
                    VAR schemaName : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              Pseudo_fieldmap : VAK509;
 
        FUNCTION
              a509get_one_value (map_ptr : tsp00_MoveObjPtr;
                    value_no       : tsp00_Int2;
                    VAR value_ptr  : tsp00_MoveObjPtr;
                    VAR value_len  : tsp00_Int4;
                    VAR is_null    : boolean;
                    VAR is_default : boolean) : boolean;
 
        FUNCTION
              a509value_cnt (map_ptr : tsp00_MoveObjPtr) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1  : VBD01;
 
        PROCEDURE
              b01treset_file (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD07;
 
        PROCEDURE
              b07cadd_record (VAR t : tgg00_TransContext;
                    VAR curr : tgg00_FileId;
                    VAR b    : tak40_show_record);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01unicode        : boolean;
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17int4to_line (int : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20int4_to_buf_swap (val    : tsp00_Int4;
                    sourceswap : tsp00_SwapKind;
                    VAR dest   : tsp00_C4;
                    di         : tsp00_Int4;
                    destswap   : tsp00_SwapKind);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80: VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01int4 (debug : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01lidentifier (debug : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier);
&       endif
 
.CM *-END-* use -----------------------------------------
.sp
.cp 3
Synonym :
 
        PROCEDURE
              b07cadd_record;
 
              tgg00_Rec tak40_show_record
 
        PROCEDURE
              g17int4to_line;
 
              tsp00_Line tsp00_KnlIdentifier;
 
        PROCEDURE
              s20int4_to_buf_swap;
 
              tsp00_MoveObj tsp00_C4
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ThomasA
.sp
.cp 3
Created : 1985-01-25
.sp
.cp 3
.sp
.cp 3
Release :      Date : 1999-10-07
.sp
***********************************************************
.sp
.cp 20
.fo
.oc _/1
Specification:
 
.sp 1
.cp 12
PROZEDUR A38_ON_USAGE
.sp 1
Die Prozedur f?uhrt den Befehl 'Usage On' semantisch aus.
Im Part2 des Auftragsegments steht beim Aufruf die Beschreibung des
SQL-DB-externen Objektes (<Defobjtype>, <Defobjname1>, <Defobjname2>).
Es wird eine tempor?are Tabelle generiert, in die
die neuen Eintr?age beim Precompilerlauf ohne Logging eingetragen werden.
.sp 2
.cp 12
PROZEDUR A38_ADD_USAGE
.sp 1
Die Prozedur f?uhrt den Befehl 'Usage Add' semantisch aus.
Der Befehl bewirkt, da?z ein Record in das durch Usage On erzeugte
tempor?are File geschrieben wird. Defobjtype, Defuser, Defobjname1 und
Defobjname2 werden mit den beim Usage On ?ubergebenen Werten belegt.
Refuser wird gleich Current_Auth_Id gesetzt. Die Felder
Refobjtype, Refobjname1 und Refobjname2 m?ussen beim Aufruf in
Part2 des Auftragsegments stehen.
.sp 2
.cp 10
PROZEDUR A38_ADD_PROGUSAGE
.sp1
Mit Hilfe dieser Prozedur werden S?atze in die durch A38_ON_USAGE
generierte tempor?are Tabelle geschieben.
Immer wenn ein SQL-DB-internes Objekt beim Parsevorgang referiert
wird, wird ein Satz, der im Ref-Teil eine Beschreibung des referierten
Objektes und im Def-Teil eine Beschreibung des SQL-DB-externen Objektes
besitzt, in die tempor?are Tabelle geschrieben.
.sp 2
.cp 9
PROZEDUR A38_OFF_USAGE
.sp 1
Diese Prozedur realisiert die Semantik des Befehls 'Usage Off', der
am Ende einer erfolgreichen Precompilation stehen mu?z.
Es wird eine Stored Procedure getriggered.
.cp 15
.sp 2
.sp2
.cp 5
PROZEDUR  A38_CREATE_DROPFILE
.sp
In dieser Prozedur wird das tempor?are File generiert, in dem die
Informationen ?uber die zu l?oschenden S?atze gespeichert werden.
.sp2
.cp7
PROZEDUR  A38_USER_DROP_IN_SYSUSAGE
.sp
Mit Hilfe dieser Prozedur wird die ?ubergebene Userid als Satz in das
zuvor erzeugte tempor?are File eingef?ugt. Dies wird sp?ater in der
Prozedur a38drop_in_sysusage so interpretiert, da?z alle S?atze in
Sysusage gel?oscht werden, deren Refuser gleich der ?ubergebenen Userid
ist.
.sp2
.cp7
PROZEDUR  A38_TABLE_DROP_IN_SYSUSAGE
.sp
Mit Hilfe dieser Prozedur wird der ?ubergebene Tabellenname als Satz in
das zuvor erzeugte tempor?are File eingef?ugt. Dies wird sp?ater in der
Prozedur a38drop_in_sysusage so interpretiert, da?z alle S?atze in
Sysusage gel?oscht werden, deren Refuser gleich der ?ubergebenen Userid
und deren Refobjname1 gleich dem Tabellenname ist.
.sp2
.cp 7
PROZEDUR  A38_COLUMN_DROP_IN_SYSUSAGE
.sp
Mit Hilfe dieser Prozedur wird der ?ubergebene Spaltenname
Userid.Tablename.Columnname als Satz in
das zuvor erzeugte tempor?are File eingef?ugt. Dies wird sp?ater in der
Prozedur a38drop_in_sysusage so interpretiert, da?z alle S?atze in
Sysusage gel?oscht werden, deren Refuser gleich der ?ubergebenen Userid
und deren Refobjname1 gleich dem Tabellenname und deren Refobjname2.
gleich dem Spaltennamen ist.
.sp 2
.cp 7
PROZEDUR  A38DROP_IN_SYSUSAGE
.sp
Diese Prozedur liest alle in der tempor?aren Datei gespeicherten
Qualifikationen gelesen und baut mit diesen Informationen den Message-
Buffer so auf, das am Ende mit einem Delete_qual alle zu l?oschenden
S?atze aus Sysusage gel?oscht werden.
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_is_rollback      = true;
      shinfooffset       = cgg_rec_key_offset + mxsp_c4;
      ln_domain          = 'DOMAIN            ';
      ln_file            = 'FILE              ';
      ln_foreign_key     = 'FOREIGN KEY       ';
      ln_multiindex      = 'MULT IND          ';
      ln_procedure       = 'PROCEDURE         ';
      ln_synonym         = 'SYNONYM           ';
      ln_view            = 'VIEW              ';
 
 
(*------------------------------*) 
 
PROCEDURE
      a38_ausage_statement (VAR acv : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      curr_n : tsp00_Int2;
      last_n : tsp00_Int2;
      index  : integer;
      res_kw : boolean;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_return_segm^.sp1r_function_code := csp1_usage_fc;
    a01_call_put (acv, a38, cak_i_usage, curr_n);
    put_node := curr_n;
    a01_next_symbol (acv);
    a01_get_keyword (acv, index, res_kw);
    CASE index OF
        cak_i_add, cak_i_off, cak_i_on :
            BEGIN
            a01_call_put (acv, a38, index, last_n);
            a_ap_tree^[last_n].n_length   := 0;
            a_ap_tree^[curr_n].n_sa_level := last_n;
            a01_next_symbol (acv);
            IF  (index = cak_i_on) AND (sc_symb <> s_eof)
            THEN
                IF  a01mandatory_keyword (acv, cak_i_except)
                THEN
                    IF  a01mandatory_keyword (acv, cak_i_trigger)
                    THEN
                        a_ap_tree^[last_n].n_length := cak_i_except
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        OTHERWISE
            a07_error (acv, e_wanted_keyword, put_node, last_n);
        END;
    (*ENDCASE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a38_call_semantic  (VAR acv : tak_all_command_glob);
 
BEGIN
(* we NEED this statement as long as the precompiler *)
(* has the check-option to specifiy that during      *)
(* parse the resultset-info has to be prepared with  *)
(* its name and not with the parsid as identification*)
(* and we need the file for storing some info for    *)
(* ddl-trigger                                       *)
WITH acv  DO
    IF  a_returncode = 0
    THEN
        IF  a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc = cak_i_usage
        THEN
            CASE a_ap_tree^[ 2 ].n_subproc OF
                cak_i_on :
                    ak38on_usage (acv,
                          a_ap_tree^[2].n_length = cak_i_except);
                cak_i_off :
                    ak38off_usage (acv);
                cak_i_add :
                    BEGIN
                    (* noop *)
                    END;
                OTHERWISE
                    a07_b_put_error (acv, e_invalid_command, 1)
                END
            (*ENDCASE*) 
        ELSE
            a07_b_put_error (acv, e_invalid_command, 1)
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak38off_usage (VAR acv : tak_all_command_glob);
 
BEGIN
IF  acv.a_progusage_add
THEN
    BEGIN
    a10_cache_delete (acv, NOT c_is_rollback);
    acv.a_progusage_add := false;
    IF  acv.a_usage_curr.fileRoot_gg00 <> NIL_PAGE_NO_GG00
    THEN
        acv.a_init_ddl := ddl_usage_off
    (*ENDIF*) 
    END
ELSE
    a07_b_put_error (acv, e_invalid_command, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak38on_usage  (VAR acv : tak_all_command_glob;
            without_trigger : boolean);
 
VAR
      pos         : integer;
      param_index : integer;
      param_count : integer;
      key_prefix  : tsp00_Int4;
      ilen        : tsp00_Int4;
      objtype     : tsp00_Name;
      parameter   : ARRAY [ 1..3 ] OF tsp00_KnlIdentifier;
      err_char_no : tsp00_Int4;
      uni_err     : tsp8_uni_error;
      ident_len   : integer;
      value_ptr   : tsp00_MoveObjPtr;
      value_len   : tsp00_Int4;
      is_null     : boolean;
      is_default  : boolean;
 
BEGIN
WITH acv DO
    BEGIN
    ident_len := sizeof (tsp00_KnlIdentifier);
    IF  a_variable_input
    THEN
        param_count := a509value_cnt (a_input_data_map) - 1
    ELSE
        param_count := (a_data_length - mxsp_c8 - csp_attr_byte)
              DIV (ident_len + csp_attr_byte);
    (*ENDIF*) 
    IF  (param_count >= 1) AND (param_count <= 3)
    THEN
        BEGIN
        pos     := 2;
        objtype := bsp_name;
        IF  a_variable_input
        THEN
            BEGIN
            IF  a509get_one_value (a_input_data_map, 1,
                value_ptr, value_len, is_null, is_default)
            THEN
                SAPDB_PascalMove ('VAK38 ',   1,    
                      a_data_length, sizeof (objtype),
                      @value_ptr^, 1, @objtype, 1, value_len,
                      a_returncode);
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            SAPDB_PascalMove ('VAK38 ',   2,    
                  a_data_length, sizeof (objtype),
                  @a_data_ptr^, pos, @objtype, 1, mxsp_c8,
                  a_returncode);
            pos     := pos + mxsp_c8 + csp_attr_byte;
            END;
        (*ENDIF*) 
        FOR param_index := 1 TO 3 DO
            parameter[ param_index ] := a01_il_b_identifier;
        (*ENDFOR*) 
        param_index := 1;
        WHILE (param_index <= param_count) AND
              (a_returncode = 0) DO
            BEGIN
            IF  g01unicode
            THEN
                BEGIN
                ilen := ident_len;
                IF  a_variable_input
                THEN
                    BEGIN
                    IF  a509get_one_value (a_input_data_map, param_index+1,
                        value_ptr, value_len, is_null, is_default)
                    THEN
                        BEGIN
                        s80uni_trans (value_ptr, value_len,
                              a_cmd_packet_header.sp1h_mess_code,
                              @parameter[ param_index ], ilen, csp_unicode,
                              [ ], uni_err, err_char_no);
                        IF  (uni_err <> uni_ok) AND
                            (uni_err <> uni_dest_too_short)
                        THEN
                            a07_uni_error (acv, uni_err,
                                  param_index+1)
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    s80uni_trans (@a_data_ptr^[ pos ], ident_len,
                          a_cmd_packet_header.sp1h_mess_code,
                          @parameter[ param_index ], ilen, csp_unicode,
                          [ ], uni_err, err_char_no);
                    IF  (uni_err <> uni_ok) AND
                        (uni_err <> uni_dest_too_short)
                    THEN
                        a07_uni_error (acv, uni_err,
                              pos-2+err_char_no)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  a_variable_input
                THEN
                    BEGIN
                    IF  a509get_one_value (a_input_data_map, param_index+1,
                        value_ptr, value_len, is_null, is_default)
                    THEN
                        SAPDB_PascalMove ('VAK38 ',   3,    
                              a_data_length, sizeof (parameter[param_index]),
                              @value_ptr^, 1, @parameter[ param_index ], 1, value_len,
                              a_returncode);
                    (*ENDIF*) 
                    END
                ELSE
                    SAPDB_PascalMove ('VAK38 ',   4,    
                          a_data_length, sizeof (parameter[param_index]),
                          @a_data_ptr^, pos, @parameter[ param_index ], 1,
                          ident_len, a_returncode)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            pos         := pos + ident_len + csp_attr_byte;
            param_index := succ (param_index)
            END;
        (*ENDWHILE*) 
        IF  NOT without_trigger
        THEN
            BEGIN
            (* create temporary file for usage information *)
            a38create_parameter_file (acv);
            IF  a_returncode = 0
            THEN (* store defobject in parameter file *)
                BEGIN
                key_prefix := 0;
                a38insert_parameters (acv, key_prefix,
                      objtype, a_curr_user_name,
                      parameter[1], parameter[2], parameter [3]);
                END;
            (*ENDIF*) 
            END
        ELSE
            a_usage_curr.fileRoot_gg00 := NIL_PAGE_NO_GG00;
        (*ENDIF*) 
        a_progusage_add := a_returncode = 0
        END
    ELSE
        IF  param_count < 1
        THEN
            a07_b_put_error (acv, e_too_few_values, a_data_length)
        ELSE
            a07_b_put_error (acv, e_too_many_values, a_data_length)
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a38create_parameter_file (VAR acv : tak_all_command_glob);
 
BEGIN
acv.a_show_data_cnt            := 0;
acv.a_usage_curr.fileRoot_gg00 := NIL_PAGE_NO_GG00;
b01treset_file (acv.a_transinf.tri_trans, acv.a_usage_curr);
IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
THEN
    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a38insert_parameters (VAR acv : tak_all_command_glob;
            key_prefix     : tsp00_Int4;
            VAR objecttype : tsp00_Name;
            VAR username   : tsp00_KnlIdentifier;
            VAR name1      : tsp00_KnlIdentifier;
            VAR name2      : tsp00_KnlIdentifier;
            VAR name3      : tsp00_KnlIdentifier);
 
VAR
      pos         : integer;
      action      : integer;
      name4       : tsp00_KnlIdentifier;
      show_buf    : tak40_show_record;
 
BEGIN
name4 := bsp_knl_identifier;
IF  NOT acv.a_in_ddl_trigger AND
    (acv.a_usage_curr.fileRoot_gg00 <> NIL_PAGE_NO_GG00)
THEN
    BEGIN
    (*============  construct key ============*)
    s20int4_to_buf_swap (key_prefix, sw_normal, show_buf.shkey, 1, sw_normal);
    pos := 1;
    SAPDB_PascalMove ('VAK38 ',   5,    
          sizeof(objecttype), sizeof(show_buf.shinfo),
          @objecttype, 1,
          @show_buf.shinfo, pos, sizeof (objecttype),
          acv.a_returncode);
    pos := pos + sizeof (objecttype);
    SAPDB_PascalMove ('VAK38 ',   6,    
          sizeof(username), sizeof(show_buf.shinfo),
          @username, 1,
          @show_buf.shinfo, pos, sizeof(username),
          acv.a_returncode);
    pos := pos + sizeof (username);
    SAPDB_PascalMove ('VAK38 ',   7,    
          sizeof(name1), sizeof(show_buf.shinfo),
          @name1, 1,
          @show_buf.shinfo, pos, sizeof(name1),
          acv.a_returncode);
    pos := pos + sizeof (name1);
    SAPDB_PascalMove ('VAK38 ',   8,    
          sizeof(name2), sizeof(show_buf.shinfo),
          @name2, 1,
          @show_buf.shinfo, pos, sizeof(name2),
          acv.a_returncode);
    pos            := pos + sizeof (name2);
    show_buf.shkl  := mxsp_c4 + pos - 1;
    (*============  construct info part ============*)
    show_buf.shinfo [pos] := bsp_c1;
    IF  key_prefix = 0
    THEN
        action := cak_i_usage
    ELSE
        action := cak_i_add;
    (*ENDIF*) 
    SAPDB_PascalMove ('VAK38 ',   9,    
          sizeof(a01kw[action]), sizeof(show_buf.shinfo),
          @a01kw[action], 1,
          @show_buf.shinfo, pos + 1, sizeof(a01kw[action]),
          acv.a_returncode);
    pos := pos + sizeof (a01kw[action]) + 1;
    show_buf.shinfo [ pos ] := bsp_c1;
    SAPDB_PascalMove ('VAK38 ',  10,    
          sizeof(objecttype), sizeof(show_buf.shinfo),
          @objecttype, 1,
          @show_buf.shinfo, pos+1, sizeof(objecttype),
          acv.a_returncode);
    pos := pos + sizeof (objecttype) + 1;
    IF  g01unicode
    THEN
        show_buf.shinfo [ pos ] := csp_unicode_def_byte
    ELSE
        show_buf.shinfo [ pos ] := bsp_c1;
    (*ENDIF*) 
    SAPDB_PascalMove ('VAK38 ',  11,    
          sizeof(username), sizeof(show_buf.shinfo),
          @username, 1,
          @show_buf.shinfo, pos+1, sizeof(username),
          acv.a_returncode);
    pos := pos + sizeof (username) + 1;
    IF  g01unicode
    THEN
        show_buf.shinfo [ pos ] := csp_unicode_def_byte
    ELSE
        show_buf.shinfo [ pos ] := bsp_c1;
    (*ENDIF*) 
    SAPDB_PascalMove ('VAK38 ',  12,    
          sizeof(name1), sizeof(show_buf.shinfo),
          @name1, 1,
          @show_buf.shinfo, pos+1, sizeof(name1),
          acv.a_returncode);
    pos := pos + sizeof (name1) + 1;
    IF  g01unicode
    THEN
        show_buf.shinfo [ pos ] := csp_unicode_def_byte
    ELSE
        show_buf.shinfo [ pos ] := bsp_c1;
    (*ENDIF*) 
    SAPDB_PascalMove ('VAK38 ',  13,    
          sizeof(name2), sizeof(show_buf.shinfo),
          @name2, 1,
          @show_buf.shinfo, pos+1, sizeof(name2),
          acv.a_returncode);
    pos := pos + sizeof (name2) + 1;
    IF  g01unicode
    THEN
        show_buf.shinfo [ pos ] := csp_unicode_def_byte
    ELSE
        show_buf.shinfo [ pos ] := bsp_c1;
    (*ENDIF*) 
    SAPDB_PascalMove ('VAK38 ',  14,    
          sizeof(name3), sizeof(show_buf.shinfo),
          @name3, 1,
          @show_buf.shinfo, pos+1, sizeof(name3),
          acv.a_returncode);
    pos            := pos + sizeof (name3) + 1;
    IF  g01unicode
    THEN
        show_buf.shinfo [ pos ] := csp_unicode_def_byte
    ELSE
        show_buf.shinfo [ pos ] := bsp_c1;
    (*ENDIF*) 
    SAPDB_PascalMove ('VAK38 ',  15,    
          sizeof(name4), sizeof(show_buf.shinfo),
          @name4, 1,
          @show_buf.shinfo, pos+1, sizeof(name4),
          acv.a_returncode);
    pos            := pos + sizeof (name4) + 1;
    show_buf.shsl  := pos + shinfooffset - 1;
    show_buf.shvarcol_offset := 0;
    show_buf.shvarcol_cnt    := 0;
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        b07cadd_record (acv.a_transinf.tri_trans,
              acv.a_usage_curr, show_buf);
        IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
        THEN
            acv.a_show_data_cnt := succ(acv.a_show_data_cnt)
        ELSE
            IF  acv.a_transinf.tri_trans.trError_gg00 <> e_duplicate_key
            THEN
                a07_b_put_error (acv,
                      acv.a_transinf.tri_trans.trError_gg00, 1)
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a38_add_progusage (VAR acv  : tak_all_command_glob;
            refobjtype      : tak_progusagetyp;
            VAR refuser     : tsp00_KnlIdentifier;
            VAR refobj1name : tsp00_KnlIdentifier;
            VAR refobj2name : tsp00_KnlIdentifier);
 
VAR
      key_prefix   : tsp00_Int4;
      objtype      : tsp00_Name;
 
BEGIN
WITH acv  DO
    IF  (a_returncode = 0) AND a_progusage_add
    THEN
        BEGIN
        key_prefix := 1;
        CASE refobjtype  OF
            p_column :
                objtype := cak_ln_column;
            p_domain :
                objtype := ln_domain;
            p_foreign_key :
                objtype := ln_foreign_key;
            p_file :
                objtype := ln_file;
            p_index :
                objtype := ln_multiindex;
            p_procedure :
                objtype := ln_procedure;
            p_synonym :
                objtype := ln_synonym;
            p_table :
                objtype := cak_ln_table;
            p_user  :
                objtype := cak_ln_user;
            p_view   :
                objtype := ln_view;
            OTHERWISE
                BEGIN
                (* key_prefix := 0; *)
                objtype    := bsp_name;
                SAPDB_PascalMove ('VAK38 ',  16,    
                      a_data_length, sizeof(objtype),
                      @a_data_ptr^, 2, @objtype, 1, mxsp_c8,
                      a_returncode)
                END;
            END;
        (*ENDCASE*) 
        IF  a_returncode = 0
        THEN
            a38insert_parameters (acv, key_prefix, objtype,
                  refuser, refobj1name, refobj2name, a01_il_b_identifier)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak38store_parameters (VAR acv : tak_all_command_glob;
            action         : integer;
            VAR objecttype : tak_keyword;
            VAR username   : tsp00_KnlIdentifier;
            VAR name1      : tsp00_KnlIdentifier;
            VAR name2      : tsp00_KnlIdentifier;
            VAR name3      : tsp00_KnlIdentifier;
            VAR name4      : tsp00_KnlIdentifier);
 
VAR
      def_byte    : char;
      pos         : integer;
      show_buf    : tak40_show_record;
 
BEGIN
IF  NOT acv.a_in_ddl_trigger AND
    NOT acv.a_progusage_add
THEN
    BEGIN
&   ifdef trace
    t01lidentifier (ak_sem, username);
    t01lidentifier (ak_sem, name1);
    t01lidentifier (ak_sem, name2);
    t01lidentifier (ak_sem, name3);
    t01lidentifier (ak_sem, name4);
&   endif
    IF  acv.a_usage_curr.fileRoot_gg00 = NIL_PAGE_NO_GG00
    THEN
        a38create_parameter_file (acv);
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        (*============  construct key ============*)
        s20int4_to_buf_swap (acv.a_show_data_cnt,
              sw_normal, show_buf.shkey, 1, sw_normal);
        show_buf.shkl  := mxsp_c4;
        (*============  construct info part ============*)
        show_buf.shinfo [1] := bsp_c1;
        SAPDB_PascalMove ('VAK38 ',  17,    
              sizeof(a01kw[action]), sizeof(show_buf.shinfo),
              @a01kw[action], 1,
              @show_buf.shinfo, 2, sizeof(a01kw[action]),
              acv.a_returncode);
        pos := 1 + sizeof (a01kw[action]) + 1;
        show_buf.shinfo [ pos ] := bsp_c1;
        SAPDB_PascalMove ('VAK38 ',  18,    
              sizeof(objecttype), sizeof(show_buf.shinfo),
              @objecttype, 1,
              @show_buf.shinfo, pos+1, sizeof(objecttype),
              acv.a_returncode);
        pos := pos + sizeof (objecttype) + 1;
        IF  g01unicode
        THEN
            def_byte := csp_unicode_def_byte
        ELSE
            def_byte := bsp_c1;
        (*ENDIF*) 
        show_buf.shinfo [ pos ] := def_byte;
        SAPDB_PascalMove ('VAK38 ',  19,    
              sizeof(username), sizeof(show_buf.shinfo),
              @username, 1,
              @show_buf.shinfo, pos+1, sizeof(username),
              acv.a_returncode);
        pos := pos + sizeof (username) + 1;
        show_buf.shinfo [ pos ] := def_byte;
        SAPDB_PascalMove ('VAK38 ',  20,    
              sizeof(name1), sizeof(show_buf.shinfo),
              @name1, 1,
              @show_buf.shinfo, pos+1, sizeof(name1),
              acv.a_returncode);
        pos := pos + sizeof (name1) + 1;
        show_buf.shinfo [ pos ] := def_byte;
        SAPDB_PascalMove ('VAK38 ',  21,    
              sizeof(name2), sizeof(show_buf.shinfo),
              @name2, 1,
              @show_buf.shinfo, pos+1, sizeof(name2),
              acv.a_returncode);
        pos := pos + sizeof (name2) + 1;
        show_buf.shinfo [ pos ] := def_byte;
        SAPDB_PascalMove ('VAK38 ',  22,    
              sizeof(name3), sizeof(show_buf.shinfo),
              @name3, 1,
              @show_buf.shinfo, pos+1, sizeof(name3),
              acv.a_returncode);
        pos := pos + sizeof (name3) + 1;
        show_buf.shinfo [ pos ] := def_byte;
        (* PTS 1132495 M.Ki. *)
        SAPDB_PascalMove ('VAK38 ',  23,    
              sizeof(name4), sizeof(show_buf.shinfo),
              @name4, 1,
              @show_buf.shinfo, pos+1, sizeof(name4),
              acv.a_returncode);
        pos            := pos + sizeof (name4) + 1;
        show_buf.shsl  := pos + shinfooffset - 1;
        show_buf.shvarcol_offset := 0;
        show_buf.shvarcol_cnt    := 0;
        END;
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        b07cadd_record (acv.a_transinf.tri_trans,
              acv.a_usage_curr, show_buf);
        IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
        THEN
            acv.a_show_data_cnt := succ(acv.a_show_data_cnt)
        ELSE
            a07_b_put_error (acv,
                  acv.a_transinf.tri_trans.trError_gg00, 1)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a38column_drop (
            VAR acv         : tak_all_command_glob;
            VAR owner       : tsp00_KnlIdentifier;
            VAR schemaName  : tsp00_KnlIdentifier;
            VAR table_name  : tsp00_KnlIdentifier;
            VAR column_name : tsp00_KnlIdentifier);
 
BEGIN
ak38store_parameters (acv, cak_i_drop, a01kw[cak_i_column],
      owner, table_name, column_name, a01_il_b_identifier, schemaName)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a38comment_parameters (VAR acv : tak_all_command_glob;
            VAR object_type : tak_keyword; (*always ascii *)
            VAR object_id1  : tsp00_KnlIdentifier;
            VAR object_id2  : tsp00_KnlIdentifier;
            VAR object_id3  : tsp00_KnlIdentifier;
            VAR object_id4  : tsp00_KnlIdentifier);
 
BEGIN
ak38store_parameters (acv, cak_i_comment,
      object_type, object_id1, object_id2, object_id3, object_id4,
      a01_il_b_identifier)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a38domain_drop (VAR acv : tak_all_command_glob;
            VAR owner       : tsp00_KnlIdentifier;
            VAR domain_name : tsp00_KnlIdentifier);
 
BEGIN
ak38store_parameters (acv, cak_i_drop,
      a01kw[cak_i_domain], owner, domain_name, a01_il_b_identifier,
      a01_il_b_identifier, a01_il_b_identifier)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a38DropSystemTrigger (
            VAR acv : tak_all_command_glob;
            VAR ReplicationUser : tsp00_KnlIdentifier;
            VAR SchemaName      : tsp00_KnlIdentifier;
            VAR TableName       : tsp00_KnlIdentifier);
 
BEGIN
ak38store_parameters (acv, cak_i_drop,
      a01kw[cak_i_trigger], ReplicationUser, SchemaName, TableName,
      a01_il_b_identifier, a01_il_b_identifier)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a38index_drop (VAR acv : tak_all_command_glob;
            VAR owner       : tsp00_KnlIdentifier;
            VAR table_name  : tsp00_KnlIdentifier;
            VAR index_name  : tsp00_KnlIdentifier;
            VAR column_name : tsp00_KnlIdentifier);
 
BEGIN
ak38store_parameters (acv, cak_i_drop,
      a01kw[cak_i_index], owner, table_name, column_name, index_name, a01_il_b_identifier)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a38fk_drop (VAR acv : tak_all_command_glob;
            VAR owner           : tsp00_KnlIdentifier;
            VAR table_name      : tsp00_KnlIdentifier;
            VAR constraint_name : tsp00_KnlIdentifier);
 
BEGIN
ak38store_parameters (acv, cak_i_drop,
      a01kw[cak_i_foreign], owner, table_name, constraint_name,
      a01_il_b_identifier, a01_il_b_identifier)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a38table_drop (VAR acv : tak_all_command_glob;
            VAR baserec : tak_baserecord);
 
VAR
      objtype     : integer;
      owner       : tsp00_KnlIdentifier;
      schemaName  : tsp00_KnlIdentifier;
      syn_ptr     : ^tak_synonymrecord;
      ownerid_ptr : ^tgg00_Surrogate;
      tabname_ptr : tsp00_KnlIdentifierPtr;
 
BEGIN
schemaName := a01_il_b_identifier;
IF  baserec.btablekind = tsynonym
THEN
    BEGIN
    syn_ptr     := @baserec;
    ownerid_ptr := @syn_ptr^.syn_owner; (* PTS 1104114 *)
    tabname_ptr := @syn_ptr^.syn_tablen
    END
ELSE
    BEGIN
    ownerid_ptr := @baserec.bauthid; (* PTS 1104114 *)
    tabname_ptr := baserec.btablen;
    a103GetSchemaName (acv, baserec.bschema, schemaName); (*PTS 1132495 M.Ki.*)
    END;
(*ENDIF*) 
CASE baserec.btablekind OF
    tsynonym :
        objtype := cak_i_synonym;
    twithkey, twithoutkey :
        objtype := cak_i_table;
    tonebase, tview, tcomplexview :
        objtype := cak_i_view;
    (* PTS 1111576 E.Z. *)
    OTHERWISE
        objtype := cak_i_no_keyword;
    END;
(*ENDCASE*) 
IF  objtype <> cak_i_no_keyword
THEN
    BEGIN
    a06determine_username (acv, ownerid_ptr^, owner); (* PTS 1104114 *)
    ak38store_parameters (acv, cak_i_drop, a01kw[objtype],
          owner, tabname_ptr^, a01_il_b_identifier,
          a01_il_b_identifier, schemaName)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a38user_drop (VAR acv : tak_all_command_glob;
            VAR user_name   : tsp00_KnlIdentifier;
            VAR groupid     : tgg00_Surrogate;
            usergroup       : boolean;
            VAR ownerid     : tgg00_Surrogate;
            uid             : tsp00_Int4);
 
VAR
      objecttype  : integer;
      group_name  : tsp00_KnlIdentifier;
      owner_name  : tsp00_KnlIdentifier;
      char_uid    : tsp00_KnlIdentifier;
      help_ident  : tsp00_KnlIdentifier;
      i           : integer;
 
BEGIN
IF  usergroup
THEN
    objecttype := cak_i_usergroup
ELSE
    objecttype := cak_i_user;
(*ENDIF*) 
IF  groupid = cgg_zero_id
THEN
    group_name := a01_il_b_identifier
ELSE
    a06determine_username (acv, groupid, group_name);
(*ENDIF*) 
a06determine_username (acv, ownerid, owner_name);
char_uid := a01_il_b_identifier;
g17int4to_line (uid,false, 10, 1, char_uid);
IF  g01unicode
THEN
    BEGIN
    help_ident := char_uid;
    char_uid   := a01_il_b_identifier;
    FOR i := 1 TO 10 DO
        char_uid [i*2] := help_ident [i];
    (*ENDFOR*) 
    END;
(*ENDIF*) 
ak38store_parameters (acv, cak_i_drop,
      a01kw[objecttype], owner_name, user_name, group_name, char_uid, a01_il_b_identifier);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a38rename (VAR acv : tak_all_command_glob;
            objtype      : integer;
            VAR owner    : tsp00_KnlIdentifier;
            VAR name1    : tsp00_KnlIdentifier;
            VAR name2    : tsp00_KnlIdentifier;
            VAR new_name : tsp00_KnlIdentifier;
            VAR schemaId : tsp00_KnlIdentifier);
 
BEGIN
IF  objtype <> cak_i_column
THEN
    ak38store_parameters (acv, cak_i_rename,
          a01kw[objtype], owner, name1, new_name, name2, schemaId)
ELSE
    ak38store_parameters (acv, cak_i_rename,
          a01kw[cak_i_column], owner, name1, name2, new_name, schemaId)
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
