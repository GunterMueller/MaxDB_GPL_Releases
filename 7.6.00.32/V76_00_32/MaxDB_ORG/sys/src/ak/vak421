.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK421$
.tt 2 $$$
.TT 3 $ElkeZ$AK_show_sysmon$2000-03-23$
***********************************************************
.nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
.nf
.sp
MODULE  : AK_show_sysmon
=========
.sp
Purpose : AK_show_sysmon
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a421connection (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a421region (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a421storage (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a421ioaccess (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a421backupioaccess (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a421spec_thread (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a421ukthread (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a421deviothread (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a421task (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a421task_detail (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a421totalcount (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a421spinlocks (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              AK_universal_show_tools : VAK40;
 
        PROCEDURE
              a40get_catalog_table (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a40move_const (VAR acv  : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : integer);
 
        PROCEDURE
              a40move_counter (VAR acv : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    val           : tsp00_8ByteCounter;
                    is_null       : boolean;
                    frac          : integer;
                    zero_to_undef : boolean);
 
        PROCEDURE
              a40move_i4 (VAR acv : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    i4_val        : tsp00_Int4;
                    is_null       : boolean;
                    frac          : integer;
                    zero_to_undef : boolean);
 
        PROCEDURE
              a40move_real (VAR acv : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    val           : tsp00_Longreal;
                    is_null       : boolean;
                    frac          : integer);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        FUNCTION
              vGetRteInfoBackupFirst (VAR RteBackupInfo : tsp92_RteBackupInfo) : boolean;
 
        FUNCTION
              vGetRteInfoBackupNext (VAR RteBackupInfo : tsp92_RteBackupInfo) : boolean;
 
        FUNCTION
              vGetRteInfoIODetailsFirst (VAR RteIODetailsInfo : tsp92_RteIODetailsInfo) : boolean;
 
        FUNCTION
              vGetRteInfoIODetailsNext (VAR RteIODetailsInfo : tsp92_RteIODetailsInfo) : boolean;
 
        FUNCTION
              vGetRteInfoIOFirst (VAR RteIOInfo : tsp92_RteIOInfo) : boolean;
 
        FUNCTION
              vGetRteInfoIONext (VAR RteIOInfo : tsp92_RteIOInfo) : boolean;
 
        FUNCTION
              vGetRteInfoRegionFirst (VAR RteRegionInfo : tsp92_RteRegionInfo) : boolean;
 
        FUNCTION
              vGetRteInfoRegionNext (VAR RteRegionInfo : tsp92_RteRegionInfo) : boolean;
 
        FUNCTION
              vGetRteInfoSpecThreadsFirst (VAR RteSpecThreadsInfo : tsp92_RteSpecThreadsInfo) : boolean;
 
        FUNCTION
              vGetRteInfoSpecThreadsNext (VAR RteSpecThreadsInfo : tsp92_RteSpecThreadsInfo) : boolean;
 
        FUNCTION
              vGetRteInfoStorageFirst (VAR RteStorageInfo : tsp92_RteStorageInfo) : boolean;
 
        FUNCTION
              vGetRteInfoStorageNext (VAR RteStorageInfo : tsp92_RteStorageInfo) : boolean;
 
        FUNCTION
              vGetRteInfoTaskDetailsFirst (VAR RteTaskDetailsInfo : tsp92_RteTaskDetailsInfo) : boolean;
 
        FUNCTION
              vGetRteInfoTaskDetailsNext (VAR RteTaskDetailsInfo : tsp92_RteTaskDetailsInfo) : boolean;
 
        FUNCTION
              vGetRteInfoTaskFirst (VAR RteTaskInfo : tsp92_RteTaskInfo;
                    StateToShow : tsp92_RteTaskInfoStateToShow ;
                    TypeToShow  : tsp92_RteTaskInfoTypeToShow ) : boolean;
 
        FUNCTION
              vGetRteInfoTaskNext (VAR RteTaskInfo : tsp92_RteTaskInfo) : boolean;
 
        PROCEDURE
              vGetRteInfoTotalCnt (VAR RteTotalCntInfo  : tsp92_RteTotalCntInfo);
 
        FUNCTION
              vGetRteInfoUKTFirst (VAR RteUKTInfo : tsp92_RteUKTInfo) : boolean;
 
        FUNCTION
              vGetRteInfoUKTNext (VAR RteUKTInfo : tsp92_RteUKTInfo) : boolean;
 
        FUNCTION
              vGetRteInfoSpinlockFirst (VAR RteSpinlockInfo : tsp92_RteSpinlockInfo) : boolean;
 
        FUNCTION
              vGetRteInfoSpinlockNext (VAR RteSpinlockInfo : tsp92_RteSpinlockInfo) : boolean;
 
        FUNCTION
              vGetRteInfoConnectionFirst (VAR RteConnectionInfo : tsp92_RteConnectionInfo) : boolean;
 
        FUNCTION
              vGetRteInfoConnectionNext (VAR RteConnectionInfo : tsp92_RteConnectionInfo) : boolean;
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ElkeZ
.sp
.cp 3
Created : 2000-01-24
.sp
.cp 3
Version : 2002-04-11
.sp
.cp 3
Release :      Date : 2000-03-23
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.sp 4
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_is_null       = true;
      c_zero_to_undef = true;
      cak421time_frac = 4;
      (* PTS 1114549 E.Z. *)
 
 
(*------------------------------*) 
 
PROCEDURE
      a421connection (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      RteConnectionInfo   : tsp92_RteConnectionInfo;
      ConnectionInfoFound : boolean;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    a40get_catalog_table (acv, a41v);
(*ENDIF*) 
ConnectionInfoFound := true;
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    IF  vGetRteInfoConnectionFirst (RteConnectionInfo)
    THEN
        REPEAT
            (* loop has to be done until ..Next results in false.
                  Then implicit unlock of registry will be made *)
            IF  acv.a_returncode = 0
            THEN
                WITH RteConnectionInfo DO
                    BEGIN
                    a40move_i4 (acv, a41v, TaskIndex,
                          NOT c_is_null, 0, NOT c_zero_to_undef);
                    a40move_i4 (acv, a41v, UKTId,
                          NOT c_is_null, 0, NOT c_zero_to_undef);
                    a40move_i4 (acv, a41v, ApplPid,
                          NOT c_is_null, 0, NOT c_zero_to_undef);
                    a40move_i4 (acv, a41v, PeerPid,
                          NOT c_is_null, 0, NOT c_zero_to_undef);
                    a40move_const (acv, a41v, @TaskName, sizeof(TaskName));
                    a40move_const (acv, a41v, @ConnectState, sizeof(ConnectState));
                    a40move_const (acv, a41v, @ConnectTime, sizeof(ConnectTime));
                    a40move_const (acv, a41v, @RemoteApplNode, sizeof(RemoteApplNode));
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            ConnectionInfoFound := vGetRteInfoConnectionNext (RteConnectionInfo);
        UNTIL
            (NOT ConnectionInfoFound);
        (*ENDREPEAT*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(* PTS 1109404 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a421spinlocks (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      RteSpinlockInfo   : tsp92_RteSpinlockInfo;
      SpinlockInfoFound : boolean;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    a40get_catalog_table (acv, a41v);
(*ENDIF*) 
SpinlockInfoFound := true;
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    IF  vGetRteInfoSpinlockFirst (RteSpinlockInfo)
    THEN
        REPEAT
            WITH RteSpinlockInfo DO
                BEGIN
                a40move_const (acv, a41v, @SpinlockName, sizeof(SpinlockName));
                a40move_counter (acv, a41v, Locks,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_counter (acv, a41v, Collisions,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_i4 (acv, a41v, TotalSpinLoops,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_i4 (acv, a41v, TotalYieldLoops,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_i4 (acv, a41v, MaxSpinLoops,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_i4 (acv, a41v, MaxYieldLoops,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_i4 (acv, a41v, CurrentLoops,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                END;
            (*ENDWITH*) 
            SpinlockInfoFound := vGetRteInfoSpinlockNext (RteSpinlockInfo);
        UNTIL
            (NOT SpinlockInfoFound) OR (acv.a_returncode <> 0);
        (*ENDREPEAT*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a421region (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      RteRegionInfo   : tsp92_RteRegionInfo;
      RegionInfoFound : boolean;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    a40get_catalog_table (acv, a41v);
(*ENDIF*) 
RegionInfoFound := true;
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    IF  vGetRteInfoRegionFirst (RteRegionInfo)
    THEN
        REPEAT
            WITH RteRegionInfo DO
                BEGIN
                a40move_i4 (acv, a41v, RegionNo,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_const (acv, a41v, @RegionName, sizeof(RegionName));
                IF  OwnerTaskIndex = -1
                THEN
                    a40move_i4 (acv, a41v, OwnerTaskIndex,
                          c_is_null, 0, NOT c_zero_to_undef)
                ELSE
                    a40move_i4 (acv, a41v, OwnerTaskIndex,
                          NOT c_is_null, 0, NOT c_zero_to_undef);
                (*ENDIF*) 
                IF  WaitTaskIndex = -1
                THEN
                    a40move_i4 (acv, a41v, WaitTaskIndex,
                          c_is_null, 0, NOT c_zero_to_undef)
                ELSE
                    a40move_i4 (acv, a41v, WaitTaskIndex,
                          NOT c_is_null, 0, NOT c_zero_to_undef);
                (*ENDIF*) 
                a40move_counter (acv, a41v, GetCount,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_counter (acv, a41v, TasCount,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_counter (acv, a41v, CollisionCount,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_real (acv, a41v, CollisionRate,
                      NOT c_is_null, 2);
                a40move_counter (acv, a41v, WaitCount,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                IF  Exclusive = -1
                THEN
                    a40move_i4 (acv, a41v, Exclusive,
                          c_is_null, 0, NOT c_zero_to_undef)
                ELSE
                    a40move_i4 (acv, a41v, Exclusive,
                          NOT c_is_null, 0, NOT c_zero_to_undef);
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
            RegionInfoFound := vGetRteInfoRegionNext (RteRegionInfo);
        UNTIL
            (NOT RegionInfoFound) OR
            (acv.a_returncode <> 0);
        (*ENDREPEAT*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a421storage (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      RteStorageInfo   : tsp92_RteStorageInfo;
      StorageInfoFound : boolean;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    a40get_catalog_table (acv, a41v);
(*ENDIF*) 
StorageInfoFound := true;
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    IF  vGetRteInfoStorageFirst (RteStorageInfo)
    THEN
        REPEAT
            WITH RteStorageInfo DO
                BEGIN
                a40move_const (acv, a41v, @StorageName, sizeof(StorageName));
                a40move_i4 (acv, a41v, StorageValue,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_const (acv, a41v, @StorageUnit, sizeof(StorageUnit));
                END;
            (*ENDWITH*) 
            StorageInfoFound := vGetRteInfoStorageNext (RteStorageInfo);
        UNTIL
            (NOT StorageInfoFound) OR
            (acv.a_returncode <> 0);
        (*ENDREPEAT*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a421ioaccess (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      RteIOInfo   : tsp92_RteIOInfo;
      IOInfoFound : boolean;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    a40get_catalog_table (acv, a41v);
(*ENDIF*) 
IOInfoFound := true;
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    IF  vGetRteInfoIOFirst (RteIOInfo)
    THEN
        REPEAT
            WITH RteIOInfo DO
                BEGIN
                a40move_i4 (acv, a41v, DevNo,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_const (acv, a41v, @DevspaceName, sizeof(DevspaceName));
                a40move_counter (acv, a41v, ReadCnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_counter (acv, a41v, ReadPageCnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_counter (acv, a41v, WriteCnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_counter (acv, a41v, WritePageCnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                END;
            (*ENDWITH*) 
            IOInfoFound := vGetRteInfoIONext (RteIOInfo);
        UNTIL
            (NOT IOInfoFound) OR
            (acv.a_returncode <> 0);
        (*ENDREPEAT*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a421backupioaccess (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      RteBackupInfo   : tsp92_RteBackupInfo;
      BackupInfoFound : boolean;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    a40get_catalog_table (acv, a41v);
(*ENDIF*) 
BackupInfoFound := true;
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    IF  vGetRteInfoBackupFirst (RteBackupInfo)
    THEN
        REPEAT
            WITH RteBackupInfo DO
                BEGIN
                a40move_i4 (acv, a41v, DevNo,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_const (acv, a41v, @DevspaceName, sizeof(DevspaceName));
                a40move_counter (acv, a41v, ReadCnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_counter (acv, a41v, WriteCnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_counter (acv, a41v, PageCnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_i4 (acv, a41v, QueLen,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_i4 (acv, a41v, MaxQueLen,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                END;
            (*ENDWITH*) 
            BackupInfoFound := vGetRteInfoBackupNext (RteBackupInfo);
        UNTIL
            (NOT BackupInfoFound) OR
            (acv.a_returncode <> 0);
        (*ENDREPEAT*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a421spec_thread (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      RteSpecThreadsInfo   : tsp92_RteSpecThreadsInfo;
      SpecThreadsInfoFound : boolean;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    a40get_catalog_table (acv, a41v);
(*ENDIF*) 
SpecThreadsInfoFound := true;
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    IF  vGetRteInfoSpecThreadsFirst (RteSpecThreadsInfo)
    THEN
        REPEAT
            WITH RteSpecThreadsInfo DO
                BEGIN
                a40move_i4 (acv, a41v, SpecThreadId,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_const (acv, a41v, @SpecThreadName, sizeof(SpecThreadName));
                END;
            (*ENDWITH*) 
            SpecThreadsInfoFound := vGetRteInfoSpecThreadsNext (RteSpecThreadsInfo);
        UNTIL
            (NOT SpecThreadsInfoFound) OR
            (acv.a_returncode <> 0);
        (*ENDREPEAT*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a421ukthread (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      RteUKTInfo   : tsp92_RteUKTInfo;
      UKTInfoFound : boolean;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    a40get_catalog_table (acv, a41v);
(*ENDIF*) 
UKTInfoFound := true;
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    IF  vGetRteInfoUKTFirst (RteUKTInfo)
    THEN
        REPEAT
            WITH RteUKTInfo DO
                BEGIN
                a40move_i4 (acv, a41v, UKTId,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_const (acv, a41v, @UKTName, sizeof(UKTName));
                a40move_const (acv, a41v, @UKTState, sizeof(UKTState));
                a40move_counter (acv, a41v, UKTDispatcherCnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_counter (acv, a41v, UKTTaskSwitchCnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_counter (acv, a41v, UKTIdleCount,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_counter (acv, a41v, UKTCommandCnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_i4 (acv, a41v, UKTActiveTasks,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_i4 (acv, a41v, UKTTotalTasks,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_i4 (acv, a41v, UKTRunQueueLen,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_const (acv, a41v, @UKTTaskCluster,
                      sizeof(UKTTaskCluster));
                END;
            (*ENDWITH*) 
            UKTInfoFound := vGetRteInfoUKTNext (RteUKTInfo);
        UNTIL
            (NOT UKTInfoFound) OR
            (acv.a_returncode <> 0);
        (*ENDREPEAT*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a421deviothread (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      RteIODetailsInfo      : tsp92_RteIODetailsInfo;
      RteIODetailsInfoFound : boolean;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    a40get_catalog_table (acv, a41v);
(*ENDIF*) 
RteIODetailsInfoFound := true;
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    IF  vGetRteInfoIODetailsFirst (RteIODetailsInfo)
    THEN
        REPEAT
            WITH RteIODetailsInfo DO
                BEGIN
                a40move_i4 (acv, a41v, ThreadId,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_const (acv, a41v, @ThreadName, sizeof(ThreadName));
                a40move_i4 (acv, a41v, DevNo,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_const (acv, a41v, @DevspaceName, sizeof(DevspaceName));
                a40move_counter (acv, a41v, ReadCnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_counter (acv, a41v, WriteCnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_i4 (acv, a41v, QueLen,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_i4 (acv, a41v, MaxQueLen,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                END;
            (*ENDWITH*) 
            RteIODetailsInfoFound := vGetRteInfoIODetailsNext (RteIODetailsInfo);
        UNTIL
            (NOT RteIODetailsInfoFound) OR
            (acv.a_returncode <> 0);
        (*ENDREPEAT*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a421task (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      RteTaskInfo      : tsp92_RteTaskInfo;
      RteTaskInfoFound : boolean;
      StateToShow      : tsp92_RteTaskInfoStateToShow;
      TypeToShow       : tsp92_RteTaskInfoTypeToShow;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    a40get_catalog_table (acv, a41v);
(*ENDIF*) 
RteTaskInfoFound := true;
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    BEGIN
    CASE a41v.a4sh_kind OF
        sh_sysmon_task,
        sh_sysmon_us,
        sh_sysmon_sv,
        sh_sysmon_dw:
            StateToShow := sp92State_All;
        sh_sysmon_active_task,
        sh_sysmon_us_active,
        sh_sysmon_sv_active,
        sh_sysmon_dw_active :
            StateToShow := sp92State_Active;
        sh_sysmon_runnable,
        sh_sysmon_us_runnable,
        sh_sysmon_sv_runnable,
        sh_sysmon_dw_runnable :
            StateToShow := sp92State_Runnable;
        OTHERWISE
            RteTaskInfoFound := false;
        END;
    (*ENDCASE*) 
    CASE a41v.a4sh_kind OF
        sh_sysmon_task,
        sh_sysmon_active_task,
        sh_sysmon_runnable :
            TypeToShow := sp92Type_All;
        sh_sysmon_us,
        sh_sysmon_us_active,
        sh_sysmon_us_runnable :
            TypeToShow := sp92Type_User;
        sh_sysmon_sv,
        sh_sysmon_sv_active,
        sh_sysmon_sv_runnable :
            TypeToShow := sp92Type_Server;
        sh_sysmon_dw,
        sh_sysmon_dw_active,
        sh_sysmon_dw_runnable :
            TypeToShow := sp92Type_DataWriter;
        OTHERWISE
            RteTaskInfoFound := false;
        END;
    (*ENDCASE*) 
    IF  RteTaskInfoFound
    THEN
        RteTaskInfoFound := vGetRteInfoTaskFirst (RteTaskInfo,
              StateToShow, TypeToShow);
    (*ENDIF*) 
    IF  RteTaskInfoFound
    THEN
        REPEAT
            WITH RteTaskInfo DO
                BEGIN
                a40move_i4 (acv, a41v, TaskIndex,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_i4 (acv, a41v, UKTId,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_const (acv, a41v, @TaskName,
                      sizeof(TaskName));
                IF  ApplPid = -1
                THEN
                    a40move_i4 (acv, a41v, ApplPid,
                          c_is_null, 0, NOT c_zero_to_undef)
                ELSE
                    a40move_i4 (acv, a41v, ApplPid,
                          NOT c_is_null, 0, NOT c_zero_to_undef);
                (*ENDIF*) 
                a40move_const (acv, a41v, @TaskState,
                      sizeof(TaskState));
                a40move_const (acv, a41v, @CancelFlag,
                      sizeof(CancelFlag));
                (* PTS 1111217 E.Z. *)
                a40move_const (acv, a41v, @OMSCallActive,
                      sizeof(OMSCallActive));
                a40move_const (acv, a41v, @SpecialFlag,
                      sizeof(SpecialFlag));
                IF  TimeOut < 0
                THEN
                    a40move_i4 (acv, a41v, TimeOut,
                          c_is_null, 0, NOT c_zero_to_undef)
                ELSE
                    a40move_i4 (acv, a41v, TimeOut,
                          NOT c_is_null, 0, NOT c_zero_to_undef);
                (*ENDIF*) 
                IF  HoldingRegion = -1
                THEN
                    a40move_i4 (acv, a41v, HoldingRegion,
                          c_is_null, 0, NOT c_zero_to_undef)
                ELSE
                    a40move_i4 (acv, a41v, HoldingRegion,
                          NOT c_is_null, 0, NOT c_zero_to_undef);
                (*ENDIF*) 
                IF  WaitingForTask = -1
                THEN
                    a40move_i4 (acv, a41v, WaitingForTask,
                          c_is_null, 0, NOT c_zero_to_undef)
                ELSE
                    a40move_i4 (acv, a41v, WaitingForTask,
                          NOT c_is_null, 0, NOT c_zero_to_undef);
                (*ENDIF*) 
                IF  WaitingForRoot = -1
                THEN
                    a40move_i4 (acv, a41v, WaitingForRoot,
                          c_is_null, 0, NOT c_zero_to_undef)
                ELSE
                    a40move_i4 (acv, a41v, WaitingForRoot,
                          NOT c_is_null, 0, NOT c_zero_to_undef);
                (*ENDIF*) 
                (* PTS 1115172 E.Z. *)
                IF  LockedPageNo = NIL_PAGE_NO_GG00
                THEN
                    a40move_i4 (acv, a41v, LockedPageNo,
                          c_is_null, 0, NOT c_zero_to_undef)
                ELSE
                    a40move_i4 (acv, a41v, LockedPageNo,
                          NOT c_is_null, 0, NOT c_zero_to_undef);
                (*ENDIF*) 
                a40move_const (acv, a41v, @ExtendedTaskState,
                      sizeof(ExtendedTaskState));
                END;
            (*ENDWITH*) 
            RteTaskInfoFound := vGetRteInfoTaskNext (RteTaskInfo);
        UNTIL
            (NOT RteTaskInfoFound) OR
            (acv.a_returncode <> 0);
        (*ENDREPEAT*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak421TaskSelfIOInfo (VAR acv : tak_all_command_glob;
            VAR a41v   : tak40_show_glob;
            VAR SelfIO : tsp92_RteTaskSelfIOInfo);
 
BEGIN
WITH SelfIO DO
    BEGIN
    IF  Cnt < 0
    THEN
        a40move_counter (acv, a41v, Cnt,
              c_is_null, 0, NOT c_zero_to_undef)
    ELSE
        a40move_counter (acv, a41v, Cnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
    (*ENDIF*) 
    IF  Pages < 0
    THEN
        a40move_counter (acv, a41v, Pages,
              c_is_null, 0, NOT c_zero_to_undef)
    ELSE
        a40move_counter (acv, a41v, Pages,
              NOT c_is_null, 0, NOT c_zero_to_undef);
    (*ENDIF*) 
    IF  AvgAbsTime < 0
    THEN
        a40move_real (acv, a41v, AvgAbsTime,
              c_is_null, cak421time_frac)
    ELSE
        a40move_real (acv, a41v, AvgAbsTime,
              NOT c_is_null, cak421time_frac);
    (*ENDIF*) 
    (* PTS 1111217 E.Z. *)
    IF  TotAbsTime < 0
    THEN
        a40move_real (acv, a41v, TotAbsTime,
              c_is_null, cak421time_frac)
    ELSE
        a40move_real (acv, a41v, TotAbsTime,
              NOT c_is_null, cak421time_frac);
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak421TaskDEVIOInfo (VAR acv : tak_all_command_glob;
            VAR a41v  : tak40_show_glob;
            VAR DevIO : tsp92_RteTaskDEVIOInfo);
 
BEGIN
WITH DevIO DO
    BEGIN
    IF  Cnt < 0
    THEN
        a40move_counter (acv, a41v, Cnt,
              c_is_null, 0, NOT c_zero_to_undef)
    ELSE
        a40move_counter (acv, a41v, Cnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
    (*ENDIF*) 
    IF  Pages < 0
    THEN
        a40move_counter (acv, a41v, Pages,
              c_is_null, 0, NOT c_zero_to_undef)
    ELSE
        a40move_counter (acv, a41v, Pages,
              NOT c_is_null, 0, NOT c_zero_to_undef);
    (*ENDIF*) 
    IF  AvgRelTime < 0
    THEN
        a40move_real (acv, a41v, AvgRelTime,
              c_is_null, cak421time_frac)
    ELSE
        a40move_real (acv, a41v, AvgRelTime,
              NOT c_is_null, cak421time_frac);
    (*ENDIF*) 
    (* PTS 1111217 E.Z. *)
    IF  TotRelTime < 0
    THEN
        a40move_real (acv, a41v, TotRelTime,
              c_is_null, cak421time_frac)
    ELSE
        a40move_real (acv, a41v, TotRelTime,
              NOT c_is_null, cak421time_frac);
    (*ENDIF*) 
    IF  AvgAbsTime < 0
    THEN
        a40move_real (acv, a41v, AvgAbsTime,
              c_is_null, cak421time_frac)
    ELSE
        a40move_real (acv, a41v, AvgAbsTime,
              NOT c_is_null, cak421time_frac);
    (*ENDIF*) 
    (* PTS 1111217 E.Z. *)
    IF  TotAbsTime < 0
    THEN
        a40move_real (acv, a41v, TotAbsTime,
              c_is_null, cak421time_frac)
    ELSE
        a40move_real (acv, a41v, TotAbsTime,
              NOT c_is_null, cak421time_frac);
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak421TaskStateInfo (VAR acv : tak_all_command_glob;
            VAR a41v  : tak40_show_glob;
            VAR State : tsp92_RteTaskStateInfo);
 
BEGIN
WITH State DO
    BEGIN
    IF  Cnt < 0
    THEN
        a40move_counter (acv, a41v, Cnt,
              c_is_null, 0, NOT c_zero_to_undef)
    ELSE
        a40move_counter (acv, a41v, Cnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
    (*ENDIF*) 
    IF  AvgRelTime < 0
    THEN
        a40move_real (acv, a41v, AvgRelTime,
              c_is_null, cak421time_frac)
    ELSE
        a40move_real (acv, a41v, AvgRelTime,
              NOT c_is_null, cak421time_frac);
    (*ENDIF*) 
    (* PTS 1111217 E.Z. *)
    IF  TotRelTime < 0
    THEN
        a40move_real (acv, a41v, TotRelTime,
              c_is_null, cak421time_frac)
    ELSE
        a40move_real (acv, a41v, TotRelTime,
              NOT c_is_null, cak421time_frac);
    (*ENDIF*) 
    IF  AvgAbsTime < 0
    THEN
        a40move_real (acv, a41v, AvgAbsTime,
              c_is_null, cak421time_frac)
    ELSE
        a40move_real (acv, a41v, AvgAbsTime,
              NOT c_is_null, cak421time_frac);
    (*ENDIF*) 
    (* PTS 1111217 E.Z. *)
    IF  TotAbsTime < 0
    THEN
        a40move_real (acv, a41v, TotAbsTime,
              c_is_null, cak421time_frac)
    ELSE
        a40move_real (acv, a41v, TotAbsTime,
              NOT c_is_null, cak421time_frac);
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a421task_detail (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      RteTaskDetailsInfo      : tsp92_RteTaskDetailsInfo;
      RteTaskDetailsInfoFound : boolean;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    a40get_catalog_table (acv, a41v);
(*ENDIF*) 
RteTaskDetailsInfoFound := true;
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    IF  vGetRteInfoTaskDetailsFirst (RteTaskDetailsInfo)
    THEN
        REPEAT
            WITH RteTaskDetailsInfo DO
                BEGIN
                a40move_i4 (acv, a41v, TaskIndex,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_const (acv, a41v, @TaskName, sizeof(TaskName));
                a40move_const (acv, a41v, @TaskState,
                      sizeof(TaskState));
                a40move_i4 (acv, a41v, UKTId,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_const (acv, a41v, @RemoteApplNode, sizeof(RemoteApplNode));
                IF  ApplPid = -1
                THEN
                    a40move_i4 (acv, a41v, ApplPid,
                          c_is_null, 0, NOT c_zero_to_undef)
                ELSE
                    a40move_i4 (acv, a41v, ApplPid,
                          NOT c_is_null, 0, NOT c_zero_to_undef);
                (*ENDIF*) 
                a40move_counter (acv, a41v, DispatcherCnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_counter (acv, a41v, CommandCnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_counter (acv, a41v, PrioCnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_counter (acv, a41v, TaskSelfSuspCnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_counter (acv, a41v, RegionAccessCnt,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                ak421TaskSelfIOInfo (acv, a41v, SelfIORead);
                ak421TaskSelfIOInfo (acv, a41v, SelfIOWrite);
                ak421TaskDEVIOInfo (acv, a41v, DEVIORead);
                ak421TaskDEVIOInfo (acv, a41v, DEVIOWrite);
                ak421TaskDEVIOInfo (acv, a41v, BackupRead);
                ak421TaskDEVIOInfo (acv, a41v, BackupWrite);
                ak421TaskStateInfo (acv, a41v, Vsuspend);
                ak421TaskStateInfo (acv, a41v, Vwait);
                ak421TaskStateInfo (acv, a41v, Vsleep);
                WITH ReceiveReply DO
                    BEGIN
                    IF  Cnt < 0
                    THEN
                        a40move_counter (acv, a41v, Cnt,
                              c_is_null, 0, NOT c_zero_to_undef)
                    ELSE
                        a40move_counter (acv, a41v, Cnt,
                              NOT c_is_null, 0, NOT c_zero_to_undef);
                    (*ENDIF*) 
                    IF  AvgAbsTime < 0
                    THEN
                        a40move_real (acv, a41v, AvgAbsTime,
                              c_is_null, cak421time_frac)
                    ELSE
                        a40move_real (acv, a41v, AvgAbsTime,
                              NOT c_is_null, cak421time_frac);
                    (*ENDIF*) 
                    (* PTS 1111217 E.Z. *)
                    IF  TotAbsTime < 0
                    THEN
                        a40move_real (acv, a41v, TotAbsTime,
                              c_is_null, cak421time_frac)
                    ELSE
                        a40move_real (acv, a41v, TotAbsTime,
                              NOT c_is_null, cak421time_frac);
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                WITH ReplyReceive DO
                    BEGIN
                    IF  AvgRelTime < 0
                    THEN
                        a40move_real (acv, a41v, AvgRelTime,
                              c_is_null, cak421time_frac)
                    ELSE
                        a40move_real (acv, a41v, AvgRelTime,
                              NOT c_is_null, cak421time_frac);
                    (*ENDIF*) 
                    (* PTS 1111217 E.Z. *)
                    IF  TotRelTime < 0
                    THEN
                        a40move_real (acv, a41v, TotRelTime,
                              c_is_null, cak421time_frac)
                    ELSE
                        a40move_real (acv, a41v, TotRelTime,
                              NOT c_is_null, cak421time_frac);
                    (*ENDIF*) 
                    IF  AvgAbsTime < 0
                    THEN
                        a40move_real (acv, a41v, AvgAbsTime,
                              c_is_null, cak421time_frac)
                    ELSE
                        a40move_real (acv, a41v, AvgAbsTime,
                              NOT c_is_null, cak421time_frac);
                    (*ENDIF*) 
                    (* PTS 1111217 E.Z. *)
                    IF  TotAbsTime < 0
                    THEN
                        a40move_real (acv, a41v, TotAbsTime,
                              c_is_null, cak421time_frac)
                    ELSE
                        a40move_real (acv, a41v, TotAbsTime,
                              NOT c_is_null, cak421time_frac);
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                (* PTS 1110965 E.Z. *)
                a40move_const (acv, a41v,
                      @COMProcedureName, sizeof(COMProcedureName));
                a40move_counter (acv, a41v, OMSCallbackCount,
                      NOT c_is_null, 0, NOT c_zero_to_undef);
                a40move_const (acv, a41v,
                      @OMSMCallbackMethodName, sizeof(OMSMCallbackMethodName));
                END;
            (*ENDWITH*) 
            RteTaskDetailsInfoFound :=
                  vGetRteInfoTaskDetailsNext (RteTaskDetailsInfo);
        UNTIL
            (NOT RteTaskDetailsInfoFound) OR
            (acv.a_returncode <> 0);
        (*ENDREPEAT*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a421totalcount (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      RteTotalCntInfo : tsp92_RteTotalCntInfo;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    a40get_catalog_table (acv, a41v);
(*ENDIF*) 
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    BEGIN
    vGetRteInfoTotalCnt (RteTotalCntInfo);
    WITH RteTotalCntInfo DO
        BEGIN
        a40move_counter (acv, a41v, DispatcherCnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, CommandCnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, VwaitCnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, VsuspendCnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, VsleepCnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, PrioCnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, UserTaskReadCnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, UserTaskWriteCnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, TaskIOCnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, DevIOCnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, RegionAccessCnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, RegionCollCnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, RegionWaitCnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, VbegexclTasCollCnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, VendexclTasCollCnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, TaskSelfSuspCnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, SymbolResolutionCnt,
              NOT c_is_null, 0, NOT c_zero_to_undef);
        END
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
*-PRETTY-*  statements    :        326
*-PRETTY-*  lines of code :       1024        PRETTYX 3.10 
*-PRETTY-*  lines in file :       1307         1997-12-10 
.PA 
