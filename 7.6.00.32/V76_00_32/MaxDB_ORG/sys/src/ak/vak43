.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK43$
.tt 2 $$$
.TT 3 $ThomasA$Show_user_priv$2000-10-25$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : AK_Show_user_priv
=========
.sp
Purpose : Show User und Privileges semantische Routinen.
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a43get_granted_priv (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    VAR owner     : tsp00_KnlIdentifier;
                    VAR tablename : tsp00_KnlIdentifier);
 
        PROCEDURE
              a43execute (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a43AllRolesCallback (
                    VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob;
                    pRole    : tak_sysbufferaddress);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
&       ifdef trace
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01surrogate (
                    layer     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR tabid : tgg00_Surrogate);
&       endif
 
      ------------------------------ 
 
        FROM
              Catalog_Select_Optimizer : VAK722;
 
        FUNCTION
              a722test_col_qual (
                    VAR acv   : tak_all_command_glob;
                    VAR a41v  : tak40_show_glob;
                    colname   : tak_oldidentifier;
                    def_byte  : char;
                    value_ptr : tsp00_MoveObjPtr;
                    value_len : integer;
                    work_buf  : tak40_int2_arr_ptr) : boolean;
 
        PROCEDURE
              a722init_epos_reccol_relation(
                    VAR acv       : tak_all_command_glob;
                    VAR pos_info  : tak40_int2_arr_ptr);
 
        PROCEDURE
              a722finalize_epos_reccol_relation(
                    VAR acv       : tak_all_command_glob;
                    VAR pos_info  : tak40_int2_arr_ptr);
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51build_userkey (
                    VAR user_name : tsp00_KnlIdentifier;
                    VAR userkey : tgg00_SysInfoKey);
 
        PROCEDURE
              a51cache_size_info (
                    VAR acv       : tak_all_command_glob;
                    session       : tgg91_SessionNo;
                    VAR ak_cache  : tsp00_Int4);
 
        PROCEDURE
              a51get_date_format (
                    VAR acv       : tak_all_command_glob;
                    VAR format    : tsp00_C120;
                    has_to_be_uni : boolean);
 
      ------------------------------ 
 
        FROM
              AK_universal_show_tools : VAK40;
 
        VAR
              a40sqlmode : ARRAY[tsp00_SqlMode] OF tsp00_C8;
              a40yes_no  : ARRAY[boolean] OF tsp00_C3;
 
        PROCEDURE
              a40comment_descriptor (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    comment_exist : boolean;
                    VAR tabid     : tgg00_Surrogate;
                    column_no     : integer;
                    comment_kind  : tak_comment_type);
 
        PROCEDURE
              a40FinishTableScan (
                    VAR acv          : tak_all_command_glob;
                    VAR a41v         : tak40_show_glob);
 
        PROCEDURE
              a40move (
                    VAR acv     : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : integer);
 
        PROCEDURE
              a40move_const (
                    VAR acv     : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : integer);
 
        PROCEDURE
              a40move_i4 (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    i4_val        : tsp00_Int4;
                    is_null       : boolean;
                    frac          : integer;
                    zero_to_undef : boolean);
 
        PROCEDURE
              a40put_date_time (
                    VAR acv             : tak_all_command_glob;
                    VAR a41v            : tak40_show_glob;
                    VAR datetime        : tsp00_Int4;
                    date                : boolean;
                    is_undef            : boolean);
 
        FUNCTION
              a40usertab_next (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    use_tables    : boolean;
                    use_dbprocs   : boolean;
                    use_sequences : boolean;
                    VAR surrogate : tgg00_Surrogate;
                    VAR kind      : tgg00_TableKind) : boolean;
 
        PROCEDURE
              a40get_catalog_table (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a40_p_priv (
                    VAR pr  : tak_privilege;
                    VAR prn : tsp00_C40;
                    colno   : tsp00_Int2);
 
        PROCEDURE
              a40ignore_down_error (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a40init_table_scan (
                    VAR acv          : tak_all_command_glob;
                    VAR a41v         : tak40_show_glob;
                    scan_temp        : boolean;
                    scan_private     : boolean;
                    scan_non_private : boolean;
                    scan_public      : boolean;
                    use_synonyms     : boolean;
                    all_base         : boolean);
 
        FUNCTION
              a40next_table (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob) : boolean;
 
        PROCEDURE
              a40site (
                    VAR acv              : tak_all_command_glob;
                    VAR a41v             : tak40_show_glob;
                    VAR siteserverdbname : tsp00_DbName;
                    VAR siteid           : tsp00_NodeId);
 
      ------------------------------ 
 
        FROM
              AK_Synonym : VAK23;
 
        FUNCTION
              a23exist_sequence (
                    VAR acv         : tak_all_command_glob;
                    tree_index      : integer;
                    inclusiveSerial : boolean;
                    VAR seq_buf     : tak_sysbufferaddress;
                    VAR seq_owner   : tsp00_KnlIdentifier;
                    VAR seq_name    : tsp00_KnlIdentifier) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_User_Password  :   VAK21;
 
        FUNCTION
              a21is_owner (
                    VAR acv     : tak_all_command_glob;
                    VAR userrec : tak_userrecord) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_usertab_tools : VAK19;
 
        FUNCTION
              a19IsDefaultRole (
                    VAR acv     : tak_all_command_glob;
                    VAR user_id : tgg00_Surrogate;
                    VAR role_id : tgg00_Surrogate) : boolean;
 
        FUNCTION
              a19user_knows_role (
                    VAR acv     : tak_all_command_glob;
                    VAR user_id : tgg00_Surrogate;
                    VAR role_id : tgg00_Surrogate) : boolean;
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        FUNCTION
              a101_RegisterCurrentStatement (
                    VAR acv : tak_all_command_glob) : tsp00_Int4;
 
        PROCEDURE
              a101_UnregisterStatement (
                    VAR acv     : tak_all_command_glob;
                    statementId : tsp00_Int4);
 
        PROCEDURE
              a101_SetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId;
                    sublevel       : tsp00_Int4(*ptocConst*));
 
        PROCEDURE
              a101_GetTempFileInstance(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
        PROCEDURE
              a101_DestroyGroupedTempFile(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103AllRoles (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate (* ptocConst *);
                    VAR schemaName : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache  :   VAK10;
 
        PROCEDURE
              a10_key_del  (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey;
                    dstate     : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10next_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    stop_prefix  : integer;
                    dstate       : tak_directory_state;
                    reckind      : tsp00_C2;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06extcolno (
                    VAR baserec  : tak_baserecord;
                    extcolno     : integer;
                    VAR col_ptr  : tak00_colinfo_ptr);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        FUNCTION
              a06_table_exist (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR authid   : tsp00_KnlIdentifier;
                    VAR tablen   : tsp00_KnlIdentifier;
                    VAR d_sparr  : tak_syspointerarr;
                    get_all      : boolean) : boolean;
 
        PROCEDURE
              a06_get_priv  (
                    VAR acv  : tak_all_command_glob;
                    VAR brec : tak_sysbufferaddress;
                    VAR priv : tak_privilege);
 
        FUNCTION
              a06_role_excluded (
                    VAR acv     : tak_all_command_glob;
                    VAR role_id : tgg00_Surrogate) : boolean;
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06det_user_id (
                    VAR acv      : tak_all_command_glob;
                    VAR authname : tsp00_KnlIdentifier;
                    VAR authid   : tgg00_Surrogate);
 
        FUNCTION
              a06role_exist (
                    VAR acv          : tak_all_command_glob;
                    VAR role_name    : tsp00_KnlIdentifier;
                    dstate           : tak_directory_state;
                    VAR role_rec_ptr : tak_sysbufferaddress) : boolean;
 
        PROCEDURE
              a06rsend_mess_buf (
                    VAR acv     : tak_all_command_glob;
                    VAR mbuf    : tgg00_MessBlock;
                    return_req  : boolean;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a06set_mtree (
                    VAR acv    : tak_all_command_glob;
                    VAR mblock : tgg00_MessBlock;
                    VAR tree   : tgg00_FileId);
 
        PROCEDURE
              a06unpack_priv (
                    VAR packed_priv   : tak_privilege;
                    VAR unpacked_priv : tak_privilege);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061get_colname (
                    VAR col_info : tak00_columninfo;
                    VAR colname  : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01char_size         : integer;
              a01defaultkey        : tgg00_SysInfoKey;
              a01emptypriv         : tak_privilege;
              a01controluser       : tsp00_KnlIdentifier;
              a01_i_dbarole        : tsp00_KnlIdentifier;
              a01_i_public         : tsp00_KnlIdentifier;
              a01_i_tablekey       : tsp00_KnlIdentifier;
              a01_i_temp           : tsp00_KnlIdentifier;
              a01_il_b_identifier  : tsp00_KnlIdentifier;
              a01kw                : tak_keywordtab;
 
        PROCEDURE
              a01sets_identifier (
                    VAR id         : tsp00_KnlIdentifier;
                    set_identifier : tak_oldidentifier);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1  : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
        PROCEDURE
              b01empty_file (
                    VAR t       : tgg00_TransContext;
                    VAR current : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD07;
 
        PROCEDURE
              b07cadd_record (
                    VAR t    : tgg00_TransContext;
                    VAR curr : tgg00_FileId;
                    VAR b    : tgg00_Rec);
 
        PROCEDURE
              b07cnext_record (
                    VAR t          : tgg00_TransContext;
                    VAR file_id    : tgg00_FileId;
                    VAR rk         : tgg00_Lkey;
                    VAR set_result : tgg00_BdSetResultRecord;
                    VAR tree_pos   : tgg00_FilePos;
                    VAR b          : tsp00_MoveObj);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20int4_to_buf_swap (
                    val        : tsp00_Int4;
                    sourceswap : tsp00_SwapKind;
                    VAR dest   : tsp00_C4;
                    di         : tsp00_Int4;
                    destswap   : tsp00_SwapKind);
 
        FUNCTION
              s20buf_to_int4(VAR str : tsp00_Buf; si : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s20buf_to_int4_swap (
                    VAR source     : tsp00_MoveObj;
                    si             : tsp00_Int4;
                    sourceswap     : tsp00_SwapKind;
                    destswap       : tsp00_SwapKind) : tsp00_Int4;
 
        PROCEDURE
              s20swap_int4 (
                    VAR val        : tsp00_Int4;
                    source_swap    : tsp00_SwapKind;
                    destin_swap    : tsp00_SwapKind);
 
      ------------------------------ 
 
        FROM
              Encrypting : VSP02;
 
        PROCEDURE
              s02encrypt (
                    VAR clearname : tsp00_Name;
                    VAR crypt : tsp00_CryptPw);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code           : tgg04_CodeGlobals;
              g01glob           : tgg00_KernelGlobals;
              g01serverdb_ident : tgg04_ServerdbIdent;
 
        PROCEDURE
              g01datapart_init (
                    VAR mblock    : tgg00_MessBlock;
                    datapart_ptr  : tgg00_DataPartPtr;
                    datapart_size : tsp00_Int4);
 
        PROCEDURE
              g01mblock_init (
                    VAR source_trans : tgg00_TransContext;
                    mess_type  : tgg00_MessType;
                    mess2_type : tgg00_MessType2;
                    VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              g01qual_init (
                    VAR mblock : tgg00_MessBlock;
                    qual_ptr   : tgg00_QualBufPtr;
                    qual_size  : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04build_temp_tree_id (
                    VAR curr : tgg00_FileId;
                    VAR t : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        FUNCTION
              gg06IsNilRef (VAR PageRef : tgg91_PageRef): boolean;
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              b07cnext_record;
 
              tgg00_DoubleBuf
 
        PROCEDURE
              s20int4_to_buf_swap;
 
              tsp00_MoveObj tsp00_C4
 
        PROCEDURE
              s20buf_to_int4;
 
              tsp00_MoveObj tsp00_Buf
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ThomasA
.sp
.cp 3
Created : 1985-03-01
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-10-25
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_scan_temp       = true;
      c_scan_private    = true;
      c_scan_nonprivate = true;
      c_scan_public     = true;
      c_use_synonyms    = true;
      c_all_base        = true;
      c_null            = true;
      c_to_undef        = true;
      c_use_tables      = true;
      c_use_dbprocs     = true;
      c_use_sequences   = true;
      c_is_synonym      = true;
 
TYPE
      t43_user_check = (user_specified, all_user, only_dbas);
 
 
(*------------------------------*) 
 
PROCEDURE
      a43execute (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
BEGIN
CASE a41v.a4sh_kind OF
    sh_connect_param :
        ak43connect_param (acv, a41v);
    sh_connect :
        ak43connected_users (acv, a41v);
    sh_priv_granted_to :
        ak43granted_to (acv, a41v);
    sh_p_prog, sh_new_privileges, sh_all_new_privileges :
        ak43privileges (acv, a41v);
    sh_userroles :
        ak43UserRoles (acv, a41v);
    sh_all_roles :  (* PTS 1104069 *)
        ak43all_roles (acv, a41v);
    sh_session_roles :
        ak43session_roles (acv, a41v);
    END;
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43connect_param  (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      ok           : boolean;
 
      abs_session  : RECORD
            CASE boolean OF
                true :
                    (c4 : tsp00_C4);
                false :
                    (i4 : tsp00_Int4);
                END;
            (*ENDCASE*) 
 
      format_buf   : tsp00_C120;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    a4sh_kind := sh_connect_param;
    a40get_catalog_table (acv, a41v);
    IF  (a_returncode = 0) AND
        (a_ex_kind <> only_parsing)
    THEN
        BEGIN
        a40move_const (acv, a41v,
              @a40sqlmode[a_sqlmode], sizeof (a40sqlmode[a_sqlmode]));
        a40move_i4 (acv, a41v,
              a_iso_level, NOT c_null, 0, NOT c_to_undef);
        a40move_i4 (acv, a41v,
              a_user_timeout, NOT c_null, 0, NOT c_to_undef);
        (* PTS 1105303 E.Z. *)
        abs_session.c4 := acv.a_transinf.tri_trans.trSessionId_gg00.ci4_gg00;
        s20swap_int4 (abs_session.i4, sw_normal, g01code.kernel_swap);
        abs_session.i4 := abs (abs_session.i4);
        a40move_i4 (acv, a41v, abs_session.i4,
              NOT c_null, 0, NOT c_to_undef);
        a51get_date_format (acv, format_buf,
              (a103GetColumn (a4p_arr.pinfop^.sbase, a41v.a4index)^.cdatatyp = dunicode));
        a40move (acv, a41v, @format_buf[ 2 ], mxsp_c50*a01char_size);
        (* PTS 1115043 E.Z. *)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43all_roles  (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      statementId : tsp00_Int4;
 
BEGIN
a40get_catalog_table (acv, a41v);
IF  acv.a_returncode = 0
THEN
    BEGIN
    statementId := a101_RegisterCurrentStatement (acv);
    a103AllRoles (acv, a41v);
    a101_UnregisterStatement (acv, statementId);
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a43AllRolesCallback (
            VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            pRole    : tak_sysbufferaddress);
 
VAR
      b_err    : tgg00_BasisError;
      privkey  : tgg00_SysInfoKey;
      priv_buf : tak_sysbufferaddress;
 
BEGIN
ak43one_db_role (acv, a41v, pRole, pRole^.suser.userowner_id);
privkey.stableid  := pRole^.syskey.sauthid;
privkey.sentrytyp := cak_eprivuser;
privkey.skeylen   := sizeof(privkey.stableid) + sizeof(privkey.sentrytyp);
REPEAT
    a10next_sysinfo (acv, privkey,
          sizeof(privkey.stableid) + sizeof(privkey.sentrytyp),
          d_release, cak_eprivuser, priv_buf, b_err);
    IF  b_err = e_ok
    THEN
        ak43one_db_role(acv, a41v, pRole,
              priv_buf^.sprivuser.pru_grantee);
    (*ENDIF*) 
UNTIL
    b_err <> e_ok;
(*ENDREPEAT*) 
IF  b_err = e_no_next_record
THEN
    b_err := e_ok;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43one_db_role  (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            role_buf : tak_sysbufferaddress;
            granteeId : tgg00_Surrogate);
 
VAR
      owner   : tsp00_KnlIdentifier;
      grantee : tsp00_KnlIdentifier;
 
BEGIN
a06determine_username (acv,
      role_buf^.suser.userowner_id, owner);
a40move (acv, a41v, @owner, sizeof (owner));
a40move (acv, a41v, @role_buf^.suser.username,
      sizeof (role_buf^.suser.username));
a06determine_username (acv, granteeId, grantee);
a40move (acv, a41v, @grantee, sizeof (grantee));
a40move_const (acv, a41v, @a40yes_no [
      a19IsDefaultRole (acv, granteeId,
      role_buf^.syskey.sauthid)], sizeof (a40yes_no[true]));
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43UserRoles  (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      e        : tgg00_BasisError;
      ix       : integer;
      sysk     : tgg00_SysInfoKey;
      pRoleTab : tak_sysbufferaddress;
 
BEGIN
a40get_catalog_table (acv, a41v);
IF  acv.a_returncode = 0
THEN
    BEGIN
    a41v.a4treeid    := acv.a_into_tree;
    IF  acv.a_current_user_kind = udba
    THEN
        IF  a06role_exist (acv, a01_i_dbarole, d_release, pRoleTab)
        THEN
            IF  ak43unique (acv, NOT c_is_synonym,
                pRoleTab^.suser.usurrogate, pRoleTab^.suser.usurrogate)
            THEN
                BEGIN
                a41v.a4unique := true;
                a40move (acv, a41v, @pRoleTab^.suser.usurrogate, sizeof(pRoleTab^.suser.usurrogate));
                a40move_const (acv, a41v, @a40yes_no [true], sizeof (a40yes_no[true]));
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    sysk             := a01defaultkey;
    sysk.sauthid     := acv.a_curr_user_id;
    sysk.sentrytyp   := cak_eroletab;
    sysk.slinkage[1] := chr(128);
    (* scan default roles first *)
    REPEAT;
        REPEAT
            a10get_sysinfo (acv, sysk, d_release, pRoleTab, e);
            IF  e = e_ok
            THEN
                WITH pRoleTab^.susertab DO
                    BEGIN
                    FOR ix := 1 TO usertabcount DO
                        IF  NOT usertabdef[ix].ut_empty
                        THEN
                            IF  ak43unique (acv, NOT c_is_synonym,
                                usertabdef[ix].ut_surrogate, usertabdef[ix].ut_surrogate)
                            THEN
                                BEGIN
                                a41v.a4unique := true;
                                a40move (acv, a41v, @usertabdef[ix].ut_surrogate, sizeof(usertabdef[ix].ut_surrogate));
                                a40move_const (acv, a41v, @a40yes_no [sysk.slinkage[1] = chr(128)], sizeof (a40yes_no[true]));
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDFOR*) 
                    IF  usertabnext_exist
                    THEN
                        a06inc_linkage (sysk.slinkage)
                    ELSE
                        e := e_sysinfo_not_found;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
        UNTIL
            (e <> e_ok);
        (*ENDREPEAT*) 
        IF  (acv.a_returncode = 0) AND (e = e_sysinfo_not_found)
        THEN
            BEGIN
            e := e_ok;
            IF  sysk.slinkage[1] = chr(128)
            THEN
                BEGIN (* scan non default roles *)
                sysk.slinkage[1] := chr(0);
                sysk.slinkage[2] := chr(1);
                END
            ELSE
                e := e_no_next_record
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    UNTIL
        (e <> e_ok) OR (acv.a_returncode <> 0);
    (*ENDREPEAT*) 
    IF  e <> e_no_next_record
    THEN
        a07_b_put_error (acv, e, 1)
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43session_roles  (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      b_err       : tgg00_BasisError;
      ix          : integer;
      roletab_ptr : tak_sysbufferaddress;
      rolekey     : tgg00_SysInfoKey;
 
BEGIN
a40get_catalog_table (acv, a41v);
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    BEGIN
    IF  (acv.a_role_info <> role_except) AND (acv.a_role_ptr <> NIL)
    THEN
        BEGIN
        ix := 1;
        WHILE ix <= acv.a_role_ptr^.rctxt_cnt DO
            BEGIN
            ak43one_role (acv, a41v, acv.a_role_ptr^.rctxt_roles[ix]);
            ix := ix + 1
            END;
        (*ENDWHILE*) 
        END
    ELSE
        IF  acv.a_role_info in [role_all, role_except] (* PTS 1104065 *)
        THEN
            BEGIN
            rolekey             := a01defaultkey;
            rolekey.sauthid     := acv.a_curr_user_id;
            rolekey.sentrytyp   := cak_eroletab;
            REPEAT
                a10get_sysinfo (acv, rolekey, d_fix, roletab_ptr, b_err);
                IF  b_err = e_ok
                THEN
                    WITH roletab_ptr^.susertab DO
                        BEGIN
                        ix := 1;
                        WHILE ix <= usertabcount DO
                            WITH usertabdef[ix] DO
                                BEGIN
                                IF  NOT ut_empty AND
                                    NOT a06_role_excluded (acv, ut_surrogate)
                                THEN
                                    ak43one_role (acv, a41v, ut_surrogate);
                                (*ENDIF*) 
                                ix := ix + 1;
                                END;
                            (*ENDWITH*) 
                        (*ENDWHILE*) 
                        IF  usertabnext_exist
                        THEN
                            a06inc_linkage (rolekey.slinkage)
                        ELSE
                            b_err := e_sysinfo_not_found
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
                IF  (b_err = e_sysinfo_not_found     ) AND
                    (rolekey.sauthid <> cak_public_id)
                THEN
                    BEGIN
                    b_err            := e_ok;
                    rolekey.sauthid  := cak_public_id;
                    rolekey.slinkage := cak_init_linkage
                    END;
                (*ENDIF*) 
            UNTIL
                b_err <> e_ok;
            (*ENDREPEAT*) 
            IF  b_err <> e_sysinfo_not_found
            THEN
                a07_b_put_error (acv, b_err, 1)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    ;
    (* empty file used by ak43unique *)
    b01empty_file (acv.a_transinf.tri_trans, acv.a_into_tree)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43one_role  (
            VAR acv     : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            VAR role_id : tgg00_Surrogate);
 
VAR
      b_err  : tgg00_BasisError;
      sysbuf : tak_sysbufferaddress;
      sysk   : tgg00_SysInfoKey;
 
BEGIN
IF  ak43unique (acv, NOT c_is_synonym, role_id, role_id)
THEN
    BEGIN
    sysk           := a01defaultkey;
    sysk.sauthid   := role_id;
    sysk.sentrytyp := cak_euser;
    a10get_sysinfo (acv, sysk, d_release, sysbuf, b_err);
    IF  b_err = e_ok
    THEN
        a40move (acv, a41v,
              @sysbuf^.suser.username, sizeof (sysbuf^.suser.username))
    ELSE
        IF  b_err <> e_sysinfo_not_found
        THEN
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43connected_users (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      b_err     : tgg00_BasisError;
      aux_file  : tgg00_FileId;
      mblock    : tgg00_MessBlock;
      data      : tsp00_Buf;
      qual      : tgg00_QualBuf;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    IF  ((a_current_user_kind = unoprivate) OR
        ( a_current_user_kind = uprivate))
        AND
        (a_curr_user_name <> a01controluser)
    THEN
        a07_b_put_error (acv, e_missing_privilege, 1);
    (*ENDIF*) 
    a4sh_kind := sh_connect;
    a40get_catalog_table (acv, a41v);
    IF  (a_returncode = 0) AND (a_ex_kind <> only_parsing)
    THEN
        BEGIN
        g04build_temp_tree_id (aux_file, a_transinf.tri_trans);
        aux_file.fileTfnTemp_gg00 := ttfnSaveScheme_egg00;
        a101_SetTempFileIndex (acv, aux_file, 1);
        g01mblock_init (a_transinf.tri_trans,
              m_show, mm_user, mblock);
        g01datapart_init (mblock, @data, sizeof (data));
        mblock.mb_struct           := mbs_buf;
        mblock.mb_data^.mbp_buf[1] := chr(ord(g01code.ctype));
        mblock.mb_data_len         := 1;
        g01qual_init (mblock, @qual, sizeof (qual));
        a06set_mtree (acv, mblock, aux_file);
        mblock.mb_qual_len := sizeof (aux_file);
        a06rsend_mess_buf (acv, mblock, cak_return_req, b_err);
        a101_GetTempFileInstance (acv.a_transinf.tri_trans, aux_file);
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1)
        ELSE
            ak43add_connected_users (acv, a41v, aux_file);
        (*ENDIF*) 
        a101_DestroyGroupedTempFile (a_transinf.tri_trans, aux_file);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43add_connected_users (
            VAR acv     : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            VAR tree    : tgg00_FileId);
 
VAR
      b_err        : tgg00_BasisError;
      rec_len      : tsp_int_map_c2;
      key_len      : tsp_int_map_c2;
      pos          : integer;
      userid       : tgg00_UserId;
      session      : tgg91_SessionNo;
      int_session  : tsp00_Int4;
      ak_cache     : tsp00_Int4;
      b_ptr        : tsp00_MoveObjPtr;
      set_result   : tgg00_BdSetResultRecord;
      tree_pos     : tgg00_FilePos;
      zerokey      : tgg00_Lkey;
      userName     : tsp00_KnlIdentifier;
      b            : ARRAY[1..8192] OF char;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    b_ptr := @b;
    WITH set_result DO
        BEGIN
        bd_key_check_len:= 0;
        bd_max_rec_cnt  := csp_maxint2;
        bd_max_fill_len := sizeof (b);
        bd_next         := false;
        END;
    (*ENDWITH*) 
    zerokey.len     := 0;
    tree_pos.tpsPno_gg00  := NIL_PAGE_NO_GG00;
    REPEAT
        b07cnext_record (a_transinf.tri_trans, tree,
              zerokey, set_result, tree_pos, b_ptr^);
        b_err := a_transinf.tri_trans.trError_gg00;
        IF  (b_err = e_ok) OR (b_err = e_key_not_found) OR
            (b_err = e_buffer_limit)
        THEN
            BEGIN
            pos    := 1;
            WHILE pos < set_result.bd_fill_len DO
                BEGIN
                rec_len.map_c2[1] := b[pos  ];
                rec_len.map_c2[2] := b[pos+1];
                key_len.map_c2[1] := b[pos+2];
                key_len.map_c2[2] := b[pos+3];
                userid[1] := b[pos+cgg_rec_key_offset+key_len.map_int+1];
                userid[2] := b[pos+cgg_rec_key_offset+key_len.map_int+2];
                userid[3] := b[pos+cgg_rec_key_offset+key_len.map_int+3];
                userid[4] := b[pos+cgg_rec_key_offset+key_len.map_int+4];
                ak43get_username (acv, userid, userName);
                a40move (acv, a41v,
                      @userName, sizeof (userName));
                a40move_const (acv, a41v,
                      @b[pos+cgg_rec_key_offset+key_len.map_int+1 +
                      sizeof(userid) + 1],
                      mxsp_termid);
                int_session := abs (s20buf_to_int4_swap (b_ptr^,
                      pos+rec_len.map_int - mxsp_c4 - 2,
                      sw_normal, g01code.kernel_swap));
                s20int4_to_buf_swap (int_session, g01code.kernel_swap,
                      session.ci4_gg00, 1, sw_normal);
                a51cache_size_info (acv, session, ak_cache);
                a40move_i4 (acv, a41v, int_session,
                      NOT c_null, 0, NOT c_to_undef);
                a40move_i4 (acv, a41v, ak_cache,
                      ak_cache = csp_maxint4, 0, NOT c_to_undef);
                pos := pos + rec_len.map_int
                END;
            (*ENDWHILE*) 
            IF  b_err = e_buffer_limit
            THEN
                b_err := e_ok
            ELSE
                b_err := e_no_next_record;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    UNTIL
        (b_err <> e_ok) OR (a_returncode <> 0);
    (*ENDREPEAT*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43get_username (
            VAR acv      : tak_all_command_glob;
            VAR userid   : tgg00_UserId;
            VAR username : tsp00_KnlIdentifier);
 
VAR
      i             : integer;
      userSurrogate : tgg00_Surrogate;
 
BEGIN
IF  userid = cak_util_userid
THEN
    username := a01controluser
ELSE
    BEGIN
    userSurrogate[1] := chr(255);
    userSurrogate[2] := chr(255);
    userSurrogate[3] := chr(0);
    userSurrogate[4] := chr(0);
    FOR i := 1 TO sizeof (tgg00_UserId) DO
        userSurrogate[sizeof(userSurrogate) - sizeof (tgg00_UserId) + i] :=
              userid[i];
    (*ENDFOR*) 
    a06determine_username (acv, userSurrogate, username);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak43perm_count (VAR acv : tak_all_command_glob) : tsp00_Int4;
 
VAR
      b_err      : tgg00_BasisError;
      perm_count : tsp00_Int4;
      aux_tree   : tgg00_FileId;
      qual       : tgg00_FileId;
      mblock     : tgg00_MessBlock;
 
BEGIN
perm_count := csp_maxint4;
IF  NOT gg06IsNilRef (acv.a_user_perm_ref)
THEN
    BEGIN
    aux_tree                  := b01niltree_id;
    aux_tree.fileUserRef_gg00 := acv.a_user_perm_ref;
    g01mblock_init (acv.a_transinf.tri_trans,
          m_show, mm_pages, mblock);
    g01qual_init  (mblock, @qual, sizeof (qual));
    a06set_mtree  (acv, mblock, aux_tree);
    mblock.mb_qual_len := sizeof (aux_tree);
    mblock.mb_struct   := mbs_tree_id;
    a06rsend_mess_buf (acv, mblock, cak_return_req, b_err);
    IF  b_err = e_ok
    THEN
        perm_count := s20buf_to_int4(mblock.mb_qual^.buf, INT4_MXSP00 + 1)
    ELSE
        a07_b_put_error (acv, b_err, 0)
    (*ENDIF*) 
    END;
(*ENDIF*) 
ak43perm_count := perm_count
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43privileges (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
CONST
      ln_grantee        = 'GRANTEE           ';
      ln_grantor        = 'GRANTOR           ';
      c_inclusiveSerial = true;
 
VAR
      full_spec     : boolean;
      is_private    : boolean;
      ok            : boolean;
      use_tables    : boolean;
      use_base      : boolean;
      use_view      : boolean;
      use_sequences : boolean;
      use_dbprocs   : boolean;
      use_grantee   : boolean;
      use_grantor   : boolean;
      use_public    : boolean;
      use_roles     : boolean;
      value         : tsp00_KnlIdentifier;
      _work_buf     : tak40_int2_arr_ptr;
 
BEGIN
(* returns all privileges the current user has granted or *)
(* received. Privileges on own objects of the user are    *)
(* treated like privileges he has granted to himself      *)
(* Objects to be considered are tables, dbprocedures and  *)
(* sequences                                              *)
a722init_epos_reccol_relation( acv, _work_buf );
a40get_catalog_table (acv, a41v);
IF  acv.a_returncode = 0
THEN
    WITH a41v DO
        BEGIN
        (* check, if value 'TABLE' in column TYPE is required *)
        a01sets_identifier (value, 'TABLE             ');
        use_base  := a722test_col_qual (acv,
              a41v, cak_ln_type, ' ', @value, 10, _work_buf);
        (* check, if value 'VIEW' in column TYPE is required *)
        a01sets_identifier (value, 'VIEW              ');
        use_view  := a722test_col_qual (acv,
              a41v, cak_ln_type, ' ', @value, 8, _work_buf);
        use_tables    := use_base OR use_view;
        (* check, if value 'SEQUENCE' in column TYPE is required *)
        a01sets_identifier (value, 'SEQUENCE          ');
        use_sequences := a722test_col_qual (acv,
              a41v, cak_ln_type, ' ', @value, 16, _work_buf);
        (* check, if value 'DBPROC' in column TYPE is required *)
        a01sets_identifier (value, 'DBPROC            ');
        use_dbprocs := a722test_col_qual (acv,
              a41v, cak_ln_type, ' ', @value, 12, _work_buf);
        (* check, if value 'ROLE' in column TYPE is required *)
        a01sets_identifier (value, 'ROLE              ');
        use_roles := a722test_col_qual (acv,
              a41v, cak_ln_type, ' ', @value, 12, _work_buf);
        value         := acv.a_curr_user_name;
        use_grantee   := a722test_col_qual (acv,
              a41v, ln_grantee, ' ', @value, sizeof (value), _work_buf);
        use_grantor   := a722test_col_qual (acv,
              a41v, ln_grantor, ' ', @value, sizeof (value), _work_buf);
        value         := a01_i_public;
        use_public    := a722test_col_qual (acv,
              a41v, ln_grantee, ' ', @value, 12, _work_buf);
        (* handle tables and sequences first *)
        full_spec :=
              (a4authname <> a01_il_b_identifier )
              AND
              (a4tablen <> a01_il_b_identifier );
        IF  use_tables OR use_sequences
        THEN
            BEGIN
            IF  NOT full_spec
            THEN
                BEGIN
                a40init_table_scan (acv, a41v, c_scan_temp,
                      c_scan_private, c_scan_nonprivate, c_scan_public,
                      NOT c_use_synonyms, c_all_base);
                a4use_base     := use_base;
                a4use_view     := use_view;
                END;
            (*ENDIF*) 
            REPEAT
                IF  full_spec
                THEN
                    BEGIN
                    a4next_owner  := a4authname;
                    a4next_tablen := a4tablen;
                    a4temp        :=
                          a4next_owner = a01_i_temp ;
                    a4private     := a4next_owner = acv.a_curr_user_name;
                    a4nonprivate  := NOT a4private;
                    ok            := false;
                    IF  use_tables
                    THEN
                        BEGIN
                        use_tables := false;
                        ok := a06_table_exist (acv,
                              d_fix, a4next_owner, a4next_tablen,
                              a4p_arr, c_all_base);
                        END;
                    (*ENDIF*) 
                    IF  NOT ok AND use_sequences
                    THEN
                        BEGIN
                        use_sequences := false;
                        ok := a23exist_sequence (acv, cak_is_undefined,
                              NOT c_inclusiveSerial,
                              a4p_arr.pbasep, a4next_owner,
                              a4next_tablen)
                        END
                    (*ENDIF*) 
                    END
                ELSE
                    ok := a40next_table (acv, a41v);
                (*ENDIF*) 
                IF  ok
                THEN
                    IF  a4p_arr.pbasep^.syskey.sentrytyp = cak_esequence
                    THEN
                        BEGIN
                        IF  use_sequences
                        THEN
                            ak43put_sequence_privileges (acv, a41v)
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        is_private := a4private OR (a4p_arr.pbasep^.sbase.bauthid = acv.a_curr_user_id);
                        IF  a4temp OR is_private
                        THEN
                            BEGIN
                            IF  use_grantor AND use_grantee
                            THEN
                                ak43put_owner_privileges (acv, a41v);
                            (*ENDIF*) 
                            IF  is_private
                            THEN
                                a43get_granted_priv (acv, a41v,
                                      a4next_owner, a4next_tablen)
                            (*ENDIF*) 
                            END
                        ELSE
                            ak43put_received_privileges (acv,
                                  a41v, NOT (a4nonprivate OR a4public),
                                  use_grantee, use_public)
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
            UNTIL
                NOT ok OR (acv.a_returncode <> 0);
            (*ENDREPEAT*) 
            END;
        (*ENDIF*) 
        IF  NOT full_spec
        THEN
            a40FinishTableScan (acv, a41v);
        (*ENDIF*) 
        IF  (acv.a_returncode = 0) AND use_dbprocs
        THEN
            ak43dbproc_privileges (acv, a41v, _work_buf);
        (*ENDIF*) 
        IF  (acv.a_returncode = 0) AND use_roles
        THEN
            ak43role_role_privileges (acv, a41v)
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
a722finalize_epos_reccol_relation( acv, _work_buf );
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43role_role_privileges (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      b_err       : tgg00_BasisError;
      roletab_ptr : tak_sysbufferaddress;
      ix          : integer;
      sysk        : tgg00_SysInfoKey;
 
BEGIN
sysk           := a01defaultkey;
sysk.sauthid   := acv.a_curr_user_id;
sysk.sentrytyp := cak_eroletab;
REPEAT
    a10get_sysinfo (acv, sysk, d_fix, roletab_ptr, b_err);
    IF  b_err = e_ok
    THEN
        WITH roletab_ptr^.susertab DO
            BEGIN
            FOR ix := 1 TO usertabcount DO
                IF  NOT usertabdef[ix].ut_empty
                THEN
                    ak43role_privileges (acv,
                          a41v, usertabdef[ix].ut_surrogate);
                (*ENDIF*) 
            (*ENDFOR*) 
            FOR ix := 1 TO usertabcount DO
                IF  NOT usertabdef[ix].ut_empty
                THEN
                    ak43dependant_roles (acv,
                          a41v, usertabdef[ix].ut_surrogate);
                (*ENDIF*) 
            (*ENDFOR*) 
            a10rel_sysinfo (roletab_ptr);
            IF  usertabnext_exist
            THEN
                a06inc_linkage (sysk.slinkage)
            ELSE
                b_err := e_sysinfo_not_found;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
UNTIL
    b_err <> e_ok;
(*ENDREPEAT*) 
IF  b_err <> e_sysinfo_not_found
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
b01empty_file (acv.a_transinf.tri_trans, acv.a_into_tree)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43role_privileges (
            VAR acv     : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            VAR role_id : tgg00_Surrogate);
 
VAR
      first      : boolean;
      b_err      : tgg00_BasisError;
      priv_p     : tak_sysbufferaddress;
      role_p     : tak_sysbufferaddress;
      role_owner : tsp00_KnlIdentifier;
      role       : tsp00_KnlIdentifier;
      priv       : tak_privilege;
      rolekey    : tgg00_SysInfoKey;
      sysk       : tgg00_SysInfoKey;
 
BEGIN
IF  ak43unique (acv, NOT c_is_synonym, role_id, role_id)
THEN
    BEGIN
    first          := true;
    sysk           := a01defaultkey;
    sysk.sauthid   := role_id;
    sysk.sentrytyp := cak_eprivuser;
    REPEAT
        a10next_sysinfo (acv, sysk,
              SURROGATE_MXGG00 + 2, d_release,
              cak_eprivuser, priv_p, b_err);
        IF  b_err = e_ok
        THEN
            IF  first
            THEN
                BEGIN
                first             := false;
                priv              := a01emptypriv;
                priv.priv_all_set := [r_sel];
                rolekey.sauthid   := role_id;
                rolekey.sentrytyp := cak_euser;
                rolekey.slinkage  := cak_init_linkage;
                rolekey.skeylen   := mxak_standard_sysk;
                a10get_sysinfo (acv, rolekey,
                      d_release, role_p, b_err);
                IF  b_err = e_ok
                THEN
                    BEGIN
                    role := role_p^.suser.username;
                    a06determine_username (acv,
                          role_p^.suser.userowner_id, role_owner)
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            BEGIN
            ak43spriv_granted_to_show (acv, a41v, a01_il_b_identifier, role_owner, role, cak_i_role,
                  priv, priv_p^.syskey.suserid, priv_p^.syskey.sgrantuser,
                  priv_p^.sprivuser.pru_date, priv_p^.sprivuser.pru_time);
            END;
        (*ENDIF*) 
    UNTIL
        b_err <> e_ok;
    (*ENDREPEAT*) 
    IF  b_err <> e_no_next_record
    THEN
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43dependant_roles (
            VAR acv    : tak_all_command_glob;
            VAR a41v   : tak40_show_glob;
            role_id    : tgg00_Surrogate);
 
VAR
      b_err       : tgg00_BasisError;
      roletab_ptr : tak_sysbufferaddress;
      ix          : integer;
      sysk        : tgg00_SysInfoKey;
 
BEGIN
sysk           := a01defaultkey;
sysk.sauthid   := role_id;
sysk.sentrytyp := cak_eroletab;
ix             := 0;
REPEAT
    a10get_sysinfo (acv, sysk, d_fix, roletab_ptr, b_err);
    IF  b_err = e_ok
    THEN
        WITH roletab_ptr^.susertab DO
            BEGIN
            ix := ix + 1;
            IF  ix > usertabcount
            THEN
                BEGIN
                a10rel_sysinfo (roletab_ptr);
                IF  usertabnext_exist
                THEN
                    a06inc_linkage (sysk.slinkage)
                ELSE
                    b_err := e_sysinfo_not_found
                (*ENDIF*) 
                END
            ELSE
                IF  NOT usertabdef[ix].ut_empty
                THEN
                    BEGIN
                    ak43role_privileges (acv, a41v,
                          usertabdef[ix].ut_surrogate);
                    a10rel_sysinfo      (roletab_ptr);
                    ak43dependant_roles (acv, a41v,
                          usertabdef[ix].ut_surrogate)
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
UNTIL
    b_err <> e_ok;
(*ENDREPEAT*) 
IF  b_err <> e_sysinfo_not_found
THEN
    a07_b_put_error (acv, b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43put_owner_privileges (
            VAR acv    : tak_all_command_glob;
            VAR a41v   : tak40_show_glob);
 
VAR
      priv      : tak_privilege;
      schema    : tsp00_KnlIdentifier;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    a06_get_priv (acv, a4p_arr.pbasep, priv);
    IF  a_returncode = 0
    THEN
        BEGIN
        a103GetSchemaName (acv, a4p_arr.pbasep^.sbase.bschema, schema);
        ak43spriv_granted_to_show (acv, a41v, schema, a_curr_user_name,
              a4p_arr.pbasep^.sbase.btablen^,
              ak43table_kind (a4p_arr.pbasep^.sbase), priv,
              a_curr_user_id, a_curr_user_id,
              a4p_arr.pbasep^.sbase.bdatecreate,
              a4p_arr.pbasep^.sbase.btimecreate)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43put_received_privileges (
            VAR acv     : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            is_role     : boolean;
            use_grantee : boolean;
            use_public  : boolean);
 
CONST
      e_skip_table = -1;
 
VAR
      public_loop : boolean;
      put_granted : boolean;
      tab_kind    : integer;
      b_err       : tgg00_BasisError;
      priv_p      : tak_sysbufferaddress;
      sysk        : tgg00_SysInfoKey;
      priv        : tak_privilege;
      owner       : tsp00_KnlIdentifier;
      schema      : tsp00_KnlIdentifier;
 
BEGIN
WITH acv, a41v DO
    BEGIN
&   ifdef trace
    t01int4 (ak_sem, 'use_grantee ', ord (use_grantee));
    t01int4 (ak_sem, 'use_public  ', ord (use_public));
&   endif
    public_loop := NOT use_grantee AND NOT is_role;
    put_granted := false;
    tab_kind    := ak43table_kind (a4p_arr.pbasep^.sbase);
    REPEAT
        (* get all privileges of table identified by a4p_arr *)
        (* granted to current user or to public              *)
        sysk           := a41v.a4p_arr.pbasep^.syskey;
        a06determine_username (acv, a41v.a4p_arr.pbasep^.sbase.bauthid, owner);
        a103GetSchemaName (acv, a41v.a4p_arr.pbasep^.sbase.bschema, schema);
        sysk.sentrytyp := cak_eprivuser;
        IF  public_loop
        THEN
            sysk.suserid   := cak_public_id
        ELSE
            IF  is_role
            THEN
                sysk.suserid := a4next_key.sauthid
            ELSE
                sysk.suserid   := acv.a_curr_user_id;
            (*ENDIF*) 
        (*ENDIF*) 
        sysk.skeylen   := sysk.skeylen + SURROGATE_MXGG00;
        REPEAT
            a10next_sysinfo (acv, sysk,
                  mxak_standard_sysk + SURROGATE_MXGG00, d_release,
                  cak_eprivuser, priv_p, b_err);
            IF  b_err <> e_ok
            THEN
                BEGIN
                IF  b_err <> e_no_next_record
                THEN
                    BEGIN
                    a07_b_put_error (acv, b_err, 1);
                    a40ignore_down_error (acv);
                    IF  a_returncode = 0
                    THEN (* skip current table *)
                        b_err := e_skip_table
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                priv := a01emptypriv;
                a06unpack_priv (priv_p^.sprivuser.pru_priv, priv);
                ak43spriv_granted_to_show (acv, a41v, schema, owner,
                      a4next_tablen, tab_kind, priv,
                      priv_p^.syskey.suserid, priv_p^.syskey.sgrantuser,
                      priv_p^.sprivuser.pru_date,
                      priv_p^.sprivuser.pru_time);
                IF  NOT public_loop AND
                    (priv.priv_all_grant_set <> []) OR
                    (priv.priv_grant_sel_set <> []) OR
                    (priv.priv_grant_upd_set <> [])
                THEN (* curr user has grant option for any priv *)
                    put_granted := true
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            b_err <> e_ok;
        (*ENDREPEAT*) 
        IF  (b_err = e_no_next_record) AND
            NOT public_loop AND use_public
        THEN
            BEGIN
            b_err       := e_ok;
            public_loop := true
            END;
        (*ENDIF*) 
    UNTIL
        b_err <> e_ok;
    (*ENDREPEAT*) 
    IF  (b_err <> e_no_next_record) AND (b_err <> e_skip_table)
    THEN
        a07_b_put_error (acv, b_err, 1)
    ELSE
        IF  put_granted
        THEN
            (* curr user has grant option for curr table   *)
            (* determine privileges for this table granted *)
            (* by current user                             *)
            a43get_granted_priv (acv, a41v,
                  a4next_owner, a4next_tablen)
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43put_sequence_privileges (
            VAR acv    : tak_all_command_glob;
            VAR a41v   : tak40_show_glob);
 
CONST
      c_exit_loop = 3;
 
VAR
      exit_loop      : boolean;
      repeat_cnt     : integer;
      b_err          : tgg00_BasisError;
      priv_p         : tak_sysbufferaddress;
      priv           : tak_privilege;
      grantee_id     : tgg00_Surrogate;
      seq_owner_name : tsp00_KnlIdentifier;
      schema         : tsp00_KnlIdentifier;
      sysk           : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a41v, a4p_arr.pbasep^.ssequence DO
    BEGIN
    priv := a01emptypriv;
    a103GetSchemaName (acv, seq_schema, schema);
    IF  seq_owner = a_curr_user_id
    THEN
        BEGIN
        (* current user is owner of sequence *)
        priv.priv_all_set       := [r_sel];
        priv.priv_all_grant_set := [r_sel];
        (* describe owner privilege *)
        ak43spriv_granted_to_show (acv, a41v, schema, a_curr_user_name,
              seq_name, cak_i_sequence, priv, a_curr_user_id,
              a_curr_user_id, seq_date, seq_time);
        priv.priv_all_grant_set := [];
        (* describe privileges granted by owner *)
        sysk           := a01defaultkey;
        sysk.stableid  := seq_surrogate;
        sysk.sentrytyp := cak_esequencepriv;
        REPEAT
            a10next_sysinfo (acv, sysk,
                  SURROGATE_MXGG00, d_release, cak_esequencepriv, priv_p, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                priv.priv_all_set := [r_sel];
                IF  priv_p^.sprocseqpriv.psp_grantOption
                THEN
                    priv.priv_all_grant_set := [r_sel];
                (*ENDIF*) 
                ak43spriv_granted_to_show (acv,
                      a41v, schema, a_curr_user_name,
                      seq_name, cak_i_sequence, priv, sysk.suserid,
                      a_curr_user_id, priv_p^.sprocseqpriv.psp_date, priv_p^.sprocseqpriv.psp_time);
                END;
            (*ENDIF*) 
        UNTIL
            (b_err <> e_ok) OR (acv.a_returncode <> 0);
        (*ENDREPEAT*) 
        IF  b_err <> e_no_next_record
        THEN
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        (* current user is not owner of the sequence ==> *)
        (* current user has select privilege only        *)
        a06determine_username (acv,
              seq_owner, seq_owner_name);
        repeat_cnt := 0;
        exit_loop  := false;
        REPEAT
            repeat_cnt := repeat_cnt + 1;
            IF  (a4next_key.sauthid[1] = chr(255)) AND
                (a4next_key.sauthid[2] = chr(250))
            THEN (* sequence granted to role *)
                BEGIN
                exit_loop  := true;
                grantee_id := a4next_key.sauthid
                END
            ELSE
                IF  a4nonprivate AND (repeat_cnt = 1)
                THEN
                    grantee_id := a_curr_user_id
                ELSE
                    IF  (repeat_cnt <= 2) AND seq_public
                    THEN
                        BEGIN
                        repeat_cnt := 2;
                        grantee_id := cak_public_id
                        END
                    ELSE
                        repeat_cnt := c_exit_loop;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            IF  repeat_cnt <> c_exit_loop
            THEN
                BEGIN
                sysk           := a01defaultkey;
                sysk.stableid  := seq_surrogate;
                sysk.sentrytyp := cak_esequencepriv;
                sysk.suserid   := grantee_id;
                sysk.skeylen   := sysk.skeylen + SURROGATE_MXGG00;
                a10get_sysinfo (acv, sysk,
                      d_release, priv_p, b_err);
                IF  b_err = e_ok
                THEN
                    BEGIN
                    priv.priv_all_set := [r_sel];
                    IF  priv_p^.sprocseqpriv.psp_grantOption
                    THEN
                        priv.priv_all_grant_set := [r_sel];
                    (*ENDIF*) 
                    ak43spriv_granted_to_show (acv, a41v, schema,
                          seq_owner_name, seq_name, cak_i_sequence,
                          priv, grantee_id, seq_owner,
                          priv_p^.sprocseqpriv.psp_date,
                          priv_p^.sprocseqpriv.psp_time);
                    END
                ELSE
                    a07_b_put_error (acv, b_err, 1)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            (repeat_cnt = c_exit_loop) OR exit_loop;
        (*ENDREPEAT*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43dbproc_privileges (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            work_buf : tak40_int2_arr_ptr);
 
CONST
      ln_owner = 'OWNER             ';
 
VAR
      init_unique : boolean;
      b_err       : tgg00_BasisError;
      dummy       : tgg00_TableKind;
      repeat_cnt  : integer;
      proc_p      : tak_sysbufferaddress;
      priv_p      : tak_sysbufferaddress;
      grantee_id  : tgg00_Surrogate;
      proc_id     : tgg00_Surrogate;
      owner_name  : tsp00_KnlIdentifier;
      schema      : tsp00_KnlIdentifier;
      priv        : tak_privilege;
      sysk        : tgg00_SysInfoKey;
      mei_sysk    : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    b_err             := e_ok;
    priv              := a01emptypriv;
    priv.priv_all_set := [r_sel];
    IF  a722test_col_qual (acv, a41v, ln_owner, ' ', @a_curr_user_name,
        sizeof (a_curr_user_name), work_buf)
    THEN
        BEGIN
        (* handle dbprocs owned by current user first *)
        sysk           := a01defaultkey;
        sysk.sauthid   := a_curr_user_id;
        sysk.sentrytyp := cak_emethodref;
        REPEAT
            (* find next dbproc owned by current user *)
            a10next_sysinfo (acv, sysk, SURROGATE_MXGG00 + 2, d_release,
                  cak_emethodref, proc_p, b_err);
            IF  b_err = e_ok
            THEN
                IF  proc_p^.smethodref.mrf_type = dbo_dbproc
                THEN
                    BEGIN
                    mei_sysk           := a01defaultkey;
                    mei_sysk.stableid  := proc_p^.smethodref.mrf_method_id;
                    mei_sysk.sentrytyp := cak_emethodinfo;
                    a10get_sysinfo (acv, mei_sysk,
                          d_release, proc_p, b_err);
                    IF  b_err = e_ok
                    THEN
                        BEGIN
                        priv.priv_all_grant_set := [r_sel];
                        ak43spriv_granted_to_show (acv,
                              a41v, a_curr_user_name, a_curr_user_name,
                              proc_p^.smethodinfo.mei_name, cak_i_dbproc, priv,
                              a_curr_user_id, a_curr_user_id,
                              proc_p^.smethodinfo.mei_date,
                              proc_p^.smethodinfo.mei_time);
                        IF  a_returncode = 0
                        THEN
                            BEGIN
                            (* determine granted privileges *)
                            (* of current dbproc            *)
                            ak43dbproc_granted_privileges (acv,
                                  a41v, priv, proc_p)
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        UNTIL
            (b_err <> e_ok) OR (a_returncode <> 0);
        (*ENDREPEAT*) 
        IF  b_err = e_no_next_record
        THEN
            b_err := e_ok
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (b_err = e_ok) AND (a4authname <> a_curr_user_name)
    THEN
        BEGIN
        (* find all dbprocs of other users visible for curr user *)
        init_unique             := a4unique;
        priv.priv_all_grant_set := [];
        repeat_cnt              := 0;
        REPEAT
            repeat_cnt := repeat_cnt + 1;
            a40init_table_scan (acv, a41v,
                  NOT c_scan_temp, NOT c_scan_private, c_scan_nonprivate,
                  c_scan_public, NOT c_use_synonyms, NOT c_all_base);
            a4b_err              := e_ok;
            a4next_key           := a01defaultkey;
            a4next_key.sentrytyp := cak_eusertab;
            IF  repeat_cnt = 1
            THEN
                BEGIN (* scan usertab record of current user *)
                a4next_key.sauthid := a_curr_user_id;
                END
            ELSE
                BEGIN (* scan public usertab record *)
                a4next_key.sauthid := cak_public_id;
                END;
            (*ENDIF*) 
            a4unique := false;
            WHILE a40usertab_next (acv, a41v, NOT c_use_tables,
                  c_use_dbprocs, NOT c_use_sequences,
                  proc_id, dummy) DO
                BEGIN
                sysk           := a01defaultkey;
                sysk.sentrytyp := cak_emethodinfo;
                sysk.stableid  := proc_id;
                a10get_sysinfo (acv, sysk,
                      d_release, proc_p, b_err);
                IF  b_err = e_ok
                THEN
                    WITH proc_p^.smethodinfo DO
                        BEGIN
                        a103GetSchemaName (acv, mei_schema, schema);
                        IF  mei_owner <> a_curr_user_id
                        THEN
                            BEGIN
                            a06determine_username (acv,
                                  mei_owner, owner_name);
                            IF  repeat_cnt = 1
                            THEN
                                grantee_id := a_curr_user_id
                            ELSE
                                grantee_id := cak_public_id;
                            (*ENDIF*) 
                            sysk.sentrytyp := cak_eprocpriv;
                            sysk.suserid   := grantee_id;
                            sysk.skeylen   :=
                                  sysk.skeylen + SURROGATE_MXGG00;
                            a10get_sysinfo (acv, sysk,
                                  d_release, priv_p, b_err);
                            IF  b_err = e_ok
                            THEN
                                ak43spriv_granted_to_show (acv, a41v,
                                      schema, owner_name, mei_name, cak_i_dbproc,
                                      priv, grantee_id, mei_owner,
                                      priv_p^.sprocseqpriv.psp_date,
                                      priv_p^.sprocseqpriv.psp_time)
                            ELSE
                                a07_b_put_error (acv, b_err, 1)
                            (*ENDIF*) 
                            END
                        ELSE
                            IF  repeat_cnt = 1
                            THEN
                                BEGIN
                                priv.priv_all_grant_set := [r_sel];
                                ak43spriv_granted_to_show (acv,
                                      a41v, schema, a_curr_user_name,
                                      proc_p^.smethodinfo.mei_name, cak_i_dbproc, priv,
                                      a_curr_user_id, a_curr_user_id,
                                      proc_p^.smethodinfo.mei_date,
                                      proc_p^.smethodinfo.mei_time);
                                IF  a_returncode = 0
                                THEN
                                    BEGIN
                                    (* determine granted privileges *)
                                    (* of current dbproc            *)
                                    ak43dbproc_granted_privileges (acv,
                                          a41v, priv, proc_p)
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            a40FinishTableScan (acv, a41v);
        UNTIL
            (repeat_cnt >= 2) OR (a_returncode <> 0);
        (*ENDREPEAT*) 
        a4unique := init_unique
        END;
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43dbproc_granted_privileges (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            VAR priv : tak_privilege;
            proc_p   : tak_sysbufferaddress);
 
VAR
      b_err     : tgg00_BasisError;
      priv_p    : tak_sysbufferaddress;
      proc      : tsp00_KnlIdentifier;
      schema    : tsp00_KnlIdentifier;
      sysk      : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
    priv.priv_all_grant_set := [];
    sysk                    := a01defaultkey;
    sysk.stableid           := proc_p^.smethodinfo.mei_surrogate;
    sysk.sentrytyp          := cak_eprocpriv;
    proc                    := proc_p^.smethodinfo.mei_name;
    REPEAT
        a10next_sysinfo (acv, sysk, SURROGATE_MXGG00 + 2, d_release,
              cak_eprocpriv, priv_p, b_err);
        IF  b_err = e_ok
        THEN
            WITH priv_p^.sprocseqpriv DO
                BEGIN
                a103GetSchemaName (acv, proc_p^.smethodinfo.mei_schema, schema);
                ak43spriv_granted_to_show (acv, a41v, schema,
                      a_curr_user_name, proc, cak_i_dbproc, priv,
                      sysk.suserid, a_curr_user_id, psp_date, psp_time);
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
    UNTIL
        (b_err <> e_ok) OR (a_returncode <> 0);
    (*ENDREPEAT*) 
    IF  b_err <> e_no_next_record
    THEN
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43granted_to (
            VAR acv    : tak_all_command_glob;
            VAR a41v   : tak40_show_glob);
 
VAR
      priv        : tak_privilege;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    a4sh_kind   := sh_priv_granted_to;
    a40get_catalog_table (acv, a41v);
    IF  (a4authname   <> a01_il_b_identifier ) AND
        (a4tablen     <> a01_il_b_identifier ) AND
        (a4tab_len    = sizeof (a4tablen))
    THEN (* table specified
          -> baserecords and privuserrecords can be
          processed direct *)
        BEGIN
        (*== get baserecord for specified table ==============*)
        IF   a06_table_exist (acv, d_fix, a4authname,
            a4tablen, a4p_arr, true)
        THEN
            (* table specified and table exists *)
            BEGIN
            a06_get_priv (acv, a4p_arr.pbasep, priv);
            IF  (priv.priv_all_set   <> [  ]) OR
                (priv.priv_col_exist <> [  ])
            THEN
                a43get_granted_priv (acv, a41v,
                      a4authname, a4tablen)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    ELSE (* no complete table-specification *)
        BEGIN
        a40init_table_scan (acv, a41v,
              NOT(c_scan_temp), c_scan_private, c_scan_nonprivate,
              NOT(c_scan_public), c_use_synonyms, c_all_base);
        WHILE a40next_table (acv, a41v) DO
            a43get_granted_priv (acv, a41v,
                  a4next_owner, a4next_tablen);
        (*ENDWHILE*) 
        a40FinishTableScan (acv, a41v);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a43get_granted_priv (
            VAR acv       : tak_all_command_glob;
            VAR a41v      : tak40_show_glob;
            VAR owner     : tsp00_KnlIdentifier;
            VAR tablename : tsp00_KnlIdentifier);
 
VAR
      next       : boolean;
      tab_kind   : integer;
      b_err      : tgg00_BasisError;
      granteeid  : tgg00_Surrogate;
      sysp       : tak_sysbufferaddress;
      sysk       : tgg00_SysInfoKey;
      schema     : tsp00_KnlIdentifier;
      userkey    : tgg00_SysInfoKey;
      priv       : tak_privilege;
 
BEGIN
(* process privrecords *)
(* initialize key for privrecords *)
sysk           := a01defaultkey;
sysk.stableid  := a41v.a4p_arr.pbasep^.syskey.stableid;
sysk.sentrytyp := cak_eprivuser;
IF  (a41v.a4user <> a01_il_b_identifier )
THEN
    BEGIN
    (* grantee specified -> grantee element of key *)
    IF  a41v.a4user = a01_i_public
    THEN
        granteeid := cak_public_id
    ELSE
        BEGIN
        a06det_user_id (acv, a41v.a4user, granteeid);
        IF  granteeid = cgg_zero_id
        THEN
            a07_b_put_error (acv, e_unknown_user,
                  acv.a_ap_tree^[ a41v.a4ci ].n_pos)
        ELSE
            BEGIN
            userkey            := a01defaultkey;
            userkey.sauthid    := granteeid;
            userkey.sentrytyp  := cak_euser;
            a10get_sysinfo (acv, userkey, d_release,
                  sysp, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                IF  sysp^.suser.urecordtyp = [ is_user_rec ]
                THEN (* specified user is group member *)
                    granteeid := sysp^.suser.usergroup_id
                (*ENDIF*) 
                END
            ELSE
                a07ak_system_error (acv, 43, 3)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    sysk.suserid := granteeid;
    sysk.skeylen := sysk.skeylen + SURROGATE_MXGG00;
    END;
(*ENDIF*) 
WITH a41v.a4p_arr.pbasep^ DO
    BEGIN
    tab_kind := ak43table_kind (sbase);
    END;
(*ENDWITH*) 
next := true;
(* get privrecords for current table and user *)
WHILE (next) AND (acv.a_returncode = 0) DO
    BEGIN
    (* get next privrecord *)
    a10next_sysinfo (acv, sysk, 0, d_fix,
          cak_eprivuser, sysp, b_err);
    IF  b_err <> e_ok
    THEN
        BEGIN
        next := false;
        IF  b_err <> e_no_next_record
        THEN
            BEGIN
            a07_b_put_error (acv, b_err, 1);
            a40ignore_down_error (acv);
            END
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        IF  (sysp^.syskey.stableid <>
            a41v.a4p_arr.pbasep^.syskey.stableid)
            (* current privrecord belongs to an other table *)
            OR
            ((a41v.a4user <> a01_il_b_identifier ) AND
            (sysp^.syskey.suserid <> granteeid))
            (* wrong grantee *)
        THEN
            next := false
        ELSE
            IF  NOT ((a41v.a4p_arr.pbasep^.sbase.bauthid <>
                acv.a_curr_user_id)
                (* current user is not owner of table ->
                      current user must be grantor *)
                AND (sysp^.syskey.sgrantuser <>
                acv.a_curr_user_id))
                OR
                (a41v.a4sh_kind = sh_all_priv_granted)
            THEN (* not (wrong grantor) *)
                BEGIN
                (* reset priv *)
                priv := a01emptypriv;
                a06unpack_priv (sysp^.sprivuser.pru_priv, priv);
                (* built record for output *)
                IF  sysp^.syskey.suserid <> sysp^.syskey.sgrantuser
                THEN (* grantee is not the grantor *)
                    BEGIN
                    a103GetSchemaName (acv, a41v.a4p_arr.pbasep^.sbase.bschema, schema);
                    (* grantee = grantor is possible for
                          sysdba and systables and for views, because
                          there are privilege records for the owners *)
                    ak43spriv_granted_to_show (acv, a41v, schema, owner,
                          tablename, tab_kind, priv,
                          sysp^.syskey.suserid, sysp^.syskey.sgrantuser,
                          sysp^.sprivuser.pru_date,
                          sysp^.sprivuser.pru_time);
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    a10_key_del (acv, sysk);
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43spriv_granted_to_show (
            VAR acv         : tak_all_command_glob;
            VAR a41v        : tak40_show_glob;
            VAR schema      : tsp00_KnlIdentifier;
            VAR owner       : tsp00_KnlIdentifier;
            VAR tablename   : tsp00_KnlIdentifier;
            object_kind     : integer;
            VAR priv        : tak_privilege;
            VAR granteeid   : tgg00_Surrogate;
            VAR grantorid   : tgg00_Surrogate;
            date            : tsp00_Int4;
            time            : tsp00_Int4);
 
VAR
      use_column    : boolean;
      undef_name2   : boolean;
      exit_loop     : boolean;
      ora_like      : boolean;
      b_err         : tgg00_BasisError;
      i             : integer;
      priv_colno    : integer;
      name2_colno   : integer;
      time_colno    : integer;
      userrec_buf   : tak_sysbufferaddress;
      col_ptr       : tak00_colinfo_ptr;
      c8            : tsp00_C8;
      grantee_name  : tsp00_KnlIdentifier;
      grantee_owner : tsp00_KnlIdentifier;
      grantor_name  : tsp00_KnlIdentifier;
      column        : tsp00_KnlIdentifier;
      column_set    : tak_columnset;
      prn           : tsp00_C40;
      sysk          : tgg00_SysInfoKey;
 
BEGIN
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    BEGIN
    WITH acv, a41v DO
        BEGIN
        a4pos    := 1;
        ora_like := (a4sh_kind in
              [sh_new_privileges, sh_all_new_privileges]);
        (* insert schema *)
        a40move (acv, a41v, @schema, sizeof (schema));
        (* insert owner *)
        IF  (a4sh_kind <> sh_priv_granted_to) AND (a4sh_kind <> sh_all_priv_granted)
        THEN
            a40move (acv, a41v, @owner, sizeof (owner));
        (* insert tablename *)
        (*ENDIF*) 
        a40move (acv, a41v, @tablename, sizeof (tablename));
        (* skip column 3, will be filled later *)
        name2_colno := a4pos;
        a4pos       := a4pos + 1;
        IF  (a4sh_kind <> sh_all_priv_granted) AND
            (a4sh_kind <> sh_priv_granted_to)
        THEN
            BEGIN
&           ifdef trace
            t01int4 (ak_sem, 'object_kind ', object_kind);
&           endif
            IF  a4is_systable
            THEN
                BEGIN
                c8 := 'SYSTEM  ';
                a40move_const (acv, a41v, @c8, sizeof (c8))
                END
            ELSE
                a40move_const (acv, a41v, @a01kw[object_kind], sizeof (c8))
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a06determine_username (acv, granteeid, grantee_name);
        a40move (acv, a41v, @grantee_name, sizeof (grantee_name));
        IF  (a4sh_kind <> sh_all_priv_granted) AND
            (a4sh_kind <> sh_priv_granted_to)
        THEN
            BEGIN
            IF  a4strategy.str_catalog.scat_col_needed [a4pos]
            THEN
                BEGIN (* determine owner of grantee *)
                IF  granteeid = cak_public_id
                THEN
                    a40move (acv, a41v, NIL, 0)
                ELSE
                    BEGIN
                    grantee_owner  := a01_il_b_identifier ;
                    sysk           := a01defaultkey;
                    sysk.sauthid   := granteeid;
                    sysk.sentrytyp := cak_euser;
                    a10get_sysinfo (acv, sysk, d_release,
                          userrec_buf, b_err);
                    IF  b_err = e_ok
                    THEN
                        a06determine_username (acv,
                              userrec_buf^.suser.userowner_id,
                              grantee_owner);
                    (*ENDIF*) 
                    a40move (acv, a41v, @grantee_owner,
                          sizeof (grantee_owner))
                    END
                (*ENDIF*) 
                END
            ELSE
                a4pos := a4pos + 1
            (*ENDIF*) 
            END;
        (* skip column privileges, will be filled later *)
        (*ENDIF*) 
        priv_colno := a4pos;
        a4pos      := a4pos + 1;
        (* insert grantor *)
        a06determine_username (acv, grantorid, grantor_name);
        IF  (a4sh_kind <> sh_all_priv_granted) AND
            (a4sh_kind <> sh_priv_granted_to)
        THEN
            BEGIN
            a40move          (acv, a41v, @grantor_name, sizeof (grantor_name));
            a40put_date_time (acv, a41v, date, true,  date < 0);
            time_colno := a4pos
            END;
        (*ENDIF*) 
        IF  ora_like
        THEN
            priv.priv_all_set := priv.priv_all_set - [r_owner];
        (*ENDIF*) 
        exit_loop := false;
        WHILE NOT exit_loop AND (priv.priv_all_set <> [  ]) DO
            BEGIN
            undef_name2 := false;
            CASE object_kind OF
                cak_i_sequence,
                cak_i_table,    cak_i_view :
                    BEGIN
                    (* insert privileges for all columns *)
                    IF  ora_like
                    THEN
                        ak43put_one_priv (priv, prn)
                    ELSE
                        BEGIN
                        a40_p_priv (priv, prn, -1);
                        exit_loop := true
                        END;
                    (*ENDIF*) 
                    undef_name2 := true
                    END;
                cak_i_dbproc :
                    BEGIN
                    prn := bsp_c40;
                    IF  r_sel in priv.priv_all_set
                    THEN
                        BEGIN
                        prn[1] := 'E';
                        prn[2] := 'X';
                        prn[3] := 'E';
                        prn[4] := 'C';
                        prn[5] := 'U';
                        prn[6] := 'T';
                        prn[7] := 'E';
                        END;
                    (*ENDIF*) 
                    IF  r_sel in priv.priv_all_grant_set
                    THEN
                        prn[8] := '+';
                    (*ENDIF*) 
                    undef_name2 := true;
                    exit_loop   := true
                    END;
                cak_i_role :
                    BEGIN
                    prn         := bsp_c40;
                    undef_name2 := true;
                    exit_loop   := true
                    END;
                END;
            (*ENDCASE*) 
            a4pos := name2_colno;
            IF  undef_name2
            THEN
                a40move (acv, a41v, NIL, 0)
            ELSE
                a40move_const (acv, a41v, @column, sizeof (column));
            (*ENDIF*) 
            (* insert privileges *)
            a4pos := priv_colno;
            a40move_const (acv, a41v, @prn, sizeof (prn));
            IF  (a4sh_kind <> sh_all_priv_granted) AND
                (a4sh_kind <> sh_priv_granted_to)
            THEN
                BEGIN
                a4pos := time_colno;
                a40put_date_time (acv, a41v, time, false, time < 0)
                END
            ELSE
                a40move (acv, a41v, @grantor_name, sizeof (grantor_name));
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        i       := 1;
        IF  priv.priv_col_exist <> []
        THEN
            BEGIN
            (* column privileges *)
            column_set := priv.priv_sel_set + priv.priv_grant_sel_set +
                  priv.priv_upd_set + priv.priv_grant_upd_set +
                  priv.priv_ref_set + priv.priv_grant_ref_set;
            WITH a4p_arr.pbasep^.sbase DO
                WHILE (i <= bmaxcol) AND
                      (a_returncode = 0) DO
                    BEGIN
                    a06extcolno (a4p_arr.pbasep^.sbase, i, col_ptr);
                    WITH col_ptr^ DO
                        BEGIN
                        use_column := NOT (ctdropped in ccolpropset)   AND
                              NOT (ctinvisible in ccolpropset) AND
                              (cextcolno in column_set);
                        IF  use_column
                        THEN
                            BEGIN
                            a061get_colname (col_ptr^, column);
                            use_column := column <> a01_i_tablekey
                            END;
                        (*ENDIF*) 
                        IF  use_column
                        THEN
                            BEGIN
                            (* insert columnname *)
                            a4pos := name2_colno;
                            a40move (acv, a41v, @ccolumnn, ord (ccolumnn_len));
                            a4pos := priv_colno;
                            REPEAT
                                exit_loop := true;
                                IF  ora_like
                                THEN
                                    ak43one_col_priv (priv,
                                          prn, i, exit_loop)
                                ELSE
                                    a40_p_priv (priv, prn, i);
                                (*ENDIF*) 
                                a40move_const (acv,
                                      a41v, @prn, sizeof (prn));
                                IF  (a4sh_kind <> sh_all_priv_granted) AND
                                    (a4sh_kind <> sh_priv_granted_to)
                                THEN
                                    BEGIN
                                    a4pos := time_colno;
                                    a40put_date_time (acv, a41v, time, false, time < 0)
                                    END
                                ELSE
                                    a40move (acv, a41v, @grantor_name, sizeof (grantor_name));
                                (*ENDIF*) 
                            UNTIL
                                exit_loop;
                            (*ENDREPEAT*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                    i := succ(i);
                    END;
                (*ENDWHILE*) 
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43put_one_priv (
            VAR priv : tak_privilege;
            VAR c40 : tsp00_C40);
 
VAR
      found   : boolean;
      ix      : integer;
      p       : tak00_PrivR;
      c10     : tsp00_C10;
      c10_ptr : ^tsp00_C10;
 
BEGIN
p     := r_sel;
found := false;
WHILE NOT found DO
    IF  p in priv.priv_all_set
    THEN
        BEGIN
        found := true;
        CASE p OF
            r_sel   :
                c10 := 'SELECT    ';
            r_upd   :
                c10 := 'UPDATE    ';
            r_ins   :
                c10 := 'INSERT    ';
            r_del   :
                c10 := 'DELETE    ';
            r_alter :
                c10 := 'ALTER     ';
            r_index :
                c10 := 'INDEX     ';
            r_link  :
                c10 := 'REFERENCES';
            END;
        (*ENDCASE*) 
        priv.priv_all_set := priv.priv_all_set - [p];
        c40      := bsp_c40;
        c10_ptr  := @c40;
        c10_ptr^ := c10;
        IF  p in priv.priv_all_grant_set
        THEN
            BEGIN
            ix := sizeof (c10);
            WHILE c10[ix] = bsp_c1 DO
                ix := ix - 1;
            (*ENDWHILE*) 
            c40[ix + 1] := '+'
            END;
        (*ENDIF*) 
        END
    ELSE
        p := succ (p)
    (*ENDIF*) 
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak43one_col_priv (
            VAR priv          : tak_privilege;
            VAR c40           : tsp00_C40;
            colno             : integer;
            VAR last_col_priv : boolean);
 
BEGIN
c40 := bsp_c40;
IF  colno in priv.priv_sel_set
THEN
    BEGIN
    c40[1] := 'S';
    c40[2] := 'E';
    c40[3] := 'L';
    c40[4] := 'E';
    c40[5] := 'C';
    c40[6] := 'T';
    IF  colno in priv.priv_grant_sel_set
    THEN
        c40[7] := '+';
    (*ENDIF*) 
    priv.priv_sel_set := priv.priv_sel_set - [colno];
    last_col_priv     := NOT (colno in priv.priv_upd_set)
    END
ELSE
    BEGIN
    IF  colno in priv.priv_upd_set
    THEN
        BEGIN
        c40[1] := 'U';
        c40[2] := 'P';
        c40[3] := 'D';
        c40[4] := 'A';
        c40[5] := 'T';
        c40[6] := 'E';
        IF  colno in priv.priv_grant_upd_set
        THEN
            c40[7] := '+';
        (*ENDIF*) 
        last_col_priv := true
        END;
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak43table_kind (VAR baserec : tak_baserecord) : integer;
 
BEGIN
CASE baserec.btablekind OF
    tonebase, tview, tcomplexview :
        ak43table_kind := cak_i_view;
    OTHERWISE
        ak43table_kind := cak_i_table;
    END;
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak43unique (
            VAR acv    : tak_all_command_glob;
            is_synonym : boolean;
            VAR tabid  : tgg00_Surrogate;
            userid     : tgg00_Surrogate) : boolean;
 
VAR
      buf      : tgg00_Rec;
      surr_ptr : ^tgg00_Surrogate;
 
BEGIN
(* userid is called with constants !!!! *)
ak43unique := true;
IF  NOT (is_synonym)
THEN
    WITH acv DO
        BEGIN
        ak43unique        := false;
        buf.keylen        := 2 * SURROGATE_MXGG00;
        buf.len           := 2 * SURROGATE_MXGG00 + cgg_rec_key_offset;
        buf.recVarcolOffset_gg00 := 0;
        buf.recVarcolCnt_gg00    := 0;
        surr_ptr          := @buf.info[ 1 ];
        surr_ptr^         := tabid;
        surr_ptr          := @buf.info[ 1 + sizeof(tabid) ];
        surr_ptr^         := userid;
        b07cadd_record (a_transinf.tri_trans, a_into_tree, buf);
        IF  a_transinf.tri_trans.trError_gg00 = e_ok
        THEN
            ak43unique := true
        ELSE
            IF  a_transinf.tri_trans.trError_gg00 <> e_duplicate_key
            THEN
                a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1);
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
