.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 2000-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-16
*****************************************************
modname : VAK562
changed : 2000-11-16
module  : AK_Insert_Select
 
Author  : ElkeZ
Created : 1987-09-22
*****************************************************
 
Purpose : Processing of normal INSERT and INSERT...SELECT
 
Define  :
 
        PROCEDURE
              a562_select_insert (VAR acv : tak_all_command_glob);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01fullset         : tak_columnset;
              a01_il_b_identifier : tsp00_KnlIdentifier;
 
        PROCEDURE
              a01_call_put (
                    VAR acv    : tak_all_command_glob;
                    proc       : tak_procs;
                    subproc    : tsp00_Int2;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_put_node (
                    VAR acv    : tak_all_command_glob;
                    VAR curr_n : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06a_mblock_init (
                    VAR acv      : tak_all_command_glob;
                    mtype        : tgg00_MessType;
                    m2type       : tgg00_MessType2;
                    VAR tree     : tgg00_FileId);
 
        PROCEDURE
              a06extcolno (
                    VAR baserec     : tak_baserecord;
                    extcolno        : integer;
                    VAR colinfo_ptr : tak00_colinfo_ptr);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061get_colname (
                    VAR col_info : tak00_columninfo;
                    VAR colname  : tsp00_KnlIdentifier);
&       ifdef trace
 
        PROCEDURE
              a061td_colinfo (
                    VAR colinfo : tak00_columninfo;
                    index : integer);
&       endif
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10_add_repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    add_sysinfo  : boolean;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_rel_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10table_cache_delete (
                    VAR acv     : tak_all_command_glob;
                    VAR tableid : tgg00_Surrogate);
 
        PROCEDURE
              a10del_sysinfo (
                    VAR acv     : tak_all_command_glob;
                    VAR syskey  : tgg00_SysInfoKey;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a10new (
                    VAR acv  : tak_all_command_glob;
                    obj_size : tsp00_Int4;
                    VAR p    : tgg00_StackListPtr);
 
        PROCEDURE
              a10dispose (
                    VAR acv : tak_all_command_glob;
                    VAR p : tgg00_StackListPtr);
 
      ------------------------------ 
 
        FROM
              SQLManager : vak101;
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
        FUNCTION
              a101_GetExtendedTempFileType(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tgg00_TfnTemp;
 
        FUNCTION
              a101_GetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
      ------------------------------ 
 
        FROM
              SequenceWrapper : VAK104;
 
        FUNCTION
              ak104_CreateIncrementalMemorySequence (
                    allocator    : tgg00_VoidPtr;
                    refMode      : tak104_refcountMode;
                    VAR sequence : tsp00_MoveObjPtr;
                    msglist      : tak104_MsgList) : boolean ;
 
        FUNCTION
              ak104_CreateVariableField_IMS (
                    sequence : tsp00_MoveObjPtr;
                    size     : tsp00_Int4;
                    VAR buf  : tsp00_MoveObjPtr;
                    msglist  : tak104_MsgList) : boolean;
 
        FUNCTION
              ak104_CloseCurrentField_IMS (
                    sequence : tsp00_MoveObjPtr;
                    size     : tsp00_Int4;
                    msglist  : tak104_MsgList) : boolean;
 
        FUNCTION
              ak104_GetFieldCount_IMS (
                    sequence : tsp00_MoveObjPtr) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              AK_Data_Type_Options : VAK14;
 
        FUNCTION
              a14LengthOfDefaultValue (
                    VAR DefaultRec : tak_defaultrecord) : integer; (* PTS 1108428 *)
 
      ------------------------------ 
 
        FROM
              AK_update_statistics : VAK28;
 
        FUNCTION
              a28prim_pages (
                    VAR acv     : tak_all_command_glob;
                    VAR baserec : tak_baserecord) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              AK_Trigger : VAK262;
 
        PROCEDURE
              a262add_trigger_info (
                    VAR acv           : tak_all_command_glob;
                    VAR dmli          : tak_dml_info;
                    ignoreUserTrigger : boolean);
 
      ------------------------------ 
 
        FROM
              Executing_dispatcher : VAK501;
 
        PROCEDURE
              a501do_execute (
                    VAR acv                 : tak_all_command_glob;
                    VAR dmli                : tak_dml_info;
                    VAR parsk               : tak_parskey;
                    output_during_execution : boolean);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK54;
 
        PROCEDURE
              a54_dml_init (
                    VAR acv   : tak_all_command_glob;
                    VAR dmli  : tak_dml_info;
                    in_union  : boolean);
 
        PROCEDURE
              a54_dml_finalize (
                    VAR dmli         : tak_dml_info;
                    VAR TransContext : tgg00_TransContext);
 
        PROCEDURE
              a54_last_part (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    last_pars_part : boolean);
 
        PROCEDURE
              a54_sel_store_parsinfo (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    VAR change_rec : tak_changerecord;
                    last_pars_part : boolean);
 
        PROCEDURE
              a54_put_indices_in_mess_buf (
                    VAR acv     : tak_all_command_glob;
                    VAR basebuf : tak_baserecord;
                    VAR dfa     : tak_dfarr;
                    all_indices : boolean);
 
        PROCEDURE
              a54_view_put_into (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a54_fixedpos (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a54set_complex_entry (
                    VAR acv     : tak_all_command_glob;
                    call_reason : tak_complex_call_reason);
 
        PROCEDURE
              a54_loc_temp_locks (
                    VAR acv   : tak_all_command_glob;
                    globstate : tgg00_HandlingSet;
                    VAR sparr : tak_syspointerarr);
 
        PROCEDURE
              a54expand_tabarr_ex(
                    VAR acv      : tak_all_command_glob;
                    VAR dmli     : tak_dml_info;
                    new_capacity : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              DML_Parts : VAK55;
 
        PROCEDURE
              a55_nullvalue (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR dfa  : tak_dfarr);
 
        PROCEDURE
              a55realloc_parsinfo (
                    VAR acv          : tak_all_command_glob;
                    VAR parsinfo_ptr : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              AK_Insert : VAK56;
 
        PROCEDURE
              a56alloc_linkpos_info (
                    VAR acv        : tak_all_command_glob;
                    VAR p_arr      : tak_syspointerarr;
                    mess_type      : tgg00_MessType;
                    VAR linkposbuf : tak_sysbufferaddress);
 
        PROCEDURE
              a56one_default_value (
                    VAR acv     : tak_all_command_glob;
                    VAR dmli    : tak_dml_info;
                    VAR colinfo : tak00_columninfo;
                    with_length : tak_fp_kind_type);
 
        PROCEDURE
              a56insert_upd_with_link (
                    VAR acv        : tak_all_command_glob;
                    VAR linkposbuf  : tak_sysbufferaddress);
 
        FUNCTION
              a56IsClusterKey (
                    VAR acv     : tak_all_command_glob;
                    VAR dmli    : tak_dml_info;
                    VAR colInfo : tak00_columninfo) : boolean;
 
        PROCEDURE
              a56put_link_info (
                    VAR acv            : tak_all_command_glob;
                    base_ptr           : tak_sysbufferaddress;
                    not_used_links     : tak_charset;
                    viewqualbuf        : tak_sysbufferaddress;
                    VAR linkposbuf     : tak_sysbufferaddress);
 
        PROCEDURE
              a56temp_table_key (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a56_enumerated_values (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    VAR dfa    : tak_dfarr;
                    VAR curr_n : integer);
 
        PROCEDURE
              a56_describe (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    fp             : tak_fp_kind_type;
                    VAR movebefore : tsp00_Int2;
                    reccolno       : integer);
 
        PROCEDURE
              a56_get_baserecords (
                    VAR acv   : tak_all_command_glob;
                    VAR sparr : tak_syspointerarr;
                    VAR tab   : tak_one_table);
 
        PROCEDURE
              a56_serial_default (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR dfa  : tak_dfarr);
 
        PROCEDURE
              a56alloc_longlit_rec (
                    VAR acv           : tak_all_command_glob;
                    VAR dmli          : tak_dml_info;
                    VAR dfa           : tak_dfarr);
 
      ------------------------------ 
 
        FROM
              AK_Update : VAK57;
 
        PROCEDURE
              a57_range_not_null (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR dfa  : tak_dfarr);
 
      ------------------------------ 
 
        FROM
              Select_List : VAK61;
 
        PROCEDURE
              a61_check_val_params (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    sel_node : integer;
                    par_node : integer);
 
        PROCEDURE
              a61_set_jump (
                    VAR mblock : tgg00_MessBlock;
                    stentrynr : integer;
                    operator  : tgg00_StackEntryType);
 
        PROCEDURE
              a61_format_change (
                    VAR acv     : tak_all_command_glob;
                    VAR dmli    : tak_dml_info;
                    stackpos    : integer;
                    cdatatyp    : tsp00_DataType;
                    VAR datalen : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Execute_factor_col_function : VAK641;
 
        PROCEDURE
              a641check_datetime(
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    datatyp  : tsp00_DataType);
 
        PROCEDURE
              a641string_set_operator (
                    VAR acv      : tak_all_command_glob;
                    operator     : tgg00_StackOpBuildIn;
                    destlength   : integer;
                    sourcelength : integer;
                    tab1         : char;
                    tab2         : char);
 
        PROCEDURE
              a641stack_for_op_b_chr (
                    VAR acv           : tak_all_command_glob;
                    VAR dmli           : tak_dml_info;
                    VAR colin          : tak00_scolinf;
                    first_int          : tsp00_Int2;
                    keep_datatype      : tsp00_DataType);
 
        PROCEDURE
              a641_get_length (
                    VAR colin            : tak00_scolinf;
                    VAR output_length     : tsp00_Int2;
                    VAR wrong_datatype    : boolean);
 
      ------------------------------ 
 
        FROM
              Execute_Where_Part : VAK65;
 
        PROCEDURE
              a65_set_operator (
                    VAR acv  : tak_all_command_glob;
                    operator : tgg00_StackOpType);
 
      ------------------------------ 
 
        FROM
              Execute_Select_Expression : VAK660;
 
        PROCEDURE
              a660select (
                    VAR acv                     : tak_all_command_glob;
                    startnode                   : tsp00_Int2;
                    VAR dmli                    : tak_dml_info;
                    VAR pseudo_resultset_select : boolean);
 
        PROCEDURE
              a660_search_one_table (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    table_node     : integer;
                    all            : boolean;
                    check_teresult : boolean;
                    lock_spec      : tak_lockenum;
                    wanted_priv    : tak00_PrivR);
 
        PROCEDURE
              a660_short_first_part (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR tree : tgg00_FileId);
 
        PROCEDURE
              a660_new_pparsp (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    first_parsinfo : boolean;
                    complicate     : boolean);
 
        PROCEDURE
              a660_prefix_delete (
                    VAR acv       : tak_all_command_glob;
                    VAR parsk     : tak_parskey;
                    VAR del_cnt   : integer;
                    prefix_length : integer);
 
      ------------------------------ 
 
        FROM
              Subquery_handling : VAK661;
 
        PROCEDURE
              a661_fdelete_fromtab_results (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              Build_Strategy : VAK70;
 
        PROCEDURE
              a70_strategy_search (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    VAR rtree  : tgg00_FileId;
                    VAR sr_rec : tak71_strat_rec);
 
      ------------------------------ 
 
        FROM
              Hint_Handling : VAK80;
 
        PROCEDURE
              a80store_cmd_hint_info(
                    VAR acv     : tak_all_command_glob;
                    VAR dmli    : tak_dml_info;
                    select_node : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code           : tgg04_CodeGlobals;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalUnicodeFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedUnicodeFill (
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2 );
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedOverlappingMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20int4_to_buf_swap (
                    val        : tsp00_Int4;
                    sourceswap : tsp00_SwapKind;
                    VAR dest   : tgg00_Surrogate;
                    di         : tsp00_Int4;
                    destswap   : tsp00_SwapKind);
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01execution_kind (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    ex_kind   : tak_execution_kind);
 
        PROCEDURE
              t01sname (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname);
 
        PROCEDURE
              t01command_kind (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    command_kind : tak_commandkind);
 
        PROCEDURE
              t01bool (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    curr_bool: boolean);
 
        PROCEDURE
              t01treeid (
                    layer      : tgg00_Debug;
                    nam        : tsp00_Sname;
                    VAR treeid : tgg00_FileId);
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR m         : tgg00_MessBlock);
 
        PROCEDURE
              t01tabid (
                    layer     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR tabid : tgg00_Surrogate);
 
        PROCEDURE
              t01buf (
                    layer    : tgg00_Debug;
                    VAR buf  : tak_systembuffer;
                    startpos : integer;
                    endpos   : integer);
 
        PROCEDURE
              t01buf1 (
                    layer    : tgg00_Debug;
                    VAR buf  : tsp00_Buf;
                    startpos : integer;
                    endpos   : integer);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01handling (
                    debug : tgg00_Debug;
                    nam : tsp00_Sname;
                    s   : tgg00_HandlingSet);
&       ENDIF
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              a10new;
 
              tak_sysbufferaddress tgg00_StackListPtr
 
        PROCEDURE
              a10dispose;
 
              tak_sysbufferaddress tgg00_StackListPtr
 
        FUNCTION
              ak104_CreateIncrementalMemorySequence;
 
              tak104_Allocator tgg00_VoidPtr
              tak104_IncrementalMemorySequence tsp00_MoveObjPtr
 
        FUNCTION
              ak104_CreateVariableField_IMS;
 
              tak104_IncrementalMemorySequence tsp00_MoveObjPtr
 
        FUNCTION
              ak104_CloseCurrentField_IMS;
 
              tak104_IncrementalMemorySequence tsp00_MoveObjPtr
 
        FUNCTION
              ak104_GetFieldCount_IMS;
 
              tak104_IncrementalMemorySequence tsp00_MoveObjPtr
 
        PROCEDURE
              s20int4_to_buf_swap;
 
              tsp00_MoveObj tgg00_Surrogate
 
        PROCEDURE
              t01buf;
 
              tsp00_Buf tak_systembuffer
 
.CM *-END-* synonym -------------------------------------
***********************************************************
 
Description:
 
.nf
n_proc = a56
n_pos  =  1  : ainsert_statement
          2  : aenumerated_value
          3  : acolumn_list
          4  : values
          5  : ignore
          6  : update
          7  : reject
          8  : anamed_values
          9  : aset_insert_clause
.fo
 
.CM *-END-* description ---------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      (*  *)
      c_all             = true (* a06_systable_get      *);
      (*                          a06_table_exits       *)
      (*                          a54_put_indices_in_mess_buf *)
      (*                          a660_search_one_table *)
      (*                          a663restable_get      *)
      c_output_during_execution= true (* a501do_execute *);
      c_last_pars_part  = true (* a54_last_part *);
      (*                          a54_sel_store_parsinfo *)
      c_in_union        = true (* a54_dml_init *);
      c_first_parsinfo  = true (* a660_new_pparsp *);
      c_complicate      = true (* a660_new_pparsp *);
      c_check_teresult  = true (* a660_search_one_table *);
      c_add             = true;
 
TYPE
      convert_type = (
            i_from_ascii,
            i_from_unicode,
            i_from_number,
            i_from_string,
            i_check_len,
            i_check_date_time,
            i_date_time_format);
 
      one_ins_sel_info = RECORD
            i_stackcnt        : tsp00_Int2;
            i_stackstartpos   : tsp00_Int2;
            i_source_len      : tsp00_Int2;
            i_convert         : SET OF convert_type;
            i_sourcedatatyp   : tsp00_DataType;
      END;
 
      ins_sel_info_arr = ARRAY [ 1..MAX_COL_PER_TAB_GG00 ] OF one_ins_sel_info;
 
 
(*------------------------------*) 
 
PROCEDURE
      ak562build_ins_sel_infos (
            VAR a_mblock      : tgg00_MessBlock;
            VAR ins_sel_infos : ins_sel_info_arr;
            VAR f             : integer);
 
VAR
      qualend : integer;
      qualpos : integer;
 
BEGIN
WITH a_mblock, mb_qual^ DO
    BEGIN
    qualpos := mqual_pos + 1;
    qualend := mqual_pos + mb_st^ [mqual_pos].epos - 2;
    f := 0;
    WHILE qualpos <= qualend DO
        BEGIN
        f := succ(f);
        WITH ins_sel_infos[ f ] DO
            BEGIN
            i_stackstartpos   := qualpos;
            i_convert         := [ ];
            i_source_len      := 0;
            i_sourcedatatyp   := dunknown;
            END;
        (*ENDWITH*) 
        REPEAT
            qualpos := succ(qualpos)
        UNTIL
            mb_st^ [qualpos].etype = st_output;
        (*ENDREPEAT*) 
        ins_sel_infos[ f ].i_stackcnt := qualpos -
              ins_sel_infos[ f ].i_stackstartpos;
        qualpos := succ(qualpos);
        IF  qualpos <= qualend
        THEN
            IF  ((mb_st^ [qualpos].etype = st_func) AND
                (mb_st^ [qualpos].eop_func = op_f_none))
                (* LASTFUNCTION *)
            THEN
                qualpos := succ(qualpos)
            ELSE
                WHILE ((mb_st^ [qualpos].etype = st_dummy) AND
                      (qualpos <= qualend)) DO
                    qualpos := succ(qualpos)
                (*ENDWHILE*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDWHILE*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak562do_select_insert (
            VAR acv         : tak_all_command_glob;
            VAR dmli        : tak_dml_info;
            VAR with_commit : boolean);
 
VAR
      second_part        : boolean;
      sel_catalog_table  : boolean;
      nowait             : boolean;
      curr_n             : tsp00_Int2;
      mess2_type         : tgg00_MessType2;
      i                  : integer;
      j                  : integer;
      k                  : integer;
      sub_n              : integer;
      ins_col_n          : integer;
      act_n              : tsp00_Int2;
      star_n             : tsp00_Int2;
      enum_n             : tsp00_Int2;
      pagecnt            : tsp00_Int4;
      result_treeid      : tgg00_FileId;
      dummy_bool         : boolean;
      strat_ptr          : ^tgg07_StrategyInfo;
      dfa                : tak_dfarr;
 
BEGIN
acv.a_rowno_allowed         := true;
acv.a_ptr1              := NIL;
acv.a_p_arr1.pbasep     := NIL;
acv.a_p_arr1.pcount     := 0;
acv.a_union_cnt         := 0;
(* PTS 1110741 E.Z. *)
acv.a_from_select       := false;
acv.a_fromsel_n         := 0;
acv.a_union_cnt         := 0;
dmli.d_outer_join       := dmli.d_outer_join OR acv.a_outer_join;
dmli.d_pseudo_ins_select     :=
      (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_length =
      cak_x_pseudo_ins_select) OR
      (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_length =
      cak_x_pseudo_ins_select + cak_i_ignore);
IF  dmli.d_pseudo_ins_select
THEN
    acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_length :=
          acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_length -
          cak_x_pseudo_ins_select;
(*ENDIF*) 
dmli.d_globstate             := acv.a_transinf.tri_global_state;
dmli.d_unchanged_globstate   := dmli.d_globstate;
mess2_type              := mm_nil;
IF  ((hsTempLock_egg00 in dmli.d_globstate) OR
    (hsPermLock_egg00 in dmli.d_globstate))
    AND
    (acv.a_isolation_info <> temp_lock_rec_get)
    AND
    NOT dmli.d_pseudo_ins_select
THEN
    acv.a_isolation_info := temp_lock_rec_needed;
(*ENDIF*) 
IF  acv.a_command_kind = complex_view_command
THEN
    acv.a_command_kind := sub_in_complex_command
ELSE
    IF  acv.a_command_kind <> sub_in_complex_command
    THEN
        acv.a_command_kind := subquery_command;
    (*ENDIF*) 
(*ENDIF*) 
;
&ifdef TRACE
t01bool( ak_sem, 'd_pseudo_ins', dmli.d_pseudo_ins_select );
t01handling( ak_sem, 'd_globstate ', dmli.d_globstate );
t01int4( ak_sem, 'isolation_in', ord( acv.a_isolation_info ));
t01command_kind( ak_sem, 'a_command_ki', acv.a_command_kind );
&endif
acv.a_mblock.mb_data_len           := cgg_rec_key_offset;
acv.a_mblock.mb_data^.mbp_reclen   := 0;
acv.a_mblock.mb_data^.mbp_keylen   := 0;
act_n := acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
dmli.d_acttabindex := 1;
dmli.d_cntfromtab  := 1;
a660_search_one_table( acv, dmli, acv.a_ap_tree^[ act_n ].n_lo_level,
      c_all, NOT c_check_teresult, no_lock, r_ins );
act_n := acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
WHILE (acv.a_ap_tree^[ act_n ].n_sa_level > 0) AND
      (acv.a_ap_tree^[ act_n ].n_proc <> a52) DO
    act_n := acv.a_ap_tree^[ act_n ].n_sa_level;
(*ENDWHILE*) 
nowait := false;
IF  ( acv.a_returncode = 0 )
THEN
    IF  (acv.a_ap_tree^[ act_n ].n_proc = a52) AND
        (acv.a_ap_tree^[ act_n ].n_subproc = cak_x_nowait)
    THEN
        BEGIN
        nowait := true;
        IF  acv.a_ap_tree^[ act_n ].n_sa_level > 0
        THEN
            act_n := acv.a_ap_tree^[ act_n ].n_sa_level;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  (acv.a_ap_tree^[ act_n ].n_proc = a52) AND
    (acv.a_ap_tree^[ act_n ].n_subproc = cak_x_commit)
THEN
    IF  (NOT dmli.d_pseudo_ins_select) OR
        (dmli.d_sparr.pbasep^.sbase.btablekind = tview)
    THEN
        a07_b_put_error (acv, e_invalid_end_of_command, acv.a_ap_tree^[ act_n ].n_pos)
    ELSE
        with_commit := true;
    (*ENDIF*) 
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    (* PTS 1124950 E.Z. *)
    (* PTS 1120988 E.Z. *)
    FOR i := 1 TO MAX_COL_PER_TAB_GG00 DO
        BEGIN
        dfa[ i ].dml_node := 0;
        dfa[ i ].dml_res_index := 0;
        END;
    (*ENDFOR*) 
    ins_col_n := acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
    ins_col_n := acv.a_ap_tree^[ ins_col_n ].n_sa_level;
    enum_n := ins_col_n;
    a56_enumerated_values( acv, dmli, dfa, ins_col_n );
    i := 1;
    FOR j := 1 TO MAX_COL_PER_TAB_GG00 DO
        dmli.d_change.cr_columns[ j ].ch_length := chr( ord( dunknown ));
    (*ENDFOR*) 
    dmli.d_colbuf := a103GetColumn (dmli.d_sparr.pbasep^.sbase,
          dmli.d_sparr.pbasep^.sbase.bfirstcolind);
    j := 0;
    WHILE (( i <= dmli.d_sparr.pbasep^.sbase.bmaxcol ) AND
          ( acv.a_returncode = 0 )) DO
        WITH dmli.d_colbuf^, dfa[ creccolno ] DO
            BEGIN
&           ifdef trace
            a061td_colinfo (dmli.d_colbuf^, i);
            t01int4 (ak_sem, 'dml_node    ', dml_node);
            t01int4 (ak_sem, 'dml_colno_in', dml_colno_in_subquery);
&           endif
            IF  dml_node <> 0
            THEN
                BEGIN
                IF  j < dml_colno_in_subquery
                THEN
                    j := dml_colno_in_subquery;
                (*ENDIF*) 
                WITH dmli.d_change.cr_columns[ dml_colno_in_subquery ],
                     dml_col_ptr^ DO
                    BEGIN
                    ch_length := chr( ord(cdatatyp ));
                    (* PTS 1120988 E.Z. *)
                    IF  cdatatyp = dfixed
                    THEN
                        ch_startpos := cdatalen * 100 + cdatafrac
                    ELSE
                        ch_startpos := cdatalen
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            i := succ( i );
            IF  ( cnextind > 0 )
            THEN
                dmli.d_colbuf := a103GetColumn (dmli.d_sparr.pbasep^.sbase, cnextind);
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDWHILE*) 
    dmli.d_change.cr_colcount := j;
    a10_rel_sysinfo( acv, dmli.d_sparr.pbasep^.syskey );
    END;
(*ENDIF*) 
sub_n      := acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_sa_level;
sub_n      := acv.a_ap_tree^[ sub_n ].n_pos;
dummy_bool := false;
IF  ( dmli.d_tabarr_capacity < 3 )
THEN
    a54expand_tabarr_ex( acv, dmli, 3 );
(*ENDIF*) 
IF  ( (acv.a_returncode = 0) AND dmli.d_pseudo_ins_select )
THEN
    BEGIN
    dmli.d_tabarr^[ 2 ] := dmli.d_tabarr^[ 1 ]; (* INSERT-table in atarr[2] *)
    IF  dmli.d_sparr.pbasep^.sbase.bstringcount > 0
    THEN
        a56alloc_longlit_rec (acv, dmli, dfa);
    (*ENDIF*) 
    END;
(*ENDIF*) 
a660select( acv, sub_n, dmli, dummy_bool );
&ifdef trace
IF  acv.a_returncode = 0
THEN
    WITH acv.a_resname_addr[ cak_intern_pos ]^.sresname DO
        t01treeid (ak_sem, 'res_tree 1  ', restreeid);
    (*ENDWITH*) 
&endif
(*ENDIF*) 
dmli.d_tabarr^[ 3 ] := dmli.d_tabarr^[ 1 ]; (* SELECT-table in atarr[ 3 ] *)
IF  ( acv.a_returncode = 0 ) AND
    ( acv.a_mblock.mb_qual^.mstrat_pos > 0 )
THEN
    IF  ( acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].etype =
        st_strat )
    THEN
        acv.a_mblock.mb_strat_len :=
              acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].epos - 1;
    (*ENDIF*) 
(*ENDIF*) 
second_part := ( NOT dmli.d_pseudo_ins_select );
&ifdef trace
t01bool( ak_sem, 'second_part1', second_part );
&endif
sel_catalog_table := false;
pagecnt := 0;
IF  ( acv.a_returncode = 0 ) AND
    ( acv.a_intern_select_cnt = acv.a_max_intern_select )
THEN
    BEGIN
    IF  NOT ( acv.a_mblock.mb_type2
        in [ mm_with_functions, mm_with_join ] )
        AND NOT dmli.d_union_insert
        AND NOT dmli.d_pseudo_ins_select
        AND ( dmli.d_corr = no_correlation )
    THEN
        WITH acv.a_mblock, mb_qual^, mtree DO
            IF  (a101_IsExtendedTempFile (acv, acv.a_mblock.mb_qual^.mtree)    AND
                ( a101_GetExtendedTempFileType (acv,
                acv.a_mblock.mb_qual^.mtree) <> ttfnTempTable_egg00 )  AND
                ( a101_GetExtendedTempFileType (acv,
                acv.a_mblock.mb_qual^.mtree) <> ttfnUserResult_egg00 ))
            THEN
                second_part := true
            ELSE
                BEGIN
                strat_ptr := @acv.a_mblock.mb_strat^
                      [ acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].epos ];
                (* PTS 1000514 E.Z. *)
                IF  (( strat_ptr^.str_distinc = no_distinct ) AND
                    NOT strat_ptr^.str_use_rowno            AND
                    ( strat_ptr^.str_qual_kind <> inv_only)  AND
                    (NOT (a101_IsExtendedTempFile (acv, strat_ptr^.str_result_id) AND
                    ( a101_GetExtendedTempFileType (acv, strat_ptr^.str_result_id)
                    = ttfnComplexSelect_egg00 ))))
                THEN
                    BEGIN
                    (* no 'DISTINCT', no 'ROWNO', no INV_ONLY used*)
                    second_part := false;
                    sel_catalog_table :=
                          ( dmli.d_sparr.pbasep^.sbase.bv_tablekind =
                          tcatalog_table );
                    pagecnt := a28prim_pages( acv, dmli.d_sparr.pbasep^.sbase );
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
&ifdef trace
(*ENDIF*) 
t01bool( ak_sem, 'second_part2', second_part );
&endif
IF  ( dmli.d_sparr.pbasep <> NIL )
THEN
    a10_rel_sysinfo( acv, dmli.d_sparr.pbasep^.syskey );
(*ENDIF*) 
IF  ( acv.a_intern_select_cnt = acv.a_max_intern_select )
THEN
    BEGIN
    IF  ( acv.a_returncode = 0 )
    THEN
        BEGIN
        act_n := acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
        dmli.d_tabarr^[ 3 ] := dmli.d_tabarr^[ 1 ]; (* SELECT-table in atarr[ 3 ] *)
        (* ok only, if not second_part *)
        dmli.d_acttabindex := 1;
        dmli.d_cntfromtab  := 1;
        a660_search_one_table( acv, dmli,
              acv.a_ap_tree^[ act_n ].n_lo_level,
              c_all, NOT c_check_teresult, no_lock, r_ins );
&       ifdef trace
        t01treeid( ak_sem, 'res_tree 2  ',
              acv.a_resname_addr[ cak_intern_pos ]^.sresname.restreeid );
&       endif
        END;
    (*ENDIF*) 
    IF  ( acv.a_returncode = 0 )
    THEN
        IF  dmli.d_sparr.pbasep^.sbase.btablekind = tview
        THEN
            a07_b_put_error (acv, e_not_implemented, 1)
        ELSE
            BEGIN
            IF  nowait
            THEN
                dmli.d_tabarr^[ 1 ].otreeid.fileHandling_gg00 :=
                      dmli.d_tabarr^[ 1 ].otreeid.fileHandling_gg00 + [ hsNoWait_egg00 ];
            (*ENDIF*) 
            IF  ( NOT second_part ) AND
                ( NOT dmli.d_pseudo_ins_select )
            THEN
                BEGIN
                dmli.d_sparr.pparsp^.sparsinfo.p_pagecnt := pagecnt;
                IF  sel_catalog_table
                    OR
                    (( NOT dmli.d_union_insert )                   AND
                    ( acv.a_mblock.mb_type2 <> mm_with_functions ) AND
                    ( acv.a_mblock.mb_type2 <> mm_with_join )      AND
                    ( acv.a_mblock.mb_qual^.mtree.fileName_gg00 =
                    dmli.d_tabarr^[ 1 ].otreeid.fileName_gg00 ))
                THEN
                    BEGIN
                    (* VAK67 (sel2_. ] did not know this =>
                          did not store parsinfo *)
                    IF  NOT a101_IsExtendedTempFile (acv, acv.a_mblock.mb_qual^.mtree)
                    THEN
                        WITH acv.a_mblock.mb_qual^.mtree DO
                            BEGIN
                            fileHandling_gg00 := dmli.d_globstate;
                            IF  hsPermLock_egg00 in fileHandling_gg00
                            THEN
                                fileHandling_gg00 := (fileHandling_gg00
                                      + [ hsWithoutLock_egg00 ])
                                      - [ hsPermLock_egg00 ]
                            ELSE
                                fileHandling_gg00 := fileHandling_gg00
                                      - [ hsTempLock_egg00 ]
                            (*ENDIF*) 
                            END;
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    WITH dmli.d_sparr.pparsp^.sparsinfo DO
                        BEGIN
                        p_select     := true;
                        p_single     := false;
                        p_reuse      := true;
                        p_resn       :=
                              a01_il_b_identifier;
                        FOR i := 1 TO sizeof( p_modul_name ) DO
                            p_modul_name[ i ] := bsp_c1;
                        (*ENDFOR*) 
                        (* correct for modul_name *)
                        IF  ( dmli.d_cntfromtab = 1 )
                        THEN
                            IF  oresfile in dmli.d_tabarr^[ 3 ].ospecialname
                            THEN
                                p_searchname := dmli.d_tabarr^[ 3 ].otable;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        p_use_sess_isolevel :=
                              ( acv.a_transinf.tri_global_state =
                              dmli.d_unchanged_globstate );
                        p_session_isolevel  := acv.a_iso_level;
                        p_handling_set      := dmli.d_unchanged_globstate;
                        END;
                    (*ENDWITH*) 
                    IF  ( acv.a_mblock.mb_st^
                        [ acv.a_mblock.mb_qual^.mstrat_pos ].etype = st_strat )
                    THEN
                        BEGIN
&                       ifdef trace
                        t01sname( ak_sem, 'test result ' );
&                       endif
                        strat_ptr := @acv.a_mblock.mb_strat^
                              [ acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mstrat_pos ].epos ];
                        (* see vak67 *)
                        acv.a_mblock.mb_strat_len  :=
                              acv.a_mblock.mb_strat_len  +
                              acv.a_mblock.mb_st^
                              [ acv.a_mblock.mb_qual^.mstrat_pos ].elen_var
                              + cgg_rec_key_offset;
                        IF  a101_IsExtendedTempFile(acv, strat_ptr^.str_result_id)
                            AND (a101_GetExtendedTempFileType (acv,
                            strat_ptr^.str_result_id) =
                            ttfnInternResult_egg00 )
                        THEN
                            WITH acv.a_resname_addr[ cak_intern_pos ]^.sresname DO
                                BEGIN
                                restreeid.fileTfnTemp_gg00 :=
                                      ttfnInternResult_egg00;
                                strat_ptr^.str_result_id := restreeid;
                                END;
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    a54_sel_store_parsinfo( acv, dmli.d_sparr, dmli.d_change,
                          NOT c_last_pars_part );
                    second_part := true;
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  (( acv.a_returncode = 0 ) AND second_part )
    THEN
        BEGIN
        (* *** store insertselect parsid in first complex rec *** *)
        acv.a_complex_key[ 5 ] := acv.a_first_parskey;
        a660_new_pparsp( acv, dmli.d_sparr,
              NOT c_first_parsinfo, c_complicate );
        END;
&   ifdef trace
    (*ENDIF*) 
    t01bool( ak_sem, 'second_part3', second_part );
&   endif
    a54set_complex_entry( acv, c_set_last_pars );
    IF  ( acv.a_returncode = 0 )
    THEN
        BEGIN
        WITH dmli.d_tabarr^[ 1 ] DO
            BEGIN
            IF  ( second_part )
            THEN
                BEGIN
                a06a_mblock_init( acv, m_insert_select, mess2_type,
                      acv.a_resname_addr [cak_intern_pos]^.sresname.restreeid );
                acv.a_mblock.mb_qual^.mtree.fileHandling_gg00 := [ hsWithoutLock_egg00 ];
                acv.a_mblock.mb_data_len := cgg_rec_key_offset + 2;
                END
            ELSE
                WITH acv.a_mblock, mb_qual^ DO
                    BEGIN
                    mb_type  := m_insert_select;
                    mb_type2 := mm_nil;
                    IF  NOT a101_IsExtendedTempFile (acv, mtree)
                    THEN
                        BEGIN
                        mtree.fileHandling_gg00 := dmli.d_globstate;
                        IF  ( acv.a_isolation_info = temp_lock_rec_get )
                        THEN
                            IF  ( hsPermLock_egg00 in mtree.fileHandling_gg00 )
                            THEN
                                mtree.fileHandling_gg00 :=
                                      ( mtree.fileHandling_gg00 +
                                      [ hsWithoutLock_egg00 ] ) -
                                      [ hsPermLock_egg00 ]
                            ELSE
                                mtree.fileHandling_gg00 :=
                                      mtree.fileHandling_gg00 -
                                      [ hsTempLock_egg00 ];
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            acv.a_mblock.mb_data^.mbp_info.rb_ins_sel_info :=
                  csp_defined_byte;
            acv.a_mblock.mb_data^.mbp_info.rb_into_temp    := false
            END;
        (*ENDWITH*) 
        dmli.d_tabarr^[ 2 ] := dmli.d_tabarr^[ 1 ];
        (* in atarr[ 2 ] is INSERT-table *)
        dmli.d_acttabindex := 2;
        IF  ( NOT second_part )
        THEN
            dmli.d_tabarr^[ 1 ] := dmli.d_tabarr^[ 3 ]
        ELSE
            BEGIN
            a10rel_sysinfo( dmli.d_sparr.pbasep );
            dmli.d_sparr.pbasep := dmli.d_esparr.pbasep;
            dmli.d_sparr.pcount := dmli.d_esparr.pcount;
            a01_call_put( acv, a60, cak_x_select_list, star_n );
            curr_n := star_n;
            a01_call_put( acv, a60, cak_x_select_column,
                  acv.a_ap_tree^[ curr_n ].n_lo_level );
            star_n := acv.a_ap_tree^[ curr_n ].n_lo_level;
            acv.a_scv.sc_symb := s_asterisk;
            a01_put_node( acv, acv.a_ap_tree^[ star_n ].n_lo_level );
            a660_short_first_part( acv, dmli, result_treeid );
            dmli.d_acttabindex := 1;
            dmli.d_cntfromtab  := 1;
            WITH dmli.d_tabarr^[ dmli.d_acttabindex ] DO
                BEGIN
                ouser        := acv.a_curr_user_name;
                otable       :=
                      a01_il_b_identifier;
                ospecialname := [  ];
                oview        := false;
                otreeid      :=
                      acv.a_resname_addr[ cak_intern_pos ]^.
                      sresname.restreeid;
                ofromtableid  := otreeid.fileTabId_gg00;
                oprivset      := [  ];
                osetallpriv   := [  ];
                oall_priv     := true;
                ospecs_needed := ons_only_tablename;
                ocomplex_view := false;
                oattributes   := [];
                ocounttabs    := 0;
                oreference    :=
                      a01_il_b_identifier;
                oviewqual     := false;
                oviewcheck    := false;
                END;
            (*ENDWITH*) 
            dmli.d_group := false;
            a61_check_val_params( acv, dmli, curr_n, curr_n );
&           IFDEF TRACE
            t01messblock( ak_sem, 'ins_sel am 2', acv.a_mblock );
&           ENDIF
            dmli.d_rowno := cgg04_no_rowno_predicate;
            END;
        (*ENDIF*) 
        (* PTS 1122921 E.Z. *)
        IF  dmli.d_rowno = cgg04_no_rowno_predicate
        THEN
            BEGIN
&           ifdef TRACE
            t01int4 (ak_sem, 'enum_n      ', enum_n);
&           endif
            enum_n := acv.a_ap_tree^[enum_n].n_lo_level;
            IF  (acv.a_ap_tree^[enum_n].n_proc = a56) AND
                (acv.a_ap_tree^[enum_n].n_subproc = cak_x_column_list)
            THEN
                enum_n := acv.a_ap_tree^[enum_n].n_sa_level;
            (*ENDIF*) 
            IF  acv.a_ap_tree^[enum_n].n_sa_level <> 0
            THEN
                IF  (acv.a_ap_tree^[acv.a_ap_tree^[enum_n].n_sa_level].n_proc = a63) AND
                    (acv.a_ap_tree^[acv.a_ap_tree^[enum_n].n_sa_level].n_subproc = cak_x_one_val_subquery)
                THEN
                    dmli.d_rowno := cgg04_subquery_one_record;
                (*ENDIF*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (* SELECT-table is in atarr[ 1 ] *)
    (*ENDIF*) 
    IF  ( acv.a_returncode = 0 )
    THEN
        BEGIN
        act_n := acv.a_ap_tree^[ act_n ].n_sa_level;
        ak562ins_sel_buffer_build( acv, dmli, dfa, second_part,
              acv.a_ap_tree^[ act_n ].n_sa_level );
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
acv.a_part_rollback := ( acv.a_returncode <> 0 );
END;
 
(* PTS 1001154 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak5622verify_not_null (
            VAR acv         : tak_all_command_glob;
            VAR sparr       : tak_syspointerarr;
            VAR stack_entry : tgg00_StackEntry);
 
BEGIN
WITH sparr.pparsp^.sparsinfo DO
    IF  p_cnt_infos >= p_max_infos
    THEN
        a55realloc_parsinfo (acv, sparr.pparsp);
    (*ENDIF*) 
(*ENDWITH*) 
IF  acv.a_returncode = 0
THEN
    WITH sparr.pparsp^.sparsinfo DO
        BEGIN
        p_cnt_infos := succ (p_cnt_infos);
        WITH  p_pars_infos[ p_cnt_infos ] DO
            BEGIN
            fp_kind       := fp_verify_not_null;
            fp_stackentry := stack_entry;
            fp_fill_151   := 0;
            END;
        (*ENDWITH*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak562ins_sel_buffer_build (
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info;
            VAR dfa     : tak_dfarr;
            second_part : boolean;
            dupl_n      : integer);
 
VAR
      tablekind     : tgg00_TableKind;
      e             : tgg00_BasisError;
      f             : integer;
      fieldno       : integer;
      i             : integer;
      mepos         : integer;
      qual_cnt      : integer;
      qual_pos      : integer;
      view_cnt      : integer;
      view_pos      : integer;
      ins_col_n     : integer;
      dupl_clause   : integer;
      h_costsum     : tsp00_Int4;
      ins_sel_infos : ins_sel_info_arr;
      sr_rec        : tak71_strat_rec;
 
BEGIN
ak562build_ins_sel_infos( acv.a_mblock, ins_sel_infos, f );
dmli.d_like := false;
IF  (( acv.a_returncode = 0 ) AND second_part )
THEN
    BEGIN
    dmli.d_esparr.pbasep  := dmli.d_sparr.pbasep;
    dmli.d_esparr.pcount  := dmli.d_sparr.pcount;
    a56_get_baserecords( acv, dmli.d_sparr, dmli.d_tabarr^[ 2 ] );
    dmli.d_acttabindex := 2;
    END;
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
&   IFDEF TRACE
    t01int4 (ak_sem, 'dupl-1      ', dupl_n);
&   ENDIF
    (* PTS 1120988 E.Z. *)
    FOR i := 1 TO dmli.d_sparr.pbasep^.sbase.bmaxcol DO
        BEGIN
        dfa[ i ].dml_node := 0;
        (* dfa[ i ].dml_res_index := 0; do NOT do that *)
        END;
    (*ENDFOR*) 
    tablekind    := dmli.d_sparr.pbasep^.sbase.btablekind;
    ins_col_n    := acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
    ins_col_n    := acv.a_ap_tree^[ ins_col_n ].n_sa_level;
    a56_enumerated_values( acv, dmli, dfa, ins_col_n );
    (* PTS 1120988 E.Z. *)
    IF  ( acv.a_returncode = 0 )
        AND dmli.d_pseudo_ins_select
    THEN
        BEGIN
        dmli.d_colbuf := a103GetColumn (dmli.d_sparr.pbasep^.sbase,
              dmli.d_sparr.pbasep^.sbase.bfirstcolind);
        i := 1;
        WHILE (( i <= dmli.d_sparr.pbasep^.sbase.bmaxcol ) AND
              ( acv.a_returncode = 0 )) DO
            WITH dmli.d_colbuf^, dfa[ creccolno ] DO
                BEGIN
&               ifdef trace
                a061td_colinfo (dmli.d_colbuf^, i);
                t01int4 (ak_sem, 'dml_node    ', dml_node);
                t01int4 (ak_sem, 'dml_res_inde', dml_res_index);
&               endif
                (* if on the right there was DEFAULT *)
                IF  (dml_node <> 0) AND (dml_res_index = 1)
                THEN
                    BEGIN
                    dml_node := 0;
                    FOR fieldno := 1 TO dmli.d_sparr.pbasep^.sbase.bmaxcol DO
                        IF  dfa[fieldno].dml_node <> 0
                        THEN
                            IF  dfa[fieldno].dml_colno_in_subquery > dml_colno_in_subquery
                            THEN
                                dfa[fieldno].dml_colno_in_subquery :=
                                      pred(dfa[fieldno].dml_colno_in_subquery);
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDFOR*) 
                    END;
                (*ENDIF*) 
                i := succ( i );
                IF  ( cnextind > 0 )
                THEN
                    dmli.d_colbuf := a103GetColumn (dmli.d_sparr.pbasep^.sbase, cnextind);
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    ak562inspect_compatibility( acv, dmli, dfa, ins_sel_infos, f );
    IF  ( NOT second_part )
    THEN
        BEGIN
        IF  ( acv.a_intern_select_cnt = acv.a_max_intern_select )
        THEN
            BEGIN
            a10del_sysinfo( acv, dmli.d_esparr.pbasep^.syskey, e );
&           ifdef trace
            dmli.d_esparr.pbasep := NIL;
&           endif
            IF  ( e <> e_ok )
            THEN
                a07_b_put_error( acv, e, 1 );
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    ak562new_mess_buf_build( acv, dmli, dfa, ins_sel_infos,
          (dupl_n <> 0) AND (acv.a_ap_tree^[ dupl_n ].n_subproc = cak_x_update_dupl) );
(* PTS 1000264 E.Z. *)
(*ENDIF*) 
dupl_clause := 0;
WITH acv.a_mblock.mb_data^.mbp_info DO
    IF  rb_ins_sel_info [ 1 ] = csp_defined_byte
    THEN
        BEGIN
        IF  dupl_n <> 0
        THEN
            CASE acv.a_ap_tree^[ dupl_n ].n_subproc OF
                cak_x_ignore_dupl :
                    BEGIN
                    rb_ins_sel_info := cgg04_ignore_dupl;
                    dupl_clause     := cak_x_ignore_dupl;
                    END;
                cak_x_update_dupl :
                    BEGIN
                    rb_ins_sel_info := cgg04_update_dupl;
                    dupl_clause     := cak_x_update_dupl;
                    END;
                cak_x_reject_dupl :
                    rb_ins_sel_info := cgg04_reject_dupl;
                OTHERWISE
                    rb_ins_sel_info := cgg04_reject_dupl
                END
            (*ENDCASE*) 
        ELSE
            rb_ins_sel_info := cgg04_reject_dupl;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
IF  ( dmli.d_pseudo_ins_select ) AND ( acv.a_returncode = 0 )
THEN
    BEGIN
    a54_fixedpos( acv, dmli );
    a56_describe( acv, dmli.d_sparr, fp_pseudo_ins_select, dmli.d_movebefore, dupl_clause );
    END;
(*ENDIF*) 
dmli.d_join := false;
&IFDEF TRACE
t01messblock( ak_sem, 'ins_sel buf ', acv.a_mblock );
&ENDIF
IF  ( acv.a_returncode = 0 )
THEN
    WITH dmli.d_tabarr^[ 2 ] DO
        IF  oview AND oviewcheck AND oviewqual
        THEN
            WITH acv.a_mblock, mb_qual^, mb_st^[ mqual_pos ] DO
                BEGIN
                mepos    := epos;
                epos     := mqual_cnt + 1;
                view_cnt := mview_cnt;
                view_pos := mview_pos;
                qual_cnt := mqual_cnt;
                qual_pos := mqual_pos;
                mview_cnt := 0;
                mview_pos := 0;
                mqual_cnt := 0;
                mqual_pos := 0;
                mupd_pos := mfirst_free;
                dmli.d_acttabindex := 2;
                a54_view_put_into( acv, dmli );
                mupd_cnt := mview_cnt;
                mqual_cnt := qual_cnt;
                mqual_pos := qual_pos;
                mview_cnt := view_cnt;
                mview_pos := view_pos;
                epos     := mepos
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    IF  ( dmli.d_pseudo_ins_select )
    THEN
        BEGIN
        (* insert with expression's which has been transformed *)
        (* into an insert select by the kernel                 *)
        (* prepare message buffer to be able to retransform it *)
        (* into an insert message buffer in VAK506             *)
        (* PTS 1001154 E.Z. *)
        dmli.d_colbuf := a103GetColumn (dmli.d_sparr.pbasep^.sbase,
              dmli.d_sparr.pbasep^.sbase.bfirstcolind);
        fieldno := 1;
        WHILE (( fieldno <= dmli.d_sparr.pbasep^.sbase.bmaxcol ) AND
              ( acv.a_returncode = 0 )) DO
            BEGIN
            dmli.d_fieldno     := dmli.d_colbuf^.creccolno;
            IF  ( dmli.d_fieldno in dmli.d_foundset )
            THEN
                BEGIN
                IF  NOT ( ctkey in dmli.d_colbuf^.ccolpropset ) AND
                    NOT ( ctopt in dmli.d_colbuf^.ccolpropset )
                THEN
                    ak5622verify_not_null( acv, dmli.d_sparr, dmli.d_colbuf^.ccolstack );
&               ifdef TRACE
                (*ENDIF*) 
                t01int4( ak_sem, 'ctkey in set', ord( ctkey in dmli.d_colbuf^.ccolpropset ));
                t01int4( ak_sem, 'ctopt in set', ord( ctopt in dmli.d_colbuf^.ccolpropset ));
&               endif
                END;
            (*ENDIF*) 
            fieldno := succ( fieldno );
            IF  ( dmli.d_colbuf^.cnextind > 0 )
            THEN
                dmli.d_colbuf := a103GetColumn (dmli.d_sparr.pbasep^.sbase,
                      dmli.d_colbuf^.cnextind);
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        acv.a_mblock.mb_qual^.mtree := dmli.d_sparr.pbasep^.sbase.btreeid;
        i := 1;
        dmli.d_movebefore := 0;
        (* describe constraints *)
        WHILE ( i <= dmli.d_sparr.pbasep^.sbase.bnamed_constr ) AND
              ( acv.a_returncode = 0 ) DO
            BEGIN
            a56_describe( acv, dmli.d_sparr,
                  fp_verify_constraint, dmli.d_movebefore, i );
            i := i + 1;
            END;
        (*ENDWHILE*) 
        END
    ELSE
        BEGIN
        dmli.d_upd_set := a01fullset; (* mark all columns as updated *)
        a57_range_not_null( acv, dmli, dfa );
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
;
&IFDEF TRACE
t01messblock( ak_sem, 'ins_sel buf2', acv.a_mblock );
&ENDIF
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    sr_rec.sr_invkeylen := csp_maxint2;
    dmli.d_use_order := false;
    (* PTS 1105795 M.Ki.; attach stack entries to describe type of LONG *)
    (* columns (LONG/LONGFILE)                                          *)
    IF  (acv.a_mblock.mb_qual^.mstring_cnt > 0) OR
        (acv.a_mblock.mb_data^.mbp_info.rb_ins_sel_info[ 1 ] = cgg04_update_dupl)
    THEN
        ak562long_type_st_entries_attach (acv, dmli);
    (*ENDIF*) 
    IF  ( second_part )
    THEN
        BEGIN
        dmli.d_sparr.pbasep      := dmli.d_esparr.pbasep;
        dmli.d_sparr.pcount      := dmli.d_esparr.pcount;
        sr_rec.sr_must_result    := true;
        sr_rec.sr_use_rowno      := false;
        sr_rec.sr_distinct_bytes := true;
        sr_rec.sr_reverse_access := false;
        END
    ELSE
        BEGIN
        a56_get_baserecords( acv, dmli.d_sparr, dmli.d_tabarr^[ 1 ] );
        dmli.d_acttabindex := 1;
        h_costsum          := acv.a_costsum;
        acv.a_costsum      := 0;
        sr_rec.sr_must_result    := true;
        sr_rec.sr_use_rowno      := false;
        sr_rec.sr_distinct_bytes := false;
        IF  ( acv.a_ex_kind = only_parsing )
        THEN
            FOR i := 1 TO dmli.d_sparr.pparsp^.sparsinfo.p_cnt_infos DO
                IF  ( dmli.d_sparr.pparsp^.sparsinfo.
                    p_pars_infos[ i ].fp_kind = fp_val_all_without_l )
                THEN
                    dmli.d_sparr.pparsp^.sparsinfo.
                          p_pars_infos[ i ].fp_stackpos := 0
                (*ENDIF*) 
            (*ENDFOR*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  ( acv.a_returncode = 0 )
    THEN
        BEGIN
        (* PTS 1113190 E.Z. *)
        IF  NOT dmli.d_pseudo_ins_select
        THEN
            BEGIN
            (* PTS 1111576 E.Z. *)
            a70_strategy_search( acv, dmli, dmli.d_tabarr^[ 2 ].otreeid, sr_rec );
            END;
        (*ENDIF*) 
        IF  ( NOT second_part )
        THEN
            BEGIN
            a56_get_baserecords( acv, dmli.d_sparr, dmli.d_tabarr^[ 2 ] );
            dmli.d_acttabindex := 2;
            acv.a_costsum     := h_costsum;
            END
        ELSE
            BEGIN
            a10del_sysinfo( acv, dmli.d_sparr.pbasep^.syskey, e );
&           ifdef trace
            dmli.d_sparr.pbasep := NIL;
&           endif
            IF  ( e <> e_ok )
            THEN
                a07_b_put_error( acv, e, 1 );
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak562inspect_compatibility (
            VAR acv           : tak_all_command_glob;
            VAR dmli          : tak_dml_info;
            VAR dfa           : tak_dfarr;
            VAR ins_sel_infos : ins_sel_info_arr;
            f                 : integer);
 
VAR
      ok            : boolean;
      i             : integer;
      maxn          : integer;
      destdatatyp   : tsp00_DataType;
      sourcedatatyp : tsp00_DataType;
      sourcedatalen : tsp00_Int2;
      sourcefrac    : integer;
      col_ptr       : tak00_colinfo_ptr;
      colname       : tsp00_KnlIdentifier;
      m_colin       : tak00_scolinf;
      dummy_bool    : boolean;
 
BEGIN
WITH dmli, d_esparr.pbasep^.sbase DO
    BEGIN
&   IFDEF TRACE
    t01buf (ak_sem, d_sparr.pbasep^, 1, d_sparr.pbasep^.b_sl);
    t01buf (ak_sem, d_esparr.pbasep^, 1, d_sparr.pbasep^.b_sl);
&   ENDIF
    i := 1;
    maxn := 0;
    d_colbuf := a103GetColumn (d_sparr.pbasep^.sbase,
          d_sparr.pbasep^.sbase.bfirstcolind);
    WHILE ((i <= d_sparr.pbasep^.sbase.bmaxcol) AND
          (acv.a_returncode = 0)) DO
        WITH d_colbuf^, dfa[ creccolno ] DO
            BEGIN
&           ifdef trace
            t01int4 (ak_sem, 'creccolno   ', creccolno);
            t01int4 (ak_sem, 'dml_node    ', dml_node);
            t01int4 (ak_sem, 'dml_colno_su', dml_colno_in_subquery);
&           endif
            IF  dml_node = 0
            THEN
                BEGIN
                dml_col_ptr := d_colbuf;
&               ifdef TRACE
                ;
                t01int4 (ak_sem, 'dfa[i]     2', creccolno);
&               endif
                END
            ELSE
                IF  dml_colno_in_subquery > f
                THEN
                    a07_b_put_error (acv, e_too_few_values, 1)
                ELSE
                    WITH ins_sel_infos[ dml_colno_in_subquery ] DO
                        BEGIN
                        IF  dml_colno_in_subquery > maxn
                        THEN
                            maxn := dml_colno_in_subquery;
                        (*ENDIF*) 
                        a06extcolno (d_esparr.pbasep^.sbase,
                              dml_colno_in_subquery + 1, col_ptr);
                        destdatatyp   := d_colbuf^.cdatatyp;
                        sourcedatatyp := col_ptr^.cdatatyp;
                        sourcedatalen := col_ptr^.cdatalen;
                        sourcefrac    := col_ptr^.cdatafrac;
                        i_sourcedatatyp := sourcedatatyp;
                        ok := true;
&                       IFDEF TRACE
                        t01int4 (ak_sem, 'i           ', i);
                        t01int4 (ak_sem, 'dm_node     ', dml_node);
                        t01int4 (ak_sem, 'dm_colno_sub', dml_colno_in_subquery);
                        t01int4 (ak_sem, 'sourcedatat ', ord(sourcedatatyp));
                        t01int4 (ak_sem, 'destdatatyp ', ord(destdatatyp));
&                       ENDIF
                        IF  (acv.a_sqlmode = sqlm_oracle) OR
                            (acv.a_comp_type = at_odbc)   OR
                            (acv.a_comp_type = at_jdbc)
                        THEN
                            IF  ((destdatatyp in [ dcha, ddate,
                                dtime, dtimestamp, dunicode ]) AND
                                (sourcedatatyp in [ dfixed, dfloat ]))
                            THEN
                                BEGIN
                                i_convert := i_convert + [ i_from_number ];
                                m_colin.sci_len    := sourcedatalen;
                                m_colin.sci_iolen  := col_ptr^.cinoutlen;
                                m_colin.sci_frac   := sourcefrac;
                                m_colin.sci_typ    := sourcedatatyp;
                                a641_get_length (m_colin, sourcedatalen, dummy_bool);
                                sourcefrac := 0;
                                sourcedatatyp := dcha;
                                END
                            ELSE
                                IF  ((sourcedatatyp in [ dcha, ddate,
                                    dtime, dtimestamp, dunicode ]) AND
                                    (destdatatyp in [ dfixed, dfloat ]))
                                THEN
                                    BEGIN
                                    IF  sourcedatatyp = dunicode
                                    THEN
                                        BEGIN
                                        i_convert := i_convert + [ i_from_unicode ];
                                        i_source_len := sourcedatalen
                                        END;
                                    (*ENDIF*) 
                                    i_convert := i_convert + [ i_from_string ];
                                    sourcedatatyp := dfloat;
                                    sourcedatalen := csp_fixed;
                                    sourcefrac    := csp_float_frac;
                                    END;
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                        IF  destdatatyp = sourcedatatyp
                        THEN
                            BEGIN
                            IF  sourcedatatyp = dfixed
                            THEN
                                BEGIN
                                (* if dest < source then check *)
                                IF  ((dml_col_ptr^.cdatalen <
                                    sourcedatalen) OR
                                    (dml_col_ptr^.cdatafrac <
                                    sourcefrac) OR
                                    (dml_col_ptr^.cdatalen -
                                    dml_col_ptr^.cdatafrac <
                                    sourcedatalen - sourcefrac))
                                THEN
                                    i_convert := i_convert + [ i_check_len ]
                                (*ENDIF*) 
                                END
                            ELSE
                                IF  sourcedatatyp = dfloat
                                THEN
                                    BEGIN
                                    (* if dest < source then check *)
                                    IF  dml_col_ptr^.cdatalen <
                                        sourcedatalen
                                    THEN
                                        i_convert := i_convert + [ i_check_len ]
                                    (*ENDIF*) 
                                    END
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END
                        ELSE
                            IF  sourcedatatyp = dunknown
                            THEN
                                ok := true
                            ELSE
                                IF  ((destdatatyp in [ dcha, ddate,
                                    dtime, dtimestamp ]) AND
                                    (sourcedatatyp in [ dcha, ddate,
                                    dtime, dtimestamp ]))
                                THEN
                                    BEGIN
                                    IF  ((destdatatyp in
                                        [ ddate, dtime, dtimestamp ]) AND
                                        (destdatatyp <> sourcedatatyp))
                                    THEN
                                        i_convert := i_convert + [ i_check_date_time ]
                                    ELSE
                                        IF  (destdatatyp = dcha) AND
                                            (acv.a_dt_format <> dtf_normal)
                                        THEN
                                            i_convert := i_convert + [ i_date_time_format ];
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                    END
                                ELSE
                                    IF  destdatatyp = dunicode
                                    THEN
                                        IF  sourcedatatyp in [ dcha, ddate, dtime, dtimestamp ]
                                        THEN
                                            BEGIN
                                            i_convert := i_convert + [ i_from_ascii ];
                                            IF  (sourcedatatyp <> dcha) AND
                                                (acv.a_dt_format <> dtf_normal)
                                            THEN
                                                i_convert := i_convert + [ i_date_time_format ];
                                            (*ENDIF*) 
                                            END
                                        ELSE
                                            ok := false
                                        (*ENDIF*) 
                                    ELSE
                                        IF  ((destdatatyp in [ dcha,
                                            ddate, dtime, dtimestamp ] ) AND
                                            (sourcedatatyp = dunicode))
                                        THEN
                                            BEGIN
                                            i_convert := i_convert + [ i_from_unicode ];
                                            i_source_len := sourcedatalen;
                                            IF  destdatatyp in
                                                [ ddate, dtime, dtimestamp ]
                                            THEN
                                                i_convert := i_convert + [ i_check_date_time ]
                                            (*ENDIF*) 
                                            END
                                        ELSE
                                            IF  ((sourcedatatyp in [ dfloat, dvfloat ]) AND
                                                (destdatatyp in [ dfloat, dvfloat ]))
                                            THEN
                                                BEGIN
                                                (* if dest < source then check *)
                                                IF  dml_col_ptr^.cdatalen <
                                                    sourcedatalen
                                                THEN
                                                    i_convert := i_convert + [ i_check_len ]
                                                (*ENDIF*) 
                                                END
                                            ELSE
                                                IF  ((destdatatyp in [ dfloat, dvfloat ]) AND
                                                    (sourcedatatyp = dfixed))
                                                THEN
                                                    BEGIN
                                                    (* if dest < source then check *)
                                                    IF  dml_col_ptr^.cdatalen <
                                                     sourcedatalen
                                                    THEN
                                                     i_convert := i_convert + [ i_check_len ]
                                                    (*ENDIF*) 
                                                    END
                                                ELSE
                                                    IF  ((destdatatyp = dfixed) AND
                                                     (sourcedatatyp in [ dfloat, dvfloat ]))
                                                    THEN
                                                     i_convert := i_convert + [ i_check_len ]
                                                    ELSE
                                                     BEGIN (* PTS 1105795 M.Ki. *)
                                                     (*                ===================                      *)
                                                     (* at least Linux-Opteron is not able to handle            *)
                                                     (* IF  ([sourcedatatyp, destdatatyp] = [dstra, dlonga]) OR *)
                                                     (* ([sourcedatatyp, destdatatyp] = [dstrb, dlongb])   OR   *)
                                                     (* ([sourcedatatyp, destdatatyp] = [dstruni, dlonguni])    *)
                                                     (* correctly                                               *)
                                                     (*                ===================                      *)
                                                     IF  
                                                      ((sourcedatatyp = dstra)    AND (destdatatyp = dlonga))   OR
                                                      ((sourcedatatyp = dlonga)   AND (destdatatyp = dstra))    OR
                                                      ((sourcedatatyp = dstrb)    AND (destdatatyp = dlongb))   OR
                                                      ((sourcedatatyp = dlongb)   AND (destdatatyp = dstrb))    OR
                                                      ((sourcedatatyp = dstruni)  AND (destdatatyp = dlonguni)) OR
                                                      ((sourcedatatyp = dlonguni) AND (destdatatyp = dstruni))
                                                     THEN
                                                      ok := true
                                                     ELSE
                                                      ok := false;
                                                     (*ENDIF*) 
                                                     END;
                                                    (*ENDIF*) 
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                        IF  NOT ok
                        THEN
                            BEGIN
                            a061get_colname (dml_col_ptr^, colname);
                            a07_nb_put_error (acv, e_incompatible_datatypes,
                                  1, colname);
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
            (*ENDIF*) 
&           IFDEF TRACE
            t01int4 (ak_sem, 'i           ', i);
            t01int4 (ak_sem, 'dml_node    ', dml_node);
            t01int4 (ak_sem, 'dm_colno_sub', dml_colno_in_subquery);
            t01int4 (ak_sem, 'dml_index   ', dml_index);
&           ENDIF
            i := succ(i);
            IF  cnextind > 0
            THEN
                d_colbuf := a103GetColumn (d_sparr.pbasep^.sbase, cnextind);
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDWHILE*) 
    IF  maxn < f
    THEN
        a07_b_put_error (acv, e_too_many_values, 1)
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak562new_mess_buf_build (
            VAR acv           : tak_all_command_glob;
            VAR dmli          : tak_dml_info;
            VAR dfa           : tak_dfarr;
            VAR ins_sel_infos : ins_sel_info_arr;
            updateDuplicates  : boolean (* PTS 1139531 *));
 
VAR
      first_column : boolean;
      use_syskey   : boolean;
      mbType       : tgg00_MessType;
      countqual    : integer;
      fieldno      : integer;
      stacklen     : integer;
      i            : integer;
      startqual    : integer;
      not_used     : tak_charset;
      aux_qual     : tgg00_QualBuf;
 
BEGIN
WITH acv.a_mblock, mb_qual^ DO
    BEGIN
    aux_qual.mst_addr := NIL;
    SAPDB_PascalForcedMove( mb_qual_size, sizeof( aux_qual.buf ), @buf, 1,
          @aux_qual.buf, 1, MB_PART1_HEAD_MXGG00 );
    stacklen := ( mfirst_free - 1 ) * STACK_ENTRY_MXGG00;
    a10new( acv, stacklen, aux_qual.mst_addr );
    IF  ( aux_qual.mst_addr = NIL )
    THEN
        a07_b_put_error( acv, e_no_more_memory, 1 )
    ELSE
        BEGIN
        aux_qual.mst_max  := mfirst_free - 1;
        SAPDB_PascalMove ('VAK562',   1,    
              mb_st_size, aux_qual.mst_max * STACK_ENTRY_MXGG00,
              @mb_st^, 1, @aux_qual.mst_addr^, 1, stacklen,
              acv.a_returncode);
        mfirst_free  := 1;
        mqual_cnt    := 0;
        mstrat_cnt   := 0;
        mb_strat_len := 0;
        IF  ( acv.a_returncode = 0 )
        THEN
            WITH dmli.d_sparr.pbasep^.sbase DO
                IF  (is_secondary_table in blinkexist) AND
                    (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_length <> cak_i_ignore) AND
                    NOT acv.a_isReplicationSession
                THEN
                    BEGIN
                    a56alloc_linkpos_info (acv,
                          dmli.d_sparr, m_insert, dmli.d_linkbuf);
                    IF  acv.a_returncode = 0
                    THEN
                        BEGIN
                        not_used := [  ];
                        dmli.d_linkbuf^.slinkposinfo.lupd_col_info :=
                              a01fullset;
                        a56put_link_info (acv,
                              dmli.d_sparr.pbasep, not_used, NIL, dmli.d_linkbuf)
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
        a262add_trigger_info( acv, dmli,
              (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_length = cak_i_ignore) );
        IF  updateDuplicates
        THEN
            BEGIN
            mbType               := acv.a_mblock.mb_type;
            acv.a_mblock.mb_type := m_update;
            a262add_trigger_info( acv, dmli,
                  (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_length = cak_i_ignore));
            acv.a_mblock.mb_type := mbType;
            END;
        (*ENDIF*) 
        IF  ( acv.a_returncode = 0 )
        THEN
            BEGIN
            mcol_pos := mfirst_free;
            FOR i := 1 TO dmli.d_sparr.pbasep^.sbase.bmaxcol DO
                BEGIN
&               IFDEF TRACE
                t01int4 (ak_sem, 'X-i         ', i);
&               ENDIF
                END;
            (*ENDFOR*) 
            IF  dmli.d_sparr.pbasep^.sbase.bindexexist
            THEN
                a54_put_indices_in_mess_buf( acv,
                      dmli.d_sparr.pbasep^.sbase, dfa, c_all );
            (*ENDIF*) 
            ;
&           IFDEF TRACE
            t01messblock (ak_sem, 'new_mess_b 1', acv.a_mblock);
&           ENDIF
            WITH dmli.d_sparr.pbasep^.sbase DO
                CASE btablekind OF
                    twithkey :
                        fieldno := 1;
                    twithoutkey :
                        fieldno := 2;
                    OTHERWISE
                        CASE bv_tablekind OF
                            twithkey :
                                fieldno := 1;
                            twithoutkey :
                                fieldno := 2;
                            OTHERWISE
                                fieldno := 1
                            END
                        (*ENDCASE*) 
                    END;
                (*ENDCASE*) 
            (*ENDWITH*) 
            IF  ( fieldno = 2 )
            THEN
                acv.a_mblock.mb_data^.mbp_info.rb_ins_sel_info :=
                      cgg04_ins_sel_nokey;
            (*ENDIF*) 
            acv.a_input_data_pos := 1;
            dmli.d_range         := true;
            dmli.d_nullkey       := false;
            dmli.d_movebefore    := 0;
            dmli.d_maxlen        := 0;
            dmli.d_pars_kind     := fp_val_all_without_l;
            dmli.d_foundset      := [  ];
            first_column    := true;
            mqual_pos       := mfirst_free;
            mfirst_free     := succ( mfirst_free );
            use_syskey      := false;
            dmli.d_colbuf        := a103GetColumn (dmli.d_sparr.pbasep^.sbase,
                  dmli.d_sparr.pbasep^.sbase.bfirstcolind);
            IF  ((fieldno = 2) AND
                (acv.a_returncode = 0))
            THEN
                BEGIN
                use_syskey := true;
                IF  a101_IsExtendedTempFile (acv,
                    dmli.d_sparr.pbasep^.sbase.btreeid) AND
                    NOT dmli.d_pseudo_ins_select
                THEN
                    a56temp_table_key( acv, dmli );
                (*ENDIF*) 
                dmli.d_colbuf := a103GetColumn (dmli.d_sparr.pbasep^.sbase, dmli.d_colbuf^.cnextind);
                END;
            (*ENDIF*) 
            WHILE ((fieldno <= dmli.d_sparr.pbasep^.sbase.bmaxcol) AND
                  (acv.a_returncode = 0)) DO
                BEGIN
                ak562one_selins_value( acv, dmli, dfa, aux_qual, ins_sel_infos );
                IF  ((fieldno = dmli.d_sparr.pbasep^.sbase.bkeycolcount + 1) AND
                    use_syskey)
                THEN
                    mb_st^[ mfirst_free - 1 ].epos :=
                          cgg_rec_key_offset + 1 + SURROGATE_MXGG00 + 1;
                (*ENDIF*) 
                WITH dmli.d_colbuf^ DO
                    BEGIN
                    IF  cnextind > 0
                    THEN
                        dmli.d_colbuf := a103GetColumn (dmli.d_sparr.pbasep^.sbase, cnextind);
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                fieldno := succ(fieldno);
                END;
            (*ENDWHILE*) 
            IF  acv.a_mblock.mb_type2 = mm_specialkey
            THEN
                acv.a_mblock.mb_data^.mbp_info.rb_ins_sel_info := cgg04_cluster_key;
&           IFDEF TRACE
            (*ENDIF*) 
            t01messblock (ak_sem, 'new_mess_b 1', acv.a_mblock);
&           ENDIF
            END;
        (*ENDIF*) 
        IF  ( acv.a_returncode = 0 )
        THEN
            BEGIN
            mqual_cnt := mfirst_free - mqual_pos;
            a61_set_jump( acv.a_mblock, mqual_pos, st_jump_output );
            WITH mb_st^ [ mqual_pos ] DO
                epos := succ( epos );
            (*ENDWITH*) 
            startqual := aux_qual.mqual_pos;
            startqual := startqual + aux_qual.mst_addr^[ startqual ].epos-1;
            countqual := aux_qual.mqual_pos + aux_qual.mqual_cnt - startqual;
            IF  mfirst_free + countqual > mb_st_max + 1
            THEN
                a07_b_put_error (acv, e_too_many_mb_stackentries, 1)
            ELSE
                BEGIN
                SAPDB_PascalMove ('VAK562',   2,    
                      aux_qual.mst_max * STACK_ENTRY_MXGG00, mb_st_size,
                      @aux_qual.mst_addr^, (startqual-1)*STACK_ENTRY_MXGG00+1,
                      @mb_st^, (mfirst_free-1)*STACK_ENTRY_MXGG00+1,
                      countqual*STACK_ENTRY_MXGG00,
                      acv.a_returncode);
                mqual_cnt := mqual_cnt + countqual;
                mfirst_free := mfirst_free + countqual;
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  aux_qual.mst_addr <> NIL
    THEN
        a10dispose( acv, aux_qual.mst_addr );
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(* PTS 1112546 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak562serial_insert_select (VAR acv : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            cdatalen : tsp00_Int2);
 
VAR
      serial_info_len : integer;
      serial_info_pos : tsp00_Int4;
      tempFileIndex   : tsp00_Int4;
      acv_addr        : tak_acv_address;
 
BEGIN
WITH acv, dmli, a_mblock, mb_qual^ DO
    BEGIN
    IF  a_ex_kind = only_parsing
    THEN
        a54_fixedpos (acv, dmli);
    (*ENDIF*) 
    IF  a101_IsExtendedTempFile (acv, d_tabarr^[d_acttabindex].otreeid)
    THEN
        serial_info_len := SURROGATE_MXGG00 + sizeof (acv_addr)
    ELSE
        serial_info_len := SURROGATE_MXGG00;
    (*ENDIF*) 
    serial_info_pos := a_mblock.mb_data_len + d_maxlen + 1;
    IF  (serial_info_pos + serial_info_len - 1 >
        a_mblock.mb_data_size)
    THEN
        a07_b_put_error (acv, e_too_many_mb_data, 1)
    ELSE
        IF  mfirst_free > mb_st_max
        THEN
            a07_b_put_error (acv, e_too_many_mb_stackentries, 1)
        ELSE
            BEGIN
            WITH mb_st^[mfirst_free] DO
                BEGIN
                etype       := st_op;
                eop         := op_serial;
                epos        := serial_info_pos;
                elen_var    := serial_info_len;
                ecol_tab[1] := chr (cdatalen);
                ecol_tab[2] := chr(0)
                END;
            (*ENDWITH*) 
            mfirst_free := mfirst_free + 1;
            WITH d_tabarr^[ d_acttabindex ] DO
                IF  a101_IsExtendedTempFile (acv, otreeid)
                THEN
                    BEGIN
&                   ifdef trace
                    t01int4 (ak_sem, 'fileTempCnt ',
                          a101_GetTempFileIndex (acv, otreeid));
&                   endif
                    tempFileIndex := a101_GetTempFileIndex (acv, otreeid);
                    SAPDB_PascalForcedMove (sizeof (tempFileIndex),
                          mb_data_size, @tempFileIndex, 1,
                          @mb_data^.mbp_buf, serial_info_pos,
                          sizeof (tempFileIndex));
                    acv_addr := @acv;
                    SAPDB_PascalForcedMove (sizeof (acv_addr), mb_data_size,
                          @acv_addr, 1, @mb_data^.mbp_buf,
                          serial_info_pos + SURROGATE_MXGG00,
                          sizeof (acv_addr));
                    mb_data_len := serial_info_pos +
                          SURROGATE_MXGG00 + sizeof (acv_addr) - 1
                    END
                ELSE
                    BEGIN
                    SAPDB_PascalForcedMove (sizeof (otreeid.fileTabId_gg00),
                          mb_data_size,
                          @otreeid.fileTabId_gg00, 1, @mb_data^.mbp_buf,
                          serial_info_pos,
                          sizeof (otreeid.fileTabId_gg00));
                    mb_data_len := serial_info_pos +
                          sizeof (otreeid.fileTabId_gg00) - 1
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak562one_selins_value (
            VAR acv           : tak_all_command_glob;
            VAR dmli          : tak_dml_info;
            VAR dfa           : tak_dfarr;
            VAR aux_qual      : tgg00_QualBuf;
            VAR ins_sel_infos : ins_sel_info_arr);
 
VAR
      isClusterUniqueColumn : boolean;
      convert_info          : convert_type;
      destiolen             : integer;
      m_colin               : tak00_scolinf;
      m_mfirst_free         : tsp00_Int2;
      colname               : tsp00_KnlIdentifier;
 
BEGIN
WITH acv, dmli, d_colbuf^, dfa[ creccolno ], a_mblock, mb_qual^ DO
    BEGIN
    isClusterUniqueColumn := false;
    d_fieldno             := creccolno;
&   ifdef TRACE
    t01int4 (ak_sem, 'dm_fieldno  ', d_fieldno);
    t01int4 (ak_sem, 'data_len    ', a_mblock.mb_data_len);
    t01int4 (ak_sem, 'cinoutlen   ', cinoutlen);
    t01messblock (ak_sem, 'one_selins 1', a_mblock);
&   endif
    IF  dml_node <> 0
    THEN
        WITH ins_sel_infos[ dml_colno_in_subquery ] DO
            BEGIN
            IF  mfirst_free + i_stackcnt > mb_st_max
            THEN
                a07_b_put_error (acv, e_too_many_mb_stackentries, 1)
            ELSE
                BEGIN
                SAPDB_PascalMove ('VAK562',   3,    
                      aux_qual.mst_max * STACK_ENTRY_MXGG00, mb_st_size,
                      @aux_qual.mst_addr^,
                      (i_stackstartpos-1)*STACK_ENTRY_MXGG00+1,
                      @mb_st^, (mfirst_free-1) * STACK_ENTRY_MXGG00+1,
                      i_stackcnt*STACK_ENTRY_MXGG00,
                      a_returncode);
                mfirst_free := mfirst_free+i_stackcnt;
                mqual_cnt   := mfirst_free-mqual_pos;
                WHILE i_convert <> [] DO
                    BEGIN
                    destiolen := cinoutlen;
                    (* in the following if then else-cascade *)
                    (* don't !! change the sequence          *)
                    (* number->string(ascii)->unicode        *)
                    (*    from_number     from_ascii         *)
                    (* number->string(ascii)->date/time      *)
                    (*    from_number     check_date_time    *)
                    (* unicode->ascii->number                *)
                    (*  from_unicode from_string+            *)
                    (*                             check_len *)
                    IF  i_from_number in i_convert
                    THEN
                        BEGIN
                        convert_info := i_from_number;
                        i_convert := i_convert - [ i_from_number ]
                        END
                    ELSE
                        IF  i_date_time_format in i_convert
                        THEN
                            BEGIN
                            convert_info := i_date_time_format;
                            i_convert := i_convert - [ i_date_time_format ]
                            END
                        ELSE
                            IF  i_from_ascii in i_convert
                            THEN
                                BEGIN
                                convert_info := i_from_ascii;
                                i_convert := i_convert - [ i_from_ascii ]
                                END
                            ELSE
                                IF  i_from_unicode in i_convert
                                THEN
                                    BEGIN
                                    convert_info := i_from_unicode;
                                    i_convert := i_convert - [ i_from_unicode ];
                                    destiolen := succ(i_source_len)
                                    END
                                ELSE
                                    IF  i_from_string in i_convert
                                    THEN
                                        BEGIN
                                        convert_info := i_from_string;
                                        i_convert := i_convert - [ i_from_string ]
                                        END
                                    ELSE
                                        IF  i_check_len in i_convert
                                        THEN
                                            BEGIN
                                            convert_info := i_check_len;
                                            i_convert := i_convert - [ i_check_len ]
                                            END
                                        ELSE
                                            IF  i_check_date_time in i_convert
                                            THEN
                                                BEGIN
                                                convert_info := i_check_date_time;
                                                i_convert := i_convert - [ i_check_date_time ]
                                                END;
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    CASE convert_info OF
                        i_from_number :
                            BEGIN
                            m_colin.sci_len    := 2 * csp_fixed;
                            m_colin.sci_iolen  := (m_colin.sci_len+1) DIV 2 + 2;
                            m_colin.sci_frac   := 0;
                            m_colin.sci_typ    := dfloat;
                            a641stack_for_op_b_chr (acv, dmli, m_colin,
                                  cdatalen, dcha);
                            END;
                        i_from_string :
                            BEGIN
                            a65_set_operator (acv, op_num);
                            END;
                        i_from_unicode :
                            BEGIN
                            a641string_set_operator (acv, op_b_uni_trans,
                                  destiolen, 0, chr(csp_unicode),
                                  chr(csp_ascii));
                            END;
                        i_from_ascii :
                            a641string_set_operator (acv, op_b_uni_trans,
                                  cinoutlen, 0, chr(csp_ascii),
                                  chr(csp_unicode));
                        i_check_len :
                            IF  ((cdatatyp = dfixed) OR
                                (cdatatyp = dfloat))
                            THEN
                                BEGIN
                                IF  ((mb_st^ [mfirst_free-1].etype <> st_result) AND
                                    ( mb_st^ [mfirst_free-1].etype <> st_noround))
                                THEN
                                    IF  mfirst_free >= mb_st_max
                                    THEN
                                        a07_b_put_error (acv,
                                              e_too_many_mb_stackentries, 1)
                                    ELSE
                                        BEGIN
                                        WITH mb_st^ [mfirst_free] DO
                                            BEGIN
                                            IF  a_sqlmode = sqlm_ansi
                                            THEN
                                                etype     := st_noround
                                            ELSE
                                                etype     := st_result;
                                            (*ENDIF*) 
                                            eop           := op_none;
                                            ecol_tab[ 1 ] := chr(0);
                                            ecol_tab[ 2 ] := chr(0)
                                            END;
                                        (*ENDWITH*) 
                                        mfirst_free := succ(mfirst_free)
                                        END;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                WITH mb_st^ [mfirst_free-1] DO
                                    BEGIN
                                    IF  a_sqlmode = sqlm_ansi
                                    THEN
                                        etype := st_noround;
                                    (*ENDIF*) 
                                    epos     := cdatalen;
                                    elen_var := cdatafrac - cak_frac_offset;
                                    END
                                (*ENDWITH*) 
                                END;
                            (*ENDIF*) 
                        i_check_date_time :
                            BEGIN
                            (* not only column, which is in internal format, *)
                            (* of the same type and therefore correct        *)
                            a641check_datetime(acv, dmli, cdatatyp);
                            END;
                        i_date_time_format :
                            BEGIN
                            m_colin.sci_len := cdatalen;
                            m_mfirst_free := mfirst_free;
                            a61_format_change (acv, dmli, m_mfirst_free,
                                  i_sourcedatatyp, m_colin.sci_len);
                            END;
                        OTHERWISE
                            BEGIN
                            END
                        END;
                    (*ENDCASE*) 
                    END;
                (*ENDWHILE*) 
                IF  ((NOT (ctopt in ccolpropset)) OR
                    ((cdatatyp = dfixed) AND cbinary))
                THEN
                    d_foundset := d_foundset+[ d_fieldno ];
                (* PTS 1112546 E.Z. *)
                (*ENDIF*) 
                IF  ctserial in ccolpropset
                THEN
                    ak562serial_insert_select (acv, dmli, cdatalen);
                (*ENDIF*) 
                dml_node := 0
                END;
            (*ENDIF*) 
            (* PTS 1122012 E.Z. *)
            IF  (cdatatyp in
                [ dlonga, dlongb, dlonguni,
                dstra, dstrb, dstruni ])
            THEN
                IF  NOT dmli.d_pseudo_ins_select
                THEN (* PTS 1105795 M.Ki. *)
                    BEGIN
                    (* for ins/sel with LONGs, we need to save both   *)
                    (* table surrogate and file surrogate in the      *)
                    (* record being built to be able to insert the    *)
                    (* correct LONG column                            *)
                    (* PTS 1120890 E.Z. *)
                    mb_st^[mfirst_free].elen_var := mxsp_long_desc + 1;
                    (* keep track how many LONGs we are dealing with  *)
                    mstring_cnt := succ(mstring_cnt);
                    END
                ELSE
                    mb_st^[mfirst_free ].elen_var := cinoutlen;
                (*ENDIF*) 
            (*ENDIF*) 
            ;
&           ifdef TRACE
            t01messblock (ak_sem, 'one_selins 2', a_mblock);
&           endif
            END
        (*ENDWITH*) 
    ELSE
        BEGIN
        dml_col_ptr := d_colbuf;
&       ifdef TRACE
        t01int4 (ak_sem, 'dfa[i]     3', creccolno);
&       endif
        IF  (a_mblock.mb_data_len + cinoutlen > a_mblock.mb_data_size) AND
            (ccolstack.etype in[ st_fixkey, st_fixcol ])
        THEN
            a07_b_put_error (acv, e_too_many_mb_data, 1)
        ELSE
            IF  mfirst_free+1 > mb_st_max
            THEN
                a07_b_put_error (acv, e_too_many_mb_stackentries, 1);
            (*ENDIF*) 
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            WITH mb_st^ [mfirst_free] DO
                BEGIN
                etype := st_value;
                eop := op_none;
                epos := a_mblock.mb_data_len+1;
                elen_var      := 0; (* will be changed 50 lines later*)
                ecol_tab[ 1 ] := chr(0);
                ecol_tab[ 2 ] := chr(0)
                END;
            (*ENDWITH*) 
            mfirst_free := succ(mfirst_free);
            (* PTS 1112546 E.Z. *)
            IF  ctserial in ccolpropset
            THEN
                BEGIN
                (* do not call a05serial *)
                ccolpropset := ccolpropset - [ctserial];
                a56_serial_default (acv, dmli, dfa);
                ccolpropset := ccolpropset + [ctserial];
                IF  a_returncode = 0
                THEN
                    ak562serial_insert_select (acv, dmli, cdatalen);
                (*ENDIF*) 
                END
            ELSE
                IF  ctdefault in ccolpropset
                THEN
                    IF  ((cinoutlen >= mxsp_c256) AND
                        (a_mblock.mb_data_len + mxsp_c256 + 1 >
                        a_mblock.mb_data_size))
                        OR
                        ((cinoutlen < mxsp_c256) AND
                        (a_mblock.mb_data_len + cinoutlen + 1 >
                        a_mblock.mb_data_size))
                    THEN
                        (* mxsp_c256: max default-length *)
                        a07_b_put_error (acv, e_too_many_mb_data, 1)
                    ELSE
                        (* PTS 1114777 E.Z. *)
                        IF  cdatatyp in
                            [ dlonga, dlongb, dlonguni,
                            dstra, dstrb, dstruni ]
                        THEN
                            (* PTS 1105795 M.Ki. *)
                            ak562longdefault_record_attach(acv, dmli, dml_col_ptr)
                        ELSE
                            a56one_default_value (acv, dmli,
                                  d_colbuf^, fp_val_varcol_with_len)
                        (*ENDIF*) 
                    (*ENDIF*) 
                ELSE
                    IF  ((ctopt in ccolpropset) OR
                        (ctdropped in ccolpropset))
                    THEN
                        IF  a_mblock.mb_data_len + 3 >
                            a_mblock.mb_data_size
                        THEN
                            (* + 3 : up to 2 length-bytes, undef-byte *)
                            a07_b_put_error (acv, e_too_many_mb_data, 1)
                        ELSE
                            a55_nullvalue (acv, dmli, dfa)
                        (*ENDIF*) 
                    ELSE
                        IF  a56IsClusterKey (acv, dmli, d_colbuf^) (* PTS 1139184 *)
                        THEN
                            isClusterUniqueColumn := true
                        ELSE
                            (* PTS 1112546 E.Z. *)
                            BEGIN
                            a061get_colname (d_colbuf^, colname);
                            a07_nb_put_error (acv, e_missing_mandatory_recordfield,
                                  a_cmd_part^.sp1p_buf_len, colname);
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                IF  NOT (ctserial in ccolpropset)
                THEN
                    WITH mb_st^ [mfirst_free-1] DO
                        BEGIN
                        IF  dml_col_ptr^.
                            ccolstack.etype = st_varcol
                        THEN
                            epos := epos+1
                        ELSE
                            IF  dml_col_ptr^.
                                ccolstack.etype = st_varlongchar
                            THEN
                                epos := epos+2;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        elen_var := a_mblock.mb_data_len+1 - epos;
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
                IF  cdatatyp in
                    [ dlonga, dlongb, dlonguni,
                    dstra, dstrb, dstruni ]
                THEN (* PTS 1105795 M.Ki. *)
                    BEGIN
                    mb_st^[mfirst_free - 1].elen_var := cinoutlen;
                    mb_st^[mfirst_free ].elen_var    := cinoutlen;
                    mstring_cnt := succ (mstring_cnt);
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  mfirst_free >= mb_st_max
    THEN
        a07_b_put_error (acv, e_too_many_mb_stackentries, 1)
    ELSE
        BEGIN
        WITH mb_st^ [mfirst_free] DO
            BEGIN
            etype := st_output_build_rec;
            CASE ccolstack.etype OF
                st_fixkey :
                    eop_out :=op_o_output_fixkey;
                st_varkey :
                    IF  isClusterUniqueColumn
                    THEN
                        eop_out :=op_o_output_cluster_key
                    ELSE
                        eop_out :=op_o_output_key;
                    (*ENDIF*) 
                st_fixcol :
                    eop_out :=op_o_output_fixcol;
                st_varcol :
                    eop_out :=op_o_output_var;
                st_varlongchar :
                    eop_out :=op_o_output_longvar;
                END;
            (*ENDCASE*) 
            epos     := 0;
            IF  NOT (cdatatyp in
                [ dlonga, dlongb, dlonguni,
                dstra, dstrb, dstruni ])
            THEN (* PTS 1105795 M.Ki.; in case of LONG columns, elen_var *)
                (* has been set earlier already and should not be overwritten*)
                elen_var := cinoutlen;
            (*ENDIF*) 
            ecol_pos := 0;
            END;
        (*ENDWITH*) 
        mfirst_free := succ(mfirst_free);
        mqual_cnt   := mfirst_free-mqual_pos;
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a562_select_insert (VAR acv : tak_all_command_glob);
 
VAR
      b_err          : tgg00_BasisError;
      with_commit    : boolean;
      m_ex_kind      : tak_execution_kind;
      mcommand       : tak_commandkind;
      del_cnt        : integer;
      parsk          : tak_parskey;
      deltabid       : tgg00_Surrogate;
      dmli           : tak_dml_info;
      is_from_select : boolean;
 
BEGIN
&ifdef trace
t01command_kind( ak_sem, 'a_command_ki', acv.a_command_kind );
t01execution_kind( ak_sem, 'a_ex_kind   ', acv.a_ex_kind );
&endif
m_ex_kind          := acv.a_ex_kind;
acv.a_ex_kind      := only_parsing;
mcommand           := acv.a_command_kind;
is_from_select     := acv.a_from_select;
with_commit        := false;
acv.a_from_select  := false;
acv.a_fromsel_n    := 0;
acv.a_union_cnt    := 0;
a54_dml_init( acv, dmli, NOT c_in_union );
IF  ( acv.a_first_hint_node <> csp_minint2 )
THEN
    BEGIN
    a80store_cmd_hint_info( acv, dmli, acv.a_ap_tree^[ 0 ].n_lo_level );
    END;
(*ENDIF*) 
ak562do_select_insert (acv, dmli, with_commit);
IF  (acv.a_returncode = 0) AND
    (acv.a_intern_select_cnt = acv.a_max_intern_select)
THEN
    WITH acv.a_mblock, mb_data^ DO
        BEGIN
        IF  dmli.d_cntfromtab = 1
        THEN
            IF  oresfile in dmli.d_tabarr^[ 1 ].ospecialname
            THEN
                dmli.d_sparr.pparsp^.sparsinfo.p_searchname :=
                      dmli.d_tabarr^[ 1 ].otable;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  with_commit
        THEN
            IF  ((acv.a_mblock.mb_qual^.mtrigger_pos > 0) AND
                (acv.a_mblock.mb_qual^.mtrigger_cnt > 0))
                OR
                (dmli.d_linkbuf <> NIL)
            THEN
                a07_b_put_error (acv, e_invalid_tabletype, 1)
            ELSE
                dmli.d_sparr.pparsp^.sparsinfo.p_own_trans := true;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            a54_last_part (acv, dmli.d_sparr, m_ex_kind = only_parsing);
            IF  dmli.d_linkbuf <> NIL
            THEN
                a56insert_upd_with_link (acv, dmli.d_linkbuf);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  ((acv.a_returncode = 0) AND
            (acv.a_isolation_info = temp_lock_rec_get))
        THEN
            a54_loc_temp_locks (acv, dmli.d_globstate, dmli.d_sparr);
        (*ENDIF*) 
        IF  (acv.a_initial_segment_header.sp1c_mess_type in [ sp1m_dbs, sp1m_execute ])
            AND
            (acv.a_intern_select_cnt = acv.a_max_intern_select)
            AND
            (acv.a_returncode = 0)
        THEN
            BEGIN
            parsk           := acv.a_pars_last_key;
            parsk.p_id[ 1 ] := acv.a_first_parskey;
            parsk.p_kind    := m_complex;
            parsk.p_no      := 0;
            acv.a_ex_kind       := only_executing;
            a501do_execute (acv, dmli, parsk,
                  NOT c_output_during_execution);
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  ((acv.a_returncode <> 0) OR
    (m_ex_kind <> only_parsing))
THEN
    a660_prefix_delete (acv, parsk, del_cnt, cak_complete_prefix)
ELSE
    IF  dmli.d_literalrec <> NIL
    THEN
        BEGIN
        b_err := e_ok;
        a10_add_repl_sysinfo (acv, dmli.d_literalrec, c_add, b_err);
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  (acv.a_returncode      = 0) AND
    (dmli.d_phase_cnt = cak_complex_view_indicator)
THEN
    acv.a_command_kind := complex_view_command
ELSE
    acv.a_command_kind := mcommand;
(*ENDIF*) 
deltabid := bsp_c8;
s20int4_to_buf_swap (cak_intern_res_fid, sw_normal, deltabid, 1, sw_normal);
&IFDEF TRACE
t01tabid (ak_sem, 'deltabid1   ', deltabid);
&ENDIF
a10table_cache_delete (acv, deltabid);
s20int4_to_buf_swap (cak_into_res_fid, sw_normal, deltabid, 1, sw_normal);
&IFDEF TRACE
t01tabid (ak_sem, 'deltabid1a  ', deltabid);
&ENDIF
a10table_cache_delete (acv, deltabid);
deltabid[ 1 ] := cak_tempinfo_byte;
SAPDB_PascalForcedMove (sizeof(acv.a_pars_last_key), sizeof(deltabid),
      @acv.a_pars_last_key, 1, @deltabid, 2, mxak_parskey-1);
deltabid[ mxak_parskey+1 ] := chr(0);
deltabid[ mxak_parskey+2 ] := bsp_c1;
&IFDEF TRACE
t01tabid (ak_sem, 'deltabid2   ', deltabid);
&ENDIF
a10table_cache_delete (acv, deltabid);
IF  dmli.d_union_insert
THEN
    BEGIN
    s20int4_to_buf_swap (cak_intern_res_fid       , sw_normal, deltabid, 1, sw_normal);
    s20int4_to_buf_swap (cak_maxsubcnt_per_level+2, sw_normal, deltabid, 5, sw_normal);
&   IFDEF TRACE
    t01tabid (ak_sem, 'deltabid1b  ', deltabid);
&   ENDIF
    a10table_cache_delete (acv, deltabid);
    END;
(* PTS 1111511 E.Z. *)
(*ENDIF*) 
IF  (is_from_select
    AND
    ((acv.a_ex_kind <> only_parsing) OR
    ( acv.a_intern_explain)          OR
    (acv.a_returncode <> 0)))
THEN
    a661_fdelete_fromtab_results (acv);
(*ENDIF*) 
acv.a_from_select := is_from_select;
a54_dml_finalize( dmli, acv.a_transinf.tri_trans );
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak562long_type_st_entries_attach (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info);
      (* PTS 1105795 M.Ki. *)
 
VAR
      qual_pos : integer;
 
BEGIN
(* adds stack entries to string part for all LONGs in the order they *)
(* appear in the record; if a LONG is not being changed during       *)
(* INSERT/SELECT, its regular stack entry from columninfo is taken;  *)
(* if it will be changed, its output length is taken from the        *)
(* corresponding stack entry in the qualification part (and should   *)
(* be 2*SURROGATE_MXGG00+1) and ecol_tab[2] is set to 1 if this column *)
(* has a short column file, and to 2 if it doesn't.                  *)
WITH acv, a_mblock, mb_qual^, dmli DO
    BEGIN
&   ifdef TRACE
    t01messblock( ak_sem, 'long_type_st', acv.a_mblock );
&   endif
    d_colbuf     := a103GetColumn (d_sparr.pbasep^.sbase,
          d_sparr.pbasep^.sbase.blastkeyind);
    d_colbuf     := a103GetColumn (d_sparr.pbasep^.sbase, d_colbuf^.cnextind);
    mstring_pos  := mfirst_free;
    qual_pos     := mqual_pos;
    IF  mfirst_free > mb_st_max
    THEN
        a07_b_put_error (acv, e_too_many_mb_stackentries, 1)
    ELSE
        BEGIN
        WHILE (d_colbuf <> NIL)                           AND
              (d_colbuf^.cdatatyp in
              [ dlonga, dlongb, dlonguni,
              dstra, dstrb, dstruni ])     AND
              NOT (ctinvisible in d_colbuf^.ccolpropset) DO
            BEGIN
            (* find corresponding stackentry for this LONG column  *)
            (* (columns have the same order on the stack as in the *)
            (*  record)                                            *)
            qual_pos := succ (qual_pos);
            WHILE ((mb_st^[qual_pos].etype <> st_output_build_rec) OR
                  ( mb_st^[qual_pos].eop_out <> op_o_output_fixcol))  AND
                  (qual_pos < (mqual_pos + mqual_cnt)) DO
                qual_pos := succ (qual_pos);
            (*ENDWHILE*) 
            mb_st^[ mfirst_free ] := d_colbuf^.ccolstack;
            (* PTS 1116809 M.Ki *)
            IF  d_colbuf^.cdatatyp in
                [ dstra, dstrb, dstruni ]
            THEN
                mb_st^[ mfirst_free ].ecol_tab[2] := chr(1)
            ELSE
                mb_st^[ mfirst_free ].ecol_tab[2] := chr(2);
            (*ENDIF*) 
            (* set correct output length *)
            mb_st^[ mfirst_free ].elen_var := mb_st^[ qual_pos ].elen_var;
&           ifdef trace
            a061td_colinfo (d_colbuf^, mfirst_free);
&           endif
            mfirst_free         := succ (mfirst_free);
            IF  d_colbuf^.cnextind > 0
            THEN
                d_colbuf := a103GetColumn (d_sparr.pbasep^.sbase, d_colbuf^.cnextind)
            ELSE
                d_colbuf := NIL;
            (*ENDIF*) 
            IF  mfirst_free > mb_st_max
            THEN
                BEGIN
                d_colbuf := NIL;
                a07_b_put_error (acv, e_too_many_mb_stackentries, 1);
                END;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak562longdefault_record_attach (
            VAR acv         : tak_all_command_glob;
            VAR dmli        : tak_dml_info;
            VAR longcolinfo : tak00_colinfo_ptr);
      (* PTS 1105795 M.Ki. *)
 
VAR
      ok          : boolean;
      padding     : integer;
      defaultlen  : tsp00_Int4;
      rec_pos     : tsp00_IntMapC2;
      e           : tgg00_BasisError;
      rec_address : tgg00_Surrogate;
      ibuf        : tak_sysbufferaddress;
      ke          : tgg00_SysInfoKey;
      shrtrec     : tgg00_Rec;
      msglist     : tak104_MsgList;
      val_start   : tsp00_MoveObjPtr;
 
BEGIN
(* get default value for this long column and build a record with *)
(* this default value which is then inserted into the data part   *)
(* of the messblock; the position of this record in the data part *)
(* is output as a st_value                                        *)
WITH acv, a_mblock, mb_qual^, mb_data^ DO
    BEGIN
    ke.sentrytyp   := cak_edefault;
    ke.stableid    := dmli.d_tabarr^[ dmli.d_acttabindex ].otreeid.fileTabId_gg00;
    ke.slinkage[1] := chr (longcolinfo^.creccolno DIV 256);
    ke.slinkage[2] := chr (longcolinfo^.creccolno MOD 256);
    ke.skeylen     := mxak_standard_sysk;
    a10get_sysinfo (acv, ke, d_release, ibuf, e);
    IF  e = e_ok
    THEN
        BEGIN
        defaultlen := a14LengthOfDefaultValue (ibuf^.sdefault);
        IF  mb_data_size <
            (mb_data_len + defaultlen + 2*SURROGATE_MXGG00 +
            + sizeof (tgg00_HeaderRec) + 2)
        THEN
            a07_b_put_error (acv, e_too_many_mb_data, 1)
        ELSE
            IF  mb_st_max < (mfirst_free + 1)
            THEN
                a07_b_put_error (acv, e_too_many_mb_stackentries, 1)
            ELSE
                BEGIN
                (* complete stack entry *)
                mb_st^[ mfirst_free-1 ].epos          := mb_data_len + 1;
                mb_st^[ mfirst_free-1 ].elen_var      := SURROGATE_MXGG00 + 1;
                mb_st^[ mfirst_free-1 ].ecol_tab[ 1 ] := chr(0);
                mb_st^[ mfirst_free-1 ].ecol_tab[ 2 ] := chr(0);
                padding             := 0;
                rec_address         := cgg_zero_id;
&               ifdef trace
                t01int4 (ak_sem, 'defaultlen  ', defaultlen );
&               endif
                IF  (a_variable_input AND
                    (a_init_ddl = no_ddl))
                THEN
                    BEGIN
                    msglist         := NIL;
                    IF  a_mblock.mb_fieldlists[cgg_idx_pars_result_valuefieldlist] = NIL
                    THEN
                        IF  NOT ak104_CreateIncrementalMemorySequence ( a_transinf.tri_trans.trAllocator_gg00,
                            sessionCount_eak104, a_mblock.mb_fieldlists[cgg_idx_pars_result_valuefieldlist], msglist)
                        THEN
                            a07_b_put_error (acv, e_no_more_memory, 1);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  (a_mblock.mb_fieldlists[cgg_idx_pars_result_valuefieldlist] <> NIL)
                    THEN
                        BEGIN
                        ok := ak104_CreateVariableField_IMS (mb_fieldlists[cgg_idx_pars_result_valuefieldlist],
                              defaultlen, val_start, msglist);
                        IF  ok
                        THEN
                            BEGIN
                            SAPDB_PascalMove ('VAK562',   4,    
                                  sizeof(ibuf^.sdefault.dfvalues), defaultlen,
                                  @ibuf^.sdefault.dfvalues, 2,
                                  val_start, 1, defaultlen, a_returncode);
                            ok := ak104_CloseCurrentField_IMS
                                  (mb_fieldlists[cgg_idx_pars_result_valuefieldlist],
                                  defaultlen, msglist);
                            rec_pos.mapInt_sp00 := ak104_GetFieldCount_IMS
                                  (mb_fieldlists[cgg_idx_pars_result_valuefieldlist]) - 1;
                            rec_address [SURROGATE_MXGG00 - 2] := chr(true);
                            END;
                        (*ENDIF*) 
                        IF  NOT ok
                        THEN
                            a07_b_put_error (acv, e_no_more_memory, 2)
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    SAPDB_PascalMove ('VAK562',   5,    
                          sizeof(ibuf^.sdefault.dfvalues), sizeof (tgg00_RecBody),
                          @ibuf^.sdefault.dfvalues, 2,
                          @shrtrec.recBody_gg00, SURROGATE_MXGG00 + 1,
                          defaultlen,
                          a_returncode);
                    shrtrec.recLen_gg00          := defaultlen + SURROGATE_MXGG00
                          + sizeof (tgg00_HeaderRec);
                    shrtrec.recKeyLen_gg00       := SURROGATE_MXGG00;
                    shrtrec.recVarcolOffset_gg00 := 0;
                    shrtrec.recVarcolCnt_gg00    := 0;
&                   ifdef trace
                    t01buf1 (ak_sem, shrtrec.recBuf_gg00, 1, shrtrec.recLen_gg00);
&                   endif
                    rec_pos.mapInt_sp00 := mb_data_len + SURROGATE_MXGG00 + 2;
                    IF  (rec_pos.mapInt_sp00 MOD 2) <> 1
                    THEN (* alignment *)
                        BEGIN
                        rec_pos.mapInt_sp00 := succ (rec_pos.mapInt_sp00);
                        padding := succ (padding);
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                rec_address [SURROGATE_MXGG00 - 1] := rec_pos.mapC2_sp00[ 1 ];
                rec_address [SURROGATE_MXGG00    ] := rec_pos.mapC2_sp00[ 2 ];
                mbp_buf [mb_data_len + 1]        := csp_defined_byte;
                SAPDB_PascalMove ('VAK562',   6,    
                      SURROGATE_MXGG00, mb_data_size,
                      @rec_address, 1,
                      @mbp_buf, mb_data_len + 2,
                      SURROGATE_MXGG00,
                      a_returncode);
                mb_data_len := mb_data_len + SURROGATE_MXGG00 + padding + 1;
                IF  NOT (a_variable_input AND
                    (a_init_ddl = no_ddl))
                THEN
                    BEGIN
                    (* write default value to data part *)
                    SAPDB_PascalMove ('VAK562',   7,    
                          sizeof(shrtrec), mb_data_size,
                          @shrtrec, 1,
                          @mbp_buf, rec_pos.mapInt_sp00,
                          shrtrec.recLen_gg00,
                          a_returncode);
                    mb_data_len := mb_data_len + shrtrec.recLen_gg00;
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
