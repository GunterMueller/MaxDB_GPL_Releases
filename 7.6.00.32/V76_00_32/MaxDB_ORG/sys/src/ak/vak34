.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK34$
.tt 2 $$$
.TT 3 $ThomasA$AK_PERSISTENT_OBJECTS$2000-10-31$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : Kernel_Sink
=========
.sp
Purpose :
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a34AbapRead (VAR acv : tak_all_command_glob;
                    VAR descriptor : tgg01_StreamDescriptor;
                    VAR e          : tsp00_Int2);
 
        PROCEDURE
              a34AbapWrite (VAR acv : tak_all_command_glob;
                    VAR descriptor  : tgg01_StreamDescriptor;
                    VAR e           : tgg00_BasisError);
 
        PROCEDURE
              a34AllocPacket (VAR acv : tak_all_command_glob;
                    VAR packet_ptr : tsp1_packet_ptr;
                    VAR size       : tsp00_Int4);
 
        PROCEDURE
              a34BasisError (VAR acv : tak_all_command_glob;
                    e : tgg00_BasisError);
 
        PROCEDURE
              a34call_semantic (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a34CreateSchema(VAR acv  : tak_all_command_glob;
                    VAR SchemaNameWyde : tak_WydeArray;
                    VAR SchemaId       : tsp00_Int4);
 
        PROCEDURE
              a34DropSchema (VAR acv : tak_all_command_glob;
                    SchemaId   : tsp00_Int4);
 
        PROCEDURE
              a34ExistsSchema(VAR acv  : tak_all_command_glob;
                    VAR SchemaNameWyde : tak_WydeArray;
                    VAR SchemaId       : tsp00_Int4);
 
        PROCEDURE
              a34InitOms (VAR acv : tak_all_command_glob;
                    inMigration : boolean);
 
        FUNCTION
              a34IsUnicodeLivecacheUser(VAR acv : tak_all_command_glob) : boolean;
 
        PROCEDURE
              a34Lock (VAR acv     : tak_all_command_glob;
                    pKey           : tsp00_MoveObjPtr;
                    KeyLen         : integer;
                    lockExclusive  : boolean;
                    VAR e          : tgg00_BasisError);
 
        FUNCTION
              a34NewSchemaId (VAR acv : tak_all_command_glob) : tsp00_Int4;
 
        PROCEDURE
              a34SchemaRefSyskey (VAR SchemaName : tsp00_KnlIdentifier;
                    VAR Syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a34SchemaSyskey (SchemaId : tsp00_Int4;
                    VAR Syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a34GetErrormsg (VAR acv : tak_all_command_glob;
                    error           : tsp00_Int2;
                    VAR errtext     : tsp00_MoveObj;
                    VAR errtextlen  : integer);
 
        PROCEDURE
              a34GetSchemaName (VAR acv : tak_all_command_glob;
                    SchemaId           : tsp00_Int4;
                    VAR SchemaNameWyde : tak_WydeArray);
 
        PROCEDURE
              a34HResultError (VAR acv : tak_all_command_glob;
                    hresult : tsp00_Int4);
 
        PROCEDURE
              a34OpMsg (
                    isError : boolean;
                    VAR Buf : tsp00_MoveObj;
                    BufLen  : tsp00_Int4);
 
        PROCEDURE
              a34Receive (VAR acv : tak_all_command_glob;
                    VAR out_packet_ptr : tsp1_packet_ptr);
 
        PROCEDURE
              a34Request (VAR acv : tak_all_command_glob;
                    sql_packet_ptr : tsp1_packet_ptr);
 
        PROCEDURE
              a34outstanding_packet (VAR acv : tak_all_command_glob;
                    VAR e : tsp00_Int2);
 
        PROCEDURE
              a34Restart (VAR acv : tak_all_command_glob);
 
        FUNCTION
              a34ReturnCode (b_err : tgg00_BasisError) : tsp00_Int2;
 
        PROCEDURE
              a34Rollback (VAR acv : tak_all_command_glob;
                    VAR keeplock : tsp00_MoveObj;
                    keep_len     : tsp00_Int4;
                    VAR e        : tsp00_Int2);
 
        PROCEDURE
              a34Sequence (VAR acv : tak_all_command_glob;
                    VAR seqname  : tsp00_KnlIdentifier (*ptocSynonym const tsp00_KnlIdentifier VAR_ARRAY_REF *);
                    VAR seqid    : tgg00_Surrogate;
                    VAR seqInfo  : tgg00_SeqInfo;
                    VAR e        : tsp00_Int2);
 
        PROCEDURE
              a34SetError (VAR acv : tak_all_command_glob;
                    error           : tsp00_Int2;
                    VAR errtext     : tsp00_MoveObj;
                    errtextlen      : integer;
                    codetype        : tsp00_CodeType);
 
        PROCEDURE
              a34SubtransCommit (VAR acv : tak_all_command_glob;
                    VAR e    : tsp00_Int2);
 
        PROCEDURE
              a34SubtransRollback (VAR acv : tak_all_command_glob;
                    VAR e    : tsp00_Int2);
 
        PROCEDURE
              a34SubtransStart (VAR acv : tak_all_command_glob;
                    VAR e    : tsp00_Int2);
 
        PROCEDURE
              a34UnLock (VAR acv  : tak_all_command_glob;
                    pKey           : tsp00_MoveObjPtr;
                    KeyLen         : integer;
                    lockExclusive  : boolean;
                    VAR e          : tgg00_BasisError);
 
        PROCEDURE
              a34VTrace (VAR acv  : tak_all_command_glob;
                    VAR trace_obj : tsp00_MoveObj;
                    trace_len     : tsp00_Int4);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01defaultkey        : tgg00_SysInfoKey;
              a01char_size         : integer;
              a01_il_b_identifier  : tsp00_KnlIdentifier;
              a01_i_oms_container  : tsp00_KnlIdentifier;
              a01_i_oms_schema     : tsp00_KnlIdentifier;
              a01_i_sapr3          : tsp00_KnlIdentifier;
 
        FUNCTION
              a01aligned_cmd_len (len : tsp00_Int4) : tsp00_Int4;
 
        PROCEDURE
              a01setl_identifier (
                    VAR id         : tsp00_KnlIdentifier;
                    set_identifier : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05_nextval_get (VAR acv : tak_all_command_glob;
                    m2_type      : tgg00_MessType2;
                    VAR seq_id   : tgg00_Surrogate;
                    VAR seq_info : tgg00_SeqInfo;
                    VAR dest     : tsp00_C20;
                    destpos      : integer;
                    VAR actlen   : integer);
 
        PROCEDURE
              a05surrogate_get (VAR acv : tak_all_command_glob;
                    VAR surrogate  : tgg00_Surrogate);
 
        PROCEDURE
              a05_unsigned_int2_get (
                    VAR acv  : tak_all_command_glob;
                    pos      : integer;
                    l        : tsp00_Int2;
                    err_code : tsp00_Int4;
                    VAR int  : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06init_curr_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06finish_curr_retpart (VAR acv : tak_all_command_glob;
                    part_kind : tsp1_part_kind;
                    arg_count : tsp00_Int2);
 
        PROCEDURE
              a06reset_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06retpart_move (VAR acv : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
        PROCEDURE
              a06lsend_mess_buf (VAR acv : tak_all_command_glob;
                    VAR mblock      : tgg00_MessBlock;
                    call_from_rsend : boolean;
                    VAR b_err       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (VAR acv : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_const_b_put_error (VAR acv : tak_all_command_glob;
                    b_err      : tgg00_BasisError;
                    err_code   : tsp00_Int4;
                    param_addr : tsp00_MoveObjPtr;
                    const_len  : integer);
 
        PROCEDURE
              a07msg_kernelsink_get (
                    VAR acv        : tak_all_command_glob;
                    msgno          : tsp00_Int2;
                    VAR err_text   : tsp00_MoveObj;
                    VAR msglen     : integer);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache :  VAK10;
 
        PROCEDURE
              a10del_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey  : tgg00_SysInfoKey;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a10add_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10get_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_key_del  (VAR acv : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10key_del  (VAR acv : tak_all_command_glob;
                    VAR  syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10next_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    stop_prefix  : integer;
                    dstate       : tak_directory_state;
                    rec_kind     : tsp00_C2;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_nil_get_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103DropSchemaContainers (
                    VAR acv      : tak_all_command_glob;
                    VAR schemaId : tgg00_Surrogate);
 
        FUNCTION
              a103ExistsSchema (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier (* ptocConst *)) : tak_sysbufferaddress;
 
        PROCEDURE
              a103LoadAuthorizationBySchemaId (
                    VAR acv     : tak_all_command_glob;
                    schemaId    : tsp00_Int4;
                    lockRequest : tgg00_LockReqMode;
                    VAR buf     : tak_userrecord;
                    VAR e       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              AK_Table : VAK11;
 
        PROCEDURE
              a11put_date_time (VAR date : tsp00_Int4;
                    VAR time : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_User_Password : VAK21;
 
        PROCEDURE
              a21CreateOmsSchema (VAR acv : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier;
                    VAR schemaId   : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_Synonym : VAK23;
 
        PROCEDURE
              a23AttachPublicSequence (VAR acv : tak_all_command_glob;
                    VAR sequenceName : tsp00_KnlIdentifier;
                    VAR sequenceId   : tgg00_Surrogate;
                    VAR seqInfo      : tgg00_SeqInfo);
 
        PROCEDURE
              a23create_sequence (VAR acv : tak_all_command_glob;
                    VAR sequence_id     : tgg00_Surrogate;
                    VAR sequence_schema : tgg00_Surrogate;
                    VAR sequence_name   : tsp00_KnlIdentifier;
                    VAR colinfo         : tak00_columninfo;
                    is_serial           : boolean;
                    is_temp_table       : boolean;
                    tree_index          : integer);
 
      ------------------------------ 
 
        FROM
              AK_dialog_tools : VAK260;
 
        PROCEDURE
              a260hresult_error (hresult : tsp00_Int4;
                    VAR dbproc_name : tsp00_KnlIdentifier;
                    VAR errtext     : tsp00_C64;
                    VAR e           : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Kernel_Sink_1 : VAK341;
 
        PROCEDURE
              ak341NilConsistentTrans (VAR Trans : tgg00_TransContext);
 
        PROCEDURE
              ak341LoadLibOms(VAR acv : tak_all_command_glob);
 
        PROCEDURE
              ak341VarObjGuid (VAR guid : tsp00_C16);
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51build_userkey (VAR user_name : tsp00_KnlIdentifier (* ptocConst *);
                    VAR userkey : tgg00_SysInfoKey);
 
        PROCEDURE
              a51_internal_trans (VAR acv : tak_all_command_glob;
                    VAR old_trans : tgg00_UnivTrans);
 
        PROCEDURE
              a51close_internal_trans (VAR acv : tak_all_command_glob;
                    VAR old_trans : tgg00_UnivTrans;
                    m_type        : tgg00_MessType);
 
      ------------------------------ 
 
        FROM
              AK_Lock_Commit_Rollback : VAK52;
 
        PROCEDURE
              a52_ex_commit_rollback (VAR acv : tak_all_command_glob;
                    m_type         : tgg00_MessType;
                    n_rel          : boolean;
                    normal_release : boolean);
 
        PROCEDURE
              a52new_subtrans (VAR acv : tak_all_command_glob;
                    VAR subtrans_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a52end_rollback_subtrans (VAR acv : tak_all_command_glob;
                    VAR subtrans_name : tsp00_KnlIdentifier;
                    m_type : tgg00_MessType);
 
      ------------------------------ 
 
        FROM
              DBS_Commands : VAK93;
 
        PROCEDURE
              a93request (acv_addr  : tak_acv_address;
                    in_packet_ptr   : tsp1_packet_ptr);
 
        PROCEDURE
              a93packet_vtrace (VAR t : tgg00_TransContext;
                    trace_object      : tgg00_VtraceType;
                    packet_ptr        : tsp1_packet_ptr);
 
        PROCEDURE
              a93swap_to_application (VAR packet : tsp1_packet_ptr;
                    a_mess_code      : tsp00_CodeType;
                    a_mess_swap      : tsp00_SwapKind;
                    a_parameter_spec : tak_param_list;
                    a_variable_input : boolean);
 
        PROCEDURE
              a93swap_from_application (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              KB_transaction : VKB53;
 
        PROCEDURE
              k53key_unlock (VAR t : tgg00_TransContext;
                    UnlockMode     : tgg00_LockReqMode;
                    TabId          : tgg00_Surrogate;
                    VAR k          : tgg00_SysInfoKey);
 
        PROCEDURE
              k53lock (VAR t        : tgg00_TransContext;
                    VAR LockTabId   : tgg00_Surrogate;
                    VAR k           : tgg00_Lkey;
                    WantedMode      : tgg00_LockReqMode;
                    WantedState     : tgg00_LockReqState;
                    Nowait          : boolean;
                    CollisionTest   : boolean;
                    VAR GrantedMode : tgg00_LockReqMode);
 
        PROCEDURE
              k53wait (VAR t  : tgg00_TransContext;
                    MessType  : tgg00_MessType;
                    MessType2 : tgg00_MessType2);
 
      ------------------------------ 
 
        FROM
              KB_Logging : vkb560;
 
        PROCEDURE
              kb560GetSys2CatalogTreeId(
                    VAR treeId : tgg00_FileId);
 
        PROCEDURE
              kb560GetSys2CatalogTabId(
                    VAR tabId : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              KB_get : VKB71;
 
        PROCEDURE
              k71num_err_to_b_err (num_err : tsp00_NumError;
                    VAR e : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD02;
 
        PROCEDURE
              b02get_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Lkey;
                    VAR b       : tgg00_Rec);
 
      ------------------------------ 
 
        FROM
              Trace : VBD120;
 
        PROCEDURE
              b120InsertTrace (
                    VAR Trans  : tgg00_TransContext;
                    TraceLayer : tgg00_Debug;
                    TraceType  : tgg00_VtraceType;
                    BodyLen    : tsp00_Int2;
                    pEntry     : tsp00_Addr);
 
        PROCEDURE
              b120MoveObjectTrace (
                    VAR Trans  : tgg00_TransContext;
                    TraceLayer : tgg00_Debug;
                    TraceType  : tgg00_VtraceType;
                    Length     : tsp00_Int4;
                    pEntry     : tsp00_BytePtr);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code          : tgg04_CodeGlobals;
              g01unicode       : boolean;
              g01vtrace        : tgg00_VtraceState;
 
        PROCEDURE
              g01mblock_init (VAR source_trans : tgg00_TransContext;
                    mess_type  : tgg00_MessType;
                    mess2_type : tgg00_MessType2;
                    VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              g01datapart_init (VAR mblock : tgg00_MessBlock;
                    datapart_ptr  : tgg00_DataPartPtr;
                    datapart_size : tsp00_Int4);
 
        FUNCTION
              g01oms_stream_timeout : tsp00_Int4; (* PTS 1115635 *)
 
        PROCEDURE
              g01optextmsg (msg_prio : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C40);
 
        PROCEDURE
              g01qual_init (VAR mblock : tgg00_MessBlock;
                    qual_ptr   : tgg00_QualBufPtr;
                    qual_size  : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        PROCEDURE
              gg06SetNilRef (VAR PageRef : tgg91_PageRef);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id   : tsp00_C6;
                    mod_num  : tsp00_Int4;
                    src_upb  : tsp00_Int4;
                    dest_upb : tsp00_Int4;
                    src      : tsp00_MoveObjPtr;
                    src_pos  : tsp00_Int4;
                    dest     : tsp00_MoveObjPtr;
                    dest_pos : tsp00_Int4;
                    length   : tsp00_Int4;
                    VAR err  : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedUnicodeFill (
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2 );
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17int4to_line (
                    intval    : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_C40 (*ptocSynonym char**));
 
      ------------------------------ 
 
        FROM
              Packet_handling: VSP26;
 
        PROCEDURE
              s26find_part (VAR segm : tsp1_segment;
                    part_kind        : tsp1_part_kind;
                    VAR part_ptr     : tsp1_part_ptr);
 
        PROCEDURE
              s26first_segment_init (packet_ptr : tsp1_packet_ptr;
                    segm_kind                 : tsp1_segment_kind;
                    VAR new_segm_ptr          : tsp1_segment_ptr);
 
        PROCEDURE
              s26nextpart (VAR part_ptr : tsp1_part_ptr);
 
        FUNCTION
              s26packet_len (packet_ptr : tsp1_packet_ptr) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Pointer-Arithmetik : VSP35;
 
        FUNCTION
              s35add_bufaddr_ptocm (
                    buf_addr : tsp00_BufAddr;
                    pos      : tsp00_Int4) : tsp00_BufAddr;
 
      ------------------------------ 
 
        FROM
              GET-Conversions : VSP40;
 
        PROCEDURE
              s40glint (
                    VAR buf  : tsp00_C20;
                    pos      : tsp00_Int4;
                    len      : integer;
                    VAR dest : tsp00_Int4;
                    VAR res  : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80 : VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vmalloc (length : tsp00_Int4;
                    VAR p     : tsp1_packet_ptr;
                    VAR ok    : boolean);
 
        PROCEDURE
              vreceive (pid              : tsp00_TaskId;
                    timeout              : tsp00_Int4;
                    VAR rcv_packet_ptr   : tsp1_packet_ptr;
                    VAR rcv_packet_len   : tsp00_Int4;
                    VAR reply_packet_ptr : tsp1_packet_ptr;
                    VAR reply_packet_len : tsp00_Int4;
                    VAR returncode       : tsp1_comm_error);
 
        PROCEDURE
              vreply (pid            : tsp00_TaskId;
                    reply_packet_ptr : tsp1_packet_ptr;
                    reply_packet_len : tsp00_Int4;
                    VAR returncode   : tsp1_comm_error);
&       ifdef trace
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01addr (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname (*ptocSynonym const char**);
                    bufaddr  : tsp1_packet_ptr (*ptocSynonym const void**));
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
&       endif
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        FUNCTION
              a103ExistsSchema;
 
              tgg00_VoidPtr tak_sysbufferaddress
 
        PROCEDURE
              a103LoadAuthorizationBySchemaId;
 
              tsp00_Buf tak_userrecord
 
        PROCEDURE
              g17int4to_line;
 
              tsp00_Line tsp00_C40
 
        PROCEDURE
              b120InsertTrace;
 
              tgg11_VtraceBodyPtr tsp00_Addr
 
        PROCEDURE
              a07msg_kernelsink_get;
 
              tak_order_errortext tsp00_MoveObj
 
        PROCEDURE
              a05_nextval_get;
 
              tsp00_MoveObj tsp00_C20
 
        PROCEDURE
              vmalloc;
 
              tsp00_ObjAddr tsp1_packet_ptr
 
        PROCEDURE
              s40glint;
 
              tsp00_MoveObj tsp00_C20
 
        PROCEDURE
              k53key_unlock;
 
              tgg00_Lkey tgg00_SysInfoKey
 
        PROCEDURE
              s35add_bufaddr_ptocm;
 
              tsp00_Int4 tsp00_BufAddr
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ThomasA
.sp
.cp 3
Created : 1985-03-14
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-10-31
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.sp 2
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_release          = true;
      c_is_error         = true;
      NoWait_c           = true;
      CollisionTest_c    = true;
 
TYPE
 
      tak34RecBuf = RECORD
            CASE boolean OF
                true :
                    (reckeyoffset : ARRAY[1..cgg_rec_key_offset] OF char;
                    oid           : tgg00_OidSpace;
                    isDeleted     : boolean);
                false :
                    (rec          : tgg00_Rec);
                END;
            (*ENDCASE*) 
 
 
VAR
      ak34OmsSchemaSeqId    : tgg00_Surrogate;
      ak34OmsContainerSeqId : tgg00_Surrogate;
      ak34VarObjGuid        : tsp00_C16;   (* PTS 1102769 T.A. 1999-06-15 *)
 
 
(*------------------------------*) 
 
PROCEDURE
      a34AbapRead (VAR acv : tak_all_command_glob;
            VAR descriptor : tgg01_StreamDescriptor;
            VAR e          : tsp00_Int2);
 
CONST
      c_with_zero = true;
 
VAR
      updateOutPacket   : boolean;
      ix                : integer;
      retcode           : tsp1_comm_error;
      reply_length      : tsp00_Int4;
      rcv_packet_len    : tsp00_Int4;
      reply_packet_size : tsp00_Int4;
      pMsg              : tsp00_MoveObjPtr;
      data_part_ptr     : tsp1_part_ptr;
      msg               : tsp00_C40;
      packetHeader      : tsp1_packet_header;
 
BEGIN
e                := e_ok;
acv.a_returncode := e_ok; (* PTS 1132650, PG *)
a34outstanding_packet (acv, e);
IF  e = e_ok
THEN
    BEGIN
    packetHeader := acv.a_client_out_packet^.sp1_header;
    a06reset_retpart (acv);
    IF  NOT acv.a_optimizedStreamSupport
    THEN
        descriptor.sdCount := 1;
    (*ENDIF*) 
    FOR ix := 1 TO descriptor.sdCount DO
        BEGIN
        a06init_curr_retpart   (acv);
        a06retpart_move        (acv, @descriptor.sdDesc[ix].osdStreamId,
              sizeof(descriptor.sdDesc[ix].osdStreamId));
        IF  descriptor.sdDesc[ix].osdHiddenDesc <> NIL
        THEN
            a06retpart_move        (acv,
                  @descriptor.sdDesc[ix].osdHiddenDesc^, descriptor.sdDesc[ix].osdHiddenDescSize);
        (*ENDIF*) 
        IF  NOT descriptor.sdDesc[ix].osdResetStream (* PTS 1131114, PG *)
        THEN
            a06finish_curr_retpart (acv, sp1pk_abap_istream, MAX_INT2_SP00)
        ELSE
            a06finish_curr_retpart (acv, sp1pk_abap_istream, -2);
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    reply_length := s26packet_len (acv.a_client_out_packet);
    acv.a_client_out_packet^.sp1_header.sp1h_varpart_len := reply_length
          - sizeof (acv.a_client_out_packet^.sp1_header);
    IF  g01vtrace.vtrAny_gg00
    THEN
        a93packet_vtrace (acv.a_transinf.tri_trans,
              ak_send, acv.a_client_out_packet);
    (*ENDIF*) 
    WITH acv DO
        BEGIN
        (* Change request 1001193, T.A. 23.10.1998 *)
        (* PTS 1102369 E.Z. *)
        (* PTS 1102365 E.Z. *)
        a93swap_to_application (a_client_out_packet, a_mess_code,
              a_client_out_packet^.sp1_header.sp1h_mess_swap,
              a_parameter_spec, a_variable_input);
        END;
    (*ENDWITH*) 
    acv.a_return_segm^.sp1r_function_code := csp1_getval_fc;
    updateOutPacket := acv.a_out_packet = acv.a_client_out_packet;
&   ifdef trace
    t01addr (ak_sem, 'a_in_packet ', acv.a_in_packet);
    t01addr (ak_sem, 'a_client_out', acv.a_client_out_packet);
&   endif
    vreply (acv.a_transinf.tri_trans.trTaskId_gg00,
          acv.a_client_out_packet, reply_length, retcode);
    IF  retcode = sp1ce_ok
    THEN
        vreceive (acv.a_transinf.tri_trans.trTaskId_gg00, g01oms_stream_timeout,
              acv.a_in_packet, rcv_packet_len,
              acv.a_client_out_packet, reply_packet_size, retcode);
    (*ENDIF*) 
    IF  updateOutPacket
    THEN
        acv.a_out_packet := acv.a_client_out_packet;
    (*ENDIF*) 
    IF  retcode = sp1ce_ok
    THEN
        BEGIN
        IF  acv.a_in_packet^.sp1_header.sp1h_mess_swap <> g01code.kernel_swap
        THEN (* Change request 1001193, T.A. 23.10.1998 *)
            a93swap_from_application (acv);
        (*ENDIF*) 
        IF  g01vtrace.vtrAny_gg00
        THEN
            a93packet_vtrace (acv.a_transinf.tri_trans,
                  ak_receive, acv.a_in_packet);
&       ifdef trace
        (*ENDIF*) 
        t01addr (ak_sem, 'a_in_packet ', acv.a_in_packet);
        t01int4 (ak_sem, 'rcv_packet_l', rcv_packet_len);
        t01addr (ak_sem, 'a_client_out', acv.a_client_out_packet);
        t01int4 (ak_sem, 'repl_pckt_sz', reply_packet_size);
&       endif
        s26find_part (acv.a_in_packet^.sp1_segm, sp1pk_data, data_part_ptr);
        IF  data_part_ptr <> NIL
        THEN
            BEGIN
            descriptor.sdCount := 0;
            REPEAT
                descriptor.sdCount := descriptor.sdCount + 1;
                IF  descriptor.sdDesc[descriptor.sdCount].osdHandle = NIL
                THEN
                    acv.a_data_part := data_part_ptr;
                (*ENDIF*) 
                IF  data_part_ptr^.sp1p_part_kind <> sp1pk_data
                THEN
                    BEGIN
                    e := e_oms_istream_error;
                    msg  := 'unexpected part found :                 ';
                    g17int4to_line (ord(data_part_ptr^.sp1p_part_kind), NOT c_with_zero, 5, 24, msg);
                    pMsg := @msg;
                    a34OpMsg (c_is_error, pMsg^, sizeof(msg));
                    END;
                (*ENDIF*) 
                descriptor.sdDesc[descriptor.sdCount].osdEndOfStream :=
                      sp1pa_last_packet in data_part_ptr^.sp1p_attributes;
                descriptor.sdDesc[descriptor.sdCount].osdRowCount := data_part_ptr^.sp1p_arg_count;
                descriptor.sdDesc[descriptor.sdCount].osdBufPtr   := @data_part_ptr^.sp1p_buf;
                descriptor.sdDesc[descriptor.sdCount].osdBufSize  := data_part_ptr^.sp1p_buf_len;
                IF  (descriptor.sdCount <> acv.a_in_packet^.sp1_segm.sp1s_no_of_parts)
                THEN
                    BEGIN
                    s26nextpart (data_part_ptr);
                    IF  acv.a_returncode <> 0
                    THEN (* may have been set by s26nextpart *)
                        e := e_oms_istream_error;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            UNTIL
                (descriptor.sdCount = acv.a_in_packet^.sp1_segm.sp1s_no_of_parts) OR (e <> e_ok);
            (*ENDREPEAT*) 
            END
        ELSE
            BEGIN
            e := e_oms_istream_error;
            ak34store_msgtext (acv, e);
            s26find_part (acv.a_in_packet^.sp1_segm, sp1pk_errortext, data_part_ptr);
            IF  data_part_ptr = NIL
            THEN
                BEGIN
                msg  := 'istream : no data and no error found    ';
                pMsg := @msg;
                a34OpMsg (c_is_error, pMsg^, sizeof(msg));
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        WITH acv.a_client_out_packet^ DO
            BEGIN
            sp1_header := packetHeader;
            sp1_header.sp1h_varpart_size := reply_packet_size -
                  sizeof (sp1_header);
            sp1_header.sp1h_varpart_size := (sp1_header.sp1h_varpart_size DIV
                  csp1_part_align_length) * csp1_part_align_length;
            END;
        (*ENDWITH*) 
        s26first_segment_init (acv.a_client_out_packet,
              sp1sk_return, acv.a_return_segm);
        acv.a_curr_retpart := NIL;
        END
    ELSE
        ak34vreceive_error (acv, retcode, e);
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34AbapWrite (VAR acv : tak_all_command_glob;
            VAR descriptor  : tgg01_StreamDescriptor;
            VAR e           : tgg00_BasisError);
 
VAR
      reset               : boolean;
      exitLoop            : boolean;
      ix                  : integer;
      ic2                 : tsp00_IntMapC2;
      retcode             : tsp1_comm_error;
      rowSize             : integer;
      rowCount            : integer;
      noOfParts           : integer;
      segmLength          : tsp00_Int4;
      length              : tsp00_Int4;
      move_len            : tsp00_Int4;
      reply_length        : tsp00_Int4;
      firstStreamRowCount : tsp00_Int4;
      restFirstStream     : tsp00_Int4;
      pBuf                : tsp00_BufAddr;
 
BEGIN
e                               := e_ok;
acv.a_returncode                := e_ok; (* PTS 1132650, PG *)
firstStreamRowCount             := descriptor.sdDesc[1].osdRowCount;
restFirstStream                 := firstStreamRowCount;
pBuf                            := @descriptor.sdDesc[1].osdBufPtr^;
descriptor.sdDesc[1].osdBufSize := 0;
WHILE ( (restFirstStream > 0) OR
      (descriptor.sdDesc[1].osdResetStream = true) ) (* PTS 1133565, PG *)
      AND
      (e = e_ok) DO
    BEGIN
    a34outstanding_packet (acv, e);
    IF  e = e_ok
    THEN
        BEGIN
        a06reset_retpart (acv);
        ix     := 0;
        reset  := false;
        REPEAT
            ix := ix + 1;
            segmLength := acv.a_return_segm^.sp1s_segm_len;
            noOfParts  := acv.a_return_segm^.sp1s_no_of_parts;
            IF  ix > 1
            THEN
                BEGIN
                pBuf := @descriptor.sdDesc[ix].osdBufPtr^;
                descriptor.sdDesc[ix].osdBufSize := 0;
                END;
            (*ENDIF*) 
            a06init_curr_retpart   (acv);
            IF  (acv.a_curr_retpart = NIL) OR (acv.a_curr_retpart^.sp1p_buf_size <
                sizeof(descriptor.sdDesc[ix].osdStreamId) + descriptor.sdDesc[ix].osdHiddenDescSize)
            THEN
                reset := true
            ELSE
                BEGIN
                a06retpart_move (acv, @descriptor.sdDesc[ix].osdStreamId,
                      sizeof(descriptor.sdDesc[ix].osdStreamId));
                IF  descriptor.sdDesc[ix].osdHiddenDesc <> NIL
                THEN
                    a06retpart_move        (acv,
                          @descriptor.sdDesc[ix].osdHiddenDesc^, descriptor.sdDesc[ix].osdHiddenDescSize);
                (*ENDIF*) 
                a06finish_curr_retpart (acv, sp1pk_abap_ostream, 1);
                a06init_curr_retpart   (acv);
                IF  acv.a_curr_retpart = NIL
                THEN
                    reset := true
                ELSE
                    BEGIN
                    move_len := 0;
                    rowSize  := descriptor.sdDesc[ix].osdRowSize;
                    IF  descriptor.sdDesc[ix].osdDefaultCompression (* PTS 1135058, PG *)
                    THEN
                        BEGIN
                        exitLoop := false;
                        rowCount := 0;
                        REPEAT
                            ic2.mapC2_sp00[1] := pBuf^[1];
                            ic2.mapC2_sp00[2] := pBuf^[2];
                            IF  acv.a_curr_retpart^.sp1p_buf_len + ic2.mapInt_sp00 - 2 <= acv.a_curr_retpart^.sp1p_buf_size
                            THEN
                                BEGIN
                                rowCount := rowCount + 1;
                                a06retpart_move (acv, @pBuf^[3], ic2.mapInt_sp00 - 2);
                                descriptor.sdDesc[ix].osdBufSize :=
                                      descriptor.sdDesc[ix].osdBufSize + ic2.mapInt_sp00;
                                pBuf := s35add_bufaddr_ptocm (pBuf, ic2.mapInt_sp00);
                                END
                            ELSE
                                BEGIN
                                exitLoop := true;
                                reset    := (acv.a_curr_retpart^.sp1p_buf_len = 0) AND (ix > 1);
                                END;
                            (*ENDIF*) 
                        UNTIL
                            exitLoop OR (rowCount = descriptor.sdDesc[ix].osdRowCount);
                        (*ENDREPEAT*) 
                        END
                    ELSE
                        BEGIN
                        rowCount := descriptor.sdDesc[ix].osdRowCount;
                        length   := rowCount * rowSize;
                        IF  length <= acv.a_curr_retpart^.sp1p_buf_size
                        THEN
                            move_len := length
                        ELSE
                            BEGIN
                            rowCount := acv.a_curr_retpart^.sp1p_buf_size DIV rowSize;
                            move_len := rowCount * rowSize;
                            reset    := (move_len = 0) AND (ix > 1);
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  (e = e_ok) AND NOT reset
                    THEN
                        BEGIN
                        descriptor.sdDesc[ix].osdBufSize :=
                              descriptor.sdDesc[ix].osdBufSize + move_len;
                        IF  move_len > 0
                        THEN
                            a06retpart_move (acv, @pBuf^, move_len);
                        (*ENDIF*) 
                        IF  acv.a_returncode = 0
                        THEN
                            descriptor.sdDesc[ix].osdRowCount := rowCount;
                        (*ENDIF*) 
                        IF  NOT descriptor.sdDesc[ix].osdResetStream (* PTS1133565, PG *)
                        THEN
                            a06finish_curr_retpart (acv, sp1pk_data, rowCount)
                        ELSE
                            BEGIN
                            a06finish_curr_retpart (acv, sp1pk_data, -2);
                            descriptor.sdDesc[ix].osdResetStream := false;
                            END;
                        (*ENDIF*) 
                        IF  ix = 1
                        THEN
                            BEGIN
                            restFirstStream := restFirstStream - rowCount;
                            IF  restFirstStream > 0
                            THEN
                                BEGIN (* first stream has to be transferred completely *)
                                descriptor.sdDesc[1].osdRowCount := restFirstStream;
                                IF  NOT descriptor.sdDesc[1].osdDefaultCompression (* PTS 1135058, PG *)
                                THEN
                                    pBuf := s35add_bufaddr_ptocm (pBuf, move_len);
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  reset OR (acv.a_returncode <> 0)
            THEN
                BEGIN
                acv.a_returncode                    := 0;
                acv.a_return_segm^.sp1s_segm_len    := segmLength;
                acv.a_return_segm^.sp1s_no_of_parts := noOfParts;
                END
            (*ENDIF*) 
        UNTIL
            reset OR (ix = descriptor.sdCount) OR (restFirstStream > 0);
        (*ENDREPEAT*) 
        IF  e = e_ok
        THEN
            BEGIN
            descriptor.sdCount := acv.a_return_segm^.sp1s_no_of_parts DIV 2;
            reply_length       := s26packet_len (acv.a_client_out_packet);
            acv.a_client_out_packet^.sp1_header.sp1h_varpart_len := reply_length
                  - sizeof (acv.a_client_out_packet^.sp1_header);
            IF  g01vtrace.vtrAny_gg00
            THEN
                a93packet_vtrace (acv.a_transinf.tri_trans,
                      ak_send, acv.a_client_out_packet);
            (*ENDIF*) 
            WITH acv DO
                BEGIN
                (* Change request 1001193, T.A. 23.10.1998 *)
                (* PTS 1102369 E.Z. *)
                (* PTS 1102365 E.Z. *)
                a93swap_to_application (a_client_out_packet, a_mess_code,
                      a_client_out_packet^.sp1_header.sp1h_mess_swap,
                      a_parameter_spec, a_variable_input);
                END;
            (*ENDWITH*) 
            vreply (acv.a_transinf.tri_trans.trTaskId_gg00,
                  acv.a_client_out_packet, reply_length, retcode);
            IF  retcode = sp1ce_ok
            THEN
                acv.a_outstanding_packet := true
            ELSE
                ak34vreceive_error (acv, retcode, e);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
descriptor.sdDesc[1].osdRowCount := firstStreamRowCount
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak34vreceive_error (VAR acv : tak_all_command_glob;
            retcode : tsp1_comm_error;
            VAR e   : tsp00_Int2);
 
BEGIN
(* acv.a_in_packet and acv.a_out_packet are nil now, assign *)
(* new memory to them                                       *)
(* session will be terminated, so a_ap_tree can be used     *)
acv.a_in_packet := @acv.a_ap_tree^;
WITH acv.a_cmd_packet_header DO
    BEGIN
    sp1h_varpart_size :=
          (cak_init_node DIV 2 * sizeof (acv.a_ap_tree^[1])) -
          sizeof (acv.a_cmd_packet_header);
    sp1h_varpart_len  := 0;
    sp1h_no_of_segm   := 0;
    END;
(*ENDWITH*) 
acv.a_out_packet        := @acv.a_ap_tree^[cak_init_node DIV 2 + 1];
acv.a_client_out_packet := acv.a_out_packet; (* PTS 1134325 *)
WITH acv.a_out_packet^ DO
    BEGIN
    sp1_header := acv.a_cmd_packet_header;
    sp1_header.sp1h_varpart_size :=
          (cak_init_node DIV 2 * sizeof (acv.a_ap_tree^[1])) -
          sizeof (sp1_header);
    sp1_header.sp1h_varpart_size := (sp1_header.sp1h_varpart_size DIV
          csp1_part_align_length) * csp1_part_align_length;
    END;
(*ENDWITH*) 
s26first_segment_init (acv.a_out_packet,
      sp1sk_return, acv.a_return_segm);
acv.a_curr_retpart := NIL;
IF  retcode = sp1ce_timeout
THEN
    e := e_response_timeout
ELSE
    e := e_net_line_down; (* PTS 1108516 *)
(*ENDIF*) 
(* PTS 1107485 E.Z. *)
acv.a_abap_tab_comm_ok := false;
(* PTS 1107551 E.Z. *)
acv.a_cmd_part  := NIL;
acv.a_abap_part := NIL;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34AllocPacket (VAR acv : tak_all_command_glob;
            VAR packet_ptr : tsp1_packet_ptr;
            VAR size       : tsp00_Int4);
 
CONST
      c_packet_size = 2;
 
VAR
      ok : boolean;
 
BEGIN
size := c_packet_size * sizeof (tsp00_Buf);
IF  acv.a_dbp_packet_ptr = NIL
THEN
    BEGIN
    vmalloc (size, acv.a_dbp_packet_ptr, ok);
    IF  NOT ok
    THEN
        size := 0
    (*ENDIF*) 
    END;
(*ENDIF*) 
packet_ptr := acv.a_dbp_packet_ptr
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34BasisError (VAR acv : tak_all_command_glob;
            e : tgg00_BasisError);
 
BEGIN
a07_b_put_error (acv, e, 1)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34SchemaRefSyskey (VAR SchemaName : tsp00_KnlIdentifier;
            VAR Syskey : tgg00_SysInfoKey);
 
BEGIN
Syskey.sauthid     := cgg_zero_id;
Syskey.sentrytyp   := cak_eschemaref;
Syskey.slinkage    := cak_init_linkage;
Syskey.sidentifier := SchemaName;
Syskey.skeylen   := sizeof(Syskey.sauthid) + sizeof(Syskey.sentrytyp) +
      sizeof (Syskey.slinkage) + sizeof(Syskey.sidentifier)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34SchemaSyskey (SchemaId : tsp00_Int4;
            VAR Syskey : tgg00_SysInfoKey);
 
VAR
      ix : integer;
 
BEGIN
Syskey.sschema_id := cgg_zero_id;
FOR ix := 1 TO 4 DO
    BEGIN
    Syskey.sschema_id[5 - ix] := chr(SchemaId MOD 256);
    SchemaId := SchemaId DIV 256
    END;
(*ENDFOR*) 
Syskey.sentrytyp   := cak_eschema;
Syskey.slinkage    := cak_init_linkage;
Syskey.skeylen   := sizeof(Syskey.sschema_id) + sizeof(Syskey.sentrytyp) +
      sizeof (Syskey.slinkage)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34GetSchemaName (VAR acv : tak_all_command_glob;
            SchemaId           : tsp00_Int4;
            VAR SchemaNameWyde : tak_WydeArray);
 
VAR
      aux              : char;
      ix               : integer;
      pos              : integer;
      i2c2             : tsp_int_map_c2;
      schemaSurrogate  : tgg00_Surrogate;
      schemaName       : tsp00_KnlIdentifier;
 
BEGIN
acv.a_returncode := 0;
IF  ak34SchemaIdExists (acv, SchemaId, lckFree_egg00, schemaName, schemaSurrogate)
THEN
    BEGIN
    ix := 0;
    IF  g01unicode
    THEN
        BEGIN
        pos := 0;
        REPEAT
            pos := pos + 1;
            i2c2.map_c2[1] := schemaName[pos];
            pos := pos + 1;
            i2c2.map_c2[2] := schemaName[pos];
            IF  g01code.kernel_swap <> sw_normal
            THEN
                BEGIN
                aux            := i2c2.map_c2[1];
                i2c2.map_c2[1] := i2c2.map_c2[2];
                i2c2.map_c2[2] := aux;
                END;
            (*ENDIF*) 
            ix := ix + 1;
            SchemaNameWyde[ix] := i2c2.map_int;
        UNTIL
            (SchemaNameWyde[ix] = 0) OR (pos >= sizeof(schemaName));
        (*ENDREPEAT*) 
        END
    ELSE
        BEGIN
        ix := 0;
        REPEAT
            ix := ix + 1;
            SchemaNameWyde[ix] := ord(schemaName[ix]);
        UNTIL
            (SchemaNameWyde[ix] = 0) OR (ix = sizeof(schemaName));
        (*ENDREPEAT*) 
        END;
    (*ENDIF*) 
    END
ELSE
    a07_b_put_error (acv, e_unknown_name, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak34SchemaIdExists (VAR acv : tak_all_command_glob;
            schemaId             : tsp00_Int4;
            lockRequest          : tgg00_LockReqMode;
            VAR schemaName       : tsp00_KnlIdentifier;
            VAR schemaSurrogate  : tgg00_Surrogate) : boolean;
 
VAR
      e      : tgg00_BasisError;
      buffer : tak_userrecord;
 
BEGIN
e := e_ok;
a103LoadAuthorizationBySchemaId (acv, schemaId, lockRequest, buffer, e);
IF  e = e_ok
THEN
    BEGIN
    IF  is_schema_rec in buffer.urecordtyp
    THEN
        BEGIN
        schemaName         := buffer.username;
        schemaSurrogate    := buffer.usurrogate;
        ak34SchemaIdExists := true;
        END
    ELSE
        ak34SchemaIdExists := false
    (*ENDIF*) 
    END
ELSE
    ak34SchemaIdExists := false;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak34BuildId(VAR acv : tak_all_command_glob;
            VAR SequenceId : tgg00_Surrogate;
            VAR SchemaId   : tsp00_Int4);
 
VAR
      num_err    : tsp00_NumError;
      b_err      : tgg00_BasisError;
      seq_buf    : tak_sysbufferaddress;
      number     : tsp00_C20;
      number_len : integer;
      sysk       : tgg00_SysInfoKey;
 
BEGIN
sysk           := a01defaultkey;
sysk.stableid  := SequenceId;
sysk.sentrytyp := cak_esequence;
a10get_sysinfo (acv, sysk, d_release, seq_buf, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    a05_nextval_get (acv,
          mm_nil, SequenceId, seq_buf^.ssequence.seq_info, number, 1, number_len);
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        s40glint (number, 2, (number_len - 2) * 2, SchemaId, num_err);
        IF  num_err <> num_ok
        THEN
            BEGIN
            k71num_err_to_b_err (num_err, b_err);
            a07_b_put_error (acv, b_err, 1)
            END;
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
ELSE
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34CreateSchema(VAR acv  : tak_all_command_glob;
            VAR SchemaNameWyde : tak_WydeArray;
            VAR SchemaId       : tsp00_Int4);
 
VAR
      e          : tgg00_BasisError;
      SchemaName : tsp00_KnlIdentifier;
 
BEGIN
ak34MakeSchemaIdentifier (SchemaNameWyde, SchemaName, e);
IF  e = e_ok
THEN
    ak34CreateSchema (acv, SchemaName, SchemaId)
ELSE
    a07_b_put_error (acv, e, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak34MakeSchemaIdentifier(
            VAR SchemaNameWyde   : tak_WydeArray;
            VAR SchemaIdentifier : tsp00_KnlIdentifier;
            VAR e                : tgg00_BasisError
            );
 
VAR
      i2c2       : tsp_int_map_c2;
      ix         : integer;
      pos        : integer;
 
BEGIN
e := e_ok;
FOR ix := 1 TO sizeof(a01_il_b_identifier) DO
    SchemaIdentifier[ix] := chr(0);
(*ENDFOR*) 
ix               := 1;
pos              := 1;
WHILE ix < sizeof(SchemaIdentifier) DIV 2 DO
    BEGIN
    IF  g01unicode
    THEN
        BEGIN
        i2c2.map_int := SchemaNameWyde[ix];
        IF  g01code.kernel_swap = sw_normal
        THEN
            BEGIN
            SchemaIdentifier[pos  ] := i2c2.map_c2[1];
            SchemaIdentifier[pos+1] := i2c2.map_c2[2];
            END
        ELSE
            BEGIN
            SchemaIdentifier[pos  ] := i2c2.map_c2[2];
            SchemaIdentifier[pos+1] := i2c2.map_c2[1];
            END;
        (*ENDIF*) 
        pos := pos + 2
        END
    ELSE
        BEGIN
        IF  SchemaNameWyde[ix] > 255
        THEN
            BEGIN
            e  := e_not_translatable;
            ix := sizeof(SchemaIdentifier);
            END;
        (*ENDIF*) 
        SchemaIdentifier[pos] := chr(SchemaNameWyde[ix]);
        pos                   := pos + 1;
        END;
    (*ENDIF*) 
    IF  SchemaNameWyde[ix] = 0
    THEN (* exit loop *)
        ix := sizeof(SchemaIdentifier)
    ELSE
        ix := ix + 1;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak34CreateSchema(VAR acv : tak_all_command_glob;
            VAR schemaName     : tsp00_KnlIdentifier;
            VAR schemaId       : tsp00_Int4);
 
CONST
      c_exclusive = true;
 
BEGIN
acv.a_returncode := 0;
a21CreateOmsSchema (acv, schemaName, schemaId);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34DropSchema (VAR acv : tak_all_command_glob;
            SchemaId   : tsp00_Int4);
 
CONST
      c_exclusive = true;
 
VAR
      ret             : integer;
      e               : tgg00_BasisError;
      schemaSurrogate : tgg00_Surrogate;
      SchemaRefSyskey : tgg00_SysInfoKey;
      schemaName      : tsp00_KnlIdentifier;
 
BEGIN
acv.a_returncode := 0;
IF  NOT ak34SchemaIdExists (acv, SchemaId, lckRowExcl_egg00, schemaName, schemaSurrogate)
THEN
    BEGIN
    e := e_unknown_schema
    END
ELSE
    IF  schemaName = a01_i_oms_schema
    THEN
        e := e_missing_privilege
    ELSE
        BEGIN
        a34SubtransStart (acv, e);
        IF  e = e_ok
        THEN
            BEGIN
            a103DropSchemaContainers (acv, schemaSurrogate);
            IF  acv.a_returncode = 0
            THEN
                BEGIN
                a51build_userkey (schemaName, SchemaRefSyskey);
                a10del_sysinfo (acv, SchemaRefSyskey, e);
                END;
            (*ENDIF*) 
            IF  acv.a_returncode = 0
            THEN
                a34SubtransCommit (acv, e)
            ELSE
                BEGIN
                ret := acv.a_returncode;
                a34SubtransRollback (acv, e);
                acv.a_returncode := ret;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34ExistsSchema(VAR acv  : tak_all_command_glob;
            VAR SchemaNameWyde : tak_WydeArray;
            VAR SchemaId       : tsp00_Int4);
 
VAR
      e          : tgg00_BasisError;
      pSchema    : tak_sysbufferaddress;
      SchemaName : tsp00_KnlIdentifier;
 
BEGIN
e                := e_ok;
acv.a_returncode := 0;
ak34MakeSchemaIdentifier (SchemaNameWyde, SchemaName, e);
IF  e = e_ok
THEN
    BEGIN
    pSchema := a103ExistsSchema (acv, SchemaName);
    IF   pSchema <> NIL
    THEN
        BEGIN
        SchemaId := pSchema^.suser.uparams[schemaid];
        IF  (SchemaId <= 0) OR (SchemaId = csp_maxint4)
        THEN
            e := e_unknown_name;
        (*ENDIF*) 
        END
    ELSE
        e := e_unknown_name;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34GetErrormsg (VAR acv : tak_all_command_glob;
            error              : tsp00_Int2;
            VAR errtext        : tsp00_MoveObj;
            VAR errtextlen     : integer);
 
BEGIN
a07msg_kernelsink_get (acv, error, errtext, errtextlen)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34HResultError (VAR acv : tak_all_command_glob;
            hresult : tsp00_Int4);
 
VAR
      e       : tgg00_BasisError;
      errtext : tsp00_C64;
      dbproc_name : tsp00_KnlIdentifier;
 
BEGIN
errtext := bsp_c64;
dbproc_name := bsp_knl_identifier;
a260hresult_error (hresult, dbproc_name, errtext, e);
a07_const_b_put_error (acv, e, 1, @errtext, sizeof (errtext))
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34InitOms (VAR acv : tak_all_command_glob;
            inMigration : boolean);
 
VAR
      ix            : integer;
      b_err         : tgg00_BasisError;
      sysk          : tgg00_SysInfoKey;
      DummySchemaId : tsp00_Int4;
      DummyColInfo  : tak00_columninfo;
 
BEGIN
ak34BuildSequenceIds;
ix := sizeof(a01_i_oms_schema);
WHILE a01_i_oms_schema[ix] = bsp_c1 DO
    BEGIN
    a01_i_oms_schema[ix] := chr(0);
    ix := ix - a01char_size
    END;
(*ENDWHILE*) 
IF  inMigration
THEN
    BEGIN
    (* try to delete old sequences, ignore errors *)
    sysk           := a01defaultkey;
    sysk.stableid  := ak34OmsSchemaSeqId;
    sysk.sentrytyp := cak_esequence;
    a10del_sysinfo (acv, sysk, b_err);
    sysk.stableid  := ak34OmsContainerSeqId;
    a10del_sysinfo (acv, sysk, b_err);
    END;
(*ENDIF*) 
a23create_sequence (acv, ak34OmsSchemaSeqId, acv.a_curr_user_id,
      a01_i_oms_schema, DummyColInfo, false, false, 0);
IF  acv.a_returncode = 0
THEN
    a23create_sequence (acv, ak34OmsContainerSeqId, acv.a_curr_user_id,
          a01_i_oms_container, DummyColInfo, false, false, 0)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a34IsUnicodeLivecacheUser(VAR acv : tak_all_command_glob) : boolean;
 
BEGIN
a34IsUnicodeLivecacheUser := acv.a_defaultcode = csp_unicode;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34call_semantic (VAR acv : tak_all_command_glob);
 
VAR
      dummy_e    : tgg00_BasisError;
      start_node : integer;
 
BEGIN
a07_b_put_error (acv, e_not_implemented, 1);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak34commit_rollback (VAR acv : tak_all_command_glob;
            m_type       : tgg00_MessType;
            VAR keeplock : tsp00_MoveObj;
            keep_len     : tsp00_Int4;
            VAR e        : tsp00_Int2);
 
VAR
      b_err   : tgg00_BasisError;
      oidcnt  : tsp00_Int4;
      lx      : tsp00_Int4;
      keypos  : tsp00_Int4;
      mblock  : tgg00_MessBlock;
      qual    : tgg00_QualBuf;
      data    : tgg00_Rec;
 
BEGIN
IF  keep_len = 0
THEN
    BEGIN
    a52_ex_commit_rollback (acv, m_type, NOT c_release, NOT c_release);
    e := acv.a_returncode
    END
ELSE
    BEGIN
    oidcnt := keep_len DIV sizeof (tgg00_OidSpace);
    keypos := 1;
    b_err  := e_ok;
    g01mblock_init   (acv.a_transinf.tri_trans,
          m_type, mm_keep_lock, mblock);
    g01qual_init     (mblock, @qual, sizeof (qual));
    g01datapart_init (mblock, @data, sizeof (data));
    mblock.mb_data_len := cgg_rec_key_offset;
    mblock.mb_qual_len := MB_PART1_LOCKHEAD_MXGG04;
    mblock.mb_struct   := mbs_lock;
    IF  oidcnt > MAX_QUALBUF_LOCKS_GG00
    THEN
        e :=  e_too_many_mb_data
    ELSE
        BEGIN
        mblock.mb_qual^.mlock_cnt := oidcnt;
        FOR lx := 1 TO oidcnt DO
            BEGIN
            WITH mblock.mb_qual^.mlock[lx] DO
                BEGIN
                kb560GetSys2CatalogTabId (lockTabId_gg00);
                lockKeyLen_gg00     := sizeof (tgg00_OidSpace);
                lockMode_gg00       := lckRowExcl_egg00;
                lockState_gg00      := [  ];
                lockKeyPos_gg00     := keypos;
                keypos              := keypos + lockKeyLen_gg00;
                mblock.mb_qual_len  := mblock.mb_qual_len + LOCK_MXGG04;
                mblock.mb_data_len  := mblock.mb_data_len + lockKeyLen_gg00
                END;
            (*ENDWITH*) 
            END;
        (*ENDFOR*) 
        SAPDB_PascalMove ('VAK34 ',   1,    
              keep_len, sizeof (data), @keeplock, 1,
              @mblock.mb_data^.mbp_buf, cgg_rec_key_offset + 1, keep_len, b_err);
        END;
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        a06lsend_mess_buf (acv, mblock, false, b_err);
    (*ENDIF*) 
    e :=  b_err
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34OpMsg (
            isError    : boolean;
            VAR Buf    : tsp00_MoveObj;
            BufLen     : tsp00_Int4);
 
VAR
      ln_len      : integer;
      msg_type    : tsp3_msg_type;
      ix          : tsp00_Int4;
      jx          : tsp00_Int4;
      pc40        : ^tsp00_C40;
      c40         : tsp00_C40;
 
BEGIN
ix := 1;
WHILE BufLen > 0 DO
    BEGIN
    pc40  := @Buf[ix];
    IF  BufLen > sizeof (tsp00_C40)
    THEN
        ln_len := sizeof(tsp00_C40)
    ELSE
        BEGIN
        ln_len := BufLen;
        FOR jx := 1 TO ln_len DO
            c40[jx] := pc40^[jx];
        (*ENDFOR*) 
        FOR jx := ln_len + 1 TO sizeof(c40) DO
            c40[jx] := ' ';
        (*ENDFOR*) 
        pc40 := @c40;
        END;
    (*ENDIF*) 
    IF  isError
    THEN
        msg_type := sp3m_error
    ELSE
        msg_type := sp3m_info;
    (*ENDIF*) 
    g01optextmsg (sp3p_console, msg_type,  csp3_ak_msg, csp3_n_obj, pc40^);
    BufLen := BufLen - ln_len;
    ix     := ix     + ln_len;
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34Receive (VAR acv : tak_all_command_glob;
            VAR out_packet_ptr : tsp1_packet_ptr);
 
BEGIN
out_packet_ptr := NIL;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34Request (VAR acv : tak_all_command_glob;
            sql_packet_ptr : tsp1_packet_ptr);
 
VAR
      variableInputParameters : boolean;
      asciiInAndOutput        : boolean;
 
BEGIN
variableInputParameters   := acv.a_variable_input;
acv.a_variable_input      := false;
asciiInAndOutput          := acv.a_ascii_in_and_output;
acv.a_ascii_in_and_output := false;
ak341NilConsistentTrans(acv.a_transinf.tri_trans);   (* PTS 1121056 *)
a93request (@acv, sql_packet_ptr);
acv.a_returncode          := 0; (* PTS 1139477 *)
acv.a_variable_input      := variableInputParameters;
acv.a_ascii_in_and_output := asciiInAndOutput;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34Restart (VAR acv : tak_all_command_glob);
 
BEGIN
ak341VarObjGuid (ak34VarObjGuid); (* PTS 1102769 T.A. 1999-06-15 *)
ak34BuildSequenceIds;
ak341LoadLibOms(acv);
END;
 
(*------------------------------*) 
 
FUNCTION
      a34ReturnCode (b_err : tgg00_BasisError) : tsp00_Int2;
 
BEGIN
a34ReturnCode := a071_return_code (b_err, sqlm_internal)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34Rollback (VAR acv : tak_all_command_glob;
            VAR keeplock : tsp00_MoveObj;
            keep_len     : tsp00_Int4;
            VAR e        : tsp00_Int2);
 
VAR
      no_of_com_objects : tsp00_Int4;
 
BEGIN
no_of_com_objects       := acv.a_no_of_com_objects;
acv.a_no_of_com_objects := 0; (* no callback to com object *)
ak34commit_rollback (acv, m_rollback, keeplock, keep_len, e);
acv.a_no_of_com_objects := no_of_com_objects
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34Sequence (VAR acv : tak_all_command_glob;
            VAR seqname  : tsp00_KnlIdentifier;
            VAR seqid    : tgg00_Surrogate;
            VAR seqInfo  : tgg00_SeqInfo;
            VAR e        : tsp00_Int2);
 
VAR
      ix           : integer;
      jx           : integer;
      m_type       : tgg00_MessType;
      oldContext   : tgg00_UnivTrans;
 
BEGIN
acv.a_returncode    := 0;
acv.a_transinf.tri_trans.trError_gg00 := e_ok;
a51_internal_trans (acv, oldContext);
IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
THEN
    BEGIN
    IF  g01unicode
    THEN
        BEGIN
        jx := sizeof(seqname);
        FOR ix := sizeof(seqname) DIV 2 DOWNTO 1 DO
            BEGIN
            seqname[jx]   := seqname[ix];
            seqname[jx-1] := chr(0);
            jx := jx - 2;
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    a23AttachPublicSequence (acv, seqname, seqid, seqInfo);
    e := acv.a_returncode;
    IF  e = e_ok
    THEN
        m_type := m_commit
    ELSE
        m_type := m_rollback;
    (*ENDIF*) 
    acv.a_transinf.tri_trans.trError_gg00 := e;
    a51close_internal_trans (acv, oldContext, m_type);
    IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
    (*ENDIF*) 
    END
ELSE
    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
(*ENDIF*) 
e := acv.a_returncode
END;
 
(* PTS 1108151 F.F. 31-OCT-2000 enable UCS2 *)
(*------------------------------*) 
 
PROCEDURE
      a34SetError (VAR acv : tak_all_command_glob;
            error          : tsp00_Int2;
            VAR errtext    : tsp00_MoveObj;
            errtextlen     : integer;
            codetype       : tsp00_CodeType);
 
VAR
      ix                : integer;
      e                 : tsp8_uni_error;
      err_char_no       : tsp00_Int4;
      filluchar         : tsp00_C2;
      dest_len          : tsp00_Int4;
 
BEGIN
(* PTS 1102574, T.A. 1999-05-05 *)
acv.a_dca.stop_msg_set   := true;
acv.a_dca.msgno          := error;
IF  errtextlen > sizeof (acv.a_dca.stop_msg)
THEN
    errtextlen := sizeof (acv.a_dca.stop_msg);
(*ENDIF*) 
dest_len := sizeof (acv.a_dca.stop_msg);
s80uni_trans (@errtext, errtextlen,
      codetype, @acv.a_dca.stop_msg[ 1 ], dest_len,
      acv.a_out_packet^.sp1_header.sp1h_mess_code, [ ],
      e, err_char_no);
IF  e <> uni_ok
THEN
    BEGIN
    IF  acv.a_out_packet^.sp1_header.sp1h_mess_code = csp_ascii
    THEN
        errtextlen := err_char_no
    ELSE
        errtextlen := err_char_no * 2;
    (*ENDIF*) 
    END
ELSE
    errtextlen := dest_len;
(*ENDIF*) 
IF  errtextlen < sizeof(acv.a_dca.stop_msg)
THEN
    BEGIN
    IF  acv.a_out_packet^.sp1_header.sp1h_mess_code = csp_ascii
    THEN
        FOR ix := errtextlen + 1 TO sizeof (acv.a_dca.stop_msg) DO
            acv.a_dca.stop_msg[ix] := bsp_c1
        (*ENDFOR*) 
    ELSE
        BEGIN
        IF  acv.a_out_packet^.sp1_header.sp1h_mess_code = csp_unicode_swap
        THEN
            BEGIN
            filluchar[ 1 ] := csp_ascii_blank;
            filluchar[ 2 ] := csp_unicode_mark;
            END
        ELSE
            BEGIN
            filluchar[ 2 ] := csp_unicode_mark;
            filluchar[ 1 ] := csp_ascii_blank;
            END;
        (*ENDIF*) 
        SAPDB_PascalForcedUnicodeFill ( sizeof (acv.a_dca.stop_msg),
              @acv.a_dca.stop_msg[ 1 ],
              errtextlen + 1,
              sizeof (acv.a_dca.stop_msg) - errtextlen,
              filluchar );
        END;
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34SubtransStart (VAR acv : tak_all_command_glob;
            VAR e    : tsp00_Int2);
 
BEGIN
acv.a_returncode := 0;
acv.a_ex_kind                      := only_executing;
acv.a_in_internal_subtr            := false;
a52new_subtrans (acv, a01_il_b_identifier);
e := acv.a_returncode;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34SubtransCommit (VAR acv : tak_all_command_glob;
            VAR e : tsp00_Int2);
 
BEGIN
acv.a_returncode := 0;
acv.a_ex_kind                      := only_executing;
acv.a_in_internal_subtr            := false;
a52end_rollback_subtrans (acv, a01_il_b_identifier, m_end);
e := acv.a_returncode;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34SubtransRollback (VAR acv : tak_all_command_glob;
            VAR e : tsp00_Int2);
 
BEGIN
acv.a_returncode := 0;
acv.a_ex_kind                      := only_executing;
acv.a_in_internal_subtr            := false;
a52end_rollback_subtrans (acv, a01_il_b_identifier, m_rollback);
e := acv.a_returncode;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34VTrace (VAR acv : tak_all_command_glob;
            VAR trace_obj : tsp00_MoveObj;
            trace_len     : tsp00_Int4);
 
BEGIN
IF  trace_len <= sizeof (tsp00_Line)
THEN
    b120InsertTrace (acv.a_transinf.tri_trans,
          ta, td_none, trace_len, @trace_obj)
ELSE
    b120MoveObjectTrace (acv.a_transinf.tri_trans,
          ta, td_none, trace_len, @trace_obj)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak34BuildSequenceIds;
 
VAR
      ix : integer;
 
BEGIN
FOR ix := 1 TO sizeof(ak34OmsSchemaSeqId) DO
    ak34OmsSchemaSeqId[ix] := chr(255);
(*ENDFOR*) 
ak34OmsContainerSeqId := ak34OmsSchemaSeqId;
ak34OmsContainerSeqId[sizeof(ak34OmsContainerSeqId)] := chr(254)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak34store_msgtext(VAR acv : tak_all_command_glob;
            e : tsp00_Int2);
 
VAR
      ix          : integer;
      max         : tsp00_Int4;
      errtext_ptr : tsp1_part_ptr;
 
BEGIN
acv.a_dca.msgno := e;
FOR ix := 1 TO sizeof (acv.a_dca.stop_msg) DO
    acv.a_dca.stop_msg[ix] := bsp_c1;
(*ENDFOR*) 
s26find_part (acv.a_in_packet^.sp1_segm, sp1pk_errortext, errtext_ptr);
IF  errtext_ptr <> NIL
THEN
    BEGIN
    a34OpMsg (c_is_error, errtext_ptr^.sp1p_buf, errtext_ptr^.sp1p_buf_len);
    IF  errtext_ptr^.sp1p_buf_len > sizeof (acv.a_dca.stop_msg)
    THEN
        max := sizeof (acv.a_dca.stop_msg)
    ELSE
        max := errtext_ptr^.sp1p_buf_len;
    (*ENDIF*) 
    FOR ix := 1 TO max DO
        acv.a_dca.stop_msg[ix] := errtext_ptr^.sp1p_buf[ix];
    (*ENDFOR*) 
    acv.a_dca.stop_msg_set := max > 0
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34outstanding_packet (VAR acv : tak_all_command_glob;
            VAR e : tsp00_Int2);
 
VAR
      updateOutPacket   : boolean;
      retcode           : tsp1_comm_error;
      rcv_packet_len    : tsp00_Int4;
      reply_packet_size : tsp00_Int4;
      errtext_ptr       : tsp1_part_ptr;
 
BEGIN
IF  acv.a_outstanding_packet
THEN
    BEGIN
    updateOutPacket := acv.a_out_packet = acv.a_client_out_packet;
    vreceive (acv.a_transinf.tri_trans.trTaskId_gg00, g01oms_stream_timeout,
          acv.a_in_packet, rcv_packet_len,
          acv.a_client_out_packet, reply_packet_size, retcode);
    acv.a_outstanding_packet := false;
    IF  retcode <> sp1ce_ok
    THEN
        ak34vreceive_error (acv, retcode, e)
    ELSE
        BEGIN
        IF  updateOutPacket
        THEN
            acv.a_out_packet := acv.a_client_out_packet;
        (*ENDIF*) 
        IF  acv.a_cmd_packet_header.sp1h_mess_swap <> g01code.kernel_swap
        THEN (* Change request 1001193, T.A. 23.10.1998 *)
            a93swap_from_application (acv);
        (*ENDIF*) 
        IF  g01vtrace.vtrAny_gg00
        THEN
            a93packet_vtrace (acv.a_transinf.tri_trans,
                  ak_receive, acv.a_in_packet);
        (*ENDIF*) 
        s26find_part (acv.a_in_packet^.sp1_segm, sp1pk_errortext, errtext_ptr);
        IF  errtext_ptr <> NIL
        THEN
            BEGIN
            e :=  e_oms_ostream_error;
            ak34store_msgtext (acv, e)
            END;
        (*ENDIF*) 
        WITH acv.a_client_out_packet^ DO
            BEGIN
            sp1_header := acv.a_cmd_packet_header;
            sp1_header.sp1h_varpart_size := reply_packet_size -
                  sizeof (sp1_header);
            (* the following statement can be dropped when the rte *tsp00_Int4)
                  (* guarantees a properly aligned packet size !!! J.P.  *)
            sp1_header.sp1h_varpart_size := (sp1_header.sp1h_varpart_size DIV
                  csp1_part_align_length) * csp1_part_align_length;
            END;
        (*ENDWITH*) 
        s26first_segment_init (acv.a_client_out_packet, sp1sk_return, acv.a_return_segm);
        acv.a_curr_retpart := NIL
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a34NewSchemaId (VAR acv : tak_all_command_glob) : tsp00_Int4;
 
VAR
      schemaId : tsp00_Int4;
 
BEGIN
ak34BuildId (acv, ak34OmsSchemaSeqId, schemaId);
a34NewSchemaId := schemaId;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34Lock (VAR acv     : tak_all_command_glob;
            pKey           : tsp00_MoveObjPtr;
            KeyLen         : integer;
            lockExclusive  : boolean;
            VAR e          : tgg00_BasisError);
 
VAR
      k            : tgg00_Lkey;
      WantedMode   : tgg00_LockReqMode;
      DummyGranted : tgg00_LockReqMode;
      sys_cat      : tgg00_Surrogate;
 
BEGIN
acv.a_transinf.tri_trans.trError_gg00 := e_ok;
k.len := KeyLen;
SAPDB_PascalMove ('VAK34 ',   2,    
      KeyLen, sizeof(k.k), @pKey^, 1, @k.k, 1, KeyLen, e);
IF  lockExclusive
THEN
    WantedMode := lckRowExcl_egg00
ELSE
    WantedMode := lckRowShare_egg00;
(*ENDIF*) 
kb560GetSys2CatalogTabId (sys_cat);
k53lock (acv.a_transinf.tri_trans, sys_cat, k, WantedMode, [ ],
      NOT NoWait_c, NOT CollisionTest_c, DummyGranted);
IF  acv.a_transinf.tri_trans.trError_gg00 = e_wait_for_lock_release
THEN
    k53wait (acv.a_transinf.tri_trans, m_lock, mm_nil);
(*ENDIF*) 
e := acv.a_transinf.tri_trans.trError_gg00
END;
 
(*------------------------------*) 
 
PROCEDURE
      a34UnLock (VAR acv  : tak_all_command_glob;
            pKey           : tsp00_MoveObjPtr;
            KeyLen         : integer;
            lockExclusive  : boolean;
            VAR e          : tgg00_BasisError);
 
VAR
      WantedMode : tgg00_LockReqMode;
      Syskey     : tgg00_SysInfoKey;
      sys_cat    : tgg00_Surrogate;
 
BEGIN
acv.a_transinf.tri_trans.trError_gg00 := e_ok;
IF  lockExclusive
THEN
    WantedMode := lckRowExcl_egg00
ELSE
    WantedMode := lckRowShare_egg00;
(*ENDIF*) 
Syskey.skeylen  := KeyLen;
SAPDB_PascalMove ('VAK34 ',   3,    
      KeyLen, sizeof(Syskey.all), @pKey^, 1, @Syskey.all, 1, KeyLen, e);
kb560GetSys2CatalogTabId (sys_cat);
k53key_unlock (acv.a_transinf.tri_trans, WantedMode,
      sys_cat, Syskey);
e := acv.a_transinf.tri_trans.trError_gg00
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
