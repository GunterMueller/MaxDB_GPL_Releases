.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-16
*****************************************************
modname : VAK56
changed : 2000-11-16
module  : AK_Insert
 
Author  : ElkeZ
Created : 1987-09-22
*****************************************************
 
Purpose : Processing of normal INSERT and INSERT...SELECT
 
Define  :
 
        PROCEDURE
              a56_ainsert_statement (
                    VAR acv      : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a56_insert_statement (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a56_aenumerated_values (
                    VAR acv        : tak_all_command_glob;
                    select_allowed : boolean;
                    VAR put_node   : tsp00_Int2;
                    VAR last_node  : tsp00_Int2);
 
        PROCEDURE
              a56alloc_linkpos_info (
                    VAR acv        : tak_all_command_glob;
                    VAR p_arr      : tak_syspointerarr;
                    mess_type      : tgg00_MessType;
                    VAR linkposbuf : tak_sysbufferaddress);
 
        PROCEDURE
              a56one_default_value (
                    VAR acv     : tak_all_command_glob;
                    VAR dmli    : tak_dml_info;
                    VAR colinfo : tak00_columninfo;
                    with_length : tak_fp_kind_type);
 
        PROCEDURE
              a56insert_upd_with_link (
                    VAR acv        : tak_all_command_glob;
                    VAR linkposbuf  : tak_sysbufferaddress);
 
        FUNCTION
              a56IsClusterKey (
                    VAR acv     : tak_all_command_glob;
                    VAR dmli    : tak_dml_info;
                    VAR colInfo : tak00_columninfo) : boolean;
 
        PROCEDURE
              a56put_link_info (
                    VAR acv            : tak_all_command_glob;
                    base_ptr           : tak_sysbufferaddress;
                    not_used_links     : tak_charset;
                    viewqualbuf        : tak_sysbufferaddress;
                    VAR linkposbuf     : tak_sysbufferaddress);
 
        PROCEDURE
              a56temp_table_key (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a56_enumerated_values (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    VAR dfa    : tak_dfarr;
                    VAR curr_n : integer);
 
        PROCEDURE
              a56_normal_insert (
                    VAR acv            : tak_all_command_glob;
                    VAR dmli           : tak_dml_info;
                    VAR dfa            : tak_dfarr;
                    join_view_insert   : boolean;
                    VAR not_used_links : tak_charset);
 
        PROCEDURE
              a56_datatype (
                    in_datatype      : tsp00_DataType;
                    VAR out_datatype : tsp00_DataType);
 
        PROCEDURE
              a56_describe (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    fp             : tak_fp_kind_type;
                    VAR movebefore : tsp00_Int2;
                    reccolno       : integer);
 
        PROCEDURE
              a56_get_baserecords (
                    VAR acv   : tak_all_command_glob;
                    VAR sparr : tak_syspointerarr;
                    VAR tab   : tak_one_table);
 
        PROCEDURE
              a56_serial_default (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR dfa  : tak_dfarr);
 
        PROCEDURE
              a56alloc_longlit_rec (
                    VAR acv           : tak_all_command_glob;
                    VAR dmli          : tak_dml_info;
                    VAR dfa           : tak_dfarr);
 
        PROCEDURE
              a56get_longlit (
                    VAR acv           : tak_all_command_glob;
                    VAR dmli          : tak_dml_info;
                    datatyp           : tsp00_DataType;
                    dml_node          : tsp00_Int2);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01fullset         : tak_columnset;
              a01kw              : tak_keywordtab;
              a01defaultkey      : tgg00_SysInfoKey;
              a01_il_b_identifier: tsp00_KnlIdentifier;
              a01_i_tablekey     : tsp00_KnlIdentifier;
              a01_i_temp         : tsp00_KnlIdentifier;
              a01char_size       : integer;
 
        PROCEDURE
              a01_next_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_call_put (
                    VAR acv    : tak_all_command_glob;
                    proc       : tak_procs;
                    subproc    : tsp00_Int2;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_force_symbol (
                    VAR acv         : tak_all_command_glob;
                    expected_symbol : tak_sc_symbol;
                    VAR node1       : tsp00_Int2;
                    VAR node2       : tsp00_Int2);
 
        PROCEDURE
              a01_is_end_symbol (VAR acv : tak_all_command_glob);
 
        FUNCTION
              a01_eqkey (
                    VAR a      : tak_keyword;
                    sqlmode    : tsp00_SqlMode;
                    VAR b      : tsp00_MoveObj;
                    VAR scv    : tak_scanner_glob) : boolean;
 
        FUNCTION
              a01mandatory_keyword (
                    VAR acv          : tak_all_command_glob;
                    required_keyword : integer) : boolean;
 
        FUNCTION
              a01is_whitespace_char (
                    VAR m    : tsp00_MoveObj;
                    pos      : tsp00_Int4) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_syntax_tools : VAK02;
 
        PROCEDURE
              a02_s_atable_spec (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a02_n_acolumnname (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a02_l_acolumn_list (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_syntax_values_tools : VAK03;
 
        PROCEDURE
              a03_l_avalue_list (
                    VAR acv         : tak_all_command_glob;
                    null_allowed    : boolean;
                    stamp_allowed   : boolean;
                    default_allowed : boolean;
                    sysuser_allowed : boolean;
                    VAR put_node    : tsp00_Int2;
                    VAR last_node   : tsp00_Int2);
 
        PROCEDURE
              a03_avalue_spec (
                    VAR acv         : tak_all_command_glob;
                    null_allowed    : boolean;
                    stamp_allowed   : boolean;
                    default_allowed : boolean;
                    sysuser_allowed : boolean;
                    VAR put_node    : tsp00_Int2;
                    VAR last_node   : tsp00_Int2);
 
        PROCEDURE
              a03_ln_aexpression_list (
                    VAR acv         : tak_all_command_glob;
                    VAR put_node    : tsp00_Int2;
                    VAR last_node   : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05_stamp_get (
                    VAR acv    : tak_all_command_glob;
                    VAR dest   : tsp00_MoveObj;
                    destpos    : integer;
                    mv_dest    : integer);
 
        PROCEDURE
              a05_transaction_get (
                    VAR acv    : tak_all_command_glob;
                    VAR dest   : tsp00_MoveObj;
                    destpos    : integer;
                    mv_dest    : integer);
 
        PROCEDURE
              a05constraint_fulfilled (
                    VAR acv       : tak_all_command_glob;
                    VAR valbuf    : tgg00_Rec;
                    VAR tree      : tgg00_FileId;
                    constraint_id : integer);
 
        PROCEDURE
              a05identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
        PROCEDURE
              a05qualification_test (
                    VAR acv        : tak_all_command_glob;
                    VAR m          : tgg00_MessBlock;
                    result_wanted  : boolean;
                    check_new_rec  : boolean;
                    error_pos      : integer;
                    VAR rec        : tgg00_Rec;
                    VAR result_buf : tsp00_Buf;
                    resultBufSize  : tsp00_Int4;
                    VAR result_len : integer);
 
        PROCEDURE
              a05long_literal_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    datatyp     : tsp00_DataType;
                    VAR moveobj : tsp00_MoveObj;
                    obj_pos     : integer;
                    VAR obj_len : integer);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        FUNCTION
              a06_table_exist (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR authname : tsp00_KnlIdentifier;
                    VAR tablen   : tsp00_KnlIdentifier;
                    VAR sparr    : tak_syspointerarr;
                    get_all      : boolean) : boolean;
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06a_mblock_init (
                    VAR acv      : tak_all_command_glob;
                    mtype        : tgg00_MessType;
                    m2type       : tgg00_MessType2;
                    VAR tree     : tgg00_FileId);
 
        PROCEDURE
              a06extcolno (
                    VAR baserec     : tak_baserecord;
                    extcolno        : integer;
                    VAR colinfo_ptr : tak00_colinfo_ptr);
 
        PROCEDURE
              a06_systable_get (
                    VAR acv     : tak_all_command_glob;
                    dstate      : tak_directory_state;
                    VAR tableid : tgg00_Surrogate;
                    VAR base_ptr: tak_sysbufferaddress;
                    get_all     : boolean;
                    VAR ok      : boolean);
 
        FUNCTION
              a06uid (VAR user_id : tgg00_Surrogate) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        FUNCTION
              a061exist_columnname (
                    VAR base_rec    : tak_baserecord;
                    VAR column      : tsp00_KnlIdentifier;
                    VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
        FUNCTION
              a061exist_columnindex (VAR base_rec : tak_baserecord;
                    extcolno        : integer;
                    VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
        PROCEDURE
              a061get_colname (
                    VAR col_info : tak00_columninfo;
                    VAR colname  : tsp00_KnlIdentifier);
&       ifdef trace
 
        PROCEDURE
              a061td_colinfo (
                    VAR colinfo : tak00_columninfo;
                    index : integer);
&       endif
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
        PROCEDURE
              a07_error (
                    VAR acv   : tak_all_command_glob;
                    errorcode : tgg00_BasisError;
                    VAR nod1  : tsp00_Int2;
                    VAR nod2  : tsp00_Int2);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
        PROCEDURE
              a07_uni_error (
                    VAR acv  : tak_all_command_glob;
                    uni_err  : tsp8_uni_error;
                    err_code : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_rel_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10key_del  (
                    VAR acv        : tak_all_command_glob;
                    VAR syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10new (
                    VAR acv  : tak_all_command_glob;
                    obj_size : tsp00_Int4;
                    VAR p    : tak_sysbufferaddress);
 
        PROCEDURE
              a10dispose (
                    VAR acv  : tak_all_command_glob;
                    VAR p    : tak_sysbufferaddress);
 
        PROCEDURE
              a10add_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              SQLManager : vak101;
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
        FUNCTION
              a101_GetExtendedTempFileType(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tgg00_TfnTemp;
 
        FUNCTION
              a101_GetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate (* ptocConst *);
                    VAR schemaName : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_Data_Type_Options : VAK14;
 
        FUNCTION
              a14LengthOfDefaultValue (
                    VAR DefaultRec : tak_defaultrecord) : integer; (* PTS 1108428 *)
 
      ------------------------------ 
 
        FROM
              AK_Link : VAK25;
 
        PROCEDURE
              a25get_linkname (
                    VAR acv        : tak_all_command_glob;
                    linkbuf        : tak_sysbufferaddress;
                    index          : integer;
                    VAR link_name  : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_Trigger : VAK262;
 
        PROCEDURE
              a262add_trigger_info (
                    VAR acv           : tak_all_command_glob;
                    VAR dmli          : tak_dml_info;
                    ignoreUserTrigger : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51_internal_trans (VAR acv : tak_all_command_glob;
                    VAR old_trans : tgg00_UnivTrans);
 
        PROCEDURE
              a51close_internal_trans (VAR acv : tak_all_command_glob;
                    VAR old_trans : tgg00_UnivTrans;
                    m_type        : tgg00_MessType);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK54;
 
        PROCEDURE
              a54_dml_init (
                    VAR acv   : tak_all_command_glob;
                    VAR dmli  : tak_dml_info;
                    in_union  : boolean);
 
        PROCEDURE
              a54_dml_finalize (
                    VAR dmli         : tak_dml_info;
                    VAR TransContext : tgg00_TransContext);
 
        PROCEDURE
              a54_last_part (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    last_pars_part : boolean);
 
        PROCEDURE
              a54_put_indices_in_mess_buf (
                    VAR acv     : tak_all_command_glob;
                    VAR basebuf : tak_baserecord;
                    VAR dfa     : tak_dfarr;
                    all_indices : boolean);
 
        PROCEDURE
              a54_get_pparsp_pinfop (
                    VAR acv   : tak_all_command_glob;
                    VAR sparr : tak_syspointerarr;
                    mtype     : tgg00_MessType);
 
        PROCEDURE
              a54_view_put_into (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a54_fixedpos (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542char_to_packet (
                    VAR acv : tak_all_command_glob;
                    c : char);
 
        PROCEDURE
              a542identifier_to_packet (
                    VAR acv        : tak_all_command_glob;
                    VAR identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              a542move_to_packet (
                    VAR acv    : tak_all_command_glob;
                    const_addr : tsp00_MoveObjPtr;
                    const_len  : tsp00_Int4);
 
        PROCEDURE
              a542internal_packet (
                    VAR acv                 : tak_all_command_glob;
                    release_internal_packet : boolean;
                    required_len            : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              DML_Parts : VAK55;
 
        PROCEDURE
              a55_named_values (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR dfa  : tak_dfarr;
                    curr_n   : integer);
 
        PROCEDURE
              a55_found_one_value (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR dfa  : tak_dfarr);
 
        PROCEDURE
              a55_nullvalue (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR dfa  : tak_dfarr);
 
        PROCEDURE
              a55_describe_value (
                    VAR acv       : tak_all_command_glob;
                    VAR dmli      : tak_dml_info;
                    VAR colinfo   : tak00_columninfo;
                    nodeno        : integer;
                    res_buf_index : integer;
                    in_datapart   : boolean);
 
        PROCEDURE
              a55realloc_parsinfo (
                    VAR acv          : tak_all_command_glob;
                    VAR parsinfo_ptr : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              AK_Delete : vak58;
 
        PROCEDURE
              a58update_with_link (
                    VAR acv     : tak_all_command_glob;
                    VAR tabid   : tgg00_Surrogate;
                    parsno      : integer;
                    check_cnt   : integer);
 
        PROCEDURE
              a58exec_link_caused_dml (
                    VAR acv      : tak_all_command_glob;
                    mblock_ptr   : tak_sysbufferaddress;
                    file_id      : tsp00_Int2;
                    VAR cascade  : boolean;
                    self_ref     : boolean);
 
        PROCEDURE
              a58link_fn_to_messbuf (
                    VAR acv : tak_all_command_glob;
                    file_id : integer);
 
        PROCEDURE
              a58mess_buf_to_linkparsinfo (
                    VAR acv             : tak_all_command_glob;
                    parse_id            : integer;
                    VAR owner           : tsp00_KnlIdentifier;
                    VAR tablen          : tsp00_KnlIdentifier;
                    VAR constraint_name : tsp00_KnlIdentifier;
                    VAR mblock_ptr      : tak_sysbufferaddress);
 
        PROCEDURE
              a58destroy_linkfile (
                    VAR acv : tak_all_command_glob;
                    file_id : integer);
 
        PROCEDURE
              a58describe_long_columns (
                    VAR acv     : tak_all_command_glob;
                    VAR d_sparr : tak_syspointerarr);
 
      ------------------------------ 
 
        FROM
              DML-Join-View-Procedures : VAK59;
 
        PROCEDURE
              a59_join_view (
                    VAR acv     : tak_all_command_glob;
                    VAR dmli    : tak_dml_info;
                    VAR viewdfa : tak_dfarr;
                    start_node  : integer;
                    mtype       : tgg00_MessType);
 
      ------------------------------ 
 
        FROM
              Executing_finish : VAK507;
 
        PROCEDURE
              a507_literal (
                    VAR acv             : tak_all_command_glob;
                    VAR longliteralrec  : tak_longliteral_rec;
                    useliteralbuf       : boolean);
 
      ------------------------------ 
 
        FROM
              Select_Syntax : VAK60;
 
        PROCEDURE
              a60_aquery_spec (
                    VAR acv       : tak_all_command_glob;
                    stamp_allowed : boolean;
                    from_select   : boolean;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2;
                    last_n        : tsp00_Int2;
                    fromselnode_built : boolean);
 
        PROCEDURE
              a60rescount (
                    VAR acv  : tak_all_command_glob;
                    rescount : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Execute_Select_Expression : VAK660;
 
        PROCEDURE
              a660_search_one_table (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    table_node     : integer;
                    all            : boolean;
                    check_teresult : boolean;
                    lock_spec      : tak_lockenum;
                    wanted_priv    : tak00_PrivR);
 
        PROCEDURE
              a660_new_pparsp (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    first_parsinfo : boolean;
                    complicate     : boolean);
 
      ------------------------------ 
 
        FROM
              Resultname_handling : VAK663;
 
        PROCEDURE
              a663restable_get (
                    VAR acv    : tak_all_command_glob;
                    dstate     : tak_directory_state;
                    VAR tablen : tsp00_KnlIdentifier;
                    VAR sparr  : tak_syspointerarr;
                    VAR ok     : boolean);
 
      ------------------------------ 
 
        FROM
              Hint_Handling : VAK80;
 
        PROCEDURE
              a80_ahint_statement (
                    VAR acv : tak_all_command_glob;
                    subproc : tsp00_Int2;
                    putnode : tsp00_Int2);
 
        PROCEDURE
              a80store_cmd_hint_info(
                    VAR acv     : tak_all_command_glob;
                    VAR dmli    : tak_dml_info;
                    select_node : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code           : tgg04_CodeGlobals;
              g01unicode        : boolean;
              g01glob           : tgg00_KernelGlobals;
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04index_tree_build (
                    VAR file_id    : tgg00_FileId (*ptocConst*);
                    VAR index_tree : tgg00_FileId;
                    index_no       : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalUnicodeFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedUnicodeFill (
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2 );
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedOverlappingMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30lnr_defbyte (
                    str       : tsp00_MoveObjPtr;
                    defbyte   : char;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30unilnr (
                    str       : tsp00_MoveObjPtr;
                    skip_val  : tsp00_C2;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
        PROCEDURE
              s30surrogate_incr (VAR surrogate : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              PUT-Conversions : VSP41;
 
        PROCEDURE
              s41plint (
                    VAR buf : tsp00_MoveObj;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
        PROCEDURE
              s41plrel (VAR buf : tsp00_MoveObj;
                    pos         : tsp00_Int4;
                    len         : integer;
                    frac        : integer;
                    source      : tsp00_Longreal;
                    VAR res     : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80: VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vtimestamp (VAR ts : tsp00_Timestamp);
 
        PROCEDURE
              vUTCtimestamp (VAR timestamp : tsp00_Timestamp);
 
        FUNCTION
              vTimeZoneDelta : tsp00_Longreal; (* PTS 1109925 *)
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR m         : tgg00_MessBlock);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01p2int4 (
                    debug : tgg00_Debug;
                    nam_1 : tsp00_Sname;
                    int_1 : tsp00_Int4;
                    nam_2 : tsp00_Sname;
                    int_2 : tsp00_Int4);
 
        PROCEDURE
              t01moveobj (
                    layer    : tgg00_Debug;
                    VAR buf  : tsp00_MoveObj;
                    startpos : tsp00_Int4;
                    endpos   : tsp00_Int4);
&       ENDIF
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              s30surrogate_incr;
 
              tsp00_C8 tgg00_Surrogate
 
.CM *-END-* synonym -------------------------------------
***********************************************************
 
Description:
 
.nf
n_proc = a56
n_pos  =  1  : ainsert_statement
          2  : aenumerated_value
          3  : acolumn_list
          4  : values
          5  : ignore
          6  : update
          7  : reject
          8  : anamed_values
          9  : aset_insert_clause
.fo
 
.CM *-END-* description ---------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      (*  *)
      c_null_allowed    = true (* a03_avalue_spec   *);
      (*                          a03_l_avalue_list *)
      c_stamp_allowed   = true (* a03_avalue_spec   *);
      (*                          a03_l_avalue_list *)
      (*                          a60_aquery_spec   *)
      c_default_allowed = true (* a03_avalue_spec   *);
      (*                          a03_l_avalue_list *)
      c_sysuser_allowed = true (* a03_avalue_spec   *);
      (*                          a03_l_avalue_list *)
      c_all             = true (* a06_systable_get      *);
      (*                          a54_put_indices_in_mess_buf *)
      (*                          a660_search_one_table *)
      c_release_internal_packet= true (* a542internal_packet*);
      c_last_pars_part  = true (* a54_last_part *);
      (*                          a54_sel_store_parsinfo *)
      c_in_union        = true (* a54_dml_init *);
      c_in_datapart     = true (* a55_describe_value *);
      c_select_allowed  = true (* a56_aenumerated_values *);
      c_join_view_insert= true (* a56_normal_insert *);
      c_self_ref        = true (* a58exec_link_caused_dml *);
      c_first_parsinfo  = true (* a660_new_pparsp *);
      c_complicate      = true (* a660_new_pparsp *);
      c_check_teresult  = true (* a660_search_one_table *);
      c_result_wanted   = true (* a05qualification_test *);
      c_check_new_rec   = true (* a05qualification_test *);
 
 
(*------------------------------*) 
 
PROCEDURE
      ak56anamed_values (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      curr_n : tsp00_Int2;
      last_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        a01_call_put (acv, a56, cak_x_named_values, curr_n);
        a01_next_symbol (acv);
        ak56aset_insert_clause (acv,
              a_ap_tree^[ curr_n ].n_lo_level, last_n);
        WHILE sc_symb = s_comma DO
            BEGIN
            a01_next_symbol (acv);
            ak56aset_insert_clause (acv, a_ap_tree^[ last_n ].n_sa_level,
                  last_n)
            END;
        (*ENDWHILE*) 
        put_node := curr_n;
        last_node := curr_n
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak56aset_insert_clause (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      curr_n : tsp00_Int2;
      last_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        a01_call_put (acv, a56, cak_x_set_clause, curr_n);
        put_node := curr_n;
        last_node := curr_n;
        a02_n_acolumnname (acv, a_ap_tree^[ curr_n ].n_lo_level,
              last_n);
        a01_force_symbol (acv, s_equal, put_node, last_node);
        IF  a_returncode = 0
        THEN
            a03_avalue_spec (acv, c_null_allowed, c_stamp_allowed,
                  c_default_allowed, c_sysuser_allowed,
                  a_ap_tree^[ last_n ].n_sa_level, last_n)
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak56build_insert_string (
            VAR acv        : tak_all_command_glob;
            VAR isparr     : tak_syspointerarr;
            VAR linkbuf    : tak_sysbufferaddress;
            VAR literalrec : tak_sysbufferaddress;
            VAR all_done   : boolean;
            VAR with_commit: boolean);
 
VAR
      _act_node : integer;
      _i        : integer;
      _tab_node : integer;
      _dummybuf : tak_sysbufferaddress;
      _dfa      : tak_dfarr;
      _not_used : tak_charset;
      _dmli     : tak_dml_info;
 
BEGIN
_dummybuf := NIL;
a54_dml_init (acv, _dmli, NOT c_in_union);
_dmli.d_acttabindex := 1;
_dmli.d_cntfromtab  := 1;
_act_node := acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
IF  ( acv.a_first_hint_node <> csp_minint2 )
THEN
    BEGIN
    a80store_cmd_hint_info( acv, _dmli, acv.a_ap_tree^[ 0 ].n_lo_level );
    END;
(*ENDIF*) 
WHILE acv.a_ap_tree^[ _act_node ].n_sa_level > 0 DO
    _act_node := acv.a_ap_tree^[ _act_node ].n_sa_level;
(*ENDWHILE*) 
IF  (acv.a_ap_tree^[ _act_node ].n_proc = a52) AND
    (acv.a_ap_tree^[ _act_node ].n_subproc = cak_x_commit)
THEN
    with_commit := true;
(*ENDIF*) 
_act_node := acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
_tab_node := acv.a_ap_tree^[ _act_node ].n_lo_level;
a660_search_one_table (acv, _dmli, _tab_node, c_all,
      c_check_teresult, no_lock, r_ins);
IF  acv.a_returncode = 0
THEN
    IF  _dmli.d_sparr.pbasep^.sbase.btablekind = tview
    THEN
        IF  acv.a_ap_tree^[acv.a_ap_tree^[_act_node].n_sa_level].n_sa_level <> 0
        THEN
            (* ignore/reject/update duplicates *)
            a07_b_put_error (acv, e_not_implemented, 1)
        ELSE
            IF  with_commit
            THEN
                a07_b_put_error (acv, e_invalid_tabletype, 1)
            ELSE
                BEGIN
                all_done := true;
                a59_join_view (acv, _dmli, _dfa,
                      acv.a_ap_tree^[ 0 ].n_lo_level, m_insert)
                END
            (*ENDIF*) 
        (*ENDIF*) 
    ELSE
        BEGIN
        FOR _i := 1 TO _dmli.d_sparr.pbasep^.sbase.bmaxcol DO
            _dfa[ _i ].dml_node := 0;
        (*ENDFOR*) 
        _act_node := acv.a_ap_tree^[ _act_node ].n_sa_level;
        WITH acv.a_ap_tree^[ _act_node ] DO
            IF  ((n_proc = a56) AND (n_subproc = cak_x_enum_values))
            THEN
                a56_enumerated_values (acv, _dmli, _dfa, _act_node)
            ELSE
                a55_named_values (acv, _dmli, _dfa, _act_node);
            (*ENDIF*) 
        (*ENDWITH*) 
        acv.a_input_data_pos := 1;
        _not_used := [  ];
        a56_normal_insert (acv, _dmli, _dfa, NOT c_join_view_insert, _not_used);
        isparr     := _dmli.d_sparr;
        linkbuf    := _dmli.d_linkbuf;
        literalrec := _dmli.d_literalrec;
        END;
    (*ENDIF*) 
(*ENDIF*) 
a54_dml_finalize( _dmli, acv.a_transinf.tri_trans );
END;
 
(* PTS 1116987 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak56check_for_colname (
            VAR acv     : tak_all_command_glob;
            node        : tsp00_Int2);
 
BEGIN
IF  node > 0
THEN
    IF  acv.a_ap_tree^[node].n_symb = s_method_call
    THEN
        BEGIN
        node := acv.a_ap_tree^[node].n_lo_level;
        node := acv.a_ap_tree^[node].n_sa_level
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  node > 0
THEN
    WITH acv.a_ap_tree^[ node ] DO
        (* PTS 1116169 E.Z. *)
        IF  n_proc <> a63query_spec
        THEN
            BEGIN
            IF  (n_proc = no_proc) AND
                (n_symb in [ s_authid, s_tablename, s_columnname, s_columnid ])
            THEN  (* PTS 1128197 D.T. *)
                a07_b_put_error (acv, e_missing_constant, n_pos)
            ELSE
                IF  NOT (
                    (n_proc = no_proc) AND
                    (n_symb in [ s_nextval, s_currval ])
                    )
                    (* authid.sequencename.NEXTVAL must be allowed
                          ------  ------
                          |Symb|__|Symb|
                          |next|  |auth|
                          ------  ------
                          .         |
                          .       ------
                          .       |Symb|
                          .       |sequ|
                          .       ------
                          *)
                THEN
                    BEGIN
                    ak56check_for_colname (acv, n_lo_level);
                    IF  acv.a_returncode = 0
                    THEN
                        ak56check_for_colname (acv, n_sa_level);
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak56col_list_element (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            VAR dfa  : tak_dfarr;
            joinview : boolean;
            col_n    : integer;
            val_n    : integer;
            sub_colno: integer);
 
VAR
      user_name : tsp00_KnlIdentifier;
      column    : tsp00_KnlIdentifier;
      col_ptr   : tak00_colinfo_ptr;
      found     : boolean;
      i_val_n   : integer;
 
BEGIN
WITH acv, dmli DO
    BEGIN
    found := false;
    IF  a_ap_tree^[ col_n ].n_symb = s_columnid
    THEN
        BEGIN
        found := a061exist_columnindex (dmli.d_sparr.pbasep^.sbase,
              dmli.d_columnindex, col_ptr);
        IF  found
        THEN
            a061get_colname (dmli.d_colbuf^, column);
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        a05identifier_get (acv, col_n, sizeof (column), column);
        found := a061exist_columnname (d_sparr.pbasep^.sbase, column, col_ptr);
        END;
    (*ENDIF*) 
    IF  NOT found
    THEN
        a07_nb_put_error (acv, e_unknown_columnname,
              a_ap_tree^[ col_n ].n_pos, column)
    ELSE
        IF  ctinvisible in col_ptr^.ccolpropset
        THEN
            a07_nb_put_error (acv, e_unknown_columnname,
                  a_ap_tree^[ col_n ].n_pos, column)
        ELSE
            IF  col_ptr^.cdatatyp in
                [ dlonga, dlongb, dlonguni,
                dstra, dstrb, dstruni ]
            THEN
                BEGIN
                IF  a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc = a57
                THEN
                    d_longdesc_found := true;
                (*ENDIF*) 
                IF  a_sqlmode = sqlm_ansi (* PTS 1105795 M.Ki. *)
                THEN
                    a07_nb_put_error (acv, e_command_for_string_not_allow,
                          a_ap_tree^[ col_n ].n_pos, column)
                ELSE
                    BEGIN
                    IF  (a_ap_tree^[ val_n ].n_proc = a64) AND
                        (a_ap_tree^[ val_n ].n_subproc = cak_x_value_expression)
                    THEN
                        i_val_n := a_ap_tree^[ val_n ].n_lo_level
                    ELSE
                        i_val_n := val_n;
                    (*ENDIF*) 
                    IF  (
                        (a_ap_tree^[ i_val_n ].n_symb <> s_null)           AND
                        (a_ap_tree^[ i_val_n ].n_symb <> s_parameter_name) AND
                        (a_ap_tree^[ i_val_n ].n_symb <> s_default)        AND
                        (a_ap_tree^[ i_val_n ].n_symb <> s_string_literal) AND
                        (a_ap_tree^[ i_val_n ].n_symb <> s_byte_string)    AND
                        NOT
                        ((a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc = a56) AND
                        ( a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc =
                        cak_x_insert_select)) (* PTS 1105795 M.Ki. *)
                        )
                    THEN
                        a07_nb_put_error (acv, e_incompatible_datatypes,
                              a_ap_tree^[ col_n ].n_pos, column);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        IF  ((a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc = a56) AND
            (column = a01_i_tablekey))
        THEN
            a07_b_put_error (acv, e_col_must_be_no_keycolumn,
                  a_ap_tree^[ col_n ].n_pos)
        ELSE
            BEGIN
            IF  joinview
            THEN
                d_fieldno := col_ptr^.cextcolno
            ELSE
                d_fieldno := col_ptr^.creccolno;
            (*ENDIF*) 
            WITH dfa[ d_fieldno ] DO
                IF  dml_node <> 0
                THEN
                    a07_nb_put_error (acv, e_duplicate_columnname,
                          a_ap_tree^[ col_n ].n_pos, column)
                ELSE
                    BEGIN
                    dml_col_ptr           := col_ptr;
                    dml_node              := val_n;
                    dml_colno_in_subquery := sub_colno;
&                   ifdef TRACE
                    t01int4 (ak_sem, 'dfa[i]     1', d_fieldno);
                    t01int4 (ak_sem, 'DML_INDEX  1', dml_index);
&                   endif
                    d_foundset := d_foundset -
                          [ col_ptr^.cextcolno ]
                    END
                (*ENDIF*) 
            (*ENDWITH*) 
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak56reclen (
            VAR acv        : tak_all_command_glob;
            VAR sparr      : tak_syspointerarr;
            VAR movebefore : tsp00_Int2);
 
BEGIN
WITH sparr.pparsp^.sparsinfo DO
    IF  p_cnt_infos >= p_max_infos
    THEN
        a55realloc_parsinfo (acv, sparr.pparsp);
    (*ENDIF*) 
(*ENDWITH*) 
IF  acv.a_returncode = 0
THEN
    WITH sparr.pparsp^.sparsinfo DO
        BEGIN
        p_cnt_infos := succ (p_cnt_infos);
        WITH  p_pars_infos[ p_cnt_infos ] DO
            BEGIN
            fp_kind          := fp_reclen;
            fp_movebefore_v4 := movebefore;
            movebefore       := 0;
            END;
        (*ENDWITH*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(* PTS 1111668 E.Z. *)
(* PTS 1112546 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a56_serial_default (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            VAR dfa  : tak_dfarr);
 
VAR
      aux_c    : tsp00_C2;
      aux_node : tak_ap_node;
      aux_dfa  : tak_dml_onefield;
 
BEGIN
(* DEFAULT is equivalent to value 0 *)
aux_c[1] := acv.a_cmd_part^.sp1p_buf[1];
aux_c[2] := acv.a_cmd_part^.sp1p_buf[2];
aux_node := acv.a_ap_tree^[acv.a_ap_tree^[ 0 ].n_lo_level];
aux_dfa  := dfa[dmli.d_fieldno];
dfa[dmli.d_fieldno].dml_node      := 1;
dfa[dmli.d_fieldno].dml_col_ptr   := dmli.d_colbuf;
dfa[dmli.d_fieldno].dml_node      := 1;
dfa[dmli.d_fieldno].dml_res_index := 0;
WITH acv.a_ap_tree^[acv.a_ap_tree^[ 0 ].n_lo_level] DO
    BEGIN
    n_symb   := s_fixed_point_literal;
    n_pos    := 1;
    n_length := a01char_size
    END;
(*ENDWITH*) 
IF  g01unicode
THEN
    acv.a_cmd_part^.sp1p_buf[1] := chr(0);
(*ENDIF*) 
acv.a_cmd_part^.sp1p_buf[a01char_size] := '0';
a55_found_one_value (acv, dmli, dfa);
acv.a_cmd_part^.sp1p_buf[1] := aux_c[1];
(* PTS 1119811 E.Z. *)
acv.a_cmd_part^.sp1p_buf[2] := aux_c[2];
acv.a_ap_tree^[acv.a_ap_tree^[ 0 ].n_lo_level] := aux_node;
dfa[dmli.d_fieldno]         := aux_dfa
END;
 
(*------------------------------*) 
 
PROCEDURE
      a56_describe (
            VAR acv        : tak_all_command_glob;
            VAR sparr      : tak_syspointerarr;
            fp             : tak_fp_kind_type;
            VAR movebefore : tsp00_Int2;
            reccolno       : integer);
 
BEGIN
WITH sparr.pparsp^.sparsinfo DO
    IF  p_cnt_infos >= p_max_infos
    THEN
        a55realloc_parsinfo (acv, sparr.pparsp);
    (*ENDIF*) 
(*ENDWITH*) 
IF  acv.a_returncode = 0
THEN
    WITH sparr.pparsp^.sparsinfo DO
        BEGIN
        p_cnt_infos := succ (p_cnt_infos);
        WITH  p_pars_infos[ p_cnt_infos ] DO
            BEGIN
            fp_kind          := fp;
            fp_movebeforev11 := movebefore;
            movebefore       := 0;
            fp_reccolno      := reccolno;
            END;
        (*ENDWITH*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a56_get_baserecords (
            VAR acv   : tak_all_command_glob;
            VAR sparr : tak_syspointerarr;
            VAR tab   : tak_one_table);
 
VAR
      f_ok  : boolean;
      owner : tsp00_KnlIdentifier;
 
BEGIN
WITH tab DO
    BEGIN
    IF  oresfile in ospecialname
    THEN
        BEGIN
        a663restable_get (acv, d_fix, otable, sparr, f_ok);
        END
    ELSE
        IF  a101_IsExtendedTempFile (acv, otreeid)
        THEN
            BEGIN
            IF  oissynonym in ospecialname
            THEN
                owner := a01_il_b_identifier
            ELSE
                owner := ouser;
            (*ENDIF*) 
            f_ok := a06_table_exist (acv, d_fix,
                  owner, otable, sparr, c_all)
            END
        ELSE
            IF  oview
            THEN
                a06_systable_get (acv, d_fix, ofromtableid,
                      sparr.pbasep, c_all, f_ok)
            ELSE
                IF  ouser = a01_i_temp
                THEN
                    a06_systable_get (acv, d_fix, ofromtableid,
                          sparr.pbasep, c_all, f_ok)
                ELSE
                    a06_systable_get (acv, d_fix, otreeid.fileTabId_gg00,
                          sparr.pbasep, c_all, f_ok);
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  NOT f_ok
    THEN
        BEGIN
        acv.a_error_tableid := otreeid.fileTabId_gg00;
        a07_nb_put_error (acv, e_unknown_tablename, 1, otable)
        END
    ELSE
        IF  otreeid.fileVersion_gg00 <>
            sparr.pbasep^.sbase.btreeid.fileVersion_gg00
        THEN
            a07_b_put_error (acv, e_old_fileversion, 1);
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(* PTS 1139184 *)
(*------------------------------*) 
 
FUNCTION
      a56IsClusterKey (
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info;
            VAR colInfo : tak00_columninfo) : boolean;
 
VAR
      ix : integer;
 
BEGIN
IF  (ctkey       in colInfo.ccolpropset) AND
    (ctinvisible in colInfo.ccolpropset) AND
    (colInfo.ccolstack.eop_out = op_o_output_cluster_key)
THEN
    BEGIN (* cluster key column, fill last key column with 0xFF *)
    FOR ix := 1 TO colInfo.ccolstack.elen_var DO
        acv.a_mblock.mb_data^.
              mbp_buf [acv.a_mblock.mb_data_len+ix] := chr(255);
    (*ENDFOR*) 
    acv.a_mblock.mb_data_len :=
          acv.a_mblock.mb_data_len + colInfo.ccolstack.elen_var;
    IF  acv.a_ex_kind = only_parsing
    THEN
        dmli.d_movebefore := dmli.d_movebefore + colInfo.ccolstack.elen_var;
    (*ENDIF*) 
    acv.a_mblock.mb_type2 := mm_specialkey;
    a56IsClusterKey       := true;
    END
ELSE
    a56IsClusterKey := false;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak56one_value (
            VAR acv           : tak_all_command_glob;
            VAR dmli          : tak_dml_info;
            VAR dfa           : tak_dfarr);
 
VAR
      ix        : integer;
      n         : tsp00_KnlIdentifier;
      save_symb : tak_sc_symbol;
&     ifdef TRACE
      old_len : tsp00_Int2;
&     endif
 
BEGIN
WITH acv, dmli, d_colbuf^, dfa[ creccolno ] DO
    BEGIN
&   IFDEF TRACE
    old_len := a_mblock.mb_data_len;
    t01int4 (ak_sem, 'dml_node    ', dml_node);
    a061td_colinfo (d_colbuf^, 0);
&   ENDIF
    d_fieldno := creccolno;
    IF  dml_node <> 0
    THEN
        WITH a_ap_tree^[dml_node] DO
            IF  a_ap_tree^[ dml_node ].n_symb = s_default
            THEN
                IF  ctserial in ccolpropset
                THEN
                    a56_serial_default (acv, dmli, dfa)
                ELSE
                    IF  ctdefault in dfa[ d_fieldno ].dml_col_ptr^.ccolpropset
                    THEN
                        a56one_default_value (acv, dmli, d_colbuf^, d_pars_kind)
                    ELSE
                        BEGIN
                        a061get_colname (dfa[ d_fieldno ].dml_col_ptr^, n);
                        a07_nb_put_error (acv, e_default_spec_not_allowed,
                              a_ap_tree^[ dml_node ].n_pos, n);
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
            ELSE
                BEGIN
                save_symb := n_symb;
                IF  (dml_col_ptr^.cdatatyp in
                    [dstra, dstruni, dstrb,
                    dlonga, dlonguni, dlongb])
                    AND (n_symb in [s_string_literal, s_byte_string])
                THEN
                    n_symb := s_stamp;
                (*ENDIF*) 
                a55_found_one_value (acv, dmli, dfa);
                n_symb := save_symb;
                IF  (d_literalrec <> NIL)              AND
                    (dml_col_ptr^.cdatatyp in
                    [dstra, dstruni, dstrb,
                    dlonga, dlonguni, dlongb]) AND
                    (n_symb in
                    [s_string_literal, s_byte_string, s_parameter_name])
                THEN
                    a56get_longlit (acv, dmli, d_colbuf^.cdatatyp,
                          dfa[dmli.d_colbuf^.creccolno].dml_node)
                (*ENDIF*) 
                END
            (*ENDIF*) 
        (*ENDWITH*) 
    ELSE
        BEGIN
        dml_col_ptr := d_colbuf;
&       ifdef TRACE
        t01int4 (ak_sem, 'dfa[i]     4', creccolno);
&       endif
        IF  ctdefault in d_colbuf^.ccolpropset
        THEN
            a56one_default_value (acv, dmli, d_colbuf^, d_pars_kind)
        ELSE
            IF  ctserial in ccolpropset
            THEN
                a56_serial_default (acv, dmli, dfa)
            ELSE
                IF  (ctopt     in d_colbuf^.ccolpropset)
                    OR
                    (ctdropped in d_colbuf^.ccolpropset)
                    OR
                    (a_mblock.mb_type2 = mm_ok_not_allowed)
                THEN
                    a55_nullvalue (acv, dmli, dfa)
                ELSE
                    IF  NOT a56IsClusterKey (acv, dmli, d_colbuf^) (* PTS 1139184 *)
                    THEN
                        BEGIN
                        a061get_colname (d_colbuf^, n);
                        a07_nb_put_error (acv, e_missing_mandatory_recordfield,
                              a_cmd_part^.sp1p_buf_len, n)
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
&       IFDEF TRACE
        IF  old_len <= 400
        THEN
            t01moveobj (ak_sem, a_mblock.mb_data^.mbp_buf, 1,
                  a_mblock.mb_data_len)
        ELSE
            BEGIN
            t01moveobj (ak_sem, a_mblock.mb_data^.mbp_buf, 1, 300);
            t01moveobj (ak_sem, a_mblock.mb_data^.mbp_buf, old_len,
                  a_mblock.mb_data_len);
            END;
        (*ENDIF*) 
&       ENDIF
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*===========================================================*)
(*        Start of procedure for INSERT...SELECT *)
(*===========================================================*)
(*------------------------------*) 
 
PROCEDURE
      a56_aenumerated_values (
            VAR acv        : tak_all_command_glob;
            select_allowed : boolean;
            VAR put_node   : tsp00_Int2;
            VAR last_node  : tsp00_Int2);
 
VAR
      select_found : boolean;
      curr_n       : tsp00_Int2;
      last_n       : tsp00_Int2;
      new_node     : tsp00_Int2;
      enum_node    : tsp00_Int2;
      i            : integer;
      m_scv_index  : integer;
      val_pos      : integer;
      scvh         : tak_scanner_glob;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        a01_call_put (acv, a56, cak_x_enum_values, curr_n);
        (* PTS 1112324 E.Z. *)
        enum_node := curr_n;
        put_node := curr_n;
        last_node := curr_n;
        IF  sc_symb = s_leftpar
        THEN
            BEGIN
            scvh := a_scv;
            a01_next_symbol (acv);
            IF  (sc_symb = s_leftpar) OR
                (a01_eqkey(a01kw[ cak_i_select ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv))
            THEN
                a_scv := scvh
            ELSE
                BEGIN
                a01_call_put (acv, a56, cak_x_column_list, curr_n);
                a_ap_tree^[ last_node ].n_lo_level := curr_n;
                a02_l_acolumn_list (acv, a_ap_tree^[ curr_n ].n_lo_level,
                      last_n);
                last_n := curr_n;
                a01_force_symbol (acv, s_rightpar, put_node, last_node);
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            IF  a01_eqkey (a01kw[ cak_i_values ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                val_pos := sc_sypos;
                a01_next_symbol (acv);
                a01_force_symbol (acv, s_leftpar, put_node, last_node);
                IF  a_returncode = 0
                THEN
                    BEGIN
                    a01_call_put (acv, a56, cak_x_value_list, curr_n);
                    IF  a_ap_tree^[ last_node ].n_lo_level = 0
                    THEN
                        a_ap_tree^[ last_node ].n_lo_level := curr_n
                    ELSE
                        a_ap_tree^[ last_n ].n_sa_level := curr_n;
                    (*ENDIF*) 
                    scvh := a_scv;
                    m_scv_index := a_scv_index;
                    (* PTS 1112324 E.Z. *)
                    select_found := false;
                    a03_l_avalue_list (acv, c_null_allowed,
                          c_stamp_allowed, c_default_allowed,
                          c_sysuser_allowed,
                          a_ap_tree^[ curr_n ].n_lo_level, last_n);
                    IF  sc_symb = s_rightpar
                    THEN
                        a01_next_symbol (acv)
                    ELSE
                        IF  ((a_sqlmode = sqlm_internal) OR
                            ( a_sqlmode = sqlm_oracle))
                            AND
                            (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc = a56)
                        THEN
                            BEGIN
                            a_returncode := 0;
                            a_errorpos   := 0;
                            a_scv := scvh;
                            a_scv_index := m_scv_index;
                            (* PTS 1116169 E.Z. *)
                            a_oneval_subq_allowed := true;
                            a03_ln_aexpression_list (acv,
                                  a_ap_tree^[ curr_n ].n_lo_level, last_n);
                            (* PTS 1116169 E.Z. *)
                            a_oneval_subq_allowed := false;
                            a01_force_symbol (acv, s_rightpar,
                                  put_node, last_node);
                            (* check if there is a column_name *)
                            i := a_ap_tree^[ curr_n ].n_lo_level;
                            WHILE ((a_returncode = 0) AND
                                  (i > 0)) DO
                                BEGIN
                                ak56check_for_colname (acv,
                                      a_ap_tree^[ i ].n_lo_level);
                                i := a_ap_tree^[ i ].n_sa_level;
                                END;
                            (*ENDWHILE*) 
                            IF  a_returncode = 0
                            THEN
                                ak56select_from_dual (acv, val_pos,
                                      put_node, last_node);
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            ELSE
                IF  NOT select_allowed
                THEN
                    a07_error (acv, e_wanted_keyword, put_node, last_node)
                ELSE
                    BEGIN
                    a_rowno_allowed := true;
                    a_rowno_found  := false;
                    a_allow_functions := tf_unknown;
                    a01_call_put (acv, a63, cak_x_subquery, new_node);
                    a_ap_tree^[ new_node ].n_lo_level := -1;
                    a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_sa_level := new_node;
                    a_leftpar_cnt  := 0;
                    a_rightpar_cnt := 0;
                    (* PTS 1116169 E.Z. *)
                    a_oneval_subq_allowed := true;
                    IF  a_ap_tree^[ last_node ].n_lo_level = 0
                    THEN
                        (* PTS 1138343 D.T. *)
                        a60_aquery_spec (acv, c_stamp_allowed, false,
                              a_ap_tree^[ last_node ].n_lo_level, last_n, cak_is_undefined, false)
                    ELSE
                        (* PTS 1138343 D.T. *)
                        a60_aquery_spec (acv, c_stamp_allowed, false,
                              a_ap_tree^[ last_n ].n_sa_level, last_n, cak_is_undefined, false);
                    (*ENDIF*) 
                    (* PTS 1116169 E.Z. *)
                    a_oneval_subq_allowed := false;
                    IF  a_returncode = 0
                    THEN
                        BEGIN
                        a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc :=
                              cak_x_insert_select;
                        (*a_precomp_info_byte := csp1_p_none;*)
                        WITH a_ap_tree^[ new_node ] DO
                            BEGIN
                            n_pos := last_n;
                            IF  n_lo_level = -1
                            THEN
                                n_lo_level := 0
                            (*ENDIF*) 
                            END;
                        (*ENDWITH*) 
                        END;
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak56select_from_dual (
            VAR acv       : tak_all_command_glob;
            val_pos       : integer;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      org_cmd    : tsp00_MoveObjPtr;
      org_len    : tsp00_Int4;
      req_len    : tsp00_Int4;
      src_start  : tsp00_Int4;
      src_end    : tsp00_Int4;
      dest_i     : tsp00_Int4;
      p          : tsp00_Int4;
      sn         : tsp00_C4;
      sysdbaname : tsp00_KnlIdentifier;
      (* This procedures creates a new sql command in a_cmd_part,    *)
      (* which is like the original one with the parenthised         *)
      (* expression list replaced by a select from dual.             *)
      (* before: ... VALUES (<expr1>, <exprN>) ...                   *)
      (* after:  ... SELECT  <expr1>, <exprN> FROM <sysdba>.DUAL ... *)
 
BEGIN
WITH acv DO
    BEGIN
    (* Set returncode, so that vak35 can parse a second time. *)
    a_returncode := 0;
    org_len := a_cmd_part^.sp1p_buf_len;
    org_cmd := @a_cmd_part^.sp1p_buf;
    req_len := 5 + 2 * sizeof (tsp00_KnlIdentifier) + 2 + 6 + 1;
    IF  g01unicode
    THEN
        req_len := 2 * req_len;
    (*ENDIF*) 
    a542internal_packet (acv,
          NOT c_release_internal_packet, org_len + req_len);
    IF  a_returncode = 0
    THEN
        BEGIN
        SAPDB_PascalMove ('VAK56 ',   1,    
              org_len, a_cmd_part^.sp1p_buf_size,
              @org_cmd^, 1, @a_cmd_part^.sp1p_buf, 1, val_pos - 1,
              a_returncode);
        a_cmd_part^.sp1p_buf_len := val_pos - 1;
        a542move_to_packet (acv, @a01kw[cak_i_select], 6);
        IF  g01unicode
        THEN
            BEGIN
            src_start := val_pos + 12;
            dest_i    := src_start;
            src_end   := org_len;
            WHILE ((org_cmd^[ src_end   ] <> ')') OR
                  (org_cmd^[ src_end-1 ] <> csp_unicode_mark))
                  AND (src_end-1 > src_start) DO
                src_end := src_end - 2;
            (*ENDWHILE*) 
            IF  ((org_cmd^[ src_end   ] <> ')') OR
                (org_cmd^[ src_end-1 ] <> csp_unicode_mark))
            THEN
                a07_error (acv, e_missing_keyword, put_node, last_node)
            ELSE
                BEGIN
                SAPDB_PascalMove ('VAK56 ',   2,    
                      org_len, a_cmd_part^.sp1p_buf_size,
                      @org_cmd^, src_start, @a_cmd_part^.sp1p_buf, dest_i,
                      src_end - src_start + 1,
                      a_returncode);
                p := dest_i+1;
                WHILE (a_cmd_part^.sp1p_buf[ p-1 ] <> csp_unicode_mark)
                      OR
                      (a_cmd_part^.sp1p_buf[ p   ] <> '(') DO
                    p := p + 2;
                (*ENDWHILE*) 
                a_cmd_part^.sp1p_buf[ p ] := bsp_c1;
                dest_i := dest_i + src_end - src_start + 1;
                a_cmd_part^.sp1p_buf[ dest_i-1 ] := bsp_c1;
                END
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            src_start := val_pos + 6;
            dest_i    := src_start;
            WHILE a01is_whitespace_char( org_cmd^, src_start ) DO
                src_start := succ (src_start);
            (*ENDWHILE*) 
            SAPDB_PascalFill ('VAK56 ',   3,    
                  a_cmd_part^.sp1p_buf_size, @a_cmd_part^.sp1p_buf,
                  dest_i, src_start+1-dest_i, bsp_c1,
                  a_returncode);
            dest_i  := src_start + 1;
            src_end := org_len;
            WHILE (org_cmd^[ src_end ] <> ')') AND
                  (src_end > src_start) DO
                src_end := pred (src_end);
            (*ENDWHILE*) 
            IF  org_cmd^[ src_end ] <> ')'
            THEN
                a07_error (acv, e_missing_keyword, put_node, last_node)
            ELSE
                BEGIN
                SAPDB_PascalMove ('VAK56 ',   4,    
                      org_len, a_cmd_part^.sp1p_buf_size,
                      @org_cmd^, src_start + 1, @a_cmd_part^.sp1p_buf, dest_i,
                      src_end - src_start - 1,
                      a_returncode);
                dest_i := dest_i + src_end - src_start;
                a_cmd_part^.sp1p_buf[ dest_i-1 ] := bsp_c1;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a_cmd_part^.sp1p_buf_len := dest_i - 1;
        a542move_to_packet (acv, @a01kw[cak_i_from], 5);
        (* PTS 1111797 E.Z. *)
        sysdbaname := g01glob.sysuser_name;
        a542identifier_to_packet (acv, sysdbaname);
        a542char_to_packet       (acv, '.');
        sn := 'DUAL';
        a542move_to_packet       (acv, @sn, sizeof (sn));
        SAPDB_PascalMove ('VAK56 ',   5,    
              org_len, a_cmd_part^.sp1p_buf_size,
              @org_cmd^, src_end + 1, @a_cmd_part^.sp1p_buf,
              a_cmd_part^.sp1p_buf_len + 1,
              org_len - src_end, a_returncode);
        a_cmd_part^.sp1p_buf_len :=
              a_cmd_part^.sp1p_buf_len + org_len - src_end;
        a07_b_put_error (acv, e_expr_in_insert_value_list, 1)
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a56_ainsert_statement (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      last_n         : tsp00_Int2;
      procs          : tak_procs;
      need_duplicates: boolean;
      scvh           : tak_scanner_glob;
 
BEGIN
acv.a_scv.sc_states := acv.a_scv.sc_states + [ scs_hint_allowed ];
a01_next_symbol (acv);
acv.a_return_segm^.sp1r_function_code := csp1_insert_fc;
procs := a56;
IF  NOT acv.a_cmd_segment_header.sp1c_mass_cmd
THEN
    a01_call_put (acv, procs, cak_x_normal_insert, put_node)
ELSE
    BEGIN
    acv.a_return_segm^.sp1r_function_code :=
          acv.a_return_segm^.sp1r_function_code + csp1_masscmd_fc_offset;
    acv.a_precomp_info_byte := csp1_p_mass_command;
    a01_call_put (acv, procs, cak_x_minsert, put_node)
    END;
(*ENDIF*) 
acv.a_ap_tree^[ put_node ].n_length := 0;
IF  acv.a_scv.sc_symb = s_hint
THEN
    a80_ahint_statement(acv, cak_x_insert_hint, put_node);
(*ENDIF*) 
acv.a_scv.sc_states := acv.a_scv.sc_states - [ scs_hint_allowed ];
WITH acv, a_scv DO
    BEGIN
    a_select_node   := 0;
    a_insert_select := true;
    IF  a01_eqkey (a01kw[ cak_i_into ], a_sqlmode,
        a_cmd_part^.sp1p_buf, a_scv)
    THEN
        a01_next_symbol (acv)
    ELSE
        IF  a_sqlmode <> sqlm_internal
        THEN
            a07_error (acv, e_wanted_keyword, put_node, last_n);
        (*ENDIF*) 
    (*ENDIF*) 
    a02_s_atable_spec (acv, a_ap_tree^[ put_node ].n_lo_level, last_n);
    IF  ((a01_eqkey (a01kw[ cak_i_set ], a_sqlmode,
        a_cmd_part^.sp1p_buf, a_scv))
        AND (a_sqlmode = sqlm_internal))
    THEN
        ak56anamed_values (acv, a_ap_tree^[ last_n ].n_sa_level,
              last_n)
    ELSE
        IF  ((a01_eqkey (a01kw[ cak_i_values ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv))
            OR
            (a01_eqkey (a01kw[ cak_i_select ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)) OR
            (sc_symb = s_leftpar))
        THEN
            a56_aenumerated_values (acv, c_select_allowed,
                  a_ap_tree^[ last_n ].n_sa_level, last_n)
        ELSE
            a07_error (acv, e_wanted_keyword, put_node, last_n);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  (a_returncode = 0) AND
        (sc_symb <> s_eof)                   AND
        ((a_sqlmode = sqlm_internal)
        OR
        ((a_sqlmode = sqlm_oracle) AND g01glob.db_is_for_sapr3))
    THEN
        BEGIN
        need_duplicates := true;
        IF  a01_eqkey (a01kw[ cak_i_ignore ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)
        THEN
            BEGIN
            need_duplicates := false;
            scvh := a_scv;
            a01_next_symbol (acv);
            IF  a01_eqkey (a01kw[ cak_i_duplicates ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                a01_call_put (acv, a56, cak_x_ignore_dupl,
                      a_ap_tree^[ last_n ].n_sa_level);
                a01_next_symbol (acv);
                END
            ELSE
                a_scv := scvh
            (*ENDIF*) 
            END
        ELSE
            IF  a01_eqkey (a01kw[ cak_i_update ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                a01_call_put (acv, a56, cak_x_update_dupl,
                      a_ap_tree^[ last_n ].n_sa_level)
            ELSE
                IF  a01_eqkey (a01kw[ cak_i_reject ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    a01_call_put (acv, a56, cak_x_reject_dupl,
                          a_ap_tree^[ last_n ].n_sa_level)
                ELSE
                    need_duplicates := false;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  need_duplicates
        THEN
            BEGIN
            last_n := a_ap_tree^[ last_n ].n_sa_level;
            a01_next_symbol (acv);
            IF  NOT a01mandatory_keyword (acv, cak_i_duplicates)
            THEN
                put_node := 0
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (a_returncode = 0)                   AND
        (sc_symb <> s_eof)                   AND
        ((a_sqlmode = sqlm_internal) OR (a_sqlmode = sqlm_oracle))
    THEN
        IF  a01_eqkey (a01kw[ cak_i_nowait ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)
        THEN
            BEGIN
            a01_call_put (acv, a52, cak_x_nowait, a_ap_tree^[ last_n ].n_sa_level);
            last_n := a_ap_tree^[ last_n ].n_sa_level;
            a01_next_symbol (acv);
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  (a_returncode = 0)                   AND
        (sc_symb <> s_eof) (* PTS 1106990 *)
        AND
        (
        (a_proc_compile in [pct_insert_trigger,
        pct_update_trigger,
        pct_delete_trigger,
        pct_multi_trigger])   OR
        (a_trigger_level > 0) OR
        (a_comp_type = at_kernel)
        )
    THEN
        IF  a01_eqkey (a01kw[ cak_i_ignore ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)
        THEN
            BEGIN
            a01_next_symbol (acv);
            IF  a01mandatory_keyword (acv, cak_i_trigger)
            THEN
                BEGIN
                acv.a_ap_tree^[ put_node ].n_length := cak_i_ignore;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  (a_returncode = 0)                   AND
        (sc_symb <> s_eof)                   AND
        ((a_sqlmode = sqlm_internal) OR (a_sqlmode = sqlm_oracle))
    THEN
        IF  a01mandatory_keyword (acv, cak_i_with)
        THEN
            IF  a01mandatory_keyword (acv, cak_i_commit)
            THEN
                a01_call_put (acv, a52, cak_x_commit, a_ap_tree^[ last_n ].n_sa_level);
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    a01_is_end_symbol (acv)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a56_datatype (
            in_datatype      : tsp00_DataType;
            VAR out_datatype : tsp00_DataType);
 
BEGIN
out_datatype := in_datatype
END;
 
(*------------------------------*) 
 
PROCEDURE
      a56_enumerated_values (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info;
            VAR dfa    : tak_dfarr;
            VAR curr_n : integer);
 
VAR
      joinview    : boolean;
      ins_select  : boolean;
      col_n       : integer;
      fieldno     : integer;
      node_before : integer;
      val_n       : integer;
      first_sub_colno  : integer;
      subq_colno  : integer;
      user_name   : tsp00_KnlIdentifier;
      n           : tsp00_KnlIdentifier;
      col_ptr     : tak00_colinfo_ptr;
 
BEGIN
col_n    := acv.a_ap_tree^[ curr_n ].n_lo_level;
joinview := dmli.d_sparr.pbasep^.sbase.btablekind = tview;
(* PTS 1120988 E.Z. *)
ins_select := false;
WITH acv, a_ap_tree^[ col_n ], dmli DO
    BEGIN
    IF  ((n_proc = a56) AND (n_subproc = cak_x_column_list))
    THEN
        BEGIN
        val_n := n_sa_level;
        col_n := n_lo_level;
        subq_colno := 0;
        IF  ((a_ap_tree^[ val_n ].n_subproc = cak_x_value_list) AND
            (a_ap_tree^[ val_n ].n_proc = a56))
        THEN
            BEGIN
            val_n := a_ap_tree^[ val_n ].n_lo_level;
            WHILE ((col_n <> 0) AND (val_n <> 0) AND
                  (a_returncode = 0)) DO
                BEGIN
                ak56col_list_element (acv, dmli, dfa, joinview,
                      col_n, val_n, subq_colno);
                col_n := a_ap_tree^[ col_n ].n_sa_level;
                val_n := a_ap_tree^[ val_n ].n_sa_level
                END;
            (*ENDWHILE*) 
            IF  ((col_n <> 0) OR (val_n <> 0))
            THEN
                IF  col_n <> 0
                THEN
                    a07_b_put_error (acv, e_too_few_values,
                          a_ap_tree^[ col_n ].n_pos)
                ELSE
                    a07_b_put_error (acv, e_too_many_values,
                          a_ap_tree^[ val_n ].n_pos)
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            (*****************)
            (* insert select *)
            (*****************)
            (* PTS 1120988 E.Z. *)
            ins_select := true;
            curr_n     := val_n;
            subq_colno := 1;
            IF  ((d_sparr.pbasep^.sbase.btablekind = twithoutkey) OR
                ((d_sparr.pbasep^.sbase.btablekind = tonebase) AND
                (d_sparr.pbasep^.sbase.bv_tablekind = twithoutkey)))
                AND
                d_repl_nokey_ins_sel
            THEN
                BEGIN
                WITH d_sparr.pbasep^.sbase, dfa[1] DO
                    BEGIN
                    dml_index := bfirstcolind;
&                   ifdef TRACE
                    t01int4 (ak_sem, 'DML_INDEX  5', dml_index);
&                   endif
                    dml_node   := 1;
                    subq_colno := subq_colno + 1
                    END;
                (*ENDWITH*) 
                END;
            (* PTS 1120988 E.Z. *)
            (*ENDIF*) 
            first_sub_colno := subq_colno;
            WHILE ((col_n <> 0) AND (a_returncode = 0)) DO
                BEGIN
                ak56col_list_element (acv, dmli, dfa, joinview,
                      col_n, val_n, subq_colno);
                col_n := a_ap_tree^[ col_n ].n_sa_level;
                subq_colno := succ(subq_colno)
                END;
            (*ENDWHILE*) 
            END
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        IF  n_proc <> a56
        THEN
            BEGIN
            curr_n     := col_n;
            val_n      := curr_n;
            subq_colno := 1;
            (* PTS 1120988 E.Z. *)
            ins_select := true;
            END
        ELSE
            BEGIN
            val_n := n_lo_level;
            subq_colno := 0;
            END;
        (*ENDIF*) 
        CASE d_sparr.pbasep^.sbase.btablekind OF
            twithkey :
                d_fieldno := 1;
            twithoutkey :
                IF  d_repl_nokey_ins_sel
                THEN
                    d_fieldno := 1
                ELSE
                    d_fieldno := 2;
                (*ENDIF*) 
            tonebase :
                BEGIN
                IF  d_repl_nokey_ins_sel
                THEN
                    WITH d_sparr.pbasep^.sbase, dfa[1] DO
                        BEGIN
                        dml_col_ptr := a103GetColumn (d_sparr.pbasep^.sbase, bfirstcolind);
&                       ifdef TRACE
                        t01int4 (ak_sem, 'DML_INDEX  5', dml_index);
&                       endif
                        dml_node   := 1;
                        subq_colno := subq_colno + 1
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
                d_fieldno := 1
                END;
            (* PTS 1111576 E.Z. *)
            OTHERWISE
                d_fieldno := 1;
            END;
        (*ENDCASE*) 
        (* PTS 1120988 E.Z. *)
        first_sub_colno := subq_colno;
        WHILE ((d_fieldno <= d_sparr.pbasep^.sbase.bmaxcol) AND
              (a_returncode = 0)) DO
            BEGIN
            a06extcolno (d_sparr.pbasep^.sbase, d_fieldno, col_ptr);
&           ifdef TRACE
            t01int4 (ak_sem, 'cdatatyp    ',
                  ord(col_ptr^.cdatatyp));
            t01int4 (ak_sem, 'd_fieldno   ', d_fieldno);
            t01int4 (ak_sem, 'val_n       ', val_n);
            t01int4 (ak_sem, 'subq_colno  ', subq_colno);
&           endif
            IF  (NOT (ctdropped in col_ptr^.ccolpropset)     AND
                (NOT (ctinvisible in col_ptr^.ccolpropset) ) )
            THEN
                IF  ((a_sqlmode = sqlm_ansi) (* PTS 1105795 M.Ki. *)
                    AND
                    (col_ptr^.cdatatyp in
                    [ dlonga, dlongb, dlonguni,
                    dstra, dstrb, dstruni ]))
                THEN
                    BEGIN
                    a061get_colname (col_ptr^, n);
                    a07_nb_put_error (acv, e_command_for_string_not_allow,
                          1, n)
                    END
                ELSE
                    IF  val_n = 0
                    THEN
                        a07_b_put_error (acv, e_too_few_values,
                              a_cmd_part^.sp1p_buf_len)
                    ELSE
                        IF  ((col_ptr^.cdatatyp in
                            [ dlonga, dlongb, dlonguni,
                            dstra, dstrb, dstruni ]) AND
                            (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc <>
                            cak_x_insert_select) (* PTS 1105795 M.Ki. *)
                            AND
                            (a_ap_tree^[ val_n ].n_symb <> s_null) AND
                            (a_ap_tree^[ val_n ].n_symb <> s_parameter_name) AND
                            (a_ap_tree^[ val_n ].n_symb <> s_string_literal) AND
                            (a_ap_tree^[ val_n ].n_symb <> s_byte_string) AND
                            (a_ap_tree^[ val_n ].n_symb <> s_default))
                        THEN
                            BEGIN
                            a061get_colname (col_ptr^, n);
                            IF  a_ap_tree^[ val_n ].n_proc = a641
                            THEN
                                a07_nb_put_error (acv, e_incompatible_datatypes,
                                      a_ap_tree^[ val_n ].n_length, n)
                            ELSE
                                a07_nb_put_error (acv, e_incompatible_datatypes,
                                      a_ap_tree^[ val_n ].n_pos, n)
                            (*ENDIF*) 
                            END
                        ELSE
                            BEGIN
                            IF  a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc = a57
                            THEN
                                IF  col_ptr^.cdatatyp in
                                    [ dstra, dstrb, dstruni,
                                    dlonga, dlongb, dlonguni ]
                                THEN
                                    d_longdesc_found := true;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            d_foundset := d_foundset - [col_ptr^.cextcolno];
                            IF  joinview
                            THEN
                                fieldno := col_ptr^.cextcolno
                            ELSE
                                fieldno := col_ptr^.creccolno;
                            (*ENDIF*) 
                            WITH dfa[ fieldno ] DO
                                BEGIN
                                dml_col_ptr := col_ptr;
&                               ifdef TRACE
                                t01int4 (ak_sem, 'dfa[i]     5', fieldno);
&                               endif
                                dml_node  := val_n;
                                dml_colno_in_subquery := subq_colno;
                                END;
                            (*ENDWITH*) 
                            IF  n_proc <> a56
                            THEN
                                subq_colno := succ(subq_colno)
                            ELSE
                                val_n := a_ap_tree^[ val_n ].n_sa_level;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            d_fieldno := succ(d_fieldno);
            END;
        (*ENDWHILE*) 
        IF  ((d_fieldno = d_sparr.pbasep^.sbase.bmaxcol+1) AND
            (val_n <> 0)
            AND (n_proc = a56))
        THEN
            a07_b_put_error (acv, e_too_many_values,
                  a_ap_tree^[ val_n ].n_pos)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    (* PTS 1120988 E.Z. *)
    IF  ins_select AND dmli.d_pseudo_ins_select
    THEN
        BEGIN
        (* look for DEFAULT and destroy it *)
        REPEAT
            node_before := val_n;
            val_n := acv.a_ap_tree^[val_n].n_lo_level;
        UNTIL
            (acv.a_ap_tree^[val_n].n_proc = a60) AND
            (acv.a_ap_tree^[val_n].n_subproc = cak_x_select_column);
        (*ENDREPEAT*) 
        subq_colno := first_sub_colno;
        WHILE (val_n <> 0) AND (acv.a_returncode = 0) DO
            BEGIN
            WITH acv.a_ap_tree^[acv.a_ap_tree^[val_n].n_lo_level] DO
                IF  (n_proc = no_proc) AND (n_symb = s_default)
                THEN
                    BEGIN
                    FOR col_n := 1 TO d_sparr.pbasep^.sbase.bmaxcol DO
                        BEGIN
                        IF  (dfa[col_n].dml_node <> 0)
                        THEN
                            BEGIN
                            IF  (dfa[col_n].dml_colno_in_subquery = subq_colno)
                            THEN
                                IF  ctdefault in dfa[col_n].dml_col_ptr^.ccolpropset
                                THEN
                                    BEGIN
                                    dfa[col_n].dml_node := 0;
                                    dfa[col_n].dml_res_index := 1;
                                    END
                                ELSE
                                    BEGIN
                                    a061get_colname (dfa[ col_n ].dml_col_ptr^, n);
                                    a07_nb_put_error (acv, e_default_spec_not_allowed,
                                          1, n)
                                    END
                                (*ENDIF*) 
                            ELSE
                                IF  (dfa[col_n].dml_colno_in_subquery > subq_colno)
                                THEN
                                    dfa[col_n].dml_colno_in_subquery := dfa[col_n].dml_colno_in_subquery - 1;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END;
                    (*ENDFOR*) 
                    IF  subq_colno = first_sub_colno
                    THEN
                        acv.a_ap_tree^[node_before].n_lo_level := acv.a_ap_tree^[val_n].n_sa_level
                    ELSE
                        acv.a_ap_tree^[node_before].n_sa_level := acv.a_ap_tree^[val_n].n_sa_level
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    node_before := val_n;
                    subq_colno := succ(subq_colno);
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
            val_n := acv.a_ap_tree^[val_n].n_sa_level;
            END;
        (*ENDWHILE*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a56_insert_statement (VAR acv : tak_all_command_glob);
 
CONST
      c_useLiteralBuf = true;
 
VAR
      ex_kind        : tak_execution_kind;
      all_done       : boolean;
      with_commit    : boolean;
      trans_m_type   : tgg00_MessType;
      old_returncode : tsp00_Int2;
      linkbuf        : tak_sysbufferaddress;
      literalrec     : tak_sysbufferaddress;
      isparr         : tak_syspointerarr;
      oldContext     : tgg00_UnivTrans;
      b_err      : tgg00_BasisError;
 
BEGIN
linkbuf    := NIL;
literalrec := NIL;
all_done   := false;
ex_kind    := acv.a_init_ex_kind;
with_commit := false;
ak56build_insert_string (acv, isparr, linkbuf, literalrec, all_done, with_commit);
IF  acv.a_returncode = 0
THEN
    IF  NOT all_done
    THEN
        BEGIN
        IF  NOT with_commit
        THEN
            a54_last_part (acv, isparr, c_last_pars_part)
        ELSE
            IF  ((acv.a_mblock.mb_qual^.mtrigger_pos > 0) AND
                (acv.a_mblock.mb_qual^.mtrigger_cnt > 0))
                OR
                (linkbuf <> NIL)
            THEN
                a07_b_put_error (acv, e_invalid_tabletype, 1)
            ELSE
                BEGIN
                IF  acv.a_ex_kind = parsing_executing
                THEN
                    BEGIN
                    old_returncode := 0;
                    a51_internal_trans (acv, oldContext);
                    IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
                    THEN
                        BEGIN
                        a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
                        old_returncode := acv.a_returncode
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    isparr.pparsp^.sparsinfo.p_own_trans := true;
                (*ENDIF*) 
                a54_last_part (acv, isparr, c_last_pars_part);
                IF  (acv.a_ex_kind = parsing_executing) AND
                    (old_returncode = 0)
                THEN
                    BEGIN
                    IF  acv.a_returncode = 0
                    THEN
                        trans_m_type := m_commit
                    ELSE
                        trans_m_type := m_rollback;
                    (*ENDIF*) 
                    acv.a_transinf.tri_trans.trError_gg00 := e_ok;
                    a51close_internal_trans (acv, oldContext, trans_m_type);
                    END;
                (*ENDIF*) 
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  (linkbuf <> NIL) AND NOT all_done
THEN
    a56insert_upd_with_link (acv, linkbuf);
(* PTS 1103144 E.Z. *)
(*ENDIF*) 
IF  (literalrec <> NIL)
THEN
    BEGIN
    IF  (ex_kind <> only_parsing)
    THEN
        BEGIN
        IF  (acv.a_returncode = 0)
        THEN
            a507_literal (acv, literalrec^.slongliteral, NOT c_useLiteralBuf);
        (*ENDIF*) 
        a10dispose (acv, literalrec);
        END
    ELSE
        BEGIN
        a10add_sysinfo( acv, literalrec, b_err );
        IF  ( b_err <> e_ok )
        THEN
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        a10_rel_sysinfo( acv, literalrec^.syskey );
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ((acv.a_returncode = 0)        AND
    (ex_kind <> only_parsing))
THEN
    a60rescount (acv, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a56_normal_insert (
            VAR acv            : tak_all_command_glob;
            VAR dmli           : tak_dml_info;
            VAR dfa            : tak_dfarr;
            join_view_insert   : boolean;
            VAR not_used_links : tak_charset);
 
CONST
      c_ignore_trigger = true;
 
VAR
      nowait          : boolean;
      i               : integer;
      res_len         : integer;
      fieldno         : integer;
      duplicate_node  : integer;
      m2type          : tgg00_MessType2;
      buf             : tsp00_Buf;
      mblock          : tgg00_MessBlock;
 
BEGIN
WITH acv, dmli DO
    BEGIN
    d_range := true;
    fieldno := 1;
    CASE d_sparr.pbasep^.sbase.btablekind OF
        twithkey :
            fieldno := 1;
        twithoutkey :
            fieldno := 2;
        OTHERWISE
            CASE d_sparr.pbasep^.sbase.bv_tablekind OF
                twithkey :
                    fieldno := 1;
                twithoutkey :
                    fieldno := 2;
                END
            (*ENDCASE*) 
        END;
    (*ENDCASE*) 
    m2type := mm_nil;
    nowait := false;
    duplicate_node := a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
    duplicate_node := a_ap_tree^[ duplicate_node ].n_sa_level;
    IF  a_ap_tree^[ duplicate_node ].n_sa_level > 0
    THEN
        BEGIN
        duplicate_node := a_ap_tree^[ duplicate_node ].n_sa_level;
        IF  a_ap_tree^[ duplicate_node ].n_proc = a56
        THEN
            BEGIN
            IF  NOT join_view_insert
            THEN
                CASE a_ap_tree^[ duplicate_node ].n_subproc OF
                    cak_x_ignore_dupl :
                        m2type := mm_ignore_duplicates;
                    cak_x_update_dupl :
                        m2type := mm_update_duplicates;
                    OTHERWISE
                        BEGIN
                        END
                    END;
                (*ENDCASE*) 
            (*ENDIF*) 
            IF  a_ap_tree^[ duplicate_node ].n_sa_level > 0
            THEN
                duplicate_node := a_ap_tree^[ duplicate_node ].n_sa_level;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (a_ap_tree^[ duplicate_node ].n_proc = a52) AND
            (a_ap_tree^[ duplicate_node ].n_subproc = cak_x_nowait)
        THEN
            nowait := true;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  fieldno = 2
    THEN
        m2type := mm_nokey;
    (*ENDIF*) 
    IF  NOT (join_view_insert)
    THEN
        a06a_mblock_init (acv, m_insert, m2type,
              dmli.d_tabarr^[ 1 ].otreeid);
    (* PTS 1113190 E.Z. *)
    (*ENDIF*) 
    IF  nowait
    THEN
        a_mblock.mb_qual^.mtree.fileHandling_gg00 :=
              a_mblock.mb_qual^.mtree.fileHandling_gg00 +
              [ hsNoWait_egg00 ];
    (*ENDIF*) 
    IF  d_sparr.pbasep^.sbase.blongvarcolcnt > 0
    THEN
        a_mblock.mb_qual^.mstack_desc.mfixedcol_len :=
              d_sparr.pbasep^.sbase.blenfixedcol
    ELSE
        a_mblock.mb_qual^.mstack_desc.mfixedcol_len :=
              cak_is_undefined;
    (*ENDIF*) 
    IF  (is_secondary_table in
        d_sparr.pbasep^.sbase.blinkexist) AND
        (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_length <>
        cak_i_ignore)
        AND
        NOT acv.a_isReplicationSession
    THEN
        BEGIN
        a56alloc_linkpos_info (acv, d_sparr, m_insert, d_linkbuf);
        IF  a_returncode = 0
        THEN
            BEGIN
            d_linkbuf^.slinkposinfo.lupd_col_info :=
                  a01fullset;
            a56put_link_info (acv, d_sparr.pbasep,
                  not_used_links, NIL, d_linkbuf)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  m2type = mm_update_duplicates
    THEN
        a58describe_long_columns (acv, d_sparr);
    (*ENDIF*) 
    IF  a_ex_kind = only_parsing
    THEN
        IF  join_view_insert
        THEN
            (* PTS 1123727 E.Z. *)
            BEGIN
            a660_new_pparsp (acv, d_sparr,
                  NOT c_first_parsinfo, NOT c_complicate);
            IF  acv.a_returncode = 0
            THEN
                d_sparr.pparsp^.sparsinfo.p_treeid := d_sparr.pbasep^.sbase.btreeid;
            (*ENDIF*) 
            END
        ELSE
            a54_get_pparsp_pinfop (acv, d_sparr, m_insert);
        (*ENDIF*) 
    (*ENDIF*) 
    d_maxlen    := 0;
    d_pars_kind := fp_val_varcol_with_len;
    a_mblock.mb_qual^.mcol_pos := a_mblock.mb_qual^.mfirst_free;
    d_colbuf := a103GetColumn (d_sparr.pbasep^.sbase,
          d_sparr.pbasep^.sbase.bfirstcolind);
    a_mblock.mb_data^.mbp_varcol_offset := d_sparr.pbasep^.sbase.blenfixedcol-1;
    a_mblock.mb_data^.mbp_varcol_cnt    := d_sparr.pbasep^.sbase.bvarcolcount;
    IF  ((m2type = mm_nokey) AND
        (acv.a_returncode = 0))
    THEN
        BEGIN (* table without user defined key *)
        IF  a101_IsExtendedTempFile (acv, d_sparr.pbasep^.sbase.btreeid)
        THEN
            BEGIN
            a_mblock.mb_type2 := mm_nil;
            a56temp_table_key (acv, dmli)
            END
        ELSE
            BEGIN
            a_mblock.mb_data^.mbp_keylen := SURROGATE_MXGG00+1;
            SAPDB_PascalFill ('VAK56 ',   6,    
                  a_mblock.mb_data_size, @a_mblock.mb_data^.mbp_buf,
                  cgg_rec_key_offset+1, SURROGATE_MXGG00+1,
                  csp_defined_byte, a_returncode);
            a_mblock.mb_data_len := cgg_rec_key_offset + SURROGATE_MXGG00+1;
            IF  a_ex_kind = only_parsing
            THEN
                d_movebefore := a_mblock.mb_data_len
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        d_colbuf := a103GetColumn (d_sparr.pbasep^.sbase, d_colbuf^.cnextind)
        END;
    (*ENDIF*) 
    IF  d_sparr.pbasep^.sbase.bstringcount > 0
    THEN
        a56alloc_longlit_rec (acv, dmli, dfa);
    (*ENDIF*) 
    WHILE ((fieldno <= d_sparr.pbasep^.sbase.bmaxcol) AND
          (a_returncode = 0)) DO
        BEGIN (* scan table fields in physical record order *)
        ak56one_value (acv, dmli, dfa);
        WITH d_colbuf^ DO
            BEGIN
            IF  ccolstack.etype = st_varkey
            THEN
                a_mblock.mb_data^.mbp_keylen := a_mblock.mb_data_len - cgg_rec_key_offset;
&           IFDEF TRACE
            (*ENDIF*) 
            t01moveobj (ak_sem, a_mblock.mb_data^.mbp_buf, 1,
                  a_mblock.mb_data_len);
&           ENDIF
            IF  cnextind > 0
            THEN
                d_colbuf := a103GetColumn (d_sparr.pbasep^.sbase, cnextind);
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        fieldno := succ(fieldno)
        END;
    (*ENDWHILE*) 
    IF  a_returncode = 0
    THEN
        IF  a_ex_kind = only_parsing
        THEN
            ak56reclen (acv, d_sparr, d_movebefore)
        ELSE
            a_mblock.mb_data^.mbp_reclen := a_mblock.mb_data_len;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  d_sparr.pbasep^.sbase.bnamed_constr > 0
    THEN
        BEGIN
        i := 1;
        WHILE (i <= d_sparr.pbasep^.sbase.bnamed_constr) AND
              (a_returncode = 0) DO
            BEGIN
            IF  a_ex_kind = only_parsing
            THEN
                a56_describe (acv, d_sparr,
                      fp_verify_constraint, d_movebefore, i)
            ELSE
                a05constraint_fulfilled (acv,
                      a_mblock.mb_data^.mbp_rec,
                      d_sparr.pbasep^.sbase.btreeid, i);
            (*ENDIF*) 
            i := i + 1
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        IF  d_sparr.pbasep^.sbase.bindexexist
        THEN
            a54_put_indices_in_mess_buf (acv,
                  d_sparr.pbasep^.sbase, dfa, c_all);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        WITH d_tabarr^[ d_acttabindex ] DO
            IF  oview AND oviewcheck AND oviewqual
            THEN
                BEGIN
                IF  a_ex_kind = only_parsing
                THEN
                    a54_fixedpos (acv, dmli);
                (*ENDIF*) 
                a54_view_put_into (acv, dmli);
                IF  a_ex_kind = only_parsing
                THEN
                    a54_fixedpos (acv, dmli);
                (*ENDIF*) 
                a_mblock.mb_qual^.mqual_pos :=
                      a_mblock.mb_qual^.mview_pos;
                a_mblock.mb_qual^.mqual_cnt :=
                      a_mblock.mb_qual^.mview_cnt;
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    a262add_trigger_info (acv, dmli,
          (acv.a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_length = cak_i_ignore));
    IF  (a_returncode = 0)
        AND
        (a_mblock.mb_qual^.mview_cnt > 0)
    THEN
        IF  a_ex_kind <> only_parsing
        THEN
            BEGIN
            mblock.mb_header       := a_mblock.mb_header;
            mblock.mb_trailer      := a_mblock.mb_trailer;
            mblock.mb_work_st      := a_work_st_addr;
            mblock.mb_work_st_max  := a_work_st_max;
            mblock.mb_workbuf      := a_work_buf_addr;
            mblock.mb_workbuf_size := a_work_buf_size;
            mblock.mb_trns         := @a_transinf.tri_trans;
            a05qualification_test (acv, mblock,
                  NOT c_result_wanted, c_check_new_rec, 1,
                  a_mblock.mb_data^.mbp_rec, buf, sizeof(buf), res_len);
            IF  a_returncode <> 0
            THEN
                a_transinf.tri_trans.trState_gg00 :=
                      mblock.mb_trns^.trState_gg00
            ELSE
                a_mblock.mb_qual^.mview_cnt := 0
            (*ENDIF*) 
            END
        ELSE
            a56_describe (acv, d_sparr, fp_verify_view,
                  d_movebefore, 0)
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a56alloc_linkpos_info (
            VAR acv        : tak_all_command_glob;
            VAR p_arr      : tak_syspointerarr;
            mess_type      : tgg00_MessType;
            VAR linkposbuf : tak_sysbufferaddress);
 
VAR
      b_err        : tgg00_BasisError;
      entry_cnt    : integer;
      i            : integer;
      required_len : integer;
      linkposkey   : tgg00_SysInfoKey;
 
BEGIN
linkposkey := a01defaultkey;
WITH linkposkey DO
    BEGIN
    stableid  := p_arr.pbasep^.sbase.btreeid.fileTabId_gg00;
    sentrytyp := cak_elinkpos
    END;
(*ENDWITH*) 
IF  mess_type = m_update
THEN
    entry_cnt := p_arr.pbasep^.sbase.bmaxcol * 2
ELSE
    entry_cnt := p_arr.pbasep^.sbase.bmaxcol;
(*ENDIF*) 
required_len := sizeof (tak_linkinforecord) - sizeof (tak_linkposinfo)
      + entry_cnt * 4;
a10_nil_get_sysinfo (acv, linkposkey, d_fix, required_len,
      linkposbuf, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    IF  acv.a_mblock.mb_qual^.mfirst_free = 1
    THEN
        acv.a_mblock.mb_qual_len  := acv.a_mblock.mb_qual_len  +
              sizeof(tgg00_FileId);
    (*ENDIF*) 
    linkposbuf^.slinkposinfo.lfullen       := linkposbuf^.slinkposinfo.lreclen;
    linkposbuf^.slinkposinfo.lmess_type    := mess_type;
    linkposbuf^.slinkposinfo.lunique_cnt   := 0;
    linkposbuf^.slinkposinfo.lprim_check   := false;
    FOR i := 1 TO entry_cnt DO
        linkposbuf^.slinkposinfo.lpos_info[ i ].lpos :=
              cak_is_undefined;
    (*ENDFOR*) 
    linkposbuf^.slinkposinfo.lupd_col_info := [  ];
    linkposbuf^.slinkposinfo.lnot_used     := [  ]
    END
ELSE
    a07_b_put_error (acv, b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a56insert_upd_with_link (
            VAR acv        : tak_all_command_glob;
            VAR linkposbuf  : tak_sysbufferaddress);
 
VAR
      b_err            : tgg00_BasisError;
      casc             : boolean;
      ok               : boolean;
      link_index       : integer;
      curr_index       : integer;
      j                : integer;
      seqno            : integer;
      extno            : integer;
      link_count       : integer;
      offset           : integer;
      sa_level_pars_id : integer;
      mblock_ptr       : tak_sysbufferaddress;
      valuebuf         : tak_sysbufferaddress;
      lbuf             : tak_sysbufferaddress;
      linkkey          : tgg00_SysInfoKey;
      valuekey         : tgg00_SysInfoKey;
      pars_ptr         : tak_sysbufferaddress;
      index_tree       : tgg00_FileId;
      ins_schema       : tsp00_KnlIdentifier;
      ins_tablen       : tsp00_KnlIdentifier;
      linkname         : tsp00_KnlIdentifier;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    a06_systable_get (acv, d_release,
          linkposbuf^.syskey.stableid, pars_ptr, NOT c_all, ok);
    IF  ok
    THEN
        BEGIN
        ins_tablen := pars_ptr^.sbase.btablen^;
        a103GetSchemaName (acv, pars_ptr^.sbase.bschema, ins_schema)
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
seqno := 1;
IF  acv.a_returncode = 0
THEN
    BEGIN
&   IFDEF TRACE
    FOR j := 1 TO 255 DO
        IF  chr(j) in linkposbuf^.slinkposinfo.lnot_used
        THEN
            t01int4 (ak_sem, 'not used    ', j);
        (*ENDIF*) 
    (*ENDFOR*) 
    FOR j := 1 TO MAX_COL_PER_TAB_GG00 DO
        IF  j in linkposbuf^.slinkposinfo.lupd_col_info
        THEN
            t01int4 (ak_sem, 'updated     ', j);
&       ENDIF
        (*ENDIF*) 
    (*ENDFOR*) 
    link_index        := 1;
    curr_index        := cak_maxlinkdef + 1;
    sa_level_pars_id  := 1;
    linkkey           := linkposbuf^.syskey;
    linkkey.sentrytyp := cak_eforeignkey;
    linkkey.slinkage  := cak_zero_linkage;
    IF  linkposbuf^.slinkposinfo.lprim_check
    THEN
        link_count := 1
    ELSE
        link_count := 0;
    (*ENDIF*) 
    END;
(*ENDIF*) 
WHILE (acv.a_returncode = 0) AND
      (link_index <= link_count) DO
    BEGIN
    IF  curr_index > cak_maxlinkdef
    THEN
        BEGIN
        curr_index := 1;
        IF  link_index > 1
        THEN
            a10_rel_sysinfo (acv, linkkey);
        (*ENDIF*) 
        a06inc_linkage (linkkey.slinkage);
        a10get_sysinfo (acv, linkkey, d_fix, lbuf, b_err);
        END;
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        WITH acv, a_mblock, mb_qual^ DO
            BEGIN
            IF  link_index = 1
            THEN
                link_count := lbuf^.slink.linkcount;
            (*ENDIF*) 
            IF  NOT (chr(link_index) in
                linkposbuf^.slinkposinfo.lnot_used)
            THEN
                BEGIN
                a06_systable_get (acv, d_fix,
                      lbuf^.slink.linkdef[ curr_index ].ltableid,
                      pars_ptr, NOT c_all, ok);
                IF  NOT ok
                THEN
                    a07ak_system_error (acv, 56, 1)
                ELSE
                    BEGIN
                    a06a_mblock_init (acv, m_get, mm_direct,
                          pars_ptr^.sbase.btreeid);
                    mtree.fileHandling_gg00 := [ hsCollisionTest_egg00 ];
                    WITH lbuf^.slink.linkdef[ curr_index ] DO
                        IF  ord (lindexid[ 1 ]) > 0
                        THEN
                            BEGIN
                            g04index_tree_build (mtree, index_tree,
                                  ord(lindexid[1]));
                            mtree := index_tree;
                            END;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    mcol_pos       := mfirst_free;
                    FOR j := 1 TO
                          lbuf^.slink.linkdef[ curr_index ].lcolcount DO
                        BEGIN
                        extno := lbuf^.slink.linkdef[ curr_index ].lseccolseq[j];
&                       IFDEF TRACE
                        t01int4 (ak_sem, 'extno       ', extno);
&                       ENDIF
                        WITH mb_st^ [mfirst_free],
                             linkposbuf^.slinkposinfo.lpos_info[ extno ] DO
                            BEGIN
                            etype    := st_fixcol;
                            eop      := op_none;
                            epos     := lpos;
                            elen_var := llen;
&                           IFDEF TRACE
                            t01int4 (ak_sem, 'lpos        ', lpos);
                            t01int4 (ak_sem, 'llen        ', llen);
&                           ENDIF
                            END;
                        (*ENDWITH*) 
                        mfirst_free := mfirst_free + 1;
                        mcol_cnt    := mcol_cnt + 1;
                        END;
                    (*ENDFOR*) 
                    WITH mb_st^ [mfirst_free - 1] DO
                        ecol_pos := 0;
                    (*ENDWITH*) 
                    sa_level_pars_id := link_index;
                    REPEAT
                        sa_level_pars_id := succ(sa_level_pars_id)
                    UNTIL
                        NOT (chr(sa_level_pars_id) in
                        linkposbuf^.slinkposinfo.lnot_used);
                    (*ENDREPEAT*) 
                    IF  (sa_level_pars_id > link_count) AND
                        (linkposbuf^.slinkposinfo.lunique_cnt = 0)
                    THEN
                        sa_level_pars_id := 0;
                    (*ENDIF*) 
                    IF  lbuf^.slink.linkdef[ curr_index ].laction =
                        cak_x_set_default
                    THEN
                        BEGIN
                        valuekey           := lbuf^.syskey;
                        valuekey.sentrytyp := cak_elinkdef;
                        a25get_linkname (acv, lbuf, curr_index,
                              valuekey.sidentifier);
                        valuekey.slinkage  := cak_init_linkage;
                        valuekey.skeylen   := mxak_standard_sysk +
                              sizeof (valuekey.sidentifier);
                        a10get_sysinfo (acv, valuekey, d_release,
                              valuebuf, b_err);
                        IF  b_err = e_ok
                        THEN
                            WITH valuebuf^.slinkdefault DO
                                BEGIN
                                a_mblock.mb_data^.mbp_keylen :=
                                      ldefault_len;
                                SAPDB_PascalMove ('VAK56 ',   7,    
                                      sizeof(ldefault_key), a_mblock.mb_data_size,
                                      @ldefault_key,
                                      1, @a_mblock.mb_data^.mbp_buf,
                                      cgg_rec_key_offset+1, ldefault_len,
                                      a_returncode);
                                a_mblock.mb_data_len  := ldefault_len
                                      + cgg_rec_key_offset;
                                END
                            (*ENDWITH*) 
                        ELSE
                            a07_b_put_error (acv, b_err, 1);
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    WITH a_mblock.mb_qual^.mlc_info DO
                        BEGIN
                        mlp_sa_level   := sa_level_pars_id;
                        mlp_lo_level   := 0;
                        mlp_use_fileid := 0;
                        END;
                    (*ENDWITH*) 
                    a25get_linkname (acv, lbuf, curr_index, linkname);
                    a58mess_buf_to_linkparsinfo (acv, seqno,
                          ins_schema, ins_tablen, linkname,
                          mblock_ptr);
                    IF  sa_level_pars_id <> 0
                    THEN
                        seqno := sa_level_pars_id
                    ELSE
                        seqno := seqno + 1;
                    (*ENDIF*) 
                    IF  (acv.a_returncode = 0) AND
                        (a_ex_kind <> only_parsing)
                    THEN
                        a58exec_link_caused_dml (acv, mblock_ptr,
                              0, casc, NOT c_self_ref);
                    (*ENDIF*) 
                    IF  mblock_ptr <> NIL
                    THEN
                        a10key_del (acv, mblock_ptr);
                    (*ENDIF*) 
                    a10_rel_sysinfo (acv, pars_ptr^.syskey)
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    ELSE
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    link_index := succ(link_index);
    curr_index := succ(curr_index)
    END;
(*ENDWHILE*) 
IF  linkposbuf <> NIL
THEN
    BEGIN
&   IFDEF TRACE
    t01int4 (ak_sem, 'lunique_cnt ',
          linkposbuf^.slinkposinfo.lunique_cnt);
&   ENDIF
    IF  linkposbuf^.slinkposinfo.lunique_cnt > 0
    THEN
        BEGIN
        offset := (linkposbuf^.b_sl - cak_sysbufferoffset -
              sizeof (linkposbuf^.slinkposinfo.lupd_col_info) -
              sizeof (linkposbuf^.slinkposinfo.lnot_used) - 4) DIV 4 DIV 2;
        FOR j := 1 TO offset DO
            linkposbuf^.slinkposinfo.lpos_info[ j ] :=
                  linkposbuf^.slinkposinfo.lpos_info[ j+offset ];
        (*ENDFOR*) 
&       IFDEF TRACE
        t01int4 (ak_sem, 'offset      ', offset);
        FOR j := 1 TO offset DO
            IF  linkposbuf^.slinkposinfo.lpos_info[ j ].lpos <>
                cak_is_undefined
            THEN
                t01p2int4 (ak_sem, 'col_no      ', j,
                      'col_pos     ',
                      linkposbuf^.slinkposinfo.lpos_info[ j ].lpos);
&           ENDIF
            (*ENDIF*) 
        (*ENDFOR*) 
        a58update_with_link (acv, linkposbuf^.syskey.stableid,
              linkposbuf^.slinkposinfo.lunique_cnt, sa_level_pars_id);
        END
    ELSE
        a10key_del (acv, linkposbuf)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_ex_kind <> only_parsing
THEN
    BEGIN
    a58destroy_linkfile (acv, 0);
    IF  (acv.a_returncode <> 0) AND (seqno > 1)
    THEN
        acv.a_part_rollback := true
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a56one_default_value (
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info;
            VAR colinfo : tak00_columninfo;
            with_length : tak_fp_kind_type);
 
VAR
      e               : tgg00_BasisError;
      stop            : boolean;
      length_bytes    : integer;
      res             : tsp00_NumError;
      i2c2            : tsp_int_map_c2;
      pos             : integer;
      val_pos         : integer;
      leng            : integer;
      move_len        : integer;
      temp_id         : tsp00_Int4;
      ibuf            : tak_sysbufferaddress;
      ke              : tgg00_SysInfoKey;
      user            : tsp00_KnlIdentifier;
      srccode         : tsp00_Int2;
      destcode        : tsp00_Int2;
      ilen            : integer;
      err_char_no     : tsp00_Int4;
      uni_err         : tsp8_uni_error;
      utcdiff         : tsp00_Longreal;
      utctimestamp    : tsp00_Timestamp;
      num_err         : tsp00_NumError;
 
BEGIN
WITH acv, a_mblock, mb_qual^, mb_data^ DO
    BEGIN
    WITH ke DO
        BEGIN
        sentrytyp       := cak_edefault;
        IF  a_ex_kind = only_executing
        THEN
            BEGIN
            IF  a101_IsExtendedTempFile (acv, mtree) AND
                (a101_GetExtendedTempFileType (acv, mtree) = ttfnTempTable_egg00)
            THEN
                BEGIN
                temp_id   := a101_GetTempFileIndex (acv, mtree);
                sentrytyp := cak_etempdefault
                END
            ELSE
                stableid   := mtree.fileTabId_gg00;
            (*ENDIF*) 
            END
        ELSE
            WITH dmli.d_tabarr^[ dmli.d_acttabindex ] DO
                BEGIN
                IF  (a101_IsExtendedTempFile (acv, otreeid)            AND
                    (a101_GetExtendedTempFileType (acv, otreeid) = ttfnTempTable_egg00))
                THEN
                    BEGIN
                    temp_id   := a101_GetTempFileIndex (acv, otreeid);
                    sentrytyp := cak_etempdefault
                    END
                ELSE
                    BEGIN
                    stableid   := otreeid.fileTabId_gg00;
                    END
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  sentrytyp = cak_etempdefault
        THEN
            BEGIN
            stableid  := cgg_zero_id;
            ssite     := cak_temp_table_site;
            stemp     := temp_id
            END;
        (*ENDIF*) 
        slinkage[1] := chr (colinfo.creccolno DIV 256);
        slinkage[2] := chr (colinfo.creccolno MOD 256);
        skeylen     := mxak_standard_sysk;
        END;
    (*ENDWITH*) 
    a10get_sysinfo (acv, ke, d_release, ibuf, e);
    IF  e = e_ok
    THEN
        WITH colinfo, ccolstack DO
            BEGIN
            (* PTS 1116801 E.Z. *)
            IF  (with_length <> fp_val_all_without_l) AND
                (with_length <> fp_fieldlist)
            THEN
                IF  (etype = st_varlongchar) OR
                    (etype = st_column)
                THEN
                    length_bytes := 2
                ELSE
                    IF  (etype = st_varcol) OR
                        (with_length = fp_val_all_with_len)
                    THEN
                        length_bytes := 1
                    ELSE
                        length_bytes := 0
                    (*ENDIF*) 
                (*ENDIF*) 
            ELSE
                length_bytes := 0;
            (*ENDIF*) 
            mb_data_len := mb_data_len + length_bytes;
            IF  a_ex_kind = only_parsing
            THEN
                dmli.d_movebefore := dmli.d_movebefore + length_bytes;
            (*ENDIF*) 
            IF  ibuf^.sdefault.dfdefault_function <> 0
            THEN
                BEGIN
                (* default date, time, timestamp,
                      uid, user, usergroup, true, false, stamp *)
                CASE ibuf^.sdefault.dfdefault_function OF
                    cak_x_date :
                        leng := mxsp_date + 1;
                    cak_x_time :
                        leng := mxsp_time + 1;
                    cak_x_timestamp,
                    (* PTS 1122484 E.Z. *)
                    cak_x_utcdate :
                        leng := mxsp_timestamp + 1;
                    cak_x_uid :
                        leng := colinfo.cinoutlen;
                    cak_x_user, cak_x_usergroup,
                    (* PTS 1122484 E.Z. *)
                    cak_x_sysdba :
                        IF  colinfo.cdatalen < sizeof (tak_oldidentifier)
                        THEN
                            leng := colinfo.cdatalen
                        ELSE
                            leng := sizeof (tsp00_KnlIdentifier);
                        (*ENDIF*) 
                    cak_x_true, cak_x_false :
                        leng := 2;
                    cak_x_transaction :
                        WITH acv.a_transinf.tri_trans DO
                            leng := 1 + sizeof(trTransId_gg00);
                        (*ENDWITH*) 
                    (* PTS 1122484 E.Z. *)
                    cak_x_utcdiff :
                        leng := (cak_utcdiff_len + 1) DIV 2 + 2;
                    cak_x_timezone :
                        leng := (cak_time_durationlen + 1) DIV 2 + 2;
                    OTHERWISE:
                        leng := SURROGATE_MXGG00 + 1;
                    END;
                (*ENDCASE*) 
                IF  (mb_data_len + dmli.d_maxlen + leng > mb_data_size) OR
                    (
                    (leng < cinoutlen)                   AND
                    (with_length <> fp_val_all_with_len) AND
                    (etype in [ st_fixkey, st_fixcol ])  AND
                    (mb_data_len + dmli.d_maxlen + cinoutlen > mb_data_size)
                    )
                THEN
                    a07_b_put_error (acv, e_too_many_mb_data,
                          -mb_data_size)
                ELSE
                    IF  (mb_type = m_insert) AND
                        (mb_data_len + leng > MAX_RECLEN_GG00)
                    THEN
                        a07_b_put_error (acv, e_too_long_record,
                              -MAX_RECLEN_GG00)
                    ELSE
                        BEGIN
                        val_pos := mb_data_len + 1;
                        CASE cdatatyp OF
                            dcha, ddate, dtime, dtimestamp :
                                mbp_buf[ mb_data_len+1 ] := csp_ascii_blank;
                            dunicode :
                                mbp_buf[ mb_data_len+1 ] := csp_unicode_def_byte;
                            OTHERWISE
                                mbp_buf[ mb_data_len+1 ] := csp_defined_byte;
                            END;
                        (*ENDCASE*) 
                        (* PTS 1122484 E.Z. *)
                        IF  (ibuf^.sdefault.dfdefault_function = cak_x_stamp) AND
                            (a_mblock.mb_type = m_insert_select)
                        THEN
                            BEGIN
                            mb_st^ [mfirst_free-1].etype    := st_op;
                            mb_st^ [mfirst_free-1].eop      := op_stamp;
                            mb_st^ [mfirst_free-1].epos     := 0;
                            mb_st^ [mfirst_free-1].elen_var := 0;
                            mb_st^ [mfirst_free-1].ecol_pos := 0;
                            mb_data_len := mb_data_len - length_bytes;
                            dmli.d_movebefore := dmli.d_movebefore
                                  - length_bytes;
                            length_bytes := 0;
                            END
                        ELSE
                            IF  (ibuf^.sdefault.dfdefault_function = cak_x_stamp) AND
                                (a_mblock.mb_type = m_update)
                            THEN
                                (* return_code will be *)
                                (* changed to 0 again. *)
                                (* an expression update*)
                                (* with stamp will be  *)
                                (* build               *)
                                a07_b_put_error (acv,
                                      e_default_spec_not_allowed, 1)
                            ELSE
                                CASE ibuf^.sdefault.dfdefault_function OF
                                    cak_x_user, cak_x_usergroup,
                                    cak_x_sysdba :
                                        BEGIN
                                        IF  ibuf^.sdefault.dfdefault_function = cak_x_user
                                        THEN
                                            user := a_acc_user
                                        ELSE
                                            IF  ibuf^.sdefault.dfdefault_function = cak_x_usergroup
                                            THEN
                                                user := a_curr_user_name
                                            ELSE
                                                user := g01glob.sysuser_name;
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                        IF  colinfo.cdatalen < sizeof (user)
                                        THEN
                                            move_len := colinfo.cdatalen
                                        ELSE
                                            move_len := sizeof (user);
                                        (*ENDIF*) 
                                        (* PTS 1001522 E.Z. *)
                                        (* PTS 1116801 E.Z. *)
                                        IF  (etype = st_column) OR
                                            (etype = st_varcol) OR
                                            (etype = st_varkey) OR
                                            (etype = st_varlongchar)
                                        THEN
                                            BEGIN
                                            IF  g01unicode
                                            THEN
                                                move_len := s30unilnr (@user, csp_unicode_blank,
                                                      1, move_len)
                                            ELSE
                                                BEGIN
                                                stop := false;
                                                WHILE NOT stop DO
                                                    IF  move_len = 0
                                                    THEN
                                                     stop := true
                                                    ELSE
                                                     IF  user[ move_len ] <> bsp_c1
                                                     THEN
                                                      stop := true
                                                     ELSE
                                                      move_len := pred(move_len);
                                                     (*ENDIF*) 
                                                    (*ENDIF*) 
                                                (*ENDWHILE*) 
                                                END;
                                            (*ENDIF*) 
                                            END;
                                        (*ENDIF*) 
                                        IF  (g01unicode AND
                                            (cdatatyp = dcha))
                                            OR
                                            (NOT g01unicode AND
                                            (cdatatyp = dunicode))
                                        THEN
                                            BEGIN
                                            IF  (cdatatyp = dcha)
                                            THEN
                                                BEGIN
                                                srccode  := csp_unicode;
                                                destcode := csp_ascii;
                                                END
                                            ELSE
                                                BEGIN
                                                srccode  := csp_ascii;
                                                destcode := csp_unicode;
                                                END;
                                            (*ENDIF*) 
                                            ilen := move_len;
                                            move_len := sizeof(tsp00_KnlIdentifier);
                                            s80uni_trans (@user[ 1 ], ilen, srccode,
                                                  @mbp_buf[ mb_data_len+2 ],
                                                  move_len, destcode,
                                                  [ ], uni_err, err_char_no);
                                            IF  uni_err <> uni_ok
                                            THEN
                                                IF  uni_err = uni_not_translatable
                                                THEN
                                                    a07_b_put_error (acv,
                                                       e_const_incompatible_with_typ, 1)
                                                ELSE
                                                    a07_uni_error (acv, uni_err,
                                                       err_char_no)
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                            END
                                        ELSE
                                            SAPDB_PascalMove ('VAK56 ',   8,    
                                                  sizeof(user), mb_data_size, @user, 1,
                                                  @mbp_buf, mb_data_len+2, move_len,
                                                  a_returncode);
                                        (*ENDIF*) 
                                        leng := move_len + 1;
                                        IF  a_ex_kind = only_parsing
                                        THEN
                                            dmli.d_movebefore :=
                                                  dmli.d_movebefore + leng;
                                        (*ENDIF*) 
                                        END;
                                    cak_x_uid :
                                        BEGIN
                                        s41plint (mbp_buf, mb_data_len + 2, colinfo.cdatalen,
                                              colinfo.cdatafrac - 1,
                                              a06uid (a_acc_user_id), res);
                                        (* PTS 1001522 E.Z. *)
                                        IF  (etype = st_column) OR
                                            (etype = st_varcol) OR
                                            (etype = st_varkey) OR
                                            (etype = st_varlongchar)
                                        THEN
                                            BEGIN
                                            pos := val_pos + leng - 1;
                                            WHILE mbp_buf[pos] = chr(0) DO
                                                BEGIN
                                                pos  := pos - 1;
                                                leng := leng - 1
                                                END;
                                            (*ENDWHILE*) 
                                            END;
                                        (*ENDIF*) 
                                        IF  a_ex_kind = only_parsing
                                        THEN
                                            dmli.d_movebefore :=
                                                  dmli.d_movebefore + leng;
                                        (*ENDIF*) 
                                        END;
                                    cak_x_true,  cak_x_false :
                                        BEGIN (* default TRUE, FALSE *)
                                        IF  ibuf^.sdefault.dfdefault_function = cak_x_true
                                        THEN
                                            mbp_buf[ mb_data_len + 2 ] := cgg04_truechar
                                        ELSE
                                            mbp_buf[ mb_data_len + 2 ] := cgg04_falsechar;
                                        (*ENDIF*) 
                                        IF  a_ex_kind = only_parsing
                                        THEN
                                            dmli.d_movebefore :=
                                                  dmli.d_movebefore + leng;
                                        (*ENDIF*) 
                                        END;
                                    OTHERWISE
                                        IF  a_ex_kind = only_parsing
                                        THEN
                                            WITH a_ap_tree^[ 0 ] DO
                                                BEGIN
                                                CASE ibuf^.sdefault.dfdefault_function OF
                                                    cak_x_date :
                                                     n_symb := s_date;
                                                    cak_x_time :
                                                     n_symb := s_time;
                                                    cak_x_timestamp :
                                                     n_symb := s_timestamp;
                                                    cak_x_stamp :
                                                     n_symb := s_stamp;
                                                    cak_x_transaction :
                                                     n_symb := s_transaction;
                                                    (* PTS 1122484 E.Z. *)
                                                    cak_x_utcdate :
                                                     n_symb := s_utcdate;
                                                    cak_x_utcdiff :
                                                     n_symb := s_utcdiff;
                                                    cak_x_timezone :
                                                     n_symb := s_timezone;
                                                    END;
                                                (*ENDCASE*) 
                                                mb_data_len := mb_data_len - length_bytes;
                                                dmli.d_movebefore := dmli.d_movebefore
                                                      - length_bytes;
                                                length_bytes := 0;
                                                a55_describe_value (acv, dmli,
                                                      colinfo, 0, 0, c_in_datapart);
                                                leng := 0;
                                                END
                                            (*ENDWITH*) 
                                        ELSE
                                            CASE ibuf^.sdefault.dfdefault_function OF
                                                cak_x_stamp :
                                                    a05_stamp_get (acv,
                                                       mbp_buf, mb_data_len+2,
                                                       mb_data_size);
                                                cak_x_transaction :
                                                    a05_transaction_get (acv,
                                                       mbp_buf, mb_data_len+2,
                                                       mb_data_size);
                                                (* PTS 1122484 E.Z. *)
                                                cak_x_utcdate :
                                                    BEGIN
                                                    vUTCtimestamp (utctimestamp);
                                                    SAPDB_PascalMove('VAK56 ',   9,    
                                                       sizeof(utctimestamp),
                                                       mb_data_size,
                                                       @utctimestamp, 1,
                                                       @mbp_buf, mb_data_len+2,
                                                       mxsp_timestamp,
                                                       a_returncode);
                                                    END;
                                                cak_x_utcdiff :
                                                    BEGIN
                                                    utcdiff := vTimeZoneDelta;
                                                    s41plrel (mbp_buf, mb_data_len+2, cak_utcdiff_len, cak_utcdiff_frac,
                                                       utcdiff, num_err);
                                                    IF  (num_err <> num_ok)
                                                    THEN
                                                     CASE num_err OF
                                                      num_invalid :
                                                       a07_b_put_error (acv,
                                                          e_num_invalid, 1);
                                                      num_trunc :
                                                       a07_b_put_error (acv,
                                                          e_num_truncated, 1);
                                                      num_overflow :
                                                       a07_b_put_error (acv,
                                                          e_num_overflow, 1);
                                                      END
                                                     (*ENDCASE*) 
                                                    (*ENDIF*) 
                                                    END;
                                                cak_x_timezone :
                                                    BEGIN
                                                    utcdiff := vTimeZoneDelta;
                                                    (* from fixed (4,2) example 8,5 --> duration example 083000 *)
                                                    utcdiff := trunc(utcdiff) * 10000 +
                                                       (utcdiff - trunc(utcdiff)) * 6000;
                                                    s41plrel (mbp_buf, mb_data_len+2, cdatalen, 0, utcdiff, num_err);
                                                    IF  (num_err <> num_ok)
                                                    THEN
                                                     CASE num_err OF
                                                      num_invalid :
                                                       a07_b_put_error (acv,
                                                          e_num_invalid, 1);
                                                      num_trunc :
                                                       a07_b_put_error (acv,
                                                          e_num_truncated, 1);
                                                      num_overflow :
                                                       a07_b_put_error (acv,
                                                          e_num_overflow, 1);
                                                      END
                                                     (*ENDCASE*) 
                                                    (*ENDIF*) 
                                                    END;
                                                cak_x_timestamp:
                                                    BEGIN
                                                    IF  a_timestamp = bsp_c20
                                                    THEN
                                                     vtimestamp(a_timestamp);
                                                    (*ENDIF*) 
                                                    SAPDB_PascalMove('VAK56 ',  10,    
                                                       sizeof(a_timestamp),
                                                       mb_data_size,
                                                       @a_timestamp, 1,
                                                       @mbp_buf, mb_data_len+2,
                                                       mxsp_timestamp,
                                                       a_returncode);
                                                    END;
                                                OTHERWISE
                                                    BEGIN
                                                    IF  a_timestamp = bsp_c20
                                                    THEN
                                                     vtimestamp (a_timestamp);
                                                    (*ENDIF*) 
                                                    IF  ibuf^.sdefault.dfdefault_function =
                                                     cak_x_time
                                                    THEN
                                                     BEGIN
                                                     mbp_buf[ mb_data_len+2 ] := '0';
                                                     mbp_buf[ mb_data_len+3 ] := '0';
                                                     SAPDB_PascalMove ('VAK56 ',  11,    
                                                        sizeof(a_timestamp),
                                                        mb_data_size,
                                                        @a_timestamp, mxsp_date+1,
                                                        @mbp_buf, mb_data_len+4, 6,
                                                        a_returncode);
                                                     END
                                                    ELSE
                                                     SAPDB_PascalMove ('VAK56 ',  12,    
                                                        sizeof(a_timestamp),
                                                        mb_data_size,
                                                        @a_timestamp, 1,
                                                        @mbp_buf, mb_data_len+2,
                                                        mxsp_date,
                                                        a_returncode);
                                                    (*ENDIF*) 
                                                    END;
                                                END
                                            (*ENDCASE*) 
                                        (*ENDIF*) 
                                    END;
                                (*ENDCASE*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                        IF  ((leng > 0) AND (leng < cinoutlen)
                            AND (with_length <> fp_val_all_with_len)
                            AND (etype in [ st_fixkey, st_fixcol ]))
                        THEN
                            BEGIN
                            IF  mbp_buf[ mb_data_len+1 ] =
                                csp_unicode_def_byte
                            THEN
                                SAPDB_PascalUnicodeFill ('VAK56 ',  13,    
                                      mb_data_size,
                                      @mbp_buf, mb_data_len+1+leng,
                                      cinoutlen-leng, csp_unicode_blank,
                                      a_returncode)
                            ELSE
                                SAPDB_PascalFill ('VAK56 ',  14,    
                                      mb_data_size, @mbp_buf, mb_data_len+1+leng,
                                      cinoutlen-leng, mbp_buf[ mb_data_len+1 ],
                                      a_returncode);
                            (*ENDIF*) 
                            IF  a_ex_kind = only_parsing
                            THEN
                                dmli.d_movebefore :=
                                      dmli.d_movebefore + cinoutlen - leng;
                            (*ENDIF*) 
                            leng := cinoutlen
                            END;
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                BEGIN (* no default function, default value *)
                leng := a14LengthOfDefaultValue (ibuf^.sdefault) (* PTS 1108428 *);
                IF  (etype = st_varcol     ) OR
                    (etype = st_varkey     ) OR
                    (etype = st_varlongchar)
                THEN
                    leng := s30lnr_defbyte (@ibuf^.sdefault.dfvalues,
                          ibuf^.sdefault.dfvalues[ 2 ], 3, leng-1)+1;
                (*ENDIF*) 
                IF  (mb_data_len + dmli.d_maxlen + leng > mb_data_size) OR
                    ((leng < cinoutlen)
                    AND (with_length <> fp_val_all_with_len)
                    AND (etype in [ st_fixkey, st_fixcol ]) AND
                    (mb_data_len + dmli.d_maxlen + cinoutlen > mb_data_size))
                THEN
                    a07_b_put_error (acv, e_too_many_mb_data, -mb_data_size)
                ELSE
                    IF  (mb_type = m_insert) AND
                        (mb_data_len + leng > MAX_RECLEN_GG00)
                    THEN
                        a07_b_put_error (acv, e_too_long_record,
                              -MAX_RECLEN_GG00)
                    ELSE
                        BEGIN
                        CASE etype OF
                            st_fixkey, st_fixcol :
                                BEGIN
                                SAPDB_PascalMove ('VAK56 ',  15,    
                                      sizeof(ibuf^.sdefault.dfvalues),
                                      mb_data_size,
                                      @ibuf^.sdefault.dfvalues, 2,
                                      @mbp_buf, mb_data_len+1, leng,
                                      a_returncode);
                                IF  (leng < cinoutlen) AND
                                    (with_length <> fp_val_all_with_len)
                                THEN
                                    BEGIN
                                    IF  mbp_buf[ mb_data_len+1 ] =
                                        csp_unicode_def_byte
                                    THEN
                                        SAPDB_PascalUnicodeFill ('VAK56 ',  16,    
                                              mb_data_size,
                                              @mbp_buf, mb_data_len+1+leng,
                                              cinoutlen-leng, csp_unicode_blank,
                                              a_returncode)
                                    ELSE
                                        SAPDB_PascalFill ('VAK56 ',  17,    
                                              mb_data_size, @mbp_buf,
                                              mb_data_len+1+leng,
                                              cinoutlen-leng, mbp_buf[ mb_data_len+1 ],
                                              a_returncode);
                                    (*ENDIF*) 
                                    leng := cinoutlen
                                    END;
                                (*ENDIF*) 
                                END;
                            st_column, st_varkey, st_varcol, st_varlongchar :
                                BEGIN
                                SAPDB_PascalMove ('VAK56 ',  18,    
                                      sizeof(ibuf^.sdefault.dfvalues),
                                      mb_data_size, @ibuf^.sdefault.dfvalues,
                                      2, @mbp_buf, mb_data_len+1, leng,
                                      a_returncode);
                                END;
                            END;
                        (*ENDCASE*) 
                        IF  a_ex_kind = only_parsing
                        THEN
                            dmli.d_movebefore := dmli.d_movebefore + leng
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  acv.a_returncode = 0
            THEN
                IF  length_bytes = 1
                THEN
                    mbp_buf[ mb_data_len ] := chr(leng)
                ELSE
                    IF  length_bytes = 2
                    THEN
                        BEGIN
                        i2c2.map_int  := leng;
                        mbp_buf[ mb_data_len-1 ] := i2c2.map_c2[ 1 ];
                        mbp_buf[ mb_data_len   ] := i2c2.map_c2[ 2 ];
                        END
                    ELSE
                        IF  with_length = fp_fieldlist
                        THEN
                            mbp_rec.columnoffset_gg00 [ecolno + 1] :=
                                  a_mblock.mb_data_len + leng - RSN_RECHEAD_MXGG00;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            ;
            mb_data_len := mb_data_len+leng;
            IF  cdatatyp in [ dstra, dstrb, dstruni,
                dlonga, dlongb, dlonguni ]
            THEN
                ak56default_longlit (acv, dmli, colinfo, ibuf^.sdefault)
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    ELSE
        IF  e = e_sysinfo_not_found
        THEN
            a07_b_put_error (acv, e_old_fileversion, 1)
        ELSE
            a07_b_put_error (acv, e,
                  a_cmd_part^.sp1p_buf_len);
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a56put_link_info (
            VAR acv            : tak_all_command_glob;
            base_ptr           : tak_sysbufferaddress;
            not_used_links     : tak_charset;
            viewqualbuf        : tak_sysbufferaddress;
            VAR linkposbuf     : tak_sysbufferaddress);
      (*=============================================================*)
      (* not_used_links is no VAR parameter because it may           *)
      (* be changed in this procedure and not_used_links corresponds *)
      (* with the component vtnot_used_links of the tviewqual record *)
      (* in some cases. If not_used_links would be a VAR parameter   *)
      (* the catalog would be changed in the user cache              *)
      (*=============================================================*)
 
VAR
      b_err           : tgg00_BasisError;
      link_found      : boolean;
      unique_pk_check : boolean;
      link_check      : boolean;
      key_update      : boolean;
      extno           : integer;
      pos             : integer;
      init_first_free : integer;
      link_index      : integer;
      curr_index      : integer;
      j               : integer;
      linkcnt         : integer;
      loop_cnt        : integer;
      offset          : integer;
      key_index       : integer;
      linkbuf         : tak_sysbufferaddress;
      colset          : tak_columnset;
      not_used_fk     : tak_charset;
      upd_key_cols    : tak_columnset;
      linkkey         : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
&   IFDEF TRACE
    t01messblock (ak_sem, 'put_link_in1', a_mblock);
&   ENDIF
    colset          := [  ];
    not_used_fk     := [  ];
    link_found      := false;
    init_first_free := a_mblock.mb_qual^.mfirst_free;
    key_update := false;
    IF  (a_mblock.mb_type = m_update) AND
        (is_primary_table in base_ptr^.sbase.blinkexist)
    THEN
        BEGIN
        upd_key_cols := [];
        key_index    := base_ptr^.sbase.bfirstcolind;
        j := 1;
        WHILE j <= base_ptr^.sbase.bkeycolcount DO
            WITH a103GetColumn (base_ptr^.sbase, key_index)^ DO
                BEGIN
                IF  creccolno in
                    linkposbuf^.slinkposinfo.lupd_col_info
                THEN
                    BEGIN
                    key_update   := true;
                    upd_key_cols := upd_key_cols + [creccolno];
                    j            := csp_maxint2
                    END;
                (*ENDIF*) 
                key_index := cnextind;
                j         := j + 1
                END;
            (*ENDWITH*) 
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    unique_pk_check := (unique_pk_table in
          base_ptr^.sbase.blinkexist) AND
          (a_mblock.mb_type = m_update);
&   ifdef trace
    t01int4 (ak_sem, 'key_update  ', ord (key_update));
    t01int4 (ak_sem, 'unique_pk_ta', ord (unique_pk_check));
&   endif
    a_mblock.mb_qual^.mlink_pos := a_mblock.mb_qual^.mfirst_free;
    a_mblock.mb_qual^.mlink_cnt := 0;
    pos     := cgg_rec_key_offset + 1;
    linkkey := linkposbuf^.syskey;
    IF  is_secondary_table in
        base_ptr^.sbase.blinkexist
    THEN
        linkkey.sentrytyp := cak_eforeignkey
    ELSE
        linkkey.sentrytyp := cak_eprimarykey;
    (*ENDIF*) 
    linkkey.slinkage  := cak_zero_linkage;
    offset            := 0;
    IF  (unique_pk_check OR key_update)
        AND
        (linkkey.sentrytyp = cak_eforeignkey)
    THEN
        loop_cnt := 2
    ELSE
        BEGIN
        loop_cnt := 1;
        IF  linkkey.sentrytyp <> cak_eforeignkey
        THEN
            BEGIN
            not_used_links := [  ];
            offset         := base_ptr^.sbase.bmaxcol
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    REPEAT
        loop_cnt   := loop_cnt - 1;
&       IFDEF TRACE
        t01int4 (ak_sem, 'loop_cnt    ', loop_cnt);
&       ENDIF
        link_index := 0;
        curr_index := cak_maxlinkdef;
        linkcnt := 0;
        REPEAT
            link_index := succ(link_index);
            curr_index := succ(curr_index);
            IF  curr_index > cak_maxlinkdef
            THEN
                BEGIN
                curr_index := 1;
                a06inc_linkage (linkkey.slinkage);
                a10get_sysinfo (acv, linkkey,
                      d_release, linkbuf, b_err)
                END;
            (*ENDIF*) 
            IF  b_err = e_ok
            THEN
                WITH linkbuf^.slink, linkdef[ curr_index ],
                     a_mblock, mb_qual^ DO
                    BEGIN
                    IF  link_index = 1
                    THEN
                        linkcnt := linkcount;
                    (*ENDIF*) 
                    IF  unique_pk_check AND
                        NOT key_update  AND (loop_cnt = 0)
                    THEN
                        IF  lindexid[ 1 ] = chr(0)
                        THEN
                            not_used_links := not_used_links +
                                  [ link_index ];
&                       IFDEF TRACE
                        (*ENDIF*) 
                    (*ENDIF*) 
                    t01int4 (ak_sem, 'lindexid    ', ord (lindexid[ 1 ]));
                    t01int4 (ak_sem, 'lunique_cnt ',
                          linkposbuf^.slinkposinfo.lunique_cnt);
&                   ENDIF
                    IF  NOT (chr(link_index) in not_used_links)
                    THEN
                        BEGIN
                        link_check := false;
&                       IFDEF TRACE
                        FOR j := 1 TO MAX_COL_PER_TAB_GG00 DO
                            IF  j in
                                linkposbuf^.slinkposinfo.lupd_col_info
                            THEN
                                t01int4 (ak_sem, 'updated     ', j);
&                           ENDIF
                            (*ENDIF*) 
                        (*ENDFOR*) 
                        j          := 1;
                        WHILE (j <= lcolcount) AND NOT (link_check) DO
                            BEGIN
                            IF  linkbuf^.syskey.sentrytyp = cak_eforeignkey
                            THEN
                                extno := lseccolseq[j]
                            ELSE
                                extno := lprimcolseq[j];
                            (*ENDIF*) 
&                           IFDEF TRACE
                            t01int4 (ak_sem, 'test_column ', extno);
&                           ENDIF
                            IF  extno in
                                linkposbuf^.slinkposinfo.lupd_col_info
                            THEN
                                link_check := true;
                            (*ENDIF*) 
                            IF  link_check
                                AND
                                (lindexid[1] = chr(0))
                                AND
                                key_update
                                AND
                                (loop_cnt = 0)
                            THEN
                                IF  NOT (extno IN upd_key_cols)
                                THEN
                                    link_check := false;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            j := succ(j)
                            END;
                        (*ENDWHILE*) 
&                       IFDEF TRACE
                        t01int4 (ak_sem,
                              'link_check  ', ord(link_check));
&                       ENDIF
                        IF  NOT link_check
                        THEN
                            not_used_links :=
                                  not_used_links + [ link_index ];
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  (viewqualbuf <> NIL) AND
                        key_update           AND
                        (linkkey.sentrytyp = cak_eprimarykey)
                    THEN
                        BEGIN
                        (* called in the course of an *)
                        (* join view insert/update    *)
                        j := 1;
                        WITH viewqualbuf^.sviewqual_basis DO
                            WHILE j <= vbasetabcnt DO
                                IF  vtable[j].vttableid = ltableid
                                THEN
                                    BEGIN
                                    not_used_links :=
                                          not_used_links + [ link_index ];
                                    j := vbasetabcnt + 1
                                    END
                                ELSE
                                    j := j + 1
                                (*ENDIF*) 
                            (*ENDWHILE*) 
                        (*ENDWITH*) 
                        END;
                    (*ENDIF*) 
                    IF  NOT (chr(link_index) in not_used_links)
                    THEN
                        link_found := true;
&                   IFDEF TRACE
                    (*ENDIF*) 
                    IF  chr(link_index) in not_used_links
                    THEN
                        t01int4 (ak_sem, 'link_not_use', link_index);
&                   ENDIF
                    (*ENDIF*) 
                    IF  NOT (chr(link_index) in not_used_links)
                    THEN
                        BEGIN
                        IF  (unique_pk_check OR key_update)
                            AND
                            (loop_cnt = 0)
                        THEN
                            WITH linkposbuf^.slinkposinfo DO
                                lunique_cnt := lunique_cnt + 1;
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        FOR j := 1 TO lcolcount DO
                            BEGIN
                            IF  linkkey.sentrytyp = cak_eforeignkey
                            THEN
                                extno := lseccolseq[j]
                            ELSE
                                extno := lprimcolseq[j];
                            (*ENDIF*) 
                            IF  NOT (extno in colset) AND
                                (a_returncode = 0)
                            THEN
                                BEGIN
                                mb_st^ [mfirst_free] := lstack[ j ];
                                IF  linkkey.sentrytyp = cak_eforeignkey
                                THEN
                                    BEGIN
                                    linkposbuf^.slinkposinfo.lprim_check := true;
                                    mb_st^ [mfirst_free].eop_new_rec := true
                                    END
                                ELSE
                                    mb_st^ [mfirst_free].eop_new_rec := false;
                                (*ENDIF*) 
                                colset := colset + [ extno ];
                                mlink_cnt   := mlink_cnt + 1;
                                mfirst_free := mfirst_free + 1;
&                               IFDEF TRACE
                                t01int4 (ak_sem,
                                      'extcolno    ', extno);
                                t01int4 (ak_sem,
                                      'extcol+offst', extno + offset);
&                               ENDIF
                                WITH linkposbuf^.slinkposinfo.
                                     lpos_info[ extno + offset ] DO
                                    BEGIN
                                    lpos := pos;
                                    llen := lstack[ j ].elen_var;
&                                   IFDEF TRACE
                                    t01int4 (ak_sem, 'lpos        ', lpos);
                                    t01int4 (ak_sem, 'lpos        ', llen);
&                                   ENDIF
                                    pos  := pos + llen
                                    END;
                                (*ENDWITH*) 
                                IF  mfirst_free > mb_st_max
                                THEN
                                    a07_b_put_error (acv, e_buffer_limit, 1);
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDFOR*) 
                        END;
                    (*ENDIF*) 
                    END
                (*ENDWITH*) 
            ELSE
                a07_b_put_error (acv, b_err, 1);
            (*ENDIF*) 
        UNTIL
            (link_index >= linkcnt) OR (a_returncode <> 0);
        (*ENDREPEAT*) 
        IF  linkkey.sentrytyp = cak_eforeignkey
        THEN
            not_used_fk := not_used_links;
        (*ENDIF*) 
        IF  unique_pk_check OR key_update
        THEN
            BEGIN
            not_used_links    := [  ];
            colset            := [  ];
            linkkey.sentrytyp := cak_eprimarykey;
            linkkey.slinkage  := cak_zero_linkage;
            offset            := base_ptr^.sbase.bmaxcol;
&           IFDEF TRACE
            t01int4 (ak_sem, 'offset      ', offset);
&           ENDIF
            END;
        (*ENDIF*) 
    UNTIL
        loop_cnt <= 0;
    (*ENDREPEAT*) 
    IF  NOT (link_found)
    THEN
        BEGIN
        a_mblock.mb_qual^.mlink_cnt   := 0;
        a_mblock.mb_qual^.mfirst_free := init_first_free;
        a10key_del (acv, linkposbuf)
        END
    ELSE
        BEGIN
        a58link_fn_to_messbuf (acv, 0);
        a_mblock.mb_qual^.mbool := true;
        linkposbuf^.slinkposinfo.lnot_used := not_used_fk
&             IFDEF TRACE
              ;
        IF  (a_mblock.mb_type = m_update) AND
            (unique_pk_table in base_ptr^.sbase.blinkexist)
        THEN
            offset := base_ptr^.sbase.bmaxcol * 2
        ELSE
            offset := base_ptr^.sbase.bmaxcol;
        (*ENDIF*) 
        FOR j := 1 TO offset DO
            IF  linkposbuf^.slinkposinfo.lpos_info[ j ].lpos <>
                cak_is_undefined
            THEN
                t01p2int4 (ak_sem, 'col_no      ', j,
                      'col_pos     ',
                      linkposbuf^.slinkposinfo.lpos_info[ j ].lpos);
&           ENDIF
            (*ENDIF*) 
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
&   IFDEF TRACE
    t01messblock (ak_sem, 'put_link_in2', a_mblock);
&   ENDIF
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a56temp_table_key (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info);
 
BEGIN
IF  acv.a_ex_kind <> only_parsing
THEN
    IF  acv.a_mblock.mb_type = m_insert_select
    THEN
        acv.a_mblock.mb_data^.mbp_info.rb_tempkey := acv.a_temp_tablekey
    ELSE
        BEGIN
        acv.a_mblock.mb_type2 := mm_nil;
        s30surrogate_incr( acv.a_temp_tablekey );
        acv.a_mblock.mb_data^.mbp_buf[ cgg_rec_key_offset + 1 ] := chr( 0 );
        SAPDB_PascalMove ('VAK56 ',  19,    
              sizeof( acv.a_temp_tablekey ), acv.a_mblock.mb_data_size,
              @acv.a_temp_tablekey, 1, @acv.a_mblock.mb_data^.mbp_buf,
              cgg_rec_key_offset + 2,
              sizeof( acv.a_temp_tablekey ),
              acv.a_returncode);
        acv.a_mblock.mb_data^.mbp_keylen  :=
              sizeof( acv.a_temp_tablekey ) + 1;
        acv.a_mblock.mb_data_len  := cgg_rec_key_offset +
              sizeof( acv.a_temp_tablekey ) + 1;
        dmli.d_movebefore := 0;
        dmli.d_maxlen     := 0;
        END
    (*ENDIF*) 
ELSE
    WITH dmli.d_sparr.pparsp^.sparsinfo DO
        BEGIN
        p_cnt_infos := succ( p_cnt_infos );
        WITH p_pars_infos[ p_cnt_infos ] DO
            BEGIN
            fp_kind := fp_temp_table_key;
            IF  acv.a_mblock.mb_type = m_insert_select
            THEN
                BEGIN
                IF  acv.a_mblock.mb_data_len < cgg_rec_key_offset+2+SURROGATE_MXGG00
                THEN
                    BEGIN
                    IF  acv.a_mblock.mb_data_len + dmli.d_maxlen <
                        cgg_rec_key_offset+2+SURROGATE_MXGG00
                    THEN
                        dmli.d_maxlen := cgg_rec_key_offset+2+SURROGATE_MXGG00 -
                              acv.a_mblock.mb_data_len;
                    (*ENDIF*) 
                    a54_fixedpos (acv, dmli);
                    END;
                (*ENDIF*) 
                fp_movebefore_v4  := 0;
                dmli.d_maxlen     := 0;
                dmli.d_movebefore := 0;
                END
            ELSE
                BEGIN
                fp_movebefore_v4 := cgg_rec_key_offset+1;
                acv.a_mblock.mb_data_len  := cgg_rec_key_offset +
                      sizeof (acv.a_temp_tablekey) + 1;
                dmli.d_movebefore := 0;
                dmli.d_maxlen     := 0;
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a56get_longlit (
            VAR acv           : tak_all_command_glob;
            VAR dmli          : tak_dml_info;
            datatyp           : tsp00_DataType;
            dml_node          : tsp00_Int2);
 
BEGIN
WITH acv, dmli, a_ap_tree^[dml_node], d_literalrec^.slongliteral DO
    BEGIN
    IF  (litcolcount < cak_max_litcoldesc)
    THEN
        BEGIN
        litcolcount := succ (litcolcount);
        WITH litcoldesc [ litcolcount ] DO
            BEGIN
            IF  datatyp in [ dlonga, dlongb, dlonguni ]
            THEN
                llwith_shortcol := false
            ELSE
                llwith_shortcol := true;
            (*ENDIF*) 
            IF  a_ap_tree^[dml_node].n_symb = s_parameter_name
            THEN
                llcdatapos := -1
            ELSE
                BEGIN
                llcdatapos := litlen + 1;
                llcdatalen := litsize;
                a05long_literal_get (acv, dml_node, datatyp,
                      litdataptr^, llcdatapos, llcdatalen);
                litlen := litlen + llcdatalen;
                IF  a_ex_kind <> only_parsing
                THEN
                    WITH a_mblock, mb_data^ DO
                        SAPDB_PascalMove ('VAK56 ',  20,    
                              mb_data_size, SURROGATE_MXGG00,
                              @mbp_buf, mb_data_len - SURROGATE_MXGG00 + 1,
                              @llclongid, 1, SURROGATE_MXGG00,
                              a_returncode);
                    (*ENDWITH*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        (*ENDWITH*) 
        END
    ELSE
        a07_b_put_error (acv, e_too_many_columns,
              -litcolcount);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak56default_longlit (
            VAR acv           : tak_all_command_glob;
            VAR dmli          : tak_dml_info;
            VAR colinfo       : tak00_columninfo;
            VAR defaultrec    : tak_defaultrecord);
 
BEGIN
WITH acv, dmli, d_literalrec^.slongliteral DO
    BEGIN
    IF  (litcolcount < cak_max_litcoldesc)
    THEN
        BEGIN
        (* compare litcolcount-handling in ak506long_support *)
        IF  a_ex_kind <> only_executing
        THEN
            litcolcount := succ (litcolcount);
        (*ENDIF*) 
        WITH litcoldesc [ litcolcount ] DO
            BEGIN
            IF  colinfo.cdatatyp in
                [ dlonga, dlongb, dlonguni ]
            THEN
                llwith_shortcol := false
            ELSE
                llwith_shortcol := true;
            (*ENDIF*) 
            llcdatapos := litlen + 1;
            llcdatalen := a14LengthOfDefaultValue (defaultrec) (* PTS 1108428 *);
            SAPDB_PascalMove ('VAK56 ',  21,    
                  sizeof(defaultrec.dfvalues),
                  litsize, @defaultrec.dfvalues,
                  2, @litdataptr^, llcdatapos,
                  llcdatalen,
                  a_returncode);
            litlen := litlen + llcdatalen;
            IF  a_ex_kind <> only_parsing
            THEN
                WITH a_mblock, mb_data^ DO
                    SAPDB_PascalMove ('VAK56 ',  22,    
                          mb_data_size, SURROGATE_MXGG00,
                          @mbp_buf, mb_data_len - SURROGATE_MXGG00 + 1,
                          @llclongid, 1, SURROGATE_MXGG00,
                          a_returncode);
                (*ENDWITH*) 
            (*ENDIF*) 
            END
        (*ENDWITH*) 
        END
    ELSE
        a07_b_put_error (acv, e_too_many_columns,
              -litcolcount);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a56alloc_longlit_rec (
            VAR acv           : tak_all_command_glob;
            VAR dmli          : tak_dml_info;
            VAR dfa           : tak_dfarr);
 
VAR
      b_err        : tgg00_BasisError;
      litreckey    : tgg00_SysInfoKey;
      required_len : tsp00_Int4;
      totlit_size  : tsp00_Int4;
      totlit_cnt   : tsp00_Int4;
 
BEGIN
WITH dmli DO
    BEGIN
    ak56calc_space_for_longlit_rec (acv, dmli, dfa, totlit_cnt, totlit_size);
    IF  totlit_cnt > 0
    THEN
        BEGIN
        required_len :=
              (* size of literal descripion for all literals *)
              (totlit_cnt * sizeof (tak_litcoldesc)) +
              (* total literal size *)
              totlit_size +
              (* size of tak_longliteral_rec header *)
              (sizeof(tak_longliteral_rec) - sizeof(tak_longlit_buf)) ;
&       ifdef trace
        t01int4 (ak_sem, 'litrec len  ', required_len);
&       endif
        IF  required_len > sizeof (tak_longliteral_rec)
        THEN
            a07_b_put_error (acv, e_command_for_string_not_allow, 1)
        ELSE
            IF  d_sparr.pparsp <> NIL
            THEN
                BEGIN
                litreckey := d_sparr.pparsp^.syskey;
                WITH litreckey DO
                    sentrytyp := cak_elongliteral;
                (*ENDWITH*) 
                a10_nil_get_sysinfo (acv, litreckey, d_fix,
                      required_len, d_literalrec, b_err);
                IF  b_err <> e_ok
                THEN
                    a07_b_put_error (acv, b_err, 1)
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                a10new (acv, required_len, d_literalrec);
                IF  acv.a_returncode = 0
                THEN
                    BEGIN
                    d_literalrec^.slongliteral.litreclen    := required_len;
                    d_literalrec^.slongliteral.litfullen    := required_len;
                    d_literalrec^.slongliteral.litentrytype := cak_edummy;
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            IF  d_sparr.pparsp <> NIL
            THEN
                d_sparr.pparsp^.sparsinfo.p_longliteral := true;
            (*ENDIF*) 
            WITH d_literalrec^.slongliteral, d_sparr.pbasep^.sbase DO
                BEGIN
                littabid := btreeid.fileTabId_gg00;
                litfiller       := 0;
                litfiller1      := 0;
                litcolcount     := 0;
                litlen          := 0;
                litsize         := totlit_size;
                litdataptr      :=
                      @(litdatabuf [totlit_cnt * sizeof(tak_litcoldesc) + 1]);
                END;
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak56calc_space_for_longlit_rec (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            VAR dfa        : tak_dfarr;
            VAR total_cnt  : tsp00_Int4;
            VAR total_size : tsp00_Int4);
 
VAR
      literal_cnt   : integer;
      null_cnt      : integer;
      parameter_cnt : integer;
      col_buf       : tak00_colinfo_ptr;
      fieldno       : integer;
      curr_node     : integer;
      curr_outcol   : integer;
 
BEGIN
WITH acv, dmli, d_sparr DO
    BEGIN
    literal_cnt   := 0;
    null_cnt      := 0;
    parameter_cnt := 0;
    total_cnt     := 0;
    total_size    := 0;
    fieldno       := 1;
    col_buf       := a103GetColumn (pbasep^.sbase, pbasep^.sbase.bfirstcolind);
    WHILE ((fieldno <= pbasep^.sbase.bmaxcol) AND
          (a_returncode = 0)) DO
        BEGIN
        WITH col_buf^, dfa [creccolno] DO
            BEGIN
            IF  dml_node <> 0
            THEN
                BEGIN
                IF  (cdatatyp in [dlonga, dlongb,
                    dlonguni, dstra, dstrb, dstruni])
                THEN
                    BEGIN
                    curr_node := dml_node;
                    IF  acv.a_ap_tree^ [curr_node].n_proc = a63query_spec
                    THEN
                        BEGIN
                        WHILE (acv.a_ap_tree^[curr_node].n_proc <> a60) OR
                              (acv.a_ap_tree^[curr_node].n_subproc <> cak_x_select_column) DO
                            curr_node := acv.a_ap_tree^[curr_node].n_lo_level;
                        (*ENDWHILE*) 
                        curr_outcol := 1;
                        WHILE curr_outcol < dml_colno_in_subquery DO
                            BEGIN
                            curr_node := acv.a_ap_tree^[curr_node].n_sa_level;
                            curr_outcol := succ(curr_outcol);
                            END;
                        (*ENDWHILE*) 
                        curr_node := acv.a_ap_tree^[curr_node].n_lo_level;
                        END;
                    (* PTS 1140703 D.T.
                          IF acv.a_ap_tree^[curr_node].n_symb = s_reference_name
                          THEN
                          curr_node := acv.a_ap_tree^[curr_node].n_sa_level; *)
                    (*ENDIF*) 
                    WITH acv.a_ap_tree^ [curr_node] DO
                        CASE n_symb OF
                            s_string_literal,
                            s_byte_string :
                                BEGIN
                                literal_cnt := succ (literal_cnt);
                                (* PTS 1122367 E.Z. *)
                                IF  g01unicode AND
                                    (cdatatyp <> dstruni) AND
                                    (cdatatyp <> dlonguni)
                                THEN
                                    BEGIN
                                    (* byte_string will need as much space        *)
                                    (* as string_literal for intermediate storage *)
                                    total_size := total_size + n_length DIV 2
                                    END
                                ELSE
                                    IF  (n_symb = s_string_literal)
                                    THEN
                                        total_size := total_size + n_length
                                    ELSE
                                        total_size := total_size + n_length DIV 2;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                END;
                            s_default :
                                BEGIN
                                literal_cnt := succ (literal_cnt);
                                total_size  := total_size + mxsp_c256;
                                END;
                            s_parameter_name :
                                IF  (ctdefault in col_buf^.ccolpropset)
                                    AND
                                    (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc = a56) AND
                                    (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc  <>
                                    cak_x_insert_select)
                                THEN
                                    BEGIN
                                    literal_cnt := succ (literal_cnt);
                                    total_size  := total_size + mxsp_c256;
                                    END
                                ELSE
                                    parameter_cnt := succ (parameter_cnt);
                                (*ENDIF*) 
                            s_null :
                                null_cnt := succ (null_cnt);
                            OTHERWISE :
                                (* h.b. PTS 1001032 *)
                                a07_b_put_error (acv,
                                      e_const_incompatible_with_typ, n_pos);
                            END;
                        (*ENDCASE*) 
                    (*ENDWITH*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  (cdatatyp in [dlonga, dlongb,
                    dlonguni, dstra, dstrb, dstruni])
                    AND
                    (ctdefault in col_buf^.ccolpropset)
                    AND
                    (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc = a56) AND
                    (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc  <>
                    cak_x_insert_select)
                THEN
                    BEGIN
                    literal_cnt := succ (literal_cnt);
                    total_size  := total_size + mxsp_c256;
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  cnextind > 0
            THEN
                col_buf := a103GetColumn (pbasep^.sbase, cnextind);
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        fieldno := succ(fieldno)
        END;
    (*ENDWHILE*) 
    IF  literal_cnt > 0
    THEN
        total_cnt := parameter_cnt + literal_cnt;
&   ifdef TRACE
    (*ENDIF*) 
    t01int4 (ak_sem, 'longlit gcnt', total_cnt);
    t01int4 (ak_sem, 'longlit gsiz', total_size);
&   endif
    END;
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
