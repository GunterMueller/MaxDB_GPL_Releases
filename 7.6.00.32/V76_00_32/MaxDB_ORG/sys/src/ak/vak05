.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK05$
.tt 2 $$$
.TT 3 $ElkeZ$AK_semantic_scanner_tools$2000-11-08$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : AK_semantic_scanner_tools
=========
.sp
Purpose : several for DDL-execution
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a05init;
 
        PROCEDURE
              a05int4_get (
                    VAR acv            : tak_all_command_glob;
                    pos                : integer;
                    l                  : tsp00_Int2;
                    VAR val            : tsp00_Int4);
 
        PROCEDURE
              a05get_err_tabid (
                    VAR t       : tgg00_TransContext;
                    VAR tree    : tgg00_FileId;
                    VAR tableid : tgg00_Surrogate);
 
        PROCEDURE
              a05_identifier_get_from_buffer(
                    VAR acv            : tak_all_command_glob;
                    VAR SourceBuffer   : tsp00_MoveObj;
                    BufferLength       : tsp00_Int4;
                    IdentifierPosition : tsp00_Int4;
                    IdentifierLength   : tsp00_Int2;
                    ComplexStringID    : boolean;
                    ObjLength          : integer;
                    VAR MoveObj        : tsp00_MoveObj);
 
        PROCEDURE
              a05identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_MoveObj);
 
        PROCEDURE
              a05_identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_MoveObj);
 
        PROCEDURE
              a05_unsigned_int2_get (
                    VAR acv            : tak_all_command_glob;
                    pos                : integer;
                    l                  : tsp00_Int2;
                    err_code           : tsp00_Int4;
                    VAR val            : tsp00_Int2);
 
        PROCEDURE
              a05_int4_unsigned_get (
                    VAR acv            : tak_all_command_glob;
                    pos                : integer;
                    l                  : tsp00_Int2;
                    VAR val            : tsp00_Int4);
 
        PROCEDURE
              a05_li_constant_get (
                    VAR acv          : tak_all_command_glob;
                    ni               : integer;
                    VAR colinfo      : tak00_columninfo;
                    orig_len         : integer;
                    mv_dest          : integer;
                    VAR dest         : tsp00_MoveObj;
                    destpos          : integer;
                    variable_length  : boolean;
                    VAR actlen       : integer);
 
        PROCEDURE
              a05_constant_get (
                    VAR acv       : tak_all_command_glob;
                    ni            : integer;
                    VAR colinfo   : tak00_columninfo;
                    may_be_longer : boolean;
                    mv_dest       : integer;
                    VAR dest      : tsp00_MoveObj;
                    destpos       : integer;
                    VAR actlen    : integer);
 
        PROCEDURE
              a05var_constant_get (
                    VAR acv          : tak_all_command_glob;
                    ni               : integer;
                    VAR colinfo      : tak00_columninfo;
                    may_be_longer    : boolean;
                    VAR valfieldno   : integer;
                    VAR valstart     : tsp00_MoveObjPtr;
                    VAR actlen       : integer);
 
        PROCEDURE
              a05_stamp_get (
                    VAR acv    : tak_all_command_glob;
                    VAR dest   : tsp00_MoveObj;
                    destpos    : integer;
                    mv_dest    : integer);
 
        PROCEDURE
              a05surrogate_get (
                    VAR acv        : tak_all_command_glob;
                    VAR surrogate  : tgg00_Surrogate);
 
        PROCEDURE
              a05temp_nextval (
                    VAR data_part    : tsp00_MoveObj;
                    data_size        : tsp00_Int4;
                    VAR st_entry     : tgg00_StackEntry;
                    VAR seq_info     : tgg00_SeqInfo;
                    VAR moveobj      : tsp00_MoveObj;
                    VAR moveobj_size : tsp00_Int4;
                    result_pos       : tsp00_Int4;
                    VAR result_len   : integer);
 
        PROCEDURE
              a05_transaction_get (
                    VAR acv    : tak_all_command_glob;
                    VAR dest   : tsp00_MoveObj;
                    destpos    : integer;
                    mv_dest    : integer);
 
        PROCEDURE
              a05_nextval_get (
                    VAR acv      : tak_all_command_glob;
                    m2_type      : tgg00_MessType2;
                    VAR seq_id   : tgg00_Surrogate (*ptocSynonym const tgg00_Surrogate VAR_ARRAY_REF *);
                    VAR seq_info : tgg00_SeqInfo;
                    VAR dest     : tsp00_MoveObj;
                    destpos      : integer;
                    VAR actlen   : integer);
 
        PROCEDURE
              a05constraint_fulfilled (
                    VAR acv         : tak_all_command_glob;
                    VAR valbuf      : tgg00_Rec;
                    VAR tree        : tgg00_FileId;
                    constraint_id   : integer);
 
        PROCEDURE
              a05is_const_in_constraint (
                    VAR acv         : tak_all_command_glob;
                    VAR valbuf      : tsp00_MoveObj;
                    val_pos         : integer;
                    val_len         : integer;
                    VAR tree        : tgg00_FileId;
                    constraint_id   : integer;
                    b_err           : tgg00_BasisError;
                    error_pos       : integer);
 
        PROCEDURE
              a05password_get (
                    VAR acv      : tak_all_command_glob;
                    tree_index   : integer;
                    VAR password : tsp00_Pw);
 
        PROCEDURE
              a05put_identifier (
                    VAR id      : tsp00_KnlIdentifier;
                    VAR moveobj : tsp00_MoveObj;
                    moveobj_size: tsp00_Int4;
                    VAR pos     : tsp00_Int4;
                    VAR retcode : tsp00_Int2);
 
        PROCEDURE
              a05qualification_test (
                    VAR acv        : tak_all_command_glob;
                    VAR m          : tgg00_MessBlock;
                    result_wanted  : boolean;
                    check_new_rec  : boolean;
                    error_pos      : integer;
                    VAR rec        : tgg00_Rec;
                    VAR result_buf : tsp00_Buf;
                    resultBufSize  : tsp00_Int4;
                    VAR result_len : integer);
 
        PROCEDURE
              a05varqualification_test (
                    VAR acv        : tak_all_command_glob;
                    VAR m          : tgg00_MessBlock;
                    result_wanted  : boolean;
                    check_new_rec  : boolean;
                    error_pos      : integer;
                    fieldlistno    : integer;
                    VAR result_no  : tsp00_Int2);
 
        PROCEDURE
              a05serial (
                    VAR acv        : tak_all_command_glob;
                    VAR colinfo    : tak00_columninfo;
                    VAR treeid     : tgg00_FileId;
                    VAR moveobj    : tsp00_MoveObj;
                    moveobj_size   : tsp00_Int4;
                    number_pos     : tsp00_Int4;
                    VAR number_len : integer;
                    with_retpart   : boolean);
 
        PROCEDURE
              a05return_serial (
                    VAR acv          : tak_all_command_glob;
                    VAR first_serial : tsp00_Number;
                    VAR last_serial  : tsp00_Number);
 
        PROCEDURE
              a05string_literal_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    datatyp     : tsp00_DataType;
                    VAR moveobj : tsp00_MoveObj;
                    obj_pos     : integer;
                    obj_len     : integer);
 
        PROCEDURE
              a05_str_literal_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    datatyp     : tsp00_DataType;
                    VAR moveobj : tsp00_MoveObj;
                    obj_pos     : integer;
                    obj_len     : integer);
 
        PROCEDURE
              a05_string_literal_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    datatyp     : tsp00_DataType;
                    obj_len     : integer;
                    VAR moveobj : tsp00_MoveObj);
 
        PROCEDURE
              a05dfts_date_from_timestamp (
                    VAR sbuf   : tsp00_MoveObj;
                    VAR dbuf   : tsp00_MoveObj;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    dbufsize   : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    language   : tsp00_C3;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              a05tfts_time_from_timestamp (
                    VAR sbuf   : tsp00_MoveObj;
                    VAR dbuf   : tsp00_MoveObj;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    dbufsize   : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    language   : tsp00_C3;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              a05tsfdt_timestamp_from_dattim (
                    VAR sbuf   : tsp00_MoveObj;
                    VAR dbuf   : tsp00_MoveObj;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    dbufsize   : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    stype      : tsp00_DataType;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              a05timestamp_get (
                    VAR acv      : tak_all_command_glob;
                    VAR src      : tsp00_MoveObj;
                    src_pos      : tsp00_Int4;
                    source_undef : boolean;
                    VAR dest     : tsp00_MoveObj;
                    dest_pos     : tsp00_Int4;
                    check_len    : tsp00_Int4;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a05get_digit (
                    VAR num_buf  : tsp00_MoveObj;
                    pos          : integer;
                    length       : integer;
                    VAR dig_len  : integer;
                    VAR dig_frac : integer);
 
        PROCEDURE
              a05long_literal_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    datatyp     : tsp00_DataType;
                    VAR moveobj : tsp00_MoveObj;
                    obj_pos     : integer;
                    VAR obj_len : integer);
 
        PROCEDURE
              a05RenameIdentifierInPacket (
                    VAR acv           : tak_all_command_glob;
                    VAR newIdentifier : tsp00_KnlIdentifier (* ptocConst *);
                    VAR pos           : integer;
                    VAR delta         : integer);
 
        PROCEDURE
              a05_verify_not_null (
                    VAR acv        : tak_all_command_glob;
                    VAR valbuf     : tgg00_Rec;
                    VAR stackentry : tgg00_StackEntry);
 
        FUNCTION
              a05lnr_space_defbyte (
                    acv       : tak_acv_address;
                    VAR str   : tsp00_MoveObjPtr;
                    defbyte   : char;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
        PROCEDURE
              a05luc_space (
                    acv          : tak_acv_address;
                    VAR buf1     : tsp00_MoveObj;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tsp00_MoveObj;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
        FUNCTION
              a05space_option (acv : tak_acv_address) : boolean;
 
        FUNCTION
              a05variable_input (acv : tak_acv_address) : boolean;
 
        PROCEDURE
              a05int_range_check (VAR acv : tak_all_command_glob;
                    VAR dest  : tsp00_MoveObj;
                    destpos   : integer;
                    numlen    : integer;
                    cdatalen  : tsp00_Int2;
                    errorpos  : tsp00_Int4);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
&       ifdef TRACE
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR m         : tgg00_MessBlock);
 
        PROCEDURE
              t01buf (
                    layer    : tgg00_Debug;
                    VAR buf  : tak_systembuffer;
                    startpos : integer;
                    endpos   : integer);
 
        PROCEDURE
              t01moveobj (
                    debug       : tgg00_Debug;
                    VAR moveobj : tsp00_MoveObj (*ptocSynonym const void**);
                    startpos    : tsp00_Int4;
                    endpos      : tsp00_Int4);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    val      : tsp00_Int4);
 
        PROCEDURE
              t01name (
                    debug : tgg00_Debug;
                    nam : tsp00_Name);
 
        PROCEDURE
              t01real (debug : tgg00_Debug;
                    nam    : tsp00_Sname;
                    re     : tsp00_Longreal;
                    digits : integer);
 
        PROCEDURE
              t01comp_result (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    comp_res  : tsp00_LcompResult);
&       endif
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01identifier_size   : integer;
              a01char_size         : integer;
 
        FUNCTION
              a01equal_char (
                    VAR m    : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    cmp_char : char) : boolean;
 
        FUNCTION
              a01is_identifier (
                    VAR identifier : tsp00_KnlIdentifier;
                    len     : integer;
                    sqlmode : tsp00_SqlMode) : boolean;
 
        FUNCTION
              a01is_whitespace_char (
                    VAR m    : tsp00_MoveObj;
                    pos      : tsp00_Int4) : boolean;
 
        PROCEDURE
              a01_next_symbol (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06rsend_mess_buf (
                    VAR acv        : tak_all_command_glob;
                    VAR mbuf       : tgg00_MessBlock;
                    result_req     : boolean;
                    VAR b_err      : tgg00_BasisError);
 
        PROCEDURE
              a06put_errtext (
                    VAR acv       : tak_all_command_glob;
                    b_err_in      : tgg00_BasisError;
                    err_type      : tgg04_ErrorText;
                    errtext_len   : integer;
                    VAR errtext   : tsp00_C256;
                    VAR b_err_out : tgg00_BasisError);
 
        FUNCTION
              a06uid (VAR user_id : tgg00_Surrogate) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_hex_uni_error (
                    VAR acv     : tak_all_command_glob;
                    uni_err     : tsp8_uni_error;
                    err_code    : tsp00_Int4;
                    to_unicode  : boolean;
                    bytestr     : tsp00_MoveObjPtr;
                    len         : tsp00_Int4 );
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv      : tak_all_command_glob;
                    b_err        : tgg00_BasisError;
                    err_code     : tsp00_Int4);
 
        PROCEDURE
              a07_const_b_put_error (
                    VAR acv    : tak_all_command_glob;
                    b_err      : tgg00_BasisError;
                    err_code   : tsp00_Int4;
                    param_addr : tsp00_MoveObjPtr;
                    const_len  : integer);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
        PROCEDURE
              a07_sb_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR err  : tgg04_Err);
 
        PROCEDURE
              a07_uni_error (
                    VAR acv  : tak_all_command_glob;
                    uni_err  : tsp8_uni_error;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache   : VAK10;
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10mark_updated (p : tak_sysbufferaddress);
 
        PROCEDURE
              a10new (
                    VAR acv  : tak_all_command_glob;
                    obj_size : tsp00_Int4;
                    VAR p    : tgg00_StackListPtr);
 
        PROCEDURE
              a10dispose (
                    VAR acv : tak_all_command_glob;
                    VAR p : tgg00_StackListPtr);
 
      ------------------------------ 
 
        FROM
              SQLManager : vak101;
 
        FUNCTION
              a101_GetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              SequenceWrapper : VAK104;
 
        FUNCTION
              ak104_CreateNullField_IMS (
                    sequence : tsp00_MoveObjPtr;
                    msglist  : tak104_MsgList)
                    : boolean;
 
        FUNCTION
              ak104_CreateVariableField_IMS (
                    sequence : tsp00_MoveObjPtr;
                    size     : tsp00_Int4;
                    VAR buf  : tsp00_MoveObjPtr;
                    msglist  : tak104_MsgList) : boolean;
 
        FUNCTION
              ak104_CloseCurrentField_IMS (
                    sequence : tsp00_MoveObjPtr;
                    size     : tsp00_Int4;
                    msglist  : tak104_MsgList) : boolean;
 
        FUNCTION
              ak104_GetFieldCount_IMS (
                    sequence : tsp00_MoveObjPtr) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              AK_Table : VAK11;
 
        PROCEDURE
              a11getconstraintname (
                    VAR constraint_rec  : tak_constraintrecord;
                    VAR constraint_name : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_Synonym : VAK23;
 
        FUNCTION
              a23exist_sequence (
                    VAR acv          : tak_all_command_glob;
                    tree_index       : integer;
                    inclusiveSerial  : boolean;
                    VAR seq_buf      : tak_sysbufferaddress;
                    VAR seq_owner    : tsp00_KnlIdentifier;
                    VAR seq_name     : tsp00_KnlIdentifier) : boolean;
 
      ------------------------------ 
 
        FROM
              Pseudo_fieldmap : VAK509;
 
        FUNCTION
              a509get_one_value (map_ptr : tsp00_MoveObjPtr;
                    value_no       : tsp00_Int2;
                    VAR value_ptr  : tsp00_MoveObjPtr;
                    VAR value_len  : tsp00_Int4;
                    VAR is_null    : boolean;
                    VAR is_default : boolean) : boolean;
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK54;
 
        PROCEDURE
              a54_internal_function (
                    VAR acv : tak_all_command_glob;
                    VAR m : tgg00_MessBlock;
                    st_no : integer);
 
      ------------------------------ 
 
        FROM
              KB_get : VKB71;
 
        VAR
              k71serial_seq_info : tgg00_SeqInfo;
 
        PROCEDURE
              k71num_err_to_b_err (
                    num_err : tsp00_NumError;
                    VAR e : tgg00_BasisError);
 
        PROCEDURE
              k71qualification_test (
                    VAR m           : tgg00_MessBlock;
                    first_qual      : boolean;
                    result_wanted   : boolean;
                    check_new_rec   : boolean;
                    VAR rec         : tgg00_Rec;
                    result_ptr      : tsp00_MoveObjPtr;
                    result_size     : tsp00_Int4;
                    VAR result_len  : integer);
 
        PROCEDURE
              k71qual_handling (
                    VAR t              : tgg00_TransContext;
                    VAR sel            : tgg00_SelectFieldsParam;
                    with_view          : boolean;
                    check_new_rec      : boolean;
                    VAR stack_desc     : tgg00_StackDesc;
                    VAR err_st_ptr     : tgg00_StEntryAddr;
                    VAR unqualified    : boolean);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id     : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              FileDir_Wrapper : vbd998;
 
        FUNCTION
              bd998GetTempFileIndex(
                    VAR trans  : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code           : tgg04_CodeGlobals;
              g01glob           : tgg00_KernelGlobals;
              g01serverdb_ident : tgg04_ServerdbIdent;
              g01unicode        : boolean;
 
        PROCEDURE
              g01mblock_init (
                    VAR source_trans : tgg00_TransContext;
                    mess_type  : tgg00_MessType;
                    mess2_type : tgg00_MessType2;
                    VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              g01datapart_init (
                    VAR mblock    : tgg00_MessBlock;
                    datapart_ptr  : tgg00_DataPartPtr;
                    datapart_size : tsp00_Int4);
 
        PROCEDURE
              g01stack_init (
                    VAR mblock : tgg00_MessBlock;
                    stack_ptr  : tgg00_StackListPtr;
                    stack_size : tsp00_Int4;
                    qual_ptr   : tgg00_QualBufPtr;
                    qual_size  : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Codetransformation_and_Coding : VGG02;
 
      ------------------------------ 
 
        FROM
              Check-Date-Time : VGG03;
 
        VAR
              g03dictionary : tsp6_dictionaries;
 
        PROCEDURE
              g03part2_decrypt (
                    VAR var_part  : tsp00_MoveObj;
                    mess_code     : tsp00_CodeType;
                    part2_pos     : tsp00_Int4;
                    sourceswap    : tsp00_SwapKind;
                    destswap      : tsp00_SwapKind;
                    VAR clearname : tsp00_Name);
 
        PROCEDURE
              g03ftsc_timestamp (
                    sptr       : tsp00_MoveObjPtr;
                    dptr       : tsp00_MoveObjPtr;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    language   : tsp00_C3;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              g03ftc_time (
                    sptr       : tsp00_MoveObjPtr;
                    dptr       : tsp00_MoveObjPtr;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              g03fdc_date (
                    sptr       : tsp00_MoveObjPtr;
                    dptr       : tsp00_MoveObjPtr;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              g03fdcheck_date (
                    VAR sbuf   : tsp00_MoveObj;
                    VAR dbuf   : tsp00_MoveObj;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              g03ftcheck_time (
                    VAR sbuf   : tsp00_MoveObj;
                    VAR dbuf   : tsp00_MoveObj;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              g03ftscheck_timestamp (
                    VAR sbuf   : tsp00_MoveObj;
                    VAR dbuf   : tsp00_MoveObj;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    language   : tsp00_C3;
                    VAR b_err  : tgg00_BasisError);
 
        FUNCTION
              g03date_error_to_b_err (date_e : tsp6_date_error)
                    : tgg00_BasisError;
 
        PROCEDURE
              g03dfchange_format_date (
                    VAR sbuf  : tsp00_Timestamp;
                    VAR dbuf  : tsp00_MoveObj;
                    spos      : tsp00_Int4;
                    dpos      : tsp00_Int4;
                    format    : tgg00_DateTimeFormat;
                    VAR b_err : tgg00_BasisError);
 
        PROCEDURE
              g03tfchange_format_time (
                    VAR sbuf  : tsp00_C9;
                    VAR dbuf  : tsp00_MoveObj;
                    spos      : tsp00_Int4;
                    dpos      : tsp00_Int4;
                    format    : tgg00_DateTimeFormat;
                    VAR b_err : tgg00_BasisError);
 
        PROCEDURE
              g03tsfchange_format_timestamp (
                    VAR sbuf  : tsp00_Timestamp;
                    VAR dbuf  : tsp00_MoveObj;
                    spos      : tsp00_Int4;
                    dpos      : tsp00_Int4;
                    format    : tgg00_DateTimeFormat;
                    language  : tsp00_C3;
                    VAR b_err : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04init_select_fields (
                    VAR sel       : tgg00_SelectFieldsParam;
                    data_addr     : tsp00_MoveObjPtr;
                    data_size     : tsp00_Int4;
                    work_st_addr  : tgg00_StackListPtr;
                    work_st_max   : tsp00_Int2;
                    work_buf_addr : tsp00_MoveObjPtr;
                    work_buf_size : tsp00_Int4;
                    curr_sqlmode  : tsp00_SqlMode;
                    fieldlistptr  : tgg00_FieldListsPtr);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalUnicodeFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              GG_allocator_interface : VGG941;
 
        FUNCTION
              gg941Allocate(VAR TransContext : tgg00_TransContext;
                    wantedBytes : integer) : tsp00_MoveObjPtr;
 
        PROCEDURE
              gg941Deallocate(VAR TransContext : tgg00_TransContext;
                    VAR p : tsp00_MoveObjPtr);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        PROCEDURE
              s30cmp (
                    VAR buf1     : tsp00_MoveObj;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tsp00_Number;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
        FUNCTION
              s30unilnr (
                    str       : tsp00_MoveObjPtr;
                    skip_val  : tsp00_C2;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : integer;
 
        FUNCTION
              s30lnr_defbyte (
                    str       : tsp00_MoveObjPtr;
                    defbyte   : char;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30klen (
                    VAR str : tsp00_KnlIdentifier;
                    val : char; cnt : integer) : integer;
 
      ------------------------------ 
 
        FROM
              GET-Conversions : VSP40;
 
        PROCEDURE
              s40g4int (
                    VAR buf  : tsp00_Number;
                    pos      : tsp00_Int4;
                    VAR dest : tsp00_Int4;
                    VAR res  : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              PUT-Conversions : VSP41;
 
        PROCEDURE
              s41pbyte (
                    VAR buf     : tsp00_MoveObj;
                    pos         : tsp00_Int4;
                    VAR len     : integer;
                    VAR source  : tsp00_MoveObj;
                    spos        : tsp00_Int4;
                    slen        : integer;
                    VAR invalid : boolean);
 
        PROCEDURE
              s41plint (
                    VAR buf : tsp00_MoveObj;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
        PROCEDURE
              s41plrel (VAR buf : tsp00_MoveObj;
                    pos         : tsp00_Int4;
                    len         : integer;
                    frac        : integer;
                    source      : tsp00_Longreal;
                    VAR res     : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              GETSTRING-Conversions : VSP42;
 
        PROCEDURE
              s42gochr (
                    VAR buf  : tsp00_Number;
                    pos      : tsp00_Int4;
                    VAR dest : tsp00_MoveObj;
                    dpos     : tsp00_Int4;
                    VAR dlen : integer;
                    VAR res  : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              PUTSTRING-Conversions : VSP43;
 
        PROCEDURE
              s43pstr  (
                    VAR dbuf   : tsp00_MoveObj;
                    dpos       : tsp00_Int4;
                    datalen    : integer;
                    datafrac   : integer;
                    VAR source : tsp00_MoveObj;
                    spos       : tsp00_Int4;
                    slen       : integer;
                    VAR err    : tsp00_NumError);
 
        PROCEDURE
              s43pstr1  (
                    VAR dbuf   : tsp00_MoveObj;
                    dpos       : tsp00_Int4;
                    datalen    : integer;
                    datafrac   : integer;
                    VAR source : tsp00_C512;
                    spos       : tsp00_Int4;
                    slen       : integer;
                    VAR err    : tsp00_NumError);
 
        PROCEDURE
              s43pstr2  (
                    VAR dbuf   : tsp00_Number;
                    dpos       : tsp00_Int4;
                    datalen    : integer;
                    datafrac   : integer;
                    VAR source : tsp00_MoveObj;
                    spos       : tsp00_Int4;
                    slen       : integer;
                    VAR err    : tsp00_NumError);
 
        PROCEDURE
              s43pstr3  (
                    VAR dbuf   : tsp00_Number;
                    dpos       : tsp00_Int4;
                    datalen    : integer;
                    datafrac   : integer;
                    VAR source : tsp00_C512;
                    spos       : tsp00_Int4;
                    slen       : integer;
                    VAR err    : tsp00_NumError);
 
        PROCEDURE
              s43lfrac (
                    VAR source  : tsp00_Number;
                    spos        : tsp00_Int4;
                    slen        : integer;
                    VAR diglen  : integer;
                    VAR digfrac : integer;
                    VAR bytelen : integer);
 
      ------------------------------ 
 
        FROM
              Number-Arithmetic : VSP51;
 
        PROCEDURE
              s51add (
                    VAR left       : tsp00_Number;
                    lpos           : tsp00_Int4;
                    llen           : integer;
                    VAR right      : tsp00_Number;
                    rpos           : tsp00_Int4;
                    rlen           : integer;
                    VAR result     : tsp00_Number;
                    respos         : tsp00_Int4;
                    reslen         : integer;
                    resfrac        : integer;
                    VAR resbytelen : integer;
                    VAR ret        : tsp00_NumError);
 
        PROCEDURE
              s51kroun (
                    VAR source     : tsp00_Number;
                    spos           : tsp00_Int4;
                    slen           : integer;
                    VAR result     : tsp00_MoveObj;
                    respos         : tsp00_Int4;
                    reslen         : integer;
                    resfrac        : integer;
                    VAR resbytelen : integer;
                    VAR ret        : tsp00_NumError);
 
        PROCEDURE
              s51neg (
                    VAR source     : tsp00_Number;
                    spos           : tsp00_Int4;
                    slen           : integer;
                    VAR result     : tsp00_Number;
                    respos         : tsp00_Int4;
                    reslen         : integer;
                    resfrac        : integer;
                    VAR resbytelen : integer;
                    VAR ret        : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              date_time_formatting : VSP78;
 
        PROCEDURE
              s78c2d_to_date (
                    VAR dictionary : tsp6_dictionary;
                    curr_date    : tsp00_MoveObjPtr;
                    fmt_addr     : tsp00_MoveObjPtr;
                    fmt_len      : tsp00_Int4;
                    src_addr     : tsp00_MoveObjPtr;
                    src_len      : tsp00_Int4;
                    dest_addr    : tsp00_MoveObjPtr;
                    VAR dest_pos : tsp00_Int4;
                    VAR e        : tsp6_date_error);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80: VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vtimestamp (VAR t   : tsp00_Timestamp);
 
        PROCEDURE
              vUTCtimestamp (VAR timestamp : tsp00_Timestamp);
 
        FUNCTION
              vTimeZoneDelta : tsp00_Longreal; (* PTS 1109925 *)
 
        PROCEDURE
              vdattime (
                    VAR date     : tsp00_Date;
                    VAR time     : tsp00_Time);
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              a10new;
 
              tak_sysbufferaddress tgg00_StackListPtr
 
        PROCEDURE
              a10dispose;
 
              tak_sysbufferaddress tgg00_StackListPtr
 
        FUNCTION
              ak104_CreateNullField_IMS;
 
              tak104_IncrementalMemorySequence tsp00_MoveObjPtr
 
        FUNCTION
              ak104_CreateVariableField_IMS;
 
              tak104_IncrementalMemorySequence tsp00_MoveObjPtr
 
        FUNCTION
              ak104_CloseCurrentField_IMS;
 
              tak104_IncrementalMemorySequence tsp00_MoveObjPtr
 
        FUNCTION
              ak104_GetFieldCount_IMS;
 
              tak104_IncrementalMemorySequence tsp00_MoveObjPtr
 
        PROCEDURE
              t01buf;
 
              tsp00_Buf tak_systembuffer
 
        FUNCTION
              a01is_identifier;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              g03dfchange_format_date;
 
              tsp00_MoveObj tsp00_Timestamp
 
        PROCEDURE
              g03tfchange_format_time;
 
              tsp00_MoveObj tsp00_C9
 
        PROCEDURE
              g03tsfchange_format_timestamp;
 
              tsp00_MoveObj tsp00_Timestamp
 
        FUNCTION
              gg941Allocate;
 
              tsp00_Addr tsp00_MoveObjPtr
 
        PROCEDURE
              gg941Deallocate;
 
              tsp00_Addr tsp00_MoveObjPtr
 
        FUNCTION
              s30klen;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              s30cmp;
 
              tsp00_MoveObj tsp00_Number
 
        PROCEDURE
              s40g4int;
 
              tsp00_MoveObj  tsp00_Number
 
        PROCEDURE
              s42gochr;
 
              tsp00_MoveObj  tsp00_Number
 
        PROCEDURE
              s43pstr1;
 
              tsp00_MoveObj  tsp00_C512
 
        PROCEDURE
              s43pstr2;
 
              tsp00_MoveObj  tsp00_Number
 
        PROCEDURE
              s43pstr3;
 
              tsp00_MoveObj  tsp00_Number
              tsp00_MoveObj  tsp00_C512
 
        PROCEDURE
              s43lfrac;
 
              tsp00_MoveObj  tsp00_Number
 
        PROCEDURE
              s43pstr1;
 
              tsp00_MoveObj  tsp00_Number
              tsp00_MoveObj  tsp00_C512
 
        PROCEDURE
              s51add;
 
              tsp00_MoveObj tsp00_Number
 
        PROCEDURE
              s51kroun;
 
              tsp00_MoveObj  tsp00_Number
 
        PROCEDURE
              s51neg;
 
              tsp00_MoveObj  tsp00_Number
              tsp00_MoveObj  tsp00_Number
 
        PROCEDURE
              s30unilnr;
 
              tsp00_Int4  integer
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ElkeZ
.sp
.cp 3
Created : 1985-02-06
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-11-08
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
 
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
.sp 2
.sp 4
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_first_qual     = true; (* k71qualification_test *)
      c_result_wanted  = true; (* k71qualification_test *)
      c_check_new_rec  = true; (* k71qualification_test *)
      c_trans_to_uni   =  true;   (* a07_hex_uni_err *)
      c_trans_from_uni =  false;  (* a07_hex_uni_err *)
      c_ascii_wid      =  1;      (* a07_hex_uni_err *)
      c_unicode_wid    =  2;      (* a07_hex_uni_err *)
      c_negativ        = true;
      c_undef          = true;
      c_variable_length= true;
 
VAR
      a05ascii_blankvalue   : tsp00_C2;
      a05unicode_blankvalue : tsp00_C3;
 
 
(*------------------------------*) 
 
PROCEDURE
      ak05int4_get (
            VAR acv          : tak_all_command_glob;
            pos              : integer;
            l                : integer;
            is_neg           : boolean;
            err_code         : tsp00_Int4;
            VAR val          : tsp00_Int4);
 
VAR
      temp_space : tsp00_C512;
      resbytelen : integer;
      uni_len    : tsp00_Int4;
      err_char_no: tsp00_Int4;
      uni_err    : tsp8_uni_error;
      intern_num : tsp00_Number;
      err        : tsp00_NumError;
 
BEGIN
&ifdef trace
t01moveobj (ak_sem, acv.a_cmd_part^.sp1p_buf, pos, pos + l - 1);
&endif
val        := 1;
intern_num := csp_null_number;
IF  g01unicode
THEN
    BEGIN
    uni_len := sizeof (temp_space);
    s80uni_trans (@(acv.a_cmd_part^.sp1p_buf[pos]), l, csp_unicode,
          @temp_space, uni_len, csp_ascii, [ ], uni_err,
          err_char_no);
    IF  uni_err = uni_ok
    THEN
        s43pstr3 (intern_num, 1, csp_fixed, csp_float_frac,
              temp_space, 1, uni_len, err)
    ELSE
        err := num_invalid
    (*ENDIF*) 
    END
ELSE
    s43pstr2 (intern_num, 1, csp_fixed, csp_float_frac,
          acv.a_cmd_part^.sp1p_buf, pos, l, err);
(*ENDIF*) 
IF  is_neg AND (err = num_ok)
THEN
    s51neg (intern_num, 1, sizeof (intern_num),
          intern_num, 1, sizeof (intern_num), 0, resbytelen, err);
(*ENDIF*) 
IF  err = num_ok
THEN
    s40g4int (intern_num, 1, val, err);
&ifdef trace
(*ENDIF*) 
t01int4 (ak_sem, 'val         ', val);
&endif
IF  (err <> num_ok           ) OR
    (intern_num > csp_maxlint) OR
    (intern_num < csp_minlint)
THEN
    a07_b_put_error (acv, err_code, pos)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak05one_number (
            VAR acv          : tak_all_command_glob;
            ni               : integer;
            VAR colinfo      : tak00_columninfo;
            mv_dest          : integer;
            VAR dest         : tsp00_MoveObj;
            destpos          : integer;
            VAR do_trunc     : boolean;
            VAR l            : integer);
 
VAR
      exponent   : integer;
      numlen     : integer;
      temp_space : tsp00_C512;
      uni_len    : tsp00_Int4;
      err_char_no: tsp00_Int4;
      uni_err    : tsp8_uni_error;
      err        : tsp00_NumError;
 
BEGIN
WITH acv, a_ap_tree^[ ni ], colinfo DO
    BEGIN
    IF  NOT (cdatatyp in [ dfixed, dfloat, dvfloat ])
    THEN
        a07_b_put_error (acv,
              e_const_incompatible_with_typ, n_pos)
    ELSE
        BEGIN
        l := cinoutlen - 1;
        IF  mv_dest < destpos + l
        THEN
            a07_b_put_error (acv, e_too_many_mb_data, n_pos)
        ELSE
            BEGIN
            (* PTS 1105848 E.Z.
                  IF  ccolstack.etype = st_varcol
                  THEN
                  do_trunc := false
                  ELSE
                  *)
            uni_len := 0;
            IF  (ccolstack.etype = st_varkey) AND
                ((a_is_ddl = ddl_create_table)  OR
                ( a_is_ddl = ddl_create_domain) OR
                ( a_is_ddl = ddl_alter_tab_add) OR
                ( a_is_ddl = ddl_alter_tab_alter))
            THEN
                do_trunc := false;
            (*ENDIF*) 
            IF  g01unicode
            THEN
                BEGIN
                uni_len := sizeof (temp_space);
                s80uni_trans (@(a_cmd_part^.sp1p_buf[n_pos]), n_length, csp_unicode,
                      @temp_space, uni_len, csp_ascii, [ ], uni_err,
                      err_char_no);
                IF  uni_err = uni_ok
                THEN
                    s43pstr1 (dest, destpos+1,
                          cdatalen, cdatafrac-cak_frac_offset,
                          temp_space, 1, uni_len, err)
                ELSE
                    err := num_invalid
                (*ENDIF*) 
                END
            ELSE
                s43pstr (dest, destpos+1,
                      cdatalen, cdatafrac-cak_frac_offset,
                      acv.a_cmd_part^.sp1p_buf, n_pos, n_length, err);
            (*ENDIF*) 
            IF  err = num_ok
            THEN
                IF  a_is_ddl = ddl_create_sequence
                THEN
                    BEGIN
                    exponent := ord (dest[ destpos+1 ]);
                    IF  ((exponent < 128) AND
                        ( 64 - exponent > colinfo.cdatalen))
                        OR
                        ((exponent > 128) AND
                        ( exponent - 192 > colinfo.cdatalen))
                    THEN
                        err := num_overflow
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  (err <> num_ok)
            THEN
                CASE err OF
                    num_invalid :
                        a07_b_put_error (acv, e_num_invalid, n_pos);
                    num_trunc, num_overflow :
                        IF  g01unicode
                        THEN
                            a07_const_b_put_error (acv, e_num_overflow, n_pos,
                                  @temp_space, uni_len)
                        ELSE
                            a07_const_b_put_error (acv, e_num_overflow, n_pos,
                                  @a_cmd_part^.sp1p_buf[n_pos], n_length)
                        (*ENDIF*) 
                    END
                (*ENDCASE*) 
            ELSE
                IF  cbinary
                THEN
                    BEGIN
                    numlen := (cdatalen + 1) DIV 2 + 1;
                    a05int_range_check (acv, dest, destpos, numlen, cdatalen, n_pos);
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05int_range_check (VAR acv : tak_all_command_glob;
            VAR dest  : tsp00_MoveObj;
            destpos   : integer;
            numlen    : integer;
            cdatalen  : tsp00_Int2;
            errorpos  : tsp00_Int4);
 
VAR
      intern_num : tsp00_Number;
      e          : tgg00_BasisError;
 
BEGIN
intern_num := csp_null_number;
e := e_ok;
SAPDB_PascalMove ('VAK05 ',   1,    
      sizeof(dest), sizeof(intern_num), @dest, destpos+1, @intern_num, 1, numlen, e);
IF  e = e_ok
THEN
    IF  cdatalen = 5
    THEN
        BEGIN
        IF  ((intern_num > csp_maxsint) OR
            ( intern_num < csp_minsint))
        THEN
            e := e_range_violation
        (*ENDIF*) 
        END
    ELSE
        IF  ((intern_num > csp_maxlint) OR
            ( intern_num < csp_minlint))
        THEN
            e := e_range_violation;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, errorpos)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak05temp_serial (
            VAR acv           : tak_all_command_glob;
            tabid             : tsp00_Int4;
            VAR sequence_info : tgg00_SeqInfo;
            VAR moveobj       : tsp00_MoveObj;
            moveobj_size      : tsp00_Int4;
            number_pos        : tsp00_Int4;
            VAR number_len    : integer);
 
VAR
      ret           : tsp00_NumError;
      cmp_res       : tsp00_LcompResult;
      b_err         : tgg00_BasisError;
      resbytelen    : integer;
      sysbuf        : tak_sysbufferaddress;
      sysk          : tgg00_SysInfoKey;
 
BEGIN
sysk.stableid    := cgg_zero_id;
sysk.ssite       := cak_temp_table_site;
sysk.stemp       := tabid;
sysk.sentrytyp   := cak_etempdefault;
sysk.slinkage    := cak_init_linkage;
sysk.skeylen     := mxak_standard_sysk;
a10get_sysinfo (acv, sysk, d_release, sysbuf, b_err);
IF  b_err = e_ok
THEN
    WITH sysbuf^.ssequence DO
        BEGIN
&       ifdef trace
        t01moveobj (ak_sem, moveobj, number_pos, number_pos + number_len - 1);
&       endif
        IF  moveobj[number_pos+1] > csp_zero_exponent
        THEN
            BEGIN
            s30cmp (moveobj, number_pos + 1, number_len - 1,
                  seq_value, 1, sizeof (seq_value), cmp_res);
            IF  cmp_res = l_greater
            THEN
                BEGIN
                seq_value := csp_null_number;
                SAPDB_PascalMove ('VAK05 ',   2,    
                      moveobj_size, sizeof (seq_value), @moveobj,
                      number_pos + 1, @seq_value, 1, number_len - 1, b_err)
                END
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            s51add (seq_value, 1, sizeof (seq_value),
                  sequence_info.seq_increment, 1,
                  sizeof(sequence_info.seq_increment),
                  seq_value, 1, csp_fixed, 0, resbytelen, ret);
            IF  ret <> num_ok
            THEN
                k71num_err_to_b_err (ret, b_err)
            ELSE
                IF  seq_value > sequence_info.seq_maxvalue
                THEN
                    seq_value := sequence_info.seq_minvalue;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  b_err = e_ok
            THEN
                BEGIN
                number_len := sizeof (seq_value);
                WHILE seq_value[number_len] = chr(0) DO
                    number_len := number_len - 1;
                (*ENDWHILE*) 
                moveobj[number_pos] := csp_defined_byte;
                SAPDB_PascalMove ('VAK05 ',   3,    
                      sizeof (seq_value), moveobj_size,
                      @seq_value, 1, @moveobj, number_pos + 1, number_len,
                      b_err);
                number_len := number_len + 1
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            a10mark_updated (sysbuf)
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  b_err <> e_ok
THEN
    a07_b_put_error (acv, b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05get_digit (
            VAR num_buf  : tsp00_MoveObj;
            pos          : integer;
            length       : integer;
            VAR dig_len  : integer;
            VAR dig_frac : integer);
 
VAR
      temp_space : tsp00_C512;
      temp_mptr  : tsp00_MoveObjPtr;
      uni_len    : tsp00_Int4;
      err_char_no: tsp00_Int4;
      uni_err    : tsp8_uni_error;
      intern_num : tsp00_Number;
      byte_len   : integer;
      err        : tsp00_NumError;
 
BEGIN
&ifdef trace
t01moveobj (ak_sem, num_buf, pos, pos + length - 1);
&endif
IF  g01unicode
THEN
    BEGIN
    uni_len := sizeof (temp_space);
    s80uni_trans (@num_buf[ pos ], length, csp_unicode,
          @temp_space, uni_len, csp_ascii, [ ], uni_err,
          err_char_no);
    IF  uni_err = uni_ok
    THEN
        BEGIN
        temp_mptr := @temp_space;
        s43pstr2 (intern_num, 1, csp_fixed, csp_float_frac,
              temp_mptr^, 1, uni_len, err)
        END
    ELSE
        err := num_invalid
    (*ENDIF*) 
    END
ELSE
    s43pstr2 (intern_num, 1, csp_fixed, csp_float_frac,
          num_buf, pos, length, err);
(*ENDIF*) 
&ifdef trace
temp_mptr := @intern_num;
t01moveobj (ak_sem, temp_mptr^, 1, sizeof (intern_num));
&endif
IF  err = num_ok
THEN
    s43lfrac (intern_num, 1, sizeof (intern_num),
          dig_len, dig_frac, byte_len)
ELSE
    BEGIN
    dig_len  := 0;
    dig_frac := 0
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05get_err_tabid (
            VAR t       : tgg00_TransContext;
            VAR tree    : tgg00_FileId;
            VAR tableid : tgg00_Surrogate);
 
VAR
 
      err_tabid  : RECORD
            CASE boolean OF
                false :
                    (surrogate : tgg00_Surrogate);
                true :
                    (site : tgg00_ServerdbNo;
                    fill  : tsp00_C2;
                    id    : tsp00_Int4);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  tree.fileTfn_gg00 <> tfnTemp_egg00
THEN
    tableid := tree.fileTabId_gg00
ELSE
    BEGIN
    err_tabid.surrogate := cgg_zero_id;
    err_tabid.site      := cak_temp_table_site;
    err_tabid.id        := bd998GetTempFileIndex (t, tree);
    tableid             := err_tabid.surrogate
    END;
(*ENDIF*) 
END;
 
(* PTS 1128197 D.T. *)
(*------------------------------*) 
 
PROCEDURE
      a05_identifier_get_from_buffer(
            VAR acv            : tak_all_command_glob;
            VAR SourceBuffer   : tsp00_MoveObj;
            BufferLength       : tsp00_Int4;
            IdentifierPosition : tsp00_Int4;
            IdentifierLength   : tsp00_Int2;
            ComplexStringID    : boolean;
            ObjLength          : integer;
            VAR MoveObj        : tsp00_MoveObj);
 
CONST
      c_ansi_identifier_len   = 18;
      c_db2_identifier_len    = 18;
      c_oracle_identifier_len = 32;
 
VAR
      e                  : tgg00_BasisError;
      def_byte           : char;
      pos                : tsp00_Int4;
      max_identifier_len : integer;
      diff               : integer;
      identifier_len     : integer;
      obj_pos            : integer;
 
BEGIN
e := e_ok;
(* makes a migration to a UNICODE database possible  *)
CASE acv.a_sqlmode OF
    sqlm_ansi :
        max_identifier_len := c_ansi_identifier_len;
    sqlm_db2 :
        max_identifier_len := c_db2_identifier_len;
    sqlm_oracle :
        max_identifier_len := c_oracle_identifier_len;
    OTHERWISE
        max_identifier_len := sizeof (tsp00_KnlIdentifier) DIV 2;
    END;
(*ENDCASE*) 
IF  max_identifier_len > ObjLength DIV a01char_size
THEN
    max_identifier_len := ObjLength DIV a01char_size;
&ifdef trace
(*ENDIF*) 
t01int4 (ak_sem, 'max_identifi', max_identifier_len);
&endif
pos := abs(IdentifierPosition);
obj_pos := 1;
IF  ComplexStringID
THEN
    BEGIN
    (* PTS 1000370 E.Z. *)
    diff   := 0;
    (* special identifier with " ... *)
    IF  NOT g01unicode
    THEN
        BEGIN
        (* ... no unicode *)
        WHILE pos - diff < IdentifierPosition + IdentifierLength DO
            BEGIN
            IF  obj_pos > max_identifier_len
            THEN
                BEGIN
                (* PTS 1105437 GG *)
                IF  NOT a01is_whitespace_char( SourceBuffer, pos )
                THEN
                    BEGIN
                    (* PTS 1117265 E.Z. *)
                    pos := IdentifierPosition + IdentifierLength + diff;
                    e   := e_identifier_too_long
                    END
                (*ENDIF*) 
                END
            ELSE
                MoveObj[obj_pos] := SourceBuffer[pos];
            (*ENDIF*) 
            obj_pos := obj_pos + 1;
            IF  SourceBuffer[pos] = '"'
            THEN
                BEGIN
                diff := succ(diff);
                pos := pos + 2
                END
            ELSE
                pos := pos + 1;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        END
    ELSE
        BEGIN
        (* ... unicode *)
        WHILE pos - diff < IdentifierPosition + IdentifierLength DO
            BEGIN
            IF  obj_pos > max_identifier_len * 2
            THEN
                BEGIN
                (* PTS 1105437 GG *)
                IF  NOT a01is_whitespace_char( SourceBuffer, pos )
                THEN
                    BEGIN
                    pos := IdentifierPosition + IdentifierLength + diff;
                    e   := e_identifier_too_long
                    END
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                MoveObj[obj_pos]   := SourceBuffer[pos];
                MoveObj[obj_pos+1] := SourceBuffer[pos+1];
                obj_pos            := obj_pos + 2;
                IF  (SourceBuffer[ pos ] = csp_unicode_mark)
                    AND (SourceBuffer[ pos + 1 ] = '"')
                THEN
                    BEGIN
                    diff := diff+2;
                    pos := pos + 4
                    END
                ELSE
                    pos := pos + 2;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    END
ELSE
    BEGIN
    IF  g01unicode
    THEN
        def_byte := csp_unicode_def_byte
    ELSE
        def_byte := bsp_c1;
    (*ENDIF*) 
    identifier_len := s30lnr_defbyte (@SourceBuffer, def_byte,
          pos, IdentifierLength);
&   ifdef trace
    t01int4 (ak_sem, 'identifier_l', identifier_len);
&   endif
    IF  identifier_len > max_identifier_len * a01char_size
    THEN
        e := e_identifier_too_long
    ELSE
        BEGIN
        IF  ( identifier_len = 0 )
        THEN
            e := e_missing_identifier
        ELSE
            BEGIN
            SAPDB_PascalMove ('VAK05 ',   4,    
                  BufferLength, sizeof (MoveObj),
                  @SourceBuffer, pos, @MoveObj, 1,
                  identifier_len, acv.a_returncode);
            obj_pos := identifier_len + 1;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, abs(IdentifierPosition))
ELSE
    BEGIN
    IF  obj_pos <= ObjLength
    THEN
        IF  g01unicode
        THEN
            SAPDB_PascalUnicodeFill ('VAK05 ',   5,    
                  ObjLength, @MoveObj, obj_pos, ObjLength - obj_pos + 1,
                  csp_unicode_blank, acv.a_returncode)
        ELSE
            SAPDB_PascalFill ('VAK05 ',   6,    
                  sizeof (MoveObj), @MoveObj, obj_pos,
                  ObjLength - obj_pos + 1, bsp_c1,
                  acv.a_returncode)
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05_identifier_get (
            VAR acv     : tak_all_command_glob;
            tree_index  : integer;
            obj_len     : integer;
            VAR moveobj : tsp00_MoveObj);
 
BEGIN
a05_identifier_get_from_buffer (acv,
      acv.a_cmd_part^.sp1p_buf, acv.a_cmd_part^.sp1p_buf_size,
      acv.a_ap_tree^[tree_index].n_pos, acv.a_ap_tree^[tree_index].n_length,
      (ni_complex_string_id in acv.a_ap_tree^[tree_index].n_special),
      obj_len, moveobj);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05identifier_get (
            VAR acv     : tak_all_command_glob;
            tree_index  : integer;
            obj_len     : integer;
            VAR moveobj : tsp00_MoveObj);
 
BEGIN
a05_identifier_get_from_buffer (acv,
      acv.a_cmd_part^.sp1p_buf, acv.a_cmd_part^.sp1p_buf_size,
      acv.a_ap_tree^[tree_index].n_pos, acv.a_ap_tree^[tree_index].n_length,
      (ni_complex_string_id in acv.a_ap_tree^[tree_index].n_special),
      obj_len, moveobj);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05return_serial (
            VAR acv          : tak_all_command_glob;
            VAR first_serial : tsp00_Number;
            VAR last_serial  : tsp00_Number);
 
BEGIN
IF  (first_serial <> csp_null_number) AND
    (last_serial <> csp_null_number)
THEN
    BEGIN
    IF  acv.a_first_serial = csp_null_number
    THEN
        BEGIN
        acv.a_first_serial := first_serial;
        acv.a_last_serial  := last_serial
        END
    ELSE
        acv.a_last_serial  := last_serial
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05serial (
            VAR acv        : tak_all_command_glob;
            VAR colinfo    : tak00_columninfo;
            VAR treeid     : tgg00_FileId;
            VAR moveobj    : tsp00_MoveObj;
            moveobj_size   : tsp00_Int4;
            number_pos     : tsp00_Int4;
            VAR number_len : integer;
            with_retpart   : boolean);
 
VAR
      b_err    : tgg00_BasisError;
      mblock   : tgg00_MessBlock;
      ldata    : tsp00_C20;
      seq_info : tgg00_SeqInfo;
 
      lqual    : RECORD
            m_seq_id    : tgg00_Surrogate;
            m_seq_value : tsp00_Number;
      END;
 
      serial_n : tsp00_Number;
 
BEGIN
IF  moveobj[number_pos] <> csp_undef_byte
THEN
    IF  moveobj[number_pos+1] < csp_zero_exponent
    THEN
        a07_b_put_error (acv, e_range_violation, 1)
    ELSE
        IF  acv.a_cmd_segment_header.sp1c_mess_type <> sp1m_parse
        THEN
            BEGIN
            IF  moveobj[number_pos+1] = csp_zero_exponent
            THEN
                BEGIN
                seq_info                 := k71serial_seq_info;
                seq_info.seq_maxvalue[1] := chr(192 + colinfo.cdatalen);
                seq_info.seq_site        := cgg_zero_c2;
                IF  treeid.fileTfn_gg00 = tfnTemp_egg00
                THEN
                    ak05temp_serial (acv,
                          a101_GetTempFileIndex (acv, treeid), seq_info,
                          moveobj, moveobj_size, number_pos, number_len)
                ELSE
                    a05_nextval_get (acv, mm_nil, treeid.fileTabId_gg00,
                          seq_info, moveobj, number_pos, number_len);
                (*ENDIF*) 
                IF  colinfo.cbinary
                THEN
                    a05int_range_check (acv, moveobj, number_pos, number_len-1,
                          colinfo.cdatalen, 1);
                (*ENDIF*) 
                IF  (colinfo.ccolstack.etype in [st_fixkey, st_fixcol])
                    AND
                    (number_len < colinfo.cinoutlen)
                THEN
                    BEGIN
                    SAPDB_PascalFill ('VAK05 ',   7,    
                          moveobj_size, @moveobj, number_pos + number_len,
                          colinfo.cinoutlen - number_len,
                          csp_defined_byte,
                          acv.a_returncode);
                    number_len := colinfo.cinoutlen
                    END
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  colinfo.cbinary
                THEN
                    a05int_range_check (acv, moveobj, number_pos, number_len-1,
                          colinfo.cdatalen, 1);
                (*ENDIF*) 
                IF  treeid.fileTfn_gg00 = tfnTemp_egg00
                THEN
                    ak05temp_serial (acv,
                          a101_GetTempFileIndex (acv, treeid), seq_info,
                          moveobj, moveobj_size, number_pos, number_len)
                ELSE
                    BEGIN
                    g01mblock_init (acv.a_transinf.tri_trans,
                          m_nextval, mm_write, mblock);
                    WITH mblock DO
                        BEGIN
                        mb_struct    := mbs_buf;
                        mb_data      := @ldata;
                        mb_data_size := sizeof (ldata);
                        mb_qual      := @lqual;
                        mb_qual_size := sizeof (lqual);
                        END;
                    (*ENDWITH*) 
                    lqual.m_seq_id      := treeid.fileTabId_gg00;
                    SAPDB_PascalMove ('VAK05 ',   8,    
                          moveobj_size, sizeof (lqual.m_seq_value),
                          @moveobj, number_pos + 1,
                          @lqual.m_seq_value, 1, number_len - 1,
                          acv.a_returncode);
                    mblock.mb_qual_len := sizeof (lqual.m_seq_id) + number_len - 1;
                    a06rsend_mess_buf (acv, mblock, cak_return_req, b_err);
                    IF  b_err <> e_ok
                    THEN
                        a07_b_put_error (acv, b_err, 1)
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            (* PTS 1118423 E.Z. *)
            IF  with_retpart              AND
                (acv.a_trigger_level = 0) AND
                (acv.a_returncode = 0)
            THEN
                BEGIN
                serial_n := csp_null_number;
                SAPDB_PascalMove ('VAK05 ',   9,    
                      moveobj_size, sizeof (serial_n),
                      @moveobj, number_pos + 1,
                      @serial_n, 1, number_len - 1,
                      acv.a_returncode);
                a05return_serial (acv, serial_n, serial_n);
                END;
            (*ENDIF*) 
            END
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(* PTS 1112983 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a05string_literal_get (
            VAR acv     : tak_all_command_glob;
            tree_index  : integer;
            datatyp     : tsp00_DataType;
            VAR moveobj : tsp00_MoveObj;
            obj_pos     : integer;
            obj_len     : integer);
 
VAR
      stop             : boolean;
      pos              : tsp00_Int4;
      startpos         : tsp00_Int4;
      first_pos_behind : tsp00_Int4;
      curr_len         : tsp00_Int4;
      diff             : integer;
      err_char_no      : tsp00_Int4;
      uni_err          : tsp8_uni_error;
&     ifdef TRACE
      abs_n_pos        : tsp00_Int4;
&     endif
 
BEGIN
WITH acv, a_ap_tree^[tree_index] DO
    BEGIN
&   ifdef TRACE
    abs_n_pos := abs (n_pos);
    t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, abs_n_pos,
          abs_n_pos + n_length - 1);
&   endif
    first_pos_behind := obj_pos;
    IF  ni_complex_string_id in n_special
    THEN
        BEGIN
        (* complex string literal containing '' *)
        pos    := abs (n_pos);
        diff   := 0;
        WHILE pos-diff < n_pos+n_length DO
            BEGIN
            startpos := pos;
            stop     := false;
            IF  NOT g01unicode
            THEN
                BEGIN
                WHILE (pos-diff < n_pos+n_length) AND (NOT stop) DO
                    BEGIN
                    IF  a_cmd_part^.sp1p_buf[pos] = ''''
                    THEN
                        BEGIN
                        stop := true;
                        diff := succ(diff);
                        END;
                    (*ENDIF*) 
                    pos := pos + 1;
                    END;
                (*ENDWHILE*) 
                IF  obj_len < first_pos_behind - obj_pos + (pos-startpos) * a01char_size
                THEN
                    BEGIN
                    a07_b_put_error (acv, e_const_incompatible_with_typ, abs(n_pos));
                    pos := n_pos + n_length + diff
                    END
                ELSE
                    IF  datatyp <> dunicode
                    THEN
                        BEGIN
                        SAPDB_PascalOverlappingMove ('VAK05 ',  10,    
                              a_cmd_part^.sp1p_buf_size, sizeof (moveobj),
                              @a_cmd_part^.sp1p_buf, startpos,
                              @moveobj, first_pos_behind, pos-startpos,
                              a_returncode);
                        first_pos_behind := first_pos_behind + pos-startpos;
                        END
                    ELSE
                        BEGIN
                        curr_len := (pos-startpos) * 2;
                        s80uni_trans (@(a_cmd_part^.sp1p_buf[startpos]), pos-startpos,
                              csp_ascii, @moveobj[ first_pos_behind ], curr_len,
                              csp_unicode, [ ], uni_err, err_char_no);
                        IF  uni_err = uni_ok
                        THEN
                            first_pos_behind := first_pos_behind + curr_len
                        ELSE
                            BEGIN
                            IF  (uni_err = uni_not_translatable) OR
                                (uni_err = uni_dest_too_short)
                            THEN
                                a07_b_put_error (acv,
                                      e_const_incompatible_with_typ, pos)
                            ELSE
                                a07_hex_uni_error (acv, uni_err,
                                      n_pos-1 + err_char_no, c_trans_to_uni,
                                      @(a_cmd_part^.sp1p_buf[startpos+err_char_no-1]),
                                      c_ascii_wid);
                            (*ENDIF*) 
&                           ifdef TRACE
                            t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, startpos, pos);
                            t01moveobj (ak_sem, moveobj, first_pos_behind,
                                  first_pos_behind+curr_len-1);
&                           endif
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  stop
                THEN
                    pos := pos + 1
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                WHILE (pos-diff < n_pos+n_length) AND (NOT stop) DO
                    BEGIN
                    IF  (a_cmd_part^.sp1p_buf[pos] = csp_unicode_mark)
                        AND (a_cmd_part^.sp1p_buf[pos+1] = '''')
                    THEN
                        BEGIN
                        stop := true;
                        diff := diff + 2
                        END;
                    (*ENDIF*) 
                    pos := pos + 2;
                    END;
                (*ENDWHILE*) 
                IF  datatyp = dunicode
                THEN
                    IF  obj_len < first_pos_behind - obj_pos + pos - startpos
                    THEN
                        BEGIN
                        a07_b_put_error (acv, e_const_incompatible_with_typ, abs(n_pos));
                        pos := n_pos + n_length + diff
                        END
                    ELSE
                        BEGIN
                        SAPDB_PascalOverlappingMove ('VAK05 ',  11,    
                              a_cmd_part^.sp1p_buf_size, sizeof (moveobj),
                              @a_cmd_part^.sp1p_buf, startpos,
                              @moveobj, first_pos_behind, pos-startpos,
                              a_returncode);
                        first_pos_behind := first_pos_behind + pos-startpos;
                        END
                    (*ENDIF*) 
                ELSE
                    IF  obj_len < first_pos_behind - obj_pos + (pos-startpos) DIV 2
                    THEN
                        BEGIN
                        a07_b_put_error (acv, e_const_incompatible_with_typ, abs(n_pos));
                        pos := n_pos + n_length + diff
                        END
                    ELSE
                        BEGIN
                        curr_len := (pos-startpos) DIV 2;
                        s80uni_trans (@(a_cmd_part^.sp1p_buf[startpos]), pos-startpos,
                              csp_unicode, @moveobj[ first_pos_behind ],
                              curr_len, csp_ascii, [ ], uni_err, err_char_no);
                        IF  uni_err = uni_ok
                        THEN
                            first_pos_behind := first_pos_behind + curr_len
                        ELSE
                            BEGIN
                            IF  (uni_err = uni_not_translatable) OR
                                (uni_err = uni_dest_too_short)
                            THEN
                                a07_b_put_error (acv,
                                      e_const_incompatible_with_typ, pos)
                            ELSE
                                a07_hex_uni_error (acv, uni_err,
                                      n_pos-1 + err_char_no, c_trans_from_uni,
                                      @(a_cmd_part^.sp1p_buf[startpos+err_char_no-1]),
                                      c_unicode_wid);
                            (*ENDIF*) 
&                           ifdef TRACE
                            t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, startpos, pos);
                            t01moveobj (ak_sem, moveobj, first_pos_behind,
                                  first_pos_behind+curr_len-1);
&                           endif
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  stop
                THEN
                    pos := pos + 2
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        END
    ELSE
        IF  ((datatyp <> dunicode) AND
            g01unicode)
        THEN
            BEGIN
&           ifdef TRACE
            t01int4 (ak_sem, 'normal char ', 1);
&           endif
            curr_len := obj_len;
            s80uni_trans (@(a_cmd_part^.sp1p_buf[abs(n_pos)]), n_length, csp_unicode,
                  @moveobj[ obj_pos ], curr_len, csp_ascii, [ ],
                  uni_err, err_char_no);
            first_pos_behind := obj_pos + curr_len;
            IF  uni_err <> uni_ok
            THEN
                IF  (uni_err = uni_not_translatable) OR
                    (uni_err = uni_dest_too_short)
                THEN
                    a07_b_put_error (acv,
                          e_const_incompatible_with_typ, n_pos)
                ELSE
                    a07_uni_error (acv, uni_err, n_pos-1 + err_char_no);
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            IF  ((datatyp = dunicode) AND
                NOT g01unicode)
            THEN
                BEGIN
&               ifdef TRACE
                t01int4 (ak_sem, 'unicode     ', 1);
                t01int4 (ak_sem, 'obj_len     ', obj_len);
&               endif
                curr_len := obj_len;
                s80uni_trans (@(a_cmd_part^.sp1p_buf[abs(n_pos)]), n_length,
                      a_cmd_packet_header.sp1h_mess_code,
                      @moveobj[ obj_pos ], curr_len, csp_unicode, [ ],
                      uni_err, err_char_no);
                first_pos_behind := obj_pos + curr_len;
                IF  uni_err <> uni_ok
                THEN
                    IF  uni_err = uni_dest_too_short
                    THEN
                        a07_b_put_error (acv,
                              e_const_incompatible_with_typ, n_pos)
                    ELSE
                        a07_hex_uni_error (acv, uni_err,
                              n_pos-1 + err_char_no, c_trans_to_uni,
                              @(a_cmd_part^.sp1p_buf[abs(n_pos)+err_char_no-1]),
                              a_max_codewidth);
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                IF  n_length > obj_len
                THEN
                    a07_b_put_error (acv, e_const_incompatible_with_typ, abs(n_pos))
                ELSE
                    BEGIN
                    SAPDB_PascalOverlappingMove ('VAK05 ',  12,    
                          a_cmd_part^.sp1p_buf_size, sizeof (moveobj),
                          @a_cmd_part^.sp1p_buf, abs (n_pos),
                          @moveobj, obj_pos, n_length,
                          a_returncode);
                    first_pos_behind := obj_pos + n_length;
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
&   ifdef TRACE
    t01moveobj (ak_sem, moveobj, obj_pos, first_pos_behind-1);
&   endif
    IF  a_returncode = 0
    THEN
        IF  first_pos_behind < obj_pos + obj_len
        THEN
            IF  datatyp = dunicode
            THEN
                SAPDB_PascalUnicodeFill ('VAK05 ',  13,    
                      obj_pos + obj_len, @moveobj, first_pos_behind,
                      obj_pos + obj_len - first_pos_behind,
                      csp_unicode_blank, a_returncode)
            ELSE
                SAPDB_PascalFill ('VAK05 ',  14,    
                      sizeof (moveobj), @moveobj, first_pos_behind,
                      obj_pos + obj_len - first_pos_behind, bsp_c1,
                      a_returncode);
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05long_literal_get (
            VAR acv     : tak_all_command_glob;
            tree_index  : integer;
            datatyp     : tsp00_DataType;
            VAR moveobj : tsp00_MoveObj;
            obj_pos     : integer;
            VAR obj_len : integer);
 
VAR
      invalid          : boolean;
      stop             : boolean;
      pos              : tsp00_Int4;
      startpos         : tsp00_Int4;
      first_pos_behind : tsp00_Int4;
      curr_len         : tsp00_Int4;
      diff             : integer;
      err_char_no      : tsp00_Int4;
      uni_len          : tsp00_Int4;
      uni_err          : tsp8_uni_error;
&     ifdef TRACE
      abs_n_pos        : tsp00_Int4;
&     endif
 
BEGIN
WITH acv, a_ap_tree^[tree_index] DO
    BEGIN
&   ifdef TRACE
    abs_n_pos := abs(n_pos);
    t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, abs_n_pos,
          abs_n_pos + n_length - 1);
&   endif
    IF  n_symb = s_byte_string
    THEN
        BEGIN
        invalid := false;
        IF  g01unicode
        THEN
            BEGIN
            uni_len := obj_len;
            s80uni_trans (@(a_cmd_part^.sp1p_buf[n_pos]), n_length, csp_unicode,
                  @moveobj[ obj_pos ], uni_len, csp_ascii, [ ], uni_err,
                  err_char_no);
            curr_len := uni_len DIV 2;
            IF  uni_err = uni_ok
            THEN
                s41pbyte (moveobj, obj_pos, curr_len,
                      moveobj, obj_pos, uni_len, invalid)
            ELSE
                IF  uni_err = uni_dest_too_short
                THEN
                    a07_b_put_error (acv, e_too_many_mb_data, n_pos)
                ELSE
                    a07_hex_uni_error (acv, uni_err,
                          n_pos-1 + err_char_no, c_trans_from_uni,
                          @(a_cmd_part^.sp1p_buf[n_pos+err_char_no-1]),
                          c_unicode_wid);
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            curr_len := n_length DIV 2;
            IF  obj_pos + curr_len - 1 > obj_len
            THEN
                a07_b_put_error (acv, e_too_many_mb_data, n_pos)
            ELSE
                s41pbyte (moveobj, obj_pos, curr_len,
                      a_cmd_part^.sp1p_buf, n_pos, n_length, invalid);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  invalid
        THEN
            a07_b_put_error (acv,
                  e_const_incompatible_with_typ, n_pos);
        (*ENDIF*) 
        obj_len := curr_len;
        END
    ELSE
        BEGIN
        first_pos_behind := obj_pos;
        IF  ni_complex_string_id in n_special
        THEN
            BEGIN
            (* complex string literal containing '' *)
            pos    := abs (n_pos);
            diff   := 0;
            WHILE pos-diff < n_pos+n_length DO
                BEGIN
                startpos := pos;
                stop     := false;
                IF  NOT g01unicode
                THEN
                    BEGIN
                    WHILE (pos-diff < n_pos+n_length) AND (NOT stop) DO
                        BEGIN
                        IF  a_cmd_part^.sp1p_buf[pos] = ''''
                        THEN
                            BEGIN
                            stop := true;
                            diff := succ(diff);
                            END;
                        (*ENDIF*) 
                        pos := pos + 1;
                        END;
                    (*ENDWHILE*) 
                    IF  (datatyp <> dstruni) AND
                        (datatyp <> dlonguni)
                    THEN
                        BEGIN
                        SAPDB_PascalMove ('VAK05 ',  15,    
                              a_cmd_part^.sp1p_buf_size, sizeof (moveobj),
                              @a_cmd_part^.sp1p_buf, startpos,
                              @moveobj, first_pos_behind, pos-startpos,
                              a_returncode);
                        first_pos_behind := first_pos_behind + pos-startpos;
                        END
                    ELSE
                        BEGIN
                        curr_len := (pos-startpos) * 2;
                        s80uni_trans (@(a_cmd_part^.sp1p_buf[startpos]), pos-startpos,
                              csp_ascii, @moveobj[ first_pos_behind ], curr_len,
                              csp_unicode, [ ], uni_err, err_char_no);
                        IF  uni_err = uni_ok
                        THEN
                            first_pos_behind := first_pos_behind + curr_len
                        ELSE
                            BEGIN
                            IF  (uni_err = uni_not_translatable) OR
                                (uni_err = uni_dest_too_short)
                            THEN
                                a07_b_put_error (acv,
                                      e_const_incompatible_with_typ, pos)
                            ELSE
                                a07_hex_uni_error (acv, uni_err,
                                      n_pos-1 + err_char_no, c_trans_to_uni,
                                      @(a_cmd_part^.sp1p_buf[startpos+err_char_no-1]),
                                      c_ascii_wid);
                            (*ENDIF*) 
&                           ifdef TRACE
                            t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, startpos, pos);
                            t01moveobj (ak_sem, moveobj, first_pos_behind,
                                  first_pos_behind+curr_len-1);
&                           endif
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  stop
                    THEN
                        pos := pos + 1
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    WHILE (pos-diff < n_pos+n_length) AND (NOT stop) DO
                        BEGIN
                        IF  (a_cmd_part^.sp1p_buf[pos] = csp_unicode_mark)
                            AND (a_cmd_part^.sp1p_buf[pos+1] = '''')
                        THEN
                            BEGIN
                            stop := true;
                            diff := diff + 2
                            END;
                        (*ENDIF*) 
                        pos := pos + 2;
                        END;
                    (*ENDWHILE*) 
                    IF  (datatyp = dstruni) OR
                        (datatyp = dlonguni)
                    THEN
                        BEGIN
                        SAPDB_PascalMove ('VAK05 ',  16,    
                              a_cmd_part^.sp1p_buf_size, sizeof (moveobj),
                              @a_cmd_part^.sp1p_buf, startpos,
                              @moveobj, first_pos_behind, pos-startpos,
                              a_returncode);
                        first_pos_behind := first_pos_behind + pos-startpos;
                        END
                    ELSE
                        BEGIN
                        curr_len := (pos-startpos) DIV 2;
                        s80uni_trans (@(a_cmd_part^.sp1p_buf[startpos]), pos-startpos,
                              csp_unicode, @moveobj[ first_pos_behind ],
                              curr_len, csp_ascii, [ ], uni_err, err_char_no);
                        IF  uni_err = uni_ok
                        THEN
                            first_pos_behind := first_pos_behind + curr_len
                        ELSE
                            BEGIN
                            IF  (uni_err = uni_not_translatable) OR
                                (uni_err = uni_dest_too_short)
                            THEN
                                a07_b_put_error (acv,
                                      e_const_incompatible_with_typ, pos)
                            ELSE
                                a07_hex_uni_error (acv, uni_err,
                                      n_pos-1 + err_char_no, c_trans_from_uni,
                                      @(a_cmd_part^.sp1p_buf[startpos+err_char_no-1]),
                                      c_unicode_wid);
                            (*ENDIF*) 
&                           ifdef TRACE
                            t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, startpos, pos);
                            t01moveobj (ak_sem, moveobj, first_pos_behind,
                                  first_pos_behind+curr_len-1);
&                           endif
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  stop
                    THEN
                        pos := pos + 2
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            END
        ELSE
            IF  ((datatyp <> dstruni) AND
                (datatyp <> dlonguni)
                AND
                g01unicode)
            THEN
                BEGIN
&               ifdef TRACE
                t01int4 (ak_sem, 'normal char ', 1);
&               endif
                curr_len := obj_len;
                s80uni_trans (@(a_cmd_part^.sp1p_buf[abs(n_pos)]), n_length, csp_unicode,
                      @moveobj[ obj_pos ], curr_len, csp_ascii, [ ],
                      uni_err, err_char_no);
                first_pos_behind := obj_pos + curr_len;
                IF  uni_err <> uni_ok
                THEN
                    IF  (uni_err = uni_not_translatable) OR
                        (uni_err = uni_dest_too_short)
                    THEN
                        a07_b_put_error (acv,
                              e_const_incompatible_with_typ, n_pos)
                    ELSE
                        a07_uni_error (acv, uni_err, n_pos-1 + err_char_no);
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                IF  (((datatyp = dstruni) OR
                    (datatyp = dlonguni)) AND
                    NOT g01unicode)
                THEN
                    BEGIN
&                   ifdef TRACE
                    t01int4 (ak_sem, 'unicode     ', 1);
                    t01int4 (ak_sem, 'obj_len     ', obj_len);
&                   endif
                    curr_len := obj_len;
                    s80uni_trans (@(a_cmd_part^.sp1p_buf[abs(n_pos)]), n_length,
                          a_cmd_packet_header.sp1h_mess_code,
                          @moveobj[ obj_pos ], curr_len, csp_unicode, [ ],
                          uni_err, err_char_no);
                    first_pos_behind := obj_pos + curr_len;
                    IF  uni_err <> uni_ok
                    THEN
                        IF  uni_err = uni_dest_too_short
                        THEN
                            a07_b_put_error (acv,
                                  e_const_incompatible_with_typ, n_pos)
                        ELSE
                            a07_hex_uni_error (acv, uni_err,
                                  n_pos-1 + err_char_no, c_trans_to_uni,
                                  @(a_cmd_part^.sp1p_buf[abs(n_pos)+err_char_no-1]),
                                  a_max_codewidth);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    SAPDB_PascalMove ('VAK05 ',  17,    
                          a_cmd_part^.sp1p_buf_size, sizeof (moveobj),
                          @a_cmd_part^.sp1p_buf, abs (n_pos),
                          @moveobj, obj_pos, n_length,
                          a_returncode);
                    first_pos_behind := obj_pos + n_length;
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        obj_len := first_pos_behind - obj_pos;
        END;
    (*ENDIF*) 
&   ifdef TRACE
    t01moveobj (ak_sem, moveobj, obj_pos, obj_len);
&   endif
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05RenameIdentifierInPacket (
            VAR acv           : tak_all_command_glob;
            VAR newIdentifier : tsp00_KnlIdentifier;
            VAR pos           : integer;
            VAR delta         : integer);
 
VAR
      _i          : integer;
      _old_len    : integer;
      _new_len    : tsp00_Int4;
      _id_pos     : tsp00_Int4;
      _vp_ptr     : tsp00_MoveObjPtr;
      _aux        : tsp00_C80;
 
BEGIN
_vp_ptr := @_aux;
IF  a01equal_char( acv.a_cmd_part^.sp1p_buf, pos - a01char_size, '"')
THEN
    (* identifier defined with quotes *)
    pos := pos - a01char_size;
(*ENDIF*) 
acv.a_scv.sc_newpos := pos;
a01_next_symbol( acv );
_old_len := acv.a_scv.sc_sylength + 2 * acv.a_scv.sc_double_quote;
_new_len := 1;
a05put_identifier( newIdentifier, _vp_ptr^, sizeof( _aux ), _new_len,
      acv.a_returncode );
_new_len := _new_len - 1;
delta    := _new_len - _old_len;
&ifdef trace
t01int4( ak_sem, 'old_len     ', _old_len );
t01int4( ak_sem, 'new_len     ', _new_len );
t01int4( ak_sem, 'delta       ', delta );
&endif
IF  acv.a_cmd_part^.sp1p_buf_len + delta > acv.a_cmd_part^.sp1p_buf_size
THEN
    a07_b_put_error( acv, e_too_small_packet_size, 1 )
ELSE
    BEGIN
    IF  delta < 0
    THEN
        SAPDB_PascalOverlappingMove('VAK05 ',  18,    
              acv.a_cmd_part^.sp1p_buf_size, acv.a_cmd_part^.sp1p_buf_size,
              @acv.a_cmd_part^.sp1p_buf, pos + _old_len,
              @acv.a_cmd_part^.sp1p_buf, pos + _new_len,
              acv.a_cmd_part^.sp1p_buf_len - ( pos + _old_len ) + 1,
              acv.a_returncode )
    ELSE
        IF  delta > 0
        THEN(* movcback is defined on buffer => *)
            (* cannot be used on variab_part    *)
            FOR _i := acv.a_cmd_part^.sp1p_buf_len DOWNTO pos DO
                acv.a_cmd_part^.sp1p_buf [ _i + delta ] :=
                      acv.a_cmd_part^.sp1p_buf [ _i ];
            (*ENDFOR*) 
        (*ENDIF*) 
    (*ENDIF*) 
    _id_pos := pos;
    a05put_identifier( newIdentifier, acv.a_cmd_part^.sp1p_buf,
          acv.a_cmd_part^.sp1p_buf_size, _id_pos,
          acv.a_returncode );
    acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len + delta;
&   ifdef trace
    t01moveobj( ak_sem, acv.a_cmd_part^.sp1p_buf, 1,
          acv.a_cmd_part^.sp1p_buf_len );
&   endif
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05temp_nextval (
            VAR data_part    : tsp00_MoveObj;
            data_size        : tsp00_Int4;
            VAR st_entry     : tgg00_StackEntry;
            VAR seq_info     : tgg00_SeqInfo;
            VAR moveobj      : tsp00_MoveObj;
            VAR moveobj_size : tsp00_Int4;
            result_pos       : tsp00_Int4;
            VAR result_len   : integer);
 
VAR
      acv_addr : tak_acv_address;
      tabid    : tsp00_Int4;
 
BEGIN
&ifdef trace
t01moveobj (ak_sem, moveobj,
      st_entry.epos, st_entry.epos + st_entry.elen_var - 1);
&endif
SAPDB_PascalForcedMove (data_size, sizeof (tabid),
      @data_part, st_entry.epos, @tabid, 1, sizeof (tabid));
SAPDB_PascalForcedMove (data_size, sizeof (acv_addr),
      @data_part, st_entry.epos + SURROGATE_MXGG00, @acv_addr, 1,
      sizeof (acv_addr));
ak05temp_serial (acv_addr^, tabid, seq_info,
      moveobj, moveobj_size, result_pos, result_len)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05_string_literal_get (
            VAR acv     : tak_all_command_glob;
            tree_index  : integer;
            datatyp     : tsp00_DataType;
            obj_len     : integer;
            VAR moveobj : tsp00_MoveObj);
 
BEGIN
a05string_literal_get (acv, tree_index, datatyp, moveobj, 1, obj_len)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05_str_literal_get (
            VAR acv     : tak_all_command_glob;
            tree_index  : integer;
            datatyp     : tsp00_DataType;
            VAR moveobj : tsp00_MoveObj;
            obj_pos     : integer;
            obj_len     : integer);
 
BEGIN
a05string_literal_get (acv, tree_index, datatyp, moveobj, obj_pos, obj_len)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05_unsigned_int2_get (
            VAR acv            : tak_all_command_glob;
            pos                : integer;
            l                  : tsp00_Int2;
            err_code           : tsp00_Int4;
            VAR val            : tsp00_Int2);
 
VAR
      int4 : tsp00_Int4;
 
BEGIN
IF  pos > 0
THEN
    ak05int4_get (acv, pos, l, NOT c_negativ, err_code, int4)
ELSE
    BEGIN
    int4 := 0;
    pos := -1;
    END;
(*ENDIF*) 
IF  (int4 > csp_maxint2) OR (int4 < 0)
THEN
    a07_b_put_error (acv, err_code, abs (pos))
ELSE
    val := int4
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05int4_get (
            VAR acv            : tak_all_command_glob;
            pos                : integer;
            l                  : tsp00_Int2;
            VAR val            : tsp00_Int4);
 
BEGIN
ak05int4_get (acv, abs (pos), l, pos < 0, e_invalid_unsign_integer, val)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05_int4_unsigned_get (
            VAR acv            : tak_all_command_glob;
            pos                : integer;
            l                  : tsp00_Int2;
            VAR val            : tsp00_Int4);
 
BEGIN
IF  pos > 0
THEN
    ak05int4_get (acv, pos, l, NOT c_negativ, e_invalid_unsign_integer, val)
ELSE
    val := -1;
(*ENDIF*) 
IF  val < 0
THEN
    a07_b_put_error (acv, e_invalid_unsign_integer, abs (pos))
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05_nextval_get (
            VAR acv      : tak_all_command_glob;
            m2_type      : tgg00_MessType2;
            VAR seq_id   : tgg00_Surrogate;
            VAR seq_info : tgg00_SeqInfo;
            VAR dest     : tsp00_MoveObj;
            destpos      : integer;
            VAR actlen   : integer);
 
VAR
      b_err   : tgg00_BasisError;
      mblock  : tgg00_MessBlock;
      ldata   : tsp00_C20;
 
      lqual   : RECORD
            m_seq_id   : tgg00_Surrogate;
            m_seq_info : tgg00_SeqInfo;
      END;
 
 
BEGIN
g01mblock_init (acv.a_transinf.tri_trans, m_nextval, m2_type, mblock);
WITH mblock DO
    BEGIN
    mb_struct    := mbs_buf;
    mb_data      := @ldata;
    mb_data_size := sizeof (ldata);
    mb_qual      := @lqual;
    mb_qual_size := sizeof (lqual);
    END;
(*ENDWITH*) 
lqual.m_seq_id      := seq_id;
lqual.m_seq_info    := seq_info;
mblock.mb_qual_len  := sizeof (lqual);
a06rsend_mess_buf (acv, mblock, cak_return_req, b_err);
IF  b_err <> e_ok
THEN
    a07_b_put_error (acv, b_err, 1)
ELSE
    BEGIN
    dest[destpos] := csp_defined_byte;
    SAPDB_PascalMove ('VAK05 ',  19,    
          mblock.mb_data_size, sizeof (dest),
          @mblock.mb_data^.mbp_buf, 1, @dest, destpos + 1,
          mblock.mb_data_len, acv.a_returncode);
    actlen := 1 + mblock.mb_data_len
    END;
(*ENDIF*) 
&ifdef TRACE
t01int4 (ak_sem, 'actlen nextv', actlen);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05_stamp_get (
            VAR acv    : tak_all_command_glob;
            VAR dest   : tsp00_MoveObj;
            destpos    : integer;
            mv_dest    : integer);
 
VAR
      b_err   : tgg00_BasisError;
      mblock  : tgg00_MessBlock;
      ldata   : tgg00_Surrogate;
 
BEGIN
g01mblock_init (acv.a_transinf.tri_trans, m_stamp, mm_key, mblock);
mblock.mb_struct               := mbs_buf;
mblock.mb_data                 := @ldata;
mblock.mb_data_size            := sizeof (ldata);
a06rsend_mess_buf (acv, mblock, cak_return_req, b_err);
IF  b_err <> e_ok
THEN
    a07_b_put_error (acv, b_err, 1)
ELSE
    SAPDB_PascalMove ('VAK05 ',  20,    
          mblock.mb_data_size, mv_dest, @mblock.mb_data^.mbp_buf, 1,
          @dest, destpos, SURROGATE_MXGG00,
          acv.a_returncode)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05surrogate_get (
            VAR acv        : tak_all_command_glob;
            VAR surrogate  : tgg00_Surrogate);
 
VAR
      b_err   : tgg00_BasisError;
      mblock  : tgg00_MessBlock;
 
BEGIN
g01mblock_init (acv.a_transinf.tri_trans, m_stamp, mm_table, mblock);
mblock.mb_struct    := mbs_buf;
mblock.mb_data      := @surrogate;
mblock.mb_data_size := sizeof (surrogate);
a06rsend_mess_buf (acv, mblock, cak_return_req, b_err);
IF  b_err <> e_ok
THEN
    a07_b_put_error (acv, b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05_transaction_get (
            VAR acv    : tak_all_command_glob;
            VAR dest   : tsp00_MoveObj;
            destpos    : integer;
            mv_dest    : integer);
 
BEGIN
SAPDB_PascalMove ('VAK05 ',  21,    
      sizeof(tgg91_TransNo), mv_dest,
      @acv.a_transinf.tri_trans.trTransId_gg00, 1,
      @dest, destpos, sizeof(acv.a_transinf.tri_trans.trTransId_gg00),
      acv.a_returncode)
END;
 
(* PTS 1117499 E.Z. *)
(* PTS 1121467 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak05get_uni_hex (VAR acv : tak_all_command_glob;
            VAR curr_n : tak_ap_node;
            mv_dest          : integer;
            VAR dest         : tsp00_MoveObj;
            pos              : integer;
            VAR l            : integer;
            VAR invalid      : boolean);
 
VAR
      uni_len    : tsp00_Int4;
      err_char_no: tsp00_Int4;
      uni_err    : tsp8_uni_error;
      p          : tsp00_MoveObjPtr;
 
BEGIN
WITH acv, curr_n DO
    BEGIN
    uni_len := (mv_dest + 1 - pos) * 2;
    p := gg941Allocate (acv.a_transinf.tri_trans, uni_len);
    IF  p = NIL
    THEN
        a07_b_put_error (acv, e_no_more_memory, 1)
    ELSE
        BEGIN
        s80uni_trans (@(a_cmd_part^.sp1p_buf[n_pos]), n_length, csp_unicode,
              p, uni_len, csp_ascii, [ ], uni_err,
              err_char_no);
        IF  uni_err = uni_ok
        THEN
            s41pbyte (dest, pos, l, p^, 1, uni_len, invalid)
        ELSE
            IF  uni_err = uni_dest_too_short
            THEN
                a07_b_put_error (acv, e_too_many_mb_data, n_pos)
            ELSE
                a07_hex_uni_error (acv, uni_err,
                      n_pos-1 + err_char_no, c_trans_from_uni,
                      @(a_cmd_part^.sp1p_buf[n_pos+err_char_no-1]),
                      c_unicode_wid);
            (*ENDIF*) 
        (*ENDIF*) 
        gg941Deallocate (acv.a_transinf.tri_trans, p);
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05_li_constant_get (
            VAR acv          : tak_all_command_glob;
            ni               : integer;
            VAR colinfo      : tak00_columninfo;
            orig_len         : integer;
            mv_dest          : integer;
            VAR dest         : tsp00_MoveObj;
            destpos          : integer;
            variable_length  : boolean;
            VAR actlen       : integer);
 
VAR
      b_err      : tgg00_BasisError;
      invalid    : boolean;
      trunc      : boolean;
      numtrunc   : boolean;
      trunc_char : char;
      l          : integer;
      j          : integer;
      pos        : integer;
      len        : integer;
      checklen   : integer;
      uni_len    : tsp00_Int4;
      err_char_no: tsp00_Int4;
      uni_err    : tsp8_uni_error;
      icolinfo   : tak00_columninfo;
      n          : tsp00_Number;
      num_err    : tsp00_NumError;
      c64        : tsp00_C64;
      l_is_actlen: boolean;
 
BEGIN
&ifdef trace
t01int4 (ak_sem, 'datatype    ', ord (colinfo.cdatatyp));
t01int4 (ak_sem, 'destpos     ', destpos);
t01int4 (ak_sem, 'mv_dest     ', mv_dest);
&endif
invalid     := false;
l_is_actlen := false;
numtrunc    := false;
l           := -1;
actlen      := 0;
WITH acv, a_ap_tree^[ ni ], colinfo, ccolstack DO
    BEGIN
    IF  destpos > mv_dest
    THEN
        a07_b_put_error (acv, e_too_many_mb_data, n_pos);
    (*ENDIF*) 
    trunc := true;
    trunc_char := csp_ascii_blank;
    IF  a_returncode = 0
    THEN
        BEGIN
        numtrunc := false;
        CASE  cdatatyp OF
            dunicode :
                dest[ destpos ] := csp_unicode_def_byte;
            dcha, ddate, dtime, dtimestamp :
                dest[ destpos ] := csp_ascii_blank;
            OTHERWISE
                dest[ destpos ] := csp_defined_byte;
            END;
        (*ENDCASE*) 
        trunc_char := dest[ destpos ];
        CASE  n_symb OF
            s_true :
                BEGIN
                IF  (cdatatyp <> dboolean)
                THEN
                    a07_b_put_error (acv,
                          e_const_incompatible_with_typ, n_pos)
                ELSE
                    IF  destpos + 1 > mv_dest
                    THEN
                        a07_b_put_error (acv, e_too_many_mb_data, n_pos)
                    ELSE
                        BEGIN
                        l := 1;
                        j := 0;
                        dest[ destpos + 1 ] := cgg04_truechar;
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            s_false :
                BEGIN
                IF  (cdatatyp <> dboolean)
                THEN
                    a07_b_put_error (acv,
                          e_const_incompatible_with_typ, n_pos)
                ELSE
                    IF  destpos + 1 > mv_dest
                    THEN
                        a07_b_put_error (acv, e_too_many_mb_data, n_pos)
                    ELSE
                        BEGIN
                        l := 1;
                        j := 0;
                        dest[ destpos + 1 ] := cgg04_falsechar;
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            s_byte_string :
                BEGIN
                IF  ((cdatatyp <> dchb)              OR
                    ((cdatalen < n_length DIV 2) AND
                    NOT g01unicode)           OR
                    ((cdatalen < n_length DIV 4) AND
                    g01unicode))
                THEN
                    a07_b_put_error (acv,
                          e_const_incompatible_with_typ, n_pos);
                (*ENDIF*) 
                IF  a_returncode = 0
                THEN
                    BEGIN
                    l := n_length DIV 2;
&                   ifdef trace
                    t01int4 (ak_sem, 'l           ', l);
                    t01int4 (ak_sem, 'destpos     ', destpos);
&                   endif
                    IF  ctcatalog in ccolpropset (* h.b. PTS 1105136 *)
                    THEN
                        pos := destpos
                    ELSE
                        pos := destpos + 1;
                    (*ENDIF*) 
                    IF  g01unicode
                    THEN
                        (* PTS 1117499 E.Z. *)
                        (* PTS 1121467 E.Z. *)
                        ak05get_uni_hex (acv, a_ap_tree^[ ni ], mv_dest, dest, pos, l,
                              invalid)
                    ELSE
                        IF  destpos + l > mv_dest
                        THEN
                            a07_b_put_error (acv, e_too_many_mb_data, n_pos)
                        ELSE
                            s41pbyte (dest, pos, l, a_cmd_part^.sp1p_buf,
                                  n_pos, n_length, invalid);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  pos = destpos
                    THEN
                        l := l - 1;
                    (*ENDIF*) 
                    IF  invalid
                    THEN
                        a07_b_put_error (acv,
                              e_const_incompatible_with_typ, n_pos);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            s_string_literal :
                BEGIN
                IF  (cdatatyp = dfixed)          OR
                    (cdatatyp = dfloat)          OR
                    (cdatatyp = dvfloat)         OR
                    (cdatatyp = dchb)            OR
                    (cdatatyp = dboolean)        OR
                    ((cdatalen < n_length DIV 2)
                    AND (cdatatyp = dunicode)
                    )                            OR
                    (
                    (    cdatatyp <> ddate)
                    AND (cdatatyp <> dtime)
                    AND (cdatatyp <> dtimestamp)
                    AND (cdatatyp <> dunicode)
                    AND
                    (((cdatalen < n_length) AND NOT g01unicode)
                    OR
                    ((cdatalen < n_length DIV 2) AND g01unicode))
                    )
                THEN
                    a07_b_put_error (acv,
                          e_const_incompatible_with_typ, n_pos)
                ELSE
                    BEGIN
                    l := n_length;
                    IF  (cdatatyp = dunicode) AND NOT g01unicode
                    THEN
                        IF  2*n_length < cinoutlen - 1
                        THEN
                            l := 2*n_length
                        ELSE
                            l := cinoutlen-1
                        (*ENDIF*) 
                    ELSE
                        IF  (cdatatyp = dcha) AND g01unicode
                        THEN
                            l := n_length DIV 2;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  mv_dest < destpos + l
                    THEN
                        a07_b_put_error (acv,
                              e_too_many_mb_data, n_pos)
                    ELSE
                        a05string_literal_get (acv, ni, cdatatyp,
                              dest, destpos + 1, l);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            s_unsigned_integer,
            s_fixed_point_literal,
            s_floating_point_literal :
                BEGIN
                ak05one_number (acv, ni, colinfo, mv_dest,
                      dest, destpos, trunc, l);
                numtrunc := trunc;
                END;
            s_plus, s_minus :
                BEGIN
                j   := n_lo_level;
                pos := n_pos;
                WITH a_ap_tree^[ j ] DO
                    BEGIN
                    len := n_pos - pos + n_length;
                    pos := a_ap_tree^[ ni ].n_length;
                    a_ap_tree^[ ni ].n_length := len;
                    ak05one_number (acv, ni, colinfo, mv_dest,
                          dest, destpos, trunc, l);
                    numtrunc := trunc;
                    a_ap_tree^[ ni ].n_length := pos;
                    END;
                (*ENDWITH*) 
                END;
            OTHERWISE
                a07_b_put_error (acv,
                      e_const_incompatible_with_typ, n_pos);
            END;
        (*ENDCASE*) 
        (* PTS 1116653 E.Z. *)
        IF  ((a_returncode <> 0)
            AND
            ((a_sqlmode = sqlm_oracle) OR
            (a_comp_type = at_odbc)    OR
            (a_comp_type = at_jdbc)    OR
            (a_comp_type = at_load)))
        THEN
            IF  a_returncode = a071_return_code (
                e_const_incompatible_with_typ,
                a_sqlmode)
            THEN
                BEGIN
                CASE a_ap_tree^[ ni ].n_symb OF
                    s_string_literal :
                        IF  ((cdatatyp = dfixed)  OR
                            ( cdatatyp = dfloat)  OR
                            ( cdatatyp = dvfloat))
                            AND
                            ((a_comp_type <> at_load)   OR
                            ( a_sqlmode = sqlm_oracle))
                        THEN
                            BEGIN
                            a_ap_tree^[ni].n_symb := s_floating_point_literal;
                            a_returncode := 0;
                            a_errorpos   := 0;
                            a05_li_constant_get (acv, ni, colinfo, colinfo.cinoutlen,
                                  mv_dest, dest, destpos, variable_length, l);
                            WITH colinfo DO
                                cinoutlen := (cdatalen + 1) DIV 2 + 2;
                            (*ENDWITH*) 
                            a_ap_tree^[ ni ].n_symb := s_string_literal;
                            (* PTS 1105376 E.Z. *)
                            l_is_actlen := true;
                            END
                        ELSE
                            IF  cdatatyp = dchb
                            THEN
                                BEGIN
                                n_symb             := s_byte_string;
                                a_returncode := 0;
                                a_errorpos   := 0;
                                a05_li_constant_get (acv, ni,
                                      colinfo, colinfo.cinoutlen,
                                      mv_dest, dest, destpos, variable_length, l);
                                l_is_actlen := true;
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    s_unsigned_integer,
                    s_fixed_point_literal,
                    s_floating_point_literal,
                    s_plus, s_minus :
                        IF  (cdatatyp = dcha)      OR
                            ( cdatatyp = dunicode)
                        THEN
                            BEGIN
                            a_returncode := 0;
                            a_errorpos   := 0;
                            icolinfo := colinfo;
                            WITH icolinfo DO
                                BEGIN
                                cdatatyp  := dfloat;
                                cdatalen  := cak_default_precision;
                                cinoutlen := (cdatalen + 1) DIV 2 + 2;
                                cdatafrac := csp_float_frac+1;
                                a05_li_constant_get (acv, ni,
                                      icolinfo, icolinfo.cinoutlen,
                                      mv_dest, dest, destpos, variable_length, l);
                                IF  a_returncode = 0
                                THEN
                                    IF  destpos + csp_fixed + 4
                                        (* reicht das fuer den Punkt etc. ?? *)
                                        > mv_dest
                                    THEN
                                        a07_b_put_error (acv, e_too_many_mb_data, n_pos)
                                    ELSE
                                        BEGIN
                                        n := csp_null_number;
                                        SAPDB_PascalMove ('VAK05 ',  22,    
                                              sizeof(dest), sizeof(n),
                                              @dest, destpos+1, @n, 1, l-1,
                                              a_returncode)
                                        END;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                IF  a_returncode = 0
                                THEN
                                    BEGIN
                                    s42gochr (n, 1, dest, destpos+1,
                                          l, num_err);
                                    IF  (num_err <> num_ok)
                                    THEN
                                        CASE num_err OF
                                            num_invalid :
                                                a07_b_put_error (acv,
                                                      e_num_invalid,
                                                      n_pos);
                                            num_trunc :
                                                a07_b_put_error (acv,
                                                      e_num_truncated,
                                                      n_pos);
                                            num_overflow :
                                                a07_b_put_error (acv,
                                                      e_num_overflow,
                                                      n_pos);
                                            END
                                        (*ENDCASE*) 
                                    ELSE
                                        (* PTS 1121799 E.Z. *)
                                        IF  l > colinfo.cdatalen
                                        THEN
                                            a07_b_put_error (acv,
                                                  e_num_truncated,
                                                  n_pos)
                                        ELSE
                                            CASE colinfo.cdatatyp OF
                                                dcha:
                                                    dest[ destpos ] := csp_ascii_blank;
                                                dunicode:
                                                    BEGIN
                                                    dest[ destpos ] := csp_unicode_def_byte;
                                                    SAPDB_PascalMove ('VAK05 ',  23,    
                                                       mv_dest, sizeof(c64),
                                                       @dest, destpos+1, @c64, 1, l,
                                                       a_returncode);
                                                    IF  a_returncode = 0
                                                    THEN
                                                     BEGIN
                                                     uni_len := mv_dest-destpos;
                                                     s80uni_trans (@c64, l, csp_ascii,
                                                        @dest[ destpos+1 ], uni_len,
                                                        csp_unicode,
                                                        [ ], uni_err, err_char_no);
                                                     IF  uni_err <> uni_ok
                                                     THEN
                                                      IF  uni_err = uni_not_translatable
                                                      THEN
                                                       a07_b_put_error (acv,
                                                          e_const_incompatible_with_typ, n_pos)
                                                      ELSE
                                                       a07_uni_error (acv, uni_err,
                                                          n_pos-1 + err_char_no)
                                                      (*ENDIF*) 
                                                     ELSE
                                                      l := uni_len
                                                     (*ENDIF*) 
                                                     END
                                                    (*ENDIF*) 
                                                    END
                                                END;
                                            (*ENDCASE*) 
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                    END;
                                (*ENDIF*) 
                                END
                            (*ENDWITH*) 
                            END
                        (*ENDIF*) 
                    OTHERWISE;
                    END
                (*ENDCASE*) 
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  l_is_actlen
        THEN
            actlen := l
        ELSE
            IF  (
                NOT variable_length AND
                ((etype = st_fixkey) OR (etype = st_fixcol) OR NOT (trunc))
                )
                OR
                (
                variable_length AND
                acv.a_space_option AND
                (l = 0)
                )
            THEN
                BEGIN
                actlen := cinoutlen;
                IF  orig_len < cinoutlen (* LIKE *)
                THEN
                    IF  l + 1 < orig_len
                    THEN
                        actlen := orig_len
                    ELSE
                        actlen := l + 1;
                    (*ENDIF*) 
&               ifdef trace
                (*ENDIF*) 
                t01int4 (ak_sem, 'l           ', l);
                t01int4 (ak_sem, 'actlen      ', actlen);
&               endif
                IF  l + 1  < actlen
                THEN
                    IF  mv_dest < destpos + actlen - 1
                    THEN
                        a07_b_put_error (acv, e_too_many_mb_data, n_pos)
                    ELSE
                        CASE  dest [ destpos ] OF
                            csp_ascii_blank :
                                SAPDB_PascalFill ('VAK05 ',  24,    
                                      mv_dest, @dest, destpos+1+l,
                                      actlen-1-l, csp_ascii_blank,
                                      a_returncode);
                            csp_unicode_def_byte :
                                SAPDB_PascalUnicodeFill ('VAK05 ',  25,    
                                      mv_dest, @dest, destpos+1+l,
                                      actlen-1-l, csp_unicode_blank,
                                      a_returncode);
                            OTHERWISE
                                SAPDB_PascalFill ('VAK05 ',  26,    
                                      mv_dest, @dest, destpos+1+l,
                                      actlen-1-l, csp_defined_byte,
                                      a_returncode);
                            END;
                        (*ENDCASE*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                actlen := l + 1;
            (*ENDIF*) 
        (*ENDIF*) 
        CASE cdatatyp OF
            ddate, dtime, dtimestamp :
                BEGIN
                b_err := e_ok;
                checklen := l;
                WHILE (checklen > 1) AND
                      (dest[ destpos+checklen ]= bsp_c1) DO
                    checklen := checklen - 1;
                (*ENDWHILE*) 
                CASE cdatatyp OF
                    ddate :
                        BEGIN
                        IF  a_ap_tree^[ ni ].n_datatype = dtimestamp
                        THEN
                            a05dfts_date_from_timestamp (dest, dest,
                                  destpos+1, destpos+1, mv_dest,
                                  checklen, a_ap_tree^[ ni ].n_dt_format,
                                  a_ak_language, b_err )
                        ELSE
                            IF  destpos + mxsp_date > mv_dest
                            THEN
                                a07_b_put_error (acv, e_too_many_mb_data, n_pos)
                            ELSE
                                g03fdcheck_date(dest, dest,
                                      destpos+1, destpos+1,
                                      checklen, a_ap_tree^[ ni ].n_dt_format, b_err );
                            (*ENDIF*) 
                        (*ENDIF*) 
                        actlen := mxsp_date + 1
                        END;
                    dtime :
                        BEGIN
                        IF  a_ap_tree^[ ni ].n_datatype = dtimestamp
                        THEN
                            a05tfts_time_from_timestamp(dest, dest,
                                  destpos+1, destpos+1, mv_dest,
                                  checklen, a_ap_tree^[ ni ].n_dt_format,
                                  a_ak_language, b_err )
                        ELSE
                            IF  destpos + mxsp_time > mv_dest
                            THEN
                                a07_b_put_error (acv, e_too_many_mb_data, n_pos)
                            ELSE
                                g03ftcheck_time(dest, dest,
                                      destpos+1, destpos+1,
                                      checklen, a_ap_tree^[ ni ].n_dt_format, b_err );
                            (*ENDIF*) 
                        (*ENDIF*) 
                        actlen := mxsp_time + 1
                        END;
                    dtimestamp :
                        BEGIN
                        IF  a_ap_tree^[ ni ].n_datatype in [dtime, ddate]
                        THEN
                            a05tsfdt_timestamp_from_dattim (dest, dest,
                                  destpos+1, destpos+1, mv_dest,
                                  checklen, a_ap_tree^[ ni ].n_dt_format,
                                  a_ap_tree^[ ni ].n_datatype, b_err )
                        ELSE
                            IF  destpos + mxsp_timestamp > mv_dest
                            THEN
                                a07_b_put_error (acv, e_too_many_mb_data, n_pos)
                            ELSE
                                a05timestamp_get (acv, dest, destpos+1, NOT c_undef,
                                      dest, destpos+1, checklen, b_err);
                            (*ENDIF*) 
                        (*ENDIF*) 
                        actlen := mxsp_timestamp + 1
                        END
                    OTHERWISE;
                    END;
                (*ENDCASE*) 
                IF  b_err <> e_ok
                THEN
                    a07_b_put_error (acv, b_err, n_pos)
                (*ENDIF*) 
                END;
            OTHERWISE
            END;
        (*ENDCASE*) 
        IF  a_returncode = 0
        THEN
            IF  (variable_length AND numtrunc) OR
                (NOT variable_length AND
                (etype <> st_fixkey) AND (etype <> st_fixcol)
                AND trunc)
            THEN
                BEGIN
                IF  trunc_char = csp_unicode_def_byte
                THEN
                    actlen := s30unilnr (@dest, csp_unicode_blank,
                          destpos, actlen)
                ELSE
                    WHILE (actlen > 1) AND
                          (dest[ destpos+actlen-1 ] = trunc_char) DO
                        actlen := actlen - 1;
                    (*ENDWHILE*) 
                (*ENDIF*) 
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak05receive_literal (
            VAR acv       : tak_all_command_glob;
            ni            : integer;
            VAR colinfo   : tak00_columninfo;
            mv_dest       : integer;
            VAR dest      : tsp00_MoveObj;
            destpos       : integer;
            destlen       : integer;
            VAR l         : integer);
 
VAR
      b_err            : tgg00_BasisError;
      i                : integer;
      length           : integer;
      digits           : integer;
      seq_exp          : integer;
      num_err          : tsp00_NumError;
      seq_buf          : tak_sysbufferaddress;
      intern_num       : tsp00_Number;
      curr_time        : tsp00_C9;
      username         : tsp00_KnlIdentifier;
      sysdbaname       : tsp00_KnlIdentifier;
      seq_name         : tsp00_KnlIdentifier;
      srccode          : tsp00_Int2;
      destcode         : tsp00_Int2;
      err_char_no      : tsp00_Int4;
      uni_err          : tsp8_uni_error;
      utcdiff          : tsp00_Longreal;
      utctimestamp     : tsp00_Timestamp;
 
BEGIN
WITH acv, a_ap_tree^[ ni ], colinfo, ccolstack  DO
    CASE  n_symb  OF
        s_null :
            (*  null *)
            dest [ destpos ] := csp_undef_byte;
        s_true :
            (*  true *)
            IF  (cdatatyp <> dboolean)
            THEN
                a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos)
            ELSE
                dest [ destpos + 1 ] := cgg04_truechar;
            (*ENDIF*) 
        s_false :
            (*  false *)
            IF  (cdatatyp <> dboolean)
            THEN
                a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos)
            ELSE
                dest [ destpos + 1 ] := cgg04_falsechar;
            (*ENDIF*) 
        s_pi :
            IF  (cdatatyp <> dfloat)
            THEN
                a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos)
            ELSE
                BEGIN
                intern_num := csp_value_pi;
                (* PTS 1107685 E.Z. *)
                s51kroun (intern_num, 1, mxsp_number, dest, destpos+1,
                      cdatalen, cdatafrac-cak_frac_offset, l, num_err);
                IF  num_err <> num_ok
                THEN
                    a07_b_put_error ( acv, e_num_invalid, 1);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        s_uid :
            IF  (cdatatyp <> dfixed)
            THEN
                a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos)
            ELSE
                BEGIN
                (* PTS 1107685 E.Z. *)
                s41plint (dest, destpos + 1, cdatalen, cdatafrac-cak_frac_offset,
                      a06uid (a_acc_user_id), num_err);
                IF  num_err <> num_ok
                THEN
                    a07_b_put_error ( acv, e_num_invalid, 1);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        s_user, s_usergroup, s_current_schema :
            BEGIN
            (* user  *)
            IF  NOT (cdatatyp in [dcha, dunicode]) OR
                (pred(cinoutlen) < l)
            THEN
                a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos)
            ELSE
                BEGIN
                CASE n_symb OF
                    s_usergroup :
                        username := a_connected_name;
                    s_user :
                        username := a_acc_user;
                    s_current_schema :
                        username := a_curr_schema;
                    END;
                (*ENDCASE*) 
                IF  (g01unicode AND
                    (cdatatyp = dcha))
                THEN
                    BEGIN
                    srccode  := csp_unicode;
                    destcode := csp_ascii;
                    length := l;
                    s80uni_trans (@username[ 1 ], l*2, srccode,
                          @dest[ destpos+1 ], length, destcode,
                          [ ], uni_err, err_char_no);
                    IF  uni_err = uni_ok
                    THEN
                        l := length
                    ELSE
                        IF  uni_err = uni_not_translatable
                        THEN
                            a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos)
                        ELSE
                            a07_uni_error (acv, uni_err, n_pos-1 + err_char_no);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    SAPDB_PascalMove ('VAK05 ',  27,    
                          sizeof(username), mv_dest, @username, 1,
                          @dest, destpos+1, l, a_returncode);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        s_database :
            IF  (NOT (cdatatyp in [dcha, dunicode]))
                OR
                (cdatalen < sizeof (tsp00_DbName))
            THEN
                a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos)
            ELSE
                BEGIN
                IF  cdatatyp = dunicode
                THEN
                    BEGIN
                    l := l * a01char_size;
                    s80uni_trans (@g01serverdb_ident.svServerdb_gg04 [1],
                          sizeof(tsp00_DbName), csp_ascii,
                          @dest [destpos+1], l, csp_unicode,
                          [ ], uni_err, err_char_no);
                    IF  uni_err <> uni_ok
                    THEN
                        IF  uni_err = uni_not_translatable
                        THEN
                            a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos)
                        ELSE
                            a07_uni_error (acv, uni_err, n_pos-1 + err_char_no);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    SAPDB_PascalMove ('VAK05 ',  28,    
                          sizeof (g01serverdb_ident.svServerdb_gg04),
                          mv_dest, @g01serverdb_ident.svServerdb_gg04, 1,
                          @dest, destpos+1, l, a_returncode);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (* PTS 1111797 E.Z. *)
        s_sysdba :
            IF  NOT (cdatatyp in [dcha, dunicode]) OR
                (pred(cinoutlen) < l)
            THEN
                a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos)
            ELSE
                BEGIN
                sysdbaname := g01glob.sysuser_name;
                IF  (g01unicode AND
                    (cdatatyp = dcha))
                THEN
                    BEGIN
                    srccode  := csp_unicode;
                    destcode := csp_ascii;
                    length := l;
                    s80uni_trans (@sysdbaname [ 1 ], l*2, srccode,
                          @dest[ destpos+1 ], length, destcode,
                          [ ], uni_err, err_char_no);
                    IF  uni_err = uni_ok
                    THEN
                        l := length
                    ELSE
                        IF  uni_err = uni_not_translatable
                        THEN
                            a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos)
                        ELSE
                            a07_uni_error (acv, uni_err, n_pos-1 + err_char_no);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    SAPDB_PascalMove ('VAK05 ',  29,    
                          sizeof (sysdbaname), mv_dest, @sysdbaname, 1,
                          @dest, destpos+1, l, a_returncode);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        s_date :
            (* PTS 1000018 Start*)
            IF  (cdatatyp = ddate)
                OR
                (((cdatatyp = dcha)          OR
                (  cdatatyp = dunicode))        AND
                ((cdatalen >= mxsp_extdate)  OR
                ((cdatalen >= mxsp_date) AND
                ( a_dt_format = dtf_normal))))
                (* date  *)
            THEN
                BEGIN
                IF  a_timestamp = bsp_c20
                THEN
                    vtimestamp (a_timestamp);
                (*ENDIF*) 
                IF  ((cdatatyp <> ddate) AND
                    ( a_dt_format <> dtf_normal))
                THEN
                    BEGIN
                    b_err := e_ok;
                    g03dfchange_format_date (a_timestamp, dest,
                          1, destpos+1, a_dt_format, b_err);
                    IF  b_err <> e_ok
                    THEN
                        a07_b_put_error (acv, b_err, 1)
                    ELSE
                        IF  cdatatyp = dunicode
                        THEN
                            FOR i := destlen DOWNTO 1 DO
                                BEGIN
                                dest[ destpos + i*2     ] := dest [ destpos + i ];
                                dest[ destpos + i*2 - 1 ] := csp_unicode_mark;
                                END
                            (*ENDFOR*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    IF  cdatatyp = dunicode
                    THEN
                        FOR i := 1 TO destlen DO
                            BEGIN
                            dest [ destpos + i*2 - 1 ] := csp_unicode_mark;
                            dest [ destpos + i*2     ] := a_timestamp [ i ];
                            END
                        (*ENDFOR*) 
                    ELSE
                        SAPDB_PascalMove ('VAK05 ',  30,    
                              mxsp_timestamp, mv_dest, @a_timestamp, 1,
                              @dest, destpos+1, destlen, a_returncode);
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos);
            (*ENDIF*) 
        s_time :
            IF  (cdatatyp = dtime)
                OR
                (((cdatatyp = dcha)          OR
                (  cdatatyp = dunicode))        AND
                ((cdatalen >= mxsp_exttime)  OR
                ((cdatalen >= mxsp_time) AND
                ( a_dt_format = dtf_normal))))
                (* time  *)
            THEN
                BEGIN
                IF  a_timestamp = bsp_c20
                THEN
                    vtimestamp (a_timestamp);
                (*ENDIF*) 
                IF  ((cdatatyp <> dtime) AND
                    ( a_dt_format <> dtf_normal))
                THEN
                    BEGIN
                    b_err := e_ok;
                    curr_time[ 2 ] := '0';
                    curr_time[ 3 ] := '0';
                    SAPDB_PascalForcedMove (sizeof (a_timestamp), sizeof (curr_time),
                          @a_timestamp, mxsp_date+1, @curr_time, 4, mxsp_time-2);
                    g03tfchange_format_time (curr_time, dest,
                          2, destpos+1, a_dt_format, b_err);
                    IF  b_err <> e_ok
                    THEN
                        a07_b_put_error (acv, b_err, 1)
                    ELSE
                        IF  cdatatyp = dunicode
                        THEN
                            FOR i := destlen DOWNTO 1 DO
                                BEGIN
                                dest[ destpos + i*2     ] := dest [ destpos + i ];
                                dest[ destpos + i*2 - 1 ] := csp_unicode_mark;
                                END
                            (*ENDFOR*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    IF  cdatatyp = dunicode
                    THEN
                        BEGIN
                        dest [ destpos+1 ] := csp_unicode_mark;
                        dest[ destpos+2 ]:= '0';
                        dest [ destpos+3 ] := csp_unicode_mark;
                        dest[ destpos+4 ]:= '0';
                        FOR i := 1 TO destlen DO
                            BEGIN
                            dest [ destpos + 4 + i*2 - 1 ] := csp_unicode_mark;
                            dest [ destpos + 4 + i*2     ] := a_timestamp [ mxsp_date+i ];
                            END;
                        (*ENDFOR*) 
                        END
                    ELSE
                        BEGIN
                        dest[ destpos+1 ]:= '0';
                        dest[ destpos+2 ]:= '0';
                        SAPDB_PascalMove ('VAK05 ',  31,    
                              mxsp_timestamp, mv_dest, @a_timestamp, mxsp_date+1,
                              @dest, destpos+3, destlen, a_returncode);
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos);
            (*ENDIF*) 
        (* PTS 1116174 E.Z. *)
        s_utcdate :
            IF  (cdatatyp = dtimestamp)
                OR
                (((cdatatyp = dcha)          OR
                (  cdatatyp = dunicode))            AND
                ((cdatalen >= mxsp_exttimestamp)  OR
                ((cdatalen >= mxsp_timestamp) AND
                ( a_dt_format = dtf_normal))))
                (* timestamp  *)
            THEN
                BEGIN
                vUTCtimestamp (utctimestamp);
                IF  ((cdatatyp <> dtimestamp) AND
                    ( a_dt_format <> dtf_normal))
                THEN
                    BEGIN
                    b_err := e_ok;
                    g03tsfchange_format_timestamp (utctimestamp, dest,
                          1, destpos+1, a_dt_format, a_ak_language, b_err);
                    IF  b_err <> e_ok
                    THEN
                        a07_b_put_error (acv, b_err, 1)
                    ELSE
                        IF  cdatatyp = dunicode
                        THEN
                            FOR i := destlen DOWNTO 1 DO
                                BEGIN
                                dest[ destpos + i*2     ] := dest [ destpos + i ];
                                dest[ destpos + i*2 - 1 ] := csp_unicode_mark;
                                END
                            (*ENDFOR*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    IF  cdatatyp = dunicode
                    THEN
                        FOR i := 1 TO destlen DO
                            BEGIN
                            dest [ destpos + i*2 - 1 ] := csp_unicode_mark;
                            dest [ destpos + i*2     ] := utctimestamp [ i ];
                            END
                        (*ENDFOR*) 
                    ELSE
                        SAPDB_PascalMove ('VAK05 ',  32,    
                              mxsp_timestamp, mv_dest, @utctimestamp, 1,
                              @dest, destpos+1, destlen, a_returncode);
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos);
            (*ENDIF*) 
        s_timestamp :
            IF  (cdatatyp = dtimestamp)
                OR
                (((cdatatyp = dcha)          OR
                (  cdatatyp = dunicode))            AND
                ((cdatalen >= mxsp_exttimestamp)  OR
                ((cdatalen >= mxsp_timestamp) AND
                ( a_dt_format = dtf_normal))))
                (* timestamp  *)
            THEN
                BEGIN
                IF  a_timestamp = bsp_c20
                THEN
                    vtimestamp (a_timestamp);
                (*ENDIF*) 
                IF  ((cdatatyp <> dtimestamp) AND
                    ( a_dt_format <> dtf_normal))
                THEN
                    BEGIN
                    b_err := e_ok;
                    g03tsfchange_format_timestamp (a_timestamp, dest,
                          1, destpos+1, a_dt_format, a_ak_language, b_err);
                    IF  b_err <> e_ok
                    THEN
                        a07_b_put_error (acv, b_err, 1)
                    ELSE
                        IF  cdatatyp = dunicode
                        THEN
                            FOR i := destlen DOWNTO 1 DO
                                BEGIN
                                dest[ destpos + i*2     ] := dest [ destpos + i ];
                                dest[ destpos + i*2 - 1 ] := csp_unicode_mark;
                                END
                            (*ENDFOR*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    IF  cdatatyp = dunicode
                    THEN
                        FOR i := 1 TO destlen DO
                            BEGIN
                            dest [ destpos + i*2 - 1 ] := csp_unicode_mark;
                            dest [ destpos + i*2     ] := a_timestamp [ i ];
                            END
                        (*ENDFOR*) 
                    ELSE
                        SAPDB_PascalMove ('VAK05 ',  33,    
                              mxsp_timestamp, mv_dest, @a_timestamp, 1,
                              @dest, destpos+1, destlen, a_returncode);
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos);
            (*ENDIF*) 
        (* PTS 1000018 Ende*)
        s_timezone :
            IF  ((cdatalen < cak_time_durationlen)
                OR NOT (cdatatyp in [ dfixed, dfloat, dvfloat ]))
            THEN
                a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos)
            ELSE
                BEGIN
                (* PTS 1107685 E.Z. *)
                utcdiff := vTimeZoneDelta;
                (* from fixed (4,2) example 8,5 --> duration example 083000 *)
                utcdiff := trunc(utcdiff) * 10000 +
                      (utcdiff - trunc(utcdiff)) * 6000;
                s41plrel (dest, destpos + 1, cdatalen, 0, utcdiff, num_err);
                IF  (num_err <> num_ok)
                THEN
                    CASE num_err OF
                        num_invalid :
                            a07_b_put_error (acv,
                                  e_num_invalid, n_pos);
                        num_trunc :
                            a07_b_put_error (acv,
                                  e_num_truncated, n_pos);
                        num_overflow :
                            a07_b_put_error (acv,
                                  e_num_overflow, n_pos);
                        END
                    (*ENDCASE*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (* PTS 1109925 E.Z. *)
        s_utcdiff :
            IF  (cdatatyp in [ dfixed, dfloat, dvfloat ])
                AND
                (cdatalen >= cak_utcdiff_len)
                AND
                ((cdatafrac = cak_ak_float)                     OR
                ((cdatalen - (cdatafrac - cak_frac_offset) >=
                cak_utcdiff_len - cak_utcdiff_frac) AND
                ( cdatafrac - cak_frac_offset >= cak_utcdiff_frac)))
            THEN
                BEGIN
                utcdiff := vTimeZoneDelta;
&               ifdef TRACE
                t01real (ak_sem, 'utcdiff     ', utcdiff, cak_utcdiff_len);
&               endif
                s41plrel (dest, destpos + 1, cak_utcdiff_len, cak_utcdiff_frac,
                      utcdiff, num_err);
                IF  (num_err <> num_ok)
                THEN
                    CASE num_err OF
                        num_invalid :
                            a07_b_put_error (acv, e_num_invalid, n_pos);
                        num_trunc :
                            a07_b_put_error (acv, e_num_truncated, n_pos);
                        num_overflow :
                            a07_b_put_error (acv, e_num_overflow, n_pos);
                        END
                    (*ENDCASE*) 
                (*ENDIF*) 
                END
            ELSE
                a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos);
            (*ENDIF*) 
        s_stamp :
            IF  ((cdatalen < SURROGATE_MXGG00)
                OR NOT (cdatatyp in [dchb,
                dstra, dstrb, dstruni,
                dlonga, dlongb, dlonguni]))
            THEN
                a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos)
            ELSE
                a05_stamp_get (acv, dest, destpos+1, mv_dest);
            (*ENDIF*) 
        s_transaction :
            IF  ((cdatalen < sizeof (tgg91_TransNo))
                OR (cdatatyp <> dchb))
            THEN
                a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos)
            ELSE
                a05_transaction_get (acv, dest, destpos+1, mv_dest);
            (*ENDIF*) 
        s_nextval, s_currval :
            IF  ((cdatatyp <> dfixed) AND
                ( cdatatyp <> dfloat))
            THEN
                a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos)
            ELSE
                BEGIN
                IF  a23exist_sequence (acv, a_ap_tree^[ ni ].n_lo_level, n_symb = s_currval,
                    seq_buf, username, seq_name)
                THEN
                    BEGIN
                    WITH seq_buf^.ssequence, seq_info DO
                        IF  n_symb = s_currval
                        THEN
                            a05_nextval_get (acv, mm_same, seq_surrogate, seq_info,
                                  dest, destpos, l)
                        ELSE
                            a05_nextval_get (acv, mm_nil, seq_surrogate, seq_info,
                                  dest, destpos, l);
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    digits  := cdatalen - cdatafrac + cak_frac_offset;
                    seq_exp := ord (dest[destpos + 1]);
                    IF  (digits < seq_exp - 192) OR
                        (digits < 64 - seq_exp )
                    THEN
                        a07_nb_put_error (acv, e_num_overflow, n_pos, seq_name)
                    ELSE
                        BEGIN
                        l := l - 1;
                        IF  cbinary
                        THEN
                            a05int_range_check (acv, dest, destpos, l, cdatalen, n_pos);
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        s_midnight :
            SAPDB_PascalFill ('VAK05 ',  34,    
                  mv_dest, @dest, destpos+1, mxsp_time, csp_ascii_zero, a_returncode);
        s_degree :
            (* DB2 degree of parallelism *)
            IF  ((cdatalen < sizeof (a_degree))
                OR (cdatatyp <> dcha))
            THEN
                a07_b_put_error (acv, e_const_incompatible_with_typ, n_pos)
            ELSE
                SAPDB_PascalMove ('VAK05 ',  35,    
                      sizeof (a_degree), mv_dest, @a_degree, 1, @dest, destpos+1, l,
                      a_returncode);
            (*ENDIF*) 
        OTHERWISE
            BEGIN
            END;
        END;
    (*ENDCASE*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak05literal_length (
            VAR acv             : tak_all_command_glob;
            ni                  : integer;
            VAR colinfo         : tak00_columninfo;
            VAR l               : integer;
            VAR destlen         : integer;
            VAR li_const        : boolean);
 
BEGIN
WITH acv, a_ap_tree^[ ni ], colinfo, ccolstack  DO
    CASE  n_symb  OF
        s_null :
            l := 0;
        s_true,
        s_false :
            l := 1;
        s_pi,
        s_uid :
            l := (cdatalen + 1) DIV 2 + 1;
        s_user, s_usergroup, s_current_schema :
            BEGIN
            IF  acv.a_sqlmode = sqlm_ansi
            THEN
                l := mxsp_c18 * a01char_size
            ELSE
                l := a01identifier_size;
            (*ENDIF*) 
            IF  (g01unicode AND
                (cdatatyp = dcha))
            THEN
                l := l DIV 2;
            (*ENDIF*) 
            END;
        s_database :
            l := sizeof (tsp00_DbName);
        (* PTS 1111797 E.Z. *)
        s_sysdba :
            BEGIN
            l := a01identifier_size;
            IF  (g01unicode AND
                (cdatatyp = dcha))
            THEN
                l := l DIV 2;
            (*ENDIF*) 
            END;
        s_date :
            (* PTS 1000018 Start*)
            BEGIN
            IF  (cdatatyp <> ddate) AND
                (a_dt_format <> dtf_normal)
            THEN
                l := mxsp_extdate
            ELSE
                l := mxsp_date;
            (*ENDIF*) 
            destlen := l;
            IF  cdatatyp = dunicode
            THEN
                l := l * 2;
            (*ENDIF*) 
            END;
        s_time :
            BEGIN
            IF  (cdatatyp <> dtime) AND
                (a_dt_format <> dtf_normal)
            THEN
                BEGIN
                l := mxsp_exttime;
                destlen := l
                END
            ELSE
                BEGIN
                l := mxsp_time;
                destlen := l - 2
                END;
            (*ENDIF*) 
            IF  cdatatyp = dunicode
            THEN
                l := l * 2;
            (*ENDIF*) 
            END;
        (* PTS 1116174 E.Z. *)
        s_utcdate,
        s_timestamp :
            BEGIN
            IF  (cdatatyp <> dtimestamp) AND
                (a_dt_format <> dtf_normal)
            THEN
                l := mxsp_exttimestamp
            ELSE
                l := mxsp_timestamp;
            (*ENDIF*) 
            destlen := l;
            IF  cdatatyp = dunicode
            THEN
                l := l * 2
                      (* PTS 1000018 Ende*)
            (*ENDIF*) 
            END;
        s_now :
            BEGIN
            CASE cdatatyp OF
                ddate :
                    BEGIN
                    n_symb := s_date;
                    l := mxsp_date;
                    END;
                dtime :
                    BEGIN
                    n_symb := s_time;
                    l := mxsp_time;
                    END;
                OTHERWISE
                    BEGIN
                    n_symb := s_timestamp;
                    IF  (cdatatyp <> dtimestamp) AND
                        (a_dt_format <> dtf_normal)
                    THEN
                        l := mxsp_exttimestamp
                    ELSE
                        l := mxsp_timestamp;
                    (*ENDIF*) 
                    END
                END;
            (*ENDCASE*) 
            destlen := l;
            IF  cdatatyp = dunicode
            THEN
                l := l * 2
            (*ENDIF*) 
            END;
        s_timezone :
            l := (cdatalen + 1) DIV 2 + 1;
        (* PTS 1109925 E.Z. *)
        s_utcdiff :
            l := (cak_utcdiff_len + 1) DIV 2 + 1;
        s_stamp :
            l:= SURROGATE_MXGG00;
        s_transaction :
            l:= sizeof (tgg91_TransNo);
        s_nextval, s_currval :
            l := NUMBER_MXGG04 - 1;
        s_midnight :
            l:= mxsp_time;
        s_degree :
            l := sizeof (a_degree);
        OTHERWISE
            BEGIN
            li_const := true;
            l := 0;
            END;
        END;
    (*ENDCASE*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05_constant_get (
            VAR acv       : tak_all_command_glob;
            ni            : integer;
            VAR colinfo   : tak00_columninfo;
            may_be_longer : boolean;
            mv_dest       : integer;
            VAR dest      : tsp00_MoveObj;
            destpos       : integer;
            VAR actlen    : integer);
 
VAR
      li_const         : boolean;
      l                : integer;
      datalen          : integer;
      inoutlen         : integer;
      destlen          : integer;
 
BEGIN
actlen          := 0;
l               := 0;
destlen         := 0;
li_const        := false;
&ifdef trace
t01int4 (ak_sem, 'cdatalen    ', colinfo.cdatalen);
&endif
WITH acv, a_ap_tree^[ ni ], colinfo, ccolstack  DO
    IF  a_returncode = 0
    THEN
        BEGIN
        CASE  cdatatyp OF
            dunicode :
                dest[ destpos ] := csp_unicode_def_byte;
            dcha, ddate, dtime, dtimestamp :
                dest[ destpos ] := csp_ascii_blank;
            OTHERWISE
                dest[ destpos ] := csp_defined_byte;
            END;
        (*ENDCASE*) 
        ak05literal_length (acv, ni, colinfo, l, destlen, li_const);
&       ifdef TRACE
        t01int4 (ak_sem, 'destpos     ', destpos);
        t01int4 (ak_sem, 'l           ', l      );
&       endif
        IF  destpos + l > mv_dest
        THEN
            BEGIN
&           ifdef TRACE
            t01int4 (td_always, 'destpos     ', destpos);
            t01int4 (td_always, 'mv_dest     ', mv_dest);
&           endif
            a07_b_put_error (acv, e_too_many_mb_data, n_pos);
            actlen := l
            END
        ELSE
            IF  NOT li_const
            THEN
                ak05receive_literal (acv, ni, colinfo, mv_dest, dest, destpos, destlen, l);
            (*ENDIF*) 
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            IF  li_const
            THEN
                BEGIN
                inoutlen := colinfo.cinoutlen;
                datalen := colinfo.cdatalen;
                IF  (may_be_longer
                    AND
                    (NOT (n_symb in [ s_unsigned_integer,
                    s_fixed_point_literal,
                    s_floating_point_literal, s_plus, s_minus ] )))
                THEN
                    BEGIN
                    colinfo.cdatalen := cak_maxfieldlength;
                    IF  colinfo.cdatatyp = dunicode
                    THEN
                        colinfo.cinoutlen := succ(colinfo.cdatalen * 2)
                    ELSE
                        colinfo.cinoutlen := succ(colinfo.cdatalen);
                    (*ENDIF*) 
                    (* because of LIKE '(a-f)*' for col with CHAR (3) for example *)
                    END;
                (*ENDIF*) 
                a05_li_constant_get (acv, ni, colinfo, inoutlen,
                      mv_dest, dest, destpos, NOT c_variable_length, actlen);
                IF  may_be_longer
                THEN
                    BEGIN
                    colinfo.cdatalen := datalen;
                    colinfo.cinoutlen := inoutlen
                    END
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  (etype = st_fixkey) OR (etype = st_fixcol)
                THEN
                    BEGIN
                    actlen := cinoutlen;
                    IF  l + 1  < actlen
                    THEN
                        IF  mv_dest < destpos + 1 + actlen
                        THEN
                            a07_b_put_error (acv, e_too_many_mb_data,
                                  n_pos)
                        ELSE
                            CASE dest [ destpos ] OF
                                csp_ascii_blank :
                                    SAPDB_PascalFill ('VAK05 ',  36,    
                                          mv_dest, @dest, destpos+1+l,
                                          actlen-1-l, csp_ascii_blank,
                                          a_returncode);
                                csp_unicode_def_byte :
                                    SAPDB_PascalUnicodeFill ('VAK05 ',  37,    
                                          mv_dest, @dest, destpos+1+l,
                                          actlen-1-l, csp_unicode_blank,
                                          a_returncode);
                                OTHERWISE
                                    SAPDB_PascalFill ('VAK05 ',  38,    
                                          mv_dest, @dest, destpos+1+l,
                                          actlen-1-l, csp_defined_byte,
                                          a_returncode);
                                END;
                            (*ENDCASE*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    actlen := l + 1;
                (*ENDIF*) 
&               ifndef vers80
                IF  (etype <> st_fixkey) AND (etype <> st_fixcol)
                THEN
                    actlen := 1 + s30lnr_defbyte (@dest, dest[ destpos ],
                          destpos+1, actlen-1);
&               endif
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05var_constant_get (
            VAR acv          : tak_all_command_glob;
            ni               : integer;
            VAR colinfo      : tak00_columninfo;
            may_be_longer    : boolean;
            VAR valfieldno   : integer;
            VAR valstart     : tsp00_MoveObjPtr;
            VAR actlen       : integer);
 
VAR
      li_const         : boolean;
      ok               : boolean;
      char_len         : integer;
      l                : integer;
      datalen          : integer;
      inoutlen         : integer;
      destlen          : integer;
      mem_len          : integer;
      msglist          : tak104_MsgList;
 
BEGIN
actlen          := 0;
valfieldno      := 0;
l               := 0;
destlen         := 0;
li_const        := false;
msglist         := NIL;
&ifdef trace
t01int4 (ak_sem, 'cdatalen    ', colinfo.cdatalen);
&endif
WITH acv, a_ap_tree^[ ni ], colinfo, ccolstack  DO
    IF  a_returncode = 0
    THEN
        BEGIN
        ak05literal_length (acv, ni, colinfo, l, destlen, li_const);
&       ifdef TRACE
        t01int4 (ak_sem, 'l           ', l      );
        t01int4 (ak_sem, 'destlen     ', destlen);
&       endif
        IF  NOT li_const
        THEN
            BEGIN
            actlen := succ(l);
            (*
                  IF  n_symb = s_null
                  THEN
                  ok := ak104_CreateNullField_IMS (a_mblock.mb_fieldlists[cgg_idx_literal_valuefieldlist],
                  msglist)
                  ELSE
                  *)
            BEGIN
            ok := ak104_CreateVariableField_IMS (a_mblock.mb_fieldlists[cgg_idx_literal_valuefieldlist],
                  actlen, valstart, msglist);
            IF  ok
            THEN
                BEGIN
                CASE  cdatatyp OF
                    dunicode :
                        valstart^[ 1 ] := csp_unicode_def_byte;
                    dcha, ddate, dtime, dtimestamp :
                        valstart^[ 1 ] := csp_ascii_blank;
                    OTHERWISE
                        valstart^[ 1 ] := csp_defined_byte;
                    END;
                (*ENDCASE*) 
                ak05receive_literal (acv, ni, colinfo, actlen, valstart^, 1, destlen, l);
                END
            (*ENDIF*) 
            END;
            END
        ELSE
            BEGIN
            inoutlen := colinfo.cinoutlen;
            datalen := colinfo.cdatalen;
            mem_len := inoutlen;
            IF  colinfo.cdatatyp in [ddate, dtime, dtimestamp]
            THEN
                BEGIN
                IF  g01unicode
                THEN
                    char_len := 2
                ELSE
                    char_len := 1;
                (*ENDIF*) 
                IF  (a_dt_format <> dtf_normal)
                THEN
                    CASE colinfo.cdatatyp OF
                        ddate :
                            mem_len := succ(char_len * EXT_DATE_MXSP00);
                        dtime :
                            mem_len := succ(char_len * EXT_TIME_MXSP00);
                        dtimestamp :
                            mem_len := succ(char_len * EXT_TIMESTAMP_MXSP00);
                        END
                    (*ENDCASE*) 
                ELSE
                    mem_len := succ(char_len * pred(mem_len));
                (*ENDIF*) 
                END
            ELSE
                IF  cdatatyp = dunicode
                THEN
                    char_len := 2
                ELSE
                    char_len := 1;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  (may_be_longer
                AND
                (NOT (n_symb in [ s_unsigned_integer,
                s_fixed_point_literal,
                s_floating_point_literal, s_plus, s_minus ] )))
            THEN
                BEGIN
                colinfo.cdatalen := cak_maxfieldlength;
                colinfo.cinoutlen := succ(colinfo.cdatalen * char_len);
                mem_len := colinfo.cinoutlen;
                (* because of LIKE '(a-f)*' for col with CHAR (3) for example *)
                END;
            (*ENDIF*) 
            ok := ak104_CreateVariableField_IMS (a_mblock.mb_fieldlists[cgg_idx_literal_valuefieldlist],
                  mem_len, valstart, msglist);
            IF  ok
            THEN
                a05_li_constant_get (acv, ni, colinfo, inoutlen,
                      mem_len, valstart^, 1, c_variable_length, actlen);
            (*ENDIF*) 
            IF  may_be_longer
            THEN
                BEGIN
                colinfo.cdatalen := datalen;
                colinfo.cinoutlen := inoutlen
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  acv.a_returncode <> 0
        THEN
            ok := false
        ELSE
            BEGIN
            ok := ak104_CloseCurrentField_IMS (a_mblock.mb_fieldlists[cgg_idx_literal_valuefieldlist],
                  actlen, msglist);
            END;
        (*ENDIF*) 
        IF  NOT ok
        THEN
            a07_b_put_error (acv, e_no_more_memory, n_pos)
        ELSE
            valfieldno := ak104_GetFieldCount_IMS (a_mblock.mb_fieldlists[cgg_idx_literal_valuefieldlist])
                  - 1;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05qualification_test (
            VAR acv        : tak_all_command_glob;
            VAR m          : tgg00_MessBlock;
            result_wanted  : boolean;
            check_new_rec  : boolean;
            error_pos      : integer;
            VAR rec        : tgg00_Rec;
            VAR result_buf : tsp00_Buf;
            resultBufSize  : tsp00_Int4;
            VAR result_len : integer);
 
VAR
      sel        : tgg00_SelectFieldsParam;
      with_view  : boolean;
      dummy_bool : boolean;
      err_st_ptr : tgg00_StEntryAddr;
      err_msg    : tgg04_Err;
 
BEGIN
(* PTS 1105092 E.Z. *)
g04init_select_fields (sel, @m.mb_data^.mbp_buf, m.mb_data_size,
      m.mb_work_st, m.mb_work_st_max, m.mb_workbuf, m.mb_workbuf_size,
      acv.a_sqlmode, @m.mb_fieldlists);
WITH sel DO
    BEGIN
    sfp_bd_mess_type    := m.mb_type;
    sfp_bd_mess2_type   := m.mb_type2;
    sfp_result_wanted   := result_wanted;
    sfp_m_result_addr   := @result_buf;
    sfp_m_result_size   := resultBufSize;
    sfp_primkey_addr    := NIL;
    sfp_first_qual      := true;
    sfp_filler2         := false;
    sfp_result_length   := 0;
    sfp_rec_addr        := @rec.buf;
    sfp_rec_len         := rec.len;
    sfp_rec_key_len     := rec.keylen;
    sfp_acv_addr        := @acv;   (* PTS 1121403 E.Z. *)
    END;
(*ENDWITH*) 
with_view           := m.mb_qual^.mview_cnt > 0;
m.mb_qual^.mst_addr := m.mb_st;
m.mb_qual^.mst_max  := m.mb_st_max;
m.mb_trns^.trError_gg00   := e_ok;
k71qual_handling (m.mb_trns^, sel, with_view, check_new_rec,
      m.mb_qual^.mstack_desc, err_st_ptr, dummy_bool);
IF  (m.mb_trns^.trError_gg00 = e_view_violation) AND check_new_rec
    AND (m.mb_type IN  [m_update, m_insert])
THEN
    m.mb_trns^.trError_gg00 := e_upd_view_violation;
(* to show the Compiler that result_stack ist necessary *)
(*ENDIF*) 
IF  (m.mb_trns^.trError_gg00 <> e_ok) AND (error_pos > 0)
THEN
    IF  (err_st_ptr <> NIL)
        AND
        ((m.mb_type = m_insert       ) OR
        ( m.mb_type = m_insert_select) OR
        ( m.mb_type = m_update       ) OR
        ( m.mb_type = m_delete      ))
    THEN
        BEGIN
        WITH err_msg DO
            BEGIN
            a05get_err_tabid (m.mb_trns^, m.mb_qual^.mtree, errtableid);
            errstack     := err_st_ptr^;
            errstacktype := tfnTable_egg00;
            END;
        (*ENDWITH*) 
        a07_sb_put_error (acv, m.mb_trns^.trError_gg00, error_pos, err_msg)
        END
    ELSE
        a07_b_put_error (acv, m.mb_trns^.trError_gg00, error_pos);
    (*ENDIF*) 
(*ENDIF*) 
result_len := sel.sfp_result_length;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05varqualification_test (
            VAR acv        : tak_all_command_glob;
            VAR m          : tgg00_MessBlock;
            result_wanted  : boolean;
            check_new_rec  : boolean;
            error_pos      : integer;
            fieldlistno    : integer;
            VAR result_no  : tsp00_Int2);
 
VAR
      sel        : tgg00_SelectFieldsParam;
      with_view  : boolean;
      dummy_bool : boolean;
      err_st_ptr : tgg00_StEntryAddr;
      err_msg    : tgg04_Err;
 
BEGIN
(* PTS 1105092 E.Z. *)
g04init_select_fields (sel, @m.mb_data^.mbp_buf, m.mb_data_size,
      m.mb_work_st, m.mb_work_st_max, m.mb_workbuf, m.mb_workbuf_size,
      acv.a_sqlmode, @m.mb_fieldlists);
WITH sel DO
    BEGIN
    sfp_bd_mess_type    := m.mb_type;
    sfp_bd_mess2_type   := m.mb_type2;
    sfp_result_wanted   := result_wanted;
    sfp_m_result_addr   := NIL;
    sfp_m_result_size   := 0;
    sfp_primkey_addr    := NIL;
    sfp_first_qual      := true;
    sfp_filler2         := false;
    sfp_result_length   := 0;
    sfp_rec_addr        := NIL;
    sfp_rec_len         := 0;
    sfp_rec_key_len     := 0;
    sfp_acv_addr        := @acv;   (* PTS 1121403 E.Z. *)
    END;
(*ENDWITH*) 
with_view           := m.mb_qual^.mview_cnt > 0;
m.mb_qual^.mst_addr := m.mb_st;
m.mb_qual^.mst_max  := m.mb_st_max;
m.mb_trns^.trError_gg00   := e_ok;
k71qual_handling (m.mb_trns^, sel, with_view, check_new_rec,
      m.mb_qual^.mstack_desc, err_st_ptr, dummy_bool);
IF  (m.mb_trns^.trError_gg00 = e_view_violation) AND check_new_rec
    AND (m.mb_type IN  [m_update, m_insert])
THEN
    m.mb_trns^.trError_gg00 := e_upd_view_violation;
(* to show the Compiler that result_stack ist necessary *)
(*ENDIF*) 
result_no := -1;
IF  (m.mb_trns^.trError_gg00 <> e_ok) AND (error_pos > 0)
THEN
    IF  (err_st_ptr <> NIL)
        AND
        ((m.mb_type = m_insert       ) OR
        ( m.mb_type = m_insert_select) OR
        ( m.mb_type = m_update       ) OR
        ( m.mb_type = m_delete      ))
    THEN
        BEGIN
        WITH err_msg DO
            BEGIN
            a05get_err_tabid (m.mb_trns^, m.mb_qual^.mtree, errtableid);
            errstack     := err_st_ptr^;
            errstacktype := tfnTable_egg00;
            END;
        (*ENDWITH*) 
        a07_sb_put_error (acv, m.mb_trns^.trError_gg00, error_pos, err_msg)
        END
    ELSE
        a07_b_put_error (acv, m.mb_trns^.trError_gg00, error_pos)
    (*ENDIF*) 
ELSE
    result_no := ak104_GetFieldCount_IMS (m.mb_fieldlists[fieldlistno]) - 1;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05constraint_fulfilled (
            VAR acv         : tak_all_command_glob;
            VAR valbuf      : tgg00_Rec;
            VAR tree        : tgg00_FileId;
            constraint_id   : integer);
 
VAR
      b_err      : tgg00_BasisError;
      res_len    : integer;
      i          : integer;
      sysk       : tgg00_SysInfoKey;
      valp       : tak_sysbufferaddress;
      lstack     : tgg00_StackListPtr;
      err_msg    : tgg04_Err;
      ldata      : tgg00_Rec;
      lqual      : tgg00_QualBuf;
      mblock     : tgg00_MessBlock;
 
BEGIN
WITH acv, sysk, mblock DO
    BEGIN
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  tree.fileTfn_gg00 = tfnTemp_egg00
        THEN
            BEGIN
            stableid  := cgg_zero_id;
            ssite     := cak_temp_table_site;
            stemp     := a101_GetTempFileIndex (acv, tree);
            sentrytyp := cak_etempconstraint;
            END
        ELSE
            BEGIN
            sentrytyp := cak_econstraint;
            stableid  := tree.fileTabId_gg00
            END;
        (*ENDIF*) 
        slinkage[1] := chr(constraint_id DIV 256);
        slinkage[2] := chr(constraint_id MOD 256);
        skeylen     := mxak_standard_sysk;
        a10get_sysinfo (acv, sysk, d_release, valp, b_err);
        IF  b_err <> e_ok
        THEN
            BEGIN
            IF  b_err = e_sysinfo_not_found
            THEN
                b_err := e_old_fileversion;
            (*ENDIF*) 
            a07_b_put_error ( acv, b_err, 1)
            END
        ELSE
            WITH valp^.sconstraint DO
                BEGIN
&               ifdef trace
                t01buf (ak_sem, valp^, 1, valp^.b_sl);
&               endif
                g01mblock_init (acv.a_transinf.tri_trans,
                      m_nil, mm_nil, mblock);
                g01datapart_init (mblock, @ldata, sizeof(ldata));
                a10new (acv, (cstack_cnt+1) * STACK_ENTRY_MXGG00,
                      lstack);
                IF  lstack = NIL
                THEN
                    a07_b_put_error (acv, e_no_more_memory, 1)
                ELSE
                    BEGIN
                    g01stack_init (mblock, lstack,
                          (cstack_cnt+1) * STACK_ENTRY_MXGG00,
                          @lqual, sizeof (lqual));
                    (* PTS 1000354 E.Z. *)
                    mb_qual^.mtree       := b01niltree_id;
                    mb_qual^.mqual_pos   := 1;
                    mb_qual^.mqual_cnt   := cstack_cnt;
                    mb_qual^.mfirst_free := cstack_cnt + 1;
                    (* PTS 1105092 E.Z. *)
                    mb_qual^.msqlmode    := a_sqlmode;
                    SAPDB_PascalMove ('VAK05 ',  39,    
                          sizeof (cstack),
                          mb_st_max * STACK_ENTRY_MXGG00,
                          @cstack, (cstackstart - 1) * STACK_ENTRY_MXGG00 + 1,
                          @mb_st^, 1, cstack_cnt * STACK_ENTRY_MXGG00,
                          a_returncode);
                    mblock.mb_data_len  := valp^.b_sl-
                          cvalue_pos+cgg_rec_key_offset+1;
                    SAPDB_PascalMove ('VAK05 ',  40,    
                          mxak_constraintrec, mb_data_size, @valp^, cvalue_pos,
                          @mb_data^.mbp_buf, cgg_rec_key_offset+1,
                          mb_data_len -cgg_rec_key_offset,
                          a_returncode);
&                   ifdef trace
                    t01messblock (ak_sem, '05constrfull', mblock);
&                   endif
                    valbuf.len := valbuf.len + cgg_rec_key_offset;
                    IF  a_returncode = 0
                    THEN
                        BEGIN
                        FOR i := mb_qual^.mqual_pos TO
                              mb_qual^.mqual_cnt DO
                            IF  mb_st^ [i].etype in
                                [ st_language, st_format,
                                st_date, st_time, st_timestamp,
                                (* PTS 1116174 E.Z. *)
                                st_utcdate,
                                (* PTS 1109925 E.Z. *)
                                st_utcdiff,
                                st_user, st_usergroup, st_current_schema, st_uid,
                                st_sysdba, st_localsysdba,
                                st_transaction, st_timezone (* PTS 1122262 E.Z. *)
                                ]
                            THEN
                                a54_internal_function (acv, mblock, i);
                            (*ENDIF*) 
                        (*ENDFOR*) 
                        IF  (coldrange OR (a_sqlmode = sqlm_ansi))
                            AND
                            (mb_qual^.mfirst_free <= mb_st_max)
                        THEN
                            WITH mb_qual^, mb_st^ [mfirst_free] DO
                                BEGIN
                                etype       := st_truth;
                                epos        := cgg04_is_not_false;
                                mqual_cnt   := mqual_cnt + 1;
                                mfirst_free := mfirst_free + 1
                                END;
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        mblock.mb_work_st      := a_work_st_addr;
                        mblock.mb_work_st_max  := a_work_st_max;
                        mblock.mb_workbuf      := a_work_buf_addr;
                        mblock.mb_workbuf_size := a_work_buf_size;
                        mblock.mb_trns         := @a_transinf.tri_trans;
                        k71qualification_test (mblock, c_first_qual,
                              NOT c_result_wanted, NOT c_check_new_rec,
                              valbuf, NIL, 0, res_len);
                        valbuf.len := valbuf.len - cgg_rec_key_offset;
                        IF  mblock.mb_trns^.trError_gg00 <> e_ok
                        THEN
                            BEGIN
                            a07_b_put_error (acv, e_range_violation,
                                  1);
                            a05get_err_tabid (acv.a_transinf.tri_trans,
                                  tree, err_msg.errtableid);
                            err_msg.errstack.etype := st_dummy;
                            err_msg.errstack.ecol_tab[1] := chr(constraint_id DIV 256);
                            err_msg.errstack.ecol_tab[2] := chr(constraint_id MOD 256);
                            err_msg.errtablesite := cgg_zero_c2;
                            err_msg.errstacktype := tfnTable_egg00;
                            a06put_errtext (acv, e_range_violation,
                                  errtext_stack,
                                  sizeof (err_msg.errtableid) +
                                  sizeof (err_msg.errstack)     +
                                  sizeof (err_msg.errtablesite) +
                                  sizeof (err_msg.errstacktype),
                                  err_msg.errt, b_err)
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    a10dispose (acv, lstack);
                    END
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05is_const_in_constraint (
            VAR acv         : tak_all_command_glob;
            VAR valbuf      : tsp00_MoveObj;
            val_pos         : integer;
            val_len         : integer;
            VAR tree        : tgg00_FileId;
            constraint_id   : integer;
            b_err           : tgg00_BasisError;
            error_pos       : integer);
 
VAR
      b_in_err   : tgg00_BasisError;
      res_len    : integer;
      i          : integer;
      p          : tak_sysbufferaddress;
      sysk       : tgg00_SysInfoKey;
      cons_name  : tsp00_KnlIdentifier;
      valb       : tgg00_Rec;
      lstack     : tgg00_StackListPtr;
      lqual      : tgg00_QualBuf;
      ldata      : tgg00_Rec;
      mblock     : tgg00_MessBlock;
 
BEGIN
WITH acv, sysk, mblock DO
    BEGIN
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  tree.fileTfn_gg00 = tfnTemp_egg00
        THEN
            BEGIN
            stableid  := cgg_zero_id;
            ssite     := cak_temp_table_site;
            stemp     := a101_GetTempFileIndex (acv, tree);
            sentrytyp := cak_etempconstraint;
            END
        ELSE
            BEGIN
            sentrytyp := cak_econstraint;
            stableid  := tree.fileTabId_gg00
            END;
        (*ENDIF*) 
        slinkage[1] := chr(constraint_id DIV 256);
        slinkage[2] := chr(constraint_id MOD 256);
        skeylen       := mxak_standard_sysk;
        a10get_sysinfo (acv, sysk, d_release, p, b_in_err);
        IF  b_in_err <> e_ok
        THEN
            a07_b_put_error ( acv, b_in_err, 1)
        ELSE
            WITH p^.sconstraint DO
                BEGIN
                g01mblock_init (acv.a_transinf.tri_trans,
                      m_nil, mm_nil, mblock);
                g01datapart_init (mblock, @ldata, sizeof(ldata));
                a10new (acv, (cstack_cnt+1) * STACK_ENTRY_MXGG00,
                      lstack);
                IF  lstack = NIL
                THEN
                    a07_b_put_error (acv, e_no_more_memory, 1)
                ELSE
                    BEGIN
                    g01stack_init (mblock, lstack,
                          (cstack_cnt+1) * STACK_ENTRY_MXGG00,
                          @lqual, sizeof (lqual));
                    (* PTS 1000354 E.Z. *)
                    mb_qual^.mtree       := b01niltree_id;
                    mb_qual^.mqual_pos   := 1;
                    mb_qual^.mqual_cnt   := cstack_cnt;
                    mb_qual^.mfirst_free := cstack_cnt + 1;
                    (* PTS 1105092 E.Z. *)
                    mb_qual^.msqlmode    := a_sqlmode;
                    SAPDB_PascalMove ('VAK05 ',  41,    
                          sizeof (cstack), mb_st_max * STACK_ENTRY_MXGG00,
                          @cstack, (cstackstart -1) * STACK_ENTRY_MXGG00 + 1,
                          @mb_st^, 1, cstack_cnt * STACK_ENTRY_MXGG00,
                          a_returncode);
                    mb_data_len  := p^.b_sl -
                          cvalue_pos + cgg_rec_key_offset + 1;
                    SAPDB_PascalMove ('VAK05 ',  42,    
                          mxak_constraintrec, mb_data_size, @p^, cvalue_pos,
                          @mb_data^.mbp_buf, cgg_rec_key_offset+1,
                          mb_data_len -cgg_rec_key_offset,
                          a_returncode);
                    IF  a_returncode = 0
                    THEN
                        BEGIN
                        FOR i := 1 TO cstack_cnt DO
                            WITH mb_st^ [i] DO
                                IF  (etype = st_fixkey) OR
                                    (etype = st_varkey) OR
                                    (etype = st_fixcol) OR
                                    (etype = st_varcol) OR
                                    (etype = st_varlongchar)
                                THEN
                                    BEGIN
                                    etype    := st_varcol;
                                    ecolno   := 1;
                                    END
                                ELSE
                                    IF  etype in
                                        [ st_language, st_format,
                                        st_date, st_time, st_timestamp,
                                        (* PTS 1116174 E.Z. *)
                                        st_utcdate,
                                        (* PTS 1109925 E.Z. *)
                                        st_utcdiff,
                                        st_user, st_usergroup, st_current_schema, st_uid,
                                        st_sysdba, st_localsysdba,
                                        st_transaction, st_timezone (* PTS 1122262 E.Z. *)
                                        ]
                                    THEN
                                        a54_internal_function (acv, mblock, i);
                                    (*ENDIF*) 
                                (*ENDIF*) 
                            (*ENDWITH*) 
                        (*ENDFOR*) 
                        IF  (coldrange OR (a_sqlmode = sqlm_ansi))
                            AND
                            (mb_qual^.mfirst_free <= mb_st_max)
                        THEN
                            WITH mb_qual^, mb_st^ [mfirst_free] DO
                                BEGIN
                                etype       := st_truth;
                                epos        := cgg04_is_not_false;
                                mfirst_free := mfirst_free + 1;
                                mqual_cnt   := mqual_cnt + 1
                                END;
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        valb.recLen_gg00          := cgg_rec_key_offset + 1 + val_len;
                        valb.recKeyLen_gg00       := 0;
                        valb.recVarcolOffset_gg00 := 0;
                        valb.recVarcolCnt_gg00    := 1;
                        valb.info[ 1 ] := chr(val_len);
                        SAPDB_PascalMove ('VAK05 ',  43,    
                              MOVEOBJ_MXSP00, RECBODY_MXGG00,
                              @valbuf, val_pos, @valb.info, 2, val_len,
                              a_returncode);
&                       ifdef trace
                        t01messblock (ak_sem, '05cinconstr ', mblock);
&                       endif
                        IF  a_returncode = 0
                        THEN
                            BEGIN
                            valb.len := valb.len + cgg_rec_key_offset;
                            mblock.mb_work_st      := a_work_st_addr;
                            mblock.mb_work_st_max  := a_work_st_max;
                            mblock.mb_workbuf      := a_work_buf_addr;
                            mblock.mb_workbuf_size := a_work_buf_size;
                            mblock.mb_trns         := @a_transinf.tri_trans;
                            k71qualification_test (mblock, c_first_qual,
                                  NOT c_result_wanted, NOT c_check_new_rec,
                                  valb, NIL, 0, res_len);
                            valb.len := valb.len - cgg_rec_key_offset;
                            IF  mblock.mb_trns^.trError_gg00 <> e_ok
                            THEN
                                BEGIN
                                a_transinf.tri_trans.trState_gg00 :=
                                      mblock.mb_trns^.trState_gg00;
                                a11getconstraintname (p^.sconstraint, cons_name);
                                a07_nb_put_error (acv, b_err,
                                      error_pos, cons_name)
                                END;
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    a10dispose (acv, lstack);
                    END
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05password_get (
            VAR acv      : tak_all_command_glob;
            tree_index   : integer;
            VAR password : tsp00_Pw);
 
VAR
      error        : tsp8_uni_error;
      err_char_no  : tsp00_Int4;
      uni_len      : tsp00_Int4;
      password_ptr : tsp00_MoveObjPtr;
      aux_pw       : tsp00_Pw;
      src_codeset  : tsp00_Int2;
      value_ptr    : tsp00_MoveObjPtr;
      value_len    : tsp00_Int4;
      is_null      : boolean;
      is_default   : boolean;
 
BEGIN
IF  tree_index <> 0
THEN
    BEGIN
    password_ptr := @password;
    src_codeset  := csp_unicode;
    a05_identifier_get (acv, tree_index,
          sizeof (password), password_ptr^)
    END
ELSE
    WITH acv DO
        BEGIN
        IF  NOT a_variable_input
            OR
            ((a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc = a36) AND
            ( a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc = cak_x_connect))
            OR
            ((a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc = a51) AND
            ( a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc = cak_x_connect))
        THEN
            BEGIN
            g03part2_decrypt (a_data_ptr^,
                  a_mess_code, a_input_data_pos + 1,
                  a_cmd_packet_header.sp1h_mess_swap,
                  g01code.kernel_swap, password);
            a_input_data_pos := a_input_data_pos + 1 + CRYPTPW_MXSP00;
            END
        ELSE
            BEGIN
            IF  NOT a509get_one_value (acv.a_input_data_map, a_input_data_pos,
                value_ptr, value_len, is_null, is_default)
            THEN
                a07ak_system_error (acv, 5, 1)
            ELSE
                g03part2_decrypt (value_ptr^,
                      a_mess_code, 1,
                      a_cmd_packet_header.sp1h_mess_swap,
                      g01code.kernel_swap, password);
            (*ENDIF*) 
            a_input_data_pos := succ(a_input_data_pos);
            END;
        (*ENDIF*) 
        src_codeset := a_cmd_packet_header.sp1h_mess_code;
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  g01unicode
THEN      (* Note, that here we transform even, if src and  *)
    BEGIN (* dest code sets are both ascii, because we need *)
    (*       to cut the password to 9 chars.                *)
    uni_len := sizeof(password);
    error   := uni_ok;
    IF  (src_codeset <> csp_unicode)      OR
        ( acv.a_ascii_in_and_output AND
        ( tree_index = 0))
    THEN      (* Since either src or dest of uni_trans have to be *)
        BEGIN (* unicode, in some cases we must call it twice.    *)
        IF  ( acv.a_ascii_in_and_output AND
            ( tree_index = 0)) (* new feature *)
        THEN
            s80uni_trans (@password, sizeof(password), csp_ascii,
                  @aux_pw, uni_len, csp_unicode,
                  [ ], error, err_char_no)
        ELSE
            s80uni_trans (@password, sizeof(password), src_codeset,
                  @aux_pw, uni_len, csp_unicode,
                  [ ], error, err_char_no);
        (*ENDIF*) 
        (* PTS 1109594 *)
        IF  (error <> uni_ok) AND (error <> uni_dest_too_short)
        THEN
            a07_hex_uni_error (acv, error, err_char_no,
                  NOT c_trans_to_uni, @password [err_char_no],
                  c_unicode_wid)
        ELSE
            BEGIN
            SAPDB_PascalForcedFill (sizeof(aux_pw), @aux_pw, uni_len+1,
                  sizeof(aux_pw) - uni_len, bsp_c1);
            password := aux_pw
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05put_identifier (
            VAR id      : tsp00_KnlIdentifier;
            VAR moveobj : tsp00_MoveObj;
            moveobj_size: tsp00_Int4;
            VAR pos     : tsp00_Int4;
            VAR retcode : tsp00_Int2);
 
VAR
      ix  : integer;
      len : integer;
 
BEGIN
IF  g01unicode
THEN
    BEGIN
    len := s30unilnr (@id, csp_unicode_blank, 1, sizeof(id));
    IF  a01is_identifier (id, len, sqlm_internal)
    THEN
        BEGIN
        SAPDB_PascalMove ('VAK05 ',  44,    
              sizeof (id), moveobj_size,
              @id, 1, @moveobj, pos, len, retcode);
        pos := pos + len
        END
    ELSE
        BEGIN
        moveobj[pos  ] := csp_unicode_mark;
        moveobj[pos+1] := '"';
        pos          := pos + 2;
        ix := 1;
        WHILE ix < len DO
            BEGIN
            moveobj[pos  ] := id[ix  ];
            moveobj[pos+1] := id[ix+1];
            IF  (id[ix  ] = csp_unicode_mark) AND
                (id[ix+1] = '"')
            THEN
                BEGIN
                moveobj[pos+2] := csp_unicode_mark;
                moveobj[pos+3] := '"';
                pos            := pos + 4
                END
            ELSE
                pos := pos + 2;
            (*ENDIF*) 
            ix := ix+2
            END;
        (*ENDWHILE*) 
        moveobj[pos  ] := csp_unicode_mark;
        moveobj[pos+1] := '"';
        pos          := pos + 2
        END;
    (*ENDIF*) 
    END
ELSE
    BEGIN
    len := s30klen (id, bsp_c1, sizeof (id));
    IF  a01is_identifier (id, len, sqlm_internal)
    THEN
        BEGIN
        SAPDB_PascalMove ('VAK05 ',  45,    
              sizeof (id), moveobj_size,
              @id, 1, @moveobj, pos, len, retcode);
        pos := pos + len
        END
    ELSE
        BEGIN
        moveobj[pos] := '"';
        pos          := pos + 1;
        FOR ix := 1 TO len DO
            BEGIN
            moveobj[pos] := id[ix];
            IF  id[ix] = '"'
            THEN
                BEGIN
                moveobj[pos+1] := '"';
                pos            := pos + 2
                END
            ELSE
                pos := pos + 1
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        moveobj[pos] := '"';
        pos          := pos + 1
        END;
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05timestamp_get (
            VAR acv      : tak_all_command_glob;
            VAR src      : tsp00_MoveObj;
            src_pos      : tsp00_Int4;
            source_undef : boolean;
            VAR dest     : tsp00_MoveObj;
            dest_pos     : tsp00_Int4;
            check_len    : tsp00_Int4;
            VAR b_err    : tgg00_BasisError);
 
VAR
      curr_date : tsp00_C9;
      date_err  : tsp6_date_error;
&     ifdef trace
      m_ptr     : tsp00_MoveObjPtr;
&     endif
 
BEGIN
IF  acv.a_dt_format <> dtf_oracle_date
THEN
    g03ftscheck_timestamp (src, dest, src_pos, dest_pos,
          check_len, acv.a_dt_format, acv.a_ak_language, b_err)
ELSE
    BEGIN
    IF  acv.a_timestamp = bsp_c20
    THEN
        vtimestamp (acv.a_timestamp);
    (*ENDIF*) 
    curr_date[ 1 ] := csp_ascii_blank;
    SAPDB_PascalForcedMove (sizeof (acv.a_timestamp), sizeof (curr_date),
          @acv.a_timestamp, 1, @curr_date, 2, mxsp_date);
    date_err := sp6de_ok;
    IF  source_undef
    THEN
        dest[dest_pos] := csp_undef_byte
    ELSE
        s78c2d_to_date (g03dictionary.dict[ acv.a_nls_params.dl_language_no ],
              @curr_date, @acv.a_nls_params.date_format,
              acv.a_nls_params.df_length, @src[ src_pos ], check_len,
              @dest, dest_pos, date_err);
    (*ENDIF*) 
&   ifdef trace
    t01int4 (ak_sem, 'date_err    ', ord (date_err));
    m_ptr := @acv.a_nls_params.date_format;
    t01moveobj (ak_sem, m_ptr^, 1, acv.a_nls_params.df_length);
    t01moveobj (ak_sem, src, src_pos, src_pos + check_len-1);
&   endif
    IF  date_err = sp6de_ok
    THEN
        b_err := e_ok
    ELSE
        b_err := g03date_error_to_b_err (date_err)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05dfts_date_from_timestamp (
            VAR sbuf   : tsp00_MoveObj;
            VAR dbuf   : tsp00_MoveObj;
            spos       : tsp00_Int4;
            dpos       : tsp00_Int4;
            dbufsize   : tsp00_Int4;
            actlen     : integer;
            format     : tgg00_DateTimeFormat;
            language   : tsp00_C3;
            VAR b_err  : tgg00_BasisError);
 
VAR
      timestamp : tsp00_Timestamp;
 
BEGIN
g03ftsc_timestamp (@sbuf, @timestamp, spos, 1,
      actlen, format, language, b_err);
IF  b_err = e_ok
THEN
    SAPDB_PascalMove ('VAK05 ',  46,    
          sizeof (timestamp), dbufsize, @timestamp, 1,
          @dbuf, dpos, sizeof (tsp00_Date), b_err)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05tfts_time_from_timestamp (
            VAR sbuf   : tsp00_MoveObj;
            VAR dbuf   : tsp00_MoveObj;
            spos       : tsp00_Int4;
            dpos       : tsp00_Int4;
            dbufsize   : tsp00_Int4;
            actlen     : integer;
            format     : tgg00_DateTimeFormat;
            language   : tsp00_C3;
            VAR b_err  : tgg00_BasisError);
 
CONST
      c_time_in_timestamp_len = 6;
 
VAR
      timestamp : tsp00_Timestamp;
 
BEGIN
g03ftsc_timestamp (@sbuf, @timestamp, spos, 1,
      actlen, format, language, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    SAPDB_PascalFill ('VAK05 ',  47,    
          dbufsize, @dbuf, dpos, mxsp_time - c_time_in_timestamp_len,
          csp_ascii_zero, b_err);
    SAPDB_PascalMove ('VAK05 ',  48,    
          sizeof (timestamp), dbufsize, @timestamp, mxsp_date + 1,
          @dbuf, dpos + mxsp_time - c_time_in_timestamp_len,
          c_time_in_timestamp_len, b_err);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05tsfdt_timestamp_from_dattim (
            VAR sbuf   : tsp00_MoveObj;
            VAR dbuf   : tsp00_MoveObj;
            spos       : tsp00_Int4;
            dpos       : tsp00_Int4;
            dbufsize   : tsp00_Int4;
            actlen     : integer;
            format     : tgg00_DateTimeFormat;
            stype      : tsp00_DataType;
            VAR b_err  : tgg00_BasisError);
 
VAR
      date : tsp00_Date;
      time : tsp00_Time;
 
BEGIN
(* initialize date and time ==> date = current date *)
(*                              time = set to null  *)
vdattime (date,time);
SAPDB_PascalForcedFill (sizeof(time), @time, 1, sizeof(time), csp_ascii_zero);
CASE stype OF
    ddate :
        g03fdc_date (@sbuf, @date, spos, 1, actlen, format, b_err);
    dtime :
        g03ftc_time (@sbuf, @time, spos, 1, actlen, format, b_err);
    OTHERWISE :
        b_err := e_invalid_timestamp;
    END;
(*ENDCASE*) 
IF  b_err = e_ok
THEN
    BEGIN
    SAPDB_PascalMove ('VAK05 ',  49,    
          sizeof(date), dbufsize,
          @date, 1, @dbuf, dpos, sizeof(date), b_err);
    SAPDB_PascalMove ('VAK05 ',  50,    
          sizeof(time), dbufsize,
          @time, 3, @dbuf, dpos+sizeof(date), sizeof(time)-2, b_err);
    SAPDB_PascalFill ('VAK05 ',  51,    
          dbufsize, @dbuf,
          dpos + mxsp_timestamp - 6, 6, csp_ascii_zero, b_err);
    END;
(*ENDIF*) 
END;
 
(* PTS 1001154 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a05_verify_not_null (
            VAR acv        : tak_all_command_glob;
            VAR valbuf     : tgg00_Rec;
            VAR stackentry : tgg00_StackEntry);
 
TYPE
      tak05short_stack = PACKED ARRAY [ 1..3 ] OF tgg00_StackEntry;
 
VAR
      b_err      : tgg00_BasisError;
      res_len    : integer;
      sysk       : tgg00_SysInfoKey;
      st         : tak05short_stack;
      lstack     : tgg00_StackListPtr;
      err_msg    : tgg04_Err;
      ldata      : tsp00_C8;
      lqual      : tgg00_QualBuf;
      mblock     : tgg00_MessBlock;
 
BEGIN
WITH acv, sysk, mblock DO
    BEGIN
    IF  a_returncode = 0
    THEN
        BEGIN
        g01mblock_init (acv.a_transinf.tri_trans,
              m_nil, mm_nil, mblock);
        g01datapart_init (mblock, @ldata, sizeof(ldata));
        lstack := @st;
        g01stack_init (mblock, lstack, 3 * STACK_ENTRY_MXGG00,
              @lqual, sizeof (lqual));
        mb_qual^.mtree       := b01niltree_id;
        mb_qual^.mqual_pos   := 1;
        mb_qual^.mqual_cnt   := 2;
        mb_qual^.mfirst_free := 3;
        (* PTS 1105092 E.Z. *)
        mb_qual^.msqlmode    := a_sqlmode;
        mb_st^[ 1 ] := stackentry;
        WITH mb_st^ [2] DO
            BEGIN
            etype := st_value;
            eop := op_not_null;
            epos := mb_data_len+1;
            elen_var := 1;
            ecol_pos := 0;
            mb_data_len := succ(mb_data_len);
            mb_data^.mbp_buf [mb_data_len] := csp_undef_byte
            END;
        (*ENDWITH*) 
        valbuf.len := valbuf.len + cgg_rec_key_offset;
        mblock.mb_work_st      := a_work_st_addr;
        mblock.mb_work_st_max  := a_work_st_max;
        mblock.mb_workbuf      := a_work_buf_addr;
        mblock.mb_workbuf_size := a_work_buf_size;
        mblock.mb_trns         := @a_transinf.tri_trans;
        k71qualification_test (mblock,  c_first_qual,
              NOT c_result_wanted, NOT c_check_new_rec,
              valbuf, NIL, 0, res_len);
        valbuf.len := valbuf.len - cgg_rec_key_offset;
        IF  mblock.mb_trns^.trError_gg00 <> e_ok
        THEN
            BEGIN
            a_transinf.tri_trans.trState_gg00 :=
                  mblock.mb_trns^.trState_gg00;
            a07_b_put_error (acv, e_range_violation,
                  1);
            a05get_err_tabid (acv.a_transinf.tri_trans, a_mblock.mb_qual^.mtree,
                  err_msg.errtableid);
            err_msg.errstack := stackentry;
            err_msg.errtablesite := cgg_zero_c2;
            err_msg.errstacktype := tfnTable_egg00;
            a06put_errtext (acv, e_range_violation,
                  errtext_stack,
                  sizeof (err_msg.errtableid) +
                  sizeof (err_msg.errstack)     +
                  sizeof (err_msg.errtablesite) +
                  sizeof (err_msg.errstacktype),
                  err_msg.errt, b_err)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1121403 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a05init;
 
BEGIN
a05unicode_blankvalue[1] := csp_unicode_def_byte;
a05ascii_blankvalue      := csp_unicode_blank;
a05unicode_blankvalue[2] := a05ascii_blankvalue[1];
a05unicode_blankvalue[3] := a05ascii_blankvalue[2];
a05ascii_blankvalue[1] := csp_ascii_blank;
a05ascii_blankvalue[2] := csp_ascii_blank;
END;
 
(*------------------------------*) 
 
FUNCTION
      a05lnr_space_defbyte (
            acv       : tak_acv_address;
            VAR str   : tsp00_MoveObjPtr;
            defbyte   : char;
            start_pos : tsp00_Int4;
            length    : tsp00_Int4) : tsp00_Int4;
 
VAR
      i      : tsp00_Int4;
      finish : boolean;
 
BEGIN
i      := start_pos + length - 1;
finish := false;
a05lnr_space_defbyte := -32767;
IF  defbyte = csp_unicode_def_byte
THEN
    BEGIN
    WHILE (i > start_pos) AND NOT finish DO
        BEGIN
        IF  (str^[i-1] <> csp_unicode_mark) OR (str^[i] <> bsp_c1)
        THEN
            BEGIN
            a05lnr_space_defbyte := i - start_pos + 1;
            finish := true;
            END
        ELSE
            i := i-2;
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  NOT finish
    THEN
        IF  acv^.a_space_option
        THEN
            BEGIN
            a05lnr_space_defbyte := 2;
            str := @a05unicode_blankvalue;
            END
        ELSE
            a05lnr_space_defbyte := 0
        (*ENDIF*) 
    (*ENDIF*) 
    END
ELSE
    BEGIN
    WHILE (i >= start_pos) AND NOT finish DO
        BEGIN
        IF  str^ [i] <> defbyte
        THEN
            BEGIN
            a05lnr_space_defbyte := i - start_pos + 1;
            finish := true;
            END
        ELSE
            i := i-1;
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  NOT finish
    THEN
        IF  (defbyte = csp_ascii_blank) AND acv^.a_space_option
        THEN
            BEGIN
            a05lnr_space_defbyte := 1;
            str := @a05ascii_blankvalue;
            END
        ELSE
            a05lnr_space_defbyte := 0;
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a05luc_space (
            acv          : tak_acv_address;
            VAR buf1     : tsp00_MoveObj;
            fieldpos1    : tsp00_Int4;
            fieldlength1 : tsp00_Int4;
            VAR buf2     : tsp00_MoveObj;
            fieldpos2    : tsp00_Int4;
            fieldlength2 : tsp00_Int4;
            VAR l_result : tsp00_LcompResult);
 
VAR
      check_trailing_defbyte : boolean;
      prefix_compare         : tsp00_LcompResult;
      def_byte               : char;
      prefix_length          : tsp00_Int4;
      i                      : tsp00_Int4;
 
BEGIN
(*  collogica  implementierung nicht getestet 4.7.85 *)
IF  (fieldlength1 < 1) OR (fieldlength2 < 1)
THEN
    l_result := l_undef
ELSE
    IF  (buf1 [fieldpos1] = csp_undef_byte) OR
        (* NULL value *)
        (buf2 [fieldpos2] = csp_undef_byte) OR
        (buf1 [fieldpos1] = csp_default_byte) OR
        (* PARAMETER *)
        (buf2 [fieldpos2] = csp_default_byte)
    THEN
        l_result := l_undef
    ELSE
        BEGIN
        IF  fieldlength1 > fieldlength2
        THEN
            prefix_length := fieldlength2 - 1
        ELSE
            prefix_length := fieldlength1 - 1;
        (*ENDIF*) 
        i                      := 1;
        prefix_compare         := l_equal;
        def_byte               := buf1 [fieldpos1];
        check_trailing_defbyte := false;
        WHILE (prefix_compare = l_equal) AND (i <= prefix_length) DO
            BEGIN
            IF  buf1 [fieldpos1+i] > buf2 [fieldpos2+i]
            THEN
                BEGIN
                prefix_compare := l_greater;
                IF  def_byte = csp_unicode_def_byte
                THEN
                    check_trailing_defbyte :=
                          (buf1 [fieldpos1+i-1] = csp_unicode_mark) AND
                          (buf1 [fieldpos1+i]   = csp_ascii_blank)  AND
                          (NOT acv^.a_space_option OR (i > 2))
                ELSE
                    check_trailing_defbyte := (buf1 [fieldpos1+i] = def_byte) AND
                          (NOT acv^.a_space_option OR (i > 1))
                (*ENDIF*) 
                END
            ELSE
                IF  buf1 [fieldpos1+i] < buf2 [fieldpos2+i]
                THEN
                    BEGIN
                    prefix_compare := l_less;
                    IF  def_byte = csp_unicode_def_byte
                    THEN
                        check_trailing_defbyte :=
                              (buf2 [fieldpos2+i-1] = csp_unicode_mark) AND
                              (buf2 [fieldpos2+i]   = csp_ascii_blank)  AND
                              (NOT acv^.a_space_option OR (i > 2))
                    ELSE
                        check_trailing_defbyte := (buf2 [fieldpos2+i] = def_byte) AND
                              (NOT acv^.a_space_option OR (i > 1))
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            i := i + 1
            END;
        (*ENDWHILE*) 
        CASE prefix_compare OF
            l_greater:
                IF  check_trailing_defbyte
                THEN
                    BEGIN
                    i := i - 1;
                    IF  def_byte = csp_unicode_def_byte
                    THEN
                        i := i - 1;
                    (*ENDIF*) 
                    IF  s30lnr_defbyte (@buf1, def_byte,
                        fieldpos1+i, fieldlength1-i) = 0
                    THEN
                        l_result := l_less
                    ELSE
                        l_result := l_greater
                    (*ENDIF*) 
                    END
                ELSE
                    l_result := l_greater;
                (*ENDIF*) 
            l_less:
                IF  check_trailing_defbyte
                THEN
                    BEGIN
                    i := i - 1;
                    IF  def_byte = csp_unicode_def_byte
                    THEN
                        i := i - 1;
                    (*ENDIF*) 
                    IF  s30lnr_defbyte (@buf2, def_byte,
                        fieldpos2+i, fieldlength2-i) = 0
                    THEN
                        l_result := l_greater
                    ELSE
                        l_result := l_less
                    (*ENDIF*) 
                    END
                ELSE
                    l_result := l_less;
                (*ENDIF*) 
            l_equal:
                BEGIN
                IF  fieldlength1 = fieldlength2
                THEN
                    l_result := l_equal
                ELSE
                    IF  fieldlength1 > fieldlength2
                    THEN
                        BEGIN
                        IF  s30lnr_defbyte (@buf1, def_byte,
                            fieldpos1+i, fieldlength1-i) = 0
                        THEN
                            l_result := l_equal
                        ELSE
                            l_result := l_greater
                        (*ENDIF*) 
                        END
                    ELSE (* fieldlength1 < fieldlength2 *)
                        BEGIN
                        IF  s30lnr_defbyte (@buf2, def_byte,
                            fieldpos2+i, fieldlength2-i) = 0
                        THEN
                            l_result := l_equal
                        ELSE
                            l_result := l_less
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            END
        (*ENDCASE*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
&ifdef trace
t01comp_result( ak_sem, 'return      ', l_result );
&endif
END;
 
(*------------------------------*) 
 
FUNCTION
      a05space_option (acv : tak_acv_address) : boolean;
 
BEGIN
a05space_option := acv^.a_space_option
END;
 
(* PTS END 1121403 E.Z. *)
(*------------------------------*) 
 
FUNCTION
      a05variable_input (acv : tak_acv_address) : boolean;
 
BEGIN
a05variable_input := acv^.a_variable_input
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
