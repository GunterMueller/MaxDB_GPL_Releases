.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 1994-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.tt 1 $SQL$Project Distributed Database System$VEN38A$
.tt 2 $$$
.tt 3 $$                                       $2000-04-12$
***********************************************************
.nf

.nf

.nf

    ========== licence begin  GPL
    Copyright (c) 1994-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

//
//   FreeBSD portions added by Kai Mosebach, 
//   For more informations see : http://www.komadev.de/sapdb
//

.fo


.fo
.nf
.sp
Module  :       CALL-DB-Procedure
=========
.sp
Purpose : This procedure pushes the parameter stack for 
	      a DB-Procedure and passes control to the procedure

.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
   externC long sql38aVdcomCall( IUnknown *lpIUnknown,
                                 PROC     pProc,
                                 void*    pBufAddr,
                                 long     BufLen );
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
.CM *-END-* use -----------------------------------------
Synonym :
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : FerdiF
.sp
.cp 3
Created : 1998-11-30
.sp
.cp 3
Version : 1998-11-30
.sp
.cp 3
Release :      Date : 2000-04-12
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:

.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
&undef	PRETTY

&if  $MACH = COMMENT
***************************************************************
*   Linux on Intel   
***************************************************************
&endif
&if  ($MACH = I386 and $OSSPEC = LINUX ) or ($OSSPEC = FREEBSD)
	.file	"ven38a"
	.version	"01.01"

	.text
	.align 4

 /*                                                                 */
 /*  EXTERN_C LONG __stdcall sql38aVdcomCall( IUnknown *lpIUnknown, */
 /*                                           PROC  pProc,          */	
 /*                                           void* pBufAddr,       */
 /*                                           long  BufLen,         */
 /*                                           long  StackSize );    */
 /*                                                                 */

	.globl		sql38aVdcomCall
	.type		sql38aVdcomCall,@function
sql38aVdcomCall:

	pushl %ebp							
	movl %esp,%ebp

 /* Save All Registers */
	pushf
	pushl %esi
	pushl %edi
	pushl %edx
	pushl %ecx
	pushl %ebx

 /* Save stack pointer for stack recovery after return from call */
	movl  %esp,%ebx 
 /* Reserve StackSizeInByte */
	subl 24(%ebp),%esp
	addl $4,%esp
 /* Load counter register with number of stack items (16B-sized) */
	movl 20(%ebp),%ecx
	shrl $4,%ecx
 /* Get source address */
	movl 16(%ebp),%esi
 /* Get destination address */
	movl %esp,%edi
 /* Move onto stack */
	cld
	test %ecx, %ecx
	jz .L1
.L0:
	movsl (%esi),%es:(%edi)
	add $12, %esi
	loop .L0
.L1:

 /* push this pointer */
	movl 8(%ebp),%edx
	pushl %edx
 /* Get procedure address */
	movl 12(%ebp),%edx
 /* Call it */ 
	call *%edx
 /*; Get former stack pointer independend of call 'result' */
	movl %ebx,%esp
 /* Always return OK */
	movl $0,%eax
 /* Get registers back */
	popl %ebx
	popl %ecx
	popl %edx
	popl %edi
	popl %esi
	popf
	movl -4(%ebp),%ebx
	leave
	ret
.Lfe1:
	.size	 sql38aVdcomCall,.Lfe1-sql38aVdcomCall
;	.ident	""
&endif

&if $OSSPEC == LINUX && $MACH == IA64
	.file	"ven38c.s"
	.pred.safe_across_calls p1-p5,p16-p63
	.text
	.align 16
	.global sql38aVdcomCall#
	.proc sql38aVdcomCall#
sql38aVdcomCall:
	.prologue 14, 37
	.mii
	.save ar.pfs, r38
	alloc r38 = ar.pfs, 4, 4, 8, 0
	mov r19 = r0
	mov r18 = r0
	.mii
	mov r17 = r0
	sxt4 r35 = r35
	.vframe r39
	mov r39 = r12
	.mmi
	mov r16 = r34
	;;
	nop.m 0
	shr.u r14 = r35, 3
	.mii
	nop.m 0
	.save rp, r37
	mov r37 = b0
	.body
	;;
	adds r14 = -7, r14
	;;
	.mmi
	cmp4.ge p6, p7 = 0, r14
	;;
	nop.m 0
	(p7) sxt4 r14 = r14
	;;
	.mmi
	(p7) shladd r14 = r14, 3, r0
	;;
	(p7) adds r14 = 30, r14
	nop.i 0
	;;
	.mmi
	(p7) and r14 = -16, r14
	;;
	(p7) sub r12 = r12, r14
	nop.i 0
	;;
	.mii
	(p7) adds r19 = 16, r12
	nop.i 0
	nop.i 0
.L3:
	.mii
	add r14 = r34, r35
	dep.z r15 = r18, 3, 32
	;;
	cmp.gtu p6, p7 = r14, r16
	.mib
	adds r14 = 8, r16
	nop.i 0
	(p7) br.cond.dpnt .L4
	;;
	.mib
	cmp4.lt p6, p7 = 7, r18
	nop.i 0
	(p6) br.cond.dptk .L7
	.mmi
	ld2 r14 = [r14]
	;;
	adds r14 = -4, r14
	nop.i 0
	;;
	.mii
	nop.m 0
	zxt2 r14 = r14
	;;
	cmp4.ltu p6, p7 = 1, r14
	.mib
	addl r14 = @ltoff(.L17), gp
	nop.i 0
	(p6) br.cond.dptk .L7
	;;
	.mib
	cmp4.ltu p6, p7 = 7, r18
	nop.i 0
	(p6) br.cond.dptk .L8
	.mmi
	ld8 r14 = [r14]
	;;
	add r15 = r15, r14
	nop.i 0
	;;
	.mmi
	ld8 r14 = [r15]
	;;
	add r14 = r14, r15
	nop.i 0
	;;
	.mib
	nop.m 0
	mov b6 = r14
	br b6
	.section	.rodata
	.align 8
	.align 4
.L17:
	data8 @pcrel(.L9)
	data8 @pcrel(.L10)
	data8 @pcrel(.L11)
	data8 @pcrel(.L12)
	data8 @pcrel(.L13)
	data8 @pcrel(.L14)
	data8 @pcrel(.L15)
	data8 @pcrel(.L16)
	.text
.L9:
	ld8 r8 = [r16];; setf.d f8 = r8;;
.L8:
	.mii
	adds r17 = 1, r17
	adds r18 = 1, r18
	nop.i 0
.L19:
	.mib
	adds r16 = 16, r16
	nop.i 0
	br .L3
	;;
.L10:
	ld8 r8 = [r16];; setf.d f9 = r8;;
	.mib
	nop.m 0
	nop.i 0
	br .L8
.L11:
	ld8 r8 = [r16];; setf.d f10 = r8;;
	.mib
	nop.m 0
	nop.i 0
	br .L8
.L12:
	ld8 r8 = [r16];; setf.d f11 = r8;;
	.mib
	nop.m 0
	nop.i 0
	br .L8
.L13:
	ld8 r8 = [r16];; setf.d f12 = r8;;
	.mib
	nop.m 0
	nop.i 0
	br .L8
.L14:
	ld8 r8 = [r16];; setf.d f13 = r8;;
	.mib
	nop.m 0
	nop.i 0
	br .L8
.L15:
	ld8 r8 = [r16];; setf.d f14 = r8;;
	.mib
	nop.m 0
	nop.i 0
	br .L8
.L16:
	ld8 r8 = [r16];; setf.d f15 = r8;;
	.mib
	nop.m 0
	nop.i 0
	br .L8
.L7:
	.mii
	cmp4.lt p6, p7 = 6, r17
	dep.z r15 = r17, 3, 32
	;;
	nop.i 0
	.mfb
	(p6) ld8 r14 = [r16]
	nop.f 0
	nop.b 0
	;;
	.mib
	(p6) st8 [r19] = r14, 8
	addl r14 = @ltoff(.L29), gp
	(p6) br.cond.dptk .L19
	.mib
	cmp4.ltu p6, p7 = 6, r17
	nop.i 0
	(p6) br.cond.dptk .L21
	;;
	.mmi
	ld8 r14 = [r14]
	;;
	add r15 = r15, r14
	nop.i 0
	;;
	.mmi
	ld8 r14 = [r15]
	;;
	add r14 = r14, r15
	nop.i 0
	;;
	.mib
	nop.m 0
	mov b6 = r14
	br b6
	.section	.rodata
	.align 8
	.align 4
.L29:
	data8 @pcrel(.L22)
	data8 @pcrel(.L23)
	data8 @pcrel(.L24)
	data8 @pcrel(.L25)
	data8 @pcrel(.L26)
	data8 @pcrel(.L27)
	data8 @pcrel(.L28)
	.text
.L22:
	ld8 out1 = [r16];;
.L21:
	.mib
	adds r17 = 1, r17
	nop.i 0
	br .L19
.L23:
	ld8 out2 = [r16];;
	.mib
	nop.m 0
	nop.i 0
	br .L21
.L24:
	ld8 out3 = [r16];;
	.mib
	nop.m 0
	nop.i 0
	br .L21
.L25:
	ld8 out4 = [r16];;
	.mib
	nop.m 0
	nop.i 0
	br .L21
.L26:
	ld8 out5 = [r16];;
	.mib
	nop.m 0
	nop.i 0
	br .L21
.L27:
	ld8 out6 = [r16];;
	.mib
	nop.m 0
	nop.i 0
	br .L21
.L28:
	ld8 out7 = [r16];;
	.mib
	nop.m 0
	nop.i 0
	br .L21
.L4:
	.mii
	ld8 r14 = [r33], 8
	mov r40 = r32
	;;
	mov b6 = r14
	.mib
	ld8 r1 = [r33]
	nop.i 0
	br.call.sptk.many b0 = b6
	;;
	.mii
	.restore sp
	mov r12 = r39
	mov ar.pfs = r38
	mov b0 = r37
	.mib
	nop.m 0
	nop.i 0
	br.ret.sptk.many b0
	.endp sql38aVdcomCall#
	.ident	"GCC: (GNU) 3.1.1 20020624 (prerelease) (SuSE Linux)"
&endif

&if  $MACH = COMMENT
***************************************************************
*   Linux on Opteron Family (AMD X86-64)
***************************************************************
&endif

&if  $OSSPEC = LINUX && $MACH = X86_64 
	.file	"ven38c.c"
	.text
	.align 2
.globl sql38aVdcomCall
	.type	sql38aVdcomCall,@function
sql38aVdcomCall:
.LFB1:
	pushq	%rbp
.LCFI0:
	movq	%rsp, %rbp
.LCFI1:
	subq	$112, %rsp
.LCFI2:
	movq	%rdi, -8(%rbp)
	movq	%rsi, -16(%rbp)
	movq	%rdx, -24(%rbp)
	movl	%ecx, -28(%rbp)
	movl	%r8d, -32(%rbp)
	movl	$0, -56(%rbp)
	movl	$0, -60(%rbp)
	movl	-28(%rbp), %eax
	cltq
	shrq	$4, %rax
	subq	$5, %rax
	salq	$3, %rax
	movl	%eax, -52(%rbp)
	cmpl	$0, -52(%rbp)
	jle	.L2
	movl	-52(%rbp), %eax
	cltq
	addq	$15, %rax
	shrq	$4, %rax
	salq	$4, %rax
	subq	%rax, %rsp
	movq	%rsp, -88(%rbp)
	jmp	.L3
.L2:
	movq	$0, -88(%rbp)
.L3:
	movq	-88(%rbp), %rax
	movq	%rax, -48(%rbp)
	movq	-24(%rbp), %rax
	movq	%rax, -40(%rbp)
.L4:
	movl	-28(%rbp), %eax
	cltq
	addq	-24(%rbp), %rax
	cmpq	%rax, -40(%rbp)
	jb	.L7
	jmp	.L5
.L7:
	movq	-40(%rbp), %rax
	movswl	8(%rax),%eax
	movl	%eax, -64(%rbp)
	movq	-40(%rbp), %rax
	cmpb	$0, 11(%rax)
	je	.L8
	movq	-40(%rbp), %rax
	movq	(%rax), %rax
	movq	%rax, -80(%rbp)
	jmp	.L9
.L8:
	cmpl	$16, -64(%rbp)
	je	.L11
	cmpl	$207, -64(%rbp)
	je	.L11
	jmp	.L10
.L11:
	movq	-40(%rbp), %rax
	movsbq	(%rax),%rax
	movq	%rax, -80(%rbp)
	jmp	.L9
.L10:
	cmpl	$2, -64(%rbp)
	jne	.L13
	movq	-40(%rbp), %rax
	movswq	(%rax),%rax
	movq	%rax, -80(%rbp)
	jmp	.L9
.L13:
	cmpl	$3, -64(%rbp)
	je	.L16
	cmpl	$22, -64(%rbp)
	je	.L16
	jmp	.L15
.L16:
	movq	-40(%rbp), %rax
	movl	(%rax), %eax
	cltq
	movq	%rax, -80(%rbp)
	jmp	.L9
.L15:
	cmpl	$4, -64(%rbp)
	je	.L18
	cmpl	$5, -64(%rbp)
	je	.L18
	cmpl	$16, -64(%rbp)
	je	.L18
	cmpl	$207, -64(%rbp)
	je	.L18
	cmpl	$17, -64(%rbp)
	je	.L18
	cmpl	$209, -64(%rbp)
	je	.L18
	cmpl	$201, -64(%rbp)
	je	.L18
	cmpl	$203, -64(%rbp)
	je	.L18
	cmpl	$11, -64(%rbp)
	je	.L18
	cmpl	$2, -64(%rbp)
	je	.L18
	cmpl	$18, -64(%rbp)
	je	.L18
	cmpl	$202, -64(%rbp)
	je	.L18
	cmpl	$3, -64(%rbp)
	je	.L18
	cmpl	$22, -64(%rbp)
	je	.L18
	cmpl	$19, -64(%rbp)
	je	.L18
	cmpl	$23, -64(%rbp)
	je	.L18
	movq	-40(%rbp), %rax
	movq	(%rax), %rax
	movq	%rax, -80(%rbp)
	jmp	.L9
.L18:
	cmpl	$17, -64(%rbp)
	je	.L21
	cmpl	$209, -64(%rbp)
	je	.L21
	cmpl	$201, -64(%rbp)
	je	.L21
	cmpl	$203, -64(%rbp)
	je	.L21
	cmpl	$11, -64(%rbp)
	je	.L21
	jmp	.L20
.L21:
	movq	-40(%rbp), %rax
	movzbq	(%rax), %rax
	movq	%rax, -80(%rbp)
	jmp	.L9
.L20:
	cmpl	$18, -64(%rbp)
	je	.L24
	cmpl	$202, -64(%rbp)
	je	.L24
	jmp	.L23
.L24:
	movq	-40(%rbp), %rax
	movzwq	(%rax), %rax
	movq	%rax, -80(%rbp)
	jmp	.L9
.L23:
	cmpl	$19, -64(%rbp)
	je	.L27
	cmpl	$23, -64(%rbp)
	je	.L27
	jmp	.L26
.L27:
	movq	-40(%rbp), %rax
	mov	(%rax), %eax
	movq	%rax, -80(%rbp)
	jmp	.L9
.L26:
	cmpl	$4, -64(%rbp)
	je	.L29
	cmpl	$5, -64(%rbp)
	je	.L29
	cmpl	$16, -64(%rbp)
	je	.L29
	cmpl	$207, -64(%rbp)
	je	.L29
	cmpl	$17, -64(%rbp)
	je	.L29
	cmpl	$209, -64(%rbp)
	je	.L29
	cmpl	$201, -64(%rbp)
	je	.L29
	cmpl	$203, -64(%rbp)
	je	.L29
	cmpl	$11, -64(%rbp)
	je	.L29
	cmpl	$2, -64(%rbp)
	je	.L29
	cmpl	$18, -64(%rbp)
	je	.L29
	cmpl	$202, -64(%rbp)
	je	.L29
	cmpl	$3, -64(%rbp)
	je	.L29
	cmpl	$22, -64(%rbp)
	je	.L29
	cmpl	$19, -64(%rbp)
	je	.L29
	cmpl	$23, -64(%rbp)
	je	.L29
	movq	-40(%rbp), %rax
	movq	(%rax), %rax
	movq	%rax, -80(%rbp)
	jmp	.L9
.L29:
	cmpl	$4, -64(%rbp)
	jne	.L31
	movq	-40(%rbp), %rax
	movss	(%rax), %xmm15
	movss	%xmm15, -100(%rbp)
	flds	-100(%rbp)
	fstpl	-80(%rbp)
	jmp	.L9
.L31:
	cmpl	$5, -64(%rbp)
	jne	.L9
	movq	-40(%rbp), %rax
	movlpd	(%rax), %xmm15
	movsd	%xmm15, -80(%rbp)
.L9:
	movq	-40(%rbp), %rax
	cmpb	$0, 11(%rax)
	jne	.L35
	cmpl	$4, -64(%rbp)
	je	.L34
	cmpl	$5, -64(%rbp)
	jne	.L35
	jmp	.L34
.L35:
	cmpl	$4, -56(%rbp)
	ja	.L42
	mov	-56(%rbp), %eax
	leaq	0(,%rax,4), %r11
	leaq	.L43(%rip), %rax
	movl	(%rax,%r11), %eax
	movslq	%eax,%r11
	leaq	.L43(%rip), %rax
	leaq	(%rax,%r11), %rax
	jmp	*%rax
	.section	.rodata
	.align 4
	.align 4
.L43:
	.long	.L37-.L43
	.long	.L38-.L43
	.long	.L39-.L43
	.long	.L40-.L43
	.long	.L41-.L43
	.text
.L37:
	movq	-80(%rbp), %rax
	movq %rax, %rsi
	jmp	.L36
.L38:
	movq	-80(%rbp), %rax
	movq %rax, %rdx
	jmp	.L36
.L39:
	movq	-80(%rbp), %rax
	movq %rax, %rcx
	jmp	.L36
.L40:
	movq	-80(%rbp), %rax
	movq %rax, %r8
	jmp	.L36
.L41:
	movq	-80(%rbp), %rax
	movq %rax, %r9
	jmp	.L36
.L42:
	movq	-48(%rbp), %rax
	movq	%rax, %r11
	movq	-80(%rbp), %rax
	movq	%rax, (%r11)
	leaq	-48(%rbp), %rax
	addq	$8, (%rax)
.L36:
	leaq	-56(%rbp), %rax
	incl	(%rax)
	jmp	.L6
.L34:
	cmpl	$4, -64(%rbp)
	je	.L46
	cmpl	$5, -64(%rbp)
	je	.L46
	jmp	.L6
.L46:
	movl	-60(%rbp), %eax
	movl	%eax, -92(%rbp)
	cmpl	$1, -92(%rbp)
	je	.L49
	cmpl	$1, -92(%rbp)
	jg	.L53
	cmpl	$0, -92(%rbp)
	je	.L48
	jmp	.L51
.L53:
	cmpl	$2, -92(%rbp)
	je	.L50
	jmp	.L51
.L48:
	movlpd -80(%rbp), %xmm0
	jmp	.L47
.L49:
	movlpd -80(%rbp), %xmm1
	jmp	.L47
.L50:
	movlpd -80(%rbp), %xmm2
	jmp	.L47
.L51:
	movq	-48(%rbp), %rax
	movlpd	-80(%rbp), %xmm15
	movsd	%xmm15, (%rax)
	leaq	-48(%rbp), %rax
	addq	$8, (%rax)
.L47:
	leaq	-60(%rbp), %rax
	incl	(%rax)
.L6:
	leaq	-40(%rbp), %rax
	addq	$16, (%rax)
	jmp	.L4
.L5:
	movl	$0, %eax
	cmpl	$0, -60(%rbp)
	jle	.L54
	movl	-60(%rbp), %eax
.L54:
	movq	-8(%rbp), %rdi
	movq	-16(%rbp), %r11
	call	*%r11
	leave
	ret
.LFE1:
.Lfe1:
	.size	sql38aVdcomCall,.Lfe1-sql38aVdcomCall
	.section	.eh_frame,"aw",@progbits
.Lframe1:
	.long	.LECIE1-.LSCIE1
.LSCIE1:
	.long	0x0
	.byte	0x1
	.string	"zPR"
	.uleb128 0x1
	.sleb128 -8
	.byte	0x10
	.uleb128 0x6
	.byte	0x9b
	.long	DW.ref.__gxx_personality_v0-.
	.byte	0x1b
	.byte	0xc
	.uleb128 0x7
	.uleb128 0x8
	.byte	0x90
	.uleb128 0x1
	.align 8
.LECIE1:
.LSFDE1:
	.long	.LEFDE1-.LASFDE1
.LASFDE1:
	.long	.LASFDE1-.Lframe1
	.long	.LFB1-.
	.long	.LFE1-.LFB1
	.uleb128 0x0
	.byte	0x4
	.long	.LCFI0-.LFB1
	.byte	0xe
	.uleb128 0x10
	.byte	0x86
	.uleb128 0x2
	.byte	0x4
	.long	.LCFI1-.LCFI0
	.byte	0xd
	.uleb128 0x6
	.align 8
.LEFDE1:
	.hidden DW.ref.__gxx_personality_v0
	.weak	DW.ref.__gxx_personality_v0
	.section	.gnu.linkonce.d.DW.ref.__gxx_personality_v0,"aw",@progbits
	.align 8
	.type	DW.ref.__gxx_personality_v0,@object
	.size	DW.ref.__gxx_personality_v0,8
DW.ref.__gxx_personality_v0:
	.quad	__gxx_personality_v0
	.ident	"GCC: (GNU) 3.2.2 (SuSE Linux)"
&endif

&if  $MACH = COMMENT
***************************************************************
*   DEC OSF1 64 Bit  & cxx Compiler   
***************************************************************
&endif
&if  $MACH = ALPHA

#include <alpha/regdef.h>

#define vt_empty          0
#define vt_null           1
#define vt_i2             2
#define vt_i4             3
#define vt_r4             4
#define vt_r8             5
#define vt_cy             6
#define vt_date           7
#define vt_bstr           8
#define vt_dispatch       9
#define vt_error          10
#define vt_bool           11
#define vt_variant        12
#define vt_unknown        13
#define vt_decimal        14
#define vt_i1             16
#define vt_ui1            17
#define vt_ui2            18
#define vt_ui4            19
#define vt_i8             20
#define vt_ui8            21
#define vt_int            22
#define vt_uint           23
#define vt_void           24
#define vt_hresult        25
#define vt_ptr            26
#define vt_safearrary     27
#define vt_carray         28
#define vt_userdefined    29
#define vt_lpstr          30
#define vt_lpwstr         31
#define vt_filetime       64
#define vt_blob           65
#define vt_stream         66
#define vt_storage        67
#define vt_streamed_object 68
#define vt_stored_object  69
#define vt_blob_object    70
#define vt_cf             71
#define vt_clsid          72
#define vt_lc_char        201
#define vt_lc_wchar       202
#define vt_lc_byte        203
#define vt_lc_bool        204
#define vt_lc_abap_tab_handle 205
#define vt_lc_stream_handle   206
#define vt_lc_int1            207
#define vt_lc_uint1           209
#define vt_vector             4096
#define vt_array              8192
#define vt_byref              16384

#define ra_disp     0  
#define fp_disp     8
#define framesize   16  

#define ste_val     0
#define ste_vt      8
#define ste_io      10
#define ste_ptr     11
#define ste_len     12

     .text
     .arch  generic
     .align 4
    #
    # Parameters:
    #   a0 = InterfacePointer
    #   a1 = Method-Entry-Address
    #   a2 = address( parameter description area )
    #   a3 = length ( parameter description area )
    #   a4 = stack_size
    #
     .globl sql38aVdcomCall
     .ent   sql38aVdcomCall
sql38aVdcomCall:
      ldgp  gp, 0($27)
      lda   sp, -framesize(sp)
      stq   ra, ra_disp(sp)
      stq   fp, fp_disp(sp)
      mov   sp, fp
      .mask 0x04008000,-framesize
      .fmask 0x00000000,0
      .frame  fp,framesize,ra
      .prologue 1
      
      subq  sp, a4, sp
      bic   sp, 15, sp           # 16 Byte Align
      mov   a1,pv                # Method Entry Address

      lda   t5, 1                # actual parm num to work on
      mov   a2, t0               # parameter source
      mov   sp, t1               # parameter destination 
      sra   a3, 4, t2            # t2 = num = len / 16
      beq   t2, L$099            # check if there are parameters
L$001:ldq   t7, ste_val(t0)
      ldbu  t3, ste_ptr(t0)      # check if pointer parameter 
      bne   t3, L$002            #
      ldbu  t4, ste_vt(t0)       # get vt type 
      cmpeq t4, vt_lc_int1, t6   # signed int1 ?
      beq   t6, P$I2 
      ldb   t7, ste_val(t0)
      br    L$002                #
P$I2: cmpeq t4, vt_i2, t6        # signed short ?
      beq   t6, P$I4
      ldw   t7, ste_val(t0)
      br    L$002                #
P$I4: cmpeq t4, vt_int, t6       # signed integer ?
      beq   t6, P$I4x
      br    P$I4z   
P$I4x:cmpeq t4, vt_i4, t6        # signed integer ?
      beq   t6, P$UI1
P$I4z:ldl   t7, ste_val(t0)
      br    L$002                #
P$UI1:cmpeq t4, vt_lc_uint1, t6  # unsigned int1 ?
      bne   t6, PSUI1
      cmpeq t4, vt_ui1, t6       # unsigned byte ?
      bne   t6, PSUI1
      cmpeq t4, vt_lc_char, t6
      bne   t6, PSUI1
      cmpeq t4, vt_lc_byte, t6  
      bne   t6, PSUI1
      cmpeq t4, vt_lc_bool, t6  
      beq   t6, P$UI2
PSUI1:ldbu  t7, ste_val(t0)
      br    L$002                #
P$UI2:cmpeq t4, vt_ui2, t6       # unsigned short ?
      bne   t6, PSUI2
      cmpeq t4, vt_lc_wchar, t6  
      beq   t6, P$UI4
PSUI2:ldwu  t7, ste_val(t0)
      br    L$002                #
P$UI4:cmpeq t4, vt_ui4, t6       # unsigned int ?
      beq   t6, PSUI4
      br    PUI
PSUI4:cmpeq t4, vt_uint, t6      # unsigned int ?
      bne   t6, PUI
      br    L$F4
PUI:  ldl   t7, ste_val(t0)      ####### 
L$002:cmpeq t5, 1, t6
      beq   t6, P2
      mov   t7, a1
      br    L$098
P2:   cmpeq t5, 2, t6
      beq   t6, P3
      mov   t7, a2
      br    L$098
P3:   cmpeq t5, 3, t6
      beq   t6, P4
      mov   t7, a3
      br    L$098
P4:   cmpeq t5, 4, t6
      beq   t6, P5
      mov   t7, a4
      br    L$098
P5:   cmpeq t5, 5, t6
      beq   t6, PSTACK
      mov   t7, a5
      br    L$098
PSTACK:
      stq   t7, 0(t1)            # store on stack
      lda   t1, 8(t1)            # increment destination address
L$098:
      lda   t5, 1(t5)            # increment arg counter
      lda   t0, 16(t0)           # increment source address
      subq  t2, 1, t2
      bne   t2, L$001
L$099:  
      jsr	ra, (pv)
      ldgp  gp, 0(ra)            # Branch to Interface Method 

      mov   fp,sp
      ldq   ra, ra_disp(sp)
      ldq   fp, fp_disp(sp)
      lda   sp, framesize(sp)
      ret   $31, (ra), 1

L$F4: cmpeq t4, vt_r4, t6 
      beq   t6, L$F8
      lds   $f10, ste_val(t0) 
      br    L$003
L$F8: cmpeq t4, vt_r8, t6
      beq   t6, L$002            ### Fehler !!!!
      ldt   $f10, ste_val(t0) 
L$003:cmpeq t5, 1, t6
      beq   t6, FP2
      fmov  $f10, $f17
      br    L$098
FP2:  cmpeq t5, 2, t6
      beq   t6, FP3
      fmov  $f10, $f18
      br    L$098
FP3:  cmpeq t5, 3, t6
      beq   t6, FP4
      fmov  $f10, $f19
      br    L$098
FP4:  cmpeq t5, 4, t6
      beq   t6, FP5
      fmov  $f10, $f20
      br    L$098
FP5:  cmpeq t5, 5, t6
      beq   t6, FPSTACK
      fmov  $f10, $f21
      br    L$098
FPSTACK:
      cmpeq t4, vt_r4, t6 
      beq   t6, L$F8x
      sts   $f10, 0(t1)          # store on stack
      lda   t1, 8(t1)            # increment destination address
      br    L$098
L$F8x:
      stt   $f10, 0(t1)          # store on stack
      lda   t1, 8(t1)            # increment destination address
      br    L$098

     .end   sql38aVdcomCall
&endif

&if  $MACH = COMMENT
***************************************************************
*   Solaris-Sparc 32 Bit V8 & 64 Bit V9, Solaris x86/x64   
***************************************************************
&endif
&if $OSSPEC in [ SOLARIS, SVR4 ]
& if $MACH in [ SPARC, SUN ]
     vt_empty          =0
     vt_null           =1
     vt_i2             =2
     vt_i4             =3
     vt_r4             =4
     vt_r8             =5
     vt_cy             =6
     vt_date           =7
     vt_bstr           =8
     vt_dispatch       =9
     vt_error          =10
     vt_bool           =11
     vt_variant        =12
     vt_unknown        =13
     vt_decimal        =14
     vt_i1             =16
     vt_ui1            =17
     vt_ui2            =18
     vt_ui4            =19
     vt_i8             =20
     vt_ui8            =21
     vt_int            =22
     vt_uint           =23
     vt_void           =24
     vt_hresult        =25
     vt_ptr            =26
     vt_safearrary     =27
     vt_carray         =28
     vt_userdefined    =29
     vt_lpstr          =30
     vt_lpwstr         =31
     vt_filetime       =64
     vt_blob           =65
     vt_stream         =66
     vt_storage        =67
     vt_streamed_object=68
     vt_stored_object  =69
     vt_blob_object    =70
     vt_cf             =71
     vt_clsid          =72
     vt_lc_char        =201
     vt_lc_wchar       =202
     vt_lc_byte        =203
     vt_lc_bool        =204
     vt_lc_abap_tab_handle=205
     vt_lc_stream_handle  =206
     vt_lc_int1           =207
     vt_lc_uint1          =209
     vt_vector            =4096
     vt_array             =8192
     vt_byref             =16384

     ste_val            =0
     ste_vt             =8
     ste_io             =10
     ste_ptr            =11
     ste_len            =12

&ifdef BIT64
     V9BIAS64           =2047
     ARGPUSHSIZE        =(6*8)
     MINFRAME           =(16*8)+ARGPUSHSIZE
     PRMS               =V9BIAS64+MINFRAME
     pushsize           =8
&else
     ARGPUSHSIZE        =(6*4)
     MINFRAME           =(16*4)+4
     PRMS               =MINFRAME
     pushsize           =4
&endif

    .section    ".text",#alloc,#execinstr
    .align  8
    .skip   24

    !
    ! Parameters:
    !   %i0 = "this" pointer of "COM"-Object
    !   %i1 = interface pointer
    !   %i2 = address( parameter description area )
    !   %i3 = length ( parameter description area )
    !   %i4 = stack_size
    !
    .global sql38aVdcomCall
    .type   sql38aVdcomCall,2
sql38aVdcomCall:
    add  %o4,MINFRAME+7,%o5 ! parameter-area + space for 
                            ! %i0-%i7 und %l0-%l7 + 7(align)
    and  %o5,-8,%o5         ! align 
    neg  %o5
    save %sp,%o5,%sp        ! Prolog
    sra  %i3,4,%l1          ! %l1 parm-count
    mov  %i2,%l2            ! %l2 actual parm-addr
&ifdef BIT64
    mov  %i0,%o0            ! first Parm = this-pointer
&else
    st   %i0,[%sp+PRMS]
&endif
    subcc %l1,1,%l5         ! decrement + check count
    bl   L_DOCALL           !
    add  %sp,PRMS,%l3       ! pos of first parm on stack
    mov  1,%l6              ! no. of parameter
&ifndef BIT64
    add  %l3,pushsize,%l3
    mov  2,%l0              ! idx for float regs
    mov  2,%l7              ! idx for float regs
&endif
L_NEXTPARM:
    add  %l6,1,%l6          ! increment parm-counter
    ldub [%l2+ste_ptr],%l5  ! get PTR flag
    subcc %l5,0,%l5         ! check if flag is set
    bg   L_REF_PARM         !
    lduh [%l2+ste_vt],%l4   !
    subcc %l4,vt_r4,%l5     ! is type FLOAT ?
    be   L_FLT4
    subcc %l4,vt_r8,%l5     ! is type DOUBLE ?
    be   L_FLT8
&ifdef BIT64
    ldsw [%l2+ste_len],%l4  ! %l4 = length
&else
    ld   [%l2+ste_len],%l4  ! %l4 = length
&endif
    subcc %l4,1,%l5         ! length = 1 ?
    be   L_LEN1
    subcc %l4,2,%l5         ! length = 2 ?
    be   L_LEN2
    subcc %l4,4,%l5         ! length = 4 ?
    be   L_LEN4
    subcc %l4,8,%l5         ! length = 8 ?
    be   L_LEN8
    nop
L_MOVEPARM:
&ifdef BIT64
    subcc %l6,2,%l5
    be   L_P2
    subcc %l6,3,%l5
    be   L_P3
    subcc %l6,4,%l5
    be   L_P4
    subcc %l6,5,%l5
    be   L_P5
    subcc %l6,6,%l5
    be   L_P6
    nop
L_P2:
    ba   L_PARMEND
    mov  %l4,%o1
L_P3:
    ba   L_PARMEND
    mov  %l4,%o2
L_P4:
    ba   L_PARMEND
    mov  %l4,%o3
L_P5:
    ba   L_PARMEND
    mov  %l4,%o4
L_P6:
    mov  %l4,%o5
&endif
L_PARMEND:
    subcc %l1,1,%l1         ! decrement + check count
    bg   L_NEXTPARM
    add  %l2,16,%l2         ! point to next element
L_DOCALL:
&ifndef BIT64
    ld  [%sp+PRMS],%o0
    ld  [%sp+PRMS+4],%o1
    ld  [%sp+PRMS+8],%o2
    ld  [%sp+PRMS+12],%o3
    ld  [%sp+PRMS+16],%o4
    ld  [%sp+PRMS+20],%o5
&endif
    jmpl %i1,%o7
    nop
    mov  %o0,%i0            ! handle returncode
    jmp  %i7+8              ! return
    restore

&ifdef BIT64
L_LEN1:
    subcc %l6,6,%l5         ! check if passed in register
    ble  L_MOVEPARM
    ldub [%l2+ste_val],%l4  ! unsigned byte -> %l4
    stx  %l4,[%l3]          ! store value on stack
    ba   L_PARMEND
    add  %l3,pushsize,%l3

L_LEN2:
    subcc %l6,6,%l5         ! check if passed in register
    ble  L_MOVEPARM
    ldsh [%l2+ste_val],%l4  ! signed short ->  %l4
    stx  %l4,[%l3]          ! store value on stack
    ba   L_PARMEND
    add  %l3,pushsize,%l3

L_LEN4:
    subcc %l6,6,%l5         ! check if passed in register
    ble  L_MOVEPARM
    ldsw [%l2+ste_val],%l4  ! signed word  ->  %l4
    stx  %l4,[%l3]          ! store value on stack
    ba   L_PARMEND
    add  %l3,pushsize,%l3

L_LEN8:
    subcc %l6,6,%l5         ! check if passed in register
    ble  L_MOVEPARM
    ldx  [%l2+ste_val],%l4  ! double word  ->  %l4
    stx  %l4,[%l3]          ! store value on stack
    ba   L_PARMEND
    add  %l3,pushsize,%l3

L_REF_PARM:
    subcc %l6,6,%l5         ! check if passed in register
    ble  L_MOVEPARM
    ldx  [%l2+ste_val],%l4  ! Address  %l4
    stx  %l4,[%l3]          ! store value on stack
    ba   L_PARMEND
    add  %l3,pushsize,%l3


L_FLT4:
    subcc %l6,6,%l5         ! check if passed in register
    ble  L_MOVEFLT 
    ld   [%l2+ste_val],%f1  !
    st   %f1,[%l3+4]        ! store value onto stack
    add  %l3,pushsize,%l3
    ba   L_MOVEFLT
    nop
L_FLT8:
    subcc %l6,6,%l5         ! check if passed in register
    ble  L_MOVEFLT 
    ldd  [%l2+ste_val],%f0  !
    st   %f0,[%l3]          ! store value onto stack
    st   %f1,[%l3+4]        ! 
    add  %l3,(pushsize),%l3
L_MOVEFLT: 
    subcc %l6,2,%l5
    be   L_FP2
    subcc %l6,3,%l5
    be   L_FP3
    subcc %l6,4,%l5
    be   L_FP4
    subcc %l6,5,%l5
    be   L_FP5
    subcc %l6,6,%l5
    be   L_FP6
    subcc %l6,7,%l5
    be   L_FP7
    subcc %l6,8,%l5
    be   L_FP8
    subcc %l6,9,%l5
    be   L_FP9
    subcc %l6,10,%l5
    be   L_FP10
    subcc %l6,11,%l5
    be   L_FP11
    subcc %l6,12,%l5
    be   L_FP12
    subcc %l6,13,%l5
    be   L_FP13
    subcc %l6,14,%l5
    be   L_FP14
    subcc %l6,15,%l5
    be   L_FP15
    subcc %l6,16,%l5
    be   L_FP16
	nop
    ba   L_PARMEND
	nop
L_FP2:
    ba   L_PARMEND
    fmovd %f0,%f2
L_FP3:
    ba   L_PARMEND
    fmovd %f0,%f4
L_FP4:
    ba   L_PARMEND
    fmovd %f0,%f6
L_FP5:
    ba   L_PARMEND
    fmovd %f0,%f8
L_FP6:
    ba   L_PARMEND
    fmovd %f0,%f10
L_FP7:
    ba   L_PARMEND
    fmovd %f0,%f12
L_FP8:
    ba   L_PARMEND
    fmovd %f0,%f14
L_FP9:
    ba   L_PARMEND
    fmovd %f0,%f16
L_FP10:
    ba   L_PARMEND
    fmovd %f0,%f18
L_FP11:
    ba   L_PARMEND
    fmovd %f0,%f20
L_FP12:
    ba   L_PARMEND
    fmovd %f0,%f22
L_FP13:
    ba   L_PARMEND
    fmovd %f0,%f24
L_FP14:
    ba   L_PARMEND
    fmovd %f0,%f26
L_FP15:
    ba   L_PARMEND
    fmovd %f0,%f28
L_FP16:
    ba   L_PARMEND
    fmovd %f0,%f30

&else
L_FLT8:
    ldd  [%l2+ste_val],%f0  !
    st   %f0,[%l3]          ! store value onto stack
    st   %f1,[%l3+4]        ! store value onto stack
    add  %l6,1,%l6
    subcc %l7,30,%l5        ! check if passed in register
    bg   L_PARMEND
    add  %l3,(2*pushsize),%l3

    subcc %l7,2,%l5
    be   L_FPD2
    subcc %l7,4,%l5
    be   L_FPD4
    subcc %l7,6,%l5
    be   L_FPD6
    subcc %l7,8,%l5
    be   L_FPD8
    subcc %l7,10,%l5
    be   L_FPD10
    subcc %l7,11,%l5
    be   L_FPD12
    subcc %l7,13,%l5
    be   L_FPD14
    subcc %l7,15,%l5
    be   L_FPD16
    subcc %l7,17,%l5
    be   L_FPD18
    subcc %l7,19,%l5
    be   L_FPD20
    subcc %l7,21,%l5
    be   L_FPD22
    subcc %l7,23,%l5
    be   L_FPD24
    subcc %l7,25,%l5
    be   L_FPD26
    subcc %l7,27,%l5
    be   L_FPD28
    subcc %l7,29,%l5
    be   L_FPD30
    ba   L_PARMEND
	nop
L_FPD2:
    ba   L_DOUBLEEND
    fmovd %f0,%f2
L_FPD4:
    ba   L_DOUBLEEND
    fmovd %f0,%f4
L_FPD6:
    ba   L_DOUBLEEND
    fmovd %f0,%f6
L_FPD8:
    ba   L_DOUBLEEND
    fmovd %f0,%f8
L_FPD10:
    ba   L_DOUBLEEND
    fmovd %f0,%f10
L_FPD12:
    ba   L_DOUBLEEND
    fmovd %f0,%f12
L_FPD14:
    ba   L_DOUBLEEND
    fmovd %f0,%f14
L_FPD16:
    ba   L_DOUBLEEND
    fmovd %f0,%f16
L_FPD18:
    ba   L_DOUBLEEND
    fmovd %f0,%f18
L_FPD20:
    ba   L_DOUBLEEND
    fmovd %f0,%f20
L_FPD22:
    ba   L_DOUBLEEND
    fmovd %f0,%f22
L_FPD24:
    ba   L_DOUBLEEND
    fmovd %f0,%f24
L_FPD26:
    ba   L_DOUBLEEND
    fmovd %f0,%f26
L_FPD28:
    ba   L_DOUBLEEND
    fmovd %f0,%f28
L_FPD30:
    ba   L_DOUBLEEND
    fmovd %f0,%f30
L_DOUBLEEND:
	subcc %l0,%l7,%l5
    bne	  L_PARMEND
	add   %l7,2,%l7
	ba    L_PARMEND
	mov   %l7,%l0

L_FLT4:
    ld   [%l2+ste_val],%f1  !
    st   %f1,[%l3]          ! store value onto stack
    subcc %l0,31,%l5        ! check if passed in register
    bg   L_PARMEND
    add  %l3,pushsize,%l3
    subcc %l0,2,%l5
    be   L_FP2
    subcc %l0,3,%l5
    be   L_FP3
    subcc %l0,4,%l5
    be   L_FP4
    subcc %l0,5,%l5
    be   L_FP5
    subcc %l0,6,%l5
    be   L_FP6
    subcc %l0,7,%l5
    be   L_FP7
    subcc %l0,8,%l5
    be   L_FP8
    subcc %l0,9,%l5
    be   L_FP9
    subcc %l0,10,%l5
    be   L_FP10
    subcc %l0,11,%l5
    be   L_FP11
    subcc %l0,12,%l5
    be   L_FP12
    subcc %l0,13,%l5
    be   L_FP13
    subcc %l0,14,%l5
    be   L_FP14
    subcc %l0,15,%l5
    be   L_FP15
    subcc %l0,16,%l5
    be   L_FP16
    subcc %l0,17,%l5
    be   L_FP17
    subcc %l0,18,%l5
    be   L_FP18
    subcc %l0,19,%l5
    be   L_FP19
    subcc %l0,20,%l5
    be   L_FP20
    subcc %l0,21,%l5
    be   L_FP21
    subcc %l0,32,%l5
    be   L_FP22
    subcc %l0,23,%l5
    be   L_FP23
    subcc %l0,24,%l5
    be   L_FP24
    subcc %l0,25,%l5
    be   L_FP25
    subcc %l0,26,%l5
    be   L_FP26
    subcc %l0,27,%l5
    be   L_FP27
    subcc %l0,28,%l5
    be   L_FP28
    subcc %l0,29,%l5
    be   L_FP29
    subcc %l0,30,%l5
    be   L_FP30
    subcc %l0,31,%l5
    be   L_FP31
	nop
    ba   L_PARMEND
	nop
L_FP2:
    ba   L_FLOATEND
    fmovs %f1,%f2
L_FP3:
    ba   L_FLOATEND
    fmovs %f1,%f3
L_FP4:
    ba   L_FLOATEND
    fmovs %f1,%f4
L_FP5:
    ba   L_FLOATEND
    fmovs %f1,%f5
L_FP6:
    ba   L_FLOATEND
    fmovs %f1,%f6
L_FP7:
    ba   L_FLOATEND
    fmovs %f1,%f7
L_FP8:
    ba   L_FLOATEND
    fmovs %f1,%f8
L_FP9:
    ba   L_FLOATEND
    fmovs %f1,%f9
L_FP10:
    ba   L_FLOATEND
    fmovs %f1,%f10
L_FP11:
    ba   L_FLOATEND
    fmovs %f1,%f11
L_FP12:
    ba   L_FLOATEND
    fmovs %f1,%f12
L_FP13:
    ba   L_FLOATEND
    fmovs %f1,%f13
L_FP14:
    ba   L_FLOATEND
    fmovs %f1,%f14
L_FP15:
    ba   L_FLOATEND
    fmovs %f1,%f15
L_FP16:
    ba   L_FLOATEND
    fmovs %f1,%f16
L_FP17:
    ba   L_FLOATEND
    fmovs %f1,%f17
L_FP18:
    ba   L_FLOATEND
    fmovs %f1,%f18
L_FP19:
    ba   L_FLOATEND
    fmovs %f1,%f19
L_FP20:
    ba   L_FLOATEND
    fmovs %f1,%f20
L_FP21:
    ba   L_FLOATEND
    fmovs %f1,%f21
L_FP22:
    ba   L_FLOATEND
    fmovs %f1,%f22
L_FP23:
    ba   L_FLOATEND
    fmovs %f1,%f23
L_FP24:
    ba   L_FLOATEND
    fmovs %f1,%f24
L_FP25:
    ba   L_FLOATEND
    fmovs %f1,%f25
L_FP26:
    ba   L_FLOATEND
    fmovs %f1,%f26
L_FP27:
    ba   L_FLOATEND
    fmovs %f1,%f27
L_FP28:
    ba   L_FLOATEND
    fmovs %f1,%f28
L_FP29:
    ba   L_FLOATEND
    fmovs %f1,%f29
L_FP30:
    ba   L_FLOATEND
    fmovs %f1,%f30
L_FP31:
    fmovs %f1,%f31
L_FLOATEND:
	add   %l0,1,%l0
	subcc %l0,%l7,%l5
	be    L_PARMEND
	nop
    bg    L_FLOATEND1
	nop
	and   %l0,-2,%l5
	subcc %l0,%l5,%l5
	bne   L_PARMEND
    nop
	ba    L_PARMEND
	mov   %l7,%l0
L_FLOATEND1:
	ba    L_PARMEND
    add   %l7,2,%l7

L_LEN1:
    ldub [%l2+ste_val],%l4  ! unsigned byte -> %l4
    st   %l4,[%l3]          ! store value on stack
    ba   L_PARMEND
    add  %l3,pushsize,%l3

L_LEN2:
    ldsh [%l2+ste_val],%l4  ! signed short ->  %l4
    st   %l4,[%l3]          ! store value on stack
    ba   L_PARMEND
    add  %l3,pushsize,%l3

L_LEN4:
    ld   [%l2+ste_val],%l4  ! signed word  ->  %l4
    st   %l4,[%l3]          ! store value on stack
    ba   L_PARMEND
    add  %l3,pushsize,%l3

L_LEN8:
    ld   [%l2+ste_val],%l4  ! 1. word  ->  %l4
    st   %l4,[%l3]          ! store value on stack
    add  %l3,pushsize,%l3
    subcc %l6,2,%l5
    be   L8_P2
    subcc %l6,3,%l5
    be   L8_P3
    subcc %l6,4,%l5
    be   L8_P4
    subcc %l6,5,%l5
    be   L8_P5
    subcc %l6,6,%l5
    be   L8_P6
    nop
    ba   L_2NDWORD
    nop
L8_P2:
    ba   L_2NDWORD
    mov  %l4,%o1
L8_P3:
    ba   L_2NDWORD
    mov  %l4,%o2
L8_P4:
    ba   L_2NDWORD
    mov  %l4,%o3
L8_P5:
    ba   L_2NDWORD
    mov  %l4,%o4
L8_P6:
    mov  %l4,%o5
L_2NDWORD:
    add  %l6,1,%l6
    ld   [%l2+ste_val+4],%l4! 2. word  ->  %l4
    st   %l4,[%l3+4]        ! store value on stack
    ba   L_PARMEND
    add  %l3,pushsize,%l3

L_REF_PARM:
    ld   [%l2+ste_val],%l4  ! Address  %l4
    st   %l4,[%l3]          ! store value on stack
    ba   L_PARMEND
    add  %l3,pushsize,%l3
&endif
    
    .size   sql38aVdcomCall,(.-sql38aVdcomCall)
    .align  8
    .align  8
    .skip   24

& elif $MACH == X86_64
	.section	.text,"ax"
	.align	4

	.globl	sql38aVdcomCall
	.type	sql38aVdcomCall,@function
	.align	16
sql38aVdcomCall:
.L_y1:
	pushq	%rbp
.L_y2:
	movq	%rsp,%rbp
.L_y3:
	subq	$160,%rsp
	movq	%rbx,-128(%rbp)
	movq	%r12,-136(%rbp)
	movq	%r13,-144(%rbp)
	movq	%r14,-152(%rbp)
	movq	%r15,-160(%rbp)
.L_y4:
	movq	%rdi, -8(%rbp)
	movq	%rsi, -16(%rbp)
	movq	%rdx, -24(%rbp)
	movq	%rcx, -32(%rbp)
	movq	%r8, -40(%rbp)
.L14:

/ File ven38c.c:
/ Line 181
	movq	-32(%rbp), %r8
	movq	%r8, -80(%rbp)
/ Line 182
	movq	-80(%rbp), %r8
	sarq	$4, %r8
	movq	%r8, -80(%rbp)
/ Line 185
	movl	$0, -120(%rbp)
	movl	$0, -116(%rbp)
	movq	-120(%rbp), %r8
	movq	%r8, -56(%rbp)
	movl	$0, -120(%rbp)
	movl	$0, -116(%rbp)
	movq	-120(%rbp), %r8
	movq	%r8, -64(%rbp)
	movq	-64(%rbp), %r8
	addq	-56(%rbp), %r8
	cmpq	-80(%rbp),%r8
	jge	.L18
.L19:
.L16:
/ Line 186
	movq	-56(%rbp), %r8
	shlq	$4, %r8
	movq	%r8, %r9
	addq	-24(%rbp), %r9
	movq	-64(%rbp), %r8
	shlq	$4, %r8
	addq	%r9, %r8
	movq	%r8, -96(%rbp)
/ Line 189
	movq	-96(%rbp), %r8
	movsbl	11(%r8), %eax
	cmpl	$0,%eax
	jne	.L20
.L21:
	movq	-96(%rbp), %r8
	movswl	8(%r8), %eax
	cmpl	$4,%eax
	je	.L22
.L23:
	movq	-96(%rbp), %r8
	movswl	8(%r8), %eax
	cmpl	$5,%eax
	jne	.L20
.L24:
.L22:
/ Line 190
	movq	-64(%rbp), %r8
	leaq	1(%r8), %r8
	movq	%r8, -64(%rbp)
	jmp	.L25
	.align	4
.L20:
/ Line 192
	movq	-56(%rbp), %r8
	leaq	1(%r8), %r8
	movq	%r8, -56(%rbp)
.L25:
/ Line 185
	movq	-64(%rbp), %r8
	addq	-56(%rbp), %r8
	cmpq	-80(%rbp),%r8
	jl	.L16
.L26:
.L18:
/ Line 196
	movl	$0, -120(%rbp)
	movl	$0, -116(%rbp)
	movq	-120(%rbp), %r8
	movq	%r8, -72(%rbp)
/ Line 197
	movq	-56(%rbp), %r8
	cmpq	$5,%r8
	jle	.L27
.L28:
/ Line 198
	movq	-56(%rbp), %r8
	leaq	-5(%r8), %r8
	addq	-72(%rbp), %r8
	movq	%r8, -72(%rbp)
.L27:
/ Line 200
	movq	-64(%rbp), %r8
	cmpq	$8,%r8
	jle	.L29
.L30:
/ Line 201
	movq	-64(%rbp), %r8
	leaq	-8(%r8), %r8
	addq	-72(%rbp), %r8
	movq	%r8, -72(%rbp)
.L29:
/ Line 203
	movq	-72(%rbp), %r8
	andq	$1, %r8
	cmpq	$0,%r8
	je	.L31
.L32:
/ASM
	subq	$8, %rsp
/ASMEND
.L31:
/ Line 206
	movq	-64(%rbp), %r8
	cmpq	$8,%r8
	jle	.L33
.L34:
/ Line 207
	movq	$8, %r8
	movq	%r8, -72(%rbp)
	jmp	.L35
	.align	4
.L33:
/ Line 209
	movq	-64(%rbp), %r8
	movq	%r8, -72(%rbp)
.L35:
/ Line 212
	movq	-56(%rbp), %r11
	orq	-64(%rbp), %r11
	cmpq	$0,%r11
	je	.L38
.L39:
.L36:
/ Line 213
	movq	-56(%rbp), %r11
	shlq	$4, %r11
	movq	%r11, %rax
	addq	-24(%rbp), %rax
	movq	-64(%rbp), %r11
	shlq	$4, %r11
	addq	%rax, %r11
	leaq	-16(%r11), %r11
	movq	%r11, -96(%rbp)
/ Line 214
	movq	-96(%rbp), %r11
	movswl	8(%r11), %eax
	movl	%eax,%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -88(%rbp)
/ Line 216
	movq	-96(%rbp), %r11
	movsbl	11(%r11), %eax
	cmpl	$0,%eax
	je	.L40
.L41:
/ Line 217
	movq	-56(%rbp), %r11
	leaq	-1(%r11), %r11
	movq	%r11, -56(%rbp)
/ Line 218
	movq	-56(%rbp), %r11
	cmpq	$0,%r11
	jne	.L42
.L43:
	movq	-96(%rbp), %r11
	movq	0(%r11), %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rsi
/ASMEND
	jmp	.L44
	.align	4
.L42:
	movq	-56(%rbp), %r11
	cmpq	$1,%r11
	jne	.L45
.L46:
	movq	-96(%rbp), %r11
	movq	0(%r11), %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rdx
/ASMEND
	jmp	.L47
	.align	4
.L45:
	movq	-56(%rbp), %r11
	cmpq	$2,%r11
	jne	.L48
.L49:
	movq	-96(%rbp), %r11
	movq	0(%r11), %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rcx
/ASMEND
	jmp	.L50
	.align	4
.L48:
	movq	-56(%rbp), %r11
	cmpq	$3,%r11
	jne	.L51
.L52:
	movq	-96(%rbp), %r11
	movq	0(%r11), %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %r8
/ASMEND
	jmp	.L53
	.align	4
.L51:
	movq	-56(%rbp), %r11
	cmpq	$4,%r11
	jne	.L54
.L55:
	movq	-96(%rbp), %r11
	movq	0(%r11), %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %r9
/ASMEND
	jmp	.L56
	.align	4
.L54:
	movq	-96(%rbp), %r11
	movq	0(%r11), %r11
	movq	%r11, -104(%rbp)
/ASM
	pushq	%r11
/ASMEND
.L56:
.L53:
.L50:
.L47:
.L44:
	jmp	.L57
	.align	4
.L40:
/ Line 219
	movq	-88(%rbp), %r11
	cmpq	$16,%r11
	je	.L59
.L60:
	movq	-88(%rbp), %r11
	cmpq	$207,%r11
	jne	.L58
.L61:
.L59:
/ Line 220
	movq	-56(%rbp), %r11
	leaq	-1(%r11), %r11
	movq	%r11, -56(%rbp)
/ Line 221
	movq	-56(%rbp), %r11
	cmpq	$0,%r11
	jne	.L62
.L63:
	movq	-96(%rbp), %r11
	movsbl	0(%r11), %eax
	movl	%eax,%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rsi
/ASMEND
	jmp	.L64
	.align	4
.L62:
	movq	-56(%rbp), %r11
	cmpq	$1,%r11
	jne	.L65
.L66:
	movq	-96(%rbp), %r11
	movsbl	0(%r11), %eax
	movl	%eax,%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rdx
/ASMEND
	jmp	.L67
	.align	4
.L65:
	movq	-56(%rbp), %r11
	cmpq	$2,%r11
	jne	.L68
.L69:
	movq	-96(%rbp), %r11
	movsbl	0(%r11), %eax
	movl	%eax,%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rcx
/ASMEND
	jmp	.L70
	.align	4
.L68:
	movq	-56(%rbp), %r11
	cmpq	$3,%r11
	jne	.L71
.L72:
	movq	-96(%rbp), %r11
	movsbl	0(%r11), %eax
	movl	%eax,%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %r8
/ASMEND
	jmp	.L73
	.align	4
.L71:
	movq	-56(%rbp), %r11
	cmpq	$4,%r11
	jne	.L74
.L75:
	movq	-96(%rbp), %r11
	movsbl	0(%r11), %eax
	movl	%eax,%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %r9
/ASMEND
	jmp	.L76
	.align	4
.L74:
	movq	-96(%rbp), %r11
	movsbl	0(%r11), %eax
	movl	%eax,%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	pushq	%r11
/ASMEND
.L76:
.L73:
.L70:
.L67:
.L64:
	jmp	.L77
	.align	4
.L58:
/ Line 223
	movq	-88(%rbp), %r11
	cmpq	$17,%r11
	je	.L79
.L80:
	movq	-88(%rbp), %r11
	cmpq	$209,%r11
	je	.L79
.L81:
	movq	-88(%rbp), %r11
	cmpq	$201,%r11
	je	.L79
.L82:
	movq	-88(%rbp), %r11
	cmpq	$11,%r11
	jne	.L78
.L83:
.L79:
/ Line 224
	movq	-56(%rbp), %r11
	leaq	-1(%r11), %r11
	movq	%r11, -56(%rbp)
/ Line 225
	movq	-56(%rbp), %r11
	cmpq	$0,%r11
	jne	.L84
.L85:
	movq	-96(%rbp), %r11
	movzbl	0(%r11), %eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rsi
/ASMEND
	jmp	.L86
	.align	4
.L84:
	movq	-56(%rbp), %r11
	cmpq	$1,%r11
	jne	.L87
.L88:
	movq	-96(%rbp), %r11
	movzbl	0(%r11), %eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rdx
/ASMEND
	jmp	.L89
	.align	4
.L87:
	movq	-56(%rbp), %r11
	cmpq	$2,%r11
	jne	.L90
.L91:
	movq	-96(%rbp), %r11
	movzbl	0(%r11), %eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rcx
/ASMEND
	jmp	.L92
	.align	4
.L90:
	movq	-56(%rbp), %r11
	cmpq	$3,%r11
	jne	.L93
.L94:
	movq	-96(%rbp), %r11
	movzbl	0(%r11), %eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %r8
/ASMEND
	jmp	.L95
	.align	4
.L93:
	movq	-56(%rbp), %r11
	cmpq	$4,%r11
	jne	.L96
.L97:
	movq	-96(%rbp), %r11
	movzbl	0(%r11), %eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %r9
/ASMEND
	jmp	.L98
	.align	4
.L96:
	movq	-96(%rbp), %r11
	movzbl	0(%r11), %eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	pushq	%r11
/ASMEND
.L98:
.L95:
.L92:
.L89:
.L86:
	jmp	.L99
	.align	4
.L78:
/ Line 226
	movq	-88(%rbp), %r11
	cmpq	$2,%r11
	jne	.L100
.L101:
/ Line 227
	movq	-56(%rbp), %r11
	leaq	-1(%r11), %r11
	movq	%r11, -56(%rbp)
/ Line 228
	movq	-56(%rbp), %r11
	cmpq	$0,%r11
	jne	.L102
.L103:
	movq	-96(%rbp), %r11
	movswl	0(%r11), %eax
	movl	%eax,%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rsi
/ASMEND
	jmp	.L104
	.align	4
.L102:
	movq	-56(%rbp), %r11
	cmpq	$1,%r11
	jne	.L105
.L106:
	movq	-96(%rbp), %r11
	movswl	0(%r11), %eax
	movl	%eax,%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rdx
/ASMEND
	jmp	.L107
	.align	4
.L105:
	movq	-56(%rbp), %r11
	cmpq	$2,%r11
	jne	.L108
.L109:
	movq	-96(%rbp), %r11
	movswl	0(%r11), %eax
	movl	%eax,%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rcx
/ASMEND
	jmp	.L110
	.align	4
.L108:
	movq	-56(%rbp), %r11
	cmpq	$3,%r11
	jne	.L111
.L112:
	movq	-96(%rbp), %r11
	movswl	0(%r11), %eax
	movl	%eax,%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %r8
/ASMEND
	jmp	.L113
	.align	4
.L111:
	movq	-56(%rbp), %r11
	cmpq	$4,%r11
	jne	.L114
.L115:
	movq	-96(%rbp), %r11
	movswl	0(%r11), %eax
	movl	%eax,%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %r9
/ASMEND
	jmp	.L116
	.align	4
.L114:
	movq	-96(%rbp), %r11
	movswl	0(%r11), %eax
	movl	%eax,%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	pushq	%r11
/ASMEND
.L116:
.L113:
.L110:
.L107:
.L104:
	jmp	.L117
	.align	4
.L100:
/ Line 229
	movq	-88(%rbp), %r11
	cmpq	$18,%r11
	je	.L119
.L120:
	movq	-88(%rbp), %r11
	cmpq	$202,%r11
	jne	.L118
.L121:
.L119:
/ Line 230
	movq	-56(%rbp), %r11
	leaq	-1(%r11), %r11
	movq	%r11, -56(%rbp)
/ Line 231
	movq	-56(%rbp), %r11
	cmpq	$0,%r11
	jne	.L122
.L123:
	movq	-96(%rbp), %r11
	movzwl	0(%r11), %eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rsi
/ASMEND
	jmp	.L124
	.align	4
.L122:
	movq	-56(%rbp), %r11
	cmpq	$1,%r11
	jne	.L125
.L126:
	movq	-96(%rbp), %r11
	movzwl	0(%r11), %eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rdx
/ASMEND
	jmp	.L127
	.align	4
.L125:
	movq	-56(%rbp), %r11
	cmpq	$2,%r11
	jne	.L128
.L129:
	movq	-96(%rbp), %r11
	movzwl	0(%r11), %eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rcx
/ASMEND
	jmp	.L130
	.align	4
.L128:
	movq	-56(%rbp), %r11
	cmpq	$3,%r11
	jne	.L131
.L132:
	movq	-96(%rbp), %r11
	movzwl	0(%r11), %eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %r8
/ASMEND
	jmp	.L133
	.align	4
.L131:
	movq	-56(%rbp), %r11
	cmpq	$4,%r11
	jne	.L134
.L135:
	movq	-96(%rbp), %r11
	movzwl	0(%r11), %eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %r9
/ASMEND
	jmp	.L136
	.align	4
.L134:
	movq	-96(%rbp), %r11
	movzwl	0(%r11), %eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	pushq	%r11
/ASMEND
.L136:
.L133:
.L130:
.L127:
.L124:
	jmp	.L137
	.align	4
.L118:
/ Line 232
	movq	-88(%rbp), %r11
	cmpq	$3,%r11
	je	.L139
.L140:
	movq	-88(%rbp), %r11
	cmpq	$22,%r11
	jne	.L138
.L141:
.L139:
/ Line 233
	movq	-56(%rbp), %r11
	leaq	-1(%r11), %r11
	movq	%r11, -56(%rbp)
/ Line 234
	movq	-56(%rbp), %r11
	cmpq	$0,%r11
	jne	.L142
.L143:
	movq	-96(%rbp), %r11
	movl	0(%r11),%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rsi
/ASMEND
	jmp	.L144
	.align	4
.L142:
	movq	-56(%rbp), %r11
	cmpq	$1,%r11
	jne	.L145
.L146:
	movq	-96(%rbp), %r11
	movl	0(%r11),%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rdx
/ASMEND
	jmp	.L147
	.align	4
.L145:
	movq	-56(%rbp), %r11
	cmpq	$2,%r11
	jne	.L148
.L149:
	movq	-96(%rbp), %r11
	movl	0(%r11),%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rcx
/ASMEND
	jmp	.L150
	.align	4
.L148:
	movq	-56(%rbp), %r11
	cmpq	$3,%r11
	jne	.L151
.L152:
	movq	-96(%rbp), %r11
	movl	0(%r11),%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %r8
/ASMEND
	jmp	.L153
	.align	4
.L151:
	movq	-56(%rbp), %r11
	cmpq	$4,%r11
	jne	.L154
.L155:
	movq	-96(%rbp), %r11
	movl	0(%r11),%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %r9
/ASMEND
	jmp	.L156
	.align	4
.L154:
	movq	-96(%rbp), %r11
	movl	0(%r11),%eax
	cltq
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	pushq	%r11
/ASMEND
.L156:
.L153:
.L150:
.L147:
.L144:
	jmp	.L157
	.align	4
.L138:
/ Line 235
	movq	-88(%rbp), %r11
	cmpq	$19,%r11
	je	.L159
.L160:
	movq	-88(%rbp), %r11
	cmpq	$23,%r11
	jne	.L158
.L161:
.L159:
/ Line 236
	movq	-56(%rbp), %r11
	leaq	-1(%r11), %r11
	movq	%r11, -56(%rbp)
/ Line 237
	movq	-56(%rbp), %r11
	cmpq	$0,%r11
	jne	.L162
.L163:
	movq	-96(%rbp), %r11
	movl	0(%r11),%eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rsi
/ASMEND
	jmp	.L164
	.align	4
.L162:
	movq	-56(%rbp), %r11
	cmpq	$1,%r11
	jne	.L165
.L166:
	movq	-96(%rbp), %r11
	movl	0(%r11),%eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rdx
/ASMEND
	jmp	.L167
	.align	4
.L165:
	movq	-56(%rbp), %r11
	cmpq	$2,%r11
	jne	.L168
.L169:
	movq	-96(%rbp), %r11
	movl	0(%r11),%eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rcx
/ASMEND
	jmp	.L170
	.align	4
.L168:
	movq	-56(%rbp), %r11
	cmpq	$3,%r11
	jne	.L171
.L172:
	movq	-96(%rbp), %r11
	movl	0(%r11),%eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %r8
/ASMEND
	jmp	.L173
	.align	4
.L171:
	movq	-56(%rbp), %r11
	cmpq	$4,%r11
	jne	.L174
.L175:
	movq	-96(%rbp), %r11
	movl	0(%r11),%eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %r9
/ASMEND
	jmp	.L176
	.align	4
.L174:
	movq	-96(%rbp), %r11
	movl	0(%r11),%eax
	movq	%rax, %r11
	movq	%r11, -104(%rbp)
/ASM
	pushq	%r11
/ASMEND
.L176:
.L173:
.L170:
.L167:
.L164:
	jmp	.L177
	.align	4
.L158:
/ Line 238
	movq	-88(%rbp), %r11
	cmpq	$4,%r11
	jne	.L178
.L179:
/ Line 239
	movq	-64(%rbp), %r11
	leaq	-1(%r11), %r11
	movq	%r11, -64(%rbp)
/ Line 240
	movq	-64(%rbp), %r11
	cmpq	$0,%r11
	jne	.L180
.L181:
	movq	-96(%rbp), %r11
	cvtss2sd	0(%r11),%xmm0
	jmp	.L182
	.align	4
.L180:
	movq	-64(%rbp), %r11
	cmpq	$1,%r11
	jne	.L183
.L184:
	movq	-96(%rbp), %r11
	cvtss2sd	0(%r11),%xmm1
	jmp	.L185
	.align	4
.L183:
	movq	-64(%rbp), %r11
	cmpq	$2,%r11
	jne	.L186
.L187:
	movq	-96(%rbp), %r11
	cvtss2sd	0(%r11),%xmm2
	jmp	.L188
	.align	4
.L186:
	movq	-64(%rbp), %r11
	cmpq	$3,%r11
	jne	.L189
.L190:
	movq	-96(%rbp), %r11
	cvtss2sd	0(%r11),%xmm3
	jmp	.L191
	.align	4
.L189:
	movq	-64(%rbp), %r11
	cmpq	$4,%r11
	jne	.L192
.L193:
	movq	-96(%rbp), %r11
	cvtss2sd	0(%r11),%xmm4
	jmp	.L194
	.align	4
.L192:
	movq	-64(%rbp), %r11
	cmpq	$5,%r11
	jne	.L195
.L196:
	movq	-96(%rbp), %r11
	cvtss2sd	0(%r11),%xmm5
	jmp	.L197
	.align	4
.L195:
	movq	-64(%rbp), %r11
	cmpq	$6,%r11
	jne	.L198
.L199:
	movq	-96(%rbp), %r11
	cvtss2sd	0(%r11),%xmm6
	jmp	.L200
	.align	4
.L198:
	movq	-64(%rbp), %r11
	cmpq	$7,%r11
	jne	.L201
.L202:
	movq	-96(%rbp), %r11
	cvtss2sd	0(%r11),%xmm7
	jmp	.L203
	.align	4
.L201:
	movq	-96(%rbp), %r11
	cvtss2sd	0(%r11),%xmm0
/ASM
	subq	$8, %rsp
	movsd	%xmm0, 0(%rsp)
/ASMEND
.L203:
.L200:
.L197:
.L194:
.L191:
.L188:
.L185:
.L182:
	jmp	.L204
	.align	4
.L178:
/ Line 241
	movq	-88(%rbp), %r11
	cmpq	$5,%r11
	jne	.L205
.L206:
/ Line 242
	movq	-64(%rbp), %r11
	leaq	-1(%r11), %r11
	movq	%r11, -64(%rbp)
/ Line 243
	movq	-64(%rbp), %r11
	cmpq	$0,%r11
	jne	.L207
.L208:
	movq	-96(%rbp), %r11
	movl	0(%r11), %eax
	movl	%eax, -112(%rbp)
	movl	4(%r11), %eax
	movl	%eax, -108(%rbp)
/ASM
	movsd	-112(%rbp), %xmm0
/ASMEND
	jmp	.L209
	.align	4
.L207:
	movq	-64(%rbp), %r11
	cmpq	$1,%r11
	jne	.L210
.L211:
	movq	-96(%rbp), %r11
	movl	0(%r11), %eax
	movl	%eax, -112(%rbp)
	movl	4(%r11), %eax
	movl	%eax, -108(%rbp)
/ASM
	movsd	-112(%rbp), %xmm1
/ASMEND
	jmp	.L212
	.align	4
.L210:
	movq	-64(%rbp), %r11
	cmpq	$2,%r11
	jne	.L213
.L214:
	movq	-96(%rbp), %r11
	movl	0(%r11), %eax
	movl	%eax, -112(%rbp)
	movl	4(%r11), %eax
	movl	%eax, -108(%rbp)
/ASM
	movsd	-112(%rbp), %xmm2
/ASMEND
	jmp	.L215
	.align	4
.L213:
	movq	-64(%rbp), %r11
	cmpq	$3,%r11
	jne	.L216
.L217:
	movq	-96(%rbp), %r11
	movl	0(%r11), %eax
	movl	%eax, -112(%rbp)
	movl	4(%r11), %eax
	movl	%eax, -108(%rbp)
/ASM
	movsd	-112(%rbp), %xmm3
/ASMEND
	jmp	.L218
	.align	4
.L216:
	movq	-64(%rbp), %r11
	cmpq	$4,%r11
	jne	.L219
.L220:
	movq	-96(%rbp), %r11
	movl	0(%r11), %eax
	movl	%eax, -112(%rbp)
	movl	4(%r11), %eax
	movl	%eax, -108(%rbp)
/ASM
	movsd	-112(%rbp), %xmm4
/ASMEND
	jmp	.L221
	.align	4
.L219:
	movq	-64(%rbp), %r11
	cmpq	$5,%r11
	jne	.L222
.L223:
	movq	-96(%rbp), %r11
	movl	0(%r11), %eax
	movl	%eax, -112(%rbp)
	movl	4(%r11), %eax
	movl	%eax, -108(%rbp)
/ASM
	movsd	-112(%rbp), %xmm5
/ASMEND
	jmp	.L224
	.align	4
.L222:
	movq	-64(%rbp), %r11
	cmpq	$6,%r11
	jne	.L225
.L226:
	movq	-96(%rbp), %r11
	movl	0(%r11), %eax
	movl	%eax, -112(%rbp)
	movl	4(%r11), %eax
	movl	%eax, -108(%rbp)
/ASM
	movsd	-112(%rbp), %xmm6
/ASMEND
	jmp	.L227
	.align	4
.L225:
	movq	-64(%rbp), %r11
	cmpq	$7,%r11
	jne	.L228
.L229:
	movq	-96(%rbp), %r11
	movl	0(%r11), %eax
	movl	%eax, -112(%rbp)
	movl	4(%r11), %eax
	movl	%eax, -108(%rbp)
/ASM
	movsd	-112(%rbp), %xmm7
/ASMEND
	jmp	.L230
	.align	4
.L228:
	movq	-96(%rbp), %r11
	movl	0(%r11), %eax
	movl	%eax, -112(%rbp)
	movl	4(%r11), %eax
	movl	%eax, -108(%rbp)
/ASM
	movq	-112(%rbp), %rax
	subq	$8, %rsp
	movq	%rax, 0(%rsp)
/ASMEND
.L230:
.L227:
.L224:
.L221:
.L218:
.L215:
.L212:
.L209:
	jmp	.L231
	.align	4
.L205:
/ Line 245
	movq	-56(%rbp), %r11
	leaq	-1(%r11), %r11
	movq	%r11, -56(%rbp)
/ Line 246
	movq	-56(%rbp), %r11
	cmpq	$0,%r11
	jne	.L232
.L233:
	movq	-96(%rbp), %r11
	movq	0(%r11), %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rsi
/ASMEND
	jmp	.L234
	.align	4
.L232:
	movq	-56(%rbp), %r11
	cmpq	$1,%r11
	jne	.L235
.L236:
	movq	-96(%rbp), %r11
	movq	0(%r11), %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rdx
/ASMEND
	jmp	.L237
	.align	4
.L235:
	movq	-56(%rbp), %r11
	cmpq	$2,%r11
	jne	.L238
.L239:
	movq	-96(%rbp), %r11
	movq	0(%r11), %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %rcx
/ASMEND
	jmp	.L240
	.align	4
.L238:
	movq	-56(%rbp), %r11
	cmpq	$3,%r11
	jne	.L241
.L242:
	movq	-96(%rbp), %r11
	movq	0(%r11), %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %r8
/ASMEND
	jmp	.L243
	.align	4
.L241:
	movq	-56(%rbp), %r11
	cmpq	$4,%r11
	jne	.L244
.L245:
	movq	-96(%rbp), %r11
	movq	0(%r11), %r11
	movq	%r11, -104(%rbp)
/ASM
	movq	%r11, %r9
/ASMEND
	jmp	.L246
	.align	4
.L244:
	movq	-96(%rbp), %r11
	movq	0(%r11), %r11
	movq	%r11, -104(%rbp)
/ASM
	pushq	%r11
/ASMEND
.L246:
.L243:
.L240:
.L237:
.L234:
.L231:
.L204:
.L177:
.L157:
.L137:
.L117:
.L99:
.L77:
.L57:
/ Line 212
	movq	-56(%rbp), %r11
	orq	-64(%rbp), %r11
	cmpq	$0,%r11
	jne	.L36
.L247:
.L38:
/ Line 250
	movq	-8(%rbp), %rdi
	movq	-72(%rbp), %rax
	movq	-16(%rbp), %r11
	call	*%r11
	movq	%rax, %r8
	movq	%r8, -48(%rbp)
	jmp	.L13
	.align	4
.L13:
	movq	-48(%rbp), %r8
	movq	%r8, %rax
	movq	-128(%rbp),%rbx
	movq	-136(%rbp),%r12
	movq	-144(%rbp),%r13
	movq	-152(%rbp),%r14
	movq	-160(%rbp),%r15
	leave
	ret
.L_y0:
	.size	sql38aVdcomCall,.-sql38aVdcomCall
	.align	4
	.type	__ir_module_info,@function
	.align	16
__ir_module_info:
.L_y6:
	pushq	%rbp
.L_y7:
	movq	%rsp,%rbp
.L_y8:
	subq	$48,%rsp
	movq	%rbx,-8(%rbp)
	movq	%r12,-16(%rbp)
	movq	%r13,-24(%rbp)
	movq	%r14,-32(%rbp)
	movq	%r15,-40(%rbp)
.L_y9:
.L249:
.L248:
	movq	-8(%rbp),%rbx
	movq	-16(%rbp),%r12
	movq	-24(%rbp),%r13
	movq	-32(%rbp),%r14
	movq	-40(%rbp),%r15
	leave
	ret
.L_y5:
	.size	__ir_module_info,.-__ir_module_info

	.section	.bss,"aw"
Bbss.bss:
	.type	Bbss.bss,@object
	.size	Bbss.bss,0

	.section	.data,"aw"
Ddata.data:
	.type	Ddata.data,@object
	.size	Ddata.data,0

	.section	.rodata,"a"
Drodata.rodata:
	.type	Drodata.rodata,@object
	.size	Drodata.rodata,0

	.section	.eh_frame,"aL",link=.text,@unwind
	.align 8
.Lframe1:
	.long	.LECIE1-.LBCIE1
.LBCIE1:
	.long	0x0
	.byte	0x1
	.string	""
	.uleb128	0x1
	.sleb128	-8
	.byte	0x10
	.byte	0xc
	.uleb128	0x7
	.uleb128	0x8
	.byte	0x90
	.uleb128	0x1
	.byte	0x8
	.byte	0x3
	.byte	0x8
	.byte	0x6
	.byte	0x8
	.byte	0xc
	.byte	0x8
	.byte	0xd
	.byte	0x8
	.byte	0xe
	.byte	0x8
	.byte	0xf
	.align 8
.LECIE1:
	.long	.LEFDE1-.LBFDE1
.LBFDE1:
	.long	.LBFDE1-.Lframe1
	.quad	.L_y1
	.quad	.L_y0-.L_y1
	.cfa_advance_loc	.L_y2-.L_y1
	.byte	0xe
	.uleb128	0x10
	.byte	0x86
	.uleb128	0x2
	.cfa_advance_loc	.L_y3-.L_y2
	.byte	0xd
	.uleb128	0x6
	.cfa_advance_loc	.L_y4-.L_y3
	.byte	0x83
	.uleb128	0x12
	.byte	0x8c
	.uleb128	0x13
	.byte	0x8d
	.uleb128	0x14
	.byte	0x8e
	.uleb128	0x15
	.byte	0x8f
	.uleb128	0x16
	.align	8
.LEFDE1:
	.long	.LEFDE2-.LBFDE2
.LBFDE2:
	.long	.LBFDE2-.Lframe1
	.quad	.L_y6
	.quad	.L_y5-.L_y6
	.cfa_advance_loc	.L_y7-.L_y6
	.byte	0xe
	.uleb128	0x10
	.byte	0x86
	.uleb128	0x2
	.cfa_advance_loc	.L_y8-.L_y7
	.byte	0xd
	.uleb128	0x6
	.cfa_advance_loc	.L_y9-.L_y8
	.byte	0x83
	.uleb128	0x3
	.byte	0x8c
	.uleb128	0x4
	.byte	0x8d
	.uleb128	0x5
	.byte	0x8e
	.uleb128	0x6
	.byte	0x8f
	.uleb128	0x7
	.align	8
.LEFDE2:

	.file	"ven38c.s"

& elif $MACH == I386
# this one is still missing... [JnZ]
# below is just a 'cut'n'paste' from the linux version
#	.file	"ven38a"
#	.version	"01.01"
#
#	.text
#	.align 4
#
# /*                                                                 */
# /*  EXTERN_C LONG __stdcall sql38aVdcomCall( IUnknown *lpIUnknown, */
# /*                                           PROC  pProc,          */	
# /*                                           void* pBufAddr,       */
# /*                                           long  BufLen,         */
# /*                                           long  StackSize );    */
# /*                                                                 */
#
#	.globl		sql38aVdcomCall
#	.type		sql38aVdcomCall,@function
#sql38aVdcomCall:
#
#	pushl %ebp							
#	movl %esp,%ebp
#
# /* Save All Registers */
#	pushf
#	pushl %esi
#	pushl %edi
#	pushl %edx
#	pushl %ecx
#	pushl %ebx
#
# /* Save stack pointer for stack recovery after return from call */
#	movl  %esp,%ebx 
# /* Reserve StackSizeInByte */
#	subl 24(%ebp),%esp
#	addl $4,%esp
# /* Load counter register with number of stack items (16B-sized) */
#	movl 20(%ebp),%ecx
#	shrl $4,%ecx
# /* Get source address */
#	movl 16(%ebp),%esi
# /* Get destination address */
#	movl %esp,%edi
# /* Move onto stack */
#	cld
#	test %ecx, %ecx
#	jz .L1
#.L0:
#	movsl (%esi),%es:(%edi)
#	add $12, %esi
#	loop .L0
#.L1:
#
# /* push this pointer */
#	movl 8(%ebp),%edx
#	pushl %edx
# /* Get procedure address */
#	movl 12(%ebp),%edx
# /* Call it */ 
#	call *%edx
# /*; Get former stack pointer independend of call 'result' */
#	movl %ebx,%esp
# /* Always return OK */
#	movl $0,%eax
# /* Get registers back */
#	popl %ebx
#	popl %ecx
#	popl %edx
#	popl %edi
#	popl %esi
#	popf
#	movl -4(%ebp),%ebx
#	leave
#	ret
#.Lfe1:
#	.size	 sql38aVdcomCall,.Lfe1-sql38aVdcomCall
#;	.ident	""

&endif
&endif

&if  $MACH = COMMENT
***************************************************************
*   AIX 32/64 Bit    xlC - Compiler
***************************************************************
&endif

&if  $MACH = _IBMR2
#
.set r0,0; .set SP,1; .set RTOC,2; .set r3,3; .set r4,4
.set r5,5; .set r6,6; .set r7,7; .set r8,8; .set r9,9
.set r10,10; .set r11,11; .set r12,12; .set r13,13; .set r14,14
.set r15,15; .set r16,16; .set r17,17; .set r18,18; .set r19,19
.set r20,20; .set r21,21; .set r22,22; .set r23,23; .set r24,24
.set r25,25; .set r26,26; .set r27,27; .set r28,28; .set r29,29
.set r30,30; .set r31,31
#
.set fpr0,0; .set fpr1,1; .set fpr2,2; .set fpr3,3; .set fpr4,4; 
.set fpr5,5; .set fpr6,6; .set fpr7,7; .set fpr8,8; .set fpr9,9; 
.set fpr10,10; .set fpr11,11; .set fpr12,12; .set fpr13,13;
#
.set BO_IF_NOT,4
.set BO_IF,12
.set CR0_LT,0
.set CR0_GT,1
.set CR0_EQ,2
#
.set vt_empty          ,0;
.set vt_null           ,1;
.set vt_i2             ,2;
.set vt_i4             ,3;
.set vt_r4             ,4;
.set vt_r8             ,5;
.set vt_cy             ,6;
.set vt_date           ,7;
.set vt_bstr           ,8;
.set vt_dispatch       ,9;
.set vt_error          ,10;
.set vt_bool           ,11;
.set vt_variant        ,12;
.set vt_unknown        ,13;
.set vt_decimal        ,14;
.set vt_i1             ,16;
.set vt_ui1            ,17;
.set vt_ui2            ,18;
.set vt_ui4            ,19;
.set vt_i8             ,20;
.set vt_ui8            ,21;
.set vt_int            ,22;
.set vt_uint           ,23;
.set vt_void           ,24;
.set vt_hresult        ,25;
.set vt_ptr            ,26;
.set vt_safearrary     ,27;
.set vt_carray         ,28;
.set vt_userdefined    ,29;
.set vt_lpstr          ,30;
.set vt_lpwstr         ,31;
.set vt_filetime       ,64;
.set vt_blob           ,65;
.set vt_stream         ,66;
.set vt_storage        ,67;
.set vt_streamed_object,68;
.set vt_stored_object  ,69;
.set vt_blob_object    ,70;
.set vt_cf             ,71;
.set vt_clsid          ,72;
.set vt_lc_char        ,201;
.set vt_lc_wchar       ,202;
.set vt_lc_byte        ,203;
.set vt_lc_bool        ,204;
.set vt_lc_abap_tab_handle,205;
.set vt_lc_stream_handle  ,206;
.set vt_lc_int1           ,207;
.set vt_lc_uint1          ,209;
.set vt_vector            ,4096;
.set vt_array             ,8192;
.set vt_byref             ,16384;
#
#
&ifdef BIT64
# Link Area
.set LINK_AREA_BACKCHAIN    , 0;
.set LINK_AREA_CR           , 8;
.set LINK_AREA_LR           , 16;
.set LINK_AREA_COMP_SAVE    , 24;
.set LINK_AREA_BIND_SAVE    , 32;
.set LINK_AREA_TOC_SAVE     , 40;
.set LINK_AREA_SIZE         , 48;
#
.set GPR_SIZE               , 8;
&else
# Link Area
.set LINK_AREA_BACKCHAIN    , 0;
.set LINK_AREA_CR           , 4;
.set LINK_AREA_LR           , 8;
.set LINK_AREA_COMP_SAVE    , 12;
.set LINK_AREA_BIND_SAVE    , 16;
.set LINK_AREA_TOC_SAVE     , 20;
.set LINK_AREA_SIZE         , 24;           # zuvor fehlerhaft 20
#
.set GPR_SIZE               , 4;
&endif
.set MIN_ARGUMENT_STACK_SIZE, 8*GPR_SIZE;   # 8 Registers
.set ARG0_OFF               , LINK_AREA_SIZE;
.set ARG1_OFF               , ARG0_OFF + GPR_SIZE;
.set ARG2_OFF               , ARG1_OFF + GPR_SIZE;
.set ARG3_OFF               , ARG2_OFF + GPR_SIZE;
.set ARG4_OFF               , ARG3_OFF + GPR_SIZE;
.set ARG5_OFF               , ARG4_OFF + GPR_SIZE;
.set ARG6_OFF               , ARG5_OFF + GPR_SIZE;
.set ARG7_OFF               , ARG6_OFF + GPR_SIZE;
#
     .dsect       ten38a_stack_elem
ste_valb: .byte
ste_vals: .short
ste_val:  .long        
ste_valf: .float
ste_vald: .double      0.0
ste_vt:   .short       0
ste_io:   .byte        0
ste_ptr:  .byte        0
ste_len:  .long        0
#   
    .globl    ._ptrgl[pr]             # *NewStyleCall*
		.globl		.sql38aVdcomCall[pr]
		.csect		.sql38aVdcomCall[pr]
.sql38aVdcomCall:
#
# Parameters:
#      r3   -   "this" pointer of "COM"-object
#      r4   -   interface pointer
#      r5   -   address ( parameter description area )
#      r6   -   length ( parameter description area )
#      r7   -   parameter stack len needed
#
#       begin prolog
#
        mfcr        r0                  # r0=CR
&ifdef BIT64
# PTS 1109630 ( use std instead of stw to save CR if 64 Bit environment )
        std         r0,LINK_AREA_CR(SP) # save CR in callers frame         
&else
        stw         r0,LINK_AREA_CR(SP) # save CR in callers frame
&endif
        mflr        r0                  # r0=LR 
&ifdef BIT64
        std         r0,LINK_AREA_LR(SP) # save LR in callers frame         
&else
        stw         r0,LINK_AREA_LR(SP) # save LR in callers frame         
&endif
        li          r8,MIN_ARGUMENT_STACK_SIZE   # >>><<<
        cmp         0,0,r8,r7           # needed size > min size 
        bc          BO_IF,CR0_GT,L_002
        cal         r8,15(r7)           # + 15 because of alignment
L_002:  cal         r8,LINK_AREA_SIZE(r8)
        neg         r8,r8
        li          r9,-16
        and.        r8,r8,r9            #Doubleword - Alignment
&ifdef BIT64
        stdux       SP,SP,r8            #decrement stack
&else
        stwux       SP,SP,r8            #decrement stack
&endif
#
#       move parameters to stack
#
        li          r0,1                #index to floatregister
#                                       for float/double parameters
        li          r7,-1               #for decrement operations
&ifdef BIT64
        sradi       r10,r6,0x4          #r10 = num = len / 16
&else
        srawi       r10,r6,0x4          #r10 = num = len / 16
&endif
        a.          r11,r10,r7          #decrement count
        bc          BO_IF,CR0_LT,L_05
        cal         r11,0(r5)
        .using      ten38a_stack_elem,r11
#       arg 0 remains in its register as passed  by caller
        cal         r9,ARG1_OFF(SP)     #next stack area
L_003:  lbz         r6,ste_ptr          #check if CallByRef
 	    cmpi        0,0,r6,0x0
        bc          BO_IF_NOT,CR0_EQ,L_0030
        lwz         r6,ste_len
        cmpi        0,0,r6,0x1          #check if ByValue & Len=1
        bc          BO_IF,CR0_EQ,L_0031
        cmpi        0,0,r6,0x2          #check if ByValue & Len=2
        bc          BO_IF,CR0_EQ,L_0032
        cmpi        0,0,r6,0x4          #check if ByValue & Len=4
        bc          BO_IF,CR0_EQ,L_0034
        b           L_0033              #if ByValue & Len=8
L_0031: lbz         r8,ste_valb  
        b           L_003X
L_0032: lhz         r8,ste_vals 
        b           L_003X
&ifdef BIT64
L_0030: li          r6,GPR_SIZE         #length of pointer 
L_0033: ld          r8,ste_val
        b           L_003X
L_0034: lwz         r8,ste_val
L_003X: std         r8,0(r9)
&else
L_0030: li          r6,GPR_SIZE         #length of pointer 
L_0033: 
L_0034: lwz         r8,ste_val
L_003X: stw         r8,0(r9)
&endif
#       
#       if vt_r4 (floating-point length 4)
#       floating - point registers have to be loaded
#
        lhz         r8,ste_vt           #check if Float4
 	    cmpi        0,0,r8,vt_r4
        bc          BO_IF,CR0_EQ,L_FLT4
#
        cal         r9,GPR_SIZE(r9)     #increment stack pointer
        cmpi        0,0,r6,0x8
        bc          BO_IF,CR0_LT,L_004
&ifndef BIT64
        lwz         r8,ste_val+4
        stw         r8,0(r9)
        cal         r9,4(r9)            #increment stack pointer
&endif
#       
#       if vt_r8 (floating-point length 8)
#       floating - point registers have to be loaded
#
        lhz         r8,ste_vt           #check if Float8
 	    cmpi        0,0,r8,vt_r8
        bc          BO_IF,CR0_EQ,L_FLT8
#
L_004:  cal         r11,16(r11)         #point to next element
        a.          r10,r10,r7          #decrement count
        bc          BO_IF,CR0_GT,L_003
#       
&ifdef BIT64
L_05:   std         RTOC,LINK_AREA_TOC_SAVE(SP) #save TOC
        cal         r11,0(r4)
        ld          r4,ARG1_OFF(SP)
        ld          r5,ARG2_OFF(SP)
        ld          r6,ARG3_OFF(SP)
        ld          r7,ARG4_OFF(SP)
        ld          r8,ARG5_OFF(SP)
        ld          r9,ARG6_OFF(SP)
        ld          r10,ARG7_OFF(SP)
        bl          ._ptrgl[pr]                 # *NewStyleCall*     
        ld          RTOC,LINK_AREA_TOC_SAVE(SP)
        ld          SP,LINK_AREA_BACKCHAIN(SP)  #restore SP
        ld          r10,LINK_AREA_CR(SP)        #restore CR
        ld          r0,LINK_AREA_LR(SP)         #get return address
&else
L_05:   stw         RTOC,LINK_AREA_TOC_SAVE(SP) #save TOC
        cal         r11,0(r4)
        lwz         r4,ARG1_OFF(SP)
        lwz         r5,ARG2_OFF(SP)
        lwz         r6,ARG3_OFF(SP)
        lwz         r7,ARG4_OFF(SP)
        lwz         r8,ARG5_OFF(SP)
        lwz         r9,ARG6_OFF(SP)
        lwz         r10,ARG7_OFF(SP)
        bl          ._ptrgl[pr]                 # *NewStyleCall*     
        lwz         RTOC,LINK_AREA_TOC_SAVE(SP)
        lwz         SP,LINK_AREA_BACKCHAIN(SP)  #restore SP
        lwz         r10,LINK_AREA_CR(SP)        #restore CR
        lwz         r0,LINK_AREA_LR(SP)         #get return address
&endif
        mtlr        r0                          #return address to LR
        mtcrf       0x38,r10                    # Restore CR2, CR3, CR4 of CR
        brl
#
#       more than 13 float/double value parameters ?
L_FLT4: 
&ifdef BIT64
        lwz         r8,ste_val
        stw         r8,0(r9)
&endif
        cal         r9,GPR_SIZE(r9)             #increment stack pointer
        lbz         r6,ste_ptr                  #check if CallByRef
        cmpi        0,0,r6,0x0
        bc          BO_IF_NOT,CR0_EQ,L_004
#
		cmpi        0,0,r0,13            
        bc          BO_IF,CR0_GT,L_004
#
L_F001: cmpi        0,0,r0,1
        bc          BO_IF_NOT,CR0_EQ,L_F002
        lfs         fpr1,ste_valf
        li          r0,2
        b           L_004
L_F002: cmpi        0,0,r0,2
        bc          BO_IF_NOT,CR0_EQ,L_F003
        lfs         fpr2,ste_valf
        li          r0,3
        b           L_004
L_F003: cmpi        0,0,r0,3
        bc          BO_IF_NOT,CR0_EQ,L_F004
        lfs         fpr3,ste_valf
        li          r0,4
        b           L_004
L_F004: cmpi        0,0,r0,4
        bc          BO_IF_NOT,CR0_EQ,L_F005
        lfs         fpr4,ste_valf
        li          r0,5
        b           L_004
L_F005: cmpi        0,0,r0,5
        bc          BO_IF_NOT,CR0_EQ,L_F006
        lfs         fpr5,ste_valf
        li          r0,6
        b           L_004
L_F006: cmpi        0,0,r0,6
        bc          BO_IF_NOT,CR0_EQ,L_F007
        lfs         fpr6,ste_valf
        li          r0,7
        b           L_004
L_F007: cmpi        0,0,r0,7
        bc          BO_IF_NOT,CR0_EQ,L_F008
        lfs         fpr7,ste_valf
        li          r0,8
        b           L_004
L_F008: cmpi        0,0,r0,8
        bc          BO_IF_NOT,CR0_EQ,L_F009
        lfs         fpr8,ste_valf
        li          r0,9
        b           L_004
L_F009: cmpi        0,0,r0,9
        bc          BO_IF_NOT,CR0_EQ,L_F010
        lfs         fpr9,ste_valf
        li          r0,10
        b           L_004
L_F010: cmpi        0,0,r0,10
        bc          BO_IF_NOT,CR0_EQ,L_F011
        lfs         fpr10,ste_valf
        li          r0,11
        b           L_004
L_F011: cmpi        0,0,r0,11
        bc          BO_IF_NOT,CR0_EQ,L_F012
        lfs         fpr11,ste_valf
        li          r0,12
        b           L_004
L_F012: cmpi        0,0,r0,12
        bc          BO_IF_NOT,CR0_EQ,L_F013
        lfs         fpr12,ste_valf
        li          r0,13
        b           L_004
L_F013: lfs         fpr13,ste_valf
        li          r0,14
        b           L_004
#
#       more than 13 float/double value parameters ?
L_FLT8: lbz         r6,ste_ptr                  #check if CallByRef
 	    cmpi        0,0,r6,0x0
        bc          BO_IF_NOT,CR0_EQ,L_004
#
		cmpi        0,0,r0,13            
        bc          BO_IF,CR0_GT,L_004
#
L_D001: cmpi        0,0,r0,1
        bc          BO_IF_NOT,CR0_EQ,L_D002
        lfd         fpr1,ste_vald
        li          r0,2
        b           L_004
L_D002: cmpi        0,0,r0,2
        bc          BO_IF_NOT,CR0_EQ,L_D003
        lfd         fpr2,ste_vald
        li          r0,3
        b           L_004
L_D003: cmpi        0,0,r0,3
        bc          BO_IF_NOT,CR0_EQ,L_D004
        lfd         fpr3,ste_vald
        li          r0,4
        b           L_004
L_D004: cmpi        0,0,r0,4
        bc          BO_IF_NOT,CR0_EQ,L_D005
        lfd         fpr4,ste_vald
        li          r0,5
        b           L_004
L_D005: cmpi        0,0,r0,5
        bc          BO_IF_NOT,CR0_EQ,L_D006
        lfd         fpr5,ste_vald
        li          r0,6
        b           L_004
L_D006: cmpi        0,0,r0,6
        bc          BO_IF_NOT,CR0_EQ,L_D007
        lfd         fpr6,ste_vald
        li          r0,7
        b           L_004
L_D007: cmpi        0,0,r0,7
        bc          BO_IF_NOT,CR0_EQ,L_D008
        lfd         fpr7,ste_vald
        li          r0,8
        b           L_004
L_D008: cmpi        0,0,r0,8
        bc          BO_IF_NOT,CR0_EQ,L_D009
        lfd         fpr8,ste_vald
        li          r0,9
        b           L_004
L_D009: cmpi        0,0,r0,9
        bc          BO_IF_NOT,CR0_EQ,L_D010
        lfd         fpr9,ste_vald
        li          r0,10
        b           L_004
L_D010: cmpi        0,0,r0,10
        bc          BO_IF_NOT,CR0_EQ,L_D011
        lfd         fpr10,ste_vald
        li          r0,11
        b           L_004
L_D011: cmpi        0,0,r0,11
        bc          BO_IF_NOT,CR0_EQ,L_D012
        lfd         fpr11,ste_vald
        li          r0,12
        b           L_004
L_D012: cmpi        0,0,r0,12
        bc          BO_IF_NOT,CR0_EQ,L_D013
        lfd         fpr12,ste_vald
        li          r0,13
        b           L_004
L_D013: lfd         fpr13,ste_vald
        li          r0,14
        b           L_004
#
TTB: .long   0x00000000
# trace table
    .byte   0x00    # Version=0
    .byte   0x0c    # Lang=TB_ASM
    .byte   0x22    # IS_GL=0, IS_EPROL=0, HAS_TBOFF=1
                    # INT_PROC=0,HAS_CTL=0,TOCLESS=0
                    # FP_PRESENT=1,LOG_ABORT=0
    .byte   0x43    # INT_HANDL=0,NAME_PRESENT=1,
                    # USER_ALLOCA=0,CL_DIS_INV=WALK_ONCOND
                    # SAVES_CR=1,SAVES_LR=1
    .byte   0x80    # STORES_BC=1,FPR_SAVED=0
    .byte   0x00    # GPR_SAVED=0
    .byte   0x00    # FIXEDPARMS=0
    .byte   0x00    # FLOATPARMS=0, PARMSONSTK=0
    .long   0x00000000
    .long   TTB - .sql38aVdcomCall  #TB_OFFSET
    .short  16      # NAME_LEN
    .byte   "sql38aVdcomCall "
    .byte	0		# padding
    .byte	0		# padding
# end of tracetable
&endif
&if  $MACH = COMMENT
***************************************************************
*   HP-UX 32 Bit    aCC - Compiler   
***************************************************************
&endif
&if  $MACH = PA11 || $MACH = PA20W
&ifdef BIT64
	.LEVEL	2.0W
&else
	.LEVEL	1.1
&endif
	.CODE	
;
vt_empty           .EQU 0
vt_null            .EQU 1
vt_i2              .EQU 2
vt_i4              .EQU 3
vt_r4              .EQU 4
vt_r8              .EQU 5
vt_cy              .EQU 6
vt_date            .EQU 7
vt_bstr            .EQU 8
vt_dispatch        .EQU 9
vt_error           .EQU 10
vt_bool            .EQU 11
vt_variant         .EQU 12
vt_unknown         .EQU 13
vt_decimal         .EQU 14
vt_i1              .EQU 16
vt_ui1             .EQU 17
vt_ui2             .EQU 18
vt_ui4             .EQU 19
vt_i8              .EQU 20
vt_ui8             .EQU 21
vt_int             .EQU 22
vt_uint            .EQU 23
vt_void            .EQU 24
vt_hresult         .EQU 25
vt_ptr             .EQU 26
vt_safearrary      .EQU 27
vt_carray          .EQU 28
vt_userdefined     .EQU 29
vt_lpstr           .EQU 30
vt_lpwstr          .EQU 31
vt_filetime        .EQU 64
vt_blob            .EQU 65
vt_stream          .EQU 66
vt_storage         .EQU 67
vt_streamed_object .EQU 68
vt_stored_object   .EQU 69
vt_blob_object     .EQU 70
vt_cf              .EQU 71
vt_clsid           .EQU 72
vt_lc_char         .EQU 201
vt_lc_wchar        .EQU 202
vt_lc_byte         .EQU 203
vt_lc_bool         .EQU 204
vt_lc_abap_tab_handle .EQU 205
vt_lc_stream_handle   .EQU 206
vt_lc_int1            .EQU 207
vt_lc_uint1           .EQU 209
vt_vector             .EQU 4096
vt_array              .EQU 8192
vt_byref              .EQU 16384
;
ste_val            .EQU 0
ste_vt             .EQU 8
ste_io             .EQU 10
ste_ptr            .EQU 11
ste_len            .EQU 12
;
ste_parmdesc_size  .EQU 16
;
; ARG 0  - %r26     this ptr
; ARG 1  - %r25     entry-point
; ARG 2  - %r24     addr(param description buffer)
; ARG 3  - %r23     len(param description buffer)
; ARG 4  - %r22     needed stack area for call (32-BIT on Stack)
;
&ifdef BIT64
;
FRAME_SIZE         .EQU 16
VAR_FRAME_SIZE     .EQU 32
;
&else
;
FRAME_SIZE         .EQU 32
VAR_FRAME_SIZE     .EQU 16
;
&endif
;
sql38aVdcomCall
	.PROC
&ifdef BIT64
	.CALLINFO CALLER,FRAME=VAR_FRAME_SIZE,ENTRY_GR=%r5,SAVE_RP,ARGS_SAVED,ALLOCA_FRAME
	.ENTER

	COPY    %r30,%r3
    COPY    %r29,%r4
    LDI     64,%r31
	CMPB,<,N %r31,%r22,STACKSIZE_OK
    NOP
    COPY    %r31,%r22
STACKSIZE_OK
    LDO     FRAME_SIZE(%r22),%r22
	ADDI    63,%r22,%r31    ;align stack size to
	DEPDI   0,63,6,%r31     ;   64 bytes alignment
	ADD     %r30,%r31,%r30  ;set new sp
	COPY    %r25,%r28       ;function pointer
; %r20 = address of last argument - word used
	COPY    %r3,%r20
&else
	.CALLINFO CALLER,FRAME=VAR_FRAME_SIZE,ENTRY_GR=%r3,SAVE_RP,ARGS_SAVED,ALLOCA_FRAME
	.ENTER

	COPY    %r30,%r3
	LDW     -124(%r3),%r21  ;%r21 arg 4 needed stack area for callee parms
	LDW     -16(%r30),%r22  ;%r22 = static link
	LDW     -4(%r30),%r1    ;%r1  = previous SP
	ADDI    63,%r21,%r31    ;align stack size to
	DEPWI   0,31,6,%r31     ;   64 bytes alignment
	ADD     %r30,%r31,%r30  ;set new sp
	STW     %r1,-4(%r30)    ;set previous SP into new frame marker
	STW     %r22,-16(%r30)  ;set static link into new frame marker
	COPY    %r25,%r22       ;r31 = entry point
; %r20 = address of last argument - word used
	LDO     -FRAME_SIZE(%r30),%r20
&endif
;
; %r21 = actual position within param-desc-buf
; %r25 = remaining length of param-desc-buf
	COPY    %r24,%r21
	COPY    %r23,%r25
;
&ifdef BIT64
	STD     %r26,0(%r20)    ;callee arg 0 = this pointer
	ADDI    8,%r20,%r20     ;
&else
	STW     %r26,-4(%r20)   ;callee arg 0 = this pointer
	ADDI    -4,%r20,%r20    ;
&endif
	LDI     5,%r23          ;number of parm float register
DO_ARGS
	CMPIB,=,N   0,%r25,ARGS_DONE
	LDB         ste_ptr(%r21),%r1  ;get PTR flag
	CMPIB,<>    0,%r1,ARG_IN_REG   ;check if flag is set
&ifdef BIT64
	LDD         ste_val(%r21),%r26
&else
	LDW         ste_val(%r21),%r26
&endif
	LDW         ste_len(%r21),%r1  ;get length of param
	CMPIB,=     1,%r1,ARG_IN_REG
	LDB         ste_val(%r21),%r26
	CMPIB,=     2,%r1,ARG_IN_REG
	LDH         ste_val(%r21),%r26
	CMPIB,=     4,%r1,ARG_IN_REG
	LDW         ste_val(%r21),%r26
&ifdef BIT64
	LDD         ste_val(%r21),%r26
ARG_IN_REG
	STD         %r26,(%r20)     ;callee arg 0 = this pointer
	ADDI        8,%r20,%r20     ;
&else
	FLDD        ste_val(%r21),%fr8
	DEPWI       0,31,3,%r20        ;double word align   
	FSTD        %fr8,-8(%r20)
	ADDI        1,%r23,%r23        ;align float register
	DEPWI       0,31,1,%r23        ;   even register number
	B           ARG_ON_STACK
	ADDI        -8,%r20,%r20       ;
ARG_IN_REG
	STW         %r26,-4(%r20)   ;callee arg 0 = this pointer
	ADDI        -4,%r20,%r20    ;
ARG_ON_STACK
	CMPIB,<,N   7,%r23,NEXT_ARG
	LDH         ste_vt(%r21),%r1  ;get type
	CMPIB,<>,N  4,%r1,CHECK_FLOAT8 ;4 == vt_r4
	CMPIB,=     7,%r23,NEXT_ARG
	FLDW        0(%r20),%fr7
	CMPIB,=     6,%r23,NEXT_ARG
	FLDW        0(%r20),%fr6
	CMPIB,=     5,%r23,NEXT_ARG
	FLDW        0(%r20),%fr5
CHECK_FLOAT8
	CMPIB,<>,N  5,%r1,NEXT_ARG     ;5 == vt_r8
	FLDD        0(%r20),%fr7
NEXT_ARG
	LDH         ste_len(%r21),%r1  ;get length of param
	CMPIB,>     4,%r1,NEXT_ARG2
	ADDI        1,%r23,%r23
	ADDI        1,%r23,%r23
NEXT_ARG2
&endif
	ADDI        ste_parmdesc_size,%r21,%r21
	B           DO_ARGS
	ADDI        -ste_parmdesc_size,%r25,%r25
;
ARGS_DONE
&ifdef BIT64
	LDO         64(%r3),%r29
	LDD         -64(%r29),%r26
	FLDD        -56(%r29),%fr5
	LDD         -56(%r29),%r25
	FLDD        -48(%r29),%fr6
	LDD         -48(%r29),%r24
	FLDD        -40(%r29),%fr7
	LDD         -40(%r29),%r23
	FLDD        -32(%r29),%fr8
	LDD         -32(%r29),%r22
	FLDD        -24(%r29),%fr9
	LDD         -24(%r29),%r21
	FLDD        -16(%r29),%fr10
	LDD         -16(%r29),%r20
	FLDD        -8(%r29),%fr11
	LDD         -8(%r29),%r19
	LDD         16(%r28),%r1        ;r1  = entry point
    .CALL
    BVE,L       (%r1),%r2
    LDD         24(%r28),%r27       ;r27 = GP 
    LDD         -120(%r3),%r27      ;retore GP
&else
	LDW         -36(%r30),%r26
	LDW         -40(%r30),%r25
	LDW         -44(%r30),%r24
	LDW         -48(%r30),%r23
	LDIL        L'$$dyncall,%r31
	.CALL       
	BE,L        R'$$dyncall(%sr4,%r31),%r31
	COPY        %r31,%r2
&endif
;
	COPY        %r0,%r28
	COPY        %r3,%r30
	.LEAVE
	.PROCEND    
;
	.DATA
	.CODE 
	.EXPORT sql38aVdcomCall,ENTRY,PRIV_LEV=3,LONG_RETURN
	.IMPORT $$dyncall,MILLICODE
	.END
&endif
&if  $MACH = COMMENT
***************************************************************
*   HP-UX 64 Bit    aCC - Compiler    IA64  
***************************************************************
&endif
&if  $MACH = HP_IA64
// HP-UX IA-64
//
// Function to make call to class function using a argument vector
//
// extern "C" long
// sql38aVdcomCall(void *pThis, void *pFunc,
//                 void *Argv, int sizeOfArgv,
//                 unsigned int StackSize)
//
// void *pThis              "this" Pointer to object instance
// void *pFunc              Pointer to function (method) to call
// void *Argv               Pointer to param description area
// int sizeOfArgv           Size of param description area
// unsigned int StackSize   Stack space require to store params (not used)
//
//
//  A little info on IA-64 parameter passing.
//
//  Parameters are handled in "slots".  Multiple slots can be used for 
//  parameters larger than 64 bits.  Given that this function handles 
//  ints, longs and doubles, we can assume a one to one correspondance 
//  between parameters and slots.  The first eight slots are in the 
//  registers out0 - out7.  Slots 8 and up are in the caller's stack frame 
//  at sp+16.  To facilitate varargs, the first 16 bytes of the caller's 
//  stack frame are available to the callee to put slots 6 and 7.  In the 
//  vararg case, slots 0 through 5 are copied to the base of the callee's 
//  stack, thus providing a contiguous area in memory for all parameters.
//
//  Floating point parameters are a little more involved.  Up to 8 floating 
//  slots exist in floating point registers f8-f15 (aka farg0-farg7).  If 
//  the formal parameters of the called function are known at call time, 
//  then FP args would would be placed only in the next available fp register 
//  and the next general register slot would be skipped.  In the case of 
//  this function, since we don't know the formal args and suspect that 
//  the called function is using varags, we need to pass floating point args 
//  in both the correct general register and the next floating point register.
//
//  An example will help here:
//  Lets suppose the caller pases arguments for a function with the signature
//
//    double somefcn(double a0, int a1, double a2, int a3, int a4, double a5)
//
//  at the time of the call, the arguments should be as follows:
//    a0        out0 & farg0
//    a1        out1
//    a2        out2 & farg1
//    a3        out3
//    a4        out4
//    a5        out5 & farg2
//
//  To simplify the handling of the arguments, two "arrays" are set up in the 
//  stack, one for the "out" slots and the other to hold up to 8 floating 
//  point arguments to be placed in registers.
//
//  Stack structure while getting arguments:
//  sp                sp+48 sp+56  sp+64     sp+64+(args-8)*8        previoussp
//  | --------48-------- | -8- | -8- | -(args-8)*8-| ----------64---------- |
//  [scratch for slots0-6|slot6|slot7|slot8...slotN| scratch for fp arg regs]
//
//  This makes the our procedure frame 128 + (args - 8) * 8 bytes.  Since 
//  stack frames need to be multiple of 16 bytes, we change this formula to 
//  128 + (((args - 7) >> 1) << 4) which will round up to 16 byte boudaries 
//  and it is trivial to calculate.  We do keep pointers to both the slot and 
//  FP scratch areas.
//
//  The stack is first created 48 bytes too large to make space to temporarily 
//  hold slots 0-6.  Right before we make the call to the target function, 
//  we add 48 to sp to make it match the convention.  Since we have a variable 
//  sized stack frame, we save the previous sp in a register for when we 
//  return.
//
//  Stack structure right before calling function:
//  sp-48                sp  sp+8  sp+16     sp+16+(args-8)*8        previoussp
//  | --------48-------- | -8- | -8- | -(args-8)*8-| ----------64---------- |
//  [scratch for slots0-6|slot6|slot7|slot8...slotN| scratch for fp arg regs]
//

        .type   sql38aVdcomCall,@function
        .radix  C
        .psr    abi64
        .psr    msb

        .section .text, "wax","progbits"
        .proc   sql38aVdcomCall
        .global sql38aVdcomCall

        // Scratch registers - not saved across calls
        temp1           = r9
        temp2           = r10
        temp3           = r11
        nargs           = r14
        pargtype        = r15
        argtype         = r16
        parglen         = r17
        arglen          = r18
        tempint         = r19
        fpptr           = r20
        slotptr         = r21
        numgrs          = r22
        numfrs          = r23
        pargisptr       = r24
        argisptr        = r25
        tempfp          = f7

        // Symbolic constants
        vt_empty             =0
        vt_null              =1
        vt_i2                =2
        vt_i4                =3
        vt_r4                =4
        vt_r8                =5
        vt_cy                =6
        vt_date              =7
        vt_bstr              =8
        vt_dispatch          =9
        vt_error             =10
        vt_bool              =11
        vt_variant           =12
        vt_unknown           =13
        vt_decimal           =14
        vt_i1                =16
        vt_ui1               =17
        vt_ui2               =18
        vt_ui4               =19
        vt_i8                =20
        vt_ui8               =21
        vt_int               =22
        vt_uint              =23
        vt_void              =24
        vt_hresult           =25
        vt_ptr               =26
        vt_safearrary        =27
        vt_carray            =28
        vt_userdefined       =29
        vt_lpstr             =30
        vt_lpwstr            =31
        vt_filetime          =64
        vt_blob              =65
        vt_stream            =66
        vt_storage           =67
        vt_streamed_object   =68
        vt_stored_object     =69
        vt_blob_object       =70
        vt_cf                =71
        vt_clsid             =72
        vt_lc_char           =201
        vt_lc_wchar          =202
        vt_lc_byte           =203
        vt_lc_bool           =204
        vt_lc_abap_tab_handle=205
        vt_lc_stream_handle  =206
        vt_lc_int1           =207
        vt_lc_uint1          =209
        vt_vector            =4096
        vt_array             =8192
        vt_byref             =16384

        // Offsets into param_t
        val_off         = 0
        type_off        = 8
        inout_off       = 10
        isptr_off       = 11
        len_off         = 12

sql38aVdcomCall:
        .prologue

        // Allocate 5 input, 4 locals and 8 outputs
[.s_pfs:] alloc         r37 = ar.pfs, 5, 5, 8, 0 // r37 = loc0 (prev_fs)
        .save           ar.pfs,r37,.sv_p

        // Registers saved by register stack engine
        pthis           = in0
        pfunc           = in1
        param           = in2
        paramsize       = in3
        stacksize       = in4

        prev_fs         = loc0
        prev_sp         = loc1
        prev_rp         = loc2
        prev_lc         = loc3
        prev_gp         = loc4

        sxt4            temp1 = paramsize
        cmp4.lt.unc     p6, p0 = paramsize, r0  // Is paramsize < 0
        ;;
        .vframe prev_sp                         // PTS 1129652
        add             prev_sp = 0, sp         // Save stack pointer
(p6)    add             ret0= -1, r0            // If paramsize is <0, 
(p6)    br.ret.sptk.many rp                     //  Return -1
        ;;
        add             fpptr = -64, sp         // fpptr is at top of frame
[.s_rp:] mov            prev_rp = rp            // Save rp
        .save           rp,prev_rp,.s_rp
        shr             nargs = temp1,4
        ;;
        add             temp1 = -6, nargs       // temp1 = nargs - 6
        cmp4.lt.unc     p6, p0 = 7, nargs       // p6 = (nargs > 7)
        add             temp3 = 128, r0         // Stack size at least 128
        ;;
        add             numgrs = 1, nargs       // Num of gr args, incl "this"
        shr.u           temp1 = temp1, 1        // temp1 = (nargs - 1) / 2
        ;;
(p6)    shladd          temp3 = temp1, 4, temp3 // if (nargs > 7)
                                                //   stack size =128 + temp1*16
                                                // else
                                                //   stack size = 128
        ;;
        sub             sp = sp, temp3          // Create stack frame
[.s_lc:] mov            prev_lc = ar.lc         // Save loop counter
        .save           ar.lc,prev_lc,.s_lc
        add             prev_gp = 0, gp         // Save global pointer

        .body
        ;;
        add             slotptr = 0, sp         // slotptr is at stack base
        cmp4.ge.unc     p6, p7 = r0, nargs      // Make sure nargs > 0
        add             numfrs = r0, r0         // Clear fr arg counter
        ;;
        st8             [slotptr] = pthis, 8    // Store "this" argument
(p7)    add             temp2 = -1, nargs       //
(p6)    br.dpnt.few     make_call               // no args to process!
        ;;
        // Set up pointers needed in the argument processing loop
        add             pargtype = type_off, param
        add             parglen = len_off, param
        add             pargisptr = isptr_off, param
        // Put the number of arguments in the loop counter register
        mov             ar.lc = temp2
        ;;

        // Argument processing:
        // We walk the param array checking the type and loading the
        // value from val.  Although there are several different types
        // these really work out to three "machine" types: 8 byte int,
        // 4 byte float, and 8 byte double.  The argument len is used to 
        // determine how we load a value (1, 2, 4 or 8 bytes), but all
        // values are appropriately aligned and treated as 8 byte quantities
        // in the argument registers.  We also store the first 8 float
        // values in the fp arg scratch area to later load them into the fp
        // argument registers.  After loading the type, length and pointer,
        // we determine if there is space in the fp argument scratch area
        // and the size of the argument.  When processing the float values,
        // we need to load the value with the appropriate load float
        // instruction, either ldfs (for vt_r4) or ldfd (for vt_r8).  Since
        // the values are converted to a common in register format, we can
        // store the value into the fp arg area using stfd to be loaded later
        // into the approriate fp arg register using ldfd.
        //
        // The predicate registers are used as follows: 
        //   p8 - True if argument length is 1
        //   p9 - True if argument length is 2
        //   p10 - True if argument length is 4
        //   p11 - True if argument length is 8 or a pointer
        //   p12 - True if space is left in fp arg area and arg is not ptr
        //   p13 - True if fp space left and arg is float (vt_r4)
        //   p14 - True if fp space left and arg is double (vt_r8)
        //   p15 - True if fp space left and we need to write an fp value
        //   p16 - True if argument is not a pointer
        // Some of the predicated loads and stores are done as soon as we know
        // we should do them to use less slots.
arg_loop:
        ld2             argtype = [pargtype],16 // Get argtype
        ld1             argisptr = [pargisptr],16  // Get arg. is pointer flag
        cmp.ltu.unc     p12, p0 = fpptr,prev_sp // p12 = fp slots left
        ;;
        ld4             arglen = [parglen],16   // Get argument length
        cmp4.ne.unc     p11, p16 = 0, argisptr  // Is arg a pointer? (8 bytes)
        cmp4.ne.andcm   p12, p0 = 0, argisptr   // p12 &= !(arg is ptr)
        ;;
(p16)   cmp4.eq.unc     p10, p0 = 4, arglen     // Is the arg 4 bytes?
        cmp4.eq.or      p11, p0 = 8, arglen     // p11 |= Is the arg 8 bytes?
(p12)   cmp4.eq.unc     p14, p0 = vt_r8,argtype // p14 = p12 && (arg is double)
        ;;
(p11)   ld8             tempint = [param]       // Get 8 byte argument
(p16)   cmp4.eq.unc     p8, p0 = 1, arglen      // Is the arg 1 byte?
(p16)   cmp4.eq.unc     p9, p0 = 2, arglen      // Is the arg 2 bytes?
        ;;
(p10)   ld4             tempint = [param]       // Get 4 byte argument
(p14)   ldfd            tempfp = [param]        // Get argument as double
(p12)   cmp4.eq.unc     p13, p0 = vt_r4,argtype // p13 = p12 && (arg is float)
        ;;
(p8)    ld1             tempint = [param]       // Get 1 byte argument
(p13)   ldfs            tempfp = [param]        // Get argument as float
        cmp.ne.unc      p15, p0 = r0, r0        // Clear p15 for next bundle
        ;;
(p9)    ld2             tempint = [param]       // Get 2 byte argument
(p12)   cmp4.eq.or      p15, p0 = vt_r4,argtype // p15=(p12 &&
(p12)   cmp4.eq.or      p15, p0 = vt_r8,argtype //     (is_float || isdouble)))
        ;;
(p15)   stfd            [fpptr] = tempfp, 8     // Fill fp reg area till full
        st8             [slotptr] = tempint, 8  // Store argument as 8 bytes
        add             param = 16, param       // Point to next param
(p15)   add             numfrs = 1, numfrs      // Increment number of fr's
        br.cloop.dptk.few arg_loop
        ;;

make_call:
        // Time to get argument registers loaded and make the call.
        // Both general and floating point registers are loaded using two 
        // pointers for each kind to interleave the loads.  temp2 & temp3
        // are used for GRs and fpptr & slotptr are used for FRs.  We only
        // load the needed number of regeisters, based on numgrs and numfrs.
        add             temp2 = 0, sp           // Point temp2 at &slot0
        add             temp3 = 32, sp          // Point temp3 at &stol4
        add             fpptr = -64, prev_sp    // reset fpptr to top of frame
        ld8             temp1 = [pfunc],8       // Get entry point of fptr
        add             slotptr = -32, prev_sp  // use slotptr for 2nd half
        cmp.le.unc      p6, p0 = 1, numgrs      // Do we have at least 1 GR?
        cmp.le.unc      p7, p0 = 5, numgrs      // Do we have at least 5 GRs?
        cmp.le.unc      p10, p0 = 1, numfrs     // Do we have at least 1 FR?
        cmp.le.unc      p11, p0 = 5, numfrs     // Do we have at least 5 FRs?
        ;;
        // Get pointer to retval
(p6)    ld8             out0 = [temp2], 8
(p7)    ld8             out4 = [temp3], 8
        cmp.le.unc      p8, p0 = 2, numgrs      // Do we have at least 2 GRs?
(p10)   ldfd            f8 = [fpptr], 8
(p11)   ldfd            f12 = [slotptr], 8
        cmp.le.unc      p9, p0 = 6, numgrs      // Do we have at least 6 GRs?
        cmp.le.unc      p12, p0 = 2, numfrs     // Do we have at least 2 FRs?
        cmp.le.unc      p13, p0 = 6, numfrs     // Do we have at least 6 FRs?
        mov             ar.lc = prev_lc         // Restore loop counter
        ;;
(p8)    ld8             out1 = [temp2], 8
(p9)    ld8             out5 = [temp3], 8
        cmp.le.unc      p6, p0 = 3, numgrs      // Do we have at least 3 GRs?
(p12)   ldfd            f9 = [fpptr], 8
(p13)   ldfd            f13 = [slotptr], 8
        cmp.le.unc      p7, p0 = 7, numgrs      // Do we have at least 7 GRs?
        cmp.le.unc      p10, p0 = 3, numfrs     // Do we have at least 3 FRs?
        mov             b6 = temp1              // Put fptr entry point in b6
        cmp.le.unc      p11, p0 = 7, numfrs     // Do we have at least 7 FRs?
        ;;
(p10)   ldfd            f10 = [fpptr], 8
(p11)   ldfd            f14 = [slotptr], 8
        cmp.le.unc      p12, p0 = 4, numfrs     // Do we have at least 4 FRs?
        ld8             gp = [pfunc]            // Get GP for fptr
        cmp.le.unc      p13, p0 = 8, numfrs     // Do we have at least 8 FRs?
        cmp.le.unc      p8, p0 = 4, numgrs      // Do we have at least 4 GRs?
(p6)    ld8             out2 = [temp2], 8
(p7)    ld8             out6 = [temp3], 8
        cmp.le.unc      p9, p0 = 8, numgrs      // Do we have at least 8 GRs?
        ;;
(p12)   ldfd            f11 = [fpptr]
(p13)   ldfd            f15 = [slotptr]
        add             sp = 48, sp             // make stack correct for call
(p8)    ld8             out3 = [temp2]
(p9)    ld8             out7 = [temp3]
        br.call.sptk.many rp = b6               // Call fptr
        ;;
        // Note, result from callee is in ret0.  Leave it alone for our return.
        add             gp = 0, prev_gp         // Restore previous GP
        mov             rp = prev_rp            // Restore RP
        .restore sp                             // 1129652
        add             sp = 0, prev_sp         // Restore previous SP
        ;;
        mov             ar.pfs = prev_fs        // Restore prev func state
        br.ret.sptk.many rp                     // Return
        ;;

        .endp   sql38aVdcomCall
&endif
&if  $MACH = COMMENT
***************************************************************
*   LINUX on PowerPC 64 Bit    gcc/g++ - Compiler
***************************************************************
&endif

&if  $MACH = SDBonPPC64
#
.set r0,0; .set SP,1; .set RTOC,2; .set r3,3; .set r4,4
.set r5,5; .set r6,6; .set r7,7; .set r8,8; .set r9,9
.set r10,10; .set r11,11; .set r12,12; .set r13,13; .set r14,14
.set r15,15; .set r16,16; .set r17,17; .set r18,18; .set r19,19
.set r20,20; .set r21,21; .set r22,22; .set r23,23; .set r24,24
.set r25,25; .set r26,26; .set r27,27; .set r28,28; .set r29,29
.set r30,30; .set r31,31
#
.set fpr0,0; .set fpr1,1; .set fpr2,2; .set fpr3,3; .set fpr4,4; 
.set fpr5,5; .set fpr6,6; .set fpr7,7; .set fpr8,8; .set fpr9,9; 
.set fpr10,10; .set fpr11,11; .set fpr12,12; .set fpr13,13;
#
.set BO_IF_NOT,4
.set BO_IF,12
.set CR0_LT,0
.set CR0_GT,1
.set CR0_EQ,2
#
.set vt_empty          ,0;
.set vt_null           ,1;
.set vt_i2             ,2;
.set vt_i4             ,3;
.set vt_r4             ,4;
.set vt_r8             ,5;
.set vt_cy             ,6;
.set vt_date           ,7;
.set vt_bstr           ,8;
.set vt_dispatch       ,9;
.set vt_error          ,10;
.set vt_bool           ,11;
.set vt_variant        ,12;
.set vt_unknown        ,13;
.set vt_decimal        ,14;
.set vt_i1             ,16;
.set vt_ui1            ,17;
.set vt_ui2            ,18;
.set vt_ui4            ,19;
.set vt_i8             ,20;
.set vt_ui8            ,21;
.set vt_int            ,22;
.set vt_uint           ,23;
.set vt_void           ,24;
.set vt_hresult        ,25;
.set vt_ptr            ,26;
.set vt_safearrary     ,27;
.set vt_carray         ,28;
.set vt_userdefined    ,29;
.set vt_lpstr          ,30;
.set vt_lpwstr         ,31;
.set vt_filetime       ,64;
.set vt_blob           ,65;
.set vt_stream         ,66;
.set vt_storage        ,67;
.set vt_streamed_object,68;
.set vt_stored_object  ,69;
.set vt_blob_object    ,70;
.set vt_cf             ,71;
.set vt_clsid          ,72;
.set vt_lc_char        ,201;
.set vt_lc_wchar       ,202;
.set vt_lc_byte        ,203;
.set vt_lc_bool        ,204;
.set vt_lc_abap_tab_handle,205;
.set vt_lc_stream_handle  ,206;
.set vt_lc_int1           ,207;
.set vt_lc_uint1          ,209;
.set vt_vector            ,4096;
.set vt_array             ,8192;
.set vt_byref             ,16384;
#
#
&ifdef BIT64
# Link Area
.set LINK_AREA_BACKCHAIN    , 0;
.set LINK_AREA_CR           , 8;
.set LINK_AREA_LR           , 16;
.set LINK_AREA_COMP_SAVE    , 24;
.set LINK_AREA_BIND_SAVE    , 32;
.set LINK_AREA_TOC_SAVE     , 40;
.set LINK_AREA_SIZE         , 48;
#
.set GPR_SIZE               , 8;
&endif
.set MIN_ARGUMENT_STACK_SIZE, 8*GPR_SIZE;   # 8 Registers
.set ARG0_OFF               , LINK_AREA_SIZE;
.set ARG1_OFF               , ARG0_OFF + GPR_SIZE;
.set ARG2_OFF               , ARG1_OFF + GPR_SIZE;
.set ARG3_OFF               , ARG2_OFF + GPR_SIZE;
.set ARG4_OFF               , ARG3_OFF + GPR_SIZE;
.set ARG5_OFF               , ARG4_OFF + GPR_SIZE;
.set ARG6_OFF               , ARG5_OFF + GPR_SIZE;
.set ARG7_OFF               , ARG6_OFF + GPR_SIZE;
#
#     .dsect       ten38a_stack_elem
.set ste_valb               , 0;
.set ste_vals               , 0;
.set ste_val                , 0;
.set ste_valf               , 0;
.set ste_vald               , 0;
.set ste_vt                 , 8;
.set ste_io                 , 10;
.set ste_ptr                , 11;
.set ste_len                , 12;
#   
# new section
    .file    "ven38a.s"
    .text
    .align 2
    .globl .ptrgl
.ptrgl:                 /* function to mimic ._ptrgl function of AIX */
.cfi_startproc
    ld    r0,0(r11)	/* Load function addr.  */
    std   RTOC,40(SP)	/* Store previous TOC.  */
    mtctr r0		/* copy function addr to ctr.  */
    ld    RTOC,8(r11)   /* Load functions TOC. */
    ld    r11,12(r11) /* "display", not required for "C". */
    bctr			/* Branch to function.  */
.cfi_endproc
#
    .section	".text"
    .align 2
    .globl		sql38aVdcomCall
    .section	".opd","aw"
    .align 3
sql38aVdcomCall:
    .quad   .sql38aVdcomCall,.TOC.@tocbase,0
    .previous
    .size   sql38aVdcomCall,24
    .type   .sql38aVdcomCall,@function
    .globl  .sql38aVdcomCall
.sql38aVdcomCall:
.cfi_startproc
#
# Parameters:
#      r3   -   "this" pointer of "COM"-object
#      r4   -   interface pointer
#      r5   -   address ( parameter description area )
#      r6   -   length ( parameter description area )
#      r7   -   parameter stack len needed
#
#       begin prolog
#
        mfcr        r0                  # r0=CR
&ifdef BIT64
# PTS 1109630 ( use std instead of stw to save CR if 64 Bit environment )
        std         r0,LINK_AREA_CR(SP) # save CR in callers frame         
&endif
.cfi_offset cr2, 8
        mflr        r0                  # r0=LR 
&ifdef BIT64
        std         r0,LINK_AREA_LR(SP) # save LR in callers frame         
&endif
.cfi_offset lr, 16
        li          r8,MIN_ARGUMENT_STACK_SIZE   # >>><<<
        cmp         0,0,r8,r7           # needed size > min size 
        bc          BO_IF,CR0_GT,L_002
#        cal         r8,15(r7)           # + 15 because of alignment
        addi        r8,r7,15           # + 15 because of alignment
#L_002:  cal         r8,LINK_AREA_SIZE(r8)
L_002:  addi        r8,r8,LINK_AREA_SIZE
        neg         r8,r8
        li          r9,-16
        and.        r8,r8,r9            #Doubleword - Alignment
&ifdef BIT64
        stdux       SP,SP,r8            #decrement stack
&endif
# DW_CFA_def_cfa_expression (0x0f) of 2 bytes.
# DW_OP_reg1 (0x51), DW_OP_deref (0x06)
.cfi_escape 0x0f,2,0x51,0x06
#
#       move parameters to stack
#
        li          r0,1                #index to floatregister
#                                       for float/double parameters
        li          r7,-1               #for decrement operations
&ifdef BIT64
        sradi       r10,r6,0x4          #r10 = num = len / 16
&endif
#        a.          r11,r10,r7          #decrement count
        addc.       r11,r10,r7          #decrement count
        bc          BO_IF,CR0_LT,L_05
#        cal         r11,0(r5)
        addi        r11,r5,0
#        .using      ten38a_stack_elem,r11
#       arg 0 remains in its register as passed  by caller
#        cal         r9,ARG1_OFF(SP)     #next stack area
        addi        r9,SP,ARG1_OFF     #next stack area
L_003:  xor         r8,r8,r8           #clear register 
        lbz         r6,ste_ptr(r11)          #check if CallByRef
 	    cmpi        0,0,r6,0x0
        bc          BO_IF_NOT,CR0_EQ,L_0030
        lwz         r6,ste_len(r11)
        cmpi        0,0,r6,0x1          #check if ByValue & Len=1
        bc          BO_IF,CR0_EQ,L_0031
        cmpi        0,0,r6,0x2          #check if ByValue & Len=2
        bc          BO_IF,CR0_EQ,L_0032
        cmpi        0,0,r6,0x4          #check if ByValue & Len=4
        bc          BO_IF,CR0_EQ,L_0034
        b           L_0033              #if ByValue & Len=8
L_0031: lbz         r8,ste_valb(r11)  
        b           L_003X
L_0032: lha         r8,ste_vals(r11) 
        b           L_003X
&ifdef BIT64
L_0030: li          r6,GPR_SIZE         #length of pointer 
L_0033: ld          r8,ste_val(r11)
        b           L_003X
L_0034: lwa         r8,ste_val(r11)
L_003X: std         r8,0(r9)
&endif
#       
#       if vt_r4 (floating-point length 4)
#       floating - point registers have to be loaded
#
        lhz         r8,ste_vt(r11)           #check if Float4
 	    cmpi        0,0,r8,vt_r4
        bc          BO_IF,CR0_EQ,L_FLT4
#
#        cal         r9,GPR_SIZE(r9)     #increment stack pointer
        addi        r9,r9,GPR_SIZE     #increment stack pointer
        cmpi        0,0,r6,0x8
        bc          BO_IF,CR0_LT,L_004
#       
#       if vt_r8 (floating-point length 8)
#       floating - point registers have to be loaded
#
        lhz         r8,ste_vt(r11)           #check if Float8
 	    cmpi        0,0,r8,vt_r8
        bc          BO_IF,CR0_EQ,L_FLT8
#
# L_004:  cal         r11,16(r11)         #point to next element
L_004:  addi        r11,r11,16
#        a.          r10,r10,r7          #decrement count
        addc.       r10,r10,r7          #decrement count
        bc          BO_IF,CR0_GT,L_003
#       
&ifdef BIT64
L_05:   std         RTOC,LINK_AREA_TOC_SAVE(SP) #save TOC
#        cal         r11,0(r4)
        addi        r11,r4,0
#	ld	    r11,0(r4)
        ld          r4,ARG1_OFF(SP)
        ld          r5,ARG2_OFF(SP)
        ld          r6,ARG3_OFF(SP)
        ld          r7,ARG4_OFF(SP)
        ld          r8,ARG5_OFF(SP)
        ld          r9,ARG6_OFF(SP)
        ld          r10,ARG7_OFF(SP)
        bl          .ptrgl
        ld          RTOC,LINK_AREA_TOC_SAVE(SP)
        ld          SP,LINK_AREA_BACKCHAIN(SP)  #restore SP
        ld          r10,LINK_AREA_CR(SP)        #restore CR
        ld          r0,LINK_AREA_LR(SP)         #get return address
&endif
        mtlr        r0                          #return address to LR
        mtcrf       0x38,r10                    # Restore CR2, CR3, CR4 of CR
#        brl
        blrl
#
#       more than 13 float/double value parameters ?
L_FLT4: 
&ifdef BIT64
        lwz         r8,ste_val(r11)
        stw         r8,0(r9)
&endif
#        cal         r9,GPR_SIZE(r9)             #increment stack pointer
        addi        r9,r9,GPR_SIZE             #increment stack pointer
        lbz         r6,ste_ptr(r11)                  #check if CallByRef
        cmpi        0,0,r6,0x0
        bc          BO_IF_NOT,CR0_EQ,L_004
#
		cmpi        0,0,r0,13            
        bc          BO_IF,CR0_GT,L_004
#
L_F001: cmpi        0,0,r0,1
        bc          BO_IF_NOT,CR0_EQ,L_F002
        lfs         fpr1,ste_valf(r11)
        li          r0,2
        b           L_004
L_F002: cmpi        0,0,r0,2
        bc          BO_IF_NOT,CR0_EQ,L_F003
        lfs         fpr2,ste_valf(r11)
        li          r0,3
        b           L_004
L_F003: cmpi        0,0,r0,3
        bc          BO_IF_NOT,CR0_EQ,L_F004
        lfs         fpr3,ste_valf(r11)
        li          r0,4
        b           L_004
L_F004: cmpi        0,0,r0,4
        bc          BO_IF_NOT,CR0_EQ,L_F005
        lfs         fpr4,ste_valf(r11)
        li          r0,5
        b           L_004
L_F005: cmpi        0,0,r0,5
        bc          BO_IF_NOT,CR0_EQ,L_F006
        lfs         fpr5,ste_valf(r11)
        li          r0,6
        b           L_004
L_F006: cmpi        0,0,r0,6
        bc          BO_IF_NOT,CR0_EQ,L_F007
        lfs         fpr6,ste_valf(r11)
        li          r0,7
        b           L_004
L_F007: cmpi        0,0,r0,7
        bc          BO_IF_NOT,CR0_EQ,L_F008
        lfs         fpr7,ste_valf(r11)
        li          r0,8
        b           L_004
L_F008: cmpi        0,0,r0,8
        bc          BO_IF_NOT,CR0_EQ,L_F009
        lfs         fpr8,ste_valf(r11)
        li          r0,9
        b           L_004
L_F009: cmpi        0,0,r0,9
        bc          BO_IF_NOT,CR0_EQ,L_F010
        lfs         fpr9,ste_valf(r11)
        li          r0,10
        b           L_004
L_F010: cmpi        0,0,r0,10
        bc          BO_IF_NOT,CR0_EQ,L_F011
        lfs         fpr10,ste_valf(r11)
        li          r0,11
        b           L_004
L_F011: cmpi        0,0,r0,11
        bc          BO_IF_NOT,CR0_EQ,L_F012
        lfs         fpr11,ste_valf(r11)
        li          r0,12
        b           L_004
L_F012: cmpi        0,0,r0,12
        bc          BO_IF_NOT,CR0_EQ,L_F013
        lfs         fpr12,ste_valf(r11)
        li          r0,13
        b           L_004
L_F013: lfs         fpr13,ste_valf(r11)
        li          r0,14
        b           L_004
#
#       more than 13 float/double value parameters ?
L_FLT8: lbz         r6,ste_ptr(r11)                  #check if CallByRef
 	    cmpi        0,0,r6,0x0
        bc          BO_IF_NOT,CR0_EQ,L_004
#
		cmpi        0,0,r0,13            
        bc          BO_IF,CR0_GT,L_004
#
L_D001: cmpi        0,0,r0,1
        bc          BO_IF_NOT,CR0_EQ,L_D002
        lfd         fpr1,ste_vald(r11)
        li          r0,2
        b           L_004
L_D002: cmpi        0,0,r0,2
        bc          BO_IF_NOT,CR0_EQ,L_D003
        lfd         fpr2,ste_vald(r11)
        li          r0,3
        b           L_004
L_D003: cmpi        0,0,r0,3
        bc          BO_IF_NOT,CR0_EQ,L_D004
        lfd         fpr3,ste_vald(r11)
        li          r0,4
        b           L_004
L_D004: cmpi        0,0,r0,4
        bc          BO_IF_NOT,CR0_EQ,L_D005
        lfd         fpr4,ste_vald(r11)
        li          r0,5
        b           L_004
L_D005: cmpi        0,0,r0,5
        bc          BO_IF_NOT,CR0_EQ,L_D006
        lfd         fpr5,ste_vald(r11)
        li          r0,6
        b           L_004
L_D006: cmpi        0,0,r0,6
        bc          BO_IF_NOT,CR0_EQ,L_D007
        lfd         fpr6,ste_vald(r11)
        li          r0,7
        b           L_004
L_D007: cmpi        0,0,r0,7
        bc          BO_IF_NOT,CR0_EQ,L_D008
        lfd         fpr7,ste_vald(r11)
        li          r0,8
        b           L_004
L_D008: cmpi        0,0,r0,8
        bc          BO_IF_NOT,CR0_EQ,L_D009
        lfd         fpr8,ste_vald(r11)
        li          r0,9
        b           L_004
L_D009: cmpi        0,0,r0,9
        bc          BO_IF_NOT,CR0_EQ,L_D010
        lfd         fpr9,ste_vald(r11)
        li          r0,10
        b           L_004
L_D010: cmpi        0,0,r0,10
        bc          BO_IF_NOT,CR0_EQ,L_D011
        lfd         fpr10,ste_vald(r11)
        li          r0,11
        b           L_004
L_D011: cmpi        0,0,r0,11
        bc          BO_IF_NOT,CR0_EQ,L_D012
        lfd         fpr11,ste_vald(r11)
        li          r0,12
        b           L_004
L_D012: cmpi        0,0,r0,12
        bc          BO_IF_NOT,CR0_EQ,L_D013
        lfd         fpr12,ste_vald(r11)
        li          r0,13
        b           L_004
L_D013: lfd         fpr13,ste_vald(r11)
        li          r0,14
        b           L_004
#
TTB: .long   0x00000000
# trace table
    .byte   0x00    # Version=0
    .byte   0x0c    # Lang=TB_ASM
    .byte   0x22    # IS_GL=0, IS_EPROL=0, HAS_TBOFF=1
                    # INT_PROC=0,HAS_CTL=0,TOCLESS=0
                    # FP_PRESENT=1,LOG_ABORT=0
    .byte   0x43    # INT_HANDL=0,NAME_PRESENT=1,
                    # USER_ALLOCA=0,CL_DIS_INV=WALK_ONCOND
                    # SAVES_CR=1,SAVES_LR=1
    .byte   0x80    # STORES_BC=1,FPR_SAVED=0
    .byte   0x00    # GPR_SAVED=0
    .byte   0x00    # FIXEDPARMS=0
    .byte   0x00    # FLOATPARMS=0, PARMSONSTK=0
    .long   0x00000000
    .long   TTB - .sql38aVdcomCall  #TB_OFFSET
    .short  16      # NAME_LEN
    .byte   "sql38aVdcomCall "
    .byte	0		# padding
    .byte	0		# padding
# end of tracetable
.cfi_endproc
&endif

.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
*-PRETTY-*  statements    :
*-PRETTY-*  lines of code :
*-PRETTY-*  lines in file :
.PA 
