.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.tt 1 $SQL$Project Distributed Database System$VPR08$
.tt 2 $$$
.TT 3 $$SQLDB-Program-Conversion$2001-02-01$
***********************************************************
.nf
 
 .nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : Precompiler_Runtime_Routinen
=========
.sp
Purpose : Runtime routines which also used from precompiler.
          Runtime_Routinen die auch der Precompiler
          aufruft.
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        FUNCTION
              p08g1addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
        FUNCTION
              p08g2addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
        FUNCTION
              p08g3addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
        FUNCTION
              p08g4addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
        FUNCTION
              p08g5addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
        FUNCTION
              p08g6addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
        FUNCTION
              p08g7addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
        FUNCTION
              p08g8addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
        FUNCTION
              p08g9addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
        FUNCTION
              p08gaaddr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
        FUNCTION
              p08gbaddr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
        FUNCTION
              p08gcaddr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
        FUNCTION
              p08gdaddr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
        FUNCTION
              p08geaddr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
        FUNCTION
              p08gfaddr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
        FUNCTION
              p08ggaddr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
        FUNCTION
              p08ghaddr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
        PROCEDURE
              p08allocat (length : tsp00_Int4;
                    VAR p : tsp00_ObjAddr;
                    VAR ok : boolean);
 
        PROCEDURE
              p08a1llocat (length : tsp00_Int4;
                    VAR p : tsp00_ObjAddr;
                    VAR ok : boolean);
 
        PROCEDURE
              p08runtimeerror (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    error : tpr_runtime_errors);
&       ifdef NICO
 
        PROCEDURE
              p08analyzeconnectstatm (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR sqlga : sqlgatype;
                    VAR ga : sqlgaentry;
                    VAR ka : sqlkaentry;
                    buflen  : tsp00_Int4;
                    VAR buf : tsp00_MoveObj);
&       endif
 
        PROCEDURE
              p08relsess   (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR ga : sqlgaentry;
                    VAR ka : sqlkaentry);
 
        PROCEDURE
              p08puttracename (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR nam   : tsp00_Name;
                    naml      : tsp00_Int2;
                    trwrite   : boolean);
 
        PROCEDURE
              p08puttraceknlid (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR nam   : tsp00_KnlIdentifier;
                    naml      : tsp00_Int2;
                    trwrite   : boolean);
 
        PROCEDURE
              p08vfwritetrace (sqlrap : sqlrapointer);
 
        PROCEDURE
              p08privicmd (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR ka : sqlkaentry;
                    VAR cmdfetch : tsp00_Int2);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Runtime-Stringroutinen   : VPR05;
 
        PROCEDURE
              p05nextsymbol (VAR buf : tsp00_MoveObj;
                    buflen  : tsp00_Int4;
                    pasanf     : tsp00_Int4;
                    VAR sympos : tsp00_Int4;
                    VAR symlen : tsp00_Int4;
                    VAR symb   : tpr_symbol);
 
        PROCEDURE
              p05up1casebuf (VAR buf : tsp00_MoveObj;
                    lwb : tsp00_Int4;
                    upb : tsp00_Int4);
 
        PROCEDURE
              p05searchword  (VAR buf : tsp00_MoveObj;
                    lwb : integer;
                    upb : integer;
                    word : tsp00_Sname;
                    lw   : integer;
                    VAR pos : integer);
 
        FUNCTION
              p05chrtoint2 (VAR buf : tsp00_MoveObj;
                    pos : integer;
                    len : integer) : integer;
 
        FUNCTION
              p05chtoint4 (VAR buf : tsp00_MoveObj;
                    pos : integer;
                    len : integer) : tsp00_Int4;
 
        FUNCTION
              p05eq (VAR a : tsp00_Sname;
                    VAR b  : tsp00_MoveObj;
                    b_pos  : tsp00_Int4;
                    length : tsp00_Int4) : boolean;
 
      ------------------------------ 
 
        FROM
              C-Type-Checker-Module  : VPR102;
 
        PROCEDURE
              pr03mAllocatP (len : tsp00_Int4;
                    VAR p : tsp00_ObjAddr;
                    nam :tsp00_Name);
 
        PROCEDURE
              p03sqlrelease  (sqlrap : sqlrapointer;
                    sqlgap :sqlgapointer;
                    VAR ga : sqlgaentry;
                    errmsg : sqlempointer);
 
        PROCEDURE
              p03conninfoget (sqlgap : sqlgapointer;
                    VAR ga : sqlgaentry;
                    sess : tsp00_Int2);
 
        PROCEDURE
              p03sqlgaentryinit(VAR ga : sqlgaentry;
                    xuindex : tsp00_Int2;
                    errmsg : sqlempointer);
 
        PROCEDURE
              p03cmdtrace (sqlrap : sqlrapointer;
                    VAR gae : sqlgaentry;
                    nlcnt : tsp00_Int2;
                    comkind : tsp00_Int2;
                    pSQLStatement : tpr05_StringPointer);
 
        PROCEDURE
              p03cseterror (sqlemp : sqlempointer;
                    error : tpr_runtime_errors);
 
        PROCEDURE
              p03initsqlem (VAR sqlem : tpr_sqlerror);
 
        PROCEDURE
              p03tvfwritetrace (sqlrap : sqlrapointer;
                    VAR sqlem : tpr_sqlerror);
 
        PROCEDURE
              pr01TraceRuntimeError (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    error : tpr_runtime_errors);
&       ifdef TRACE
 
        PROCEDURE
              m90int2 (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : tsp00_Int2);
 
        PROCEDURE
              m90int4 (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : tsp00_Int4);
 
        PROCEDURE
              m90int (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : integer);
 
        PROCEDURE
              m90buf  (layer : tsp00_ToolLayer;
                    VAR buf :  tsp00_MoveObj;
                    pos_anf : integer;
                    pos_end : integer);
 
        PROCEDURE
              m90buf1  (layer : tsp00_ToolLayer;
                    VAR buf :  tpr_macroline;
                    pos_anf : integer;
                    pos_end : integer);
 
        PROCEDURE
              m90buf2  (layer : tsp00_ToolLayer;
                    VAR buf :  tsp1_segment;
                    pos_anf : integer;
                    pos_end : integer);
 
        PROCEDURE
              m90name (layer : tsp00_ToolLayer;
                    nam : tsp00_Name);
 
        PROCEDURE
              m90sname (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname);
 
        PROCEDURE
              m90userid  (layer : tsp00_ToolLayer;
                    nam : tsp_username);
 
        PROCEDURE
              m90hexint4 (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : tsp00_Int4);
 
        PROCEDURE
              m90identifier (
                    layer : tsp00_ToolLayer;
                    ident : tsp00_KnlIdentifier);
&       endif
 
      ------------------------------ 
 
        FROM
              SQLDB-Auftrags-Schnittstelle   : VPR03;
 
        PROCEDURE
              p03find_part  (sqlrap : sqlrapointer;
                    part_kind        : tsp1_part_kind;
                    VAR part_ptr     : tsp1_part_ptr);
 
        PROCEDURE
              p03encrypt (VAR nam : tsp00_Name;
                    VAR crypt : tsp00_CryptPw);
 
        PROCEDURE
              p03returncodeget (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype);
 
        PROCEDURE
              p03getparameteraddr (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR paix : integer;
                    VAR cmcnt : integer;
                    VAR vaaddr : tpr_vtypepointer;
                    VAR vaind  : integer;
                    VAR indaddr : tpr_vtypepointer;
                    VAR indind  : integer);
 
      ------------------------------ 
 
        FROM
              Precompiler_ORACLE        : VPR08B;
 
        PROCEDURE
              p08batdbanalyse (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR sypos : tsp00_Int4;
                    VAR sylen : tsp00_Int4;
                    VAR symb  : tpr_symbol;
                    buflen  : tsp00_Int4;
                    VAR buf : tsp00_MoveObj);
 
        PROCEDURE
              p08busingdbanalyse (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR sypos : tsp00_Int4;
                    VAR sylen : tsp00_Int4;
                    VAR symb  : tpr_symbol;
                    buflen  : tsp00_Int4;
                    VAR buf : tsp00_MoveObj);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill   : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;       
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;    
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;    
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30    : VSP30;
 
        FUNCTION
              s30gad (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        FUNCTION
              s30len (VAR str : tpr_valuerec;
                    val : char; cnt : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30lnr1 (VAR str : tsp00_KnlIdentifier;
                    val : char;
                    pos : tsp00_Int4;
                    cnt : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30lnr (VAR str : tpr_valuerec;
                    val : char;
                    pos : tsp00_Int4;
                    cnt : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              RTE_driver       : VEN102;
 
        PROCEDURE
              sqlallocat (length : tsp00_Int4;
                    VAR p : tsp00_ObjAddr;
                    VAR ok  : boolean);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              pr03mAllocatP;
 
              tpr_vtypepointer tsp00_ObjAddr
 
        PROCEDURE
              sqlallocat;
 
              tsp00_Int4        tsp00_Int4
              tsp00_ObjAddr     tsp00_ObjAddr
 
        PROCEDURE
              p05searchword;
 
              tsp00_MoveObj   tsp00_MoveObj
 
        PROCEDURE
              m90userid;
 
              tsp00_KnlIdentifier tsp_username
 
        PROCEDURE
              m90buf1;
 
              tsp00_Buf           tpr_macroline
 
        PROCEDURE
              m90buf2;
 
              tsp00_Buf           tsp1_segment
 
        PROCEDURE
              p05nextsymbol;
 
              tsp00_MoveObj  tsp00_MoveObj
 
        FUNCTION
              p05chrtoint2;
 
              tsp00_MoveObj  tsp00_MoveObj
 
        FUNCTION
              p05chtoint4;
 
              integer      tsp00_Int4
              tsp00_MoveObj  tsp00_MoveObj
 
        PROCEDURE
              s30len;
 
              tsp00_MoveObj  tpr_valuerec
 
        PROCEDURE
              s30lnr1;
 
              tsp00_MoveObj       tsp00_KnlIdentifier
 
        PROCEDURE
              s30klen;
 
              tsp00_MoveObj       tsp00_KnlIdentifier
 
        PROCEDURE
              s30lnr;
 
              tsp00_MoveObj  tpr_valuerec
 
        PROCEDURE
              m90buf;
 
              tsp00_Buf   tsp00_MoveObj
 
        PROCEDURE
              p03encrypt;
 
              tsp00_CryptName     tsp00_CryptPw
 
        FUNCTION
              s30gad;
 
              tsp00_Addr          tpr_intaddr
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1986-04-07
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2001-02-01
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.sp 2
PROCEDURE  P08ALLOCAT:
.sp 2
Allokiert einen Speicherbereich der L?ange length;
.sp 2
PROCEDURE P08A1LLOCAT:
.sp 2
Allokiert einen Speicherbereich der L?ange length;
.sp 2
PROCEDURE  P08TRRUNTIMEERROR:
.sp 2
Procedure replaced by pr01TraceRuntimeError
.sp 4;.cp 6
PROCEDURE  P08RUNTIMEERROR:
.sp 2
Writes a program error to the sqlca area.
If trace output is activate, it is logged there.
.sp 4;.cp 6
PROCEDURE  P08ANALYZECONNECTSTATM:
.sp 2
If no connect has been executed for this session yet,
the instruction is analyzed and the information written
to the SQLGA area.
.sp 4
.cp 4
PROCEDURE  P08NEXTSESSION:
.sp 2
When a new session is specified, checks whether
number is permitted, for oracle or sapr3 mode
if there is an entry in the SQLAT area,
and analyzes the connect instruction.
.sp 4
.cp 4
PROCEDURE  P08RELSESS:
.sp 2
End of a session is recognized when parse ID [11]  =
message type 'commit_release' or 'rollback_release'.
The current session number is terminated normally with
sqlarelease. The flag is set, to make a reconnect for an implicit connect.
.sp 4
.cp 4
PROCEDURE  P08EXPANDPARAMETER:
.sp 2
This procedure is called if a record or array
is specified in an into clause or '??' is specified
in the statement.
.br
It expands the structure
in the request segment from position ppos.
Fetches all names of the structure elements and
writes them as parameters with, if appropriate, indicator
parameters to the request segment.
Anf is set at the position after the expanded structure parameter
in the request.
.sp 4
.cp 4
PROCEDURE  P08PRIVICMD:
.sp 2
SQLDB commands with parse ID [11] as message type no.
.nf
  30  : csp1_p_not_allowed_for_program
  43  : csp1_p_mfetch_found  without array statement
  36  : cpr_m_nolog
  41  : csp1_p_describe_found
are not permitted in the precompiler and supply the
    error -101 'command not availabe in this mode'.
.fo
.sp 4
***********************************************************
.sp 2
 
PROCEDURE
:
.sp 2
Schreibt einen Programmfehler in die sclca-area.
Ist Traceoutput eingeschaltet wird er dort protokolliert.
Zus?atslich wird das Kommando in den Tracefile geschrieben.
.sp 4;.cp 6
PROCEDURE  P08RUNTIMEERROR:
.sp 2
Schreibt einen Programmfehler in die sclca-area.
Ist Traceoutput eingeschaltet wird er dort protokolliert.
.sp 4;.cp 6
PROCEDURE  P08PUTNAME:
.sp 2
Die Procedure setzt an die Position varpos im Var_part einen Namen mit
Expansion von " in "". In len wird die maximale L?ange des Name
im var_part zur?uckgegeben (Anzahl Bytes).
.sp 4
.cp 4
PROCEDURE  P08EXPANDPARAMETER:
.sp 2
Diese Procedure wird aufgerufen, wenn ein Record oder Array
in einer Into-Clause oder '??' im Statement
angegeben wurde.
.br
Sie expandiert im Auftragssegment
von Position ppos die Struktur.
Holt sich alle Namen der Strukturelemente und
schreibt sie als Parameter mit eventuellen Indicatorparametern
in das Auftragssegment.
Anf wird auf die Position nach dem expandierten Strukturparameter
in dem Auftrag gesetzt.
.sp 4
.cp 4
PROCEDURE  P08ANALYZECONNECTSTATM:
.sp 2
Wenn noch kein Connect f?ur diese Session abgesetzt wurde,
wird der Befehl analysiert  und die Informatioen in die SQLGA-Area
geschrieben.
.sp 4
.cp 4
PROCEDURE  P08NEXTSESSION:
.sp 2
Pr?uft bei einer neuen Sessionangabe, ob Nummer erlaubt,
und analysiert den Connect-Befehl.
.sp 4
.cp 4
PROCEDURE  P08RELSESS:
.sp 2
Ende eine Session wird erkannt, wenn Parsid [11]  =
Messagetype 'commit_release' oder 'rollback_release'.
Die Actuelle_sessionnummer wird ordnugs gem?ass mit sqlarelease
abgeschlossen.
.sp 4
.cp 4
PROCEDURE  P08PUTTRACENAME:
.sp 2
Screibt einen Namen in die Traceoutputline. Ist trwrite = true
wird die Zeile in den Trace geschrieben. Ist naml = -1 wird nur eine
Leerzeile in den Trace geschrieben.
.sp 4
.cp 4
PROCEDURE  P08VFWRITETRACE:
.sp 2
Initalisiert einen lokalen Error-Record (wird als Parameter gebraucht) und
schreibt eine Zeile in den Tracefile.
.sp 4
.cp 4
PROCEDURE  P08PRIVICMD:
.sp 2
SQLDB_Kommandos mit Parsid [11]  als Messagetypen
.nf
  30  : csp1_p_not_allowed_for_program
  43  : csp1_p_mfetch_found  ohne Angaben ?uber ein Arraystatement
  36  : cpr_m_nolog
  41  : csp1_p_describe_found
werden im Precompiler nicht zugelassen und liefern den
    Fehler -101 'comand not availabe in this mode'.
.fo
.sp 4
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      leerzeile = -1;
 
 
(*------------------------------*) 
 
FUNCTION
      p08g1addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
BEGIN
p08g1addr := s30gad (a);
END;
 
(*------------------------------*) 
 
FUNCTION
      p08g2addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
BEGIN
p08g2addr := s30gad (a);
END;
 
(*------------------------------*) 
 
FUNCTION
      p08g3addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
BEGIN
p08g3addr := s30gad (a);
END;
 
(*------------------------------*) 
 
FUNCTION
      p08g4addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
BEGIN
p08g4addr := s30gad (a);
END;
 
(*------------------------------*) 
 
FUNCTION
      p08g5addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
BEGIN
p08g5addr := s30gad (a);
END;
 
(*------------------------------*) 
 
FUNCTION
      p08g6addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
BEGIN
p08g6addr := s30gad (a);
END;
 
(*------------------------------*) 
 
FUNCTION
      p08g7addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
BEGIN
p08g7addr := s30gad (a);
END;
 
(*------------------------------*) 
 
FUNCTION
      p08g8addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
BEGIN
p08g8addr := s30gad (a);
END;
 
(*------------------------------*) 
 
FUNCTION
      p08g9addr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
BEGIN
p08g9addr := s30gad (a);
END;
 
(*------------------------------*) 
 
FUNCTION
      p08gaaddr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
BEGIN
p08gaaddr := s30gad (a);
END;
 
(*------------------------------*) 
 
FUNCTION
      p08gbaddr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
BEGIN
p08gbaddr := s30gad (a);
END;
 
(*------------------------------*) 
 
FUNCTION
      p08gcaddr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
BEGIN
p08gcaddr := s30gad (a);
END;
 
(*------------------------------*) 
 
FUNCTION
      p08gdaddr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
BEGIN
p08gdaddr := s30gad (a);
END;
 
(*------------------------------*) 
 
FUNCTION
      p08geaddr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
BEGIN
p08geaddr := s30gad (a);
END;
 
(*------------------------------*) 
 
FUNCTION
      p08gfaddr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
BEGIN
p08gfaddr := s30gad (a);
END;
 
(*------------------------------*) 
 
FUNCTION
      p08ggaddr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
BEGIN
p08ggaddr := s30gad (a);
END;
 
(*------------------------------*) 
 
FUNCTION
      p08ghaddr (VAR a: tsp00_MoveObj): tpr_intaddr;
 
BEGIN
p08ghaddr := s30gad (a);
END;
 
(*------------------------------*) 
 
PROCEDURE
      p08allocat (length : tsp00_Int4;
            VAR p : tsp00_ObjAddr;
            VAR ok : boolean);
 
BEGIN
pr03mAllocatP(length, p, 'p08allocat        ');
IF  p = NIL
THEN
    ok := false
ELSE
    ok := true
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p08a1llocat (length : tsp00_Int4;
            VAR p : tsp00_ObjAddr;
            VAR ok : boolean);
 
BEGIN
pr03mAllocatP(length, p, 'p08allocat        ');
IF  p = NIL
THEN
    ok := false
ELSE
    ok := true
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p08runtimeerror (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            error : tpr_runtime_errors);
 
BEGIN
&ifdef TRACE
m90int2 (pc, 'error       ', ord(error));
&endif
p03cseterror  (sqlca.sqlemp, error);
p03returncodeget (sqlca, sqlxa);
END;
 
(*------------------------------*) 
 
PROCEDURE
      p08getconparameter (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ga : sqlgaentry;
            VAR ka : sqlkaentry;
            VAR param : integer;
            VAR userpassw : tsp00_KnlIdentifier);
 
VAR
      pos : integer;
      len : integer;
      sint   : tsp00_Int2;
      cnt    : integer;
      paind  : integer;
      vaind  : integer;
      indind : integer;
      vaaddr : tpr_vtypepointer;
      vaddr   : tpr_vtypepointer;
      iaddr   : tpr_vtypepointer;
 
BEGIN
WITH sqlca, sqlrap^, sqlxa, sqlgap^, ga DO
    BEGIN
    IF   ralang <> cpr_la_call
    THEN
        BEGIN
        (* hole wert aus hostvariable *)
        paind  := ka.kapaindex + param;
        p03getparameteraddr (sqlca, sqlxa, paind (* paindex *),
              cnt, vaddr, vaind,
              iaddr, indind );
&       ifdef TRACE
        m90int  (pc, 'paind       ', paind );
        m90int  (pc, 'param       ', param );
        m90int  (pc, 'cnt         ', cnt   );
        m90int  (pc, 'vaind       ', vaind   );
        m90int  (pc, 'indind      ', indind  );
        m90int  (pc, 'vaddr       ', vaddr.intaddr );
        m90int  (pc, 'iaddr       ', iaddr.intaddr );
&       endif
        paind := paind + 1;
        param := paind - ka.kapaindex;
        vaaddr  := vaddr;
        WITH sqlv1p^ [vaind ], sqlv2p^ [va1indva2_sc] DO
            BEGIN
            userpassw := bsp_c64;
            len := va2size;
            IF   va2typ = cpr_vcharc
            THEN
                BEGIN
                IF  va2size = cpr_pointerlen
                THEN
                    len := mxsp_c40;
                (*ENDIF*) 
                len := s30len (vaaddr.vtypep^, chr(0), len);
                END;
            (*ENDIF*) 
            IF   len  > mxsp_c40
            THEN
                len := mxsp_c40;
            (*ENDIF*) 
            IF   (va2typ = cpr_vchar) OR (va2typ = cpr_vbchar)
                OR (va2typ = cpr_vcharc)
                OR (va2typ = cpr_vbuf)
            THEN
                s10mv (mxsp_c40, mxsp_c64,
                      @vaaddr.vtypep^.ch, 1,
                      @userpassw, 1, len)
            ELSE
                IF  (va2typ = cpr_vstring)
                    OR  (va2typ = cpr_vstring1)
                THEN
                    BEGIN
                    IF  (va2typ <> cpr_vstring1)
                    THEN
                        BEGIN
                        s10mv (mxsp_c2, mxsp_c2, @vaaddr.vtypep^, 1,
                              @sint, 1, mxsp_c2);
                        pos := 3;
                        END
                    ELSE
                        BEGIN
                        sint := ord (vaaddr.vtypep^.buf[1]);
                        pos  := 2;
                        END;
                    (*ENDIF*) 
                    len := sint;
                    IF   len  > mxsp_c40
                    THEN
                        len := mxsp_c40;
&                   ifdef TRACE
                    (*ENDIF*) 
                    m90int2 (pc, 'movc13 len  ', len);
                    m90int2 (pc, 'pos         ', pos);
&                   endif
                    s10mv (mxsp_c40+2, mxsp_c64,
                          @vaaddr.vtypep^.ch, pos,
                          @userpassw, 1, len)
                    END
                ELSE
                    pr01TraceRuntimeError (sqlca, sqlxa, cpr_paramlist_wrong);
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
&ifdef NICO
(*------------------------------*) 
 
PROCEDURE
      p08analyzeconnectstatm (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR sqlga : sqlgatype;
            VAR ga : sqlgaentry;
            VAR ka : sqlkaentry;
            buflen  : tsp00_Int4;
            VAR buf : tsp00_MoveObj);
 
CONST
      n_iso_le = ' ISOLATION LEVEL  ';
      l_lock   = 18;
 
VAR
      pos   : tsp00_Int4;
      sypos : tsp00_Int4;
      sylen : tsp00_Int4;
      symb  : tpr_symbol;
      v_conn : tsp00_Sname;
      v_conn1: tsp00_Sname;
      v_time : tsp00_Sname;
      param  : integer;
      passw  : tsp00_Name;
      i      : integer;
      j      : integer;
      len    : integer;
      varplen: tsp00_Int2;
      level  : tsp00_Int2;
      mode   : tsp00_Int2;
      ansi   : tsp00_Int2;
      userpassw : tsp00_KnlIdentifier;
      passwfound: boolean;
 
BEGIN
WITH sqlca, sqlrap^, sqlxa, ga, gaxuserrec DO
    IF  (sqlcode  = 0)
    THEN
        IF  (gareference <> 0)
        THEN
            pr01TraceRuntimeError (sqlca, sqlxa,
                  cpr_session_already_connected )
        ELSE
            BEGIN
&           ifdef TRACE
            m90int2(pc, 'xu_timeout  ', xu_timeout );
            m90int2(pc, 'gamodisolati', gamodisolation );
            m90int2(pc, 'gaxu_isolat ', gaopxuserrec.xu_isolation);
            m90int2(pc, 'sqldbmode   ', ord(sqldbmode));
            IF   buflen > 0
            THEN
                m90buf (pc, buf, 1, buflen);
&           endif
            (*ENDIF*) 
            p05up1casebuf (buf, 1, buflen);
            p05nextsymbol (buf, buflen, 1,
                  sypos, sylen, symb);
            passwfound := false;
            v_conn     := 'CONNECT     ';
            v_conn1    := 'CONNECT:    ';
            IF  ((sylen = 7) AND p05eq (v_conn, buf, sypos, 7))
                OR ((sylen = 8) AND p05eq (v_conn1, buf, sypos, 8))
            THEN
                BEGIN
                param := 0;
                (* user *)
                p05nextsymbol (buf, buflen, sypos+sylen,
                      sypos, sylen, symb);
                IF   symb = cpr_s_parameter_name
                THEN
                    BEGIN
                    IF   ralang <> cpr_la_call
                    THEN
                        BEGIN
                        (* hole wert aus hostvariable *)
                        (*            param := param + 1;  *)
                        p08getconparameter (sqlca, sqlxa, ga, ka, param, userpassw);
                        IF  (userpassw [1] = '/')
                            AND  (userpassw [2] = ' ')
                        THEN
                            BEGIN
                            passwfound := true;
                            IF  (sqlga.gauseropset = cpr_is_false)
                                OR (raactsession <> cpr_se_primary)
                            THEN
                                p03sqlgaentryinit  (ga, raactsession, sqlemp);
                            (*ENDIF*) 
                            END
                        ELSE
                            BEGIN
                            xu_user := bsp_knl_identifier;
                            i := 1;
                            WHILE ((userpassw [i] <> '/') AND
                                  (i <= mxsp_c64 -1)) DO
                                BEGIN
                                xu_user [i] := userpassw [i];
                                i := i + 1;
                                END;
                            (*ENDWHILE*) 
                            IF  (userpassw [i] = '/')
                            THEN
                                BEGIN
                                passwfound := true;
                                i := i + 1;
                                j := 1;
                                passw := bsp_name;
                                WHILE ((i <= mxsp_c64)
                                      AND (j <= mxsp_name))  DO
                                    BEGIN
                                    passw [j] := userpassw [i];
                                    i := i + 1;
                                    j := j + 1;
                                    END;
                                (*ENDWHILE*) 
                                p03encrypt (passw, xu_password);
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
&                   ifdef TRACE
                    m90int (pc, 'symb        ', ord (symb) );
                    m90int (pc, 'sylen       ', sylen );
                    m90int2(pc, 'sypos       ', sypos  );
&                   endif
                    IF   sylen > mxsp_c64
                    THEN
                        len := mxsp_c64
                    ELSE
                        len := sylen;
                    (*ENDIF*) 
                    xu_user := bsp_knl_identifier;
                    FOR i := 1 TO len  DO
                        xu_user  [i]  := buf [ sypos+i-1] ;
                    (*ENDFOR*) 
                    IF  buf [sypos-1] = '"'
                    THEN
                        sylen := sylen + 1;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                (* identified *)
                p05nextsymbol (buf, buflen, sypos+sylen+1,
                      sypos, sylen, symb);
                IF  passwfound
                THEN
                    (* implicites connect *)
                    sqlga.gasqlconntyp := cpr_ci_ora_connect
                ELSE
                    BEGIN
                    passw := bsp_name;
                    IF   symb <> cpr_s_eof
                    THEN
                        BEGIN
                        v_conn := 'IDENTIFIED  ';
                        IF  (sylen = 10) AND p05eq (v_conn, buf, sypos, 10)
                        THEN
                            BEGIN
                            (* by  *)
                            p05nextsymbol (buf, buflen, sypos+sylen,
                                  sypos, sylen, symb);
                            (* password  *)
                            p05nextsymbol (buf, buflen, sypos+sylen,
                                  sypos, sylen, symb);
                            IF   symb = cpr_s_parameter_name
                            THEN
                                BEGIN
                                IF   ralang <>  cpr_la_call
                                THEN
                                    BEGIN
                                    (* hole wert aus hostvariable *)
                                    (*        param := param + 1;  *)
                                    p08getconparameter (sqlca, sqlxa, ga, ka,
                                          param, userpassw);
                                    s10mv (mxsp_c64, mxsp_name,
                                          @userpassw, 1, @passw, 1, mxsp_name);
                                    p03encrypt (passw, xu_password);
                                    END
                                (*ENDIF*) 
                                END
                            ELSE
                                BEGIN
                                IF   sylen > mxsp_name
                                THEN
                                    len := mxsp_name
                                ELSE
                                    len := sylen;
                                (*ENDIF*) 
                                passw := bsp_name;
                                FOR i := 1 TO len  DO
                                    passw  [i]  := buf [ sypos+i-1] ;
                                (*ENDFOR*) 
                                IF  buf [sypos-1] = '"'
                                THEN
                                    sylen := sylen + 1;
                                (*ENDIF*) 
                                p03encrypt (passw, xu_password);
&                               ifdef TRACE
                                m90int (pc, 'sypos       ', sypos );
                                m90int (pc, 'sylen       ', sylen );
                                m90int (pc, 'symb        ', ord (symb) );
                                m90int (pc, 'len         ', len   );
                                m90identifier (pc, xu_user);
                                m90name (pc, passw);
&                               endif
                                END;
                            (*ENDIF*) 
                            (* lock  *)
                            p05nextsymbol (buf, buflen, sypos+sylen+1,
                                  sypos, sylen, symb);
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END; (* passwfound *)
                (*ENDIF*) 
                v_conn   := 'SQLMODE     ';
                IF   symb <> cpr_s_eof
                THEN
                    IF   (sylen = 7) AND p05eq (v_conn, buf, sypos, 7)
                    THEN
                        BEGIN
                        (* sqlmode  *)
                        p05nextsymbol (buf, buflen, sypos+sylen,
                              sypos, sylen, symb);
                        IF  ralang <> cpr_la_call
                        THEN
                            pr01TraceRuntimeError (sqlca, sqlxa,
                                  cpr_connect_syntax_wrong)
                        ELSE
                            BEGIN
                            mode := cpr_kind_empty;
                            ansi := cpr_kind_empty;
                            CASE buf [sypos] OF
                                'S' :
                                    BEGIN
                                    v_conn   := 'SQL-DB      ';
                                    IF   (sylen = 6) AND p05eq (v_conn, buf, sypos, 6)
                                    THEN
                                        BEGIN
                                        mode := cpr_kind_internal;
                                        sylen := 6;
                                        END
                                    ELSE
                                        BEGIN
                                        v_conn   := 'SAPR3       ';
                                        IF   (sylen = 5) AND p05eq (v_conn, buf, sypos, 5)
                                        THEN
                                            mode := cpr_kind_sapr3;
                                        (*ENDIF*) 
                                        END;
                                    (*ENDIF*) 
                                    END;
                                'D' :
                                    BEGIN
                                    v_conn   := 'DB2         ';
                                    IF   (sylen = 3) AND p05eq (v_conn, buf, sypos, 3)
                                    THEN
                                        mode := cpr_kind_db2;
                                    (*ENDIF*) 
                                    END;
                                'A', 'I' :
                                    BEGIN
                                    IF  buf [sypos] = 'A'
                                    THEN
                                        BEGIN
                                        v_conn   := 'ADABAS      ';
                                        len := 6;
                                        END
                                    ELSE
                                        BEGIN
                                        v_conn   := 'INTERNAL    ';
                                        len := 8;
                                        END;
                                    (*ENDIF*) 
                                    IF   (sylen = len) AND p05eq (v_conn, buf, sypos, 6)
                                    THEN
                                        BEGIN
                                        mode := cpr_kind_internal;
                                        END
                                    ELSE
                                        BEGIN
                                        v_conn   := 'ANSI        ';
                                        IF   (sylen = 4) AND p05eq (v_conn,buf, sypos, 4)
                                        THEN
                                            BEGIN
                                            mode := cpr_kind_internal;
                                            ansi := cpr_kind_ansi;
                                            END
                                        ELSE
                                            BEGIN
                                            v_conn   := 'ANSIORA     ';
                                            IF   (sylen = 7) AND p05eq (v_conn, buf,
                                                sypos, 7)
                                            THEN
                                                BEGIN
                                                mode := cpr_kind_oracle;
                                                ansi := cpr_kind_ansi;
                                                END
                                            (*ENDIF*) 
                                            END;
                                        (*ENDIF*) 
                                        END;
                                    (*ENDIF*) 
                                    END;
                                'O' :
                                    BEGIN
                                    v_conn   := 'ORACLE      ';
                                    IF   (sylen = 6) AND p05eq (v_conn, buf, sypos, 6)
                                    THEN
                                        mode := cpr_kind_oracle;
                                    (*ENDIF*) 
                                    END;
                                OTHERWISE:
                                    mode := cpr_kind_empty;
                                END;
                            (*ENDCASE*) 
                            IF  sqldbmode = cpr_kind_empty
                            THEN
                                BEGIN
                                sqldbmode := mode;
                                rasqlansi := ansi;
                                END
                            ELSE
                                IF  (sqldbmode <> mode)
                                    OR (rasqlansi <> ansi)
                                    OR (mode = cpr_kind_empty)
                                THEN
                                    pr01TraceRuntimeError (sqlca, sqlxa,
                                          cpr_differ_sqlmode_not_allowed)
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        (* lese next keyword *)
                        p05nextsymbol (buf, buflen, sypos+sylen,
                              sypos, sylen, symb);
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                v_conn   := 'NOLOG       ';
                IF   symb <> cpr_s_eof
                THEN
                    IF   (sylen = 5) AND p05eq (v_conn, buf, sypos, 5)
                    THEN
                        BEGIN
                        (* sqlmode  *)
                        p05nextsymbol (buf, buflen, sypos+sylen,
                              sypos, sylen, symb);
                        ganolog := cpr_is_true;
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  rasqlansi = cpr_kind_ansi
                THEN
                    xu_isolation := cpr_lo_isolev3
                ELSE
                    xu_isolation := cpr_lo_isolev10;
                (*ENDIF*) 
                varplen := sypos - 1;
                IF   symb <> cpr_s_eof
                THEN
                    BEGIN
                    v_conn   := 'LOCK        ';
                    IF   (sylen = 4) AND p05eq (v_conn, buf, sypos, 4)
                    THEN
                        BEGIN
                        (* lockset  *)
                        p05nextsymbol (buf, buflen, sypos+sylen,
                              sypos, sylen, symb);
                        v_conn   := 'NORMAL      ';
                        IF   (sylen = 6) AND p05eq (v_conn, buf, sypos, 6)
                        THEN
                            xu_isolation := cpr_lo_isolev10
                        ELSE
                            BEGIN
                            v_conn := 'EXPLICIT    ';
                            IF   (sylen = 8) AND p05eq (v_conn, buf, sypos, 8)
                            THEN
                                xu_isolation := cpr_lo_isolev0
                            ELSE
                                BEGIN
                                v_conn := 'IMPLICIT    ';
                                IF   (sylen = 8) AND p05eq (v_conn, buf, sypos, 8)
                                THEN
                                    xu_isolation := cpr_lo_isolev20
                                ELSE
                                    pr01TraceRuntimeError (sqlca, sqlxa,
                                          cpr_connect_syntax_wrong);
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        p05nextsymbol (buf, buflen, sypos+sylen,
                              sypos, sylen, symb);
                        END
                    ELSE
                        BEGIN
                        v_conn   := 'ISOLATION   ';
                        IF   (sylen = 9) AND p05eq (v_conn, buf, sypos, 9)
                        THEN
                            BEGIN
                            (* isolation level   *)
                            p05nextsymbol (buf, buflen, sypos+sylen,
                                  sypos, sylen, symb);
                            v_conn   := 'LEVEL       ';
                            IF   (sylen = 5) AND p05eq (v_conn, buf, sypos, 5)
                            THEN
                                BEGIN
                                IF  rasqlansi = cpr_kind_ansi
                                THEN
                                    xu_isolation := cpr_lo_isolev3
                                ELSE
                                    xu_isolation := cpr_lo_isolev10;
                                (*ENDIF*) 
                                (* level <n> *)
                                p05nextsymbol (buf, buflen, sypos+sylen,
                                      sypos, sylen, symb);
                                IF   symb = cpr_s_unsigned_integer
                                THEN
                                    BEGIN
                                    level := p05chrtoint2 (buf, sypos, sylen);
                                    IF  NOT (level in [cpr_lo_isolev0,
                                        cpr_lo_isolev1,
                                        cpr_lo_isolev2, cpr_lo_isolev3,
                                        cpr_lo_isolev4, cpr_lo_isolev9,
                                        cpr_lo_isolev10, cpr_lo_isolev15,
                                        cpr_lo_isolev20, cpr_lo_isolev30])
                                    THEN
                                        BEGIN
                                        pr01TraceRuntimeError (sqlca, sqlxa,
                                              cpr_connect_syntax_wrong);
                                        END
                                    ELSE
                                        xu_isolation := level;
                                    (*ENDIF*) 
                                    p05nextsymbol (buf, buflen, sypos+sylen,
                                          sypos, sylen, symb);
                                    END
                                ELSE
                                    pr01TraceRuntimeError (sqlca, sqlxa,
                                          cpr_connect_syntax_wrong)
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF   symb <> cpr_s_eof
                THEN
                    BEGIN
                    v_time   := 'TIMEOUT     ';
                    IF   (sylen = 7) AND p05eq (v_time, buf, sypos, 7)
                    THEN
                        BEGIN
                        (* time   *)
                        p05nextsymbol (buf, buflen, sypos+sylen,
                              sypos, sylen, symb);
                        IF   symb = cpr_s_unsigned_integer
                        THEN
                            BEGIN
                            xu_timeout :=  p05chrtoint2 (buf, sypos, sylen);
                            p05nextsymbol (buf, buflen, sypos+sylen,
                                  sypos, sylen, symb);
                            END
                        ELSE
                            pr01TraceRuntimeError (sqlca, sqlxa,
                                  cpr_connect_syntax_wrong)
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF   symb <> cpr_s_eof
                THEN
                    BEGIN
                    v_time   := 'CACHELIMIT  ';
                    IF   (sylen = 10) AND p05eq (v_time, buf, sypos, 10)
                    THEN
                        BEGIN
                        (* cachelimit   *)
                        p05nextsymbol (buf, buflen, sypos+sylen,
                              sypos, sylen, symb);
                        IF   symb = cpr_s_unsigned_integer
                        THEN
                            BEGIN
                            xu_cachelimit :=  p05chtoint4 (buf, sypos, sylen);
                            p05nextsymbol (buf, buflen, sypos+sylen,
                                  sypos, sylen, symb);
                            END
                        ELSE
                            pr01TraceRuntimeError (sqlca, sqlxa,
                                  cpr_connect_syntax_wrong)
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF   symb <> cpr_s_eof
                THEN
                    BEGIN
                    v_time   := 'AT          ';
                    IF   (sylen = 2) AND p05eq (v_time, buf, sypos, 2)
                    THEN
                        BEGIN
                        (* at   *)
                        IF  ((sqldbmode = cpr_kind_oracle)
                            OR (sqldbmode = cpr_kind_sapr3))
                            AND (racomponent [1] <> 'R')
                        THEN
                            BEGIN
                            sqlga.gasqlconntyp := cpr_ci_ora_connect;
                            p08batdbanalyse (sqlca, sqlxa,
                                  sypos, sylen, symb, buflen, buf);
                            END
                        ELSE
                            pr01TraceRuntimeError (sqlca, sqlxa,
                                  cpr_connect_syntax_wrong)
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF   symb <> cpr_s_eof
                THEN
                    BEGIN
                    v_time   := 'USING       ';
                    IF   (sylen = 5) AND p05eq (v_time, buf, sypos, 5)
                    THEN
                        BEGIN
                        (* using *)
                        IF  (sqldbmode = cpr_kind_oracle)
                            OR (sqldbmode = cpr_kind_sapr3)
                        THEN
                            BEGIN
                            sqlga.gasqlconntyp := cpr_ci_ora_connect;
                            p08busingdbanalyse (sqlca, sqlxa, sypos, sylen,
                                  symb, buflen, buf );
                            END
                        ELSE
                            pr01TraceRuntimeError (sqlca, sqlxa,
                                  cpr_connect_syntax_wrong)
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                v_conn   := 'CHARACTER   ';
                IF   symb <> cpr_s_eof
                THEN
                    IF   (sylen = 9) AND p05eq (v_conn, buf, sypos, 9)
                    THEN
                        BEGIN
                        xu_dblang := bsp_knl_identifier;
                        p05nextsymbol (buf, buflen, sypos+sylen,
                              sypos, sylen, symb);
                        v_conn   := 'SET         ' ;
                        IF   (sylen = 3) AND p05eq (v_conn, buf, sypos, 3)
                        THEN
                            p05nextsymbol (buf, buflen, sypos+sylen,
                                  sypos, sylen, symb);
                        (*ENDIF*) 
                        i := 1;
                        pos := sypos;
                        REPEAT
                            xu_dblang [i] := buf [pos];
                            i := i + 1;
                            pos := pos + 1;
                        UNTIL
                            (i > mxsp_c64) OR (buf[pos] = bsp_c1)
                            OR (pos > buflen) OR (buf[pos] = chr (0));
                        (*ENDREPEAT*) 
                        IF  (buf[pos] <> bsp_c1)
                            AND (i > mxsp_c64)
                        THEN
                            pr01TraceRuntimeError (sqlca, sqlxa,
                                  cpr_multibyteset_not_allowed);
                        (*ENDIF*) 
                        sypos := pos;
                        sylen := 0;
                        (*****
                              v_conn   := 'JA_JPN      ';
                              IF   p05eq (v_conn, buf, sypos, 6)
                              THEN
                              BEGIN
                              p05nextsymbol (buf, buflen, sypos+sylen,
                              sypos, sylen, symb);
                              p05nextsymbol (buf, buflen, sypos+sylen,
                              sypos, sylen, symb);
                              v_conn   := 'SJIS        ';
                              IF   p05eq (v_conn, buf, sypos, 4)
                              THEN
                              xu_dblang := 'JA_JPN.SJIS       '
                              ELSE
                              BEGIN
                              v_conn   := 'EUC         ';
                              IF   p05eq (v_conn, buf, sypos, 3)
                              THEN
                              xu_dblang := 'JA_JPN.EUC        '
                              ELSE
                              pr01TraceRuntimeError (sqlca, sqlxa,
                              cpr_multibyteset_not_allowed)
                              END;
                              END;
                              *********)
                        (* lese next keyword *)
                        p05nextsymbol (buf, buflen, sypos+sylen,
                              sypos, sylen, symb);
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF   symb <> cpr_s_eof
                THEN
                    IF  sqlcode = 0
                    THEN
                        pr01TraceRuntimeError (sqlca, sqlxa,
                              cpr_connect_syntax_wrong);
                    (*ENDIF*) 
                (*ENDIF*) 
                buflen := varplen;
                END;
&           ifdef TRACE
            (*ENDIF*) 
            m90int (pc, 'sypos       ', sypos );
            m90int (pc, 'sylen       ', sylen );
            m90int (pc, 'symb        ', ord (symb) );
            m90int (pc, 'actual_sess ', raactsession);
            m90int2(pc, 'xu_timeout  ', xu_timeout );
            m90int2(pc, 'gamodisolati', gamodisolation );
            m90int2(pc, 'xu_isolation', xu_isolation);
            m90int2(pc, 'xuopisolatio', gaopxuserrec.xu_isolation);
            m90identifier (pc, xu_user);
            m90name (pc, passw);
            m90sname (pc, v_conn);
&           endif
            p03conninfoget (sqlgap, ga, raactsession);
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
&endif
(*------------------------------*) 
 
PROCEDURE
      p08relsess   (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ga : sqlgaentry;
            VAR ka : sqlkaentry);
 
BEGIN
WITH sqlca, sqlxa DO
    IF   sqlcode  = 0
    THEN
        BEGIN
        IF   (ord(ka.kaParseInfo.ParseId[cpr_p_precom_index] )= csp1_p_release_found)
        THEN
            BEGIN
            p03sqlrelease (sqlrap, sqlgap, ga, sqlemp);
            IF  (sqldbmode IN [cpr_kind_oracle, cpr_kind_sapr3])
            THEN
                (* f?ur  neue option erkennung *)
                ga.gareconnect := cpr_is_true;
            (*ENDIF*) 
            sqlrap^.raactsession := cpr_se_empty;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p08puttracename (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR nam   : tsp00_Name;
            naml      : tsp00_Int2;
            trwrite   : boolean);
 
BEGIN
WITH sqlca, sqlxa, sqlrap^, rasqltap^  DO
    BEGIN
    IF  naml > 0
    THEN
        BEGIN
        s10mv (mxsp_name, mxsp_c256, @nam, 1,
              @tastr80, tastr80l+1, naml);
        tastr80l := tastr80l + naml;
        END;
    (*ENDIF*) 
    IF  trwrite
    THEN
        BEGIN
        (* naml ::= -1  leerzeile ausgeben *)
        IF  naml = leerzeile
        THEN
            BEGIN
            tastr80l := 1;
            tastr80  [1]  := bsp_c1;
            END;
        (*ENDIF*) 
        p08vfwritetrace (sqlca.sqlrap);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p08puttraceknlid (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR nam   : tsp00_KnlIdentifier;
            naml      : tsp00_Int2;
            trwrite   : boolean);
 
VAR
      len : tsp00_Int2;
 
BEGIN
WITH sqlca, sqlxa, sqlrap^, rasqltap^  DO
    BEGIN
    IF  naml > 0
    THEN
        BEGIN
        len := s30lnr1 (nam, bsp_c1, 1, sizeof(tsp00_KnlIdentifier));
        IF  len < mxsp_name
        THEN
            len := mxsp_name;
        (*ENDIF*) 
        IF  len + tastr80l+1  > mxsp_c256
        THEN
            p08vfwritetrace (sqlca.sqlrap);
        (*ENDIF*) 
        s10mv (sizeof(tsp00_KnlIdentifier), mxsp_c256, @nam, 1,
              @tastr80, tastr80l+1, len);
        tastr80l := tastr80l + len;
        END;
    (*ENDIF*) 
    IF  trwrite
    THEN
        BEGIN
        (* naml ::= -1  leerzeile ausgeben *)
        IF  naml = leerzeile
        THEN
            BEGIN
            tastr80l := 1;
            tastr80  [1]  := bsp_c1;
            END;
        (*ENDIF*) 
        p08vfwritetrace (sqlca.sqlrap);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p08vfwritetrace (sqlrap : sqlrapointer);
 
VAR
      sqlem   : tpr_sqlerror;
 
BEGIN
p03initsqlem (sqlem);
p03tvfwritetrace (sqlrap, sqlem);
END;
 
(*------------------------------*) 
 
PROCEDURE
      p08privicmd (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ka : sqlkaentry;
            VAR cmdfetch : tsp00_Int2);
 
VAR
      mtyp : integer;
      ind  : integer;
 
BEGIN
WITH sqlca, sqlxa DO
    IF   sqlcode = 0
    THEN
        BEGIN
        mtyp := ord(ka.kaParseInfo.ParseId[cpr_p_precom_index] );
&       ifdef TRACE
        m90int (pc, 'mtyp        ', mtyp);
&       endif
        CASE mtyp OF
            cpr_m_nolog,
            csp1_p_not_allowed_for_program ,
            csp1_p_describe_found  :
                p08runtimeerror (sqlca, sqlxa, cpr_cmd_not_available);
            csp1_p_mfetch_found  :
                BEGIN
                IF  ka.kapaindex > 0
                THEN
                    ind :=   ka.kapaindex
                ELSE
                    ind := - ka.kapaindex;
                (*ENDIF*) 
                IF  false AND (ind > 0)
                THEN
                    WITH sqlpap^ [ind ]  DO
                        IF  (cmdfetch = cpr_is_false)
                            AND (pakindlo <> sqlparlo)
                        THEN
                            p08runtimeerror (sqlca, sqlxa,
                                  cpr_cmd_not_available);
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (*ENDIF*) 
                END;
            OTHERWISE:
                BEGIN
                END;
            END;
        (*ENDCASE*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
