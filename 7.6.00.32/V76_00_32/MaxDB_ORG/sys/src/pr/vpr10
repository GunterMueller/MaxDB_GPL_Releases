.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.tt 1 $SQL$Project Distributed Database System$VPR10$
.tt 2 $$$
.TT 3 $$SQLDB-Call-Interface$2001-01-02$
***********************************************************
.nf
 
 .nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : SQLDB-Call-Interface
=========
.sp
Purpose : SQLDB Call Interface.
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              p10connect  (VAR sqcca    : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcdbno   : tsp00_Int2;
                    VAR sqcdbnode : tsp00_NodeId;
                    VAR sqcdbname : tsp00_DbName;
                    VAR sqcstmlen : tsp00_Int4;
                    VAR sqcstmbuf : tsp00_MoveObj;
                    encodingType : tpr05_StringEncoding;
                    VAR sqcuser   : tsp00_KnlIdentifier;
                    VAR sqcpassw  : tpr_password);
 
        PROCEDURE
              p10statement  (VAR sqcca  : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcdbno   : tsp00_Int2;
                    VAR sqcstmlen : tsp00_Int4;
                    VAR sqcstmbuf : tsp00_MoveObj;
                    encodingType : tpr05_StringEncoding);
 
        PROCEDURE
              p10parcc   (VAR sqcca   : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcdbno   : tsp00_Int2;
                    VAR sqcstmlen : tsp00_Int4;
                    VAR sqcstmbuf : tsp00_MoveObj;
                    encodingType : tpr05_StringEncoding;
                    VAR sqcda     : sqldavrec;
                    VAR sqcparsid : tpr_parsid);
 
        PROCEDURE
              p10parse    (VAR sqcca    : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcdbno   : tsp00_Int2;
                    VAR sqcstmlen : tsp00_Int4;
                    VAR sqcstmbuf : tsp00_MoveObj;
                    encodingType : tpr05_StringEncoding;
                    VAR sqcda     : sqldavrec;
                    VAR sqcparsid : tpr_parsid);
 
        PROCEDURE
              p10pars1    (VAR sqcca    : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcdbno   : tsp00_Int2;
                    VAR sqcstmlen : tsp00_Int4;
                    VAR sqcstmbuf : tsp00_MoveObj;
                    encodingType : tpr05_StringEncoding;
                    VAR sqcda     : sqldavrec;
                    VAR sqcparsid : tpr_parsid);
 
        PROCEDURE
              p10execute  (VAR sqcca    : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcdbno   : tsp00_Int2;
                    VAR sqcstmlen : tsp00_Int4;
                    VAR sqcstmbuf : tsp00_MoveObj;
                    encodingType : tpr05_StringEncoding;
                    VAR sqcda     : sqldavrec;
                    VAR sqcparsid : tpr_parsid;
                    sqcrowcount   : tsp00_Int4);
 
        PROCEDURE
              p10forexecute  (VAR sqcca   : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcdbno   : tsp00_Int2;
                    VAR sqcstmlen : tsp00_Int4;
                    VAR sqcstmbuf : tsp00_MoveObj;
                    encodingType : tpr05_StringEncoding;
                    VAR sqcda     : sqldavrec;
                    VAR sqcparsid : tpr_parsid;
                    VAR for_count  : tsp00_Int2;
                    VAR offset_index : tsp00_Int2;
                    sqcrowcount   : tsp00_Int4);
 
        PROCEDURE
              p10putlongdata  (VAR sqcca   : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcdbno   : tsp00_Int2;
                    VAR sqcvarno  : tsp00_Int2;
                    VAR sqcda     : sqldavrec;
                    VAR sqcparsid : tpr_parsid);
 
        PROCEDURE
              p10getlongdata  (VAR sqcca   : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcdbno   : tsp00_Int2;
                    VAR sqcvarno  : tsp00_Int2;
                    VAR sqcda     : sqldavrec;
                    VAR sqcparsid : tpr_parsid);
 
        PROCEDURE
              p10setmacro    (VAR sqcca : sqlcatype;
                    VAR macrono   : tsp00_Int2;
                    VAR macroval  : tpr_macroline);
 
        PROCEDURE
              p10dropparsid  (VAR sqcca : sqlcatype;
                    gae : sqlgaentrypointer;
                    VAR sqcdbno   : tsp00_Int2;
                    VAR sqcparsid : tpr_parsid);
 
        PROCEDURE
              p10release  (VAR sqcca   : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcdbno  : tsp00_Int2);
 
        PROCEDURE
              p10cancel  (VAR sqcca   : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcdbno   : tsp00_Int2);
 
        PROCEDURE
              p10finish  (VAR sqcca   : sqlcatype);
 
        PROCEDURE
              p10getinfo  (VAR sqcca    : sqlcatype;
                    VAR sqcvarno  : tsp00_Int2;
                    VAR sqcvarinfo: sqlvarvrec;
                    VAR sqcda     : sqldavrec;
                    VAR sqcerr    : tsp00_Int2);
 
        PROCEDURE
              p10putinfo  (VAR sqcca    : sqlcatype;
                    VAR sqcvarno  : tsp00_Int2;
                    VAR sqcvarinfo: sqlvarvrec;
                    VAR sqcda     : sqldavrec;
                    VAR sqcerr    : tsp00_Int2);
 
        PROCEDURE
              p10int2bind  (VAR sqcca   : sqlcatype;
                    VAR sqcvarno  : tsp00_Int2;
                    VAR varint2   : tsp00_Int2;
                    VAR sqcda     : sqldavrec;
                    VAR sqcerr    : tsp00_Int2);
 
        PROCEDURE
              p10int4bind  (VAR sqcca   : sqlcatype;
                    VAR sqcvarno  : tsp00_Int2;
                    VAR varint4   : tsp00_Int4;
                    VAR sqcda     : sqldavrec;
                    VAR sqcerr    : tsp00_Int2);
 
        PROCEDURE
              p10uns2bind  (VAR sqcca   : sqlcatype;
                    VAR sqcvarno  : tsp00_Int2;
                    VAR varuns2   : tsp00_Int2;
                    VAR sqcda     : sqldavrec;
                    VAR sqcerr    : tsp00_Int2);
 
        PROCEDURE
              p10uns4bind  (VAR sqcca   : sqlcatype;
                    VAR sqcvarno  : tsp00_Int2;
                    VAR varuns4   : tsp00_Int4;
                    VAR sqcda     : sqldavrec;
                    VAR sqcerr    : tsp00_Int2);
 
        PROCEDURE
              p10r4bind  (VAR sqcca     : sqlcatype;
                    VAR sqcvarno  : tsp00_Int2;
                    VAR varreal4  : tsp00_Shortreal;
                    VAR sqcda     : sqldavrec;
                    VAR sqcerr    : tsp00_Int2);
 
        PROCEDURE
              p10r8bind  (VAR sqcca     : sqlcatype;
                    VAR sqcvarno  : tsp00_Int2;
                    VAR varreal8  : tsp00_Longreal;
                    VAR sqcda     : sqldavrec;
                    VAR sqcerr    : tsp00_Int2);
 
        PROCEDURE
              p10charbind  (VAR sqcca   : sqlcatype;
                    VAR sqcvarno  : tsp00_Int2;
                    VAR varcharlen: tsp00_Int4;
                    VAR varchar   : tpr_char_array;
                    VAR sqcda     : sqldavrec;
                    VAR sqcerr    : tsp00_Int2);
 
        PROCEDURE
              p10ccharbind  (VAR sqcca   : sqlcatype;
                    VAR sqcvarno   : tsp00_Int2;
                    VAR varccharlen: tsp00_Int4;
                    VAR varcchar  : tpr_char_array;
                    VAR sqcda     : sqldavrec;
                    VAR sqcerr    : tsp00_Int2);
 
        PROCEDURE
              p10zonedbind  (VAR sqcca   : sqlcatype;
                    VAR sqcvarno   : tsp00_Int2;
                    VAR varzonedlen: tsp00_Int2;
                    VAR varzonedfrac: tsp00_Int2;
                    VAR varzoned  : tpr_char_array;
                    VAR sqcda     : sqldavrec;
                    VAR sqcerr    : tsp00_Int2);
 
        PROCEDURE
              p10decbind  (VAR sqcca    : sqlcatype;
                    VAR sqcvarno  : tsp00_Int2;
                    VAR vardeclen : tsp00_Int2;
                    VAR vardecfrac: tsp00_Int2;
                    VAR vardec  : tpr_char_array;
                    VAR sqcda   : sqldavrec;
                    VAR sqcerr  : tsp00_Int2);
 
        PROCEDURE
              p10v1stringbind  (VAR sqcca   : sqlcatype;
                    VAR sqcvarno    : tsp00_Int2;
                    VAR v1stringlen : tsp00_Int2;
                    VAR v1char    : tpr_char_array;
                    VAR sqcda     : sqldavrec;
                    VAR sqcerr    : tsp00_Int2);
 
        PROCEDURE
              p10v2stringbind  (VAR sqcca   : sqlcatype;
                    VAR sqcvarno    : tsp00_Int2;
                    VAR v2stringlen : tsp00_Int2;
                    VAR v2string  : tpr_string;
                    VAR sqcda     : sqldavrec;
                    VAR sqcerr    : tsp00_Int2);
 
        PROCEDURE
              p10command   (VAR sqcca   : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcmode     : tsp00_Int2;
                    VAR sqcstmlen   : tsp00_Int4;
                    VAR sqcstmbuf : tsp00_MoveObj;
                    encodingType : tpr05_StringEncoding;
                    VAR sqcresult : tsp00_Int2);
 
        PROCEDURE
              p10ansierror (VAR sqcca   : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR parsret : tpr_parsid);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Call_statement_proceduren  : VPR11;
 
        PROCEDURE
              p11connect (VAR sqcca : sqlcatype;
                    VAR gae : sqlgaentry);
 
        PROCEDURE
              p11statement (VAR sqcca : sqlcatype;
                    VAR gae : sqlgaentry);
 
        PROCEDURE
              p11parse  (VAR sqcca : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcda     : sqldavrec;
                    VAR sqcparsid : tpr_parsid;
                    again         : boolean);
 
        PROCEDURE
              p11execute (VAR sqcca : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcda     : sqldavrec;
                    VAR sqcparsid : tpr_parsid;
                    again         : boolean;
                    VAR arrayparsid : boolean;
                    sqcrowcount   : tsp00_Int4);
 
        PROCEDURE
              p11getxsqcerr (sqcvarno : tsp00_Int2;
                    sqcvint2 : tsp00_Int2;
                    VAR sqcda     : sqldavrec;
                    VAR sqcerr : tsp00_Int2);
 
        PROCEDURE
              p11trace  (VAR sqcca   : sqlcatype;
                    VAR nam : tsp00_Name );
 
        PROCEDURE
              p11pparsidtrace (VAR sqcca : sqlcatype;
                    VAR parsid : tpr_parsid;
                    inout : integer);
 
        PROCEDURE
              p11againtrace (VAR sqcca : sqlcatype;
                    art : integer;
                    again : boolean);
 
        PROCEDURE
              p11checkarraycommand   (VAR sqcca   : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcdbno   : tsp00_Int2;
                    VAR sqcstmlen : tsp00_Int4;
                    VAR sqcstmbuf : tsp00_MoveObj;
                    encodingType : tpr05_StringEncoding;
                    VAR sqcda     : sqldavrec;
                    VAR sqcparsid : tpr_parsid;
                    VAR arrayparsid : boolean);
 
      ------------------------------ 
 
        FROM
              Fetch-Optimierung   : VPR01B;
 
        PROCEDURE
              p01bdrop_parsid (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlcxatype;
                    VAR parsid : tpr_parsid);
 
      ------------------------------ 
 
        FROM
              SQL_runtime_routinen  : VPR01E;
 
        PROCEDURE
              p01xtimetrace (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlcxatype;
                    VAR gae : sqlgaentry);
 
        PROCEDURE
              p01xvfclosetrace  (VAR sqcca : sqlcatype);
 
        PROCEDURE
              p01xtracefilecheck  (VAR sqcca : sqlcatype;
                    VAR sqlcxa : sqlcxatype);
 
        PROCEDURE
              p01xprofinit (VAR sqcca : sqlcatype;
                    VAR sqlxa : sqlcxatype;
                    VAR gae : sqlgaentry);
 
      ------------------------------ 
 
        FROM
              C-Type-Checker-Module  : VPR102;
 
        PROCEDURE
              pr11cGetsqcstm (VAR sqcca : sqlcatype;
                    ConDesc : tsp00_Addr;
                    PacketEncoding : tpr05_StringEncoding;
                    cmdtyp : tsp1_cmd_mess_type;
                    sqcstmlen : tsp00_Int4;
                    VAR sqcstmbuf : tsp00_MoveObj;
                    encodingType : tpr05_StringEncoding;
                    VAR AnalyzeDesc   : tpr05_StmtAnalysisDesc);
 
        PROCEDURE
              pr11cFetchDescribe (VAR sqcca : sqlcatype;
                    ConDesc : tsp00_Addr;
                    PacketEncoding : tpr05_StringEncoding;
                    VAR sqcda     : sqldavrec;
                    VAR AnalyzeDesc   : tpr05_StmtAnalysisDesc);
 
        PROCEDURE
              pr11cDescribe  (VAR sqcca : sqlcatype;
                    ConDesc : tsp00_Addr;
                    PacketEncoding : tpr05_StringEncoding;
                    VAR sqcda     : sqldavrec;
                    VAR sqcparsid : tpr_parsid;
                    again         : boolean);
 
        PROCEDURE
              pr03cRelease(ConDesc : tsp00_Addr);
 
        PROCEDURE
              p03conninfoget (sqlgap : sqlgapointer;
                    VAR ga : sqlgaentry;
                    sess : tsp00_Int2);
 
        PROCEDURE
              p03cmdtrace (sqlrap : sqlrapointer;
                    VAR gae : sqlgaentry;
                    nlcnt : tsp00_Int2;
                    comkind : tsp00_Int2;
                    pSQLStatement : tpr05_StringPointer);
 
        PROCEDURE
              p03csqlclock   (sqlra : sqlrapointer;
                    cmd   : integer);
 
        PROCEDURE
              p03csqlcaareainit (VAR sqcca    : sqlcatype);
 
        PROCEDURE
              p03sqlfree (VAR sqcca    : sqlcatype);
 
        PROCEDURE
              p08analyzeconnectstatm (VAR sqlca : sqlcatype;
                    VAR sqlcxa : sqlcxatype;
                    VAR sqlga : sqlgatype;
                    VAR ga : sqlgaentry;
                    VAR ka : sqlkaentry;
                    partlen   : tsp00_Int4;
                    VAR buffer : tsp00_MoveObj);
 
        PROCEDURE
              p16profexec (
                    sqlrap : sqlrapointer;
                    gaentryp : sqlgaentrypointer;
                    stmt   : tpr_intaddr;
                    prog   : tsp00_KnlIdentifier;
                    modn   : tsp00_KnlIdentifier;
                    lang       : tsp00_Int2;
                    lino       : tsp00_Int4;
                    pid    : tpr_parsid;
                    errmsg : sqlempointer);
 
        PROCEDURE
              p01xcheck  (VAR sqcca : sqlcatype;
                    VAR sqlcxa : sqlcxatype);
 
        PROCEDURE
              pr01TraceRuntimeError (VAR sqcca : sqlcatype;
                    VAR sqlcxa : sqlcxatype;
                    error : tpr_runtime_errors);
 
        FUNCTION
              pr04LongPOdbcData (VAR sqlca : sqlcatype;
                    VAR sqlcxa : sqlcxatype;
                    VAR ga : sqlgaentry;
                    VAR lvcrec : tpr_longvarcharrec;
                    VAR spindex : tsp00_Int2;
                    VAR first  : boolean) : boolean;
 
        FUNCTION
              pr04LongGOdbcData (VAR sqlca : sqlcatype;
                    VAR sqlcxa : sqlcxatype;
                    VAR ga : sqlgaentry;
                    VAR lvcrec : tpr_longvarcharrec;
                    VAR spindex : tsp00_Int2) : boolean;
 
        FUNCTION
              pr04LongGetvalOutput (VAR sqlca : sqlcatype;
                    VAR sqlcxa : sqlcxatype;
                    VAR ga : sqlgaentry;
                    spindex : tsp00_Int2) : boolean;
 
        FUNCTION
              pr04LongOdbcColIsTrunc (VAR sqlca : sqlcatype;
                    colno : integer) : boolean;
 
        PROCEDURE
              pr04LongInitLD (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlcxatype);
 
        PROCEDURE
              pr04LongLvcInitRec (VAR sqlca : sqlcatype;
                    VAR lvcrec: tpr_longvarcharrec);
&       ifdef TRACE
 
        PROCEDURE
              m90int2 (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : tsp00_Int2);
 
        PROCEDURE
              m90int4 (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : tsp00_Int4);
 
        PROCEDURE
              m90int (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : integer);
 
        PROCEDURE
              m90buf (layer : tsp00_ToolLayer;
                    VAR buf :  char;
                    pos_anf : integer;
                    pos_end : integer);
&       endif
 
      ------------------------------ 
 
        FROM
              SQLDB-Auftrags-Schnittstelle  : VPR03;
 
        PROCEDURE
              p03find_part  (sqlrap : sqlrapointer;
                    part_kind        : tsp1_part_kind;
                    VAR part_ptr     : tsp1_part_ptr);
 
        PROCEDURE
              p03encrypt (VAR clearname : tsp00_Name;
                    VAR crypt : tsp00_CryptPw);
 
        PROCEDURE
              p03returncodeget (VAR sqlca : sqlcatype;
                    VAR sqlcxa : sqlcxatype);
 
        PROCEDURE
              p03dropparsid  (VAR sqcca : sqlcatype;
                    VAR sqlcxa : sqlcxatype;
                    VAR gae : sqlgaentry;
                    VAR parsid : tpr_parsid);
 
        PROCEDURE
              p03cancel ( VAR sqlca : sqlcatype;
                    VAR ga    : sqlgaentry);
 
        PROCEDURE
              p03putsysprofbuf (sqlrap : sqlrapointer);
 
        PROCEDURE
              p03sysproferror  (VAR sqcca : sqlcatype;
                    VAR gae : sqlgaentry);
 
      ------------------------------ 
 
        FROM
              Precompiler_Runtime_Routinen  : VPR08;
 
        PROCEDURE
              p08runtimeerror (VAR sqcca : sqlcatype;
                    VAR sqlcxa : sqlcxatype;
                    error : tpr_runtime_errors);
 
        PROCEDURE
              p08vfwritetrace (sqlrap : sqlrapointer);
&       ifdef SQLODBC
 
      ------------------------------ 
 
        FROM
              COMUNICATION WITH ORDER INTERFACE   : VPA01C;
 
        PROCEDURE
              pa01TraceSession (cmdl : tsp00_Int2);
 
        PROCEDURE
              pa01SqlRelease;
 
        FUNCTION
              pa01UtilityConnect : tsp00_Int2;
&       endif
 
      ------------------------------ 
 
        FROM
              RTE-Extension-70    : VSP70;
 
        PROCEDURE
              s70execanalyze (VAR cmd : tsp00_MoveObj;
                    cmdl              : tsp00_Int2;
                    VAR ex_args       : tsp00_ExecLine;
                    VAR ex_mode       : tsp00_ExecMode;
                    VAR spec_complete : boolean);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30    : VSP30;
 
        FUNCTION
              s30gad (VAR b : tsp00_Int2) : tpr_intaddr;
 
        FUNCTION
              s30gad1 (VAR b : tsp00_Int4) : tpr_intaddr;
 
        FUNCTION
              s30gad2 (VAR b : tsp00_Shortreal) : tpr_intaddr;
 
        FUNCTION
              s30gad3 (VAR b : tsp00_Longreal) : tpr_intaddr;
 
        FUNCTION
              s30gad4 (VAR b : char) : tpr_intaddr;
 
        FUNCTION
              s30gad5 (VAR b : tpr_string) : tpr_intaddr;
 
        FUNCTION
              s30klen (VAR str : tpr_macroline;
                    val : char; cnt : integer) : integer;
 
        FUNCTION
              s30len (VAR str : tpr_macroline;
                    val : char; cnt : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30len1 (VAR str : tsp00_KnlIdentifier;
                    val : char; cnt : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30len2 (VAR str : tpr_password;
                    val : char; cnt : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30len3 (VAR str : tsp00_DbName;
                    val : char; cnt : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30len4 (VAR str : tsp00_NodeId;
                    val : char; cnt : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill     : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;       
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;    
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;    
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE_driver         : VEN102;
 
        PROCEDURE
              sqlfinish (term : boolean);
 
        PROCEDURE
              sqldattime (VAR d : tsp00_C8;
                    VAR t : tsp00_C8);
 
        PROCEDURE
              sqlexec ( VAR ex_args       : tsp00_ExecLine;
                    ex_mode       : tsp00_ExecMode;
                    VAR retur         : tsp00_ExecReturn;
                    VAR err_text      : tsp00_ErrText;
                    VAR progresult    : tsp00_Int2);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              m90buf;
 
              tsp00_Buf       char
 
        PROCEDURE
              sqldattime;
 
              tsp00_Date        tsp00_C8
              tsp00_Time        tsp00_C8
 
        PROCEDURE
              sqlexec;
 
              tsp00_ExecLine    tsp00_ExecLine
              tsp00_ExecMode    tsp00_ExecMode
              tsp00_ExecReturn  tsp00_ExecReturn
              tsp00_ErrText     tsp00_ErrText
              tsp00_Int2        tsp00_Int2
 
        PROCEDURE
              p01bdrop_parsid;
 
              sqlxatype         sqlcxatype
 
        PROCEDURE
              p01xcheck;
 
              sqlcatype    sqlcatype
              sqlxatype    sqlcxatype
 
        PROCEDURE
              p01xtracefilecheck;
 
              sqlcatype    sqlcatype
              sqlxatype    sqlcxatype
 
        PROCEDURE
              p01xprofinit;
 
              sqlcatype    sqlcatype
              sqlxatype    sqlcxatype
 
        PROCEDURE
              p03dropparsid;
 
              sqlcatype    sqlcatype
              sqlxatype    sqlcxatype
 
        PROCEDURE
              p03encrypt;
 
              tsp00_CryptName     tsp00_CryptPw
 
        PROCEDURE
              p03returncodeget;
 
              sqlcatype    sqlcatype
              sqlxatype    sqlcxatype
 
        PROCEDURE
              p03sysproferror;
 
              sqlcatype    sqlcatype
 
        PROCEDURE
              p01xvfclosetrace;
 
              sqlcatype    sqlcatype
 
        PROCEDURE
              p08analyzeconnectstatm;
 
              sqlxatype    sqlcxatype
              tpc_partbuffer tsp00_MoveObj
 
        PROCEDURE
              p01xtimetrace;
 
              sqlxatype    sqlcxatype
 
        PROCEDURE
              p08runtimeerror;
 
              sqlxatype    sqlcxatype
              sqlcatype    sqlcatype
 
        PROCEDURE
              pr01TraceRuntimeError;
 
              sqlxatype    sqlcxatype
              sqlcatype    sqlcatype
 
        PROCEDURE
              s70execanalyze;
 
              tsp00_Buf       tsp_varpart
 
        PROCEDURE
              s30gad;
 
              tsp00_MoveObj   tsp00_Int2
              tsp00_Addr          tpr_intaddr
 
        PROCEDURE
              s30gad1;
 
              tsp00_MoveObj   tsp00_Int4
 
        PROCEDURE
              s30gad2;
 
              tsp00_MoveObj   tsp00_Shortreal
 
        PROCEDURE
              s30gad3;
 
              tsp00_MoveObj   tsp00_Longreal
 
        PROCEDURE
              s30gad4;
 
              tsp00_MoveObj   char
 
        PROCEDURE
              s30gad5;
 
              tsp00_MoveObj   tpr_string
 
        PROCEDURE
              s30klen;
 
              tsp00_MoveObj    tpr_macroline
 
        FUNCTION
              s30gad            tsp00_Addr          tpr_intaddr;
 
        FUNCTION
              s30gad1;
 
              tsp00_Addr          tpr_intaddr
 
        FUNCTION
              s30gad2;
 
              tsp00_Addr          tpr_intaddr
 
        FUNCTION
              s30gad3;
 
              tsp00_Addr          tpr_intaddr
 
        FUNCTION
              s30gad4;
 
              tsp00_Addr          tpr_intaddr
 
        FUNCTION
              s30gad5;
 
              tsp00_Addr          tpr_intaddr
 
        FUNCTION
              s30len;
 
              tsp00_MoveObj       tpr_macroline
 
        FUNCTION
              s30len1;
 
              tsp00_MoveObj   tsp00_KnlIdentifier
 
        FUNCTION
              s30len2;
 
              tsp00_MoveObj   tpr_password
 
        FUNCTION
              s30len3;
 
              tsp00_MoveObj   tsp00_DbName
 
        FUNCTION
              s30len4;
 
              tsp00_MoveObj   tsp00_NodeId
 
        PROCEDURE
              s70execanalyze;
 
              tsp00_Buf           tsp00_MoveObj
 
        PROCEDURE
              pr04LongInitLD;
 
              sqlxatype         sqlcxatype
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1988-03-25
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2001-01-02
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.nf
CONST
    sqc_maxdbname           =   64;
    sqc_maxuser             =    8;
    sqc_maxname             =   18;
    sqc_maxpassword         =   18;
    sqc_maxargline          =  132;
    sqc_maxgatype           =  964;
    sqc_maxmatype           = 4100;
    sqc_maxratype           = 8308;
    sqc_maxmftype           =  508;
    sqc_maxcxatype          =  100;
    sqc_maxstatement_buffer = 8240;
    sqc_maxsqcvartype       =  300;
 
 
              sqcinppar    = 0;    (* colio *)
              sqcoutpar    = 1;
 
              sqcvalue     = 0;    (* colmode *)
              sqcundef     = 1;
 
              sqcfixed     = 0;    (* coltype *)
              sqcfloat     = 1;
              sqcchar      = 2;
              sqcbyte      = 3;
              sqcdate      = 4;
              sqctime      = 5;
              sqcstring    = 6;
 
                  (* hostvartype *)
              sqcvint2     = 0;   (* 2 byte integer *)
              sqcvint4     = 1;   (* 4 byte integer *)
              sqcvr4       = 2;   (* 4 byte real    *)
              sqcvr8       = 3;   (* 8 byte real    *)
              sqcvdecimal  = 4;
              sqcvzoned    = 5;
              sqcvchar     = 6;  (* char filled with blank         *)
              sqcvcharc    = 7;  (* c-char with binary zero as end *)
              sqcvbchar    = 8;  (* with unprintable characters    *)
              sqcvbuf      = 10; (* char arrays > 254 bytes        *)
              sqcvstring   = 15; (* 2-byte length, char array      *)
              sqcvuns2     = 16; (* 2-byte unsigned integer        *)
              sqcvuns4     = 17; (* 4-byte unsigned integer        *)
              sqcvstring1  = 20; (* 1-byte length, char array      *)
 
 
TYPE
    tsp00_Int2  = shortint;  (* packed  -32768..32767 ; 2 Byte lang *)
    tsp00_Int4  = integer;   (* 4 Byte long *)
    tsp00_Shortreal    = real;      (* 4 Byte long *)
    tsp00_Longreal    = double;    (* 8 Byte long *)
    tpr_char_array = char;      (* 1st byte of a char array *)
 
    tpr_parsid         = packed array [1..16 ]                   of char;
    sqc_c6               = packed array [1..6 ]                    of char;
    tsp00_C8               = packed array [1..8 ]                    of char;
    tsp00_C12              = packed array [1..12 ]                   of char;
    tsp00_C70              = packed array [1..70 ]                   of char;
    tsp00_DbName           = packed array [1..sqc_maxdbname ]        of char;
    tsp_username             = packed array [1..sqc_maxuser ]          of char;
    tsp00_Name             = packed array [1..sqc_maxname ]          of char;
    tpr_password         = packed array [1..sqc_maxpassword ]      of char;
    sqc_argline          = packed array [1..sqc_maxargline ]       of char;
    sqc_gatype           = packed array [1..sqc_maxgatype ]        of char;
    sqc_ratype           = packed array [1..sqc_maxratype ]        of char;
    sqc_mftype           = packed array [1..sqc_maxmftype ]        of char;
    sqc_matype           = packed array [1..sqc_maxmatype ]        of char;
    sqc_cxatype          = packed array [1..sqc_maxcxatype ]       of char;
    tsp00_MoveObj = packed array [1..sqc_maxstatement_buffer] of char;
 
    sqlcatype =   RECORD
          sqlenv   : tsp00_Int4;     (*  cobol init = 0  *)
          sqlcaid  : tsp00_C8;       (* help with dump analysis *)
          sqlcabc  : tsp00_Int4;     (* length of SQLCA, not constant ?? *)
          sqlcode  : tsp00_Int4;     (* reflex return code       *)
          sqlfill1 : tsp00_Int2;
          sqlerrml : tsp00_Int2;     (* length of error message  *)
          sqlerrmc : tsp00_C70;      (* message text             *)
          sqlmfetch: tsp00_Int2;     (* mfetch switch            *)
          sqlerrp  : tsp00_C8;
          sqlerrd  : ARRAY [1..6]  OF tsp00_Int4;  (* ResCnt(3), Cost *)
          sqlwarn0 : char;    (* shows whether warnings set, if nec. 'W' *)
          sqlwarn1 : char;    (* alphanumeric values truncated *)
          sqlwarn2 : char;    (* NULL values ignored with aggregation *)
          sqlwarn3 : char;    (* SELECT no. of columns not equal param no.*)
          sqlwarn4 : char;    (* UPDATE or DELETE through entire table *)
          sqlwarn5 : char;
          sqlwarn6 : char;
          sqlwarn7 : char;
          sqlwarn8 : char;
          sqlwarn9 : char;
          sqlwarna : char;
          sqlwarnb : char;
          sqlwarnc : char;
          sqlwarnd : char;
          sqlwarne : char;  (* select next,prev,first,last,*)
                            (*  secondary key change       *)
          sqlwarnf : char;  (* create table, index contains ibm syntax *)
          sqlcursor  : tsp00_Int2;       (* cursor position with dia state*)
          sqlpfkey   : tsp00_Int2;       (* last pfkey after dia_statem   *)
          sqlext     : tsp00_C12;          (* hatzel_check *)
          tatraceno : tsp00_Int4;       (* fileno after vfopen *)
          tatracefn : tsp00_DbName;     (* trace file name     *)
          tatracety : tsp00_Int2;       (* 1=tr-off, 2=tr-normal, 3=tr-long *)
          sqlfill3   : tsp00_Int2;
          sqlargl  : sqc_argline;      (* option runtime argline       *)
          sqlgap^    : sqc_gatype;       (* global connect  *)
          sqlmap^    : sqc_matype;       (* sqlmap^ area max 128 macros *)
          sqlrap^    : sqc_ratype;       (* runtime request,sql or dia *)
          sqlmfp^    : sqc_mftype;       (* sqlmfp^ area      *)
          sqlcxa   : sqc_cxatype;      (* sqlxa area      *)
        END;
 
 
      sqlvartype  =   RECORD    (* 44 B *)
          colname  : tsp00_Name;       (* select list column names *)
          colio    : tsp00_Int2;       (* 0:inp ;  1:outp          *)
          colmode  : tsp1_param_opt_set;
          colfill1 : char;
          coltype  : tsp00_Int2;       (* 0:number; 2: char        *)
          collength: tsp00_Int2;       (* number places total      *)
          colfrac  : tsp00_Int2;       (* number places after point*)
          hostindicator : tsp00_Int4;  (* host indicator variable  *)
          hostvartype   : tsp00_Int2;  (* host variable type       *)
          hostvaraddr   : tsp00_Int4;  (* host variable address    *)
          hostindaddr   : tsp00_Int4;  (* host indicator address   *)
          colinfo       : tsp00_C8;    (* reflex col infos         *)
       END;
 
      sqldatype =   RECORD
          sqldaid : tsp00_C8;       (* sqcda_const *)
          sqlmax  : tsp00_Int4;     (* maxsqcvartype maximum occupancy*)
          sqln    : tsp00_Int2;     (* number assigned sqcvar elements*)
          sqld    : tsp00_Int2;     (* erg. number sqcvar elements    *)
          sqlkano : tsp00_Int2;     (* dummy                          *)
          sqlprno : tsp00_Int2;     (* dummy                          *)
          sqlvar  : ARRAY [1..mxpr_sqln] of sqlvartype;
        END;
.sp 4
 
.cp 12
PROCEDURE PARAMETER:
.sp 2;.hi 9;.fo
sqcca:  contains general information for all database commands.
Return codes, connect informaton (sqc_gatype),
macro information (sqc_matype), internal information (sqc_xatype)
and the order segment (sqc_ratype).
.sp 2
sqcdbno: number (1,2,.] of the database which should execute
this command.
Maximum of 8 databases.
.sp 2
sqcdbname: name of the database.
.sp 2
sqcstmlen: length of the command in the statement buffer
(sqcstmbuf).
.sp 2
sqcstmbuf: contains the command which should by executed by
the SQLDB database.
.sp 2
sqcuser: if the connect statement contains host variable for the user,
it is necessary to qualify the host variable here.
Otherwise a dummy parameter is allowed.
.sp 2
sqcpassw: if the connect statement contains a host variable for the
password, it is necessary to qualify the host varibale here.
Otherwise a dummy parameter is allowed.
.sp 2
sqcda: contains information for the converting of Reflex data
to host variables and vice versa.
While calling sqc_parsen the information is stored
in the database which can be queried or enhanced by the
user.
While calling sqc_execute this information is needed
for the conversion.
.sp 2
sqcvarinfo: contains information of one sqcca.sqlvar
for the converting of Reflex data
to host variables and vice versa.
.sp 2
sqcparsid: the parse id is a 6-byte-long item of information
or a key which is used for storing tempory information about
that command in the database. At sqc_execute this information
is needed for the execution of the command.
.sp 2
sqcerr: returns the error message after
testing
whether a conversion of the Reflex data type to
the specified data type is allowed or if it is possible that
values are
truncated or if it is possible that there will be an
overflow.
     sqcerr = cpr_c_ok           = 0
            = cpr_c_incompatible = 1
            = cpr_c_overflow     = 2
            = cpr_c_truncated    = 3
            = cpr_c_varnowrong   = 4
            = cpr_c_notimplemented= 5
.sp 2;.hi;.cp 8
.sp 4
.cp 6
PROCEDURE  SQCCONNECT:
.sp 2
For every user who wants to work with the database the
connection to the Reflex database is installed.
The sqcca variables are implicitly initialized at the
first call.
.sp 4
.cp 6
PROCEDURE  SQCSTATEMENT:
.sp 2
Statements with no parameters, that means there is no conversion
for host variables, can be executed with this routine.
.sp 4
.cp 6
PROCEDURE  SQCDIALOG:
.sp 2
Not yet implemented.
.sp 4
.cp 6
PROCEDURE  SQCFORM:
.sp 2
Not yet implemented.
.sp 4
.cp 6
PROCEDURE  SQCREPORT:
.sp 2
Not yet implemented.
.sp 4
.cp 6
PROCEDURE  SQCPARSEN:
.sp 2
With this call a command will only be parsed, that means a
syntax and semantic check and information about the parameters
will be stored in the sqlda variable.
If there are no parameters in the statement then
sqln in sqcda = 0.
In sqcparsid the parse id for this command is returned.
This parse id is necessary for calling sqc_execute.
.sp 4
.cp 6
PROCEDURE  SQCEXECUTE:
.sp 2
The command which belongs to the parse id will be executed.
The command should be repeated because it may happen that is
necessary to parse the command again.
It is done implicitly.
.sp 4
.cp 6
PROCEDURE  p10putlongdata:
.sp 2
Diese Procedure wird nur f?ur ODBC gebraucht.
Beim Insert von Longspalten wird nach jeder Longspalte nach Abarbeitung der
zugeh?origen Hostvariable, die Kommunikation mit den Anwender zur?uckgegeben.
Dieser muss signalisieren mit der L?ange der Hostvariblen = 0, da?z f?ur
diese Spalte kein Input mehr kommt.
.sp
Nach dem 1. execute Input m?uss sich der Anwender die Collno aus der
SQLDA holen. Es ist die erste Longspalte in der SQLDA.
Alle weiteren Aufrufe m?ussen mit p10putlongdata abgesetzt werden.
.sp
.br; input sqlvarno  gibt den index der Spalte in der SQLDA.varentry an.
.br; output sqlvarno = 0 alle Inputlongspalten sind abgearbeitet.
.br; output sqlvarno = negativ gibt an die Longspalte wurde nicht
mit L?ange = 0 abgeschlossen.
.br; output = positiv es werden weitere Input-Werte oder Hostvarlength = 0
erwartet.
.sp 4
.cp 6
PROCEDURE  p10getlongdata:
.sp 2
Diese Procedure wird nur f?ur ODBC gebraucht.
Beim Output von Longspalten wird nach jeder Longspalte nach F?ullung der
zugeh?origen Hostvariable, die Kommunikation an den Anwender zur?uckgegeben.
Dieser muss signalisieren, welche Spalte er bearbeitet haben will.
In sqcvarno wird die Spaltennummer mitgegeben, f?ur die entsprechende Werte
in die  Hostvarible geholt werden. Reihenfolge der Parameter beim
'fetch' muss dabei beachtet werden.
.sp
Nach dem 1. execute Output m?uss sich der Anwender die
zuletzt bearbeitete
Collno aus dem ldrestbufp^.rbcolno  holen.
(siehe TYPE tpr_sqlld)
Ist dieser Wert = 0, so sind alle Spalten abgearbeitet.
Bei Angabe Colno  k?onnen f?ur diese Spalte weiter Informationen
geholt werden.
Alle weiteren Aufrufe m?ussen mit p10getlongdata abgesetzt werden.
.sp
.br; input sqlvarno  gibt den index der Spalte in der SQLDA.varentry
gleich Colno an.
.br; output sqlvarno = 0 die Outputlongspalte ist vollst?andig abgearbeitet,
es kann mit der n?achsten sqlvarno die n?achste Longspalte geholt werden.
.br; output sqlvarno = negativ gibt an die Longspalte wurde schon
vollst?andig in Hostvariable geschrieben.
.br; output = positiv es k?onnen weitere Output-Werte in die Hostvaribale
geholt werden.
.sp 4
.cp 6
PROCEDURE  SQCDROPPARSID:
.sp 2
If you know that this parse id is not needed anymore then
it is possible with this routine to drop the parse id and
the information in the database.
They are dropped automatically at commit work.
.sp 4
.cp 6
PROCEDURE  SQCRELEASE:
.sp 2
Terminates the database session.
With the commands 'commit release'
or 'rollback release' this is done automatically.
Not yet implemented.
.sp 4
.cp 6
PROCEDURE  SQCFINISH:
.sp 2
Terminates all connections to the database, closes virtual
files and returns the result code to the user.
This call should be the last one in every program.
Not yet implemented.
.sp 4
.cp 6
PROCEDURE  SQCGETINFO:
.sp 2
Gets a sqlvarvrec information out of the sqcda.
.sp 4
.cp 6
PROCEDURE  SQCPUTINFO:
.sp 2
Writes a sqlvarvrec information into the sqcda.
.sp 4
.cp 6
PROCEDURE  SQCINT2BIND:
.sp 2
Writes into sqc_vatype of sqcda[sqcvarno] the
hostvartyp (sqcvint2) and the
hostvaraddr (address) of qualified variable sqcvar.
Tests whether a conversion is allowed and returns
sqcerr.
.sp 4
.cp 6
PROCEDURE  SQCINT4BIND:
.sp 2
Writes into sqc_vatype of sqcda[sqcvarno] the
hostvartyp (sqcvint4) and the
hostvaraddr (address) of the qualified variable sqcvar.
Tests whether a conversion is allowed and returns
sqcerr.
.sp 4
.cp 6
PROCEDURE  SQCUNS2BIND:
.sp 2
Writes into sqc_vatype of sqcda[sqcvarno] the
hostvartyp (sqcvuns2 unsigned integer) and the
hostvaraddr (address) of qualified variable sqcvar.
Tests whether a conversion is allowed and returns
sqcerr.
.sp 4
.cp 6
PROCEDURE  SQCUNS4BIND:
.sp 2
Writes into sqc_vatype of sqcda[sqcvarno] the
hostvartyp (sqcvuns4 unsigned integer) and the
hostvaraddr (address) of the qualified variable sqcvar.
Tests whether a conversion is allowed and returns
sqcerr.
.sp 4
.cp 6
PROCEDURE  SQCR4BIND:
.sp 2
Writes into sqc_vatype of sqcda[sqcvarno] the
hostvartyp (sqcvr4) and the
hostvaraddr (address) of the qualified variable sqcvar.
Tests whether a conversion is allowed and returns
sqcerr.
.sp 4
.cp 6
PROCEDURE  SQCR8BIND:
.sp 2
Writes into sqc_vatype of sqcda[sqcvarno] the
hostvartyp (sqcvr8) and the
hostvaraddr (address) of the qualified variable sqcvar.
Tests whether a conversion is allowed and returns
sqcerr.
.sp 4
.cp 6
PROCEDURE  SQCCHARBIND:
.sp 2
Writes into sqc_vatype of sqcda[sqcvarno] the
hostvartyp (sqcvchar char array filled with blanks) and the
hostvaraddr (address) of the qualified variable sqcvar.
Varcharlen = complete length becomes collength
and colfrac is 0.
Tests whether a conversion is allowed and returns
sqcerr.
.sp 4
.cp 6
PROCEDURE  SQCCCHARBIND:
.sp 2
Writes into sqc_vatype of sqcda[sqcvarno] the
hostvartyp (sqccchar c-char array with binary null as delimiter) and the
hostvaraddr (address) of the qualified variable sqcvar.
Varccharlen = complete length becomes collength
and colfrac is 0.
Varccharlen may be collength + 1.
Tests whether a conversion is allowed and returns
sqcerr.
.sp 4
.cp 6
PROCEDURE  SQCZONEDBIND:
.sp 2
Writes into sqc_vatype of sqcda[sqcvarno] the
hostvartyp (sqcvzoned) and the
hostvaraddr (address) of the qualified variable sqcvar.
Varzonedlen = complete length becomes collength
and varzonedfrac = number of decimal digits is moved to
colfrac.
Tests whether a conversion is allowed and returns
sqcerr.
.sp 4
.cp 6
PROCEDURE  SQCDECIMALBIND:
.sp 2
Writes into sqc_vatype of sqcda[sqcvarno] the
hostvartyp (sqcvdecimal) and the
hostvaraddr (address) of the qualified variable sqcvar.
Vardeclen = number of digits becomes collength
and vardecfrac = number of decimal digits is moved to
colfrac.
Tests whether a conversion is allowed and returns
sqcerr.
.sp 4
.cp 6
PROCEDURE  SQCV1STRINGBIND:
.sp 2
Writes into sqc_vatype of sqcda[sqcvarno] the
hostvartyp (sqcvstring1) and the
hostvaraddr (address) of the qualified variable sqcvar[0].
V1stringlen = complete length becomes collength
and colfrac is 0.
V1stringaddress will be set by Character index of 0.
(sqcvar[0]).
Tests whether a conversion is allowed and returns
sqcerr.
.sp 4
.cp 6
PROCEDURE  SQCV2STRINGBIND:
.sp 2
Writes into sqc_vatype of sqcda[sqcvarno] the
hostvartyp (sqcvstring) and the
hostvaraddr (address) of the qualified variable sqcvar.
V1stringlen = complete length becomes collength
and colfrac is 0.
Tests whether a conversion is allowed and returns
sqcerr.
.sp 4
***********************************************************
.sp 3
 
.cp 12
PROCEDURE PARAMETER:
.sp 2;.hi 9;.fo
sqcca:  enth?alt allgemeine Angaben f?ur alle SQLDB-Datenbank
Kommandos. R?uckmeldungen, Connect-informatonen(sqc_gatype),
Macro-informationen (sqc_matype), Interne-informationen (sqc_xatype)
und das Auftragssegment (sqc_ratype).
.sp 2
sqcdbno: Gibt die Nummer (1,2,.] an, auf welcher Datenbank
das Kommando abgearbeitet
werden soll. Maximal sind 8 zugelassen.
In allen Aufrufen Input-Parameter.
.sp 2
sqcdbname: Gibt den Namen der Datenbank an.
.sp 2
sqcstmlen: Gibt  die L?ange des Statements im Statementpuffer
(sqcstmbuf) an.
.sp 2
sqcstmbuf: Enth?alt das Kommando, das von der SQLDB-Datenbank
bearbeitet werden soll.
.sp 2
sqcuser: Wird im Connect-Statement der User ?uber Hostvariable
angegeben, muss die Hostvariable hier angegeben werden.
Sonst kann ein dummy Parameter angegeben werden.
.sp 2
sqcpassw: Ist im Connect-Statement das Password ?uber Hostvariable
angegeben, muss die Hostvariable hier angegeben werden.
Sonst kann ein dummy Parameter angegeben werden.
.sp 2
sqcda: Enth?alt Informationen f?ur die Konvertierung der
SQLDB-Daten zu den Hostvariablen und umgekehrt.
Beim Procedureaufruf sqc_parsen werden Informationen
aus der Datenbank dort abgelegt, die der Anwender abfragen
und erg?anzen kann.
Beim Procedureaufruf sqc_execute werden diese Informationen
zur Konvertierung gebraucht.
.sp 2
sqcvarinfo: Enth?alt einen Eintrag sqlvartype der
sqcda Variablen.
.sp 2
sqcparsid: Die Parsid  ist eine 6 Byte lange Information
oder Key unter der in der Datenbank tempor?are Informationen
dieses Kommandos abgeleget wurden. Bei sqc_execute werden
diese zur Abarbeitung des Kommandos ben?otigt.
.sp 2
sqcerr: Gibt die Errormeldung nach
der Pr?ufung,
ob eine Konvertierung des SQLDB-Datentype mit
dem angegebenen Datentype erlaubt ist, und ob eventuell
die Werte abgeschnitten (truncated) werden oder ein ?Uberlauf
(overflow) entstehen kann, zur?uck.
     sqcerr = cpr_c_ok           = 0
            = cpr_c_incompatible = 1
            = cpr_c_overflow     = 2
            = cpr_c_truncated    = 3
            = cpr_c_varnowrong   = 4
.sp 2;.hi;.cp 8
.sp 4
.cp 6
TEST-OPTIONS:
.sp 2
Zum Testen kann eine Datei mit einer Zeile (max = 132)
erstellt werde.
In Bs-unix 'xpc.parms' unter der actuellen Direktory,
in Bs-VM   'XPC PARMS'.
In dieser Zeile k?onnen Options f?ur das Call-Interface angegeben
werden.
.sp
.hi 6
-xtl /'<filename>'/: Bs-unix eine Datei mit dem <filename> oder default
'CALLTRAC.pct' wird in der actuellen Directory
erzeugt, in der alle Datenbank-
Kommandos protokoliert werden.
.sp
tracel /'<filename filetype>'/ : Bs-VM eine Datei mit dem
<filename filetype> oder default
'CALLTRAC PCTRACE' wird in der actuellen Directory erzeugt,
in der alle Datenbank-
Kommandos protokoliert werden.
.hi
.sp 4
.cp 6
PROCEDURE  SQCCONNECT:
.sp 2
F?ur jeden User der mit der Datenbank arbeiten will, wird
hiermit die Verbindung zum SQLDB-Datenbanksytem hergestellt.
Ein implizites Initialisieren der Sqcca-Variablen wird beim
ersten Aufruf gemacht.
.sp 4
.cp 6
PROCEDURE  SQCSTATEMENT:
.sp 2
Statements, die keine Parameter benutzen, d.h. es findet keine
Konvertierung f?ur Hostvariable statt, k?onnen mit diesem
Aufruf abgearbeitet werden.
.sp 4
.cp 6
PROCEDURE  SQCDIALOG:
.sp 2
Noch nicht implementiert.
.sp 4
.cp 6
PROCEDURE  SQCFORM:
.sp 2
Noch nicht implementiert.
.sp 4
.cp 6
PROCEDURE  SQCREPORT:
.sp 2
Noch nicht implementiert.
.sp 4
.cp 6
PROCEDURE  SQCPARSE:
.sp 2
Mit diesem Aufruf wird ein Kommando nur geparsed, d.h. Syntax,
Semantic gescheckt und Informatioen ?uber benutzte Parameter
in der sqcda Variablen abgelegt.
Sind keine Parameter im Kommando so wird sqcn in sqcda = 0 gesetzt.
In sqcparsid wird die Parsid f?ur dieses Kommando zur?uckgegeben.
Diese Parsid muss bei dem Aufruf sqc_execute wieder mitgegeben werden.
.sp
Mit diesem Aufruf kann auch jedes Kommnado mit 'describe' davor
aufgerufen werden.
.sp
Bei 'fetch' Kommandos mit unbekannter Spalten-
Anzahl, muss 'fetch /resultname/ using desriptor' abgesetzt werden.
Die Bearbeitung ist wie  'parse, execute'.
.sp 4
.cp 6
PROCEDURE  SQCEXECUTE:
.sp 2
Das Kommando, das zu der entspechenden Parsid geh?ort wird abgearbeitet.
Das kommando selbst sollte nochmal mit angegeben werden, da bei einer
bestimmten Datenbankmeldung eventuell das Kommando nochmals geparsed
werden muss.
Dies wird dann impliziet gemacht.
.sp 4
.cp 6
PROCEDURE  SQCDROPPARSID:
.sp 2
Wenn man genau feststellen kann, da?z diese Parsid nicht mehr gebraucht
wird, kann hiermit die Informatioenen der Parsid in der Datenbank
gel?oscht werden.
Sie werden aber auch bei commit work release automatisch gel?oscht.
.sp 4
.cp 6
PROCEDURE  SQCRELEASE:
.sp 2
L?ost  ordnugsgem?a?z eine Verbindung zur Datenbank.
Bei den Kommandos 'commit release'
oder 'rollback release' wird dies
impliziet gemacht.
.sp 4
.cp 6
PROCEDURE  SQCFINISH:
.sp 2
L?ost alle Verbindungen zur Datenbank, beendet die virtuellen
Files ordentlich und gibt  den result-code an den User zur?uck.
Dieser Aufruf sollte am Programmende immer abgesetzt werden.
.sp 4
.cp 6
PROCEDURE  SQCGETINFO:
.sp 2
Holt eine sqlvarvrec Information aus der sqcda.
.sp 4
.cp 6
PROCEDURE  SQCPUTINFO:
.sp 2
Schreibt  eine sqlvarvrec Information in die sqcda.
.sp 4
.cp 6
PROCEDURE  SQCINT2BIND:
.sp 2
Schreibt in den sqc_vatype der sqcda [sqcvarno] den
hostvartyp (sqcvint2) und die
hostvaraddr (Addresse) der angegeben Variablen sqcvar.
Pr?uft, ob eine Konvertierung erlaubt ist und gibt
sqcerr zur?uck.
.sp 4
.cp 6
PROCEDURE  SQCINT4BIND:
.sp 2
Schreibt in den sqc_vatype der sqcda [sqcvarno] den
hostvartyp (sqcvint4) und die
hostvaraddr (Addresse) der angegeben Variablen sqcvar.
Pr?uft, ob eine Konvertierung erlaubt ist und gibt
sqcerr zur?uck.
.sp 4
.cp 6
PROCEDURE  SQCUNS2BIND:
.sp 2
Schreibt in den sqc_vatype der sqcda [sqcvarno] den
hostvartyp (sqcvuns2) und die
hostvaraddr (Addresse) der angegeben Variablen sqcvar.
Pr?uft, ob eine Konvertierung erlaubt ist und gibt
sqcerr zur?uck.
.sp 4
.cp 6
PROCEDURE  SQCUNS4BIND:
.sp 2
Schreibt in den sqc_vatype der sqcda [sqcvarno] den
hostvartyp (sqcvuns4) und die
hostvaraddr (Addresse) der angegeben Variablen sqcvar.
Pr?uft, ob eine Konvertierung erlaubt ist und gibt
sqcerr zur?uck.
.sp 4
.cp 6
PROCEDURE  SQCR4BIND:
.sp 2
Schreibt in den sqc_vatype der sqcda [sqcvarno] den
hostvartyp (sqcvr4) und die
hostvaraddr (Addresse) der angegeben Variablen sqcvar.
Pr?uft, ob eine Konvertierung erlaubt ist und gibt
sqcerr zur?uck.
.sp 4
.cp 6
PROCEDURE  SQCR8BIND:
.sp 2
Schreibt in den sqc_vatype der sqcda [sqcvarno] den
hostvartyp (sqcvr8) und die
hostvaraddr (Addresse) der angegeben Variablen sqcvar.
Pr?uft, ob eine Konvertierung erlaubt ist und gibt
sqcerr zur?uck.
.sp 4
.cp 6
PROCEDURE  SQCCHARBIND:
.sp 2
Schreibt in den sqc_vatype der sqcda [sqcvarno] den
hostvartyp (sqcvchar char-array mit blank aufgef?ullt) und die
hostvaraddr (Addresse) der angegeben Variablen sqcvar.
Varcharlen = Anzahlstellen gesamt  wird nach collength
und colfrac wird = 0 gesetzt.
Pr?uft, ob eine Konvertierung erlaubt ist und gibt
sqcerr zur?uck.
.sp 4
.cp 6
PROCEDURE  SQCCCHARBIND:
.sp 2
Schreibt in den sqc_vatype der sqcda [sqcvarno] den
hostvartyp (sqccchar c-char-array mit bin?arnull als abschlu?z) und die
hostvaraddr (Addresse) der angegeben Variablen sqcvar.
Varcharlen = Anzahlstellen gesamt  wird nach collength
und colfrac wird = 0 gesetzt.
Pr?uft, ob eine Konvertierung erlaubt ist und gibt
sqcerr zur?uck.
.sp 4
.cp 6
PROCEDURE  SQCZONEDBIND:
.sp 2
Schreibt in den sqc_vatype der sqcda [sqcvarno] den
hostvartyp (sqcvzoned) und die
hostvaraddr (Addresse) der angegeben Variablen sqcvar.
Varzonedlen = Anzahlstellen gesamt  wird nach collength
und varzonedfrac = Anzahlstellen nach dem Komma wird nach
colfrac gebracht.
Pr?uft, ob eine Konvertierung erlaubt ist und gibt
sqcerr zur?uck.
.sp 4
.cp 6
PROCEDURE  SQCDECIMALBIND:
.sp 2
Schreibt in den sqc_vatype der sqcda [sqcvarno] den
hostvartyp (sqcvdecimal) und die
hostvaraddr (Addresse) der angegeben Variablen sqcvar.
Vardeclen = Anzahlstellen gesamt  wird nach collength
und vardecfrac = Anzahlstellen nach dem Komma wird nach
colfrac gebracht.
Pr?uft, ob eine Konvertierung erlaubt ist und gibt
sqcerr zur?uck.
.sp 4
PROCEDURE  P80COMMAND :
.sp 2
Analyzes a 'command' statement with the following infos :
   sqcmode :  0 ::= sync
              1 ::= newsync
              2 ::= async
   sqcstmlen :  length of command in sqcstmbuf
   sqcstmbuf : sqlexec command is stored
   sqcresult : result parameter will stored after the command,
               it is := 0 always by async mode.
.sp 4
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
.sp 2
Collogia Interface :
.sp 2
SQCBEGIN (SQCCA <return-code>)
 
This procedure
obtains and initializes memory required for Pascal Runtime support.
It must be called once at the start of execution of every
program using the Call Interface,
prior to calls to any other Runtime procedures.
 
In case of error the full-word return code parameter is set to a
positive non-zero value.
 
.sp;.nf
SQCROLLO (SQCCA <return-code> <key-code> SQCXA)                 <==
.sp;.fo
This procedure rolls out to CICS
Temporary Storage all Runtime control blocks to be restored when this
transaction later resumes execution.
It must be the last call to Pascal Runtime before task
termination in pseudoconversational mode.
 
In case of error the full-word return code parameter is set to a
positive non-zero value.
 
The 4-byte key-code is appended to the right of the terminal ID to
form the key used to write to CICS Temporary Storage.
 
If called by a batch program, this procedure has no effect.
 
.sp;.nf
SQCROLLI (SQCCA <return-code> <key-code> SQCXA)                 <==
.sp;.fo
This procedure
rolls back in from Temporary Storage the Runtime control blocks
previously rolled out as part of task termination.
It must be the second call to Pascal Runtime (after SQCBEGIN)
when a transaction resumes execution in pseudoconversational mode.
 
In case of error the full-word return code parameter is set to a
positive non-zero value, except that -1 is set if no data could be
obtained from CICS Temporary Storage (this may or may
not be interpreted as an error).
 
The 4-byte key-code is appended to the right of the terminal ID to
form the key used to read from CICS Temporary Storage.
 
If called by a batch program, this procedure has no effect.
.pa;.cm ====================================================
SQCEND (SQCCA <return-code> <key-code>)
 
This procedure
deletes the CICS Temporary Storage queue for this terminal
with this key-code.
It should be called at the logical end of a
pseudoconversational task (instead of SQCROLLO) and
if appropriate as part of the task's error handling routine
(before SQCERROR).
 
In case of error the full-word return code parameter is set to a
positive non-zero value.
 
The 4-byte key-code is appended to the right of the terminal ID to
form the key used to delete the CICS Temporary Storage queue.
 
If called by a batch program, this procedure has no effect.
 
 
SQCERROR (SQCCA <return-code>)
 
This procedure cleans up after errors and
should be called as part of a task's error handling
routine.  It serves the following purposes:
.sp;.hi 5
@@1)@For all sessions it severs the connection with the kernel to
release kernel resources without waiting for Command Timeout.
.sp;.br
@@2)@With CICS under VSE for all sessions it releases local
resident resources (XECB's & XPCCB's) not managed
by CICS (i.e. not automatically released at task end).
.sp;.br
@@3)@If the error occurred in Pascal or Assembler Runtime code, it
sets the full-word return code parameter to a positive non-zero value
and produces dumps and/or Pascal Traceback as appropriate.
.sp 2
.hi
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
(*------------------------------*) 
 
PROCEDURE
      p10connect  (VAR sqcca   : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcdbno   : tsp00_Int2;
            VAR sqcdbnode : tsp00_NodeId;
            VAR sqcdbname : tsp00_DbName;
            VAR sqcstmlen : tsp00_Int4;
            VAR sqcstmbuf : tsp00_MoveObj;
            encodingType : tpr05_StringEncoding;
            VAR sqcuser   : tsp00_KnlIdentifier;
            VAR sqcpassw  : tpr_password);
 
VAR
      cmdtyp : tsp1_cmd_mess_type;
      user   : tsp00_KnlIdentifier;
      passwt : tsp00_Name;
      passw  : tpr_password;
      dbnode : tsp00_NodeId;
      dbname : tsp00_DbName;
      len    : integer;
      parsret: tpr_parsid;
      AnalyzeDesc : tpr05_StmtAnalysisDesc;
      part_ptr : tsp1_part_ptr;
      dummyka : sqlkaentry;
 
BEGIN
WITH sqcca, sqlcxap^  DO
    BEGIN
    xalang := cpr_la_call;
    sqlargl [1]  := bsp_c1;
    p01xcheck (sqcca, sqlcxap^);
    IF  sqldatetime  = cpr_dt_empty
    THEN
        sqldatetime  := cpr_dt_normal;
    (*ENDIF*) 
    IF   sqlcxap^.xainit = cpr_is_true
    THEN
        BEGIN
        sqlcxap^.xaprogn :=
              'CALLTRAC                                                        ';
        sqlcxap^.xaprogc := 8;
        END;
    (*ENDIF*) 
    p03csqlcaareainit(sqcca);
    p01xtracefilecheck (sqcca, sqlcxap^);
&   ifdef TRACE
    m90int2 (pc, 'sqcdbno     ', sqcdbno );
    m90buf  (pc, sqcdbnode[1] , 1, 64 );
    m90buf  (pc, sqcstmbuf[1] , 1, 20 );
    m90buf  (pc, sqcuser  [1] , 1, 64 );
    m90buf  (pc, sqcpassw [1] , 1, 18 );
    m90int4 (pc, 'sqcstmlen   ', sqcstmlen );
    m90buf  (pc, sqcdbname[1] , 1, 64 );
&   endif
&   ifdef TRACE
    m90int2 (pc, 'sqlcode     ', sqlcode );
    m90int2 (pc, 'xakano      ', sqlcxap^.xakano );
    m90int2 (pc, 'sqcdbno     ', sqcdbno );
&   endif
    IF  sqlcode = 0
    THEN
        BEGIN
&       ifdef TRACE
        m90int2 (pc, 'sqlcode 1   ', sqlcode );
        m90int2 (pc, 'xakano  1   ', sqlcxap^.xakano );
        m90int2 (pc, 'sqcdbno 1   ', sqcdbno );
&       endif
        sqlcxap^.xakano := cpr_com_sql_conn;
        IF   (sqcdbno < 1) OR (sqcdbno >  mxpr_sqlga)
        THEN
            p08runtimeerror (sqcca, sqcca.sqlcxap^, cpr_db_session_not_allowed)
        ELSE
            WITH sqlgap^, gaentry [sqcdbno]^, gaxuserrec,
                 sqlrap^, sqloap^  DO
                BEGIN
&               ifdef TRACE
                m90int2 (pc, 'sqlcode  3  ', sqlcode );
                m90int2 (pc, 'xakano   3  ', sqlcxap^.xakano );
                m90int2 (pc, 'sqcdbno  3  ', sqcdbno );
                m90int4 (pc, 'sqcstmlen   ', sqcstmlen );
&               endif
                raactsession := sqcdbno;
                IF  (raactsession = cpr_se_primary)
                    AND (gauseropset = cpr_is_true)
                THEN
&                   ifdef SQLODBC
                    (* always change to cpr_ci_explicite *)
                    (* sqlarg3 ignores most of options *)
                    gasqlconntyp := cpr_ci_explicit
&                         else
                          gasqlconntyp := cpr_ci_program
&                         endif
                ELSE
                    gasqlconntyp := cpr_ci_implicit;
                (*ENDIF*) 
                IF   (sqcstmlen >= 0)
                THEN
                    BEGIN
&                   ifdef TRACE
                    m90int2 (pc, 'sqcdbno     ', sqcdbno );
&                   endif
                    cmdtyp := sp1m_dbs;
                    pr11cGetsqcstm (sqcca, xaSQLDesc^.ConDesc,
                          xaSQLDesc^.PacketEncoding, cmdtyp,
                          sqcstmlen, sqcstmbuf, encodingType, AnalyzeDesc);
                    sqlcxap^.xakano := cpr_com_sql_conn;
                    user   := bsp_knl_identifier;
                    passw  := bsp_name;
                    dbnode := bsp_nodeid;
                    dbname := bsp_dbname;
                    len := s30len1 (sqcuser, chr(0), mxsp_c64);
                    s10mv (mxsp_c64,  mxsp_c64, @sqcuser, 1,
                          @user, 1, len);
                    len := s30len2 (sqcpassw, chr(0), mxsp_name);
                    s10mv (mxsp_name, mxsp_name, @sqcpassw, 1, @passw, 1, len);
                    len := s30len4 (sqcdbnode, chr(0), NODEID_MXSP00);
&                   ifdef TRACE
                    m90int  (pc, 'len dbnode  ', len );
&                   endif
                    s10mv (NODEID_MXSP00, NODEID_MXSP00,
                          @sqcdbnode, 1,
                          @dbnode, 1, len);
                    len := s30len3 (sqcdbname, chr(0), DBNAME_MXSP00);
&                   ifdef TRACE
                    m90int  (pc, 'len dbname  ', len );
&                   endif
                    s10mv (DBNAME_MXSP00, DBNAME_MXSP00,
                          @sqcdbname, 1,
                          @dbname, 1, len);
                    IF  dbname <> bsp_dbname
                    THEN
                        BEGIN
                        xu_serverdb := dbname;
                        xu_servernode := dbnode;
                        END;
                    (*ENDIF*) 
                    IF  sqcuser <> bsp_knl_identifier
                    THEN
                        BEGIN
                        (* hole wert aus hostvariable *)
                        xu_user := user;
                        END;
                    (*ENDIF*) 
                    IF  sqcpassw <> bsp_name
                    THEN
                        BEGIN
                        (* get value wert from hostvariable *)
                        passwt := passw;
                        p03encrypt (passwt, xu_password);
                        END;
&                   ifdef TRACE
                    (*ENDIF*) 
                    m90buf  (pc, user     [1] , 1, 18 );
                    m90buf  (pc, passw    [1] , 1, 18 );
&                   endif
                    p03find_part (sqlrap, sp1pk_command, part_ptr);
                    WITH  part_ptr^, sp1p_part_header  DO
                        p08analyzeconnectstatm (sqcca, sqlcxap^, sqlgap^,
                              gae, dummyka, sp1p_buf_len, sp1p_buf);
                    (*ENDWITH*) 
                    IF  sqldbmode = cpr_kind_empty
                    THEN
                        sqldbmode := cpr_kind_internal;
                    (*ENDIF*) 
                    IF   gasqlconntyp = cpr_ci_program
                    THEN
                        gastatus := cpr_co_user_op
                    ELSE
                        gastatus := cpr_co_ok;
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    (* implicites connect *)
                    IF  sqldbmode = cpr_kind_empty
                    THEN
                        sqldbmode := cpr_kind_internal
                    ELSE
                        IF  sqldbmode <> cpr_kind_internal
                        THEN
                            pr01TraceRuntimeError (sqcca,
                                  sqlcxap^,cpr_differ_sqlmode_not_allowed);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF   gasqlconntyp = cpr_ci_program
                    THEN
                        gastatus := cpr_co_user_op
                    ELSE
                        gastatus := cpr_co_implicit;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                radbmode := sqldbmode;
                rakamode := sqldbmode;
                IF  sqlcode = 0
                THEN
                    BEGIN
                    p03conninfoget  (sqlgap, gae, raactsession);
                    sqcuser   := xu_user;
                    sqcdbname := xu_serverdb;
                    sqcdbnode := xu_servernode;
                    IF  (sqcdbname = bsp_dbname)
                        OR (sqcuser = bsp_knl_identifier)
                    THEN
                        p08runtimeerror (sqcca, sqlcxap^,
                              cpr_implicit_connect_wrong);
                    (*  f?ur profiling statement anf   *)
                    (*ENDIF*) 
                    IF  (raopprof <>  cpr_is_false)
                    THEN
                        (* sysprofile belegen *)
                        p03putsysprofbuf (sqlrap);
                    (*ENDIF*) 
                    parsret := cpr_parsidnull;
&                   ifdef TRACE
                    m90int (pc, 'gareference ',
                          gae.gareference);
&                   endif
                    p11connect (sqcca, gae);
                    p01xprofinit (sqcca, sqlcxap^, gae);
                    p10ansierror (sqcca, gae, parsret);
                    END;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10statement  (VAR sqcca : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcdbno   : tsp00_Int2;
            VAR sqcstmlen : tsp00_Int4;
            VAR sqcstmbuf : tsp00_MoveObj;
            encodingType : tpr05_StringEncoding);
 
VAR
      cmdtyp : tsp1_cmd_mess_type;
      again  : boolean;
      parsret: tpr_parsid;
      AnalyzeDesc : tpr05_StmtAnalysisDesc;
 
BEGIN
WITH sqcca,  sqlcxap^, sqlrap^  DO
    IF   (sqcdbno < 1) OR (sqcdbno >  mxpr_sqlga)
    THEN
        p08runtimeerror (sqcca, sqcca.sqlcxap^, cpr_db_session_not_allowed)
    ELSE
        BEGIN
        raactsession := sqcdbno;
        p03csqlcaareainit(sqcca);
        p01xtracefilecheck (sqcca, sqlcxap^);
        parsret := cpr_parsidnull;
        IF  sqlcode = 0
        THEN
            BEGIN
            again := false;
            sqlcxap^.xakano := cpr_com_sql;
            REPEAT
                cmdtyp := sp1m_dbs;
                pr11cGetsqcstm (sqcca, xaSQLDesc^.ConDesc,
                      xaSQLDesc^.PacketEncoding, cmdtyp, sqcstmlen,
                      sqcstmbuf, encodingType, AnalyzeDesc);
                p11statement (sqcca, gae);
                IF   (sqlcode = csp_old_fileversion)
                    OR  (sqlcode = cpr_file_or_table_droped)
                THEN
                    again := NOT again
                ELSE
                    again := false;
                (*ENDIF*) 
            UNTIL
                (NOT again);
            (*ENDREPEAT*) 
            p10ansierror (sqcca, gae, parsret);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10parse   (VAR sqcca   : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcdbno   : tsp00_Int2;
            VAR sqcstmlen : tsp00_Int4;
            VAR sqcstmbuf : tsp00_MoveObj;
            encodingType : tpr05_StringEncoding;
            VAR sqcda     : sqldavrec;
            VAR sqcparsid : tpr_parsid);
 
VAR
      again : boolean;
 
BEGIN
sqcca.sqlcxap^.xakano := cpr_com_sql;
again := false;
p10allparse (sqcca, gae, sqcdbno, sqcstmlen, sqcstmbuf, encodingType,
      sqcda, sqcparsid, again);
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10pars1    (VAR sqcca    : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcdbno   : tsp00_Int2;
            VAR sqcstmlen : tsp00_Int4;
            VAR sqcstmbuf : tsp00_MoveObj;
            encodingType : tpr05_StringEncoding;
            VAR sqcda     : sqldavrec;
            VAR sqcparsid : tpr_parsid);
 
BEGIN
p10parse ( sqcca, gae, sqcdbno, sqcstmlen, sqcstmbuf,
      encodingType, sqcda, sqcparsid );
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10parcc   (VAR sqcca   : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcdbno   : tsp00_Int2;
            VAR sqcstmlen : tsp00_Int4;
            VAR sqcstmbuf : tsp00_MoveObj;
            encodingType : tpr05_StringEncoding;
            VAR sqcda     : sqldavrec;
            VAR sqcparsid : tpr_parsid);
 
VAR
      again : boolean;
 
BEGIN
sqcca.sqlcxap^.xakano := cpr_com_sql;
(* no init for  hostvaraddr, hostindicator, hostvartype in sqlda-area *)
again := true;
p10allparse (sqcca, gae, sqcdbno, sqcstmlen, sqcstmbuf, encodingType,
      sqcda, sqcparsid, again);
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10allparse   (VAR sqcca   : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcdbno   : tsp00_Int2;
            VAR sqcstmlen : tsp00_Int4;
            VAR sqcstmbuf : tsp00_MoveObj;
            encodingType : tpr05_StringEncoding;
            VAR sqcda     : sqldavrec;
            VAR sqcparsid : tpr_parsid;
            VAR again     : boolean);
 
VAR
      cmdtyp : tsp1_cmd_mess_type;
      parsret: tpr_parsid;
      mtyp   : tsp00_Int2;
      AnalyzeDesc : tpr05_StmtAnalysisDesc;
 
BEGIN
WITH sqcca, sqlcxap^, sqlrap^ DO
    IF   (sqcdbno < 1) OR (sqcdbno >  mxpr_sqlga)
    THEN
        p08runtimeerror (sqcca, sqcca.sqlcxap^, cpr_db_session_not_allowed)
    ELSE
        BEGIN
        raactsession := sqcdbno;
        p03csqlcaareainit(sqcca);
        p01xtracefilecheck (sqcca, sqlcxap^);
        parsret := cpr_parsidnull;
        IF  sqlcode = 0
        THEN
            BEGIN
            REPEAT
                cmdtyp := sp1m_parse;
                pr11cGetsqcstm (sqcca, xaSQLDesc^.ConDesc,
                      xaSQLDesc^.PacketEncoding, cmdtyp, sqcstmlen,
                      sqcstmbuf, encodingType, AnalyzeDesc);
                p10setkamode (sqcca, sqcda);
                IF   (xakano = cpr_com_fetch_describe)
                    OR  (xakano = cpr_com_mfetch_describe)
                THEN
                    BEGIN
                    pr11cDescribe (sqcca, xaSQLDesc^.ConDesc,
                          xaSQLDesc^.PacketEncoding, sqcda, sqcparsid, again);
                    pr11cGetsqcstm (sqcca, xaSQLDesc^.ConDesc,
                          xaSQLDesc^.PacketEncoding, cmdtyp,
                          sqcstmlen, sqcstmbuf, encodingType, AnalyzeDesc);
                    pr11cFetchDescribe(sqcca, xaSQLDesc^.ConDesc,
                          xaSQLDesc^.PacketEncoding, sqcda, AnalyzeDesc );
                    END;
                (*ENDIF*) 
                IF  sqlcode = 0
                THEN
                    p11parse(sqcca, gae, sqcda, sqcparsid, again);
                (*ENDIF*) 
                IF   (sqlcode = csp_old_fileversion)
                    OR  (sqlcode = cpr_file_or_table_droped)
                THEN
                    again := NOT again
                ELSE
                    again := false;
                (*ENDIF*) 
            UNTIL
                (NOT again);
            (*ENDREPEAT*) 
            IF   sqlcode = 0
            THEN
                BEGIN
                (* check privelge commands *)
                mtyp := ord(sqcparsid [cpr_p_precom_index] );
                CASE mtyp OF
                    csp1_p_describe_found,
                    csp1_p_not_allowed_for_program :
                        p08runtimeerror (sqcca, sqcca.sqlcxap^,
                              cpr_cmd_not_available);
                    OTHERWISE:
                        BEGIN
                        END;
                    END;
                (*ENDCASE*) 
                END;
            (*ENDIF*) 
            parsret := sqcparsid;
            p10ansierror (sqcca, gae, parsret);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10execute  (VAR sqcca   : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcdbno   : tsp00_Int2;
            VAR sqcstmlen : tsp00_Int4;
            VAR sqcstmbuf : tsp00_MoveObj;
            encodingType : tpr05_StringEncoding;
            VAR sqcda     : sqldavrec;
            VAR sqcparsid : tpr_parsid;
            sqcrowcount   : tsp00_Int4);
 
VAR
      cnt    : tsp00_Int2;
      offset : tsp00_Int2;
 
BEGIN
cnt    := 0;
offset := 0;
sqcca.sqlcxap^.xakano := cpr_com_sql;
p10forexecute (sqcca, gae, sqcdbno, sqcstmlen, sqcstmbuf, encodingType,
      sqcda, sqcparsid, cnt, offset, sqcrowcount);
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10forexecute  (VAR sqcca   : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcdbno   : tsp00_Int2;
            VAR sqcstmlen : tsp00_Int4;
            VAR sqcstmbuf : tsp00_MoveObj;
            encodingType : tpr05_StringEncoding;
            VAR sqcda     : sqldavrec;
            VAR sqcparsid : tpr_parsid;
            VAR for_count  : tsp00_Int2;
            VAR offset_index : tsp00_Int2;
            sqcrowcount   : tsp00_Int4);
 
VAR
      diferr3 : integer;
      error   : tpr_runtime_errors;
      arrayparsid : boolean;
      com_kind    : integer;
 
BEGIN
WITH sqcca DO
    BEGIN
    diferr3     := 0;
    error       := cpr_p_ok;
    arrayparsid := true;
    sqcca.sqlcxap^.xakano := cpr_com_sql;
    IF  sqlrap^.rasqlansi = cpr_kind_ansi
    THEN
        BEGIN
        WITH  sqcda.sqldb DO
            BEGIN
            sqlloop    := for_count;
            sqloffset := offset_index;
            IF  sqlloop <> 0
            THEN
                error := cpr_not_implemented;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        END
    ELSE
        CASE sqldbmode OF
            cpr_kind_internal :
                BEGIN
                WITH  sqcda.sqldb DO
                    BEGIN
                    sqlloop    := for_count;
                    sqloffset := offset_index;
                    END;
                (*ENDWITH*) 
                END;
            cpr_kind_db2 :
                WITH  sqcda.db2 DO
                    BEGIN
                    sqlloop    := for_count;
                    sqloffset := offset_index;
                    IF  sqlloop <> 0
                    THEN
                        error := cpr_not_implemented;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            cpr_kind_oracle, cpr_kind_sapr3 :
                WITH  sqcda.orada DO
                    BEGIN
                    sqlloop    := for_count;
                    sqloffset := offset_index;
                    END;
                (*ENDWITH*) 
            OTHERWISE:
                BEGIN
                WITH  sqcda.sqldb DO
                    BEGIN
                    sqlloop    := for_count;
                    sqloffset := offset_index;
                    IF  sqlloop <> 0
                    THEN
                        error := cpr_not_implemented;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                END;
            END;
        (*ENDCASE*) 
    (*ENDIF*) 
    p03csqlcaareainit(sqcca);
    p01xtracefilecheck (sqcca, sqlcxap^);
    IF  error <> cpr_p_ok
    THEN
        p08runtimeerror (sqcca, sqlcxap^, error)
    ELSE
        BEGIN
        IF  for_count <> 0
        THEN
            p11checkarraycommand (sqcca, gae, sqcdbno, sqcstmlen, sqcstmbuf,
                  encodingType, sqcda, sqcparsid, arrayparsid)
        ELSE
            BEGIN
            (** ffetch geparsed **)
            com_kind := ord (sqcparsid [cpr_p_precom_index] );
            IF   (com_kind =  csp1_p_mfetch_found)
            THEN
                sqcca.sqlcxap^.xakano := cpr_com_mfetch;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  sqcca.sqlcode <> 0
        THEN
            p01xtimetrace (sqcca, sqlcxap^, gae)
        ELSE
            REPEAT
                p10allexecute (sqcca, gae, sqcdbno, sqcstmlen, sqcstmbuf,
                      encodingType, sqcda, sqcparsid, arrayparsid, sqcrowcount);
                CASE sqldbmode OF
                    cpr_kind_oracle, cpr_kind_sapr3 :
                        WITH  sqcda.orada DO
                            BEGIN
                            IF  sqlloop = 0
                            THEN
                                diferr3 := 0
                            ELSE
                                BEGIN
                                IF  for_count > 0
                                THEN
                                    diferr3 :=  sqlerrd [3] MOD for_count;
                                (*ENDIF*) 
                                sqlloop    := for_count - diferr3;
                                sqloffset := diferr3;
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDWITH*) 
                    OTHERWISE:
                        BEGIN
                        END;
                    END;
                (*ENDCASE*) 
            UNTIL
                (for_count <= diferr3)  OR (diferr3 = 0)
                OR (sqcca.sqlcode <> 0);
            (*ENDREPEAT*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10allexecute  (VAR sqcca   : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcdbno   : tsp00_Int2;
            VAR sqcstmlen : tsp00_Int4;
            VAR sqcstmbuf : tsp00_MoveObj;
            encodingType : tpr05_StringEncoding;
            VAR sqcda     : sqldavrec;
            VAR sqcparsid : tpr_parsid;
            VAR arrayparsid : boolean;
            sqcrowcount   : tsp00_Int4);
 
VAR
      cmdtyp : tsp1_cmd_mess_type;
      again  : boolean;
      parsret: tpr_parsid;
      AnalyzeDesc : tpr05_StmtAnalysisDesc;
 
BEGIN
WITH sqcca, sqlcxap^, sqlrap^  DO
    IF   (sqcdbno < 1) OR (sqcdbno >  mxpr_sqlga)
    THEN
        p08runtimeerror (sqcca, sqcca.sqlcxap^, cpr_db_session_not_allowed)
    ELSE
        BEGIN
        raactsession := sqcdbno;
        p01xtracefilecheck (sqcca, sqlcxap^);
        parsret := sqcparsid;
        IF  sqlcode = 0
        THEN
            BEGIN
            again := false;
            REPEAT
                cmdtyp := sp1m_execute;
                pr11cGetsqcstm (sqcca, xaSQLDesc^.ConDesc,
                      xaSQLDesc^.PacketEncoding, cmdtyp, sqcstmlen, sqcstmbuf,
                      encodingType, AnalyzeDesc);
                p10getkamode (sqcca, sqcda);
                p11execute  (sqcca, gae, sqcda, sqcparsid,
                      again, arrayparsid, sqcrowcount);
                IF  ((sqlcode = csp_old_fileversion)
                    OR  (sqlcode = cpr_file_or_table_droped))
&                   ifndef SQLODBC
                    AND NOT (again)
&                   else
                    AND again
&                   endif
                THEN
                    BEGIN
                    again := NOT again;
                    cmdtyp := sp1m_parse;
                    pr11cGetsqcstm (sqcca, xaSQLDesc^.ConDesc,
                          xaSQLDesc^.PacketEncoding, cmdtyp,
                          sqcstmlen, sqcstmbuf, encodingType, AnalyzeDesc);
                    IF   (xakano = cpr_com_fetch_describe)
                        OR  (xakano = cpr_com_mfetch_describe)
                    THEN
                        BEGIN
                        pr11cDescribe  (sqcca, xaSQLDesc^.ConDesc,
                              xaSQLDesc^.PacketEncoding, sqcda, sqcparsid, again);
                        pr11cGetsqcstm (sqcca, xaSQLDesc^.ConDesc,
                              xaSQLDesc^.PacketEncoding, cmdtyp,
                              sqcstmlen, sqcstmbuf, encodingType, AnalyzeDesc);
                        pr11cFetchDescribe(sqcca, xaSQLDesc^.ConDesc,
                              xaSQLDesc^.PacketEncoding, sqcda, AnalyzeDesc);
                        END;
                    (*ENDIF*) 
                    IF  sqlcode = 0
                    THEN
                        p11parse(sqcca, gae, sqcda, sqcparsid, again);
                    (*ENDIF*) 
                    END
                ELSE
                    again := false;
                (*ENDIF*) 
            UNTIL
                (NOT again);
            (*ENDREPEAT*) 
            p10ansierror (sqcca, gae, parsret);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10putlongdata  (VAR sqcca   : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcdbno   : tsp00_Int2;
            VAR sqcvarno  : tsp00_Int2;
            VAR sqcda     : sqldavrec;
            VAR sqcparsid : tpr_parsid);
 
VAR
      i        : integer;
      ind      : integer;
      sp_index : integer;
      pc_index : integer;
      lvcrec   : tpr_longvarcharrec;
      first    : boolean;
      collen   : tsp00_Int4;
      colno    : tsp00_Int2;
      res      : boolean;
 
BEGIN
WITH sqcca, sqlrap^, rasqlldp.vtypep^ DO
    BEGIN
    sqlrap^.raactsession := sqcdbno;
    (* suche pc_index, sp_index *)
    (* rowno wird nicht beachtet d.h. kein masscommand *)
    (* rette anfang tpr_sqlld *)
    ldmaxi   := ldretmaxi;
    ldmaxo   := ldretmaxo;
    ldindpc := ldretindpc;
    ldindsp := ldretindsp;
    colno       := sqcvarno;
    pc_index := 0;
    sp_index := 0;
&   ifdef TRACE
    m90int2 (pc, 'ldmaxi      ', ldmaxi  );
&   endif
    p11againtrace (sqcca, 5, true);
    FOR i := 1  TO ldmaxi DO
        WITH ldpc^ [i] DO
            BEGIN
&           ifdef TRACE
            m90int2 (pc, 'ldcolno     ', ldcolno   );
            m90int2 (pc, 'sqcvarno    ', sqcvarno   );
&           endif
            IF  ldcolno = sqcvarno
            THEN
                pc_index := i;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDFOR*) 
    FOR i := 1  TO ldmaxi DO
        WITH ldsp^ [i].descnew DO
            BEGIN
&           ifdef TRACE
            m90int2 (pc, 'pc_index    ', pc_index   );
            m90int2 (pc, 'ldb_valind  ', ldb_valind );
&           endif
            ind := ldb_valind;
            IF  pc_index = ind
            THEN
                sp_index := i;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDFOR*) 
&   ifdef TRACE
    m90int2 (pc, 'pc_index    ', pc_index   );
    m90int2 (pc, 'sp_index    ', sp_index   );
    m90int2 (pc, 'ldindsp     ', ldindsp);
&   endif
    WITH sqcda.sqldb.sqlvar [colno], ldpc^ [pc_index] DO
        BEGIN
        ldhostaddr :=  hostvaraddr;
        ldhosttype :=  hostvartype;
        ldhostlen  :=  collength;
        END;
    (*ENDWITH*) 
    IF  (ldindsp <> sp_index)
        AND (ldsp^ [ldindsp].descnew.
        ldb_valmode <> vm_lastdata)
    THEN
        BEGIN
        (* ldindsp descriptor nicht abgeschlossen *)
        (*  alte collno an anwender negativ zur?uck *)
        sqcvarno :=  ldpc^ [ldindpc].ldcolno;
        collen   := 0;
        END
    ELSE
        BEGIN
        ldindpc := pc_index;
        ldindsp := sp_index;
        collen      := sqcda.sqldb.sqlvar [colno].collength;
        END;
    (*ENDIF*) 
    WITH  ldpc^ [ldindpc] DO
        BEGIN
        p11pparsidtrace (sqcca, sqcparsid, 3);
        (* belege longvarchar record *)
        pr04LongLvcInitRec (sqcca, lvcrec);
        lvcrec.lvcnext  := true;
        ldhostlen       :=  collen;
        first            := true;
&       ifdef TRACE
        m90int2 (pc, 'ldhosttype  ', ldhosttype);
        m90int4 (pc, 'ldhostlen   ', ldhostlen );
        m90int4 (pc, 'dlhostlensum', ldhostlensum);
&       endif
        (* sende neue hostvariable putdata append *)
        res := pr04LongPOdbcData (sqcca, sqcca.sqlcxap^,
              gae, lvcrec, ldindsp, first);
        END;
    (*ENDWITH*) 
    WITH sqcda, ldpc^ [ldindpc] DO
        BEGIN
        IF  (ldallsend) AND (ldhostlen = 0)
        THEN
            BEGIN
            sqcvarno := 0;
            p01xtimetrace (sqcca, sqlcxap^, gae);
            pr04LongInitLD (sqcca, sqlcxap^);
            END
        ELSE
            sqcvarno :=  ldpc^ [ldindpc].ldcolno;
        (*ENDIF*) 
&       ifdef TRACE
        m90int2 (pc, 'pc_index    ', pc_index   );
        m90int2 (pc, 'sp_index    ', sp_index   );
        m90int2 (pc, 'ldindpc     ', ldindpc);
        m90int2 (pc, 'ldindsp     ', ldindsp);
        m90int2 (pc, 'ldcolno     ', ldcolno   );
        m90int2 (pc, 'sqcvarno    ', sqcvarno   );
&       endif
        END;
    (*ENDWITH*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10getlongdata  (VAR sqcca   : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcdbno   : tsp00_Int2;
            VAR sqcvarno  : tsp00_Int2;
            VAR sqcda     : sqldavrec;
            VAR sqcparsid : tpr_parsid);
 
VAR
      i        : integer;
      ind      : integer;
      sp_index : integer;
      pc_index : integer;
      lvcrec   : tpr_longvarcharrec;
      nextcol  : boolean;
      res      : boolean;
 
BEGIN
nextcol := true;
pc_index := 0;
sp_index := 0;
IF  sqcvarno > 0
THEN
    WITH sqcca, sqlrap^, rasqlldp.vtypep^, ldrestbufp.vtypep^ DO
        BEGIN
        p11againtrace (sqcca, 6, true);
        sqlrap^.raactsession := sqcdbno;
        IF  (rbcolno = sqcvarno)
        THEN
            nextcol := false;
        (* suche pc_index, sp_index *)
        (* rowno wird nicht beachtet d.h. kein masscommand *)
        (* rette anfang tpr_sqlld *)
        (* ldmaxi   := ldretmaxi;
              ldmaxo   := ldretmaxo;
              ldindpc := ldretindpc;
              ldindsp := ldretindsp; *)
&       ifdef TRACE
        (*ENDIF*) 
        m90int2 (pc, 'ldmaxo      ', ldmaxo  );
        m90int2 (pc, 'sqcvarno    ', sqcvarno   );
&       endif
        FOR i := 1  TO ldmaxo DO
            WITH ldpc^ [i] DO
                BEGIN
                IF  ldcolno = sqcvarno
                THEN
                    pc_index := i;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDFOR*) 
        FOR i := 1  TO ldmaxo DO
            WITH ldsp^ [i].descnew DO
                BEGIN
                ind := ldb_valind;
                IF  pc_index = ind
                THEN
                    sp_index := i;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDFOR*) 
        ldindpc := pc_index;
        ldindsp := sp_index;
&       ifdef TRACE
        m90int2 (pc, 'pc_index    ', pc_index   );
        m90int2 (pc, 'sp_index    ', sp_index   );
        m90int2 (pc, 'ldindsp     ', ldindsp);
        m90int2 (pc, 'ldindpc     ', ldindpc);
        m90int2 (pc, 'rbcolno     ', rbcolno);
        m90int2 (pc, 'rbrestlen   ', rbrestlen);
&       endif
        IF  rbcolno <> sqcvarno
        THEN
            BEGIN
            rbcolno      := sqcvarno;
            rbrestlen    := - csp_maxint2;
            rbhostlensum := 0;
            rblongcolmax := 0;
            END;
&       ifdef TRACE
        (*ENDIF*) 
        m90int2 (pc, 'pc_index    ', pc_index   );
        m90int2 (pc, 'sp_index    ', sp_index   );
        m90int2 (pc, 'rbcolno     ', rbcolno);
        m90int2 (pc, 'rbrestlen   ', rbrestlen);
        m90int4 (pc, 'rbhostlensum',  rbhostlensum );
        m90int4 (pc, 'rblongcolmax',  rblongcolmax );
&       endif
        IF  (rbcolno = sqcvarno)
        THEN
            BEGIN
            IF  (pr04LongOdbcColIsTrunc (sqcca, rbcolno) = false)
            THEN
                BEGIN
                (* ldindsp descriptor ist abgeschlossen *)
                (* naechste longspalte bearbeiten, oder negt. zur?uck *)
                sqcvarno := - sqcvarno;
                (****10.10.95 bf ******)
                IF  pc_index >= ldmaxo
                THEN
                    sqcvarno := 0
                ELSE
                    BEGIN
                    rbcolno :=  ldpc^ [pc_index+1].ldcolno;
                    rbrestlen    := - csp_maxint2;
                    rbhostlensum := 0;
                    rblongcolmax := 0;
                    END;
                (*ENDIF*) 
                END
            ELSE
                WITH sqcda.sqldb.sqlvar [sqcvarno],
                     ldpc^ [ldindpc] DO
                    BEGIN
                    p11pparsidtrace (sqcca, sqcparsid, 3);
                    (* neue hostvarible getnext datapart der longspalte *)
                    (* belege longvarchar record *)
                    pr04LongLvcInitRec (sqcca, lvcrec);
                    lvcrec.lvcnext  := true;
                    ldhostaddr :=  hostvaraddr;
                    ldhosttype :=  hostvartype;
                    (* ldhostlen  :=  collength; ) (* TSNEW *)
&                   ifdef TRACE
                    m90int2 (pc, 'ldhosttype  ', ldhosttype);
                    m90int2 (pc, 'dlhostlen   ', ldhostlen );
                    m90int2 (pc, 'dlhostlensum', ldhostlensum);
&                   endif
                    (* restbuf in Hostvarible bringen  *)
                    (* sende neue hostvariable putdata append *)
                    res := pr04LongGetvalOutput (sqcca, sqcca.sqlcxap^,
                          gae, ldindsp);
&                   ifdef TRACE
                    m90int2 (pc, 'ldindsp     ', ldindsp);
                    m90int2 (pc, 'ldindpc     ', ldindpc);
                    m90int2 (pc, 'rbcolno     ', rbcolno);
                    m90int2 (pc, 'rbrestlen   ', rbrestlen);
                    m90int4 (pc, 'rbhostlensum',  rbhostlensum );
                    m90int4 (pc, 'rblongcolmax',  rblongcolmax );
&                   endif
                    IF  (rbrestlen = 0)
                    THEN
                        BEGIN
                        IF  ldindpc = ldmaxo
                        THEN
                            BEGIN
                            rbcolno := 0;
                            sqcvarno := 0;
                            END
                        ELSE
                            sqcvarno := - rbcolno;
                        (*ENDIF*) 
                        p01xtimetrace (sqcca, sqlcxap^, gae);
                        pr04LongInitLD (sqcca, sqlcxap^);
                        END
                    ELSE
                        sqcvarno :=  rbcolno;
                    (*ENDIF*) 
&                   ifdef TRACE
                    m90int2 (pc, 'ldmaxo      ', ldmaxo  );
                    m90int2 (pc, 'ldindpc     ', ldindpc);
                    m90int2 (pc, 'rbcolno     ', rbcolno);
                    m90int2 (pc, 'rbrestlen   ', rbrestlen);
&                   endif
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10setmacro    (VAR sqcca : sqlcatype;
            VAR macrono   : tsp00_Int2;
            VAR macroval  : tpr_macroline);
 
VAR
      ma_len   : integer;
 
BEGIN
WITH sqcca,  sqlmap^, maentry [macrono ] DO
    BEGIN
    ma_len := s30len (macroval, chr(0), mxpr_macroline);
    ma_len := s30klen (macroval, bsp_c1, ma_len);
    IF   maversion >= csp_maxint4 - 2
    THEN
        maversion := cpr_minint4 + 1
    ELSE
        maversion := maversion + 1;
    (*ENDIF*) 
    IF  ma_len > mxpr_macroline
    THEN
        malen := mxpr_macroline
    ELSE
        malen := ma_len;
    (*ENDIF*) 
    SAPDB_PascalForcedFill (mxpr_macroline, @maval, 1, mxpr_macroline, bsp_c1);
    IF   malen > 0
    THEN
        s10mv (mxpr_macroline, mxpr_macroline, @macroval, 1,
              @maval, 1, malen);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10dropparsid  (VAR sqcca : sqlcatype;
            gae : sqlgaentrypointer;
            VAR sqcdbno   : tsp00_Int2;
            VAR sqcparsid : tpr_parsid);
 
VAR
      nam : tsp00_Name;
      retparsid : tpr_parsid;
 
BEGIN
WITH sqcca, sqlcxap^, sqlrap^, rasqltap^ DO
    IF   (sqcdbno < 1) OR (sqcdbno >  mxpr_sqlga)
    THEN
        p08runtimeerror (sqcca, sqcca.sqlcxap^, cpr_db_session_not_allowed)
    ELSE
        BEGIN
        raactsession := sqcdbno;
        sqcca.sqlcode := 0;
        retparsid     := sqcparsid;
        p01bdrop_parsid (sqcca, sqcca.sqlcxap^, sqcparsid);
        IF  gae <> NIL
        THEN
            p03dropparsid (sqcca, sqcca.sqlcxap^, gae^, sqcparsid);
        (*ENDIF*) 
        IF   tatraceno <> 0
        THEN
            BEGIN
            nam  := 'SQCDROPPARSID     ';
            p11trace (sqcca, nam);
            p11pparsidtrace (sqcca, retparsid, 3);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10release  (VAR sqcca   : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcdbno   : tsp00_Int2);
 
VAR
      nam : tsp00_Name;
 
BEGIN
WITH sqcca, sqlcxap^, sqlrap^, rasqltap^ DO
    IF   (sqcdbno < 1) OR (sqcdbno >  mxpr_sqlga)
    THEN
        p08runtimeerror (sqcca, sqcca.sqlcxap^, cpr_db_session_not_allowed)
    ELSE
        BEGIN
        raactsession := sqcdbno;
        sqcca.sqlcode := 0;
&       ifndef SQLODBC
        pr03cRelease (xaSQLDesc^.ConDesc);
        IF   tatraceno <> 0
        THEN
            BEGIN
            nam  := 'SQCRELEASE DBNO=  ';
            nam [17] := chr(sqcdbno + ord('0'));
            p11trace (sqcca, nam);
            END;
&       else
        (*ENDIF*) 
        IF   tatraceno <> 0
        THEN
            pa01TraceSession(cpr_com_commit_release);
        (*ENDIF*) 
        IF  pa01UtilityConnect = 0
        THEN
            pr03cRelease (xaSQLDesc^.ConDesc)
        ELSE
            pa01SqlRelease;
        (*ENDIF*) 
&       endif
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10cancel  (VAR sqcca   : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcdbno   : tsp00_Int2);
 
VAR
      nam : tsp00_Name;
 
BEGIN
WITH sqcca, sqlcxap^, sqlrap^, rasqltap^ DO
    IF   (sqcdbno < 1) OR (sqcdbno >  mxpr_sqlga)
    THEN
        p08runtimeerror (sqcca, sqcca.sqlcxap^, cpr_db_session_not_allowed)
    ELSE
        BEGIN
        raactsession := sqcdbno;
        sqcca.sqlcode := 0;
        IF   tatraceno <> 0
        THEN
            BEGIN
            nam  := 'SQCCANCEL  DBNO=  ';
            nam [17] := chr(sqcdbno + ord('0'));
            p11trace (sqcca, nam);
            END;
        (*ENDIF*) 
        p03cancel (sqcca, gae);
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10finish  (VAR sqcca   : sqlcatype);
 
VAR
      i : integer;
      nam : tsp00_Name;
 
BEGIN
WITH sqcca, sqlcxap^, sqlgap^, sqlrap^, rasqltap^  DO
    BEGIN
    FOR i := 1 TO mxpr_sqlga DO
        BEGIN
        IF   gaentry [i]^ .gareference <> 0
        THEN
            BEGIN
            raactsession := i;
            (* commit release *)
            sqcca.sqlcode := 0;
            pr03cRelease(xaSQLDesc^.ConDesc);
            END;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    IF   tatraceno <> 0
    THEN
        BEGIN
        nam  := 'SQCFINISH         ';
        p11trace (sqcca, nam);
        p01xvfclosetrace (sqcca);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
p03sqlfree (sqcca);
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10getinfo  (VAR sqcca   : sqlcatype;
            VAR sqcvarno    : tsp00_Int2;
            VAR sqcvarinfo: sqlvarvrec;
            VAR sqcda     : sqldavrec;
            VAR sqcerr    : tsp00_Int2);
 
BEGIN
sqcerr := cpr_c_ok;
IF  sqcca.sqldbmode = cpr_kind_internal
THEN
    BEGIN
    WITH sqcda.sqldb DO
        BEGIN
        IF   (sqcvarno < 1) OR (sqcvarno > sqlmax)
        THEN
            sqcerr := cpr_c_varnowrong
        ELSE
            sqcvarinfo.sqldbv := sqlvar [sqcvarno] ;
        (*ENDIF*) 
        END
    (*ENDWITH*) 
    END
ELSE
    WITH sqcda.db2 DO
        BEGIN
        IF   (sqcvarno < 1) OR (sqcvarno > sqln)
        THEN
            sqcerr := cpr_c_varnowrong
        ELSE
            sqcvarinfo.db2v := sqlvardb2 [sqcvarno] ;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10putinfo  (VAR sqcca   : sqlcatype;
            VAR sqcvarno    : tsp00_Int2;
            VAR sqcvarinfo: sqlvarvrec;
            VAR sqcda     : sqldavrec;
            VAR sqcerr    : tsp00_Int2);
 
BEGIN
sqcerr := cpr_c_ok;
IF  sqcca.sqldbmode = cpr_kind_internal
THEN
    BEGIN
    WITH sqcda.sqldb DO
        BEGIN
        IF   (sqcvarno < 1) OR (sqcvarno > sqlmax)
        THEN
            sqcerr := cpr_c_varnowrong
        ELSE
            sqlvar [sqcvarno] := sqcvarinfo.sqldbv;
        (*ENDIF*) 
        END
    (*ENDWITH*) 
    END
ELSE
    WITH sqcda.db2 DO
        BEGIN
        IF   (sqcvarno < 1) OR (sqcvarno > sqln)
        THEN
            sqcerr := cpr_c_varnowrong
        ELSE
            sqlvardb2 [sqcvarno] := sqcvarinfo.db2v;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10int2bind  (VAR sqcca   : sqlcatype;
            VAR sqcvarno    : tsp00_Int2;
            VAR varint2   : tsp00_Int2;
            VAR sqcda     : sqldavrec;
            VAR sqcerr    : tsp00_Int2);
 
BEGIN
IF  sqcca.sqldbmode <> cpr_kind_internal
THEN
    sqcerr := cpr_c_notimplemented
ELSE
    p11getxsqcerr (sqcvarno, cpr_vint2, sqcda, sqcerr);
(*ENDIF*) 
IF   sqcerr = cpr_c_ok
THEN
    WITH sqcda.sqldb, sqlvar [sqcvarno] DO
        hostvaraddr.intaddr :=  s30gad (varint2);
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10int4bind  (VAR sqcca   : sqlcatype;
            VAR sqcvarno    : tsp00_Int2;
            VAR varint4   : tsp00_Int4;
            VAR sqcda     : sqldavrec;
            VAR sqcerr    : tsp00_Int2);
 
BEGIN
IF  sqcca.sqldbmode <> cpr_kind_internal
THEN
    sqcerr := cpr_c_notimplemented
ELSE
    p11getxsqcerr (sqcvarno, cpr_vint4, sqcda, sqcerr);
(*ENDIF*) 
IF   sqcerr = cpr_c_ok
THEN
    WITH sqcda.sqldb,  sqlvar [sqcvarno] DO
        hostvaraddr.intaddr :=  s30gad1 (varint4);
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10uns2bind  (VAR sqcca   : sqlcatype;
            VAR sqcvarno    : tsp00_Int2;
            VAR varuns2   : tsp00_Int2;
            VAR sqcda     : sqldavrec;
            VAR sqcerr    : tsp00_Int2);
 
BEGIN
IF  sqcca.sqldbmode <> cpr_kind_internal
THEN
    sqcerr := cpr_c_notimplemented
ELSE
    p11getxsqcerr (sqcvarno, cpr_vuns2, sqcda, sqcerr);
(*ENDIF*) 
IF   sqcerr = cpr_c_ok
THEN
    WITH sqcda.sqldb, sqlvar [sqcvarno] DO
        hostvaraddr.intaddr :=  s30gad (varuns2);
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10uns4bind  (VAR sqcca   : sqlcatype;
            VAR sqcvarno    : tsp00_Int2;
            VAR varuns4   : tsp00_Int4;
            VAR sqcda     : sqldavrec;
            VAR sqcerr    : tsp00_Int2);
 
BEGIN
IF  sqcca.sqldbmode <> cpr_kind_internal
THEN
    sqcerr := cpr_c_notimplemented
ELSE
    p11getxsqcerr (sqcvarno, cpr_vuns4, sqcda, sqcerr);
(*ENDIF*) 
IF   sqcerr = cpr_c_ok
THEN
    WITH sqcda.sqldb, sqlvar [sqcvarno] DO
        hostvaraddr.intaddr :=  s30gad1 (varuns4);
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10r4bind  (VAR sqcca   : sqlcatype;
            VAR sqcvarno   : tsp00_Int2;
            VAR varreal4  : tsp00_Shortreal;
            VAR sqcda     : sqldavrec;
            VAR sqcerr    : tsp00_Int2);
 
BEGIN
IF  sqcca.sqldbmode <> cpr_kind_internal
THEN
    sqcerr := cpr_c_notimplemented
ELSE
    p11getxsqcerr (sqcvarno, cpr_vreal4, sqcda, sqcerr);
(*ENDIF*) 
IF   sqcerr = cpr_c_ok
THEN
    WITH sqcda.sqldb, sqlvar [sqcvarno] DO
        hostvaraddr.intaddr :=  s30gad2 (varreal4);
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10r8bind  (VAR sqcca   : sqlcatype;
            VAR sqcvarno   : tsp00_Int2;
            VAR varreal8  : tsp00_Longreal;
            VAR sqcda     : sqldavrec;
            VAR sqcerr    : tsp00_Int2);
 
BEGIN
IF  sqcca.sqldbmode <> cpr_kind_internal
THEN
    sqcerr := cpr_c_notimplemented
ELSE
    p11getxsqcerr (sqcvarno, cpr_vreal8, sqcda, sqcerr);
(*ENDIF*) 
IF   sqcerr = cpr_c_ok
THEN
    WITH sqcda.sqldb, sqlvar [sqcvarno] DO
        hostvaraddr.intaddr :=  s30gad3 (varreal8);
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10charbind  (VAR sqcca   : sqlcatype;
            VAR sqcvarno    : tsp00_Int2;
            VAR varcharlen: tsp00_Int4;
            VAR varchar   : tpr_char_array;
            VAR sqcda     : sqldavrec;
            VAR sqcerr    : tsp00_Int2);
 
BEGIN
IF  sqcca.sqldbmode <> cpr_kind_internal
THEN
    sqcerr := cpr_c_notimplemented
ELSE
    p11getxsqcerr (sqcvarno, cpr_vchar, sqcda, sqcerr);
(*ENDIF*) 
IF   sqcerr = cpr_c_ok
THEN
    WITH sqcda.sqldb, sqlvar [sqcvarno] DO
        BEGIN
        IF   (colio = cpr_info_input) AND (collength < varcharlen)
        THEN
            sqcerr := cpr_c_truncated
        ELSE
            IF   (colio = cpr_info_output) AND (collength > varcharlen)
            THEN
                sqcerr := cpr_c_truncated;
            (*ENDIF*) 
        (*ENDIF*) 
        hostvaraddr.intaddr := s30gad4 (varchar);
        collength   := varcharlen;
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10ccharbind  (VAR sqcca   : sqlcatype;
            VAR sqcvarno   : tsp00_Int2;
            VAR varccharlen: tsp00_Int4;
            VAR varcchar  : tpr_char_array;
            VAR sqcda     : sqldavrec;
            VAR sqcerr    : tsp00_Int2);
 
VAR
      len : tsp00_Int2;
 
BEGIN
IF  sqcca.sqldbmode <> cpr_kind_internal
THEN
    sqcerr := cpr_c_notimplemented
ELSE
    p11getxsqcerr (sqcvarno, cpr_vcharc, sqcda, sqcerr);
(*ENDIF*) 
IF   sqcerr = cpr_c_ok
THEN
    WITH sqcda.sqldb, sqlvar [sqcvarno] DO
        BEGIN
        len := collength + 1;
        IF   (colio = cpr_info_input) AND (len < varccharlen)
        THEN
            sqcerr := cpr_c_truncated
        ELSE
            IF   (colio = cpr_info_output) AND (len > varccharlen)
            THEN
                sqcerr := cpr_c_truncated;
            (*ENDIF*) 
        (*ENDIF*) 
        hostvaraddr.intaddr := s30gad4 (varcchar);
        collength   := varccharlen;
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10zonedbind  (VAR sqcca   : sqlcatype;
            VAR sqcvarno   : tsp00_Int2;
            VAR varzonedlen   : tsp00_Int2;
            VAR varzonedfrac  : tsp00_Int2;
            VAR varzoned  : tpr_char_array;
            VAR sqcda     : sqldavrec;
            VAR sqcerr    : tsp00_Int2);
 
BEGIN
IF  sqcca.sqldbmode <> cpr_kind_internal
THEN
    sqcerr := cpr_c_notimplemented
ELSE
    p11getxsqcerr (sqcvarno, cpr_vzoned, sqcda, sqcerr);
(*ENDIF*) 
IF   sqcerr = cpr_c_ok
THEN
    WITH sqcda.sqldb, sqlvar [sqcvarno] DO
        BEGIN
        hostvaraddr.intaddr := s30gad4 (varzoned);
        collength   := varzonedlen;
        colfrac     := varzonedfrac;
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10decbind  (VAR sqcca   : sqlcatype;
            VAR sqcvarno   : tsp00_Int2;
            VAR vardeclen   : tsp00_Int2;
            VAR vardecfrac  : tsp00_Int2;
            VAR vardec  : tpr_char_array;
            VAR sqcda   : sqldavrec;
            VAR sqcerr  : tsp00_Int2);
 
BEGIN
IF  sqcca.sqldbmode <> cpr_kind_internal
THEN
    sqcerr := cpr_c_notimplemented
ELSE
    p11getxsqcerr (sqcvarno, cpr_vdecimal, sqcda, sqcerr);
(*ENDIF*) 
IF   sqcerr = cpr_c_ok
THEN
    WITH sqcda.sqldb, sqlvar [sqcvarno] DO
        BEGIN
        hostvaraddr.intaddr := s30gad4 (vardec);
        collength   := vardeclen;
        colfrac     := vardecfrac;
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10v1stringbind  (VAR sqcca   : sqlcatype;
            VAR sqcvarno    : tsp00_Int2;
            VAR v1stringlen : tsp00_Int2;
            VAR v1char    : tpr_char_array;
            VAR sqcda     : sqldavrec;
            VAR sqcerr    : tsp00_Int2);
 
BEGIN
IF  sqcca.sqldbmode <> cpr_kind_internal
THEN
    sqcerr := cpr_c_notimplemented
ELSE
    p11getxsqcerr (sqcvarno, cpr_vstring1, sqcda, sqcerr);
(*ENDIF*) 
IF   sqcerr = cpr_c_ok
THEN
    WITH sqcda.sqldb, sqlvar [sqcvarno] DO
        BEGIN
        IF   (colio = cpr_info_input) AND (collength < v1stringlen)
        THEN
            sqcerr := cpr_c_truncated
        ELSE
            IF   (colio = cpr_info_output) AND (collength > v1stringlen)
            THEN
                sqcerr := cpr_c_truncated;
            (*ENDIF*) 
        (*ENDIF*) 
        hostvaraddr.intaddr := s30gad4 (v1char);
        collength   := v1stringlen;
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10v2stringbind  (VAR sqcca   : sqlcatype;
            VAR sqcvarno    : tsp00_Int2;
            VAR v2stringlen : tsp00_Int2;
            VAR v2string  : tpr_string;
            VAR sqcda     : sqldavrec;
            VAR sqcerr    : tsp00_Int2);
 
BEGIN
IF  sqcca.sqldbmode <> cpr_kind_internal
THEN
    sqcerr := cpr_c_notimplemented
ELSE
    p11getxsqcerr (sqcvarno, cpr_vstring, sqcda, sqcerr);
(*ENDIF*) 
IF   sqcerr = cpr_c_ok
THEN
    WITH sqcda.sqldb, sqlvar [sqcvarno] DO
        BEGIN
        IF   (colio = cpr_info_input) AND (collength < v2stringlen)
        THEN
            sqcerr := cpr_c_truncated
        ELSE
            IF   (colio = cpr_info_output) AND (collength > v2stringlen)
            THEN
                sqcerr := cpr_c_truncated;
            (*ENDIF*) 
        (*ENDIF*) 
        hostvaraddr.intaddr := s30gad5 (v2string);
        collength   := v2stringlen;
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10command   (VAR sqcca   : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcmode     : tsp00_Int2;
            VAR sqcstmlen   : tsp00_Int4;
            VAR sqcstmbuf : tsp00_MoveObj;
            encodingType : tpr05_StringEncoding;
            VAR sqcresult : tsp00_Int2);
 
VAR
      ex_args  : tsp00_ExecLine;
      ex_mode  : tsp00_ExecMode;
      spec_complete : boolean;
      ex_return : tsp00_ExecReturn;
      err_text  : tsp00_ErrText;
      nam         : tsp00_Name;
      cmdtyp      : tsp1_cmd_mess_type;
      parsret     : tpr_parsid;
      AnalyzeDesc : tpr05_StmtAnalysisDesc;
      part_ptr : tsp1_part_ptr;
      dummyka : ^sqlkaentry;
 
BEGIN
WITH sqcca, sqlcxap^, sqlrap^, rasqltap^, sqlemp^  DO
    BEGIN
    xakano := cpr_com_command;
    cmdtyp := sp1m_dbs;
    pr11cGetsqcstm (sqcca, xaSQLDesc^.ConDesc, xaSQLDesc^.PacketEncoding,
          cmdtyp, sqcstmlen, sqcstmbuf, encodingType, AnalyzeDesc);
    p03csqlcaareainit(sqcca);
    p01xtracefilecheck (sqcca, sqlcxap^);
    parsret := cpr_parsidnull;
    p03cmdtrace (sqcca.sqlrap, gae, 1, cpr_com_command, NIL);
    spec_complete := true;
    p03find_part (sqlrap, sp1pk_command, part_ptr);
    WITH  part_ptr^, sp1p_part_header  DO
        s70execanalyze (sp1p_buf, sp1p_buf_len-1, ex_args,
              ex_mode, spec_complete);
    (*ENDWITH*) 
    tastr80l:= 1;
    CASE sqcmode OF
        0 :
            BEGIN
            nam     := 'SYNC              ';
            ex_mode :=  sync_same_session;
            END;
        1 :
            BEGIN
            nam     := 'NEWSYNC           ';
            ex_mode :=  sync_new_session;
            END;
        2 :
            BEGIN
            nam     := 'ASYNC             ';
            ex_mode :=  async;
            END;
        OTHERWISE:
        END;
    (*ENDCASE*) 
    IF  tatraceno <> 0
    THEN
        BEGIN
        s10mv (mxsp_name, mxsp_c256, @nam, 1,
              @tastr80, tastr80l+1, mxsp_name);
        tastr80l := tastr80l + mxsp_name;
        p08vfwritetrace (sqlrap);
        IF  ranotrtimeoutp = cpr_is_false
        THEN
            sqldattime (tastartdate, tastarttime);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    sqlexec (ex_args, ex_mode,
          ex_return, err_text, sqcresult);
    IF  tatraceno <> 0
    THEN
        IF  ranotrtimeoutp = cpr_is_false
        THEN
            sqldattime (taenddate, taendtime);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  ex_return <> ex_ok
    THEN
        BEGIN
        ereturncode   := -11000 -ord (ex_return);
        eerrorpos     := 0;
        etextlen       := ERRTEXT_MXSP00;
        s10mv (ERRTEXT_MXSP00, mxsp_c70, @err_text, 1,
              @etext, 1, ERRTEXT_MXSP00);
        p03returncodeget(sqcca, sqlcxap^);
        END;
    (*ENDIF*) 
    p10ansierror (sqcca, gae, parsret);
    p01xtimetrace (sqcca, sqlcxap^, gae);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10ansierror (VAR sqcca   : sqlcatype;
            VAR gae : sqlgaentry;
            VAR parsret : tpr_parsid);
 
BEGIN
WITH sqcca DO
    BEGIN
    p10profend (sqcca, gae, parsret);
    IF  sqlrap^.rasqlansi = cpr_kind_ansi
    THEN
        BEGIN
        IF  (sqlcode = 250)
            OR (sqlcode = 300)
            OR (sqlcode = 320)
        THEN
            sqlcode := - sqlcode;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10profend  (VAR sqcca   : sqlcatype;
            VAR gae : sqlgaentry;
            VAR parsret : tpr_parsid);
 
VAR
      lineno  : tsp00_Int4;
      len     : tsp00_Int2;
      parsid  : tpr_parsid;
      vptr    : tpr_vtypepointer;
 
BEGIN
WITH sqcca, sqlcxap^, sqlgap^, sqlrap^ DO
    IF  (raopprof <>  cpr_is_false)
    THEN
        BEGIN
        p03csqlclock (sqlrap, cpr_is_end);
        IF  raactsession > 0
        THEN
            WITH  sqlmap^  DO
                BEGIN
                (*         sec := raprofsec;  *)
                lineno := 0;
                vptr.intaddr := raprofstmtp;
                IF  parsret = cpr_parsidnull
                THEN
                    BEGIN
                    len := vptr.vtypep^.i2;
                    IF  len > mxpr_parsid
                    THEN
                        len := mxpr_parsid;
                    (*ENDIF*) 
                    parsid := '                ';
                    s10mv (mxsp_c40, mxpr_parsid,
                          @vptr.vtypep^, 3,
                          @parsid, 1,  len);
                    END
                ELSE
                    parsid := parsret;
                (*ENDIF*) 
                (*p16profexec (sqlrap, gae, raprofstmtp, xaprogn,
                      xamodn, ralang, lineno, parsid, sqlemp);*)
                (**   p16prof (gareference, ratermid, sqlrap^.rapacket,
                      gaxuserrec.xu_user,
                      xaprogn, xamodn, ralang, lineno, parsid,
                      raprofstmtp, sec, retcode);
                      ******)
                p03sysproferror (sqcca, gae);
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10setkamode    (VAR sqcca  : sqlcatype;
            VAR sqcda : sqldavrec);
 
BEGIN
WITH sqcca, sqlgap^, sqlrap^  DO
    CASE sqldbmode OF
        cpr_kind_internal :
            BEGIN
            WITH  sqcda.sqldb DO
                BEGIN
                sqlkamode  := rakamode;
                END;
            (*ENDWITH*) 
            END;
        cpr_kind_db2 :
            WITH  sqcda.db2 DO
                BEGIN
                sqlkamode  := rakamode;
                END;
            (*ENDWITH*) 
        cpr_kind_oracle, cpr_kind_sapr3 :
            WITH  sqcda.orada DO
                BEGIN
                sqlkamode  := rakamode;
                END;
            (*ENDWITH*) 
        OTHERWISE:
            BEGIN
            END;
        END;
    (*ENDCASE*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p10getkamode    (VAR sqcca  : sqlcatype;
            VAR sqcda : sqldavrec);
 
BEGIN
WITH sqcca, sqlgap^, sqlrap^  DO
    CASE sqldbmode OF
        cpr_kind_internal :
            BEGIN
            WITH  sqcda.sqldb DO
                BEGIN
                rakamode := sqlkamode;
                END;
            (*ENDWITH*) 
            END;
        cpr_kind_db2 :
            WITH  sqcda.db2 DO
                BEGIN
                rakamode := sqlkamode;
                END;
            (*ENDWITH*) 
        cpr_kind_oracle, cpr_kind_sapr3 :
            WITH  sqcda.orada DO
                BEGIN
                rakamode := sqlkamode;
                END;
            (*ENDWITH*) 
        OTHERWISE:
            BEGIN
            END;
        END;
    (*ENDCASE*) 
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
