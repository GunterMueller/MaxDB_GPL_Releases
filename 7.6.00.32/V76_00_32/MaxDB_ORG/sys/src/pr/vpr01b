.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.tt 1 $SQL$Project Distributed Database System$VPR01B$
.tt 2 $$$
.TT 3 $$Fetch-Optimization$$$2001-06-25$
***********************************************************
.nf
 
 .nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : Fetch-Optimierung
=========
.sp
Purpose : Fetch commands are changed  in mfetch commands.
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              p01bdrop_parsid (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR parsid : tpr_parsid);
 
        PROCEDURE
              p01bbparsen  (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR ga : sqlgaentry;
                    VAR ka : sqlkaentry;
                    VAR cmdfetch : tsp00_Int2);
 
        PROCEDURE
              p01baparsen  (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR ga : sqlgaentry;
                    VAR ka : sqlkaentry;
                    VAR cmdfetch : tsp00_Int2);
 
        FUNCTION
              p01bmfetch(VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR ga : sqlgaentry;
                    VAR ka : sqlkaentry;
                    VAR cmdfetch : tsp00_Int2;
                    sqcrowcount   : tsp00_Int4) : tsp00_Int2;
 
        FUNCTION
              p01bmselect(VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR ka : sqlkaentry) : tsp00_Int2;
 
        PROCEDURE
              p01baexecute  (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry;
                    VAR kae : sqlkaentry;
                    VAR ore : sqlorentry);
 
        PROCEDURE
              p01bafterexecute (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR ga : sqlgaentry;
                    kae    : sqlkaentry_ptr;
                    ore    : sqlorentry_ptr;
                    VAR parsid: tpr_parsid);
 
        PROCEDURE
              p01bgetmfetch  (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR ga : sqlgaentry;
                    VAR ka : sqlkaentry;
                    sqcrowcount   : tsp00_Int4);
 
        PROCEDURE
              p01mfentryinit  (VAR sqlca : sqlcatype;
                    VAR index   : integer);
 
        PROCEDURE
              p01bnewmfetch (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR ga : sqlgaentry;
                    VAR fa_entry : sqlfaentry;
                    sqcrowcount   : tsp00_Int4);
 
        PROCEDURE
              p01bnextrecord  (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR ga : sqlgaentry;
                    kae : sqlkaentry_ptr;
                    VAR faentry : sqlfaentry;
                    VAR mf_index : tsp00_Int2;
                    VAR cmdfetch : tsp00_Int2;
                    sqcrowcount   : tsp00_Int4);
 
        PROCEDURE
              p01bsearchnextrec (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR ga : sqlgaentry;
                    kae : sqlkaentry_ptr;
                    VAR faentry : sqlfaentry;
                    VAR mfindex : tsp00_Int2;
                    VAR cmdfetch : tsp00_Int2;
                    sqcrowcount   : tsp00_Int4);
 
        FUNCTION
              p01bmfentryget(VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR selparsid: tpr_parsid) : tsp00_Int2;
 
        FUNCTION
              p01bmfentryadd(VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    selparsid : tpr_parsid;
                    resname : tsp00_KnlIdentifier) : integer;
 
        FUNCTION
              pr01bNumberOfRows(VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype) : tsp00_Int4;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Precompiler_Runtime_Routinen  : VPR08;
 
        PROCEDURE
              p08runtimeerror (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    error : tpr_runtime_errors);
 
        PROCEDURE
              p08puttracename (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR nam   : tsp00_Name;
                    naml      : tsp00_Int2;
                    trwrite   : boolean);
 
        PROCEDURE
              p08vfwritetrace (sqlrap : sqlrapointer);
 
      ------------------------------ 
 
        FROM
              Runtime-Stringroutinen   : VPR05;
 
        PROCEDURE
              p05inttochr12 (int : integer;
                    VAR chr12 : tsp00_C12);
 
      ------------------------------ 
 
        FROM
              SQLDB-Auftrags-Schnittstelle   : VPR03;
 
        PROCEDURE
              p03partptrinit  (sqlrap : sqlrapointer);
 
        PROCEDURE
              p03find_part  (sqlrap : sqlrapointer;
                    part_kind        : tsp1_part_kind;
                    VAR part_ptr     : tsp1_part_ptr);
 
        PROCEDURE
              p03gselparsid  (sqlrap : sqlrapointer;
                    sqlemp : sqlempointer;
                    VAR parsid : tpr_parsid;
                    VAR SessionID : tpr00_SessionID);
 
      ------------------------------ 
 
        FROM
              C-Type-Checker-Module  : VPR102;
 
        PROCEDURE
              p03cresultcountget (sqlrap :sqlrapointer;
                    VAR ga          : sqlgaentry ;
                    VAR resultcount : tsp00_Int4);
 
        PROCEDURE
              p03dynalloc (VAR desc: tpr_sqlmdesc);
 
        PROCEDURE
              p03DebugBreak;
 
        PROCEDURE
              p04trline(sqlrap : sqlrapointer; szStr : tsp00_Name);
 
        PROCEDURE
              p04trint2(sqlrap : sqlrapointer; szStr : tsp00_Name; cbValue : tsp00_Int2);
 
        PROCEDURE
              p04trint4(sqlrap : sqlrapointer; szStr : tsp00_Name; cbValue : tsp00_Int4);
 
        FUNCTION
              pr04GetLoopCnt(VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR looprec : tpr_sqlloop) : tsp00_Int4;
 
        FUNCTION
              pr01cIsComType(VAR xaSQLDesc : tpr01_SQLDesc;
                    ComType : tpr00_ComTypeEnum) : boolean;
 
        PROCEDURE
              pr01cSetLastDataReceived (VAR sqlSQLDesc : tpr01_SQLDesc;
                    aValue : tsp00_Int4);
 
        FUNCTION
              pr05cChToInt4 (VAR buf : tsp00_MoveObj;
                    pos : integer;
                    len : integer;
                    entype : tpr05_StringEncoding) : tsp00_Int4;
 
        PROCEDURE
              pr05cNextSymbol (VAR buf : tsp00_MoveObj;
                    buflen  : tsp00_Int4;
                    pasanf     : tsp00_Int4;
                    VAR sympos : tsp00_Int4;
                    VAR symlen : tsp00_Int4;
                    VAR symb   : tpr_symbol;
                    VAR accpos : tsp00_Int4;
                    entype     : tpr05_StringEncoding);
 
        FUNCTION
              pr03PacketGetEncoding  (VAR pck : tsp1_packet) : tpr05_StringEncoding;
&       ifdef TRACE
 
        PROCEDURE
              m90int4 (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : tsp00_Int4);
 
        PROCEDURE
              m90int2 (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : tsp00_Int2);
 
        PROCEDURE
              m90int (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : integer);
 
        PROCEDURE
              m90name (layer : tsp00_ToolLayer;
                    nam : tsp00_Name);
 
        PROCEDURE
              m90identifier (
                    layer : tsp00_ToolLayer;
                    nam   : tsp00_KnlIdentifier);
 
        PROCEDURE
              m90buf1 (layer : tsp00_ToolLayer;
                    VAR buf :  tpr_parsid;
                    pos_anf : integer;
                    pos_end : integer);
 
        PROCEDURE
              m90buf5 (layer : tsp00_ToolLayer;
                    VAR buf :  tsp00_MoveObj;
                    pos_anf : integer;
                    pos_end : integer);
 
        PROCEDURE
              m90buf4 (layer : tsp00_ToolLayer;
                    VAR buf :  tsp1_packet;
                    pos_anf : integer;
                    pos_end : integer);
&       endif
 
      ------------------------------ 
 
        FROM
              SQL_runtime_routinen  : VPR01;
 
        PROCEDURE
              p01pparsidtrace (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    kae    : sqlkaentry_ptr;
                    VAR parsid : tpr_parsid;
                    inout : tpr00_TraceParseID_Enum);
 
      ------------------------------ 
 
        FROM
              SQL_runtime_routinen  : VPR01E;
 
        PROCEDURE
              p01xballocate  (VAR sqlca : sqlcatype;
                    VAR ga : sqlgaentry;
                    index : integer);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill   : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26finish_part (packet_ptr : tsp1_packet_ptr;
                    VAR finish_part      : tsp1_part);
 
        PROCEDURE
              s26new_part_init (packet_ptr : tsp1_packet_ptr;
                    VAR segm               : tsp1_segment;
                    VAR new_part_ptr       : tsp1_part_ptr);
 
        PROCEDURE
              s26find_part (VAR segm : tsp1_segment;
                    part_kind        : tsp1_part_kind;
                    VAR part_ptr     : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30    : VSP30;
 
        FUNCTION
              s30gad3 (VAR b : tsp1_segment) : tsp1_segment_ptr;
 
      ------------------------------ 
 
        FROM
              GET-Conversions   : VSP40;
 
        PROCEDURE
              s40g4int (VAR buf : tsp00_MoveObj;
                    pos : tsp00_Int4;
                    VAR dest : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              PUT-Conversions   : VSP41;
 
        PROCEDURE
              s41p4int ( VAR buf : tsp00_MoveObj;
                    pos : tsp00_Int4;
                    source : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
        PROCEDURE
              s41plint ( VAR buf : tsp00_MoveObj;
                    pos : tsp00_Int4;
                    len : integer;
                    frac : integer;
                    source : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              m90buf1;
 
              tsp00_Buf       tpr_parsid
 
        PROCEDURE
              m90buf4;
 
              tsp00_Buf       tsp1_packet
 
        PROCEDURE
              m90buf5;
 
              tsp00_Buf       tsp00_MoveObj
 
        PROCEDURE
              s30gad3;
 
              tsp00_MoveObj tsp1_segment
              tsp00_Addr tsp1_segment_ptr
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1986-07-07
.sp
.cp 3
        6-18
        6-11
.sp
.cp 3
Release :  7.3    Date : 2001-06-25
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.sp 2
Working with the MFETCH Function in Version 2.4
.sp
IN the SQLCA there is a component called SQLMFETCH.
It is initialized with zero to switch off the MFETCH function.
.sp
There are two possibilities to work with MFETCH:
.hi 2
.sp
- Set SQLMFETCH to 1. If the FETCH statement is the only one
in a loop, then
it is switched to MFETCH with the second execution of that loop.
After the execution of the loop it is necessary to close the
result table.
.sp
- Set SQLMFETCH to a value > 1. Every FETCH statement will be
executed directly as MFETCH. There cab be more than one FETCH
statement in one loop, but if a loop should be executed
several times the result table must be in its initial state
(selected or opened).
.hi 0
.sp
In general it is possible to select the FETCH statements that
shall be executed as MFETCH and to choose one of the two
possibilities of execution by asigning a value > 0 to
the SQLMFETCH component before starting a FETCH loop.
.sp 6
Arbeiten mit MFETCH-Version in Rel. 3.0.
.sp
?Uber Option SQLMFETCH kann eine Zahl 1<=sqlmfetch<=18 angegeben werden.
Es k?onnen dann maximal sqlmfetch 8K-Puffer gleichzeitig f?ur Massen-selects
angelegt werden.
.br
In jedem Puffer werden von je einer Ergebnismenge records abgelegt.
Fetch die auf dieser Ergebnismenge arbeiten, holen sich Records aus
diesem Puffer und f?ullen ihn eventuell wieder. Die Positionen
des actuellen letzten fetch wird festgehalten, ebenso die
erste und letzte Position im Puffer.
.sp 4
.cp 8
PROCEDURE  p01bdrop_parsid :
.sp 2
Beim L?oschen einer Parsid wird nachgesehen, ob es
sich um ein select handelt.
Alle mfentries, in denen Eintr?age von der Parsid
select-parsid stehen,   werden gel?oscht.
D.h. es wird mfInit := cpr_is_false und mfSelectno := 0
gesetzt.
.sp 4
.cp 8
PROCEDURE  p01bbparsen :
.sp 2
Before_Parsen wird gepr?uft, ob der Mfetch-Mechanismus
?uberhaupt eingesetzt werden soll.
.br
Ist Traceoutput eingeschaltet sqlca.tatraceno <> 0
wird Mfetch nicht eingeschaltet.
.br
Ebenso, ob eine Reservierung in der sqlfa vorgenommen wurde.
Bei ja,
wird untersucht um welches fetch (next,same,... ) es sich handelt
und in die sqlfa-area eingetragen. Fa-entry init : faspec, fafetch : cpr_is_true.
Soll auf mfetch umgeschaltet werden sqlmfp^.mfmfetch = cpr_is_true,
wird das Kommando
in 'MFETCH' umgesetzt und cmdfetch := cpr_is_true gesetzt.
und bei fetch pos-constante, wird die Konstante in fapos
abgelegt, um sp?ater eventuell im Puffer direkt zugreifen zuk?onnen.
.br
cmdfetch := cpr_is_true der Mechanismus ist eingeschaltet.
.br
cmdfetch := cpr_is_false der Mechanismus wird nicht eingeschaltet.
.sp 4
PROCEDURE  p01baparsen :
.sp 2
After_parsen, wird nachgesehen ob es sich um ein Massenselect
handelt.
.br
Bei ja, wird ein freier Eintrag in der SQLMF-Area gesucht und
initialisiert. Alle fetch Kommandos mit der gleichen Selectparsid
werden sp?ater ?uber diesen SQLMF-entry abgearbeitet mit ihren
entsprechenden Positionen.
.br
Handelt es sich um ein Fetch-Kommando oder Mfetch-Kommando,
wird nachgesehen, ob es sich um
fetch handelt f?ur das es schon einen Eintrag in der sqlmfp^-area gibt.
.br
Ist es ein Mfetch-Kommando wird der Eintrag in der sqlmf_area wieder
frei gegeben. Wurde schon ein fetch auf der Ergebnismenge abgesetzt,
wird Fehler -750 (mixen von fetch und array-fetch nicht erlaubt)
ausgegeben.
.br
Ist es ein Fetch-Kommando wird,
bei ja, der zugeh?orige fa-entry initialisiert (faselectno, famfindex,
fapos).
.br
Bei nein wird nicht auf mfetch umgeschaltet (cmdfetch := cpr_is_false).
.sp 4
PROCEDURE  p01mfentryinit :
.sp 2
Initialisiert einen mfentry und allociert, noch einen Puffer, falls
noch keiner angelegt wurde, f?ur diesen mfentry.
.sp 4
PROCEDURE  p01bnextrecord :
.sp 2
Holt aus dem Mfbuffer den n?achsten Record in den Auftragspuffer.
Wurde vorher schon 'row not found' festgestellt wird diese
Meldung an den Anwender zur?uckgegeben.
.br
Wurde vorher festgestellt, der Record liegt nicht im Puffer
 mfRecpos = 0, so wird veranlasst, da?z der zugeh?orige Puffer
geholt wird. Ist noch keine Parsid f?ur das mfetch vorhanden,
wird mfmfetch = cpr_is_true gesetzt und das Kommando muss nochmals
geparsed werden mit gleichzeitiger umschaltung auf mfetch.
mfmfetch = cpr_is_true bedeutet Umschaltung.
.sp
R?uckgabeparameter bedeutet:
.br
cmdfetch ::= cpr_is_true  Record wurde geholt oder rownotfound gefunden
.br
cmdfetch ::= cpr_is_false Puffer muss neu gef?ullt werden und
das Kommando muss auf mfetch umgestellt werden (pars again).
.br
cmdfetch ::= cpr_is_init  Puffer muss neu gef?ullt werden,
die parsid vom fetch ist schon f?ur mfetch vorhanden.
der var_part erh?alt nur noch als Angabe, die Maximale Anzahl der
Records, die geholt werden sollen.
.sp 4
PROCEDURE  p01bexecute :
.sp 2
Before_execute, cmdfetch wird auf cpr_is_false gesetzt.
.sp
Ist es ein Fetchkommand :
.sp
Es wird nachgepr?uft, ob der n?achste Record, der geholt
werden soll noch im Pufferliegt.
.sp
Ist die selectno in der sqlfa-area ungleich der selectno in
dem sqlmfp^.mfentry, so wurde inzwischen eine neue Selectmenge
hier abgelegt. Das bedeutet das Fetchkommando geh?ort nicht mehr
zu diesem Select-mfentry, d.h. das Kommando muss neu geparst
werden um den zugeh?origen sqlmfp^-entry zufinden.
.sp
In  p01bsearchnextrec
wird untersucht, ob der Record noch im Puffer liegt,
werden Fall unterscheidungen der verschiedenen Fetchkommandos
betrachtet.
.br
 mfRownotfound = cpr_is_true, bedeutet der Record existiert nicht.
.br
 mfRecpos = 0, bedeutet ein neuer Puffer soll geholt werden.
.br
andernfalls hole den Record.
.sp 2
Ist es ein Selectkommand :
.sp
D.h. es wurde eine neue Ergebnismenge mit der gleichen
Parsid erzeugt. Eine neue Initialisierung des sqlmfp^.entries
wird durchgef?uhrt und selectno erh?oht. D.h. sp?atere Fetchkommandos
m?ussen neu geparset werden.
.sp 4
PROCEDURE  p01bgetmfetch :
.sp 2
Wird nur aufgerufen, wenn ein neuer Puffer geholt wurde cmdfetch = cpr_is_init.
Zun?acht wird die Fehlerbehandlung gemacht. Es wird gepr?uft,
ob es eien selectparsid gibt. Bei nein Error 'missing select parsid'.
Und ob, die selectno in dem sqlmfp^.entry gleich der selectno in der
sqlfa-area ist, bei nein Error 'duplicate fetch statement'.
.br
Wurde kein Fehler gefunden, wird gepr?uft, ob 'row not found' kam.
Bei nein  wird f?ur die unterschiedlichen Fetchkommandos die
bufgebno, bufendno, lastrecno und mf-recpos berechnet.
der varpart wird in den Mfentry-buffer geschrieben und der
entsprechende Record in den Auftragspuffer geschrieben.
.sp
 mfLastrecno wird auf die Nummer des lezten Records, der an den Anwender ging
gesetzt. mfRecpos erha?lt die Position des n?achsten
(next) Records im Puffer.
.sp
 mfPrevfaspec enth?lt das letzte Fetchkommando.
 mfLastfaspec = cpr_fe_empty solange kein 'fetch last' abgesetzt wurde.
 mfLastfaspec = cpr_fe_last, sobald einmal ein 'fetch last' abgesetzt wurde.
Ist mfLastfaspec = cpr_fe_last und mfMaxselrec < 0 kann nicht
davon ausgegangen werden, da?z die ..no, den Recordnummern in der
Ergebnismenge entsprechen.
.sp 4
PROCEDURE p01baexecute :
.sp 2
Ist es ein 'Close-kommando',  wird der entsprechende Eintrag in der
Sqlmf-area gel?oscht.
.br
Ist ein 'select-kommando', wird die Anzahl der Ergebnisrecords
sqlerrd (3) nach mfMaxselrec geholt.
.sp 4
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
.sp 2
.nf
CONST
      mxpr_mfetch        = 18;
      mxpr_mfetchbuffer  = 18;
      mxpr_mfetchrecords = 250;  (* number records per mfetch *)
 
 
 
      sqlmftype   =  RECORD    (* 1660 B *)
           mfselcnt   :  tsp00_Int2;
           mfmfetch   :  tsp00_Int2; (* change next com to mfetch *)
           mfentry    :  array [ 1..mxpr_mfetch ] of tpr_mfetchentry;
      END;
 
.sp 2
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
(**)
(*------------------------------*) 
 
PROCEDURE
      p01bdrop_parsid (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR parsid : tpr_parsid);
 
VAR
      i   : integer;
 
BEGIN
WITH sqlca, sqlxa  DO
    IF  sqlmfetch <> 0
    THEN
        BEGIN
        IF   (parsid [cpr_p_precom_index] = chr(csp1_p_mass_select_found))
            OR (parsid [cpr_p_precom_index] = chr(csp1_p_reuse_mass_select_found))
            OR (parsid [cpr_p_precom_index] = chr(csp1_p_mselect_found))
            OR (parsid [cpr_p_precom_index] = chr(csp1_p_reuse_mselect_found))
            OR (parsid [cpr_p_precom_index] = chr(csp1_p_select_for_update_found))  (* PTS 1103882 *)
            OR (parsid [cpr_p_precom_index] = chr(csp1_p_reuse_update_sel_found))   (* PTS 1103882 *)
            OR (parsid [cpr_p_precom_index] = chr(csp1_p_for_upd_mselect_found))    (* PTS 1103882 *)
            OR (parsid [cpr_p_precom_index] = chr(csp1_p_reuse_upd_mselect_found))  (* PTS 1103882 *)
        THEN
            BEGIN
            i   := 1;
            REPEAT
                WITH sqlmfp^, mfentry^ [i] DO
                    BEGIN
                    IF   mfInit = cpr_is_true
                    THEN
                        IF   (mfSelparsid = parsid)
                        THEN
                            BEGIN
                            p04trint2(sqlrap, 'mfIndex delete    ', i);
                            mfInit := cpr_is_false;
                            mfSelectno  := 0;
                            mfSelparsid := cpr_parsidnull;
&                           ifdef TRACE
                            m90int (pc, 'i  delete   ', i);
                            m90int2(pc, 'mfSelectno  ', mfSelectno);
&                           endif
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    i := i + 1;
                    END;
                (*ENDWITH*) 
            UNTIL
                (i > sqlmfetch);
            (*ENDREPEAT*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(**)
(*------------------------------*) 
 
PROCEDURE
      p01bbparsen  (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ga : sqlgaentry;
            VAR ka : sqlkaentry;
            VAR cmdfetch : tsp00_Int2);
 
VAR
      ergn  : tsp00_KnlIdentifier;
      descr : boolean;
      intopos : integer;
      pos     : tsp00_Int4;
      sypos   : tsp00_Int4;
      sylen   : tsp00_Int4;
      accpos  : tsp00_Int4;
      symb    : tpr_symbol;
      prevsymb: tpr_symbol;
      part_ptr : tsp1_part_ptr;
      entype : tpr05_StringEncoding;
      (* before parsen *)
 
BEGIN
cmdfetch := cpr_is_false;
&ifdef P04TRACE
p04trint2(sqlca.sqlrap, 'p01bbparsen       ', cmdfetch);
&endif
(* vorbereitung mfetch unterdrueckung bei longvarchar *)
&ifdef TRACE
      m90int (pc, 'cdmfetch    ', cmdfetch);
&endif
(****p01btrace (sqlca, sqlxa, 0, cmdfetch); **)
WITH sqlca, sqlrap^, sqlmfp^, rasqltap^, sqlxa   DO
    BEGIN
    (* trace on mfetch greift nicht  *)
    IF  (* (tatraceno = 0)  AND*)
        (sqlmfetch <> 0)
    THEN
        BEGIN
        IF  (ka.kafaindex > 0)
            AND (ka.kamacro = cpr_is_false)
        THEN
            WITH ka.kafae^ DO
                BEGIN
                p03find_part (sqlrap, sp1pk_command, part_ptr);
                IF  part_ptr <> NIL
                THEN
                    WITH  part_ptr^, sp1p_part_header  DO
                        BEGIN
                        IF  (mfmfetch = cpr_is_false)
                        THEN
                            BEGIN
                            (* init fa-entry 'fetch command' *)
                            faselectno := 0;
                            famfindex  := 0;
                            fapos      := 0;
                            (*no longer needed *)
                            (*pr08cSearchFetch (sqlca, sqlxa, ga, ergn,*)
                            (*      descr,intopos);                    *)
                            (*in sqlcxap^.xacfetspec steht *)
                            (*fetch specification*)
                            faspec     := sqlcxap^.xacfetspec;
                            fafetch    := cpr_is_true;
                            mfmfetch   := cpr_is_true;
&                           ifdef TRACE
                            m90int (pc, 'faspec      ', faspec  );
                            m90int (pc, 'fafetch     ', fafetch );
&                           endif
                            END;
                        (*ENDIF*) 
                        IF  faspec = cpr_fe_posc
                        THEN
                            BEGIN
                            (* get pos unsigned_integer into fapos *)
                            sypos := 1;
                            sylen := 0;
                            symb := cpr_s_unknown;
                            entype := pr03PacketGetEncoding (ga.gareqptr^);
                            REPEAT
                                pos := sypos + sylen;
                                pr05cNextSymbol (sp1p_buf, sp1p_buf_len, pos,
                                      sypos, sylen, symb, accpos,
                                      entype);
                                prevsymb := symb;
                            UNTIL
                                (symb = cpr_s_unsigned_integer);
                            (*ENDREPEAT*) 
                            IF  prevsymb = cpr_s_minus
                            THEN
                                fapos := -fapos;
                            (*ENDIF*) 
                            fapos := pr05cChToInt4 (sp1p_buf, sypos, sylen, entype);
&                           ifdef TRACE
                            m90int (pc, 'fapos       ', fapos );
&                           endif
                            END;
                        (*ENDIF*) 
                        IF  (mfmfetch = cpr_is_true)
                            AND (faspec <> cpr_fe_empty)
                        THEN
                            BEGIN
                            (* mfetch einsetzen *)
                            fafetch  := cpr_is_false;
                            cmdfetch := cpr_is_true;
&                           ifdef P04TRACE
                            p04trint2(sqlrap, 'p01bbparsen  1    ', cmdfetch);
&                           endif
&                           ifdef TRACE
                            m90int (pc, 'faspec  1   ', faspec  );
                            m90int (pc, 'fafetch 1   ', fafetch );
&                           endif
                            (* PTS 1108115 rasegptr^.sp1c_mass_cmd := true; *)
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    mfmfetch := cpr_is_false;
    END;
(*ENDWITH*) 
END;
 
(**)
(*------------------------------*) 
 
PROCEDURE
      p01baparsen  (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ga : sqlgaentry;
            VAR ka : sqlkaentry;
            VAR cmdfetch : tsp00_Int2);
 
VAR
      i   : integer;
      paind  : integer;
      found  : boolean;
      parsid : tpr_parsid;
      loopfound : boolean;
      resname   : tsp00_KnlIdentifier;
      part_ptr  : tsp1_part_ptr;
      resnamefound : boolean;
      (* after parsen *)
 
BEGIN
&ifdef P04TRACE
p04trint2(sqlca.sqlrap, 'p01baparsen       ', cmdfetch);
&endif
&ifdef TRACE
m90int (pc, 'cdmfetch    ', cmdfetch);
&endif
WITH sqlca, sqlrap^, rasqltap^, sqlxa DO
    BEGIN
    WITH sqlmfp^ DO
        IF  mfdesc.descNelem = 0
        THEN
            BEGIN
            p03dynalloc (mfdesc);
            sqlmfetch := mfdesc.descNelem;
            (* ADIS 1000837 *)
            FOR i := 1 TO mfdesc.descMaxelem DO
                BEGIN
                mfentry^[i].mfBufinit := cpr_is_false;
                mfentry^[i].mfresultname := bsp_knl_identifier;
                END;
            (*ENDFOR*) 
            i := sqlmfetch;
            p01mfentryinit (sqlca, i);
            END;
        (*ENDIF*) 
    (*ENDWITH*) 
    IF  (*  (tatraceno = 0)  AND **)
        (sqlmfetch <> 0)
        AND (ka.kamacro = cpr_is_false)
    THEN
        BEGIN
        found := false;
&       ifdef TRACE
        m90buf1 (pc, ka.kaParseInfo.ParseId, 1, 12);
        m90identifier (pc, sqlresn );
&       endif
        IF  (ka.kaParseInfo.ParseId [cpr_p_precom_index] = chr(csp1_p_mass_select_found))
            OR (ka.kaParseInfo.ParseId [cpr_p_precom_index] = chr(csp1_p_reuse_mass_select_found))
            OR (ka.kaParseInfo.ParseId [cpr_p_precom_index] = chr(csp1_p_mselect_found))
            OR (ka.kaParseInfo.ParseId [cpr_p_precom_index] = chr(csp1_p_reuse_mselect_found))
        THEN
            BEGIN
            resnamefound := FALSE;
            p03find_part (sqlrap, sp1pk_resulttablename, part_ptr);
            IF  part_ptr <> NIL
            THEN
                IF  part_ptr^.sp1p_part_header.sp1p_buf_len > 0
                THEN
                    resnamefound := TRUE;
                (*ENDIF*) 
            (*ENDIF*) 
            resname := sqlresn;
            IF  sqlresn = bsp_knl_identifier
            THEN
                BEGIN
                resname[1] := chr (0);
                resnamefound := TRUE;
                END;
            (*  select command ergname found *)
            (*ENDIF*) 
            i     := 1;
            IF  (resnamefound)
            THEN
                WHILE (i <= sqlmfetch) AND NOT found DO
                    WITH sqlmfp^, mfentry^ [i] DO
                        BEGIN
&                       ifdef TRACE
                        m90int (pc, 'i mf_resname', i);
                        m90int (pc, 'i resname   ', i);
&                       endif
                        IF  (mfresultname = resname)
                            (***     and (found)  ***** test 7.3. *******)
                        THEN
                            BEGIN
                            found := true;
                            p01mfentryinit (sqlca, i);
                            mfSelparsid := ka.kaParseInfo.ParseId;
                            mfresultname := resname;
&                           ifdef TRACE
                            m90int (pc, 'i =resname  ', i);
                            m90int2(pc, 'mfSelectno  ', mfSelectno);
                            m90identifier (pc, mfresultname );
                            m90buf1 (pc, ka.kaParseInfo.ParseId, 1, mxpr_parsid);
&                           endif
                            END;
                        (*ENDIF*) 
                        i := i + 1;
                        END;
                    (*ENDWITH*) 
                (*ENDWHILE*) 
            (*  select command *)
            (*ENDIF*) 
            IF  NOT found
            THEN
                i := p01bmfentryadd(sqlca, sqlxa, ka.kaParseInfo.ParseId, resname);
            (*ENDIF*) 
            cmdfetch := cpr_is_false;
&           ifdef P04TRACE
            p04trint2(sqlrap, 'p01baparsen  1    ', cmdfetch);
&           endif
            END;
        (*ENDIF*) 
        IF  (ka.kaParseInfo.ParseId [cpr_p_precom_index] = chr(csp1_p_fetch_found))
            OR  (ka.kaParseInfo.ParseId [cpr_p_precom_index] = chr(csp1_p_mfetch_found))
        THEN
            BEGIN
            cmdfetch := cpr_is_false;
&           ifdef P04TRACE
            p04trint2(sqlrap, 'p01baparsen  2    ', cmdfetch);
            p04trint2(sqlrap, 'kafaindex         ', ka.kafaindex);
&           endif
&           ifdef TRACE
            m90int2 (pc, 'kafaindex   ', ka.kafaindex);
&           endif
            IF  ka.kafaindex > 0
            THEN
                WITH ka.kafae^ DO
                    BEGIN
                    p03gselparsid (sqlrap, sqlemp, parsid, ga.gaKnlSessionID);
                    IF  (parsid  <> cpr_parsidnull)
                    THEN
                        (* select parsid <> 0 *)
                        BEGIN
                        i     := 1;
                        REPEAT
                            WITH sqlmfp^, mfentry^ [i] DO
                                BEGIN
&                               ifdef TRACE
                                m90buf1 (pc, mfSelparsid, 1, mxpr_parsid);
&                               endif
                                IF   mfSelparsid = parsid
                                THEN
                                    BEGIN
                                    found := true;
                                    p04trint2(sqlrap, 'mfIndex found     ', i       );
                                    sqlxa.xaSQLDesc^.PacketEncoding :=     PacketEncoding;
&                                   ifdef TRACE
                                    m90int (pc, 'i           ', i);
                                    m90int2(pc, 'mfSelectno  ', mfSelectno);
                                    m90int2(pc, 'mfRecpos    ', mfRecpos);
                                    m90int2(pc, 'mfReclen    ', mfReclen);
                                    m90int2(pc, 'mfBufinit   ', mfBufinit);
                                    m90int2(pc, 'mfBuflen    ', mfBuflen);
                                    m90int4(pc, 'mfLastrecno ', mfLastrecno);
                                    m90buf1 (pc, ka.kaParseInfo.ParseId, 1, 12);
&                                   endif
                                    END;
                                (*ENDIF*) 
                                i := i + 1;
                                END;
                            (*ENDWITH*) 
                        UNTIL
                            (i > sqlmfetch) OR (found);
                        (*ENDREPEAT*) 
                        IF   NOT found
                        THEN
                            BEGIN
                            IF  (ka.kaParseInfo.ParseId [cpr_p_precom_index] = chr(csp1_p_mfetch_found))
                            THEN
                                BEGIN
                                resname := sqlresn;
                                IF  sqlresn = bsp_knl_identifier
                                THEN
                                    resname[1] := chr (0);
                                (* PTS 1124855 *)
                                (*ENDIF*) 
                                i := p01bmfentryadd(sqlca, sqlxa, parsid, resname);
&                               ifdef P04TRACE
                                p04trint2(sqlrap, 'p01baparsen  3    ', cmdfetch);
&                               endif
                                cmdfetch := cpr_is_true;
                                faselectno := sqlmfp^.mfentry^[i].mfSelectno;
                                famfindex  := i;
                                fapos      := 0;
                                END
                            ELSE
                                BEGIN
                                faselectno := 0;
                                famfindex  := 0;
                                fapos      := 0;
                                END
                            (*ENDIF*) 
                            END
                        ELSE
                            WITH ka.kafae^, sqlmfp^,
                                 mfentry^ [i-1] DO
                                BEGIN
                                loopfound := false;
                                IF  ka.kapaindex >= 0
                                THEN
                                    paind := ka.kapaindex
                                ELSE
                                    paind := - ka.kapaindex;
                                (*ENDIF*) 
                                IF  paind > 0
                                THEN
                                    BEGIN
                                    WITH sqlpap^ [paind] DO
                                        IF  pakindlo = sqlparlo
                                        THEN
                                            loopfound := true;
                                        (*ENDIF*) 
                                    (*ENDWITH*) 
                                    END;
                                (*ENDIF*) 
                                IF  (loopfound)
                                    AND (raparse_again = false)
                                THEN
                                    BEGIN
                                    IF  mfLastrecno <> 0
                                    THEN
                                        p08runtimeerror (sqlca, sqlxa,
                                              cpr_ffetch_fetch_mix_not_allowed)
                                    ELSE
                                        BEGIN
                                        (* delete mass_select entry *)
                                        (* in sqlmfp^-area *)
                                        (* from array statement  *)
                                        faselectno := 0;
                                        famfindex  := 0;
                                        fapos      := 0;
                                        i := i - 1;
                                        p01mfentryinit (sqlca, i);
                                        mfInit  := cpr_is_false;
                                        END
                                    (*ENDIF*) 
                                    END
                                ELSE
                                    BEGIN
                                    faselectno := mfSelectno;
                                    famfindex  := i - 1;
&                                   ifdef P04TRACE
                                    p04trint2(sqlrap, 'p01baparsen  4    ', cmdfetch);
&                                   endif
                                    cmdfetch := cpr_is_true;
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01mfentryinit  (VAR sqlca : sqlcatype;
            VAR index   : integer);
 
BEGIN
WITH sqlca, sqlmfp^, mfentry^[index] DO
    BEGIN
    p04trint2(sqlrap, 'mfIndex init      ', index);
    mfInit := cpr_is_true;
    mfSelectno  := 0;
    mfBuflen    := 0;
    mfSelparsid := cpr_parsidnull;
    mfRecpos    := 0;
    mfReclen    := 0;
    mfRownotfound:= cpr_is_false;
    mfRecposbeg := 0;
    mfPrevfaspec:= cpr_fe_empty;
    mfLastfaspec:= cpr_fe_empty;
    mfMaxselrec := 0;
    mfLastrecno := 0;
    mfBufbegno  := 0;
    mfBufendno  := 0;
    mfLongcolpos:= 0;
    mfFetchget  := 0;
    mfsumanzrec := 0;
    mffetchkind := cpr_is_true;
    mfopendata  := cpr_is_false;
    mfPrecomindex := 0;
    mfActualPos := 0;
    mfNextLoopCnt := -1;
    mfAllRecordsRead := cpr_is_false;
    IF   mfBufinit = cpr_is_false
    THEN
        BEGIN
        mfrecptrlen := 0;
        mfrecpointer.vtypep := NIL;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01bnextrecord  (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ga : sqlgaentry;
            kae : sqlkaentry_ptr;
            VAR faentry : sqlfaentry;
            VAR mf_index : tsp00_Int2;
            VAR cmdfetch : tsp00_Int2;
            sqcrowcount   : tsp00_Int4);
 
VAR
      nam   : tsp00_Name;
      part_ptr  : tsp1_part_ptr;
      lint  : tsp00_Int4;
      res : tsp00_NumError;
 
BEGIN
&ifdef P04TRACE
p04trint2(sqlca.sqlrap, 'p01bnextrecord    ', cmdfetch);
&endif
WITH sqlca, sqlxa, sqlrap^, sqlemp^,
     sqlmfp^, mfentry^ [mf_index], faentry DO
    BEGIN
&   ifdef TRACE
    m90int (pc, 'mfRecpos    ', mfRecpos  );
    m90int (pc, 'fafetch     ', fafetch    );
    m90int (pc, 'sqlcode     ', sqlcode    );
&   endif
&   ifdef P04TRACE
    p04trint2(sqlrap, 'p01bnextrecord    ', mf_index);
&   endif
    IF  mfRownotfound = cpr_is_true
    THEN
        BEGIN
        ereturncode := 100;
        nam := 'ROW NOT FOUND     ';
        s10mv (mxsp_name, mxsp_c70, @nam, 1,
              @etext, 1, mxsp_name);
        etextlen       := mxsp_name;
        (* this hould only stay true if row not found comes from kernel *)
        mfRownotfound  := cpr_is_false; (* reset val HBI *)
&       ifdef P04TRACE
        p04trint2(sqlrap, 'p01bnextrecord 1  ', cmdfetch);
&       endif
        cmdfetch       := cpr_is_true;
        END
    ELSE
        IF   (mfRecpos > 0)
        THEN
            BEGIN
            p01bonerecget (sqlca, sqlxa, ga, mf_index);
&           ifdef P04TRACE
            p04trint2(sqlrap, 'p01bnextrecord 2  ', cmdfetch);
&           endif
            cmdfetch    := cpr_is_true;
            mfRecpos    := mfRecpos + mfReclen;
            mfLastrecno := mfLastrecno + 1;
            (* 28.2.94 longvarchar wird in p01bonerecget belegt *)
&           ifdef TRACE
            m90int (pc, 'mfRecpos    ', mfRecpos );
&           endif
            END
        ELSE
            IF  (fafetch  = cpr_is_true)
                AND (raparse_again = false)
                AND (kae^.kaParseInfo.ParseId [cpr_p_precom_index] = chr(csp1_p_fetch_found))
            THEN
                BEGIN
                sqlcode := csp_old_fileversion;
                sqlemp^.ereturncode := sqlcode;
                mfmfetch := cpr_is_true;
                xastopcnt := xastopcnt - 1;
&               ifdef P04TRACE
                p04trint2(sqlrap, 'fafetch           ', fafetch);
&               endif
                p01bchangetomfetch (sqlca, sqlxa);
                END
            ELSE
                BEGIN
                (* zur?uck setzen der parsid auf mass_command *)
                p03find_part (sqlrap, sp1pk_parsid, part_ptr);
                IF  part_ptr <> NIL
                THEN
                    WITH  part_ptr^, sp1p_part_header  DO
                        BEGIN
                        IF  (sp1p_buf [cpr_p_precom_index] = chr(csp1_p_fetch_found))
                        THEN
                            sp1p_buf[cpr_p_precom_index] := chr(csp1_p_mfetch_found);
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
                IF  (faspec = cpr_fe_posv) OR (faspec = cpr_fe_relv)
                THEN
                    BEGIN
                    p03find_part (sqlrap, sp1pk_data, part_ptr);
                    IF  part_ptr = NIL
                    THEN
                        WITH sqlgap^ DO
                            BEGIN
                            s26new_part_init (ga.gareqptr, rasegptr^, part_ptr);
                            part_ptr^.sp1p_part_header.sp1p_part_kind
                                  :=  sp1pk_data;
                            part_ptr^.sp1p_part_header.sp1p_buf_len
                                  :=  mxpr_numb + 1;
                            rasegmpartptr [ord(sp1pk_data)+1] := part_ptr;
                            s26finish_part (ga.gareqptr, part_ptr^);
                            END;
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    WITH  part_ptr^, sp1p_part_header  DO
                        BEGIN
                        lint := fapos;
                        (* s41plint (sp1p_buf, 2, 18, 0,
                              lint, res); HBI *)
                        s41p4int (sp1p_buf, 2, lint, res);
                        sp1p_buf [1] := csp_defined_byte;
                        END;
                    (*ENDWITH*) 
                    p04trint4( sqlrap, 'FETCH-PARAMETER   ', lint );
                    END;
                (*ENDIF*) 
                p03find_part (sqlrap, sp1pk_resultcount, part_ptr);
                IF  part_ptr = NIL
                THEN
                    WITH sqlgap^ DO
                        IF  (ga.gareqptr <> NIL) AND (rasegptr <> NIL)
                        THEN
                            BEGIN
                            s26new_part_init (ga.gareqptr, rasegptr^, part_ptr);
                            part_ptr^.sp1p_part_header.sp1p_part_kind
                                  :=  sp1pk_resultcount;
                            part_ptr^.sp1p_part_header.sp1p_buf_len
                                  :=  mxpr_numb + 1;
                            rasegmpartptr [ord(sp1pk_resultcount)+1] := part_ptr;
                            s26finish_part (ga.gareqptr, part_ptr^);
                            END;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (*ENDIF*) 
                WITH  part_ptr^, sp1p_part_header  DO
                    BEGIN
                    lint := sqcrowcount;
                    (* s41plint (sp1p_buf, 2, 18, 0, lint, res); *)
                    s41p4int (sp1p_buf, 2, lint, res);
                    sp1p_buf [1] := csp_defined_byte;
                    END;
                (*ENDWITH*) 
                cmdfetch := cpr_is_init;
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  (cmdfetch = cpr_is_true)
        AND ((sqldbmode = cpr_kind_oracle)
        OR (sqldbmode = cpr_kind_sapr3))
    THEN
        sqlerrd [3] := mfLastrecno;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      p01bmfetch (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ga : sqlgaentry;
            VAR ka : sqlkaentry;
            VAR cmdfetch : tsp00_Int2;
            sqcrowcount   : tsp00_Int4) : tsp00_Int2;
 
VAR
      i   : integer;
      found : boolean;
      (*   in2   : tsp_int_map_c2;*)
      (* before execute *)
 
BEGIN
&ifdef P04TRACE
p04trint2(sqlca.sqlrap, 'p01bmfetch        ', cmdfetch);
&endif
p01bmfetch := cpr_is_false;
WITH sqlca, sqlxa, sqlrap^, rasqltap^, sqlmfp^  DO
    BEGIN
&   ifdef P04TRACE
    p04trint2(sqlrap, 'sqlmfetch         ', sqlmfetch);
&   endif
    IF  (sqlmfetch <> 0 ) (*****AND (tatraceno = 0)*****)
        AND (ka.kamacro = cpr_is_false)
    THEN
        BEGIN
&       ifdef P04TRACE
        p04trint2(sqlrap, 'p01bmfetch  1     ', cmdfetch);
&       endif
&       ifdef TRACE
        m90int (pc, 'sqlmfetch   ', sqlmfetch);
        m90int (pc, 'kapars[11]  ', ord(ka.kaParseInfo.ParseId [cpr_p_precom_index] ));
        m90buf1 (pc, ka.kaParseInfo.ParseId, 1, 12);
&       endif
        IF   (ka.kaParseInfo.ParseId [cpr_p_precom_index] = chr(csp1_p_fetch_found))
            OR  (ka.kaParseInfo.ParseId [cpr_p_precom_index] = chr(csp1_p_mfetch_found))
        THEN
            IF  (ka.kafae <> NIL)
            THEN
                WITH ka.kafae^  DO
                    BEGIN
                    p01bmfetch := cpr_is_true;
&                   ifdef TRACE
                    m90int (pc, 'famfindex   ', famfindex);
&                   endif
                    IF  famfindex > 0
                    THEN
                        WITH sqlmfp^, mfentry^ [famfindex] DO
                            BEGIN
&                           ifdef TRACE
                            m90int (pc, 'sqlcode     ', sqlcode  );
                            m90int (pc, 'kafaindex   ', ka.kafaindex);
                            m90int (pc, 'famfindex   ', famfindex);
                            m90int (pc, 'faselectno  ', faselectno);
                            m90int (pc, 'mfRecpos    ', mfRecpos  );
                            m90int (pc, 'mfReclen    ', mfReclen  );
                            m90int (pc, 'mfSelectno  ', mfSelectno);
                            m90int (pc, 'mf_prevfaspe', mfPrevfaspec);
                            m90int (pc, 'mf_lastfaspe', mfLastfaspec);
                            m90int (pc, 'mfMaxselrec ', mfMaxselrec);
                            m90int (pc, 'mfLastrecno ', mfLastrecno);
                            m90int (pc, 'mfBufbegno  ', mfBufbegno );
                            m90int (pc, 'mfBufendno  ', mfBufendno );
                            m90int (pc, 'faspec      ', faspec );
                            m90int (pc, 'fafetch     ', fafetch );
&                           endif
                            IF  (mfSelparsid <> cpr_parsidnull)      (* PTS 1103882 *)
                            THEN
                                IF  (faselectno <> mfSelectno)
                                    AND (ka.kaParseInfo.ParseId [cpr_p_precom_index] = chr(csp1_p_fetch_found))
                                THEN
                                    BEGIN
                                    (* pars again *)
                                    faselectno := 0;
                                    famfindex  := 0;
                                    fapos      := 0;
                                    fafetch    := cpr_is_true;
&                                   ifdef TRACE
                                    m90int (pc, 'faspec  2   ', faspec  );
                                    m90int (pc, 'fafetch 2   ', fafetch );
&                                   endif
                                    sqlcode    := csp_old_fileversion;
                                    sqlemp^.ereturncode := sqlcode;
                                    mfmfetch := cpr_is_true;
                                    xastopcnt := xastopcnt - 1;
&                                   ifdef P04TRACE
                                    p04trint2(sqlrap, 'faselectno 1      ', faselectno);
                                    p04trint2(sqlrap, 'faspec 1          ', faspec);
&                                   endif
                                    p01bchangetomfetch (sqlca, sqlxa);
                                    END
                                ELSE
                                    p01bsearchnextrec (sqlca, sqlxa, ga, @ka,
                                          ka.kafae^,
                                          famfindex, cmdfetch, sqcrowcount);
                                (*ENDIF*) 
&                           ifdef TRACE
                            (*ENDIF*) 
                            m90int (pc, 'faspec  3   ', faspec  );
                            m90int (pc, 'fafetch 3   ', fafetch );
&                           endif
                            END;
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      p01bmselect (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ka : sqlkaentry) : tsp00_Int2;
 
VAR
      i   : integer;
      found : boolean;
      (*   in2   : tsp_int_map_c2;*)
      (* before execute *)
 
BEGIN
p01bmselect := cpr_is_false;
WITH sqlca, sqlxa, sqlrap^, rasqltap^, sqlmfp^  DO
    IF  (sqlmfetch <> 0 ) (*****AND (tatraceno = 0)*****)
        AND (ka.kamacro = cpr_is_false)
    THEN
        BEGIN
&       ifdef TRACE
        m90int (pc, 'sqlmfetch   ', sqlmfetch);
        m90int (pc, 'kapars[11]  ', ord(ka.kaParseInfo.ParseId [cpr_p_precom_index] ));
        m90buf1 (pc, ka.kaParseInfo.ParseId, 1, 12);
&       endif
        IF  (ka.kaParseInfo.ParseId [cpr_p_precom_index] = chr(csp1_p_mass_select_found))
            OR (ka.kaParseInfo.ParseId [cpr_p_precom_index] = chr(csp1_p_reuse_mass_select_found))
            OR (ka.kaParseInfo.ParseId [cpr_p_precom_index] = chr(csp1_p_mselect_found))
            OR (ka.kaParseInfo.ParseId [cpr_p_precom_index] = chr(csp1_p_reuse_mselect_found))
        THEN
            BEGIN
            p01bmselect := cpr_is_true;
            (* init des zugeh?origen select eintrags *)
            found := false;
            i := 1;
            REPEAT
                WITH sqlmfp^, mfentry^ [i] DO
                    BEGIN
                    IF   (mfSelparsid = ka.kaParseInfo.ParseId)
                    THEN
                        BEGIN
                        found := true;
                        p01mfentryinit (sqlca, i);
                        IF  mfselcnt >= csp_maxint2
                        THEN
                            mfselcnt := 1
                        ELSE
                            mfselcnt := mfselcnt + 1;
                        (*ENDIF*) 
                        mfSelectno  := mfselcnt;
                        mfSelparsid := ka.kaParseInfo.ParseId;
&                       ifdef TRACE
                        m90int (pc, 'i init bexe ', i);
                        m90int2(pc, 'mfSelectno  ', mfSelectno);
                        m90buf1 (pc, ka.kaParseInfo.ParseId, 1, 12);
&                       endif
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                i := i + 1;
            UNTIL
                (i > sqlmfetch) OR (found);
            (*ENDREPEAT*) 
            i     := 1;
            IF  NOT found
            THEN
                REPEAT
                    WITH sqlmfp^, mfentry^ [i] DO
                        BEGIN
                        IF   mfInit = cpr_is_false
                        THEN
                            BEGIN
                            found := true;
                            p01mfentryinit (sqlca, i);
                            IF  mfselcnt >= csp_maxint2
                            THEN
                                mfselcnt := 1
                            ELSE
                                mfselcnt := mfselcnt + 1;
                            (*ENDIF*) 
                            mfSelectno  := mfselcnt;
                            mfSelparsid := ka.kaParseInfo.ParseId;
&                           ifdef TRACE
                            m90int (pc, 'i           ', i);
                            m90int2(pc, 'mfSelectno  ', mfSelectno);
                            m90buf1 (pc, ka.kaParseInfo.ParseId, 1, 12);
&                           endif
                            END;
                        (*ENDIF*) 
                        i := i + 1;
                        END;
                    (*ENDWITH*) 
                UNTIL
                    (i > sqlmfetch) OR (found);
                (*ENDREPEAT*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01bsearchnextrec (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ga : sqlgaentry;
            kae : sqlkaentry_ptr;
            VAR faentry : sqlfaentry;
            VAR mfindex : tsp00_Int2;
            VAR cmdfetch : tsp00_Int2;
            sqcrowcount   : tsp00_Int4);
 
VAR
      res   : tsp00_NumError;
      part_ptr  : tsp1_part_ptr;
      fatmp : tsp00_Int4;
 
BEGIN
&ifdef P04TRACE
p04trint2(sqlca.sqlrap, 'p01bsearchnextrec ', cmdfetch);
&endif
&ifdef TRACE
m90int (pc, 'cmdfetch    ', cmdfetch);
&endif
WITH  sqlca, sqlrap^, faentry, sqlmfp^, mfentry^ [mfindex] DO
    BEGIN
    (*  suche number  *)
    mfFetchget := cpr_is_init;
&   ifdef TRACE
    m90int (pc, 'sqlcode     ', sqlcode );
    m90int (pc, 'faspec      ', ord(faspec));
    m90int2(pc, 'mfRownotfoun', mfRownotfound);
    m90int2(pc, 'mfPrevfaspec', mfPrevfaspec);
&   endif
    CASE faspec OF
        cpr_fe_fetch, cpr_fe_next :
            BEGIN
            IF  (mfRownotfound = cpr_is_true)
                AND (mfPrevfaspec = cpr_fe_prev)
            THEN
                BEGIN
                mfRownotfound := cpr_is_false;
                mfLastrecno := 0;
                mfRecpos    := mfRecposbeg;
                END
            ELSE
                IF  (mfLastrecno = -1)
                THEN
                    BEGIN
                    mfRownotfound := cpr_is_true;
                    mfLastrecno := 0;
                    END
                ELSE
                    IF  (mfRownotfound = cpr_is_false)
                        OR ((mfPrevfaspec <> cpr_fe_fetch)
                        AND (mfPrevfaspec <> cpr_fe_next))
                    THEN
                        IF  mfLastrecno >= mfBufendno
                        THEN
                            IF  ((mfMaxselrec > 0)
                                AND (mfLastrecno >= mfMaxselrec))
                                OR (mfPrevfaspec = cpr_fe_last)
                            THEN
                                BEGIN
                                IF  (mfAllRecordsRead = cpr_is_false)
                                THEN
                                    BEGIN
                                    mfRownotfound := cpr_is_false;
                                    mfRecpos := 0;
                                    END
                                ELSE
                                    BEGIN
&                                   ifdef SQLODBC
                                    mfLastrecno := mfMaxselrec + 1;   (* PTS 1108750 *)
&                                   endif
                                    mfRownotfound := cpr_is_true;
                                    END
                                (*ENDIF*) 
                                END
                            ELSE
                                BEGIN
                                mfRownotfound := cpr_is_false;
                                mfRecpos := 0;
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            p01bnextrecord (sqlca, sqlxa, ga, kae, faentry, mfindex, cmdfetch, sqcrowcount);
&           ifdef P04TRACE
            p04trint2(sqlrap, 'p01bsearchnextrec1', cmdfetch);
&           endif
            END;
        cpr_fe_first :
            BEGIN
            mfRownotfound := cpr_is_false;
            mfActualPos := 0;
            IF  (mfBufbegno  = 1) AND
                (mfLastfaspec = cpr_fe_empty)
            THEN
                BEGIN
                mfLastrecno := 0;
                mfRecpos    := mfRecposbeg;
                END
            ELSE
                mfRecpos := 0;
            (*ENDIF*) 
            p01bnextrecord (sqlca, sqlxa, ga, kae, faentry, mfindex, cmdfetch, sqcrowcount);
&           ifdef P04TRACE
            p04trint2(sqlrap, 'p01bsearchnextrec2', cmdfetch);
&           endif
            END;
        cpr_fe_last :
            BEGIN
            mfRownotfound := cpr_is_false;
            IF  mfBufendno  = mfMaxselrec
            THEN
                BEGIN
                mfLastrecno := mfMaxselrec - 1;
                mfRecpos    := (mfBufendno - mfBufbegno) * mfReclen + 1;  (* PTS 1108670 *)
                mfActualPos := mfRecpos - 1;
                part_ptr := mfsegmpartptr[ord(sp1pk_data)+1];
                (*                p03find_part (mfsegmpartptr, sp1pk_data, part_ptr);*)
                IF  (part_ptr <> NIL)
                THEN
                    BEGIN
                    WITH  part_ptr^, sp1p_part_header  DO
                        IF  (sp1pa_last_packet in sp1p_attributes)
                        THEN
                            mfAllRecordsRead := cpr_is_true
                        ELSE
                            mfRecpos := 0;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                mfRecpos := 0;
            (*ENDIF*) 
            p01bnextrecord (sqlca, sqlxa, ga, kae, faentry, mfindex, cmdfetch, sqcrowcount);
&           ifdef P04TRACE
            p04trint2(sqlrap, 'p01bsearchnextrec3', cmdfetch);
&           endif
            END;
        cpr_fe_prev :
            BEGIN
            IF  (mfRownotfound = cpr_is_false)
                OR  (mfPrevfaspec <> cpr_fe_prev)
            THEN
                IF  (mfBufbegno < mfLastrecno)
                    AND  (mfLastrecno <= mfBufendno)
                THEN
                    BEGIN
                    IF  mfRownotfound = cpr_is_true
                    THEN
                        BEGIN
                        IF  (mfMaxselrec > 0)
                        THEN
                            BEGIN
                            IF  (mfMaxselrec = mfBufendno)
                            THEN
                                BEGIN
                                (* last record *)
                                mfLastrecno := mfMaxselrec - 1;
                                mfRecpos    := mfBuflen - mfReclen + 1;
                                END
                            ELSE
                                BEGIN
                                (* new buffer get  *)
                                mfRownotfound := cpr_is_false;
                                mfRecpos    := 0;
                                END;
                            (*ENDIF*) 
                            END
                        ELSE
                            BEGIN
                            mfLastrecno := mfLastrecno - 1;
                            mfRecpos    := mfRecpos - mfReclen;
                            mfRownotfound := cpr_is_false;
                            END;
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        (* record - 1 *)
                        mfLastrecno := mfLastrecno - 2;
                        mfRecpos    := mfRecpos
                              - mfReclen - mfReclen;
                        END;
                    (*ENDIF*) 
                    mfRownotfound := cpr_is_false;
                    END
                ELSE
                    IF   (mfBufbegno = 1)
                        AND (mfLastfaspec = cpr_fe_empty)
                    THEN
                        mfRownotfound := cpr_is_true
                    ELSE
                        BEGIN
                        mfRecpos := 0;
                        mfRownotfound := cpr_is_false;
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            p01bnextrecord (sqlca, sqlxa, ga, kae, faentry, mfindex, cmdfetch, sqcrowcount);
&           ifdef P04TRACE
            p04trint2(sqlrap, 'p01bsearchnextrec4', cmdfetch);
&           endif
            END;
        cpr_fe_same :
            BEGIN
            IF  (mfRownotfound = cpr_is_false)
                AND  (mfLastrecno <>  0)
            THEN
                IF  (mfBufbegno <= mfLastrecno)
                    AND  (mfLastrecno <= mfBufendno)
                THEN
                    BEGIN
                    mfLastrecno := mfLastrecno - 1;
                    mfRecpos    := mfRecpos - mfReclen;
                    p01bnextrecord (sqlca, sqlxa, ga, kae, faentry, mfindex, cmdfetch, sqcrowcount);
&                   ifdef P04TRACE
                    p04trint2(sqlrap, 'p01bsearchnextrec5', cmdfetch);
&                   endif
                    END
                ELSE
                    p08runtimeerror (sqlca, sqlxa, cpr_missing_previous_fetch)
                (*ENDIF*) 
            ELSE
                p08runtimeerror (sqlca, sqlxa, cpr_missing_previous_fetch);
            (*ENDIF*) 
            END;
        cpr_fe_posc, cpr_fe_posv:
            BEGIN
&           ifdef TRACE
            m90int  (pc, 'fapos       ', fapos );
            m90int4 (pc, 'mfBufbegno  ', mfBufbegno );
            m90int4 (pc, 'mfLastrecno ', mfLastrecno);
            m90int4 (pc, 'mfRecpos    ', mfRecpos   );
            m90int4 (pc, 'mfReclen    ', mfReclen   );
            m90int4 (pc, 'mfLastfaspec', mfLastfaspec);
&           endif
            fatmp := fapos;
            IF  (mfBufbegno <= fatmp)
                AND  (fatmp <= mfBufendno)
                (* AND (mfLastfaspec = cpr_fe_empty) *) (* HBI *)
            THEN
                BEGIN
                (* record liegt im puffer *)
                (* -1, da in p01bnextrecord wieder um 1 erhht wird !!! *)
                mfLastrecno := fatmp - 1;
                mfRecpos    := mfRecposbeg
                      + (fatmp - mfBufbegno) * mfReclen;
                mfActualPos := mfRecpos - 1;
                mfRownotfound := cpr_is_false;
&               ifdef TRACE
                m90int4 (pc, 'mfRecpos  n ', mfRecpos   );
                m90int4 (pc, 'mfLastrecno ', mfLastrecno);
&               endif
                END
            ELSE
                BEGIN
                IF  ((mfMaxselrec > 0) AND (fatmp > mfMaxselrec)
                    AND (mfAllRecordsRead = cpr_is_true))
                THEN
                    mfRownotfound := cpr_is_true
                ELSE
                    BEGIN
                    mfRownotfound := cpr_is_false;
                    mfRecpos := 0;
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            p01bnextrecord (sqlca, sqlxa, ga, kae, faentry, mfindex, cmdfetch, sqcrowcount);
&           ifdef P04TRACE
            p04trint2(sqlrap, 'p01bsearchnextrec6', cmdfetch);
&           endif
            END;
        cpr_fe_relc, cpr_fe_relv :
            BEGIN
&           ifdef TRACE
            m90int  (pc, 'fapos       ', fapos );
            m90int4 (pc, 'mfBufbegno  ', mfBufbegno );
            m90int4 (pc, 'mfLastrecno ', mfLastrecno);
            m90int4 (pc, 'mfRecpos    ', mfRecpos   );
            m90int4 (pc, 'mfReclen    ', mfReclen   );
            m90int4 (pc, 'mfLastfaspec', mfLastfaspec);
&           endif
            fatmp := mfLastrecno + fapos;
            IF  (mfBufbegno <= fatmp)
                AND  (fatmp <= mfBufendno)
                (* AND (mfLastfaspec = cpr_fe_empty) *) (* HBI *)
            THEN
                BEGIN
                (* record liegt im puffer *)
                mfLastrecno := fatmp - 1;
                mfRecpos    := mfRecposbeg
                      + (fatmp - mfBufbegno) * mfReclen;
                mfActualPos := mfRecpos - 1;
                mfRownotfound := cpr_is_false;
&               ifdef TRACE
                m90int4 (pc, 'mfRecpos  n ', mfRecpos   );
                m90int4 (pc, 'mfLastrecno ', mfLastrecno);
&               endif
                END
            ELSE
                BEGIN
                IF  ((mfMaxselrec > 0) AND (fatmp > mfMaxselrec)
                    AND (mfAllRecordsRead = cpr_is_true))
                THEN
                    BEGIN
&                   ifdef SQLODBC
                    mfLastrecno := mfMaxselrec + 1;   (* PTS 1108786 *)
&                   endif
                    mfRownotfound := cpr_is_true;
                    END
                ELSE
                    BEGIN
                    IF  ((mfBufbegno < 0) AND (fatmp >= 0))(* fetch hinter die
                          * Ergebnismenge  *)
                    THEN
                        BEGIN
                        mfRownotfound := cpr_is_true;
                        mfLastrecno   := 0
                        END
                    ELSE
                        BEGIN
                        IF  ((mfBufbegno > 0) AND (fatmp <= 0))(* fetch vor die
                              * Ergebnismenge
                              *)
                        THEN
                            BEGIN
                            mfRownotfound := cpr_is_true;
                            mfLastrecno   := 0
                            END
                        ELSE (* neuen Buffer holen *)
                            BEGIN
                            (* calculate relative fetch. *)
                            (* mfRownotfound is set by last fetch *)
                            IF  (mfRownotfound = cpr_is_true)
                            THEN (* cursor stands behind or before resultset *)
                                fapos := fatmp
                            ELSE
                                IF  (fapos>=0)
                                THEN (* the kernel fetches relativ to bufend *)
                                    fapos := (fatmp - mfBufendno)
                                ELSE (* the kernel fetches relativ to bufbeg *)
                                    fapos := (fatmp - mfBufbegno);
                                (*ENDIF*) 
                            (*ENDIF*) 
                            mfRownotfound := cpr_is_false;
                            mfRecpos := 0;
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            p01bnextrecord (sqlca, sqlxa, ga, kae, faentry, mfindex, cmdfetch, sqcrowcount);
&           ifdef P04TRACE
            p04trint2(sqlrap, 'p01bsearchnextrec6', cmdfetch);
&           endif
            END;
        OTHERWISE:
            BEGIN
            p08runtimeerror (sqlca, sqlxa, cpr_not_implemented);
            END;
        END;
    (*ENDCASE*) 
    (* mfPrevfaspec:= faspec; *)
    (* HBI *)
    (*case*)
    END;
(*ENDWITH*) 
&ifdef TRACE
m90int (pc, 'cdmfetch    ', cmdfetch);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01bgetmfetch (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ga : sqlgaentry;
            VAR ka : sqlkaentry;
            sqcrowcount   : tsp00_Int4);
 
BEGIN
(* after execute with  sqlrequest, sqlreceve *)
WITH sqlca, sqlrap^, sqlxa, rasqltap^ DO
    IF  (sqlmfetch <> 0)   (**** AND (tatraceno = 0)******)
        AND (ka.kamacro = cpr_is_false)
    THEN
        p01bnewmfetch (sqlca, sqlxa, ga, ka.kafae^, sqcrowcount);
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01bnewmfetch (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ga : sqlgaentry;
            VAR fa_entry : sqlfaentry;
            sqcrowcount   : tsp00_Int4);
 
BEGIN
p01bsetmfetch (sqlca, sqlxa, ga, fa_entry, false, sqcrowcount );
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01bsetmfetch (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ga : sqlgaentry;
            VAR fa_entry : sqlfaentry;
            opendata : boolean;
            sqcrowcount   : tsp00_Int4);
 
VAR
      lint  : tsp00_Int4;
      res : tsp00_NumError;
      anz : integer;
      parsid: tpr_parsid;
      nam   : tsp00_Name;
      part_ptr  : tsp1_part_ptr;
      headerlen : tsp00_Int4;
      var_tsp1_packet_header : tsp1_packet_header;
      i : integer;
      resname : tsp00_KnlIdentifier;
      (* after execute with  sqlrequest, sqlreceve *)
 
BEGIN
WITH sqlca, sqlrap^, sqlgap^, sqlxa, fa_entry, sqlemp^  DO
    BEGIN
    parsid := cpr_parsidnull;
    IF   (ereturncode = 0)
        AND (NOT opendata)
    THEN
        BEGIN
        (* error handling *)
        p03gselparsid (sqlrap, sqlemp, parsid, ga.gaKnlSessionID);
        IF  (parsid  = cpr_parsidnull)
        THEN
            p08runtimeerror (sqlca, sqlxa, cpr_select_parsid_missing)
        ELSE
            BEGIN
            IF  (parsid  = cpr_parsidnull)
            THEN
                p08runtimeerror (sqlca, sqlxa, cpr_select_parsid_missing)
            ELSE
                WITH sqlmfp^, mfentry^ [famfindex] DO
                    IF  (mfSelparsid = cpr_parsidnull)
                        OR (mfSelparsid <> parsid)
                    THEN
                        BEGIN
                        resname := bsp_knl_identifier;
                        i := p01bmfentryadd(sqlca, sqlxa, parsid, resname);
                        faselectno := sqlmfp^.mfentry^[i].mfSelectno;
                        famfindex  := i;
                        fapos      := 0;
                        END
                    ELSE
                        IF   (mfSelparsid <> parsid)
                        THEN
                            BEGIN
&                           ifdef TRACE
                            m90int (pc, 'famfindex   ',famfindex );
                            m90int2(pc, 'faselectno  ', faselectno);
                            m90int2(pc, 'mfSelectno  ', mfSelectno);
                            m90int2(pc, 'mfRecpos    ', mfRecpos);
&                           endif
                            IF  ralang = cpr_la_call
                            THEN
                                p08runtimeerror (sqlca, sqlxa,
                                      cpr_duplicate_fetch_callif)
                            ELSE
                                p08runtimeerror (sqlca, sqlxa,
                                      cpr_duplicate_fetch);
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDWITH*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF   ereturncode = 0
    THEN
        BEGIN
        (* ok , neues mfetch  ablegen *)
        (* und 1. record holen  *)
        WITH sqlmfp^, mfentry^ [famfindex] DO
            BEGIN
&           ifdef TRACE
            m90int (pc, 'famfindex   ', famfindex);
            m90int2(pc, 'mfSelectno  ', mfSelectno);
            m90int2(pc, 'mfRecpos    ', mfRecpos);
            m90int2(pc, 'mfReclen    ', mfReclen);
            m90int2(pc, 'mfBufinit   ', mfBufinit);
            m90int2(pc, 'mfBuflen    ', mfBuflen);
            m90int2(pc, 'mfMaxselrec ', mfMaxselrec);
            m90int2(pc, 'mfLastrecno ', mfLastrecno);
            m90int2(pc, 'mfBufbegno  ', mfBufbegno );
            m90int2(pc, 'mfBufendno  ', mfBufendno );
            m90int2(pc, 'fareclen    ', fareclen     );
            m90int4(pc, 'mfrecptrlen ', mfrecptrlen  );
&           endif
            IF  (sqlcode = 0) AND (opendata)
            THEN
                BEGIN
                p03cresultcountget (sqlrap, ga, sqlerrd[3]);
                IF  sqlerrd[3] <> 1
                THEN
                    BEGIN
                    p03find_part (sqlrap, sp1pk_resultcount, part_ptr);
                    IF  part_ptr <> NIL
                    THEN
                        WITH  part_ptr^, sp1p_part_header  DO
                            BEGIN
                            s40g4int (sp1p_buf, 2, lint, res);
                            lint := 1;
                            s41p4int (sp1p_buf, 2, lint, res);
                            sp1p_buf [1] := csp_defined_byte;
&                           ifdef P04TRACE
                            p04trint4(sqlrap, 'resultcount 2     ', lint);
&                           endif
                            END
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            mfBuflen := 0;
            mfActualPos := 0;
            mfNextLoopCnt := -1;
            mfAllRecordsRead := cpr_is_false;
            anz      := 0;
            p03find_part (sqlrap, sp1pk_data, part_ptr);
            IF  part_ptr <> NIL
            THEN
                WITH  part_ptr^, sp1p_part_header  DO
                    BEGIN
                    mfBuflen  := sp1p_buf_len;
                    anz       := sp1p_arg_count;
                    IF  (sp1pa_last_packet in sp1p_attributes)
                        AND (opendata)
                    THEN
                        mfMaxselrec := sp1p_arg_count
                    ELSE
                        IF  (mfMaxselrec > 0)
                        THEN (* HBI *)
                            mfMaxselrec := mfMaxselrec + anz
                        ELSE
                            mfMaxselrec := anz;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            mfFetchget := cpr_is_init;
            mfRecpos    := 1;
            mfRecposbeg := mfRecpos;
            mfSelparsid := parsid;
&           ifdef TRACE
            m90int (pc, 'anz         ', anz);
&           endif
            IF   anz  = 0
            THEN
                BEGIN
                sqlerrd [3] := 0;
                ereturncode := 100;
                nam := 'ROW NOT FOUND     ';
                s10mv (mxsp_name, mxsp_c70, @nam, 1,
                      @etext, 1, mxsp_name);
                etextlen       := mxsp_name;
                mfRownotfound := cpr_is_true;
                mfBufbegno  := 0;
                mfBufendno  := 0;
                mfLastrecno := 0;
                END
            ELSE
                WITH  part_ptr^, sp1p_part_header  DO
                    BEGIN
                    mfRownotfound := cpr_is_false;
                    mfReclen := fareclen;
                    mfLongcolpos  :=  (mfReclen * anz) + 1;
                    IF  (mfBuflen + mfReclen <= sp1p_buf_size)
                        AND (sqcrowcount <> anz)
                    THEN
                        IF  (mfLastfaspec = cpr_fe_empty)
                            AND  (mfMaxselrec < 0)
                        THEN
                            IF  (faspec = cpr_fe_posc)
                                OR (faspec = cpr_fe_posv)
                            THEN
                                (* rest records in einem puffer ab fapos *)
                                mfMaxselrec := fapos + anz - 1
                            ELSE
                                (* alle oder rest records in einem puffer *)
                                mfMaxselrec := mfBufendno + anz;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    CASE faspec OF
                        cpr_fe_fetch, cpr_fe_next :
                            BEGIN
                            mfBufbegno  := mfBufendno  + 1;
                            mfBufendno  := mfBufbegno  + (anz-1);
                            mfLastrecno := mfBufbegno  - 1;
                            END;
                        cpr_fe_first :
                            BEGIN
                            mfBufbegno  := 1;
                            mfBufendno  := mfBufbegno  + (anz-1);
                            mfLastrecno := mfBufbegno  - 1;
                            END;
                        cpr_fe_last :
                            BEGIN
                            mfLastfaspec:= cpr_fe_last;
                            mfBufendno  := -1; (* HBI *)
                            mfBufbegno  := mfBufendno  - (anz-1);
                            mfLastrecno := mfBufendno  - 1;
                            mfRecpos    := mfRecpos + (anz-1) * mfReclen;
                            mfActualPos := mfRecpos - 1;
                            END;
                        cpr_fe_prev :
                            BEGIN
                            IF  (mfLastfaspec = cpr_fe_empty)
                                AND (mfBufendno <> 0)
                            THEN
                                mfBufendno  := mfBufbegno  - 1
                            ELSE
                                mfBufendno  := anz;
                            (*ENDIF*) 
                            mfBufbegno  := mfBufendno  - (anz-1);
                            mfLastrecno := mfBufendno  - 1;
                            mfRecpos    := mfRecpos + (anz-1) * mfReclen;
                            mfActualPos := mfRecpos - 1;
                            END;
                        cpr_fe_same  :
                            BEGIN
                            IF  (mfLastfaspec = cpr_fe_empty)
                                AND (mfBufendno <> 0)
                            THEN
                                mfBufbegno  := mfBufendno
                            ELSE
                                mfBufbegno  := 1;
                            (*ENDIF*) 
                            mfBufendno  := mfBufbegno  + (anz-1);
                            mfLastrecno := mfBufbegno  - 1;
                            END;
                        cpr_fe_posc, cpr_fe_posv :
                            BEGIN
                            mfBufbegno  := fapos;
                            mfBufendno  := mfBufbegno  + (anz-1);
                            mfLastrecno := mfBufbegno  - 1;
                            END;
                        cpr_fe_relc, cpr_fe_relv :
                            BEGIN (* HBI *)
                            IF  (fapos >= 0)
                            THEN
                                mfBufbegno  := mfBufendno + fapos
                            ELSE
                                mfBufbegno  := mfBufbegno + fapos;
                            (*ENDIF*) 
                            mfBufendno  := mfBufbegno + (anz-1);
                            mfLastrecno := mfBufbegno-1;
                            END;
                        OTHERWISE:
                            p08runtimeerror (sqlca, sqlxa,
                                  cpr_select_parsid_missing);
                        END;
                    (*ENDCASE*) 
&                   ifdef TRACE
                    m90int (pc, 'famfindex   ', famfindex);
                    m90int2(pc, 'mfSelectno  ', mfSelectno);
                    m90int2(pc, 'mfRecpos    ', mfRecpos);
                    m90int2(pc, 'mfReclen    ', mfReclen);
                    m90int2(pc, 'mfLongcolpos', mfLongcolpos);
                    m90int2(pc, 'mfBufinit   ', mfBufinit);
                    m90int2(pc, 'mfBuflen    ', mfBuflen);
                    m90int2(pc, 'mf_lastfaspe', mfLastfaspec);
                    m90int2(pc, 'mfMaxselrec ', mfMaxselrec);
                    m90int2(pc, 'mfLastrecno ', mfLastrecno+1);
                    m90int2(pc, 'mfBufbegno  ', mfBufbegno );
                    m90int2(pc, 'mfBufendno  ', mfBufendno );
                    m90int4(pc, 'mfrecptrlen ', mfrecptrlen  );
&                   endif
                    WITH sqlgap^, ga, garecptr^, sp1_header DO
                        BEGIN
                        (* rette garecptr packet nach mfbufpointer *)
                        (*mfbufinit,bufpointer; 4B len, garecpacket*)
                        p01xballocate (sqlca, ga, famfindex);
                        (* PTS 1110937 *)
                        IF  (mfBufpointer.intaddr = 0)
                        THEN
                            p08runtimeerror (sqlca, sqlxa, cpr_memory_allocation_faild)
                        ELSE
                            BEGIN
&                           ifdef TRACE
                            m90int (pc, 'famfindex   ', famfindex);
                            m90int2(pc, 'sp1p_seg_len', sp1_segm.sp1s_segm_len );
&                           endif
                            WITH var_tsp1_packet_header DO
                                headerlen := sizeof (var_tsp1_packet_header);
                            (*ENDWITH*) 
                            s10mv (sp1h_varpart_size + headerlen,
                                  sp1h_varpart_size + headerlen,
                                  @garecptr^, 1,
                                  @mfBufpointer.vtypep^, 1,
                                  sp1h_varpart_len + headerlen);
                            (* 1. record retten *)
                            s10mv (mfReclen, mfReclen,
                                  @part_ptr^.sp1p_buf, 1,
                                  @mfrecpointer.vtypep^[1], 1, mfReclen);
                            garecptr := mfBufpointer.vtypep;
                            rasegptr := s30gad3 (mfBufpointer.vtypep^.sp1_segm);
                            p03partptrinit (sqlrap);
                            mfsegmpartptr := rasegmpartptr;
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                    IF  NOT   opendata
                    THEN
                        BEGIN
                        p01bonerecget (sqlca, sqlxa, ga, famfindex);
                        mfRecpos := mfRecpos + mfReclen;
                        mfLastrecno:= mfLastrecno + 1;
                        mfPrevfaspec:= faspec;
                        IF  (sqldbmode = cpr_kind_oracle)
                            OR (sqldbmode = cpr_kind_sapr3)
                        THEN
                            sqlerrd [3]  := mfLastrecno
                        ELSE
                            sqlerrd [3]  := 1;
                        (*ENDIF*) 
&                       ifdef TRACE
                        m90int2(pc, 'mfReclen    ', mfReclen);
                        m90int2(pc, 'mfRecpos    ', mfRecpos);
                        m90int2(pc, 'mfLastrecno ', mfLastrecno);
                        m90int2(pc, 'mfPrevfaspec', mfPrevfaspec);
                        m90int2(pc, 'sqlerrd(3)  ', sqlerrd [3] );
&                       endif
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(**)
(*------------------------------*) 
 
PROCEDURE
      p01bonerecget (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ga : sqlgaentry;
            mfindex  : tsp00_Int2);
 
VAR
      part_ptr  : tsp1_part_ptr;
      segm_ptr   : tsp1_segment_ptr;
      maxlen     : tsp00_Int4;
      loop : integer;
      posrec : tsp00_Int4;
      pos  : tsp00_Int4;
 
BEGIN
WITH sqlca, sqlrap^, sqlemp^, sqlxa,
     sqlgap^, sqlmfp^, mfentry^ [mfindex] DO
    BEGIN
&   ifdef P04TRACE
    p04trint2(sqlrap, 'p01bonerecget     ', mfindex);
&   endif
    ga.garecptr := mfBufpointer.vtypep;
    segm_ptr := s30gad3 (mfBufpointer.vtypep^.sp1_segm);
    (** s26find_part (segm_ptr,  sp1pk_data, part_ptr); **)
    part_ptr := mfsegmpartptr [ord(sp1pk_data)+1];
    IF  part_ptr  <> NIL
    THEN
        WITH part_ptr^, sp1p_part_header  DO
            BEGIN
&           ifdef TRACE
            m90int4 (pc, 'mfrecpos    ', mfRecpos);
            m90int4 (pc, 'mfreclen    ', mfReclen);
            m90int4 (pc, 'mf_buf_size ', part_ptr^.sp1p_buf_size);
            m90int4 (pc, 'pa_buf_size ', part_ptr^.sp1p_buf_size);
            m90int4 (pc, 'pa_buf_len  ', part_ptr^.sp1p_buf_len );
&           endif
            (* move all data_part *)
            rasegptr := segm_ptr;
            rasegmpartptr := mfsegmpartptr;
&           ifdef NEWMFETCH
            (* removed since PTS 1109385 *)
            maxlen := part_ptr^.sp1p_buf_size;
            (* move acct record to pos 1 in data_part *)
&           ifdef P04TRACE
            p04trint2(sqlrap, 'mfRecpos          ', mfRecpos);
&           endif
            IF  mfRecpos = 1
            THEN
                s10mv (maxlen, maxlen,
                      @mfrecpointer.vtypep^[1], mfRecpos,
                      @part_ptr^.sp1p_buf, 1, mfReclen)
            ELSE
                s10mv (maxlen, maxlen,
                      @part_ptr^.sp1p_buf, mfRecpos,
                      @part_ptr^.sp1p_buf, 1, mfReclen);
            (*ENDIF*) 
            IF  (mffetchkind = cpr_is_loop)
            THEN
                BEGIN
                (** next loop part in datapart moven ab pos = 1 **)
                IF  (mfRecpos > 1)
                THEN
                    BEGIN
                    mfsumanzrec := mfsumanzrec + mfLastrecno + 1;
                    posrec := mfRecpos + mfReclen;
                    pos    := 1 + mfReclen;
                    FOR loop := mfLastrecno +1 TO mfMaxselrec DO
                        BEGIN
                        s10mv (maxlen, maxlen,
                              @part_ptr^.sp1p_buf, posrec,
                              @part_ptr^.sp1p_buf, pos, mfReclen);
                        posrec := posrec + mfReclen;
                        pos    := pos + mfReclen;
                        END;
                    (*ENDFOR*) 
                    mfMaxselrec := mfMaxselrec - mfLastrecno ;
                    sp1p_arg_count := mfMaxselrec;
&                   ifdef TRACE
                    m90int4 (pc, 'mfMaxselrec ', mfMaxselrec);
                    m90int  (pc, 'posrec      ', posrec  );
                    m90int  (pc, 'pos         ', pos);
&                   endif
                    END;
                (*ENDIF*) 
                END;
&           endif
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01baexecute (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR gae : sqlgaentry;
            VAR kae : sqlkaentry;
            VAR ore : sqlorentry);
 
BEGIN
(* after execute immer *)
&ifdef TRACE
m90int (pc, 'sqlmfecht   ',sqlca.sqlmfetch );
m90int2(pc, 'kamacro     ', kae.kamacro );
m90int2(pc, 'ereturncode ', sqlca.sqlemp^.ereturncode);
&endif
IF  (sqlca.sqlmfetch <> 0)  (* AND (tatraceno = 0) ***)
    AND (kae.kamacro = cpr_is_false)
THEN
    p01bafterexecute (sqlca, sqlxa, gae, @kae, @ore, kae.kaParseInfo.ParseId);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01bafterexecute (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ga : sqlgaentry;
            kae : sqlkaentry_ptr;
            ore : sqlorentry_ptr;
            VAR parsid: tpr_parsid);
 
VAR
      i   : integer;
      selparsid: tpr_parsid;
      found : boolean;
      resname : tsp00_KnlIdentifier;
      part_ptr  : tsp1_part_ptr;
      parsidequal : boolean;
      resultnameequal : boolean;
      retmfselectno : tsp00_Int2;
      lint  : tsp00_Int4;
 
BEGIN
WITH sqlca, sqlrap^, sqlgap^, sqlemp^, sqlxa DO
    BEGIN
    IF   (ereturncode = 0)
        OR  (ereturncode = 100)
    THEN
        BEGIN
&       ifdef TRACE
        m90buf1 (pc, parsid, 1, 12);
&       endif
        found := false;
        IF  (parsid [cpr_p_precom_index] = chr(csp1_p_close_found))
        THEN
            BEGIN
            p03gselparsid (sqlrap, sqlemp, selparsid, ga.gaKnlSessionID);
            IF  (selparsid  <> cpr_parsidnull)
            THEN
                BEGIN
                p01pparsidtrace (sqlca, sqlxa, kae, selparsid, TraceParseIDSelect_epr00);
&               ifdef TRACE
                m90buf1 (pc, selparsid, 1, mxpr_parsid);
&               endif
                i := 1;
                REPEAT
                    WITH sqlmfp^, mfentry^ [i] DO
                        IF   (mfSelparsid = selparsid)
                        THEN
                            BEGIN
                            mfRecpos := -1;
                            found := true;
&                           ifdef TRACE
                            m90int (pc, 'i  delete   ',i );
                            m90int2(pc, 'mfSelectno  ', mfSelectno);
                            m90int2(pc, 'mfRecpos    ', mfRecpos);
                            m90buf1 (pc, mfSelparsid, 1, mxpr_parsid);
&                           endif
                            retmfselectno := mfSelectno;
                            p01mfentryinit (sqlca, i);
                            p04trint2(sqlrap, 'mfIndex restore   ', i);
                            mfSelparsid := selparsid;
                            mfSelectno  := retmfselectno;
                            END;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    i := i + 1;
                UNTIL
                    (i > sqlmfetch) OR (found);
                (*ENDREPEAT*) 
                END;
            (*ENDIF*) 
            END;
        (* PTS 1000837 E.Z.  und sortiert gegenber 6.2.8.8 *)
        (*ENDIF*) 
        IF  (   parsid [cpr_p_precom_index] = chr(csp1_p_mass_select_found))
            OR (parsid [cpr_p_precom_index] = chr(csp1_p_select_for_update_found))
            OR (parsid [cpr_p_precom_index] = chr(csp1_p_reuse_update_sel_found))
            OR (parsid [cpr_p_precom_index] = chr(csp1_p_reuse_mass_select_found))
            OR (parsid [cpr_p_precom_index] = chr(csp1_p_mselect_found))
            OR (parsid [cpr_p_precom_index] = chr(csp1_p_for_upd_mselect_found))
            OR (parsid [cpr_p_precom_index] = chr(csp1_p_reuse_mselect_found))
            OR (parsid [cpr_p_precom_index] = chr(csp1_p_reuse_upd_mselect_found))
        THEN
            BEGIN
            resname := sqlresn;
            IF  sqlresn = bsp_knl_identifier
            THEN
                resname[1] := chr (0);
&           ifdef TRACE
            (*ENDIF*) 
            m90identifier (pc, resname);
&           endif
            (*  select command ergname found *)
            i := 1;
            REPEAT
                WITH sqlmfp^, mfentry^ [i] DO
                    BEGIN
&                   ifdef TRACE
                    m90int (pc, 'i  mfresultn',i );
                    m90identifier (pc, mfresultname);
&                   endif
                    parsidequal := FALSE;
                    IF  mfresultname = resname
                    THEN
                        parsidequal := TRUE;
                    (*ENDIF*) 
                    IF  (mfSelparsid = parsid)
                    THEN
                        parsidequal := TRUE;
                    (*ENDIF*) 
                    IF   (parsidequal)
                    THEN
                        BEGIN
                        retmfselectno := mfSelectno;
                        p01mfentryinit (sqlca, i);
                        mfSelectno  := retmfselectno;
                        IF  sqlcode = 0
                        THEN
                            p03cresultcountget (sqlrap, ga, sqlerrd[3]);
                        (*ENDIF*) 
                        mfMaxselrec := sqlerrd [3];
                        mfSelparsid := parsid;
                        mfresultname := resname;
                        found := true;
                        IF  ralang <> cpr_la_call
                        THEN
                            BEGIN
                            (* PTS 1104383 *)
                            lint := pr01bNumberOfRows(sqlca,sqlxa);
                            p01bexistdatapart (sqlca, sqlxa, ga, kae^, ore^, i, lint);
                            END;
&                       ifdef TRACE
                        (*ENDIF*) 
                        m90int (pc, 'i  mass sel ',i );
                        m90int2(pc, 'mfSelectno  ', mfSelectno);
                        m90int2(pc, 'mfMaxselrec ', mfMaxselrec);
&                       endif
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                i := i + 1;
            UNTIL
                (i > sqlmfetch) OR (found);
            (*ENDREPEAT*) 
            IF  (NOT found)
            THEN
                BEGIN
                p03find_part (sqlrap, sp1pk_data, part_ptr);
                IF  part_ptr <> NIL
                THEN
                    BEGIN
                    i := p01bmfentryadd(sqlca, sqlxa, parsid, resname);
                    WITH sqlmfp^, mfentry^ [i] DO
                        BEGIN
                        IF  sqlcode = 0
                        THEN
                            p03cresultcountget (sqlrap, ga, sqlerrd[3]);
                        (*ENDIF*) 
                        mfMaxselrec := sqlerrd [3];
                        IF  ralang <> cpr_la_call
                        THEN
                            BEGIN
                            (* PTS 1104383 *)
                            lint := pr01bNumberOfRows(sqlca,sqlxa);
                            p01bexistdatapart (sqlca, sqlxa, ga, kae^, ore^, i, lint);
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01bexistdatapart (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ga : sqlgaentry;
            VAR ka : sqlkaentry;
            VAR ore : sqlorentry;
            mfindex : integer;
            sqcrowcount   : tsp00_Int4);
 
VAR
      part_ptr  : tsp1_part_ptr;
      fa_entry : sqlfaentry;
 
BEGIN
WITH sqlca, sqlxa, sqlrap^, rasqltap^ DO
    WITH sqlmfp^, mfentry^ [mfindex] DO
        BEGIN
        IF  (pr01cIsComType(sqlxa.xaSQLDesc^, cpr_com_sql_open))
        THEN
            BEGIN
            (*24.3.97*)
            mfopendata := cpr_is_false;
            ka.kaopendata := cpr_is_false;
            p03find_part (sqlrap, sp1pk_data, part_ptr);
            IF  part_ptr <> NIL
            THEN
                BEGIN
                WITH fa_entry DO
                    BEGIN
                    p04trint2(sqlrap, 'mfIndex data      ', mfindex);
                    (** datapart bei open gefunden **)
                    (** lege in mfbuffer ab        **)
                    faselectno := mfSelectno;
                    famfindex  := mfindex;
                    fapos      := 0;
                    (*faspec     := cpr_fe_first;*)
                    faspec     := cpr_fe_fetch;
                    fafetch    := cpr_is_false;
                    fareclen   := ore.orressqlrow.oreclen;
&                   ifdef TRACE
                    m90int4(pc, 'fareclen    ', fareclen  );
&                   endif
                    p01bsetmfetch (sqlca, sqlxa, ga, fa_entry, true, sqcrowcount );
                    mfSelparsid := ka.kaParseInfo.ParseId;
                    mfopendata  := cpr_is_true;
                    ka.kaopendata  := cpr_is_true;
                    END;
                (*ENDWITH*) 
                WITH  part_ptr^, sp1p_part_header  DO
                    BEGIN
                    IF  (sp1pa_last_packet in sp1p_attributes)
                    THEN
                        pr01cSetLastDataReceived (sqlxa.xaSQLDesc^, 1)
                    ELSE
                        pr01cSetLastDataReceived (sqlxa.xaSQLDesc^, 0);
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01bchangetomfetch (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype);
 
VAR
      nam     : tsp00_Name;
 
BEGIN
WITH sqlca, sqlxa, sqlrap^, rasqltap^   DO
    IF   (tatrout <> cpr_trace_off)
    THEN
        BEGIN
        (* ausgabe art = komando again  *)
        SAPDB_PascalForcedFill (mxsp_c256, @tastr80, 1, mxsp_c256, bsp_c1);
        nam := 'CHANGE TO IMPLICIT';
        p08puttracename (sqlca, sqlxa, nam, mxsp_name, false);
        nam := ' MASS FETCH       ';
        p08puttracename (sqlca, sqlxa, nam, mxsp_name, false);
        p08vfwritetrace (sqlca.sqlrap);
        END;
    (*ENDIF*) 
(*ENDWITH*) 
p03DebugBreak;
END;
 
(*------------------------------*) 
 
FUNCTION
      p01bmfentryget(VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR selparsid: tpr_parsid) : tsp00_Int2;
 
VAR
      i   : integer;
      found : boolean;
 
BEGIN
WITH sqlca DO
    BEGIN
    found := FALSE;
    p01bmfentryget := 0;
    i := 1;
    REPEAT
        IF   (sqlmfp^.mfentry^[i].mfSelparsid = selparsid)
        THEN
            BEGIN
            p01bmfentryget := i;
            found := TRUE;
            END;
        (*ENDIF*) 
        i := i + 1;
    UNTIL
        (i > sqlmfetch) OR (found);
    (*ENDREPEAT*) 
    END;
(*ENDWITH*) 
END;
 
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      p01btrace (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            art : tsp00_Int2;
            wert : tsp00_Int4);
 
VAR
      nam  : tsp00_Name;
      int  : integer;
      chr12  : tsp00_C12;
 
BEGIN
WITH sqlca, sqlrap^, rasqltap^  DO
    BEGIN
    IF  art = 0
    THEN
        tatrout := cpr_trace_off
    ELSE
        IF  tatraceno <> 0
        THEN
            BEGIN
            tatrout := cpr_trace_long;
            SAPDB_PascalForcedFill (mxsp_c256, @tastr80, 1, mxsp_c256, bsp_c1);
            CASE art OF
                1 :
                    nam := 'mf sp1p_buf_size  ';
                3 :
                    nam := 'mf sp1p_buf_len   ';
                2 :
                    nam := 'part sp1p_buf_size';
                4 :
                    nam := 'lo sp1p_buf_size  ';
                5 :
                    nam := 'lo sp1p_buf_len   ';
                6 :
                    nam := 'mf recpos         ';
                7 :
                    nam := 'mf reclen         ';
                8 :
                    nam := 'mf index          ';
                9 :
                    BEGIN
                    tastr80l := 1;
                    p08vfwritetrace (sqlca.sqlrap);
                    nam := 'xakano            ';
                    END;
                10 :
                    nam := 'sessionno         ';
                OTHERWISE:
                    nam := 'RESULT      :     ';
                END;
            (*ENDCASE*) 
            p08puttracename (sqlca, sqlxa, nam, mxsp_name, false);
            int := wert;
            p05inttochr12 (int, chr12);
            s10mv (mxsp_c12, mxsp_c80, @chr12, 2,
                  @tastr80, tastr80l+1, 5 );
            tastr80l := tastr80l + 5;
            p08vfwritetrace (sqlca.sqlrap);
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
&endif
(*------------------------------*) 
 
FUNCTION
      p01bmfentryadd(VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            selparsid : tpr_parsid;
            resname : tsp00_KnlIdentifier) : integer;
 
VAR
      i : integer;
      found : boolean;
      descMaxelem : tsp00_Int4;
 
BEGIN
found := false;
i := 1;
WITH sqlca DO
    BEGIN
    WHILE (i <= sqlmfetch) AND NOT found DO
        WITH sqlmfp^, mfentry^ [i] DO
            BEGIN
            IF   mfInit = cpr_is_false
            THEN
                BEGIN
                found := true;
                p01mfentryinit (sqlca, i);
                mfSelparsid := selparsid;
                mfresultname := resname;
                PacketEncoding := sqlxa.xaSQLDesc^.PacketEncoding;
                END
            ELSE
                i := i + 1;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDWHILE*) 
    IF  NOT found
    THEN
        WITH sqlmfp^ DO
            BEGIN
            descMaxelem := mfdesc.descMaxelem;
            p03dynalloc (mfdesc);
            sqlmfetch := mfdesc.descNelem;
            FOR i := descMaxelem+1 TO mfdesc.descMaxelem DO
                mfentry^[i].mfBufinit := cpr_is_false;
            (*ENDFOR*) 
            i := sqlmfetch;
            p01mfentryinit (sqlca, i);
            mfentry^[i].mfSelparsid := selparsid;
            mfentry^[i].mfresultname := resname;
            mfentry^[i].PacketEncoding := sqlxa.xaSQLDesc^.PacketEncoding;
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
p01bmfentryadd := i;
END;
 
(*------------------------------*) 
 
FUNCTION
      pr01bNumberOfRows(VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype) : tsp00_Int4;
 
VAR
      lp : ^tpr_sqlloop;
      rows  : tsp00_Int4;
 
BEGIN
lp := NIL;
rows := pr04GetLoopCnt(sqlca, sqlxa, lp^);
IF  (rows = 0)
THEN
    rows := mxpr_mfetchrecords;
(*ENDIF*) 
pr01bNumberOfRows := rows;
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
