/* @lastChanged: "1999-02-03  15:26"
 
 * @filename:   vut07
 * @purpose:    "UT_repair"
 * @release:    7.2.0.0
 * @see:        "-.-"
 *
 * @Copyright (c) 1999-2005 SAP AG"
 */
 
.tt 1 $SAP$LiveCache$VUT07$
.tt 3 $$UT_repair$1999-02-03$
 
.nf
 
 .nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
***********************************************************
 
Module  : UT_repair
 
Define  :
 
        PROCEDURE
              u07connect_check (VAR term : tut_terminal;
                    VAR userid   : tsp00_KnlIdentifier;
                    VAR password : tsp00_CryptPw;
                    VAR serverdb : tsp00_DbName;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              u07edit_restart_rec_loginfo (VAR term : tut_terminal;
                    VAR protfile   : tut_vf_fileref;
                    VAR f          : tut_file;
                    is_read_only   : boolean;
                    loginfo_wanted : boolean;
                    VAR pfkey      : tut_pfkey);
 
        PROCEDURE
              u07read_page (VAR term : tut_terminal;
                    VAR protfile     : tut_vf_fileref;
                    snd_packet       : tsp1_packet_ptr;
                    VAR sql_ref      : tsp00_Int4;
                    dev_type         : tut_dev_type;
                    devno            : tsp00_Int2;
                    VAR devname      : tsp00_VFilename;
                    pno              : tsp00_Int4;
                    VAR buf          : tsp00_Page;
                    VAR buf_len      : tsp00_Int4;
                    VAR sql_retcode  : tsp00_Int2);
 
        PROCEDURE
              u07repair (VAR term   : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    snd_packet      : tsp1_packet_ptr;
                    VAR sql_ref     : tsp00_Int4;
                    VAR userid      : tsp00_KnlIdentifier;
                    VAR password    : tsp00_CryptPw;
                    VAR serverdb    : tsp00_DbName;
                    VAR pfkey       : tut_pfkey;
                    VAR sql_retcode : tsp00_Int2;
                    bDoConnectCheck : boolean);
 
        PROCEDURE
              u07write_page (VAR term : tut_terminal;
                    VAR protfile      : tut_vf_fileref;
                    snd_packet        : tsp1_packet_ptr;
                    VAR sql_ref       : tsp00_Int4;
                    dev_type          : tut_dev_type;
                    devno             : tsp00_Int2;
                    VAR devname       : tsp00_VFilename;
                    dev_pno           : tsp00_Int4;
                    VAR buf           : tsp00_Page;
                    buf_len           : tsp00_Int4;
                    VAR sql_retcode   : tsp00_Int2);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              UT_utility_driver : VUT02;
 
        PROCEDURE
              u02send (VAR term     : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    snd_packet      : tsp1_packet_ptr;
                    VAR sql_ref     : tsp00_Int4;
                    msg_wanted      : integer;
                    req_only        : boolean;
                    VAR rcv_packet  : tsp1_packet_ptr;
                    VAR sql_retcode : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              UT_auxiliary_procedures : VUT05;
 
        PROCEDURE
              u05vfnto_packet (VAR n : tsp00_VFilename;
                    snd_packet : tsp1_packet_ptr);
 
        PROCEDURE
              u05encrypt (pw_clear : tsp00_Name;
                    VAR pw_crypt   : tsp00_CryptPw);
 
        PROCEDURE
              u05header (VAR term : tut_terminal;
                    progname   : tsp00_C8;
                    serverdb   : tsp00_DbName;
                    VAR userid : tsp00_KnlIdentifier);
 
        PROCEDURE
              u05int_to_packet (int : tsp00_Int4;
                    snd_packet      : tsp1_packet_ptr);
 
        FUNCTION
              u05isdevname_upper_case : boolean;
 
        FUNCTION
              u05isuser_upper_case : boolean;
 
        FUNCTION
              u05isyes (VAR n : tsp00_Name) : boolean;
 
        PROCEDURE
              u05nameto_packet (n : tsp00_Name;
                    snd_packet : tsp1_packet_ptr);
 
        PROCEDURE
              u05packet_init (snd_packet : tsp1_packet_ptr);
 
        PROCEDURE
              u05str20_to_line (comment : tsp00_C20;
                    VAR commentline     : tsp00_Line);
 
        PROCEDURE
              u05cmdwrite_prot (VAR protfile : tut_vf_fileref;
                    VAR blankline : tsp00_Line;
                    write_time    : boolean;
                    snd_packet    : tsp1_packet_ptr);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17int4to_line (int : tsp00_Int4;
                    with_zero     : boolean;
                    int_len       : integer;
                    ln_pos        : integer;
                    VAR ln        : tsp00_Line);
 
        PROCEDURE
              g17nameto_line (n : tsp00_Name;
                    VAR ln_len  : integer;
                    VAR ln      : tsp00_Line);
 
        PROCEDURE
              g17sname_to_line (n : tsp00_Sname;
                    VAR ln_len    : integer;
                    VAR ln        : tsp00_Line);
 
        PROCEDURE
              g17trimint4_to_line (int : tsp00_Int4;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              TA_terminal_IO : VTA09;
 
        PROCEDURE
              t09frame (VAR term : tut_terminal; on : boolean);
 
        PROCEDURE
              t09getmenu (VAR term : tut_terminal;
                    size           : integer;
                    msg_attr       : char;
                    upper_case     : boolean;
                    VAR msg        : tut_c20_array;
                    VAR selected   : integer;
                    VAR pfkey      : tut_pfkey;
                    VAR ln         : tsp00_Line;
                    VAR ok         : boolean);
 
        PROCEDURE
              t09get1name (VAR term : tut_terminal;
                    msg         : tsp00_C20;
                    msg_attr    : char;
                    in_attr     : char;
                    in_len      : integer;
                    upper_case  : boolean;
                    VAR in_name : tsp00_Name;
                    VAR pfkey   : tut_pfkey);
 
        PROCEDURE
              t09get2name (VAR term : tut_terminal;
                    msg1,        msg2        : tsp00_C20;
                    msg1_attr,   msg2_attr   : char;
                    in1_attr,    in2_attr    : char;
                    in1_len,     in2_len     : integer;
                    upper_case1, upper_case2 : boolean;
                    VAR in1_name,in2_name    : tsp00_Name;
                    VAR pfkey                : tut_pfkey);
 
        PROCEDURE
              t09header (VAR term : tut_terminal;
                    left_msg  : tsp00_C20;
                    right_msg : tsp00_C20);
 
        PROCEDURE
              t09holding (VAR term : tut_terminal;
                    VAR pfkey      : tut_pfkey);
 
        FUNCTION
              t09is_window_full (VAR term : tut_terminal;
                    wanted_lines: integer): boolean;
 
        PROCEDURE
              t09mask (VAR term   : tut_terminal;
                    count_names   : integer;
                    mask_size     : integer;
                    VAR mask_spec : tut_term_mask;
                    return_pfkey  : boolean;
                    VAR pfkey     : tut_pfkey);
 
        PROCEDURE
              t09menu (VAR term  : tut_terminal;
                    size         : integer;
                    msg_attr     : char;
                    VAR msg      : tut_c20_array;
                    VAR selected : integer;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              t09msgheader (VAR term : tut_terminal;
                    msg     : tsp00_C30;
                    is_perm : boolean);
 
        PROCEDURE
              t09newscreen_page (VAR term : tut_terminal);
 
        PROCEDURE
              t09put (VAR term : tut_terminal;
                    VAR text   : tsp00_Line;
                    text_attr  : char);
 
        PROCEDURE
              t09put60 (VAR term : tut_terminal;
                    ln60         : tsp00_C60;
                    text_attr    : char);
 
        PROCEDURE
              t09putmsg (VAR term     : tut_terminal;
                    VAR text          : tsp00_Line;
                    is_warning        : boolean;
                    immediate_display : boolean);
 
        PROCEDURE
              t09returncode_set (VAR term : tut_terminal;
                    retcode : integer);
 
      ------------------------------ 
 
        FROM
              TA_write_protfile : VTA12;
 
        PROCEDURE
              t12write_prot (VAR fileref : tut_vf_fileref;
                    VAR ln    : tsp00_Line;
                    length    : integer;
                    VAR error : integer);
 
      ------------------------------ 
 
        FROM
              TA_buf_display : VTA14;
 
        PROCEDURE
              t14bufdimension (VAR term : tut_terminal;
                    scan                : tut_diag_scan;
                    VAR bytes_per_line  : integer;
                    VAR line_size       : integer;
                    VAR lines_per_buf   : integer);
 
        PROCEDURE
              t14bufdisplay (VAR term : tut_terminal;
                    VAR protfile      : tut_vf_fileref;
                    scan              : tut_diag_scan;
                    msg               : tsp00_C30;
                    VAR buf           : tsp00_Page;
                    buf_size          : tsp00_Int4;
                    startpos          : tsp00_Int4;
                    endpos            : tsp00_Int4;
                    start_numbering   : tsp00_Int4;
                    VAR break_pos     : tsp00_Int4;
                    VAR pfkey         : tut_pfkey);
 
        PROCEDURE
              t14display_msg (VAR term : tut_terminal; msg : tsp00_C20);
 
        PROCEDURE
              t14editbuf (VAR term : tut_terminal;
                    VAR protfile   : tut_vf_fileref;
                    VAR buf        : tsp00_Page;
                    buf_size       : tsp00_Int4;
                    buf_offset     : tsp00_Int4;
                    VAR file_pos   : tut_file_pos;
                    edit_scan      : tut_diag_scan;
                    VAR is_saved   : boolean;
                    VAR pfkey      : tut_pfkey);
 
        PROCEDURE
              t14int4from_line (VAR term : tut_terminal;
                    VAR ln  : tsp00_Line;
                    ln_pos  : integer;
                    ln_len  : integer;
                    VAR int : tsp00_Int4;
                    VAR ok  : boolean);
 
        PROCEDURE
              t14record_edit (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    VAR node     : tsp00_Page;
                    node_size    : tsp00_Int4;
                    VAR file_pos : tut_file_pos;
                    edit_scan    : tut_diag_scan;
                    VAR is_saved : boolean;
                    VAR pfkey    : tut_pfkey);
 
      ------------------------------ 
 
        FROM
              XT_auxiliary_procedures : VXT05;
 
        PROCEDURE
              x05int_from_name (VAR term : tut_terminal;
                    displ_warning : boolean;
                    int2_wanted   : boolean;
                    n             : tsp00_Name;
                    VAR int       : tsp00_Int4;
                    VAR ok        : boolean);
 
        PROCEDURE
              x05int_to_name (int : tsp00_Int4; VAR n : tsp00_Name);
 
      ------------------------------ 
 
        FROM
              XT_page_display : VXT07;
 
        PROCEDURE
              x07debug_page (VAR term : tut_terminal;
                    VAR protfile      : tut_vf_fileref;
                    header_only       : boolean;
                    VAR file_pos      : tut_file_pos;
                    VAR buf           : tsp00_Page;
                    buf_size          : tsp00_Int4;
                    VAR pfkey         : tut_pfkey);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26find_part (VAR segm : tsp1_segment;
                    part_kind        : tsp1_part_kind;
                    VAR part_ptr     : tsp1_part_ptr);
 
        PROCEDURE
              s26finish_part (packet_ptr : tsp1_packet_ptr;
                    VAR finish_part      : tsp1_part);
 
        PROCEDURE
              s26new_part_init (packet_ptr : tsp1_packet_ptr;
                    VAR segm               : tsp1_segment;
                    VAR new_part_ptr       : tsp1_part_ptr);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              t09put;
 
              tsp00_C80 tsp00_Line
 
        PROCEDURE
              t14bufdisplay;
 
              tsp00_MoveObj tsp00_Page
 
        PROCEDURE
              t14editbuf;
 
              tsp00_MoveObj tsp00_Page
 
        PROCEDURE
              t14record_edit;
 
              tsp00_MoveObj tsp00_Page
 
        PROCEDURE
              x07debug_page;
 
              tsp00_MoveObj tsp00_Page
 
        PROCEDURE
              x07write_slot_to_page;
 
              tsp00_MoveObj tsp00_Page
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : JuergenA
.sp
.cp 3
Created : 1987-04-14
.sp
.cp 3
.sp
.cp 3
Release :      Date : 1999-02-03
.sp
***********************************************************
.sp
.cp 11
.fo
.oc _/1
Specification:
 
.CM *-END-* specification -------------------------------
.cp 15;.fo;.sp 2
***********************************************************
.sp
.fo
.oc _/1
Description:
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 20
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_msg               =     1;
      c_in                =     2;
      c_default_devno     =     1;
      c_display_msg       =     1;
      c_max_buffers       =    10;
      maxbuf_bytes_per_ln =    20;
      minbuf_bytes_per_ln =    30;
      mx_yes_no           =     2;
      int4_length         =    10;
      first_loc           = '0                 ';
      program_name        = 'REPAIR  ';
      retcode_repair_end  = 10001;
      string_delimiter    =  '''';
      c_yes_answer        = 'y                 ';
      (* *)
      c_header_only       =  true;
      c_immed_displ       =  true;
      c_int2              =  true;
      c_perm              =  true;
      c_read_page         =  true;
      c_req_only          =  true;
      c_return_pfkey      =  true;
      c_upper_case        =  true;
      c_warning           =  true;
      c_write_time        =  true;
      (*
      N A M E  *)
      utn_data            = 'DATA              ';
      utn_volume          = 'VOLUME            ';
      utn_diagnose        = 'DIAGNOSE          ';
      utn_from            = 'FROM              ';
      utn_for             = 'FOR               ';
      utn_log             = 'LOG               ';
      utn_loginfo         = 'LOGFULL           ';
      utn_mirrored        = 'SECOND            ';
      utn_page            = 'PAGE              ';
      utn_perm            = 'PERMANENT         ';
      utn_static          = 'STATIC            ';
      utn_restart         = 'RESTART           ';
      utn_restore         = 'RESTORE           ';
      utn_to              = 'TO                ';
      utn_set_block       = '  SET BLOCK ADDR  ';
      utn_del_block       = 'DELETE BLOCK ADDR ';
      utn_set             = 'SET               ';
      utn_delete          = 'DELETE            ';
      utn_block           = 'BLOCK             ';
      utn_block_addr      = 'BLOCK ADDRESS     ';
      (*
      M E S S A G E *)
      msg_set_data_perm  = 'SET DATA PERM       ';
      msg_del_data_perm  = 'DELETE DATA PERM    ';
      msg_set_data_static= 'SET DATA STATIC     ';
      msg_del_data_static= 'DELETE DATA STATIC  ';
      msg_data_perm      = 'DATA PERM           ';
      msg_data_static    = 'DATA STATIC         ';
      msg_data_perm_pno  = 'DATA PERM PAGENO    ';
      msg_data_static_pno= 'DATA STATIC PAGENO  ';
      msg_dev_name       = 'VOLUME NAME         ';
      msg_block_no       = 'BLOCKNO             ';
      msg_volume_name    = 'VOLUME              ';
      msg_volume_id      = 'VOLUME ID           ';
      msg_dupl_name      = 'Duplicate page name ';
      msg_illegal_input  = 'Illegal input       ';
      msg_illegal_len    = 'Illegal length      ';
      msg_illegal_pos    = 'Illegal position    ';
      msg_log            = 'LOG                 ';
      msg_log_volume_id  = 'LOG VOLUME ID       ';
      msg_loginfo_page   = 'LOG INFO PAGE       ';
      msg_mirr_log       = 'MIRRORED LOG        ';
      msg_not_defined    = 'No pages defined    ';
      msg_page_saved     = 'PAGE SAVED          ';
      msg_conv_updated   = 'CONVERTER UPDATED   ';
      msg_restart_rec    = 'RESTART RECORD      ';
      msg_return         = 'RETURN              ';
      msg_too_many_pages = 'Too many pages used ';
      msg_unknown_name   = 'Unknown page name   ';
      msg_execution      = 'EXECUTION?  (y/n)   ';
      msg_cmd_cancelled  = 'COMMAND CANCELLED   ';
      msg30_edit_page    = '          EDIT PAGE           ';
      msg30_edit_conv    = '     EDIT CONVERTER ENTRY     ';
      msg30_execute      = '           EXECUTE            ';
      msg30_show         = '          SHOW PAGES          ';
 
TYPE
      t_bufnames = ARRAY [1..c_max_buffers] OF tsp00_Name;
 
      t_read_param = RECORD
            rd_dev_type : tut_dev_type;
            rd_filler   : boolean;
            rd_devno    : tsp00_Int2;
            rd_pno      : tsp00_Int4;
            rd_devname  : tsp00_VFilename
      END;
 
 
 
(*------------------------------*) 
 
PROCEDURE
      u07connect_check (VAR term : tut_terminal;
            VAR userid   : tsp00_KnlIdentifier;
            VAR password : tsp00_CryptPw;
            VAR serverdb : tsp00_DbName;
            VAR pfkey    : tut_pfkey);
 
CONST
      x_pw = 1;
      x_id = 2;
 
VAR
      i           : integer;
      in_pw_crypt : tsp00_CryptPw;
      mask        : tut_term_mask;
 
BEGIN
t09frame  (term, false);
t09newscreen_page (term);
t09header (term, bsp_c20, bsp_c20);
t09put (term, term.blankline, cut_protected);
t09put (term, term.blankline, cut_protected);
FOR i := 1 TO 2 DO
    WITH mask [i] DO
        BEGIN
        msg_in_attr [c_msg] := cut_protected;
        msg_in_attr [c_in ] := cut_invisible;
        upper_case          := u05isuser_upper_case;
        code_input          := false;
        msg                 := bsp_c20;
        in_fn               := term.blankfilename
        END;
    (*ENDWITH*) 
(*ENDFOR*) 
mask [1].in_len := sizeof (tsp00_Name);
mask [2].in_len := sizeof (tsp00_KnlIdentifier);
t09mask (term, x_pw, x_id, mask, NOT c_return_pfkey, pfkey);
IF  pfkey = pf_none
THEN
    BEGIN
    u05encrypt (mask [x_pw].in_name, in_pw_crypt);
    IF  (mask [x_id].in_ident = userid) AND (in_pw_crypt = password)
    THEN
        u05header (term, program_name, serverdb, userid)
    ELSE
        pfkey := pf_end
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u07edit_restart_rec_loginfo (VAR term : tut_terminal;
            VAR protfile   : tut_vf_fileref;
            VAR f          : tut_file;
            is_read_only   : boolean;
            loginfo_wanted : boolean;
            VAR pfkey      : tut_pfkey);
 
VAR
      is_saved      : boolean;
      dev_type      : tut_dev_type;
      sql_retcode   : tsp00_Int2;
      buf_len       : tsp00_Int4;
      snd_packet    : tsp1_packet_ptr;
      file_pos      : tut_file_pos;
      dummy_devname : tsp00_VFilename;
      buf           : tsp00_Page;
 
BEGIN
sql_retcode := 0;
pfkey       := pf_none;
is_saved    := false;
snd_packet  := @f.utf_sql_packet^; (* tsp00_Addr -> tsp1_packet_ptr *)
IF  loginfo_wanted
THEN
    dev_type := utdt_loginfo
ELSE
    dev_type := utdt_restart_rec;
(*ENDIF*) 
u07read_page (term, protfile, snd_packet, f.utf_sql_ref,
      dev_type, 0, dummy_devname, 1, buf, buf_len, sql_retcode);
IF  (sql_retcode = 0) AND (pfkey = pf_none)
THEN
    BEGIN
    WITH file_pos DO
        BEGIN
        utfp_block_no        := cut_nil_block_no;
        utfp_page_no         := 1;
        utfp_pages_per_block := 1
        END;
    (*ENDWITH*) 
    t14editbuf (term, protfile, buf, buf_len, 0, file_pos,
          [utds_page_header], is_saved, pfkey)
    END;
(*ENDIF*) 
IF  (sql_retcode = 0) AND (pfkey = pf_none) AND is_saved
    AND NOT is_read_only
THEN
    u07write_page (term, protfile, snd_packet, f.utf_sql_ref,
          dev_type, 0, dummy_devname, 0, buf, buf_len, sql_retcode);
(*ENDIF*) 
IF  pfkey = pf_end
THEN
    pfkey := pf_none
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u07read_page (VAR term : tut_terminal;
            VAR protfile     : tut_vf_fileref;
            snd_packet       : tsp1_packet_ptr;
            VAR sql_ref      : tsp00_Int4;
            dev_type         : tut_dev_type;
            devno            : tsp00_Int2;
            VAR devname      : tsp00_VFilename;
            pno              : tsp00_Int4;
            VAR buf          : tsp00_Page;
            VAR buf_len      : tsp00_Int4;
            VAR sql_retcode  : tsp00_Int2);
 
VAR
      page_part  : tsp1_part_ptr;
      rcv_packet : tsp1_packet_ptr;
 
BEGIN
sql_retcode := 0;
u05packet_init   (snd_packet);
u05nameto_packet (utn_diagnose, snd_packet);
u05nameto_packet (utn_to, snd_packet);
WITH snd_packet^.sp1_segm DO
    BEGIN
    sp1p_buf [sp1p_buf_len + 1]:= ' ';
    sp1p_buf [sp1p_buf_len + 2]:= string_delimiter;
    sp1p_buf [sp1p_buf_len + 3]:= 'X';
    sp1p_buf [sp1p_buf_len + 4]:= string_delimiter;
    sp1p_buf_len := sp1p_buf_len + 4;
    END;
(*ENDWITH*) 
CASE dev_type OF
    utdt_data_perm:
        BEGIN
        u05nameto_packet (utn_data, snd_packet);
        u05int_to_packet (pno,      snd_packet)
        END;
    utdt_data_static:
        BEGIN
        u05nameto_packet (utn_static, snd_packet);
        u05int_to_packet (pno,        snd_packet);
        END;
    utdt_restart_rec:
        u05nameto_packet (utn_restart, snd_packet);
    utdt_loginfo:
        u05nameto_packet (utn_loginfo, snd_packet);
    OTHERWISE:
        ut07volume_to_cmd (snd_packet, dev_type, devno, devname, pno);
    END;
(*ENDCASE*) 
s26finish_part (snd_packet, snd_packet^.sp1_segm.sp1p_part);
u02send (term, protfile, snd_packet, sql_ref, c_display_msg,
      NOT c_req_only, rcv_packet, sql_retcode);
(* *)
IF  sql_retcode = 0
THEN
    BEGIN
    s26find_part (rcv_packet^.sp1_segm, sp1pk_page, page_part);
    IF  page_part <> NIL
    THEN
        BEGIN
        IF  (page_part^.sp1p_buf_len <= sizeof (buf)) AND
            (page_part^.sp1p_buf_len >  0)
        THEN
            BEGIN
            buf_len := page_part^.sp1p_buf_len;
            SAPDB_PascalForcedMove (page_part^.sp1p_buf_size, sizeof (buf),
                  @page_part^.sp1p_buf, 1, @buf, 1, buf_len)
            END
        ELSE
            page_part := NIL
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  page_part = NIL
    THEN
        t14display_msg (term, 'Page not transferred')
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u07repair (VAR term   : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            snd_packet      : tsp1_packet_ptr;
            VAR sql_ref     : tsp00_Int4;
            VAR userid      : tsp00_KnlIdentifier;
            VAR password    : tsp00_CryptPw;
            VAR serverdb    : tsp00_DbName;
            VAR pfkey       : tut_pfkey;
            VAR sql_retcode : tsp00_Int2;
            bDoConnectCheck : boolean);
 
CONST
      x_pages_scan  =  1;
      x_page_noscan =  3;
      x_page_scan   =  4;
      x_edit_conv   =  6;
      x_exit        =  9;
 
VAR
      is_quit    : boolean;
      selected   : integer;
      msg        : tut_c20_array;
      curr_dev   : tsp00_VFilename;
 
BEGIN
pfkey := pf_none;
FOR selected := 1 TO x_exit DO
    msg [selected] := bsp_c20;
(*ENDFOR*) 
msg [x_pages_scan ] := 'EDIT PAGE(S)        ';
msg [x_page_noscan] := 'EDIT PAGE (noscan)  ';
msg [x_page_scan  ] := 'EDIT PAGE (header)  ';
msg [x_edit_conv  ] := 'EDIT CONVERTER      ';
msg [x_exit       ] := 'EXIT                ';
IF  bDoConnectCheck
THEN
    u07connect_check (term, userid, password, serverdb, pfkey);
(*ENDIF*) 
is_quit  := false;
curr_dev := term.blankfilename;
IF  pfkey = pf_none
THEN
    REPEAT
        t09msgheader (term, bsp_c30, true);
        t09menu (term, x_exit, cut_protected, msg, selected, pfkey);
        t09putmsg (term, term.blankline, NOT c_warning, NOT c_immed_displ);
        IF  pfkey = pf_none
        THEN
            BEGIN
            CASE selected OF
                x_pages_scan:
                    ut07pages_repair (term, protfile, snd_packet, sql_ref,
                          curr_dev, pfkey, sql_retcode);
                x_page_noscan:
                    ut07one_page_repair (term, protfile, snd_packet, sql_ref,
                          [ ], curr_dev, pfkey, sql_retcode);
                x_page_scan:
                    ut07one_page_repair (term, protfile, snd_packet, sql_ref,
                          [utds_page_header], curr_dev, pfkey, sql_retcode);
                x_edit_conv:
                    ut07edit_converter (term, protfile, snd_packet, sql_ref,
                          pfkey, sql_retcode);
                x_exit:
                    BEGIN
                    is_quit := true;
                    pfkey   := pf_end
                    END;
                OTHERWISE
                    pfkey := pf_end;
                END
            (*ENDCASE*) 
            END;
        (*ENDIF*) 
        IF  (pfkey <> pf_none) AND NOT is_quit
        THEN
            BEGIN
            pfkey := pf_none;
            ut07display_leave_msg (term);
            t09holding (term, pfkey)
            END
        (*ENDIF*) 
    UNTIL
        pfkey in [pf_end, pf_cancel];
    (*ENDREPEAT*) 
(*ENDIF*) 
IF  sql_retcode <> 0
THEN
    t09holding (term, pfkey);
(*ENDIF*) 
IF  sql_retcode = retcode_repair_end
THEN
    t09returncode_set (term, 0);
(*ENDIF*) 
IF  sql_retcode = cut_sql_req_failed
THEN
    pfkey := pf_cancel
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u07write_page (VAR term : tut_terminal;
            VAR protfile      : tut_vf_fileref;
            snd_packet        : tsp1_packet_ptr;
            VAR sql_ref       : tsp00_Int4;
            dev_type          : tut_dev_type;
            devno             : tsp00_Int2;
            VAR devname       : tsp00_VFilename;
            dev_pno           : tsp00_Int4;
            VAR buf           : tsp00_Page;
            buf_len           : tsp00_Int4;
            VAR sql_retcode   : tsp00_Int2);
 
VAR
      dummy_err  : integer;
      part_ptr   : tsp1_part_ptr;
      rcv_packet : tsp1_packet_ptr;
      ln         : tsp00_Line;
 
BEGIN
sql_retcode := 0;
u05packet_init   (snd_packet);
u05nameto_packet (utn_diagnose, snd_packet);
u05nameto_packet (utn_restore,  snd_packet);
CASE dev_type OF
    utdt_data_perm:
        u05nameto_packet (utn_data, snd_packet);
    utdt_data_static:
        u05nameto_packet (utn_static, snd_packet);
    utdt_restart_rec:
        u05nameto_packet (utn_restart, snd_packet);
    utdt_loginfo:
        u05nameto_packet (utn_loginfo, snd_packet);
    OTHERWISE:
        ut07volume_to_cmd (snd_packet, dev_type, devno, devname, dev_pno);
    END;
(*ENDCASE*) 
s26finish_part (snd_packet, snd_packet^.sp1_segm.sp1p_part);
s26new_part_init (snd_packet, snd_packet^.sp1_segm, part_ptr);
SAPDB_PascalForcedMove (sizeof (buf), part_ptr^.sp1p_buf_size,
      @buf, 1, @part_ptr^.sp1p_buf, 1, buf_len);
part_ptr^.sp1p_part_kind := sp1pk_page;
part_ptr^.sp1p_buf_len   := buf_len;
s26finish_part (snd_packet, part_ptr^);
u05cmdwrite_prot (protfile, term.blankline, c_write_time,
      snd_packet);
t09msgheader (term,  msg30_execute, false);
u02send (term, protfile, snd_packet, sql_ref, c_display_msg,
      NOT c_req_only, rcv_packet, sql_retcode);
IF  sql_retcode = 0
THEN
    BEGIN
    u05str20_to_line (msg_page_saved, ln);
    t09putmsg (term, ln, NOT c_warning, c_immed_displ);
    t12write_prot (protfile, ln, 20, dummy_err)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut07volume_to_cmd (snd_packet : tsp1_packet_ptr;
            dev_type    : tut_dev_type;
            devno       : tsp00_Int2;
            VAR devname : tsp00_VFilename;
            VAR pno     : tsp00_Int4);
 
BEGIN
u05nameto_packet (utn_volume, snd_packet);
CASE dev_type OF
    utdt_volume_name:
        u05vfnto_packet (devname, snd_packet);
    utdt_log:
        BEGIN
        u05nameto_packet (utn_log, snd_packet);
        u05int_to_packet (devno, snd_packet);
        END;
    utdt_mirr_log:
        BEGIN
        u05nameto_packet (utn_mirrored, snd_packet);
        u05nameto_packet (utn_log, snd_packet);
        u05int_to_packet (devno, snd_packet);
        END;
    END;
(*ENDCASE*) 
u05nameto_packet (utn_from, snd_packet);
u05int_to_packet (pno,      snd_packet);
u05nameto_packet (utn_to,   snd_packet);
u05int_to_packet (pno,      snd_packet)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut07display_leave_msg (VAR term : tut_terminal);
 
BEGIN
t09put   (term, term.blankline, cut_protected);
t09put60 (term,
      'If you want to leave, restrike the END key                  ',
      cut_bright_protected)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut07move (VAR term   : tut_terminal;
            VAR protfile   : tut_vf_fileref;
            buf_len        : tsp00_Int4;
            source_name    : tsp00_Name;
            VAR source_buf : tsp00_Page;
            destin_name    : tsp00_Name;
            VAR destin_buf : tsp00_Page;
            VAR pfkey      : tut_pfkey);
 
VAR
      is_ok      : boolean;
      source_pos : tsp00_Int4;
      destin_pos : tsp00_Int4;
      move_len   : tsp00_Int4;
      source_upb : tsp00_Int4;
      destin_lwb : tsp00_Int4;
      destin_upb : tsp00_Int4;
      dummy_pos  : tsp00_Int4;
      count      : tsp00_Int4;
      offset     : tsp00_Int4;
      i          : tsp00_Int4;
      n          : tsp00_Name;
      n_endpos   : tsp00_Name;
      msg_source : tsp00_C30;
      msg_destin : tsp00_C30;
      ln         : tsp00_Line;
 
BEGIN
msg_source := 'SOURCE:                       ';
msg_destin := 'DESTIN:                       ';
SAPDB_PascalForcedMove (sizeof (source_name), sizeof (msg_source), @source_name, 1,
      @msg_source, 9, sizeof (source_name));
SAPDB_PascalForcedMove (sizeof (destin_name), sizeof (msg_destin), @destin_name, 1,
      @msg_destin, 9, sizeof (destin_name));
count := 0;
is_ok := true;
REPEAT
    count := count + 1;
    t09newscreen_page (term);
    t14bufdisplay (term, protfile, [utds_display], msg_source,
          source_buf, buf_len, 1, maxbuf_bytes_per_ln,
          1, dummy_pos, pfkey);
    t09put (term, term.blankline, cut_protected);
    n := '1                 ';
    t09get1name (term, '         SOURCE POS:', cut_bright_protected,
          cut_unprotected, sizeof (tsp00_Name), true, n, pfkey);
    t09putmsg (term, term.blankline, NOT c_warning, NOT c_immed_displ);
    IF  pfkey = pf_none
    THEN
        BEGIN
        SAPDB_PascalForcedMove (sizeof (n), sizeof (ln), @n, 1, @ln, 1, sizeof (n));
        t14int4from_line (term, ln, 1, sizeof (n), source_pos, is_ok);
        IF  is_ok
        THEN
            BEGIN
            IF  (source_pos < 1) OR (source_pos > buf_len)
            THEN
                BEGIN
                is_ok := false;
                t14display_msg (term, msg_illegal_pos)
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
UNTIL
    is_ok OR (pfkey <> pf_none) OR (count >= 3);
(*ENDREPEAT*) 
IF  (pfkey = pf_none) AND NOT is_ok
THEN
    pfkey := pf_end;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    IF  source_pos + maxbuf_bytes_per_ln - 1 <= buf_len
    THEN
        source_upb := source_pos + maxbuf_bytes_per_ln - 1
    ELSE
        source_upb := buf_len
    (*ENDIF*) 
    END;
(*ENDIF*) 
count := 0;
is_ok := false;
WHILE NOT is_ok AND (pfkey = pf_none) AND (count < 3) DO
    BEGIN
    count := count + 1;
    t09newscreen_page (term);
    t14bufdisplay (term, protfile, [utds_display], msg_source,
          source_buf, buf_len, source_pos, source_upb,
          source_pos, dummy_pos, pfkey);
    t09put (term, term.blankline, cut_protected);
    t14bufdisplay (term, protfile, [utds_display], msg_destin,
          destin_buf, buf_len, 1, maxbuf_bytes_per_ln,
          1, dummy_pos, pfkey);
    t09put (term, term.blankline, cut_protected);
    n := '1                 ';
    t09get1name (term, '         DESTIN POS:', cut_bright_protected,
          cut_unprotected, sizeof (tsp00_Name), true, n, pfkey);
    t09putmsg (term, term.blankline, NOT c_warning, NOT c_immed_displ);
    IF  pfkey = pf_none
    THEN
        BEGIN
        SAPDB_PascalForcedMove (sizeof (n), sizeof (ln), @n, 1, @ln, 1, sizeof (n));
        t14int4from_line (term, ln, 1, sizeof (n), destin_pos, is_ok);
        IF  is_ok
        THEN
            BEGIN
            IF  (destin_pos < 1) OR (destin_pos > buf_len)
            THEN
                BEGIN
                is_ok := false;
                t14display_msg (term, msg_illegal_pos)
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  (pfkey = pf_none) AND NOT is_ok
THEN
    pfkey := pf_end;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    IF  destin_pos + maxbuf_bytes_per_ln - 1 <= buf_len
    THEN
        destin_upb := destin_pos + maxbuf_bytes_per_ln - 1
    ELSE
        destin_upb := buf_len
    (*ENDIF*) 
    END;
(*ENDIF*) 
count := 0;
is_ok := false;
WHILE NOT is_ok AND (pfkey = pf_none) AND (count < 3) DO
    BEGIN
    count := count + 1;
    t09newscreen_page (term);
    t14bufdisplay (term, protfile, [utds_display], msg_source,
          source_buf, buf_len, source_pos, source_upb,
          source_pos, dummy_pos, pfkey);
    t09put (term, term.blankline, cut_protected);
    t14bufdisplay (term, protfile, [utds_display], msg_destin,
          destin_buf, buf_len, destin_pos, destin_upb,
          destin_pos, dummy_pos, pfkey);
    t09put (term, term.blankline, cut_protected);
    n := bsp_name;
    n_endpos := bsp_name;
    t09get2name (term, '        MOVE LENGTH:', 'or    SOURCE ENDPOS:',
          cut_bright_protected, cut_bright_protected, cut_unprotected,
          cut_unprotected, sizeof (tsp00_Name), sizeof (tsp00_Name),
          true, true, n, n_endpos, pfkey);
    t09putmsg (term, term.blankline, NOT c_warning, NOT c_immed_displ);
    IF  pfkey = pf_none
    THEN
        BEGIN
        IF  n <> bsp_name
        THEN
            SAPDB_PascalForcedMove (sizeof (n), sizeof (ln), @n, 1, @ln, 1, sizeof (n))
        ELSE
            SAPDB_PascalForcedMove (sizeof (n_endpos), sizeof (ln), @n_endpos, 1, @ln, 1,
                  sizeof (n_endpos));
        (*ENDIF*) 
        t14int4from_line (term, ln, 1, sizeof (n), move_len, is_ok);
        IF  is_ok
        THEN
            BEGIN
            IF  n <> bsp_name
            THEN
                BEGIN
                IF  (source_pos + move_len - 1 > buf_len)
                    OR
                    (destin_pos + move_len - 1 > buf_len)
                    OR
                    (move_len < 1)
                THEN
                    BEGIN
                    is_ok := false;
                    t14display_msg (term, msg_illegal_len)
                    END
                (*ENDIF*) 
                END
            ELSE
                IF  (move_len < source_pos)
                    OR
                    (move_len > buf_len)
                THEN
                    BEGIN
                    is_ok := false;
                    t14display_msg (term, msg_illegal_pos)
                    END
                ELSE
                    BEGIN
                    move_len := move_len - source_pos + 1;
                    IF  destin_pos + move_len -1 > buf_len
                    THEN
                        BEGIN
                        is_ok := false;
                        t14display_msg (term, msg_illegal_len)
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  (pfkey = pf_none) AND NOT is_ok
THEN
    pfkey := pf_end;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    IF  move_len > 4 * minbuf_bytes_per_ln
    THEN
        BEGIN
        msg_source := 'SOURCE (trunc):               ';
        SAPDB_PascalForcedMove (sizeof (source_name), sizeof (msg_source),
              @source_name, 1, @msg_source, 17, 14)
        END;
    (*ENDIF*) 
    t09newscreen_page (term);
    IF  move_len > 4 * minbuf_bytes_per_ln
    THEN
        source_upb := source_pos + 4 * minbuf_bytes_per_ln - 1
    ELSE
        source_upb := source_pos + move_len - 1;
    (*ENDIF*) 
    IF  move_len > 2 * maxbuf_bytes_per_ln
    THEN
        t14bufdisplay (term, protfile, [utds_minbuf, utds_display],
              msg_source, source_buf, buf_len,
              source_pos, source_upb, source_pos, dummy_pos, pfkey)
    ELSE
        BEGIN
        IF  move_len > maxbuf_bytes_per_ln
        THEN
            t09frame (term, false);
        (*ENDIF*) 
        t14bufdisplay (term, protfile, [utds_display], msg_source,
              source_buf, buf_len, source_pos, source_upb,
              source_pos, dummy_pos, pfkey)
        END;
    (*ENDIF*) 
    IF  destin_pos > 5
    THEN
        destin_lwb := destin_pos - 5
    ELSE
        destin_lwb := 1;
    (*ENDIF*) 
    IF  destin_upb + maxbuf_bytes_per_ln - 1 <= buf_len
    THEN
        destin_upb := destin_lwb + maxbuf_bytes_per_ln - 1
    ELSE
        destin_upb := buf_len;
    (*ENDIF*) 
    IF  destin_upb < destin_pos + move_len - 1
    THEN
        count := destin_upb - destin_pos + 1
    ELSE
        count := move_len;
    (*ENDIF*) 
    count := count * 3;
    ln := term.blankline;
    offset := 4 + (destin_pos - destin_lwb) * 3;
    ln [offset+2] := '|';
    FOR i := 3 TO count DO
        ln [offset+i] := '=';
    (*ENDFOR*) 
    IF  destin_upb < destin_pos + move_len - 1
    THEN
        ln [offset + count + 1] := '>'
    ELSE
        ln [offset + count] := '|';
    (*ENDIF*) 
    t09put (term, term.blankline, cut_bright_protected);
    t14bufdisplay (term, protfile, [utds_display], msg_destin,
          destin_buf, buf_len, destin_lwb, destin_upb,
          destin_lwb, dummy_pos, pfkey);
    t09put (term, ln, cut_bright_protected);
    t09put (term, term.blankline, cut_protected);
    ln := term.blankline;
    n := 'MOVE:             ';
    SAPDB_PascalForcedMove (sizeof (n), sizeof (ln), @n, 1, @ln, 1, 5);
    i := 7;
    n := 'source pos:     ; ';
    SAPDB_PascalForcedMove (sizeof (n), sizeof (ln), @n, 1, @ln, i, sizeof (n));
    g17int4to_line (source_pos, false, 4, i+12, ln);
    i := i + sizeof (n);
    n := 'destin pos:     ; ';
    SAPDB_PascalForcedMove (sizeof (n), sizeof (ln), @n, 1, @ln, i, sizeof (n));
    g17int4to_line (destin_pos, false, 4, i+12, ln);
    i := i + sizeof (n);
    n := 'move length:      ';
    SAPDB_PascalForcedMove (sizeof (n), sizeof (ln), @n, 1, @ln, i, sizeof (n));
    g17int4to_line (move_len, false, 4, i+13, ln);
    t09put (term, ln, cut_protected);
    n := 'y                 ';
    t09get1name (term, 'EXECUTE MOVE ? (y/n)', cut_bright_protected,
          cut_unprotected, mx_yes_no, true, n, pfkey);
    t09frame (term, true)
    END;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    IF  u05isyes (n)
    THEN
        SAPDB_PascalForcedMove (sizeof (source_buf), sizeof (destin_buf),
              @source_buf, source_pos,
              @destin_buf, destin_pos, move_len)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut07not_saved_warning (VAR term : tut_terminal;
            VAR page_name : tsp00_Name;
            VAR is_quit   : boolean;
            VAR pfkey     : tut_pfkey);
 
VAR
      ln_len : integer;
      answer : tsp00_Name;
      ln     : tsp00_Line;
 
BEGIN
pfkey  := pf_none;
answer := 'n                 ';
ln     := term.blankline;
ln_len := 0;
g17nameto_line   (page_name, ln_len, ln);
g17sname_to_line (' not saved !', ln_len, ln);
t09put (term, term.blankline, cut_protected);
t09put (term, ln, cut_bright_protected);
t09put (term, term.blankline, cut_protected);
t09get1name (term, '              QUIT ?', cut_bright_protected,
      cut_unprotected, 2, c_upper_case, answer, pfkey);
is_quit := (pfkey = pf_none) AND u05isyes (answer)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut07one_page_repair (VAR term : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            snd_packet      : tsp1_packet_ptr;
            VAR sql_ref     : tsp00_Int4;
            repair_type     : tut_diag_scan;
            VAR curr_dev    : tsp00_VFilename;
            VAR pfkey       : tut_pfkey;
            VAR sql_retcode : tsp00_Int2);
 
VAR
      is_saved  : boolean;
      buf_len   : tsp00_Int4;
      last_read : t_read_param;
      file_pos  : tut_file_pos;
      buf       : tsp00_Page;
 
BEGIN
sql_retcode           := 0;
pfkey                 := pf_none;
is_saved              := false;
last_read.rd_dev_type := utdt_nil;
ut07page_from_to_db (term, protfile, snd_packet, sql_ref, buf,
      buf_len, c_read_page, curr_dev, last_read, pfkey, sql_retcode);
IF  (sql_retcode = 0) AND (pfkey = pf_none)
THEN
    BEGIN
    WITH file_pos DO
        BEGIN
        utfp_block_no        := last_read.rd_pno;
        utfp_page_no         := 1;
        utfp_pages_per_block := 1
        END;
    (*ENDWITH*) 
    t09msgheader (term, msg30_edit_page, true);
    t14editbuf (term, protfile, buf, buf_len, 0, file_pos,
          repair_type, is_saved, pfkey);
    IF  pfkey <> pf_cancel
    THEN
        pfkey := pf_none
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (sql_retcode = 0) AND (pfkey = pf_none) AND is_saved
THEN
    u07write_page (term, protfile, snd_packet, sql_ref,
          last_read.rd_dev_type, last_read.rd_devno,
          last_read.rd_devname,  last_read.rd_pno,
          buf, buf_len, sql_retcode);
(*ENDIF*) 
IF  pfkey = pf_end
THEN
    pfkey := pf_none
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut07page_from_to_db (VAR term : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            snd_packet      : tsp1_packet_ptr;
            VAR sql_ref     : tsp00_Int4;
            VAR buf         : tsp00_Page;
            VAR buf_len     : tsp00_Int4;
            read_page       : boolean;
            VAR curr_dev    : tsp00_VFilename;
            VAR last_read   : t_read_param;
            VAR pfkey       : tut_pfkey;
            VAR sql_retcode : tsp00_Int2);
 
CONST
      x_data_perm    =  1;
      x_data_static  =  2;
      x_restart_rec  =  4;
      x_log_info     =  6;
      x_log          =  8;
      x_mirr_log     =  9;
      x_volume_name  = 11;
      x_return       = 14;
      (* *)
      z_pno          =  1;
      z_devno        =  2;
      z_devname      =  2;
 
VAR
      is_ok           : boolean;
      wanted_dev_type : tut_dev_type;
      i               : integer;
      selected        : integer;
      count_names     : integer;
      count           : integer;
      mask_size       : integer;
      i4              : tsp00_Int4;
      ln              : tsp00_Line;
      msg             : tut_c20_array;
      mask            : tut_term_mask;
 
BEGIN
pfkey := pf_none;
CASE last_read.rd_dev_type OF
    utdt_data_perm:
        selected := x_data_perm;
    utdt_data_static:
        selected := x_data_static;
    utdt_volume_name:
        selected := x_volume_name;
    utdt_loginfo:
        selected := x_log_info;
    utdt_log:
        selected := x_log;
    utdt_mirr_log:
        selected := x_mirr_log;
    utdt_restart_rec:
        selected := x_restart_rec;
    OTHERWISE
        selected := 0
    END;
(*ENDCASE*) 
FOR i := 1 TO 20 DO
    msg [i] := bsp_c20;
(*ENDFOR*) 
msg [x_data_perm   ] := msg_data_perm;
msg [x_data_static ] := msg_data_static;
msg [x_restart_rec ] := msg_restart_rec;
msg [x_log_info    ] := msg_loginfo_page;
msg [x_log         ] := msg_log;
msg [x_mirr_log    ] := msg_mirr_log;
msg [x_volume_name ] := msg_volume_name;
msg [x_return      ] := msg_return;
count := 1;
ln    := term.blankline;
IF  selected > 0
THEN
    ln [1] := chr (ord(selected) + ord('0'));
(*ENDIF*) 
REPEAT
    is_ok := true;
    count := count + 1;
    t09getmenu (term, x_return, cut_protected, c_upper_case,
          msg, selected, pfkey, ln, is_ok);
    IF  NOT is_ok
    THEN
        t14display_msg (term, msg_illegal_input)
    (*ENDIF*) 
UNTIL
    (count > 3) OR is_ok OR term.is_inputfile;
(*ENDREPEAT*) 
IF  NOT is_ok
THEN
    pfkey := pf_end
ELSE
    t09putmsg (term, term.blankline, NOT c_warning,
          NOT c_immed_displ);
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    IF  selected = x_return
    THEN
        pfkey := pf_end
    (*ENDIF*) 
    END;
(*ENDIF*) 
count_names := z_devno;
mask_size   := z_devno;
IF  pfkey = pf_none
THEN
    BEGIN
    CASE selected OF
        x_data_perm:
            BEGIN
            wanted_dev_type := utdt_data_perm;
            IF  read_page
            THEN
                count_names := z_pno
            ELSE
                count_names := 0;
            (*ENDIF*) 
            mask_size := count_names
            END;
        x_data_static:
            BEGIN
            wanted_dev_type := utdt_data_static;
            IF  read_page
            THEN
                count_names := z_pno
            ELSE
                count_names := 0;
            (*ENDIF*) 
            mask_size := count_names
            END;
        x_restart_rec:
            BEGIN
            wanted_dev_type := utdt_restart_rec;
            count_names     := 0;
            mask_size       := 0
            END;
        x_log_info:
            BEGIN
            wanted_dev_type := utdt_loginfo;
            count_names     := 0;
            mask_size       := 0
            END;
        x_log:
            wanted_dev_type := utdt_log;
        x_mirr_log:
            wanted_dev_type := utdt_mirr_log;
        x_volume_name:
            BEGIN
            wanted_dev_type := utdt_volume_name;
            count_names     := z_pno;
            mask_size       := z_devname
            END;
        END;
    (*ENDCASE*) 
    IF  last_read.rd_dev_type <> wanted_dev_type
    THEN
        BEGIN
        last_read.rd_pno     := cut_nil_block_no;
        last_read.rd_devno   := c_default_devno;
        last_read.rd_devname := term.blankfilename
        END;
    (*ENDIF*) 
    last_read.rd_dev_type := wanted_dev_type;
    FOR i := 1 TO mask_size DO
        WITH mask [i] DO
            BEGIN
            msg_in_attr [1] := cut_protected;
            msg_in_attr [2] := cut_bright_unprotected;
            upper_case      := true;
            code_input      := false;
            in_len          := sizeof (tsp00_Name);
            in_fn           := term.blankfilename
            END
        (*ENDWITH*) 
    (*ENDFOR*) 
    END;
(*ENDIF*) 
count := 1;
is_ok := (mask_size = 0);
WHILE NOT is_ok AND (count <= 3) AND (pfkey = pf_none)
      AND (mask_size > 0) DO
    BEGIN
    t09newscreen_page (term);
    is_ok := true;
    count := count + 1;
    mask [z_pno].msg := msg_block_no;
    IF  last_read.rd_pno <> cut_nil_block_no
    THEN
        x05int_to_name (last_read.rd_pno, mask [z_pno].in_name);
    (*ENDIF*) 
    CASE wanted_dev_type OF
        utdt_data_perm:
            mask [z_pno].msg := msg_data_perm_pno;
        utdt_data_static:
            mask [z_pno].msg := msg_data_static_pno;
        utdt_log, utdt_mirr_log:
            BEGIN
            mask [z_devno].msg := msg_log_volume_id;
            x05int_to_name (last_read.rd_devno, mask [z_devno].in_name)
            END;
        utdt_volume_name:
            BEGIN
            IF  last_read.rd_devname = term.blankfilename
            THEN
                last_read.rd_devname := curr_dev;
            (*ENDIF*) 
            mask [z_devname].upper_case := u05isdevname_upper_case;
            mask [z_devname].msg        := msg_dev_name;
            mask [z_devname].in_fn      := last_read.rd_devname;
            mask [z_devname].in_len     := sizeof (last_read.rd_devname)
            END;
        OTHERWISE ;
        END;
    (*ENDCASE*) 
    t09mask (term, count_names, mask_size, mask,
          NOT c_return_pfkey, pfkey);
    IF  pfkey = pf_none
    THEN
        BEGIN
        x05int_from_name (term, c_warning, NOT c_int2,
              mask [z_pno].in_name, last_read.rd_pno, is_ok);
        IF  is_ok
            AND
            (wanted_dev_type = utdt_log     ) OR
            (wanted_dev_type = utdt_mirr_log)
        THEN
            BEGIN
            x05int_from_name (term, c_warning, NOT c_int2,
                  mask [z_devno].in_name, i4, is_ok);
            IF  is_ok
            THEN
                last_read.rd_devno := i4
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  is_ok AND (wanted_dev_type = utdt_volume_name)
        THEN
            BEGIN
            last_read.rd_devname := mask [z_devname].in_fn;
            curr_dev             := term.blankfilename
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  NOT is_ok
THEN
    pfkey := pf_end;
(*ENDIF*) 
IF  (pfkey = pf_none) AND read_page
THEN
    u07read_page (term, protfile, snd_packet, sql_ref,
          last_read.rd_dev_type, last_read.rd_devno,
          last_read.rd_devname,  last_read.rd_pno,
          buf, buf_len, sql_retcode)
ELSE
    IF  (pfkey = pf_none) AND NOT read_page
    THEN
        u07write_page (term, protfile, snd_packet, sql_ref,
              last_read.rd_dev_type, last_read.rd_devno,
              last_read.rd_devname,  last_read.rd_pno,
              buf, buf_len, sql_retcode);
    (*ENDIF*) 
(*ENDIF*) 
IF  (last_read.rd_dev_type = utdt_data_perm  ) OR
    (last_read.rd_dev_type = utdt_data_static) OR
    (last_read.rd_dev_type = utdt_loginfo    ) OR
    (last_read.rd_dev_type = utdt_restart_rec)
THEN
    last_read.rd_pno := cut_nil_block_no
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut07page_name_header (VAR term : tut_terminal;
            page_name : tsp00_Name);
 
VAR
 
      msg : RECORD
            CASE integer OF
                1:
                    (str30 : tsp00_C30);
                2:
                    (n     : tsp00_Name)
                END;
            (*ENDCASE*) 
 
 
BEGIN
msg.str30 := bsp_c30;
msg.n     := page_name;
t09msgheader (term, msg.str30, c_perm)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut07pages_repair (
            VAR term        : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            snd_packet      : tsp1_packet_ptr;
            VAR sql_ref     : tsp00_Int4;
            VAR curr_dev    : tsp00_VFilename;
            VAR pfkey       : tut_pfkey;
            VAR sql_retcode : tsp00_Int2);
 
CONST
      x_read      =  1;
      x_edit_page =  3;
      x_edit_rec  =  4;
      x_edit_fdir =  5;
      x_save      =  8;
      x_debug     = 10;
      x_move      = 12;
      x_show      = 14;
      x_release   = 16;
      x_return    = 18;
 
VAR
      is_exit      : boolean;
      is_quit      : boolean;
      is_saved     : boolean;
      aux_pfkey    : tut_pfkey;
      i            : integer;
      count        : integer;
      selected     : integer;
      curr_buf     : integer;
      prev_buf     : integer;
      dummy_err    : integer;
      dummy_size   : integer;
      minbuf_bytes : integer;
      minbuf_lines : integer;
      ln_len       : integer;
      file_pos     : tut_file_pos;
      msg_header   : tsp00_C30;
      ln           : tsp00_Line;
      msg          : tut_c20_array;
      names        : t_bufnames;
      aux_buf      : tsp00_Page;
      is_updated   : ARRAY [1..c_max_buffers] OF boolean;
      last_read    : ARRAY [1..c_max_buffers] OF t_read_param;
      buf_len      : ARRAY [1..c_max_buffers] OF tsp00_Int4;
      buf          : ARRAY [1..c_max_buffers] OF tsp00_Page;
 
BEGIN
pfkey := pf_none;
t14bufdimension (term, [utds_minbuf],
      minbuf_bytes, dummy_size, minbuf_lines);
FOR selected := 1 TO x_return DO
    msg [selected] := bsp_c20;
(*ENDFOR*) 
msg [x_read     ] := 'READ PAGE           ';
msg [x_edit_page] := 'EDIT PAGE           ';
msg [x_edit_rec ] := 'EDIT RECORD         ';
msg [x_edit_fdir] := 'EDIT BLOB FDIR ENTRY';
msg [x_save     ] := 'SAVE PAGE           ';
msg [x_debug    ] := 'DEBUG PAGE          ';
msg [x_move     ] := 'MOVE                ';
msg [x_show     ] := 'SHOW PAGES          ';
msg [x_release  ] := 'RELEASE PAGE NAME   ';
msg [x_return   ] := 'RETURN              ';
FOR i := 1 TO c_max_buffers DO
    BEGIN
    is_updated [i]             := false;
    last_read  [i].rd_dev_type := utdt_nil;
    last_read  [i].rd_filler   := false;
    last_read  [i].rd_devno    := c_default_devno;
    last_read  [i].rd_pno      := cut_nil_block_no;
    last_read  [i].rd_devname  := term.blankfilename;
    names      [i]             := bsp_name;
    buf_len    [i]             := sizeof (buf [i]);
    SAPDB_PascalForcedFill (sizeof (buf [i]), @buf [i], 1, sizeof (buf [i]), chr(255))
    END;
(*ENDFOR*) 
curr_buf := 1;
is_exit  := false;
REPEAT
    sql_retcode := 0;
    t09msgheader (term, bsp_c30, true);
    t09menu (term, x_return, cut_protected, msg, selected, pfkey);
    t09putmsg (term, term.blankline, NOT c_warning, NOT c_immed_displ);
    IF  pfkey = pf_none
    THEN
        CASE selected OF
            x_read:
                BEGIN
                prev_buf := curr_buf;
                ut07search_name (term, 'read:     PAGE NAME:',
                      bsp_name, true, names, curr_buf, pfkey);
                IF  pfkey = pf_none
                THEN
                    BEGIN
                    IF  is_updated [curr_buf]
                    THEN
                        BEGIN
                        ut07not_saved_warning (term, names [curr_buf],
                              is_quit, pfkey);
                        IF  NOT is_quit AND (pfkey = pf_none)
                        THEN
                            pfkey := pf_end
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  pfkey = pf_none
                THEN
                    BEGIN
                    is_updated [curr_buf] := false;
                    last_read  [curr_buf] := last_read [prev_buf];
                    ut07page_from_to_db (term, protfile, snd_packet,
                          sql_ref, buf [curr_buf], buf_len [curr_buf], c_read_page,
                          curr_dev, last_read [curr_buf], pfkey, sql_retcode)
                    END;
                (*ENDIF*) 
                IF  pfkey <> pf_cancel
                THEN
                    pfkey := pf_none
                (*ENDIF*) 
                END;
            x_edit_page, x_edit_rec, x_edit_fdir:
                BEGIN
                ut07search_name (term, 'edit:     PAGE NAME:',
                      names [curr_buf], true, names, curr_buf, pfkey);
                IF  pfkey = pf_none
                THEN
                    BEGIN
                    is_saved   := false;
                    msg_header := 'EDIT                          ';
                    SAPDB_PascalForcedMove (sizeof(names[curr_buf]), sizeof(msg_header),
                          @names [curr_buf], 1,
                          @msg_header, 6, sizeof (names [curr_buf]));
                    t09msgheader (term, msg_header, true);
                    SAPDB_PascalForcedMove (sizeof (buf [curr_buf]), sizeof (aux_buf),
                          @buf [curr_buf], 1, @aux_buf, 1,
                          buf_len [curr_buf]);
                    WITH file_pos DO
                        BEGIN
                        utfp_block_no        := last_read [curr_buf].rd_pno;
                        utfp_page_no         := 1;
                        utfp_pages_per_block := 1
                        END;
                    (*ENDWITH*) 
                    CASE selected OF
                        x_edit_page:
                            t14editbuf (term, protfile, aux_buf,
                                  buf_len [curr_buf], 0, file_pos,
                                  [utds_page_header], is_saved, pfkey);
                        x_edit_rec:
                            t14record_edit (term, protfile, aux_buf,
                                  buf_len [curr_buf], file_pos,
                                  [ ], is_saved, pfkey);
                        x_edit_fdir:
                            t14record_edit (term, protfile, aux_buf,
                                  buf_len [curr_buf], file_pos,
                                  [utds_fdir], is_saved, pfkey);
                        OTHERWISE:
                        END;
                    (*ENDCASE*) 
                    IF  is_saved AND (pfkey = pf_none)
                    THEN
                        BEGIN
                        is_updated [curr_buf] := true;
                        SAPDB_PascalForcedMove (sizeof(aux_buf), sizeof (buf [curr_buf]),
                              @aux_buf, 1, @buf [curr_buf], 1,
                              buf_len [curr_buf])
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  pfkey <> pf_cancel
                THEN
                    pfkey := pf_none
                (*ENDIF*) 
                END;
            x_debug:
                BEGIN
                ut07search_name (term, 'debug:    PAGE NAME:',
                      names [curr_buf], true, names,
                      curr_buf, pfkey);
                IF  pfkey = pf_none
                THEN
                    BEGIN
                    ln := term.blankline;
                    t12write_prot (protfile, ln, 1, dummy_err);
                    ln_len := 0;
                    g17nameto_line (names[curr_buf], ln_len, ln);
                    ln [ln_len+1] := ':';
                    t12write_prot (protfile, ln, ln_len+1, dummy_err);
                    msg_header := bsp_c30;
                    SAPDB_PascalForcedMove (sizeof(names[curr_buf]), sizeof(msg_header),
                          @names [curr_buf], 1,
                          @msg_header, 1, sizeof (names [curr_buf]));
                    t09msgheader (term, msg_header, true);
                    WITH file_pos DO
                        BEGIN
                        utfp_block_no        := last_read [curr_buf].rd_pno;
                        utfp_page_no         := 1;
                        utfp_pages_per_block := 1
                        END;
                    (*ENDWITH*) 
                    x07debug_page (term, protfile, NOT c_header_only,
                          file_pos, buf [curr_buf], buf_len [curr_buf], pfkey);
                    END;
                (*ENDIF*) 
                IF  pfkey <> pf_cancel
                THEN
                    pfkey := pf_none
                (*ENDIF*) 
                END;
            x_save:
                BEGIN
                ut07search_name (term, 'save:     PAGE NAME:',
                      names [curr_buf], false, names, curr_buf, pfkey);
                IF  pfkey = pf_none
                THEN
                    BEGIN
                    ut07page_from_to_db (term, protfile, snd_packet, sql_ref,
                          buf [curr_buf], buf_len [curr_buf], NOT c_read_page,
                          curr_dev, last_read [curr_buf], pfkey, sql_retcode);
                    is_updated [curr_buf] := (sql_retcode <> 0)
                    END;
                (*ENDIF*) 
                IF  pfkey <> pf_cancel
                THEN
                    pfkey := pf_none
                (*ENDIF*) 
                END;
            x_move:
                BEGIN
                ut07search_name (term, '   SOURCE PAGE NAME:',
                      bsp_name, false, names, i, pfkey);
                IF  pfkey = pf_none
                THEN
                    ut07search_name (term, '   DESTIN PAGE NAME:',
                          names [curr_buf], true, names,
                          curr_buf, pfkey);
                (*ENDIF*) 
                IF  pfkey = pf_none
                THEN
                    IF  i = curr_buf
                    THEN
                        t14display_msg (term, msg_dupl_name)
                    ELSE
                        BEGIN
                        is_updated [curr_buf] := true;
                        buf_len    [curr_buf] := buf_len [i];
                        ut07move (term, protfile, buf_len [i], names [i], buf [i],
                              names [curr_buf], buf [curr_buf], pfkey)
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  pfkey <> pf_cancel
                THEN
                    pfkey := pf_none
                (*ENDIF*) 
                END;
            x_show:
                BEGIN
                t09msgheader (term, msg30_show, true);
                t09newscreen_page (term);
                count := 0;
                i     := 1;
                WHILE (i <= c_max_buffers) AND (pfkey = pf_none) DO
                    BEGIN
                    IF  names [i] <> bsp_name
                    THEN
                        BEGIN
                        count := count + 1;
                        IF  count > 1
                        THEN
                            BEGIN
                            IF  t09is_window_full (term, 4+minbuf_lines)
                            THEN
                                BEGIN
                                t09holding (term, pfkey);
                                IF  pfkey = pf_none
                                THEN
                                    t09newscreen_page (term)
                                (*ENDIF*) 
                                END
                            ELSE
                                BEGIN
                                t09put (term, term.blankline, cut_protected);
                                t09put (term, term.blankline, cut_protected)
                                END
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  (names [i] <> bsp_name) AND (pfkey = pf_none)
                    THEN
                        ut07show_page (term, protfile, names [i],
                              last_read [i], buf [i], buf_len [i],
                              minbuf_bytes, pfkey);
                    (*ENDIF*) 
                    i := i + 1
                    END;
                (*ENDWHILE*) 
                IF  pfkey = pf_none
                THEN
                    BEGIN
                    IF  count > 0
                    THEN
                        t09holding (term, pfkey)
                    ELSE
                        t14display_msg (term, msg_not_defined)
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  pfkey <> pf_cancel
                THEN
                    pfkey := pf_none
                (*ENDIF*) 
                END;
            x_release:
                BEGIN
                ut07search_name (term, 'release:  PAGE NAME:',
                      names [curr_buf], false, names, curr_buf, pfkey);
                IF  pfkey = pf_none
                THEN
                    BEGIN
                    IF  is_updated [curr_buf]
                    THEN
                        BEGIN
                        ut07not_saved_warning (term, names [curr_buf],
                              is_quit, pfkey);
                        IF  NOT is_quit AND (pfkey = pf_none)
                        THEN
                            pfkey := pf_end
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  pfkey = pf_none
                THEN
                    BEGIN
                    is_updated [curr_buf] := false;
                    names      [curr_buf] := bsp_name;
                    SAPDB_PascalForcedFill (sizeof (buf [curr_buf]), @buf [curr_buf], 1,
                          sizeof (buf [curr_buf]), chr(255));
                    last_read [curr_buf].rd_dev_type := utdt_nil;
                    last_read [curr_buf].rd_devno    := c_default_devno;
                    last_read [curr_buf].rd_devname  := term.blankfilename;
                    last_read [curr_buf].rd_pno      := cut_nil_block_no
                    END;
                (*ENDIF*) 
                IF  pfkey <> pf_cancel
                THEN
                    pfkey := pf_none
                (*ENDIF*) 
                END;
            x_return:
                BEGIN
                is_exit := true;
                pfkey   := pf_end
                END;
            OTHERWISE
                pfkey := pf_end
            END;
        (*ENDCASE*) 
    (*ENDIF*) 
    IF  pfkey = pf_help
    THEN
        pfkey := pf_none;
    (*ENDIF*) 
    IF  pfkey <> pf_none
    THEN
        BEGIN
        aux_pfkey := pf_none;
        is_quit   := true;
        i         := 1;
        REPEAT
            IF  is_updated [i]
            THEN
                ut07not_saved_warning (term, names [i],
                      is_quit, aux_pfkey);
            (*ENDIF*) 
            i := i + 1
        UNTIL
            (i > c_max_buffers) OR (aux_pfkey <> pf_none) OR
            NOT is_quit;
        (*ENDREPEAT*) 
        IF  NOT is_quit
        THEN
            BEGIN
            is_exit := false;
            pfkey   := pf_none
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (pfkey <> pf_none) AND NOT is_exit
    THEN
        BEGIN
        pfkey := pf_none;
        ut07display_leave_msg (term);
        t09holding (term, pfkey)
        END
    (*ENDIF*) 
UNTIL
    pfkey <> pf_none;
(*ENDREPEAT*) 
IF  pfkey = pf_end
THEN
    pfkey := pf_none
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut07search_name  (VAR term : tut_terminal;
            msg         : tsp00_C20;
            init_name   : tsp00_Name;
            assign_name : boolean;
            VAR names   : t_bufnames;
            VAR curr    : integer;
            VAR pfkey   : tut_pfkey);
 
VAR
      found : boolean;
      i     : integer;
      n     : tsp00_Name;
 
BEGIN
pfkey := pf_none;
n := init_name;
t09get1name (term, msg, cut_bright_protected, cut_unprotected,
      sizeof (n), true, n, pfkey);
found := false;
i := 1;
WHILE NOT found AND (i <= c_max_buffers) DO
    IF  names [i] = n
    THEN
        found := true
    ELSE
        i := i + 1;
    (*ENDIF*) 
(*ENDWHILE*) 
IF  found
THEN
    BEGIN
    curr := i;
    IF  assign_name
    THEN
        names [curr] := n
    (*ENDIF*) 
    END
ELSE
    BEGIN
    IF  NOT assign_name
    THEN
        BEGIN
        pfkey := pf_end;
        t14display_msg (term, msg_unknown_name)
        END
    ELSE
        BEGIN
        found := false;
        i := 1;
        WHILE NOT found AND (i <= c_max_buffers) DO
            IF  names [i] = bsp_name
            THEN
                found := true
            ELSE
                i := i + 1;
            (*ENDIF*) 
        (*ENDWHILE*) 
        IF  found
        THEN
            BEGIN
            curr := i;
            names [curr] := n
            END
        ELSE
            BEGIN
            pfkey := pf_end;
            t14display_msg (term, msg_too_many_pages)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    ut07page_name_header (term, names [curr])
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut07show_page (VAR term : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            VAR page_name   : tsp00_Name;
            VAR last_read   : t_read_param;
            VAR buf         : tsp00_Page;
            buf_len         : tsp00_Int4;
            minbuf_bytes    : tsp00_Int4;
            VAR pfkey       : tut_pfkey);
 
CONST
      c_max_volume_name_len = 64;
 
VAR
      ln_len    : integer;
      dummy_pos : tsp00_Int4;
      file_pos  : tut_file_pos;
      ln        : tsp00_Line;
 
BEGIN
pfkey  := pf_none;
ln     := term.blankline;
ln_len := 0;
g17nameto_line (page_name, ln_len, ln);
WITH last_read DO
    CASE rd_dev_type OF
        utdt_data_perm:
            g17sname_to_line (' (perm data)', ln_len, ln);
        utdt_data_static:
            g17sname_to_line (' (stat data)', ln_len, ln);
        utdt_restart_rec:
            g17nameto_line   (' (restart rec)    ', ln_len, ln);
        utdt_nil:
            g17sname_to_line (' (undefined)', ln_len, ln);
        OTHERWISE
            BEGIN
            g17sname_to_line (' (blockno:  ', ln_len, ln);
            ln_len := ln_len + 1;
            g17trimint4_to_line (rd_pno, ln_len, ln);
            CASE rd_dev_type OF
                utdt_volume_name:
                    BEGIN
                    g17sname_to_line (', volume:   ', ln_len, ln);
                    SAPDB_PascalForcedMove (sizeof (rd_devname), sizeof (ln),
                          @rd_devname, 1,
                          @ln, ln_len + 2, c_max_volume_name_len);
                    ln_len := ln_len + 1 + c_max_volume_name_len;
                    WHILE ln [ln_len] = ' ' DO
                        ln_len := ln_len - 1;
                    (*ENDWHILE*) 
                    ln [ln_len+1] := ')'
                    END;
                utdt_log:
                    g17nameto_line (', log             ', ln_len, ln);
                utdt_mirr_log:
                    g17nameto_line (', mirrored log    ', ln_len, ln);
                END;
            (*ENDCASE*) 
            IF  (rd_dev_type = utdt_log     ) OR
                (rd_dev_type = utdt_mirr_log)
            THEN
                BEGIN
                ln_len := ln_len + 1;
                g17trimint4_to_line (rd_pno, ln_len, ln);
                ln [ln_len+1] := ')'
                END
            (*ENDIF*) 
            END
        END;
    (*ENDCASE*) 
(*ENDWITH*) 
t09put (term, ln, cut_bright_protected);
t09put (term, term.blankline, cut_protected);
WITH file_pos DO
    BEGIN
    utfp_block_no        := last_read.rd_pno;
    utfp_page_no         := 1;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
x07debug_page (term, protfile, c_header_only,
      file_pos, buf, buf_len, pfkey);
pfkey := pf_none;
t09put (term, term.blankline, cut_protected);
t14bufdisplay (term, protfile, [utds_minbuf, utds_display],
      bsp_c30, buf, buf_len, 1, minbuf_bytes, 1, dummy_pos, pfkey)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut07edit_converter (
            VAR term        : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            snd_packet      : tsp1_packet_ptr;
            VAR sql_ref     : tsp00_Int4;
            VAR pfkey       : tut_pfkey;
            VAR sql_retcode : tsp00_Int2);
 
CONST
      x_set_perm_block    =  1;
      x_del_perm_block    =  2;
      x_set_static_block  =  6;
      x_del_static_block  =  7;
      x_return            = 10;
 
VAR
      is_ok       : boolean;
      i           : integer;
      selected    : integer;
      answer_len  : integer;
      dummy_err   : integer;
      rcv_packet  : tsp1_packet_ptr;
      msg         : tut_c20_array;
      ln          : tsp00_Line;
      answer      : tsp00_Name;
 
BEGIN
is_ok       := false;
sql_retcode := 0;
FOR selected := 1 TO x_return DO
    msg [selected] := bsp_c20;
(*ENDFOR*) 
msg [x_set_perm_block  ] := msg_set_data_perm;
msg [x_del_perm_block  ] := msg_del_data_perm;
msg [x_set_static_block] := msg_set_data_static;
msg [x_del_static_block] := msg_del_data_static;
msg [x_return          ] := msg_return;
(* *)
REPEAT
    t09msgheader (term, msg30_edit_conv, true);
    t09menu (term, x_return, cut_protected, msg, selected, pfkey);
    IF  (selected = x_return) AND (pfkey = pf_none)
    THEN
        pfkey := pf_end;
    (*ENDIF*) 
    IF  pfkey = pf_none
    THEN
        BEGIN
        CASE selected OF
            x_set_perm_block:
                ut07set_block_address( term, msg_data_perm_pno,
                      utn_perm, snd_packet, pfkey, is_ok);
            x_set_static_block:
                ut07set_block_address( term, msg_data_static_pno,
                      utn_static, snd_packet, pfkey, is_ok);
            x_del_perm_block:
                ut07del_block_address( term, msg_del_data_perm,
                      utn_perm, snd_packet, pfkey, is_ok);
            x_del_static_block:
                ut07del_block_address( term, msg_del_data_static,
                      utn_static, snd_packet, pfkey, is_ok);
            OTHERWISE:
            END;
        (*ENDCASE*) 
        pfkey := pf_none;
        END;
    (*ENDIF*) 
UNTIL
    (pfkey <> pf_none) OR is_ok;
(*ENDREPEAT*) 
IF  is_ok
THEN
    BEGIN
    (* *)
    pfkey := pf_none;
    ln    := term.blankline;
    WITH snd_packet^.sp1_segm DO
        BEGIN
        i := sp1p_buf_len;
        IF  i > LINE_MXSP00
        THEN
            i := LINE_MXSP00;
        (*ENDIF*) 
        SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (ln),
              @sp1p_buf, 1, @ln, 1, i)
        END;
    (*ENDWITH*) 
    answer := c_yes_answer;
    IF  NOT term.is_inputfile
    THEN
        BEGIN
        t09newscreen_page (term);
        t09msgheader (term, bsp_c30, true);
        answer_len := mx_yes_no;
        IF  term.use_pfkeys
        THEN
            BEGIN
            t09put (term, ln, cut_bright_unprotected);
            (* avoid moving to previous line field *)
            answer_len := answer_len + 1
            END
        ELSE
            t09put (term, ln, cut_bright_protected);
        (*ENDIF*) 
        t09put (term, term.blankline, cut_protected);
        t09get1name (term, msg_execution, cut_bright_protected,
              cut_unprotected, answer_len, true, answer, pfkey)
        END;
    (*ENDIF*) 
    IF  (NOT u05isyes (answer)) OR (pfkey in [ pf_end, pf_help, pf_cancel])
    THEN
        BEGIN
        u05str20_to_line (msg_cmd_cancelled, ln);
        t09putmsg (term, ln, NOT c_warning, NOT c_immed_displ)
        END
    ELSE
        BEGIN
        u02send (term, protfile, snd_packet, sql_ref, c_display_msg,
              NOT c_req_only, rcv_packet, sql_retcode);
        IF  sql_retcode = 0
        THEN
            BEGIN
            u05str20_to_line (msg_conv_updated, ln);
            t09putmsg (term, ln, NOT c_warning, c_immed_displ);
            t12write_prot (protfile, ln, 20, dummy_err)
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut07set_block_address(
            VAR term   : tut_terminal;
            msgPageNo  : tsp00_C20;
            recMode    : tsp00_Name;
            snd_packet : tsp1_packet_ptr;
            VAR pfkey  : tut_pfkey;
            VAR is_ok  : boolean);
 
VAR
      pageNo   : tsp00_Name;
      volumeId : tsp00_Name;
      blockNo  : tsp00_Name;
 
BEGIN
pfkey    := pf_none;
pageNo   := first_loc;
volumeId := bsp_c18;
blockNo  := bsp_c18;
t09newscreen_page (term);
ut07page_name_header (term, utn_set_block);
t09get1name (term, msgPageNo, cut_bright_protected,
      cut_unprotected, int4_length, c_upper_case, pageNo, pfkey);
t09put (term, term.blankline, cut_protected);
t09get2name (term, msg_volume_id, msg_block_no,
      cut_bright_protected, cut_bright_protected,
      cut_unprotected, cut_unprotected, int4_length, int4_length,
      c_upper_case, c_upper_case, volumeId, blockNo, pfkey);
IF  pfkey = pf_none
THEN
    BEGIN
    is_ok := true;
    u05packet_init   (snd_packet);
    u05nameto_packet (utn_diagnose,   snd_packet);
    u05nameto_packet (utn_set,        snd_packet);
    u05nameto_packet (utn_block_addr, snd_packet);
    u05nameto_packet (utn_for,        snd_packet);
    u05nameto_packet (recMode,        snd_packet);
    u05nameto_packet (utn_page,       snd_packet);
    u05nameto_packet (pageNo,         snd_packet);
    u05nameto_packet (utn_to,         snd_packet);
    u05nameto_packet (utn_volume,     snd_packet);
    u05nameto_packet (volumeId,       snd_packet);
    u05nameto_packet (utn_block,      snd_packet);
    u05nameto_packet (blockNo,        snd_packet);
    (* *)
    s26finish_part (snd_packet, snd_packet^.sp1_segm.sp1p_part);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut07del_block_address(
            VAR term   : tut_terminal;
            msgPageNo  : tsp00_C20;
            recMode    : tsp00_Name;
            snd_packet : tsp1_packet_ptr;
            VAR pfkey  : tut_pfkey;
            VAR is_ok  : boolean);
 
VAR
      pageNo : tsp00_Name;
 
BEGIN
pfkey  := pf_none;
pageNo := first_loc;
t09newscreen_page (term);
ut07page_name_header (term, utn_del_block);
t09get1name (term, msgPageNo, cut_bright_protected,
      cut_unprotected, int4_length, c_upper_case, pageNo, pfkey);
t09put (term, term.blankline, cut_protected);
IF  pfkey = pf_none
THEN
    BEGIN
    is_ok := true;
    u05packet_init   (snd_packet);
    u05nameto_packet (utn_diagnose,   snd_packet);
    u05nameto_packet (utn_delete,     snd_packet);
    u05nameto_packet (utn_block_addr, snd_packet);
    u05nameto_packet (utn_for,        snd_packet);
    u05nameto_packet (recMode,        snd_packet);
    u05nameto_packet (utn_page,       snd_packet);
    u05nameto_packet (pageNo,         snd_packet);
    (* *)
    s26finish_part (snd_packet, snd_packet^.sp1_segm.sp1p_part);
    END;
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
