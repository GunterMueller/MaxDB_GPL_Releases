/* @lastChanged: "1999-10-28  16:09"
 
 * @filename:   vut02
 * @purpose:    "UT_utility_driver"
 * @release:    7.2.0.0
 * @see:        "-.-"
 *
 * @Copyright (c) 1999-2005 SAP AG"
 */
 
.tt 1 $SAP$LiveCache$VUT02$
.tt 3 $$UT_utility_driver$2000-11-22$
 
.nf
 
 .nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
***********************************************************
 
Module  : UT_utility_driver
 
Define  :
 
        PROCEDURE
              u02receive (VAR term  : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    VAR sql_ref     : tsp00_Int4;
                    msg_wanted      : integer;
                    VAR rcv_packet  : tsp1_packet_ptr;
                    VAR sql_retcode : tsp00_Int2);
 
        PROCEDURE
              u02send (VAR term     : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    snd_packet      : tsp1_packet_ptr;
                    VAR sql_ref     : tsp00_Int4;
                    msg_wanted      : integer;
                    req_only        : boolean;
                    VAR rcv_packet  : tsp1_packet_ptr;
                    VAR sql_retcode : tsp00_Int2);
 
        PROCEDURE
              u02utility (VAR term  : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    aid             : tsp00_TaskId;
                    VAR termid      : tsp00_TermId;
                    VAR xusertype   : tsp4_xuser;
                    VAR username    : tsp00_KnlIdentifier;
                    VAR password    : tsp00_CryptPw;
                    VAR serverdb    : tsp00_DbName;
                    VAR servernode  : tsp00_NodeId;
                    adbs_session    : boolean;
                    write_time      : boolean;
                    use_cmd_line    : boolean;
                    VAR cmd_line    : tsp00_Line;
                    VAR pfkey       : tut_pfkey);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              UT_errormsg : VUT03;
 
        PROCEDURE
              u03version  (VAR term : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    write_prot      : boolean);
 
      ------------------------------ 
 
        FROM
              UT_auxiliary_procedures : VUT05;
 
        PROCEDURE
              u05c20to_packet (n : tsp00_C20;
                    snd_packet   : tsp1_packet_ptr);
 
        PROCEDURE
              u05cmdwrite_prot (VAR protfile : tut_vf_fileref;
                    VAR blankline : tsp00_Line;
                    write_time    : boolean;
                    snd_packet    : tsp1_packet_ptr);
 
        PROCEDURE
              u05connect_mask (VAR term : tut_terminal;
                    is_batch       : boolean;
                    VAR username   : tsp00_KnlIdentifier;
                    VAR password   : tsp00_Name;
                    VAR serverdb   : tsp00_DbName;
                    VAR servernode : tsp00_NodeId;
                    VAR pfkey      : tut_pfkey);
 
        PROCEDURE
              u05diagextract (VAR term : tut_terminal;
                    snd_packet         : tsp1_packet_ptr;
                    VAR pfkey          : tut_pfkey);
 
        PROCEDURE
              u05diagnose (VAR term    : tut_terminal;
                    snd_packet         : tsp1_packet_ptr;
                    VAR is_blockoutput : boolean;
                    VAR menu_finished  : boolean;
                    VAR pfkey          : tut_pfkey);
 
        PROCEDURE
              u05encrypt (pw_clear : tsp00_Name;
                    VAR pw_crypt   : tsp00_CryptPw);
 
        PROCEDURE
              u05errmsg (VAR term : tut_terminal;
                    VAR protfile  : tut_vf_fileref;
                    errcode       : tsp00_Int2);
 
        PROCEDURE
              u05fetch_show (VAR term : tut_terminal;
                    VAR protfile      : tut_vf_fileref;
                    snd_packet        : tsp1_packet_ptr;
                    VAR sql_ref       : tsp00_Int4;
                    header_msg        : tsp00_C30;
                    VAR pfkey         : tut_pfkey;
                    VAR rcv_packet    : tsp1_packet_ptr;
                    VAR sql_retcode   : tsp00_Int2);
 
        PROCEDURE
              u05get_block_addr (
                    VAR term            : tut_terminal;
                    VAR protfile        : tut_vf_fileref;
                    rcv_packet          : tsp1_packet_ptr;
                    VAR pfkey           : tut_pfkey);
 
        PROCEDURE
              u05getcommand (VAR term  : tut_terminal;
                    VAR protfile       : tut_vf_fileref;
                    snd_packet         : tsp1_packet_ptr;
                    write_time         : boolean;
                    VAR ln             : tsp00_Line;
                    VAR is_continue_ln : boolean;
                    VAR pfkey          : tut_pfkey);
 
        PROCEDURE
              u05gettoken (snd_packet : tsp1_packet_ptr;
                    VAR tok1 : tsp00_Name;
                    VAR tok2 : tsp00_Name;
                    VAR tok3 : tsp00_Name;
                    VAR tok4 : tsp00_Name;
                    VAR tok5 : tsp00_Name;
                    VAR tok6 : tsp00_Name);
 
        PROCEDURE
              u05get2token (VAR ln : tsp00_Line;
                    VAR tok1 : tsp00_Name;
                    VAR tok2 : tsp00_Name);
 
        PROCEDURE
              u05header (VAR term : tut_terminal;
                    progname      : tsp00_C8;
                    serverdb      : tsp00_DbName;
                    VAR username  : tsp00_KnlIdentifier);
 
        FUNCTION
              u05isyes (VAR n : tsp00_Name): boolean;
 
        PROCEDURE
              u05nameto_packet (n : tsp00_Name;
                    snd_packet    : tsp1_packet_ptr);
 
        PROCEDURE
              u05packet_init (snd_packet : tsp1_packet_ptr);
 
        PROCEDURE
              u05param_errmsg (VAR term : tut_terminal;
                    VAR protfile        : tut_vf_fileref;
                    rcv_packet          : tsp1_packet_ptr);
 
        PROCEDURE
              u05request_errmsg (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    VAR errtext  : tsp00_ErrText;
                    comm_error   : tsp1_comm_error);
 
        PROCEDURE
              u05str20_to_line (comment : tsp00_C20;
                    VAR commentline     : tsp00_Line);
 
        PROCEDURE
              u05switch (VAR term   : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    snd_packet      : tsp1_packet_ptr;
                    VAR sql_ref     : tsp00_Int4;
                    switch_cmd      : tsp00_C20;
                    VAR pfkey       : tut_pfkey;
                    VAR sql_retcode : tsp00_Int2);
 
        PROCEDURE
              u05username_to_packet (VAR n : tsp00_KnlIdentifier;
                    snd_packet : tsp1_packet_ptr);
 
        PROCEDURE
              u05usewrite_prot (VAR protfile : tut_vf_fileref;
                    VAR blankln    : tsp00_Line;
                    VAR serverdb   : tsp00_DbName;
                    VAR servernode : tsp00_NodeId);
 
        PROCEDURE
              u05write_prot (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    n            : tsp00_Name;
                    int          : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              UT_repair : VUT07;
 
        PROCEDURE
              u07repair (VAR term   : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    snd_packet      : tsp1_packet_ptr;
                    VAR sql_ref     : tsp00_Int4;
                    VAR userid      : tsp00_KnlIdentifier;
                    VAR password    : tsp00_CryptPw;
                    VAR serverdb    : tsp00_DbName;
                    VAR pfkey       : tut_pfkey;
                    VAR sql_retcode : tsp00_Int2;
                    bDoConnectCheck : boolean);
 
      ------------------------------ 
 
        FROM
              UT_diagnose_catalog : VUT10;
 
        PROCEDURE
              u10diagnose_catalog (VAR term  : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    snd_packet   : tsp1_packet_ptr;
                    rcv_packet   : tsp1_packet_ptr;
                    VAR sql_ref  : tsp00_Int4;
                    VAR username : tsp00_KnlIdentifier;
                    VAR password : tsp00_CryptPw;
                    VAR pfkey    : tut_pfkey);
 
      ------------------------------ 
 
        FROM
              TA_terminal_IO : VTA09;
 
        PROCEDURE
              t09frame (VAR term : tut_terminal; on : boolean);
 
        PROCEDURE
              t09get (VAR term : tut_terminal;
                    VAR text   : tsp00_Line;
                    VAR pfkey  : tut_pfkey);
 
        PROCEDURE
              t09getmenu (VAR term : tut_terminal;
                    size           : integer;
                    msg_attr       : char;
                    upper_case     : boolean;
                    VAR msg        : tut_c20_array;
                    VAR selected   : integer;
                    VAR pfkey      : tut_pfkey;
                    VAR ln         : tsp00_Line;
                    VAR ok         : boolean);
 
        PROCEDURE
              t09get1name (VAR term : tut_terminal;
                    msg             : tsp00_C20;
                    msg_attr        : char;
                    in_attr         : char;
                    in_len          : integer;
                    upper_case      : boolean;
                    VAR in_name     : tsp00_Name;
                    VAR pfkey       : tut_pfkey);
 
        PROCEDURE
              t09header (VAR term : tut_terminal;
                    left_msg      : tsp00_C20;
                    right_msg     : tsp00_C20);
 
        PROCEDURE
              t09holding (VAR term : tut_terminal;
                    VAR pfkey      : tut_pfkey);
 
        PROCEDURE
              t09msgheader (VAR term : tut_terminal;
                    msg     : tsp00_C30;
                    is_perm : boolean);
 
        PROCEDURE
              t09newscreen_page (VAR term : tut_terminal);
 
        PROCEDURE
              t09pfkeys (VAR term : tut_terminal; on : boolean);
 
        PROCEDURE
              t09put (VAR term : tut_terminal;
                    VAR text   : tsp00_Line;
                    text_attr  : char);
 
        PROCEDURE
              t09putmsg (VAR term     : tut_terminal;
                    VAR msg           : tsp00_Line;
                    is_warning        : boolean;
                    immediate_display : boolean);
 
        FUNCTION
              t09retcode (VAR term : tut_terminal) : integer;
 
        PROCEDURE
              t09returncode_set (VAR term : tut_terminal;
                    retcode : integer);
 
        PROCEDURE
              t09setpf1 (VAR term : tut_terminal; pfkey_label : tsp00_C8);
 
      ------------------------------ 
 
        FROM
              TA_write_protfile : VTA12;
 
        PROCEDURE
              t12write_prot (VAR fileref : tut_vf_fileref;
                    VAR ln    : tsp00_Line;
                    length    : integer;
                    VAR error : integer);
 
      ------------------------------ 
 
        FROM
              RTE_driver : VEN102;
 
        PROCEDURE
              sqlaconnect (uid      : tsp00_TaskId;
                    VAR servernode  : tsp00_NodeId;
                    VAR serverdb    : tsp00_DbName;
                    service         : tsp00_Service;
                    packet_cnt      : tsp00_Int4;
                    VAR reference   : tsp00_Int4;
                    VAR packet_size : tsp00_Int4;
                    VAR packet_list : tsp1_packet_list;
                    VAR errtext     : tsp00_ErrText;
                    VAR returncode  : tsp1_comm_error);
 
        PROCEDURE
              sqlareceive (reference   : tsp00_Int4;
                    VAR res_packet     : tsp1_packet_ptr;
                    VAR res_packet_len : tsp00_Int4;
                    VAR errtext        : tsp00_ErrText;
                    VAR returncode     : tsp1_comm_error);
 
        PROCEDURE
              sqlarelease (reference : tsp00_Int4);
 
        PROCEDURE
              sqlarequest (reference : tsp00_Int4;
                    sql_packet       : tsp1_packet_ptr;
                    length           : tsp00_Int4;
                    VAR errtext      : tsp00_ErrText;
                    VAR returncode   : tsp1_comm_error);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26finish_part (packet_ptr : tsp1_packet_ptr;
                    VAR finish_part      : tsp1_part);
 
        PROCEDURE
              s26new_part_init (packet_ptr : tsp1_packet_ptr;
                    VAR segm               : tsp1_segment;
                    VAR new_part_ptr       : tsp1_part_ptr);
 
        FUNCTION
              s26packet_len (packet_ptr : tsp1_packet_ptr) : tsp00_Int4;
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              TA_test_procedures : VTA02;
 
        FUNCTION
              t02buflength_max : tsp00_Int4;
 
        PROCEDURE
              t02int4 (layer : tut_debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        FUNCTION
              t02is_minbuf : boolean;
 
        PROCEDURE
              t02name1 (layer : tut_debug;
                    nam       : tsp00_Sname;
                    n         : tsp00_Name);
 
        FUNCTION
              t02trace (debug : tut_debug) : boolean;
&       endif
 
      ------------------------------ 
 
        FROM
              XT_typebuf : VXT03;
 
        PROCEDURE
              x03typedata (VAR term : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    VAR progname    : tsp00_C20;
                    sql_packet      : tsp1_packet_ptr;
                    VAR sql_ref     : tsp00_Int4;
                    VAR pfkey       : tut_pfkey);
 
      ------------------------------ 
 
        FROM
              XT_auxiliary_procedures : VXT05;
 
        PROCEDURE
              x05packet (VAR term : tut_terminal;
                    VAR protfile  : tut_vf_fileref;
                    is_minbuf     : boolean;
                    maxbuflength  : tsp00_Int4;
                    nam           : tsp00_Sname;
                    packet_ptr    : tsp1_packet_ptr);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              x03typedata;
 
              tsp00_Addr tsp1_packet_ptr;
 
        PROCEDURE
              t09put;
 
              tsp00_C80 tsp00_Line
 
        FUNCTION
              s26packet_len;
 
              tsp00_Int4 tsp00_Int4
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : JuergenA
.sp
.cp 3
Created : 1984-03-26
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-11-22
.sp
***********************************************************
.sp
.cp 11
.fo
.oc _/1
Specification:
.sp
Procedure U02RECEIVE
.sp
The procedure SQLARECEIVE is executed and an appropriate error
message is displayed in the event of an error.
.sp 2;.cp 4
Procedure U02SEND
.sp
This procedure is responsible for sending the utility commands to
the service task (SQLAREQUEST) and, if necessary, for receiving the
results (U02RECEIVE). In the event of a failure, an error message
is displayed.
.sp 2;.cp 4
Procedure U02UTILITY
.sp
Once connect has been sucessfully executed, utility functions can
be selected from a menu with the aid of COLD_FUNCTIONS or
WARM_FUNCTIONS until a connect (automatic after SHUTDOWN or
RESTART) fails or the EXIT function is selected. EXIT is also
executed when a main menu returns the PFKEY PF_END. As well as
the command in PART1 of a SQL_PACKET, functions that have an effect
on the configuration also occupy the second part of the SQL_PACKET
and are executed in appropriate procedures
by COLD_FUNCTIONS or the CONFIG_MENU.
If the command is normal, only PART1 of the SQL_PACKET is occupied,
and the request is executed by the procedure EXECUTE_CMD.
.br
At the end of U02UTILITY, U02RELEASE is called and the
MSG_SESSION_END message is displayed in the message line of the
terminal and written into the protocol file.
.sp 2;.cp 4
Procedure UT02ALTER_CONFIG
.sp
In the same way as GET CONFIG, the procedure begins by fetching
the old configuration parameters to initialize the input
mask. Mask input is repeated until all the numeric parameters
consist of digits, or until the PFKEY PF_END or PF_CANCEL is
pressed.
.sp;.cp 3
Once user confirmation has been received, the command is executed
by U02SEND with the PART1 "ALTER CONFIG 'sys devspace name'". If
the request fails, the mask input can be repeated with the
parameters last specified.
.sp 2;.cp 4
Procedure UT02ALTER_DEVICE
.sp
This procedure processes both types of "ALTER DEVICE CONFIG".
.br
For "ALTER DEVICE CONFIG RESTORE", a request is sent with the
PART1 "RESTORE CONFIG FROM 'hostfilename'" that returns the
host file name as the result in PART2. The first records
in this file (CONFIG) are read by U06IN_FIRST_BUF and sent to
the kernel, so that finally, the CONFIG records can be stored in a
buffer in the KB layer. A subsequent request with the PART1 "GET
DEVICE CONFIG" returns the old configuration parameters in the
same way as "GET CONFIG" to initialize the input mask.
.br
For "ALTER DEVICE CONFIG", the old configuration parameters
are fetched by "GET CONFIG " to initialize the input mask.
.sp;.cp 3
PART1 contains the command "ALTER DEVICE CONFIG 'sys devspace
name'" or "ALTER DEVICE CONFIG RESTORE'".
The RESTORE command means that once the last request has been
successfully executed, the rest of the host file still has to be
incopied. In the same way as with RESTORE DATABASE, the remaining
records are read from the still open file by U06INCOPY and passed
to the kernel. Once the command has been executed the log
is initialized by an implicit CLEAR LOG.
.sp 2;.cp 4
Procedure UT02COLD_FUNCTIONS
.sp
The procedure selects the UTILITY-functions while the system is in COLD
mode. The configuration functions that occupy both parts of the
SQL_PACKET are either executed directly by
procedures with the 'UTIL' prefix, or selected via the
CONFIG_MENU. For the other functions, only the SQL command is assigned
to PART1 of the SQL_PACKET.
.sp 2;.cp 4
Procedure UT02CONIG_MENU
.sp
The procedure selects the configuration functions while the system
is in COLD mode. With the exception of "ADD CONFIG", these functions
are executed directly by procedures with the 'UTIL' prefix.
.sp 2;.cp 3
Procedure UT02CONNECT
.sp
This procedure deletes the header, displays the connect mask and
then executes "CONNECT username IDENTIFIED BY :X"; the password
is assigned to PART2 of the SQL_PACKET in coded form.
The connect is repeated until it is correct, PFKEY PF_CANCEL or
PF_END is returned or MAX_LOGON_COUNT attempts have taken place.
After a successful connect, a new header is created with the Userid
and the serverdb name. A failed connect can be recognized by
the calling procedure by the REQUEST.RETURN_CODE <> 0.
.sp 2;.cp 5
Procedure UT02DEVICE_MASK
.sp
The preinitialized parameters DEVSPACE_SIZE and DEVSPACE_NAME are
set by configuration masks; a maximum of ten devices can be
used per mask for operation with a normal or a mirror disk.
.sp 2;.cp 4
Procedure UT02EXECUTE_CMD
.sp
Execution of normal utility functions (without configuration).
If CHECK_CMD = true, execution does not take place until the user
issues confirmation.
In addition, another procedure for incopy or outcopy
is called for the RESTORE and SAVE commands.
.br
.sp 2;.cp 10
Procedure UT02GET_CONFIG
.sp
The configuration parameters are fetched by executing a request
with the PART1 "GET CONFIG 'sys devspace name'".
.sp;.cp 3
The parameters in Part2 are displayed in a mask of the system
parameters and other masks with a maximum of 10 DEVSPACE
definitions. The number of other masks depends on NO_OF_DEF.
DEV_USED indicates how many DEVSPACE definitions have been displayed.
.sp 2;.cp 4
Procedure UT02INIT_CONFIG
.sp
After the default assignment of parameters for the mask for the
system parameters and the masks for the DEVSPACE definitions, mask
input is repeated until all the numeric parameters consist of
digits, or until the PFKEY PF_END or PF_CANCEL is pressed. If a
PFKEY is not pressed, a request is configurated having a PART2
corresponding to that of GET CONFIG. PART1 contains "INIT CONFIG".
U02SEND is called once user confirmation is issued.
If the request should chance to fail, mask
input can be repeated with the parameters last specified.
.sp 2;.cp 3
Procedure UT02LOGMODE_TO_PACKET
.sp
The logmode string parameter contained in the mask
is converted into a single logmode character.
These logmode character is added to PART1 of the SQL_PACKET.
.sp 2;.cp 2
Procedure UT02RELEASE
.sp
A release is executed using the command "COMMIT WORK RELEASE".
.sp 2;.cp 4
Procedure UT02WARM_FUNCTIONS
.sp
The procedure selects the UTILITY-functions while the system is in WARM
mode. PART1 of the SQL_PACKET is created accordingly by procedures
with the 'BUILD' prefix when the menu-input mode is selected.
Otherwise the command line is copied to PART1.
.CM *-END-* specification -------------------------------
.fo;.sp 2
***********************************************************
.sp
.fo;.cp 10
.oc _/1
Description:
.sp 2
.oc _/1
Special_UTILITY_commands_for_COLD_mode
.sp
DIAGNOSE
.br;Calls the diagnose menu with the DUMP, VTRACE and
FLUSH VTRACE functions
.sp;.cp 3
DIAGNOSE DISABLE PFKEYS
.br;Only the PFKEYS PF03 (SK09) and PF05 (SK01) are available
.sp;.cp 3
DIAGNOSE ENABLE PFKEYS
.br;All the PFKEYS are available
.sp;.cp 3
DIAGNOSE EXTRACT
.br;Calls the menu for writing database pages to a host file
.sp;.cp 3
DIAGNOSE REPAIR
.br;Calls the REPAIR tool
.sp;.cp 3
DIAGNOSE SWITCH
.br;Calls the menu with the SWITCH, SWITCHLIMIT,
BUFLIMIT, MINBUF and MAXBUF functions
.sp;.cp 8
USE /<serverdb> /<servernode>//
.br;Change to another database with an implicit COMMIT WORK
RELEASE and CONNECT. If a SERVERDB name is not specified or if a
connect failes with the specified SERVERDB name and
the Userid/password combination last used, the CONNECT mask
appears on the screen.
.sp;.cp 3
VDNEXIT
.br;UTILITY is terminated with an implicit COMMIT WORK RELEASE
(as with EXIT)
.sp 2
.oc _/1
Special_UTILITY_commands_for_WARM_mode
.sp
DIAGNOSE
.br;Calls the diagnose menu with the DUMP, VTRACE and
FLUSH VTRACE functions
.sp;.cp 3
DIAGNOSE DISABLE PFKEYS
.br;Only the PFKEYS PF03 (SK09) and PF05 (SK01) are available
.sp;.cp 3
DIAGNOSE ENABLE PFKEYS
.br;All the PFKEYS are available
.sp;.cp 3
DIAGNOSE INDEX ...
.br;The INDEX-Check function is executed. The syntax corresponds
to that of the CREATE INDEX command with the exception of the
keyword 'DIAGNOSE' instead of 'CREATE'.
.sp;.cp 3
DIAGNOSE SWITCH
.br;Calls the menu with the SWITCH, SWITCHLIMIT,
BUFLIMIT, MINBUF and MAXBUF functions
.sp;.cp 4
DROP INDEX ...
.br;Executes the DROP INDEX command. The command is also processed
if the BD file or records of the system catalog do not exist.
.sp;.cp 5
DROP TABLE ...
.br;Executes the DROP TABLE command. The command is also processed
if the BD file or records of the system catalog do not exist.
.sp;.cp 3
FETCH ...
.br;Displays a result record. For every column of the result record
the column name and its value (hex/char format) is displayed.
.sp
RESTART PDM
.br;A PDM restart is performed
.sp;.cp 3
SELECT ...
.br;Executes all the set selects. "-1" as the number of
results means undefined.
.sp;.cp 3
SET LOG MODE DEMO
.br;The log is overwritten cyclically, regardless of the defined
log mode (same as logmode DEMO).
.sp;.cp 2
SHOW ...
.br;Executes a SHOW command.
.sp
SHUTDOWN PDM
.sp;.cp 8
USE /<serverdb> /<servernode>//
.br;Change to another database with an implicit COMMIT WORK
RELEASE and CONNECT. If a SERVERDB name is not specified or if a
connect failes with the specified SERVERDB name and
the Userid/password combination last used, the CONNECT mask
appears on the screen.
.sp;.cp 3
VDNEXIT
.br;UTILITY is terminated with an implicit COMMIT WORK RELEASE
(as with EXIT)
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 20
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_immediate_displ       = true;
      c_on                    = true;
      c_req_only              = true;
      c_warning               = true;
      c_upper_case            = true;
      display_msg             =     1;
      max_connect_count       =     3;
      mx_yes_no               =     1;
      program_name            = 'DIAGNOSE'; (* PTS 1104396 JA 1999-10-28 *)
      retcode_dev_invalid     = -3037;
      retcode_devsize_invalid = -3038;
      retcode_dupl_devname    = -6010;
      retcode_host_wrong      = -3004;
      retcode_incomplete      = -9212;
      retcode_invalid_cmd     = -3005;
      retcode_io_error        =  -902;
      retcode_io_error2       =  -914;
      retcode_io_err_host     =  -903;
      retcode_net_rollb       =   650;
      retcode_next_file       = -8020;
      retcode_not_in_xparam   = -3032;
      retcode_rolled_back     =   600;
      retcode_row_not_found   =   100;
      retcode_small_devsize   = -2008;
      retcode_sysdev_invalid  = -3001;
      retcode_wrong_mode      =  -101;
      suppress_msg            =     0;
      suppress_not_found_msg  =     2;
      suppress_next_file_msg  =     3;
      suppress_wrong_mode_msg =     4;
      (*
      N A M E  *)
      utn_by          = 'BY                ';
      utn_catalog     = 'CATALOG           ';
      utn_connect     = 'CONNECT           ';
      utn_diagnose    = 'DIAGNOSE          ';
      utn_edit        = 'EDIT              ';
      utn_exit        = 'EXIT              ';
      utn_exit2       = 'VDNEXIT           ';
      utn_extract     = 'EXTRACT           ';
      utn_identified  = 'IDENTIFIED        ';
      utn_layer       = 'LAYER             ';
      utn_repair      = 'REPAIR            ';
      utn_show        = 'SHOW              ';
      utn_switch      = 'SWITCH            ';
      utn_typedata    = 'TYPEDATA          ';
      utn_utility     = 'UTILITY           ';
      utn_verify      = 'VERIFY            ';
      utn_version     = 'VERSION           ';
      utn_vtrace      = 'VTRACE            ';
      utn_is_admin    = 'IS STATE ADMIN    ';
      yes_answer      = 'y                 ';
      (*
      C O M M A N D *)
      cmd_commit_rel        = 'COMMIT WORK RELEASE ';
      cmd_exit              = 'EXIT                ';
      (*
      M E S S A G E *)
      msg_cmd_cancelled     = 'COMMAND CANCELLED   ';
      msg_connecting        = 'CONNECTING ...      ';
      msg_diag_extract      = 'DIAGNOSE EXTRACT    ';
      msg_diag_switch       = 'DIAGNOSE SWITCH     ';
      msg_diag_typedata     = 'DIAGNOSE TYPEDATA   ';
      msg_diagnose          = 'DIAGNOSE            ';
      msg_session_end       = 'SESSION END         ';
      qmsg_execution        = 'EXECUTION?  (y/n)   ';
      (*
      M E S S A G E  30 *)
      msg30_cold_function    = '      admin mode              ';
      msg30_execute          = '           EXECUTE            ';
      msg30_primary_function = '      online mode             ';
      msg40_leave1 = 'If you want to leave the DIAGNOSE sessio';
      msg40_leave2 = 'n, restrike the END key                 ';
 
TYPE
      util_cmd_type = (
            ut_none,
            ut_dbs,
            ut_exit,
            ut_invalid,
            ut_output,
            ut_get_block_addr,
            ut_show,
            ut_show_cmdline,
            ut_standard,
            ut_verify_catalog);
      (* *)
      util_menu_type = (
            utmenu_none,
            utmenu_diag,
            utmenu_exit);
      (* *)
      database_state = (db_stateIsAdmin, db_stateIsOnline);
 
 
(*------------------------------*) 
 
PROCEDURE
      u02receive (VAR term  : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            VAR sql_ref     : tsp00_Int4;
            msg_wanted      : integer;
            VAR rcv_packet  : tsp1_packet_ptr;
            VAR sql_retcode : tsp00_Int2);
 
VAR
      sql_comm_err : tsp1_comm_error;
      errtext      : tsp00_ErrText;
      dummy_len    : tsp00_Int4;
 
BEGIN
sql_retcode  := 0;
rcv_packet   := NIL;
sql_comm_err := sp1ce_ok;
sqlareceive (sql_ref, rcv_packet, dummy_len, errtext, sql_comm_err);
&ifdef TRACE
t02int4 (debug_ut, 'RECEIVE rslt', ord (sql_comm_err));
&endif
IF  sql_comm_err <> sp1ce_ok
THEN
    BEGIN
    u05write_prot (term, protfile, 'sqlareceive, err: ',
          ord (sql_comm_err));
    sqlarelease (sql_ref);
    u05request_errmsg (term, protfile, errtext, sql_comm_err);
    sql_retcode := cut_sql_req_failed
    END
ELSE
    BEGIN
    sql_retcode := rcv_packet^.sp1_segm.sp1r_returncode;
&   ifdef TRACE
    IF  t02trace (debug_ut)
    THEN
        x05packet (term, protfile, t02is_minbuf, t02buflength_max,
              'RECEIVE     ', rcv_packet);
&   endif
    (*ENDIF*) 
    t09returncode_set (term, sql_retcode);
    IF  (sql_retcode <> 0)
        AND (
        (msg_wanted = display_msg)
        OR
        ((msg_wanted = suppress_wrong_mode_msg)
        AND (sql_retcode <> retcode_wrong_mode))
        OR
        ((msg_wanted = suppress_not_found_msg)
        AND (sql_retcode <> retcode_row_not_found))
        OR
        ((msg_wanted = suppress_next_file_msg)
        AND (sql_retcode <> retcode_next_file )))
    THEN
        IF  (sql_retcode = retcode_dev_invalid    ) OR
            (sql_retcode = retcode_devsize_invalid) OR
            (sql_retcode = retcode_dupl_devname   ) OR
            (sql_retcode = retcode_host_wrong     ) OR
            (sql_retcode = retcode_incomplete     ) OR
            (sql_retcode = retcode_io_error       ) OR
            (sql_retcode = retcode_io_error2      ) OR
            (sql_retcode = retcode_io_err_host    ) OR
            (sql_retcode = retcode_net_rollb      ) OR
            (sql_retcode = retcode_not_in_xparam  ) OR
            (sql_retcode = retcode_rolled_back    ) OR
            (sql_retcode = retcode_small_devsize  ) OR
            (sql_retcode = retcode_sysdev_invalid )
        THEN
            u05param_errmsg (term, protfile, rcv_packet)
        ELSE
            u05errmsg (term, protfile, sql_retcode)
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u02send (VAR term     : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            snd_packet      : tsp1_packet_ptr;
            VAR sql_ref     : tsp00_Int4;
            msg_wanted      : integer;
            req_only        : boolean;
            VAR rcv_packet  : tsp1_packet_ptr;
            VAR sql_retcode : tsp00_Int2);
 
VAR
      sql_comm_err : tsp1_comm_error;
      snd_length   : tsp00_Int4;
      errtext      : tsp00_ErrText;
 
BEGIN
(* snd_packet.mess_type := cmd_mess_type; *)
&ifdef TRACE
IF  t02trace (debug_ut)
THEN
    x05packet (term, protfile, t02is_minbuf, t02buflength_max,
          'REQUEST     ', snd_packet);
&endif
(*ENDIF*) 
sql_retcode  := 0;
IF  NOT req_only
THEN
    rcv_packet := NIL;
(*ENDIF*) 
sql_comm_err := sp1ce_ok;
snd_length   := s26packet_len (snd_packet);
snd_packet^.sp1_header.sp1h_varpart_len := snd_length -
      sizeof (snd_packet^.sp1_header);
sqlarequest (sql_ref, snd_packet, snd_length, errtext, sql_comm_err);
&ifdef TRACE
t02int4 (debug_ut, 'REQUEST rslt', ord(sql_comm_err));
&endif
IF  sql_comm_err = sp1ce_ok
THEN
    BEGIN
    IF  NOT req_only
    THEN
        u02receive (term, protfile, sql_ref, msg_wanted,
              rcv_packet, sql_retcode)
    (*ENDIF*) 
    END
ELSE
    BEGIN
    u05write_prot (term, protfile, 'sqlarequest, err: ',
          ord (sql_comm_err));
    sqlarelease (sql_ref);
    u05request_errmsg (term, protfile, errtext, sql_comm_err);
    sql_retcode := cut_sql_req_failed
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u02utility (VAR term  : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            aid             : tsp00_TaskId;
            VAR termid      : tsp00_TermId;
            VAR xusertype   : tsp4_xuser;
            VAR username    : tsp00_KnlIdentifier;
            VAR password    : tsp00_CryptPw;
            VAR serverdb    : tsp00_DbName;
            VAR servernode  : tsp00_NodeId;
            adbs_session    : boolean;
            write_time      : boolean;
            use_cmd_line    : boolean;
            VAR cmd_line    : tsp00_Line;
            VAR pfkey       : tut_pfkey);
 
VAR
      cold_warm_state : database_state;
      cmd             : util_cmd_type;
      last_menu       : util_menu_type;
      check_cmd       : boolean;
      is_connected    : boolean;
      is_continue_ln  : boolean;
      connect_type    : tsp4_xuser;
      dummy_err       : integer;
      len             : integer;
      util_retcode    : tsp00_Int2;
      sql_retcode     : tsp00_Int2;
      sql_ref         : tsp00_Int4;
      snd_packet      : tsp1_packet_ptr;
      snd_2_packet    : tsp1_packet_ptr;
      rcv_packet      : tsp1_packet_ptr;
      tok1            : tsp00_Name;
      tok2            : tsp00_Name;
      ln              : tsp00_Line;
 
BEGIN
pfkey           := pf_none;
is_connected    := false;
cold_warm_state := db_stateIsAdmin;
check_cmd       := true;
is_continue_ln  := false;
sql_ref         := 0;
cmd             := ut_none;
last_menu       := utmenu_none;
snd_packet      := NIL;
snd_2_packet    := NIL;
rcv_packet      := NIL;
sql_retcode     := 0;
IF  use_cmd_line
THEN
    BEGIN
    u05get2token (cmd_line, tok1, tok2);
    IF  (tok1 = utn_version) AND (tok2 = bsp_name)
    THEN
        BEGIN
        u03version (term, protfile, true);
        pfkey := pf_end
        END
    ELSE
        ln := cmd_line
    (*ENDIF*) 
    END
ELSE
    ln := term.blankline;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    connect_type := xusertype;
    ut02connect (term, protfile, snd_packet, snd_2_packet, sql_ref, aid,
          termid, adbs_session, write_time, use_cmd_line, display_msg,
          connect_type, username, password, serverdb, servernode,
          cold_warm_state, is_connected, is_continue_ln, pfkey, sql_retcode)
    END;
(*ENDIF*) 
IF  (sql_retcode = 0) AND (pfkey = pf_none)
THEN
    REPEAT
        sql_retcode := 0;
        IF  (last_menu = utmenu_none) OR (last_menu = utmenu_exit)
        THEN
            CASE cold_warm_state OF
                db_stateIsAdmin:
                    ut02cold_functions (term, protfile, snd_packet, sql_ref,
                          check_cmd, is_continue_ln, write_time, use_cmd_line,
                          ln, username, password, serverdb, cmd, last_menu,
                          pfkey, sql_retcode);
                db_stateIsOnline:
                    ut02warm_functions (term, protfile, snd_packet, sql_ref,
                          check_cmd, is_continue_ln, write_time, use_cmd_line,
                          ln, cmd, username, password, serverdb, last_menu,
                          pfkey, rcv_packet, sql_retcode);
                END
            (*ENDCASE*) 
        ELSE
            BEGIN
            ut02last_menu (term, protfile, snd_packet, write_time, cmd, last_menu, pfkey);
            ln := term.blankline
            END;
        (*ENDIF*) 
        IF  pfkey in [pf_end, pf_help]
        THEN
            BEGIN
            pfkey := pf_none;
            IF  cmd <> ut_exit
            THEN
                cmd := ut_none
            (*ENDIF*) 
            END
        ELSE
            IF  pfkey = pf_cancel
            THEN
                cmd := ut_exit;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  ((cmd = ut_exit) AND (pfkey = pf_none) AND (sql_retcode <> cut_sql_req_failed))
        THEN
            BEGIN
            util_retcode := t09retcode (term);
            ut02release (term, protfile, snd_packet, sql_ref, adbs_session,
                  write_time, is_connected, rcv_packet, sql_retcode);
            IF  sql_retcode <> 0
            THEN
                t09returncode_set (term, util_retcode)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (pfkey = pf_none) AND (sql_retcode <> cut_sql_req_failed) AND
            (cmd in [
            ut_dbs,
            ut_output,
            ut_get_block_addr,
            ut_show,
            ut_show_cmdline,
            ut_standard,
            ut_verify_catalog])
        THEN
            BEGIN
            ut02execute_cmd (term, protfile, snd_packet, sql_ref,
                  write_time, check_cmd, cmd, pfkey, rcv_packet, sql_retcode);
            IF  (cmd = ut_verify_catalog) AND (sql_retcode <> cut_sql_req_failed)
            THEN
                ut02verify_catalog_show (term, protfile, snd_packet,
                      sql_ref, cmd, pfkey, rcv_packet, sql_retcode);
            (*ENDIF*) 
            IF  sql_retcode = 0
            THEN
                BEGIN
                ln := term.blankline;
                IF  cmd = ut_output
                THEN
                    BEGIN
                    WITH rcv_packet^.sp1_segm DO
                        BEGIN
                        len := sp1p_buf_len;
                        IF  len > sizeof (ln)
                        THEN
                            len := sizeof (ln);
                        (*ENDIF*) 
                        SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (ln),
                              @sp1p_buf, 1, @ln, 1, len);
                        END;
                    (*ENDWITH*) 
                    t09put (term, term.blankline, cut_protected);
                    t09put (term, ln, cut_bright_protected);
                    t12write_prot (protfile, ln, len, dummy_err);
                    t09holding (term, pfkey);
                    IF  pfkey <> pf_cancel
                    THEN
                        pfkey := pf_none;
                    (*ENDIF*) 
                    ln := term.blankline
                    END
                ELSE
                    IF  cmd = ut_get_block_addr
                    THEN
                        u05get_block_addr (term, protfile, rcv_packet, pfkey)
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  pfkey in [pf_end, pf_help]
            THEN
                pfkey := pf_none
            (*ENDIF*) 
            END
        ELSE
            IF  (cmd = ut_none) AND (sql_retcode = 0)
            THEN
                ln := term.blankline;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  (sql_retcode = cut_sql_req_failed) AND (pfkey = pf_none)
        THEN
            BEGIN
            last_menu    := utmenu_none;
            is_connected := false;
            IF  NOT use_cmd_line
            THEN
                BEGIN
                sql_retcode := 0;
                ut02connect (term, protfile, snd_packet, snd_2_packet,
                      sql_ref, aid, termid, adbs_session,
                      write_time, use_cmd_line,
                      suppress_msg, connect_type, username, password,
                      serverdb, servernode, cold_warm_state,
                      is_connected, is_continue_ln, pfkey, sql_retcode)
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
    UNTIL
        (cmd = ut_exit) OR (pfkey <> pf_none) OR use_cmd_line;
    (*ENDREPEAT*) 
(*ENDIF*) 
IF  is_connected AND (sql_retcode <> cut_sql_req_failed)
THEN
    BEGIN
    util_retcode := t09retcode (term);
    ut02release (term, protfile, snd_packet, sql_ref, adbs_session,
          write_time, is_connected, rcv_packet, sql_retcode);
    IF  sql_retcode = 0
    THEN
        t09returncode_set (term, util_retcode)
    (*ENDIF*) 
    END;
(*ENDIF*) 
u05str20_to_line (msg_session_end, ln);
IF  (pfkey <> pf_cancel) AND NOT use_cmd_line
THEN
    BEGIN
    pfkey := pf_end;
    t09putmsg (term, ln, NOT c_warning, c_immediate_displ)
    END;
(*ENDIF*) 
t12write_prot (protfile, ln, 20, dummy_err)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut02cold_functions (VAR term : tut_terminal;
            VAR protfile       : tut_vf_fileref;
            snd_packet         : tsp1_packet_ptr;
            VAR sql_ref        : tsp00_Int4;
            VAR is_selected    : boolean;
            VAR is_continue_ln : boolean;
            write_time         : boolean;
            use_cmd_line       : boolean;
            VAR ln             : tsp00_Line;
            VAR username       : tsp00_KnlIdentifier;
            VAR password       : tsp00_CryptPw;
            VAR serverdb       : tsp00_DbName;
            VAR cmd            : util_cmd_type;
            VAR last_menu      : util_menu_type;
            VAR pfkey          : tut_pfkey;
            VAR sql_retcode    : tsp00_Int2);
 
CONST
      (* HELP MENU *)
      x_diagnose      =  1;
      x_diag_switch   =  3;
      (* --- column 2 --- *)
      x_diag_extract  =  8;
      x_diag_typedata = 10;
      x_exit          = 13;
 
VAR
      cmd_created    : boolean;
      selected       : integer;
      tok1           : tsp00_Name;
      tok2           : tsp00_Name;
      tok3           : tsp00_Name;
      tok4           : tsp00_Name;
      tok5           : tsp00_Name;
      tok6           : tsp00_Name;
      blank_progname : tsp00_C20;
      msg            : tut_c20_array;
 
BEGIN
pfkey       := pf_none;
cmd         := ut_invalid;
is_selected := false;
IF  NOT use_cmd_line
THEN
    BEGIN
    t09msgheader (term, msg30_cold_function, true);
    t09setpf1 (term, cut_pfkey_none);
    FOR selected := 1 TO 20 DO
        msg [selected] := bsp_c20;
    (*ENDFOR*) 
    msg [x_diagnose     ] := msg_diagnose;
    msg [x_diag_switch  ] := msg_diag_switch;
    msg [x_diag_extract ] := msg_diag_extract;
    msg [x_diag_typedata] := msg_diag_typedata;
    msg [x_exit         ] := cmd_exit;
    t09getmenu (term, x_exit, cut_protected, NOT c_upper_case,
          msg, selected, pfkey, ln, is_selected);
    t09msgheader (term, bsp_c30, true)
    END;
(*ENDIF*) 
IF  pfkey <> pf_none
THEN
    BEGIN
    IF  last_menu = utmenu_exit
    THEN
        BEGIN
        last_menu   := utmenu_none;
        selected    := x_exit;
        is_selected := true
        END
    ELSE
        BEGIN
        ut02display_leave_msg (term);
        last_menu := utmenu_exit;
        cmd       := ut_none
        END
    (*ENDIF*) 
    END
ELSE
    BEGIN
    last_menu := utmenu_none;
    IF  is_selected
    THEN
        is_continue_ln := false
    ELSE
        BEGIN
        u05getcommand (term, protfile, snd_packet, write_time, ln,
              is_continue_ln, pfkey);
        u05gettoken (snd_packet, tok1, tok2, tok3, tok4, tok5, tok6);
&       ifdef TRACE
        t02name1 (debug_ut, 'tok1        ', tok1);
        t02name1 (debug_ut, 'tok2        ', tok2);
        t02name1 (debug_ut, 'tok3        ', tok3);
        t02name1 (debug_ut, 'tok4        ', tok4);
        IF  t02trace (debug_ut)
        THEN
            x05packet (term, protfile, t02is_minbuf, t02buflength_max,
                  'COMMAND     ', snd_packet);
&       endif
        (*ENDIF*) 
        IF  (tok1 = utn_exit) OR (tok1 = utn_exit2)
        THEN
            BEGIN
            selected    := x_exit;
            is_selected := true
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  is_selected
THEN
    BEGIN
    ln := term.blankline;
    CASE selected OF
        x_diagnose:
            BEGIN
            ut02diagnose_menu (term, snd_packet, cmd, last_menu, pfkey);
            (* without command prompting *)
            is_selected := false
            END;
        x_diag_switch:
            BEGIN
            cmd := ut_none;
            u05switch (term, protfile, snd_packet, sql_ref,
                  bsp_c20, pfkey, sql_retcode)
            END;
        x_diag_extract:
            BEGIN
            cmd := ut_standard;
            u05diagextract (term, snd_packet, pfkey);
            END;
        x_diag_typedata:
            BEGIN
            cmd            := ut_none;
            blank_progname := bsp_c20;
            x03typedata (term, protfile, blank_progname, snd_packet, sql_ref, pfkey)
            END;
        x_exit:
            cmd := ut_exit;
        OTHERWISE
            cmd := ut_invalid
        END
    (*ENDCASE*) 
    END
ELSE
    (* without menu selection ==> scan input line *)
    BEGIN
    cmd_created := false;
    IF  tok1 = utn_vtrace
    THEN
        cmd := ut_standard;
    (*ENDIF*) 
    IF  tok1 = utn_diagnose
    THEN
        BEGIN
        IF  (tok2 = utn_vtrace) OR ((tok2 = utn_switch) AND (tok3  = utn_layer))
        THEN
            cmd := ut_standard
        ELSE
            BEGIN
            IF  (tok2 = utn_extract) AND (tok3 = bsp_name) AND NOT use_cmd_line
            THEN
                BEGIN
                cmd := ut_standard;
                u05diagextract (term, snd_packet, pfkey);
                END
            ELSE
                IF  ((tok2 = utn_repair) OR (tok2 = utn_edit)) AND (tok3 = bsp_name) AND NOT use_cmd_line
                THEN
                    BEGIN
                    cmd := ut_none;
                    u07repair (term, protfile, snd_packet, sql_ref, username, password,
                          serverdb, pfkey, sql_retcode, (tok2 = utn_repair));
                    IF  pfkey <> pf_cancel
                    THEN
                        u05header (term, program_name, serverdb, username)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (pfkey <> pf_none) OR cmd_created OR (cmd = ut_none)
    THEN
        ln := term.blankline
    ELSE
        IF  cmd = ut_invalid
        THEN
            ut02cmd_line_handling (term, protfile, snd_packet, sql_ref, write_time,
                  use_cmd_line, ln, tok1, tok2, tok3, cmd, last_menu, pfkey, sql_retcode)
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut02cmd_line_handling (VAR term : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            snd_packet      : tsp1_packet_ptr;
            VAR sql_ref     : tsp00_Int4;
            write_time      : boolean;
            use_cmd_line    : boolean;
            VAR ln          : tsp00_Line;
            VAR tok1        : tsp00_Name;
            VAR tok2        : tsp00_Name;
            VAR tok3        : tsp00_Name;
            VAR cmd         : util_cmd_type;
            VAR last_menu   : util_menu_type;
            VAR pfkey       : tut_pfkey;
            VAR sql_retcode : tsp00_Int2);
 
VAR
      cmd_created    : boolean;
      blank_progname : tsp00_C20;
 
BEGIN
pfkey       := pf_none;
cmd_created := false;
IF  tok1 = bsp_name
THEN
    cmd := ut_none;
(*ENDIF*) 
IF  cmd = ut_invalid
THEN
    BEGIN
    IF  tok1 = utn_diagnose
    THEN
        BEGIN
        IF  (tok2 = utn_switch) AND (tok3 = bsp_name) AND NOT use_cmd_line
        THEN
            BEGIN
            cmd := ut_none;
            u05switch (term, protfile, snd_packet, sql_ref, bsp_c20, pfkey, sql_retcode)
            END
        ELSE
            IF  tok2 = utn_typedata
            THEN
                BEGIN
                cmd := ut_none;
                blank_progname := bsp_c20;
                x03typedata (term, protfile, blank_progname, snd_packet, sql_ref, pfkey)
                END
            ELSE
                IF  (tok2 = bsp_name) AND NOT use_cmd_line
                THEN
                    BEGIN
                    cmd_created := true;
                    ut02diagnose_menu (term, snd_packet, cmd, last_menu, pfkey);
                    IF  (cmd <> ut_none) AND (pfkey = pf_none)
                    THEN
                        u05cmdwrite_prot (protfile, term.blankline, write_time, snd_packet)
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    sql_retcode := retcode_invalid_cmd;
                    t09returncode_set  (term, sql_retcode);
                    u05errmsg (term,protfile, sql_retcode)
                    END
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE (* tok1 <> utn_diagnose *)
        IF  (tok1 = utn_show) AND (tok2 = utn_utility) AND (tok3 = utn_version)
        THEN
            BEGIN
            cmd := ut_none;
            u03version (term, protfile, false)
            END
        ELSE
            BEGIN
            sql_retcode := retcode_invalid_cmd;
            t09returncode_set(term, sql_retcode);
            u05errmsg(term,protfile, sql_retcode)
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  cmd_created OR (cmd = ut_none)
THEN
    ln := term.blankline
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut02connect (VAR term     : tut_terminal;
            VAR protfile        : tut_vf_fileref;
            VAR snd_packet      : tsp1_packet_ptr;
            VAR snd_2_packet    : tsp1_packet_ptr;
            VAR sql_ref         : tsp00_Int4;
            aid                 : tsp00_TaskId;
            VAR termid          : tsp00_TermId;
            adbs_session        : boolean;
            write_time          : boolean;
            is_util_cmd_line    : boolean;
            try_connect_errmsg  : integer;
            VAR connect_type    : tsp4_xuser;
            VAR username        : tsp00_KnlIdentifier;
            VAR password        : tsp00_CryptPw;
            VAR serverdb        : tsp00_DbName;
            VAR servernode      : tsp00_NodeId;
            VAR cold_warm_state : database_state;
            VAR is_connected    : boolean;
            VAR is_continue_ln  : boolean;
            VAR pfkey           : tut_pfkey;
            VAR sql_retcode     : tsp00_Int2);
 
VAR
      sql_comm_err    : tsp1_comm_error;
      is_use_cmd      : boolean;
      msg_wanted      : integer;
      connect_count   : integer;
      ln_len          : integer;
      dummy_err       : integer;
      snd_packet_size : tsp00_Int4;
      connect_packet  : tsp1_packet_ptr;
      rcv_packet      : tsp1_packet_ptr;
      datapart_ptr    : tsp1_part_ptr;
      packet_list     : tsp1_packet_list;
      errtext         : tsp00_ErrText;
      input_pw        : tsp00_Name;
      tok1            : tsp00_Name;
      tok3            : tsp00_Name;
      tok4            : tsp00_Name;
      tok6            : tsp00_Name;
      ln              : tsp00_Line;
      (* h.b. PTS 1102605 connect_buf has to be aligned  *)
      connect_buf     : PACKED ARRAY [1..256] OF tsp00_Int4;
 
      univ_token : RECORD
            CASE integer OF
                1:
                    (n   : tsp00_Name);
                2:
                    (c64 : tsp00_KnlIdentifier)
                END;
            (*ENDCASE*) 
 
 
BEGIN
pfkey := pf_none;
t09pfkeys (term, NOT c_on); (* PTS 1000215 JA 1997-11-14 *)
IF  NOT is_util_cmd_line
THEN
    BEGIN
    t09frame (term, false);
    t09header (term, bsp_c20, bsp_c20)
    END;
(*ENDIF*) 
connect_count := 0;
IF  (connect_type <> sp4xu_sql_usermask) OR is_util_cmd_line
THEN
    connect_count := -1;
(*ENDIF*) 
connect_packet := @connect_buf;
connect_packet^.sp1_header.sp1h_varpart_size := sizeof (connect_buf);
REPEAT
    is_use_cmd := false;
    IF  connect_count = 0
    THEN
        connect_type := sp4xu_sql_usermask;
&   ifdef TRACE
    (*ENDIF*) 
    t02int4 (debug_ut, 'connect type', ord(connect_type));
&   endif
    IF  (connect_count = 0) AND term.is_inputfile
    THEN
        BEGIN
        (* INPUT FILE: *)
        (* REPEAT read connect command; try connect UNTIL ok OR eof *)
        msg_wanted := display_msg;
        u05connect_mask (term, true, username, input_pw,
              serverdb, servernode, pfkey);
        pfkey := pf_none;
        REPEAT
            t09get (term, ln, pfkey);
            IF  pfkey = pf_help
            THEN
                pfkey := pf_none
            (*ENDIF*) 
        UNTIL
            (ln <> term.blankline) OR (pfkey <> pf_none);
        (*ENDREPEAT*) 
        IF  pfkey = pf_none
        THEN
            u05getcommand (term, protfile, connect_packet, write_time,
                  ln, is_continue_ln, pfkey);
        (*ENDIF*) 
        IF  pfkey = pf_none
        THEN
            BEGIN
            univ_token.c64 := bsp_c64;
            u05gettoken (connect_packet, tok1, univ_token.n, tok3, tok4, input_pw, tok6);
            username := univ_token.c64;
            IF  (tok1 = utn_exit) OR (tok1 = utn_exit2)
            THEN
                pfkey := pf_end
            ELSE
                IF  (tok1 = utn_connect)
                    AND
                    ((input_pw = bsp_name) OR ((tok3 = utn_identified) AND (tok4 = utn_by)))
                THEN
                    u05encrypt (input_pw, password)
                ELSE
                    BEGIN
                    IF  tok1 = utn_connect
                    THEN
                        BEGIN
                        t12write_prot (protfile, term.blankline, 1, dummy_err);
                        ln_len := 8;
                        t12write_prot (protfile, ln, ln_len, dummy_err)
                        END;
                    (*ENDIF*) 
                    sql_retcode := retcode_invalid_cmd;
                    t09returncode_set (term, sql_retcode);
                    u05errmsg (term, protfile, sql_retcode);
                    pfkey := pf_end
                    END
                (*ENDIF*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        IF  connect_count = -1
        THEN
            (* TRY CONNECT *)
            msg_wanted := try_connect_errmsg
        ELSE
            BEGIN
            (* TERMINAL INPUT *)
            msg_wanted := display_msg;
            input_pw   := bsp_name;
            u05connect_mask (term, false, username, input_pw, serverdb, servernode, pfkey);
            IF  pfkey = pf_help
            THEN
                pfkey := pf_none;
            (*ENDIF*) 
            IF  pfkey = pf_none
            THEN
                BEGIN
                u05str20_to_line (msg_connecting, ln);
                t09putmsg (term, ln, NOT c_warning, c_immediate_displ);
                t09putmsg (term, term.blankline, NOT c_warning, NOT c_immediate_displ);
                u05encrypt (input_pw, password);
                u05usewrite_prot (protfile, term.blankline, serverdb, servernode)
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        connect_count := connect_count + 1
        END;
    (*ENDIF*) 
    IF  (pfkey = pf_none) AND NOT is_use_cmd
    THEN
        BEGIN
        sql_comm_err := sp1ce_ok;
        sqlaconnect (aid, servernode, serverdb, sql_user, 2,
              sql_ref, snd_packet_size, packet_list, errtext,
              sql_comm_err);
&       ifdef TRACE
        t02name1 (debug_ut, 'serverdb    ', serverdb);
        t02int4  (debug_ut, 'CONNECT rslt', ord(sql_comm_err));
        t02int4  (debug_ut, '     sql_ref', sql_ref);
        t02int4  (debug_ut, 'packet size ', snd_packet_size);
&       endif
        IF  sql_comm_err <> sp1ce_ok
        THEN
            BEGIN
            u05write_prot (term, protfile, 'sqlaconnect, err: ',
                  ord (sql_comm_err));
            u05request_errmsg (term, protfile, errtext, sql_comm_err);
            sql_retcode := cut_sql_req_failed;
            (* u05put_error_into_rcv_packet (snd_packet, cut_sql_req_failed); *)
            END
        ELSE
            BEGIN
            snd_packet   := packet_list [1];
            snd_2_packet := packet_list [2];
            snd_packet^.sp1_header.sp1h_varpart_size :=
                  snd_packet_size - sizeof (snd_packet^.sp1_header);
            snd_2_packet^.sp1_header.sp1h_varpart_size :=
                  snd_packet_size - sizeof (snd_2_packet^.sp1_header);
            u05packet_init (snd_packet);
            IF  adbs_session
            THEN
                snd_packet^.sp1_segm.sp1c_mess_type := sp1m_dbs;
            (*ENDIF*) 
            u05nameto_packet (utn_connect, snd_packet);
            u05username_to_packet (username, snd_packet);
            u05nameto_packet (utn_identified, snd_packet);
            u05nameto_packet (utn_by, snd_packet);
            u05nameto_packet (':X                ', snd_packet);
            s26finish_part (snd_packet, snd_packet^.sp1_segm.sp1p_part);
            s26new_part_init (snd_packet, snd_packet^.sp1_segm,
                  datapart_ptr);
            u05cmdwrite_prot (protfile, term.blankline, write_time,
                  snd_packet);
            WITH datapart_ptr^ DO
                BEGIN
                sp1p_buf [sp1p_buf_len+1] := csp_defined_byte;
                SAPDB_PascalForcedMove (sizeof (password), sp1p_buf_size, @password, 1,
                      @sp1p_buf, sp1p_buf_len + 2, sizeof (password));
                sp1p_buf_len := sp1p_buf_len + 1 + sizeof (password);
                sp1p_buf [sp1p_buf_len+1] := ' ';
                SAPDB_PascalForcedMove (sizeof (termid), sp1p_buf_size,
                      @termid, 1, @sp1p_buf,
                      sp1p_buf_len + 2, sizeof (termid));
                sp1p_buf_len := sp1p_buf_len + 1 + sizeof (termid)
                END;
            (*ENDWITH*) 
            s26finish_part (snd_packet, datapart_ptr^);
            u02send (term, protfile, snd_packet, sql_ref,
                  msg_wanted, false, rcv_packet, sql_retcode);
            IF  sql_retcode = 0
            THEN
                is_connected := true
            ELSE
                IF  sql_retcode <> cut_sql_req_failed
                THEN
                    sqlarelease (sql_ref);
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    (*ENDIF*) 
UNTIL
    (NOT is_use_cmd AND (sql_retcode = 0))
    OR (connect_count >= max_connect_count)
    OR (pfkey <> pf_none)
    OR is_util_cmd_line;
(*ENDREPEAT*) 
IF  (pfkey = pf_none) AND (sql_retcode = 0)
THEN
    BEGIN
    IF  adbs_session
    THEN
        cold_warm_state := db_stateIsOnline
    ELSE
        ut02get_cold_warm_state (term, protfile, snd_packet, sql_ref,
              cold_warm_state, rcv_packet, sql_retcode);
    (*ENDIF*) 
    IF  (sql_retcode = 0) AND NOT is_util_cmd_line
    THEN
        u05header (term, program_name, serverdb, username)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (sql_retcode <> 0) AND (pfkey <> pf_cancel)
THEN
    pfkey := pf_end;
(*ENDIF*) 
t09pfkeys (term, c_on); (* PTS 1000215 JA 1997-11-14 *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut02diagnose_menu (VAR term : tut_terminal;
            snd_packet    : tsp1_packet_ptr;
            VAR cmd       : util_cmd_type;
            VAR last_menu : util_menu_type;
            VAR pfkey     : tut_pfkey);
 
VAR
      is_blockoutput : boolean;
      menu_finished  : boolean;
 
BEGIN
u05diagnose (term, snd_packet, is_blockoutput, menu_finished, pfkey);
IF  menu_finished
THEN
    BEGIN
    cmd       := ut_none;
    last_menu := utmenu_none
    END
ELSE
    BEGIN
    last_menu := utmenu_diag;
    IF  is_blockoutput
    THEN
        cmd := ut_get_block_addr
    ELSE
        cmd := ut_standard
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut02display_leave_msg (VAR term : tut_terminal);
 
VAR
      i   : integer;
      msg : tsp00_C40;
      ln  : tsp00_Line;
 
BEGIN
ln  := term.blankline;
msg := msg40_leave1;
FOR i := 1 TO 40 DO
    ln[ i] := msg [i];
(*ENDFOR*) 
msg := msg40_leave2;
FOR i := 1 TO 40 DO
    ln[ 40+i] := msg [i];
(*ENDFOR*) 
t09putmsg (term, ln, NOT c_warning, NOT c_immediate_displ)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut02execute_cmd (
            VAR term        : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            snd_packet      : tsp1_packet_ptr;
            VAR sql_ref     : tsp00_Int4;
            write_time      : boolean;
            check_cmd       : boolean;
            VAR cmd         : util_cmd_type;
            VAR pfkey       : tut_pfkey;
            VAR rcv_packet  : tsp1_packet_ptr;
            VAR sql_retcode : tsp00_Int2);
 
VAR
      i          : integer;
      answer_len : integer;
      msg_wanted : integer;
      show_msg   : tsp00_C30;
      ln         : tsp00_Line;
      answer     : tsp00_Name;
 
BEGIN
pfkey       := pf_none;
sql_retcode := 0;
ln          := term.blankline;
WITH snd_packet^.sp1_segm DO
    BEGIN
    i := sp1p_buf_len;
    IF  i > LINE_MXSP00
    THEN
        i := LINE_MXSP00;
    (*ENDIF*) 
    SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (ln), @sp1p_buf, 1, @ln, 1, i)
    END;
(*ENDWITH*) 
IF  check_cmd AND (cmd <> ut_show)
THEN
    BEGIN
    answer := yes_answer;
    IF  NOT term.is_inputfile
    THEN
        BEGIN
        t09newscreen_page (term);
        t09msgheader (term, bsp_c30, true);
        answer_len := mx_yes_no;
        IF  term.use_pfkeys
        THEN
            BEGIN
            t09put (term, ln, cut_bright_unprotected);
            (* avoid moving to previous line field *)
            answer_len := answer_len + 1
            END
        ELSE
            t09put (term, ln, cut_bright_protected);
        (*ENDIF*) 
        t09put (term, term.blankline, cut_protected);
        t09get1name (term, qmsg_execution, cut_bright_protected,
              cut_unprotected, answer_len, true, answer, pfkey)
        END;
    (*ENDIF*) 
    IF  NOT u05isyes (answer) OR (pfkey in [ pf_end, pf_help])
    THEN
        BEGIN
        cmd := ut_none;
        u05str20_to_line (msg_cmd_cancelled, ln);
        t09putmsg (term, ln, NOT c_warning, NOT c_immediate_displ)
        END
    ELSE
        IF  pfkey = pf_cancel
        THEN
            cmd := ut_exit
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (cmd <> ut_none) AND (cmd <> ut_exit)
THEN
    BEGIN
    IF  check_cmd
    THEN
        u05cmdwrite_prot (protfile, term.blankline,
              write_time, snd_packet);
    (*ENDIF*) 
    t09msgheader (term, msg30_execute, false);
    WITH snd_packet^.sp1_segm DO
        IF  cmd  = ut_dbs
        THEN
            sp1c_mess_type := sp1m_dbs
        ELSE
            IF  cmd in [ut_show, ut_show_cmdline]
            THEN
                BEGIN
                sp1c_mess_type := sp1m_dbs;
                sp1c_with_info := true
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDWITH*) 
    IF  cmd in [ut_show, ut_show_cmdline]
    THEN
        WITH snd_packet^.sp1_segm DO
            BEGIN
            i := 1;
            show_msg := bsp_c30;
            WHILE  (i <= 30) AND (i <= sp1p_buf_len) DO
                BEGIN
                show_msg[ i] := sp1p_buf [i];
                i := i + 1
                END;
            (*ENDWHILE*) 
            IF  (sp1p_buf_len > 30) AND (sp1p_buf [31] <> ' ')
            THEN
                BEGIN
                i := 30;
                WHILE (i > 1) AND (show_msg [i] <> ' ') DO
                    BEGIN
                    show_msg [i] := ' ';
                    i := i - 1
                    END
                (*ENDWHILE*) 
                END
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    msg_wanted := display_msg;
    u02send (term, protfile, snd_packet, sql_ref, msg_wanted, false,
          rcv_packet, sql_retcode);
    IF  sql_retcode = 0
    THEN
        BEGIN
        IF  cmd in [ ut_show, ut_show_cmdline]
        THEN
            u05fetch_show (term, protfile, snd_packet,
                  sql_ref, show_msg, pfkey, rcv_packet, sql_retcode)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut02get_cold_warm_state (VAR term : tut_terminal;
            VAR protfile        : tut_vf_fileref;
            snd_packet          : tsp1_packet_ptr;
            VAR sql_ref         : tsp00_Int4;
            VAR cold_warm_state : database_state;
            VAR rcv_packet      : tsp1_packet_ptr;
            VAR sql_retcode     : tsp00_Int2);
 
BEGIN
cold_warm_state := db_stateIsAdmin;
u05packet_init (snd_packet);
u05nameto_packet (utn_diagnose, snd_packet);
u05nameto_packet (utn_is_admin, snd_packet);
s26finish_part (snd_packet, snd_packet^.sp1_segm.sp1p_part);
u02send (term, protfile, snd_packet, sql_ref, suppress_wrong_mode_msg, false,
      rcv_packet, sql_retcode);
IF  sql_retcode = 0
THEN
    cold_warm_state := db_stateIsAdmin
ELSE
    BEGIN
    sql_retcode     := 0;
    cold_warm_state := db_stateIsOnline;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut02last_menu (VAR term  : tut_terminal;
            VAR protfile       : tut_vf_fileref;
            snd_packet         : tsp1_packet_ptr;
            write_time         : boolean;
            VAR cmd            : util_cmd_type;
            VAR last_menu      : util_menu_type;
            VAR pfkey          : tut_pfkey);
 
VAR
      select_menu   : util_menu_type;
 
BEGIN
select_menu := last_menu;
(* PTS 1104396 JA 1999-10-28 *)
CASE select_menu OF
    utmenu_diag:
        BEGIN
        ut02diagnose_menu (term, snd_packet, cmd, last_menu, pfkey);
        IF  (cmd <> ut_none) AND (pfkey = pf_none)
        THEN
            u05cmdwrite_prot (protfile, term.blankline,
                  write_time, snd_packet)
        (*ENDIF*) 
        END;
    OTHERWISE
        BEGIN
        last_menu := utmenu_none;
        cmd       := ut_none
        END
    END
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut02release (VAR term  : tut_terminal;
            VAR protfile     : tut_vf_fileref;
            snd_packet       : tsp1_packet_ptr;
            VAR sql_ref      : tsp00_Int4;
            adbs_session     : boolean;
            write_time       : boolean;
            VAR is_connected : boolean;
            VAR rcv_packet   : tsp1_packet_ptr;
            VAR sql_retcode  : tsp00_Int2);
 
BEGIN
sql_retcode := 0;
u05packet_init (snd_packet);
IF  adbs_session
THEN
    snd_packet^.sp1_segm.sp1c_mess_type := sp1m_dbs;
(*ENDIF*) 
u05c20to_packet (cmd_commit_rel, snd_packet);
s26finish_part (snd_packet, snd_packet^.sp1_segm.sp1p_part);
u05cmdwrite_prot (protfile, term.blankline, write_time, snd_packet);
u02send (term, protfile, snd_packet, sql_ref, display_msg,
      NOT c_req_only, rcv_packet, sql_retcode);
IF  sql_retcode = 0
THEN
    BEGIN
    is_connected := false;
    sqlarelease (sql_ref);
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut02verify_catalog_show (VAR term : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            snd_packet      : tsp1_packet_ptr;
            VAR sql_ref     : tsp00_Int4;
            VAR cmd         : util_cmd_type;
            VAR pfkey       : tut_pfkey;
            VAR rcv_packet  : tsp1_packet_ptr;
            VAR sql_retcode : tsp00_Int2);
 
CONST
      c_check_cmd           = true;
      c_integrity_violation = 300;
      c_show_cmd            = 'SHOW DATA FOR DOMAIN';
      c_write_time          = true;
 
VAR
      i       : integer;
      ln_len  : integer;
      sql_cmd : tsp00_C20;
      ln      : tsp00_Line;
 
BEGIN
IF  sql_retcode = c_integrity_violation
THEN
    BEGIN
    ln := term.blankline;
    WITH rcv_packet^.sp1_segm DO
        BEGIN
        ln_len := sp1p_buf_len;
        SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (ln),
              @sp1p_buf, 1, @ln, 1, ln_len)
        END;
    (*ENDWITH*) 
    t09putmsg (term, ln,
          NOT c_warning, NOT c_immediate_displ);
    t12write_prot (protfile, ln, ln_len, i);
    u05packet_init (snd_packet);
    sql_retcode := 0;
    cmd         := ut_show;
    sql_cmd     := c_show_cmd;
    WITH snd_packet^.sp1_segm DO
        BEGIN
        FOR i := 1 TO sizeof (sql_cmd) DO
            sp1p_buf [i] := sql_cmd [i];
        (*ENDFOR*) 
        sp1p_buf_len := mxsp_c20;
        END;
    (*ENDWITH*) 
    s26finish_part (snd_packet, snd_packet^.sp1_segm.sp1p_part);
    ut02execute_cmd (term, protfile, snd_packet, sql_ref,
          NOT c_write_time, NOT c_check_cmd, cmd, pfkey, rcv_packet, sql_retcode)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut02warm_functions (VAR term : tut_terminal;
            VAR protfile       : tut_vf_fileref;
            snd_packet         : tsp1_packet_ptr;
            VAR sql_ref        : tsp00_Int4;
            VAR is_selected    : boolean;
            VAR is_continue_ln : boolean;
            write_time         : boolean;
            use_cmd_line       : boolean;
            VAR ln             : tsp00_Line;
            VAR cmd            : util_cmd_type;
            VAR username       : tsp00_KnlIdentifier;
            VAR password       : tsp00_CryptPw;
            VAR serverdb       : tsp00_DbName;
            VAR last_menu      : util_menu_type;
            VAR pfkey          : tut_pfkey;
            VAR rcv_packet     : tsp1_packet_ptr;
            VAR sql_retcode    : tsp00_Int2);
 
CONST
      (* HELP MENU *)
      x_diagnose      =  1;
      x_diag_switch   =  3;
      (* --- column 2 --- *)
      x_diag_extract  =  8;
      x_diag_typedata = 10;
      x_exit          = 13;
 
VAR
      selected       : integer;
      tok1           : tsp00_Name;
      tok2           : tsp00_Name;
      tok3           : tsp00_Name;
      tok4           : tsp00_Name;
      tok5           : tsp00_Name;
      tok6           : tsp00_Name;
      blank_progname : tsp00_C20;
      msg            : tut_c20_array;
 
BEGIN
pfkey        := pf_none;
cmd          := ut_invalid;
is_selected  := false;
IF  NOT use_cmd_line
THEN
    BEGIN
    t09msgheader (term, msg30_primary_function, true);
    t09setpf1 (term, cut_pfkey_none);
    FOR selected := 1 TO 20 DO
        msg [ selected] := bsp_c20;
    (*ENDFOR*) 
    msg [x_diagnose     ] := msg_diagnose;
    msg [x_diag_switch  ] := msg_diag_switch;
    msg [x_diag_extract ] := msg_diag_extract;
    msg [x_diag_typedata] := msg_diag_typedata;
    msg [x_exit         ] := cmd_exit;
    t09getmenu (term, x_exit, cut_protected, NOT c_upper_case,
          msg, selected, pfkey, ln, is_selected);
    t09msgheader (term, bsp_c30, true)
    END;
(*ENDIF*) 
IF  pfkey <> pf_none
THEN
    BEGIN
    IF  last_menu = utmenu_exit
    THEN
        BEGIN
        last_menu   := utmenu_none;
        selected    := x_exit;
        is_selected := true
        END
    ELSE
        BEGIN
        ut02display_leave_msg (term);
        last_menu := utmenu_exit;
        cmd       := ut_none
        END
    (*ENDIF*) 
    END
ELSE
    BEGIN
    last_menu := utmenu_none;
    IF  is_selected
    THEN
        is_continue_ln := false
    ELSE
        BEGIN
        u05getcommand (term, protfile, snd_packet, write_time, ln,
              is_continue_ln, pfkey);
        u05gettoken (snd_packet, tok1, tok2, tok3, tok4, tok5, tok6);
        IF  (tok1 = utn_exit) OR (tok1 = utn_exit2)
        THEN
            BEGIN
            selected    := x_exit;
            is_selected := true
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  is_selected
THEN
    BEGIN
    ln := term.blankline;
    CASE selected OF
        x_diagnose:
            BEGIN
            ut02diagnose_menu (term, snd_packet, cmd, last_menu, pfkey);
            (* without command prompting *)
            is_selected := false
            END;
        x_diag_switch:
            BEGIN
            cmd := ut_none;
            u05switch (term, protfile, snd_packet, sql_ref,
                  bsp_c20, pfkey, sql_retcode)
            END;
        x_diag_extract:
            BEGIN
            cmd := ut_standard;
            u05diagextract (term, snd_packet, pfkey);
            END;
        x_diag_typedata:
            BEGIN
            cmd            := ut_none;
            blank_progname := bsp_c20;
            x03typedata (term, protfile, blank_progname, snd_packet, sql_ref, pfkey)
            END;
        x_exit :
            cmd := ut_exit;
        OTHERWISE
            cmd := ut_invalid
        END
    (*ENDCASE*) 
    END
ELSE
    (* without menu selection ==> scan input line *)
    BEGIN
    IF  tok1 = utn_diagnose
    THEN
        BEGIN
        IF  (tok2 = utn_catalog) AND (tok3 = bsp_name) AND NOT use_cmd_line
        THEN
            BEGIN
            cmd := ut_none;
            u10diagnose_catalog (term, protfile, snd_packet,
                  rcv_packet, sql_ref, username, password, pfkey);
            IF  pfkey <> pf_cancel
            THEN
                u05header (term, program_name, serverdb, username)
            (*ENDIF*) 
            END
        ELSE
            IF  (tok2 = utn_vtrace) OR ((tok2  = utn_switch) AND (tok3  = utn_layer))
            THEN
                cmd := ut_standard;
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE (* tok1 <> diagnose *)
        BEGIN
        IF  (tok1 = utn_show) AND ((tok2<> utn_utility) OR (tok3 <> utn_version))
        THEN
            cmd := ut_show_cmdline
        ELSE
            IF  (tok1 = utn_verify) AND (tok2 <> bsp_name)
            THEN
                cmd := ut_verify_catalog
            ELSE
                IF  tok1 = utn_vtrace
                THEN
                    cmd := ut_dbs
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (pfkey <> pf_none) OR (cmd = ut_none)
    THEN
        ln := term.blankline
    ELSE
        ut02cmd_line_handling (term, protfile, snd_packet, sql_ref,
              write_time, use_cmd_line, ln, tok1, tok2, tok3, cmd,
              last_menu, pfkey, sql_retcode)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
