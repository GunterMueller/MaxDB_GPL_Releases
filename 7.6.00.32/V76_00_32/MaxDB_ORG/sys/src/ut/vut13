/* @lastChanged: "1998-03-06 12:00"
 
 * @filename:   vut13
 * @purpose:    "UT_diag_scheme_4"
 * @release:    7.1.0.0
 * @see:        "-.-"
 *
 * @Copyright (c) 1998-2005 SAP AG"
 */
 
.tt 1 $SAP$LiveCache$VUT13$
.tt 3 $$UT_diag_scheme_4$1999-11-01$
 
.nf
 
 .nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 1998-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
***********************************************************
 
Module  : UT_diag_scheme_4
 
Define  :
 
        PROCEDURE
              u13baserec (VAR term : tut_terminal;
                    VAR s        : tak_systembuffer;
                    protect_mode : char;
                    VAR modified : boolean;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              u13columnset (colsetname : tsp00_C20;
                    VAR colset     : tak_columnset;
                    VAR mask       : tut_term_mask;
                    index          : integer;
                    VAR modified   : boolean;
                    VAR ok         : tut_ok_array);
 
        PROCEDURE
              u13constraintrec (VAR term : tut_terminal;
                    VAR s        : tak_systembuffer;
                    VAR protfile : tut_vf_fileref;
                    protect_mode : char;
                    VAR modified : boolean;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              u13constraintnamerec (VAR term : tut_terminal;
                    VAR s        : tak_systembuffer;
                    protect_mode : char;
                    VAR modified : boolean;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              u13defaultrec (VAR term : tut_terminal;
                    VAR s        : tak_systembuffer;
                    VAR protfile : tut_vf_fileref;
                    protect_mode : char;
                    VAR modified : boolean;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              u13domainrec (VAR term : tut_terminal;
                    VAR s        : tak_systembuffer;
                    protect_mode : char;
                    VAR modified : boolean;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              u13privrec (VAR term : tut_terminal;
                    VAR s        : tak_systembuffer;
                    protect_mode : char;
                    VAR modified : boolean;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              u13tablerefrec (VAR term : tut_terminal;
                    VAR s        : tak_systembuffer;
                    protect_mode : char;
                    VAR modified : boolean;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              u13alterdaterec (VAR term : tut_terminal;
                    VAR s        : tak_systembuffer;
                    protect_mode : char;
                    VAR modified : boolean;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              u13stack_entry (VAR st_entry : tgg00_StackEntry;
                    VAR mask       : tut_term_mask;
                    mask_index     : integer;
                    VAR ok         : tut_ok_array;
                    VAR modified   : boolean);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              TA_buf_display : VTA14;
 
        PROCEDURE
              t14editbuf (VAR term : tut_terminal;
                    VAR protfile   : tut_vf_fileref;
                    VAR buf        : tsp00_Buf;
                    buf_size       : tsp00_Int4;
                    buf_offset     : tsp00_Int4;
                    VAR file_pos   : tut_file_pos;
                    edit_scan      : tut_diag_scan;
                    VAR is_saved   : boolean;
                    VAR pfkey      : tut_pfkey);
 
      ------------------------------ 
 
        FROM
              UT_diag_scheme_2 : VUT11;
 
        PROCEDURE
              u11c6in_out (VAR c6 : tsp00_C6;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11c64in_out (VAR out : tsp00_C64;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR modified : boolean);
 
        PROCEDURE
              u11filename_in_out (VAR fn : tgg00_Filename;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11eopin_out (VAR st_entry : tgg00_StackEntry;
                    VAR eop      : tgg00_StackOpType;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11etype_in_out (VAR etype  : tgg00_StackEntryType;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11datatype_in_out (VAR datatype : tsp00_DataType;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11maskerror (VAR term : tut_terminal;
                    VAR ok        : tut_ok_array;
                    VAR mask      : tut_term_mask;
                    mask_size     : integer;
                    VAR pfkey     : tut_pfkey);
 
        PROCEDURE
              u11setin_out (VAR c2 : tsp00_C2;
                    VAR mask     : tut_term_mask;
                    mask_size    : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11setc256_in_out (VAR c256set : tsp00_C256;
                    VAR mask      : tut_term_mask;
                    mask_size     : integer;
                    pos          : integer;
                    len          : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11newpage (VAR term : tut_terminal;
                    msgheader : tsp00_C20);
 
        PROCEDURE
              u11boolean_in_out (VAR in_out_bool : boolean;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11int1in_out (VAR int1 : tsp00_Uint1;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11int2in_out (VAR int2 : tsp00_Int2;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11int4in_out (VAR int4 : tsp00_Int4;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11surrogate_in_out (VAR surrogate : tgg00_Surrogate;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11namein_out (VAR out : tsp00_Name;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR modified : boolean);
 
        PROCEDURE
              u11c1inout (VAR c1  : char;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11c2inout (VAR c2 : tsp00_C2;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11tabkind_in_out (VAR kind : tgg00_TableKind;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
      ------------------------------ 
 
        FROM
              TA_terminal_IO : VTA09;
 
        PROCEDURE
              t09putmsg (VAR term     : tut_terminal;
                    VAR msg           : tsp00_Line;
                    is_warning        : boolean;
                    immediate_display : boolean);
 
        PROCEDURE
              t09mask (VAR t09    : tut_terminal;
                    count_names   : integer;
                    mask_size     : integer;
                    VAR mask_spec : tut_term_mask;
                    return_pf_key : boolean;
                    VAR pfkey     : tut_pfkey);
 
        PROCEDURE
              t09newscreen_page (VAR t09 : tut_terminal);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              t14editbuf;
 
              tsp00_MoveObj tsp00_Buf
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ThomasA
.sp
.cp 3
Created : 1986-01-17
.sp
.cp 3
.sp
.cp 3
Release :      Date : 1999-11-01
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      msg20_tablerefrec       = '   TABLEREF RECORD  ';
      msg20_constraintrec     = ' CONSTRAINT RECORD  ';
      msg20_constrainnamerec  = ' CONSTRAINT NAME REC';
      msg20_defaultrec        = '   DEFAULT RECORD   ';
      msg20_domainrec         = '    DOMAIN RECORD   ';
      msg20_baserec           = '    BASE RECORD     ';
      msg20_alterdaterec      = '  ALTERDATE RECORD  ';
      msg20_privrec           = '  PRIVILEGE RECORD  ';
 
 
(*------------------------------*) 
 
PROCEDURE
      ut13columninfo (VAR term : tut_terminal;
            VAR col_info   : tak00_columninfo;
            VAR index      : tsp00_Int2;
            VAR mask       : tut_term_mask;
            VAR modified   : boolean;
            VAR ok         : tut_ok_array);
 
VAR
      is_changed : boolean;
      datafrac   : tsp00_Uint1;
      tabno      : tsp00_Uint1;
      nextind    : tsp00_Uint1;
      ix         : integer;
      shiftout   : char;
      datalen    : tsp00_Int2;
      inoutlen   : tsp00_Int2;
      datatype   : tsp00_DataType;
 
      ccolset_map_c2 : RECORD
            CASE boolean OF
                true :
                    (propset : tak00_colpropset);
                false :
                    (c2 : tsp00_C2);
                END;
            (*ENDCASE*) 
 
      colname     : tsp00_C64;
      stack_entry : tgg00_StackEntry;
 
BEGIN
mask[ 1 ].msg  := 'COLUMNINDEX    (HEX)';
mask[ 1 ].msg_in_attr[ 2 ] := cut_unprotected;
is_changed := false;
u11int2in_out (index,
      mask, 1, ok[ 1 ], is_changed);
mask[2].msg            := bsp_c20;
mask[2].msg_in_attr[2] := cut_protected;
IF  NOT is_changed
THEN
    BEGIN
    mask[3].msg  := 'CCOLPROPSET    (BIN)';
    ccolset_map_c2.propset := col_info.ccolpropset;
    u11setin_out (ccolset_map_c2.c2,
          mask, 3, ok[3], modified);
    col_info.ccolpropset := ccolset_map_c2.propset;
    mask[4].msg  := 'CEXTCOLNO           ';
    u11int2in_out (col_info.cextcolno, mask, 4, ok[4], modified);
    mask[5].msg  := 'CRECCOLNO           ';
    u11int2in_out (col_info.creccolno, mask, 5, ok[5], modified);
    mask[6].msg  := 'CTABNO         (HEX)';
    tabno := col_info.ctabno;
    u11int1in_out (tabno,
          mask, 6, ok[6], modified);
    col_info.ctabno := tabno;
    mask[7].msg  := 'CDATATYPE           ';
    datatype       := col_info.cdatatyp;
    u11datatype_in_out (datatype, mask, 7, ok[7], modified);
    col_info.cdatatyp := datatype;
    datalen := col_info.cdatalen;
    mask[8].msg  := 'CDATALEN       (HEX)';
    u11int2in_out (datalen,
          mask, 8, ok[8], modified);
    col_info.cdatalen := datalen;
    inoutlen := col_info.cinoutlen;
    mask[9].msg  := 'CINOUTLEN      (HEX)';
    u11int2in_out (inoutlen,
          mask, 9, ok[9], modified);
    col_info.cinoutlen := inoutlen;
    datafrac := col_info.cdatafrac;
    mask[10].msg  := 'CDATAFRAC      (HEX)';
    u11int1in_out (datafrac,
          mask, 10, ok[10], modified);
    col_info.cdatafrac := datafrac;
    mask[11].msg  := 'CNEXTIND       (HEX)';
    nextind := col_info.cnextind;
    u11int1in_out (nextind,
          mask, 11, ok[11], modified);
    col_info.cnextind := nextind;
    mask[12].msg  := 'CSHIFTOUT      (HEX)';
    shiftout := col_info.cshiftoutchar;
    u11c1inout (shiftout,
          mask, 12, ok[ 12], modified);
    col_info.cshiftoutchar  := shiftout;
    stack_entry := col_info.ccolstack;
    u13stack_entry (stack_entry, mask, 12, ok, modified);
    col_info.ccolstack := stack_entry;
    mask[19].msg              := 'CCOLUMNN            ';
    mask[19].msg_in_attr[ 2 ] := cut_protected;
    mask[19].in_c256          := term.blankfilename;
    colname                   := bsp_c64;
    FOR ix := 1 TO ord(col_info.ccolumnn_len) DO
        colname[ix] := col_info.ccolumnn[ix];
    (*ENDFOR*) 
    u11c64in_out (colname, mask, 19, modified)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut13pack_priv (VAR s        : tak_systembuffer;
            VAR new_priv    : tak_privilege;
            VAR packed_priv : tak_privilege);
 
CONST
      min_priv_rec_info_len = 8; (* segmentid + 2 Bytes Filler +      *)
 
VAR
      i          : tak_priv_descriptors;
      priv_index : tak_priv_descriptors;
 
BEGIN
packed_priv.priv_all_set       := new_priv.priv_all_set;
packed_priv.priv_all_grant_set := new_priv.priv_all_grant_set;
packed_priv.priv_col_exist     := [  ];
packed_priv.priv_filler        := false;
s.b_sl := cak_sysbufferoffset + SURROGATE_MXGG00 + min_priv_rec_info_len;
IF  (s.syskey.sentrytyp = cak_eprivuser) OR
    (s.syskey.sentrytyp = cak_eprivproc)
THEN
    s.b_sl := s.b_sl + SURROGATE_MXGG00;
(*ENDIF*) 
priv_index  := priv_col_sel;
FOR i := priv_col_sel TO priv_col_upd_grant DO
    BEGIN
    IF  i in new_priv.priv_col_exist
    THEN
        BEGIN
        packed_priv.priv_col[ priv_index ] :=
              new_priv.priv_col[ i ];
        packed_priv.priv_col_exist := new_priv.priv_col_exist + [ i ];
        IF  priv_index < priv_col_upd_grant
        THEN
            priv_index     := succ(priv_index);
        (*ENDIF*) 
        s.b_sl := s.b_sl + 32
        END;
    (*ENDIF*) 
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut13unpack_priv (VAR packed_priv : tak_privilege;
            VAR unpacked_priv : tak_privilege);
 
VAR
      i : tak_priv_descriptors;
      j : tak_priv_descriptors;
 
BEGIN
unpacked_priv.priv_all_set       := packed_priv.priv_all_set;
unpacked_priv.priv_all_grant_set := packed_priv.priv_all_grant_set;
unpacked_priv.priv_col_exist     := [  ];
j := priv_col_sel;
FOR i := priv_col_sel TO priv_col_upd_grant DO
    unpacked_priv.priv_col[ i ] := [  ];
(*ENDFOR*) 
FOR i := priv_col_sel TO priv_col_upd_grant DO
    BEGIN
    IF  i in packed_priv.priv_col_exist
    THEN
        BEGIN
        unpacked_priv.priv_col[ i ] := packed_priv.priv_col[ j ];
        unpacked_priv.priv_col_exist :=
              unpacked_priv.priv_col_exist + [ i ];
        IF  j < priv_col_upd_grant
        THEN
            j := succ(j)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u13baserec (VAR term : tut_terminal;
            VAR s        : tak_systembuffer;
            protect_mode : char;
            VAR modified : boolean;
            VAR pfkey    : tut_pfkey);
 
CONST
      c_init_index     = -10;
      c_max_prop_index = 4;
 
VAR
      dummy           : boolean;
      index_modified  : boolean;
      pos             : integer;
      is_input        : boolean;
      mask_cnt        : integer;
      name_cnt        : integer;
      i,j             : integer;
      move_len        : integer;
      col_cnt         : integer;
      index           : tsp00_Int2;
      ok              : tut_ok_array;
      mask            : tut_term_mask;
      tablename       : tsp00_C64;
 
      lset_map_c2 : RECORD
            CASE boolean OF
                true  :
                    (linkset    : tgg00_Linkset);
                false :
                    (c2         : tsp00_C2);
                END;
            (*ENDCASE*) 
 
 
      pset_map_c2 : RECORD
            CASE boolean OF
                true  :
                    (privset    : tak00_PrivilegeSet);
                false :
                    (c2         : tsp00_C2);
                END;
            (*ENDCASE*) 
 
 
      pcset_map_c2 : RECORD
            CASE boolean OF
                true  :
                    (privcolset : tak_priv_desc);
                false :
                    (c2         : tsp00_C2);
                END;
            (*ENDCASE*) 
 
 
      sqlmode_map_int1 : RECORD
            CASE boolean OF
                true :
                    (sqlmode : tsp00_SqlMode);
                false :
                    (int1 : tsp00_Uint1);
                END;
            (*ENDCASE*) 
 
 
      distinct_map_int1 : RECORD
            CASE boolean OF
                true :
                    (dist : tgg04_Distinct);
                false :
                    (int1 : tsp00_Uint1);
                END;
            (*ENDCASE*) 
 
      colinfo : tak00_columninfo;
 
      colpos_info : ARRAY[1..256] OF RECORD
            cp_pos : integer;
            cp_len : integer;
      END;
 
 
BEGIN
dummy     := true;
is_input  := false;
FOR i := 1 TO cut_mask_items DO
    BEGIN
    mask[ i ].upper_case       := true;
    mask[ i ].msg_in_attr[ 1 ] := cut_protected;
    mask[ i ].msg_in_attr[ 2 ] := protect_mode;
    mask[ i ].code_input       := false;
    END;
(*ENDFOR*) 
term.use_pfkeys := true;
col_cnt         := 0;
IF  s.sbase.btablekind <> tsynonym
THEN
    BEGIN
    IF  s.syskey.slinkage = cak_init_linkage
    THEN
        BEGIN
        pos   := sizeof (s.sbase) -
              sizeof (s.sbase.bcolumn) -
              sizeof (s.sbase.bptr) -
              sizeof (s.sbase.btablen) + 1;
        tablename := bsp_c64;
        FOR i := 1 TO ord (s.ssysbuf[pos]) DO
            BEGIN
            pos          := pos + 1;
            tablename[i] := s.ssysbuf[pos];
            END;
        (*ENDFOR*) 
        pos := pos + 1;
        END
    ELSE
        pos := cak_sysbufferoffset +
              sizeof (s.sbase.bsegmentid) + 1;
    (*ENDIF*) 
    REPEAT
        move_len := sizeof (tak00_columninfo) -
              sizeof (tsp00_KnlIdentifier) +
              ord (s.ssysbuf[pos - 1 +
              sizeof (tak00_columninfo) - sizeof (tsp00_KnlIdentifier)]);
        col_cnt                     := col_cnt + 1;
        colpos_info[col_cnt].cp_pos := pos;
        colpos_info[col_cnt].cp_len := move_len;
        pos                         := pos + move_len;
    UNTIL
        pos > s.b_sl;
    (*ENDREPEAT*) 
    END;
(*ENDIF*) 
index := c_init_index;
u11newpage (term, msg20_baserec);
REPEAT
    t09newscreen_page(term);
    index_modified := false;
    IF  NOT is_input
    THEN
        BEGIN
        FOR i := 1 TO cut_mask_items DO
            BEGIN
            mask[ i ].in_c256 := term.blankfilename;
            ok  [ i ]         := true
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    IF  index = c_init_index
    THEN
        BEGIN
        mask[ 1 ].msg  := 'RECORD LENGTH  (HEX)';
        mask[ 1 ].msg_in_attr[ 2 ] := protect_mode;
        u11int2in_out (s.b_sl,
              mask, 1, ok[ 1 ], modified);
        mask[ 2 ].msg  := 'TABLESURROGATE (HEX)';
        u11surrogate_in_out (s.syskey.sauthid,
              mask, 2, ok[ 2 ], modified);
        mask[ 3 ].msg  := 'ENTRYTYPE      (HEX)';
        u11c2inout (s.syskey.sentrytyp,
              mask, 3, ok[ 3 ], modified);
        mask[ 4 ].msg  := 'LINKAGE        (HEX)';
        u11c2inout (s.syskey.slinkage,
              mask, 4, ok[ 4 ], modified);
        IF  s.sbase.btablekind = tsynonym
        THEN
            BEGIN
            mask[ 5 ].msg  := 'SYNSEGMENTID   (HEX)';
            u11c2inout (s.ssynonym.synsegmentid,
                  mask, 5, ok[ 5 ], modified);
            mask[ 6 ].msg  := 'SYN_MAXCOL     (HEX)';
            u11int2in_out (s.ssynonym.syn_maxcol,
                  mask, 6, ok[ 6 ], modified);
            mask[ 7 ].msg  := 'SYN_TABLEKIND       ';
            u11tabkind_in_out (s.ssynonym.syn_tablekind,
                  mask, 7, ok[ 7 ], modified);
            mask[ 8 ].msg  := 'SYN_TABLEID    (HEX)';
            u11surrogate_in_out (s.ssynonym.syn_tableid,
                  mask, 8, ok[ 8 ], modified);
            mask[ 9 ].msg  := 'SYN_TIME       (HEX)';
            u11int4in_out (s.ssynonym.syn_time,
                  mask, 9, ok[ 9 ], modified);
            mask[ 10 ].msg  := 'SYN_DATE       (HEX)';
            u11int4in_out (s.ssynonym.syn_date,
                  mask, 10, ok[ 10 ], modified);
            mask[ 11 ].msg  := 'SYN_AUTHID     (HEX)';
            u11surrogate_in_out (s.ssynonym.syn_authid,
                  mask, 11, ok[ 11 ], modified);
            mask[12].msg  := 'SYN_TABLEN          ';
            pos := sizeof (tak_synonymrecord) -
                  sizeof (s.ssynonym.syn_tablen) + 1;
            tablename := bsp_c64;
            FOR i := 1 TO ord (s.ssysbuf[pos]) DO
                BEGIN
                pos := pos + 1;
                tablename[i] := s.ssysbuf[pos]
                END;
            (*ENDFOR*) 
            mask[12].in_c256        := term.blankfilename;
            mask[12].msg_in_attr[2] := cut_protected;
            u11c64in_out (tablename, mask, 12, dummy);
            name_cnt := 11;
            mask_cnt := 12
            END
        ELSE
            BEGIN
            mask[ 5 ].msg  := 'BSEGMENTID     (HEX)';
            u11c2inout (s.sbase.bsegmentid,
                  mask, 5, ok[ 5 ], modified);
            mask[ 6 ].msg  := 'BFIRSTINDEX    (HEX)';
            u11int2in_out (s.sbase.bfirstindex,
                  mask, 6, ok[ 6 ], modified);
            mask[ 7 ].msg  := 'BLASTINDEX     (HEX)';
            u11int2in_out (s.sbase.blastindex,
                  mask, 7, ok[ 7 ], modified);
            name_cnt := 7;
            mask_cnt := 7
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (index = c_init_index + 1) AND (s.syskey.slinkage = cak_init_linkage)
    THEN
        BEGIN
        IF  NOT is_input
        THEN
            mask[ 8 ].in_c256 := term.blankfilename;
        (*ENDIF*) 
        ut13treeid (s.sbase.btreeid, mask, 0, 0, ok, modified);
        name_cnt := 6;
        mask_cnt := 7
        END;
    (*ENDIF*) 
    IF  (index = c_init_index + 2) AND (s.syskey.slinkage = cak_init_linkage)
    THEN
        BEGIN
        mask[ 1 ].msg  := 'BAUTHID        (HEX)';
        mask[ 1 ].msg_in_attr[ 2 ] := protect_mode;
        u11surrogate_in_out (s.sbase.bauthid,
              mask, 1, ok[ 1 ], modified);
        mask[ 2 ].msg  := 'BTABLEKIND          ';
        u11tabkind_in_out (s.sbase.btablekind,
              mask, 2, ok[ 2 ], modified);
        mask[ 3 ].msg  := 'BLINKEXIST     (BIN)';
        lset_map_c2.linkset  := s.sbase.blinkexist;
        lset_map_c2.c2[ 2 ]  := chr(0);
        u11setin_out (lset_map_c2.c2,
              mask, 3, ok[ 3 ], modified);
        s.sbase.blinkexist := lset_map_c2.linkset;
        mask[ 4 ].msg  := 'BMAXCOL        (HEX)';
        u11int2in_out (s.sbase.bmaxcol,
              mask, 4, ok[ 4 ], modified);
        mask[ 5 ].msg  := 'BMAXRECLEN     (HEX)';
        u11int2in_out (s.sbase.bmaxreclen,
              mask, 5, ok[ 5 ], modified);
        mask[ 6 ].msg  := 'BKEYCOLCOUNT   (HEX)';
        u11int2in_out (s.sbase.bkeycolcount,
              mask, 6, ok[ 6 ], modified);
        mask[ 7 ].msg  := 'BLENFIXEDCOL   (HEX)';
        u11int2in_out (s.sbase.blenfixedcol,
              mask, 7, ok[ 7 ], modified);
        mask[ 8 ].msg  := 'BVARCOLCOUNT   (HEX)';
        u11int2in_out (s.sbase.bvarcolcount,
              mask, 8, ok[ 8 ], modified);
        mask[ 9 ].msg  := 'BCNTDROPCOLT   (HEX)';
        u11int2in_out (s.sbase.bcntdropcol,
              mask, 9, ok[ 9 ], modified);
        mask[ 10 ].msg  := 'BSTRINGCOUNT   (HEX)';
        u11int2in_out (s.sbase.bstringcount,
              mask, 10, ok[ 10 ], modified);
        mask[ 11 ].msg  := 'BDATECREATE    (HEX)';
        u11int4in_out (s.sbase.bdatecreate,
              mask, 11, ok[ 11 ], modified);
        mask[ 12 ].msg  := 'BTIMECREATE    (HEX)';
        u11int4in_out (s.sbase.btimecreate,
              mask, 12, ok[ 12 ], modified);
        mask[ 13 ].msg  := 'BUPDSTATDATE   (HEX)';
        u11int4in_out (s.sbase.bupdstatdate,
              mask, 13, ok[ 13 ], modified);
        mask[ 14 ].msg  := 'BUPDSTATTIME   (HEX)';
        u11int4in_out (s.sbase.bupdstattime,
              mask, 14, ok[ 14 ], modified);
        pset_map_c2.privset  := s.sbase.bpriv_all_set;
        pset_map_c2.c2[ 2 ]  := chr(0);
        mask[ 15 ].msg  := 'BPRIV_ALL_SET  (BIN)';
        u11setin_out (pset_map_c2.c2,
              mask, 15, ok[ 15 ], modified);
        s.sbase.bpriv_all_set    := pset_map_c2.privset;
        pcset_map_c2.privcolset  := s.sbase.bpriv_col_exist;
        pcset_map_c2.c2[ 2 ]     := chr(0);
        mask[ 16 ].msg  := 'BPRIV_COL_EXIST(BIN)';
        u11setin_out (pcset_map_c2.c2,
              mask, 16, ok[ 16], modified);
        s.sbase.bpriv_col_exist := pcset_map_c2.privcolset;
        mask[ 17 ].msg    := 'BTABLEN             ';
        mask[ 17 ].in_c256 := term.blankfilename;
        mask[ 17 ].msg_in_attr[2] := cut_protected;
        u11c64in_out (tablename, mask, 17, dummy);
        name_cnt := 16;
        mask_cnt := 17
        END;
    (*ENDIF*) 
    IF  (index = c_init_index + 3) AND (s.syskey.slinkage = cak_init_linkage)
    THEN
        BEGIN
        mask[ 1 ].msg  := 'BUNLOADED           ';
        mask[ 1 ].msg_in_attr[ 2 ] := protect_mode;
        u11boolean_in_out (s.sbase.bunloaded,
              mask, 1, ok[ 1 ], modified);
        mask[ 2 ].msg  := 'BINDEXEXIST         ';
        u11boolean_in_out (s.sbase.bindexexist,
              mask, 2, ok[ 2 ], modified);
        mask[ 3 ].msg  := 'BPAGES         (HEX)';
        u11int4in_out (s.sbase.bpages,
              mask, 3, ok[ 3 ], modified);
        mask[ 4 ].msg  := 'BROWS          (HEX)';
        u11int4in_out (s.sbase.brows,
              mask, 4, ok[ 4 ], modified);
        mask[ 5 ].msg  := 'BAVGROWLEN     (HEX)';
        u11int2in_out (s.sbase.bavgrowlen,
              mask, 5, ok[ 5 ], modified);
        mask[ 6 ].msg  := 'BLASTKEYIND    (HEX)';
        u11int2in_out (s.sbase.blastkeyind,
              mask, 6, ok[ 6 ], modified);
        mask[ 7 ].msg  := 'BV_LEVEL       (HEX)';
        u11int1in_out (s.sbase.bv_level,
              mask, 7, ok[ 7 ], modified);
        mask[ 8 ].msg  := 'BV_TABCOUNT    (HEX)';
        u11int1in_out (s.sbase.bv_tabcount,
              mask, 8, ok[ 8 ], modified);
        mask[ 9 ].msg  := 'BFIRSTCOLIND   (HEX)';
        u11int2in_out (s.sbase.bfirstcolind,
              mask, 9, ok[ 9 ], modified);
        mask[ 10 ].msg  := 'BV_TABLEKIND        ';
        u11tabkind_in_out (s.sbase.bv_tablekind,
              mask, 10, ok[ 10 ], modified);
        mask[ 11 ].msg  := 'BV_CHECKOPT         ';
        u11boolean_in_out (s.sbase.bv_checkopt,
              mask, 11, ok[ 11 ], modified);
        mask[ 12 ].msg  := 'BV_QUALEXIST        ';
        u11boolean_in_out (s.sbase.bv_qualexist,
              mask, 12, ok[ 12 ], modified);
        mask[ 13 ].msg  := 'BV_DISTINCT         ';
        distinct_map_int1.dist := s.sbase.bv_distinct;
        u11int1in_out (distinct_map_int1.int1,
              mask, 13, ok[ 13 ], modified);
        s.sbase.bv_distinct := distinct_map_int1.dist;
        mask[ 14 ].msg  := 'BV_VIEWLIST         ';
        u11boolean_in_out (s.sbase.bv_viewlist,
              mask, 14, ok[ 14 ], modified);
        mask[ 15 ].msg  := 'BDEF_STAMP          ';
        u11boolean_in_out (s.sbase.bdef_stamp,
              mask, 15, ok[ 15 ], modified);
        mask[ 16 ].msg  := 'BLONGVARCOLCNT (HEX)';
        u11int1in_out (s.sbase.blongvarcolcnt,
              mask, 16, ok[ 16 ], modified);
        name_cnt := 16;
        mask_cnt := 16
        END;
    (*ENDIF*) 
    IF  (index = c_init_index + c_max_prop_index) AND (s.syskey.slinkage = cak_init_linkage)
    THEN
        BEGIN
        mask[ 1 ].msg  := 'BSQLMODE            ';
        sqlmode_map_int1.sqlmode := s.sbase.bsqlmode;
        mask[ 1 ].msg_in_attr[ 2 ] := protect_mode;
        u11int1in_out (sqlmode_map_int1.int1,
              mask, 1, ok[ 1 ], modified);
        s.sbase.bsqlmode := sqlmode_map_int1.sqlmode;
        mask[ 3 ].msg  := 'BNAMED_CONSTR       ';
        mask[ 3 ].msg_in_attr[ 2 ] := protect_mode;
        u11int2in_out (s.sbase.bnamed_constr,
              mask, 3, ok[ 3 ], modified);
        mask[ 4 ].msg := 'BALTERDATE          ';
        mask[ 4 ].msg_in_attr[ 2 ] := protect_mode;
        u11int4in_out (s.sbase.balterdate,
              mask, 4, ok[ 4 ], modified);
        mask[ 5 ].msg := 'BALTERTIME          ';
        mask[ 5 ].msg_in_attr[ 2 ] := protect_mode;
        u11int4in_out (s.sbase.baltertime,
              mask, 5, ok[ 5 ], modified);
        mask[ 6 ].msg := 'BSAMPLE             ';
        mask[ 6 ].msg_in_attr[ 2 ] := protect_mode;
        u11int4in_out (s.sbase.bsample,
              mask, 6, ok[ 6 ], modified);
        name_cnt := 6;
        mask_cnt := 6
        END;
    (*ENDIF*) 
    IF  (s.sbase.btablekind <> tsynonym) AND (index > 0)
    THEN
        BEGIN (* column info *)
        IF  s.syskey.slinkage = cak_init_linkage
        THEN
            i := index
        ELSE
            i := 1;
        (*ENDIF*) 
        j := index;
        SAPDB_PascalForcedMove (s.b_sl, sizeof (colinfo),
              @s, colpos_info[i].cp_pos, @colinfo, 1, colpos_info[i].cp_len);
        ut13columninfo (term, colinfo, index, mask, modified, ok);
        IF  modified
        THEN
            SAPDB_PascalForcedMove (sizeof (colinfo), s.b_sl, @colinfo, 1,
                  @s, colpos_info[i].cp_pos, colpos_info[i].cp_len);
        (*ENDIF*) 
        index_modified := index <> j;
        name_cnt       := 18;
        mask_cnt       := 19
        END;
    (*ENDIF*) 
    IF  NOT is_input
    THEN
        BEGIN
        t09newscreen_page(term);
        t09mask (term, name_cnt, mask_cnt, mask, true, pfkey);
        t09putmsg (term, term.blankline, false, false);
        CASE pfkey OF
            pf_up, pf_down, pf_end, pf_run :
                is_input := true;
            pf_cancel :
                modified := false;
            OTHERWISE;
            END;
        (*ENDCASE*) 
        END
    ELSE
        BEGIN
        u11maskerror (term, ok, mask, cut_mask_items, pfkey);
        IF  ok[ 1 ]
        THEN
            CASE pfkey OF
                pf_up :
                    BEGIN
                    IF  s.sbase.btablekind <> tsynonym
                    THEN
                        IF  (index = 1) AND
                            (s.syskey.slinkage = cak_init_linkage)
                        THEN
                            index := c_init_index + c_max_prop_index
                        ELSE
                            index := index - 1;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    pfkey := pf_none
                    END;
                pf_down :
                    BEGIN
                    IF  s.sbase.btablekind <> tsynonym
                    THEN
                        index := index + 1;
                    (*ENDIF*) 
                    pfkey := pf_none
                    END;
                pf_run :
                    pfkey := pf_none;
                OTHERWISE ;
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        is_input := false
        END;
    (*ENDIF*) 
    IF  index < c_init_index
    THEN
        index := c_init_index
    ELSE
        IF  s.sbase.btablekind <> tsynonym
        THEN
            IF  (index > c_init_index + c_max_prop_index) AND (index < 0)
            THEN
                index := 1
            ELSE
                IF  index > col_cnt
                THEN
                    index := c_init_index;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
UNTIL
    (pfkey <> pf_none) AND NOT is_input;
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u13columnset (colsetname : tsp00_C20;
            VAR colset     : tak_columnset;
            VAR mask       : tut_term_mask;
            index          : integer;
            VAR modified   : boolean;
            VAR ok         : tut_ok_array);
 
VAR
      is_changed  : boolean;
      i           : integer;
      pos         : integer;
      c256         : tsp00_C256;
 
BEGIN
is_changed   := false;
SAPDB_PascalForcedMove (sizeof(colset), sizeof(c256), @colset, 1, @c256, 1, sizeof(colset));
pos := 1;
FOR i := 1 TO 8 DO
    BEGIN
    mask[ index+i ].msg := colsetname;
    colsetname := bsp_c20;
    u11setc256_in_out (c256, mask, index+i,
          pos, 4, ok[ index+i ], is_changed);
    pos := pos + 4
    END;
(*ENDFOR*) 
IF  is_changed
THEN
    BEGIN
    modified := true;
    SAPDB_PascalForcedMove (sizeof (c256), sizeof (colset), @c256,
          1, @colset, 1, sizeof (colset))
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u13constraintrec (VAR term : tut_terminal;
            VAR s        : tak_systembuffer;
            VAR protfile : tut_vf_fileref;
            protect_mode : char;
            VAR modified : boolean;
            VAR pfkey    : tut_pfkey);
 
VAR
      dummy           : boolean;
      index_modified  : boolean;
      is_input        : boolean;
      mask_cnt        : integer;
      name_cnt        : integer;
      i               : integer;
      move_len        : integer;
      index           : tsp00_Int2;
      file_pos        : tut_file_pos;
      ok              : tut_ok_array;
      mask            : tut_term_mask;
      buf             : tsp00_Buf;
 
BEGIN
dummy     := true;
is_input  := false;
FOR i := 1 TO cut_mask_items DO
    BEGIN
    mask[ i ].upper_case       := true;
    mask[ i ].msg_in_attr[ 1 ] := cut_protected;
    mask[ i ].msg_in_attr[ 2 ] := protect_mode;
    mask[ i ].code_input       := false;
    END;
(*ENDFOR*) 
term.use_pfkeys := true;
index                := 0;
u11newpage (term, msg20_constraintrec);
REPEAT
    t09newscreen_page(term);
    index_modified := false;
    IF  NOT is_input
    THEN
        BEGIN
        FOR i := 1 TO cut_mask_items DO
            BEGIN
            mask[ i ].in_name := bsp_name;
            ok  [ i ] := true
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    IF  index = 0
    THEN
        BEGIN
        mask[ 1 ].msg  := 'RECORD LENGTH  (HEX)';
        mask[ 1 ].msg_in_attr[ 2 ] := protect_mode;
        u11int2in_out (s.b_sl,
              mask, 1, ok[ 1 ], modified);
        mask[ 2 ].msg  := 'TABLESURROGATE (HEX)';
        u11surrogate_in_out (s.syskey.sauthid,
              mask, 2, ok[ 2 ], modified);
        mask[ 3 ].msg  := 'ENTRYTYPE      (HEX)';
        u11c2inout (s.syskey.sentrytyp,
              mask, 3, ok[ 3 ], modified);
        mask[ 4 ].msg  := 'LINKAGE        (HEX)';
        u11c2inout (s.syskey.slinkage,
              mask, 4, ok[ 4 ], modified);
        mask[ 5 ].msg  := 'CSEGMENTID     (HEX)';
        u11c2inout (s.sconstraint.csegmentid,
              mask, 5, ok[ 5 ], modified);
        mask[ 6 ].msg  := 'CSTACK_CNT     (HEX)';
        u11int2in_out (s.sconstraint.cstack_cnt,
              mask, 6, ok[ 6 ], modified);
        mask[ 7 ].msg  := 'CVALUE_POS     (HEX)';
        u11int2in_out (s.sconstraint.cvalue_pos,
              mask, 7, ok[ 7 ], modified);
        mask[ 8 ].msg  := 'CFUNCTION           ';
        u11boolean_in_out (s.sconstraint.cfunction,
              mask, 8, ok[ 8 ], modified);
        mask[ 9 ].msg  := 'COLDRANGE           ';
        u11boolean_in_out (s.sconstraint.coldrange,
              mask, 9, ok[ 9 ], modified);
        mask[ 10 ].msg  := 'CCNAME              ';
        u11namein_out (s.sconstraint.ccname, mask, 10, modified);
        IF  NOT is_input
        THEN
            FOR i := 12 TO 19 DO
                mask[ i ].in_c256 := term.blankfilename;
            (*ENDFOR*) 
        (*ENDIF*) 
        u13columnset ('CCOLSET        (BIN)', s.sconstraint.ccolset,
              mask, 11, modified, ok);
        name_cnt := 10;
        mask_cnt := 19
        END;
    (*ENDIF*) 
    IF  (index >= 1) AND (index <= s.sconstraint.cstack_cnt)
    THEN
        BEGIN
        mask[ 1 ].msg_in_attr[ 2 ] := cut_unprotected;
        mask[ 1 ].msg  := 'INDEX ENTRY    (HEX)';
        u11int2in_out (index,
              mask, 1, ok[ 1 ], index_modified);
        IF  NOT index_modified
        THEN
            BEGIN
            u13stack_entry (s.sconstraint.cstack[ index ], mask, 1,
                  ok, modified);
            name_cnt := 6;
            mask_cnt := 6
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  index > s.sconstraint.cstack_cnt
    THEN
        BEGIN
        move_len := s.b_sl - s.sconstraint.cvalue_pos + 1;
        SAPDB_PascalForcedMove (sizeof (s), sizeof (buf),
              @s, s.sconstraint.cvalue_pos, @buf, 1, move_len);
        WITH file_pos DO
            BEGIN
            utfp_pages_per_block := 1;
            utfp_block_no        := cut_nil_block_no;
            utfp_page_no         := 0
            END;
        (*ENDWITH*) 
        t14editbuf (term, protfile, buf, move_len, 0,
              file_pos, [ ], modified, pfkey);
        IF  modified
        THEN
            SAPDB_PascalForcedMove (sizeof (buf), sizeof (s), @buf, 1,
                  @s, s.sconstraint.cvalue_pos, move_len);
        (*ENDIF*) 
        is_input := true;
        IF  pfkey = pf_end
        THEN
            BEGIN
            pfkey := pf_none;
            index := 0
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  NOT is_input
    THEN
        BEGIN
        t09newscreen_page(term);
        t09mask (term, name_cnt, mask_cnt, mask, true, pfkey);
        t09putmsg (term, term.blankline, false, false);
        CASE pfkey OF
            pf_up, pf_down, pf_end, pf_run :
                is_input := true;
            pf_cancel :
                modified := false;
            OTHERWISE;
            END;
        (*ENDCASE*) 
        END
    ELSE
        BEGIN
        u11maskerror (term, ok, mask, cut_mask_items, pfkey);
        IF  ok[ 1 ]
        THEN
            CASE pfkey OF
                pf_up :
                    BEGIN
                    index := index - 1;
                    pfkey := pf_none
                    END;
                pf_down :
                    BEGIN
                    index := index + 1;
                    pfkey := pf_none
                    END;
                pf_run :
                    pfkey := pf_none;
                OTHERWISE ;
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        is_input := false
        END;
    (*ENDIF*) 
    IF  (index < 0) OR
        (index > s.sconstraint.cstack_cnt + 1)
    THEN
        index := 0;
    (*ENDIF*) 
UNTIL
    (pfkey <> pf_none) AND NOT is_input;
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u13constraintnamerec (VAR term : tut_terminal;
            VAR s        : tak_systembuffer;
            protect_mode : char;
            VAR modified : boolean;
            VAR pfkey    : tut_pfkey);
 
CONST
      max_constraintname_mask = 6;
 
VAR
      is_input    : boolean;
      mask_cnt    : integer;
      i           : integer;
      ok          : tut_ok_array;
      mask        : tut_term_mask;
 
BEGIN
u11newpage (term, msg20_constrainnamerec);
is_input := false;
REPEAT
    IF  NOT is_input
    THEN
        FOR i := 1 TO max_constraintname_mask DO
            BEGIN
            mask[ i ].upper_case       := true;
            mask[ i ].msg_in_attr[ 1 ] := cut_protected;
            mask[ i ].msg_in_attr[ 2 ] := protect_mode;
            mask[ i ].in_name          := bsp_name;
            mask[ i ].code_input       := false;
            ok  [ i ] := true
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    mask[ 1 ].msg  := 'RECORD LENGTH  (HEX)';
    u11int2in_out (s.b_sl,
          mask, 1, ok[ 1 ], modified);
    mask[ 2 ].msg  := 'TABLESURROGATE (HEX)';
    u11surrogate_in_out (s.syskey.sauthid,
          mask, 2, ok[ 2 ], modified);
    mask[ 3 ].msg  := 'ENTRYTYPE      (HEX)';
    u11c2inout (s.syskey.sentrytyp, mask, 3, ok[ 3 ], modified);
    mask[ 4 ].msg  := 'LINKAGE        (HEX)';
    u11c2inout (s.syskey.slinkage, mask, 4, ok[ 4 ], modified);
    mask[ 5 ].msg  := 'KEY2                ';
    (*u11namein_out (s.sconstrname.cnkey2, mask, 5, modified);*)
    mask[ 6 ].msg  := 'SEGMENTID      (HEX)';
    u11c2inout (s.sconstrname.cnsegmentid,
          mask, 6, ok[ 6 ], modified);
    mask_cnt := max_constraintname_mask;
    IF  NOT is_input
    THEN
        BEGIN
        t09newscreen_page(term);
        t09mask (term, mask_cnt, mask_cnt, mask, true, pfkey);
        t09putmsg (term, term.blankline, false, false);
        is_input := true
        END
    ELSE
        BEGIN
        u11maskerror (term, ok, mask, max_constraintname_mask, pfkey);
        is_input := false
        END;
    (*ENDIF*) 
UNTIL
    ((pfkey <> pf_none) AND (NOT is_input)) OR
    (protect_mode = cut_protected);
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u13defaultrec (VAR term : tut_terminal;
            VAR s        : tak_systembuffer;
            VAR protfile : tut_vf_fileref;
            protect_mode : char;
            VAR modified : boolean;
            VAR pfkey    : tut_pfkey);
 
CONST
      max_default_mask = 7;
 
VAR
      is_input    : boolean;
      len         : char;
      i           : integer;
      index       : integer;
      move_len    : integer;
      file_pos    : tut_file_pos;
      ok          : tut_ok_array;
      mask        : tut_term_mask;
      buf         : tsp00_Buf;
 
BEGIN
u11newpage (term, msg20_defaultrec);
FOR i := 1 TO max_default_mask DO
    BEGIN
    mask[ i ].upper_case       := true;
    mask[ i ].msg_in_attr[ 1 ] := cut_protected;
    mask[ i ].msg_in_attr[ 2 ] := protect_mode;
    mask[ i ].code_input       := false;
    END;
(*ENDFOR*) 
index    := 0;
is_input := false;
REPEAT
    t09newscreen_page(term);
    IF  NOT is_input
    THEN
        BEGIN
        FOR i := 1 TO max_default_mask DO
            BEGIN
            mask[ i ].in_name := bsp_name;
            ok  [ i ] := true
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    IF  index = 0
    THEN
        BEGIN
        mask[ 1 ].msg  := 'RECORD LENGTH  (HEX)';
        u11int2in_out (s.b_sl,
              mask, 1, ok[ 1 ], modified);
        mask[ 2 ].msg  := 'SURROGATE      (HEX)';
        u11surrogate_in_out (s.syskey.sauthid,
              mask, 2, ok[ 2 ], modified);
        mask[ 3 ].msg  := 'ENTRYTYPE      (HEX)';
        u11c2inout (s.syskey.sentrytyp,
              mask, 3, ok[ 3 ], modified);
        mask[ 4 ].msg  := 'LINKAGE        (HEX)';
        u11c2inout (s.syskey.slinkage,
              mask, 4, ok[ 4 ], modified);
        mask[ 5 ].msg  := 'DFSEGMENTID    (HEX)';
        u11c2inout (s.sdefault.dfsegment_id,
              mask, 5, ok[ 5 ], modified);
        mask[ 6 ].msg  := 'DEFAULTFUNCTION(HEX)';
        u11int2in_out (s.sdefault.dfdefault_function,
              mask, 6, ok[ 6 ], modified);
        mask[ 7 ].msg  := 'VALUE LEN      (HEX)';
        len := s.sdefault.dfvalues[ 1 ];
        u11c1inout (len,
              mask, 7, ok[ 7 ], modified);
        s.sdefault.dfvalues[ 1 ] := len
        END
    ELSE
        BEGIN
        move_len := ord (s.sdefault.dfvalues[ 1 ]);
        SAPDB_PascalForcedMove (sizeof (s.sdefault.dfvalues), sizeof (buf),
              @s.sdefault.dfvalues, 2, @buf, 1, move_len);
        WITH file_pos DO
            BEGIN
            utfp_pages_per_block := 1;
            utfp_block_no        := cut_nil_block_no;
            utfp_page_no         := 0
            END;
        (*ENDWITH*) 
        t14editbuf (term, protfile, buf, move_len, 0,
              file_pos, [ ], modified, pfkey);
        IF  modified
        THEN
            SAPDB_PascalForcedMove (sizeof (buf), sizeof (s.sdefault.dfvalues), @buf, 1,
                  @s.sdefault.dfvalues, 2, move_len);
        (*ENDIF*) 
        is_input := true;
        IF  pfkey = pf_end
        THEN
            pfkey := pf_none;
        (*ENDIF*) 
        index := 0
        END;
    (*ENDIF*) 
    IF  NOT is_input
    THEN
        BEGIN
        t09newscreen_page(term);
        t09mask (term,
              max_default_mask, max_default_mask, mask, true, pfkey);
        t09putmsg (term, term.blankline, false, false);
        CASE pfkey OF
            pf_up, pf_down, pf_end, pf_run :
                is_input := true;
            pf_cancel :
                modified := false;
            OTHERWISE;
            END;
        (*ENDCASE*) 
        END
    ELSE
        BEGIN
        u11maskerror (term, ok, mask, max_default_mask, pfkey);
        IF  ok[ 1 ]
        THEN
            CASE pfkey OF
                pf_up :
                    BEGIN
                    index := index - 1;
                    pfkey := pf_none
                    END;
                pf_down :
                    BEGIN
                    index := index + 1;
                    pfkey := pf_none
                    END;
                pf_run :
                    pfkey := pf_none;
                OTHERWISE ;
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        is_input := false
        END;
    (*ENDIF*) 
UNTIL
    (pfkey <> pf_none) AND NOT is_input
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u13domainrec (VAR term : tut_terminal;
            VAR s        : tak_systembuffer;
            protect_mode : char;
            VAR modified : boolean;
            VAR pfkey    : tut_pfkey);
 
CONST
      max_domain_mask = 20;
 
VAR
      is_input    : boolean;
      i           : integer;
      index       : tsp00_Int2;
      mask_count  : integer;
      ok          : tut_ok_array;
      mask        : tut_term_mask;
 
BEGIN
u11newpage (term, msg20_domainrec);
FOR i := 1 TO max_domain_mask DO
    BEGIN
    mask[ i ].upper_case       := true;
    mask[ i ].msg_in_attr[ 1 ] := cut_protected;
    mask[ i ].msg_in_attr[ 2 ] := protect_mode;
    mask[ i ].code_input       := false;
    END;
(*ENDFOR*) 
index    := 0;
is_input := false;
REPEAT
    t09newscreen_page(term);
    IF  NOT is_input
    THEN
        BEGIN
        FOR i := 1 TO max_domain_mask DO
            BEGIN
            mask[ i ].in_name := bsp_name;
            ok  [ i ] := true
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    IF  index = 0
    THEN
        BEGIN
        mask[ 1 ].msg  := 'RECORD LENGTH  (HEX)';
        u11int2in_out (s.b_sl,
              mask, 1, ok[ 1 ], modified);
        mask[ 2 ].msg  := 'SURROGATE      (HEX)';
        u11surrogate_in_out (s.syskey.sauthid,
              mask, 2, ok[ 2 ], modified);
        mask[ 3 ].msg  := 'ENTRYTYPE      (HEX)';
        u11c2inout (s.syskey.sentrytyp,
              mask, 3, ok[ 3 ], modified);
        mask[ 4 ].msg  := 'LINKAGE        (HEX)';
        u11c2inout (s.syskey.slinkage,
              mask, 4, ok[ 4 ], modified);
        mask[ 5 ].msg  := 'DOM_SEGMENTID  (HEX)';
        u11c2inout (s.sdomain.dom_segmentid,
              mask, 5, ok[ 5 ], modified);
        mask[ 6 ].msg  := 'DOM_FILLER          ';
        u11int1in_out (s.sdomain.dom_filler,
              mask, 6, ok[ 6 ], modified);
        mask[ 7 ].msg  := 'DOM_CONSTRAINT      ';
        u11boolean_in_out (s.sdomain.dom_constraint,
              mask, 7, ok[ 7 ], modified);
        mask_count := 7
        END
    ELSE
        BEGIN
        ut13columninfo (term, s.sdomain.dom_colinfo,
              index, mask, modified, ok);
        mask_count := max_domain_mask
        END;
    (*ENDIF*) 
    IF  NOT is_input
    THEN
        BEGIN
        t09newscreen_page(term);
        t09mask (term,
              mask_count, mask_count, mask, true, pfkey);
        t09putmsg (term, term.blankline, false, false);
        CASE pfkey OF
            pf_up, pf_down, pf_end, pf_run :
                is_input := true;
            pf_cancel :
                modified := false;
            OTHERWISE;
            END;
        (*ENDCASE*) 
        END
    ELSE
        BEGIN
        u11maskerror (term, ok, mask, max_domain_mask, pfkey);
        IF  ok[ 1 ]
        THEN
            CASE pfkey OF
                pf_up :
                    BEGIN
                    index := index - 1;
                    pfkey := pf_none
                    END;
                pf_down :
                    BEGIN
                    index := index + 1;
                    pfkey := pf_none
                    END;
                pf_run :
                    pfkey := pf_none;
                OTHERWISE ;
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        is_input := false
        END;
    (*ENDIF*) 
    IF  (index < 0) OR (index > 1)
    THEN
        index := 0
    (*ENDIF*) 
UNTIL
    (pfkey <> pf_none) AND NOT is_input
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u13privrec (VAR term : tut_terminal;
            VAR s        : tak_systembuffer;
            protect_mode : char;
            VAR modified : boolean;
            VAR pfkey    : tut_pfkey);
 
CONST
      max_priv_mask = 16;
 
VAR
      dummy           : boolean;
      is_input        : boolean;
      mask_cnt        : integer;
      name_cnt        : integer;
      i               : integer;
      index           : tsp00_Int2;
      ok              : tut_ok_array;
      priv            : tak_privilege;
      mask            : tut_term_mask;
 
      pset_map_c2, paset_map_c2 : RECORD
            CASE boolean OF
                true  :
                    (privset    : tak00_PrivilegeSet);
                false :
                    (c2         : tsp00_C2);
                END;
            (*ENDCASE*) 
 
 
      pcset_map_c2 : RECORD
            CASE boolean OF
                true  :
                    (privcolset : tak_priv_desc);
                false :
                    (c2         : tsp00_C2);
                END;
            (*ENDCASE*) 
 
 
BEGIN
dummy     := true;
is_input  := false;
FOR i := 1 TO max_priv_mask DO
    BEGIN
    mask[ i ].upper_case       := true;
    mask[ i ].msg_in_attr[ 1 ] := cut_protected;
    mask[ i ].msg_in_attr[ 2 ] := protect_mode;
    mask[ i ].code_input       := false;
    END;
(*ENDFOR*) 
index                := 0;
u11newpage (term, msg20_privrec);
IF  s.syskey.sentrytyp = cak_epriv
THEN
    ut13unpack_priv (s.spriv.pr_priv, priv)
ELSE
    ut13unpack_priv (s.sprivuser.pru_priv, priv);
(*ENDIF*) 
REPEAT
    t09newscreen_page(term);
    IF  NOT is_input
    THEN
        BEGIN
        FOR i := 1 TO max_priv_mask DO
            BEGIN
            mask[ i ].in_name := bsp_name;
            ok  [ i ] := true
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    IF  index = 0
    THEN
        BEGIN
        mask[ 1 ].msg  := 'RECORD LENGTH  (HEX)';
        mask[ 1 ].msg_in_attr[ 2 ] := protect_mode;
        u11int2in_out (s.b_sl,
              mask, 1, ok[ 1 ], modified);
        mask[ 2 ].msg  := 'TABLESURROGATE (HEX)';
        u11surrogate_in_out (s.syskey.sauthid,
              mask, 2, ok[ 2 ], modified);
        mask[ 3 ].msg  := 'ENTRYTYPE      (HEX)';
        u11c2inout (s.syskey.sentrytyp,
              mask, 3, ok[ 3 ], modified);
        mask[ 4 ].msg  := 'LINKAGE        (HEX)';
        u11c2inout (s.syskey.slinkage,
              mask, 4, ok[ 4 ], modified);
        mask[ 5 ].msg  := 'USERSURROGATE  (HEX)';
        u11surrogate_in_out (s.syskey.sauthid,
              mask, 5, ok[ 5 ], modified);
        i := 5;
        IF  s.syskey.sentrytyp = cak_eprivuser
        THEN
            BEGIN
            mask[ 6 ].msg  := 'GRANTOR        (HEX)';
            u11surrogate_in_out (s.syskey.sauthid,
                  mask, 6, ok[ 6 ], modified);
            i := 6
            END;
        (*ENDIF*) 
        mask[ i+1 ].msg  := 'PR_SEGMENTID   (HEX)';
        u11c2inout (s.spriv.pr_segmentid,
              mask, i+1, ok[ i+1 ], modified);
        mask[ i+2 ].msg  := 'PR_FILLER      (HEX)';
        u11c2inout (s.spriv.pr_filler,
              mask, i+2, ok[ i+2 ], modified);
        pset_map_c2.privset  := priv.priv_all_set;
        pset_map_c2.c2[ 2 ]  := chr(0);
        mask[ i+3 ].msg  := 'PRIV_ALL_SET   (BIN)';
        u11setin_out (pset_map_c2.c2,
              mask, i+3, ok[ i+3 ], modified);
        priv.priv_all_set := pset_map_c2.privset;
        paset_map_c2.privset  := priv.priv_all_grant_set;
        paset_map_c2.c2[ 2 ]  := chr(0);
        mask[ i+4 ].msg  := 'PRIV_ALL_GRANT (BIN)';
        u11setin_out (paset_map_c2.c2,
              mask, i+4, ok[ i+4 ], modified);
        priv.priv_all_grant_set := paset_map_c2.privset;
        pcset_map_c2.privcolset  := priv.priv_col_exist;
        pcset_map_c2.c2[ 2 ]     := chr(0);
        mask[ i+5 ].msg  := 'PRIV_COL_EXIST (BIN)';
        u11setin_out (pcset_map_c2.c2,
              mask, i+5, ok[ i+5 ], modified);
        priv.priv_col_exist := pcset_map_c2.privcolset;
        mask[ i+6 ].msg  := 'BRIVFILLER          ';
        u11boolean_in_out (s.sbase.bunloaded,
              mask, i+6, ok[ i+6 ], modified);
        name_cnt := i + 6;
        mask_cnt := name_cnt
        END;
    (*ENDIF*) 
    IF  index = 1
    THEN
        BEGIN
        IF  NOT is_input
        THEN
            FOR i := 1 TO max_priv_mask DO
                mask[ i ].in_c256 := term.blankfilename;
            (*ENDFOR*) 
        (*ENDIF*) 
        u13columnset ('PRIV_SEL_SET   (BIN)',
              priv.priv_sel_set, mask, 0, modified, ok);
        u13columnset ('PRIV_UPD_SET   (BIN)',
              priv.priv_upd_set, mask, 8, modified, ok);
        name_cnt := 0;
        mask_cnt := max_priv_mask
        END;
    (*ENDIF*) 
    IF  index = 2
    THEN
        BEGIN
        IF  NOT is_input
        THEN
            FOR i := 1 TO max_priv_mask DO
                mask[ i ].in_c256 := term.blankfilename;
            (*ENDFOR*) 
        (*ENDIF*) 
        u13columnset ('PRIV_GRANT_SEL (BIN)',
              priv.priv_grant_sel_set, mask, 0, modified, ok);
        u13columnset ('PRIV_GRANT_UPD (BIN)',
              priv.priv_grant_upd_set, mask, 8, modified, ok);
        name_cnt := 0;
        mask_cnt := max_priv_mask
        END;
    (*ENDIF*) 
    IF  NOT is_input
    THEN
        BEGIN
        t09newscreen_page(term);
        t09mask (term, name_cnt, mask_cnt, mask, true, pfkey);
        t09putmsg (term, term.blankline, false, false);
        CASE pfkey OF
            pf_up, pf_down, pf_end, pf_run :
                is_input := true;
            pf_cancel :
                modified := false;
            OTHERWISE;
            END;
        (*ENDCASE*) 
        END
    ELSE
        BEGIN
        u11maskerror (term, ok, mask, max_priv_mask, pfkey);
        IF  ok[ 1 ]
        THEN
            CASE pfkey OF
                pf_up :
                    BEGIN
                    IF  index = 0
                    THEN
                        index := 2
                    ELSE
                        index := index - 1;
                    (*ENDIF*) 
                    pfkey := pf_none
                    END;
                pf_down :
                    BEGIN
                    IF  index = 2
                    THEN
                        index := 0
                    ELSE
                        index := index + 1;
                    (*ENDIF*) 
                    pfkey := pf_none
                    END;
                pf_run :
                    pfkey := pf_none;
                OTHERWISE ;
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        is_input := false
        END;
    (*ENDIF*) 
UNTIL
    (pfkey <> pf_none) AND NOT is_input;
(*ENDREPEAT*) 
IF  modified
THEN
    IF  s.syskey.sentrytyp = cak_epriv
    THEN
        ut13pack_priv (s, priv, s.spriv.pr_priv)
    ELSE
        ut13pack_priv (s, priv, s.sprivuser.pru_priv);
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u13stack_entry (VAR st_entry : tgg00_StackEntry;
            VAR mask       : tut_term_mask;
            mask_index     : integer;
            VAR ok         : tut_ok_array;
            VAR modified   : boolean);
 
VAR
      c : char;
 
BEGIN
mask[ mask_index+1 ].msg  := 'ENTRY TYPE          ';
u11etype_in_out (st_entry.etype,
      mask, mask_index+1, ok[ mask_index+1 ], modified);
CASE st_entry.etype OF
    st_func, st_build_in_func :
        BEGIN
        END;
    st_output, st_rec_output, st_output_join, st_output_build_rec :
        BEGIN
        END;
    OTHERWISE
        BEGIN
        mask[ mask_index+2 ].msg  := 'ENTRY EOP           ';
        u11eopin_out (st_entry, st_entry.eop,
              mask, mask_index+2, ok[ mask_index+2 ], modified);
        END;
    END;
(*ENDCASE*) 
mask[ mask_index+3 ].msg  := 'EPOS           (HEX)';
u11int2in_out (st_entry.epos,
      mask, mask_index+3, ok[ mask_index+3 ], modified);
mask[ mask_index+4 ].msg  := 'ELEN_VAR       (HEX)';
u11int2in_out (st_entry.elen_var,
      mask, mask_index+4, ok[ mask_index+4 ], modified);
mask[ mask_index+5 ].msg  := 'ECOL_TAB(1)    (HEX)';
c := st_entry.ecol_tab[ 1 ];
u11c1inout (c,
      mask, mask_index+5, ok[ mask_index+5 ], modified);
st_entry.ecol_tab[ 1 ] := c;
mask[ mask_index+6 ].msg  := 'ECOL_TAB(2)    (HEX)';
c := st_entry.ecol_tab[ 2 ];
u11c1inout (c,
      mask, mask_index+6, ok[ mask_index+6 ], modified);
st_entry.ecol_tab[ 2 ] := c
END;
 
(*------------------------------*) 
 
PROCEDURE
      u13tablerefrec (VAR term : tut_terminal;
            VAR s        : tak_systembuffer;
            protect_mode : char;
            VAR modified : boolean;
            VAR pfkey    : tut_pfkey);
 
CONST
      max_tableref_mask = 11;
 
VAR
      is_input    : boolean;
      mask_cnt    : integer;
      i           : integer;
      ok          : tut_ok_array;
      mask        : tut_term_mask;
 
BEGIN
u11newpage (term, msg20_tablerefrec);
is_input := false;
REPEAT
    IF  NOT is_input
    THEN
        FOR i := 1 TO max_tableref_mask DO
            BEGIN
            mask[ i ].upper_case       := true;
            mask[ i ].msg_in_attr[ 1 ] := cut_protected;
            mask[ i ].msg_in_attr[ 2 ] := protect_mode;
            mask[ i ].in_name          := bsp_name;
            mask[ i ].code_input       := false;
            ok  [ i ] := true
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    mask[ 1 ].msg  := 'RECORD LENGTH  (HEX)';
    u11int2in_out (s.b_sl,
          mask, 1, ok[ 1 ], modified);
    mask[ 2 ].msg  := 'USERSURROGATE  (HEX)';
    u11surrogate_in_out (s.syskey.sauthid,
          mask, 2, ok[ 2 ], modified);
    mask[ 3 ].msg  := 'ENTRYTYPE      (HEX)';
    u11c2inout (s.syskey.sentrytyp, mask, 3, ok[ 3 ], modified);
    mask[ 4 ].msg  := 'LINKAGE        (HEX)';
    u11c2inout (s.syskey.sentrytyp, mask, 4, ok[ 4 ], modified);
    mask[ 5 ].msg  := 'TABLENAME           ';
    u11namein_out (s.syskey.stablen, mask, 5, modified);
    mask[ 6 ].msg  := 'RSEGMENTID     (HEX)';
    u11c2inout (s.stableref.rsegmentid,
          mask, 6, ok[ 6 ], modified);
    mask[ 7 ].msg  := 'RSYSTABLE      (HEX)';
    u11boolean_in_out (s.stableref.rsystable,
          mask, 7, ok[ 7 ], modified);
    mask[ 8 ].msg  := 'RFILLER        (HEX)';
    u11boolean_in_out (s.stableref.rfiller,
          mask, 8, ok[ 8 ], modified);
    mask[ 9 ].msg := 'RTABLEKIND          ';
    u11tabkind_in_out (s.stableref.rtablekind,
          mask, 9, ok[ 9 ], modified);
    mask[ 10 ].msg  := 'RUNDEFBYTE          ';
    u11boolean_in_out (s.stableref.rundefbyte,
          mask, 10, ok[ 10 ], modified);
    mask[ 11 ].msg := 'RTABLEID       (HEX)';
    u11surrogate_in_out (s.stableref.rtableid,
          mask, 11, ok[ 11 ], modified);
    mask_cnt := 11;
    IF  s.stableref.rtablekind = tsynonym
    THEN
        BEGIN
        mask[ 12 ].msg := 'RSYNID         (HEX)';
        u11surrogate_in_out (s.stableref.rsynid,
              mask, 12, ok[ 12 ], modified);
        mask_cnt := 12;
        END;
    (*ENDIF*) 
    IF  NOT is_input
    THEN
        BEGIN
        t09newscreen_page(term);
        t09mask (term, mask_cnt, mask_cnt, mask, true, pfkey);
        t09putmsg (term, term.blankline, false, false);
        is_input := true
        END
    ELSE
        BEGIN
        u11maskerror (term, ok, mask, max_tableref_mask, pfkey);
        is_input := false
        END;
    (*ENDIF*) 
UNTIL
    ((pfkey <> pf_none) AND (NOT is_input)) OR
    (protect_mode = cut_protected);
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u13alterdaterec (VAR term : tut_terminal;
            VAR s        : tak_systembuffer;
            protect_mode : char;
            VAR modified : boolean;
            VAR pfkey    : tut_pfkey);
 
CONST
      max_alterdate_mask = 9;
 
VAR
      is_input    : boolean;
      mask_cnt    : integer;
      i           : integer;
      ok          : tut_ok_array;
      mask        : tut_term_mask;
 
BEGIN
u11newpage (term, msg20_alterdaterec);
is_input := false;
REPEAT
    IF  NOT is_input
    THEN
        FOR i := 1 TO max_alterdate_mask DO
            BEGIN
            mask[ i ].upper_case       := true;
            mask[ i ].msg_in_attr[ 1 ] := cut_protected;
            mask[ i ].msg_in_attr[ 2 ] := protect_mode;
            mask[ i ].in_name          := bsp_name;
            mask[ i ].code_input       := false;
            ok  [ i ] := true
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    mask[ 1 ].msg  := 'RECORD LENGTH  (HEX)';
    u11int2in_out (s.b_sl,
          mask, 1, ok[ 1 ], modified);
    mask[ 2 ].msg  := 'TABLESURROGATE (HEX)';
    u11surrogate_in_out (s.syskey.sauthid,
          mask, 2, ok[ 2 ], modified);
    mask[ 3 ].msg  := 'ENTRYTYPE      (HEX)';
    u11c2inout (s.syskey.sentrytyp, mask, 3, ok[ 3 ], modified);
    mask[ 4 ].msg  := 'LINKAGE        (HEX)';
    u11c2inout (s.syskey.slinkage, mask, 4, ok[ 4 ], modified);
    mask[ 5 ].msg  := 'SEGMENTID      (HEX)';
    u11c2inout (s.salterdate.ad_segmentid,
          mask, 5, ok[ 5 ], modified);
    mask[ 6 ].msg  := 'CREATEDATE     (HEX)';
    u11int4in_out (s.salterdate.ad_createdate,
          mask, 6, ok[ 6 ], modified);
    mask[ 7 ].msg  := 'CREATETIME     (HEX)';
    u11int4in_out (s.salterdate.ad_createtime,
          mask, 7, ok[ 7 ], modified);
    mask[ 8 ].msg := 'ALTERDATE      (HEX)';
    u11int4in_out (s.salterdate.ad_alterdate,
          mask, 8, ok[ 8 ], modified);
    mask[ 9 ].msg  := 'ALTERTIME      (HEX)';
    u11int4in_out (s.salterdate.ad_altertime,
          mask, 9, ok[ 9 ], modified);
    mask_cnt := max_alterdate_mask;
    IF  NOT is_input
    THEN
        BEGIN
        t09newscreen_page(term);
        t09mask (term, mask_cnt, mask_cnt, mask, true, pfkey);
        t09putmsg (term, term.blankline, false, false);
        is_input := true
        END
    ELSE
        BEGIN
        u11maskerror (term, ok, mask, max_alterdate_mask, pfkey);
        is_input := false
        END;
    (*ENDIF*) 
UNTIL
    ((pfkey <> pf_none) AND (NOT is_input)) OR
    (protect_mode = cut_protected);
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut13treeid (VAR tree : tgg00_FileId;
            VAR mask       : tut_term_mask;
            mask_index     : integer;
            c256_offset     : integer;
            VAR ok         : tut_ok_array;
            VAR modified   : boolean);
 
VAR
 
      handling_map_c2 : RECORD
            CASE boolean OF
                true :
                    (handling : tgg00_HandlingSet);
                false :
                    (c2 : tsp00_C2);
                END;
            (*ENDCASE*) 
 
 
      bd_use_map_c2 : RECORD
            CASE boolean OF
                true :
                    (bd_use : tgg00_BdUseSet);
                false :
                    (c2 : tsp00_C2);
                END;
            (*ENDCASE*) 
 
 
      ft_map_c2 : RECORD
            CASE boolean OF
                true :
                    (ft : tgg00_FiletypeSet);
                false :
                    (c2 : tsp00_C2);
                END;
            (*ENDCASE*) 
 
 
BEGIN
mask[ mask_index+1 ].msg  := 'USERREF REF    (HEX)';
u11c6in_out (tree.fileUserRef_gg00.ci6_gg00,
      mask, mask_index+1, ok[ mask_index+1 ], modified);
mask[ mask_index+2 ].msg  := 'FILEVERSION    (HEX)';
u11c2inout (tree.fileVersion_gg00.ci2_gg00,
      mask, mask_index+2, ok[ mask_index+2 ], modified);
mask[ mask_index+3 ].msg  := 'ROOT           (HEX)';
u11int4in_out (tree.fileRoot_gg00,
      mask, mask_index+3, ok[ mask_index+3 ], modified);
handling_map_c2.handling := tree.fileHandling_gg00;
mask[ mask_index+4 ].msg  := 'HANDLING       (BIN)';
u11setin_out (handling_map_c2.c2,
      mask, mask_index+4, ok[ mask_index+4 ], modified);
tree.fileHandling_gg00 := handling_map_c2.handling;
bd_use_map_c2.bd_use := tree.fileBdUse_gg00;
mask[ mask_index+5 ].msg  := 'BD USE         (BIN)';
u11setin_out (bd_use_map_c2.c2,
      mask, mask_index+5, ok[ mask_index+5 ], modified);
tree.fileBdUse_gg00 := bd_use_map_c2.bd_use;
ft_map_c2.ft := tree.fileType_gg00;
mask[ mask_index+6 ].msg  := 'FILETYPE       (BIN)';
u11setin_out (ft_map_c2.c2,
      mask, mask_index+6, ok[ mask_index+6 ], modified);
mask[ mask_index+7 ].msg  := 'FN             (HEX)';
tree.fileType_gg00 := ft_map_c2.ft;
u11filename_in_out (tree.fileName_gg00,
      mask, mask_index + 7 + c256_offset,
      ok[ mask_index + 7 + c256_offset ], modified)
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
