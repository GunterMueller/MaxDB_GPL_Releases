/* @lastChanged: "1998-03-03 12:00"
 
 * @filename:   vut11
 * @purpose:    "UT_diag_scheme_2"
 * @release:    7.1.0.0
 * @see:        "-.-"
 *
 * @Copyright (c) 1998-2005 SAP AG"
 */
 
.tt 1 $SAP$LiveCache$VUT11$
.tt 3 $$UT_diag_scheme_2$2000-01-11$
 
.nf
 
 .nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 1998-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
***********************************************************
 
Module  : UT_diag_scheme_2
 
Define  :
 
        PROCEDURE
              u11datatype_in_out (
                    VAR datatype  : tsp00_DataType;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11etype_in_out (
                    VAR etype    : tgg00_StackEntryType;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11eopin_out (
                    VAR st_entry : tgg00_StackEntry;
                    VAR eop      : tgg00_StackOpType;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11filename_in_out (
                    VAR fn       : tgg00_Filename;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11newpage (
                    VAR term  : tut_terminal;
                    msgheader : tsp00_C20);
 
        PROCEDURE
              u11hexident_in_out (VAR out : tsp00_KnlIdentifier;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11hexname_in_out (
                    VAR name     : tsp00_Name;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11hexpw (
                    VAR pw  : tsp00_CryptPw;
                    VAR out : tsp00_C256);
 
        PROCEDURE
              u11boolean_in_out (
                    VAR in_out_bool : boolean;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11int1in_out (
                    VAR int1     : tsp00_Uint1;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11int2in_out (
                    VAR int2     : tsp00_Int2;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11int4in_out (
                    VAR int4     : tsp00_Int4;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11c6in_out (
                    VAR c6       : tsp00_C6;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11maskerror (
                    VAR term      : tut_terminal;
                    VAR ok        : tut_ok_array;
                    VAR mask      : tut_term_mask;
                    mask_size     : integer;
                    VAR pfkey     : tut_pfkey);
 
        PROCEDURE
              u11setin_out (
                    VAR c2       : tsp00_C2;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11setc256_in_out (
                    VAR c256set   : tsp00_C256;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    pos          : integer;
                    len          : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11surrogate_in_out (
                    VAR surrogate : tgg00_Surrogate;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11namein_out (
                    VAR out      : tsp00_Name;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR modified : boolean);
 
        PROCEDURE
              u11c64in_out (
                    VAR out      : tsp00_C64;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR modified : boolean);
 
        PROCEDURE
              u11c8surrogate_in_out (
                    VAR out      : tgg00_Surrogate;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11c1inout (
                    VAR c1       : char;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11c2inout (
                    VAR c2       : tsp00_C2;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11utkind_in_out (
                    VAR kind     : tak_usertab_descriptor;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11tabkind_in_out (
                    VAR kind     : tgg00_TableKind;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11modein_out (
                    VAR mode     : tsp1_param_opt_type;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11io_type_in_out (
                    VAR io_type  : tsp1_param_io_type;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11integer_hex (
                    val      : tsp00_Int4;
                    len      : integer;
                    VAR out  : tsp00_Name);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              UT_auxiliary_procedures : VUT05;
 
        PROCEDURE
              u05msgheader (VAR term : tut_terminal; msg : tsp00_C20);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17st1op (
                    op      : tgg00_StackOpType;
                    VAR len : integer;
                    VAR msg : tsp00_Sname);
 
        PROCEDURE
              g17st2op_func (
                    op      : tgg00_StackOpFunc;
                    VAR len : integer;
                    VAR msg : tsp00_Sname);
 
        PROCEDURE
              g17st3op_output (
                    op      : tgg00_StackOpOutput;
                    VAR len : integer;
                    VAR msg : tsp00_Sname);
 
        PROCEDURE
              g17st4op_build_in (
                    op              : tgg00_StackOpBuildIn;
                    VAR len         : integer;
                    VAR msg         : tsp00_Sname);
 
      ------------------------------ 
 
        FROM
              TA_test_procedures : VTA02;
 
        PROCEDURE
              t02name (layer : tut_debug; nam  : tsp00_Name);
 
        PROCEDURE
              t02int4 (
                    layer    : tut_debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              TA_terminal_IO : VTA09;
 
        PROCEDURE
              t09putmsg (
                    VAR term          : tut_terminal;
                    VAR msg           : tsp00_Line;
                    is_warning        : boolean;
                    immediate_display : boolean);
 
        PROCEDURE
              t09newscreen_page (VAR term : tut_terminal);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ThomasA
.sp
.cp 3
Created : 1986-01-17
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-01-11
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      true_name            = 'TRUE              ';
      false_name           = 'FALSE             ';
      ut_table_name        = 'TABLE             ';
      ut_own_table_name    = 'OWN TABLE         ';
      ut_proc_name         = 'PROCEDURE         ';
      dfixed_name          = 'FIXED             ';
      dfloat_name          = 'FLOAT             ';
      dcha_name            = 'CHAR ASCII        ';
      dchb_name            = 'CHAR BYTE         ';
      dstra_name           = 'STRING ASCII      ';
      dstrb_name           = 'STRING BYTE       ';
      ddate_name           = 'DATE              ';
      dtime_name           = 'TIME              ';
      dtimestamp_name      = 'TIMESTAMP         ';
      twithkey_name        = 'TWITHKEY          ';
      twithoutkey_name     = 'TWITHOUTKEY       ';
      tonebase_name        = 'TONEBASE          ';
      tsynonym_name        = 'TSYNONYM          ';
      tview_name           = 'TVIEW             ';
      tcomplexview_name    = 'TCOMPLEXVIEW      ';
      tdb2view_name        = 'TDB2VIEW          ';
      input_name           = 'INPUT             ';
      output_name          = 'OUTPUT            ';
      inout_name           = 'INPUT/OUTPUT      ';
      mandatory_name       = 'MANDATORY         ';
      optional_name        = 'OPTIONAL          ';
      default_name         = 'DEFAULT           ';
 
 
(*------------------------------*) 
 
PROCEDURE
      u11newpage (
            VAR term  : tut_terminal;
            msgheader : tsp00_C20);
 
BEGIN
t09newscreen_page(term);
u05msgheader (term , msgheader);
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11maskerror (
            VAR term      : tut_terminal;
            VAR ok        : tut_ok_array;
            VAR mask      : tut_term_mask;
            mask_size     : integer;
            VAR pfkey     : tut_pfkey);
 
VAR
      i   : integer;
      c20 : tsp00_C20;
      ln  : tsp00_Line;
 
BEGIN
i := 1;
WHILE i <= mask_size DO
    IF  NOT ok[ i ]
    THEN
        BEGIN
        ln  := term.blankline;
        c20 := 'INVALID INPUT :     ';
        SAPDB_PascalForcedMove (sizeof (c20), sizeof (ln), @c20, 1, @ln, 1, 16);
        SAPDB_PascalForcedMove (sizeof (c20), sizeof (ln),
              @mask[ i ].msg, 1, @ln, 17, sizeof (c20));
        t09putmsg (term, ln, true, false);
        IF  (pfkey <> pf_end) AND (pfkey <> pf_cancel)
        THEN
            pfkey := pf_none;
        (*ENDIF*) 
        i     := MAX_INT2_SP00;
        END
    ELSE
        i := succ(i);
    (*ENDIF*) 
(*ENDWHILE*) 
ok[ 1 ] := i < MAX_INT2_SP00
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11hexc6 (
            VAR c6  : tsp00_C6;
            len     : integer;
            VAR out : tsp00_C256);
 
VAR
      hex_byte : ARRAY [ 1..2 ] OF integer;
      pos      : integer;
      i        : integer;
      ln_pos   : integer;
      dec      : integer;
 
BEGIN
SAPDB_PascalForcedFill (sizeof(out), @out, 1, sizeof(out), ' ');
ln_pos := 1;
FOR pos := 1 TO len DO
    BEGIN
    dec := ord (c6[ pos ]);
    hex_byte[ 1 ] := dec DIV 16;
    hex_byte[ 2 ] := dec MOD 16;
    FOR i := 1 TO 2 DO
        BEGIN
        IF  hex_byte[ i ] > 9
        THEN
            out[ ln_pos ] := chr(ord('A')-10+ hex_byte[ i ])
        ELSE
            out[ ln_pos ] := chr (ord('0') + hex_byte[ i ]);
        (*ENDIF*) 
        ln_pos := ln_pos + 1
        END
    (*ENDFOR*) 
    END
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11hexc256 (
            VAR c256 : tsp00_C256;
            len     : integer;
            VAR out : tsp00_C256);
 
VAR
      hex_byte : ARRAY [ 1..2 ] OF integer;
      pos      : integer;
      i        : integer;
      ln_pos   : integer;
      dec      : integer;
 
BEGIN
SAPDB_PascalForcedFill (sizeof(out), @out, 1, sizeof(out), ' ');
ln_pos := 1;
FOR pos := 1 TO len DO
    BEGIN
    dec := ord (c256[ pos ]);
    hex_byte[ 1 ] := dec DIV 16;
    hex_byte[ 2 ] := dec MOD 16;
    FOR i := 1 TO 2 DO
        BEGIN
        IF  hex_byte[ i ] > 9
        THEN
            out[ ln_pos ] := chr(ord('A')-10+ hex_byte[ i ])
        ELSE
            out[ ln_pos ] := chr (ord('0') + hex_byte[ i ]);
        (*ENDIF*) 
        ln_pos := ln_pos + 1
        END
    (*ENDFOR*) 
    END
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11hexsurrogate (
            VAR surrogate : tgg00_Surrogate;
            VAR out : tsp00_Name);
 
VAR
      hex_byte : ARRAY [ 1..2 ] OF integer;
      pos      : integer;
      i        : integer;
      ln_pos   : integer;
      dec      : integer;
 
BEGIN
out    := bsp_name;
ln_pos := 1;
FOR pos := 1 TO SURROGATE_MXGG00 DO
    BEGIN
    dec := ord (surrogate[ pos ]);
    hex_byte[ 1 ] := dec DIV 16;
    hex_byte[ 2 ] := dec MOD 16;
    FOR i := 1 TO 2 DO
        BEGIN
        IF  hex_byte[ i ] > 9
        THEN
            out[ ln_pos ] := chr(ord('A')-10+ hex_byte[ i ])
        ELSE
            out[ ln_pos ] := chr (ord('0') + hex_byte[ i ]);
        (*ENDIF*) 
        ln_pos := ln_pos + 1
        END
    (*ENDFOR*) 
    END
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11hexpw (
            VAR pw  : tsp00_CryptPw;
            VAR out : tsp00_C256);
 
VAR
      hex_byte : ARRAY [ 1..2 ] OF integer;
      pos      : integer;
      i        : integer;
      ln_pos   : integer;
      dec      : integer;
 
BEGIN
SAPDB_PascalForcedFill (sizeof(out), @out, 1, sizeof(out), ' ');
ln_pos := 1;
FOR pos := 1 TO CRYPTPW_MXSP00 DO
    BEGIN
    dec := ord (pw[ pos ]);
    hex_byte[ 1 ] := dec DIV 16;
    hex_byte[ 2 ] := dec MOD 16;
    FOR i := 1 TO 2 DO
        BEGIN
        IF  hex_byte[ i ] > 9
        THEN
            out[ ln_pos ] := chr(ord('A')-10+ hex_byte[ i ])
        ELSE
            out[ ln_pos ] := chr (ord('0') + hex_byte[ i ]);
        (*ENDIF*) 
        ln_pos := ln_pos + 1
        END
    (*ENDFOR*) 
    END
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11hexc2 (
            VAR c2  : tsp00_C2;
            len     : integer;
            VAR out : tsp00_Name);
 
VAR
      hex_byte : ARRAY [ 1..2 ] OF integer;
      pos      : integer;
      i        : integer;
      ln_pos   : integer;
      dec      : integer;
 
BEGIN
out    := bsp_name;
ln_pos := 1;
FOR pos := 1 TO len DO
    BEGIN
    dec := ord (c2[ pos ]);
    hex_byte[ 1 ] := dec DIV 16;
    hex_byte[ 2 ] := dec MOD 16;
    FOR i := 1 TO 2 DO
        BEGIN
        IF  hex_byte[ i ] > 9
        THEN
            out[ ln_pos ] := chr(ord('A')-10+ hex_byte[ i ])
        ELSE
            out[ ln_pos ] := chr (ord('0') + hex_byte[ i ]);
        (*ENDIF*) 
        ln_pos := ln_pos + 1
        END
    (*ENDFOR*) 
    END
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11integer_hex (
            val      : tsp00_Int4;
            len      : integer;
            VAR out  : tsp00_Name);
 
VAR
      hex_byte : ARRAY [ 1..2 ] OF integer;
      add      : integer;
      pos      : integer;
      i        : integer;
      ln_pos   : integer;
      dec      : integer;
 
BEGIN
ln_pos  := len * 2;
out     := bsp_name;
IF  val < 0
THEN
    BEGIN
    CASE len OF
        1 :
            val := 128 + val;
        2 :
            val := MAX_INT2_SP00 + val + 1;
        4 :
            BEGIN
            (* PTS 1104704 E.Z. Compilerproblem *)
            val := val + 1;
            val := val + MAX_INT4_SP00;
            END;
        END;
    (*ENDCASE*) 
    add := 8;
    END
ELSE
    add := 0;
(*ENDIF*) 
&ifdef trace
t02int4 (debug_ut, 'value       ', val);
&endif
FOR pos := 1 TO len DO
    BEGIN
    dec           := val MOD 256;
    hex_byte[ 2 ] := dec DIV 16;
    hex_byte[ 1 ] := dec MOD 16;
    FOR i := 1 TO 2 DO
        BEGIN
        IF  hex_byte[ i ] > 9
        THEN
            out[ ln_pos ] := chr(ord('A')-10+ hex_byte[ i ])
        ELSE
            out[ ln_pos ] := chr (ord('0') + hex_byte[ i ]);
        (*ENDIF*) 
        ln_pos := ln_pos - 1
        END;
    (*ENDFOR*) 
    val := val DIV 256
    END;
(*ENDFOR*) 
&ifdef trace
t02name (debug_ut, out);
&endif
val := ord(out[ ln_pos+1 ]) - ord('0') + add;
IF  val < 10
THEN
    out[ ln_pos+1 ] := chr(ord('0') + val)
ELSE
    out[ ln_pos+1 ] := chr(ord('A') + val - 10)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11hexint_input (
            VAR hexin : tsp00_Name;
            VAR out : tsp00_Int4;
            len     : integer;
            VAR ok  : boolean);
 
VAR
      i    : integer;
      sign : integer;
      mult : integer;
      c256  : tsp00_C256;
 
BEGIN
mult := 1;
out  := 0;
u11input_hex (hexin, c256, len, ok);
IF  c256[ 1 ] > chr(127)
THEN
    BEGIN  (* construct 2 - complement *)
    FOR i := 1 TO len DO
        c256[ i ] := chr (255 - ord(c256[ i ]));
    (*ENDFOR*) 
    i := len;
    WHILE i > 0 DO
        IF  c256[ i ] = chr(255)
        THEN
            i := i - 1
        ELSE
            BEGIN
            c256[ i ] := chr(ord(c256[ i ])+1);
            i := 0
            END;
        (*ENDIF*) 
    (*ENDWHILE*) 
    sign := -1
    END
ELSE
    sign := 1;
(*ENDIF*) 
IF  ok
THEN
    WHILE (len > 0) DO
        BEGIN
        out  := out + ord(c256[ len ]) * mult;
        IF  len > 1
        THEN
            mult := mult * 256;
        (*ENDIF*) 
        len  := len - 1
        END;
    (*ENDWHILE*) 
(*ENDIF*) 
out := sign * out;
&ifdef trace
t02int4 (debug_ut, 'out         ', out);
t02name (debug_ut, hexin);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11input_hex (
            VAR hexin : tsp00_Name;
            VAR out : tsp00_C256;
            len     : integer;
            VAR ok  : boolean);
 
VAR
      multiply  : boolean;
      i         : integer;
      start_pos : integer;
      end_pos   : integer;
      val       : integer;
 
BEGIN
IF  hexin = bsp_name
THEN
    ok := false
ELSE
    BEGIN
    start_pos := 1;
    WHILE hexin[ start_pos ] = bsp_c1 DO
        start_pos := start_pos + 1;
    (*ENDWHILE*) 
    end_pos := NAME_MXSP00;
    WHILE hexin[ end_pos ] = bsp_c1 DO
        end_pos := end_pos - 1;
    (*ENDWHILE*) 
    IF  end_pos - start_pos + 1 > 2 * len
    THEN
        ok := false
    ELSE
        BEGIN
        i        := end_pos;
        len      := len + 1;
        multiply := false;
        WHILE i >= start_pos DO
            IF  NOT (hexin[ i ] in [ '0'..'9', 'A'..'F' ])
            THEN
                BEGIN
                i  := 0;
                ok := false
                END
            ELSE
                BEGIN
                IF  hexin[ i ] in [ '0'..'9' ]
                THEN
                    val := ord (hexin[ i ]) - ord('0')
                ELSE
                    val := 10 + ord (hexin[ i ]) - ord('A');
                (*ENDIF*) 
                IF  multiply
                THEN
                    BEGIN
                    out[ len ] :=
                          chr(ord(out[ len ]) + val * 16);
                    multiply := false
                    END
                ELSE
                    BEGIN
                    len := len - 1;
                    out[ len ] := chr(val);
                    multiply := true
                    END;
                (*ENDIF*) 
                i := i - 1;
                END;
            (*ENDIF*) 
        (*ENDWHILE*) 
        FOR i := len - 1 DOWNTO 1 DO
            out[ i ] := chr(0)
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11inputc6_hex (
            VAR hexin : tsp00_C256;
            VAR out : tsp00_C6;
            len     : integer;
            VAR ok  : boolean);
 
VAR
      multiply  : boolean;
      i         : integer;
      start_pos : integer;
      end_pos   : integer;
      val       : integer;
      check     : tsp00_C256;
 
BEGIN
SAPDB_PascalForcedFill (sizeof(check), @check, 1, sizeof(check), ' ');
IF  hexin = check
THEN
    ok := false
ELSE
    BEGIN
    start_pos := 1;
    WHILE hexin[ start_pos ] = bsp_c1 DO
        start_pos := start_pos + 1;
    (*ENDWHILE*) 
    end_pos := mxsp_c256;
    WHILE hexin[ end_pos ] = bsp_c1 DO
        end_pos := end_pos - 1;
    (*ENDWHILE*) 
    IF  end_pos - start_pos + 1 > 2 * len
    THEN
        ok := false
    ELSE
        BEGIN
        i        := end_pos;
        len      := len + 1;
        multiply := false;
        WHILE i >= start_pos DO
            IF  NOT (hexin[ i ] in [ '0'..'9', 'A'..'F' ])
            THEN
                BEGIN
                i  := 0;
                ok := false
                END
            ELSE
                BEGIN
                IF  hexin[ i ] in [ '0'..'9' ]
                THEN
                    val := ord (hexin[ i ]) - ord('0')
                ELSE
                    val := 10 + ord (hexin[ i ]) - ord('A');
                (*ENDIF*) 
                IF  multiply
                THEN
                    BEGIN
                    out[ len ] :=
                          chr(ord(out[ len ]) + val * 16);
                    multiply := false
                    END
                ELSE
                    BEGIN
                    len := len - 1;
                    out[ len ] := chr(val);
                    multiply := true
                    END;
                (*ENDIF*) 
                i := i - 1;
                END;
            (*ENDIF*) 
        (*ENDWHILE*) 
        FOR i := len - 1 DOWNTO 1 DO
            out[ i ] := chr(0)
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11inputc256_hex (
            VAR hexin : tsp00_C256;
            VAR out : tsp00_C256;
            len     : integer;
            VAR ok  : boolean);
 
VAR
      multiply  : boolean;
      i         : integer;
      start_pos : integer;
      end_pos   : integer;
      val       : integer;
      check     : tsp00_C256;
 
BEGIN
SAPDB_PascalForcedFill (sizeof(check), @check, 1, sizeof(check), ' ');
IF  hexin = check
THEN
    ok := false
ELSE
    BEGIN
    start_pos := 1;
    WHILE hexin[ start_pos ] = bsp_c1 DO
        start_pos := start_pos + 1;
    (*ENDWHILE*) 
    end_pos := mxsp_c256;
    WHILE hexin[ end_pos ] = bsp_c1 DO
        end_pos := end_pos - 1;
    (*ENDWHILE*) 
    IF  end_pos - start_pos + 1 > 2 * len
    THEN
        ok := false
    ELSE
        BEGIN
        i        := end_pos;
        len      := len + 1;
        multiply := false;
        WHILE i >= start_pos DO
            IF  NOT (hexin[ i ] in [ '0'..'9', 'A'..'F' ])
            THEN
                BEGIN
                i  := 0;
                ok := false
                END
            ELSE
                BEGIN
                IF  hexin[ i ] in [ '0'..'9' ]
                THEN
                    val := ord (hexin[ i ]) - ord('0')
                ELSE
                    val := 10 + ord (hexin[ i ]) - ord('A');
                (*ENDIF*) 
                IF  multiply
                THEN
                    BEGIN
                    out[ len ] :=
                          chr(ord(out[ len ]) + val * 16);
                    multiply := false
                    END
                ELSE
                    BEGIN
                    len := len - 1;
                    out[ len ] := chr(val);
                    multiply := true
                    END;
                (*ENDIF*) 
                i := i - 1;
                END;
            (*ENDIF*) 
        (*ENDWHILE*) 
        FOR i := len - 1 DOWNTO 1 DO
            out[ i ] := chr(0)
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11boolean_in_out (
            VAR in_out_bool : boolean;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      new_bool : boolean;
 
BEGIN
WITH mask[ mask_index ] DO
    BEGIN
    in_len := 5;
    IF  in_name = bsp_name
    THEN
        BEGIN
        IF  in_out_bool
        THEN
            in_name := true_name
        ELSE
            in_name := false_name
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        IF  in_name = true_name
        THEN
            new_bool := true
        ELSE
            IF  in_name = false_name
            THEN
                new_bool := false
            ELSE
                ok := false;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  ok AND (new_bool <> in_out_bool)
        THEN
            BEGIN
            modified    := true;
            in_out_bool := new_bool
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11hexident_in_out (
            VAR out      : tsp00_KnlIdentifier;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      aux_ident : tsp00_C256;
 
BEGIN
WITH mask[ mask_index ] DO
    BEGIN
    in_len := mxsp_c256;
    u11inputc256_hex (in_c256, aux_ident, sizeof(aux_ident), ok);
    IF  ok
    THEN
        IF  aux_ident <> in_c256
        THEN
            BEGIN
            modified := true;
            in_c256   := aux_ident
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11hexname_in_out (
            VAR name     : tsp00_Name;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
 
      c256_map_name : RECORD
            CASE boolean OF
                true :
                    (c256 : tsp00_C256);
                false :
                    (nam : tsp00_Name);
                END;
            (*ENDCASE*) 
 
      check     : tsp00_C256;
 
BEGIN
SAPDB_PascalForcedFill (sizeof(check), @check, 1, sizeof(check), ' ');
WITH mask[ mask_index ] DO
    BEGIN
    in_len := mxsp_c256;
    IF  in_c256 = check
    THEN
        BEGIN
        c256_map_name.nam := name;
        u11hexc256 (c256_map_name.c256, NAME_MXSP00, in_c256)
        END
    ELSE
        BEGIN
        u11inputc256_hex (in_c256, c256_map_name.c256, NAME_MXSP00, ok);
        IF  ok
        THEN
            IF  c256_map_name.nam <> name
            THEN
                BEGIN
                modified := true;
                name     := c256_map_name.nam
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11setin_out (
            VAR c2       : tsp00_C2;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      c256    : tsp00_C256;
 
BEGIN
WITH mask[ mask_index ] DO
    BEGIN
    in_len := 16;
    IF  in_name = bsp_name
    THEN
        BEGIN
        c256[ 1 ] := c2[ 1 ];
        c256[ 2 ] := c2[ 2 ];
        ut11bin_output (c256, 2, in_name)
        END
    ELSE
        BEGIN
        ut11bin_input (in_name, 2, c256, ok);
        IF  ok AND ((c256[ 1 ] <> c2[ 1 ]) OR (c256[ 2 ] <> c2[ 2 ]))
        THEN
            BEGIN
            modified := true;
            c2[ 1 ]  := c256[ 1 ];
            c2[ 2 ]  := c256[ 2 ];
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11setc256_in_out (
            VAR c256set   : tsp00_C256;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            pos          : integer;
            len          : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      i       : integer;
      c256     : tsp00_C256;
      check     : tsp00_C256;
 
BEGIN
SAPDB_PascalForcedFill (sizeof(check), @check, 1, sizeof(check), ' ');
WITH mask[ mask_index ] DO
    BEGIN
    in_len := mxsp_c256;
    IF  in_c256 = check
    THEN
        ut11binc256_output (c256set, pos, len, in_c256)
    ELSE
        BEGIN
        ut11binc256_input (in_c256, len, c256, ok);
        IF  ok
        THEN
            BEGIN
            FOR i := pos TO pos + len - 1 DO
                IF  c256[ i - pos + 1 ] <> c256set[ i ]
                THEN
                    modified := true;
                (*ENDIF*) 
            (*ENDFOR*) 
            IF  modified
            THEN
                FOR i := pos TO pos + len - 1 DO
                    c256set[ i ] := c256[ i - pos + 1  ];
                (*ENDFOR*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11int1in_out (
            VAR int1     : tsp00_Uint1;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      i4       : tsp00_Int4;
 
BEGIN
mask[ mask_index ].in_len := 2;
IF  mask[ mask_index ].in_name = bsp_name
THEN
    u11integer_hex (int1, 1, mask[ mask_index ].in_name)
ELSE
    BEGIN
    u11hexint_input (mask[ mask_index ].in_name, i4, 1, ok);
    IF  ok AND (int1 <> i4)
    THEN
        BEGIN
        modified := true;
        int1     := i4
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11int2in_out (
            VAR int2     : tsp00_Int2;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      i4       : tsp00_Int4;
 
BEGIN
mask[ mask_index ].in_len := 4;
IF  mask[ mask_index ].in_name = bsp_name
THEN
    u11integer_hex (int2, 2, mask[ mask_index ].in_name)
ELSE
    BEGIN
    u11hexint_input (mask[ mask_index ].in_name, i4, 2, ok);
    IF  ok AND (int2 <> i4)
    THEN
        BEGIN
        modified := true;
        int2     := i4
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11int4in_out (
            VAR int4     : tsp00_Int4;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      i4       : tsp00_Int4;
 
BEGIN
mask[ mask_index ].in_len := 8;
IF  mask[ mask_index ].in_name = bsp_name
THEN
    u11integer_hex (int4, 4, mask[ mask_index ].in_name)
ELSE
    BEGIN
    u11hexint_input (mask[ mask_index ].in_name, i4, 4, ok);
    IF  ok AND (int4 <> i4)
    THEN
        BEGIN
        modified := true;
        int4     := i4
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11c6in_out (
            VAR c6       : tsp00_C6;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      c6i : tsp00_C6;
 
BEGIN
WITH mask[ mask_index ] DO
    BEGIN
    in_len := 2 * mxsp_c6;
    IF  mask[ mask_index ].in_name = bsp_name
    THEN
        u11hexc6 (c6, 6, mask[ mask_index ].in_c256)
    ELSE
        BEGIN
        u11inputc6_hex (mask[ mask_index ].in_c256, c6i, 6, ok);
        IF  ok AND (c6 <> c6i)
        THEN
            BEGIN
            modified := true;
            c6       := c6i
            END;
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11filename_in_out (
            VAR fn       : tgg00_Filename;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
 
      c256_map_fn : RECORD
            CASE boolean OF
                true :
                    (c256 : tsp00_C256);
                false :
                    (fn : tgg00_Filename);
                END;
            (*ENDCASE*) 
 
      check     : tsp00_C256;
 
BEGIN
SAPDB_PascalForcedFill (sizeof(check), @check, 1, sizeof(check), ' ');
WITH mask[ mask_index ] DO
    BEGIN
    in_len := mxsp_c256;
    IF  in_c256 = check
    THEN
        BEGIN
        c256_map_fn.fn := fn;
        u11hexc256 (c256_map_fn.c256, FN_MXGG00, in_c256)
        END
    ELSE
        BEGIN
        u11inputc256_hex (in_c256, c256_map_fn.c256, FN_MXGG00, ok);
        IF  ok
        THEN
            IF  c256_map_fn.fn <> fn
            THEN
                BEGIN
                modified := true;
                fn       := c256_map_fn.fn
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11surrogate_in_out (
            VAR surrogate : tgg00_Surrogate;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      i   : integer;
      c256 : tsp00_C256;
 
BEGIN
mask[ mask_index ].in_len := 2 * SURROGATE_MXGG00;
IF  mask[ mask_index ].in_name = bsp_name
THEN
    u11hexsurrogate (surrogate, mask[ mask_index ].in_name)
ELSE
    BEGIN
    u11input_hex (mask[ mask_index ].in_name, c256, SURROGATE_MXGG00, ok);
    IF  ok
    THEN
        FOR i := 1 TO SURROGATE_MXGG00 DO
            BEGIN
            IF  c256[ i ] <> surrogate[ i ]
            THEN
                modified := true;
            (*ENDIF*) 
            surrogate[ i ] := c256[ i ]
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11namein_out (
            VAR out      : tsp00_Name;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR modified : boolean);
 
BEGIN
mask[ mask_index ].in_len := NAME_MXSP00;
IF  mask[ mask_index ].in_name = bsp_name
THEN
    mask[ mask_index ].in_name := out
ELSE
    BEGIN
    IF  mask[ mask_index ].in_name <> out
    THEN
        BEGIN
        modified := true;
        out      := mask[ mask_index ].in_name
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11c64in_out (
            VAR out      : tsp00_C64;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR modified : boolean);
 
BEGIN
WITH mask[ mask_index ] DO
    BEGIN
    in_len := mxsp_c64;
    IF  in_ident = bsp_c64
    THEN
        in_ident := out
    ELSE
        BEGIN
        IF  in_ident <> out
        THEN
            BEGIN
            modified := true;
            out      := in_ident
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11c8surrogate_in_out (
            VAR out      : tgg00_Surrogate;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      i   : integer;
 
BEGIN
WITH mask[ mask_index ] DO
    BEGIN
    in_len := SURROGATE_MXGG00;
    IF  in_name = bsp_name
    THEN
        FOR i := 1 TO SURROGATE_MXGG00 DO
            in_name[ i ] := out[ i ]
        (*ENDFOR*) 
    ELSE
        BEGIN
        FOR i := 1 TO SURROGATE_MXGG00 DO
            IF  in_name[ i ] <> out[ i ]
            THEN
                modified := true;
            (*ENDIF*) 
        (*ENDFOR*) 
        FOR i := SURROGATE_MXGG00 TO NAME_MXSP00 DO
            IF  in_name[ i ] <> bsp_c1
            THEN
                ok := false;
            (*ENDIF*) 
        (*ENDFOR*) 
        IF  modified  AND ok
        THEN
            FOR i := 1 TO SURROGATE_MXGG00 DO
                out[ i ] := in_name[ i ];
            (*ENDFOR*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11c1inout (
            VAR c1       : char;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      c2  : tsp00_C2;
      c256 : tsp00_C256;
 
BEGIN
mask[ mask_index ].in_len := 2;
IF  mask[ mask_index ].in_name = bsp_name
THEN
    BEGIN
    c2[ 1 ] := c1;
    u11hexc2 (c2, 1, mask[ mask_index ].in_name)
    END
ELSE
    BEGIN
    u11input_hex (mask[ mask_index ].in_name, c256, 1, ok);
    IF  ok
    THEN
        BEGIN
        IF  c256[ 1 ] <> c1
        THEN
            modified := true;
        (*ENDIF*) 
        c1 := c256[ 1 ]
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11c2inout (
            VAR c2       : tsp00_C2;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      i   : integer;
      c256 : tsp00_C256;
 
BEGIN
mask[ mask_index ].in_len := 4;
IF  mask[ mask_index ].in_name = bsp_name
THEN
    u11hexc2 (c2, mxsp_c2, mask[ mask_index ].in_name)
ELSE
    BEGIN
    u11input_hex (mask[ mask_index ].in_name, c256, mxsp_c2, ok);
    IF  ok
    THEN
        FOR i := 1 TO mxsp_c2 DO
            BEGIN
            IF  c256[ i ] <> c2[ i ]
            THEN
                modified := true;
            (*ENDIF*) 
            c2[ i ] := c256[ i ]
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11utkind_in_out (
            VAR kind     : tak_usertab_descriptor;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      aux : tak_usertab_descriptor;
 
BEGIN
WITH mask[ mask_index ] DO
    BEGIN
    in_len := NAME_MXSP00;
    IF  in_name = bsp_name
    THEN
        BEGIN
        CASE kind OF
            ut_table :
                in_name := ut_table_name;
            ut_base_table :
                in_name := ut_own_table_name;
            ut_procedure :
                in_name := ut_proc_name;
            END;
        (*ENDCASE*) 
        END
    ELSE
        BEGIN
        aux := kind;
        IF  in_name = ut_table_name
        THEN
            aux := ut_table
        ELSE
            IF  in_name = ut_own_table_name
            THEN
                aux := ut_base_table
            ELSE
                IF  in_name = ut_proc_name
                THEN
                    aux := ut_procedure
                ELSE
                    ok := false;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  kind <> aux
        THEN
            BEGIN
            modified := true;
            kind     := aux
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11tabkind_in_out (
            VAR kind     : tgg00_TableKind;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      aux : tgg00_TableKind;
 
      c2_map_tabkind : RECORD
            CASE boolean OF
                true :
                    (c2 : tsp00_C2);
                false :
                    (tk : tgg00_TableKind);
                END;
            (*ENDCASE*) 
 
 
BEGIN
WITH mask[ mask_index ] DO
    BEGIN
    in_len := NAME_MXSP00;
    IF  in_name = bsp_name
    THEN
        BEGIN
        CASE kind OF
            twithkey :
                in_name := twithkey_name;
            twithoutkey :
                in_name := twithoutkey_name;
            tonebase :
                in_name := tonebase_name;
            tsynonym :
                in_name := tsynonym_name;
            tview :
                in_name := tview_name;
            tcomplexview :
                in_name := tcomplexview_name;
            tdb2view :
                in_name := tdb2view_name;
            OTHERWISE
                BEGIN
                c2_map_tabkind.c2[ 2 ] := chr(0);
                c2_map_tabkind.tk      := kind;
                u11c2inout (c2_map_tabkind.c2,
                      mask, mask_index, ok, modified)
                END;
            END;
        (*ENDCASE*) 
        END
    ELSE
        BEGIN
        aux := kind;
        IF  in_name = twithkey_name
        THEN
            aux := twithkey
        ELSE
            IF  in_name = twithoutkey_name
            THEN
                aux := twithoutkey
            ELSE
                IF  in_name = tonebase_name
                THEN
                    aux := tonebase
                ELSE
                    IF  in_name = tsynonym_name
                    THEN
                        aux := tsynonym
                    ELSE
                        IF  in_name = tview_name
                        THEN
                            aux := tview
                        ELSE
                            IF  in_name = tcomplexview_name
                            THEN
                                aux := tcomplexview
                            ELSE
                                IF  in_name = tdb2view_name
                                THEN
                                    aux := tdb2view
                                ELSE
                                    BEGIN
                                    c2_map_tabkind.c2[ 2 ] := chr(0);
                                    c2_map_tabkind.tk      := aux;
                                    u11c2inout (c2_map_tabkind.c2,
                                          mask, mask_index, ok, modified);
                                    aux := c2_map_tabkind.tk
                                    END;
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  kind <> aux
        THEN
            BEGIN
            modified := true;
            kind     := aux
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11datatype_in_out (
            VAR datatype  : tsp00_DataType;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      aux  : tsp00_DataType;
      int1 : tsp00_Uint1;
 
BEGIN
WITH mask[ mask_index ] DO
    BEGIN
    in_len := NAME_MXSP00;
    IF  in_name = bsp_name
    THEN
        BEGIN
        CASE datatype OF
            dfixed :
                in_name := dfixed_name;
            dfloat :
                in_name := dfloat_name;
            dcha :
                in_name := dcha_name;
            dchb :
                in_name := dchb_name;
            dstra :
                in_name := dstra_name;
            dstrb :
                in_name := dstrb_name;
            ddate :
                in_name := ddate_name;
            dtime :
                in_name := dtime_name;
            dtimestamp :
                in_name := dtimestamp_name;
            OTHERWISE
                BEGIN
                int1 := ord (datatype);
                u11integer_hex (int1, 1, in_name)
                END;
            END;
        (*ENDCASE*) 
        END
    ELSE
        BEGIN
        aux := datatype;
        IF  in_name = dfixed_name
        THEN
            aux := dfixed
        ELSE
            IF  in_name = dfloat_name
            THEN
                aux := dfloat
            ELSE
                IF  in_name = dcha_name
                THEN
                    aux := dcha
                ELSE
                    IF  in_name = dchb_name
                    THEN
                        aux := dchb
                    ELSE
                        IF  in_name = dstra_name
                        THEN
                            aux := dstra
                        ELSE
                            IF  in_name = dstrb_name
                            THEN
                                aux := dstrb
                            ELSE
                                IF  in_name = ddate_name
                                THEN
                                    aux := ddate
                                ELSE
                                    IF  in_name = dtime_name
                                    THEN
                                        aux := dtime
                                    ELSE
                                        IF  in_name =
                                            dtimestamp_name
                                        THEN
                                            aux := dtimestamp
                                        ELSE
                                            ok := false;
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  datatype <> aux
        THEN
            BEGIN
            modified := true;
            datatype := aux
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut11bin_output (
            VAR c256     : tsp00_C256;
            len         : integer;
            VAR in_name : tsp00_Name);
 
VAR
      i   : integer;
      j   : integer;
      val : integer;
      pos : integer;
 
BEGIN
in_name := bsp_name;
pos     := 0;
FOR i := 1 TO len DO
    BEGIN
    val := ord(c256[ i ]);
    FOR j := 8 DOWNTO 1 DO
        BEGIN
        in_name[ pos+j ] := chr(ord('0') + val MOD 2);
        val := val DIV 2
        END;
    (*ENDFOR*) 
    pos := pos + 8
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut11bin_input (
            VAR in_name : tsp00_Name;
            len     : integer;
            VAR c256 : tsp00_C256;
            VAR ok  : boolean);
 
VAR
      i     : integer;
      j     : integer;
      mult  : integer;
      val   : integer;
      pos   : integer;
 
BEGIN
SAPDB_PascalForcedFill (sizeof(c256), @c256, 1, sizeof(c256), ' ');
pos := 0;
FOR i := 1 TO len DO
    BEGIN
    mult := 128;
    val  := 0;
    FOR j := 1 TO 8 DO
        BEGIN
        pos := pos + 1;
        IF  (in_name [ pos ] <> '0') AND (in_name[ pos ] <> '1')
        THEN
            ok := false
        ELSE
            IF  in_name[ pos ] = '1'
            THEN
                val := val + mult;
            (*ENDIF*) 
        (*ENDIF*) 
        mult := mult DIV 2;
        END;
    (*ENDFOR*) 
    c256[ i ] := chr(val);
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut11binc256_output (
            VAR c256     : tsp00_C256;
            pos         : integer;
            len         : integer;
            VAR in_c256  : tsp00_C256);
 
VAR
      i       : integer;
      j       : integer;
      val     : integer;
      c256_pos : integer;
 
BEGIN
SAPDB_PascalForcedFill (sizeof(in_c256), @in_c256, 1, sizeof(in_c256), ' ');
c256_pos := 0;
FOR i := pos  TO pos + len - 1 DO
    BEGIN
    val := ord(c256[ i ]);
    FOR j := 8 DOWNTO 1 DO
        BEGIN
        in_c256[ c256_pos+j ] := chr(ord('0') + val MOD 2);
        val := val DIV 2
        END;
    (*ENDFOR*) 
    c256_pos := c256_pos + 8
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut11binc256_input (
            VAR in_c256 : tsp00_C256;
            len     : integer;
            VAR c256 : tsp00_C256;
            VAR ok  : boolean);
 
VAR
      i     : integer;
      j     : integer;
      mult  : integer;
      val   : integer;
      pos   : integer;
 
BEGIN
SAPDB_PascalForcedFill (sizeof(c256), @c256, 1, sizeof(c256), ' ');
pos := 0;
FOR i := 1 TO len DO
    BEGIN
    mult := 128;
    val  := 0;
    FOR j := 1 TO 8 DO
        BEGIN
        pos := pos + 1;
        IF  (in_c256 [ pos ] <> '0') AND (in_c256[ pos ] <> '1')
        THEN
            ok := false
        ELSE
            IF  in_c256[ pos ] = '1'
            THEN
                val := val + mult;
            (*ENDIF*) 
        (*ENDIF*) 
        mult := mult DIV 2;
        END;
    (*ENDFOR*) 
    c256[ i ] := chr(val);
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut11stack_op_type (
            st_entry : tgg00_StackEntry;
            VAR n : tsp00_Name);
 
VAR
      len   : integer;
      sname : tsp00_Sname;
 
BEGIN
CASE st_entry.etype OF
    st_func :
        g17st2op_func (st_entry.eop_func, len, sname);
    st_output, st_output_build_rec, st_output_join :
        g17st3op_output (st_entry.eop_out, len, sname);
    st_build_in_func :
        g17st4op_build_in (st_entry.eop_build_in, len, sname);
    OTHERWISE
        g17st1op (st_entry.eop, len, sname);
    END;
(*ENDCASE*) 
n := bsp_name;
SAPDB_PascalForcedMove (sizeof (sname), sizeof (n), @sname, 1, @n, 1, len)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut11stack_entry_type (
            etype : tgg00_StackEntryType;
            VAR n : tsp00_Name);
 
BEGIN
CASE etype OF
    st_fixkey :
        n := 'ST_FIXKEY         ';
    st_varkey :
        n := 'ST_VARKEY         ';
    st_fixcol :
        n := 'ST_FIXCOL         ';
    st_varcol :
        n := 'ST_VARCOL         ';
    st_fixinv :
        n := 'ST_FIXINV         ';
    st_varinv :
        n := 'ST_VARINV         ';
    st_fixprimkey :
        n := 'ST_FIXPRIMKEY     ';
    st_varprimkey :
        n := 'ST_VARPRIMKEY     ';
    st_old_fixkey :
        n := 'ST_OLD_FIXKEY     ';
    st_old_varkey :
        n := 'ST_OLD_VARKEY     ';
    st_old_fixcol :
        n := 'ST_OLD_FIXCOL     ';
    st_old_varcol :
        n := 'ST_OLD_VARCOL     ';
    st_old_varlongchar :
        n := 'ST_OLD_VARLONGCHAR';
    st_varlongchar :
        n := 'ST_OLD_VARLONGCHAR';
    st_column :
        n := 'ST_COLUMN         ';
    st_object_key :
        n := 'ST_OBJECT_KEY     ';
    st_param :
        n := 'ST_PARAM          ';
    st_dbproc_param :
        n := 'DBPROC_PARAM      ';
    st_filler3 :
        n := 'ST_FILLER3        ';
    st_filler4 :
        n := 'ST_FILLER4        ';
    st_get_subquery :
        n := 'ST_GET_SUBQUERY   ';
    st_bool :
        n := 'ST_BOOL           ';
    st_value :
        n := 'ST_VALUE          ';
    st_parseid :
        n := 'ST_PARSEID        ';
    st_stop :
        n := 'ST_STOP           ';
    st_object_col :
        n := 'ST_OBJECT_COL     ';
    st_op :
        n := 'ST_OP             ';
    st_filler5 :
        n := 'ST_FILLER5        ';
    st_output :
        n := 'ST_OUTPUT         ';
    st_result :
        n := 'ST_RESULT         ';
    st_rec_output :
        n := 'ST_REC_OUTPUT     ';
    st_jump_true :
        n := 'ST_JUMP_TRUE      ';
    st_jump_false :
        n := 'ST_JUMP_FALSE     ';
    st_jump_output :
        n := 'ST_JUMP_OUTPUT    ';
    st_jump_absolute :
        n := 'ST_JUMP_ABSOLUTE  ';
    st_date :
        n := 'ST_DATE           ';
    st_time :
        n := 'ST_TIME           ';
    st_user :
        n := 'ST_USER           ';
    st_strat :
        n := 'ST_STRAT          ';
    st_dummy :
        n := 'ST_DUMMY          ';
    st_noround :
        n := 'ST_NOROUND        ';
    st_truth :
        n := 'ST_TRUTH          ';
    st_output_join :
        n := 'ST_OUTPUT_JOIN    ';
    st_func :
        n := 'ST_FUNC           ';
    st_rowno :
        n := 'ST_ROWNO          ';
    st_datetime_arith :
        n := 'ST_DATETIME_ARITH ';
    st_not_needed :
        n := 'ST_NOT_NEEDED     ';
    st_usergroup :
        n := 'ST_USERGROUP      ';
    st_timestamp :
        n := 'ST_TIMESTAMP      ';
    st_localsysdba :
        n := 'ST_LOCALSYSDBA    ';
    st_sysdba :
        n := 'ST_SYSDBA         ';
    st_output_build_rec :
        n := 'ST_OUTPUT_BUILD_RE';
    st_output_catalog :
        n := 'ST_OUTPUT_CATALOG ';
    st_build_in_func :
        n := 'ST_BUILD_IN_FUNC  ';
    st_subquery :
        n := 'ST_SUBQUERY       ';
    st_mass_compare :
        n := 'ST_MASS_COMPARE   ';
    st_uid :
        n := 'ST_UID            ';
    OTHERWISE
        n := bsp_name;
    END;
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11etype_in_out (
            VAR etype    : tgg00_StackEntryType;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      stop     : boolean;
      aux      : tgg00_StackEntryType;
      aux_name : tsp00_Name;
 
BEGIN
WITH mask[ mask_index ] DO
    BEGIN
    in_len := NAME_MXSP00;
    IF  in_name = bsp_name
    THEN
        ut11stack_entry_type (etype, in_name)
    ELSE
        BEGIN
        aux  := st_fixkey;
        stop := false;
        REPEAT
            ut11stack_entry_type (aux, aux_name);
            IF  aux_name <> in_name
            THEN
                IF  aux = st_uid
                THEN
                    stop := true
                ELSE
                    aux := succ(aux)
                (*ENDIF*) 
            ELSE
                stop := true;
            (*ENDIF*) 
        UNTIL
            (aux_name = bsp_name) OR stop;
        (*ENDREPEAT*) 
        IF  NOT stop
        THEN
            ok := false
        ELSE
            IF  aux <> etype
            THEN
                BEGIN
                etype := aux;
                modified := true
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11eopin_out (
            VAR st_entry : tgg00_StackEntry;
            VAR eop      : tgg00_StackOpType;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      stop     : boolean;
      aux      : tgg00_StackEntry;
      aux_name : tsp00_Name;
 
BEGIN
WITH mask[ mask_index ] DO
    BEGIN
    in_len := NAME_MXSP00;
    IF  in_name = bsp_name
    THEN
        ut11stack_op_type (st_entry, in_name)
    ELSE
        BEGIN
        aux.etype := st_fixkey;
        aux.eop   := op_none;
        stop      := false;
        REPEAT
            ut11stack_op_type (aux, aux_name);
            IF  aux_name <> in_name
            THEN
                aux.eop := succ(aux.eop)
            ELSE
                stop := true;
            (*ENDIF*) 
        UNTIL
            (aux_name = bsp_name) OR stop;
        (*ENDREPEAT*) 
        IF  NOT stop
        THEN
            BEGIN
            aux.etype    := st_func;
            aux.eop_func := op_f_none;
            REPEAT
                ut11stack_op_type (aux, aux_name);
                IF  aux_name <> in_name
                THEN
                    aux.eop_func := succ(aux.eop_func)
                ELSE
                    stop := true;
                (*ENDIF*) 
            UNTIL
                (aux_name = bsp_name) OR stop;
            (*ENDREPEAT*) 
            END;
        (*ENDIF*) 
        IF  NOT stop
        THEN
            BEGIN
            aux.etype   := st_output;
            aux.eop_out := op_o_none;
            REPEAT
                ut11stack_op_type (aux, aux_name);
                IF  aux_name <> in_name
                THEN
                    aux.eop_out := succ(aux.eop_out)
                ELSE
                    stop := true;
                (*ENDIF*) 
            UNTIL
                (aux_name = bsp_name) OR stop;
            (*ENDREPEAT*) 
            END;
        (*ENDIF*) 
        IF  NOT stop
        THEN
            BEGIN
            aux.etype        := st_build_in_func;
            aux.eop_build_in := op_b_none;
            REPEAT
                ut11stack_op_type (aux, aux_name);
                IF  aux_name <> in_name
                THEN
                    aux.eop_build_in := succ(aux.eop_build_in)
                ELSE
                    stop := true;
                (*ENDIF*) 
            UNTIL
                (aux_name = bsp_name) OR stop;
            (*ENDREPEAT*) 
            END;
        (*ENDIF*) 
        IF  NOT stop
        THEN
            ok := false
        ELSE
            IF  aux.eop <> eop
            THEN
                BEGIN
                eop      := aux.eop;
                modified := true
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11modein_out (
            VAR mode     : tsp1_param_opt_type;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      aux  : tsp1_param_opt_type;
      int1 : tsp00_Uint1;
 
BEGIN
WITH mask[ mask_index ] DO
    BEGIN
    in_len := NAME_MXSP00;
    IF  in_name = bsp_name
    THEN
        BEGIN
        CASE mode OF
            sp1ot_mandatory :
                in_name := mandatory_name;
            sp1ot_optional :
                in_name := optional_name;
            sp1ot_default :
                in_name := default_name;
            OTHERWISE
                BEGIN
                int1 := ord (mode);
                u11integer_hex (int1, 1, in_name)
                END;
            END;
        (*ENDCASE*) 
        END
    ELSE
        BEGIN
        aux := mode;
        IF  in_name = mandatory_name
        THEN
            aux := sp1ot_mandatory
        ELSE
            IF  in_name = optional_name
            THEN
                aux := sp1ot_optional
            ELSE
                IF  in_name = default_name
                THEN
                    aux := sp1ot_default
                ELSE
                    ok := false;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  mode <> aux
        THEN
            BEGIN
            modified := true;
            mode     := aux
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u11io_type_in_out (
            VAR io_type  : tsp1_param_io_type;
            VAR mask     : tut_term_mask;
            mask_index   : integer;
            VAR ok       : boolean;
            VAR modified : boolean);
 
VAR
      aux  : tsp1_param_io_type;
      int1 : tsp00_Uint1;
 
BEGIN
WITH mask[ mask_index ] DO
    BEGIN
    in_len := NAME_MXSP00;
    IF  in_name = bsp_name
    THEN
        BEGIN
        CASE io_type OF
            sp1io_input :
                in_name := input_name;
            sp1io_output :
                in_name := output_name;
            sp1io_inout :
                in_name := inout_name;
            OTHERWISE
                BEGIN
                int1 := ord (io_type);
                u11integer_hex (int1, 1, in_name)
                END;
            END;
        (*ENDCASE*) 
        END
    ELSE
        BEGIN
        aux := io_type;
        IF  in_name = input_name
        THEN
            aux := sp1io_input
        ELSE
            IF  in_name = output_name
            THEN
                aux := sp1io_output
            ELSE
                IF  in_name = inout_name
                THEN
                    aux := sp1io_inout
                ELSE
                    ok := false;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  io_type <> aux
        THEN
            BEGIN
            modified := true;
            io_type  := aux
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
