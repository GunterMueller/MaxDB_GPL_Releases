/* @lastChanged: "1999-11-03"
 
 * @filename:   vxt02
 * @purpose:    "XT_kernprot"
 * @release:    7.2.0.0
 * @see:        "-.-"
 *
 * @Copyright (c) 1999-2005 SAP AG"
 */
 
.tt 1 $SAP$LiveCache$VXT02$
.tt 3 $$XT_kernprot$2000-11-14$
 
.nf
 
 .nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
 
 
.fo
***********************************************************
 
Module  : XT_kernprot
 
Define  :
 
        PROCEDURE
              x02kernprot (
                    VAR term        : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    VAR progname    : tsp00_C20;
                    VAR cmd_in_fn   : tsp00_VFilename;
                    cmd_token       : tsp00_Name;
                    VAR pfkey       : tut_pfkey);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              SQLManager : VAK101;
 
        PROCEDURE
              a101_CreateErrorHandler;
 
      ------------------------------ 
 
        FROM
              XT_auxiliary_procedures : VXT05;
 
        PROCEDURE
              x05close_file (VAR f : tut_file);
 
        PROCEDURE
              x05direct_entry (
                    VAR term        : tut_terminal;
                    VAR f           : tut_file;
                    wanted_pagetype : tgg00_PageType;
                    wanted_pno      : tsp00_Int4;
                    wanted_pos      : tsp00_Int4;
                    VAR entry_ptr   : tsp00_MoveObjPtr;
                    entry_size      : tsp00_Int4;
                    VAR err         : tsp00_VfReturn);
 
        PROCEDURE
              x05display_msg (
                    VAR term           : tut_terminal;
                    msg                : tsp00_C20;
                    is_warning         : boolean;
                    immediate_display  : boolean);
 
        PROCEDURE
              x05find_lwb_upb_pno (
                    VAR term         : tut_terminal;
                    VAR f            : tut_file;
                    wanted_pagetype  : tgg00_PageType;
                    VAR last_checkpt : tsp00_Int4;
                    VAR err          : tsp00_VfReturn);
 
        PROCEDURE
              x05get_file_pos (
                    VAR f            : tut_file;
                    wanted_pno       : tsp00_Int4;
                    VAR file_pos     : tut_file_pos);
 
        PROCEDURE
              x05header (
                    VAR term      : tut_terminal;
                    VAR protfile  : tut_vf_fileref;
                    VAR progname  : tsp00_C20;
                    VAR fn        : tsp00_VFilename);
 
        PROCEDURE
              x05hexint (
                    VAR term      : tut_terminal;
                    VAR protfile  : tut_vf_fileref;
                    VAR pfkey     : tut_pfkey);
 
        PROCEDURE
              x05holdhexint (
                    VAR term  : tut_terminal;
                    VAR pfkey : tut_pfkey);
 
        PROCEDURE
              x05init_file (
                    VAR f             : tut_file;
                    VAR blankfilename : tsp00_VFilename);
 
        FUNCTION
              x05ishex (
                    VAR buf     : tsp00_MoveObj;
                    buf_size    : tsp00_Int4;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4): boolean;
 
        PROCEDURE
              x05next_entry (
                    VAR term          : tut_terminal;
                    VAR f             : tut_file;
                    wanted_pagetype   : tgg00_PageType;
                    VAR entry_ptr     : tsp00_MoveObjPtr;
                    entry_size        : tsp00_Int4;
                    VAR err           : tsp00_VfReturn);
 
        PROCEDURE
              x05open_file (
                    VAR term         : tut_terminal;
                    VAR f            : tut_file;
                    skip_mask        : boolean;
                    edit_file        : boolean;
                    rewind_option    : boolean;
                    msg_fn           : tsp00_C20;
                    VAR pfkey        : tut_pfkey);
 
        PROCEDURE
              x05packet (
                    VAR term      : tut_terminal;
                    VAR protfile  : tut_vf_fileref;
                    is_minbuf     : boolean;
                    maxbuflength  : tsp00_Int4;
                    nam           : tsp00_Sname;
                    packet_ptr    : tsp1_packet_ptr);
 
        PROCEDURE
              x05pageno_to_line (
                    int        : tsp00_Int4;
                    trim       : boolean;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              x05print_msg (
                    VAR term     : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    msg          : tsp00_C20);
 
        PROCEDURE
              x05read_entry_pos_from_to (
                    VAR term     : tut_terminal;
                    VAR f        : tut_file;
                    only_from    : boolean;
                    VAR from_pno : tsp00_Int4;
                    VAR from_pos : tsp00_Int4;
                    VAR to_pno   : tsp00_Int4;
                    VAR to_pos   : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x05readint4 (
                    VAR term  : tut_terminal;
                    init_int  : boolean;
                    is_int2   : boolean;
                    msg       : tsp00_C20;
                    VAR int   : tsp00_Int4;
                    VAR pfkey : tut_pfkey);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        PROCEDURE
              gg06FileVersToLine (
                    VAR FileVers : tgg91_FileVersion;
                    VAR LineLen : integer;
                    VAR Line    : tsp00_Line);
 
        FUNCTION
              gg06IsNilObjFileNo (ObjFileNo : tgg00_ObjFileNo): boolean;
 
        FUNCTION
              gg06IsNilTrans (VAR TransNo : tgg91_TransNo): boolean;
 
        PROCEDURE
              gg06OidToLine (
                    VAR oid          : tgg00_OidSpace;
                    VAR LineLen      : integer;
                    VAR Line         : tsp00_Line);
 
        FUNCTION
              gg06RefPno (VAR PageRef : tgg91_PageRef): tsp00_Int4;
 
        FUNCTION
              gg06RefPos (VAR PageRef : tgg91_PageRef): tsp00_Int4;
 
        PROCEDURE
              gg06SessionToLine (
                    VAR SessionNo : tgg91_SessionNo;
                    VAR LineLen : integer;
                    VAR Line    : tsp00_Line);
 
        PROCEDURE
              gg06SetNilSession (VAR SessionNo : tgg91_SessionNo);
 
        PROCEDURE
              gg06SetNilTrans (VAR TransNo : tgg91_TransNo);
 
        PROCEDURE
              gg06TransToLine (
                    VAR TransNo : tgg91_TransNo;
                    VAR LineLen : integer;
                    VAR Line    : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17st1op (
                    op      : tgg00_StackOpType;
                    VAR len : integer;
                    VAR msg : tsp00_Sname);
 
        PROCEDURE
              g17basis_err_to_line (
                    b_err      : tgg00_BasisError;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17bd_use_set_to_line (
                    bd_use     : tgg00_BdUseSet;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17cmdsegm_head (
                    VAR cmdsegm_head : tsp1_segment_header;
                    VAR ln1_len : integer;
                    VAR ln1     : tsp00_Line;
                    VAR ln2_len : integer;
                    VAR ln2     : tsp00_Line;
                    VAR ln3_len : integer;
                    VAR ln3     : tsp00_Line);
 
        PROCEDURE
              g17counter_to_line (
                    counter               : tsp00_8ByteCounter;
                    VAR ln_len            : integer;
                    VAR ln                : tsp00_Line);
 
        PROCEDURE
              g17date_to_line (
                    date            : tsp00_Date;
                    VAR ln_len      : integer;
                    VAR ln          : tsp00_Line);
 
        PROCEDURE
              g17filename (
                    nam             : tsp00_Sname;
                    VAR fn          : tgg00_Filename;
                    line_indent     : integer;
                    VAR first_ln    : tsp00_Line;
                    VAR second_ln   : tsp00_Line;
                    VAR third_ln    : tsp00_Line;
                    VAR is_third_ln : boolean);
 
        PROCEDURE
              g17filetype_to_line (
                    filetype     : tgg00_FiletypeSet;
                    is_edit_mode : boolean;
                    VAR ln_len   : integer;
                    VAR ln       : tsp00_Line);
 
        PROCEDURE
              g17handling_set_to_line (
                    handling   : tgg00_HandlingSet;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17hexto_line (
                    c          : char;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17intdate_time (
                    int_date     : tsp00_Int4;
                    int_time     : tsp00_Int4;
                    VAR str_date : tsp00_Date;
                    VAR str_time : tsp00_Time);
 
        PROCEDURE
              g17intern_warning_item_to_line (
                    warning_item : tsp1_intern_warning;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17int4to_line (
                    int           : tsp00_Int4;
                    with_zero     : boolean;
                    int_len       : integer;
                    ln_pos        : integer;
                    VAR ln        : tsp00_Line);
 
        PROCEDURE
              g17lockmode_to_line (
                    lock_mode  : tgg00_LockReqMode;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17messtype_to_line (
                    mess_type  : tgg00_MessType;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17mess2type_to_line (
                    mess2_type : tgg00_MessType2;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17nameto_line (
                    n           : tsp00_Name;
                    VAR ln_len  : integer;
                    VAR ln      : tsp00_Line);
 
        PROCEDURE
              g17onestackentry (
                    VAR st             : tgg00_StackEntry;
                    entry_index        : integer;
                    VAR ln             : tsp00_Line;
                    VAR is_second_ln   : boolean;
                    VAR second_ln      : tsp00_Line);
 
        PROCEDURE
              g17packet_head (
                    nam             : tsp00_Sname;
                    VAR packet_head : tsp1_packet_header;
                    VAR ln_len      : integer;
                    VAR ln          : tsp00_Line);
 
        PROCEDURE
              g17page_ref_to_line (
                    VAR obj_seq : tgg91_PageRef;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17pagetype_to_line (
                    pagetype   : tgg00_PageType;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17pagetype2_to_line (
                    pagetype2  : tgg00_PageType2;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17paraminfo_to_line (
                    VAR pi     : tsp1_param_info;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17varparaminfo_to_line (
                    VAR pi     : tsp1_param_info;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17paramspec_to_line (
                    data_type  : tsp00_DataType;
                    length     : tsp00_Int2;
                    frac       : tsp00_Uint1;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17parsidinfo_to_line (
                    info       : char;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17parthead (
                    VAR part_head : tsp1_part_header;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        FUNCTION
              g17printable_char (c : char) : boolean;
 
        PROCEDURE
              g17returnsegm_head (
                    VAR retsegm_head : tsp1_segment_header;
                    VAR ln1_len      : integer;
                    VAR ln1          : tsp00_Line;
                    VAR ln2_len      : integer;
                    VAR ln2          : tsp00_Line);
 
        PROCEDURE
              g17sname_to_line (
                    n             : tsp00_Sname;
                    VAR ln_len    : integer;
                    VAR ln        : tsp00_Line);
 
        PROCEDURE
              g17surrogate_to_line (
                    VAR surrogate : tgg00_Surrogate;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17time_to_line (
                    time            : tsp00_Time;
                    VAR ln_len      : integer;
                    VAR ln          : tsp00_Line);
 
        PROCEDURE
              g17trans_state_to_line (
                    trans_state : tgg00_TransState;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17trimint4_to_line (
                    int        : tsp00_Int4;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17warning_item_to_line (
                    warning_item : tsp00_Warnings;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17stratenum_to_line (
                    strat      : tgg07_StratEnum;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17access_mode_set (
                    access_state : tgg07_StratAccessModSet;
                    VAR ln_len   : integer;
                    VAR ln       : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines_2 : VGG172;
 
        PROCEDURE
              g172fileno_to_line (
                    fileno : tsp00_C8;
                    VAR ln_pos : integer;
                    VAR ln     : tsp00_Line (*ptocSynonym char**));
 
      ------------------------------ 
 
        FROM
              TA_terminal_IO : VTA09;
 
        PROCEDURE
              t09display (
                    VAR t09       : tut_terminal;
                    display_on    : boolean);
 
        PROCEDURE
              t09frame (VAR t09 : tut_terminal; on : boolean);
 
        PROCEDURE
              t09get1name (
                    VAR t09        : tut_terminal;
                    msg            : tsp00_C20;
                    msg_attr       : char;
                    in_attr        : char;
                    in_len         : integer;
                    upper_case     : boolean;
                    VAR in_name    : tsp00_Name;
                    VAR pfkey      : tut_pfkey);
 
        FUNCTION
              t09is_empty_window (VAR term : tut_terminal): boolean;
 
        FUNCTION
              t09is_window_full (
                    VAR term    : tut_terminal;
                    wanted_lines: integer): boolean;
 
        PROCEDURE
              t09menu (
                    VAR t09      : tut_terminal;
                    size         : integer;
                    msg_attr     : char;
                    VAR msg      : tut_c20_array;
                    VAR selected : integer;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              t09newscreen_page (VAR t09 : tut_terminal);
 
        PROCEDURE
              t09pfkeys (VAR t09 : tut_terminal; on : boolean);
 
        PROCEDURE
              t09put (
                    VAR t09   : tut_terminal;
                    VAR ln    : tsp00_Line;
                    text_attr : char);
 
        PROCEDURE
              t09put20 (
                    VAR t09     : tut_terminal;
                    ln20        : tsp00_C20;
                    text_attr   : char);
 
        PROCEDURE
              t09putmsg (
                    VAR t09           : tut_terminal;
                    VAR msg           : tsp00_Line;
                    is_warning        : boolean;
                    immediate_display : boolean);
 
      ------------------------------ 
 
        FROM
              TA_write_protfile : VTA12;
 
        PROCEDURE
              t12write_prot (
                    VAR fileref : tut_vf_fileref;
                    VAR ln    : tsp00_Line;
                    length    : integer;
                    VAR error : integer);
 
      ------------------------------ 
 
        FROM
              TA_buf_display : VTA14;
 
        PROCEDURE
              t14bufdisplay (
                    VAR term          : tut_terminal;
                    VAR protfile      : tut_vf_fileref;
                    scan              : tut_diag_scan;
                    msg               : tsp00_C30;
                    VAR buf           : tsp00_MoveObj;
                    buf_size          : tsp00_Int4;
                    startpos          : tsp00_Int4;
                    endpos            : tsp00_Int4;
                    start_numbering   : tsp00_Int4;
                    VAR break_pos     : tsp00_Int4;
                    VAR pfkey         : tut_pfkey);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        FUNCTION
              s20buf_to_int4 (
                    VAR source    : tsp00_Buf;
                    source_pos    : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s20buf_to_int4_1 (
                    VAR source    : tsp00_MoveObj;
                    source_pos    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30lnr (
                    VAR str   : tsp00_Line;
                    val       : char;
                    start     : tsp00_Int4;
                    cnt       : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              GETSTRING-Conversions : VSP42;
 
        PROCEDURE
              s42gchr (
                    VAR buf  : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    len      : integer;
                    frac     : integer;
                    origlen  : integer;
                    VAR dest : tsp00_Line;
                    dpos     : tsp00_Int4;
                    VAR dlen : integer;
                    VAR res  : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE_driver : VEN102;
 
        PROCEDURE
              sqlclock (
                    VAR sec      : tsp00_Int4;
                    VAR microsec : tsp00_Int4);
 
        PROCEDURE
              sqlallocat (
                    length : tsp00_Int4;
                    VAR p  : tsp00_MoveObjPtr;
                    VAR ok : boolean);
 
        PROCEDURE
              sqlfree (p : tsp00_MoveObjPtr);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              t09put;
 
              tsp00_C80 tsp00_Line
 
        PROCEDURE
              s20buf_to_int4;
 
              tsp00_MoveObj tsp00_Buf
 
        FUNCTION
              s30lnr;
 
              tsp00_MoveObj tsp00_Line
 
        PROCEDURE
              s42gchr;
 
              tsp00_MoveObj   tsp00_Line
 
        PROCEDURE
              sqlallocat;
 
              tsp00_ObjAddr tsp00_MoveObjPtr
 
        PROCEDURE
              sqlfree;
 
              tsp00_BufAddr tsp00_MoveObjPtr
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : JuergenA
.sp
.cp 3
Created : 1984-10-02
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-11-14
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.CM *-END-* specification -------------------------------
.fo
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      DISPLAY_INTERVAL   =     5; (* seconds *)
      LINE_FUNCT_INDENT  =     1;
      MAX_LINES_PER_TASK =    50;
      MAX_PACKETS        =     5;
      MIN_LABEL_LEN      =     8;
      MIN_OBJ_LABEL_LEN  =    12;
      OFFSET_FIRST_ENTRY =     5;
      OUT_MAXBUFLENFGTH  = 65535;
      PACKET_INDENT      =     9;
      PROT_LINESIZE      =    72;
      FLUSH_INTERVAL     =   100;
      (* *)
      BLOCK_IO_SIGN       = '*';
      CALL_FUNCTION_SIGN  = '>';
      LEAVE_FUNCTION_SIGN = '-';
      NO_FUNCTION_SIGN    = ' ';
      (* *)
      c_adjust          = true;
      c_edit_file       = true;
      c_immediate_displ = true;
      c_init            = true;
      c_int2            = true;
      c_on              = true;
      c_only_from       = true;
      c_rewind_option   = true; (* PTS 1103859 JA 1999-09-02 *)
      c_warning         = true;
      c_with_delimiter  = true;
      c_with_zero       = true;
 
TYPE
      arrow_type = (
            without_arrow,
            left_arrow,
            right_arrow);
      net_event = (
            n_open,
            n_request,
            n_receive,
            n_restart,
            n_shutdown,
            n_discard,
            n_response_timeout,
            n_close,
            n_resume_server_vtrace);
 
      net_trace = RECORD
            net_op     : net_event;
            net_code   : tsp1_comm_error;
            site       : tgg00_ServerdbNo;
            b_error    : tgg00_BasisError;
            mess_type  : tgg00_MessType;
            mess2_type : tgg00_MessType2;
            id         : tsp00_Int4;
            transid    : tgg91_TransNo
      END;
 
 
      trace_record = RECORD
            CASE integer OF
                1:
                    (vtrace_entry     : tsp00_Buf);
                2:
                    (trceHead         : tgg11_VtraceHeader;
                    buf               : tsp00_Buf);
                3:
                    (space3           : tgg11_VtraceHeader;
                    mblock            : tgg00_MessBlock;
                    mbl_xt_mtrail     : tgg00_MessBufTrailer;
                    mbl_trans         : tgg00_TransContext;
                    mbl_qual_pos      : tsp00_Int4;
                    mbl_data_pos      : tsp00_Int4;
                    mbl_stack_pos     : tsp00_Int4;
                    mbl_trans_pos     : tsp00_Int4;
                    mbl_strat_pos     : tsp00_Int4);
                5:
                    (space5           : tgg11_VtraceHeader;
                    net               : net_trace);
                6:
                    (space6           : tgg11_VtraceHeader;
                    i4                : ARRAY [1..4] OF tsp00_Int4);
                8:
                    (space8           : tgg11_VtraceHeader;
                    order_layer       : tsp00_C1;
                    order_counter     : tsp00_C1;
                    order_packet_head : tsp1_packet_header);
                9:
                    (space9           : tgg11_VtraceHeader;
                    packet_head       : tsp1_packet_header;
                    packet_segm_head  : tsp1_segment_header;
                    part_head         : tsp1_part_header);
                10:
                    (space10          : tgg11_VtraceHeader;
                    segm_head         : tsp1_segment_header);
                11:
                    (space11          : tgg11_VtraceHeader;
                    packet_part_head  : tsp1_part_header;
                    packet_part_buf   : tsp00_Line);
                12:
                    (space12          : tgg11_VtraceHeader;
                    packet_ptr        : tsp1_packet_ptr);
                13:
                    (space13          : tgg11_VtraceHeader;
                    io_dev_type       : tsp00_Uint1;
                    io_pagetype       : tgg00_PageType;
                    io_pagetype2      : tgg00_PageType2;
                    io_buf_no         : tsp00_Uint1;
                    io_pno            : tsp00_PageNo;
                    io_dev_offset     : tsp00_Int4;
                    io_dev_no         : tsp00_Int2);
                15:
                    (space15          : tgg11_VtraceHeader;
                    longinfo_cnt      : tsp00_Int2;
                    longinfo_layer    : tgg00_Debug);
                16:
                    (space16          : tgg11_VtraceHeader;
                    log_session       : tgg91_SessionNo;
                    log_trans         : tgg91_TransNo;
                    log_type          : tgg00_MessType;
                    log_type2         : tgg00_MessType2;
                    log_len           : tsp00_Int4);
                20:
                    (space20          : tgg11_VtraceHeader;
                    trceBdInt         : tgg11_BdIntTrace);
                23:
                    (space23          : tgg11_VtraceHeader;
                    trceBdAppendRoot  : tgg11_BdAppendRootTrace);
                24:
                    (space24          : tgg11_VtraceHeader;
                    trceBdAppendTrans : tgg11_BdAppendTransTrace);
                25:
                    (space25          : tgg11_VtraceHeader;
                    trceBdEvalPages   : tgg11_BdEvalPagesTrace);
                26:
                    (space26          : tgg11_VtraceHeader;
                    trceBdFilename    : tgg11_BdFilenameTrace);
                27:
                    (space27          : tgg11_VtraceHeader;
                    trceBdKey         : tgg11_BdKeyTrace);
                28:
                    (space28          : tgg11_VtraceHeader;
                    trceBdMerge       : tgg11_BdMergeTrace);
                29:
                    (space29          : tgg11_VtraceHeader;
                    trceBdRename      : tgg11_BdRenameTrace);
                30:
                    (space30          : tgg11_VtraceHeader;
                    trceBdRoot        : tgg11_BdRootTrace);
                31:
                    (space31          : tgg11_VtraceHeader;
                    trceBdTwoKeys     : tgg11_BdTwoKeysTrace);
                32:
                    (space32          : tgg11_VtraceHeader;
                    trceBdVerify      : tgg11_BdVerifyTrace);
                33:
                    (space33          : tgg11_VtraceHeader;
                    trceBdWriteStr    : tgg11_BdWriteStrTrace);
                40:
                    (space40          : tgg11_VtraceHeader;
                    trceKb            : tgg11_KbTrace);
                41:
                    (space41          : tgg11_VtraceHeader;
                    trceKbConsistView : tgg11_KbConsistViewTrace);
                42:
                    (space42          : tgg11_VtraceHeader;
                    trceKbDateTime    : tgg11_KbDateTimeTrace);
                43:
                    (space43          : tgg11_VtraceHeader;
                    trceKbLock        : tgg11_KbLockTrace);
                44:
                    (space44          : tgg11_VtraceHeader;
                    trceKbRedo        : tgg11_KbRedoTrace);
                45:
                    (space45          : tgg11_VtraceHeader;
                    trceKbTabId       : tgg11_KbTabIdTrace);
                46:
                    (space46          : tgg11_VtraceHeader;
                    trceKbTabKey      : tgg11_KbTabKeyTrace);
                47:
                    (space47          : tgg11_VtraceHeader;
                    trceKbTime        : tgg11_KbTimeTrace);
                48:
                    (space48          : tgg11_VtraceHeader;
                    trceKbTimeout     : tgg11_KbTimeoutTrace);
                50:
                    (space50          : tgg11_VtraceHeader;
                    OmsMessType       : tgg00_MessType;
                    OmsMessType2      : tgg00_MessType2;
                    OmsTraceType      : tgg12_OmsTraceType;
                    OmsTraceType2     : tgg12_OmsTraceType2);
                51:
                    (space51          : tgg11_VtraceHeader;
                    OmsError          : tgg12_OmsErrorTrace);
                52:
                    (space52          : tgg11_VtraceHeader;
                    OmsGarbColl       : tgg12_OmsGarbCollTrace);
                53:
                    (space53          : tgg11_VtraceHeader;
                    OmsFileInfo       : tgg12_OmsFileInfoTrace);
                54:
                    (space54          : tgg11_VtraceHeader;
                    OmsKey            : tgg12_OmsKeyTrace);
                55:
                    (space55          : tgg11_VtraceHeader;
                    OmsOid            : tgg12_OmsOidTrace);
                56:
                    (space56          : tgg11_VtraceHeader;
                    OmsPageChainStat  : tgg12_OmsPageChainStatTrace);
                57:
                    (space57          : tgg11_VtraceHeader;
                    OmsPageStat       : tgg12_OmsPageStatTrace);
                58:
                    (space58          : tgg11_VtraceHeader;
                    OmsFilename       : tgg12_OmsFilenameTrace);
                59:
                    (space59          : tgg11_VtraceHeader;
                    OmsPageConStat    : tgg12_OmsPageContainerStatTrace);
                60:
                    (space60          : tgg11_VtraceHeader;
                    OmsVersionError    : tgg12_OmsVersionErrorTrace);
                61:
                    (space61          : tgg11_VtraceHeader;
                    OmsRelOid    : tgg12_OmsRelOidTrace);
                62:
                    (space62          : tgg11_VtraceHeader;
                    OmsTwoKeys        : tgg12_OmsTwoKeyTrace);  (* PTS 1111934 AK 25/09/2001    *)
                63:
                    (space63          : tgg11_VtraceHeader;
                    trceJoin          : tgg11_JoinTabIdTrace);
                END;
            (*ENDCASE*) 
 
 
      t_aux_ptr = RECORD
            CASE boolean OF
                false :
                    (x_moveobj_ptr : tsp00_MoveObjPtr);
                true  :
                    (x_data_ptr    : tgg00_DataPartPtr)
                END;
            (*ENDCASE*) 
 
      t_TermAddr = ^tut_terminal;
      t_ProtAddr = ^tut_vf_fileref;
 
      t_DisplState = RECORD
            dsTerm           : t_TermAddr;
            dsProt           : t_ProtAddr;
            dsMaxBuflength   : tsp00_Int4;
            dsPfkey          : tut_pfkey;
            dsTdbufWanted    : boolean;
            dsIsMinbuf       : boolean;
            dsLeaveFunctSign : tsp00_C1
      END;
 
 
 
(*------------------------------*) 
 
PROCEDURE
      x02kernprot (
            VAR term        : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            VAR progname    : tsp00_C20;
            VAR cmd_in_fn   : tsp00_VFilename;
            cmd_token       : tsp00_Name;
            VAR pfkey       : tut_pfkey);
 
VAR
      is_exit     : boolean;
      io_err      : tsp00_VfReturn;
      file_ext    : tsp00_C4;
      dummy_i4    : tsp00_Int4;
      vtrace_file : tut_file;
 
BEGIN
pfkey    := pf_none;
io_err   := vf_ok;
is_exit  := false;
file_ext := '.dat';
x05init_file (vtrace_file, term.blankfilename);
vtrace_file.utf_fn := cmd_in_fn;
t09frame  (term, true);
t09pfkeys (term, true);
IF  (term.blankfilename = vtrace_file.utf_fn)
THEN
    SAPDB_PascalForcedMove (sizeof (file_ext), sizeof (vtrace_file.utf_fn),
          @file_ext, 1, @vtrace_file.utf_fn, 1, sizeof (file_ext));
(*ENDIF*) 
a101_CreateErrorHandler;
REPEAT
    x05open_file (term, vtrace_file, (cmd_token <> bsp_name),
          NOT c_edit_file,
          NOT c_rewind_option, (* PTS 1103859 JA 1999-09-02 *)
          ' SORTED TRACE FILE :', pfkey);
    IF  pfkey = pf_none
    THEN
        x05find_lwb_upb_pno (term, vtrace_file, ptVtrace_egg00,
              dummy_i4, io_err);
    (*ENDIF*) 
    IF  (pfkey = pf_none) AND (io_err = vf_ok)
    THEN
        BEGIN
        IF  cmd_token <> bsp_name
        THEN
            t09display (term, NOT c_on);
        (*ENDIF*) 
        x05header (term, protfile, progname, vtrace_file.utf_fn);
        xt02menu_main (term, protfile, vtrace_file,
              cmd_token, is_exit, pfkey);
        IF  pfkey = pf_end
        THEN
            pfkey := pf_none
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    x05close_file (vtrace_file)
UNTIL
    (pfkey <> pf_none) OR is_exit OR (cmd_token <> bsp_name);
(*ENDREPEAT*) 
IF  pfkey <> pf_cancel
THEN
    pfkey := pf_none
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02allocat_packet (
            VAR source_tr   : trace_record;
            VAR packet_ptr  : tsp00_MoveObjPtr;
            VAR packet_size : tsp00_Int4;
            VAR ok          : boolean);
 
VAR
      src_trace_pos : integer;
      rest_len      : integer;
      requiredSize  : tsp00_Int4;
      packet_head   : tsp1_packet_header;
 
BEGIN
(* PTS 1000369 JA 1997-12-09 *)
src_trace_pos := sizeof (source_tr.longinfo_cnt  )
      +          sizeof (source_tr.longinfo_layer) + 1;
rest_len := source_tr.trceHead.vhLen_gg11
      -     sizeof (tgg11_VtraceHeader)
      -     sizeof (source_tr.longinfo_cnt  )
      -     sizeof (source_tr.longinfo_layer);
IF  rest_len > sizeof (packet_head)
THEN
    rest_len := sizeof (packet_head);
(*ENDIF*) 
SAPDB_PascalForcedMove (sizeof (source_tr.buf), sizeof (packet_head),
      @source_tr.buf, src_trace_pos,
      @packet_head, 1, rest_len);
(* PTS 1000442 JA 1997-12-16 *)
requiredSize := sizeof (packet_head) + packet_head.sp1h_varpart_size;
ok           := true;
IF  packet_ptr = NIL
THEN
    packet_size := requiredSize
ELSE
    IF  packet_size < requiredSize
    THEN
        BEGIN
        sqlfree (packet_ptr);
        packet_ptr  := NIL;
        packet_size := requiredSize;
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  packet_ptr = NIL
THEN
    sqlallocat (packet_size, packet_ptr, ok);
(*ENDIF*) 
IF  NOT ok
THEN
    BEGIN
    packet_ptr  := NIL;
    packet_size := 0
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02_BasisError (
            err        : tgg00_BasisError;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
BEGIN
IF  err <> e_ok
THEN
    BEGIN
    g17sname_to_line ('***         ', ln_len, ln);
    ln_len := ln_len + 1
    END;
(*ENDIF*) 
g17basis_err_to_line (err, ln_len, ln);
IF  err <> e_ok
THEN
    g17sname_to_line (' ***        ', ln_len, ln)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02bd_vtrace (
            bd_vtrace          : tgg00_VtraceType;
            VAR n              : tsp00_Sname;
            VAR is_io_trace    : boolean;
            VAR is_oms         : boolean;
            VAR ok             : boolean);
 
BEGIN
ok          := true;
is_oms      := false;
is_io_trace := false;
CASE bd_vtrace OF
    b01b_create:
        n := 'b01b_create ';
    b01create:
        n := 'b01create   ';
    b01destroy:
        n := 'b01destroy  ';
    b01empty:
        n := 'b01empty    ';
    b01p_destroy:
        n := 'b01p_destroy';
    b01rename:
        n := 'b01rename   ';
    b01t_create:
        n := 'b01t_create ';
    b01t_reset:
        n := 'b01t_reset  ';
    b01verify:
        n := 'b01verify   ';
    b02add:
        n := 'b02add      ';
    b02del:
        n := 'b02del      ';
    b02direct_qual:
        n := 'b02direct_ql';
    b02exists:
        n := 'b02exists   ';
    b02first_qual:
        n := 'b02first_ql ';
    b02get:
        n := 'b02get      ';
    b02kb_del:
        n := 'b02kb_del   ';
    b02kb_repl:
        n := 'b02kb_repl  ';
    b02last_qual:
        n := 'b02last_qual';
    b02logadd:
        n := 'b02logadd   ';
    b02next:
        n := 'b02next     ';
    b02next_qual:
        n := 'b02next_qual';
    b02prev:
        n := 'b02prev     ';
    b02prev_qual:
        n := 'b02prev_qual';
    b02repl:
        n := 'b02repl     ';
    b03add:
        n := 'b03add      ';
    b03aggr:
        n := 'b03aggr     ';
    b03check:
        n := 'b03check    ';
    b03create:
        n := 'b03/48create';
    b03del:
        n := 'b03del_inv  ';
    b03empty:
        n := 'b03test_uniq';
    b03imerge:
        n := 'b03imerge   ';
    b03intersect:
        n := 'b03intersect';
    b03eval:
        n := 'b03eval     ';
    b03first_qual:
        n := 'b03first_ql ';
    b03get:
        n := 'b03get      ';
    b03last_qual:
        n := 'b03last_qual';
    b03merge:
        n := 'b03merge    ';
    b03next_list:
        n := 'b03next_list';
    b03next_qual:
        n := 'b03next_qual';
    b03pcreate:
        n := 'b03pcreate  ';
    b03prev_qual:
        n := 'b03prev_qual';
    b03test:
        n := 'b03/48test  ';
    b04create:
        BEGIN
        n := 'b04CreateObj';
        is_oms := true
        END;
    b04del:
        BEGIN
        n := 'b04DelObj   ';
        is_oms := true
        END;
    b04DelAll:
        BEGIN
        n := 'b04DelAll   ';
        is_oms := true
        END;
    b04drop:
        BEGIN
        n := 'b04drop     ';
        is_oms := true
        END;
    b04get_consistent:
        BEGIN
        n := 'b04GetObjCns';
        is_oms := true
        END;
    b04GetObjWithKey:
        BEGIN
        n := 'b04GetObjKey';
        is_oms := true
        END;
    b04info:
        BEGIN
        n:=  'b04info     ';
        is_oms := true
        END;
    b04IsHistUsed:
        BEGIN
        n:=  'b04IsHistUse';
        is_oms := true
        END;
    b04IsSelfLocked:
        BEGIN
        n:=  'b04IsSelfLoc';
        is_oms := true
        END;
    b04lock:
        BEGIN
        n := 'b04LockObj  ';
        is_oms := true
        END;
    b04new:
        BEGIN
        n := 'b04NewObj   ';
        is_oms := true
        END;
    b04next_consistent:
        BEGIN
        n := 'b04NextObjCs';
        is_oms := true
        END;
    b04newhash:
        BEGIN
        n:=  'b04NewObjKey';
        is_oms := true
        END;
    b04newhash_consistent:
        BEGIN
        n:=  'b04GetHashCs';
        is_oms := true
        END;
    b04ResetLock:
        BEGIN
        n:=  'b04ResetLock';
        is_oms := true
        END;
    b04rupd:
        BEGIN
        n := 'b04RollbObj ';
        is_oms := true
        END;
    b04unlock:
        BEGIN
        n := 'b04UnlockObj';
        is_oms := true
        END;
    b04upd:
        BEGIN
        n := 'b04UpdObj   ';
        is_oms := true
        END;
    b04CreateKeyIter:
        BEGIN
        n := 'b04CreateIte';
        is_oms := true
        END;
    b04NextKey:
        BEGIN
        n := 'b04NextKey  ';
        is_oms := true
        END;
    b04DestroyIter:
        BEGIN
        n := 'b04DelIter  ';
        is_oms := true
        END;
    b91repair:
        BEGIN
        n := 'b91RepObjFil';
        is_oms := true
        END;
    b05find:
        n := 'b05find     ';
    b05getset:
        n := 'b05getset   ';
    b05length:
        n := 'b05length   ';
    b05trunc:
        n := 'b05trunc    ';
    b05copy:
        n := 'b05copy     ';
    b05expand:
        n := 'b05expand   ';
    b05read:
        n := 'b05read     ';
    b05write:
        n := 'b05write    ';
    b07cadd:
        n := 'b07cadd     ';
    b07cappend:
        n := 'b07cappend  ';
    b07cdel:
        n := 'b07cdel     ';
    b07cget:
        n := 'b07cget     ';
    b07cget_leaf:
        n := 'b07cget leaf'; (* PTS 1105706 TS 2000-02-24 *)
    b07cnext:
        n := 'b07cnext    ';
    b07cprev:
        n := 'b07cprev    ';
    b07crel_leaf:
        n := 'b07crel leaf'; (* PTS 1105706 TS 2000-02-24 *)
    b07crepl:
        n := 'b07crepl    ';
    b09append:
        n := 'b09append   ';
    b09next:
        n := 'b09next     ';
    b09prev:
        n := 'b09prev     ';
    b15read_page:
        BEGIN
        n := 'b15read     ';
        is_io_trace := true
        END;
    b15write_page:
        BEGIN
        n := 'b15write    ';
        is_io_trace := true
        END;
    b22rem_oid:
        BEGIN
        n := 'b22RemOId   ';
        is_oms := true
        END;
    b91garbcol:
        BEGIN
        n:=  'b91Garbage  ';
        is_oms := true
        END;
    b92verify:
        BEGIN
        n:=  'b92Verify   ';
        is_oms := true
        END;
    b92check_hash:
        BEGIN
        n:=  'b92CheckHash';
        is_oms := true
        END;
    b95redo_new:
        BEGIN
        n:=  'b95RedoNew  ';
        is_oms := true
        END;
    b95redo_del:
        BEGIN
        n:=  'b95RedoDel  ';
        is_oms := true
        END;
    b95redo_upd:
        BEGIN
        n:=  'b95RedoUpd  ';
        is_oms := true
        END;
    b95removeobj:
        BEGIN
        n:=  'b95RemObj   ';
        is_oms := true
        END;
    b95delkey:
        BEGIN
        n:=  'b95DelKey   ';
        is_oms := true
        END;
    b930DropFile:
        BEGIN
        n:=  'b930DropFile';
        is_oms := true
        END;
    b930Garbcol:
        BEGIN
        n:=  'b930Garbcol ';
        is_oms := true
        END;
    b930RemovePage:
        BEGIN
        n:=  'b930RemovePa';
        is_oms := true
        END;
    b_await_r:
        n := 'b13awaitread';
    b_await_w:
        n := 'b13await_wrt';
    b13share_wait  :
        n := 'b13share    ';
    b13exclusive_wait :
        n := 'b13exclusive';
    vttBdLockUpd_egg00 :
        BEGIN
        n:=  'bd04LockUpd ';
        is_oms := true
        END;
    OTHERWISE
        ok := false
    END
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02_CenterPnoToLine (
            pno        : tsp00_Int4;
            arrow      : arrow_type;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
CONST
      c_pno_ln_offset = 27;
 
VAR
      first_arrow_pos : integer;
      last_arrow_pos  : integer;
      i               : integer;
 
BEGIN
first_arrow_pos := ln_len + 2;
IF  ln_len < c_pno_ln_offset
THEN
    ln_len := c_pno_ln_offset;
(*ENDIF*) 
x05pageno_to_line (pno, ln_len > c_pno_ln_offset, ln_len, ln);
IF  arrow <> without_arrow
THEN
    BEGIN
    last_arrow_pos := first_arrow_pos + 1;
    IF  (ln [first_arrow_pos-1] = ' ') AND
        (ln [first_arrow_pos  ] = ' ') AND
        (ln [ last_arrow_pos  ] = ' ') AND
        (ln [ last_arrow_pos+1] = ' ')
    THEN
        BEGIN
        WHILE (ln [last_arrow_pos + 2] = ' ')
              AND (last_arrow_pos + 2 < sizeof (ln)) DO
            last_arrow_pos := last_arrow_pos + 1;
        (*ENDWHILE*) 
        FOR i := first_arrow_pos TO last_arrow_pos  DO
            ln [i] := '-';
        (*ENDFOR*) 
        IF  arrow = left_arrow
        THEN
            ln [first_arrow_pos] := '<'
        ELSE
            ln [last_arrow_pos] := '>'
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02center_pno_to_line (
            VAR buf    : tsp00_Buf;
            buf_pos    : integer;
            arrow      : arrow_type;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
BEGIN
xt02_CenterPnoToLine (s20buf_to_int4 (buf, buf_pos), arrow, ln_len, ln)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02_DateTimeToLine (
            DateInt   : tsp00_Int4;
            TimeInt   : tsp00_Int4;
            adjust    : boolean;
            VAR LnLen : integer;
            VAR Ln    : tsp00_Line);
 
CONST
      mx_date_displ = 10;
      mx_time_displ =  8;
 
VAR
      DateStr : tsp00_Date;
      TimeStr : tsp00_Time;
 
BEGIN
IF  LnLen + mx_date_displ + 1 +  mx_time_displ <= sizeof (Ln)
THEN
    BEGIN
    IF  adjust AND (LnLen + mx_date_displ + 1 + mx_time_displ <= PROT_LINESIZE)
    THEN
        LnLen := PROT_LINESIZE - mx_date_displ - 1 - mx_time_displ;
    (*ENDIF*) 
    g17intdate_time (DateInt, TimeInt, DateStr, TimeStr);
    g17date_to_line (DateStr, LnLen, Ln);
    LnLen := LnLen + 1;
    g17time_to_line (TimeStr, LnLen, Ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02datetime_to_line (
            VAR trace  : trace_record;
            trace_pos  : integer;
            adjust     : boolean;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
CONST
      mx_date_displ = 10;
      mx_time_displ =  8;
 
BEGIN
IF  ln_len + mx_date_displ + 1 + mx_time_displ <= PROT_LINESIZE
THEN
    BEGIN
    IF  adjust
    THEN
        ln_len := PROT_LINESIZE - mx_date_displ - 1 - mx_time_displ;
    (*ENDIF*) 
    ln [ln_len + 1] := trace.buf [trace_pos    ]; (* year *)
    ln [ln_len + 2] := trace.buf [trace_pos + 1]; (* year *)
    ln [ln_len + 3] := trace.buf [trace_pos + 2]; (* year *)
    ln [ln_len + 4] := trace.buf [trace_pos + 3]; (* year *)
    ln [ln_len + 5] := '-';
    ln [ln_len + 6] := trace.buf [trace_pos + 4]; (* month *)
    ln [ln_len + 7] := trace.buf [trace_pos + 5]; (* month *)
    ln [ln_len + 8] := '-';
    ln [ln_len + 9] := trace.buf [trace_pos + 6]; (* day *)
    ln [ln_len +10] := trace.buf [trace_pos + 7]; (* day *)
    ln_len := ln_len + 10
    END;
(*ENDIF*) 
IF  ln_len + 1 + mx_time_displ <= PROT_LINESIZE
THEN
    BEGIN
    ln_len := ln_len + 1;
    IF  adjust
    THEN
        ln_len := PROT_LINESIZE - mx_time_displ
    ELSE
        ln_len := ln_len + 1;
    (*ENDIF*) 
    ln [ln_len + 1] := trace.buf [trace_pos + 10]; (* hour *)
    ln [ln_len + 2] := trace.buf [trace_pos + 11]; (* hour *)
    ln [ln_len + 3] := ':';
    ln [ln_len + 4] := trace.buf [trace_pos + 12]; (* min *)
    ln [ln_len + 5] := trace.buf [trace_pos + 13]; (* min *)
    ln [ln_len + 6] := ':';
    ln [ln_len + 7] := trace.buf [trace_pos + 14]; (* sec *)
    ln [ln_len + 8] := trace.buf [trace_pos + 15]; (* sec *)
    ln_len := ln_len + 8
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02entry_pos_to_line (
            VAR f      : tut_file;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
BEGIN
g17trimint4_to_line (f.utf_entry_pno, ln_len, ln);
ln_len      := ln_len + 1;
ln [ln_len] := '.';
(* PTS 1000369 JA 1997-12-09 *)
g17trimint4_to_line (f.utf_entry_pos + OFFSET_FIRST_ENTRY, ln_len, ln);
g17sname_to_line ('  page      ', ln_len, ln);
ln_len := ln_len + 1;
g17trimint4_to_line (f.utf_pos.utfp_block_no, ln_len, ln);
IF  f.utf_pos.utfp_pages_per_block > 1
THEN
    BEGIN
    ln_len      := ln_len + 1;
    ln [ln_len] := '/';
    g17trimint4_to_line (f.utf_pos.utfp_page_no, ln_len, ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      xt02sess_contains_taskname (session : tgg91_SessionNo): boolean;
 
BEGIN
xt02sess_contains_taskname :=
      (session.ci4_gg00 [1] = chr (255)) AND
      (session.ci4_gg00 [2] = chr (  0)) AND
      (session.ci4_gg00 [3] = chr (  0))
END;
 
(*------------------------------*) 
 
FUNCTION
      xt02isuniasc (
            VAR moveobj : tsp00_MoveObj;
            buf_pos : tsp00_Int4;
            buf_len : tsp00_Int4) : boolean;
 
VAR
      ok       : boolean;
      i        : tsp00_Int4;
      mark_off : tsp00_Int4;
 
BEGIN
i  := 0;
ok := true;
IF  moveobj[ buf_pos ] = csp_unicode_mark
THEN
    mark_off := 0
ELSE
    IF  moveobj[ buf_pos+1 ] = csp_unicode_mark
    THEN
        mark_off := 1
    ELSE
        ok := false;
    (*ENDIF*) 
(*ENDIF*) 
WHILE ok AND (buf_pos+i < buf_len) DO
    BEGIN
    ok := (moveobj[ buf_pos+i+mark_off ] = csp_unicode_mark) AND
          (g17printable_char (moveobj[ buf_pos+i+1-mark_off ]));
    i  := i + 2
    END;
(*ENDWHILE*) 
xt02isuniasc := ok
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02mblock_handling (
            VAR source_tr       : trace_record;
            VAR target_tr       : trace_record;
            VAR target_len      : tsp00_Int4;
            VAR qual_buf        : tgg00_QualBuf;
            VAR stack_list      : tgg00_StackList;
            VAR data_alloc_ok   : boolean;
            VAR strat_alloc_ok  : boolean);
 
VAR
      aux_len       : tsp00_Int4;
      rest_len      : tsp00_Int4;
      skip_len      : tsp00_Int4;
      curr_move_len : tsp00_Int4;
      curr_st_len   : tsp00_Int4;
      src_trace_pos : integer;
      aux_ptr       : t_aux_ptr;
 
BEGIN
WITH target_tr DO
    BEGIN
    (* PTS 1105306 E.Z. *)
    data_alloc_ok := true;
    strat_alloc_ok:= true;
    (* PTS 1000369 JA 1997-12-09 *)
    src_trace_pos := sizeof (source_tr.longinfo_cnt  )
          +          sizeof (source_tr.longinfo_layer) + 1;
    rest_len := source_tr.trceHead.vhLen_gg11
          -     sizeof (tgg11_VtraceHeader)
          -     sizeof (source_tr.longinfo_cnt  )
          -     sizeof (source_tr.longinfo_layer);
    IF  target_len < sizeof (mblock)
    THEN
        BEGIN
        IF  sizeof (mblock) - target_len > rest_len
        THEN
            curr_move_len := rest_len
        ELSE
            curr_move_len := sizeof (mblock) - target_len;
        (*ENDIF*) 
        SAPDB_PascalForcedMove (sizeof (source_tr.buf), sizeof (mblock),
              @source_tr.buf, src_trace_pos,
              @mblock, target_len + 1, curr_move_len);
        rest_len      := rest_len      - curr_move_len;
        src_trace_pos := src_trace_pos + curr_move_len;
        target_len    := target_len    + curr_move_len;
        WITH mbl_xt_mtrail DO
            BEGIN
            mb_qual        := NIL;
            mb_st          := NIL;
            mb_strat       := NIL;
            mb_work_st     := NIL;
            mb_workbuf     := NIL;
            mb_next_mblock := NIL;
            mb_trns        := NIL;
            mb_qual_size   := 0;
            mb_st_size     := 0;
            mb_st_max      := 0;
            mb_work_st_max := 0
            END;
        (*ENDWITH*) 
        IF  target_len >= sizeof (mblock)
        THEN
            BEGIN
            IF  mblock.mb_qual_len > 0
            THEN
                BEGIN
                mbl_xt_mtrail.mb_qual      := @qual_buf;
                mbl_xt_mtrail.mb_qual_size := sizeof (qual_buf);
                END;
            (*ENDIF*) 
            IF  (mblock.mb_data_len > 0)
                AND
                (mbl_xt_mtrail.mb_data = NIL)
            THEN
                BEGIN
                sqlallocat (mblock.mb_data_size, aux_ptr.x_moveobj_ptr, data_alloc_ok);
                IF  data_alloc_ok
                THEN
                    BEGIN
                    mbl_xt_mtrail.mb_data      := aux_ptr.x_data_ptr;
                    mbl_xt_mtrail.mb_data_size := mblock.mb_data_size
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  (mblock.mb_strat_len > 0)
                AND
                (mbl_xt_mtrail.mb_strat = NIL)
            THEN
                BEGIN
                sqlallocat (mblock.mb_strat_size, aux_ptr.x_moveobj_ptr, strat_alloc_ok);
                IF  strat_alloc_ok
                THEN
                    BEGIN
                    mbl_xt_mtrail.mb_strat      := aux_ptr.x_moveobj_ptr;
                    mbl_xt_mtrail.mb_strat_size := mblock.mb_strat_size
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  (mblock.mb_st   <> NIL) AND
                (mblock.mb_qual <> NIL)
            THEN
                BEGIN
                mbl_xt_mtrail.mb_st      := @stack_list;
                mbl_xt_mtrail.mb_st_size := sizeof (stack_list)
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  ( data_alloc_ok AND strat_alloc_ok )
    THEN
        BEGIN
        IF  rest_len > 0
        THEN
            BEGIN
            IF  mbl_qual_pos <= mblock.mb_qual_len
            THEN
                BEGIN
                IF  mblock.mb_qual_len - mbl_qual_pos + 1 > rest_len
                THEN
                    curr_move_len := rest_len
                ELSE
                    curr_move_len :=
                          mblock.mb_qual_len - mbl_qual_pos + 1;
                (*ENDIF*) 
                SAPDB_PascalForcedMove (sizeof (source_tr.buf),
                      mbl_xt_mtrail.mb_qual_size,
                      @source_tr.buf, src_trace_pos,
                      @mbl_xt_mtrail.mb_qual^.buf, mbl_qual_pos,
                      curr_move_len);
                rest_len      := rest_len      - curr_move_len;
                src_trace_pos := src_trace_pos + curr_move_len;
                mbl_qual_pos  := mbl_qual_pos  + curr_move_len;
                target_len    := target_len    + curr_move_len
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  rest_len > 0
        THEN
            BEGIN
            IF  mbl_data_pos <= mblock.mb_data_len
            THEN
                BEGIN
                IF  mblock.mb_data_len - mbl_data_pos + 1 > rest_len
                THEN
                    curr_move_len := rest_len
                ELSE
                    curr_move_len :=
                          mblock.mb_data_len - mbl_data_pos + 1;
                (*ENDIF*) 
                IF  mbl_data_pos > mbl_xt_mtrail.mb_data_size
                THEN
                    BEGIN
                    skip_len      := curr_move_len;
                    curr_move_len := 0
                    END
                ELSE
                    BEGIN
                    IF  mbl_data_pos + curr_move_len - 1 >
                        mbl_xt_mtrail.mb_data_size
                    THEN
                        BEGIN
                        aux_len       := curr_move_len;
                        curr_move_len := mbl_xt_mtrail.mb_data_size
                              - mbl_data_pos + 1;
                        skip_len      := aux_len - curr_move_len
                        END
                    ELSE
                        skip_len := 0
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  curr_move_len > 0
                THEN
                    BEGIN
                    SAPDB_PascalForcedMove (sizeof (source_tr.buf),
                          mbl_xt_mtrail. mb_data_size,
                          @source_tr.buf, src_trace_pos,
                          @mbl_xt_mtrail.mb_data^.mbp_buf, mbl_data_pos,
                          curr_move_len);
                    END;
                (*ENDIF*) 
                rest_len     := rest_len     - curr_move_len - skip_len;
                src_trace_pos:= src_trace_pos+ curr_move_len + skip_len;
                mbl_data_pos := mbl_data_pos + curr_move_len + skip_len;
                target_len   := target_len   + curr_move_len
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (rest_len > 0) AND (mbl_xt_mtrail.mb_st <> NIL)
        THEN
            BEGIN
            IF  mbl_xt_mtrail.mb_qual = NIL
            THEN
                curr_st_len := 0
            ELSE
                curr_st_len := (mbl_xt_mtrail.mb_qual^.mfirst_free - 1)
                      * sizeof (tgg00_StackEntry);
            (*ENDIF*) 
            IF  mbl_stack_pos <= curr_st_len
            THEN
                BEGIN
                IF  curr_st_len - mbl_stack_pos + 1 > rest_len
                THEN
                    curr_move_len := rest_len
                ELSE
                    curr_move_len := curr_st_len - mbl_stack_pos + 1;
                (*ENDIF*) 
                SAPDB_PascalForcedMove (sizeof (source_tr.buf),
                      mbl_xt_mtrail.mb_st_size,
                      @source_tr.buf, src_trace_pos,
                      @mbl_xt_mtrail.mb_st^, mbl_stack_pos,
                      curr_move_len);
                rest_len      := rest_len      - curr_move_len;
                src_trace_pos := src_trace_pos + curr_move_len;
                mbl_stack_pos := mbl_stack_pos + curr_move_len;
                target_len    := target_len    + curr_move_len
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (rest_len > 0) AND (mblock.mb_strat_len > 0)
        THEN
            IF  mbl_strat_pos <= mblock.mb_strat_len
            THEN
                BEGIN
                IF  mblock.mb_strat_len - mbl_strat_pos + 1 > rest_len
                THEN
                    curr_move_len := rest_len
                ELSE
                    curr_move_len :=
                          mblock.mb_strat_len - mbl_strat_pos + 1;
                (*ENDIF*) 
                (* PTS 1115266 M.Ki. *)
                IF  mbl_strat_pos + curr_move_len < mbl_xt_mtrail.mb_strat_size
                THEN
                    SAPDB_PascalForcedMove (sizeof (source_tr.buf),
                          mbl_xt_mtrail.mb_strat_size,
                          @source_tr.buf, src_trace_pos,
                          @mbl_xt_mtrail.mb_strat^, mbl_strat_pos,
                          curr_move_len)
                ELSE
                    SAPDB_PascalForcedMove (sizeof (source_tr.buf),
                          mbl_xt_mtrail.mb_strat_size,
                          @source_tr.buf, src_trace_pos,
                          @mbl_xt_mtrail.mb_strat^, mbl_strat_pos,
                          mbl_xt_mtrail.mb_strat_size - mbl_strat_pos + 1);
                (*ENDIF*) 
                rest_len      := rest_len      - curr_move_len;
                src_trace_pos := src_trace_pos + curr_move_len;
                mbl_strat_pos := mbl_strat_pos + curr_move_len;
                target_len    := target_len    + curr_move_len
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  rest_len > 0
        THEN
            IF  mbl_trans_pos <= sizeof (mbl_trans)
            THEN
                BEGIN
                IF  sizeof (mbl_trans) - mbl_trans_pos + 1 > rest_len
                THEN
                    curr_move_len := rest_len
                ELSE
                    curr_move_len :=
                          sizeof (mbl_trans) - mbl_trans_pos + 1;
                (*ENDIF*) 
                IF  curr_move_len > 0
                THEN
                    SAPDB_PascalForcedMove (sizeof (source_tr.buf), sizeof (mbl_trans),
                          @source_tr.buf, src_trace_pos,
                          @mbl_trans, mbl_trans_pos, curr_move_len);
                (*ENDIF*) 
                rest_len      := rest_len      - curr_move_len;
                src_trace_pos := src_trace_pos + curr_move_len;
                mbl_trans_pos := mbl_trans_pos + curr_move_len;
                target_len    := target_len    + curr_move_len
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02menu_main (
            VAR term          : tut_terminal;
            VAR protfile      : tut_vf_fileref;
            VAR f             : tut_file;
            cmd_token         : tsp00_Name;
            VAR is_exit       : boolean;
            VAR pfkey         : tut_pfkey);
 
CONST
      on_noselect  = '-                   ';
      on_minbuf    = '-                   ';
      on_maxbuf    = '-                   ';
      on_hexln     = '-                   ';
      on_displ     = '-                   ';
      on_nodispl   = '-                   ';
      off_noselect = 'TRACE SELECTION OFF ';
      off_minbuf   = 'MINBUF              ';
      off_maxbuf   = 'MAXBUF              ';
      off_hexln    = 'HEXLINE             ';
      off_displ    = 'DISPLAY             ';
      off_nodispl  = 'NODISPLAY           ';
      (* --- column 1 --- *)
      x_all      =  1;
      x_last     =  2;
      x_from     =  3;
      x_cmd      =  5;
      x_error    =  6;
      x_sel_task =  8;
      x_noselect = 10;
      (* --- column 2 --- *)
      x_minbuf   = 11;
      x_maxbuf   = 12;
      x_hexln    = 13;
      x_displ    = 14;
      x_nodispl  = 15;
      x_maxlen   = 16;
      x_hexint   = 17;
      x_other    = 19;
      x_exit     = 20;
 
VAR
      term_wanted    : boolean;
      select_trace   : boolean;
      search_retcode : tsp00_Int4;
      i4             : tsp00_Int4;
      wanted_pno     : tsp00_Int4;
      wanted_pos     : tsp00_Int4;
      stop_pno       : tsp00_Int4;
      stop_pos       : tsp00_Int4;
      selected       : integer;
      search_op      : tsp00_Name;
      search_cmd     : tsp00_VFilename;
      wanted_trace   : tgg11_VtraceHeader;
      msg            : tut_c20_array;
      d              : t_DisplState;
 
BEGIN
is_exit                := false;
pfkey                  := pf_none;
d.dsTerm               := @term;
d.dsProt               := @protfile;
d.dsMaxBuflength       := OUT_MAXBUFLENFGTH;
d.dsPfkey              := pf_none;
d.dsTdbufWanted        := false;
d.dsIsMinbuf           := false;
d.dsLeaveFunctSign [1] := ' '; (* disable leave display until first occurrence of slow trace *)
search_retcode := 0;
search_op      := bsp_name;
search_cmd     := term.blankfilename;
select_trace   := false;
term_wanted    := false;
wanted_pno     := f.utf_cycle_lwb_pno;
wanted_pos     := 1;
stop_pno       := wanted_pno;
stop_pos       := wanted_pos;
wanted_trace.vhTask_gg11 := cgg_nil_pid;
gg06SetNilSession (wanted_trace.vhSession_gg11);
gg06SetNilTrans   (wanted_trace.vhTrans_gg11);
FOR selected := 1 TO x_exit DO
    msg [selected] :=  bsp_c20;
(*ENDFOR*) 
msg [x_all     ] := 'ALL                 ';
msg [x_last    ] := 'LAST                ';
msg [x_from    ] := 'FROM/TO             ';
msg [x_cmd     ] := 'FIND COMMAND        ';
msg [x_error   ] := 'FIND RETURN CODE    ';
msg [x_sel_task] := 'TASK SELECT         ';
msg [x_noselect] := on_noselect;
msg [x_minbuf  ] := off_minbuf;
msg [x_maxbuf  ] := off_maxbuf;
msg [x_hexln   ] := on_hexln;
msg [x_displ   ] := off_displ;
msg [x_nodispl ] := on_nodispl;
msg [x_maxlen  ] := 'BUFFER LENGTH       ';
msg [x_hexint  ] := 'HEXINT              ';
msg [x_other   ] := 'INPUTFILE           ';
msg [x_exit    ] := 'EXIT                ';
REPEAT
    IF  cmd_token = bsp_name
    THEN
        t09menu (term, x_exit, cut_protected, msg, selected, pfkey)
    ELSE
        selected := x_all;
    (*ENDIF*) 
    IF  pfkey = pf_none
    THEN
        BEGIN
        CASE selected OF
            x_all:
                BEGIN
                t09newscreen_page (term);
                wanted_pno := f.utf_cycle_lwb_pno;
                wanted_pos := 1;
                stop_pno   := f.utf_cycle_upb_pno;
                stop_pos   := sizeof (tsp00_Page);
                xt02scan_vtrace (d, f, cmd_token, term_wanted, select_trace,
                      wanted_trace, wanted_pno, wanted_pos,
                      stop_pno, stop_pos, pfkey);
                wanted_pno := f.utf_entry_pno;
                wanted_pos := f.utf_entry_pos
                END;
            x_last:
                BEGIN
                t09newscreen_page (term);
                x05readint4 (term, c_init, NOT c_int2,
                      '  NO OF LAST PAGES :', i4, pfkey);
                IF  pfkey = pf_none
                THEN
                    BEGIN
                    t09newscreen_page (term);
                    wanted_pno := f.utf_cycle_upb_pno - i4 + 1;
                    wanted_pos := 1;
                    stop_pno   := f.utf_cycle_upb_pno;
                    stop_pos   := sizeof (tsp00_Page);
                    IF  wanted_pno < f.utf_cycle_lwb_pno
                    THEN
                        wanted_pno := f.utf_cycle_lwb_pno;
                    (*ENDIF*) 
                    xt02scan_vtrace (d, f, cmd_token, term_wanted, select_trace,
                          wanted_trace, wanted_pno, wanted_pos,
                          stop_pno, stop_pos, pfkey)
                    END
                (*ENDIF*) 
                END;
            x_from:
                BEGIN
                (* PTS 1000369 JA 1997-12-09 *)
                wanted_pos := wanted_pos + OFFSET_FIRST_ENTRY;
                stop_pos   := stop_pos   + OFFSET_FIRST_ENTRY;
                x05read_entry_pos_from_to (term, f, NOT c_only_from,
                      wanted_pno, wanted_pos, stop_pno, stop_pos,pfkey);
                IF  pfkey = pf_none
                THEN
                    BEGIN
                    (* PTS 1000369 JA 1997-12-09 *)
                    wanted_pos := wanted_pos - OFFSET_FIRST_ENTRY;
                    stop_pos   := stop_pos   - OFFSET_FIRST_ENTRY;
                    IF  wanted_pos < 1
                    THEN
                        wanted_pos := 1;
                    (*ENDIF*) 
                    IF  stop_pos < 1
                    THEN
                        stop_pos := 1;
                    (*ENDIF*) 
                    xt02scan_vtrace (d, f, cmd_token, term_wanted, select_trace,
                          wanted_trace, wanted_pno, wanted_pos,
                          stop_pno, stop_pos, pfkey)
                    END
                (*ENDIF*) 
                END;
            x_cmd:
                BEGIN
                END;
            x_error:
                BEGIN
                END;
            x_sel_task:
                BEGIN
                x05readint4 (term, wanted_trace.vhTask_gg11 = cgg_nil_pid,
                      c_int2, '      ENTER TASK-ID:', i4, pfkey);
                IF  pfkey = pf_none
                THEN
                    BEGIN
                    wanted_trace.vhTask_gg11 := i4;
                    msg [x_noselect]         := off_noselect;
                    select_trace             := true;
                    gg06SetNilSession (wanted_trace.vhSession_gg11);
                    gg06SetNilTrans   (wanted_trace.vhTrans_gg11)
                    END
                (*ENDIF*) 
                END;
            x_noselect:
                BEGIN
                x05display_msg (term, off_noselect, NOT c_warning,
                      NOT c_immediate_displ);
                msg [x_noselect]         := on_noselect;
                select_trace             := false;
                wanted_trace.vhTask_gg11 := cgg_nil_pid;
                gg06SetNilSession (wanted_trace.vhSession_gg11);
                gg06SetNilTrans   (wanted_trace.vhTrans_gg11)
                END;
            x_minbuf:
                BEGIN
                x05display_msg (term, off_minbuf, NOT c_warning,
                      NOT c_immediate_displ);
                msg [x_minbuf]  := on_minbuf;
                msg [x_maxbuf]  := off_maxbuf;
                msg [x_hexln ]  := off_hexln;
                d.dsTdbufWanted := true;
                d.dsIsMinbuf    := true
                END;
            x_maxbuf:
                BEGIN
                x05display_msg (term, off_maxbuf, NOT c_warning,
                      NOT c_immediate_displ);
                msg [x_minbuf]  := off_minbuf;
                msg [x_maxbuf]  := on_maxbuf;
                msg [x_hexln ]  := off_hexln;
                d.dsTdbufWanted := true;
                d.dsIsMinbuf    := false
                END;
            x_hexln:
                BEGIN
                x05display_msg (term, off_hexln, NOT c_warning,
                      NOT c_immediate_displ);
                msg [x_minbuf]  := off_minbuf;
                msg [x_maxbuf]  := off_maxbuf;
                msg [x_hexln ]  := on_hexln;
                d.dsTdbufWanted := false
                END;
            x_displ:
                BEGIN
                x05display_msg (term, off_displ, NOT c_warning,
                      NOT c_immediate_displ);
                msg [x_displ  ] := on_displ;
                msg [x_nodispl] := off_nodispl;
                term_wanted     := true
                END;
            x_nodispl:
                BEGIN
                x05display_msg (term, off_nodispl, NOT c_warning,
                      NOT c_immediate_displ);
                msg [ x_displ   ] := off_displ;
                msg [ x_nodispl ] := on_nodispl;
                term_wanted       := false
                END;
            x_maxlen:
                BEGIN
                IF  d.dsMaxBuflength <= 0
                THEN
                    d.dsMaxBuflength := OUT_MAXBUFLENFGTH
                (*ENDIF*) 
                END;
            x_hexint:
                x05hexint (term, protfile, pfkey);
            x_other:
                pfkey := pf_end;
            x_exit:
                BEGIN
                is_exit := true;
                pfkey   := pf_end
                END;
            OTHERWISE
                pfkey := pfkey;
            END;
        (*ENDCASE*) 
        IF  (pfkey = pf_end  ) AND
            (selected <> x_other) AND
            (selected <> x_exit )
        THEN
            pfkey := pf_none;
        (*ENDIF*) 
        IF  NOT term.is_batch AND (cmd_token = bsp_name)
        THEN
            t09display (term, c_on)
        (*ENDIF*) 
        END
    (*ENDIF*) 
UNTIL
    (pfkey = pf_cancel) OR (pfkey = pf_end) OR (cmd_token <> bsp_name);
(*ENDREPEAT*) 
IF  pfkey = pf_end
THEN
    pfkey := pf_none;
(*ENDIF*) 
t09putmsg (term, term.blankline, NOT c_warning, NOT c_immediate_displ)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02mess_types_to_line (
            mtype      : tgg00_MessType;
            mtype2     : tgg00_MessType2;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
BEGIN
IF  mtype <> m_return_error
THEN
    BEGIN
    g17messtype_to_line (mtype, ln_len, ln);
    IF  (mtype <> m_return_result) AND (mtype2 <> mm_nil)
    THEN
        BEGIN
        ln_len := ln_len + 1;
        g17mess2type_to_line (mtype2, ln_len, ln)
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02packet_handling (
            VAR source_tr   : trace_record;
            VAR target_tr   : trace_record;
            VAR packet_buf  : tsp00_MoveObj;
            packet_buf_size : tsp00_Int4;
            VAR packet_pos  : tsp00_Int4);
 
VAR
      rest_len      : tsp00_Int4;
      src_trace_pos : integer;
 
BEGIN
WITH target_tr DO
    BEGIN
    (* PTS 1000369 JA 1997-12-09 *)
    src_trace_pos := sizeof (source_tr.longinfo_cnt  )
          +          sizeof (source_tr.longinfo_layer) + 1;
    rest_len := source_tr.trceHead.vhLen_gg11
          -     sizeof (tgg11_VtraceHeader)
          -     sizeof (source_tr.longinfo_cnt  )
          -     sizeof (source_tr.longinfo_layer);
    IF  (rest_len > 0)
        AND
        (src_trace_pos - 1 + rest_len <= sizeof (source_tr.buf))
        AND
        (packet_pos - 1 + rest_len <= packet_buf_size)
        (* PTS 1000442 JA 1997-12-16 *)
    THEN
        BEGIN
        SAPDB_PascalForcedMove (sizeof (source_tr.buf), packet_buf_size,
              @source_tr.buf, src_trace_pos,
              @packet_buf, packet_pos, rest_len);
        packet_pos                    := packet_pos + rest_len;
        target_tr.trceHead.vhLen_gg11 := target_tr.trceHead.vhLen_gg11 + rest_len;
        target_tr.packet_ptr          := @packet_buf;
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_bd (
            VAR d         : t_DisplState;
            VAR trace     : trace_record);
 
VAR
      ok          : boolean;
      is_oms      : boolean;
      is_io_trace : boolean;
      ln_len      : integer;
      err         : integer;
      trace_name  : tsp00_Sname;
      ln          : tsp00_Line;
      moveobj_ptr : tsp00_MoveObjPtr;
 
BEGIN
xt02bd_vtrace (trace.trceHead.vhType_gg11, trace_name, is_io_trace, is_oms, ok);
IF  NOT ok
    OR (trace.trceHead.vhLen_gg11 <= sizeof (tgg11_VtraceHeader))
THEN
    BEGIN
    ln     := d.dsTerm^.blankline;
    ln_len := 1;
    IF  ok
    THEN
        g17sname_to_line (trace_name, ln_len, ln)
    ELSE
        BEGIN
        g17sname_to_line ('BD_VTRACE = ', ln_len, ln);
        ln_len := ln_len + 1;
        g17trimint4_to_line (ord(trace.trceHead.vhType_gg11), ln_len, ln)
        END;
    (*ENDIF*) 
    t12write_prot (d.dsProt^, ln, ln_len, err);
    t09put (d.dsTerm^, ln, cut_protected)
    END
ELSE
    IF  is_oms
    THEN
        xt02print_bd_object (d, trace, trace_name, ok)
    ELSE
        IF  is_io_trace
        THEN
            xt02print_bd_io (d.dsTerm^, d.dsProt^, trace, trace_name)
        ELSE
            xt02print_bd_trace (d, trace, trace_name, ok);
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
IF  NOT ok
THEN
    BEGIN
    ln          := d.dsTerm^.blankline;
    ln_len      := 0;
    moveobj_ptr := @trace.buf;
    xt02print_hex (d, moveobj_ptr^, sizeof (trace.buf), 1,
          trace.trceHead.vhLen_gg11 - sizeof (tgg11_VtraceHeader), 2, ln_len, ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_bd_io (
            VAR term       : tut_terminal;
            VAR protfile   : tut_vf_fileref;
            VAR trace      : trace_record;
            VAR trace_name : tsp00_Sname);
 
CONST
      c_dt_sys       =  0;
      c_dt_log       =  1;
      c_dt_mirr_log  =  2;
      c_dt_data      =  3;
      c_dt_trace     =  4;
      c_dt_tape      = 20;
 
VAR
      arrow      : arrow_type;
      ln_len     : integer;
      aux_ln_len : integer;
      err        : integer;
      n          : tsp00_Sname;
      ln         : tsp00_Line;
 
BEGIN
ln      := term.blankline;
ln_len  := 1;
g17sname_to_line (trace_name, ln_len, ln);
IF  MIN_LABEL_LEN > ln_len
THEN
    ln_len := MIN_LABEL_LEN;
(*ENDIF*) 
IF  trace.io_buf_no <= 1
THEN
    ln [1] := BLOCK_IO_SIGN;
(*ENDIF*) 
IF  trace.io_buf_no > 0
THEN
    (* multiple io *)
    BEGIN
    ln_len := ln_len - 1; (* output: 'read9'/'writ9' *)
    g17trimint4_to_line (trace.io_buf_no, ln_len, ln)
    END;
(*ENDIF*) 
ln_len := ln_len + 1;
g17pagetype_to_line (trace.io_pagetype, ln_len, ln);
IF  trace.io_pagetype2 <> pt2Nil_egg00
THEN
    BEGIN
    ln [ln_len+1] := ' ';
    ln_len := ln_len + 1;
    g17pagetype2_to_line (trace.io_pagetype2, ln_len,ln)
    END;
(*ENDIF*) 
IF  trace.trceHead.vhType_gg11 = b15read_page
THEN
    arrow := left_arrow
ELSE
    arrow := right_arrow;
(*ENDIF*) 
xt02center_pno_to_line (trace.buf, 5, arrow, ln_len, ln);
IF  trace.io_dev_type = c_dt_tape
THEN
    BEGIN
    g17sname_to_line ('; tape      ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (trace.io_dev_no, ln_len, ln)
    END
ELSE
    BEGIN
    g17sname_to_line ('; pno       ', ln_len, ln);
    (* " ddev 12:"  ==>  len + 9 *)
    aux_ln_len := ln_len + 9;
    CASE trace.io_dev_type OF
        c_dt_sys:
            n :=        ' sysdev     ';
        c_dt_log:
            n :=        ' log        ';
        c_dt_mirr_log:
            n :=        ' Mlog       ';
        c_dt_data:
            n :=        ' ddev       ';
        c_dt_trace:
            n :=        ' trace      ';
        OTHERWISE
            n :=        ' dev        '
        END;
    (*ENDCASE*) 
    g17sname_to_line (n, ln_len, ln);
    ln_len := ln_len + 1;
    IF  (trace.io_dev_type <> c_dt_sys)
        OR
        (trace.io_dev_no > 1)
    THEN
        BEGIN
        g17trimint4_to_line (trace.io_dev_no, ln_len, ln);
        ln_len := ln_len + 1
        END;
    (*ENDIF*) 
    ln [ln_len] := ':';
    IF  aux_ln_len > ln_len
    THEN
        ln_len := aux_ln_len;
    (*ENDIF*) 
    x05pageno_to_line (s20buf_to_int4 (trace.buf, 9), ln_len > aux_ln_len, ln_len, ln)
    END;
(*ENDIF*) 
t12write_prot (protfile, ln, ln_len, err);
t09put (term, ln, cut_protected)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_bd_object (
            VAR d          : t_DisplState;
            VAR trace      : trace_record;
            VAR trace_name : tsp00_Sname;
            VAR ok         : boolean);
 
VAR
      ln_len  : integer;
      ln      : tsp00_Line;
 
BEGIN
ok     := true;
ln     := d.dsTerm^.blankline;
ln_len := LINE_FUNCT_INDENT;
g17sname_to_line (trace_name, ln_len, ln);
IF  MIN_OBJ_LABEL_LEN > ln_len
THEN
    ln_len := MIN_OBJ_LABEL_LEN;
(*ENDIF*) 
ln_len := ln_len + 1;
CASE trace.OmsTraceType OF
    otError_egg12:
        xt02print_oms_error (d, trace, ln_len, ln);
    otFileInfo_egg12:
        xt02print_oms_file_info (d, trace, ln_len, ln);
    otFilename_egg12:
        xt02print_filename (d.dsTerm^, d.dsProt^, CALL_FUNCTION_SIGN, trace_name,
              trace.OmsFilename.ofnFileName_gg12);
    otGarbColl_egg12:
        xt02print_oms_garb_coll (d, trace, ln_len, ln);
    otKey_egg12:
        xt02print_oms_key (d, trace, ln_len, ln);
    otOid_egg12:
        xt02print_oms_oid (d, trace, ln_len, ln);
    otPageChainStat_egg12:
        xt02print_oms_page_chain_stat (d, trace, ln_len, ln);
    otPageContainerStat_egg12:
        xt02print_oms_page_container_stat (d.dsTerm^, d.dsProt^, trace, ln_len, ln);
    otPageStat_egg12:
        xt02print_oms_page_stat (d.dsTerm^, d.dsProt^, trace, ln_len, ln);
    otVersionError_egg12:
        xt02print_oms_version_error (d.dsTerm^, d.dsProt^, trace, ln_len, ln);
    otRelOid_egg12:
        xt02print_oms_rel_obj_stat (d, trace, ln_len, ln);
    otTwoKeys_egg12:
        xt02print_oms_keys_of_iterator (d, trace, ln_len, ln); (* PTS 1111934 AK 25/09/2001 *)
    OTHERWISE
        ok := false
    END
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_bd_trace (
            VAR d          : t_DisplState;
            VAR trace      : trace_record;
            VAR trace_name : tsp00_Sname;
            VAR ok         : boolean);
 
VAR
      err             : integer;
      i               : integer;
      items           : integer;
      ln_len          : integer;
      new_line_offset : integer;
      msg             : ARRAY [1..4] OF tsp00_Sname;
      ln              : tsp00_Line;
 
BEGIN
ok := true;
IF  ord (trace.trceBdRoot.bdrTrType_gg11) > ord (bdtrWriteStr_egg11)
THEN
    trace.trceBdRoot.bdrTrType_gg11 := bdtrNil_egg11;
(*ENDIF*) 
IF  trace.trceBdRoot.bdrTrType_gg11 <> bdtrFilename_egg11
THEN
    BEGIN
    ln     := d.dsTerm^.blankline;
    ln_len := LINE_FUNCT_INDENT;
    ln [1] := CALL_FUNCTION_SIGN;
    g17sname_to_line (trace_name, ln_len, ln);
    IF  MIN_LABEL_LEN > ln_len
    THEN
        ln_len := MIN_LABEL_LEN;
    (*ENDIF*) 
    ln_len          := ln_len + 1;
    new_line_offset := ln_len
    END;
(*ENDIF*) 
CASE trace.trceBdRoot.bdrTrType_gg11 OF
    bdtrInt_egg11:
        BEGIN
        CASE trace.trceHead.vhType_gg11 OF
            b_await_r, b_await_w, b13share_wait, b13exclusive_wait, b07crel_leaf:(* PTS 1105706 TS 2000-02-24 *)
                BEGIN
                g17sname_to_line ('pno         ', ln_len, ln);
                xt02_CenterPnoToLine (trace.trceBdInt.bdiInt_gg11[0], without_arrow, ln_len, ln)
                END;
            b07cnext, b07cprev, b07cget_leaf: (* PTS 1105706 TS 2000-02-24 *)
                BEGIN
                g17sname_to_line ('leaf        ', ln_len, ln);
                xt02_CenterPnoToLine (trace.trceBdInt.bdiInt_gg11[0], without_arrow, ln_len, ln);
                g17sname_to_line ('; index     ', ln_len, ln);
                ln_len := ln_len + 1;
                g17trimint4_to_line (trace.trceBdInt.bdiInt_gg11[1], ln_len, ln)
                END;
            OTHERWISE
                BEGIN
                CASE trace.trceHead.vhType_gg11 OF
                    b05expand, b05trunc:
                        BEGIN
                        items  := 1;
                        msg[1] := 'length      '
                        END;
                    b05find:
                        BEGIN
                        items  := 2;
                        msg[1] := 'startpos    ';
                        msg[2] := '; stoppos   '
                        END;
                    b05read:
                        BEGIN
                        items  := 2;
                        msg[1] := 'pos         ';
                        msg[2] := '; length    '
                        END;
                    b05copy:
                        BEGIN
                        items  := 3;
                        msg[1] := 'from        ';
                        msg[2] := '; to        ';
                        msg[3] := '; length    '
                        END;
                    b02first_qual, b02next_qual, b02direct_qual,
                    b02prev_qual, b02last_qual,
                    b03first_qual, b03next_qual,
                    b03prev_qual, b03last_qual :
                        BEGIN
                        SAPDB_PascalForcedFill( sizeof(ln), @ln, 1,
                              sizeof(tsp00_Name), bsp_c1 );
                        items  := 1;
                        msg[1] := 'res cnt     ';
                        END;
                    OTHERWISE
                        BEGIN
                        items := 0;
                        ok    := false
                        END
                    END;
                (*ENDCASE*) 
                FOR i := 1 TO items DO
                    BEGIN
                    g17sname_to_line (msg[i], ln_len, ln);
                    ln_len := ln_len + 1;
                    g17trimint4_to_line (trace.trceBdInt.bdiInt_gg11[i-1], ln_len, ln)
                    END
                (*ENDFOR*) 
                END
            END;
        (*ENDCASE*) 
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected)
        END;
    bdtrAppendTrans_egg11:
        BEGIN
        ln [1] := CALL_FUNCTION_SIGN;
        g17sname_to_line ('log(        ', ln_len, ln);
        g17trimint4_to_line (trace.trceBdAppendTrans.bdatLen_gg11, ln_len, ln);
        ln [ln_len+1]  := ')';
        ln [ln_len+2]  := ':';
        ln_len         := ln_len + 3;
        gg06TransToLine (trace.trceBdAppendTrans.bdatTrans_gg11, ln_len, ln);
        ln_len := ln_len + 1;
        g17messtype_to_line (trace.trceBdAppendTrans.bdatLogType_gg11, ln_len, ln);
        IF  trace.trceBdAppendTrans.bdatLogType2_gg11 <> mm_nil
        THEN
            BEGIN
            ln_len := ln_len + 1;
            g17mess2type_to_line (trace.trceBdAppendTrans.bdatLogType2_gg11, ln_len, ln)
            END;
        (*ENDIF*) 
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected)
        END;
    bdtrFilename_egg11:
        xt02print_filename (d.dsTerm^, d.dsProt^, CALL_FUNCTION_SIGN, trace_name,
              trace.trceBdFilename.bdfFn_gg11);
    bdtrKey_egg11:
        xt02print_vtrace_key (d, new_line_offset, 'key         ',
              trace.trceBdKey.bdkKeyLen_gg11,
              trace.trceBdKey.bdkKey_gg11,
              ln_len, ln);
    bdtrMerge_egg11:
        BEGIN
        items := 2;
        IF  trace.trceBdMerge.bdmIsStartKey_gg11
        THEN
            BEGIN
            msg [1] := 'StartInvKey ';
            msg [2] := 'StartPrimKey';
            END
        ELSE
            BEGIN
            msg [1] := 'StopInvKey  ';
            IF  trace.trceBdMerge.bdmIsPrimStop_gg11
            THEN
                msg [2] := 'StopPrimKey '
            ELSE
                items := 1
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        FOR i := 1 TO items DO
            BEGIN
            xt02print_vtrace_key (d, new_line_offset, msg [i],
                  trace.trceBdMerge.bdmKeyLen_gg11 [i-1],
                  trace.trceBdMerge.bdmKey_gg11    [i-1],
                  ln_len, ln);
            IF  i < items
            THEN
                BEGIN
                ln     := d.dsTerm^.blankline;
                ln_len := new_line_offset
                END
            (*ENDIF*) 
            END
        (*ENDFOR*) 
        END;
    bdtrRename_egg11:
        BEGIN
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected);
        xt02print_filename (d.dsTerm^, d.dsProt^, NO_FUNCTION_SIGN, '    old file',
              trace.trceBdRename.bdrnOldFn_gg11);
        xt02print_filename (d.dsTerm^, d.dsProt^, NO_FUNCTION_SIGN, '    new file',
              trace.trceBdRename.bdrnNewFn_gg11)
        END;
    bdtrRoot_egg11, bdtrAppendRoot_egg11, bdtrEvalPages_egg11, bdtrVerify_egg11:
        BEGIN
        ln [1] := d.dsLeaveFunctSign [1];
        IF  trace.trceHead.vhType_gg11 = b03create
        THEN
            g17sname_to_line ('prim keycnt ', ln_len, ln)
        ELSE
            g17sname_to_line ('root        ', ln_len, ln);
        (*ENDIF*) 
        xt02_CenterPnoToLine (trace.trceBdRoot.bdrRoot_gg11, without_arrow, ln_len, ln);
        ln [ln_len+1] := ';';
        ln_len        := ln_len + 2;
        xt02_BasisError (trace.trceBdRoot.bdrError_gg11, ln_len, ln);
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected);
        CASE trace.trceBdRoot.bdrTrType_gg11 OF
            bdtrAppendRoot_egg11:
                BEGIN
                ln     := d.dsTerm^.blankline;
                ln_len := new_line_offset;
                g17sname_to_line ('rightmost   ', ln_len, ln);
                xt02_CenterPnoToLine (trace.trceBdAppendRoot.bdarRigthmost_gg11, without_arrow, ln_len, ln);
                t12write_prot (d.dsProt^, ln, ln_len, err);
                t09put (d.dsTerm^, ln, cut_protected)
                END;
            bdtrEvalPages_egg11:
                BEGIN
                ln     := d.dsTerm^.blankline;
                ln_len := new_line_offset;
                g17sname_to_line ('PageCnt     ', ln_len, ln);
                ln_len  := ln_len  + 1;
                g17trimint4_to_line (trace.trceBdEvalPages.bdePageCnt_gg11, ln_len, ln);
                IF  trace.trceBdEvalPages.bdeRecordCnt_gg11 > 0
                THEN
                    BEGIN
                    g17sname_to_line ('; RecCnt    ', ln_len, ln);
                    ln_len  := ln_len  + 1;
                    g17trimint4_to_line (trace.trceBdEvalPages.bdeRecordCnt_gg11, ln_len, ln)
                    END;
                (*ENDIF*) 
                g17sname_to_line ('; AllPageCnt', ln_len, ln);
                ln_len  := ln_len  + 1;
                g17trimint4_to_line (trace.trceBdEvalPages.bdeAllPageCnt_gg11, ln_len, ln);
                t12write_prot (d.dsProt^, ln, ln_len, err);
                t09put (d.dsTerm^, ln, cut_protected)
                END;
            bdtrVerify_egg11:
                BEGIN
                ln     := d.dsTerm^.blankline;
                ln_len := new_line_offset;
                g17sname_to_line ('num pages   ', ln_len, ln);
                xt02_CenterPnoToLine (trace.trceBdVerify.bdvNumPages_gg11, without_arrow, ln_len, ln);
                t12write_prot (d.dsProt^, ln, ln_len, err);
                t09put (d.dsTerm^, ln, cut_protected);
                xt02print_filename (d.dsTerm^, d.dsProt^, NO_FUNCTION_SIGN, ' verify file',
                      trace.trceBdVerify.bdvFn_gg11);
                END;
            OTHERWISE ;
            END
        (*ENDCASE*) 
        END;
    bdtrTwoKeys_egg11:
        BEGIN
        CASE trace.trceHead.vhType_gg11 OF
            b03eval, b03pcreate,
            b02first_qual, b02last_qual,
            b02next_qual, b02prev_qual, b02direct_qual:
                BEGIN
                msg [1] := 'StartKey    ';
                msg [2] := 'Stop Key    '
                END;
            OTHERWISE
                BEGIN
                msg [1] := 'Inv Key     ';
                msg [2] := 'PrimKey     '
                END
            END;
        (*ENDCASE*) 
        FOR i := 1 TO 2 DO
            BEGIN
            xt02print_vtrace_key (d, new_line_offset, msg [i],
                  trace.trceBdTwoKeys.bdtkKeyLen_gg11 [i-1],
                  trace.trceBdTwoKeys.bdtkKey_gg11    [i-1],
                  ln_len, ln);
            IF  i = 1
            THEN
                BEGIN
                ln     := d.dsTerm^.blankline;
                ln_len := new_line_offset
                END
            (*ENDIF*) 
            END
        (*ENDFOR*) 
        END;
    bdtrWriteStr_egg11:
        xt02print_bd_write_str (d, trace, new_line_offset, ln_len, ln);
    OTHERWISE
        BEGIN
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected);
        ok := false
        END
    END
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_bd_write_str (
            VAR d           : t_DisplState;
            VAR trace       : trace_record;
            new_line_offset : integer;
            VAR ln_len      : integer;
            VAR ln          : tsp00_Line);
 
VAR
      len         : integer;
      moveobj_ptr : tsp00_MoveObjPtr;
 
BEGIN
g17sname_to_line ('pos         ', ln_len, ln);
ln_len := ln_len + 1;
g17trimint4_to_line (trace.trceBdWriteStr.bdwsHead_gg11.bdwhPos_gg11, ln_len, ln);
g17sname_to_line ('; length    ', ln_len, ln);
ln_len := ln_len + 1;
len    := trace.trceBdWriteStr.bdwsHead_gg11.bdwhLen_gg11;
g17trimint4_to_line (len, ln_len, ln);
IF  len > trace.trceHead.vhLen_gg11 - sizeof (tgg11_VtraceHeader) - sizeof (tgg11_BdWriteStrHeader)
THEN
    len := trace.trceHead.vhLen_gg11 - sizeof (tgg11_VtraceHeader) - sizeof (tgg11_BdWriteStrHeader);
(*ENDIF*) 
moveobj_ptr := @trace.trceBdWriteStr.bdwsStr_gg11;
IF  x05ishex (moveobj_ptr^, sizeof (trace.trceBdWriteStr.bdwsStr_gg11), 1, len)
THEN
    xt02print_hex (d, moveobj_ptr^, sizeof (trace.trceBdWriteStr.bdwsStr_gg11),
          1, len, new_line_offset, ln_len, ln)
ELSE
    xt02print_char (d.dsTerm^, d.dsProt^,
          moveobj_ptr^, sizeof (trace.trceBdWriteStr.bdwsStr_gg11),
          1, len, new_line_offset, true, ln_len, ln)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_char (
            VAR term           : tut_terminal;
            VAR protfile       : tut_vf_fileref;
            VAR moveobj        : tsp00_MoveObj;
            moveobj_size       : tsp00_Int4;
            lwb                : tsp00_Int4;
            upb                : tsp00_Int4;
            new_line_offset    : integer;
            with_str_delimiter : boolean;
            VAR ln_len         : integer;
            VAR ln             : tsp00_Line);
 
CONST
      min_trunc_len = 3;
 
VAR
      ln_size : integer;
      len     : integer;
      pos     : integer;
      err     : integer;
      ix      : integer;
 
BEGIN
IF  with_str_delimiter
THEN
    ln_size := PROT_LINESIZE -1
ELSE
    ln_size := PROT_LINESIZE;
(*ENDIF*) 
pos := lwb;
WHILE pos <= upb DO
    BEGIN
    IF  ln_len + min_trunc_len <= ln_size
    THEN
        BEGIN
        IF  with_str_delimiter
        THEN
            BEGIN
            ln_len      := ln_len + 1;
            ln [ln_len] := ''''
            END;
        (*ENDIF*) 
        len := upb - pos + 1;
        IF  ln_len + len > ln_size
        THEN
            len := ln_size - ln_len;
        (*ENDIF*) 
        SAPDB_PascalForcedMove (moveobj_size, sizeof (ln), @moveobj, pos, @ln,
              ln_len+1, len);
        FOR ix := ln_len+1 TO ln_len+len DO
            IF  ln[ ix ] = csp_unicode_mark
            THEN
                ln[ ix ] := csp_ascii_blank;
            (*ENDIF*) 
        (*ENDFOR*) 
        ln_len := ln_len + len;
        IF  with_str_delimiter
        THEN
            BEGIN
            ln_len      := ln_len + 1;
            ln [ln_len] := ''''
            END
        (*ENDIF*) 
        END
    ELSE
        len := 0;
    (*ENDIF*) 
    pos := pos + len;
    t12write_prot (protfile, ln, ln_len, err);
    t09put (term, ln, cut_protected);
    ln := term.blankline;
    IF  pos <= upb
    THEN
        ln_len := new_line_offset
    ELSE
        ln_len := 0
    (*ENDIF*) 
    END
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_cmd_segm_head (
            VAR d             : t_DisplState;
            VAR cmd_segm_head : tsp1_segment_header);
 
VAR
      err     : integer;
      ln1_len : integer;
      ln2_len : integer;
      ln3_len : integer;
      ln1     : tsp00_Line;
      ln2     : tsp00_Line;
      ln3     : tsp00_Line;
 
BEGIN
g17cmdsegm_head (cmd_segm_head,
      ln1_len, ln1, ln2_len, ln2, ln3_len, ln3);
t12write_prot (d.dsProt^, ln1, ln1_len, err);
t12write_prot (d.dsProt^, ln2, ln2_len, err);
t09put (d.dsTerm^, ln1, cut_bright_protected);
t09put (d.dsTerm^, ln2, cut_bright_protected);
IF  ln3_len > 0
THEN
    BEGIN
    t12write_prot (d.dsProt^, ln3, ln3_len, err);
    t09put (d.dsTerm^, ln3, cut_bright_protected)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_entry_pos (
            VAR term     : tut_terminal;
            VAR protfile : tut_vf_fileref;
            VAR f        : tut_file);
 
VAR
      err    : integer;
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
(* PTS 1000369 JA 1997-12-09 *)
ln          := term.blankline;
ln_len      := 1;
ln [ln_len] := '(';
xt02entry_pos_to_line (f, ln_len, ln);
ln_len      := ln_len + 1;
ln [ln_len] := ')';
t12write_prot (protfile, ln, ln_len, err);
t09put (term, ln, cut_bright_protected);
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_filename (
            VAR term      : tut_terminal;
            VAR protfile  : tut_vf_fileref;
            function_sign : char;
            msg           : tsp00_Sname;
            VAR fn        : tgg00_Filename);
 
CONST
      c_indent    =  1;
      c_colon_pos = 14;
 
VAR
      is_ln3 : boolean;
      ln1    : tsp00_Line;
      ln2    : tsp00_Line;
      ln3    : tsp00_Line;
 
BEGIN
g17filename (msg, fn, c_indent, ln1, ln2, ln3, is_ln3);
ln1 [c_indent + c_colon_pos] := ' ';
ln1 [1] := function_sign;
ln2 [1] := NO_FUNCTION_SIGN;
ln3 [1] := NO_FUNCTION_SIGN;
xt02xwrite_line (term, protfile, ln1);
xt02xwrite_line (term, protfile, ln2);
IF  is_ln3
THEN
    xt02xwrite_line (term, protfile, ln3)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_hex (
            VAR d           : t_DisplState;
            VAR moveobj     : tsp00_MoveObj;
            moveobj_size    : tsp00_Int4;
            lwb             : tsp00_Int4;
            upb             : tsp00_Int4;
            new_line_offset : integer;
            VAR ln_len      : integer;
            VAR ln          : tsp00_Line);
 
VAR
      is_first_ln : boolean;
      hex_only    : boolean;
      scan        : tut_diag_scan;
      dummy_pfkey : tut_pfkey;
      err         : integer;
      dummy_pos   : tsp00_Int4;
      len         : tsp00_Int4;
      char_cnt    : tsp00_Int4;
      i           : tsp00_Int4;
      pos         : tsp00_Int4;
      cnt         : tsp00_Int4;
      displ_upb   : tsp00_Int4;
 
BEGIN
IF  d.dsTdbufWanted
THEN
    BEGIN
    IF  ln_len > 0
    THEN
        BEGIN
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected)
        END;
    (*ENDIF*) 
    ln     := d.dsTerm^.blankline;
    ln_len := 0;
    IF  upb - lwb + 1 > d.dsMaxBuflength
    THEN
        displ_upb := lwb + d.dsMaxBuflength - 1
    ELSE
        displ_upb := upb;
    (*ENDIF*) 
    IF  d.dsIsMinbuf
    THEN
        scan := [utds_minbuf]
    ELSE
        scan := [ ];
    (*ENDIF*) 
    IF  d.dsTerm^.is_display
    THEN
        scan := scan + [utds_display];
    (*ENDIF*) 
    t14bufdisplay (d.dsTerm^, d.dsProt^, scan, bsp_c30,
          moveobj, moveobj_size, lwb, displ_upb, 1, dummy_pos, dummy_pfkey)
    END
ELSE
    IF  lwb > upb
    THEN
        BEGIN
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected);
        ln     := d.dsTerm^.blankline;
        ln_len := 0
        END
    ELSE
        BEGIN
        is_first_ln := true;
        pos         := lwb;
        cnt         := 0;
        WHILE pos <= upb DO
            BEGIN
            len := PROT_LINESIZE - ln_len;
            (* space behind 8 characters (4 bytes) *)
            len := len - (len DIV 9);
            (* two characters for one hex byte *)
            len := len DIV 2;
            IF  len > upb - pos + 1
            THEN
                len := upb - pos + 1
            ELSE
                (* 4 byte packages only *)
                len := (len DIV 4) * 4;
            (*ENDIF*) 
            IF  is_first_ln AND (len < upb - pos + 1)
                AND (ln_len > new_line_offset)
            THEN
                BEGIN
                t12write_prot (d.dsProt^, ln, ln_len, err);
                t09put (d.dsTerm^, ln, cut_protected);
                ln     := d.dsTerm^.blankline;
                ln_len := new_line_offset
                END
            ELSE
                BEGIN
                FOR i := 1 TO len DO
                    BEGIN
                    IF  (i > 1) AND (cnt MOD 4 = 0)
                    THEN
                        ln_len := ln_len + 1;
                    (*ENDIF*) 
                    g17hexto_line (moveobj [pos], ln_len, ln);
                    pos := pos + 1;
                    cnt := cnt + 1
                    END;
                (*ENDFOR*) 
                IF  pos <= upb
                THEN
                    BEGIN
                    t12write_prot (d.dsProt^, ln, ln_len, err);
                    t09put (d.dsTerm^, ln, cut_protected);
                    ln     := d.dsTerm^.blankline;
                    ln_len := new_line_offset
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            is_first_ln := false
            END;
        (*ENDWHILE*) 
        hex_only := true;
        char_cnt := 0;
        FOR i := lwb TO upb DO
            IF  (moveobj [i] <> ' ') AND
                g17printable_char (moveobj [i])
            THEN
                BEGIN
                (* printable characters without blank *)
                char_cnt := char_cnt + 1;
                IF  char_cnt > 2
                THEN
                    hex_only := false
                (*ENDIF*) 
                END
            ELSE
                IF  moveobj [i] <> ' '
                THEN
                    BEGIN
                    char_cnt    := 0;
                    moveobj [i] := '.'
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDFOR*) 
        IF  hex_only
        THEN
            BEGIN
            t12write_prot (d.dsProt^, ln, ln_len, err);
            t09put (d.dsTerm^, ln, cut_protected)
            END
        ELSE
            BEGIN
            IF  ln_len + 2 + upb - lwb + 1 + 1 > PROT_LINESIZE
            THEN
                BEGIN
                t12write_prot (d.dsProt^, ln, ln_len, err);
                t09put (d.dsTerm^, ln, cut_protected);
                ln     := d.dsTerm^.blankline;
                ln_len := new_line_offset
                END
            ELSE
                ln_len := ln_len + 1;
            (*ENDIF*) 
            xt02print_char (d.dsTerm^, d.dsProt^, moveobj, moveobj_size,
                  lwb, upb, new_line_offset, true, ln_len, ln)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_info (
            VAR d               : t_DisplState;
            VAR f               : tut_file;
            with_transid        : boolean;
            with_entry_pos      : boolean;
            VAR trace           : trace_record;
            VAR old_trace       : tgg11_VtraceHeader;
            VAR ln_cnt_per_task : integer);
 
VAR
      err         : integer;
      len         : integer;
      offset      : integer;
      ln_len      : integer;
      i2c2        : tsp_int_map_c2;
      n           : tsp00_Name;
      ln          : tsp00_Line;
      moveobj_ptr : tsp00_MoveObjPtr;
 
BEGIN
CASE trace.trceHead.vhLayer_gg11 OF
    ak_join:
        BEGIN
        xt02print_trace_id (d.dsTerm^, d.dsProt^, with_transid,
              with_entry_pos, f, trace, old_trace, ln_cnt_per_task);
        xt02print_ak_join (d, trace)
        END;
    ak_messbuf:
        BEGIN
        xt02print_trace_id (d.dsTerm^, d.dsProt^, with_transid,
              with_entry_pos, f, trace, old_trace, ln_cnt_per_task);
        t12write_prot (d.dsProt^, d.dsTerm^.blankline, 1, err);
        t09put (d.dsTerm^, d.dsTerm^.blankline, cut_protected);
        (* PTS 1000369 JA 1997-12-09 *)
        IF  with_entry_pos
        THEN
            xt02print_entry_pos (d.dsTerm^, d.dsProt^, f);
        (*ENDIF*) 
        IF  trace.trceHead.vhType_gg11 = ak_send
        THEN
            xt02xmessblock (d, 'MBLOCK snd  ', trace);
        (*ENDIF*) 
        IF  trace.trceHead.vhType_gg11 = ak_receive
        THEN
            xt02xmessblock (d, 'MBLOCK rcv  ', trace);
        (*ENDIF*) 
        END;
    ak_packet_head:
        BEGIN
        xt02print_trace_id (d.dsTerm^, d.dsProt^, with_transid,
              with_entry_pos, f, trace, old_trace, ln_cnt_per_task);
        xt02print_packet_head (d, f, with_entry_pos, trace);
        IF  trace.packet_segm_head.sp1s_segm_kind = sp1sk_cmd
        THEN
            xt02print_cmd_segm_head (d, trace.packet_segm_head)
        ELSE
            xt02print_ret_segm_head (d, trace.packet_segm_head)
        (*ENDIF*) 
        END;
    ak_packet_part:
        BEGIN
        xt02print_trace_id (d.dsTerm^, d.dsProt^, with_transid,
              with_entry_pos, f, trace, old_trace, ln_cnt_per_task);
        xt02print_packet_part (d, trace)
        END;
    ak_packet_segm:
        BEGIN
        xt02print_trace_id (d.dsTerm^, d.dsProt^, with_transid,
              with_entry_pos, f, trace, old_trace, ln_cnt_per_task);
        IF  trace.segm_head.sp1s_segm_kind = sp1sk_cmd
        THEN
            xt02print_cmd_segm_head (d, trace.segm_head)
        ELSE
            xt02print_ret_segm_head (d, trace.segm_head)
        (*ENDIF*) 
        END;
    ak_receive_error:
        BEGIN
        xt02print_trace_id (d.dsTerm^, d.dsProt^, with_transid,
              with_entry_pos, f, trace, old_trace, ln_cnt_per_task);
        IF  with_entry_pos
        THEN
            xt02print_entry_pos (d.dsTerm^, d.dsProt^, f);
        (*ENDIF*) 
        ln     := d.dsTerm^.blankline;
        ln_len := 0;
        g17nameto_line ('*** REQUEST ERROR:', ln_len, ln);
        ln_len := ln_len + 1;
        g17trimint4_to_line (ord(trace.buf[ 1 ]), ln_len, ln);
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected)
        END;
    ak_sem:
        IF  trace.trceHead.vhType_gg11 = ak_returncode
        THEN
            BEGIN
            xt02print_trace_id (d.dsTerm^, d.dsProt^, with_transid,
                  with_entry_pos, f, trace, old_trace, ln_cnt_per_task);
            ln     := d.dsTerm^.blankline;
            ln_len := 0;
            g17nameto_line ('*** sql errorcode:', ln_len, ln);
            ln_len         := ln_len + 1;
            i2c2.map_c2[1] := trace.buf[1];
            i2c2.map_c2[2] := trace.buf[2];
            g17trimint4_to_line (i2c2.map_int, ln_len, ln);
            t12write_prot (d.dsProt^, ln, ln_len, err);
            t09put (d.dsTerm^, ln, cut_protected)
            END;
        (*ENDIF*) 
    ak_sqlpacket:
        BEGIN
        xt02print_trace_id (d.dsTerm^, d.dsProt^, with_transid,
              with_entry_pos, f,
              trace, old_trace, ln_cnt_per_task);
        t12write_prot (d.dsProt^, d.dsTerm^.blankline, 1, err);
        t09put (d.dsTerm^, d.dsTerm^.blankline, cut_protected);
        (* PTS 1000369 JA 1997-12-09 *)
        IF  with_entry_pos
        THEN
            xt02print_entry_pos (d.dsTerm^, d.dsProt^, f);
        (*ENDIF*) 
        x05packet (d.dsTerm^, d.dsProt^, d.dsIsMinbuf, d.dsMaxBuflength,
              'PACKET      ', trace.packet_ptr)
        END;
    ak_strat:
        BEGIN
        xt02print_trace_id (d.dsTerm^, d.dsProt^, with_transid,
              with_entry_pos, f,
              trace, old_trace, ln_cnt_per_task);
        IF  with_entry_pos
        THEN
            xt02print_entry_pos (d.dsTerm^, d.dsProt^, f);
        (*ENDIF*) 
        ln     := d.dsTerm^.blankline;
        ln_len := 0;
        IF  trace.trceHead.vhType_gg11 = ak_join_strat
        THEN
            BEGIN
            g17sname_to_line ('JOIN:       ', ln_len, ln);
            len := trace.trceHead.vhLen_gg11 - sizeof (tgg11_VtraceHeader);
            moveobj_ptr := @trace.buf;
            SAPDB_PascalForcedMove (sizeof (trace.buf), sizeof (ln),
                  @moveobj_ptr^, 1, @ln, 7, len);
            ln_len := ln_len + len + 1;
            END
        ELSE
            IF  trace.trceHead.vhType_gg11 = ak_send
            THEN
                BEGIN
                ln_len := trace.trceHead.vhLen_gg11 - sizeof (tgg11_VtraceHeader);
                moveobj_ptr := @trace.buf;
                SAPDB_PascalForcedMove (sizeof (trace.buf), sizeof (ln),
                      @moveobj_ptr^, 1, @ln, 1, ln_len);
                END
            ELSE
                IF  trace.trceHead.vhType_gg11 = ak_strat_with_int
                THEN
                    BEGIN
                    g17sname_to_line ('STRATEGY:   ', ln_len, ln);
                    len := trace.trceHead.vhLen_gg11 - sizeof (tgg11_VtraceHeader) - INT4_MXSP00;
                    moveobj_ptr := @trace.buf;
                    SAPDB_PascalForcedMove (sizeof (trace.buf), sizeof (ln),
                          @moveobj_ptr^, INT4_MXSP00 + 1, @ln, ln_len + 2, len);
                    ln_len := ln_len + 2 + len + 1;
                    g17trimint4_to_line (trace.i4[ 1 ], ln_len, ln);
                    END
                ELSE
                    IF  trace.trceHead.vhType_gg11 = ak_strat_with_bool
                    THEN
                        BEGIN
                        g17sname_to_line ('STRATEGY:   ', ln_len, ln);
                        len := trace.trceHead.vhLen_gg11 - sizeof (tgg11_VtraceHeader) - INT4_MXSP00;
                        moveobj_ptr := @trace.buf;
                        SAPDB_PascalForcedMove (sizeof (trace.buf), sizeof (ln),
                              @moveobj_ptr^, INT4_MXSP00 + 1, @ln, ln_len + 2, len);
                        ln_len := ln_len + 2 + len + 1;
                        IF  ( trace.i4[ 1 ] = 0 )
                        THEN
                            g17sname_to_line ('false       ', ln_len, ln)
                        ELSE
                            g17sname_to_line ('true        ', ln_len, ln);
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        g17sname_to_line ('STRATEGY:   ', ln_len, ln);
                        len := trace.trceHead.vhLen_gg11 - sizeof (tgg11_VtraceHeader);
                        moveobj_ptr := @trace.buf;
                        SAPDB_PascalForcedMove (sizeof (trace.buf), sizeof (ln),
                              @moveobj_ptr^, 1, @ln, ln_len + 2, len);
                        ln_len := ln_len + 2 + len;
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected)
        END;
    bd:
        BEGIN
        xt02print_trace_id (d.dsTerm^, d.dsProt^, with_transid,
              with_entry_pos, f, trace, old_trace, ln_cnt_per_task);
        xt02print_bd (d, trace)
        END;
    gg:
        IF  trace.trceHead.vhType_gg11 = gg_opmsg
        THEN
            BEGIN
            xt02print_trace_id (d.dsTerm^, d.dsProt^, with_transid,
                  with_entry_pos, f, trace, old_trace, ln_cnt_per_task);
            ln  := d.dsTerm^.blankline;
            len := trace.trceHead.vhLen_gg11 - sizeof (tgg11_VtraceHeader);
            IF  len > sizeof (ln) - 1
            THEN
                len := sizeof (ln) - 1;
            (*ENDIF*) 
            moveobj_ptr := @trace.buf;
            SAPDB_PascalForcedMove (sizeof (trace.buf), sizeof (ln), @moveobj_ptr^, 1, @ln, 2, len);
            t12write_prot (d.dsProt^, ln, 1 + len, err);
            t09put (d.dsTerm^, ln, cut_bright_protected)
            END;
        (*ENDIF*) 
    gg_time:
        BEGIN
        ln     := d.dsTerm^.blankline;
        ln_len := 0;
        IF  trace.trceHead.vhType_gg11 = bd_timer
        THEN
            BEGIN
            g17sname_to_line ('TIME        ', ln_len, ln);
            ln_len := ln_len + 1;
            SAPDB_PascalForcedMove (sizeof (trace.buf), sizeof (n),
                  @trace.buf, sizeof (tsp00_Int4) + sizeof (tsp00_Int4) + 1,
                  @n, 1, sizeof (n));
            g17nameto_line (n, ln_len, ln)
            END;
        (*ENDIF*) 
        xt02print_seconds (d.dsTerm^, d.dsProt^, trace, 1, ln_len, ln)
        END;
    kb:
        BEGIN
        xt02print_trace_id (d.dsTerm^, d.dsProt^, with_transid,
              with_entry_pos, f, trace, old_trace, ln_cnt_per_task);
        xt02print_kb (d, trace)
        END;
    kb_qual:
        BEGIN
        xt02print_trace_id (d.dsTerm^, d.dsProt^, with_transid,
              with_entry_pos, f, trace, old_trace, ln_cnt_per_task);
        ln     := d.dsTerm^.blankline;
        ln_len := 0;
        len := trace.trceHead.vhLen_gg11 - sizeof (tgg11_VtraceHeader) - 4 * INT4_MXSP00;
        moveobj_ptr := @trace.buf;
        SAPDB_PascalForcedMove (sizeof (trace.buf), sizeof (ln),
              @moveobj_ptr^, 4 * INT4_MXSP00 + 1, @ln, 1, len);
        ln_len := len + 1;
        g17trimint4_to_line (trace.i4 [1] , ln_len, ln);
        ln_len := ln_len + 1;
        g17trimint4_to_line (trace.i4 [2] , ln_len, ln);
        ln_len := ln_len + 1;
        g17trimint4_to_line (trace.i4 [3] , ln_len, ln);
        ln_len := ln_len + 1;
        g17trimint4_to_line (trace.i4 [4] , ln_len, ln);
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected)
        END;
    ta, ut:
        BEGIN
        xt02print_trace_id (d.dsTerm^, d.dsProt^, with_transid,
              with_entry_pos, f, trace, old_trace, ln_cnt_per_task);
        ln := d.dsTerm^.blankline;
        moveobj_ptr := @trace.buf;
        IF  trace.trceHead.vhType_gg11 = vttSlowTrace_egg00
        THEN
            BEGIN
            (* entry contains CALL/LEAVE_FUNCTION_SIGN *)
            offset := 0;
            d.dsLeaveFunctSign [1] := LEAVE_FUNCTION_SIGN (* enable leave display *)
            END
        ELSE
            offset := 1;
        (*ENDIF*) 
        len := trace.trceHead.vhLen_gg11 - sizeof (tgg11_VtraceHeader);
        IF  len > sizeof (ln) - offset
        THEN
            len := sizeof (ln) - offset;
        (*ENDIF*) 
        SAPDB_PascalForcedMove (sizeof (trace.buf), sizeof (ln), @moveobj_ptr^, 1, @ln, offset + 1, len);
        t12write_prot (d.dsProt^, ln, 1+len, err);
        t09put (d.dsTerm^, ln, cut_protected)
        END;
    OTHERWISE
        BEGIN
        xt02print_trace_id (d.dsTerm^, d.dsProt^, with_transid,
              with_entry_pos, f, trace, old_trace, ln_cnt_per_task);
        xt02print_unknown (d, trace)
        END
    END
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_kb (
            VAR d         : t_DisplState;
            VAR trace     : trace_record);
 
VAR
      ok               : boolean;
      print_sess_trans : boolean;
      ln_len           : integer;
      err              : integer;
      sn               : tsp00_Sname;
      ln               : tsp00_Line;
 
BEGIN
ln               := d.dsTerm^.blankline;
ln_len           := LINE_FUNCT_INDENT;
ok               := true;
print_sess_trans := false;
CASE trace.trceHead.vhType_gg11 OF
    vttKbClearLockList_egg00, vttKbRequestTimeout_egg00:
        sn := 'KB51        ';
    vttKbColdFunctions_egg00:
        BEGIN
        sn := 'KB05 COLD   ';
        ln [1]           := CALL_FUNCTION_SIGN;
        print_sess_trans := true
        END;
    vttKbFunctions_egg00:
        BEGIN
        sn := 'KB05        ';
        ln [1]           := CALL_FUNCTION_SIGN;
        print_sess_trans := true
        END;
    vttKbLockCollision_egg00:
        BEGIN
        sn := 'KB51        ';
        print_sess_trans := true
        END;
    vttKbLockWait_egg00:
        sn := 'WAIT        ';
    vttKbLockWaitResume_egg00:
        sn := 'WAIT RESUME ';
    kb04oms:
        BEGIN
        sn := 'KB04        ';
        ln [1]           := CALL_FUNCTION_SIGN;
        print_sess_trans := true
        END;
    vttKbRedoLogError_egg00:
        sn := '*** REDO LOG';
    kb38restore_parallel:
        sn := 'RESTORE     ';
    kb38save_parallel:
        sn := 'SAVE        ';
    vttKbServer_egg00:
        BEGIN
        sn := 'KB SERVER   ';
        ln [1]           := CALL_FUNCTION_SIGN;
        print_sess_trans := true
        END;
    OTHERWISE
        BEGIN
        ok := false;
        xt02print_unknown (d, trace)
        END
    END;
(*ENDCASE*) 
IF  ok
THEN
    BEGIN
    g17sname_to_line (sn, ln_len, ln);
    ln_len := ln_len + 1;
    IF  print_sess_trans
    THEN
        BEGIN
        xt02sess_trans_to_line (trace, ln_len, ln);
        ln_len := ln_len + 1
        END;
    (*ENDIF*) 
    CASE trace.trceHead.vhType_gg11 OF
        vttKbClearLockList_egg00, vttKbRequestTimeout_egg00:
            xt02print_kb_locking (d, trace, ln_len, ln);
        vttKbColdFunctions_egg00, vttKbServer_egg00:
            BEGIN
            IF   false AND
                (trace.trceHead.vhType_gg11   =  vttKbServer_egg00) AND
                (trace.trceKb.kbMessType_gg11 <> m_return_error   ) AND
                (trace.trceKb.kbMessType_gg11 <> m_return_result  )
            THEN
                BEGIN
                IF  trace.trceKbTabId.kbtHead_gg11.kbSubtrans_gg11 <> 0
                THEN
                    BEGIN
                    ln[ ln_len ] := '/';
                    g17trimint4_to_line (trace.trceKbTabId.kbtHead_gg11.kbSubtrans_gg11, ln_len, ln);
                    ln_len := ln_len + 1
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            xt02mess_types_to_line (trace.trceKb.kbMessType_gg11,
                  trace.trceKb.kbMessType2_gg11, ln_len, ln);
            IF  (trace.trceKb.kbMessType_gg11 = m_return_error ) OR
                (trace.trceKb.kbMessType_gg11 = m_return_result)
            THEN
                ln [1] := d.dsLeaveFunctSign [1];
            (*ENDIF*) 
            IF  trace.trceKb.kbMessType_gg11 = m_return_error
            THEN
                xt02_BasisError (trace.trceKb.kbError_gg11, ln_len, ln);
            (*ENDIF*) 
            IF  trace.trceHead.vhType_gg11 = vttKbColdFunctions_egg00
            THEN
                BEGIN
                ln_len := ln_len + 1;
                xt02_DateTimeToLine (trace.trceKbDateTime.kbdtDate_gg11,
                      trace.trceKbDateTime.kbdtTime_gg11, c_adjust, ln_len, ln)
                END;
            (*ENDIF*) 
            t12write_prot (d.dsProt^, ln, ln_len, err);
            t09put (d.dsTerm^, ln, cut_protected)
            END;
        vttKbFunctions_egg00:
            xt02print_kb_function (d, trace, ln_len, ln);
        vttKbLockCollision_egg00:
            xt02print_kb_collision (d, trace, ln_len, ln);
        vttKbLockWait_egg00, vttKbLockWaitResume_egg00:
            BEGIN
            xt02mess_types_to_line (trace.trceKb.kbMessType_gg11,
                  trace.trceKb.kbMessType2_gg11, ln_len, ln);
            IF  trace.trceHead.vhType_gg11 = vttKbLockWaitResume_egg00
            THEN
                BEGIN
                ln [ln_len+1] := ':';
                ln_len        := ln_len + 2;
                xt02_BasisError (trace.trceKb.kbError_gg11, ln_len, ln)
                END;
            (*ENDIF*) 
            t12write_prot (d.dsProt^, ln, ln_len, err);
            t09put (d.dsTerm^, ln, cut_protected)
            END;
        kb04oms:
            xt02print_kb_oms (d, trace, ln_len, ln);
        vttKbRedoLogError_egg00:
            BEGIN
            ln [ln_len] := ':';
            ln_len      := ln_len + 1;
            g17sname_to_line ('logpos:     ', ln_len, ln);
            ln_len  := ln_len + 1;
            g17trimint4_to_line (trace.trceKbRedo.kbrRedoLogPos_gg11.logLpno_gg00, ln_len, ln);
            ln_len  := ln_len + 1;
            g17trimint4_to_line (trace.trceKbRedo.kbrRedoLogPos_gg11.logPpos_gg00, ln_len, ln);
            ln_len      := ln_len + 1;
            ln [ln_len] := '[';
            g17pagetype_to_line (trace.trceKbRedo.kbrRedoLogPos_gg11.logPageType_gg00, ln_len, ln);
            ln [ln_len+1] := ']';
            ln_len        := ln_len + 2;
            xt02_BasisError (trace.trceKb.kbError_gg11, ln_len, ln);
            t12write_prot (d.dsProt^, ln, ln_len, err);
            t09put (d.dsTerm^, ln, cut_protected)
            END;
        kb38restore_parallel, kb38save_parallel:
            BEGIN
            xt02put_save_restore_to_line (trace, ln_len, ln);
            t12write_prot (d.dsProt^, ln, ln_len, err);
            t09put (d.dsTerm^, ln, cut_protected)
            END;
        OTHERWISE ;
        END
    (*ENDCASE*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_kb_collision (
            VAR d        : t_DisplState;
            VAR trace    : trace_record;
            VAR ln_len   : integer;
            VAR ln       : tsp00_Line);
 
VAR
      line_written : boolean;
      err          : integer;
      indent       : integer;
      print_keylen : integer;
      moveobj_ptr  : tsp00_MoveObjPtr;
 
BEGIN
(* --- vttKbLockCollision_egg00 --- *)
line_written := false;
WITH trace.trceKb, trace.trceKbLock.kblcHead_gg11 DO
    BEGIN
    IF  kbMessType2_gg11 = mm_checkpoint
    THEN
        g17nameto_line ('SHUTDWN COLLISION ', ln_len, ln)
    ELSE
        BEGIN
        IF  kbMessType2_gg11 = mm_table
        THEN
            g17sname_to_line ('TAB LOCK    ', ln_len, ln)
        ELSE
            (* mm_key *)
            g17sname_to_line ('ROW LOCK    ', ln_len, ln);
        (*ENDIF*) 
        IF  kbMessType_gg11 = m_lock
        THEN
            g17sname_to_line (' COLLISION  ', ln_len, ln)
        ELSE
            (* m_insert *)
            g17sname_to_line (' RESERVATION', ln_len, ln)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  kblReqTask_gg11 <> cgg_nil_pid
    THEN
        BEGIN
        g17sname_to_line (' (ReqTask   ', ln_len, ln);
        ln_len := ln_len + 1;
        g17trimint4_to_line (kblReqTask_gg11, ln_len, ln);
        ln_len      := ln_len + 1;
        ln [ln_len] := ')'
        END;
    (*ENDIF*) 
    IF  kbMessType2_gg11 <> mm_checkpoint
    THEN
        (* collision / reservation *)
        BEGIN
        ln_len := ln_len + 1;
        g17lockmode_to_line (kblReqMode_gg11, ln_len, ln);
        IF  (kbMessType_gg11 = m_lock) AND (kblLockTask_gg11 <> cgg_nil_pid)
        THEN
            BEGIN
            g17nameto_line ('; excl locked by  ', ln_len, ln);
            ln_len := ln_len + 1;
            g17trimint4_to_line (kblLockTask_gg11, ln_len,ln)
            END;
        (*ENDIF*) 
        g17sname_to_line ('; TABID     ', ln_len, ln);
        ln_len := ln_len + 1;
        g17surrogate_to_line (kblTabId_gg11, ln_len, ln);
        IF  kbMessType2_gg11 = mm_key
        THEN
            (* row collision / row reservation *)
            BEGIN
            t12write_prot (d.dsProt^, ln, ln_len, err);
            t09put (d.dsTerm^, ln, cut_protected);
            ln     := d.dsTerm^.blankline;
            ln_len := 4;
            g17sname_to_line ('key(        ', ln_len, ln);
            g17trimint4_to_line (kblKeyLen_gg11, ln_len, ln);
            g17sname_to_line ('):          ', ln_len, ln);
            ln_len       := ln_len + 1;
            indent       := ln_len;
            moveobj_ptr  := @trace.trceKbLock.kblcInfo_gg11;
            print_keylen := trace.trceHead.vhLen_gg11
                  - sizeof (tgg11_VtraceHeader)
                  - sizeof (trace.trceKbLock.kblcHead_gg11);
            IF  print_keylen > kblKeyLen_gg11
            THEN
                print_keylen := kblKeyLen_gg11;
            (*ENDIF*) 
            IF  print_keylen > 0
            THEN
                BEGIN
                IF  x05ishex (moveobj_ptr^, sizeof (trace.trceKbLock.kblcInfo_gg11),
                    1, print_keylen)
                THEN
                    xt02print_hex (d, moveobj_ptr^, sizeof (trace.trceKbLock.kblcInfo_gg11),
                          1, print_keylen, indent, ln_len, ln)
                ELSE
                    xt02print_char (d.dsTerm^, d.dsProt^, moveobj_ptr^,
                          sizeof (trace.trceKbLock.kblcInfo_gg11),
                          1, print_keylen, indent, true, ln_len, ln);
                (*ENDIF*) 
                line_written := true
                END;
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  NOT line_written
THEN
    BEGIN
    t12write_prot (d.dsProt^, ln, ln_len, err);
    t09put (d.dsTerm^, ln, cut_protected)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_kb_function (
            VAR d      : t_DisplState;
            VAR trace  : trace_record;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
VAR
      keylen      : integer;
      err         : integer;
      moveobj_ptr : tsp00_MoveObjPtr;
 
BEGIN
(* --- vttKbFunctions_egg00 --- *)
IF  false AND
    (trace.trceKb.kbMessType_gg11 <> m_return_error ) AND
    (trace.trceKb.kbMessType_gg11 <> m_return_result)
THEN
    BEGIN
    IF  trace.trceKbTabId.kbtHead_gg11.kbSubtrans_gg11 <> 0
    THEN
        BEGIN
        ln[ ln_len ] := '/';
        g17trimint4_to_line (trace.trceKbTabId.kbtHead_gg11.kbSubtrans_gg11, ln_len, ln);
        ln_len := ln_len + 1
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt02mess_types_to_line (trace.trceKb.kbMessType_gg11,
      trace.trceKb.kbMessType2_gg11, ln_len, ln);
CASE trace.trceKb.kbMessType_gg11 OF
    m_delete,            m_insert_select,
    m_select,            m_fetch,
    m_select_row,        m_get,
    m_update,            m_insert,
    m_update_rec:
        BEGIN
        ln_len := ln_len + 1;
        IF  trace.trceKbTabId.kbtTabId_gg11 = cgg_sys1_catalog_id
        THEN
            g17sname_to_line ('SYS1CAT     ', ln_len, ln)
        ELSE
            IF  trace.trceKbTabId.kbtTabId_gg11 = cgg_sys2_catalog_id
            THEN
                g17sname_to_line ('SYS2CAT     ', ln_len, ln)
            ELSE
                BEGIN
                g17sname_to_line ('TABID       ', ln_len, ln);
                ln_len := ln_len + 1;
                g17surrogate_to_line (trace.trceKbTabId.kbtTabId_gg11, ln_len, ln)
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        keylen  := trace.trceKbTabId.kbtKeyLen_gg11;
        IF  keylen = 0
        THEN
            BEGIN
            g17sname_to_line (' zerokey    ', ln_len, ln);
            t12write_prot (d.dsProt^, ln, ln_len, err);
            t09put (d.dsTerm^, ln, cut_protected)
            END
        ELSE
            BEGIN
            g17sname_to_line (' key(       ', ln_len, ln);
            g17trimint4_to_line (keylen, ln_len, ln);
            g17sname_to_line ('):          ', ln_len, ln);
            ln_len := ln_len + 1;
            IF  keylen > trace.trceHead.vhLen_gg11
                - sizeof (tgg11_VtraceHeader)
                - sizeof (tgg11_KbTabIdTrace)
            THEN
                keylen := trace.trceHead.vhLen_gg11
                      - sizeof (tgg11_VtraceHeader)
                      - sizeof (tgg11_KbTabIdTrace);
            (*ENDIF*) 
            moveobj_ptr := @trace.trceKbTabKey.kbtkKey_gg11;
            IF  x05ishex (moveobj_ptr^, sizeof (trace.trceKbTabKey.kbtkKey_gg11), 1, keylen)
            THEN
                xt02print_hex (d, moveobj_ptr^, sizeof (trace.trceKbTabKey.kbtkKey_gg11),
                      1, keylen, 5, ln_len, ln)
            ELSE
                xt02print_char (d.dsTerm^, d.dsProt^,
                      moveobj_ptr^, sizeof (trace.trceKbTabKey.kbtkKey_gg11),
                      1, keylen, 5, true, ln_len, ln)
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    m_return_error, m_return_result:
        BEGIN
        ln [1] := d.dsLeaveFunctSign [1];
        IF  trace.trceKb.kbMessType_gg11 <> m_return_result
        THEN
            xt02_BasisError (trace.trceKb.kbError_gg11, ln_len, ln);
        (*ENDIF*) 
        IF  trace.trceKb.kbMessType2_gg11 = mm_test
        THEN
            (* KbTimeTrace *)
            xt02_PrintSeconds (d.dsTerm^, d.dsProt^,
                  trace.trceKbTime.kbtmSec_gg11,
                  trace.trceKbTime.kbtmMsec_gg11, ln_len, ln);
        (*ENDIF*) 
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected)
        END;
    OTHERWISE
        BEGIN
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected)
        END
    END
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_kb_locking (
            VAR d      : t_DisplState;
            VAR trace  : trace_record;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
VAR
      err : integer;
 
BEGIN
(* --- vttKbClearLockList_egg00 --- vttKbRequestTimeout_egg00 --- *)
CASE trace.trceKb.kbMessType_gg11 OF
    m_begin:
        BEGIN
        ln [1] := CALL_FUNCTION_SIGN;
        g17nameto_line ('inspect locklist  ', ln_len, ln)
        END;
    m_return_error:
        BEGIN
        ln [1] := d.dsLeaveFunctSign [1];
        g17nameto_line ('inspect locklist  ', ln_len, ln);
        ln_len := ln_len + 1;
        xt02_BasisError (trace.trceKb.kbError_gg11, ln_len, ln)
        END;
    m_cancel, m_rollback:
        BEGIN
        ln_len := ln_len + 1;
        IF  trace.trceHead.vhType_gg11 = vttKbClearLockList_egg00
        THEN
            g17nameto_line ('lock timeout:     ', ln_len, ln)
        ELSE
            g17nameto_line ('request timeout:  ', ln_len, ln);
        (*ENDIF*) 
        trace.trceKbTimeout.kbtmoSubtrans_gg11 := 0;
        gg06TransToLine (trace.trceKbTimeout.kbtmoTransId_gg11, ln_len, ln);
        ln_len := ln_len + 1;
        g17sname_to_line ('(task       ', ln_len, ln);
        ln_len      := ln_len + 1;
        g17trimint4_to_line (trace.trceKbTimeout.kbtmoTask_gg11, ln_len, ln);
        ln_len      := ln_len + 1;
        ln [ln_len] := ')'
        END;
    OTHERWISE ;
    END;
(*ENDCASE*) 
t12write_prot (d.dsProt^, ln, ln_len, err);
t09put (d.dsTerm^, ln, cut_protected)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_kb_oms (
            VAR d        : t_DisplState;
            VAR trace    : trace_record;
            VAR ln_len   : integer;
            VAR ln       : tsp00_Line);
 
VAR
      ok                 : boolean;
      print_consist_view : boolean;
      print_line         : boolean;
      err                : integer;
 
BEGIN
(* --- kb04oms --- *)
print_consist_view := false;
print_line         := true;
ok                 := true;
IF  trace.trceKb.kbMessType_gg11 = m_get_object
THEN
    CASE trace.trceKb.kbMessType2_gg11 OF
        mm_key:
            g17nameto_line   ('GetObjWithKey     ', ln_len, ln);
        mm_object_id:
            BEGIN
            print_consist_view := true;
            g17nameto_line   ('GetObjWithKeyCons ', ln_len, ln)
            END;
        mm_nil:
            g17sname_to_line ('GetObj      ',       ln_len, ln);
        mm_consistent:
            BEGIN
            print_consist_view := true;
            g17nameto_line   ('GetObjConsistent  ', ln_len, ln)
            END;
        mm_next:
            g17sname_to_line ('NextObj     ',       ln_len, ln);
        mm_qual:
            BEGIN
            print_consist_view := true;
            g17nameto_line   ('NextObjConsistent ', ln_len, ln)
            END;
        OTHERWISE
            ok := false
        END
    (*ENDCASE*) 
ELSE
    IF  trace.trceKb.kbMessType2_gg11 = mm_object
    THEN
        CASE trace.trceKb.kbMessType_gg11 OF
            m_create_file:
                g17nameto_line   ('CreateObjFile     ', ln_len, ln);
            (* PTS 1114833 UJ *)
            m_create_index:
                g17nameto_line   ('CreateObjIndex    ', ln_len, ln);
            m_delete:
                g17sname_to_line ('DeleteObj   ',       ln_len, ln);
            m_lock:
                g17sname_to_line ('LockObj     ',       ln_len, ln);
            m_new:
                g17sname_to_line ('NewObj      ',       ln_len, ln);
            m_release, m_usage:
                BEGIN
                print_line := false;
                ln [1]     := ' ';
                IF  trace.trceKb.kbMessType_gg11 = m_release
                THEN
                    g17sname_to_line ('unused      ',       ln_len, ln)
                ELSE
                    g17sname_to_line ('used        ',       ln_len, ln);
                (*ENDIF*) 
                ln_len := ln_len + 1;
                xt02print_oms_oid (d, trace, ln_len, ln)
                END;
            m_unlock:
                g17sname_to_line ('UnlockObj   ',       ln_len, ln);
            m_update:
                g17sname_to_line ('UpdateObj   ',       ln_len, ln);
            OTHERWISE
                ok := false
            END
        (*ENDCASE*) 
    ELSE
        IF  (trace.trceKb.kbMessType_gg11  = m_begin ) AND
            (trace.trceKb.kbMessType2_gg11 = mm_trans)
        THEN
            g17nameto_line ('StartConsistTrans ', ln_len, ln)
        ELSE
            IF  (trace.trceKb.kbMessType_gg11  = m_end   ) AND
                (trace.trceKb.kbMessType2_gg11 = mm_trans)
            THEN
                BEGIN
                print_consist_view := true;
                g17nameto_line ('EndConsistentTrans', ln_len, ln)
                END
            ELSE
                IF  trace.trceKb.kbMessType_gg11 = m_return_error
                THEN
                    BEGIN
                    ln [1] := d.dsLeaveFunctSign [1];
                    print_consist_view := trace.trceKb.kbMessType2_gg11 = mm_trans;
                    xt02_BasisError (trace.trceKb.kbError_gg11, ln_len, ln)
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
IF  NOT ok
THEN
    xt02mess_types_to_line (trace.trceKb.kbMessType_gg11,
          trace.trceKb.kbMessType2_gg11, ln_len, ln)
ELSE
    IF  print_consist_view
    THEN
        BEGIN
        g17sname_to_line (' (CsVers    ', ln_len, ln);
        ln_len := ln_len + 1;
        gg06TransToLine (trace.trceKbConsistView.kbcvConsistView_gg11, ln_len, ln);
        ln_len := ln_len + 1;
        ln [ln_len] := ')'
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  print_line
THEN
    BEGIN
    t12write_prot (d.dsProt^, ln, ln_len, err);
    t09put (d.dsTerm^, ln, cut_protected)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_oms_error (
            VAR d        : t_DisplState;
            VAR trace    : trace_record;
            VAR ln_len   : integer;
            VAR ln       : tsp00_Line);
 
VAR
      ix : integer;
 
BEGIN
WITH trace.OmsError DO
    BEGIN
    ln [1] := d.dsLeaveFunctSign [1];
    g17sname_to_line ('FileNo =    ', ln_len, ln);
    ln_len := ln_len + 1;
    g172fileno_to_line ( oerr.ObjFileNo_C8_gg12, ln_len, ln );
    g17sname_to_line (', root      ', ln_len, ln);
    ln_len := ln_len + 1;
    IF  oerrRoot_gg12 = NIL_PAGE_NO_GG00
    THEN
        g17sname_to_line ('= nil       ', ln_len, ln)
    ELSE
        g17trimint4_to_line (oerrRoot_gg12 , ln_len, ln);
    (*ENDIF*) 
    ln [ln_len+1] := ')';
    ln_len := ln_len + 2;
    xt02_BasisError (oerrError_gg12, ln_len, ln);
    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_oms_file_info (
            VAR d      : t_DisplState;
            VAR trace  : trace_record;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
BEGIN
WITH trace.OmsFileInfo DO
    BEGIN
    ln [1] := d.dsLeaveFunctSign [1];
    g17sname_to_line ('root page=  ', ln_len, ln);
    g17trimint4_to_line (oinfRoot_gg12 , ln_len, ln);
    g17sname_to_line (' # all p.=  ', ln_len, ln);
    g17trimint4_to_line (oinfNumAllPages_gg12 , ln_len, ln);
    g17sname_to_line (' # free p.= ', ln_len, ln);
    g17trimint4_to_line (oinfNumFreePages_gg12 , ln_len, ln);
    g17sname_to_line (' # empty p.=', ln_len, ln);
    g17trimint4_to_line (oinfNumEmptyPages_gg12 , ln_len, ln);
    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_oms_garb_coll (
            VAR d      : t_DisplState;
            VAR trace  : trace_record;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
BEGIN
WITH trace.OmsGarbColl DO
    BEGIN
    ln_len := ln_len - 2;
    g17sname_to_line ('Collector   ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (ogrbCollectorIndex_gg12 , ln_len, ln);
    IF  ( ogrbIsActiv_gg12 )
    THEN
        BEGIN
        ln [1] := CALL_FUNCTION_SIGN;
        g17sname_to_line (' is started ', ln_len, ln)
        END
    ELSE
        BEGIN
        ln [1] := d.dsLeaveFunctSign [1];
        g17sname_to_line (' is stopped ', ln_len, ln)
        END;
    (*ENDIF*) 
    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_oms_key (
            VAR d      : t_DisplState;
            VAR trace  : trace_record;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
VAR
      err             : integer;
      new_line_offset : integer;
      print_key_len   : integer;
      moveobj_ptr     : tsp00_MoveObjPtr;
      ix              : integer;
 
BEGIN
IF  (trace.trceHead.vhType_gg11 <> b22rem_oid   ) AND
    (trace.trceHead.vhType_gg11 <> b92check_hash)
THEN
    ln [1] := CALL_FUNCTION_SIGN;
(*ENDIF*) 
WITH trace.OmsKey, trace.OmsKey.okyHead_gg12 DO
    BEGIN
    g17sname_to_line ('KeyFileNo = ', ln_len, ln);
    ln_len := ln_len + 1;
    g172fileno_to_line ( okh.ObjFileNo_C8_gg12, ln_len, ln );
    g17sname_to_line (' KEY(       ', ln_len, ln);
    g17trimint4_to_line (okhKeyLen_gg12, ln_len, ln);
    g17sname_to_line ('):          ', ln_len, ln);
    ln_len := ln_len + 1;
    new_line_offset := ln_len;
    IF  okhKeyLen_gg12 > trace.trceHead.vhLen_gg11
        - sizeof (tgg11_VtraceHeader) - sizeof (tgg12_OmsTraceKeyHeader)
    THEN
        print_key_len := trace.trceHead.vhLen_gg11
              - sizeof (tgg11_VtraceHeader) - sizeof (tgg12_OmsTraceKeyHeader)
    ELSE
        print_key_len := okhKeyLen_gg12;
    (*ENDIF*) 
    IF  print_key_len > 0
    THEN
        BEGIN
        moveobj_ptr := @okyKey_gg12;
        xt02print_hex (d, moveobj_ptr^, sizeof (okyKey_gg12),
              1, print_key_len, new_line_offset, ln_len, ln)
        END
    ELSE
        BEGIN
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected)
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_oms_oid (
            VAR d      : t_DisplState;
            VAR trace  : trace_record;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
BEGIN
WITH trace.OmsOid DO
    BEGIN
    IF  (ooidTrType2_gg12 = ot2Input_egg12       ) OR
        (ooidTrType2_gg12 = ot2InputVers_egg12   ) OR
        (ooidTrType2_gg12 = ot2InputSeq_egg12    ) OR
        (ooidTrType2_gg12 = ot2InputSeqVers_egg12)
    THEN
        BEGIN
        ln [1] := CALL_FUNCTION_SIGN;
        g17sname_to_line ('--> OID     ', ln_len, ln)
        END
    ELSE
        BEGIN
        ln [1] := d.dsLeaveFunctSign [1];
        g17sname_to_line ('<-- OID     ', ln_len, ln)
        END;
    (*ENDIF*) 
    ln_len := ln_len + 1;
    gg06OidToLine (ooidObjId_gg12, ln_len, ln);
    IF  (ooidTrType2_gg12 = ot2InputSeq_egg12    ) OR
        (ooidTrType2_gg12 = ot2InputSeqVers_egg12) OR
        ((trace.trceHead.vhType_gg11 = b04get_consistent) AND
        (ooidTrType2_gg12 = ot2InputVers_egg12   )) OR   (* FF 2003-Dec-01 PTS 1124797 *)
        (ooidTrType2_gg12 = ot2OutputSeq_egg12   )
    THEN
        BEGIN
        g17sname_to_line ('  ObjVers:  ', ln_len, ln);
        ln_len := ln_len + 1;
        g17page_ref_to_line (ooidObjVers_gg12, ln_len, ln)
        END;
    (*ENDIF*) 
    IF  (ooidTrType2_gg12 = ot2InputVers_egg12   ) OR
        (ooidTrType2_gg12 = ot2InputSeqVers_egg12)
    THEN
        BEGIN
        g17sname_to_line ('  CsVers:   ', ln_len, ln);
        ln_len := ln_len + 1;
        gg06TransToLine (ooidConsView_gg12, ln_len, ln)
        END;
    (*ENDIF*) 
    IF  (trace.trceHead.vhType_gg11 = b04rupd) AND (ooidTrType2_gg12 = ot2InputSeqVers_egg12)
    THEN
        (* display rollback mess type *)
        BEGIN
        g17sname_to_line ('  RollbType:', ln_len, ln);
        ln_len := ln_len + 1;
        g17messtype_to_line (trace.OmsMessType, ln_len, ln)
        END;
    (*ENDIF*) 
    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_oms_page_chain_stat (
            VAR d      : t_DisplState;
            VAR trace  : trace_record;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
VAR
      start_ln_len : integer;
 
BEGIN
WITH trace.OmsPageChainStat DO
    BEGIN
    start_ln_len := ln_len;
    g17sname_to_line ('sub root =  ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opctSubRoot_gg12 , ln_len, ln);
    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
    (* *)
    ln := d.dsTerm^.blankline;
    ln_len := start_ln_len;
    g17sname_to_line ('free obj =  ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opctFreeObjCnt_gg12 , ln_len, ln);
    ln_len := ln_len + 2;
    g17sname_to_line ('occ obj =   ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opctOccObjCnt_gg12 , ln_len, ln);
    ln_len := ln_len + 2;
    g17sname_to_line ('res obj =   ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opctResObjCnt_gg12 , ln_len, ln);
    ln_len := ln_len + 2;
    g17sname_to_line ('feot obj =  ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opctFeotObjCnt_gg12 , ln_len, ln);
    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
    (* *)
    ln     := d.dsTerm^.blankline;
    ln_len := start_ln_len;
    g17sname_to_line ('all pages  =', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opctAllPageCnt_gg12 , ln_len, ln);
    g17sname_to_line ('=           ', ln_len, ln);
    g17trimint4_to_line (opctAllPageRootCnt_gg12 , ln_len, ln);
    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
    (* *)
    ln     := d.dsTerm^.blankline;
    ln_len := start_ln_len;
    g17sname_to_line ('free pages =', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opctFreePageWithFreeLabelInFreeChainCnt_gg12 , ln_len, ln);
    g17sname_to_line ('<=          ', ln_len, ln);
    g17trimint4_to_line (opctFreePageInFreeChainCnt_gg12 , ln_len, ln);
    g17sname_to_line ('<=          ', ln_len, ln);
    g17trimint4_to_line (opctFreePageCnt_gg12 , ln_len, ln);
    g17sname_to_line ('<=          ', ln_len, ln);
    g17trimint4_to_line (opctPageWithFreeLabelInFreeChainCnt_gg12 , ln_len, ln);
    g17sname_to_line ('=           ', ln_len, ln);
    g17trimint4_to_line (opctFreePageRootCnt_gg12 , ln_len, ln);
    g17sname_to_line ('=           ', ln_len, ln);
    g17trimint4_to_line (opctPageWithFreeLabelCnt_gg12 , ln_len, ln);
    g17sname_to_line ('=           ', ln_len, ln);
    g17trimint4_to_line (opctPageInFreeChainCnt_gg12 , ln_len, ln);
    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
    (* *)
    ln     := d.dsTerm^.blankline;
    ln_len := start_ln_len;
    g17sname_to_line ('feot pages =', ln_len, ln);
    g17trimint4_to_line (opctFeotPageCnt_gg12 , ln_len, ln);
    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
    (* *)
    ln     := d.dsTerm^.blankline;
    ln_len := start_ln_len;
    g17sname_to_line ('empty pages=', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opctEmptyPageInFreeChainCnt_gg12 , ln_len, ln);
    g17sname_to_line ('<=          ', ln_len, ln);
    g17trimint4_to_line (opctEmptyPageRootCnt_gg12 , ln_len, ln);
    g17sname_to_line ('=           ', ln_len, ln);
    g17trimint4_to_line (opctPageWithEmptyLabelCnt_gg12 , ln_len, ln);
    g17sname_to_line ('<=          ', ln_len, ln);
    g17trimint4_to_line (opctEmptyPageCnt_gg12 , ln_len, ln);
    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
    (* *)
    ln     := d.dsTerm^.blankline;
    ln_len := start_ln_len;
    g17nameto_line ('ChainDeleteFlag  =', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (ord(opctIsChainDeleted_gg12) , ln_len, ln);
    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_oms_page_container_stat (
            VAR term        : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            VAR trace       : trace_record;
            VAR ln_len      : integer;
            VAR ln          : tsp00_Line);
 
VAR
      start_ln_len : integer;
 
BEGIN
WITH trace.OmsPageConStat DO
    BEGIN
    start_ln_len := ln_len;
    g17sname_to_line ('# sub roots=', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opcoNumSubRoots_gg12 , ln_len, ln);
    xt02xwrite_line (term, protfile, ln);
    (* *)
    ln := term.blankline;
    ln_len := start_ln_len;
    g17sname_to_line ('free obj =  ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opcoFreeObjCnt_gg12 , ln_len, ln);
    ln_len := ln_len + 2;
    g17sname_to_line ('occ obj =   ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opcoOccObjCnt_gg12 , ln_len, ln);
    ln_len := ln_len + 2;
    g17sname_to_line ('res obj =   ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opcoResObjCnt_gg12 , ln_len, ln);
    ln_len := ln_len + 2;
    g17sname_to_line ('feot obj =  ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opcoFeotObjCnt_gg12 , ln_len, ln);
    xt02xwrite_line (term, protfile, ln);
    (* *)
    ln := term.blankline;
    ln_len := start_ln_len;
    g17sname_to_line ('all pages  =', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opcoAllPageCnt_gg12 , ln_len, ln);
    ln_len := ln_len + 1;
    g17sname_to_line ('free pages =', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opcoFreePageCnt_gg12 , ln_len, ln);
    ln_len := ln_len + 1;
    g17sname_to_line ('feot pages =', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opcoFeotPageCnt_gg12 , ln_len, ln);
    ln_len := ln_len + 1;
    g17sname_to_line ('empty pages=', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opcoEmptyPageCnt_gg12 , ln_len, ln);
    xt02xwrite_line (term, protfile, ln);
    (**)
    ln := term.blankline;
    ln_len := start_ln_len;
    g17nameto_line ('FileDeleteFlag   =', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (ord(opcoIsFileDeleted_gg12) , ln_len, ln);
    xt02xwrite_line (term, protfile, ln);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_oms_page_stat (
            VAR term        : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            VAR trace       : trace_record;
            VAR ln_len      : integer;
            VAR ln          : tsp00_Line);
 
BEGIN
WITH trace.OmsPageStat DO
    BEGIN
    g17sname_to_line ('page no =   ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (opsPno_gg12 , ln_len, ln);
    g17sname_to_line ('  # occ obj=', ln_len, ln);
    g17trimint4_to_line (opsOccObjCnt_gg12 , ln_len, ln);
    g17sname_to_line (' # free obj=', ln_len, ln);
    g17trimint4_to_line (opsFreeObjCnt_gg12 , ln_len, ln);
    g17sname_to_line (' # feot obj=', ln_len, ln);
    g17trimint4_to_line (opsFreeEotObjCnt_gg12 , ln_len, ln);
    g17sname_to_line (' # res obj= ', ln_len, ln);
    g17trimint4_to_line (opsResObjCnt_gg12 , ln_len, ln);
    xt02xwrite_line (term, protfile, ln)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_oms_version_error (
            VAR term        : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            VAR trace       : trace_record;
            VAR ln_len      : integer;
            VAR ln          : tsp00_Line);
 
VAR
      start_ln_len : integer;
      ix : integer;
 
BEGIN
WITH trace.OmsVersionError DO
    BEGIN
    start_ln_len := ln_len;
    g17sname_to_line ('Wanted OID: ', ln_len, ln);
    gg06OidToLine (oveObjId_gg12, ln_len, ln);
    g17sname_to_line ('Wanted Vers:', ln_len, ln);
    ln_len := ln_len + 1;
    g17page_ref_to_line (oveWantedVers_gg12, ln_len, ln);
    xt02xwrite_line (term, protfile, ln);
    (**)
    ln     := term.blankline;
    ln_len := start_ln_len + 10;
    g17sname_to_line ('  ObjVers:  ', ln_len, ln);
    ln_len := ln_len + 1;
    g17page_ref_to_line (oveObjVers_gg12, ln_len, ln);
    g17sname_to_line ('FrameVers:  ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (oveFrameVers_gg12 , ln_len, ln);
    g17sname_to_line ('PageFileNo: ', ln_len, ln);
    ln_len := ln_len + 1;
    g172fileno_to_line ( ove.ObjFileNo_C8_gg12, ln_len, ln );
    xt02xwrite_line (term, protfile, ln)
    END;
(*ENDWITH*) 
END;
 
(* PTS 1111934 AK 25/09/2001    *)
(*------------------------------*) 
 
PROCEDURE
      xt02print_oms_keys_of_iterator (
            VAR d      : t_DisplState;
            VAR trace  : trace_record;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
VAR
      msg              : ARRAY [1..2] OF tsp00_Sname;
      new_line_offset  : integer;
 
BEGIN
new_line_offset  := ln_len;
msg [1] := 'StartKey    ';
msg [2] := 'Stop Key    ';
xt02print_vtrace_key (d, new_line_offset, msg [1],
      trace.OmsTwoKeys.oskKeyLen_gg12,
      trace.OmsTwoKeys.oskStartKey_gg12,
      ln_len, ln);
ln     := d.dsTerm^.blankline;
ln_len := new_line_offset;
xt02print_vtrace_key (d, new_line_offset, msg [2],
      trace.OmsTwoKeys.oskKeyLen_gg12,
      trace.OmsTwoKeys.oskStopKey_gg12,
      ln_len, ln);
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_oms_rel_obj_stat (
            VAR d      : t_DisplState;
            VAR trace  : trace_record;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
BEGIN
WITH trace.OmsRelOid DO
    BEGIN
    IF  (roidTrType2_gg12 = ot2Input_egg12       ) OR
        (roidTrType2_gg12 = ot2InputVers_egg12   ) OR
        (roidTrType2_gg12 = ot2InputSeq_egg12    ) OR
        (roidTrType2_gg12 = ot2InputSeqVers_egg12)
    THEN
        BEGIN
        ln [1] := CALL_FUNCTION_SIGN;
        g17sname_to_line ('--> OID     ', ln_len, ln)
        END
    ELSE
        BEGIN
        ln [1] := d.dsLeaveFunctSign [1];
        g17sname_to_line ('<-- OID     ', ln_len, ln)
        END;
    (*ENDIF*) 
    ln_len := ln_len + 1;
    gg06OidToLine (roidObjId_gg12, ln_len, ln);
    ln_len := ln_len + 1;
    IF  (roidTrType2_gg12 = ot2InputSeq_egg12    ) OR
        (roidTrType2_gg12 = ot2InputSeqVers_egg12) OR
        (roidTrType2_gg12 = ot2OutputSeq_egg12   )
    THEN
        BEGIN
        g17sname_to_line ('  ObjVers:  ', ln_len, ln);
        ln_len := ln_len + 1;
        g17page_ref_to_line (roidObjVers_gg12, ln_len, ln)
        END;
    (*ENDIF*) 
    IF  (roidTrType2_gg12 = ot2InputVers_egg12   ) OR
        (roidTrType2_gg12 = ot2InputSeqVers_egg12)
    THEN
        BEGIN
        g17sname_to_line ('  CsVers:   ', ln_len, ln);
        ln_len := ln_len + 1;
        gg06TransToLine (roidConsView_gg12, ln_len, ln)
        END;
    (*ENDIF*) 
    CASE roidRelObjStatus_gg12 OF
        rosObjSucessfullyReleased_gg12 :
            g17sname_to_line ('Ok          ', ln_len, ln);
        rosPageNotFound_gg12:
            g17sname_to_line ('PageNotFound', ln_len, ln);
        rosFileAlreadyDeleted_gg12:
            g17sname_to_line ('FileNotFound', ln_len, ln);
        (* PTS 1106724 Alexander Kley 23/05/2000 *)
        rosFileJustDeleted_gg12:
            g17sname_to_line ('FileDeleted ', ln_len, ln);
        rosWrongFileNo_gg12:
            g17sname_to_line ('WrongFileNo ', ln_len, ln);
        rosWrongObjVersion_gg12:
            g17sname_to_line ('WrongObjVers', ln_len, ln);
        rosUnknownError_gg12:
            g17sname_to_line ('NOT Ok      ', ln_len, ln);
        (* PTS 1106760  Alexander Kley 25/06/2000 *)
        rosDelKeyFailed_gg12:
            g17sname_to_line ('DelKeyFailed', ln_len, ln);
        rosDelContObjFailed_gg12:
            g17sname_to_line ('DelCOFailed ', ln_len, ln);
        rosWrongKeyInfo_gg12:
            g17sname_to_line ('WrongKeyInfo', ln_len, ln);
        rosOIdReused_gg12:
            g17sname_to_line ('OFrameReused', ln_len, ln);
        END;
    (*ENDCASE*) 
    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_packet_head (
            VAR d          : t_DisplState;
            VAR f          : tut_file;
            with_entry_pos : boolean;
            VAR trace      : trace_record);
 
VAR
      n      : tsp00_Sname;
      err    : integer;
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  trace.trceHead.vhType_gg11 = ak_send
THEN
    n := 'RECEIVE     '
ELSE
    BEGIN
    t12write_prot (d.dsProt^, d.dsTerm^.blankline, 1, err);
    t09put (d.dsTerm^, d.dsTerm^.blankline, cut_protected);
    IF  trace.trceHead.vhType_gg11 = ak_receive
    THEN
        n := 'REQUEST     '
    ELSE
        (* ak_reject *)
        n := '*** REJECT  '
    (*ENDIF*) 
    END;
(*ENDIF*) 
g17packet_head (n, trace.packet_head, ln_len, ln);
t12write_prot (d.dsProt^, ln, ln_len, err);
t09put (d.dsTerm^, ln, cut_bright_protected);
IF  with_entry_pos
THEN
    BEGIN
    ln          := d.dsTerm^.blankline;
    ln_len      := 1;
    ln [ln_len] := '(';
    xt02entry_pos_to_line (f, ln_len, ln);
    ln_len      := ln_len + 1;
    ln [ln_len] := ')';
    t12write_prot (d.dsProt^, ln, ln_len, err);
    t09put (d.dsTerm^, ln, cut_bright_protected);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_packet_part (
            VAR d     : t_DisplState;
            VAR trace : trace_record);
 
VAR
      displ_buf    : boolean;
      err          : integer;
      ln_len       : integer;
      buf_len      : tsp00_Int4;
      moveobj_ptr  : tsp00_MoveObjPtr;
      ln           : tsp00_Line;
 
BEGIN
g17parthead (trace.packet_part_head, ln_len, ln);
t12write_prot (d.dsProt^, ln, ln_len, err);
t09put (d.dsTerm^, ln, cut_bright_protected);
buf_len := trace.packet_part_head.sp1p_buf_len;
IF  buf_len > trace.trceHead.vhLen_gg11
    - sizeof (tgg11_VtraceHeader) - sizeof(trace.packet_part_head)
THEN
    buf_len:= trace.trceHead.vhLen_gg11
          - sizeof (tgg11_VtraceHeader) - sizeof(trace.packet_part_head);
(*ENDIF*) 
moveobj_ptr := @trace.packet_part_buf;
xt02special_part_buf (d,
      trace.packet_part_head.sp1p_part_kind,
      trace.packet_part_head.sp1p_arg_count,
      buf_len, moveobj_ptr, displ_buf);
IF  (buf_len > 0) AND displ_buf
THEN
    BEGIN
    ln     := d.dsTerm^.blankline;
    ln_len := PACKET_INDENT;
    g17sname_to_line ('buf(        ', ln_len, ln);
    g17trimint4_to_line (trace.packet_part_head.sp1p_buf_len,
          ln_len, ln);
    g17sname_to_line ('):          ', ln_len, ln);
    IF  x05ishex (moveobj_ptr^, sizeof (trace.packet_part_buf),
        1, buf_len) AND
        NOT xt02isuniasc (moveobj_ptr^, 1, buf_len)
    THEN
        BEGIN
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected);
        ln     := d.dsTerm^.blankline;
        ln_len := PACKET_INDENT;
        xt02print_hex (d, moveobj_ptr^, sizeof (trace.packet_part_buf), 1, buf_len,
              PACKET_INDENT, ln_len, ln)
        END
    ELSE
        BEGIN
        ln_len := ln_len + 1;
        IF  ln_len + 2 + buf_len > PROT_LINESIZE
        THEN
            BEGIN
            t12write_prot (d.dsProt^, ln, ln_len, err);
            t09put (d.dsTerm^, ln, cut_protected);
            ln     := d.dsTerm^.blankline;
            ln_len := PACKET_INDENT
            END;
        (*ENDIF*) 
        xt02print_char (d.dsTerm^, d.dsProt^, moveobj_ptr^,
              sizeof (trace.packet_part_buf), 1, buf_len,
              PACKET_INDENT, c_with_delimiter, ln_len, ln)
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_ret_segm_head (
            VAR d             : t_DisplState;
            VAR ret_segm_head : tsp1_segment_header);
 
VAR
      err     : integer;
      ln1_len : integer;
      ln2_len : integer;
      ln1     : tsp00_Line;
      ln2     : tsp00_Line;
 
BEGIN
g17returnsegm_head (ret_segm_head, ln1_len, ln1, ln2_len, ln2);
t12write_prot (d.dsProt^, ln1, ln1_len, err);
t09put (d.dsTerm^, ln1, cut_bright_protected);
IF  ln2_len > 0
THEN
    BEGIN
    t12write_prot (d.dsProt^, ln2, ln2_len, err);
    t09put (d.dsTerm^, ln2, cut_bright_protected)
    END;
(*ENDIF*) 
IF  ((ret_segm_head.sp1r_returncode     =  0  ) AND
    (ret_segm_head.sp1r_extern_warning <> [ ]))
    OR
    (warn15_user_defined_code in ret_segm_head.sp1r_extern_warning)
THEN
    xt02print_warnings (d.dsTerm^, d.dsProt^,
          ret_segm_head.sp1r_extern_warning, PACKET_INDENT);
(*ENDIF*) 
IF  (ret_segm_head.sp1r_intern_warning <> [ ])
THEN
    xt02print_intern_warnings (d.dsTerm^, d.dsProt^,
          ret_segm_head.sp1r_intern_warning, PACKET_INDENT);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02_PrintSeconds (
            VAR term     : tut_terminal;
            VAR protfile : tut_vf_fileref;
            Sec          : tsp00_Int4;
            Msec         : tsp00_Int4;
            VAR ln_len   : integer;
            VAR ln       : tsp00_Line);
 
CONST
      mx_msec_displ = 3;
 
VAR
      err        : integer;
      aux_ln_len : integer;
      aux_ln     : tsp00_Line;
 
BEGIN
aux_ln     := term.blankline;
aux_ln_len := 0;
g17trimint4_to_line (Sec, aux_ln_len, aux_ln);
aux_ln_len          := aux_ln_len + 1;
aux_ln [aux_ln_len] := '.';
(* 0.000987 --> 0.001 *)
g17int4to_line ((Msec + 500) DIV 1000, c_with_zero, mx_msec_displ, aux_ln_len+1, aux_ln);
aux_ln_len := aux_ln_len + mx_msec_displ + 1;
g17sname_to_line ('sec         ', aux_ln_len, aux_ln);
IF  ln_len + 1 + aux_ln_len > PROT_LINESIZE
THEN
    BEGIN
    t12write_prot (protfile, ln, ln_len, err);
    t09put (term, ln, cut_protected);
    ln     := term.blankline;
    ln_len := 0
    END;
(*ENDIF*) 
SAPDB_PascalForcedMove (sizeof (aux_ln), sizeof (ln),
      @aux_ln, 1, @ln, PROT_LINESIZE - aux_ln_len + 1, aux_ln_len);
ln_len := PROT_LINESIZE;
t12write_prot (protfile, ln, ln_len, err);
t09put (term, ln, cut_protected)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_seconds (
            VAR term     : tut_terminal;
            VAR protfile : tut_vf_fileref;
            VAR trace    : trace_record;
            trace_pos    : integer;
            VAR ln_len   : integer;
            VAR ln       : tsp00_Line);
 
BEGIN
xt02_PrintSeconds (term, protfile, s20buf_to_int4 (trace.buf, trace_pos),
      s20buf_to_int4 (trace.buf, trace_pos + INT4_MXSP00), ln_len, ln);
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_shutdown (
            VAR term     : tut_terminal;
            VAR protfile : tut_vf_fileref;
            VAR trace    : trace_record);
 
VAR
      err        : integer;
      i          : integer;
      ln1_len    : integer;
      ln2_len    : integer;
      ln3_len    : integer;
      date_pos   : integer;
      msg        : tsp00_Name;
      ln1        : tsp00_Line;
      ln2        : tsp00_Line;
      ln3        : tsp00_Line;
 
BEGIN
(*   ln1:   ***************  date time                *)
(*   ln2:   **  MESSAGE  **  [messtype / serverdb  ]  *)
(*   ln3:   ***************  [error    / servernode]  *)
(* *)
CASE trace.trceHead.vhType_gg11 OF
    vttKbEmergencyShutdown_egg00:
        BEGIN
        msg      := 'EMERGENCY SHUTDOWN';
        END;
    vttKbQuickShutdown_egg00:
        BEGIN
        msg      := 'QUICK SHUTDOWN    ';
        END;
    vttKbShutdown_egg00:
        BEGIN
        msg      := 'SHUTDOWN          ';
        date_pos := 1
        END
    END;
(*ENDCASE*) 
ln2     := term.blankline;
ln2 [1] := '*';
ln2 [2] := '*';
ln2_len := 4;
g17nameto_line (msg, ln2_len, ln2);
ln2_len         := ln2_len + 4;
ln2 [ln2_len-1] := '*';
ln2 [ln2_len  ] := '*';
(* *)
ln1_len := ln2_len;
ln1     := term.blankline;
FOR i := 1 TO ln1_len DO
    ln1 [i] := '*';
(*ENDFOR*) 
ln3_len := ln1_len;
ln3     := ln1;
(* *)
ln1_len := ln1_len + 3;
xt02_DateTimeToLine (trace.trceKbDateTime.kbdtDate_gg11,
      trace.trceKbDateTime.kbdtTime_gg11, (* PTS 1104456 JA 1999-11-03 *)
      NOT c_adjust, ln1_len, ln1);
IF  trace.trceHead.vhType_gg11 = vttKbEmergencyShutdown_egg00
THEN
    BEGIN
    ln2_len := ln2_len + 3;
    ln3_len := ln2_len;
    g17messtype_to_line (trace.trceKb.kbMessType_gg11, ln2_len, ln2);
    ln2_len := ln2_len + 1;
    g17mess2type_to_line (trace.trceKb.kbMessType2_gg11, ln2_len, ln2);
    g17basis_err_to_line (trace.trceKb.kbError_gg11, ln3_len, ln3)
    END;
(*ENDIF*) 
t09put (term, term.blankline, cut_protected);
t09put (term, ln1, cut_bright_protected);
t09put (term, ln2, cut_bright_protected);
t09put (term, ln3, cut_bright_protected);
t09put (term, term.blankline, cut_protected);
t12write_prot (protfile, term.blankline, 1, err);
t12write_prot (protfile, ln1, ln1_len, err);
t12write_prot (protfile, ln2, ln2_len, err);
t12write_prot (protfile, ln3, ln3_len, err);
t12write_prot (protfile, term.blankline, 1, err)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_trace_id (
            VAR term               : tut_terminal;
            VAR protfile           : tut_vf_fileref;
            with_transid           : boolean;
            with_entry_pos         : boolean;
            VAR f                  : tut_file;
            VAR trace              : trace_record;
            VAR old_trace          : tgg11_VtraceHeader;
            VAR ln_cnt_per_task    : integer);
 
VAR
      is_other_sess : boolean;
      is_new_trans  : boolean;
      err           : integer;
      i             : integer;
      ln_len        : integer;
      pno_len       : integer;
      ln            : tsp00_Line;
      pno_ln        : tsp00_Line;
 
BEGIN
is_other_sess :=
      (trace.trceHead.vhTask_gg11 <> old_trace.vhTask_gg11);
;
is_new_trans :=
      with_transid AND NOT is_other_sess
      AND
      NOT gg06IsNilTrans (trace.trceHead.vhTrans_gg11)
      AND
      (trace.trceHead.vhTrans_gg11 <> old_trace.vhTrans_gg11);
;
IF  is_other_sess OR is_new_trans OR (ln_cnt_per_task > MAX_LINES_PER_TASK)
THEN
    BEGIN
    ln     := term.blankline;
    ln_len := 0;
    IF  is_other_sess
    THEN
        BEGIN
        old_trace.vhSession_gg11 := trace.trceHead.vhSession_gg11;
        old_trace.vhTrans_gg11   := trace.trceHead.vhTrans_gg11;
        old_trace.vhTask_gg11    := trace.trceHead.vhTask_gg11;
        t12write_prot (protfile, term.blankline, 1, err);
        t09put (term, term.blankline, cut_protected);
        g17sname_to_line ('=====       ', ln_len, ln);
        ln_len := ln_len + 1;
        END
    ELSE
        BEGIN
        ln_len      := ln_len + 6; (* "     [" instead of "===== " *)
        ln [ln_len] := '['
        END;
    (*ENDIF*) 
    IF  NOT xt02sess_contains_taskname (trace.trceHead.vhSession_gg11)
    THEN
        BEGIN
        g17sname_to_line ('T           ', ln_len, ln);
        g17trimint4_to_line (trace.trceHead.vhTask_gg11, ln_len, ln);
        g17sname_to_line (' =====      ', ln_len, ln);
        ln_len := ln_len + 1
        END;
    (*ENDIF*) 
    xt02sess_trans_to_line (trace, ln_len, ln);
    ln_len  := ln_len + 1;
    (**)
    pno_ln  := term.blankline;
    pno_len := 0;
    IF  with_entry_pos
    THEN
        xt02entry_pos_to_line (f, pno_len, pno_ln);
    (**)
    (*ENDIF*) 
    IF  is_other_sess
    THEN
        WHILE ln_len < PROT_LINESIZE - pno_len - 1 DO
            BEGIN
            ln_len      := ln_len + 1;
            ln [ln_len] := '='
            END
        (*ENDWHILE*) 
    ELSE
        BEGIN
        IF  is_new_trans
        THEN
            BEGIN
            old_trace.vhTrans_gg11 := trace.trceHead.vhTrans_gg11;
            g17sname_to_line (' new TransNo', ln_len, ln);
            ln_len := ln_len + 1
            END;
        (*ENDIF*) 
        ln [ln_len] := ']';
        IF  ln_len + 1 + pno_len < PROT_LINESIZE
        THEN
            ln_len := PROT_LINESIZE - pno_len + 1
        ELSE
            ln_len := ln_len + 1
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    FOR i := 1 TO pno_len DO
        ln [ln_len+i] := pno_ln [i];
    (*ENDFOR*) 
    ln_len := ln_len + pno_len;
    t12write_prot (protfile, ln, ln_len, err);
    t09put (term, ln, cut_bright_protected);
    ln_cnt_per_task := 0
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_unknown (
            VAR d     : t_DisplState;
            VAR trace : trace_record);
 
VAR
      err         : integer;
      ln_len      : integer;
      ln          : tsp00_Line;
      moveobj_ptr : tsp00_MoveObjPtr;
 
BEGIN
ln     := d.dsTerm^.blankline;
ln_len := 0;
g17sname_to_line ('UNKNOWN:    ', ln_len, ln);
ln_len := ln_len + 1;
g17trimint4_to_line (ord(trace.trceHead.vhLayer_gg11), ln_len, ln);
ln_len := ln_len + 1;
g17trimint4_to_line (ord(trace.trceHead.vhType_gg11), ln_len, ln);
ln_len := ln_len + 1;
t12write_prot (d.dsProt^, ln, ln_len, err);
t09put (d.dsTerm^, ln, cut_bright_protected);
moveobj_ptr := @trace.buf;
IF  trace.trceHead.vhLen_gg11 - sizeof (tgg11_VtraceHeader) > 0
THEN
    xt02print_hex (d, moveobj_ptr^, sizeof (trace.buf),
          sizeof (tgg11_VtraceHeader) + 1, trace.trceHead.vhLen_gg11, 5, ln_len, ln)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_vtrace_key (
            VAR d           : t_DisplState;
            new_line_offset : integer;
            msg             : tsp00_Sname;
            keylen          : integer;
            VAR key         : tgg00_VtraceKey;
            VAR ln_len      : integer;
            VAR ln          : tsp00_Line);
 
VAR
      print_len   : integer;
      err         : integer;
      moveobj_ptr : tsp00_MoveObjPtr;
 
BEGIN
IF  keylen = 0
THEN
    BEGIN
    g17sname_to_line ('zero        ', ln_len, ln);
    ln_len := succ(ln_len);
    g17sname_to_line (msg, ln_len, ln);
    t12write_prot (d.dsProt^, ln, ln_len, err);
    t09put (d.dsTerm^, ln, cut_protected)
    END
ELSE
    BEGIN
    g17sname_to_line (msg, ln_len, ln);
    ln_len      := ln_len + 1;
    ln [ln_len] := '(';
    g17trimint4_to_line (keylen, ln_len, ln);
    g17sname_to_line ('):          ', ln_len, ln);
    ln_len := ln_len + 1;
    IF  keylen > sizeof (key)
    THEN
        print_len := sizeof (key)
    ELSE
        print_len := keylen;
    (*ENDIF*) 
    moveobj_ptr := @key;
    IF  x05ishex (moveobj_ptr^, sizeof (key), 1, print_len)
    THEN
        xt02print_hex (d, moveobj_ptr^, sizeof (key), 1, print_len,
              new_line_offset, ln_len, ln)
    ELSE
        xt02print_char (d.dsTerm^, d.dsProt^, moveobj_ptr^, sizeof (key), 1, print_len,
              new_line_offset, true, ln_len, ln)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_warnings (
            VAR term        : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            warn            : tsp00_WarningSet;
            new_line_offset : integer);
 
VAR
      curr_warn : tsp00_Warnings;
      err       : integer;
      ln_len    : integer;
      ln        : tsp00_Line;
 
BEGIN
IF  warn <> [ ]
THEN
    BEGIN
    IF  NOT (warn0_exist in warn)
    THEN
        BEGIN
        ln     := term.blankline;
        ln_len := new_line_offset;
        g17sname_to_line ('*** external',       ln_len, ln);
        g17nameto_line   (' WARNING 0 missing', ln_len, ln);
        t12write_prot (protfile, ln, ln_len, err);
        t09put (term, ln, cut_protected)
        END;
    (*ENDIF*) 
    FOR curr_warn := warn0_exist TO warn15_user_defined_code DO
        IF  curr_warn in warn
        THEN
            BEGIN
            ln     := term.blankline;
            ln_len := new_line_offset;
            g17sname_to_line ('external    ', ln_len, ln);
            ln_len := ln_len + 1;
            g17warning_item_to_line (curr_warn, ln_len, ln);
            t12write_prot (protfile, ln, ln_len, err);
            t09put (term, ln, cut_protected)
            END
        (*ENDIF*) 
    (*ENDFOR*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_intern_warnings (
            VAR term        : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            warn            : tsp1_warningset_intern;
            new_line_offset : integer);
 
VAR
      curr_warn : tsp1_intern_warning;
      err       : integer;
      ln_len    : integer;
      ln        : tsp00_Line;
 
BEGIN
IF  warn <> [ ]
THEN
    BEGIN
    FOR curr_warn := sp1iw_warn0_resultset_closed TO sp1iw_warn15 DO
        IF  curr_warn in warn
        THEN
            BEGIN
            ln     := term.blankline;
            ln_len := new_line_offset;
            g17sname_to_line ('internal    ', ln_len, ln);
            ln_len := ln_len + 1;
            g17intern_warning_item_to_line (curr_warn, ln_len, ln);
            t12write_prot (protfile, ln, ln_len, err);
            t09put (term, ln, cut_protected)
            END
        (*ENDIF*) 
    (*ENDFOR*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02put_save_restore_to_line (
            VAR trace  : trace_record;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
CONST
      c_task_drt = 1;
      c_task_dwt = 3;
      c_task_trt = 4;
 
VAR
      i2  : tsp00_IntMapC2;
      len : integer;
      n   : tsp00_Sname;
 
      save_vtrace_type : RECORD
            CASE boolean OF
                true:
                    (e : tgg00_SrVtrace2Type);
                false:
                    (c : tsp00_C2)
                END;
            (*ENDCASE*) 
 
      moveobj_ptr : tsp00_MoveObjPtr;
 
BEGIN
(* --- kb38restore_parallel --- kb38save_parallel --- *)
save_vtrace_type.c [1] := trace.buf [1];
CASE save_vtrace_type.e OF
    kb38run_save, kb38end_save:
        BEGIN
        IF  save_vtrace_type.e = kb38run_save
        THEN
            g17sname_to_line ('start       ', ln_len, ln)
        ELSE
            g17sname_to_line ('end         ', ln_len, ln);
        (*ENDIF*) 
        IF  (trace.buf [2] = chr (ord (c_task_drt))) OR
            (trace.buf [2] = chr (ord (c_task_trt)))
        THEN
            g17sname_to_line (' read  task ', ln_len, ln)
        ELSE
            g17sname_to_line (' write task ', ln_len, ln);
        (*ENDIF*) 
        ln_len        := ln_len + 1;
        i2.mapC2_sp00 [1] := trace.buf [3];
        i2.mapC2_sp00 [2] := trace.buf [4];
        g17trimint4_to_line (i2.mapInt_sp00, ln_len, ln);
        IF  (trace.buf [2] = chr (ord (c_task_drt))) OR
            (trace.buf [2] = chr (ord (c_task_dwt)))
        THEN
            g17sname_to_line (' devsp      ', ln_len, ln)
        ELSE
            BEGIN
            g17sname_to_line (' tape       ', ln_len, ln);
            ln_len := ln_len + 1; (* "tape " *)
            END;
        (*ENDIF*) 
        ln_len        := ln_len + 1;
        i2.mapC2_sp00 [1] := trace.buf [5];
        i2.mapC2_sp00 [2] := trace.buf [6];
        g17trimint4_to_line (i2.mapInt_sp00, ln_len, ln);
        IF  save_vtrace_type.e = kb38end_save
        THEN
            BEGIN
            i2.mapC2_sp00 [1] := trace.buf [7];
            i2.mapC2_sp00 [2] := trace.buf [8];
            IF  i2.mapInt_sp00 <> 0
            THEN
                g17sname_to_line (' ***        ', ln_len, ln);
            (*ENDIF*) 
            ln_len := ln_len + 1;
            g17basis_err_to_line (i2.mapInt_sp00, ln_len, ln)
            END
        (*ENDIF*) 
        END;
    kb38blocksize:
        BEGIN
        g17sname_to_line ('blocksize   ', ln_len, ln);
        ln_len        := ln_len + 1;
        i2.mapC2_sp00 [1] := trace.buf [2];
        i2.mapC2_sp00 [2] := trace.buf [3];
        g17trimint4_to_line (i2.mapInt_sp00, ln_len, ln)
        END;
    kb38que_state:
        BEGIN
        g17nameto_line ('*** queue error:  ', ln_len, ln);
        ln_len := ln_len + 1;
        IF  trace.buf [2] = chr (1)
        THEN
            n := 'in <> out   '
        ELSE
            IF  trace.buf [2] = chr (2)
            THEN
                n := 'not all free'
            ELSE
                IF  trace.buf [2] = chr (3)
                THEN
                    n := 'task running'
                ELSE
                    n := 'FBM error   ';
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        g17sname_to_line (n, ln_len, ln)
        END;
    kb38rte_errtext:
        BEGIN
        SAPDB_PascalForcedMove (sizeof (trace.buf), sizeof (n),
              @trace.buf, 4, @n, 1, sizeof (n));
        g17sname_to_line (n, ln_len, ln);
        g17sname_to_line (': ***       ', ln_len, ln);
        ln_len := ln_len + 1;
        i2.mapC2_sp00 [1] := trace.buf [2];
        i2.mapC2_sp00 [2] := trace.buf [3];
        g17basis_err_to_line (i2.mapInt_sp00, ln_len, ln);
        len := sizeof (tsp00_ErrText);
        moveobj_ptr := @trace.buf;
        WHILE (moveobj_ptr^ [3 + sizeof (n) +  len] = ' ') AND
              (len > 0) DO
            len := len - 1;
        (*ENDWHILE*) 
        IF  len > 0
        THEN
            BEGIN
            ln [ln_len+1] := ',';
            SAPDB_PascalForcedMove (sizeof (moveobj_ptr^), sizeof (ln),
                  @moveobj_ptr^, 4 + sizeof (n), @ln, ln_len+3, len);
            ln_len := ln_len + 2 + len
            END
        (*ENDIF*) 
        END;
    kb38hm_wait:
        BEGIN
        g17sname_to_line ('wait No.    ', ln_len, ln);
        i2.mapC2_sp00 [1] := trace.buf [2];
        i2.mapC2_sp00 [2] := trace.buf [3];
        g17trimint4_to_line (i2.mapInt_sp00, ln_len, ln)
        END;
    OTHERWISE ;
    END
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02scan_headline (
            VAR term        : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            VAR f           : tut_file;
            to_entry_pno    : tsp00_Int4;
            to_entry_pos    : tsp00_Int4);
 
VAR
      dummy_err   : integer;
      i           : integer;
      ln_len      : integer;
      ln          : tsp00_Line;
      to_file_pos : tut_file_pos;
 
BEGIN
t12write_prot (protfile, term.blankline, 1, dummy_err);
t09put (term, term.blankline, cut_protected);
ln     := term.blankline;
ln_len := 10;
FOR i := 1 TO ln_len DO
    ln [i] := '-';
(*ENDFOR*) 
IF  (f.utf_entry_pno <> to_entry_pno) OR
    (f.utf_entry_pos <> to_entry_pos)
THEN
    g17sname_to_line (' from       ', ln_len, ln);
(*ENDIF*) 
g17sname_to_line (' entry      ', ln_len, ln);
ln_len := ln_len + 1;
g17trimint4_to_line (f.utf_entry_pno, ln_len, ln);
ln_len      := ln_len + 1;
ln [ln_len] := '.';
(* PTS 1000369 JA 1997-12-09 *)
g17trimint4_to_line (f.utf_entry_pos + OFFSET_FIRST_ENTRY, ln_len, ln);
IF  (f.utf_entry_pno <> to_entry_pno) OR
    (f.utf_entry_pos <> to_entry_pos)
THEN
    BEGIN
    g17sname_to_line (' to         ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (to_entry_pno, ln_len, ln);
    ln_len      := ln_len + 1;
    ln [ln_len] := '.';
    (* PTS 1000369 JA 1997-12-09 *)
    g17trimint4_to_line (to_entry_pos + OFFSET_FIRST_ENTRY, ln_len, ln)
    END;
(*ENDIF*) 
IF  (f.utf_entry_pno <> to_entry_pno) OR
    (f.utf_entry_pos <> to_entry_pos)
THEN
    g17nameto_line (' (from page       ', ln_len, ln)
ELSE
    g17nameto_line (' (page            ', ln_len, ln);
(*ENDIF*) 
ln_len := ln_len + 1;
g17trimint4_to_line (f.utf_pos.utfp_block_no, ln_len, ln);
IF  f.utf_pos.utfp_pages_per_block > 1
THEN
    BEGIN
    ln_len      := ln_len + 1;
    ln [ln_len] := '/';
    g17trimint4_to_line (f.utf_pos.utfp_page_no, ln_len, ln)
    END;
(*ENDIF*) 
IF  (f.utf_entry_pno <> to_entry_pno) OR
    (f.utf_entry_pos <> to_entry_pos)
THEN
    BEGIN
    x05get_file_pos (f, to_entry_pno, to_file_pos);
    g17sname_to_line (' to         ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (to_file_pos.utfp_block_no, ln_len, ln);
    IF  f.utf_pos.utfp_pages_per_block > 1
    THEN
        BEGIN
        ln_len      := ln_len + 1;
        ln [ln_len] := '/';
        g17trimint4_to_line (to_file_pos.utfp_page_no, ln_len, ln)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
ln_len      := ln_len + 1;
ln [ln_len] := ')';
FOR i := ln_len + 2 TO PROT_LINESIZE DO
    ln [i] := '-';
(*ENDFOR*) 
t12write_prot (protfile, ln, PROT_LINESIZE, dummy_err);
t09put (term, ln, cut_protected)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02scan_vtrace (
            VAR d            : t_DisplState;
            VAR f            : tut_file;
            cmd_token        : tsp00_Name;
            term_wanted      : boolean;
            select_trace     : boolean;
            VAR wanted_trace : tgg11_VtraceHeader;
            start_pno        : tsp00_Int4;
            start_pos        : tsp00_Int4;
            stop_pno         : tsp00_Int4;
            stop_pos         : tsp00_Int4;
            VAR pfkey        : tut_pfkey);
 
VAR
      alloc_ok         : boolean;
      ak_wanted        : boolean;
      bd_wanted        : boolean;
      ed_wanted        : boolean;
      found            : boolean;
      kb_wanted        : boolean;
      mess_wanted      : boolean;
      print_info       : boolean;
      print_longinfo   : boolean;
      strat_wanted     : boolean;
      td_wanted        : boolean;
      time_wanted      : boolean;
      entry_pos_wanted : boolean;
      read_err         : tsp00_VfReturn;
      i                : integer;
      ln_cnt_per_task  : integer; (* PTS 1000369 JA 1997-12-09 *)
      dummy_micsec     : tsp00_Int4;
      msg_time         : tsp00_Int4;
      last_displ       : tsp00_Int4;
      aux_ptr          : t_aux_ptr;
      n                : tsp00_Name;
      data_alloc_ok    : ARRAY [1..MAX_PACKETS] OF boolean;
      strat_alloc_ok   : ARRAY [1..MAX_PACKETS] OF boolean;
      buf_f            : ARRAY [1..MAX_PACKETS] OF tut_file;
      packet_pos_arr   : ARRAY [1..MAX_PACKETS] OF tsp00_Int4;
      packet_size_arr  : ARRAY [1..MAX_PACKETS] OF tsp00_Int4;
      target_len_arr   : ARRAY [1..MAX_PACKETS] OF tsp00_Int4;
      trace_count      : ARRAY [1..MAX_PACKETS] OF tsp00_Int2;
      old_trace        : tgg11_VtraceHeader;
      trace            : trace_record;
      stack_arr        : ARRAY [1..MAX_PACKETS] OF tgg00_StackList;
      qual_arr         : ARRAY [1..MAX_PACKETS] OF tgg00_QualBuf;
      buf_trace        : ARRAY [1..MAX_PACKETS] OF trace_record;
      packet_ptr_arr   : ARRAY [1..MAX_PACKETS] OF tsp00_MoveObjPtr;
      moveobj_ptr      : tsp00_MoveObjPtr;
      help_trace       : trace_record;
      help_segm_head   : tsp1_segment_header;
      help_packet_head : tsp1_packet_header;
 
BEGIN
pfkey           := pf_none;
read_err        := vf_ok;
ln_cnt_per_task := 0; (* PTS 1000369 JA 1997-12-09 *)
FOR i := 1 TO MAX_PACKETS DO
    BEGIN
    packet_ptr_arr  [i] := NIL;
    packet_size_arr [i] := 0;
    data_alloc_ok   [i] := false;
    strat_alloc_ok  [i] := false;
    trace_count     [i] := 0;
    WITH buf_trace [i] DO
        BEGIN
        trceHead.vhTask_gg11       := cgg_nil_pid;
        mbl_xt_mtrail.mb_data      := NIL;
        mbl_xt_mtrail.mb_data_size := 0;
        mbl_xt_mtrail.mb_strat     := NIL;
        mbl_xt_mtrail.mb_strat_size:= 0;
        END
    (*ENDWITH*) 
    END;
(*ENDFOR*) 
t09frame  (d.dsTerm^, true);
t09pfkeys (d.dsTerm^, true);
ak_wanted        := false;
bd_wanted        := false;
ed_wanted        := false;
kb_wanted        := false;
mess_wanted      := false;
strat_wanted     := false;
td_wanted        := false;
time_wanted      := false;
entry_pos_wanted := true;
IF  cmd_token <> bsp_name
THEN
    n := cmd_token
ELSE
    BEGIN
    t09put20 (d.dsTerm^, 'A = AK vtrace       ', cut_protected);
    t09put20 (d.dsTerm^, 'B = BD vtrace       ', cut_protected);
    t09put20 (d.dsTerm^, 'K = KB vtrace       ', cut_protected);
    t09put20 (d.dsTerm^, 'M = Message buffer  ', cut_protected);
    t09put20 (d.dsTerm^, 'N = Net vtrace      ', cut_protected);
    t09put20 (d.dsTerm^, 'S = Strategy        ', cut_protected);
    t09put20 (d.dsTerm^, 'T = Time vtrace     ', cut_protected);
    t09put20 (d.dsTerm^, 'X = SWITCH output   ', cut_protected);
    t09put20 (d.dsTerm^, 'E = No entry pos    ', cut_protected);
    t09put   (d.dsTerm^, d.dsTerm^.blankline, cut_protected);
    n := 'abkn              ';
    t09get1name (d.dsTerm^, '        SELECT CHAR:', cut_bright_protected,
          cut_unprotected, NAME_MXSP00, true, n, pfkey)
    END;
(*ENDIF*) 
IF  (pfkey = pf_none) AND (n = bsp_name)
THEN
    pfkey := pf_end;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    FOR i := 1 TO NAME_MXSP00 DO
        IF  n [i] <> ' '
        THEN
            CASE n [i] OF
                'a', 'A':
                    ak_wanted        := true;
                'b', 'B':
                    bd_wanted        := true;
                'k', 'K':
                    kb_wanted        := true;
                'm', 'M':
                    mess_wanted      := true;
                'p', 'P':
                    ed_wanted        := true;
                's', 'S':
                    strat_wanted     := true;
                't', 'T':
                    time_wanted      := true;
                'x', 'X':
                    td_wanted        := true;
                'e', 'E':
                    entry_pos_wanted := false;
                OTHERWISE
                    td_wanted        := td_wanted;
                END
            (*ENDCASE*) 
        (*ENDIF*) 
    (*ENDFOR*) 
    END;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    old_trace.vhTask_gg11  := cgg_nil_pid;
    gg06SetNilSession (old_trace.vhSession_gg11);
    gg06SetNilTrans   (old_trace.vhTrans_gg11);
    IF  NOT term_wanted AND (cmd_token = bsp_name)
    THEN
        BEGIN
        x05display_msg (d.dsTerm^, 'CREATING OUTPUT     ', NOT c_warning, c_immediate_displ);
        IF  NOT d.dsTerm^.is_batch
        THEN
            t09display (d.dsTerm^, NOT c_on)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    t09newscreen_page (d.dsTerm^);
    moveobj_ptr := @trace.vtrace_entry;
    x05direct_entry (d.dsTerm^, f, ptVtrace_egg00, start_pno, start_pos,
          moveobj_ptr, sizeof (trace.vtrace_entry), read_err);
    IF  read_err = vf_ok
    THEN
        xt02scan_headline (d.dsTerm^, d.dsProt^, f, stop_pno, stop_pos);
    (*ENDIF*) 
    last_displ := 0;
    sqlclock (msg_time, dummy_micsec);
    WHILE (read_err = vf_ok)
          AND NOT d.dsTerm^.is_reset_called AND (pfkey = pf_none) DO
        BEGIN
        IF  (f.utf_pos.utfp_block_no MOD 10) = 0
        THEN
            BEGIN
            xt02scanned_msg (d.dsTerm^, f.utf_pos.utfp_block_no, msg_time, last_displ);
            IF  NOT term_wanted AND NOT d.dsTerm^.is_batch
            THEN
                t09display (d.dsTerm^, NOT c_on)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        FOR i := 1 TO MAX_PACKETS DO
            IF  trace_count [i] <> 0
            THEN
                BEGIN
                trace_count [i] := succ(trace_count[i]);
                IF  trace_count[i] > FLUSH_INTERVAL
                THEN
                    BEGIN
                    IF  (mess_wanted AND
                        (buf_trace [i].trceHead.vhLayer_gg11 = ak_messbuf))
                        OR
                        (ak_wanted AND (buf_trace [i].trceHead.vhLayer_gg11 in
                        [ak_sqlpacket, ak_packet_segm]))
                    THEN
                        xt02print_info (d, buf_f [i], kb_wanted, entry_pos_wanted,
                              buf_trace [i], old_trace, ln_cnt_per_task);
                    (*ENDIF*) 
                    buf_trace [i].trceHead.vhTask_gg11 := cgg_nil_pid;
                    trace_count[i] := 0;
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDFOR*) 
        i := 1;
        found := false;
        WHILE NOT found AND (i <= MAX_PACKETS) DO
            IF  buf_trace [i].trceHead.vhTask_gg11 = trace.trceHead.vhTask_gg11
            THEN
                found := true
            ELSE
                i := i + 1;
            (*ENDIF*) 
        (*ENDWHILE*) 
        IF  found
            AND
            ((trace.trceHead.vhLayer_gg11 <> bd_oflw) OR
            ( trace.longinfo_cnt = 1)) (* PTS 1000369 JA 1997-12-09 *)
        THEN
            BEGIN
            IF  (mess_wanted AND
                (buf_trace [i].trceHead.vhLayer_gg11 = ak_messbuf))
                OR
                (ak_wanted AND (buf_trace [i].trceHead.vhLayer_gg11 in
                [ak_sqlpacket, ak_packet_segm]))
            THEN
                xt02print_info (d, buf_f [i], kb_wanted, entry_pos_wanted,
                      buf_trace [i], old_trace, ln_cnt_per_task);
            (*ENDIF*) 
            buf_trace [i].trceHead.vhTask_gg11 := cgg_nil_pid;
            trace_count[i] := 0;
            END;
        (*ENDIF*) 
        print_info     := false;
        print_longinfo := false;
        IF  NOT select_trace
            OR
            (wanted_trace.vhTask_gg11 = trace.trceHead.vhTask_gg11)
        THEN
            CASE trace.trceHead.vhLayer_gg11 OF
                ak_receive_error,
                ak_sqlpacket,
                ak_packet_head,
                ak_packet_segm,
                ak_packet_part,
                ak_join,
                ak_sem:
                    print_info := ak_wanted;
                ak_strat:
                    print_info := strat_wanted;
                bd:
                    print_info := bd_wanted;
                bd_oflw:
                    print_longinfo := true;
                ed:
                    print_info := ed_wanted;
                gg:
                    print_info := (trace.trceHead.vhType_gg11 = gg_opmsg);
                gg_time:
                    print_info := time_wanted;
                kb:
                    IF  trace.trceHead.vhType_gg11 in [
                        vttKbEmergencyShutdown_egg00,
                        vttKbQuickShutdown_egg00,
                        vttKbShutdown_egg00]
                    THEN
                        BEGIN
                        xt02print_trace_id(d.dsTerm^, d.dsProt^, true,
                              entry_pos_wanted, f, trace,
                              old_trace, ln_cnt_per_task);
                        xt02print_shutdown (d.dsTerm^, d.dsProt^, trace)
                        END
                    ELSE
                        print_info := kb_wanted;
                    (*ENDIF*) 
                kb_qual:
                    print_info := time_wanted;
                ta:
                    print_info := td_wanted;
                td_always:
                    ; (* vtrace command ==> filler *)
                ut:
                    (* opmsg *)
                    print_info := true;
                OTHERWISE
                    IF  td_wanted OR kb_wanted
                    THEN
                        BEGIN
                        xt02print_trace_id(d.dsTerm^, d.dsProt^, true,
                              entry_pos_wanted, f, trace, old_trace,
                              ln_cnt_per_task);
                        xt02print_unknown (d, trace)
                        END
                    (*ENDIF*) 
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        IF  print_info
        THEN
            xt02print_info (d, f, kb_wanted, entry_pos_wanted,
                  trace, old_trace, ln_cnt_per_task);
        (*ENDIF*) 
        IF  print_longinfo
        THEN
            BEGIN
            IF  trace.longinfo_cnt = 1 (* PTS 1000369 JA 1997-12-09 *)
            THEN
                BEGIN
                i := 1;
                found := false;
                WHILE NOT found AND (i <= MAX_PACKETS) DO
                    IF  buf_trace [i].trceHead.vhTask_gg11 = cgg_nil_pid
                    THEN
                        found := true
                    ELSE
                        i := i + 1;
                    (*ENDIF*) 
                (*ENDWHILE*) 
                IF  i > MAX_PACKETS
                THEN
                    BEGIN
                    xt02print_trace_id (d.dsTerm^, d.dsProt^,
                          kb_wanted, entry_pos_wanted,
                          f, trace, old_trace, ln_cnt_per_task);
                    x05print_msg (d.dsTerm^, d.dsProt^,
                          'TOO MANY PACKETS    ');
                    xt02print_unknown (d, trace)
                    END
                ELSE
                    BEGIN
                    trace_count [i] := 1;
                    buf_f [i] := f;
                    WITH buf_trace[i].trceHead DO
                        BEGIN
                        (* PTS 1000369 JA 1997-12-09 *)
                        vhLen_gg11     := trace.trceHead.vhLen_gg11
                              -    sizeof (trace.longinfo_cnt)
                              -    sizeof (trace.longinfo_layer);
                        vhType_gg11    := trace.trceHead.vhType_gg11;
                        vhTask_gg11    := trace.trceHead.vhTask_gg11;
                        vhSession_gg11 := trace.trceHead.vhSession_gg11;
                        vhTrans_gg11   := trace.trceHead.vhTrans_gg11;
                        vhLayer_gg11   := trace.longinfo_layer
                        END;
                    (*ENDWITH*) 
                    IF  trace.trceHead.vhLen_gg11
                        - sizeof (tgg11_VtraceHeader)
                        - sizeof (trace.longinfo_cnt)
                        - sizeof (trace.longinfo_layer) > 0
                        (* PTS 1000369 JA 1997-12-09 *)
                    THEN
                        CASE buf_trace [i].trceHead.vhLayer_gg11 OF
                            ak_messbuf:
                                BEGIN
                                WITH buf_trace [i] DO
                                    BEGIN
                                    trceHead.vhLen_gg11 := 0;
                                    mbl_qual_pos        := 1;
                                    mbl_data_pos        := 1;
                                    mbl_stack_pos       := 1;
                                    mbl_strat_pos       := 1;
                                    mbl_trans_pos       := 1;
                                    END;
                                (*ENDWITH*) 
                                target_len_arr [i] := 0;
                                xt02mblock_handling (trace,
                                      buf_trace      [i],
                                      target_len_arr [i],
                                      qual_arr       [i],
                                      stack_arr      [i],
                                      data_alloc_ok  [i],
                                      strat_alloc_ok [i]);
                                IF  NOT ( data_alloc_ok [i] AND strat_alloc_ok [i])
                                THEN
                                    BEGIN
                                    xt02print_trace_id (d.dsTerm^, d.dsProt^,
                                          kb_wanted,
                                          entry_pos_wanted,
                                          f, trace, old_trace,
                                          ln_cnt_per_task);
                                    (* PTS 1105306 E.Z. *)
                                    x05print_msg (d.dsTerm^, d.dsProt^, 'MALLOC ERROR1in xt02')
                                    END;
                                (*ENDIF*) 
                                END;
                            ak_sqlpacket :
                                BEGIN
                                xt02allocat_packet (trace,
                                      packet_ptr_arr  [i],
                                      packet_size_arr [i], alloc_ok);
                                IF  NOT alloc_ok
                                THEN
                                    BEGIN
                                    xt02print_trace_id (d.dsTerm^,
                                          d.dsProt^,
                                          kb_wanted,
                                          entry_pos_wanted,
                                          f, trace, old_trace,
                                          ln_cnt_per_task);
                                    (* PTS 1105306 E.Z. *)
                                    x05print_msg (d.dsTerm^, d.dsProt^, 'MALLOC ERROR2in xt02')
                                    END;
                                (*ENDIF*) 
                                buf_trace [i].trceHead.vhLen_gg11 := 0;
                                packet_pos_arr [i] := 1;
                                IF  packet_ptr_arr [i] <> NIL
                                THEN
                                    xt02packet_handling (trace,
                                          buf_trace       [i],
                                          packet_ptr_arr  [i]^,
                                          packet_size_arr [i],
                                          packet_pos_arr  [i]);
                                (*ENDIF*) 
                                END;
                            ak_packet_segm :
                                BEGIN
                                buf_trace [i].trceHead.vhLayer_gg11 := ak_sqlpacket;
                                help_trace := trace;
                                SAPDB_PascalForcedMove (sizeof(trace), sizeof(help_segm_head),
                                      @trace.buf, sizeof (trace.longinfo_cnt)
                                      + sizeof (trace.longinfo_layer) + 1,
                                      @help_segm_head, 1, sizeof (help_segm_head));
                                WITH help_packet_head DO
                                    BEGIN
                                    sp1h_mess_code    := csp_codeneutral;
                                    sp1h_mess_swap    := sw_dummy;
                                    sp1h_filler1      := 0;
                                    sp1h_appl_version := 'DIAGN';
                                    sp1h_application  := 'OSE';
                                    sp1h_varpart_len  := sizeof(help_trace.packet_head) + sizeof(trace.segm_head) +
                                          help_segm_head.sp1s_segm_len;
                                    sp1h_varpart_size := sp1h_varpart_len;
                                    sp1h_filler2      := 0;
                                    sp1h_no_of_segm   := 1;
                                    sp1h_filler3      := '        ';
                                    END;
                                (*ENDWITH*) 
                                SAPDB_PascalForcedMove (sizeof (help_packet_head), sizeof (help_trace),
                                      @help_packet_head, 1, @help_trace.buf,
                                      sizeof (help_trace.longinfo_cnt)
                                      + sizeof (help_trace.longinfo_layer) + 1,
                                      sizeof (help_packet_head));
                                help_trace.trceHead.vhLen_gg11 :=
                                      sizeof (tgg11_VtraceHeader)
                                      + sizeof (help_trace.longinfo_cnt  )
                                      + sizeof (help_trace.longinfo_layer)
                                      + sizeof (help_packet_head);
                                xt02allocat_packet (help_trace,
                                      packet_ptr_arr  [i],
                                      packet_size_arr [i], alloc_ok);
                                IF  NOT alloc_ok
                                THEN
                                    BEGIN
                                    xt02print_trace_id (d.dsTerm^,
                                          d.dsProt^,
                                          kb_wanted,
                                          entry_pos_wanted,
                                          f, trace, old_trace,
                                          ln_cnt_per_task);
                                    (* PTS 1105306 E.Z. *)
                                    x05print_msg (d.dsTerm^, d.dsProt^, 'MALLOC ERROR2in xt02')
                                    END;
                                (*ENDIF*) 
                                buf_trace [i].trceHead.vhLen_gg11 := 0;
                                packet_pos_arr [i] := 1;
                                IF  packet_ptr_arr [i] <> NIL
                                THEN
                                    BEGIN
                                    xt02packet_handling (help_trace,
                                          buf_trace       [i],
                                          packet_ptr_arr  [i]^,
                                          packet_size_arr [i],
                                          packet_pos_arr  [i]);
                                    xt02packet_handling (trace,
                                          buf_trace       [i],
                                          packet_ptr_arr  [i]^,
                                          packet_size_arr [i],
                                          packet_pos_arr  [i]);
                                    END
                                (*ENDIF*) 
                                END;
                            OTHERWISE
                                BEGIN
                                moveobj_ptr := @buf_trace [i].buf;
                                (* PTS 1000369 JA 1997-12-09 *)
                                SAPDB_PascalForcedMove (sizeof (trace.buf), sizeof (buf_trace [i].buf),
                                      @trace.buf,
                                      sizeof (trace.longinfo_cnt) + sizeof (trace.longinfo_layer) + 1,
                                      @moveobj_ptr^, 1,
                                      trace.trceHead.vhLen_gg11 - sizeof (tgg11_VtraceHeader)
                                      - sizeof (trace.longinfo_cnt)
                                      - sizeof (trace.longinfo_layer))
                                END
                            END
                        (*ENDCASE*) 
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                i     := 1;
                found := false;
                WHILE NOT found AND (i <= MAX_PACKETS) DO
                    IF  buf_trace [i].trceHead.vhTask_gg11 = trace.trceHead.vhTask_gg11
                    THEN
                        found := true
                    ELSE
                        i := i + 1;
                    (*ENDIF*) 
                (*ENDWHILE*) 
                IF  found
                THEN
                    BEGIN
                    IF  trace.trceHead.vhLen_gg11
                        - sizeof (tgg11_VtraceHeader)
                        - sizeof (trace.longinfo_cnt  )
                        - sizeof (trace.longinfo_layer) > 0
                        (* PTS 1000369 JA 1997-12-09 *)
                    THEN
                        BEGIN
                        CASE  buf_trace [i].trceHead.vhLayer_gg11 OF
                            ak_messbuf:
                                BEGIN
                                IF  ( data_alloc_ok [i] AND strat_alloc_ok [i] )
                                THEN
                                    xt02mblock_handling (trace,
                                          buf_trace      [i],
                                          target_len_arr [i],
                                          qual_arr       [i],
                                          stack_arr      [i],
                                          data_alloc_ok  [i],
                                          strat_alloc_ok [i]);
                                (*ENDIF*) 
                                IF  NOT ( data_alloc_ok [i] AND strat_alloc_ok [i])
                                THEN
                                    BEGIN
                                    xt02print_trace_id (d.dsTerm^, d.dsProt^,
                                          kb_wanted,
                                          entry_pos_wanted,
                                          f, trace, old_trace,
                                          ln_cnt_per_task);
                                    (* PTS 1105306 E.Z. *)
                                    x05print_msg (d.dsTerm^, d.dsProt^, 'MALLOC ERROR3in xt02')
                                    END
                                (*ENDIF*) 
                                END;
                            ak_sqlpacket, ak_packet_segm :
                                IF  packet_ptr_arr [i] <> NIL
                                THEN
                                    xt02packet_handling (trace,
                                          buf_trace       [i],
                                          packet_ptr_arr  [i]^,
                                          packet_size_arr [i],
                                          packet_pos_arr  [i]);
                                (*ENDIF*) 
                            OTHERWISE
                                BEGIN
                                moveobj_ptr := @buf_trace[i].buf;
                                SAPDB_PascalForcedMove (sizeof (trace.buf), sizeof (buf_trace[i].buf),
                                      @trace.buf, 3,
                                      @moveobj_ptr^,
                                      buf_trace [i].trceHead.vhLen_gg11
                                      - sizeof (tgg11_VtraceHeader) + 1,
                                      trace.trceHead.vhLen_gg11 - sizeof (tgg11_VtraceHeader) - 2);
                                buf_trace [i].trceHead.vhLen_gg11 :=
                                      buf_trace [i].trceHead.vhLen_gg11
                                      + trace.trceHead.vhLen_gg11
                                      - sizeof (tgg11_VtraceHeader) - 2
                                END
                            END
                        (*ENDCASE*) 
                        END
                    ELSE
                        BEGIN
                        IF  (mess_wanted AND
                            (buf_trace [i].trceHead.vhLayer_gg11 = ak_messbuf) AND
                            data_alloc_ok [i])
                            OR
                            (ak_wanted AND (buf_trace [i].trceHead.vhLayer_gg11 in
                            [ak_sqlpacket, ak_packet_segm]))
                        THEN
                            xt02print_info (d, buf_f [i], kb_wanted,
                                  entry_pos_wanted, buf_trace [i], old_trace, ln_cnt_per_task);
                        (*ENDIF*) 
                        WITH buf_trace [i].mbl_xt_mtrail DO
                            BEGIN
                            IF  (mb_data <> NIL) AND data_alloc_ok [i]
                            THEN
                                BEGIN
                                aux_ptr.x_data_ptr := mb_data;
                                sqlfree (aux_ptr.x_moveobj_ptr);
                                mb_data      := NIL;
                                mb_data_size := 0;
                                END;
                            (*ENDIF*) 
                            IF  (mb_strat <> NIL) AND strat_alloc_ok [i]
                            THEN
                                BEGIN
                                sqlfree (mb_strat);
                                mb_strat      := NIL;
                                mb_strat_size := 0;
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDWITH*) 
                        IF  packet_ptr_arr [i] <> NIL
                        THEN
                            BEGIN
                            sqlfree (packet_ptr_arr [i]);
                            packet_ptr_arr  [i] := NIL;
                            packet_size_arr [i] := 0
                            END;
                        (*ENDIF*) 
                        buf_trace [i].trceHead.vhTask_gg11 := cgg_nil_pid;
                        trace_count[i] := 0;
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  NOT d.dsTerm^.is_reset_called AND (pfkey = pf_none)
            AND d.dsTerm^.is_display
        THEN
            BEGIN
            IF  t09is_window_full (d.dsTerm^, 5)
            THEN
                BEGIN
                x05holdhexint (d.dsTerm^, pfkey);
                IF  pfkey = pf_none
                THEN
                    t09newscreen_page (d.dsTerm^)
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  NOT d.dsTerm^.is_reset_called AND (pfkey = pf_none)
        THEN
            BEGIN
            IF  (f.utf_entry_pno < stop_pno)
                OR
                ((f.utf_entry_pno = stop_pno) AND
                ( f.utf_entry_pos < stop_pos))
            THEN
                BEGIN
                moveobj_ptr := @trace.vtrace_entry;
                x05next_entry (d.dsTerm^, f, ptVtrace_egg00, moveobj_ptr,
                      sizeof (trace.vtrace_entry), read_err);
                IF  (read_err = vf_ok)
                    AND
                    ((f.utf_entry_pno > stop_pno)
                    OR
                    ((f.utf_entry_pno = stop_pno) AND
                    ( f.utf_entry_pos > stop_pos)))
                THEN
                    read_err := vf_eof
                (*ENDIF*) 
                END
            ELSE
                read_err := vf_eof
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    FOR i := 1 TO MAX_PACKETS DO
        IF  buf_trace [i].trceHead.vhTask_gg11 <> cgg_nil_pid
        THEN
            BEGIN
            IF  (mess_wanted AND
                (buf_trace [i].trceHead.vhLayer_gg11 = ak_messbuf))
                OR
                (ak_wanted AND (buf_trace [i].trceHead.vhLayer_gg11 in
                [ak_sqlpacket, ak_packet_segm]))
            THEN
                xt02print_info (d, buf_f [i], kb_wanted, entry_pos_wanted,
                      buf_trace [i], old_trace, ln_cnt_per_task);
            (*ENDIF*) 
            buf_trace [i].trceHead.vhTask_gg11 := cgg_nil_pid;
            trace_count[i] := 0;
            END;
        (*ENDIF*) 
    (*ENDFOR*) 
    FOR i := 1 TO MAX_PACKETS DO
        BEGIN
        IF  packet_ptr_arr [i] <> NIL
        THEN
            BEGIN
            sqlfree (packet_ptr_arr [i]);
            packet_ptr_arr  [i] := NIL;
            packet_size_arr [i] := 0
            END;
        (*ENDIF*) 
        WITH buf_trace [i].mbl_xt_mtrail DO
            BEGIN
            IF  (mb_data <> NIL) AND data_alloc_ok [i]
            THEN
                BEGIN
                aux_ptr.x_data_ptr := mb_data;
                sqlfree (aux_ptr.x_moveobj_ptr);
                mb_data      := NIL;
                mb_data_size := 0
                END;
            (*ENDIF*) 
            IF  (mb_strat <> NIL) AND strat_alloc_ok [i]
            THEN
                BEGIN
                sqlfree (mb_strat);
                mb_strat      := NIL;
                mb_strat_size := 0
                END
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        END;
    (*ENDFOR*) 
    IF  NOT d.dsTerm^.is_inputfile
    THEN
        d.dsTerm^.is_reset_called := false;
    (*ENDIF*) 
    IF  NOT t09is_empty_window (d.dsTerm^)
    THEN
        x05holdhexint (d.dsTerm^, pfkey)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  NOT d.dsTerm^.is_batch AND (cmd_token = bsp_name)
THEN
    t09display (d.dsTerm^, c_on);
(*ENDIF*) 
IF  pfkey <> pf_cancel
THEN
    pfkey := pf_none
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02scanned_msg (
            VAR term       : tut_terminal;
            line_no        : tsp00_Int4;
            VAR msg_time   : tsp00_Int4;
            VAR last_displ : tsp00_Int4);
 
VAR
      ln_len       : integer;
      curr_time    : tsp00_Int4;
      dummy_micsec : tsp00_Int4;
      ln           : tsp00_Line;
 
BEGIN
sqlclock (curr_time, dummy_micsec);
IF  curr_time - msg_time >= DISPLAY_INTERVAL
THEN
    BEGIN
    msg_time   := curr_time;
    last_displ := line_no;
    ln         := term.blankline;
    ln_len     := 0;
    g17trimint4_to_line (line_no, ln_len, ln);
    ln_len := ln_len + 1;
    g17nameto_line ('blocks scanned    ', ln_len, ln);
    t09display (term, c_on);
    t09putmsg (term, ln, NOT c_warning, c_immediate_displ)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02sess_trans_to_line (
            VAR trace  : trace_record;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
CONST
      NIL_SESSION_BYTE = 255;
 
VAR
      subtr : tgg00_SubtransNo;
      ic2   : tsp_int_map_c2;
 
BEGIN
IF  trace.trceHead.vhSession_gg11.ci4_gg00 [1] = chr(NIL_SESSION_BYTE)
THEN
    gg06SessionToLine (trace.trceHead.vhSession_gg11, ln_len, ln)
ELSE
    BEGIN
    g17sname_to_line ('id          ', ln_len, ln);
    gg06TransToLine  (trace.trceHead.vhTrans_gg11, ln_len, ln);
    ic2.map_c2 [1] := trace.trceHead.vhSession_gg11.ci4_gg00 [3];
    ic2.map_c2 [2] := trace.trceHead.vhSession_gg11.ci4_gg00 [4];
    subtr := ic2.map_int;
    IF  subtr <> 0
    THEN
        (* subtrans to line *)
        BEGIN
        ln_len      := ln_len + 1;
        ln [ln_len] := '/';
        g17trimint4_to_line (subtr, ln_len, ln);
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02special_part_buf (
            VAR d         : t_DisplState;
            part_kind     : tsp1_part_kind;
            arg_count     : tsp00_Int2;
            buf_len       : tsp00_Int4;
            moveobj_ptr   : tsp00_MoveObjPtr;
            VAR displ_buf : boolean);
 
CONST
      cmx_parsid     = 12;
      c_messtype_pos =  9;
      c_p_info_pos   = 11;
 
VAR
      numb_err        : tsp00_NumError;
      err             : integer;
      ln_len, ln2_len : integer;
      len             : integer;
      pos             : integer;
      ln, ln2         : tsp00_Line;
      curr_i          : tsp00_Int2;
      pi_ptr          : ^tsp1_param_info;
      psl_ptr         : ^tsp1_param_spec_list;
      arg_size        : integer;
      ix              : integer;
 
      c1_mtype : RECORD
            CASE boolean OF
                true :
                    (c1    : char);
                false :
                    (mtype : tgg00_MessType);
                END;
            (*ENDCASE*) 
 
 
BEGIN
displ_buf := true;
CASE  part_kind OF
    sp1pk_abap_info:
        BEGIN
        displ_buf := false;
        ln      := d.dsTerm^.blankline;
        ln_len  := PACKET_INDENT;
        g17nameto_line ('name   :          ', ln_len, ln);
        len := ord(moveobj_ptr^[1]);
        FOR ix := 1 TO len DO
            ln [ln_len + ix + 1] := moveobj_ptr^ [1 + ix];
        (*ENDFOR*) 
        ln_len := ln_len + len + 1;
        t12write_prot (d.dsProt^, ln, ln_len, err);
        ln      := d.dsTerm^.blankline;
        ln_len  := PACKET_INDENT;
        g17nameto_line ('linenr :          ', ln_len, ln);
        pos := 2 + len;
        len := ord(moveobj_ptr^[pos]);
        FOR ix := 1 TO len DO
            ln [ln_len + ix + 1] := moveobj_ptr^ [pos + ix];
        (*ENDFOR*) 
        ln_len := ln_len + len + 1;
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected);
        END;
    sp1pk_resultcount:
        IF  buf_len = sizeof (tsp00_ResNum)
        THEN
            BEGIN
            ln      := d.dsTerm^.blankline;
            ln_len  := PACKET_INDENT;
            g17nameto_line ('result_count:     ', ln_len, ln);
            IF  moveobj_ptr^[1] <> csp_defined_byte
            THEN
                BEGIN
                IF  moveobj_ptr^[1] = csp_undef_byte
                THEN
                    g17sname_to_line (' UNDEF      ', ln_len, ln)
                ELSE
                    g17sname_to_line (' NO DEFBYTE ', ln_len, ln);
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                s42gchr (moveobj_ptr^, 2, csp_resnum_deflen, 0,
                      csp_resnum_deflen, ln, ln_len+2, len, numb_err);
                IF  numb_err = num_ok
                THEN
                    ln_len := ln_len + 1 + len
                ELSE
                    FOR ix := 1 TO sizeof (tsp00_ResNum) DO
                        g17hexto_line (moveobj_ptr^[1], ln_len, ln);
                    (*ENDFOR*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            displ_buf := false;
            t12write_prot (d.dsProt^, ln, ln_len, err);
            t09put (d.dsTerm^, ln, cut_protected);
            END;
        (*ENDIF*) 
    sp1pk_shortinfo, sp1pk_output_cols_no_parameter,
    sp1pk_appl_parameter_description, sp1pk_vardata_shortinfo:
        BEGIN
        IF  (part_kind = sp1pk_shortinfo) OR
            (part_kind = sp1pk_output_cols_no_parameter) OR
            (part_kind = sp1pk_vardata_shortinfo)
        THEN
            arg_size := sizeof (tsp1_param_info)
        ELSE (* part_kind = sp1pk_appl_parameter_description *)
            BEGIN
            psl_ptr  := @moveobj_ptr^[1];
            arg_size := sizeof (tsp1_param_spec)
            END;
        (*ENDIF*) 
        curr_i := 1;
        WHILE curr_i <= arg_count DO
            BEGIN
            ln := d.dsTerm^.blankline;
            g17int4to_line (curr_i, NOT c_with_zero, 3, PACKET_INDENT, ln);
            ln[ PACKET_INDENT+3 ] := '.';
            ln_len := PACKET_INDENT+5;
            IF  curr_i * arg_size <= buf_len
            THEN
                IF  (part_kind = sp1pk_shortinfo) OR
                    (part_kind = sp1pk_output_cols_no_parameter)
                THEN
                    BEGIN
                    pi_ptr := @moveobj_ptr^[1 + (curr_i-1)*arg_size];
                    g17paraminfo_to_line (pi_ptr^, ln_len, ln)
                    END
                ELSE
                    IF  part_kind = sp1pk_vardata_shortinfo
                    THEN
                        BEGIN
                        pi_ptr := @moveobj_ptr^[1 + (curr_i-1)*arg_size];
                        g17varparaminfo_to_line (pi_ptr^, ln_len, ln)
                        END
                    ELSE (* part_kind = sp1pk_appl_parameter_description *)
                        g17paramspec_to_line (psl_ptr^[curr_i].para_type,
                              psl_ptr^[curr_i].para_length,
                              ord (psl_ptr^[curr_i].para_frac), ln_len, ln)
                    (*ENDIF*) 
                (*ENDIF*) 
            ELSE
                BEGIN
                g17sname_to_line ('<continued> ', ln_len, ln);
                curr_i := arg_count (* signal to stop *)
                END;
            (*ENDIF*) 
            t12write_prot (d.dsProt^, ln, ln_len, err);
            t09put (d.dsTerm^, ln, cut_protected);
            curr_i := succ (curr_i)
            END;
        (*ENDWHILE*) 
        displ_buf := false
        END;
    sp1pk_parsid, sp1pk_parsid_of_select:
        IF  buf_len = cmx_parsid
        THEN
            BEGIN
            ln     := d.dsTerm^.blankline;
            ln_len := PACKET_INDENT;
            IF  ord (moveobj_ptr^[c_p_info_pos]) <> csp1_p_none
            THEN
                BEGIN
                g17parsidinfo_to_line (moveobj_ptr^[c_p_info_pos],
                      ln_len, ln);
                ln [ln_len+1] := ',';
                ln_len        := ln_len+2
                END;
            (*ENDIF*) 
            g17sname_to_line ('mess_type:  ', ln_len, ln);
            ln_len      := succ (ln_len);
            c1_mtype.c1 := moveobj_ptr^[c_messtype_pos];
            IF  (ord (c1_mtype.c1) >= ord (m_nil)) AND
                (ord (c1_mtype.c1) <= ord (m_autosave))
            THEN
                g17messtype_to_line (c1_mtype.mtype, ln_len, ln)
            ELSE
                g17hexto_line (c1_mtype.c1, ln_len, ln);
            (*ENDIF*) 
            t12write_prot (d.dsProt^, ln, ln_len, err);
            t09put (d.dsTerm^, ln, cut_protected)
            END;
        (* PTS 1111575 E.Z. *)
        (*ENDIF*) 
    OTHERWISE;
    END
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xaddr (
            VAR term      : tut_terminal;
            VAR protfile  : tut_vf_fileref;
            nam           : tsp00_Sname;
            is_nil        : boolean;
            addr_space    : tsp00_C8);
 
VAR
      err    : integer;
      i      : integer;
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
xt02xline_init (term, nam, ln_len, ln);
ln_len := ln_len + 1;
IF  is_nil
THEN
    g17sname_to_line ('nil         ', ln_len, ln)
ELSE
    FOR i := 1 TO sizeof (tsp00_Addr) DO
        g17hexto_line (addr_space [i], ln_len, ln);
    (*ENDFOR*) 
(*ENDIF*) 
t12write_prot (protfile, ln, ln_len, err);
t09put (term, ln, cut_protected)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xcounter (
            VAR term      : tut_terminal;
            VAR protfile  : tut_vf_fileref;
            nam           : tsp00_Sname;
            cnt           : tsp00_8ByteCounter);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
(* PTS 1103743 JA 1999-08-25*)
xt02xline_init (term, nam, ln_len, ln);
g17counter_to_line (cnt, ln_len, ln);
xt02xwrite_line (term, protfile, ln)
END;
 
(*------------------------------*) 
 
PROCEDURE (* PTS 1112689 *)
      xt02xbool (
            VAR term      : tut_terminal;
            VAR protfile  : tut_vf_fileref;
            nam           : tsp00_Sname;
            bool          : boolean);
 
CONST
      mx_number   = 11;
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
xt02xline_init (term, nam, ln_len, ln);
IF  bool
THEN
    g17sname_to_line (' true       ', ln_len, ln)
ELSE
    g17sname_to_line (' false      ', ln_len, ln);
(*ENDIF*) 
xt02xwrite_line (term, protfile, ln)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xint4 (
            VAR term      : tut_terminal;
            VAR protfile  : tut_vf_fileref;
            nam           : tsp00_Sname;
            int           : tsp00_Int4);
 
CONST
      mx_number   = 11;
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
xt02xline_init (term, nam, ln_len, ln);
IF  int = NIL_PAGE_NO_GG00
THEN
    g17sname_to_line (' NIL_PNO    ', ln_len, ln)
ELSE
    g17int4to_line (int, NOT c_with_zero, mx_number, ln_len + 1, ln);
(*ENDIF*) 
xt02xwrite_line (term, protfile, ln)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xsname (
            VAR term      : tut_terminal;
            VAR protfile  : tut_vf_fileref;
            nam           : tsp00_Sname);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
ln := term.blankline;
ln_len := 0;
g17sname_to_line (nam, ln_len, ln);
xt02xwrite_line (term, protfile, ln);
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xname (
            VAR term      : tut_terminal;
            VAR protfile  : tut_vf_fileref;
            nam           : tsp00_Name);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
ln := term.blankline;
ln_len := 0;
g17nameto_line (nam, ln_len, ln);
xt02xwrite_line (term, protfile, ln);
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xmessblock (
            VAR d           : t_DisplState;
            nam             : tsp00_Sname;
            VAR trace       : trace_record);
 
VAR
      dummy_pfkey : tut_pfkey;
      dummy_pos   : tsp00_Int4;
      scan        : tut_diag_scan;
      err         : integer;
      ln_len      : integer;
      strat_len   : tsp00_Int2;
      i           : integer;
      displ_upb   : tsp00_Int4;
      moveobj_ptr : tsp00_MoveObjPtr;
      n           : tsp00_Name;
      ln          : tsp00_Line;
      strat       : tgg07_StrategyInfo;
      getrec      : tgg07_get_param;
 
      univ_addr : RECORD
            CASE integer OF
                1:
                    (addr_space     : tsp00_C8);
                2:
                    (rte_com        : tsp00_RteCommAddr;
                    rte_com_space   : tsp00_Int4);
                3:
                    (bd_tcache      : tgg00_TempDataCachePtr;
                    bd_tcache_space : tsp00_Int4);
                4:
                    (moveobj        : tsp00_MoveObjPtr;
                    moveobj_space   : tsp00_Int4);
                END;
            (*ENDCASE*) 
 
 
BEGIN
WITH trace.mblock.mb_header DO
    BEGIN
    xt02xline_init (d.dsTerm^, nam, ln_len, ln);
    ln_len      := ln_len + 1;
    gg06TransToLine (trace.mbl_trans.trTransId_gg00, ln_len, ln);
    ln_len := ln_len + 2;
    g17messtype_to_line (mb_type, ln_len, ln);
    IF  mb_type2 <> mm_nil
    THEN
        BEGIN
        ln_len := ln_len + 1;
        g17mess2type_to_line (mb_type2, ln_len, ln);
        END;
    (*ENDIF*) 
    t12write_prot (d.dsProt^, ln, ln_len, err);
    t09put (d.dsTerm^, ln, cut_bright_protected);
    CASE mb_struct OF
        mbs_nil:
            n := 'mbs_nil           ';
        mbs_buf:
            n := 'mbs_buf           ';
        mbs_double_buf:
            n := 'mbs_double_buf    ';
        mbs_save_restore:
            n := 'mbs_save_restore  ';
        mbs_link:
            n := 'mbs_link          ';
        mbs_lock:
            n := 'mbs_lock          ';
        mbs_result:
            n := 'mbs_result        ';
        mbs_stack_addr:
            n := 'mbs_stack_addr    ';
        mbs_stat_info:
            n := 'mbs_stat_info     ';
        mbs_tree_id:
            n := 'mbs_tree_id       ';
        mbs_util:
            n := 'mbs_util          ';
        mbs_long:
            n := 'mbs_long          ';
        OTHERWISE
            BEGIN
            n := bsp_name;
            xt02xint4 (d.dsTerm^, d.dsProt^, 'mb_struct   ', ord(mb_struct))
            END
        END;
    (*ENDCASE*) 
    IF  n <> bsp_name
    THEN
        xt02xname1 (d.dsTerm^, d.dsProt^, 'mb_struct   ', n);
    (*ENDIF*) 
    t09put (d.dsTerm^, ln, cut_protected);
    xt02xline_init (d.dsTerm^, 'mb_reply    ', ln_len, ln);
    ln_len := ln_len + 1;
    IF  ord (mb_reply) = 0
    THEN
        g17sname_to_line ('false       ', ln_len, ln)
    ELSE
        IF  ord (mb_reply) = 1
        THEN
            g17sname_to_line ('true        ', ln_len, ln)
        ELSE
            g17trimint4_to_line (ord (mb_reply), ln_len, ln);
        (*ENDIF*) 
    (*ENDIF*) 
    t12write_prot (d.dsProt^, ln, ln_len, err);
    t09put (d.dsTerm^, ln, cut_protected);
    END;
(*ENDWITH*) 
WITH trace.mbl_trans DO
    BEGIN
    xt02xp2int4     (d.dsTerm^, d.dsProt^, 'trTaskId    ', trTaskId_gg00
          ,                      'trIndex     ', trIndex_gg00);
    xt02xint4       (d.dsTerm^, d.dsProt^, 'trChild     ', trChild_gg00);
    xt02xline_init  (d.dsTerm^,       'trState     ',           ln_len, ln);
    g17trans_state_to_line(                      trState_gg00, ln_len, ln);
    t12write_prot (d.dsProt^, ln, ln_len, err);
    t09put (d.dsTerm^, ln, cut_protected);
    xt02xwarningset (d.dsTerm^, d.dsProt^, 'trWarning   ', trWarning_gg00);
    xt02xint4       (d.dsTerm^, d.dsProt^, 'trSessAuxCnt', trSessionAuxCounter_gg00);
    xt02xint4       (d.dsTerm^, d.dsProt^, 'trTempCount ', trTempCount_gg00);
    (* PTS 1103743 JA 1999-08-25*)
    xt02xcounter    (d.dsTerm^, d.dsProt^, 'trIoCount   ', trIoCount_gg00);
    univ_addr.rte_com       :=  trRteCommPtr_gg00;
    univ_addr.rte_com_space := 0;
    xt02xaddr (d.dsTerm^, d.dsProt^, 'trRteCommPtr', trRteCommPtr_gg00  = NIL, univ_addr.addr_space);
    univ_addr.bd_tcache       :=  trBdTcachePtr_gg00;
    univ_addr.bd_tcache_space := 0;
    xt02xaddr (d.dsTerm^, d.dsProt^, 'trBdTcachPtr', trBdTcachePtr_gg00 = NIL, univ_addr.addr_space)
    END;
(*ENDWITH*) 
xt02xp2int4   (d.dsTerm^, d.dsProt^, 'mb_qual_len ', trace.mblock.mb_qual_len
      ,                    'mb_data_len ', trace.mblock.mb_data_len);
xt02xint4       (d.dsTerm^, d.dsProt^, 'mb_strat_len', trace.mblock.mb_strat_len);
IF  trace.mbl_trans.trError_gg00 = e_ok
THEN
    xt02xname1 (d.dsTerm^, d.dsProt^, 'trError     ', 'e_ok              ')
ELSE
    BEGIN
    xt02xline_init (d.dsTerm^, '**** trError', ln_len, ln);
    ln_len := ln_len + 1;
    g17basis_err_to_line (trace.mbl_trans.trError_gg00, ln_len, ln);
    t12write_prot (d.dsProt^, ln, ln_len, err);
    t09put (d.dsTerm^, ln, cut_protected)
    END;
(*ENDIF*) 
WITH trace.mblock DO
    BEGIN
    xt02xp2int4 (d.dsTerm^, d.dsProt^, 'mb_data_size', mb_data_size
          ,                  'mb_st_size  ', mb_st_size);
    xt02xp2int4 (d.dsTerm^, d.dsProt^, 'mb_qual_size', mb_qual_size
          ,                  'mb_st_max   ', mb_st_max);
    xt02xp2int4 (d.dsTerm^, d.dsProt^, 'mb_work_st_m', mb_work_st_max
          ,                  'mb_workbuf_s', mb_workbuf_size);
    xt02xint4   (d.dsTerm^, d.dsProt^, 'mb_strat_siz', mb_strat_size);
    FOR i := 0 TO cgg_valuelistoffset - 1 DO
        BEGIN
        univ_addr.moveobj := mb_fieldlists[i];
        xt02xaddr   (d.dsTerm^, d.dsProt^, 'mb_fieldlist', mb_fieldlists[i] = NIL, univ_addr.addr_space);
        END;
    (*ENDFOR*) 
    xt02xaddr   (d.dsTerm^, d.dsProt^, 'mb_data     ', mb_data        = NIL, mb_ptr_space1);
    xt02xaddr   (d.dsTerm^, d.dsProt^, 'mb_qual     ', mb_qual        = NIL, mb_ptr_space2);
    xt02xaddr   (d.dsTerm^, d.dsProt^, 'mb_strat    ', mb_strat       = NIL, mb_ptr_space2);
    xt02xaddr   (d.dsTerm^, d.dsProt^, 'mb_st       ', mb_st          = NIL, mb_ptr_space3);
    xt02xaddr   (d.dsTerm^, d.dsProt^, 'mb_work_st  ', mb_work_st     = NIL, mb_ptr_space4);
    xt02xaddr   (d.dsTerm^, d.dsProt^, 'mb_workbuf  ', mb_workbuf     = NIL, mb_ptr_space5);
    xt02xaddr   (d.dsTerm^, d.dsProt^, 'mb_next_mblo', mb_next_mblock = NIL, mb_ptr_space6);
    xt02xaddr   (d.dsTerm^, d.dsProt^, 'mb_trns     ', mb_trns        = NIL, mb_ptr_space7);
    END;
(*ENDWITH*) 
IF  d.dsIsMinbuf
THEN
    scan := [utds_minbuf]
ELSE
    scan := [ ];
(*ENDIF*) 
IF  d.dsTerm^.is_display
THEN
    scan := scan + [utds_display];
(*ENDIF*) 
WITH trace, trace.mblock.mb_header DO
    BEGIN
    IF  (mbl_xt_mtrail.mb_qual <> NIL) AND
        (mb_qual_len > 0)
    THEN
        CASE mb_struct OF
            mbs_stack_addr:
                BEGIN
                xt02xtreeid (d.dsTerm^,d.dsProt^, 'treeid      ',
                      mbl_xt_mtrail.mb_qual^.mtree);
                xt02xstackdesc (d, 'STACK DESC  ',  mbl_xt_mtrail.mb_st,
                      mbl_xt_mtrail.mb_qual^.mstack_desc);
                IF  mb_qual_len > MB_PART1_HEAD_MXGG00
                THEN
                    BEGIN
                    moveobj_ptr := @mbl_xt_mtrail.mb_qual^;
                    displ_upb   := mb_qual_len;
                    IF  displ_upb - MB_PART1_HEAD_MXGG00 > d.dsMaxBuflength
                    THEN
                        displ_upb := MB_PART1_HEAD_MXGG00 + d.dsMaxBuflength;
                    (*ENDIF*) 
                    t14bufdisplay (d.dsTerm^, d.dsProt^, scan,
                          'MB_QUAL                       ',
                          moveobj_ptr^, mbl_xt_mtrail.mb_qual_size,
                          MB_PART1_HEAD_MXGG00 + 1, displ_upb,
                          MB_PART1_HEAD_MXGG00 + 1, dummy_pos, dummy_pfkey)
                    END;
                (*ENDIF*) 
                IF  (mbl_xt_mtrail.mb_strat <> NIL) AND
                    (mb_strat_len > 0)
                THEN
                    BEGIN (* PTS 1112689 *)
                    IF  ( mbl_xt_mtrail.mb_qual^.mstack_desc.mstrat_pos > 0 )
                    THEN
                        BEGIN
                        strat_len := mbl_xt_mtrail.mb_st^[ mbl_xt_mtrail.mb_qual^.
                              mstack_desc.mstrat_pos ].elen_var;
                        IF  ( strat_len > sizeof(strat) )
                        THEN
                            strat_len := sizeof(strat);
                        (*ENDIF*) 
                        SAPDB_PascalForcedMove (mbl_xt_mtrail.mb_strat_size, sizeof( strat ),
                              @mbl_xt_mtrail.mb_strat^,
                              mbl_xt_mtrail.mb_st^[ mbl_xt_mtrail.mb_qual^.
                              mstack_desc.mstrat_pos ].epos,
                              @strat, 1, strat_len);
                        xt02strat (d.dsTerm^,d.dsProt^, trace,
                              'STRATEGY    ', strat );
                        IF  ( mbl_xt_mtrail.mb_qual^.mstack_desc.mstrat_cnt = 4 ) AND
                            ( mbl_xt_mtrail.mb_st^[ mbl_xt_mtrail.mb_qual^.
                            mstack_desc.mstrat_pos + 3 ].etype = st_strat )
                        THEN
                            BEGIN
                            strat_len := mbl_xt_mtrail.mb_st^[ mbl_xt_mtrail.
                                  mb_qual^.mstack_desc.mstrat_pos + 3 ].elen_var;
                            IF  ( strat_len > sizeof(strat) )
                            THEN
                                strat_len := sizeof(strat);
                            (*ENDIF*) 
                            SAPDB_PascalForcedMove (mbl_xt_mtrail.mb_strat_size, sizeof( strat ),
                                  @mbl_xt_mtrail.mb_strat^,
                                  mbl_xt_mtrail.mb_st^[ mbl_xt_mtrail.mb_qual^.
                                  mstack_desc.mstrat_pos + 3 ].epos,
                                  @strat, 1, strat_len);
                            xt02strat (d.dsTerm^,d.dsProt^, trace,
                                  'ONETAB STRAT', strat );
                            END;
                        (*ENDIF*) 
                        IF  ( mbl_xt_mtrail.mb_qual^.mstack_desc.mstrat_cnt > 1 ) AND
                            ( mb_type = m_select ) AND
                            ( mb_type2 in
                            [ mm_with_join, mm_join_with_last_tab ] )
                        THEN
                            BEGIN
                            SAPDB_PascalForcedMove ( mbl_xt_mtrail.mb_strat_size,
                                  sizeof(getrec.gi_result_info),
                                  @mbl_xt_mtrail.mb_strat^,
                                  mbl_xt_mtrail.mb_st^[ mbl_xt_mtrail.mb_qual^.
                                  mstack_desc.mstrat_pos + 1].epos - sizeof(getrec.gi_result_info),
                                  @getrec.gi_result_info, 1, sizeof(getrec.gi_result_info));
                            SAPDB_PascalForcedMove ( mbl_xt_mtrail.mb_strat_size,
                                  sizeof(getrec.gi_copy_info),
                                  @mbl_xt_mtrail.mb_strat^,
                                  mbl_xt_mtrail.mb_st^[ mbl_xt_mtrail.mb_qual^.
                                  mstack_desc.mstrat_pos + 1].epos,
                                  @getrec.gi_copy_info, 1,
                                  mbl_xt_mtrail.mb_st^[ mbl_xt_mtrail.mb_qual^.
                                  mstack_desc.mstrat_pos + 1].elen_var);
                            SAPDB_PascalForcedMove ( mbl_xt_mtrail.mb_strat_size,
                                  sizeof(getrec.gi_linkrec),
                                  @mbl_xt_mtrail.mb_strat^,
                                  mbl_xt_mtrail.mb_st^[ mbl_xt_mtrail.mb_qual^.
                                  mstack_desc.mstrat_pos + 2].epos,
                                  @getrec.gi_linkrec, 1,
                                  mbl_xt_mtrail.mb_st^[ mbl_xt_mtrail.mb_qual^.
                                  mstack_desc.mstrat_pos + 2].elen_var);
                            xt02xjoininfo( d.dsTerm^, d.dsProt^, getrec );
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            mbs_tree_id:
                BEGIN
                xt02xtreeid (d.dsTerm^,d.dsProt^, 'treeid      ',
                      mbl_xt_mtrail.mb_qual^.mtree);
                IF  mb_qual_len > sizeof (tgg00_FileId)
                THEN
                    BEGIN
                    moveobj_ptr := @mbl_xt_mtrail.mb_qual^;
                    displ_upb   := mb_qual_len;
                    IF  displ_upb - sizeof (tgg00_FileId) > d.dsMaxBuflength
                    THEN
                        displ_upb := sizeof(tgg00_FileId) + d.dsMaxBuflength;
                    (*ENDIF*) 
                    t14bufdisplay (d.dsTerm^, d.dsProt^, scan,
                          'MB_QUAL                       ',
                          moveobj_ptr^, mbl_xt_mtrail.mb_qual_size,
                          sizeof (tgg00_FileId) + 1, displ_upb,
                          sizeof (tgg00_FileId) + 1,
                          dummy_pos, dummy_pfkey)
                    END
                (*ENDIF*) 
                END;
            OTHERWISE;
                BEGIN
                moveobj_ptr := @mbl_xt_mtrail.mb_qual^;
                displ_upb   := mb_qual_len;
                IF  displ_upb > d.dsMaxBuflength
                THEN
                    displ_upb := d.dsMaxBuflength;
                (*ENDIF*) 
                t14bufdisplay (d.dsTerm^, d.dsProt^, scan,
                      'MB_QUAL                       ',
                      moveobj_ptr^, mbl_xt_mtrail.mb_qual_size,
                      1, displ_upb, 1, dummy_pos, dummy_pfkey)
                END
            END;
        (*ENDCASE*) 
    (*ENDIF*) 
    IF  (mbl_xt_mtrail.mb_data <> NIL) AND
        (mb_data_len > 0)
    THEN
        BEGIN
        moveobj_ptr := @mbl_xt_mtrail.mb_data^;
        displ_upb   := mb_data_len;
        IF  displ_upb > d.dsMaxBuflength
        THEN
            displ_upb := d.dsMaxBuflength;
        (*ENDIF*) 
        t14bufdisplay (d.dsTerm^, d.dsProt^, scan,
              'MB_DATA                       ',
              moveobj_ptr^, mbl_xt_mtrail.mb_data_size, 1, displ_upb, 1,
              dummy_pos, dummy_pfkey);
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xname1 (
            VAR term       : tut_terminal;
            VAR protfile   : tut_vf_fileref;
            nam            : tsp00_Sname;
            n              : tsp00_Name);
 
VAR
      i      : integer;
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
xt02xline_init (term, nam, ln_len, ln);
ln_len := ln_len + 1;
FOR i := 1 TO sizeof (n) DO
    IF  g17printable_char (n [i])
    THEN
        ln [ln_len + i] := n [i]
    ELSE
        ln [ln_len + i] := '.';
    (*ENDIF*) 
(*ENDFOR*) 
xt02xwrite_line (term, protfile, ln)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xline_init (
            VAR term   : tut_terminal;
            nam        : tsp00_Sname;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
BEGIN
ln          := term.blankline;
ln_len      := 0;
g17sname_to_line (nam, ln_len, ln);
ln_len      := sizeof (nam) + 2;
ln [ln_len] := ':'
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xp2int4 (
            VAR term      : tut_terminal;
            VAR protfile  : tut_vf_fileref;
            nam_1         : tsp00_Sname;
            int_1         : tsp00_Int4;
            nam_2         : tsp00_Sname;
            int_2         : tsp00_Int4);
 
CONST
      mx_left_col = 39;
      mx_number   = 11;
 
VAR
      err    : integer;
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
xt02xline_init (term, nam_1, ln_len, ln);
IF  int_1 = NIL_PAGE_NO_GG00
THEN
    g17sname_to_line (' nil_pno    ', ln_len, ln)
ELSE
    g17int4to_line (int_1, NOT c_with_zero, mx_number, ln_len + 1, ln);
(*ENDIF*) 
ln_len := mx_left_col;
g17sname_to_line (nam_2, ln_len, ln);
ln_len := mx_left_col + sizeof (nam_2) + 2;
ln [ln_len] := ':';
IF  int_2 = NIL_PAGE_NO_GG00
THEN
    g17sname_to_line (' NIL_PNO    ', ln_len, ln)
ELSE
    g17int4to_line (int_2, NOT c_with_zero, mx_number, ln_len + 1, ln);
(*ENDIF*) 
ln_len := ln_len + mx_number;
t12write_prot (protfile, ln, ln_len, err);
t09put (term, ln, cut_protected)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xp2bool (
            VAR term      : tut_terminal;
            VAR protfile  : tut_vf_fileref;
            nam_1         : tsp00_Sname;
            bool_1        : boolean;
            nam_2         : tsp00_Sname;
            bool_2        : boolean);
 
CONST
      mx_left_col = 39;
      mx_number   = 11;
 
VAR
      err    : integer;
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
xt02xline_init (term, nam_1, ln_len, ln);
IF  bool_1
THEN
    g17sname_to_line (' true       ', ln_len, ln)
ELSE
    g17sname_to_line (' false      ', ln_len, ln);
(*ENDIF*) 
ln_len := mx_left_col;
g17sname_to_line (nam_2, ln_len, ln);
ln_len := mx_left_col + sizeof (nam_2) + 2;
ln [ln_len] := ':';
IF  bool_2
THEN
    g17sname_to_line (' true       ', ln_len, ln)
ELSE
    g17sname_to_line (' false      ', ln_len, ln);
(*ENDIF*) 
ln_len := ln_len + mx_number;
t12write_prot (protfile, ln, ln_len, err);
t09put (term, ln, cut_protected)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xstackdesc (
            VAR d           : t_DisplState;
            nam             : tsp00_Sname;
            stack_addr      : tgg00_StackListPtr;
            VAR stack_desc  : tgg00_StackDesc);
 
CONST
      c_int2_cnt = 20;
 
VAR
      is_second_ln  : boolean;
      values_found  : boolean;
      i2            : tsp00_IntMapC2;
      err           : integer;
      i             : integer;
      ln_len        : integer;
      highest_stack : integer;
      stackptr      : integer;
      st_start      : integer;
      st_stop       : integer;
      ln            : tsp00_Line;
      second_ln     : tsp00_Line;
 
      univ_ptr : RECORD
            CASE integer OF
                2:
                    (s          : tgg00_StEntryAddr);
                3:
                    (bufaddr    : tsp00_BufAddr);
                4:
                    (stack_addr : tgg00_StackListPtr)
                END;
            (*ENDCASE*) 
 
 
      univ_stack_desc : RECORD
            CASE integer OF
                1:
                    (st_desc : tgg00_StackDesc);
                2:
                    (int2_arr: PACKED ARRAY [1..c_int2_cnt] OF tsp00_Int2)
                END;
            (*ENDCASE*) 
 
 
BEGIN
values_found := false;
IF  (stack_addr             = NIL) AND
    (stack_desc.mst_max     =   0) AND
    (stack_desc.mfirst_free =   1)
THEN
    BEGIN
    univ_stack_desc.st_desc := stack_desc;
    i := 1;
    WHILE NOT values_found AND (i <= c_int2_cnt) DO
        IF  univ_stack_desc.int2_arr [i] = 0
        THEN
            i := i + 1
        ELSE
            values_found := true
        (*ENDIF*) 
    (*ENDWHILE*) 
    END
ELSE
    values_found := true;
(*ENDIF*) 
IF  NOT values_found
THEN
    BEGIN
    ln     := d.dsTerm^.blankline;
    ln_len := 0;
    g17nameto_line   ('stack_desc   : EMP', ln_len, ln);
    g17nameto_line   ('TY (mst_addr: NIL;', ln_len, ln);
    g17nameto_line   ('  firstfree: 1)   ', ln_len, ln);
    t12write_prot (d.dsProt^, ln, ln_len, err);
    t09put (d.dsTerm^, ln, cut_protected)
    END
ELSE
    WITH stack_desc DO
        BEGIN
        highest_stack := 0;
        ln     := d.dsTerm^.blankline;
        ln_len := 0;
        g17sname_to_line ('---         ', ln_len, ln);
        ln_len := ln_len + 1;
        g17sname_to_line (nam, ln_len, ln);
        g17sname_to_line (' ---        ', ln_len, ln);
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected);
        univ_ptr.stack_addr := stack_addr;
        t12write_prot (d.dsProt^, d.dsTerm^.blankline, 1, err);
        t09put (d.dsTerm^, d.dsTerm^.blankline, cut_protected);
        ln     := d.dsTerm^.blankline;
        ln_len := 0;
        g17sname_to_line ('st_max   :  ', ln_len, ln);
        g17int4to_line   (mst_max, NOT c_with_zero, 5, ln_len+1, ln);
        ln_len        := ln_len + 5;
        g17sname_to_line ('; firstfree:', ln_len, ln);
        g17int4to_line   (mfirst_free, NOT c_with_zero, 5, ln_len+1,ln);
        ln_len        := ln_len + 5;
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected);
        ln            := d.dsTerm^.blankline;
        ln_len        := 0;
        g17sname_to_line ('special  :  ', ln_len, ln);
        IF  mspecial = 0
        THEN
            g17sname_to_line ('    0;      ', ln_len, ln)
        ELSE
            BEGIN
            ln_len := ln_len + 1;
            g17trimint4_to_line (mspecial, ln_len, ln);
            ln_len      := ln_len + 1;
            ln [ln_len] := '/';
            i2.mapInt_sp00  := mspecial;
            g17hexto_line (i2.mapC2_sp00 [1], ln_len, ln);
            g17hexto_line (i2.mapC2_sp00 [2], ln_len, ln)
            END;
        (*ENDIF*) 
        g17sname_to_line (' bool     : ', ln_len, ln);
        IF  ord (mbool) = 0
        THEN
            g17sname_to_line (' FALSE      ', ln_len, ln)
        ELSE
            IF  ord (mbool) = 1
            THEN
                g17sname_to_line (' TRUE       ', ln_len, ln)
            ELSE
                g17trimint4_to_line (ord(mbool), ln_len, ln);
            (*ENDIF*) 
        (*ENDIF*) 
        g17sname_to_line ('; state:    ', ln_len, ln);
        IF  ( mstack_state = [] )
        THEN
            g17sname_to_line (' <empty>    ', ln_len, ln)
        ELSE
            BEGIN
            IF  ( ssSubquery_egg00 in mstack_state )
            THEN
                g17sname_to_line (' ssSubquery ', ln_len, ln);
            (*ENDIF*) 
            IF  ( ssConstParamExpr_egg00 in mstack_state )
            THEN
                g17sname_to_line (' ConstParam ', ln_len, ln);
            (*ENDIF*) 
            IF  ( ssCopyRow_egg00 in mstack_state )
            THEN
                g17sname_to_line (' ssCopyRow  ', ln_len, ln);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected);
        (* PTS 1106938 E.Z. *)
        ln      := d.dsTerm^.blankline;
        ln_len  := 0;
        g17sname_to_line ('sqlmode  :  ', ln_len, ln);
        CASE msqlmode OF
            sqlm_ansi :
                g17sname_to_line (' ANSI       ', ln_len, ln);
            sqlm_db2  :
                g17sname_to_line (' DB2        ', ln_len, ln);
            sqlm_oracle :
                g17sname_to_line (' ORACLE     ', ln_len, ln);
            OTHERWISE :
                g17sname_to_line (' INTERNAL   ', ln_len, ln);
            END;
        (*ENDCASE*) 
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected);
        (* END OF PTS 1106938 E.Z. *)
        t12write_prot (d.dsProt^, d.dsTerm^.blankline, 1, err);
        t09put (d.dsTerm^, d.dsTerm^.blankline, cut_protected);
        ln      := d.dsTerm^.blankline;
        ln_len  := 0;
        g17sname_to_line ('col_pos  :  ', ln_len, ln);
        g17int4to_line   (mcol_pos, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        g17sname_to_line ('; mult_pos :', ln_len, ln);
        g17int4to_line   (mmult_pos, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        g17sname_to_line ('; qual_pos :', ln_len, ln);
        g17int4to_line   (mqual_pos, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        g17sname_to_line ('; view_pos: ', ln_len, ln);
        g17int4to_line   (mview_pos, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected);
        ln      := d.dsTerm^.blankline;
        ln_len  := 0;
        g17sname_to_line ('col_cnt  :  ', ln_len, ln);
        g17int4to_line   (mcol_cnt, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        g17sname_to_line ('; mult_cnt :', ln_len, ln);
        g17int4to_line   (mmult_cnt, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        g17sname_to_line ('; qual_cnt :', ln_len, ln);
        g17int4to_line   (mqual_cnt, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        g17sname_to_line ('; view_cnt: ', ln_len, ln);
        g17int4to_line   (mview_cnt, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected);
        t12write_prot (d.dsProt^, d.dsTerm^.blankline, 1, err);
        t09put (d.dsTerm^, d.dsTerm^.blankline, cut_protected);
        ln      := d.dsTerm^.blankline;
        ln_len  := 0;
        g17sname_to_line ('upd_pos  :  ', ln_len, ln);
        g17int4to_line   (mupd_pos, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        g17sname_to_line ('; link_pos :', ln_len, ln);
        g17int4to_line   (mlink_pos, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        g17sname_to_line ('; strat_pos:', ln_len, ln);
        g17int4to_line   (mstrat_pos, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        g17sname_to_line ('; str_pos : ', ln_len, ln);
        g17int4to_line   (mstring_pos, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected);
        ln      := d.dsTerm^.blankline;
        ln_len  := 0;
        g17sname_to_line ('upd_cnt  :  ', ln_len, ln);
        g17int4to_line   (mupd_cnt, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        g17sname_to_line ('; link_cnt :', ln_len, ln);
        g17int4to_line   (mlink_cnt, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        g17sname_to_line ('; strat_cnt:', ln_len, ln);
        g17int4to_line   (mstrat_cnt, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        g17sname_to_line ('; str_cnt : ', ln_len, ln);
        g17int4to_line   (mstring_cnt, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t12write_prot (d.dsProt^, d.dsTerm^.blankline, 1, err);
        t09put (d.dsTerm^, ln, cut_protected);
        t09put (d.dsTerm^, d.dsTerm^.blankline, cut_protected);
        ln     := d.dsTerm^.blankline;
        ln_len := 0;
        g17sname_to_line ('iqual_pos:  ', ln_len, ln);
        g17int4to_line   (minvqual_pos, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        g17sname_to_line ('; trigg_pos:', ln_len, ln);
        g17int4to_line   (mtrigger_pos, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        g17sname_to_line ('; resq_pos: ', ln_len, ln);
        g17int4to_line   (mresqual_pos, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t09put (d.dsTerm^, ln, cut_protected);
        ln     := d.dsTerm^.blankline;
        ln_len := 0;
        g17sname_to_line ('iqual_cnt:  ', ln_len, ln);
        g17int4to_line   (minvqual_cnt, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        g17sname_to_line ('; trigg_cnt:', ln_len, ln);
        g17int4to_line   (mtrigger_cnt, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        g17sname_to_line ('; resq_cnt: ', ln_len, ln);
        g17int4to_line   (mresqual_cnt, false, 5, ln_len+1, ln);
        ln_len := ln_len + 5;
        t12write_prot (d.dsProt^, ln, ln_len, err);
        t12write_prot (d.dsProt^, d.dsTerm^.blankline, 1, err);
        t09put (d.dsTerm^, ln, cut_protected);
        t09put (d.dsTerm^, d.dsTerm^.blankline, cut_protected);
        IF  (mcol_cnt > 0) AND (mcol_pos > 0)
        THEN
            BEGIN
            stackptr := mcol_pos - 1;
            IF  highest_stack < stackptr + mcol_cnt
            THEN
                highest_stack := stackptr + mcol_cnt;
            (*ENDIF*) 
            xt02xint4 (d.dsTerm^, d.dsProt^, 'col_cnt     ', mcol_cnt);
            IF  (stackptr + mcol_cnt <= mst_max) AND (stackptr >= 0)
            THEN
                FOR i := 1 TO mcol_cnt DO
                    BEGIN
                    g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                          is_second_ln, second_ln);
                    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
                    IF  is_second_ln
                    THEN
                        xt02xwrite_line (d.dsTerm^, d.dsProt^, second_ln)
                    (*ENDIF*) 
                    END
                (*ENDFOR*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (mmult_cnt > 0) AND (mmult_pos > 0)
        THEN
            BEGIN
            stackptr := mmult_pos - 1;
            IF  highest_stack < stackptr + mmult_cnt
            THEN
                highest_stack := stackptr + mmult_cnt;
            (*ENDIF*) 
            xt02xint4 (d.dsTerm^, d.dsProt^, 'mult_cnt    ', mmult_cnt);
            IF  (stackptr + mmult_cnt <= mst_max) AND
                (stackptr >= 0)
            THEN
                FOR i := 1 TO mmult_cnt DO
                    BEGIN
                    g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                          is_second_ln, second_ln);
                    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
                    IF  is_second_ln
                    THEN
                        xt02xwrite_line (d.dsTerm^, d.dsProt^, second_ln)
                    (*ENDIF*) 
                    END
                (*ENDFOR*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (mqual_cnt > 0) AND (mqual_pos > 0)
        THEN
            BEGIN
            stackptr := mqual_pos - 1;
            IF  highest_stack < stackptr + mqual_cnt
            THEN
                highest_stack := stackptr + mqual_cnt;
            (*ENDIF*) 
            xt02xint4 (d.dsTerm^, d.dsProt^, 'qual_cnt    ', mqual_cnt);
            IF  (stackptr + mqual_cnt <= mst_max) AND
                (stackptr >= 0)
            THEN
                FOR i := 1 TO mqual_cnt DO
                    BEGIN
                    g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                          is_second_ln, second_ln);
                    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
                    IF  is_second_ln
                    THEN
                        xt02xwrite_line (d.dsTerm^, d.dsProt^, second_ln)
                    (*ENDIF*) 
                    END
                (*ENDFOR*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (minvqual_cnt > 0) AND (minvqual_pos > 0)
        THEN
            BEGIN
            stackptr := minvqual_pos - 1;
            IF  highest_stack < stackptr + minvqual_cnt
            THEN
                highest_stack := stackptr + minvqual_cnt;
            (*ENDIF*) 
            xt02xint4 (d.dsTerm^, d.dsProt^, 'minvqual_cnt', minvqual_cnt);
            IF  (stackptr + minvqual_cnt <= mst_max) AND
                (stackptr >= 0)
            THEN
                FOR i := 1 TO minvqual_cnt DO
                    BEGIN
                    g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                          is_second_ln, second_ln);
                    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
                    IF  is_second_ln
                    THEN
                        xt02xwrite_line (d.dsTerm^, d.dsProt^, second_ln)
                    (*ENDIF*) 
                    END
                (*ENDFOR*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (mresqual_cnt > 0) AND (mresqual_pos >0)
        THEN
            BEGIN
            stackptr := mresqual_pos - 1;
            IF  highest_stack < stackptr + mresqual_cnt
            THEN
                highest_stack := stackptr + mresqual_cnt;
            (*ENDIF*) 
            xt02xint4 (d.dsTerm^, d.dsProt^, 'mresqual_cnt', mresqual_cnt);
            IF  (stackptr + mresqual_cnt <= mst_max) AND (stackptr >= 0)
            THEN
                FOR i := 1 TO mresqual_cnt DO
                    BEGIN
                    g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                          is_second_ln, second_ln);
                    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
                    IF  is_second_ln
                    THEN
                        xt02xwrite_line (d.dsTerm^, d.dsProt^, second_ln)
                    (*ENDIF*) 
                    END
                (*ENDFOR*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (mupd_cnt > 0) AND (mupd_pos >0)
        THEN
            BEGIN
            stackptr := mupd_pos - 1;
            IF  highest_stack < stackptr + mupd_cnt
            THEN
                highest_stack := stackptr + mupd_cnt;
            (*ENDIF*) 
            xt02xint4 (d.dsTerm^, d.dsProt^, 'upd_cnt     ', mupd_cnt);
            IF  (stackptr + mupd_cnt <= mst_max) AND (stackptr >= 0)
            THEN
                FOR i := 1 TO mupd_cnt DO
                    BEGIN
                    g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                          is_second_ln, second_ln);
                    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
                    IF  is_second_ln
                    THEN
                        xt02xwrite_line (d.dsTerm^, d.dsProt^, second_ln)
                    (*ENDIF*) 
                    END
                (*ENDFOR*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (mlink_cnt > 0) AND (mlink_pos > 0)
        THEN
            BEGIN
            stackptr := mlink_pos - 1;
            IF  highest_stack < stackptr + mlink_cnt
            THEN
                highest_stack := stackptr + mlink_cnt;
            (*ENDIF*) 
            xt02xint4   (d.dsTerm^, d.dsProt^, 'link_cnt    ', mlink_cnt);
            IF  (stackptr + mlink_cnt <= mst_max) AND
                (stackptr >= 0)
            THEN
                FOR i := 1 TO mlink_cnt DO
                    BEGIN
                    g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                          is_second_ln, second_ln);
                    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
                    IF  is_second_ln
                    THEN
                        xt02xwrite_line (d.dsTerm^, d.dsProt^, second_ln)
                    (*ENDIF*) 
                    END;
                (*ENDFOR*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (mstrat_cnt > 0) AND (mstrat_pos > 0)
        THEN
            BEGIN
            stackptr := mstrat_pos - 1;
            IF  highest_stack < stackptr + mstrat_cnt
            THEN
                highest_stack := stackptr + mstrat_cnt;
            (*ENDIF*) 
            xt02xint4 (d.dsTerm^, d.dsProt^, 'strat_cnt   ', mstrat_cnt);
            IF  (stackptr + mstrat_cnt <= mst_max) AND
                (stackptr >= 0)
            THEN
                FOR i := 1 TO mstrat_cnt DO
                    BEGIN
                    g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                          is_second_ln, second_ln);
                    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
                    IF  is_second_ln
                    THEN
                        xt02xwrite_line (d.dsTerm^, d.dsProt^, second_ln)
                    (*ENDIF*) 
                    END
                (*ENDFOR*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (mstring_cnt > 0) AND (mstring_pos > 0)
        THEN
            BEGIN
            stackptr := mstring_pos - 1;
            IF  highest_stack < stackptr + mstring_cnt
            THEN
                highest_stack := stackptr + mstring_cnt;
            (*ENDIF*) 
            xt02xint4 (d.dsTerm^, d.dsProt^, 'string_cnt  ', mstring_cnt);
            IF  (stackptr + mstring_cnt <= mst_max) AND
                (stackptr >= 0)
            THEN
                FOR i := 1 TO mstring_cnt DO
                    BEGIN
                    g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                          is_second_ln, second_ln);
                    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
                    IF  is_second_ln
                    THEN
                        xt02xwrite_line (d.dsTerm^, d.dsProt^, second_ln)
                    (*ENDIF*) 
                    END
                (*ENDFOR*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (mtrigger_cnt > 0) AND (mtrigger_pos > 0)
        THEN
            BEGIN
            stackptr := mtrigger_pos - 1;
            IF  highest_stack < stackptr + mtrigger_cnt
            THEN
                highest_stack := stackptr + mtrigger_cnt;
            (*ENDIF*) 
            xt02xint4 (d.dsTerm^, d.dsProt^, 'trigger_cnt ', mtrigger_cnt);
            IF  (stackptr + mstrat_cnt <= mst_max) AND
                (stackptr >= 0)
            THEN
                FOR i := 1 TO mtrigger_cnt DO
                    BEGIN
                    g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                          is_second_ln, second_ln);
                    xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
                    IF  is_second_ln
                    THEN
                        xt02xwrite_line (d.dsTerm^, d.dsProt^, second_ln)
                    (*ENDIF*) 
                    END
                (*ENDFOR*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (mfirst_free - 1 > highest_stack) OR
            (((mcol_pos > mstrat_pos + mstrat_cnt) OR
            (mresqual_pos > mstrat_pos + mstrat_cnt)) AND
            (mstrat_cnt > 0))
        THEN
            (* *** mm_with_join or mm_join_with_last_tab *** *)
            BEGIN
            IF  (mfirst_free - 1 > highest_stack)
            THEN
                BEGIN
                st_start := highest_stack + 1;
                st_stop  := mfirst_free - 1;
                END
            ELSE
                BEGIN
                st_start := mstrat_pos + mstrat_cnt;
                IF  (mresqual_pos > mstrat_pos + mstrat_cnt)
                THEN
                    st_stop  := mresqual_pos - 1
                ELSE
                    st_stop  := mcol_pos - 1;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            ln     := d.dsTerm^.blankline;
            ln_len := 0;
            g17nameto_line ('cols to be        ', ln_len, ln);
            g17nameto_line (' shifted from i-1.', ln_len, ln);
            g17nameto_line ('th result to i.th ', ln_len, ln);
            g17nameto_line (' result :         ', ln_len, ln);
            g17int4to_line   (st_stop - (mstrat_pos + mstrat_cnt) + 1,
                  false, 5, ln_len + 1, ln);
            xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
            i := st_start;
            WHILE i <= st_stop DO
                BEGIN
                g17onestackentry (stack_addr^ [ i ], i, ln,
                      is_second_ln, second_ln);
                xt02xwrite_line (d.dsTerm^, d.dsProt^, ln);
                IF  is_second_ln
                THEN
                    xt02xwrite_line (d.dsTerm^, d.dsProt^, second_ln);
                (*ENDIF*) 
                i := succ( i );
                END;
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xtreeid (
            VAR term        : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            nam             : tsp00_Sname;
            VAR treeid      : tgg00_FileId);
 
VAR
      err    : integer;
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
WITH treeid DO
    BEGIN
    ln     := term.blankline;
    ln_len := 0;
    g17sname_to_line ('---         ', ln_len, ln);
    ln_len := ln_len + 1;
    g17sname_to_line (nam, ln_len, ln);
    ln_len := ln_len + 1;
    g17sname_to_line ('---         ', ln_len, ln);
    t12write_prot  (protfile, ln, ln_len, err);
    t09put (term, ln, cut_protected);
    xt02xp2int4    (term, protfile,     'fileUserRPno', gg06RefPno (fileUserRef_gg00)
          ,                             'fileUserRIdx', gg06RefPos (fileUserRef_gg00));
    xt02xline_init (term,               'fileHandling', ln_len, ln);
    g17handling_set_to_line (fileHandling_gg00, ln_len, ln);
    t12write_prot  (protfile, ln, ln_len, err);
    t09put (term, ln, cut_protected);
    xt02xline_init (term,               'fileBdUse   ', ln_len, ln);
    g17bd_use_set_to_line (fileBdUse_gg00, ln_len, ln);
    t12write_prot  (protfile, ln, ln_len, err);
    t09put (term, ln, cut_protected);
    xt02xline_init (term,               'fileType    ', ln_len, ln);
    g17filetype_to_line (fileType_gg00, NOT c_edit_file, ln_len, ln);
    t12write_prot  (protfile, ln, ln_len, err);
    t09put (term, ln, cut_protected);
    xt02xp2int4    (term, protfile,     'fileRoot    ', fileRoot_gg00
          ,                             'fileLeafNode', fileLeafNodes_gg00);
    xt02xline_init (term,               'fileRootchck', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (fileRootCheck_gg00, ln_len, ln);
    t12write_prot (protfile, ln, ln_len, err);
    t09put (term, ln, cut_protected);
    xt02xline_init (term,               'fileVersion ', ln_len, ln);
    ln_len := ln_len + 1;
    gg06FileVersToLine (fileVersion_gg00, ln_len, ln);
    t12write_prot (protfile, ln, ln_len, err);
    t09put (term, ln, cut_protected);
    xt02print_filename (term, protfile, NO_FUNCTION_SIGN, 'filename    ', fileName_gg00)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02strat (
            VAR term        : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            VAR trace       : trace_record;
            nam             : tsp00_Sname;
            VAR strat       : tgg07_StrategyInfo);
 
VAR
      ln     : tsp00_Line;
      ln2    : tsp00_Line;
      ln3    : tsp00_Line;
      err    : integer;
      ln_len : integer;
      i      : integer;
      strat_pos : tsp00_Int2;
      strat_len : tsp00_Int2;
      is_ln3 : boolean;
 
      str            : RECORD
            CASE boolean OF
                true  :
                    (strat_char : tsp00_C1);
                false :
                    (strat_enum : tgg07_StratEnum);
                END;
            (*ENDCASE*) 
 
 
BEGIN (* PTS 1112689 *)
WITH strat DO
    BEGIN
    xt02xline_init (term, nam, ln_len, ln);
    ln_len := ln_len + 1;
    g17stratenum_to_line (str_strategy, ln_len, ln);
    xt02xwrite_line (term, protfile, ln);
    g17filename ('result_id   ', str_result_id.fileName_gg00, 0, ln, ln2, ln3, is_ln3);
    xt02xwrite_line (term, protfile, ln);
    xt02xwrite_line (term, protfile, ln2);
    IF  ( is_ln3 )
    THEN
        xt02xwrite_line (term, protfile, ln3);
    (*ENDIF*) 
    xt02xint4 (term, protfile, 'distinct    ', ord(str_distinc ));
    xt02xint4 (term, protfile, 'qual_kind   ', ord(str_qual_kind ));
    xt02xint4 (term, protfile, 'rowno       ', ord(str_rowno ));
    xt02xp2bool (term, protfile, 'build_result', str_build_result
          ,                      'use_rowno   ', str_use_rowno);
    xt02xp2bool (term, protfile, 'corr_single ', str_corr_single
          ,                    'res_possible', str_res_possible);
    xt02xp2bool (term, protfile, 'use_order   ', str_use_order
          ,                    'ordering    ', str_ordering);
    xt02xbool (term, protfile, 'sel_into    ', str_selinto);
    xt02xp2int4 (term, protfile, 'cnt_strat   ', str_cnt_strat
          ,                      'union_kind  ', str_union_kind);
    xt02xp2int4 (term, protfile, 'foundresults', str_foundresults
          ,                      'union_key_cn', str_union_key_cnt_offs);
    xt02xp2int4 (term, protfile, 'key_len     ', str_key_len
          ,                      'rec_len     ', str_rec_len);
    xt02xp2int4 (term, protfile, 'out key seql', str_out_keyseqlen
          ,                      'stack out of', str_stack_output_offs );
    xt02xp2bool (term, protfile, 'search_first', str_search_first
          ,                    'all_files   ', str_all_files);
    xt02xint4 (term, protfile, 'key_order_sp', ord(str_key_order_support));
    xt02xline_init (term, 'access mode ', ln_len, ln);
    ln_len := ln_len + 1;
    g17access_mode_set (str_access_mod, ln_len, ln);
    xt02xwrite_line (term, protfile, ln);
    IF  NOT ( str_strategy
        in [ strat_no_result, strat_more_than_one, strat_undecided ] )
    THEN
        BEGIN
        IF  ( str_strategy in [
            strat_inv_range,
            strat_inv_subq,
            strat_inv_in,
            (* fetch *)
            strat_inv_range_fetch,
            strat_inv_range_merge_fetch ])
            OR
            ( str_strategy in
            [ strat_join_inv,
            strat_join_all_inv_equal,
            strat_join_inv_range ] ) OR
            ( str_strategy in [
            strat_join_key_equal,
            strat_join_key_next,
            strat_join_all_keys_equal,
            strat_join_key_range ] )
        THEN
            BEGIN
            xt02xcolposarr(term, protfile, 'keystart    ',
                  str_key_in_range.skir_keystart);
            xt02xcolposarr(term, protfile, 'keystop     ',
                  str_key_in_range.skir_keystop);
            END;
        (*ENDIF*) 
        IF  ( str_strategy in [
            strat_inv_range,
            strat_inv_subq,
            strat_inv_in,
            (* fetch *)
            strat_inv_range_fetch,
            strat_inv_range_merge_fetch ])
        THEN
            BEGIN
            xt02xoutput_invstrat( term, protfile, 'inv data    ',
                  str_inv_in_range );
            END
        ELSE
            BEGIN
            IF  ( str_strategy in [
                strat_key_equal,
                strat_key_subq,
                strat_key_in,
                strat_key_range,
                (* fetch *)
                strat_key_range_fetch ])
            THEN
                BEGIN
                xt02xoutput_keystrat( term, protfile, 'key data    ',
                      str_key_in_range );
                END
            ELSE
                IF  ( str_strategy in [
                    strat_join_key_equal,
                    strat_join_key_next,
                    strat_join_all_keys_equal,
                    strat_join_key_range,
                    strat_join_viewkey,
                    strat_join_inv,
                    strat_join_all_inv_equal,
                    strat_join_inv_range ])
                THEN
                    BEGIN
                    IF   ( NOT ( str_strategy
                        in [ strat_join_viewkey, strat_viewkey ]))
                    THEN
                        BEGIN
                        xt02xint4 (term, protfile, 'index no    ', str_join_multfields.sjmf_index_no );
                        xt02xint4 (term, protfile, 'cntfields   ', str_join_multfields.sjmf_cntfields );
                        xt02xint4 (term, protfile, 'inv len     ', str_join_multfields.sjmf_invlen );
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    IF  ( str_strategy = strat_catalog )
                    THEN
                        BEGIN
                        xt02xint4 (term, protfile, 'showkind    ', ord(str_catalog.scat_show_kind) );
                        xt02xint4 (term, protfile, 'authname    ', str_catalog.scat_authname );
                        xt02xint4 (term, protfile, 'tablename   ', str_catalog.scat_tablename );
                        xt02xint4 (term, protfile, 'username    ', str_catalog.scat_username );
                        xt02xint4 (term, protfile, 'columnname  ', str_catalog.scat_columnname );
                        END
                    ELSE
                        BEGIN
                        xt02xline_init (term, 'unkown strat', ln_len, ln);
                        g17stratenum_to_line( str_strategy, ln_len, ln );
                        xt02xwrite_line (term, protfile, ln);
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        IF  (( strat.str_strategy = strat_more_than_one ) AND
            ( strat.str_cnt_strat > 1 ))
        THEN
            BEGIN
            i := 1;
            strat_pos := trace.mbl_xt_mtrail.
                  mb_st^[ trace.mbl_xt_mtrail.mb_qual^.
                  mstack_desc.mstrat_pos ].epos +
                  STRATEGY_START_MXGG07;
            WHILE i <= strat.str_cnt_strat DO
                BEGIN
                str.strat_char[ 1 ] := trace.mbl_xt_mtrail.mb_strat^[ strat_pos ];
                strat_len           :=
                      s20buf_to_int4_1( trace.mbl_xt_mtrail.mb_strat^,
                      strat_pos + 4 );
                (* get strategy *)
                SAPDB_PascalForcedMove ( trace.mbl_xt_mtrail.mb_strat_size,
                      sizeof( strat ),
                      @trace.mbl_xt_mtrail.mb_strat^,
                      strat_pos + cgg07_stratpos_offs,
                      @strat, STRATEGY_START_MXGG07 + 1,
                      strat_len);
                strat.str_strategy := str.strat_enum;
                xt02strat (term,protfile, trace, 'one OR-strat', strat );
                i := succ(i);
                strat_pos := strat_pos + strat_len + cgg07_stratpos_offs;
                END;
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xoutput_colposarr_ex (
            VAR term    : tut_terminal;
            VAR protfile: tut_vf_fileref;
            nam         : tsp00_Sname;
            VAR keypos  : tgg07_ColPosArr;
            length      : tsp00_Int2);
 
VAR
      _ix       : tsp00_Int2;
      _ln_len   : integer;
      _line     : tsp00_Line;
 
BEGIN
_line   := term.blankline;
_ln_len := 0;
g17sname_to_line( nam, _ln_len, _line );
_ln_len := sizeof( nam ) + 2;
_line[ _ln_len ] := ':';
_ln_len := _ln_len + 2;
IF  length = 0
THEN
    BEGIN
    g17sname_to_line( 'NONE        ', _ln_len, _line );
    END
ELSE
    FOR _ix := 0 TO length - 1 DO
        BEGIN
        g17trimint4_to_line( keypos[ _ix ], _ln_len, _line );
        _ln_len := succ( _ln_len );
        IF  ( _ln_len > 70 ) AND ( _ix < MAX_COLPOSARR_IDX_GG07 )
        THEN
            BEGIN
            xt02xwrite_line (term, protfile, _line );
            _line := term.blankline;
            _ln_len := sizeof( nam ) + 4;
            END
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
(*ENDIF*) 
xt02xwrite_line (term, protfile, _line );
END;
 
(*------------------------------*) 
 
PROCEDURE (* PTS 1112689 *)
      xt02xcolposarr (
            VAR term     : tut_terminal;
            VAR protfile : tut_vf_fileref;
            nam          : tsp00_Sname;
            VAR colposarr    : tgg07_ColPosArr);
 
VAR
      ix        : integer;
      err       : integer;
      ln_len    : integer;
      ln        : tsp00_Line;
 
BEGIN
xt02xoutput_colposarr_ex( term, protfile, nam,
      colposarr, MAX_STRATEGY_KEYS_GG04 );
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xwarningset (
            VAR term     : tut_terminal;
            VAR protfile : tut_vf_fileref;
            nam          : tsp00_Sname;
            warn         : tsp00_WarningSet);
 
VAR
      curr_warn : tsp00_Warnings;
      err       : integer;
      ln_len    : integer;
      margin    : integer;
      ln        : tsp00_Line;
 
BEGIN
xt02xline_init (term, nam, ln_len, ln);
margin := ln_len;
IF  warn <> [ ]
THEN
    FOR curr_warn := warn0_exist
          TO warn15_user_defined_code DO
        IF  curr_warn in warn
        THEN
            BEGIN
            ln     := term.blankline;
            ln_len := margin;
            g17warning_item_to_line (curr_warn, ln_len, ln);
            t12write_prot (protfile, ln, ln_len, err);
            t09put (term, ln, cut_protected)
            END
        (*ENDIF*) 
    (*ENDFOR*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xwrite_line (
            VAR term     : tut_terminal;
            VAR protfile : tut_vf_fileref;
            VAR ln       : tsp00_Line);
 
VAR
      err : integer;
 
BEGIN
t12write_prot (protfile, ln, s30lnr (ln, ' ', 1, sizeof (ln)), err);
t09put (term, ln, cut_protected)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xoutput_invstrat(
            VAR term : tut_terminal;
            VAR protfile : tut_vf_fileref;
            nam           : tsp00_Sname;
            VAR inv_strat : tgg07_StrInvInRange);
 
VAR
      _ln_len   : integer;
      _line     : tsp00_Line;
 
BEGIN
_line   := term.blankline;
_ln_len := 0;
g17sname_to_line( nam, _ln_len, _line );
_ln_len := sizeof( nam ) + 2;
_line[ _ln_len ] := ':';
_ln_len := _ln_len + 2;
xt02xwrite_line (term, protfile, _line);
WITH inv_strat DO
    BEGIN
    xt02xname (term, protfile, '------------------');
    xt02xint4 (term, protfile, 'index_no    ', inv_strat.siir_indexno );
    xt02xint4 (term, protfile, 'icount      ', inv_strat.siir_icount );
    xt02xint4 (term, protfile, 'invlen      ', inv_strat.siir_invlen );
    xt02xInvColSet( term, protfile, 'invcoldesc  ', inv_strat.siir_invcoldesc );
    xt02xint4 (term, protfile, 'IN/SUBQ stpo', inv_strat.siir_IN_SUBQ_stpos );
    xt02xint4 (term, protfile, 'inelemcnt   ', inv_strat.siir_inelemcnt );
    xt02xint4 (term, protfile, 'subq idx    ', inv_strat.siir_subq_idx );
    xt02xint4 (term, protfile, 'out invseq  ', inv_strat.siir_out_invseqlen );
    xt02xname (term, protfile, '- inv properties -');
    IF  ( isp_auto_distinct in inv_strat.siir_strat_props )
    THEN
        xt02xsname (term, protfile, 'auto distinc' );
    (*ENDIF*) 
    IF  ( isp_unique_idx in inv_strat.siir_strat_props )
    THEN
        xt02xsname (term, protfile, 'iunique     ' );
    (*ENDIF*) 
    IF  ( isp_inv_only in inv_strat.siir_strat_props )
    THEN
        xt02xsname (term, protfile, 'inv only    ' );
    (*ENDIF*) 
    IF  ( isp_exact_match in inv_strat.siir_strat_props )
    THEN
        xt02xsname (term, protfile, 'exact match ' );
    (*ENDIF*) 
    IF  ( isp_exact_IN_SUBQ_match in inv_strat.siir_strat_props )
    THEN
        xt02xname (term, protfile, 'exact INSUBQ match' );
    (*ENDIF*) 
    IF  ( isp_order_support in inv_strat.siir_strat_props )
    THEN
        BEGIN
        IF  ( isp_order_support_reverse in inv_strat.siir_strat_props )
        THEN
            xt02xsname (term, protfile, 'reverse     ' );
        (*ENDIF*) 
        xt02xname (term, protfile, 'inv order support ' );
        END;
    (*ENDIF*) 
    IF  ( isp_listmerge_allowed in inv_strat.siir_strat_props )
    THEN
        xt02xname (term, protfile, 'merge possible    ' );
    (*ENDIF*) 
    IF  ( isp_aggr_MIN_opt in inv_strat.siir_strat_props )
    THEN
        BEGIN
        IF  ( isp_aggr_MIN_opt_reverse in inv_strat.siir_strat_props )
        THEN
            xt02xname (term, protfile, 'MIN opt as MAX opt')
        ELSE
            xt02xname (term, protfile, 'MIN optim         ');
        (*ENDIF*) 
        xt02xint4 (term, protfile, 'MIN recpos  ', inv_strat.siir_MIN_recpos );
        END;
    (*ENDIF*) 
    IF  ( isp_aggr_MAX_opt in inv_strat.siir_strat_props )
    THEN
        BEGIN
        IF  ( isp_aggr_MAX_opt_reverse in inv_strat.siir_strat_props )
        THEN
            xt02xname (term, protfile, 'MAX opt as MIN opt')
        ELSE
            xt02xname (term, protfile, 'MAX optim         ');
        (*ENDIF*) 
        xt02xint4 (term, protfile, 'MAX recpos  ', inv_strat.siir_MAX_recpos );
        END;
    (*ENDIF*) 
    IF  ( isp_pure_inv_output in inv_strat.siir_strat_props )
    THEN
        xt02xname (term, protfile, 'pure_inv_output   ' );
    (*ENDIF*) 
    IF  ( isp_aggr_optim in inv_strat.siir_strat_props )
    THEN
        xt02xname (term, protfile, 'aggregation optim ' );
    (*ENDIF*) 
    IF  ( isp_aggr_key_MIN_opt in inv_strat.siir_strat_props )
    THEN
        xt02xname (term, protfile, 'key MIN optim     ' );
    (*ENDIF*) 
    IF  ( isp_aggr_key_MAX_opt in inv_strat.siir_strat_props )
    THEN
        xt02xname (term, protfile, 'key MAX optim     ' );
    (*ENDIF*) 
    IF  ( isp_first_row_start in inv_strat.siir_strat_props )
    THEN
        xt02xname (term, protfile, 'first row start   ' );
    (*ENDIF*) 
    IF  ( isp_first_row_stop in inv_strat.siir_strat_props )
    THEN
        xt02xname (term, protfile, 'first row stop    ' );
    (*ENDIF*) 
    IF  ( isp_keysubset in inv_strat.siir_strat_props )
    THEN
        xt02xname (term, protfile, 'idx is key subset ');
    (*ENDIF*) 
    IF  ( isp_unused23 in inv_strat.siir_strat_props )
    THEN
        xt02xsname (term, protfile, 'unused23    ');
    (*ENDIF*) 
    IF  ( isp_unused24 in inv_strat.siir_strat_props )
    THEN
        xt02xsname (term, protfile, 'unused24    ');
    (*ENDIF*) 
    IF  ( isp_unused25 in inv_strat.siir_strat_props )
    THEN
        xt02xsname (term, protfile, 'unused25    ');
    (*ENDIF*) 
    IF  ( isp_unused26 in inv_strat.siir_strat_props )
    THEN
        xt02xsname (term, protfile, 'unused26    ');
    (*ENDIF*) 
    IF  ( isp_unused27 in inv_strat.siir_strat_props )
    THEN
        xt02xsname (term, protfile, 'unused27    ');
    (*ENDIF*) 
    IF  ( isp_unused30 in inv_strat.siir_strat_props )
    THEN
        xt02xsname (term, protfile, 'unused30    ');
    (*ENDIF*) 
    IF  ( isp_unused31 in inv_strat.siir_strat_props )
    THEN
        xt02xsname (term, protfile, 'unused31    ');
    (*ENDIF*) 
    IF  ( isp_unused32 in inv_strat.siir_strat_props )
    THEN
        xt02xsname (term, protfile, 'unused32    ');
    (*ENDIF*) 
    IF  ( isp_unused33 in inv_strat.siir_strat_props )
    THEN
        xt02xsname (term, protfile, 'unused33    ');
    (*ENDIF*) 
    IF  ( isp_unused34 in inv_strat.siir_strat_props )
    THEN
        xt02xsname (term, protfile, 'unused34    ');
    (*ENDIF*) 
    IF  ( isp_unused35 in inv_strat.siir_strat_props )
    THEN
        xt02xsname (term, protfile, 'unused35    ');
    (*ENDIF*) 
    IF  ( isp_unused36 in inv_strat.siir_strat_props )
    THEN
        xt02xsname (term, protfile, 'unused36    ');
    (*ENDIF*) 
    IF  ( isp_unused37 in inv_strat.siir_strat_props )
    THEN
        xt02xsname (term, protfile, 'unused37    ');
    (*ENDIF*) 
    xt02xoutput_colposarr_ex( term, protfile, 'inv start   ',
          inv_strat.siir_invstart, inv_strat.siir_startcnt );
    xt02xoutput_colposarr_ex( term, protfile, 'inv stop    ',
          inv_strat.siir_invstop, inv_strat.siir_stopcnt );
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xInvColSet (
            VAR term     : tut_terminal;
            VAR protfile : tut_vf_fileref;
            nam          : tsp00_Sname;
            invcolset    : tgg07_InvColSet);
 
VAR
      _ix       : tsp00_Int2;
      _ln_len   : integer;
      _line     : tsp00_Line;
 
BEGIN
_line   := term.blankline;
_ln_len := 0;
g17sname_to_line( nam, _ln_len, _line );
_ln_len := sizeof( nam ) + 2;
_line[ _ln_len ] := ':';
_ln_len := _ln_len + 2;
IF  ( invcolset = [] )
THEN
    BEGIN
    g17sname_to_line( 'EMPTY       ', _ln_len, _line );
    END
ELSE
    FOR _ix := 1 TO MAX_COL_SEQUENCE_GG00 DO
        BEGIN
        IF  ( _ix in invcolset )
        THEN
            BEGIN
            g17trimint4_to_line( _ix, _ln_len, _line );
            _ln_len := succ( _ln_len );
            IF  ( _ln_len > 70 ) AND ( _ix < MAX_COL_SEQUENCE_GG00 )
            THEN
                BEGIN
                xt02xwrite_line (term, protfile, _line );
                _line   := term.blankline;
                _ln_len := sizeof( nam ) + 4;
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
(*ENDIF*) 
xt02xwrite_line (term, protfile, _line );
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xoutput_keystrat(
            VAR term     : tut_terminal;
            VAR protfile : tut_vf_fileref;
            nam           : tsp00_Sname;
            VAR key_strat : tgg07_StrKeyInRange);
 
VAR
      _ln_len   : integer;
      _line     : tsp00_Line;
 
BEGIN
_line   := term.blankline;
_ln_len := 0;
g17sname_to_line( nam, _ln_len, _line );
_ln_len := sizeof( nam ) + 2;
_line[ _ln_len ] := ':';
_ln_len := _ln_len + 2;
xt02xwrite_line (term, protfile, _line );
xt02xname (term, protfile, '------------------');
IF  ( ksp_auto_distinct in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'auto distinc' );
(*ENDIF*) 
IF  ( ksp_exact_match in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'exact match ' );
(*ENDIF*) 
IF  ( ksp_exact_IN_SUBQ_match in key_strat.skir_strat_props )
THEN
    xt02xname (term, protfile, 'exact INSUBQ match' );
(*ENDIF*) 
IF  ( ksp_order_support in key_strat.skir_strat_props )
THEN
    BEGIN
    IF  ( ksp_order_support_reverse in key_strat.skir_strat_props )
    THEN
        xt02xsname (term, protfile, 'reverse     ' );
    (*ENDIF*) 
    xt02xname (term, protfile, 'key order support ' );
    END;
(*ENDIF*) 
IF  ( ksp_aggr_MIN_opt in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'MIN optim   ');
(*ENDIF*) 
IF  ( ksp_aggr_MAX_opt in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'MAX optim   ');
(*ENDIF*) 
IF  ( ksp_first_row_start in key_strat.skir_strat_props )
THEN
    xt02xname (term, protfile, 'first row start   ' );
(*ENDIF*) 
IF  ( ksp_first_row_stop in key_strat.skir_strat_props )
THEN
    xt02xname (term, protfile, 'first row stop    ' );
(*ENDIF*) 
IF  ( ksp_unused11 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused11    ');
(*ENDIF*) 
IF  ( ksp_unused12 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused12    ');
(*ENDIF*) 
IF  ( ksp_unused13 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused13    ');
(*ENDIF*) 
IF  ( ksp_unused14 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused14    ');
(*ENDIF*) 
IF  ( ksp_unused15 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused15    ');
(*ENDIF*) 
IF  ( ksp_unused16 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused16    ');
(*ENDIF*) 
IF  ( ksp_unused17 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused17    ');
(*ENDIF*) 
IF  ( ksp_unused20 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused20    ');
(*ENDIF*) 
IF  ( ksp_unused21 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused21    ');
(*ENDIF*) 
IF  ( ksp_unused22 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused22    ');
(*ENDIF*) 
IF  ( ksp_unused23 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused23    ');
(*ENDIF*) 
IF  ( ksp_unused24 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused24    ');
(*ENDIF*) 
IF  ( ksp_unused25 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused25    ');
(*ENDIF*) 
IF  ( ksp_unused26 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused26    ');
(*ENDIF*) 
IF  ( ksp_unused27 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused27    ');
(*ENDIF*) 
IF  ( ksp_unused30 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused30    ');
(*ENDIF*) 
IF  ( ksp_unused31 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused31    ');
(*ENDIF*) 
IF  ( ksp_unused32 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused32    ');
(*ENDIF*) 
IF  ( ksp_unused33 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused33    ');
(*ENDIF*) 
IF  ( ksp_unused34 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused34    ');
(*ENDIF*) 
IF  ( ksp_unused35 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused35    ');
(*ENDIF*) 
IF  ( ksp_unused36 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused36    ');
(*ENDIF*) 
IF  ( ksp_unused37 in key_strat.skir_strat_props )
THEN
    xt02xsname (term, protfile, 'unused37    ');
(*ENDIF*) 
xt02xcolposarr( term, protfile, 'key start   ', key_strat.skir_keystart );
xt02xcolposarr( term, protfile, 'key stop    ', key_strat.skir_keystop );
xt02xint4 (term, protfile, 'IN/SUBQ st  ', key_strat.skir_IN_SUBQ_stpos );
xt02xint4 (term, protfile, 'IN elem cnt ', key_strat.skir_inelemcnt );
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xjoininfo (
            VAR term        : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            VAR getrec      : tgg07_get_param);
 
VAR
      _j     : integer;
      _k     : integer;
      _ln    : tsp00_Line;
      _lnln  : integer;
      _nam   : tsp00_Sname;
 
BEGIN
xt02xname (term, protfile, 'JOIN INFORMATION: ');
xt02xname (term, protfile, 'gi_result_info :  ');
xt02xtreeid (term, protfile, 'o_tree      ', getrec.gi_result_info.o_tree );
xt02xp2int4 (term, protfile, 'n_rec_len   ', getrec.gi_result_info.n_rec_len,
      'n_key_len   ', getrec.gi_result_info.n_key_len);
xt02xint4 (term, protfile, 'n_res_rec_le', getrec.gi_result_info.n_res_rec_len);
xt02xsname (term, protfile, '------------');
xt02xname (term, protfile, 'cols to be copied ');
xt02xsname (term, protfile, 'gi_copy_inf:');
xt02xint4 (term, protfile, 'n_j_cnt     ', getrec.gi_copy_info.n_j_cnt);
FOR _j := 1 TO getrec.gi_copy_info.n_j_cnt DO
    BEGIN
    xt02xp2int4 (term, protfile, 'jfrom       ', getrec.gi_copy_info.n_j_arr[ _j ].jfrom,
          'jlen        ', getrec.gi_copy_info.n_j_arr[ _j ].jlen);
    xt02xint4 (term, protfile, 'jto         '  , getrec.gi_copy_info.n_j_arr[ _j ].jto);
    END;
(*ENDFOR*) 
xt02xsname (term, protfile, '------------');
xt02xsname (term, protfile, 'gi_linkrec :');
xt02xp2bool (term, protfile, 'kbjr_right_o', getrec.gi_linkrec.kbjr_right_oj,
      'kbjr_left_oj', getrec.gi_linkrec.kbjr_left_oj);
xt02xint4 (term, protfile, 'trans cnt   ', getrec.gi_linkrec.kbjr_jointrans_cnt);
_nam := 'side        ';
FOR _j := 1 TO getrec.gi_linkrec.kbjr_jointrans_cnt DO
    BEGIN
    FOR _k := 1 TO 2 DO
        BEGIN
        xt02xline_init (term, _nam, _lnln, _ln);
        _lnln := 6;
        g17int4to_line(_k, false, 2, _lnln, _ln);
        xt02xwrite_line (term, protfile, _ln);
        xt02xp2int4 (term, protfile, 'kboj_recpos ', getrec.gi_linkrec.
              kbjr_jarr[ _j ].kbji_parts[ _k ].kboj_recpos,
              'kboj_len    ', getrec.gi_linkrec.
              kbjr_jarr[ _j ].kbji_parts[ _k ].kboj_len);
        IF  _k = 1
        THEN
            xt02xop (term, protfile, 'kboj_op     '  ,
                  getrec.gi_linkrec.kbjr_jarr[ _j ].kbji_parts[ _k ].kboj_op)
        ELSE
            xt02xint4 (term, protfile, 'kboj_op     '  ,
                  ord(getrec.gi_linkrec.kbjr_jarr[ _j ].kbji_parts[ _k ].kboj_op))
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    END;
(*ENDFOR*) 
xt02xsname (term, protfile, '------------');
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02xop (
            VAR term        : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            nam             : tsp00_Sname;
            op              : tgg00_StackOpType);
 
VAR
      len      : integer;
      ln_len   : integer;
      n        : tsp00_Sname;
      ln       : tsp00_Line;
 
BEGIN
xt02xline_init (term, nam, ln_len, ln);
g17st1op (op, len, n);
SAPDB_PascalForcedMove ( sizeof (n), sizeof (ln), @n, 1, @ln, ln_len + 2, len );
xt02xwrite_line (term, protfile, ln);
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_ak_join (
            VAR d         : t_DisplState;
            VAR trace     : trace_record);
 
VAR
      ok               : boolean;
      ln_len           : integer;
      sn               : tsp00_Sname;
      ln               : tsp00_Line;
 
BEGIN
ln               := d.dsTerm^.blankline;
ln_len           := LINE_FUNCT_INDENT;
ok               := true;
CASE trace.trceHead.vhType_gg11 OF
    vttAccessOperator_egg00:
        BEGIN
        sn := 'AccessOp    ';
        END;
    vttOperatorJoin_egg00:
        BEGIN
        sn := 'JoinOp      ';
        END;
    OTHERWISE
        BEGIN
        ok := false;
        xt02print_unknown (d, trace)
        END
    END;
(*ENDCASE*) 
IF  ok
THEN
    BEGIN
    g17sname_to_line (sn, ln_len, ln);
    ln_len := ln_len + 1;
    CASE trace.trceHead.vhType_gg11 OF
        vttAccessOperator_egg00,
        vttOperatorJoin_egg00:
            xt02print_join_function (d, trace, ln_len, ln);
        OTHERWISE ;
        END;
    (*ENDCASE*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt02print_join_function (
            VAR d      : t_DisplState;
            VAR trace  : trace_record;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
VAR
      tabno       : integer;
      err         : integer;
      moveobj_ptr : tsp00_MoveObjPtr;
 
BEGIN
IF  ( trace.trceJoin.jtType_gg11 in [ jntrCtor_gg11, jntrDtor_gg11 ] )
THEN
    BEGIN
    xt02sess_trans_to_line (trace, ln_len, ln);
    ln_len := ln_len + 1;
    xt02mess_types_to_line (trace.trceJoin.jtHead_gg11.kbMessType_gg11,
          trace.trceJoin.jtHead_gg11.kbMessType2_gg11, ln_len, ln);
    END;
(*ENDIF*) 
CASE trace.trceJoin.jtType_gg11 OF
    jntrCtor_gg11 :
        BEGIN
        ln [1] := CALL_FUNCTION_SIGN;
        ln_len := ln_len + 1;
        IF  trace.trceJoin.jtTabId_gg11 = cgg_sys1_catalog_id
        THEN
            g17sname_to_line ('SYS1CAT     ', ln_len, ln)
        ELSE
            IF  trace.trceJoin.jtTabId_gg11 = cgg_sys2_catalog_id
            THEN
                g17sname_to_line ('SYS2CAT     ', ln_len, ln)
            ELSE
                BEGIN
                g17sname_to_line ('TABID       ', ln_len, ln);
                ln_len := ln_len + 1;
                g17surrogate_to_line (trace.trceJoin.jtTabId_gg11, ln_len, ln)
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    jntrDtor_gg11:
        BEGIN
        ln [1] := d.dsLeaveFunctSign [1];
        IF  trace.trceJoin.jtHead_gg11.kbMessType_gg11 <> m_return_result
        THEN
            xt02_BasisError (trace.trceJoin.jtHead_gg11.kbError_gg11, ln_len, ln);
        (*ENDIF*) 
        END;
    jntrOpen_gg11:
        BEGIN
        ln [1] := CALL_FUNCTION_SIGN;
        g17sname_to_line ('Open()      ', ln_len, ln)
        END;
    jntrOpen1_gg11:
        BEGIN
        ln [1] := CALL_FUNCTION_SIGN;
        g17sname_to_line ('Open( keys )', ln_len, ln)
        END;
    jntrClose_gg11:
        BEGIN
        ln [1] := CALL_FUNCTION_SIGN;
        g17sname_to_line ('Close()     ', ln_len, ln)
        END;
    jntrSort_gg11:
        BEGIN
        ln [1] := CALL_FUNCTION_SIGN;
        g17sname_to_line ('Sorting     ', ln_len, ln)
        END;
    jntrLegacy_gg11:
        BEGIN
        ln [1] := CALL_FUNCTION_SIGN;
        g17nameto_line ('Create result     ', ln_len, ln)
        END;
    OTHERWISE
        BEGIN
        END;
    END;
(*ENDCASE*) 
IF  trace.trceHead.vhType_gg11 = vttAccessOperator_egg00
THEN
    BEGIN
    tabno  := trace.trceJoin.jtTabno_gg11;
    g17sname_to_line (' TabNo      ', ln_len, ln);
    ln_len := ln_len + 1;
    g17int4to_line( tabno, true, 3, ln_len+1, ln);
    ln_len := ln_len + 3;
    END;
(*ENDIF*) 
t12write_prot (d.dsProt^, ln, ln_len, err);
t09put (d.dsTerm^, ln, cut_protected);
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
