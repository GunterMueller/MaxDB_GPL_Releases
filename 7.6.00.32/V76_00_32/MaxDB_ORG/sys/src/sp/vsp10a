.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 1988-2005 SAP AG-2001$$Page %$
.tm 12
.hm 6
.hs 3
.tt 1 $NME$Project Distributed Database System$VSP10A$
.tt 2 $$$
.tt 3 $$Laufzeitumgebung_Pascalerweiterungen$1995-12-07$
***********************************************************
.nf

.nf

.nf

    ========== licence begin  GPL
    Copyright (c) 1988-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo


.fo


.fo
.nf
.sp
Module  : Laufzeitumgebung_Pascalerweiterungen_10
=========
.sp
Purpose : move   s10mv mit sizecheck
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :

        PROCEDURE
              s10fil (size : integer;
                          VAR m : moveobject;
                          pos : integer;
                          len : integer;
                          fillchar : char);

        PROCEDURE
              s10fil1 (size : integer;
                          VAR m : moveobject;
                          pos : integer;
                          len : integer;
                          fillchar : char);

        PROCEDURE
              s10fil2 (size : integer;
                          VAR m : moveobject;
                          pos : integer;
                          len : integer;
                          fillchar : char);

        PROCEDURE
              s10fil3 (size : integer;
                          VAR m : moveobject;
                          pos : integer;
                          len : integer;
                          fillchar : char);

        PROCEDURE
              s10fil4 (size : integer;
                          VAR m : moveobject;
                          pos : integer;
                          len : integer;
                          fillchar : char);

        PROCEDURE
              s10fil5 (size : integer;
                          VAR m : moveobject;
                          pos : integer;
                          len : integer;
                          fillchar : char);

        PROCEDURE
              s10fil6 (size : integer;
                          VAR m : moveobject;
                          pos : integer;
                          len : integer;
                          fillchar : char);

        PROCEDURE
              s10mvc (size1 : int4; size2 : int4;
                          VAR val1 : takcachebuf; p1 : int4;
                          VAR val2 : takcachebuf; p2  :int4;
                          anz: int4);

        PROCEDURE
              s10mv (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv1 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv2 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv3 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv4 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv5 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv6 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv7 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv8 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv9 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv10 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv11 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv12 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv13 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv14 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv15 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv16 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv17 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv18 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv19 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv20 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv21 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv22 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv23 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv24 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv25 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv26 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv27 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv28 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv29 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mv30 (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2  :integer;
                          anz: integer);

        PROCEDURE
              s10mvr (size1 : integer; size2 : integer;
                          VAR val1 : moveobject; p1 : integer;
                          VAR val2 : moveobject; p2 : integer;
                          anz : integer);

        FUNCTION
              sp10a24 : int4;

.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :

.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :

.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1979-06-07
.sp
.cp 3
Version : 1995-04-10
.sp
.cp 3
Release :  6.1.2 	 Date : 1995-12-07
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:

Die Positionsangabe POS gibt das erste Byte des betroffenen Feldes an.
Das erste Byte im Puffer ist durch POS = 1 ansprechbar.
.sp 2
PROCEDURE  S10FIL:
.sp 1
Ein Moveobject m wird ab der Position pos mit fillchar
von der L?ange len belegt. Bei len <= 0 wird nichts gef?ullt.
Es wird gepr?uft, ob die Position plus len die  Movegrenzen
nicht ?uberschreitet.
.sp 4
PROCEDURE  S10MV..:
.sp
Moved die Strings von links nach rechts, und checked
die Sizebereiche.(d.h. die hinteren Bytes
werden zuerst verschoben)
.sp
.nf
   size1  : gibt die maximale L?ange des Sourceobject an
   size2  : gibt die maximale L?ange des Destinationobjects an.
   val1   : Sourceobject
   val2   : Destinationobject
   p1     : erste Position im val1, ab der verschoben werden soll
   p2     : erste Position in val2, wohin geschoben werden soll
   anz    : Anzahl der Bytes um die geschoben werdeb soll
.sp
Es wird gepr?uft, ob die Positionen und Movegrenzen f?ur
val1 und val2 nicht ?uberschritten werden und,
ob die Anzahl der zuverschiebenden Bytes > 0 ist.
.sp 2
   S10MVC  ist f?ur ein move des Cachebuffer (maxcachelength)
          (ca. 11 buffer).
.sp 4
PROCEDURE  S10MVR :
.sp
Moved die Strings von rechts nach links, und checked
die Sizebereiche.
.sp
.nf
   size1  : gibt die maximale L?ange des Sourceobject an
   size2  : gibt die maximale L?ange des Destinationobjects an.
   val1   : Sourceobject
   val2   : Destinationobject
   p1     : erste Position im val1, ab der verschoben werden soll
   p2     : erste Position in val2, wohin geschoben werden soll
   anz    : Anzahl der Bytes um die geschoben werdeb soll
.sp
Es wird gepr?uft, ob die Positionen und Movegrenzen f?ur
val1 und val2 nicht ?uberschritten werden und,
ob die Anzahl der zuverschiebenden Bytes > 0 ist.
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:


.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:

(*------------------------------*)

PROCEDURE
      s10fil (size : integer;
                  VAR m : moveobject;
                  pos : integer;
                  len : integer;
                  fillchar : char);

VAR
      i : integer;

BEGIN
IF   (pos+len-1 > size) OR
            (pos < 0) OR (len < 0)
THEN
     BEGIN
     i := 0;
     i := pos DIV i;
     END
ELSE
     FOR i := 1 TO len DO
         m [pos+i-1 ] := fillchar;
     (*ENDFOR*)
(*ENDIF*)
END;

(*------------------------------*)

PROCEDURE
      s10mvc (size1 : int4; size2 : int4;
                  VAR val1 : takcachebuf; p1 : int4;
                  VAR val2 : takcachebuf; p2  :int4;
                  anz: int4);

VAR
      i : int4;
      n : int4;
      i1 : int4;
      n1 : int4;
      i2 : int4;
      n2 : int4;

BEGIN
n := anz - 1;
IF   (p1+n > size1) OR (p2+n > size2) OR (anz < 0)
            OR (p1 <= 0) OR (p2 <= 0)
THEN
     BEGIN
     i := 0;
     i := p1 DIV i;
     END
ELSE
     BEGIN
     i1 := (p1 DIV maxbufferlength) + 1;
     n1 :=  p1 MOD maxbufferlength;
     IF   n1 = 0
     THEN
          n1 := maxbufferlength;
     (*ENDIF*)
     i2 := (p2 DIV maxbufferlength) + 1;
     n2 :=  p2 MOD maxbufferlength;
     IF   n2 = 0
     THEN
          n2 := maxbufferlength;
     (*ENDIF*)
     FOR i := 1  TO  anz  DO
         BEGIN
         val2 [i2,n2 ] := val1 [i1,n1] ;
         n2 := n2 + 1;
         IF   n2 > maxbufferlength
         THEN
              BEGIN
              n2 := 1;
              i2 := i2 + 1;
              END;
         (*ENDIF*)
         n1 := n1 + 1;
         IF   n1 > maxbufferlength
         THEN
              BEGIN
              n1 := 1;
              i1 := i1 + 1;
              END;
         (*ENDIF*)
         END;
     (*ENDFOR*)
     END;
(*ENDIF*)
END;

(*------------------------------*)

PROCEDURE
      s10mv (size1 : integer; size2 : integer;
                  VAR val1 : moveobject; p1 : integer;
                  VAR val2 : moveobject; p2  :integer;
                  anz: integer);

VAR
      i : integer;
      n : integer;

BEGIN
n := anz - 1;
IF   (p1+n > size1) OR (p2+n > size2) OR (anz < 0)
            OR (p1 <= 0) OR (p2 <= 0)
THEN
     BEGIN
     i := 0;
     i := p1 DIV i;
     END
ELSE
     FOR i:=0 TO n DO
         val2 [p2+i ] := val1 [p1+i] ;
     (*ENDFOR*)
(*ENDIF*)
END;

(*------------------------------*)

PROCEDURE
      s10mvr (size1 : integer; size2 : integer;
                  VAR val1 : moveobject; p1 : integer;
                  VAR val2 : moveobject; p2 : integer;
                  anz : integer);

VAR
      i : integer;
      n : integer;

BEGIN
n := anz - 1;
IF   (p1+n > size1) OR (p2+n > size2) OR (anz < 0)
            OR (p1 <= 0) OR (p2 <= 0)
THEN
     BEGIN
     i := 0;
     i := p1 DIV i;
     END
ELSE
     FOR i := anz-1  DOWNTO 0 DO
         val2 [p2+i ] := val1 [p1+i] ;
     (*ENDFOR*)
(*ENDIF*)
END;

.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :

&if $MACH = T35
#=========================================================

        .data   0
        .text   0
        .globl  _sp10a24
_sp10a24:
        movw    $926190817,pr0
        ret

#=========================================================

                .text
                .globl  _s10fil
                .globl  _s10fil1
                .globl  _s10fil2
                .globl  _s10fil3
                .globl  _s10fil4
                .globl  _s10fil5
                .globl  _s10fil6
_s10fil:
_s10fil1:
_s10fil2:
_s10fil3:
_s10fil4:
_s10fil5:
_s10fil6:
                movw    $0,lr0          # clear i
                movw    pr2,pr5
                addw    pr3,pr5
                subw    $1,pr5
                cmpw    pr0,pr5         # (pos + len - 1) - size ??
                bfc     nz,_fill_crash
                mtstw   pr2,pr2         # pos ??
                btc     n,_fill_crash
                mtstw   pr3,pr3         # len ??
                bfc     n,_fill_work
_fill_crash:    movw    $0,lr0          # zero divide for crash
                movw    pr2,pr5
                divw    lr0,pr5
                movw    pr5,lr0
                br      _fill_return
_fill_work:     movw    pr3,lr1
                cmpw    $1,lr1
                btc     n,_fill_return
                movw    $1,lr0
                mova    0xffffffff(pr1),pr5
                addw    pr2,pr5         # pr5 := addr (m [pos])
_fill_loop:     cvtwb   pr4,(pr5)
                cmpw    lr1,lr0
                btc     z,_fill_return
                addw    $1,lr0
                addw    $1,pr5          # pr5 := addr (next byte)
                br      _fill_loop
_fill_return:   ret

#============================================================================

                .globl  _s10mv
                .globl  _s10mv1
                .globl  _s10mv2
                .globl  _s10mv3
                .globl  _s10mv4
                .globl  _s10mv5
                .globl  _s10mv6
                .globl  _s10mv7
                .globl  _s10mv8
                .globl  _s10mv9
                .globl  _s10mv10
                .globl  _s10mv11
                .globl  _s10mv12
                .globl  _s10mv13
                .globl  _s10mv14
                .globl  _s10mv15
                .globl  _s10mv16
                .globl  _s10mv17
                .globl  _s10mv18
                .globl  _s10mv19
                .globl  _s10mv20
                .globl  _s10mv21
                .globl  _s10mv22
                .globl  _s10mv23
                .globl  _s10mv24
                .globl  _s10mv25
                .globl  _s10mv26
                .globl  _s10mv27
                .globl  _s10mv28
                .globl  _s10mv29
                .globl  _s10mv30
_s10mv:
_s10mv1:
_s10mv2:
_s10mv3:
_s10mv4:
_s10mv5:
_s10mv6:
_s10mv7:
_s10mv8:
_s10mv9:
_s10mv10:
_s10mv11:
_s10mv12:
_s10mv13:
_s10mv14:
_s10mv15:
_s10mv16:
_s10mv17:
_s10mv18:
_s10mv19:
_s10mv20:
_s10mv21:
_s10mv22:
_s10mv23:
_s10mv24:
_s10mv25:
_s10mv26:
_s10mv27:
_s10mv28:
_s10mv29:
_s10mv30:

                movw    $0,lr0          # clear n, i
                movw    $0,lr1
                mova    0xffffffff(pr6),lr1 # n := anz - 1 ;
                movw    pr3,pr7
                addw    lr1,pr7
                cmpw    pr0,pr7         # (p1+n) - size ??
                bfc     nz,_movc_crash
                movw    pr5,pr7
                addw    lr1,pr7
                cmpw    pr1,pr7         # (p2+n) - size ??
                bfc     nz,_movc_crash
                mtstw   pr6,pr6         # anz < 0  ??
                btc     n,_movc_crash
                mtstw   pr3,pr3         # p1  < 0  ??
                btc     nz,_movc_crash
                mtstw   pr5,pr5         # p2  < 0  ??
                bfc     nz,_movc_work
_movc_crash:    movw    $0,lr0          # zero divide for crash
                movw    pr3,pr7
                divw    lr0,pr7
                movw    pr7,lr0
                halt
_movc_work:     mtstw   lr1,lr2         # n     ??
                btc     n,_movc_return
                movw    $0,lr0          # i := 0
                movw    pr4,pr7
                addw    pr5,pr7
                subw    $1,pr7          # pr7 := addr (val2 [p2])
                movw    pr2,pr8
                addw    pr3,pr8
                subw    $1,pr8          # pr8 := addr (val1 [p1])
                movw    pr7,tr0         # destination
                movw    pr8,tr1         # source
                movw    pr6,tr2         # anz
                call    _memcpy,tr14
_movc_return:   ret

#============================================================================
                .globl  _s10mvr
_s10mvr:         movw    $0,lr0          # clear n, i
                movw    $0,lr1
                mova    0xffffffff(pr6),lr1 # n := anz - 1 ;
                movw    pr3,pr7
                addw    lr1,pr7
                cmpw    pr0,pr7         # (p1+n) - size ??
                bfc     nz,_movcr_crash
                movw    pr5,pr7
                addw    lr1,pr7
                cmpw    pr1,pr7         # (p2+n) - size ??
                bfc     nz,_movcr_crash
                mtstw   pr6,pr6         # anz ??
                btc     n,_movcr_crash
                mtstw   pr3,pr3         # p1 ??
                btc     nz,_movcr_crash
                mtstw   pr5,pr5         # p2 ??
                bfc     nz,_movcr_work
_movcr_crash:   movw    $0,lr0          # zero divide for crash
                movw    pr3,pr7
                divw    lr0,pr7
                movw    pr7,lr0
                halt
_movcr_work:    mtstw   lr1,lr0         # i := n ; i ??
                btc     n,_movcr_return
                movw    pr4,pr7
                addw    pr5,pr7
                addw    lr0,pr7
                subw    $1,pr7          # pr7 := addr (val2 [p2+i])
                movw    pr2,pr8
                addw    pr3,pr8
                addw    lr0,pr8
                subw    $1,pr8          # pr8 := addr (val1 [p1+i])
_movcr_loop:    movb    (pr8),(pr7)
                mtstw   lr0,lr0         # i = 0 ??
                btc     z,_movcr_return
                subw    $1,lr0
                subw    $1,pr7          # pr7 := addr (prev byte)
                subw    $1,pr8          # pr8 :=   "    "    "
                br      _movcr_loop
_movcr_return:  ret

                .globl  _s10mvc
#       PROCEDURE
#             s10mvc (size1 : int4 { pr0 } ; size2 : int4 { pr1 } ;
#                         VAR val1 : takcachebuf { pr2 } ; p1 : int4 { pr3 } ;
#                         VAR val2 : takcachebuf { pr4 } ; p2 : int4 { pr5 } ;
#                         anz: int4 { pr6 } );
#       VAR
#             i : int4  { lr0 } ;             n : int4  { lr1 } ;
#             i1 : int4 { lr2 } ;             n1 : int4 { lr3 } ;
#             i2 : int4 { lr4 } ;             n2 : int4 { lr5 } ;
#                                       BEGIN
#                                       n := anz - 1;
_s10mvc:         mova    0xffffffff(pr6),lr1
#                                       IF   (p1+n > size1)
                movw    pr3,pr7
                addw    lr1,pr7
                cmpw    pr0,pr7
                bfc     nz,_movcc_crash
#                                                   OR (p2+n > size2)
                movw    pr5,pr7
                addw    lr1,pr7
                cmpw    pr1,pr7
                bfc     nz,_movcc_crash
#                                                             OR (anz < 0)
                mtstw   pr6,pr6
                btc     n,_movcc_crash
#                                                   OR (p1 <= 0)
                mtstw   pr3,pr3
                btc     nz,_movcc_crash
#                                                        OR (p2 <= 0)
                mtstw   pr5,pr5
                bfc     nz,_movcc_work
#                                       THEN
_movcc_crash:
#                                            BEGIN
#                                            i := 0;
                movw    $0,lr0
#                                            i := p1 DIV i;
                movw    pr3,pr7
                divw    lr0,pr7
                movw    pr7,lr0
#                                            halt;
                halt
#                                            END;
_movcc_work:
#
                movw    pr2,lr1
                addw    pr3,lr1
                subw    $1,lr1          # lr1 := addr ( val1 [p1] );
#
                movw    pr4,lr2
                addw    pr5,lr2
                subw    $1,lr2          # lr2 := addr ( val2 [p2] );
#
#                                       FOR i := 1  TO  anz  DO
                movw    pr6,lr6
                cmpw    $1,lr6
                btc     n,_movcc_return
                movw    $1,lr0
#                                           BEGIN
#                                           mem [ lr2 ] := mem [ lr1 ] ;
_movcc_copy:    movb    (lr1),(lr2)
#                                           lr1 := succ ( lr1 );
                addw    $1,lr1
#                                           lr2 := succ ( lr2 );
                addw    $1,lr2
#                                           END;
                cmpw    lr6,lr0
                btc     z,_movcc_return
                addw    $1,lr0
                br      _movcc_copy
#                                       END;
_movcc_return:  ret
&endif /* T35 */

&if $MACH in [ I386 ]
	.file   "vsp10a.s"
	.text

/============================================================================/
/
/       fill
/
/       PROCEDURE
/             fill (size : integer;
/                         VAR m : moveobject;
/                         pos : integer;
/                         len : integer;
/                         fillchar : char);
/
	.globl  s10fil
	.globl  s10fil1
	.globl  s10fil2
	.globl  s10fil3
	.globl  s10fil4
	.globl  s10fil5
	.globl  s10fil6
s10fil:
s10fil1:
s10fil2:
s10fil3:
s10fil4:
s10fil5:
s10fil6:

	pushl   %ebp                    / build stack frame
	movl    %esp, %ebp
	subl    $8, %esp
	pushl   %edi                    / save register

F_PARMPOS       =       8

F_SIZE          =       F_PARMPOS
F_M             =       F_PARMPOS + 4
F_POS           =       F_PARMPOS + 8
F_LEN           =       F_PARMPOS + 12
F_FILLCHAR      =       F_PARMPOS + 16

	movl    F_LEN(%ebp), %ecx       / get length
	movl    $0, -8(%ebp)            / lower bound 0
	movl    $0x7fffffff, -4(%ebp)   / upper bound maxint4
	bound   -8(%ebp), %ecx          / check bounds

	decl    %ecx                    / decrement length; set cond. flags
	jl      fill_leave              / LEN = 0 : nothing to do

/       check buffer boundaries

	movl    $1, -8(%ebp)            / lower bound always 1
	movl    F_SIZE(%ebp), %eax      / get upper bound
	movl    %eax, -4(%ebp)          / upper bound

	movl    F_POS(%ebp), %eax       / get position
	bound   -8(%ebp), %eax          / check bounds

	addl    %ecx, %eax              / pos + len - 1
	bound   -8(%ebp), %eax          / check bounds

/       fill

	movl    F_M(%ebp), %edi         / get buffer address
	addl    F_POS(%ebp), %edi       / compute start address
	decl    %edi                    / correct for start pos = 1

	incl    %ecx                    / undo decrement of length
	movb    F_FILLCHAR(%ebp), %al   / get fillchar
	cld                             / set direction to forward
	rep                             / repeat the following instruction
					/ %ecx times
	sstob                           / store %al to (%edi), update %edi

fill_leave:

	popl    %edi                    / restore register
	leave                           / remove stack frame
	ret

/============================================================================/
/
/       s10mvc
/       s10mv
/
/       PROCEDURE
/             s10mvc (size1 : int4; size2 : int4;
/                         VAR val1 : takcachebuf; p1 : int4;
/                         VAR val2 : takcachebuf; p2  :int4;
/                         anz: int4);
/
/       PROCEDURE
/             s10mv (size1 : integer; size2 : integer;
/                         VAR val1 : moveobject; p1 : integer;
/                         VAR val2 : moveobject; p2  :integer;
/                         anz: integer);
/
	.globl  s10mvc
	.globl  s10mv
	.globl  s10mv1
	.globl  s10mv2
	.globl  s10mv3
	.globl  s10mv4
	.globl  s10mv5
	.globl  s10mv6
	.globl  s10mv7
	.globl  s10mv8
	.globl  s10mv9
	.globl  s10mv10
	.globl  s10mv11
	.globl  s10mv12
	.globl  s10mv13
	.globl  s10mv14
	.globl  s10mv15
	.globl  s10mv16
	.globl  s10mv17
	.globl  s10mv18
	.globl  s10mv19
	.globl  s10mv20
	.globl  s10mv21
	.globl  s10mv22
	.globl  s10mv23
	.globl  s10mv24
	.globl  s10mv25
	.globl  s10mv26
	.globl  s10mv27
	.globl  s10mv28
	.globl  s10mv29
	.globl  s10mv30
s10mvc:
s10mv:
s10mv1:
s10mv2:
s10mv3:
s10mv4:
s10mv5:
s10mv6:
s10mv7:
s10mv8:
s10mv9:
s10mv10:
s10mv11:
s10mv12:
s10mv13:
s10mv14:
s10mv15:
s10mv16:
s10mv17:
s10mv18:
s10mv19:
s10mv20:
s10mv21:
s10mv22:
s10mv23:
s10mv24:
s10mv25:
s10mv26:
s10mv27:
s10mv28:
s10mv29:
s10mv30:

	pushl   %ebp                    / build stack frame
	movl    %esp, %ebp
	subl    $8, %esp
	pushl   %edi                    / save register
	pushl   %esi                    / save register

MC_PARMPOS      =       8

MC_SIZE1        =       MC_PARMPOS
MC_SIZE2        =       MC_PARMPOS + 4
MC_VAL1         =       MC_PARMPOS + 8
MC_P1           =       MC_PARMPOS + 12
MC_VAL2         =       MC_PARMPOS + 16
MC_P2           =       MC_PARMPOS + 20
MC_ANZ          =       MC_PARMPOS + 24

	movl    MC_ANZ(%ebp), %ecx      / get length
	movl    $0, -8(%ebp)            / lower bound 0
	movl    $0x7fffffff, -4(%ebp)   / upper bound maxint4
	bound   -8(%ebp), %ecx          / check bounds

	decl    %ecx                    / decrement length; set cond. flags
	jl      movcc_leave             / ANZ = 0 : nothing to do

/       check buffer1 boundaries

	movl    $1, -8(%ebp)            / lower bound always 1
	movl    MC_SIZE1(%ebp), %eax    / get upper bound
	movl    %eax, -4(%ebp)          / upper bound

	movl    MC_P1(%ebp), %eax       / get position
	bound   -8(%ebp), %eax          / check bounds

	addl    %ecx, %eax              / pos + len - 1
	bound   -8(%ebp), %eax          / check bounds

/       check buffer2 boundaries

	movl    $1, -8(%ebp)            / lower bound always 1
	movl    MC_SIZE2(%ebp), %eax    / get upper bound
	movl    %eax, -4(%ebp)          / upper bound

	movl    MC_P2(%ebp), %eax       / get position
	bound   -8(%ebp), %eax          / check bounds

	addl    %ecx, %eax              / pos + len - 1
	bound   -8(%ebp), %eax          / check bounds

/       move

	movl    MC_VAL1(%ebp), %esi     / get buffer address
	addl    MC_P1(%ebp), %esi       / compute start address
	decl    %esi                    / correct for start pos = 1

	movl    MC_VAL2(%ebp), %edi     / get buffer address
	addl    MC_P2(%ebp), %edi       / compute start address
	decl    %edi                    / correct for start pos = 1

	incl    %ecx                    / undo decrement of length
	cld                             / set direction to forward
	rep                             / repeat the following instruction
					/ %ecx times
	smovb                           / move (%esi) to (%edi),
					/ update %esi and %edi

movcc_leave:

	popl    %esi                    / restore register
	popl    %edi                    / restore register
	leave                           / remove stack frame
	ret

/============================================================================/
/
/       s10mvr
/
/       PROCEDURE
/             s10mvr (size1 : integer; size2 : integer;
/                         VAR val1 : moveobject; p1 : integer;
/                         VAR val2 : moveobject; p2 : integer;
/                         anz : integer);
/
	.globl  s10mvr
s10mvr:

	pushl   %ebp                    / build stack frame
	movl    %esp, %ebp
	subl    $8, %esp
	pushl   %edi                    / save register
	pushl   %esi                    / save register

MR_PARMPOS      =       8

MR_SIZE1        =       MR_PARMPOS
MR_SIZE2        =       MR_PARMPOS + 4
MR_VAL1         =       MR_PARMPOS + 8
MR_P1           =       MR_PARMPOS + 12
MR_VAL2         =       MR_PARMPOS + 16
MR_P2           =       MR_PARMPOS + 20
MR_ANZ          =       MR_PARMPOS + 24

	movl    MR_ANZ(%ebp), %ecx      / get length
	movl    $0, -8(%ebp)            / lower bound 0
	movl    $0x7fffffff, -4(%ebp)   / upper bound maxint4
	bound   -8(%ebp), %ecx          / check bounds

	decl    %ecx                    / decrement length; set cond. flags
	jl      movcr_leave             / ANZ = 0 : nothing to do

/       check buffer1 boundaries

	movl    $1, -8(%ebp)            / lower bound always 1
	movl    MR_SIZE1(%ebp), %eax    / get upper bound
	movl    %eax, -4(%ebp)          / upper bound

	movl    MR_P1(%ebp), %eax       / get position
	bound   -8(%ebp), %eax          / check bounds

	addl    %ecx, %eax              / pos + len - 1
	bound   -8(%ebp), %eax          / check bounds

/       check buffer2 boundaries

	movl    $1, -8(%ebp)            / lower bound always 1
	movl    MR_SIZE2(%ebp), %eax    / get upper bound
	movl    %eax, -4(%ebp)          / upper bound

	movl    MR_P2(%ebp), %eax       / get position
	bound   -8(%ebp), %eax          / check bounds

	addl    %ecx, %eax              / pos + len - 1
	bound   -8(%ebp), %eax          / check bounds

/       move

	movl    MR_VAL1(%ebp), %esi     / get buffer address
	addl    MR_P1(%ebp), %esi       / compute start address
	decl    %esi                    / correct for start pos = 1
	addl    %ecx, %esi              / compute end address (+ len - 1)

	movl    MR_VAL2(%ebp), %edi     / get buffer address
	addl    MR_P2(%ebp), %edi       / compute start address
	decl    %edi                    / correct for start pos = 1
	addl    %ecx, %edi              / compute end address (+ len - 1)

	incl    %ecx                    / undo decrement of length
	std                             / set direction to reverse
	rep                             / repeat the following instruction
					/ %ecx times
	smovb                           / move (%esi) to (%edi),
					/ update %esi and %edi
	cld                             / reset direction to forward

movcr_leave:

	popl    %esi                    / restore register
	popl    %edi                    / restore register
	leave                           / remove stack frame
	ret

/============================================================================/
/
/	Link-Check
/
	.globl  sp10a24
sp10a24:

	movl    $926190817 , %eax       / set link check code
	ret
&endif I386

&if $MACH = ALPHA
&ifdef BIT64
	.data
	.align	0
s10mv_fmt:
	.ascii	"%d %d %p %d %p %d %d s10mv ABEND\X0A\X00"
s10mvr_fmt:
	.ascii	"%d %d %p %d %p %d %d s10mvr ABEND\X0A\X00"

	.text
	.align	4
	.globl	s10fil
	.globl	s10fil1
	.globl	s10fil2
	.globl	s10fil3
	.globl	s10fil4
	.globl	s10fil5
	.ent	s10fil
/* void s10fil(size, m, pos, len, fillchar)
 *           int size;
 *           unsigned char *m;
 *           int pos;
 *           int len;
 *           unsigned char fillchar;
 */
s10fil:
s10fil1:
s10fil2:
s10fil3:
s10fil4:
s10fil5:
	ldgp	$gp, 0($27)	# global ptr reg gets addr of this proc
	lda	$sp, -16($sp)	# grow stack
	stq	$26, 0($sp)	# save caller's addr on stack
	.mask	0x04000000, -16
	.frame	$sp, 16, $26, 0
	.prologue	1
	addl	$16, 0, $16	# arg1 $16: int size
				# arg2 $17: unsigned char *m
	addl	$18, 0, $18	# arg3 $18: int pos
	addl	$19, 0, $19	# arg4 $19: int len
	and	$20, 255, $20	# arg5 $20: unsigned char fillchar
				# check args
	addl	$18, -1, $2	# (pos - 1
	addl	$2, $19, $3	#  + len)
	subq	$16, $3, $4	# if size < pos - 1 + len
	blt	$4, s10fil_err	#     goto s10fil_err
	blt	$18, s10fil_err	# if pos < 0 goto s10fil_err
	blt	$19, s10fil_err	# if len < 0 goto s10fil_err
				# prepare args for memset ()
	addq	$2, $17, $16	# (pos - 1) + m
	bis	$20, $20, $17	# fillchar
	bis	$19, $19, $18	# len
	jsr	$26, memset
	ldgp	$gp, 0($26)	# restore global addr ptr
s10fil_ret:			# prepare to return
	ldq	$26, 0($sp)	# restore caller's addr
	lda	$sp, 16($sp)	# restore stack
	ret	$31, ($26), 1	# return to caller
s10fil_err:			# create core dump
	ldil	$5, 1		# m = 0; *m = 1;
	.set	 noat
	ldq_u	$28, 0($31)
	insbl	$5, $31, $6
	mskbl	$28, $31, $28
	bis	$28, $6, $28
	stq_u	$28, 0($31)	# segmentation fault produces core dump
	.set	 at
	br	$31, s10fil_ret	# we never reach this point
	.end	s10fil

	.text
	.align	4
	.globl	s10mv
	.globl	s10mvc
	.globl	s10mv1
	.globl	s10mv2
	.globl	s10mv3
	.globl	s10mv4
	.globl	s10mv5
	.globl	s10mv6
	.globl	s10mv7
	.globl	s10mv8
	.globl	s10mv9
	.globl	s10mv10
	.globl	s10mv11
	.globl	s10mv12
	.globl	s10mv13
	.globl	s10mv14
	.globl	s10mv15
	.globl	s10mv16
	.globl	s10mv17
	.globl	s10mv18
	.globl	s10mv19
	.globl	s10mv20
	.globl	s10mv21
	.globl	s10mv22
	.globl	s10mv23
	.globl	s10mv24
	.globl	s10mv25
	.globl	s10mv26
	.globl	s10mv27
	.globl	s10mv28
	.globl	s10mv29
	.globl	s10mv30
	.ent	s10mv
/* void s10mv(size1, size2, val1, p1, val2, p2, cnt)
 *            int size1;
 *            int size2;
 *            unsigned char *val1;
 *            int p1;
 *            unsigned char *val2;
 *            int p2;
 *            int cnt;
 */
s10mv:
s10mvc:
s10mv1:
s10mv2:
s10mv3:
s10mv4:
s10mv5:
s10mv6:
s10mv7:
s10mv8:
s10mv9:
s10mv10:
s10mv11:
s10mv12:
s10mv13:
s10mv14:
s10mv15:
s10mv16:
s10mv17:
s10mv18:
s10mv19:
s10mv20:
s10mv21:
s10mv22:
s10mv23:
s10mv24:
s10mv25:
s10mv26:
s10mv27:
s10mv28:
s10mv29:
s10mv30:
	ldgp	$gp, 0($27)	# global ptr reg gets addr of this proc
	lda	$sp, -32($sp)	# grow stack
	stq	$26, 16($sp)	# save caller's addr on stack
	.mask	0x04000000, -16
	.frame	$sp, 32, $26, 0
	.prologue	1
	addl	$16, 0, $16	# arg1 $16: int size1
	addl	$17, 0, $17	# arg2 $17: int size2
				# arg3 $18: unsigned char *val1
	addl	$19, 0, $19	# arg4 $19: int p1
				# arg5 $20: unsigned char *val2
	addl	$21, 0, $21	# arg6 $21: int p2
	ldl	$2, 32($sp)	# arg7 on stack: int cnt
				# check args
	addl	$19, -1, $8	# (p1 - 1
	addl	$8, $2, $22	#  + cnt)
	subq	$16, $22, $23	# if size1 < p1 - 1 + cnt
	blt	$23, s10mv_err	#     goto s10mv_err
	addl	$21, -1, $24	# (p2 - 1
	addl	$24, $2, $25	#  + cnt)
	subq	$17, $25, $27	# if size2 < p2 - 1 + cnt
	blt	$27, s10mv_err	#     goto s10mv_err
	ble	$19, s10mv_err	# if p1 <= 0 goto s10mv_err
	ble	$21, s10mv_err	# if p2 <= 0 goto s10mv_err
	blt	$2, s10mv_err	# if cnt < 0 goto s10mv_err
				# prepare memcpy () args
	addq	$24, $20, $16	# (p2 - 1) + val2
	addq	$8, $18, $17	# (p1 - 1) + val1
	bis	$2, $2, $18	# cnt
	jsr	$26, memcpy
	ldgp	$gp, 0($26)	# restore global addr ptr
s10mv_ret:			# prepare to return
	ldq	$26, 16($sp)	# restore caller's addr
	lda	$sp, 32($sp)	# restore stack
	ret	$31, ($26), 1	# return to caller
s10mv_err:			# print err msg and dump core
				# prepare printf() args
	stq	$2, 8($sp)	# cnt
	stq	$21, 0($sp)	# p2
	bis	$20, $20, $21	# val2
	bis	$19, $19, $20	# p1
	bis	$18, $18, $19	# val1
	bis	$17, $17, $18	# size2
	bis	$16, $16, $17	# size1
	lda	$16, s10mv_fmt	# "%d %d %p %d %p %d %d s10mv : ABEND\n"
	jsr	$26, printf
	ldgp	$gp, 0($26)	# restore global addr ptr
	ldil	$8, 1		# val1 = 0; *val1 = 1 ;
	.set	 noat
	ldq_u	$28, 0($31)
	insbl	$8, $31, $22
	mskbl	$28, $31, $28
	bis	$28, $22, $28
	stq_u	$28, 0($31)	# segmentation fault produces core dump
	.set	 at
	br	$31, s10mv_ret	# we never reach this point
	.end	s10mv

	.text
	.align	4
	.globl	s10mvr
	.ent	s10mvr
/* void s10mvr(size1, size2, val1, p1, val2, p2, cnt)
 *             int size1;
 *             int size2;
 *             unsigned char *val1;
 *             int p1;
 *             unsigned char *val2;
 *             int p2;
 *             int cnt;
 */
s10mvr:
	ldgp	$gp, 0($27)	# global ptr reg gets addr of this proc
	lda	$sp, -32($sp)	# grow stack
	stq	$26, 16($sp)	# save caller's addr on stack
	.mask	0x04000000, -16
	.frame	$sp, 32, $26, 0
	.prologue	1
	addl	$16, 0, $16	# arg1 $16: int size1
	addl	$17, 0, $17	# arg2 $17: int size2
				# arg3 $18: unsigned char *val1
	addl	$19, 0, $19	# arg4 $19: int p1
				# arg5 $20: unsigned char *val2
	addl	$21, 0, $21	# arg6 $21: int p2
	ldl	$1, 32($sp)	# arg7 on stack: int cnt
				# check args
	addl	$19, -1, $6	# (p1 - 1
	addl	$6, $1, $22	#  + cnt)
	subq	$16, $22, $23	# if (size1 < p1 - 1 + cnt)
	blt	$23, s10mvr_err	#     goto s10mvr_err
	addl	$21, -1, $7	# (p2 - 1
	addl	$7, $1, $25	#  + cnt)
	subq	$17, $25, $27	# if (size2 < p2 - 1 + cnt)
	blt	$27, s10mvr_err	#     goto s10mvr_err
	blt	$1, s10mvr_err	# if (cnt < 0) goto s10mvr_err
	ble	$19, s10mvr_err	# if (p1 <= 0) goto s10mvr_err
	ble	$21, s10mvr_err	# if (p2 <= 0) goto s10mvr_err
				# prepare args for memmove()
	addq	$20, $7, $16	# val2 + (p2 - 1)
	addq	$18, $6, $17	# val1 + (p1 - 1)
	bis	$1, $1, $18	# cnt
	jsr	$26, memmove
	ldgp	$gp, 0($26)	# restore global addr ptr
s10mvr_ret:			# prepare to return
	ldq	$26, 16($sp)	# restore caller's addr
	lda	$sp, 32($sp)	# restore stack
	ret	$31, ($26), 1	# return to caller
s10mvr_err:			# print err msg and dump core
				# prepare args for printf ()
	stq	$1, 8($sp)	# cnt
	stq	$21, 0($sp)	# p2
	bis	$20, $20, $21	# val2
	bis	$19, $19, $20	# p1
	bis	$18, $18, $19	# val1
	bis	$17, $17, $18	# size2
	bis	$16, $16, $17	# size1
	lda	$16, s10mvr_fmt	# "%d %d %x %d %x %d %d s10mvr ABEND\n"
	jsr	$26, printf
	ldgp	$gp, 0($26)	# restore global addr ptr
	ldil	$8, 1		# val1 = 0; *val1 = 1 ;
	.set	 noat
	ldq_u	$28, 0($31)
	insbl	$8, $31, $22
	mskbl	$28, $31, $28
	bis	$28, $22, $28
	stq_u	$28, 0($31)	# segmentation fault produces core dump
	.set	 at
	br	$31, s10mvr_ret	# we never reach this point
	.end	s10mvr

	.text
	.align	4
	.globl	sp10a24
	.ent	sp10a24
/* int sp10a24()
 */
sp10a24:
	ldgp	$gp, 0($27)	# global ptr reg gets addr of this proc
	.frame	$sp, 0, $26, 0
	.prologue	1
	ldil	$0, 926190817	# return value: link check code
	ret	$31, ($26), 1	# return to caller
	.end	sp10a24
&else
/* 32BIT for ALPHA NT */
	.text
	.align	4
	.globl	s10fil
	.globl	s10fil1
	.globl	s10fil2
	.globl	s10fil3
	.globl	s10fil4
	.globl	s10fil5
	.ent	s10fil
/* void s10fil(size, m, pos, len, fillchar)
 *           int size;
 *           unsigned char *m;
 *           int pos;
 *           int len;
 *           unsigned char fillchar;
 */
s10fil:
s10fil1:
s10fil2:
s10fil3:
s10fil4:
s10fil5:
//	ldgp	$gp, 0($27)	# global ptr reg gets addr of this proc
//	.mask	0x04000000, -16
//	.frame	$sp, 16, $26, 0
	.prologue	0

	lda	$sp, -16($sp)	# grow stack
	stq	$26, 0($sp)	# save caller's addr on stack

	and	$20, 255, $20	# fillchar in   $20 (cast unsigned char to int)

	addl	$18, -1, $0	# p = pos - 1 into $0
	addl	$0, $19, $1	# p + len into $1
	subl	$16, $1, $2	# if (size < p + len )
	blt	$2, s10fil_err	#    goto s10fil_err
	blt	$18, s10fil_err # if (pos < 0 ) goto s10fil_err
	blt	$19, s10fil_err # if (len < 0 ) goto s10fil_err
				# memset ( m + p, (int)fillchar, len )
	addl	$0, $17, $16	# p + m    into $16
	bis	$20, $20, $17	# fillchar into $17
	bis	$19, $19, $18	# len      into $18
	jsr	$26, memset
	ldgp	$gp, 0($26)	# restore global addr ptr
s10fil_ret:
	ldq	$26, 0($sp)	# restore caller's addr
	lda	$sp, 16($sp)	# restore stack
	ret	$31, ($26), 1	# return to caller
s10fil_err:
	ldil	$6, 1		# m = 0; *m = 1;
	.set	 noat
	ldq_u	$28, 0($31)
	insbl	$6, $31, $7
	mskbl	$28, $31, $28
	bis	$28, $7, $28
	stq_u	$28, 0($31)	# segmentation fault produces core dump
	.set	 at
	br	$31, s10fil_ret	# never reached, but looks nice
	.end	s10fil

	.text
	.align	4
	.globl	s10mv
	.globl	s10mvc
	.globl	s10mv1
	.globl	s10mv2
	.globl	s10mv3
	.globl	s10mv4
	.globl	s10mv5
	.globl	s10mv6
	.globl	s10mv7
	.globl	s10mv8
	.globl	s10mv9
	.globl	s10mv10
	.globl	s10mv11
	.globl	s10mv12
	.globl	s10mv13
	.globl	s10mv14
	.globl	s10mv15
	.globl	s10mv16
	.globl	s10mv17
	.globl	s10mv18
	.globl	s10mv19
	.globl	s10mv20
	.globl	s10mv21
	.globl	s10mv22
	.globl	s10mv23
	.globl	s10mv24
	.globl	s10mv25
	.globl	s10mv26
	.globl	s10mv27
	.globl	s10mv28
	.globl	s10mv29
	.globl	s10mv30
	.ent	s10mv
/* void s10mv(size1, size2, val1, p1, val2, p2, cnt)
 *            int size1;
 *            int size2;
 *            unsigned char *val1;
 *            int p1;
 *            unsigned char *val2;
 *            int p2;
 *            int cnt;
 */
s10mv:
s10mvc:
s10mv1:
s10mv2:
s10mv3:
s10mv4:
s10mv5:
s10mv6:
s10mv7:
s10mv8:
s10mv9:
s10mv10:
s10mv11:
s10mv12:
s10mv13:
s10mv14:
s10mv15:
s10mv16:
s10mv17:
s10mv18:
s10mv19:
s10mv20:
s10mv21:
s10mv22:
s10mv23:
s10mv24:
s10mv25:
s10mv26:
s10mv27:
s10mv28:
s10mv29:
s10mv30:
//	ldgp	$gp, 0($27)	# global ptr reg gets addr of this proc
//	.mask	0x04000000, -16
//	.frame	$sp, 32, $26, 0
	.prologue	0

	lda	$sp, -32($sp)	# grow stack
	stq	$26, 16($sp)	# save caller's addr on stack

				# size1 in   $16
				# size2 in   $17
				# val1  in   $18
				# p1    in   $19
				# val2  in   $20
				# p2    in   $21
	ldl	$4, 32($sp)	# cnt   into $4

	ble	$19, s10mv_err	# if (p1 <= 0 ) goto s10mv_err
	ble	$21, s10mv_err	# if (p2 <= 0 ) goto s10mv_err
	blt	$4, s10mv_err	# if (cnt < 0 ) goto s10mv_err

	addl	$19, -1, $0	# pos1 = p1 - 1 into $0
	addl	$21, -1, $1	# pos2 = p2 - 1 into $1

	addl	$0, $4, $22	# pos1 + cnt into $22
	subl	$16, $22, $23	# if (size1 < pos1 + cnt )
	blt	$23, s10mv_err	#     goto s10mv_err

	addl	$1, $4, $22	# pos2 + cnt into $22
	subl	$17, $22, $23	# if (size2 < pos2 + cnt )
	blt	$23, s10mv_err	#     goto s10mv_err

				# memcpy ( val2 + pos2, val1 + pos1, cnt )
	addl	$1, $20, $16	# pos2 + val2 into $16
	addl	$0, $18, $17	# pos1 + val1 into $17
	bis	$4, $4, $18	# cnt into $18
	jsr	$26, memcpy
	ldgp	$gp, 0($26)	# restore global addr ptr
s10mv_ret:
	ldq	$26, 16($sp)	# restore caller's addr
	lda	$sp, 32($sp)	# restore stack
	ret	$31, ($26), 1	# return to caller
s10mv_err:
	ldil	$27, 1		# val1 = 0; *val1 = 1
	.set	 noat
	ldq_u	$28, 0($31)
	insbl	$27, $31, $22
	mskbl	$28, $31, $28
	bis	$28, $22, $28
	stq_u	$28, 0($31)	# segmentation fault produces core dump
	.set	 at
	br	$31, s10mv_ret	# never reached, but looks nice
	.end	s10mv

	.text
	.align	4
	.globl	s10mvr
	.ent	s10mvr
/* void s10mvr(size1, size2, val1, p1, val2, p2, cnt)
 *             int size1;
 *             int size2;
 *             unsigned char *val1;
 *             int p1;
 *             unsigned char *val2;
 *             int p2;
 *             int cnt;
 */
s10mvr:
//	ldgp	$gp, 0($27)	# global ptr reg gets addr of this proc
//	.frame	$sp, 0, $26, 0
	.prologue	0
				# size1 in   $16
				# size2 in   $17
				# val1  in   $18
				# p1    in   $19
				# val1  in   $20
				# p2    in   $21

	ldl	$1, 0($sp)	# cnt   into $1

	blt	$1, s10mvr_err	# if ( cnt < 0 ) goto s10mvr_err
	ble	$19, s10mvr_err # if ( p1 <= 0 ) goto s10mvr_err
	ble	$21, s10mvr_err	# if ( p2 <= 0) goto s10mvr_err

	addl	$1, -1, $0	# c = cnt - 1 into $0

	addl	$19, $0, $2	# p1 + c into $2
	subl	$16, $2, $4	# if ( size1 < ( p1 + c ) )
	blt	$4, s10mvr_err	#    goto s10mvr_err

	addl	$21, $0, $3	# p2 + c into $3
	subl	$17, $3, $4	# if ( size2 < ( p2 + c ) )
	blt	$4, s10mvr_err	#    goto s10mvr_err

	addl	$18, $2, $18	# val1 = val1 + ( p1 + c ) into $18
	addl	$18, -1, $18	# val1 = val - 1           into $18

	addl	$20, $3, $20	# val2 = val2 + ( p2 + c ) into $20
	addl	$20, -1, $20	# val2 = val2 - 1          into $20

	beq	$1, s10mvr_ret	# if ( cnt == 0 ) goto s10mvr_ret

				# if cnt not evenly divisible by 4,
				# copy the extra 1, 2 or 3 bytes first
	and	$1, 3, $0
	negl	$0, $0
	beq	$0, s10mvr_lp4	# if (subcnt == 0) go copy groups of 4
	addl	$0, $1, $0	# subcnt = 1, 2 or 3 into $0
	.align	3
s10mvr_123:			# loop 1, 2 or 3 times to copy 1, 2 or 3 bytes
	ldq_u	$22, 0($18)
	extbl	$22, $18, $22
	.set	 noat
	ldq_u	$28, 0($20)
	insbl	$22, $20, $23
	mskbl	$28, $20, $28
	bis	$28, $23, $28
	stq_u	$28, 0($20)	# *val2 = *val1
	.set	 at
	addl	$20, -1, $20	# val2--
	addl	$18, -1, $18	# val1--
	addl	$1, -1, $1	# cnt--
	subl	$0, $1, $24	# if (subcnt finished)
	bne	$24, s10mvr_123	#    goto s10mvr_123
	beq	$1, s10mvr_ret	# if ( cnt finished ) return
	.align	3
s10mvr_lp4:			# have at least 4 more bytes to copy
	ldq_u	$2, 0($18)
	extbl	$2, $18, $2
	.set	 noat
	ldq_u	$28, 0($20)
	insbl	$2, $20, $3
	mskbl	$28, $20, $28
	bis	$28, $3, $28
	stq_u	$28, 0($20)	# *val2 = *val1
	.set	 at
	addl	$20, -1, $20	# val2--
	addl	$18, -1, $18	# val1--

	ldq_u	$2, 0($18)
	extbl	$2, $18, $2
	.set	 noat
	ldq_u	$28, 0($20)
	insbl	$2, $20, $3
	mskbl	$28, $20, $28
	bis	$28, $3, $28
	stq_u	$28, 0($20)	# *val2 = *val1
	.set	 at
	addl	$20, -1, $20	# val2--
	addl	$18, -1, $18	# val1--

	ldq_u	$2, 0($18)
	extbl	$2, $18, $2
	.set	 noat
	ldq_u	$28, 0($20)
	insbl	$2, $20, $3
	mskbl	$28, $20, $28
	bis	$28, $3, $28
	stq_u	$28, 0($20)	# *val2 = *val1
	.set	 at
	addl	$20, -1, $20	# val2--
	addl	$18, -1, $18	# val1--

	ldq_u	$2, 0($18)
	extbl	$2, $18, $2
	.set	 noat
	ldq_u	$28, 0($20)
	insbl	$2, $20, $3
	mskbl	$28, $20, $28
	bis	$28, $3, $28
	stq_u	$28, 0($20)	# *val2 = *val1
	.set	 at
	addl	$20, -1, $20	# val2--
	addl	$18, -1, $18	# val1--

	addl	$1, -4, $1	# cnt = cnt - 4 into $1
	bne	$1, s10mvr_lp4	# if ( cnt not finished ) loop again
	ret	$31, ($26), 1	# return to caller
s10mvr_err:
	ldil	$8, 1		# val1 = 0; *val1 = 1
	.set	 noat
	ldq_u	$28, 0($31)
	insbl	$8, $31, $22
	mskbl	$28, $31, $28
	bis	$28, $22, $28
	stq_u	$28, 0($31)	# segmentation fault produces core dump
	.set	 at
s10mvr_ret:
	ret	$31, ($26), 1	# return to caller
	.end	s10mvr

	.text
	.align	4
	.globl	sp10a24
	.ent	sp10a24
/* int sp10a24()
 */
sp10a24:
//	ldgp	$gp, 0($27)
//	.frame	$sp, 0, $26, 0
	.prologue	0
	ldil	$0, 926190817	# return link check code
	ret	$31, ($26), 1
	.end	sp10a24
&endif
&endif /* ALPHA */

.CM *-END-* code ----------------------------------------
.sp
.sp
***********************************************************
ANZAHL STATEMENTS :         178
ANZAHL LINES OF CODE :         813
.pa
