/****************************************************************************
  module      : vkb64
  author      : JuergenA
  responsible : UweH
  special area: Logging
  see also    :
  description :
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2001-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
*****************************************************************************/
 
.tt 1 $SAP$LiveCache$VKB64$
.tt 3 $UweH$KB_file_table_handling$$2000-11-28$
 
Module  : KB_file_table_handling
 
Define  :
 
        PROCEDURE
              k64begin_load (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k64build_aux_fn_prefix (
                    VAR transid    : tgg91_TransNo;
                    is_perm        : boolean;
                    VAR aux_id     : tgg00_FileId;
                    VAR prefix_len : integer);
 
        PROCEDURE
              k64change_filetype (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k64cmd_drop (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k64create_bd_file (
                    VAR t          : tgg00_TransContext;
                    VAR tree_id    : tgg00_FileId;
                    mess_type      : tgg00_MessType;
                    mess2_type     : tgg00_MessType2;
                    eFiletypeSet   : tgg00_ExtendedFiletypeSet;
                    str_col_cnt    : tsp00_Int2);
 
        PROCEDURE
              k64CreateTable (
                    VAR t              : tgg00_TransContext;
                    VAR fileId         : tgg00_FileId;
                    mess2_type         : tgg00_MessType2;
                    eFiletypeSet       : tgg00_ExtendedFiletypeSet;
                    str_col_cnt        : tsp00_Int2;
                    createShortColFile : boolean);
 
        PROCEDURE
              k64drop_tree (
                    VAR t         : tgg00_TransContext;
                    VAR file_id   : tgg00_FileId);
 
        PROCEDURE
              k64drop_lob_tree (
                    VAR t         : tgg00_TransContext;
                    VAR tableid   : tgg00_Surrogate (*ptocSynonym const tgg00_Surrogate&*);
                    VAR file_id   : tgg00_FileId);
 
        PROCEDURE
              k64end_load (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k64rename_lob_file (
                    VAR t         : tgg00_TransContext;
                    VAR tableid   : tgg00_Surrogate (*ptocSynonym const tgg00_Surrogate&*);
                    VAR source_id : tgg00_FileId;
                    VAR target_id : tgg00_FileId);
 
        PROCEDURE
              k64set_file_version (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k64set_treeleafnodes (
                    VAR t      : tgg00_TransContext;
                    VAR fileId : tgg00_FileId);
 
        PROCEDURE
              k64short_col_file_create (
                    VAR t       : tgg00_TransContext;
                    VAR tree_id : tgg00_FileId);
 
        PROCEDURE
              k64short_col_file_drop (
                    VAR t       : tgg00_TransContext;
                    VAR tree_id : tgg00_FileId);
 
        PROCEDURE
              k64table_create (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k64temp_file_handling (VAR m : tgg00_MessBlock);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              SQLManager : VAK101;
 
        PROCEDURE
              a101_DestroyGroupedTempFile(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103CatalogCacheInvalidateTable (
                    TaskId       : tsp00_TaskId;
                    VAR  TableId : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              KB_trans_state : VKB50;
 
        PROCEDURE
              k50aux_fn_no (
                    transindex          : tgg00_TransIndex;
                    is_perm             : boolean;
                    VAR auxiliary_fn_no : tsp00_Int4);
 
        PROCEDURE
              k50new_write_trans (VAR t : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              KB_transaction : VKB53;
 
        PROCEDURE
              k53eot_excl_lock (
                    VAR t             : tgg00_TransContext;
                    VAR TreeId        : tgg00_FileId;
                    VAR k             : tgg00_Lkey;
                    forInsert         : boolean;
                    WantedMode        : tgg00_LockReqMode;
                    VAR GrantedMode   : tgg00_LockReqMode);
 
        PROCEDURE
              k53commit (
                    VAR t      : tgg00_TransContext;
                    mess2_type : tgg00_MessType2);
 
      ------------------------------ 
 
        FROM
              KB_Logging : VKB560;
 
        PROCEDURE
              kb560StartSavepoint (VAR Trans : tgg00_TransContext;
                    MessType2 : tgg00_MessType2);
 
      ------------------------------ 
 
        FROM
              KB_restart_record : VKB57;
 
        PROCEDURE
              k57adjust_table_key (VAR m : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              KB_inv_link_trigger_handling : VKB62;
 
        PROCEDURE
              k62last_multi_inv_st (
                    VAR stack_desc : tgg00_StackDesc;
                    first_st    : integer;
                    VAR last_st : integer);
 
      ------------------------------ 
 
        FROM
              KB_CreateDropFile_interface : VKB641;
 
        PROCEDURE
              kb641BeginLoad (
                    VAR trans   : tgg00_TransContext;
                    VAR fileid  : tgg00_FileId;
                    VAR lastkey : tgg00_Lkey);
 
        PROCEDURE
              kb641ChangeFileType (
                    VAR TransContext   : tgg00_TransContext;
                    VAR FileId         : tgg00_FileId;
                    VAR NewFiletypeSet : tgg00_FiletypeSet);
 
        PROCEDURE
              kb641CreateFile (
                    VAR TransContext : tgg00_TransContext;
                    VAR FileId       : tgg00_FileId);
 
        PROCEDURE
              kb641CreateTable (
                    VAR TransContext : tgg00_TransContext;
                    VAR FileId       : tgg00_FileId;
                    eFileTypeset     : tgg00_ExtendedFiletypeSet;
                    StrColCnt        : tsp00_Int2;
                    VarColCntOff     : tsp00_Int2);
 
        PROCEDURE
              kb641CreateShortColumnFile (
                    VAR TransContext : tgg00_TransContext;
                    VAR shortColId   : tgg00_FileId;
                    VAR tableSurr    : tgg00_Surrogate);
 
        PROCEDURE
              kb641MarkFileAsDeleted (
                    VAR trans  : tgg00_TransContext;
                    VAR fileid : tgg00_FileId);
 
        PROCEDURE
              kb641RenameLobFile (
                    VAR TransContext : tgg00_TransContext;
                    VAR TableId      : tgg00_Surrogate;
                    VAR OldFileId    : tgg00_FileId;
                    VAR NewFileId    : tgg00_FileId);
 
        PROCEDURE
              kb641SuccFileVersion (
                    VAR TransContext   : tgg00_TransContext;
                    VAR FileId         : tgg00_FileId;
                    VAR NewFileVersion : tgg91_FileVersion;
                    OldLongCnt         : tsp00_Int4;
                    NewLongCnt         : tsp00_Int4);
 
        PROCEDURE
              kb641UpdFileStatistic (
                    VAR TransContext : tgg00_TransContext;
                    VAR FileId       : tgg00_FileId;
                    OldLeafNodes     : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01fullkey    : tsp00_Key;
              b01niltree_id : tgg00_FileId;
 
        PROCEDURE
              b01destroy_file (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              b01empty_file (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              b01filestate (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              b01move_filecontent (
                    VAR t         : tgg00_TransContext;
                    VAR source_id : tgg00_FileId;
                    VAR target_id : tgg00_FileId);
 
        PROCEDURE
              b01prefix_destroy_files (
                    VAR t         : tgg00_TransContext;
                    VAR prefix_fn : tgg00_Filename;
                    prefix_len    : integer);
 
        PROCEDURE
              b01set_fileversion (VAR t : tgg00_TransContext;
                    VAR file_id     : tgg00_FileId;
                    new_fileversion : tgg91_FileVersion;
                    new_long_cnt    : tsp00_Int2);
 
        PROCEDURE
              b01treeleafnodes (
                    VAR t                 : tgg00_TransContext;
                    VAR file_id           : tgg00_FileId;
                    m_type                : tgg00_MessType;
                    VAR old_treeleafnodes : tsp00_Int4);
 
        PROCEDURE
              b01vstate_fileversion (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD02;
 
        PROCEDURE
              b02prev_record (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Lkey;
                    inclusive   : boolean;
                    VAR b       : tgg00_Rec);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_9 : VBD09;
 
        PROCEDURE
              bd09FinishLoad (
                    VAR t          : tgg00_TransContext;
                    VAR file_id    : tgg00_FileId;
                    rightmost_leaf : tsp00_PageNo);
 
      ------------------------------ 
 
        FROM
              FileDir_Wrapper : vbd998;
 
        PROCEDURE
              bd998NewFileNo (
                    VAR file_no : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter: VGG01;
 
        PROCEDURE
              g01check (
                    msg_no     : tsp00_Int4;
                    msg_label  : tsp00_C8;
                    msg_text   : tsp00_C24;
                    bad_value  : tsp00_Int4;
                    constraint : boolean);
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04index_tree_build (
                    VAR file_id    : tgg00_FileId (*ptocConst*);
                    VAR index_tree : tgg00_FileId;
                    index_no       : tsp00_Int2);
 
        PROCEDURE
              g04short_col_tree_build (
                    VAR table_surrogate : tgg00_Surrogate (*ptocConst*);
                    VAR short_col_tree  : tgg00_FileId;
                    VAR b_err           : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        PROCEDURE
              gg06FileVersIncr (VAR FileVers : tgg91_FileVersion);
 
        FUNCTION
              gg06IsNilTrans (VAR TransNo : tgg91_TransNo): boolean;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id     : tsp00_C6;
                    mod_num    : tsp00_Int4;
                    source_upb : tsp00_Int4;
                    destin_upb : tsp00_Int4;
                    source     : tsp00_MoveObjPtr;
                    source_pos : tsp00_Int4;
                    destin     : tsp00_MoveObjPtr;
                    destin_pos : tsp00_Int4;
                    length     : tsp00_Int4;
                    VAR err    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        FUNCTION
              s20buf_to_int4 (VAR str : tsp00_Buf; si : tsp00_Int4) : tsp00_Int4;
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01sname (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**));
 
        PROCEDURE
              t01messtype (
                    layer        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    mess_type    : tgg00_MessType);
 
        PROCEDURE
              t01mess2type (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    mess2_type    : tgg00_MessType2);
 
        PROCEDURE
              t01msgcheck (
                    msg             : tsp00_C30;
                    check_condition : boolean;
                    bad_int         : tsp00_Int4);
&       endif
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        FUNCTION
              s20buf_to_int4;
 
              tsp00_MoveObj tsp00_Buf
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : JuergenA
.sp
.cp 3
Created : 1979-11-13
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-11-28
.sp
***********************************************************
.sp
.cp 12
.fo
.oc _/1
Specification:
.sp
Procedure K64BEGIN_LOAD
.sp
This procedure writes a 'begin key/nokey' log entry and
flushes the file pages onto the disk.
.sp 2;.cp 4
Procedure K64BUILD_AUX_FN_PREFIX
.sp
The prefix of an auxiliary file name is built from the transid and
a number (AUX_FN_NO). This prefix is used by a commit to destroy
all appropriate auxiliary files.
.sp 2;.cp 4
Procedure K64CMD_DROP
.sp
Locks the table id (MTREE.TABID) in system exclusive mode.
Depending on the message2 type a force drop (MM_CLEAR), an index
drop (MM_INDEX) or a normal drop (MM_TABLE) is performed.
.hi 10;.sp
MM_CLEAR tries to drop the primary file, all inv files (single 1-255,
multi 1-256) and the short string column.
.sp
MM_INDEX drops the specied inv_file.
.sp
MM_TABLE drops the primary file, the specied inv files and the specified
short string column.
.hi;.sp
The dropping of a primary file, an inv file or a short string column
is performed via K64RENAME_FILE.
.sp 2;.cp 4
Procedure K64CREATE_TREE
.sp
A log entry is written to the log.
For M_CREATE_FILE a bytestring is created via
B01BCREATE_FILE and for M_CREATE_TABLE a tree is created
via B01FCREATE_FILE.
.sp 2;.cp 4
Procedure K64DROP_TREE
.sp
Performs the drop handling by renaming the tree (FILE_ID) into
an auxiliary file via K64RENAME_TREE.
A commit drops all appropriate auxiliary files using the transid
contained in the auxiliary filename prefix.
A rollback renames the auxiliary files into the logged name of
the FILE_ID.
.sp 2;.cp 3
Procedure K64END_LOAD
.sp
Terminates the data load handling.
.sp 2;.cp 4
Procedure K64RENAME_TREE
.sp
Writes a log entry and renames the tree to the specified TARGET tree id.
.br
BUILD_AUX_ID indicates that the TARGET tree id is not specified.
In that case the TARGET id is created as an auxiliary file to
perform the drop handling: rename the SOURCE tree into
an auxiliary name.
A commit drops all appropriate auxiliary files using the transid
contained in the auxiliary filename prefix.
A rollback renames the auxiliary files into the logged source filenames.
.sp 2;.cp 4
Procedure K64SET_FILE_VERSION
.sp
This procedure checks the correctness of the old FILE-VERSION
via B01VSTATE_FILEVERSION. If the FILE-VERSION  matches the
version in the BD layer, the file is locked in system exclusive mode
and the old and new FILE-VERSION are written to the log.
The new FILE-VERSION is then set via B01SET_FILEVERSION.
The new file version is assigned to the tree_id of the message buffer.
.sp 2;.cp 4
Procedure K64SET_READ_ONLY_FILE
.sp
Locks the table in table exclusive mode and sets
or removes the state 'read only' for the specified table.
.sp 2;.cp 4
Procedure K64TABLE_CREATE
.sp
Locks the new table in system exclusive mode.
The file version '0' is assigned to the tree id.
The creation of the tree and the short string column is performed
via K64CREATE_TREE.
.sp 2;.cp 4
Procedure K64TEMP_FILE_HANDLING
.sp
The procedure performes the following operations on temp files:
.hi 9;.sp
DESTROY~EMPTY empties the temp file
.sp
DESTROY~NIL drops the temp file
.sp
DESTROY~PREFIX performs a prefix destroy for the specified prefix
and the TEMP_INV prefix
.sp
MOVE moves the file contents
.hi
.sp 2;.cp 4
Procedure K64SET_TREELEAFNODES
.sp
Nothing is done for tfnCluster_egg00. From a primary tree without tfnCluster_egg00
treeleafnodes in leftnext of the root page is read and compared with
treeleafnodes from the tree identification. If those treeleafnodes are
different a log entry is written with both treeleafnodes and
treeleafnodes from the tree identification replaces treeleafnodes in
leftnext of the root.
.sp 2;.cp 4
Procedure KB64TREE_UNLOAD_RELOAD
.sp
A log entry is written to the log
and the file state 'unloaded' is erase for M_RELOAD
or creates a new empty file with the same specifications
as the original file (AUX_ID) for M_UNLOAD.
.sp
.CM *-END-* specification -------------------------------
.sp 2
**********************************************************
.sp
.cp 25
.fo
.oc _/1
Description:
.sp
.CM *-END-* description ---------------------------------
.sp 2;.fo
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 20
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_inclusive        = true;
      c_perm             = true;
 
 
(*------------------------------*) 
 
PROCEDURE
      k64begin_load (VAR m : tgg00_MessBlock);
 
VAR
      dummy_granted : tgg00_LockReqMode;
      site_lastkey  : tgg00_ServerdbNo;
      move_len      : tsp00_Int4;
      syskey_id     : tgg00_Surrogate;
      startkey      : tgg00_Lkey;
      dummy_k       : tgg00_Lkey;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
k53eot_excl_lock (m.mb_trns^, m.mb_qual^.mtree, dummy_k, false, lckSysExcl_egg00, dummy_granted);
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    m.mb_data^.mbp_keylen := 0;
    IF  m.mb_qual^.mtree.fileTfn_gg00 = tfnTable_egg00
    THEN
        BEGIN
        startkey.keyVal_gg00 := b01fullkey;
        startkey.keyLen_gg00 := PERM_KEY_MXSP00;
        b02prev_record (m.mb_trns^, m.mb_qual^.mtree, startkey,
              c_inclusive, m.mb_data^.mbp_rec)
        END
    ELSE
        m.mb_trns^.trError_gg00 := e_no_prev_record;
    (*ENDIF*) 
    IF  (m.mb_trns^.trError_gg00 = e_no_prev_record) OR
        (m.mb_trns^.trError_gg00 = e_file_empty)
    THEN
        (*zerokey*)
        BEGIN
        m.mb_trns^.trError_gg00 := e_ok;
        CASE m.mb_type2 OF
            mm_key:
                m.mb_data^.mbp_keylen := 0;
            mm_nokey:
                BEGIN
                (*+++++++++++++++++++++++++++++++++++++++++++*)
                (* error: dummy site greater than any syskey *)
                (*+++++++++++++++++++++++++++++++++++++++++++*)
                site_lastkey  := cgg04_dummy_site;
                syskey_id     := cgg_zero_id;
                syskey_id [1] := site_lastkey [1];
                syskey_id [2] := site_lastkey [2];
                move_len      := sizeof (syskey_id);
                SAPDB_PascalMove ('VKB64 ',   1,    
                      sizeof (syskey_id), m.mb_data_size,
                      @syskey_id, 1, @m.mb_data^.mbp_key.k,
                      2, move_len, m.mb_trns^.trError_gg00);
                m.mb_data^.mbp_key.keyVal_gg00 [1] := csp_defined_byte;
                m.mb_data^.mbp_keylen := move_len + 1
                END
            END
        (*ENDCASE*) 
        END
    ELSE
        IF  m.mb_trns^.trError_gg00 = e_key_not_found
        THEN
            m.mb_trns^.trError_gg00 := e_ok
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    kb641BeginLoad (m.mb_trns^, m.mb_qual^.mtree, m.mb_data^.mbp_key);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k64build_aux_fn_prefix (
            VAR transid    : tgg91_TransNo;
            is_perm        : boolean;
            VAR aux_id     : tgg00_FileId;
            VAR prefix_len : integer);
 
BEGIN
aux_id := b01niltree_id;
IF  is_perm
THEN
    aux_id.fileTfn_gg00 := tfnAux_egg00
ELSE
    aux_id.fileTfn_gg00 := tfnTempAux_egg00;
(*ENDIF*) 
aux_id.fileTransId_gg00 := transid;
(* *)
prefix_len := sizeof (aux_id.fileTfn_gg00    )
      +       sizeof (aux_id.fileTfnNo_gg00  )
      +       sizeof (aux_id.fileTransId_gg00)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k64change_filetype (VAR m : tgg00_MessBlock);
 
VAR
      dummy_granted : tgg00_LockReqMode;
      new_filetype  : tgg00_FiletypeSet;
      dummy_k       : tgg00_Lkey;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
new_filetype            := m.mb_qual^.mtree.fileType_gg00;
b01filestate (m.mb_trns^, m.mb_qual^.mtree);
IF  m.mb_trns^.trError_gg00 = e_file_read_only
THEN
    m.mb_trns^.trError_gg00 := e_ok;
(*ENDIF*) 
IF  new_filetype <> m.mb_qual^.mtree.fileType_gg00
THEN
    BEGIN
    IF  ftsDynamic_egg00 in new_filetype
    THEN
        new_filetype := m.mb_qual^.mtree.fileType_gg00 + [ftsDynamic_egg00]
    ELSE
        new_filetype := m.mb_qual^.mtree.fileType_gg00 - [ftsDynamic_egg00];
    (*ENDIF*) 
    IF  m.mb_trns^.trError_gg00 = e_ok
    THEN
        k53eot_excl_lock (m.mb_trns^, m.mb_qual^.mtree, dummy_k,
              false, lckSysExcl_egg00, dummy_granted);
    (*ENDIF*) 
    IF  m.mb_trns^.trError_gg00 = e_ok
    THEN
        kb641ChangeFileType (m.mb_trns^, m.mb_qual^.mtree, new_filetype)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    m.mb_type      := m_return_result;
    m.mb_type2     := mm_nil;
    m.mb_struct    := mbs_tree_id;
    m.mb_qual_len  := sizeof (m.mb_qual^.mtree);
    m.mb_data_len  := 0
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k64short_col_file_drop (
            VAR t       : tgg00_TransContext;
            VAR tree_id : tgg00_FileId);
 
VAR
      short_scol_id : tgg00_FileId;
 
BEGIN
(* PTS 1115206 M.Ki. *)
short_scol_id                           := tree_id;
g04short_col_tree_build (tree_id.fileTabId_gg00, short_scol_id,
      t.trError_gg00);
short_scol_id.fileBdUse_gg00            := [ ];
IF  t.trError_gg00 = e_ok
THEN
    k64drop_tree (t, short_scol_id);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k64cmd_drop (VAR m : tgg00_MessBlock);
 
VAR
      dummy_granted : tgg00_LockReqMode;
      col           : integer;
      last_col      : integer;
      inv_id        : tgg00_FileId;
      short_scol_id : tgg00_FileId;
      dummy_k       : tgg00_Lkey;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
&ifdef TRACE
t01mess2type (kb, 'm.mb_type2  ', m.mb_type2);
&endif
k53eot_excl_lock (m.mb_trns^, m.mb_qual^.mtree, dummy_k,
      false, lckSysExcl_egg00, dummy_granted);
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    CASE m.mb_type2 OF
        mm_clear:
            BEGIN
            b01filestate (m.mb_trns^, m.mb_qual^.mtree);
            IF  m.mb_trns^.trError_gg00 = e_bad_file (* PTS 1129273 TS 2004-04-21 *)
            THEN
                m.mb_trns^.trError_gg00 := e_ok;
            (*ENDIF*) 
            IF  m.mb_trns^.trError_gg00 = e_ok
            THEN
                k64drop_tree (m.mb_trns^, m.mb_qual^.mtree)
            ELSE
                m.mb_trns^.trError_gg00 := e_ok;
            (*ENDIF*) 
            col := 1;
            WHILE (m.mb_trns^.trError_gg00 = e_ok) AND
                  (col <= MAX_INV_PER_TAB_GG00) DO
                BEGIN
                g04index_tree_build (m.mb_qual^.mtree, inv_id, col);
                inv_id.fileBdUse_gg00 := [ ];
                b01filestate (m.mb_trns^, inv_id);
                IF  m.mb_trns^.trError_gg00 = e_file_not_accessible (* PTS 1129273 TS 2004-04-21 *)
                THEN
                    m.mb_trns^.trError_gg00 := e_ok;
                (*ENDIF*) 
                IF  m.mb_trns^.trError_gg00 = e_ok
                THEN
                    k64drop_tree (m.mb_trns^, inv_id)
                ELSE
                    m.mb_trns^.trError_gg00 := e_ok;
                (*ENDIF*) 
                col := col + 1
                END;
            (*ENDWHILE*) 
            IF  m.mb_trns^.trError_gg00 = e_ok
            THEN
                (* drop short string column *)
                BEGIN
                short_scol_id                := m.mb_qual^.mtree;
                g04short_col_tree_build (m.mb_qual^.mtree.fileTabId_gg00,
                      short_scol_id, m.mb_trns^.trError_gg00);
                short_scol_id.fileBdUse_gg00 := [ ];
                IF  m.mb_trns^.trError_gg00 = e_ok
                THEN
                    b01filestate (m.mb_trns^, short_scol_id);
                (*ENDIF*) 
                IF  m.mb_trns^.trError_gg00 = e_bad_file (* PTS 1129273 TS 2004-04-21 *)
                THEN
                    m.mb_trns^.trError_gg00 := e_ok;
                (*ENDIF*) 
                IF  m.mb_trns^.trError_gg00 = e_ok
                THEN
                    k64drop_tree (m.mb_trns^, short_scol_id)
                ELSE
                    m.mb_trns^.trError_gg00 := e_ok
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        mm_index:
            BEGIN
            g04index_tree_build (m.mb_qual^.mtree, inv_id,
                  ord(m.mb_qual^.mst_addr^[m.mb_qual^.mmult_pos].ecol_tab[1]));
            inv_id.fileLeafNodes_gg00 := cgg_nil_leafnodes;
            inv_id.fileBdUse_gg00     := [ ];
            m.mb_trns^.trError_gg00     := e_ok;
            kb641MarkFileAsDeleted(m.mb_trns^, inv_id);
            IF  m.mb_trns^.trError_gg00 = e_ok
            THEN
                BEGIN
                m.mb_type      := m_return_result;
                m.mb_type2     := mm_nil;
                m.mb_struct    := mbs_tree_id;
                m.mb_qual_len  := sizeof (m.mb_qual^.mtree);
                m.mb_data_len  := 0
                END;
            (*ENDIF*) 
            END;
        mm_table:
            BEGIN
            (* drop inv files *)
            (* drop mult inv files *)
&           ifdef trace
            t01sname( kb, 'drop mindex ' );
&           endif
            col := m.mb_qual^.mmult_pos;
            m.mb_qual^.mst_addr := m.mb_st;
            m.mb_qual^.mst_max  := m.mb_st_max;
            WHILE (m.mb_trns^.trError_gg00    =  e_ok       ) AND
                  (col < m.mb_qual^.mmult_pos + m.mb_qual^.mmult_cnt) DO
                BEGIN
                g04index_tree_build (m.mb_qual^.mtree, inv_id,
                      ord(m.mb_st^ [col].ecol_tab [1]));
                inv_id.fileBdUse_gg00 := [ ];
                k62last_multi_inv_st (m.mb_qual^.mstack_desc,
                      col, last_col);
                k64drop_tree (m.mb_trns^, inv_id);
                col := last_col + 1
                END;
            (*ENDWHILE*) 
            IF  (m.mb_trns^.trError_gg00 = e_ok)   AND
                (m.mb_qual^.mstring_cnt > 0) AND
                (m.mb_qual^.mstring_cnt > m.mb_qual^.mlink_cnt)
                (* old long *)
                (* mlink_cnt: no of new long columns *)
            THEN (* PTS 1115206 M.Ki. *)
                k64short_col_file_drop (m.mb_trns^, m.mb_qual^.mtree);
            (* drop table last because it is needed to get to index *)
            (* and short column files                               *)
            (*ENDIF*) 
            k64drop_tree (m.mb_trns^, m.mb_qual^.mtree);
            END;
        OTHERWISE
            m.mb_trns^.trError_gg00 := e_not_implemented
        END
    (*ENDCASE*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k64create_bd_file (
            VAR t          : tgg00_TransContext;
            VAR tree_id    : tgg00_FileId;
            mess_type      : tgg00_MessType;
            mess2_type     : tgg00_MessType2;
            eFiletypeSet   : tgg00_ExtendedFiletypeSet;
            str_col_cnt    : tsp00_Int2);
 
BEGIN
t.trError_gg00 := e_ok;
&ifdef TRACE
t01messtype  (kb, 'mess_type   ', mess_type);
t01mess2type (kb, 'mess2_type  ', mess2_type);
t01msgcheck ('k64create_bd_f: wrong messtype',
      mess_type in [m_create_file, m_create_table], ord (mess_type));
t01msgcheck ('k64create_bd_f:wrong mess2type',
      mess2_type in [mm_nil, mm_nokey, mm_specialkey, mm_object], ord (mess2_type));
&endif
IF  mess_type = m_create_table
THEN
    BEGIN
    (* PTS 1117547 E.Z. *)
    tree_id.fileType_gg00 := tree_id.fileType_gg00
          - [ ftsTemp_egg00, ftsByteStr_egg00, ftsShared_egg00, ftsObject_egg00 ]
          + [ ftsPerm_egg00, ftsConcurrent_egg00 ]
    END;
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    tree_id.fileRoot_gg00      := NIL_PAGE_NO_GG00;
    tree_id.fileBdUse_gg00     := [ ];
    tree_id.fileLeafNodes_gg00 := cgg_nil_leafnodes;
    IF  mess_type = m_create_table
    THEN
        kb641CreateTable (t, tree_id, eFiletypeSet, str_col_cnt,
              cgg_nil_varcol_cnt_off)
    ELSE
        (* m_create_file *)
        BEGIN
        tree_id.fileType_gg00 := [ftsByteStr_egg00, ftsConcurrent_egg00];
        kb641CreateFile (t, tree_id)
        END;
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k64drop_tree (
            VAR t         : tgg00_TransContext;
            VAR file_id   : tgg00_FileId);
 
BEGIN
IF  gg06IsNilTrans (t.trWriteTransId_gg00)
THEN
    k50new_write_trans (t);
(*ENDIF*) 
g01check(kb64DropTree_csp03, csp3_n_data,
      'not impl for tfnColumn  ',
      ord(file_id.fileTfn_gg00),
      file_id.fileTfn_gg00 <> tfnColumn_egg00);
t.trError_gg00     := e_ok;
file_id.fileBdUse_gg00 := [ ];
kb641MarkFileAsDeleted(t, file_id)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k64drop_lob_tree (
            VAR t         : tgg00_TransContext;
            VAR tableid   : tgg00_Surrogate;
            VAR file_id   : tgg00_FileId);
 
VAR
      aux_id : tgg00_FileId;
 
BEGIN
g01check(kb64DropTree_csp03, csp3_n_data,
      'only impl for tfnColumn ',
      ord(file_id.fileTfn_gg00),
      file_id.fileTfn_gg00 = tfnColumn_egg00);
IF  gg06IsNilTrans (t.trWriteTransId_gg00)
THEN
    k50new_write_trans (t);
(*ENDIF*) 
kb64drop_lob_file (t, tableid, file_id, aux_id)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k64end_load (VAR m : tgg00_MessBlock);
 
VAR
      pos            : integer;
      rightmost_leaf : tsp00_PageNo;
      act_tree_id    : tgg00_FileId;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
IF  m.mb_type2 = mm_nokey
THEN
    k57adjust_table_key (m);
(*ENDIF*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    pos := cgg_rec_key_offset + m.mb_data^.mbp_keylen + 1;
    SAPDB_PascalMove ('VKB64 ',   2,    
          m.mb_data_size, sizeof (act_tree_id),
          @m.mb_data^.mbp_4kbuf, pos,
          @act_tree_id, 1,
          sizeof (act_tree_id), m.mb_trns^.trError_gg00)
    END;
(*ENDIF*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    pos := pos + sizeof (act_tree_id);
    rightmost_leaf                 := s20buf_to_int4 (m.mb_data^.mbp_4kbuf, pos);
    act_tree_id.fileRootCheck_gg00 := ROOT_CHECK_GG00;
    bd09FinishLoad(m.mb_trns^, act_tree_id, rightmost_leaf)
    END;
(*ENDIF*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    kb560StartSavepoint (m.mb_trns^, mm_read);
    k53commit (m.mb_trns^, mm_nil)
    END
(*ENDIF*) 
END;
 
(* PTS 1107952 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      k64rename_lob_file (
            VAR t         : tgg00_TransContext;
            VAR tableid   : tgg00_Surrogate;
            VAR source_id : tgg00_FileId;
            VAR target_id : tgg00_FileId);
 
BEGIN
t.trError_gg00 := e_ok;
source_id.fileBdUse_gg00 := [ ];
target_id.fileBdUse_gg00 := [ ];
kb641RenameLobFile (t, tableid, source_id, target_id);
END;
 
(*------------------------------*) 
 
PROCEDURE
      k64set_file_version (VAR m : tgg00_MessBlock);
 
VAR
      dummy_granted : tgg00_LockReqMode;
      new_file_vers : tgg91_FileVersion;
      dummy_k       : tgg00_Lkey;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
b01vstate_fileversion (m.mb_trns^, m.mb_qual^.mtree);
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    k53eot_excl_lock (m.mb_trns^, m.mb_qual^.mtree, dummy_k,
          false, lckSysExcl_egg00, dummy_granted);
(*ENDIF*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    a103CatalogCacheInvalidateTable (m.mb_trns^.trTaskId_gg00, m.mb_qual^.mtree.fileTabId_gg00);
    (* PTS 1120287 E.Z. *)
    new_file_vers := m.mb_qual^.mtree.fileVersion_gg00;
    gg06FileVersIncr (new_file_vers);
    IF  new_file_vers.ci2_gg00 >= cgg_special_file_version
    THEN
        BEGIN
        new_file_vers.ci2_gg00 [1] := chr (0);
        new_file_vers.ci2_gg00 [2] := chr (0)
        END
    (*ENDIF*) 
    ;
    (* PTS 1112997 *)
    IF  (ftsConcurrent_egg00 in m.mb_qual^.mtree.fileType_gg00) AND
        (ftsTemp_egg00       in m.mb_qual^.mtree.fileType_gg00)
    THEN
        BEGIN
        b01set_fileversion (m.mb_trns^, m.mb_qual^.mtree,
              new_file_vers, m.mb_qual^.mnew_long_cnt);
        IF  m.mb_trns^.trError_gg00 = e_ok
        THEN
            m.mb_qual^.mtree.fileVersion_gg00 := new_file_vers;
        (*ENDIF*) 
        END
    ELSE
        kb641SuccFileVersion (m.mb_trns^, m.mb_qual^.mtree, new_file_vers,
              m.mb_qual^.mold_long_cnt, m.mb_qual^.mnew_long_cnt);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    m.mb_type     := m_return_result;
    m.mb_type2    := mm_nil;
    m.mb_struct   := mbs_tree_id;
    m.mb_qual_len := FILE_ID_MXGG00;
    m.mb_data_len := 0
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k64short_col_file_create (
            VAR t          : tgg00_TransContext;
            VAR tree_id    : tgg00_FileId);
 
VAR
      short_scol_id : tgg00_FileId;
 
BEGIN
(* PTS 1115206 M.Ki. *)
short_scol_id                           := tree_id;
short_scol_id.fileTfn_gg00              := tfnShortScol_egg00;
short_scol_id.fileVersion_gg00.ci2_gg00 := cgg_dummy_file_version;
short_scol_id.fileRoot_gg00             := NIL_PAGE_NO_GG00;
short_scol_id.fileBdUse_gg00            := [ ];
(* *)
bd998NewFileNo (short_scol_id.fileTabId_gg00);
kb641CreateShortColumnFile (
      t,
      short_scol_id,
      tree_id.fileTabId_gg00);
(* *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k64table_create (VAR m : tgg00_MessBlock);
 
VAR
      createShortColFile : boolean;
      eFiletypeSet       : tgg00_ExtendedFiletypeSet;
 
BEGIN
(* create short string column                  *)
(* already exists: ALTER TABLE ... PRIMARY KEY *)
(* mlink_cnt : number of new long-columns without *)
(* short column file                              *)
createShortColFile := (m.mb_qual^.mstring_cnt > 0) AND
      (m.mb_qual^.mstring_cnt > m.mb_qual^.mlink_cnt) AND
      (m.mb_type2 <> mm_key);
eFiletypeSet := [];
k64CreateTable (m.mb_trns^, m.mb_qual^.mtree, m.mb_type2,
      eFiletypeSet, m.mb_qual^.mstring_cnt, createShortColFile);
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    m.mb_type     := m_return_result;
    m.mb_type2    := mm_nil;
    m.mb_struct   := mbs_stack_addr;
    m.mb_qual_len := MB_PART1_HEAD_MXGG00;  (* contains string cnt *)
    m.mb_data_len := 0
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k64CreateTable (
            VAR t              : tgg00_TransContext;
            VAR fileId         : tgg00_FileId;
            mess2_type         : tgg00_MessType2;
            eFiletypeSet       : tgg00_ExtendedFiletypeSet;
            str_col_cnt        : tsp00_Int2;
            createShortColFile : boolean);
 
VAR
      cr_mess2_type : tgg00_MessType2;
      dummy_granted : tgg00_LockReqMode;
      dummy_k       : tgg00_Lkey;
 
BEGIN
t.trError_gg00 := e_ok;
&ifdef TRACE
t01mess2type (kb, 'mess2_type  ', mess2_type);
t01msgcheck ('k64CreateTable: wrong type2   ',
      mess2_type in [mm_nil, mm_key, mm_nokey, mm_specialkey], ord (mess2_type));
&endif
k53eot_excl_lock (t, fileId, dummy_k, false, lckSysExcl_egg00, dummy_granted);
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    CASE mess2_type OF
        mm_nokey :
            cr_mess2_type := mm_nokey;
        mm_specialkey :
            cr_mess2_type := mm_specialkey;
        OTHERWISE
            cr_mess2_type := mm_nil;
        END;
    (*ENDCASE*) 
    (* *)
    (* If an old root became a root again an error may have occured. *)
    (* Now the file version starts with a random value which must    *)
    (* be equal only on each site and the probability of the same    *)
    (* error has decreased (drastically ???).                        *)
    (* *)
    fileId.fileVersion_gg00.ci2_gg00 [1] := t.trTransId_gg00.ci6_gg00 [6];
    fileId.fileVersion_gg00.ci2_gg00 [2] := chr (t.trSubtransId_gg00 MOD 256);
    (* *)
    k64create_bd_file (t, fileId, m_create_table, cr_mess2_type,
          eFiletypeSet, str_col_cnt)
    END;
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    k64set_treeleafnodes (t, fileId);
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok  )
    AND createShortColFile
THEN
    k64short_col_file_create (t, fileId);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k64temp_file_handling (VAR m : tgg00_MessBlock);
 
VAR
      aux_err     : tgg00_BasisError;
      i           : integer;
      new_file_id : tgg00_FileId;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
CASE m.mb_type OF
    m_destroy_temp:
        CASE m.mb_type2 OF
            mm_empty:
                b01empty_file (m.mb_trns^, m.mb_qual^.mtree);
            mm_nil:
                b01destroy_file (m.mb_trns^, m.mb_qual^.mtree);
            mm_prefix:
                BEGIN
                FOR i := m.mb_qual^.mcol_pos + 1 TO FN_MXGG00 DO
                    m.mb_qual^.mtree.fileName_gg00 [i] := chr(0);
                (*ENDFOR*) 
                b01prefix_destroy_files (m.mb_trns^,
                      m.mb_qual^.mtree.fileName_gg00,
                      m.mb_qual^.mcol_pos);
                m.mb_qual^.mtree.fileTfn_gg00     := tfnTemp_egg00;
                m.mb_qual^.mtree.fileTfnTemp_gg00 := ttfnTempInv_egg00;
                aux_err                 := m.mb_trns^.trError_gg00;
                m.mb_trns^.trError_gg00 := e_ok;
                b01prefix_destroy_files (m.mb_trns^,
                      m.mb_qual^.mtree.fileName_gg00, m.mb_qual^.mcol_pos);
                IF  aux_err <> e_ok
                THEN
                    m.mb_trns^.trError_gg00 := aux_err
                (*ENDIF*) 
                END
            END;
        (*ENDCASE*) 
    m_move:
        BEGIN
        SAPDB_PascalMove ('VKB64 ',   3,    
              sizeof (m.mb_qual^.buf), sizeof (new_file_id),
              @m.mb_qual^.buf, FILE_ID_MXGG00 + 1,
              @new_file_id, 1, sizeof (new_file_id), m.mb_trns^.trError_gg00);
        IF  m.mb_trns^.trError_gg00 = e_ok
        THEN
            BEGIN
            b01move_filecontent (m.mb_trns^, m.mb_qual^.mtree,
                  new_file_id);
            aux_err                 := m.mb_trns^.trError_gg00;
            m.mb_trns^.trError_gg00 := e_ok;
            a101_DestroyGroupedTempFile (m.mb_trns^, m.mb_qual^.mtree);
            IF  aux_err <> e_ok
            THEN
                m.mb_trns^.trError_gg00 := aux_err
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    OTHERWISE
        m.mb_trns^.trError_gg00 := e_not_implemented
    END;
(*ENDCASE*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    m.mb_type      := m_return_result;
    m.mb_type2     := mm_nil;
    m.mb_struct    := mbs_tree_id;
    m.mb_qual_len  := FILE_ID_MXGG00;
    m.mb_data_len  := 0
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k64set_treeleafnodes (
            VAR t      : tgg00_TransContext;
            VAR fileId : tgg00_FileId);
 
VAR
      dummy_granted     : tgg00_LockReqMode;
      old_treeleafnodes : tsp00_Int4;
      key               : tgg00_Lkey;
 
BEGIN
key.len  := 1;
key.k[1] := chr(1);
k53eot_excl_lock (t, fileId, key, false, lckRowExcl_egg00, dummy_granted);
IF  t.trError_gg00 = e_ok
THEN
    b01treeleafnodes (t, fileId, m_fetch, old_treeleafnodes);
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok)
    AND
    (fileId.fileLeafNodes_gg00 <> old_treeleafnodes)
THEN
    kb641UpdFileStatistic (t, fileId, old_treeleafnodes)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb64drop_lob_file (
            VAR t         : tgg00_TransContext;
            VAR tableid   : tgg00_Surrogate;
            VAR file_id   : tgg00_FileId;
            VAR aux_id    : tgg00_FileId);
 
VAR
      dummy_len    : integer;
 
BEGIN
&ifdef TRACE
t01msgcheck ('K64DROP_TREE: transindex = nil',
      t.trIndex_gg00 <> cgg_nil_transindex, t.trIndex_gg00);
&endif
t.trError_gg00     := e_ok;
file_id.fileBdUse_gg00 := [ ];
IF  file_id.fileTfn_gg00 <> tfnColumn_egg00
THEN
    kb641MarkFileAsDeleted(t, file_id)
ELSE
    BEGIN
    (* long columns are still dropped using the *)
    (* rename/prefix-destroy mechanism          *)
    k64build_aux_fn_prefix (t.trWriteTransId_gg00, c_perm, aux_id, dummy_len);
    k50aux_fn_no (t.trIndex_gg00, c_perm, aux_id.fileAuxCnt_gg00);
    aux_id.fileType_gg00 := file_id.fileType_gg00;
    aux_id.fileVersion_gg00.ci2_gg00 := cgg_dummy_file_version;
    aux_id.fileOldTfn_gg00 := file_id.fileTfn_gg00;
    k64rename_lob_file (t, tableid, file_id, aux_id)
    END;
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
