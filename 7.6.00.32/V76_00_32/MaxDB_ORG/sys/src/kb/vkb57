/****************************************************************************
  module      : vkb57
  author      : JuergenA,UweH
  responsible : UweH
  special area: Logging
  see also    :
  description : restart record implementation
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2001-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
*****************************************************************************/
 
.tt 1 $SAP$LiveCache$VKB57$
.tt 3 $UweH$KB_restart_record$2000-01-10$
 
Module  : KB_restart_record
 
Define  :
 
        PROCEDURE
              k57adjust_table_key (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k57allocate (VAR t : tgg00_TransContext);
 
        FUNCTION
              k57calc_checksum (VAR logpage : tkb00_Page): tsp00_Int4;
 
        PROCEDURE
              k57create_restartrecord (VAR t : tgg00_TransContext);
 
        PROCEDURE
              k57currval (
                    VAR t          : tgg00_TransContext;
                    buf_addr       : tsp00_MoveObjPtr;
                    buf_size       : tsp00_Int4;
                    firstpos       : integer;
                    resultbuf_addr : tsp00_MoveObjPtr;
                    resultbuf_size : tsp00_Int4;
                    resultpos      : integer;
                    VAR res_len    : tsp00_Int4);
 
        PROCEDURE
              k57overall_currval (
                    VAR t          : tgg00_TransContext;
                    buf_addr       : tsp00_MoveObjPtr;
                    buf_size       : tsp00_Int4;
                    firstpos       : integer;
                    resultbuf_addr : tsp00_MoveObjPtr;
                    resultbuf_size : tsp00_Int4;
                    resultpos      : integer;
                    VAR res_len    : tsp00_Int4);
 
        PROCEDURE
              k57dump_restartrec (
                    VAR hostfile : tgg00_VfFileref;
                    VAR buf      : tsp00_Page;
                    VAR out_pno  : tsp00_Int4;
                    VAR out_pos  : integer;
                    VAR host_err : tsp00_VfReturn;
                    VAR errtext  : tsp00_ErrText);
 
        PROCEDURE
              k57end_flush_sequences (taskid : tsp00_TaskId);
 
        PROCEDURE
              k57flush_sequences (VAR t : tgg00_TransContext);
 
        PROCEDURE
              kb57GetLastWriteTransNo (
                    TaskId  : tsp00_TaskId;
                    VAR TransNo : tgg91_TransNo);
 
        PROCEDURE
              kb57GetLastSessionNo (
                    TaskId  : tsp00_TaskId;
                    VAR SessionNo : tgg91_SessionNo);
 
        PROCEDURE
              k57info_seq_cache (
                    process_id      : tsp00_TaskId;
                    VAR cache_total : tsp00_8ByteCounter;
                    VAR cache_hit   : tsp00_8ByteCounter;
                    VAR cache_miss  : tsp00_8ByteCounter);
 
        PROCEDURE
              k57init_restartrec_handling (VAR t : tgg00_TransContext);
 
        PROCEDURE
              k57new_session (
                    TaskId           : tsp00_TaskId;
                    VAR SessionId    : tgg91_SessionNo);
 
        PROCEDURE
              k57new_write_trans (
                    TaskId               : tsp00_TaskId;
                    VAR WriteTransNo     : tgg91_TransNo);
 
        PROCEDURE
              k57nextval (
                    VAR t          : tgg00_TransContext;
                    buf_addr       : tsp00_MoveObjPtr;
                    buf_size       : tsp00_Int4;
                    firstpos       : tsp00_Int4;
                    resultbuf_addr : tsp00_MoveObjPtr;
                    resultbuf_size : tsp00_Int4;
                    resultpos      : tsp00_Int4;
                    VAR res_len    : tsp00_Int4);
 
        PROCEDURE
              k57put_sequence_value (
                    VAR t             : tgg00_TransContext;
                    VAR seq_surrogate : tgg00_Surrogate;
                    VAR val_buf       : tsp00_MoveObj;
                    val_buf_size      : tsp00_Int4;
                    val_buf_pos       : tsp00_Int4;
                    val_len           : tsp00_Int4);
 
        PROCEDURE
              kb57RedoTransNoIncrement (
                    TaskId      : tsp00_TaskId;
                    RedoTransNo : tgg91_TransNo);
 
        PROCEDURE
              kb57RefreshSequence (
                    VAR TransContext : tgg00_TransContext;
                    VAR SeqSurrogate : tgg00_Surrogate         (*ptocConst*);
                    VAR SeqValue     : tsp00_Number            (*ptocConst*));
 
        PROCEDURE
              kb57RefreshSurrogate (
                    VAR TaskId    : tsp00_TaskId;
                    VAR Surrogate : tgg00_Surrogate            (*ptocConst*);
                    VAR SysKey    : tgg00_Surrogate            (*ptocConst*));
 
        PROCEDURE
              kb57RefreshSurrogateIfNecessary (
                    VAR TaskId    : tsp00_TaskId    (*ptocConst*);
                    VAR Surrogate : tgg00_Surrogate (*ptocConst*));
 
        PROCEDURE
              k57save_restartrecord (TaskId : tsp00_TaskId);
 
        PROCEDURE
              k57select_restartrec (
                    TaskId : tsp00_TaskId;
                    pAcv  : tsp00_Addr;
                    pA41v : tsp00_Addr);
 
        PROCEDURE
              k57select_log_info (
                    TaskId : tsp00_TaskId;
                    pAcv  : tsp00_Addr;
                    pA41v : tsp00_Addr);
 
        PROCEDURE
              k57sequence_no (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k57set_not_generated;
 
        PROCEDURE
              k57stamp_logged (
                    VAR trans_state : tgg00_TransState;
                    task_id         : tsp00_TaskId;
                    stamp_type      : tgg00_MessType2;
                    buffer          : tsp00_MoveObjPtr;
                    buf_len         : tsp00_Int4;
                    VAR b_err       : tgg00_BasisError);
 
        PROCEDURE
              k57stamp (
                    task_id         : tsp00_TaskId;
                    stamp_type      : tgg00_MessType2;
                    buffer          : tsp00_MoveObjPtr (*ptocSynonym void**);
                    buf_len         : tsp00_Int4;
                    VAR b_err       : tgg00_BasisError);
 
        PROCEDURE
              k57statistics_reset (process_id : tsp00_TaskId);
 
        PROCEDURE
              k57surrogates_to_log (VAR t : tgg00_TransContext);
 
        PROCEDURE
              k57table_key_get (
                    pid             : tsp00_TaskId;
                    VAR trans_state : tgg00_TransState;
                    VAR syskey      : tgg00_Lkey);
 
        FUNCTION
              k57DBIdentifier : tsp00_BytePtr;
 
        FUNCTION
              kb57AnyOpenTransactionsExist : boolean;
 
        PROCEDURE
              kb57GetRestartRecordKernelVersion(
                    VAR kernelVersion : tsp00_Version);
 
        FUNCTION
              kb57GetFdirRoot : tsp00_PageNo;
 
        PROCEDURE
              kb57SetFdirRoot(
                    VAR root : tsp00_PageNo(*ptocConst*));
 
        FUNCTION
              kb57GetLongFdir : tsp00_PageNo;
 
        FUNCTION
              kb57GetFdirEntryCount : tsp00_Int4;
 
        PROCEDURE
              kb57SetFdirEntryCount(
                    VAR entryCount : tsp00_Int4(*ptocConst*));
 
        PROCEDURE
              k57GetLastFileId (
                    VAR lastFileId : tgg00_Surrogate);
 
        PROCEDURE
              k57SetLastFileId (
                    VAR lastFileId : tgg00_Surrogate);
 
        PROCEDURE
              k57SetSys1CatalogTabId (
                    VAR sys1CatalogTabId : tgg00_Surrogate);
 
        PROCEDURE
              k57SetSys2CatalogTabId (
                    VAR sys2CatalogTabId : tgg00_Surrogate);
 
        FUNCTION
              kb57GetOldConverterVersion(
                    pOldRestart : tkb57_OldRestarRecordPtr(* ptocSynonym tsp00_PageAddr *) ) : tsp00_Int4;
 
        FUNCTION
              kb57GetUSMRoot(
                    pOldRestart : tkb57_OldRestarRecordPtr(* ptocSynonym tsp00_PageAddr *) ) : tsp00_PageNo;
 
        FUNCTION
              kb57GetMaxDataPageNo(
                    pOldRestart : tkb57_OldRestarRecordPtr(* ptocSynonym tsp00_PageAddr *) ) : tsp00_PageNo;
 
        FUNCTION
              kb57MigrateRestartRecord(
                    pOldRestart : tkb57_OldRestarRecordPtr(* ptocSynonym tsp00_PageAddr *) ) : boolean;
 
        FUNCTION
              kb57IsMigrationFlagSet(
                    pOldRestart : tkb57_OldRestarRecordPtr(* ptocSynonym tsp00_PageAddr *) ) : boolean;
 
        PROCEDURE
              kb57InspectRestartRecordForRestore(
                    pRestart             : tkb00_PagePtr;
                    bIsRestoreData       : boolean;
                    VAR bRestorePossible : boolean;
                    VAR bMigrationNeeded : boolean);
 
        PROCEDURE
              kb57RestoreRestartRecord (TaskId : tsp00_TaskId);
 
        PROCEDURE
              kb57RestoreRestartRecordAfterMigration(
                    pOldRestart : tkb57_OldRestarRecordPtr(* ptocSynonym tsp00_PageAddr *));
 
        PROCEDURE
              kb57SetRootBlockAddr( PackedRootBlockAddr : tsp00_Int4 );
 
        PROCEDURE
              kb57SetMaxDynamicPageNo( MaxDynamicPageNo : tsp00_PageNo );
 
        PROCEDURE
              kb57SetMaxStaticPageNo( MaxStaticPageNo : tsp00_PageNo );
 
        PROCEDURE
              kb57SetVolumeNoBitCount( VolumeNoBitCount : tsp00_Uint1 );
 
        FUNCTION
              kb57GetClusterBlockCount : tsp00_Uint2;
 
        PROCEDURE
              kb57SetClusterBlockCount( ClusterBlockCount : tsp00_Uint2 );
 
        FUNCTION
              kb57GetClusterReservedSpace : tsp00_Uint4;
 
        PROCEDURE
              kb57SetClusterReservedSpace( ClusterReservedSpace : tsp00_Uint4 );
 
        FUNCTION
              kb57IsSnapShotDefined : boolean;
              (*ptocExport hkb57_1.h *)
 
        VAR
              k57frozen_restartrec : tkb00_PagePtr;
              k57restartrec        : tkb00_PagePtr;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              AK_Synonym : VAK23;
 
        PROCEDURE
              a23get_sequence_value (
                    VAR t             : tgg00_TransContext;
                    VAR seq_surrogate : tgg00_Surrogate;
                    VAR seq_value     : tsp00_Number;
                    VAR seq_first     : boolean);
 
        PROCEDURE
              a23flush_sequence (
                    VAR t              : tgg00_TransContext;
                    VAR seq_surrogate  : tgg00_Surrogate;
                    VAR seq_value      : tsp00_Number);
 
      ------------------------------ 
 
        FROM
              AK_Show_statistics : VAK42;
 
        PROCEDURE
              a42bool_to_intern_state (
                    acv_ptr     : tsp00_Addr;
                    a41v_ptr    : tsp00_Addr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    bool_val    : boolean);
 
        PROCEDURE
              a42date_to_intern_state (
                    acv_ptr     : tsp00_Addr;
                    a41v_ptr    : tsp00_Addr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    int_date    : tsp00_Int4);
 
        PROCEDURE
              a42int4_to_intern_state (
                    acv_ptr     : tsp00_Addr;
                    a41v_ptr    : tsp00_Addr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    int_val     : tsp00_Int4);
 
        PROCEDURE
              a42session_to_intern_state (
                    acv_ptr     : tsp00_Addr;
                    a41v_ptr    : tsp00_Addr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    session       : tgg91_SessionNo);
 
        PROCEDURE
              a42str_to_intern_state (
                    acv_ptr     : tsp00_Addr;
                    a41v_ptr    : tsp00_Addr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    str_ptr     : tsp00_MoveObjPtr;
                    str_len     : integer);
 
        PROCEDURE
              a42surrogate_to_intern_state (
                    acv_ptr     : tsp00_Addr;
                    a41v_ptr    : tsp00_Addr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    surrogate   : tgg00_Surrogate);
 
        PROCEDURE
              a42time_to_intern_state (
                    acv_ptr     : tsp00_Addr;
                    a41v_ptr    : tsp00_Addr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    int_time    : tsp00_Int4);
 
        PROCEDURE
              a42trans_to_intern_state (
                    acv_ptr     : tsp00_Addr;
                    a41v_ptr    : tsp00_Addr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    trans       : tgg91_TransNo);
 
        PROCEDURE
              a42uint1_to_intern_state (
                    acv_ptr     : tsp00_Addr;
                    a41v_ptr    : tsp00_Addr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    int_val     : tsp00_Int2);
 
        PROCEDURE
              a42uint2_to_intern_state (
                    acv_ptr     : tsp00_Addr;
                    a41v_ptr    : tsp00_Addr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    int_val     : tsp00_Int4);
 
        PROCEDURE
              a42uint4_to_intern_state (
                    acv_ptr     : tsp00_Addr;
                    a41v_ptr    : tsp00_Addr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    int_val     : tsp00_8ByteCounter);
 
      ------------------------------ 
 
        FROM
              pagestore : VBD10;
 
        FUNCTION
              bd10GetConverterVersion : tsp00_Int4;
 
        FUNCTION
              bd10GetVolumeNoBitCount : tsp00_Uint1;
 
      ------------------------------ 
 
        FROM
              KB_Check : VKB03;
 
        VAR
              kb03Check : tkb00_Check;
 
      ------------------------------ 
 
        FROM
              KB_Logging : VKB560;
 
        PROCEDURE
              kb560GetSavepointReasonString (
                    reasonid        : tsp00_Uint1;
                    VAR resonstring : tsp00_C40);
 
        PROCEDURE
              kb560GetSavepointStatistics (
                    VAR lastDurationSec      : tsp00_Int4;
                    VAR lastDurationMicroSec : tsp00_Int4;
                    VAR lastWrittenPages     : tsp00_Int4;
                    VAR lastIOcount          : tsp00_Int4;
                    VAR avgWrittenPages      : tsp00_Int4;
                    VAR avgIOcount           : tsp00_Int4);
 
        PROCEDURE
              kb560InitSavepointParam (VAR param : tkb00_SaveptParam);
 
        FUNCTION
              kb560GetLogInfo (
                    taskid                    : tsp00_TaskId;
                    VAR date                   : tsp00_Int4;
                    VAR time                   : tsp00_Int4;
                    VAR flushmode              : tsp00_Int4;
                    VAR devicestate            : tsp00_Int4;
                    VAR queuecount             : tsp00_Uint4;
                    VAR cycleendoffset         : tsp00_Uint4;
                    VAR oldestnotsavedoffset   : tsp00_Uint4;
                    VAR oldestnotsavedsequence : tsp00_Uint4;
                    VAR lastknownoffset        : tsp00_Uint4;
                    VAR lastknownsequence      : tsp00_Uint4;
                    VAR backupcount            : tsp00_Uint4;
                    VAR untildate              : tsp00_Int4;
                    VAR untiltime              : tsp00_Int4;
                    VAR untilclearloweroffset  : tsp00_Uint4;
                    VAR untilclearupperoffset  : tsp00_Uint4;
                    VAR untilsequenceafterredo : tsp00_Uint4;
                    VAR savepointsequence      : tsp00_Uint4;
                    VAR savepointdevoffset     : tsp00_Uint4;
                    VAR savepointoffset        : tsp00_Uint4) : boolean;
 
        FUNCTION
              k560IsSavepointAllowed : boolean;
 
      ------------------------------ 
 
        FROM
              KB_transaction : VKB53;
 
        PROCEDURE
              k53StartInternalSession (
                    VAR TransContext    : tgg00_TransContext;
                    VAR AuxTransContext : tgg00_TransContext;
                    bOpenNewTrans       : boolean;
                    bInheritLocalFDir   : boolean);
 
        PROCEDURE
              k53StopInternalSession (
                    VAR TransContext    : tgg00_TransContext;
                    VAR AuxTransContext : tgg00_TransContext;
                    typeOfTransEnd      : tgg00_MessType);
 
      ------------------------------ 
 
        FROM
              KB_RefreshSurrogSeq_interface : VKB571;
 
        PROCEDURE
              kb571AllSurrogateWaitsResume;
 
        PROCEDURE
              kb571SurrogateWaitInsert (
                    taskid          : tsp00_TaskId;
                    VAR waitcontext : tgg00_WaitContext);
 
        PROCEDURE
              kb571WriteRefreshSeqAfterImage (
                    VAR TransContext : tgg00_TransContext;
                    SequenceCount    : tsp00_Int4;
                    pSequenceList    : tsp00_Addr);
 
        PROCEDURE
              kb571WriteRefreshSurrogAfterImage (
                    VAR TransContext : tgg00_TransContext;
                    VAR Surrogate    : tgg00_Surrogate;
                    VAR SysKey       : tgg00_Surrogate);
 
        PROCEDURE
              kb571GetOldestCompatibleVersionString(VAR version : tsp00_C10);
 
      ------------------------------ 
 
        FROM
              KB_get : VKB71;
 
        PROCEDURE
              k71num_err_to_b_err (
                    num_err : tsp00_NumError;
                    VAR e : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01zerokey : tsp00_Key;
 
      ------------------------------ 
 
        FROM
              error_text_handling : VBD06;
 
        PROCEDURE
              b06put_errtxt (
                    VAR t          : tgg00_TransContext;
                    pid            : tsp00_TaskId;
                    errlen         : integer;
                    etexttype      : tgg04_ErrorText;
                    b_err_in       : tgg00_BasisError;
                    VAR errtxt     : tsp00_C256;
                    VAR b_err_out  : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              BD_Wrapper : VBD999;
 
        PROCEDURE
              bd999ReadRestartPage(
                    TaskId : tsp00_TaskId;
                    VAR p  : tkb00_PagePtr);
 
        PROCEDURE
              bd999WriteRestartPage(
                    TaskId : tsp00_TaskId;
                    VAR p  : tkb00_PagePtr);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01hashprime : tgg00_HashPrimeList;
 
        PROCEDURE
              g01abort (
                    msg_no     : tsp00_Int4;
                    msg_label  : tsp00_C8;
                    msg_text   : tsp00_C24;
                    bad_value  : tsp00_Int4);
 
        PROCEDURE
              g01allocate_msg (
                    msg_label  : tsp00_C8;
                    msg_text   : tsp00_C24;
                    alloc_size : tsp00_Int4);
 
        FUNCTION
              g01cache_size (cache_type : tgg04_CacheType) : tsp00_Int4;
 
        PROCEDURE
              g01new_dump_page (
                    VAR hostfile : tgg00_VfFileref;
                    VAR buf      : tsp00_Page;
                    VAR out_pno  : tsp00_Int4;
                    VAR out_pos  : integer;
                    VAR host_err : tsp00_VfReturn;
                    VAR errtext  : tsp00_ErrText);
 
        PROCEDURE
              g01opmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C24;
                    msg_value : tsp00_Int4);
 
        PROCEDURE
              g01optextmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C40);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        FUNCTION
              gg06IsSurrogateGreater(
                    VAR surrogateA : tgg00_Surrogate (*ptocConst*);
                    VAR surrogateB : tgg00_Surrogate (*ptocConst*)) : BOOLEAN;
 
        FUNCTION
              gg06IsMaxSession (VAR SessionNo : tgg91_SessionNo): boolean;
 
        FUNCTION
              gg06IsMaxTrans (VAR TransNo : tgg91_TransNo): boolean;
 
        PROCEDURE
              gg06SessionIncr (VAR SessionNo : tgg91_SessionNo);
 
        PROCEDURE
              gg06SetZeroSession (VAR SessionNo : tgg91_SessionNo);
 
        PROCEDURE
              gg06SetZeroTrans (VAR TransNo : tgg91_TransNo);
 
        PROCEDURE
              gg06TransIncr (VAR TransNo : tgg91_TransNo);
 
      ------------------------------ 
 
        FROM
              Regions_and_Longwaits : VGG08;
 
        VAR
              g08surrogate : tsp00_RegionId;
 
        PROCEDURE
              g08excl_check (
                    pid          : tsp00_TaskId;
                    region       : tsp00_RegionId);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id   : tsp00_C6;
                    mod_num  : tsp00_Int4;
                    obj_upb  : tsp00_Int4;
                    obj      : tsp00_MoveObjPtr;
                    obj_pos  : tsp00_Int4;
                    length   : tsp00_Int4;
                    fillchar : char;
                    VAR e    : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Kernel-Version : VGG11;
 
        PROCEDURE
              g11kernel_version  (VAR vers : tsp00_Version);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vbegexcl (
                    pid     : tsp00_TaskId;
                    region  : tsp00_RegionId);
 
        PROCEDURE
              vendexcl (
                    pid     : tsp00_TaskId;
                    region  : tsp00_RegionId);
 
        PROCEDURE
              vfwrite (
                    hostfileno    : tsp00_Int4;
                    buf           : tsp_vf_bufaddr;
                    VAR error     : tsp00_VfReturn;
                    VAR errtext   : tsp00_ErrText);
 
        PROCEDURE
              vnewbuf (
                    count         : tsp00_Int4;
                    VAR available : tsp00_Int4;
                    VAR p         : tkb00_PagePtr;
                    VAR ok        : boolean);
 
        PROCEDURE
              vsuspend (
                    pid            : tsp00_TaskId;
                    suspend_reason : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        FUNCTION
              s20buf_to_int4 (
                    VAR source    : tgg00_Surrogate;
                    source_pos    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30klen (
                    VAR str : tsp00_Number;
                    val : char; cnt : integer) : integer;
 
        PROCEDURE
              s30surrogate_incr (VAR surrogate : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              Number-Arithmetic : VSP51;
 
        PROCEDURE
              s51add (
                    VAR left       : tsp00_Number;
                    lpos           : tsp00_Int4;
                    llen           : integer;
                    VAR right      : tsp00_Number;
                    rpos           : tsp00_Int4;
                    rlen           : integer;
                    VAR result     : tsp00_Number;
                    respos         : tsp00_Int4;
                    reslen         : integer;
                    resfrac        : integer;
                    VAR resbytelen : integer;
                    VAR ret        : tsp00_NumError);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              a42bool_to_intern_state;
 
              tak_acv_address     tsp00_Addr
              tak40_show_glob_ptr tsp00_Addr
 
        PROCEDURE
              a42cint6_to_intern_state;
 
              tak_acv_address     tsp00_Addr
              tak40_show_glob_ptr tsp00_Addr
 
        PROCEDURE
              a42date_to_intern_state;
 
              tak_acv_address     tsp00_Addr
              tak40_show_glob_ptr tsp00_Addr
 
        PROCEDURE
              a42int4_to_intern_state;
 
              tak_acv_address     tsp00_Addr
              tak40_show_glob_ptr tsp00_Addr
 
        PROCEDURE
              a42logpos_to_intern_state;
 
              tak_acv_address     tsp00_Addr
              tak40_show_glob_ptr tsp00_Addr
 
        PROCEDURE
              a42mess_to_intern_state;
 
              tak_acv_address     tsp00_Addr
              tak40_show_glob_ptr tsp00_Addr
 
        PROCEDURE
              a42mess2_to_intern_state;
 
              tak_acv_address     tsp00_Addr
              tak40_show_glob_ptr tsp00_Addr
 
        PROCEDURE
              a42session_to_intern_state;
 
              tak_acv_address     tsp00_Addr
              tak40_show_glob_ptr tsp00_Addr
 
        PROCEDURE
              a42str_to_intern_state;
 
              tak_acv_address     tsp00_Addr
              tak40_show_glob_ptr tsp00_Addr
 
        PROCEDURE
              a42surrogate_to_intern_state;
 
              tak_acv_address     tsp00_Addr
              tak40_show_glob_ptr tsp00_Addr
 
        PROCEDURE
              a42time_to_intern_state;
 
              tak_acv_address     tsp00_Addr
              tak40_show_glob_ptr tsp00_Addr
 
        PROCEDURE
              a42trans_to_intern_state;
 
              tak_acv_address     tsp00_Addr
              tak40_show_glob_ptr tsp00_Addr
 
        PROCEDURE
              a42uint1_to_intern_state;
 
              tak_acv_address     tsp00_Addr
              tak40_show_glob_ptr tsp00_Addr
 
        PROCEDURE
              a42uint2_to_intern_state;
 
              tak_acv_address     tsp00_Addr
              tak40_show_glob_ptr tsp00_Addr
 
        PROCEDURE
              a42uint4_to_intern_state;
 
              tak_acv_address     tsp00_Addr
              tak40_show_glob_ptr tsp00_Addr
 
        PROCEDURE
              b01rwrite_restartpage;
 
              tsp00_PageAddr tkb00_PagePtr
 
        PROCEDURE
              vnewbuf;
 
              tsp00_PageAddr tkb00_PagePtr
 
        FUNCTION
              s30klen;
 
              tsp00_MoveObj tsp00_Number
 
        PROCEDURE
              s30surrogate_incr;
 
              tsp00_C8 tgg00_Surrogate
 
        FUNCTION
              s20buf_to_int4;
 
              tsp00_MoveObj tgg00_Surrogate
 
        PROCEDURE
              s51add;
 
              tsp00_MoveObj tsp00_Number
 
.CM *-END-* synonym -------------------------------------
Author  :  R. Munz/J.Aurisch
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
Restart record handling, surrogate and sequence administration
.sp 2;.cp 4
Procedure K57ADJUST_TABLE_KEY
.sp
RST_LAST_SYSKEY is set to the value contained in PART2 of the MESSAGE
BUFFER, if this value is grater than RST_LAST_SYSKEY.
.sp 2;.cp 4
Procedure #
.sp
The restart record is allocated via VNEWBUF if this has not already
taken place.
.sp 2;.cp 4
Procedure K57DUMP_RESTARTREC
.sp
This procedure writes either "K57UNDEF" if K57RESTARTREC is not
allocated or writes the following information to the specified
host file:
.nf;.sp;.cp 8
K57VARS:    Dump_code         2 Bytes = 1501
            LAST_SURROGATE    8 Bytes
            LAST_SYSKEY       8 Bytes
            SEQUENCE_NO       4 Bytes
            IS_UPDATED        1 Byte
            FILLER            3 Bytes
.sp
            K57RESTARTREC^    1 Page
.sp 2;.cp 6
Procedure K57INIT_TRANS_SESSION
.sp
For the consecutive numbering of the sessions, the transid requires
the session_number that has been incremented by one (in the restart
record RUN_ID) during a logon. The restart record provided with the new
RUN_ID is written onto the disk.
.sp 2;.cp 4
Procedure K57MV_LOGPAGE_TO_RESTARTREC
.sp
A checkpoint logpage is assigned to the restartrec and the K57 variables
are initialized.
.sp 2;.cp 4
Procedure K57MV_RESTARTREC_TO_LOGPAGE
.sp
The K57 variables are assigned to the restartrec in order to assign
the restartrec to a checkpoint logpage.
.sp 2;.cp 4
Procedure K57NEXTVAL
.sp
The next SEQUENCE_NO is assigned to the RESULTBUF at position
RESULTPOS. After that the SEQUENCE_NO is incremented according to
the specifications of the MESSAGE BUFFER.
.sp 2;.cp 3
Procedure K57RESET_RESTARTRECORD
.sp
The restart record is read from the disk.
.sp 2;.cp 3
Procedure K57SAVE_RESTARTRECORD
.sp
The restart record is written onto the disk.
.sp 2;.cp 6
Procedure K57SEQUENCE_NO
.sp
Returns the next SEQUENCE_NO and updates the restart record
accordingly, WITHOUT writing it onto the disk. Instead, the
SEQUENCE_NP is written to the log at the time of each (signal)
commit and rollback. If MB_TYPE2 = MM_WRITE the SEQUENCE_NO is
reset by the value of MP_PART1.
.sp 2;.cp 5
Procedure K57SET_NOT_GENERATED
.sp
The state is set that the restart record is not allocated.
This procedure is called when the kernel is initialized.
.sp 2;.cp 3
Procedure K57STAMP
.sp
Assignes the next LAST_TABLE_KEY to part2 of the message buffer
and updates the restart record accordingly, WITHOUT writing it
onto the disk. Instead, the LAST_TABLE_KEY is written to
the log at the time of each (signal) commit and rollback.
.sp 2;.cp 4
Procedure K57SURROGATES_TO_LOG
.sp
The K57 variables (SURROGATES) are copied to the log.
.sp 2;.cp 6
Procedure K57TABLE_KEY_GET
.sp
Returns the next LAST_TABLE_KEY and updates the restart record
accordingly, WITHOUT writing it onto the disk. Instead, the
LAST_TABLE_KEY is written to the log at the time of each (signal)
commit and rollback.
.CM *-END-* specification -------------------------------
.cp 5
.sp 2
***********************************************************
.sp
.cp 5
.fo
.oc _/1
Description:
.sp
Var K57RESTARTREC
.sp
Pointer to the restart page. The restart page is identical to the
last checkpoint page in the log except for the page mode SYS.
.sp
The restart page contains the following entries:
.sp;.hi 18
LPNO the log page number of the checkpoint log page
.sp
LPAGEMODE         page~type:~p_restart~- 4th page on first devspace
.sp;~             ~~~~~~~~~~~p_log~~~~~- checkpoint
.br;~             ~~~~~~~~~~~~~~~~~~~~~~ 3rd page within log area
.sp
LMODE             l_checkpoint~~- checkpoint
.br;~             ~~~~~~~~~~~~~~~ 4th page on first devspace
.sp;~             l_restart_rec - 3rd page wihtin log area
.sp
LPOS used part of the restartrec = mxkb_logpagespace
.sp
LAST_CHECKPT the log page number of the previous checkpoint
.sp
CHECKPT_COUNT initialized by INIT~CONFIG, SAVE~DATA and SAVE~PAGES
.sp
CHECKPT_DATE when this checkpoint was created
.sp
CHECKPT_TIME when this checkpoint was created
.sp
CHECKPT_STATE message type defining the reason for checkpoint writing
.sp
IS_CONSISTENT_DB true indicates, that a restart can be performed without
the log in a non distributed environment (i.e. after normal SHUTDOWN)
.sp
SAVEPT_LPOS the savepoint entry starts at this position within the log
page
.sp
SAVEPT_LPNO the  the number of the log page containing
the beginning of the last savepoint
.sp
SAVEPT_COUNT set to zero every time a checkpoint is created
.sp
LOG_FIRST_USED the position of the first valid log page in the
archive log
.sp
SHORTLOG_FIRST_USED the position of the first valid log page in the
short log
.sp
LPNO_PREV_DIST_EOT the number of the log page containing the previous
distributed commit or rollback
.sp
LPOS_PREV_DIST_EOT the previous distributed commit or rollback starts at
this position within the logpage
.sp
FILLER1
.sp
LAST_SAVE_DATA the log page number of the last SAVE~DATA or SAVE~PAGES
.sp
LAST_SESSION the number of the last session
.br;~ (session counter per serverdb)
.sp
LAST_SURROGATE the last assigned surrogate of this serverdb
.sp
LAST_SYSKEY the last assigned internal key of this serverdb
for tables without an explicit key column
.sp
CONFIG_PHASE indicates the steps at INIT~CONFIG and ACTIVATE
.sp
IS_END_OF_SEGMENT true indicates, that this checkpoint is the
last page of a SAVE~LOG~SEGMENT command
.sp
IS_LOG_COLD_SAVED true indicates, that SAVE~LOG~COLD was performed
(now RESTORE~LOG is allowed)
.sp
IS_VERIFIED_DB false indicates, that the last restart was aborted and
one a verify handling has to be performed
.sp
LAST_ROOT_VERIFY specifiy the root for the verify handling
.sp
LAST_LEAF_VERIFY specify a leaf for the verify handling
.sp
LAST_TREE_VERIFY specify a tree for the verify handling
.sp
LPNO_END_DIST_LOG the number of the log page containing the end of the
last distributed signal, commit or rollback log entry
.sp
LPOS_END_DIST_LOG the last distributed signal, commit or rollback
entry is finished at this position within the logpage
.sp
LPOS_PREV_REPLI_EOT the last signal, commit or rollback for a
transaction with replicated data starts at this position within
the logpage
.sp
LPNO_PREV_REPLI_EOT the number of the log page containing the beginning
of the last signal, commit or rollback for a
transaction with replicated data
.sp
SEGMENT-START the log page number specifies the beginning of this
log segment
.sp
PREV_SEGMENT_START the log page number specifies the beginning of the
previous log segment
.sp
END_PENDING_COPY the number of the last log page containing
copies of pending transactions (this LPNO is used to avoid
additional pending copies by subsequent checkpoint writing)
.sp
SEQUENCE_NO the last assigned sequence number of this serverdb
.sp
LPNO_LAST_REPLI_SEOT the number of the log page containing the
beginning of the last signal for a transaction with replicated data
.sp
LPOS_LAST_REPLI_SEOT the last signal for a transaction with
replicated data starts at this position within the logpage
.sp
LAST_REPLI_SEOT_ID the transid of the last signal for a transaction
with replicated data
.hi
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 5
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_is_restart         = true;
      c_inherit_locfdir    = true; (* PTS 1132447 FF*)
      ckb57_seq_hash_value = 97;
      (* *)
      VERSION               = 'version             ';           (* UH 2003-07-04 *)
      SVP                   = 'savepoint           ';           (* PTS 1119276 UH 2002-12-10 *)
      RREC                  = 'restart record      ';           (* PTS 1108435 JA 2000-11-30 *)
      LOGINFO               = 'log info            ';
      (* *)
      D01_PAGE_NO           = 'checkpoint page no                      ';
      D03_CONFIG_PHASE      = 'config phase                            ';
      D04_SET_END_READ_ONLY = 'set end read only                       ';
      D05_LAST_SAVE_DATA    = 'last save data successful               ';
      D06_CONVERTER_VERS    = 'converter version                       ';
      D07_PREV_CONV_VERS    = 'previous converter version              ';
      D08_CURR_BACKUP_VERS  = 'current backup version                  ';
      D09_PREV_BACKUP_VERS  = 'previous backup version                 ';
      (* *)
      D21_CONF_FDIR_ROOT    = 'file directory root                     ';
      D22_CONF_LONGDIR_ROOT = 'long directory root                     ';
      D23_CONF_MAX_DYN_PNO  = 'max dynamic data pno                    ';
      D24_CONF_MAX_STAT_PNO = 'max static data pno                     ';
      (* *)
      D50_SVP_ID              = 'savepoint id                            ';
      D51_SVP_REASON          = 'savepoint reason                        ';
      D52_SVP_OPEN_TRANS      = 'savepoint open trans count              ';
      D53_SVP_IOSEQUENCE      = 'savepoint start iosequence              ';
      D54_SVP_STARTOFFSET     = 'savepoint start offset of page on device';
      D55_SVP_STARTENTRYOFF   = 'savepoint start offset of entry in page ';
      D56_SVP_DATE            = 'savepoint date                          ';
      D57_SVP_TIME            = 'savepoint time                          ';
      D58_SVP_OPEN_TRANS_ROOT = 'savepoint open trans file root          ';
      D59_SVP_HISTORY_ROOT    = 'savepoint history directory root        ';
      D60_SVP_ENTRY_TYPE      = 'savepoint start entry type              ';
      D61_SVP_ENTRY_DATE      = 'savepoint start entry date              ';
      D62_SVP_ENTRY_TIME      = 'savepoint start entry time              ';
      (* *)
      D60_LOG_LASTFLUSHDATE   = 'last flush date                         ';
      D61_LOG_LASTFLUSHTIME   = 'last flush time                         ';
      D62_LOG_FLUSHMODE       = 'flush mode                              ';
      D63_LOG_DEVICESTATE     = 'device state                            ';
      D64_LOG_QUEUECOUNT      = 'queue count                             ';
      D65_LOG_CYCLEENDOFFSET  = 'cycle related end offset                ';
      D66_LOG_NOTSAVEDOFFSET  = 'oldest not saved offset                 ';
      D67_LOG_NOTSAVEDSEQ     = 'oldest not saved sequence               ';
      D68_LOG_LASTKNOWNOFFSET = 'last known offset                       ';
      D69_LOG_LASTKNOWNSEQ    = 'last known sequence                     ';
      D70_LOG_BACKUPCOUNT     = 'log backup count                        ';
      D71_LOG_SAVEPOINTSEQ    = 'last savepoint sequence                 ';
      D72_LOG_SAVEPOINTDEVOFF = 'last savepoint offset on device         ';
      D73_LOG_SAVEPOINTOFFSET = 'last savepoint offset in page           ';
      D74_SVP_DURATION_SEC    = 'last duration (sec)                     ';
      D75_SVP_DURATION_MSEC   = 'last duration (microsec)                ';
      D76_SVP_LAST_WRITTEN    = 'last written page count                 ';
      D77_SVP_LAST_IO         = 'last io count                           ';
      D78_SVP_AVG_WRITTEN     = 'average written page count              ';
      D79_SVP_AVG_IO          = 'average io count                        ';
      (* *)
      D80_SURR_SESSION      = 'max used session no                     ';
      D81_SURR_SURROGATE    = 'max used surrogate                      ';
      D82_SURR_SYSKEY       = 'max used syskey                         ';
      D83_SURR_TRANS        = 'max used transaction no                 ';
      (* *)
      D91_DATA_BACKUP_CNT   = 'data backup count                       ';
      D92_LAST_DATA_BACKUP  = 'last data backup page no                ';
      D93_DB_IDENT          = 'database identifier                     ';
      D94_RELEASE_VERSION   = 'last savepoint release version          ';
      D95_CONF_RELEASE_VERS = 'install serverdb release version        ';
      (* *)
      D100_OLDEST_COMPATIBLE_VERSION = 'oldest compatible version               ';
 
TYPE
      tkb57_seq_cache_ptr = ^tkb57_seq_cache_entry;
 
      tkb57_seq_cache_entry = RECORD
            sqc_surrogate : tgg00_Surrogate;
            sqc_value     : tsp00_Number;
            sqc_log_value : tsp00_Number;
            sqc_flush     : boolean;
            sqc_log       : boolean;
            sqc_first     : boolean;
            sqc_filler    : boolean;
            sqc_lru_ts    : tsp00_Int4;
            CASE boolean OF
                true :
                    (sqc_hash_next : tkb57_seq_cache_ptr;
                    sqc_log_next   : tkb57_seq_cache_ptr);
                false :
                    (sqc_next_free : tkb57_seq_cache_ptr);
                END;
            (*ENDCASE*) 
 
      tkb57_seq_cache = ARRAY[1..MAX_INT2_SP00] OF tkb57_seq_cache_entry;
 
      tkb57_seq_hash_entry = RECORD
            sqh_first : tkb57_seq_cache_ptr;
            sqh_last  : tkb57_seq_cache_ptr;
      END;
 
 
      tkb57_glob = RECORD
            surrogate_upd  : boolean;
            surrog_logging : boolean;
            filler2        : tsp00_Int2;
            lru_timestamp  : tsp00_Int4;
            (* *)
            seq_hit        : tsp00_8ByteCounter; (* PTS 1103743 JA 1999-08-25 *)
            (* *)
            seq_miss       : tsp00_8ByteCounter; (* PTS 1103743 JA 1999-08-25 *)
            (* *)
            seq            : ^tkb57_seq_cache;
            seq_free       : tkb57_seq_cache_ptr;
            seq_log        : tkb57_seq_cache_ptr;
            seq_head       : ARRAY[0..ckb57_seq_hash_value]
                  OF tkb57_seq_hash_entry;
      END;
 
 
      tkb57_OldConfigRestartParam = RECORD (* for migration from 7.2/7.3 to 7.4 *)
            crMaxDataPno_kb57     : tsp00_Int4;
            crFdirRoot_kb57       : tsp00_PageNo;
            (* *)
            crLongDirRoot_kb57    : tsp00_PageNo;
            crUsmRoot_kb57        : tsp00_PageNo;
            (* *)
            crReleaseVers_kb57    : tsp00_Version;
            (* *)
            crMaxUsedDataPno_kb57 : tsp00_PageNo;
            crFiller1_kb57        : tsp00_Int4;
            (* *)
            crFiller2_kb57        : tsp00_Int4;
            crFiller3_kb57        : tsp00_Int4
      END;
 
 
      tkb57_SaveptParam = RECORD (* for migration from 7.2/7.3 to 7.4 *)
            svpId_kb57            : tsp00_Int4;
            svpReason_kb57        : tgg00_MessType;
            svpReason2_kb57       : tgg00_MessType2;
            svpIsCheckpt_kb57     : boolean;
            svpFiller1_kb57       : boolean;
            (* *)
            svpStartLogPos_kb57   : tgg00_LogPos;
            svpFirstUsed_kb57     : tgg00_LogPos;
            (*                                          24 bytes *)
            svpPrevSavept_kb57    : tgg00_LogPos;
            svpSeqStart_kb57      : tgg90_Cint6; (*tkb00_LogEntrySeq*)
            svpSeqRedoStart_kb57  : tgg90_Cint6; (*tkb00_LogEntrySeq*)
            (*                                          24 bytes *)
            svpSeqRollbTrunc_kb57 : tgg90_Cint6; (*tkb00_LogEntrySeq*)
            svpOpenTransCnt_kb57  : tsp00_Int2;
            (* *)
            svpPrevCheckptId_kb57 : tsp00_PageNo;
            svpSaveptCnt_kb57     : tsp00_Int4;
            (* *)
            svpCheckptCnt_kb57    : tsp00_Int4;
            svpFiller2_kb57       : tsp00_Int4;
            svpFiller3_kb57       : tsp00_Int4;
            svpFiller4_kb57       : tsp00_Int4;
            (*                                          16 bytes *)
            svpInfoLogBupCnt_kb57 : tsp00_Int4;
            svpFiller5_kb57       : tsp00_Int4;
            (* *)
            svpDate_kb57          : tsp00_Int4;
            svpTime_kb57          : tsp00_Int4;
      END;
 
 
      tkb57_OldRestarRecord = RECORD (* for migration from 7.2/7.3 to 7.4 *)
            rstLogPos_kb57            : tgg00_LogPos;
            rstFiller1_kb57           : tsp00_Int4;
            (* *)
            rstIsConsistentDb_kb57    : boolean;
            rstConfigPhase_kb57       : tkb00_ConfigPhase;
            rstSetEndReadOnly_kb57    : boolean;
            rstMigrationDone_kb57     : boolean;
            rstFiller3_kb57           : tsp00_Int4;
            (* *)
            rstConverterVersion_kb57  : tsp00_Int4;
            rstPrevConverterVers_kb57 : tsp00_Int4;
            (* *)
            rstCurrBackupVersion_kb57 : tsp00_Int4;
            rstPrevBackupVersion_kb57 : tsp00_Int4;
            (* *)
            rstFormerUpdatedDataPages_kb57 : tsp00_Int4;
            rstPreparedBupVers_kb57        : tsp00_Int4;
            (* *)
            rstConfigParam_kb57       : tkb57_OldConfigRestartParam;
            rstFurtherUse1_kb57       : tsp00_C80;
            (* *)
            rstLastSavept_kb57        : tkb57_SaveptParam;
            rstFurtherUse2_kb57       : tsp00_C64;
            (* *)
            rstLastSurrogate_kb57     : tkb00_SurrogateParam;
            rstFurtherUse3_kb57       : tsp00_C70;
            rstFurtherUse4_kb57       : tsp00_C2;
            (* *)
            rstFurtherUse5_kb57       : tsp00_C70;
            rstFurtherUse6_kb57       : tsp00_C70;
            rstTotalLogDevSize_kb57   : tsp00_Int4;
            (* *)
            rstDataBackupCnt_kb57     : tsp00_Int4;
            rstLastDataBackup_kb57    : tsp00_PageNo;
            (* *)
            rstReleaseVersion_kb57    : tsp00_Version;
            rstDbIdent_kb57           : tsp00_Line
      END;
 
      tkb57_OldRestarRecordPtr = ^tkb57_OldRestarRecord;
 
VAR
      k57 : tkb57_glob;
 
 
(*------------------------------*) 
 
PROCEDURE
      k57adjust_table_key (VAR m : tgg00_MessBlock);
 
VAR
      syskey_site : tgg00_ServerdbNo;
      syskey      : tgg00_Surrogate;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
IF  m.mb_data^.mbp_rec.keylen <> SURROGATE_MXGG00 + 1
THEN
    m.mb_trns^.trError_gg00 := e_illegal_key
ELSE
    SAPDB_PascalMove ('VKB57 ',   1,    
          m.mb_data_size, sizeof (syskey),
          @m.mb_data^.mbp_4kbuf, cgg_rec_key_offset + 2,
          @syskey, 1, sizeof (syskey), m.mb_trns^.trError_gg00);
(*ENDIF*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    syskey_site [1] := syskey [1];
    syskey_site [2] := syskey [2];
    IF  syskey_site <> cgg04_dummy_site
    THEN
        BEGIN
        m.mb_trns^.trState_gg00 :=
              m.mb_trns^.trState_gg00 + [tsSurrogateUpd_egg00];
        vbegexcl (m.mb_trns^.trTaskId_gg00, g08surrogate);
        kb57wait_for_surrogate_log (m.mb_trns^.trTaskId_gg00);
        k57.surrogate_upd := true;
        WITH k57restartrec^.rstLastSurrogate_kb00 DO
            IF  (syskey [1] <> srgSyskey_kb00 [1]) OR
                (syskey [2] <> srgSyskey_kb00 [2])
            THEN (* site not equal *)
                m.mb_trns^.trError_gg00 := e_illegal_key
            ELSE
                IF  syskey >= srgSyskey_kb00
                THEN
                    BEGIN
                    srgSyskey_kb00 := syskey;
                    s30surrogate_incr (srgSyskey_kb00)
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDWITH*) 
        vendexcl (m.mb_trns^.trTaskId_gg00, g08surrogate)
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57allocate (VAR t : tgg00_TransContext);
 
VAR
      ok             : boolean;
      available      : tsp00_Int4;
      seq_cache_size : tsp00_Int4;
      buf_addr       : tkb00_PagePtr;
      aux_ptr        : tkb00_PagePtr;
 
BEGIN
t.trError_gg00     := e_ok;
k57.surrogate_upd  := false;
k57.surrog_logging := false;
seq_cache_size     := g01cache_size (cachSequence_egg04);
g01allocate_msg (csp3_n_dyndata, 'DYND_K57_KB_PAGES      :',
      1 + 1 + 8 + seq_cache_size);
ok := true;
vnewbuf (1, available, k57restartrec, ok);
IF  ok
THEN
    vnewbuf (1, available, k57frozen_restartrec, ok);
(*ENDIF*) 
IF  ok
THEN
    BEGIN
    vnewbuf (seq_cache_size, available, aux_ptr, ok);
    IF  ok
    THEN
        k57.seq := @aux_ptr^
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  NOT ok
THEN
    BEGIN
    g01abort (kb57x1Allocate_csp03, csp3_n_restart,
          'K57: DYNDATA EXCEEDED   ', 0);
    t.trError_gg00 := e_sysbuf_storage_exceeded
    END
ELSE
    kb57init_sequence_cache (seq_cache_size);
(*ENDIF*) 
k57.filler2 := 0;
END;
 
(*------------------------------*) 
 
FUNCTION
      k57calc_checksum (VAR logpage : tkb00_Page): tsp00_Int4;
 
CONST
      c_page_check_step    = 128;
      c_checkpt_check_step =  32;
      mx_checkpt_check     = 512;
 
VAR
      prime_idx   : integer;
      pos         : tsp00_Int4;
      logbody_len : tsp00_Int4;
      check_sum   : tsp00_Int4;
 
BEGIN
check_sum := 0;
WITH logpage DO
    BEGIN
    FOR pos := 1 TO 4 DO
        check_sum := check_sum +
              ord (pageHeader_kb00.pageHeaderStr_gg00 [pos]) * g01hashprime [pos];
    (*ENDFOR*) 
    check_sum := check_sum + ord (pageType2_kb00) * g01hashprime [5];
    prime_idx := 6;
    IF  pagePposFree_kb00 - 1 >= sizeof (pageLogBody_kb00)
    THEN
        logbody_len := sizeof (pageLogBody_kb00)
    ELSE
        logbody_len := pagePposFree_kb00 - 1;
    (*ENDIF*) 
    IF  (pageType2_kb00 = pt2Checkpt_egg00) OR
        (pageType2_kb00 = pt2LogInfo_egg00  )
    THEN
        (* check bytes: 0+1, 0+4, 32+1, 32+4, ... *)
        BEGIN
        pos := 1;
        WHILE (pos < mx_checkpt_check)
              AND
              (prime_idx < MAX_HASH_PRIME_GG00) DO
            BEGIN
            check_sum := check_sum + ord (pageLogBody_kb00 [pos])
                  * g01hashprime [prime_idx];
            prime_idx := prime_idx + 1;
            check_sum := check_sum + ord (pageLogBody_kb00 [pos+3])
                  * g01hashprime [prime_idx];
            prime_idx := prime_idx + 1;
            pos       := pos + c_checkpt_check_step;
            END
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    pos := 1;
    WHILE (pos <= logbody_len)
          AND
          (prime_idx <= MAX_HASH_PRIME_GG00) DO
        BEGIN
        check_sum := check_sum +
              ord (pageLogBody_kb00 [pos]) * g01hashprime [prime_idx];
        pos       := pos + c_page_check_step;
        prime_idx := prime_idx + 1
        END
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
k57calc_checksum := check_sum
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57create_restartrecord (VAR t : tgg00_TransContext);
 
VAR
      pos : integer;
 
BEGIN
t.trError_gg00 := e_ok;
WITH k57restartrec^ DO
    BEGIN
    SAPDB_PascalFill ('VKB57 ',   2,    
          sizeof (k57restartrec^),
          @k57restartrec^, 1, sizeof (k57restartrec^), chr(0),
          t.trError_gg00);
    t.trError_gg00 := e_ok;
    (* *)
    pageLpno_kb00     := 0;
    pageType_kb00     := ptData_egg00;
    pageType2_kb00    := pt2Checkpt_egg00;
    pageCheck_kb00    := chckNil_egg00;
    pageMode_kb00     := [ ];
    pagePposFree_kb00 := sizeof (pageLogBody_kb00) + 1;
    pageTrailer_kb00  := pageHeader_kb00;
    (* *)
    (* all restartrec variables are initialized by zero  *)
    (* *)
    rstFiller2_kb00                := false;
    rstConfigPhase_kb00            := cfpStartConfig_ekb00;
    rstLastSaveDataSuccessful_kb00 := true;
    rstConverterVersion_kb00       := bd10GetConverterVersion;
    rstPrevConverterVers_kb00      := 0;
    rstCurrBackupVersion_kb00      := 1;
    rstPrevBackupVersion_kb00      := 1;
    rstFiller4_kb00                := 0;
    rstFiller5_kb00                := 0;
    (* *)
    WITH rstConfigParam_kb00 DO
        BEGIN
        crSnapShotRestartRecordAddr_kb00     := 0;
        crConvRootBlockAddr_kb00             := 0;
        crFdirRoot_kb00                      := NIL_PAGE_NO_GG00;
        crLongDirRoot_kb00                   := NIL_PAGE_NO_GG00;
        crMaxDynamicPno_kb00                 := 0;
        crMaxStaticPno_kb00                  := 0;
        crPrevDataRecoveryWasIncomplete_kb00 := false; (* PTS 1124994 UH 2004-01-26 *)
        crVolumeBitCount_kb00                := bd10GetVolumeNoBitCount;
        crClusterBlockCount_kb00             := 0;
        crFdirEntryCount_kb00                := 0;
        crClusterReservedSpace_kb00          := 0;
        crFiller3_kb00                       := 0;
        g11kernel_version (crReleaseVers_kb00);
        END;
    (*ENDWITH*) 
    kb560InitSavepointParam (rstLastSavept_kb00);
    (* *)
    WITH rstLastSurrogate_kb00 DO
        BEGIN
        gg06SetZeroSession (srgSession_kb00);
        gg06SessionIncr    (srgSession_kb00);
        gg06SetZeroTrans   (srgWriteTrans_kb00);
        srgSurrogate_kb00        := cgg_zero_id;
        pos                      := sizeof (srgSurrogate_kb00);
        srgSurrogate_kb00 [pos]  := chr(100);
        srgSyskey_kb00           := srgSurrogate_kb00
        END;
    (*ENDWITH*) 
    rstLastFileId_kb00          := cgg_zero_id;
    rstSys1Catalog_kb00         := cgg_zero_id;
    rstSys2Catalog_kb00         := cgg_zero_id;
    rstFiller6_kb00             := 0;
    rstDataBackupCnt_kb00       := 0;             (* PTS 1000333 UH *)
    rstLastDataBackup_kb00      := pageLpno_kb00; (* PTS 1000333 UH *)
    g11kernel_version (rstReleaseVersion_kb00);
    (* *)
    (* *)
    (*rst_db_ident        := bsp00_Line; PTS 1000449 UH 19980909 *)
    (* *)
    k57frozen_restartrec^ := k57restartrec^;
    k57.surrogate_upd     := false;
    END
(*ENDWITH*) 
END;
 
(* PTS 1110096 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      k57overall_currval (
            VAR t          : tgg00_TransContext;
            buf_addr       : tsp00_MoveObjPtr;
            buf_size       : tsp00_Int4;
            firstpos       : integer;
            resultbuf_addr : tsp00_MoveObjPtr;
            resultbuf_size : tsp00_Int4;
            resultpos      : integer;
            VAR res_len    : tsp00_Int4);
 
VAR
      curr_seq      : tkb57_seq_cache_ptr;
      seq_surrogate : tgg00_Surrogate;
      seq_info      : tgg00_SeqInfo;
 
BEGIN
t.trError_gg00 := e_ok;
SAPDB_PascalMove ('VKB57 ',   3,    
      buf_size, sizeof (seq_surrogate),
      @buf_addr^, firstpos, @seq_surrogate, 1,
      sizeof (seq_surrogate), t.trError_gg00);
SAPDB_PascalMove ('VKB57 ',   4,    
      buf_size, sizeof (seq_info),
      @buf_addr^, firstpos + sizeof (seq_surrogate), @seq_info, 1,
      sizeof (seq_info), t.trError_gg00);
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    vbegexcl (t.trTaskId_gg00, g08surrogate);
    kb57wait_for_surrogate_log (t.trTaskId_gg00);
    kb57find_sequence (t, seq_surrogate, curr_seq, NOT c_is_restart);
    IF  (curr_seq <> NIL) AND (t.trError_gg00 = e_ok)
    THEN
        BEGIN
        res_len := s30klen (curr_seq^.sqc_value,
              csp_defined_byte, sizeof (curr_seq^.sqc_value));
        SAPDB_PascalMove ('VKB57 ',   5,    
              sizeof (curr_seq^.sqc_value), resultbuf_size,
              @curr_seq^.sqc_value, 1, @resultbuf_addr^, resultpos,
              res_len, t.trError_gg00)
        END;
    (*ENDIF*) 
    vendexcl (t.trTaskId_gg00, g08surrogate)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57currval (
            VAR t          : tgg00_TransContext;
            buf_addr       : tsp00_MoveObjPtr;
            buf_size       : tsp00_Int4;
            firstpos       : integer;
            resultbuf_addr : tsp00_MoveObjPtr;
            resultbuf_size : tsp00_Int4;
            resultpos      : integer;
            VAR res_len    : tsp00_Int4);
 
VAR
      seq_found     : boolean;
      seqindex      : integer;
      seq_surrogate : tgg00_Surrogate;
 
BEGIN
t.trError_gg00 := e_ok;
SAPDB_PascalMove ('VKB57 ',   6,    
      buf_size, sizeof (seq_surrogate),
      @buf_addr^, firstpos, @seq_surrogate, 1,
      sizeof (seq_surrogate), t.trError_gg00);
(* PTS 1110095 E.Z. *)
IF  t.trSeqInfoPtr_gg00 = NIL
THEN
    t.trError_gg00 := e_currval_without_nextval
ELSE
    WITH t.trSeqInfoPtr_gg00^ DO
        BEGIN
        seqindex := 1;
        seq_found := false;
        WHILE (seqindex <= csi_cnt) AND (NOT seq_found) DO
            IF  seq_surrogate = csi_values [seqindex].ocs_seq_surrogate
            THEN
                seq_found := true
            ELSE
                seqindex := succ(seqindex);
            (*ENDIF*) 
        (*ENDWHILE*) 
        IF  NOT seq_found
        THEN
            t.trError_gg00 := e_currval_without_nextval
        ELSE
            BEGIN
            res_len := s30klen (csi_values [seqindex].ocs_seq_value,
                  csp_defined_byte, sizeof (csi_values [seqindex].ocs_seq_value));
            SAPDB_PascalMove ('VKB57 ',   7,    
                  sizeof (csi_values [seqindex].ocs_seq_value), resultbuf_size,
                  @csi_values [seqindex].ocs_seq_value, 1, @resultbuf_addr^, resultpos,
                  res_len, t.trError_gg00)
            END;
        (*ENDIF*) 
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(* END PTS 1110096 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      k57dump_restartrec (
            VAR hostfile : tgg00_VfFileref;
            VAR buf      : tsp00_Page;
            VAR out_pno  : tsp00_Int4;
            VAR out_pos  : integer;
            VAR host_err : tsp00_VfReturn;
            VAR errtext  : tsp00_ErrText);
 
CONST
      mark0_k57undef = 'K57UNDEF';
      code0_k57undef = 1500;
      mark1_k57vars  = 'K57VARS ';
      code1_k57vars  = 1501;
 
VAR
      i2        : tsp00_IntMapC2;
      move_err  : tgg00_BasisError; (* dummy_error *)
      dump_mark : tsp00_C8;
 
BEGIN
(* CRASH: outside lock and surrogate region *)
host_err := vf_ok;
move_err := e_ok;
g01new_dump_page (hostfile, buf, out_pno, out_pos, host_err, errtext);
IF  (k57restartrec = NIL) AND (host_err = vf_ok)
THEN
    BEGIN
    (* ---  K 5 7 U N D E F --- *)
    dump_mark := mark0_k57undef;
    SAPDB_PascalMove ('VKB57 ',   8,    
          sizeof (dump_mark), sizeof (buf),
          @dump_mark, 1, @buf, out_pos,
          sizeof (dump_mark), move_err);
    move_err        := e_ok; (* ignore error *)
    out_pos         := out_pos + sizeof (dump_mark);
    i2.mapInt_sp00  := code0_k57undef;
    buf [out_pos  ] := i2.mapC2_sp00 [1];
    buf [out_pos+1] := i2.mapC2_sp00 [2];
    out_pos         := out_pos + 2
    END;
(*ENDIF*) 
IF  (k57restartrec <> NIL) AND (host_err = vf_ok)
THEN
    BEGIN
    (* ---  K 5 7 V A R S  --- *)
    dump_mark := mark1_k57vars;
    SAPDB_PascalMove ('VKB57 ',   9,    
          sizeof (dump_mark), sizeof (buf),
          @dump_mark, 1, @buf, out_pos,
          sizeof (dump_mark), move_err);
    move_err        := e_ok; (* ignore error *)
    out_pos         := out_pos + sizeof (dump_mark);
    i2.mapInt_sp00  := code1_k57vars;
    buf [out_pos  ] := i2.mapC2_sp00 [1];
    buf [out_pos+1] := i2.mapC2_sp00 [2 ];
    out_pos         := out_pos + 2;
    SAPDB_PascalMove ('VKB57 ',  10,    
          sizeof (k57), sizeof (buf),
          @k57, 1, @buf, out_pos, sizeof (k57), move_err);
    move_err := e_ok; (* ignore error *)
    out_pos  := out_pos + sizeof (k57);
    END;
(*ENDIF*) 
IF  (k57restartrec <> NIL) AND (host_err = vf_ok)
THEN
    BEGIN
    g01new_dump_page (hostfile, buf, out_pno, out_pos, host_err, errtext);
    IF  host_err = vf_ok
    THEN
        BEGIN
        vfwrite (hostfile.no, @k57restartrec^, host_err, errtext);
        out_pos := 1
        END;
    (*ENDIF*) 
    IF  (k57frozen_restartrec <> NIL) AND (host_err = vf_ok)
    THEN
        BEGIN
        vfwrite (hostfile.no, @k57frozen_restartrec^, host_err,errtext);
        out_pos := 1
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57end_flush_sequences (taskid : tsp00_TaskId);
 
BEGIN
(* PTS 1117320 UH 2002-11-08 new *)
(* this may only be called by the savepoint coordinator *)
vbegexcl (taskid, g08surrogate);
IF  k57.surrog_logging
THEN
    BEGIN
    k57.surrog_logging := false;
    kb571AllSurrogateWaitsResume;
    END;
(*ENDIF*) 
vendexcl (taskid, g08surrogate);
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57flush_sequences (VAR t : tgg00_TransContext);
 
VAR
      ix       : integer;
      curr_seq : tkb57_seq_cache_ptr;
 
BEGIN
t.trError_gg00 := e_ok;
ix := 0;
vbegexcl (t.trTaskId_gg00, g08surrogate);
kb57wait_for_surrogate_log (t.trTaskId_gg00);
k57.surrog_logging := true; (* PTS 1117320 UH 2002-10-28 *)
WHILE (ix < ckb57_seq_hash_value) AND (t.trError_gg00 = e_ok) DO
    BEGIN
    curr_seq := k57.seq_head[ix].sqh_first;
    WHILE (curr_seq <> NIL) AND (t.trError_gg00 = e_ok) DO
        BEGIN
        IF  curr_seq^.sqc_flush
        THEN
            a23flush_sequence (t,
                  curr_seq^.sqc_surrogate, curr_seq^.sqc_log_value);
        (*ENDIF*) 
        curr_seq := curr_seq^.sqc_hash_next
        END;
    (*ENDWHILE*) 
    ix := ix + 1
    END;
(*ENDWHILE*) 
vendexcl (t.trTaskId_gg00, g08surrogate)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57info_seq_cache (
            process_id      : tsp00_TaskId;
            VAR cache_total : tsp00_8ByteCounter;
            VAR cache_hit   : tsp00_8ByteCounter;
            VAR cache_miss  : tsp00_8ByteCounter);
 
BEGIN
vbegexcl (process_id, g08surrogate);
cache_hit  := k57.seq_hit;           (* PTS 1103743 JA 1999-08-25 *)
cache_miss := k57.seq_miss;
vendexcl (process_id, g08surrogate);
cache_total := cache_hit + cache_miss
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57init_restartrec_handling (VAR t : tgg00_TransContext);
 
BEGIN
t.trError_gg00 := e_ok;
IF  k57restartrec^.rstConfigParam_kb00.crPrevDataRecoveryWasIncomplete_kb00
THEN
    BEGIN
    (* PTS 1124994 UH 2004-01-26 *)
    g01optextmsg (sp3p_knldiag, sp3m_error, kbMsg_csp03,
          csp3_n_restart, 'Previous data recovery was incomplete   ');
    t.trError_gg00 := e_prev_data_recovery_was_incomplete
    END
ELSE
    BEGIN
    vbegexcl (t.trTaskId_gg00, g08surrogate);
    k57frozen_restartrec^ := k57restartrec^;
    k57.surrogate_upd     := false;
    vendexcl (t.trTaskId_gg00, g08surrogate);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57new_session (
            TaskId           : tsp00_TaskId;
            VAR SessionId    : tgg91_SessionNo);
 
BEGIN
vbegexcl (TaskId, g08surrogate);
WITH k57restartrec^.rstLastSurrogate_kb00 DO
    BEGIN
    gg06SessionIncr (srgSession_kb00);
    IF  gg06IsMaxSession (srgSession_kb00)
    THEN
        gg06SetZeroSession (srgSession_kb00);
    (*ENDIF*) 
    SessionId := srgSession_kb00
    END;
(*ENDWITH*) 
vendexcl (TaskId, g08surrogate)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57new_write_trans (
            TaskId               : tsp00_TaskId;
            VAR WriteTransNo     : tgg91_TransNo);
 
BEGIN
vbegexcl (TaskId, g08surrogate);
WITH k57restartrec^.rstLastSurrogate_kb00 DO
    BEGIN
    IF  gg06IsMaxTrans (srgWriteTrans_kb00)
    THEN
        gg06SetZeroTrans (srgWriteTrans_kb00)
    ELSE
        gg06TransIncr (srgWriteTrans_kb00);
    (*ENDIF*) 
    WriteTransNo := srgWriteTrans_kb00
    END;
(*ENDWITH*) 
vendexcl (TaskId, g08surrogate)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57nextval (
            VAR t          : tgg00_TransContext;
            buf_addr       : tsp00_MoveObjPtr;
            buf_size       : tsp00_Int4;
            firstpos       : tsp00_Int4;
            resultbuf_addr : tsp00_MoveObjPtr;
            resultbuf_size : tsp00_Int4;
            resultpos      : tsp00_Int4;
            VAR res_len    : tsp00_Int4);
 
VAR
      positive_incr : boolean;
      seq_log       : boolean;
      cached_seq    : boolean;
      seq_found     : boolean;
      ret           : tsp00_NumError;
      dummy_err     : tgg00_BasisError;
      curr_seq      : tkb57_seq_cache_ptr;
      seq_surrogate : tgg00_Surrogate;
      prev_value    : tsp00_Number;
      seq_info      : tgg00_SeqInfo;
      resbytelen    : integer;
      err_msg       : tgg04_Err;
      seqindex      : integer;
 
BEGIN
t.trError_gg00 := e_ok;
curr_seq       := NIL;
SAPDB_PascalMove ('VKB57 ',  11,    
      buf_size, sizeof (seq_surrogate),
      @buf_addr^, firstpos, @seq_surrogate, 1, sizeof (seq_surrogate),
      t.trError_gg00);
SAPDB_PascalMove ('VKB57 ',  12,    
      buf_size, sizeof (seq_info),
      @buf_addr^, firstpos + sizeof (seq_surrogate), @seq_info, 1,
      sizeof (seq_info), t.trError_gg00);
seq_log       := false;
positive_incr := seq_info.seq_increment[1] > csp_zero_exponent;
(* cached_seq = TRUE <=> seq_cachevalue > 1 *)
cached_seq    := (seq_info.seq_cachevalue[1] > chr(193)) OR
      (seq_info.seq_cachevalue[2] > chr(16));
vbegexcl (t.trTaskId_gg00, g08surrogate);
kb57wait_for_surrogate_log (t.trTaskId_gg00);
IF  t.trError_gg00 = e_ok
THEN
    kb57find_sequence (t, seq_surrogate, curr_seq, NOT c_is_restart);
(*ENDIF*) 
IF  (curr_seq <> NIL) AND (t.trError_gg00 = e_ok)
THEN
    BEGIN
    IF  NOT curr_seq^.sqc_first
    THEN
        BEGIN
        prev_value := curr_seq^.sqc_value;
        s51add (prev_value, 1, sizeof (prev_value),
              seq_info.seq_increment, 1, sizeof(seq_info.seq_increment),
              curr_seq^.sqc_value, 1, csp_fixed, 0, resbytelen, ret);
        IF  ret = num_ok
        THEN
            BEGIN
            SAPDB_PascalFill ('VKB57 ',  13,    
                  sizeof (curr_seq^.sqc_value), @curr_seq^.sqc_value,
                  resbytelen + 1,
                  sizeof (curr_seq^.sqc_value) - resbytelen,
                  csp_defined_byte, t.trError_gg00);
            IF  positive_incr
            THEN
                BEGIN
                IF  curr_seq^.sqc_value > seq_info.seq_maxvalue
                THEN
                    ret := num_overflow
                (*ENDIF*) 
                END
            ELSE
                IF  curr_seq^.sqc_value < seq_info.seq_minvalue
                THEN
                    ret := num_overflow;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (ret = num_ok) AND (t.trError_gg00 = e_ok)
        THEN
            BEGIN
            IF  NOT cached_seq
            THEN
                BEGIN
                seq_log                 := true;
                curr_seq^.sqc_log_value := curr_seq^.sqc_value
                END
            ELSE
                IF  positive_incr
                THEN
                    BEGIN
                    IF  curr_seq^.sqc_value > curr_seq^.sqc_log_value
                    THEN
                        BEGIN
                        seq_log := true;
                        s51add (curr_seq^.sqc_log_value, 1,
                              sizeof (curr_seq^.sqc_log_value),
                              seq_info.seq_cachevalue, 1,
                              sizeof (seq_info.seq_cachevalue),
                              curr_seq^.sqc_log_value, 1, csp_fixed,
                              0, resbytelen, ret);
                        IF  (ret = num_overflow)
                            OR
                            (curr_seq^.sqc_log_value
                            > seq_info.seq_maxvalue)
                        THEN
                            BEGIN
                            ret := num_ok;
                            curr_seq^.sqc_log_value :=
                                  seq_info.seq_maxvalue
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    IF  curr_seq^.sqc_value < curr_seq^.sqc_log_value
                    THEN
                        BEGIN
                        seq_log := true;
                        s51add (curr_seq^.sqc_log_value, 1,
                              sizeof (curr_seq^.sqc_value),
                              seq_info.seq_cachevalue, 1,
                              sizeof (seq_info.seq_cachevalue),
                              curr_seq^.sqc_log_value, 1, csp_fixed,
                              0, resbytelen, ret);
                        IF  (ret = num_overflow)
                            OR
                            (curr_seq^.sqc_log_value
                            < seq_info.seq_minvalue)
                        THEN
                            BEGIN
                            ret := num_ok;
                            curr_seq^.sqc_log_value :=
                                  seq_info.seq_minvalue
                            END
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (ret = num_overflow) AND (t.trError_gg00 = e_ok)
        THEN
            BEGIN
            ret := num_ok;
            IF  seq_info.seq_cycle
            THEN
                BEGIN
                seq_log := true;
                IF  positive_incr
                THEN
                    curr_seq^.sqc_value := seq_info.seq_minvalue
                ELSE
                    curr_seq^.sqc_value := seq_info.seq_maxvalue;
                (*ENDIF*) 
                curr_seq^.sqc_log_value := curr_seq^.sqc_value
                END
            ELSE
                BEGIN
                (* sequence exhausted, restore previous value *)
                curr_seq^.sqc_value := prev_value;
                t.trError_gg00      := e_sequence_overflow
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (ret <> num_ok) AND (t.trError_gg00 = e_ok)
        THEN
            k71num_err_to_b_err (ret, t.trError_gg00)
        (*ENDIF*) 
        END
    ELSE
        seq_log := true;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        curr_seq^.sqc_first := false;
        IF  seq_log
        THEN
            BEGIN
            t.trState_gg00      := t.trState_gg00 + [tsSurrogateUpd_egg00];
            curr_seq^.sqc_flush := true;
            IF  NOT curr_seq^.sqc_log
            THEN
                BEGIN
                (* chain into list of sequence that have to be logged *)
                curr_seq^.sqc_log_next := k57.seq_log;
                k57.seq_log            := curr_seq
                END;
            (*ENDIF*) 
            curr_seq^.sqc_log := true
            END;
        (*ENDIF*) 
        res_len := s30klen (curr_seq^.sqc_value,
              csp_defined_byte, sizeof (curr_seq^.sqc_value));
        SAPDB_PascalMove ('VKB57 ',  14,    
              sizeof (curr_seq^.sqc_value), resultbuf_size,
              @curr_seq^.sqc_value, 1, @resultbuf_addr^, resultpos,
              res_len, t.trError_gg00);
        (* PTS 1110096 E.Z. *)
        IF  t.trSeqInfoPtr_gg00 <> NIL
        THEN
            WITH t.trSeqInfoPtr_gg00^ DO
                BEGIN
                seqindex := 1;
                seq_found := false;
                WHILE (seqindex <= csi_cnt) AND (NOT seq_found) DO
                    IF  seq_surrogate = csi_values [seqindex].ocs_seq_surrogate
                    THEN
                        seq_found := true
                    ELSE
                        seqindex := succ(seqindex);
                    (*ENDIF*) 
                (*ENDWHILE*) 
                IF  NOT seq_found
                THEN
                    BEGIN
                    IF  csi_cnt < MAX_SEQINFOS_GG00
                    THEN
                        csi_cnt := succ(csi_cnt)
                    ELSE
                        BEGIN
                        (* throw the first (the oldest ?) sequence away *)
                        FOR seqindex := 2 TO MAX_SEQINFOS_GG00 DO
                            csi_values [seqindex-1] := csi_values [seqindex];
                        (*ENDFOR*) 
                        END;
                    (*ENDIF*) 
                    seqindex := csi_cnt;
                    csi_values [seqindex].ocs_seq_surrogate := seq_surrogate;
                    END;
                (*ENDIF*) 
                csi_values [seqindex].ocs_seq_value := curr_seq^.sqc_value
                END
            (*ENDWITH*) 
        (*ENDIF*) 
        END
    ELSE
        IF  t.trError_gg00 = e_sequence_overflow
        THEN
            WITH err_msg DO
                BEGIN
                errtableid   := seq_surrogate;
                errtablesite := cgg_zero_c2;
                b06put_errtxt (t, t.trTaskId_gg00,
                      SURROGATE_MXGG00 + STACK_ENTRY_MXGG00 + 2,
                      errtext_surrogate, t.trError_gg00, err_msg.errt,
                      dummy_err);
                t.trError_gg00 := e_sequence_overflow
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
vendexcl (t.trTaskId_gg00, g08surrogate)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57put_sequence_value (
            VAR t             : tgg00_TransContext;
            VAR seq_surrogate : tgg00_Surrogate;
            VAR val_buf       : tsp00_MoveObj;
            val_buf_size      : tsp00_Int4;
            val_buf_pos       : tsp00_Int4;
            val_len           : tsp00_Int4);
 
VAR
      curr_seq  : tkb57_seq_cache_ptr;
      seq_value : tsp00_Number;
 
BEGIN
t.trError_gg00 := e_ok;
curr_seq       := NIL;
SAPDB_PascalMove ('VKB57 ',  15,    
      val_buf_size, sizeof (seq_value),
      @val_buf, val_buf_pos, @seq_value, 1, val_len, t.trError_gg00);
SAPDB_PascalFill ('VKB57 ',  16,    
      sizeof (seq_value), @seq_value,
      val_len + 1, sizeof (seq_value) - val_len, chr(0), t.trError_gg00);
vbegexcl (t.trTaskId_gg00, g08surrogate);
kb57wait_for_surrogate_log (t.trTaskId_gg00);
IF  t.trError_gg00 = e_ok
THEN
    kb57find_sequence (t, seq_surrogate, curr_seq, NOT c_is_restart);
(*ENDIF*) 
IF  (curr_seq <> NIL) AND (t.trError_gg00 = e_ok)
THEN
    BEGIN
    IF  seq_value > curr_seq^.sqc_value
    THEN
        BEGIN
        curr_seq^.sqc_value := seq_value;
        IF  seq_value > curr_seq^.sqc_log_value
        THEN
            BEGIN
            t.trState_gg00          := t.trState_gg00 + [tsSurrogateUpd_egg00];
            curr_seq^.sqc_flush     := true;
            curr_seq^.sqc_log_value := seq_value;
            IF  NOT curr_seq^.sqc_log
            THEN
                BEGIN
                (* chain into list of sequence that have to be logged *)
                curr_seq^.sqc_log_next := k57.seq_log;
                k57.seq_log            := curr_seq
                END;
            (*ENDIF*) 
            curr_seq^.sqc_log := true
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
vendexcl (t.trTaskId_gg00, g08surrogate)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57RedoTransNoIncrement (
            TaskId      : tsp00_TaskId;
            RedoTransNo : tgg91_TransNo);
 
BEGIN
vbegexcl (TaskId, g08surrogate);
IF  RedoTransNo.ci6_gg00
    >
    k57restartrec^.rstLastSurrogate_kb00.srgWriteTrans_kb00.ci6_gg00
THEN (* PTS 1117239 UH 2002-08-14 *)
    k57restartrec^.rstLastSurrogate_kb00.srgWriteTrans_kb00
          := RedoTransNo;
(*ENDIF*) 
vendexcl (TaskId, g08surrogate)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57GetLastWriteTransNo (
            TaskId  : tsp00_TaskId;
            VAR TransNo : tgg91_TransNo);
 
BEGIN
vbegexcl (TaskId, g08surrogate);
TransNo := k57restartrec^.rstLastSurrogate_kb00.srgWriteTrans_kb00;
vendexcl (TaskId, g08surrogate);
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57GetLastSessionNo (
            TaskId  : tsp00_TaskId;
            VAR SessionNo : tgg91_SessionNo);
 
BEGIN
vbegexcl (TaskId, g08surrogate);
SessionNo := k57restartrec^.rstLastSurrogate_kb00.srgSession_kb00;
vendexcl (TaskId, g08surrogate);
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57RefreshSequence (
            VAR TransContext : tgg00_TransContext;
            VAR SeqSurrogate : tgg00_Surrogate;
            VAR SeqValue     : tsp00_Number);
 
VAR
      found_seq : tkb57_seq_cache_ptr;
 
BEGIN
vbegexcl (TransContext.trTaskId_gg00, g08surrogate);
kb57find_sequence (TransContext, SeqSurrogate, found_seq, c_is_restart);
IF  found_seq <> NIL
THEN
    BEGIN
    found_seq^.sqc_surrogate := SeqSurrogate;
    found_seq^.sqc_first     := false;
    found_seq^.sqc_value     := SeqValue;
    found_seq^.sqc_log_value := SeqValue;
    found_seq^.sqc_log       := false;
    found_seq^.sqc_flush     := true
    END;
(*ENDIF*) 
vendexcl (TransContext.trTaskId_gg00, g08surrogate)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57RefreshSurrogate (
            VAR TaskId    : tsp00_TaskId;
            VAR Surrogate : tgg00_Surrogate;
            VAR SysKey    : tgg00_Surrogate);
 
BEGIN
vbegexcl (TaskId, g08surrogate);
WITH k57restartrec^.rstLastSurrogate_kb00 DO
    BEGIN
    srgSurrogate_kb00 := Surrogate;
    srgSyskey_kb00    := SysKey
    END;
(*ENDWITH*) 
vendexcl (TaskId, g08surrogate)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57RefreshSurrogateIfNecessary (VAR TaskId : tsp00_TaskId;
            VAR Surrogate : tgg00_Surrogate            (*ptocConst*));
 
BEGIN
WITH k57restartrec^.rstLastSurrogate_kb00 DO
    IF  gg06IsSurrogateGreater(Surrogate, srgSurrogate_kb00)
    THEN
        BEGIN
        vbegexcl (TaskId, g08surrogate);
        IF  gg06IsSurrogateGreater(Surrogate, srgSurrogate_kb00)
        THEN
            srgSurrogate_kb00 := Surrogate;
        (*ENDIF*) 
        vendexcl (TaskId, g08surrogate)
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57save_restartrecord (TaskId : tsp00_TaskId);
 
BEGIN
IF  k560IsSavepointAllowed
THEN
    BEGIN
    vbegexcl (TaskId, g08surrogate);
    k57restartrec^.pageTrailer_kb00 := k57restartrec^.pageHeader_kb00;
    bd999WriteRestartPage ( TaskId, k57restartrec);
    vendexcl (TaskId, g08surrogate)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57select_restartrec (
            TaskId : tsp00_TaskId;
            pAcv  : tsp00_Addr;
            pA41v : tsp00_Addr);
 
VAR
      AuxRestartRec        : tkb00_Page;
      lastDurationSec      : tsp00_Int4;
      lastDurationMicroSec : tsp00_Int4;
      lastWrittenPages     : tsp00_Int4;
      lastIOcount          : tsp00_Int4;
      avgWrittenPages      : tsp00_Int4;
      avgIOcount           : tsp00_Int4;
      resonstring          : tsp00_C40;
      oldestCompatibleVers : tsp00_C10;
 
BEGIN
(* PTS 1108435 JA 2000-11-30 *)
IF  k57restartrec <> NIL
THEN
    BEGIN
    vbegexcl (TaskId, g08surrogate);
    AuxRestartRec := k57restartrec^;
    vendexcl (TaskId, g08surrogate);
    WITH AuxRestartRec DO
        BEGIN
        a42int4_to_intern_state (pAcv, pA41v, RREC, D01_PAGE_NO,           pageLpno_kb00);
        a42int4_to_intern_state (pAcv, pA41v, RREC, D03_CONFIG_PHASE,      ord(rstConfigPhase_kb00));
        a42bool_to_intern_state (pAcv, pA41v, RREC, D04_SET_END_READ_ONLY, rstSetEndReadOnly_kb00);
        a42bool_to_intern_state (pAcv, pA41v, RREC, D05_LAST_SAVE_DATA,    rstLastSaveDataSuccessful_kb00);
        a42int4_to_intern_state (pAcv, pA41v, RREC, D06_CONVERTER_VERS,    rstConverterVersion_kb00);
        a42int4_to_intern_state (pAcv, pA41v, RREC, D07_PREV_CONV_VERS,    rstPrevConverterVers_kb00);
        a42int4_to_intern_state (pAcv, pA41v, RREC, D08_CURR_BACKUP_VERS,  rstCurrBackupVersion_kb00);
        a42int4_to_intern_state (pAcv, pA41v, RREC, D09_PREV_BACKUP_VERS,  rstPrevBackupVersion_kb00);
        END;
    (*ENDWITH*) 
    WITH AuxRestartRec.rstConfigParam_kb00 DO
        BEGIN
        a42int4_to_intern_state (pAcv, pA41v, RREC, D21_CONF_FDIR_ROOT,          crFdirRoot_kb00);
        a42int4_to_intern_state (pAcv, pA41v, RREC, D22_CONF_LONGDIR_ROOT,       crLongDirRoot_kb00);
        a42int4_to_intern_state (pAcv, pA41v, RREC, D23_CONF_MAX_DYN_PNO,        crMaxDynamicPno_kb00);
        a42int4_to_intern_state (pAcv, pA41v, RREC, D24_CONF_MAX_STAT_PNO,       crMaxStaticPno_kb00);
        END;
    (*ENDWITH*) 
    WITH AuxRestartRec.rstLastSavept_kb00 DO
        BEGIN
        a42uint4_to_intern_state  (pAcv, pA41v, RREC, D50_SVP_ID,              svpId_kb00);
        resonstring := bsp_c40;
        kb560GetSavepointReasonString (svpReason_kb00, resonstring);
        a42str_to_intern_state    (pAcv, pA41v, RREC, D51_SVP_REASON, @resonstring, sizeof (resonstring));
        a42date_to_intern_state   (pAcv, pA41v, RREC, D56_SVP_DATE,            svpDate_kb00);
        a42time_to_intern_state   (pAcv, pA41v, RREC, D57_SVP_TIME,            svpTime_kb00);
        a42uint2_to_intern_state  (pAcv, pA41v, RREC, D52_SVP_OPEN_TRANS,      svpOpenTransCnt_kb00);
        a42int4_to_intern_state   (pAcv, pA41v, RREC, D58_SVP_OPEN_TRANS_ROOT, svpOpenTransRoot_kb00);
        a42int4_to_intern_state   (pAcv, pA41v, RREC, D59_SVP_HISTORY_ROOT,    svpHistoryRoot_kb00);
        a42uint4_to_intern_state  (pAcv, pA41v, RREC, D53_SVP_IOSEQUENCE,      svpIOsequence_kb00);
        a42uint4_to_intern_state  (pAcv, pA41v, RREC, D54_SVP_STARTOFFSET,     svpStartOffset_kb00);
        a42uint2_to_intern_state  (pAcv, pA41v, RREC, D55_SVP_STARTENTRYOFF,   svpStartEntryOffset_kb00);
        a42uint1_to_intern_state  (pAcv, pA41v, RREC, D60_SVP_ENTRY_TYPE,      svpStartEntryType_kb00);
        a42date_to_intern_state   (pAcv, pA41v, RREC, D61_SVP_ENTRY_DATE,      svpStartEntryDate_kb00);
        a42time_to_intern_state   (pAcv, pA41v, RREC, D62_SVP_ENTRY_TIME,      svpStartEntryTime_kb00);
        END;
    (*ENDWITH*) 
    WITH AuxRestartRec.rstLastSurrogate_kb00 DO
        BEGIN
        a42session_to_intern_state   (pAcv, pA41v, RREC, D80_SURR_SESSION,   srgSession_kb00);
        a42surrogate_to_intern_state (pAcv, pA41v, RREC, D81_SURR_SURROGATE, srgSurrogate_kb00);
        a42surrogate_to_intern_state (pAcv, pA41v, RREC, D82_SURR_SYSKEY,    srgSyskey_kb00);
        a42trans_to_intern_state     (pAcv, pA41v, RREC, D83_SURR_TRANS,     srgWriteTrans_kb00);
        END;
    (*ENDWITH*) 
    WITH AuxRestartRec DO
        BEGIN
        a42int4_to_intern_state (pAcv, pA41v, RREC, D91_DATA_BACKUP_CNT,   rstDataBackupCnt_kb00);
        a42int4_to_intern_state (pAcv, pA41v, RREC, D92_LAST_DATA_BACKUP,  rstLastDataBackup_kb00);
        a42str_to_intern_state  (pAcv, pA41v, RREC, D93_DB_IDENT,         @rstDbIdent_kb00
              ,                                                    sizeof (rstDbIdent_kb00));
        a42str_to_intern_state  (pAcv, pA41v, RREC, D94_RELEASE_VERSION,  @rstReleaseVersion_kb00
              ,                                                    sizeof (rstReleaseVersion_kb00));
        END;
    (*ENDWITH*) 
    WITH AuxRestartRec.rstConfigParam_kb00 DO
        a42str_to_intern_state (pAcv, pA41v, RREC, D95_CONF_RELEASE_VERS, @crReleaseVers_kb00
              ,                                                    sizeof (crReleaseVers_kb00));
    (*ENDWITH*) 
    (* PTS 1119276 UH 2002-12-10 begin *)
    kb560GetSavepointStatistics (lastDurationSec, lastDurationMicroSec,
          lastWrittenPages, lastIOcount, avgWrittenPages, avgIOcount);
    a42int4_to_intern_state (pAcv, pA41v, SVP, D74_SVP_DURATION_SEC,  lastDurationSec);
    a42int4_to_intern_state (pAcv, pA41v, SVP, D75_SVP_DURATION_MSEC, lastDurationMicroSec);
    a42int4_to_intern_state (pAcv, pA41v, SVP, D76_SVP_LAST_WRITTEN,  lastWrittenPages);
    a42int4_to_intern_state (pAcv, pA41v, SVP, D77_SVP_LAST_IO,       lastIOcount);
    a42int4_to_intern_state (pAcv, pA41v, SVP, D78_SVP_AVG_WRITTEN,   avgWrittenPages);
    a42int4_to_intern_state (pAcv, pA41v, SVP, D79_SVP_AVG_IO,        avgIOcount);
    (* PTS 1119276 UH 2002-12-10 end *)
    oldestCompatibleVers := bsp_c10;
    kb571GetOldestCompatibleVersionString(oldestCompatibleVers);
    a42str_to_intern_state  (pAcv, pA41v, VERSION, D100_OLDEST_COMPATIBLE_VERSION,
          @oldestCompatibleVers, sizeof (oldestCompatibleVers));
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57select_log_info (
            TaskId : tsp00_TaskId;
            pAcv  : tsp00_Addr;
            pA41v : tsp00_Addr);
 
VAR
      date                   : tsp00_Int4;
      time                   : tsp00_Int4;
      flushmode              : tsp00_Int4;
      devicestate            : tsp00_Int4;
      queuecount             : tsp00_Uint4;
      cycleendoffset         : tsp00_Uint4;
      oldestnotsavedoffset   : tsp00_Uint4;
      oldestnotsavedsequence : tsp00_Uint4;
      lastknownoffset        : tsp00_Uint4;
      lastknownsequence      : tsp00_Uint4;
      backupcount            : tsp00_Uint4;
      untildate              : tsp00_Int4;
      untiltime              : tsp00_Int4;
      untilclearloweroffset  : tsp00_Uint4;
      untilclearupperoffset  : tsp00_Uint4;
      untilsequenceafterredo : tsp00_Uint4;
      savepointsequence      : tsp00_Uint4;
      savepointdevoffset     : tsp00_Uint4;
      savepointoffset        : tsp00_Uint4;
      is_valid               : boolean;
      auxstr                 : tsp00_C16;
      auxstrlen              : tsp00_Int4;
 
BEGIN
is_valid := kb560GetLogInfo
      (TaskId, date, time,
      flushmode, devicestate,
      queuecount, cycleendoffset,
      oldestnotsavedoffset, oldestnotsavedsequence,
      lastknownoffset,lastknownsequence,
      backupcount, untildate, untiltime,
      untilclearloweroffset, untilclearupperoffset, untilsequenceafterredo,
      savepointsequence, savepointdevoffset, savepointoffset);
(**)
IF  is_valid
THEN
    BEGIN
    a42date_to_intern_state  (pAcv, pA41v, LOGINFO, D60_LOG_LASTFLUSHDATE,   date);
    a42time_to_intern_state  (pAcv, pA41v, LOGINFO, D61_LOG_LASTFLUSHTIME,   time);
    IF  flushmode = 0
    THEN
        BEGIN
        auxstr    := 'MinimizeSpace   ';
        auxstrlen := 13
        END
    ELSE
        BEGIN
        auxstr    := 'MaximizeSafety  ';
        auxstrlen := 14
        END;
    (*ENDIF*) 
    a42str_to_intern_state (pAcv, pA41v, LOGINFO, D62_LOG_FLUSHMODE, @auxstr, auxstrlen);
    CASE devicestate OF
        0:
            BEGIN
            auxstr    := 'Okay            ';
            auxstrlen := 4
            END;
        1:
            BEGIN
            auxstr    := 'HistoryLost     ';
            auxstrlen := 11
            END;
        2:
            BEGIN
            auxstr    := 'Cleared         ';
            auxstrlen := 7
            END;
        3:
            BEGIN
            auxstr    := 'Clearing        ';
            auxstrlen := 8
            END;
        END;
    (*ENDCASE*) 
    a42str_to_intern_state   (pAcv, pA41v, LOGINFO, D63_LOG_DEVICESTATE, @auxstr, auxstrlen);
    a42uint4_to_intern_state (pAcv, pA41v, LOGINFO, D64_LOG_QUEUECOUNT,      queuecount);
    a42uint4_to_intern_state (pAcv, pA41v, LOGINFO, D65_LOG_CYCLEENDOFFSET,  cycleendoffset);
    a42uint4_to_intern_state (pAcv, pA41v, LOGINFO, D66_LOG_NOTSAVEDOFFSET,  oldestnotsavedoffset);
    a42uint4_to_intern_state (pAcv, pA41v, LOGINFO, D67_LOG_NOTSAVEDSEQ,     oldestnotsavedsequence);
    a42uint4_to_intern_state (pAcv, pA41v, LOGINFO, D68_LOG_LASTKNOWNOFFSET, lastknownoffset);
    a42uint4_to_intern_state (pAcv, pA41v, LOGINFO, D69_LOG_LASTKNOWNSEQ,    lastknownsequence);
    a42uint4_to_intern_state (pAcv, pA41v, LOGINFO, D70_LOG_BACKUPCOUNT,     backupcount);
    a42uint4_to_intern_state (pAcv, pA41v, LOGINFO, D71_LOG_SAVEPOINTSEQ,    savepointsequence);
    a42uint4_to_intern_state (pAcv, pA41v, LOGINFO, D72_LOG_SAVEPOINTDEVOFF, savepointdevoffset);
    a42uint4_to_intern_state (pAcv, pA41v, LOGINFO, D73_LOG_SAVEPOINTOFFSET, savepointoffset);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57sequence_no (VAR m : tgg00_MessBlock);
 
VAR
      mobj_ptr      : tsp00_MoveObjPtr;
      seq_surrogate : tgg00_Surrogate;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
CASE m.mb_type2 OF
    mm_close :
        kb57remove_sequence (m);
    mm_nil :
        k57nextval (m.mb_trns^, @m.mb_qual^.buf, m.mb_qual_size, 1,
              @m.mb_data^.mbp_buf, m.mb_data_size, 1, m.mb_data_len);
    mm_same :
        k57currval (m.mb_trns^, @m.mb_qual^.buf, m.mb_qual_size, 1,
              @m.mb_data^.mbp_buf, m.mb_data_size, 1, m.mb_data_len);
    (* PTS 1110095 E.Z. *)
    mm_direct :
        k57overall_currval (m.mb_trns^, @m.mb_qual^.buf, m.mb_qual_size, 1,
              @m.mb_data^.mbp_buf, m.mb_data_size, 1, m.mb_data_len);
    mm_write :
        BEGIN
        SAPDB_PascalMove ('VKB57 ',  17,    
              m.mb_qual_size, sizeof (seq_surrogate),
              @m.mb_qual^.buf, 1, @seq_surrogate, 1,
              sizeof (seq_surrogate), m.mb_trns^.trError_gg00);
        IF  m.mb_trns^.trError_gg00 = e_ok
        THEN
            BEGIN
            mobj_ptr := @m.mb_qual^.buf;
            k57put_sequence_value (m.mb_trns^,
                  seq_surrogate, mobj_ptr^,
                  m.mb_qual_size, sizeof (seq_surrogate) + 1,
                  m.mb_qual_len - sizeof (seq_surrogate))
            END
        (*ENDIF*) 
        END;
    OTHERWISE
        m.mb_trns^.trError_gg00 := e_not_implemented;
    END;
(*ENDCASE*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    m.mb_type   := m_return_result;
    m.mb_struct := mbs_buf;
    END
ELSE
    m.mb_type := m_return_error;
(*ENDIF*) 
m.mb_qual_len := 0;
m.mb_type2    := mm_nil
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57set_not_generated;
 
BEGIN
k57restartrec        := NIL;
k57frozen_restartrec := NIL
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57stamp_logged (
            VAR trans_state : tgg00_TransState;
            task_id         : tsp00_TaskId;
            stamp_type      : tgg00_MessType2;
            buffer          : tsp00_MoveObjPtr;
            buf_len         : tsp00_Int4;
            VAR b_err       : tgg00_BasisError);
 
BEGIN
b_err       := e_ok;
trans_state := trans_state +  [tsSurrogateUpd_egg00];
k57stamp (task_id, stamp_type, buffer, buf_len, b_err);
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57stamp (
            task_id         : tsp00_TaskId;
            stamp_type      : tgg00_MessType2;
            buffer          : tsp00_MoveObjPtr;
            buf_len         : tsp00_Int4;
            VAR b_err       : tgg00_BasisError);
 
BEGIN
b_err       := e_ok;
vbegexcl (task_id, g08surrogate);
kb57wait_for_surrogate_log (task_id);
k57.surrogate_upd := true;
WITH k57restartrec^.rstLastSurrogate_kb00 DO
    BEGIN
    IF  stamp_type = mm_key
    THEN
        BEGIN
        SAPDB_PascalMove ('VKB57 ',  18,    
              sizeof (srgSyskey_kb00), buf_len,
              @srgSyskey_kb00, 1,
              buffer, 1, sizeof (srgSyskey_kb00),
              b_err);
        s30surrogate_incr (srgSyskey_kb00)
        END
    ELSE
        BEGIN
        SAPDB_PascalMove ('VKB57 ',  19,    
              sizeof (srgSurrogate_kb00), buf_len,
              @srgSurrogate_kb00, 1,
              buffer, 1, sizeof (srgSurrogate_kb00),
              b_err);
        s30surrogate_incr (srgSurrogate_kb00)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
vendexcl (task_id, g08surrogate);
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57statistics_reset (process_id : tsp00_TaskId);
 
BEGIN
vbegexcl (process_id, g08surrogate);
k57.seq_hit  := 0;
k57.seq_miss := 0;
vendexcl (process_id, g08surrogate)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57surrogates_to_log (VAR t : tgg00_TransContext);
 
VAR
      WriteLog        : boolean;
      ImageSurrogate  : tgg00_Surrogate;
      ImageSysKey     : tgg00_Surrogate;
      AuxTransContext : tgg00_TransContext;
 
BEGIN
t.trError_gg00 := e_ok;
;
vbegexcl (t.trTaskId_gg00, g08surrogate);
WriteLog := k57.surrogate_upd OR (k57.seq_log <> NIL);
vendexcl (t.trTaskId_gg00, g08surrogate);
;
IF  WriteLog
THEN
    BEGIN
    k53StartInternalSession (t, AuxTransContext, true, c_inherit_locfdir);
    vbegexcl (t.trTaskId_gg00, g08surrogate);
    kb57wait_for_surrogate_log (t.trTaskId_gg00);
    k57.surrog_logging := true;
    IF  k57.surrogate_upd
    THEN
        BEGIN
        WITH k57restartrec^.rstLastSurrogate_kb00 DO
            BEGIN
            ImageSurrogate := srgSurrogate_kb00;
            ImageSysKey    := srgSyskey_kb00
            END;
        (*ENDWITH*) 
        vendexcl (t.trTaskId_gg00, g08surrogate);
        ;
        kb571WriteRefreshSurrogAfterImage (t, ImageSurrogate, ImageSysKey);
        ;
        vbegexcl (t.trTaskId_gg00, g08surrogate);
        IF  t.trError_gg00 = e_ok
        THEN
            k57.surrogate_upd := false
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  k57.seq_log <> NIL
    THEN
        kb57sequences_to_log (t);
    (*ENDIF*) 
    k57.surrog_logging := false;
    kb571AllSurrogateWaitsResume;
    vendexcl (t.trTaskId_gg00, g08surrogate);
    k53StopInternalSession (t, AuxTransContext, m_commit);
    END;
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    t.trState_gg00 := t.trState_gg00 - [tsSurrogateUpd_egg00]
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57table_key_get (
            pid             : tsp00_TaskId;
            VAR trans_state : tgg00_TransState;
            VAR syskey      : tgg00_Lkey);
 
VAR
      move_err : tgg00_BasisError; (* dummy error *)
 
BEGIN
trans_state := trans_state + [tsSurrogateUpd_egg00];
syskey.len  := SURROGATE_MXGG00;
syskey.k    := b01zerokey;
move_err    := e_ok;
vbegexcl (pid, g08surrogate);
kb57wait_for_surrogate_log (pid);
WITH k57restartrec^.rstLastSurrogate_kb00 DO
    BEGIN
    k57.surrogate_upd := true;
    SAPDB_PascalMove ('VKB57 ',  20,    
          sizeof (srgSyskey_kb00), sizeof (syskey.k),
          @srgSyskey_kb00, 1,
          @syskey.k, 1, sizeof (srgSyskey_kb00), move_err);
    s30surrogate_incr (srgSyskey_kb00);
    END;
(*ENDWITH*) 
vendexcl (pid, g08surrogate)
END;
 
(*------------------------------*) 
 
FUNCTION
      k57DBIdentifier : tsp00_BytePtr;
 
BEGIN
k57DBIdentifier := @k57restartrec^.rstDbIdent_kb00;
END;
 
(*------------------------------*) 
 
FUNCTION
      kb57AnyOpenTransactionsExist : boolean;
 
BEGIN
kb57AnyOpenTransactionsExist :=
      k57restartrec^.rstLastSavept_kb00.svpOpenTransCnt_kb00 <> 0;
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57GetRestartRecordKernelVersion(
            VAR kernelVersion : tsp00_Version);
 
BEGIN
kernelVersion := k57restartrec^.rstReleaseVersion_kb00;
END;
 
(*------------------------------*) 
 
FUNCTION
      kb57GetFdirRoot : tsp00_PageNo;
 
BEGIN
kb57GetFdirRoot := k57restartrec^.rstConfigParam_kb00.crFdirRoot_kb00;
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57SetFdirRoot(
            VAR root : tsp00_PageNo);
 
BEGIN
k57restartrec^.rstConfigParam_kb00.crFdirRoot_kb00 := root;
END;
 
(*------------------------------*) 
 
FUNCTION
      kb57GetLongFdir : tsp00_PageNo;
 
BEGIN
kb57GetLongFdir := k57restartrec^.rstConfigParam_kb00.crLongDirRoot_kb00;
END;
 
(*------------------------------*) 
 
FUNCTION
      kb57GetFdirEntryCount : tsp00_Int4;
 
BEGIN
kb57GetFdirEntryCount := k57restartrec^.rstConfigParam_kb00.crFdirEntryCount_kb00;
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57SetFdirEntryCount(
            VAR entryCount : tsp00_Int4);
 
BEGIN
k57restartrec^.rstConfigParam_kb00.crFdirEntryCount_kb00 := entryCount;
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57GetLastFileId (
            VAR lastFileId : tgg00_Surrogate);
 
BEGIN
lastFileId := k57restartrec^.rstLastFileId_kb00;
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57SetLastFileId (
            VAR lastFileId : tgg00_Surrogate);
 
BEGIN
k57restartrec^.rstLastFileId_kb00 := lastFileId;
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57SetSys1CatalogTabId (
            VAR sys1CatalogTabId : tgg00_Surrogate);
 
BEGIN
k57restartrec^.rstSys1Catalog_kb00 := sys1CatalogTabId;
END;
 
(*------------------------------*) 
 
PROCEDURE
      k57SetSys2CatalogTabId (
            VAR sys2CatalogTabId : tgg00_Surrogate);
 
BEGIN
k57restartrec^.rstSys2Catalog_kb00 := sys2CatalogTabId;
END;
 
(*------------------------------*) 
 
FUNCTION
      kb57GetOldConverterVersion( pOldRestart : tkb57_OldRestarRecordPtr ) : tsp00_Int4;
 
BEGIN
kb57GetOldConverterVersion := pOldRestart^.rstConverterVersion_kb57;
END;
 
(*------------------------------*) 
 
FUNCTION
      kb57GetUSMRoot( pOldRestart : tkb57_OldRestarRecordPtr ) : tsp00_PageNo;
 
BEGIN
kb57GetUSMRoot := pOldRestart^.rstConfigParam_kb57.crUsmRoot_kb57;
END;
 
(*------------------------------*) 
 
FUNCTION
      kb57GetMaxDataPageNo( pOldRestart : tkb57_OldRestarRecordPtr ) : tsp00_PageNo;
 
BEGIN
kb57GetMaxDataPageNo := pOldRestart^.rstConfigParam_kb57.crMaxDataPno_kb57;
END;
 
(*------------------------------*) 
 
FUNCTION
      kb57MigrateRestartRecord( pOldRestart : tkb57_OldRestarRecordPtr ) : boolean;
 
VAR
      auxError : tgg00_BasisError;
      new      : tkb00_Page;
 
BEGIN
IF  pOldRestart^.rstIsConsistentDb_kb57
    AND
    pOldRestart^.rstLastSavept_kb57.svpIsCheckpt_kb57
    AND
    ( pOldRestart^.rstLastSavept_kb57.svpOpenTransCnt_kb57 = 0 )
THEN
    BEGIN
    WITH pOldRestart^ DO
        BEGIN
        auxError := e_ok;
        SAPDB_PascalFill ('VKB57 ',  21,    
              sizeof( new ), @new, 1, sizeof( new ), chr(0), auxError );
        auxError := e_ok;
        (* *)
        new.pageLogPos_kb00  := rstLogPos_kb57;
        new.pageType_kb00    := ptData_egg00;
        new.pageCheck_kb00   := chckNil_egg00;
        new.rstFiller1_kb00  := 0;
        new.pageTrailer_kb00 := new.pageHeader_kb00;
        (* *)
        new.rstFiller2_kb00                := false;
        new.rstConfigPhase_kb00            := rstConfigPhase_kb57;
        new.rstSetEndReadOnly_kb00         := rstSetEndReadOnly_kb57;
        new.rstLastSaveDataSuccessful_kb00 := false;
        new.rstFiller3_kb00                := 0;
        (* *)
        new.rstConverterVersion_kb00  := rstConverterVersion_kb57;
        new.rstPrevConverterVers_kb00 := rstPrevConverterVers_kb57;
        (* *)
        new.rstCurrBackupVersion_kb00 := rstCurrBackupVersion_kb57;
        new.rstPrevBackupVersion_kb00 := rstPrevBackupVersion_kb57;
        (* *)
        new.rstFiller4_kb00 := 0;
        new.rstFiller5_kb00 := 0;
        (* *)
        WITH new.rstConfigParam_kb00 DO
            BEGIN
            crSnapShotRestartRecordAddr_kb00 := 0;
            crConvRootBlockAddr_kb00         := 0;
            crFdirRoot_kb00                  := rstConfigParam_kb57.crFdirRoot_kb57;
            crLongDirRoot_kb00               := rstConfigParam_kb57.crLongDirRoot_kb57;
            IF  rstConfigParam_kb57.crMaxUsedDataPno_kb57 > 0
            THEN
                crMaxDynamicPno_kb00 := rstConfigParam_kb57.crMaxUsedDataPno_kb57
            ELSE
                crMaxDynamicPno_kb00 := rstConfigParam_kb57.crMaxDataPno_kb57;
            (*ENDIF*) 
            crMaxStaticPno_kb00                  := crMaxDynamicPno_kb00;
            crPrevDataRecoveryWasIncomplete_kb00 := false; (* PTS 1124994 UH 2004-01-26 *)
            crVolumeBitCount_kb00                := bd10GetVolumeNoBitCount;
            crClusterBlockCount_kb00             := 0;
            crFdirEntryCount_kb00                := 0;
            crClusterReservedSpace_kb00          := 0;
            crFiller3_kb00                       := 0;
            crReleaseVers_kb00                   := rstConfigParam_kb57.crReleaseVers_kb57;
            END;
        (*ENDWITH*) 
        (* *)
        kb560InitSavepointParam (new.rstLastSavept_kb00);
        (* *)
        new.rstLastSurrogate_kb00  := rstLastSurrogate_kb57;
        new.rstFiller6_kb00        := 0;
        new.rstDataBackupCnt_kb00  := rstDataBackupCnt_kb57;
        new.rstLastDataBackup_kb00 := rstLastDataBackup_kb57;
        new.rstReleaseVersion_kb00 := rstReleaseVersion_kb57;
        new.rstDbIdent_kb00        := rstDbIdent_kb57;
        (* *)
        END;
    (*ENDWITH*) 
    SAPDB_PascalMove ('VKB57 ',  22,    
          sizeof (new), sizeof (new),
          @new, 1, @pOldRestart^, 1, sizeof (new), auxError);
    (* *)
    g01optextmsg (sp3p_knldiag, sp3m_info, kbMsg_csp03,
          csp3_n_migration, 'Migration of restart record done        ');
    (* *)
    kb57MigrateRestartRecord := true;
    END
ELSE
    BEGIN
    g01optextmsg (sp3p_knldiag, sp3m_error, kbMsg_csp03,
          csp3_n_migration, 'Could not migrate restart record        ');
    kb57MigrateRestartRecord := false;
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      kb57IsMigrationFlagSet( pOldRestart : tkb57_OldRestarRecordPtr ) : boolean;
 
BEGIN
kb57IsMigrationFlagSet := pOldRestart^.rstMigrationDone_kb57;
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57InspectRestartRecordForRestore(
            pRestart             : tkb00_PagePtr;
            bIsRestoreData       : boolean;
            VAR bRestorePossible : boolean;
            VAR bMigrationNeeded : boolean);
 
CONST
      MAJOR_DIGIT_POS = 11;
      MINOR_DIGIT_POS = 13;
 
VAR
      majorReleaseId : tsp00_Int4;
      minorReleaseId : tsp00_Int4;
      pOldRestart    : tkb57_OldRestarRecordPtr;
 
BEGIN
(* *)
(* rstReleaseVersion: Kernel    7.4.X      *)
(* rstReleaseVersion: QuickKnl  7.4.X      *)
(* rstReleaseVersion: SlowKnl   7.4.X      *)
(*                    1---5----1----5----2 *)
(* *)
bMigrationNeeded := false;
bRestorePossible := false;
WITH pRestart^ DO
    BEGIN
    majorReleaseId  := ord( rstReleaseVersion_kb00[ MAJOR_DIGIT_POS ] ) - ord( '0' );
    minorReleaseId  := ord( rstReleaseVersion_kb00[ MINOR_DIGIT_POS ] ) - ord( '0' );
    IF  ( 7 = majorReleaseId ) AND ( minorReleaseId >= 4 )
    THEN
        BEGIN
        (* *)
        (* The given restart record is at least from a 7.4 release. Therefore *)
        (* no migration is needed and restore data/pages is possible *)
        (* *)
        bMigrationNeeded := false;
        bRestorePossible := true
        END
    ELSE
        BEGIN
        IF  bIsRestoreData (* PTS 1113245 TS 2002-02-20 *)
            AND
            (
            (( 7 = majorReleaseId ) AND ( 2 = minorReleaseId ))
            OR
            (( 7 = majorReleaseId ) AND ( 3 = minorReleaseId ) )
            )
        THEN
            BEGIN
            pOldRestart := @(pRestart^);
            IF  pOldRestart^.rstMigrationDone_kb57
            THEN
                BEGIN
                (* *)
                (* Restore data of liveCache release 7.2    *)
                (* containing the migration flag is allowed *)
                (* *)
                bMigrationNeeded := true;
                bRestorePossible := true
                END
            ELSE
                g01opmsg (sp3p_knldiag, sp3m_info, kbMsg_csp03,
                      csp3_n_migration, 'Hostfile is not migrated', 0 );
            (*ENDIF*) 
            END
        ELSE
            g01optextmsg (sp3p_knldiag, sp3m_info, kbMsg_csp03,
                  csp3_n_migration, 'Restore of this Hostfile not possible   ');
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  NOT bRestorePossible
    THEN
        BEGIN
        g01optextmsg (sp3p_knldiag, sp3m_error, kbMsg_csp03,
              csp3_n_restore, rstReleaseVersion_kb00 );
        g01optextmsg (sp3p_knldiag, sp3m_error, kbMsg_csp03,
              csp3_n_restore, 'Restore not possible. Hostfile too old! ');
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57RestoreRestartRecord (TaskId : tsp00_TaskId);
 
BEGIN
vbegexcl (TaskId, g08surrogate);
bd999ReadRestartPage (TaskId, k57restartrec);
vendexcl (TaskId, g08surrogate)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57RestoreRestartRecordAfterMigration (pOldRestart : tkb57_OldRestarRecordPtr);
 
VAR
      auxError : tgg00_BasisError;
 
BEGIN
auxError := e_ok; (* no move error is possible *)
SAPDB_PascalMove ('VKB57 ',  23,    
      sizeof (k57restartrec^), sizeof (k57restartrec^),
      @pOldRestart^, 1, @k57restartrec^, 1, sizeof (k57restartrec^), auxError);
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57SetRootBlockAddr( PackedRootBlockAddr : tsp00_Int4 );
 
BEGIN
k57restartrec^.rstConfigParam_kb00.crConvRootBlockAddr_kb00 := PackedRootBlockAddr;
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57SetMaxDynamicPageNo( MaxDynamicPageNo : tsp00_PageNo );
 
BEGIN
k57restartrec^.rstConfigParam_kb00.crMaxDynamicPno_kb00 := MaxDynamicPageNo;
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57SetMaxStaticPageNo( MaxStaticPageNo : tsp00_PageNo );
 
BEGIN
k57restartrec^.rstConfigParam_kb00.crMaxStaticPno_kb00 := MaxStaticPageNo;
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57SetVolumeNoBitCount( VolumeNoBitCount : tsp00_Uint1 );
 
BEGIN
k57restartrec^.rstConfigParam_kb00.crVolumeBitCount_kb00 := VolumeNoBitCount;
END;
 
(*------------------------------*) 
 
FUNCTION
      kb57GetClusterReservedSpace: tsp00_Uint4;
 
BEGIN
kb57GetClusterReservedSpace := k57restartrec^.rstConfigParam_kb00.crClusterReservedSpace_kb00;
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57SetClusterReservedSpace( ClusterReservedSpace : tsp00_Uint4 );
 
BEGIN
k57restartrec^.rstConfigParam_kb00.crClusterReservedSpace_kb00 := ClusterReservedSpace;
END;
 
(*------------------------------*) 
 
FUNCTION
      kb57GetClusterBlockCount: tsp00_Uint2;
 
BEGIN
kb57GetClusterBlockCount := k57restartrec^.rstConfigParam_kb00.crClusterBlockCount_kb00;
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57SetClusterBlockCount( ClusterBlockCount : tsp00_Uint2 );
 
BEGIN
    k57restartrec^.rstConfigParam_kb00.crClusterBlockCount_kb00 := ClusterBlockCount;
END;
 
(*------------------------------*) 
 
FUNCTION
      kb57IsSnapShotDefined : boolean;
 
BEGIN
WITH k57restartrec^.rstConfigParam_kb00 DO
    kb57IsSnapShotDefined := (crSnapShotRestartRecordAddr_kb00 <> 0)
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57adjust_lru_timestamp;
 
VAR
      ix       : integer;
      curr_seq : tkb57_seq_cache_ptr;
 
BEGIN
k57.lru_timestamp := k57.lru_timestamp DIV 2 + 1;
FOR ix := 0 TO ckb57_seq_hash_value - 1 DO
    BEGIN
    curr_seq := k57.seq_head[ix].sqh_first;
    WHILE curr_seq <> NIL DO
        BEGIN
        curr_seq^.sqc_lru_ts := curr_seq^.sqc_lru_ts DIV 2;
        curr_seq             := curr_seq^.sqc_hash_next
        END;
    (*ENDWHILE*) 
    END
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      kb57displaced_sequence (VAR t : tgg00_TransContext) : tkb57_seq_cache_ptr;
 
VAR
      ix           : tsp00_Int4;
      min_ts       : tsp00_Int4;
      curr_head    : ^tkb57_seq_hash_entry;
      displace_seq : tkb57_seq_cache_ptr;
      prev_seq     : tkb57_seq_cache_ptr;
 
BEGIN
(* find sequence to be displaced, i.e. sequence with least lru *)
(* timestamp, candidates are last entries of all hash lists    *)
min_ts := MAX_INT4_SP00;
FOR ix := 0 TO ckb57_seq_hash_value - 1 DO
    IF  k57.seq_head[ix].sqh_last <> NIL
    THEN
        IF  k57.seq_head[ix].sqh_last^.sqc_lru_ts < min_ts
        THEN
            BEGIN
            curr_head := @k57.seq_head[ix];
            min_ts    := curr_head^.sqh_last^.sqc_lru_ts;
            END;
        (* remove sequence from hash list *)
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDFOR*) 
prev_seq     := NIL;
displace_seq := curr_head^.sqh_first;
WHILE displace_seq^.sqc_hash_next <> NIL DO
    BEGIN
    prev_seq     := displace_seq;
    displace_seq := displace_seq^.sqc_hash_next
    END;
(*ENDWHILE*) 
IF  displace_seq^.sqc_log
THEN
    kb57sequences_to_log (t);
(*ENDIF*) 
IF  (displace_seq^.sqc_flush) AND (t.trError_gg00 = e_ok)
THEN
    a23flush_sequence (t,
          displace_seq^.sqc_surrogate, displace_seq^.sqc_log_value);
(*ENDIF*) 
IF  t.trError_gg00 <> e_ok
THEN
    displace_seq := NIL
ELSE
    IF  prev_seq = NIL
    THEN
        BEGIN
        curr_head^.sqh_first := NIL;
        curr_head^.sqh_last  := NIL
        END
    ELSE
        BEGIN
        prev_seq^.sqc_hash_next := NIL;
        curr_head^.sqh_last     := prev_seq
        END;
    (*ENDIF*) 
(*ENDIF*) 
kb57displaced_sequence := displace_seq
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57find_sequence (
            VAR t              : tgg00_TransContext;
            VAR seq_surrogate  : tgg00_Surrogate;
            VAR found_seq      : tkb57_seq_cache_ptr;
            is_restart         : boolean);
 
VAR
      curr_head : ^tkb57_seq_hash_entry;
      curr_seq  : tkb57_seq_cache_ptr;
      prev_seq  : tkb57_seq_cache_ptr;
      absval    : tsp00_Int4;
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-10-11 *)
THEN
    g08excl_check (t.trTaskId_gg00, g08surrogate);
(*ENDIF*) 
t.trError_gg00  := e_ok;
found_seq := NIL;
absval := abs(s20buf_to_int4 (seq_surrogate, sizeof (seq_surrogate) - 4 + 1));
curr_head := @k57.seq_head[absval MOD ckb57_seq_hash_value];
curr_seq  := curr_head^.sqh_first;
WHILE curr_seq <> NIL DO
    IF  curr_seq^.sqc_surrogate = seq_surrogate
    THEN
        BEGIN
        IF  true (* k57.seq_hit + k57.seq_miss < MAX_INT4_SP00 *)
        THEN
            k57.seq_hit := k57.seq_hit + ONE_8BYTE_CNT_GG04 (* PTS 1103743 JA 1999-08-25 *)
        ELSE
            BEGIN
            k57.seq_miss := k57.seq_miss / 2;
            k57.seq_hit  := k57.seq_hit  / 2 + 1
            END;
        (*ENDIF*) 
        found_seq   := curr_seq;
        IF  found_seq <> curr_head^.sqh_first
        THEN
            BEGIN (* move found sequence in front of list *)
            IF  found_seq^.sqc_hash_next = NIL
            THEN
                BEGIN
                prev_seq^.sqc_hash_next := NIL;
                curr_head^.sqh_last     := prev_seq
                END
            ELSE
                prev_seq^.sqc_hash_next := found_seq^.sqc_hash_next;
            (*ENDIF*) 
            found_seq^.sqc_hash_next := curr_head^.sqh_first;
            curr_head^.sqh_first     := found_seq
            END;
        (*ENDIF*) 
        curr_seq  := NIL;
        END
    ELSE
        BEGIN
        prev_seq := curr_seq;
        curr_seq := curr_seq^.sqc_hash_next
        END;
    (*ENDIF*) 
(*ENDWHILE*) 
IF  found_seq = NIL
THEN
    BEGIN
    IF  true (* k57.seq_hit + k57.seq_miss < MAX_INT4_SP00 *)
    THEN
        k57.seq_miss := k57.seq_miss + ONE_8BYTE_CNT_GG04 (* PTS 1103743 JA 1999-08-25 *)
    ELSE
        BEGIN
        k57.seq_miss := k57.seq_miss / 2 + 1;
        k57.seq_hit  := k57.seq_hit  / 2
        END;
    (*ENDIF*) 
    IF  k57.seq_free = NIL
    THEN
        curr_seq := kb57displaced_sequence (t)
    ELSE
        BEGIN
        curr_seq     := k57.seq_free;
        k57.seq_free := curr_seq^.sqc_next_free
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (curr_seq <> NIL) AND (t.trError_gg00 = e_ok)
THEN
    BEGIN
    IF  NOT is_restart
    THEN
        a23get_sequence_value (t,
              seq_surrogate, curr_seq^.sqc_value,
              curr_seq^.sqc_first);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        found_seq                := curr_seq;
        found_seq^.sqc_log_value := found_seq^.sqc_value;
        found_seq^.sqc_surrogate := seq_surrogate;
        found_seq^.sqc_log       := false;
        found_seq^.sqc_log_next  := NIL;
        found_seq^.sqc_flush     := false;
        found_seq^.sqc_filler    := false;
        (* just to make usecheck happy *)
        found_seq^.sqc_hash_next := curr_head^.sqh_first;
        IF  curr_head^.sqh_first = NIL
        THEN
            curr_head^.sqh_last := found_seq;
        (*ENDIF*) 
        curr_head^.sqh_first := found_seq
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok) AND (found_seq <> NIL)
THEN
    BEGIN
    IF  k57.lru_timestamp = MAX_INT4_SP00
    THEN
        kb57adjust_lru_timestamp
    ELSE
        k57.lru_timestamp := k57.lru_timestamp + 1;
    (*ENDIF*) 
    found_seq^.sqc_lru_ts := k57.lru_timestamp
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57init_sequence_cache (seq_cache_size : tsp00_Int4);
 
VAR
      ix                : tsp00_Int4;
      seq_cache_entries : tsp00_Int4;
 
BEGIN
k57.lru_timestamp := 0;
k57.seq_hit       := 0;
k57.seq_miss      := 0;
FOR ix := 0 TO ckb57_seq_hash_value DO
    BEGIN
    k57.seq_head[ix].sqh_first := NIL;
    k57.seq_head[ix].sqh_last  := NIL
    END;
(*ENDFOR*) 
(* PTS 1116801 E.Z. *)
seq_cache_entries :=
      (seq_cache_size * sizeof (tsp00_Page)) DIV sizeof (k57.seq^[1]);
k57.seq_free := @k57.seq^[1];
FOR ix := 1 TO seq_cache_entries - 1 DO
    k57.seq^[ix].sqc_next_free := @k57.seq^[ix+1];
(*ENDFOR*) 
k57.seq^[seq_cache_entries].sqc_next_free := NIL;
k57.seq_log                               := NIL
END; { kb57init_sequence_cache }
 
(*------------------------------*) 
 
PROCEDURE
      kb57remove_sequence (VAR m : tgg00_MessBlock);
 
VAR
      curr_head     : ^tkb57_seq_hash_entry;
      curr_seq      : tkb57_seq_cache_ptr;
      prev_seq      : tkb57_seq_cache_ptr;
      seq_surrogate : tgg00_Surrogate;
      absval        : tsp00_Int4;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
SAPDB_PascalMove ('VKB57 ',  24,    
      m.mb_qual_size, sizeof (seq_surrogate),
      @m.mb_qual^.buf, 1, @seq_surrogate, 1, sizeof (seq_surrogate),
      m.mb_trns^.trError_gg00);
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    absval := abs(s20buf_to_int4 (seq_surrogate, sizeof (seq_surrogate) - 4 + 1));
    curr_head := @k57.seq_head[absval MOD ckb57_seq_hash_value];
    prev_seq  := NIL;
    vbegexcl (m.mb_trns^.trTaskId_gg00, g08surrogate);
    kb57wait_for_surrogate_log (m.mb_trns^.trTaskId_gg00);
    curr_seq  := curr_head^.sqh_first;
    WHILE (curr_seq <> NIL) AND (m.mb_trns^.trError_gg00 = e_ok) DO
        IF  curr_seq^.sqc_surrogate = seq_surrogate
        THEN
            BEGIN
            IF  curr_seq^.sqc_log
            THEN
                kb57sequences_to_log (m.mb_trns^);
            (*ENDIF*) 
            ;
            (* sequence found, remove from hash list *)
            IF  prev_seq = NIL
            THEN
                curr_head^.sqh_first := curr_seq^.sqc_hash_next
            ELSE
                prev_seq^.sqc_hash_next := curr_seq^.sqc_hash_next;
            (*ENDIF*) 
            IF  curr_head^.sqh_last = curr_seq
            THEN
                curr_head^.sqh_last := prev_seq;
            (*ENDIF*) 
            ;
            (* insert into free list *)
            curr_seq^.sqc_next_free := k57.seq_free;
            k57.seq_free            := curr_seq;
            ;
            (* exit loop *)
            curr_seq  := NIL
            END
        ELSE
            BEGIN
            prev_seq := curr_seq;
            curr_seq := curr_seq^.sqc_hash_next
            END;
        (*ENDIF*) 
    (*ENDWHILE*) 
    vendexcl (m.mb_trns^.trTaskId_gg00, g08surrogate)
    END
(*ENDIF*) 
END; { kb57remove_sequence }
 
(*------------------------------*) 
 
PROCEDURE
      kb57sequences_to_log (VAR t : tgg00_TransContext);
 
VAR
      logging_set : boolean;
      i           : integer;
      SequenceCnt : integer;
      buf_len     : tsp00_Int4;
      old_seq     : tkb57_seq_cache_ptr;
      curr_seq    : tkb57_seq_cache_ptr;
      buf         : tsp00_Buf;
 
BEGIN
(* log updated sequences stored in k57.seq_log list *)
t.trError_gg00 := e_ok;
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-10-11 *)
THEN
    g08excl_check (t.trTaskId_gg00, g08surrogate);
(*ENDIF*) 
IF  k57.surrog_logging
THEN
    logging_set := false
ELSE
    BEGIN
    logging_set        := true;
    k57.surrog_logging := true
    END;
(*ENDIF*) 
REPEAT
    SequenceCnt := 0;
    curr_seq    := k57.seq_log;
    i           := 1;
    buf_len     := 0;
    WHILE (curr_seq <> NIL) AND (t.trError_gg00 = e_ok)
          AND
          (buf_len + sizeof (tgg00_Surrogate) + sizeof (tsp00_Number)
          <= sizeof (buf)) DO
        BEGIN
        IF  curr_seq^.sqc_log
        THEN
            BEGIN
            SequenceCnt := SequenceCnt + 1;
            SAPDB_PascalMove ('VKB57 ',  25,    
                  sizeof (curr_seq^.sqc_surrogate), sizeof (buf),
                  @curr_seq^.sqc_surrogate, 1, @buf, buf_len + 1,
                  sizeof (curr_seq^.sqc_surrogate), t.trError_gg00);
            buf_len := buf_len + sizeof (curr_seq^.sqc_surrogate);
            SAPDB_PascalMove ('VKB57 ',  26,    
                  sizeof (curr_seq^.sqc_log_value), sizeof (buf),
                  @curr_seq^.sqc_log_value, 1, @buf, buf_len+1,
                  sizeof (curr_seq^.sqc_log_value), t.trError_gg00);
            buf_len := buf_len + sizeof (curr_seq^.sqc_log_value)
            END;
        (*ENDIF*) 
        curr_seq := curr_seq^.sqc_log_next
        END;
    (*ENDWHILE*) 
    ;
    (* PTS 1110134 E.Z. *)
    IF  SequenceCnt > 0
    THEN
        BEGIN
        vendexcl (t.trTaskId_gg00, g08surrogate);
        ;
        kb571WriteRefreshSeqAfterImage (t, SequenceCnt, @buf);
        ;
        vbegexcl (t.trTaskId_gg00, g08surrogate);
        ;
        IF  t.trError_gg00 = e_ok
        THEN (* remove logged sequences from list *)
            BEGIN
            curr_seq    := k57.seq_log;
            k57.seq_log := NIL;
            i := 0;
            WHILE (i < SequenceCnt) AND (curr_seq <> NIL) DO
                BEGIN
                old_seq  := curr_seq;
                curr_seq := curr_seq^.sqc_log_next;
                IF  old_seq^.sqc_log
                THEN
                    BEGIN
                    (* remove *)
                    old_seq^.sqc_log      := false;
                    old_seq^.sqc_log_next := NIL;
                    i := succ(i)
                    END
                ELSE
                    BEGIN
                    (* leave in list *)
                    old_seq^.sqc_log_next := k57.seq_log;
                    k57.seq_log := old_seq;
                    END
                (*ENDIF*) 
                END
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
UNTIL
    (SequenceCnt = 0) OR (t.trError_gg00 <> e_ok);
(*ENDREPEAT*) 
IF  logging_set
THEN
    BEGIN
    k57.surrog_logging := false;
    kb571AllSurrogateWaitsResume;
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb57wait_for_surrogate_log (process_id : tsp00_TaskId);
 
VAR
      waitcontext : tgg00_WaitContext;
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-10-11 *)
THEN
    g08excl_check (process_id, g08surrogate);
(*ENDIF*) 
WHILE k57.surrog_logging DO
    BEGIN
    kb571SurrogateWaitInsert (process_id, waitcontext);
    vendexcl (process_id, g08surrogate);
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    vsuspend (process_id, 225);
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    vbegexcl (process_id, g08surrogate)
    END
(*ENDWHILE*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
