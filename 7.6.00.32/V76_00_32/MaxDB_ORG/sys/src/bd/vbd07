.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.tt 1 $SQL$Project Distributed Database System$VBD07$
.tt 2 $$$$
.tt 3 $JuergenP$filesysteminterface_7$$2000-10-04$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
Module  : filesysteminterface_7
=========
.sp
Purpose : base layer operations :
            - processing temporary files
 
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              b07cadd_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b07cappend_record (VAR t : tgg00_TransContext;
                    VAR file_id  : tgg00_FileId;
                    VAR tree_pos : tgg00_FilePos;
                    VAR b        : tgg00_Rec);
 
        PROCEDURE
              b07crepl_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b07ctrepl_record (
                    VAR t        : tgg00_TransContext;
                    VAR file_id  : tgg00_FileId;
                    VAR tree_pos : tgg00_FilePos;
                    VAR b        : tgg00_Rec);
 
        PROCEDURE
              b07cdel_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Lkey);
 
        PROCEDURE
              b07ctget_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR tree_pos : tgg00_FilePos;
                    VAR rk      : tgg00_Lkey;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b07cget_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Lkey;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b07cprev_record (VAR t : tgg00_TransContext;
                    VAR file_id    : tgg00_FileId;
                    VAR rk         : tgg00_Lkey;
                    VAR set_result : tgg00_BdSetResultRecord;
                    VAR tree_pos   : tgg00_FilePos;
                    VAR b          : tsp00_MoveObj);
 
        PROCEDURE
              b07cnext_record (VAR t : tgg00_TransContext;
                    VAR file_id    : tgg00_FileId;
                    VAR rk         : tgg00_Lkey;
                    VAR set_result : tgg00_BdSetResultRecord;
                    VAR tree_pos   : tgg00_FilePos;
                    VAR b          : tsp00_MoveObj);
 
        PROCEDURE
              b07get_result_leaf (VAR t : tgg00_TransContext;
                    VAR file_id     : tgg00_FileId;
                    VAR rk          : tgg00_Lkey;
                    get_next        : boolean;
                    prepare_for_upd : boolean;
                    VAR tree_pos    : tgg00_FilePos;
                    VAR nptr        : tbd_node_ptrs);
 
        PROCEDURE
              b07release_result_leaf (VAR t : tgg00_TransContext;
                    VAR file_id  : tgg00_FileId;
                    node_changed : boolean;
                    VAR nptr     : tbd_node_ptrs);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01downfilesystem : boolean;
 
      ------------------------------ 
 
        FROM
              nodehandling : VBD13;
 
        PROCEDURE
              b13r_release_node (VAR nptr : tbd_node_ptrs;
                    VAR current : tbd_current_tree;
                    lru_info    : tbd_lru_info);
 
        PROCEDURE
              b13w_release_node (VAR nptr : tbd_node_ptrs;
                    VAR current : tbd_current_tree);
 
      ------------------------------ 
 
        FROM
              treehandling : VBD30;
 
        PROCEDURE
              b30cappend_to_tree (
                    VAR rk       : tgg00_Lkey;
                    VAR b        : tgg00_Rec;
                    VAR tree_pos : tgg00_FilePos;
                    VAR current  : tbd_current_tree);
 
        PROCEDURE
              b30cget_result_leaf (
                    VAR rk          : tgg00_Lkey;
                    get_next        : boolean;
                    prepare_for_upd : boolean;
                    VAR tree_pos    : tgg00_FilePos;
                    VAR nptr        : tbd_node_ptrs;
                    VAR current     : tbd_current_tree);
 
        PROCEDURE
              b30cprev_from_tree (
                    VAR rk         : tgg00_Lkey;
                    VAR set_result : tgg00_BdSetResultRecord;
                    VAR tree_pos   : tgg00_FilePos;
                    VAR b          : tsp00_MoveObj;
                    VAR current    : tbd_current_tree);
 
        PROCEDURE
              b30cnext_from_tree (
                    VAR rk         : tgg00_Lkey;
                    VAR set_result : tgg00_BdSetResultRecord;
                    VAR tree_pos   : tgg00_FilePos;
                    VAR b          : tsp00_MoveObj;
                    VAR current    : tbd_current_tree);
 
        PROCEDURE
              bd30AddToTree (
                    VAR recKey    : tgg00_Lkey;
                    VAR rec       : tgg00_Rec;
                    VAR current   : tbd_current_tree);
 
        PROCEDURE
              bd30BuildCurrent (
                    VAR trans   : tgg00_TransContext;
                    VAR fileId  : tgg00_FileId;
                    VAR current : tbd_current_tree);
 
        PROCEDURE
              bd30DelFromTree (
                    VAR recKey  : tgg00_Lkey;
                    VAR current : tbd_current_tree);
 
        PROCEDURE
              bd30GetFromTreeWithTreepos (
                    VAR recKey  : tgg00_Lkey;
                    VAR rec     : tgg00_Rec;
                    VAR tree_pos   : tgg00_FilePos;
                    VAR current : tbd_current_tree;
                    wantedLock  : tgg00_LockReqMode);
 
        PROCEDURE
              bd30GetTree (
                    VAR trans            : tgg00_TransContext;
                    VAR fileId           : tgg00_FileId;
                    VAR current          : tbd_current_tree;
                    messType             : tgg00_MessType;
                    bLockTreeExcl        : boolean;
                    bSynchronizeExclLock : boolean);
 
        PROCEDURE
              bd30ReleaseTree (
                    VAR current : tbd_current_tree);
 
        PROCEDURE
              bd30ReplaceInTree (
                    VAR recKey    : tgg00_Lkey;
                    VAR rec       : tgg00_Rec;
                    VAR current   : tbd_current_tree;
                    VAR beforeRef : tgg91_PageRef;
                    VAR updTrans  : tgg91_TransNo);
 
        PROCEDURE
              bd30ReplaceInTreeWithTreepos (
                    VAR rec      : tgg00_Rec;
                    VAR tree_pos : tgg00_FilePos;
                    VAR current  : tbd_current_tree);
 
      ------------------------------ 
 
        FROM
              BD_Wrapper : VBD999;
 
        PROCEDURE
              bd999CheckSpace(
                    VAR Trans         : tgg00_TransContext;
                    NumPagesRequestes : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01vtrace : tgg00_VtraceState;
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        FUNCTION
              gg06Min (
                    value1 : tsp00_Int4;
                    value2 : tsp00_Int4 ) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              ref_statistic : VBD73;
 
        PROCEDURE
              b73cmd_count (statement_kind : tgg00_RefInfoIndex);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01basis_error (layer : tgg00_Debug;
                    nam   : tsp00_Sname;
                    b_err : tgg00_BasisError);
 
        PROCEDURE
              t01int4 (layer : tgg00_Debug;
                    nam : tsp00_Sname;
                    int : tsp00_Int4);
 
        PROCEDURE
              t01name (layer : tgg00_Debug;
                    nam : tsp00_Name);
 
        PROCEDURE
              t01lkey (layer : tgg00_Debug;
                    VAR k : tgg00_Lkey);
 
        PROCEDURE
              t01bool (debug : tgg00_Debug;
                    nam      : tsp00_Sname;
                    curr_bool: boolean);
 
        PROCEDURE
              t01buf (layer : tgg00_Debug;
                    VAR buf : tgg00_Rec;
                    start_p : integer;
                    stop_p  : integer);
 
        PROCEDURE
              t01moveobj (layer : tgg00_Debug;
                    VAR buf : tsp00_MoveObj;
                    start_p : tsp00_Int4;
                    stop_p  : tsp00_Int4);
 
        PROCEDURE
              t01page (layer : tgg00_Debug;
                    VAR buf : tbd_node;
                    start_p : tsp00_Int4;
                    stop_p  : tsp00_Int4);
 
        PROCEDURE
              t01p2int4 (layer : tgg00_Debug;
                    nam_1 : tsp00_Sname;
                    int_1 : tsp00_Int4;
                    nam_2 : tsp00_Sname;
                    int_2 : tsp00_Int4);
 
        PROCEDURE
              t01treeid (layer : tgg00_Debug;
                    nam        : tsp00_Sname;
                    VAR treeid : tgg00_FileId);
&       endif
 
      ------------------------------ 
 
        FROM
              Trace : VBD120;
 
        PROCEDURE
              b120InsertTrace (VAR t   : tgg00_TransContext;
                    trace_layer  : tgg00_Debug;
                    trace_object : tgg00_VtraceType;
                    body_len     : tsp00_Int2;
                    trace_body   : tgg11_VtraceBodyPtr);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
&       ifdef TRACE
        PROCEDURE
              t01buf;
 
              tsp00_Buf tgg00_Rec
 
        PROCEDURE
              t01page;
 
              tsp00_Page tbd_node
&             endif
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : JuergenP
.sp
.cp 3
Created : 1979-09-05
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-10-04
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.sp 2;.cp 4
.oc _/1;1._Processing_Primary_Files
.sp 3
Primary file entries are records that have the following
structure when they are transferred to record buffers:
.nf
.sp 2
       2   2    kl bytes      v bytes
     --------------------------------------
     |rl |kl |   key   |  nonkeyfields     |
     --------------------------------------
 
     |rl| = 2 + 2 + kl + v <= maxrecordlength
 
.fo
.sp 2
Records are always left-justified (i.e. they start in position 1)
when they are entered in record buffers.  Each record has a record
header that contains its record length (rl <= maxrecordlength)
and its record key length (kl <= max_keylen).
.sp 3;.cp 6
b07cadd_record (t,fn,bd_use_info,act_tree_id,b,e)
.sp
The record that is transferred to record buffer b is entered in the
temporary file that is either identified by the file name fn or is
already identified by the record variable act_tree_id, depending
on bd_use_info.  If act_tree_id has not been assigned, the file
identification is read from the file directory and sent to
the calling procedure.  One of the following messages, among others,
is sent to e:
   - e_ok
   - b_duplicate_key
   - b_no_more_tempspace
   - b_illegal_entrypos
   - b_invalid_entrypos
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b07cappend_record (t,file_id,tree_pos,b,e)
.sp
The record that is transferred to record buffer b is appended to
the temporary file that is identified by the
record variable file_id.
One of the following messages is sent to e:
   - e_ok
   - b_duplicate_key
   - b_no_more_tempspace
   - b_illegal_entrypos
   - b_invalid_entrypos
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b07crepl_record (t,fn,bd_use_info,act_tree_id,b,e)
.sp
The record that is transferred to record buffer b replaces the
record with the same key in file fn, if the file contains such
a record.  The meaning of parameters bd_use_info and act_tree_id
can be found in the b07cadd_record specification.
One of the following messages is sent to e:
   - e_ok
   - b_file_not_found
   - b_key_not_found
   - b_illegal_entrypos
   - b_invalid_entrypos
   - b_no_more_tempspace
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b02cdel_record (t,fn,bd_use_info,act_tree_id,rk,e)
.sp
The record whose key matches the key entered in the key
buffer rk is deleted from the file.  The key structure must
be compatible with the key type defined for the file.
The meaning of parameters bd_use_info and act_tree_id can be
found in the b07cadd_record specification.
One of the following messages, among others, is sent to e:
   - e_ok
   - b_file_not_found
   - b_illegal_key
   - b_illegal_entrypos
   - b_invalid_entrypos
   - b_key_not_found
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b07cget_record (t,fn,bd_use_info,act_tree_id,rk,b,e)
.sp
A search is carried out in the file fn for the record whose key
matches the key entered in rk.  If this record is present, it
is transferred to record buffer b.  The meaning of parameters
bd_use_info and act_tree_id can be found in the b07cadd_record
specification.
One of the following messages, among others, is sent to e:
   - e_ok
   - b_file_not_found
   - b_illegal_key
   - b_illegal_entrypos
   - b_invalid_entrypos
   - b_key_not_found
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b07cprev_record (t,file_id,rk,set_result,tree_pos,b,e)
.sp
If the temporary file that is identified by the file name fn or
by file information act_tree_id as validated by bd_use_info contains
no record with a key that is smaller than the key entered in rk,
'b_no_prev_record' it sent to e.  Otherwise a search is carried
out in the file for the record with a key that matches the entered
key.  If such a record is present, as many of the records
immediately preceeding it (NOT single, cnt > 1) in the file are
transferred to record buffer b as the buffer can receive; the first
two bytes contain the total length of the records that have been
transferred.  If further records are present, e shows
'b_buffer_limit'.  If the record is not found, e returns
'b_key_not_found' and supplies those file records that would have
preceeded the record for which the search was being run.
One of the following messages, among others, is sent to e:
   - e_ok
   - b_file_not_found
   - b_illegal_key
   - b_illegal_entrypos
   - b_invalid_entrypos
   - b_no_prev_record
   - b_key_not_found
   - b_buffer_limit
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b07cnext_record (t,file_id,rk,set_result,tree_pos,b,e)
.sp
If the temporary file that is identified by
file information file_id
contains no record with a key greater than the key entered
in rk, 'b_no_next_record' is sent to e.  Otherwise, a search
is carried out in the file for the record with a key that
matches the entered key.  If such a record is present, as many
records that immediately follow it (NOT single plus cnt > 1) in the
file are transferred to record buffer b as the buffer can receive;
the first two bytes contain the total length of the records that
have been transferred.  If further records are present, e shows
'b_buffer_limit'.  If the record is not found, e returns
'b_key_not_found' and supplies file records that would have
followed the record for which the search was being run.
One of the following messages, among others, is sent to e:
   - e_ok
   - b_file_not_found
   - b_illegal_key
   - b_illegal_entrypos
   - b_invalid_entrypos
   - b_no_next_record
   - b_key_not_found
   - b_buffer_limit
   - b_shutdown
   - b_disk_not_accessible
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
A global variable 'database_state' indicates by means of
'e_ok' that the file system has been generated and is
not shut down; otherwise it contains the message 'b_shutdown'.
The existence of a file can generally be detected by accessing
the file directory.  In addition, the 'add' and 'repl' operations
are used to determine whether enough space is still available
in the secondary storage.
.sp
When a new file is being created, a tree root is requested and an
entry identifying the file is included in the file directory.
.sp
Entries in a file are stored in the leaves of a B tree.
File routines are thus referred back to the appropriate
tree routine.  Before each tree routine is called, the operation
b30adjust_tree identifies which tree is being processed;
this means that, later on, certain information does not always
have to be carried along as a parameter.
.sp
When a checkpoint is set, only the system buffer
(as necessary) is written to the secondary storage.
.sp
If a file routine sends the message b_disk_not_accessible
to e, the physical integrity of the file system is no
longer secure!
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
(*------------------------------*) 
 
PROCEDURE
      b07cadd_record (VAR t : tgg00_TransContext;
            VAR file_id : tgg00_FileId;
            VAR b       : tgg00_Rec);
 
VAR
      auxError   : tgg00_BasisError;
      key_trace  : tgg11_BdKeyTrace;
      root_trace : tgg11_BdRootTrace;
      current    : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := b.recKeyLen_gg00;
    SAPDB_PascalMove ('VBD07 ',   1,    
          b.recKeyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @b.recKey_gg00.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( b.recKeyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b07cadd, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd cadd rec ');
t01treeid (bi, 'treeid      ', file_id);
t01buf    (bi, b, 1, b.recLen_gg00);
&endif
b73cmd_count (icadd_rec);
WITH t DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        IF  (b.recLen_gg00 > MAX_RECLEN_GG00) OR
            (b.recLen_gg00 < MIN_RECORD_LEN_BD00)
        THEN
            trError_gg00 := e_illegal_record
        ELSE
            IF  (b.recKeyLen_gg00 > KEY_MXSP00) OR (b.recKeyLen_gg00 < 0)
            THEN
                trError_gg00 := e_illegal_key
            ELSE
                trError_gg00 := e_ok;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        bd999CheckSpace (t, 2);
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 + [bd_write_acc];
        bd30GetTree (t, file_id, current, m_insert,
              LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            root_trace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
            bd30AddToTree (b.recKey_gg00, b, current)
            END;
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  trError_gg00 = e_ok
        THEN
            file_id := current.curr_tree_id;
        (*ENDIF*) 
        file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 - [bd_write_acc]
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b07cadd, sizeof (root_trace), @root_trace)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b07cappend_record (VAR t : tgg00_TransContext;
            VAR file_id  : tgg00_FileId;
            VAR tree_pos : tgg00_FilePos;
            VAR b        : tgg00_Rec);
 
VAR
      auxError      : tgg00_BasisError;
      key_trace     : tgg11_BdKeyTrace;
      root_trace    : tgg11_BdRootTrace;
      current       : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := b.recKeyLen_gg00;
    SAPDB_PascalMove ('VBD07 ',   2,    
          b.recKeyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @b.recKey_gg00.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( b.recKeyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b07cappend, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd capp rec ');
t01treeid (bi, 'treeid      ', file_id);
t01p2int4 (bi, 'leaf        ', tree_pos.tpsPno_gg00,
      'index       ', tree_pos.tpsIndex_gg00);
t01buf    (bi, b, 1, b.recLen_gg00);
&endif
b73cmd_count (icadd_rec);
WITH t DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        IF  (b.recLen_gg00 > MAX_RECLEN_GG00)
            OR (b.recLen_gg00 < MIN_RECORD_LEN_BD00)
        THEN
            trError_gg00 := e_illegal_record
        ELSE
            IF  (b.recKeyLen_gg00 > KEY_MXSP00) OR (b.recKeyLen_gg00 < 0)
            THEN
                trError_gg00 := e_illegal_key
            ELSE
                trError_gg00 := e_ok;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        bd999CheckSpace (t, 2);
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 + [bd_write_acc];
        bd30GetTree (t, file_id, current, m_insert,
              LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            root_trace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
            b30cappend_to_tree (b.recKey_gg00, b, tree_pos, current);
            END;
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  trError_gg00 = e_ok
        THEN
            file_id := current.curr_tree_id;
        (*ENDIF*) 
        file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 - [bd_write_acc]
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
t01p2int4 (bi, 'leaf out    ', tree_pos.tpsPno_gg00, 'index out   ',
      tree_pos.tpsIndex_gg00);
t01basis_error (bi, 'capp rec err', t.trError_gg00);
&endif
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b07cappend, sizeof (root_trace), @root_trace)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b07crepl_record (VAR t : tgg00_TransContext;
            VAR file_id : tgg00_FileId;
            VAR b       : tgg00_Rec);
 
VAR
      dummy_tree_pos   : tgg00_FilePos;
 
BEGIN
dummy_tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
b07ctrepl_record (t, file_id, dummy_tree_pos, b);
END;
 
(*------------------------------*) 
 
PROCEDURE
      b07ctrepl_record (
            VAR t         : tgg00_TransContext;
            VAR file_id   : tgg00_FileId;
            VAR tree_pos  : tgg00_FilePos;
            VAR b         : tgg00_Rec);
 
VAR
      auxError      : tgg00_BasisError;
      key_trace     : tgg11_BdKeyTrace;
      root_trace    : tgg11_BdRootTrace;
      current       : tbd_current_tree;
      dummyRef      : tgg91_PageRef;
      dummyTrans    : tgg91_TransNo;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := b.recKeyLen_gg00;
    SAPDB_PascalMove ('VBD07 ',   3,    
          b.recKeyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @b.recKey_gg00.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( b.recKeyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b07crepl, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd crepl rec');
t01treeid (bi, 'treeid      ', file_id);
t01p2int4 (bi, 'treePosLeaf ', tree_pos.tpsPno_gg00,
      'treePosIndex', tree_pos.tpsIndex_gg00);
t01buf    (bi, b, 1, b.recLen_gg00);
&endif
b73cmd_count (icrepl_rec);
WITH t DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        IF  (b.recLen_gg00 > MAX_RECLEN_GG00)
            OR (b.recLen_gg00 < MIN_RECORD_LEN_BD00)
        THEN
            trError_gg00 := e_illegal_record
        ELSE
            IF  (b.recKeyLen_gg00 > KEY_MXSP00) OR (b.recKeyLen_gg00 < 0)
            THEN
                trError_gg00 := e_illegal_key
            ELSE
                trError_gg00 := e_ok;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 + [bd_write_acc];
        bd30GetTree (t, file_id, current, m_update,
              LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            root_trace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
            IF  tree_pos.tpsPno_gg00 <> NIL_PAGE_NO_GG00
            THEN
                bd30ReplaceInTreeWithTreepos (b, tree_pos, current)
            ELSE
                bd30ReplaceInTree (b.recKey_gg00, b, current, dummyRef, dummyTrans)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  trError_gg00 = e_ok
        THEN
            file_id := current.curr_tree_id;
        (*ENDIF*) 
        file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 - [bd_write_acc]
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b07crepl, sizeof (root_trace), @root_trace)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b07cdel_record (VAR t : tgg00_TransContext;
            VAR file_id : tgg00_FileId;
            VAR rk      : tgg00_Lkey);
 
VAR
      auxError   : tgg00_BasisError;
      key_trace  : tgg11_BdKeyTrace;
      root_trace : tgg11_BdRootTrace;
      current    : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := rk.keyLen_gg00;
    SAPDB_PascalMove ('VBD07 ',   4,    
          rk.keyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @rk.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( rk.keyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b07cdel, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd cdel rec ');
t01treeid (bi, 'treeid      ', file_id);
t01lkey   (bi, rk);
&endif
b73cmd_count (icdel_rec);
WITH t DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        IF  (rk.keyLen_gg00 > KEY_MXSP00) OR (rk.keyLen_gg00 < 0)
        THEN
            trError_gg00 := e_illegal_key
        ELSE
            trError_gg00 := e_ok;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 + [bd_write_acc];
        bd30GetTree (t, file_id, current, m_delete,
              LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            root_trace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
            bd30DelFromTree (rk, current)
            END;
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  trError_gg00 = e_ok
        THEN
            file_id := current.curr_tree_id;
        (*ENDIF*) 
        file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 - [bd_write_acc]
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b07cdel, sizeof (root_trace), @root_trace)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b07cget_record (VAR t : tgg00_TransContext;
            VAR file_id : tgg00_FileId;
            VAR rk      : tgg00_Lkey;
            VAR b       : tgg00_Rec);
 
VAR
      dummy_tree_pos   : tgg00_FilePos;
 
BEGIN
dummy_tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
b07ctget_record (t, file_id, dummy_tree_pos, rk, b);
END;
 
(*------------------------------*) 
 
PROCEDURE
      b07ctget_record (VAR t : tgg00_TransContext;
            VAR file_id  : tgg00_FileId;
            VAR tree_pos : tgg00_FilePos;
            VAR rk       : tgg00_Lkey;
            VAR b        : tgg00_Rec);
 
VAR
      auxError   : tgg00_BasisError;
      key_trace  : tgg11_BdKeyTrace;
      root_trace : tgg11_BdRootTrace;
      current    : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := rk.keyLen_gg00;
    SAPDB_PascalMove ('VBD07 ',   5,    
          rk.keyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @rk.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( rk.keyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b07cget, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd cget rec ');
t01treeid (bi, 'treeid      ', file_id);
t01lkey   (bi, rk);
&endif
b73cmd_count (icget_rec);
WITH t DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        IF  (rk.keyLen_gg00 > KEY_MXSP00) OR (rk.keyLen_gg00 < 0)
        THEN
            trError_gg00 := e_illegal_key
        ELSE
            trError_gg00 := e_ok;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        bd30GetTree (t, file_id, current, m_get,
              NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            root_trace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
            bd30GetFromTreeWithTreepos (rk, b, tree_pos, current, lckFree_egg00)
            END;
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  trError_gg00 = e_ok
        THEN
            file_id := current.curr_tree_id
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    t01buf (bi, b, 1, b.recLen_gg00);
    t01p2int4 (bi, 'treePosLeaf ', tree_pos.tpsPno_gg00,
          'treePosIndex', tree_pos.tpsIndex_gg00);
    END;
&endif
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b07cget, sizeof (root_trace), @root_trace)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b07cprev_record (VAR t : tgg00_TransContext;
            VAR file_id    : tgg00_FileId;
            VAR rk         : tgg00_Lkey;
            VAR set_result : tgg00_BdSetResultRecord;
            VAR tree_pos   : tgg00_FilePos;
            VAR b          : tsp00_MoveObj);
 
VAR
      auxError   : tgg00_BasisError;
      fpos_trace : tgg11_BdIntTrace;
      key_trace  : tgg11_BdKeyTrace;
      root_trace : tgg11_BdRootTrace;
      current    : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrRoot_gg11 := NIL_PAGE_NO_GG00;
    IF  tree_pos.tpsPno_gg00 = NIL_PAGE_NO_GG00
    THEN
        BEGIN
        auxError                 := e_ok;
        key_trace.bdkTrType_gg11 := bdtrKey_egg11;
        key_trace.bdkKeyLen_gg11 := rk.keyLen_gg00;
        SAPDB_PascalMove ('VBD07 ',   6,    
              rk.keyLen_gg00, sizeof (key_trace.bdkKey_gg11),
              @rk.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
              gg06Min( rk.keyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
        b120InsertTrace (t, bd, b07cprev, sizeof (key_trace), @key_trace)
        END
    ELSE
        BEGIN
        fpos_trace.bdiTrType_gg11  := bdtrInt_egg11;
        fpos_trace.bdiInt_gg11 [0] := tree_pos.tpsPno_gg00;
        fpos_trace.bdiInt_gg11 [1] := tree_pos.tpsIndex_gg00;
        b120InsertTrace (t, bd, b07cprev,
              sizeof (fpos_trace) - sizeof (fpos_trace.bdiInt_gg11 [2]), @fpos_trace)
        END
    (*ENDIF*) 
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd cprev rec');
t01treeid (bi, 'treeid      ', file_id);
WITH set_result DO
    BEGIN
    t01int4   (bi, 'check len   ', bd_key_check_len);
    t01p2int4 (bi, 'max rec cnt ', bd_max_rec_cnt,
          'max fill len', bd_max_fill_len);
    t01bool   (bi, 'next record ', bd_next);
    END;
(*ENDWITH*) 
IF  tree_pos.tpsPno_gg00 = NIL_PAGE_NO_GG00
THEN
    t01lkey (bi, rk);
(*ENDIF*) 
t01p2int4 (bi, 'treePosLeaf ', tree_pos.tpsPno_gg00,
      'treePosIndex', tree_pos.tpsIndex_gg00);
&endif
b73cmd_count (icprev_rec);
WITH t DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        IF  tree_pos.tpsPno_gg00 = NIL_PAGE_NO_GG00
        THEN
            IF  (rk.keyLen_gg00 > KEY_MXSP00) OR (rk.keyLen_gg00 < 0)
            THEN
                trError_gg00 := e_illegal_key
            ELSE
                trError_gg00 := e_ok
            (*ENDIF*) 
        ELSE
            trError_gg00 := e_ok;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        bd30GetTree (t, file_id, current, m_get,
              NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            set_result.bd_rec_cnt   := 0;
            set_result.bd_fill_len  := 0;
            root_trace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
            b30cprev_from_tree (rk, set_result, tree_pos, b, current)
            END;
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  trError_gg00 = e_ok
        THEN
            file_id := current.curr_tree_id;
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
t01p2int4 (bi, 'treePosLeaf ', tree_pos.tpsPno_gg00,
      'treePosIndex', tree_pos.tpsIndex_gg00);
WITH set_result DO
    BEGIN
    t01p2int4 (bi, 'rec cnt     ', bd_rec_cnt,
          'fill len    ',  bd_fill_len);
    IF  (t.trError_gg00 = e_ok) OR (t.trError_gg00 = e_key_not_found)
        OR (t.trError_gg00 = e_buffer_limit) OR (t.trError_gg00 = e_no_prev_record)
    THEN
        t01moveobj (bi, b, 1, bd_fill_len)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&endif
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b07cprev, sizeof (root_trace), @root_trace)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b07cnext_record (VAR t : tgg00_TransContext;
            VAR file_id    : tgg00_FileId;
            VAR rk         : tgg00_Lkey;
            VAR set_result : tgg00_BdSetResultRecord;
            VAR tree_pos   : tgg00_FilePos;
            VAR b          : tsp00_MoveObj);
 
VAR
      auxError   : tgg00_BasisError;
      fpos_trace : tgg11_BdIntTrace;
      key_trace  : tgg11_BdKeyTrace;
      root_trace : tgg11_BdRootTrace;
      current    : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrRoot_gg11 := NIL_PAGE_NO_GG00;
    IF  tree_pos.tpsPno_gg00 = NIL_PAGE_NO_GG00
    THEN
        BEGIN
        auxError                 := e_ok;
        key_trace.bdkTrType_gg11 := bdtrKey_egg11;
        key_trace.bdkKeyLen_gg11 := rk.keyLen_gg00;
        SAPDB_PascalMove ('VBD07 ',   7,    
              rk.keyLen_gg00, sizeof (key_trace.bdkKey_gg11),
              @rk.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
              gg06Min( rk.keyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
        b120InsertTrace (t, bd, b07cnext, sizeof (key_trace), @key_trace)
        END
    ELSE
        BEGIN
        fpos_trace.bdiTrType_gg11  := bdtrInt_egg11;
        fpos_trace.bdiInt_gg11 [0] := tree_pos.tpsPno_gg00;
        fpos_trace.bdiInt_gg11 [1] := tree_pos.tpsIndex_gg00;
        b120InsertTrace (t, bd, b07cnext,
              sizeof (fpos_trace) - sizeof (fpos_trace.bdiInt_gg11 [2]), @fpos_trace)
        END
    (*ENDIF*) 
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd cnext rec');
t01treeid (bi, 'treeid      ', file_id);
WITH set_result DO
    BEGIN
    t01int4   (bi, 'check len   ', bd_key_check_len);
    t01p2int4 (bi, 'max rec cnt ', bd_max_rec_cnt,
          'max fill len', bd_max_fill_len);
    t01bool   (bi, 'next record ', bd_next);
    END;
(*ENDWITH*) 
IF  tree_pos.tpsPno_gg00 = NIL_PAGE_NO_GG00
THEN
    t01lkey (bi, rk)
ELSE
    t01p2int4 (bi, 'treePosLeaf ', tree_pos.tpsPno_gg00,
          'treePosIndex', tree_pos.tpsIndex_gg00);
(*ENDIF*) 
&endif
b73cmd_count (icnext_rec);
WITH t DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        IF  tree_pos.tpsPno_gg00 = NIL_PAGE_NO_GG00
        THEN
            IF  (rk.keyLen_gg00 > KEY_MXSP00) OR (rk.keyLen_gg00 < 0)
            THEN
                trError_gg00 := e_illegal_key
            ELSE
                trError_gg00 := e_ok
            (*ENDIF*) 
        ELSE
            trError_gg00 := e_ok;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        bd30GetTree (t, file_id, current, m_get,
              NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            set_result.bd_rec_cnt  := 0;
            set_result.bd_fill_len := 0;
            root_trace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
            b30cnext_from_tree (rk, set_result, tree_pos, b, current)
            END;
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  trError_gg00 = e_ok
        THEN
            file_id := current.curr_tree_id;
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
t01p2int4 (bi, 'treePosLeaf ', tree_pos.tpsPno_gg00,
      'treePosIndex', tree_pos.tpsIndex_gg00);
WITH set_result DO
    BEGIN
    t01p2int4 (bi, 'rec cnt     ', bd_rec_cnt,
          'fill len    ', bd_fill_len);
    IF  (t.trError_gg00 = e_ok) OR (t.trError_gg00 = e_key_not_found)
        OR (t.trError_gg00 = e_buffer_limit) OR (t.trError_gg00 = e_no_next_record)
    THEN
        t01moveobj (bi, b, 1, bd_fill_len)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&endif
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b07cnext, sizeof (root_trace), @root_trace)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b07get_result_leaf (
            VAR t           : tgg00_TransContext;
            VAR file_id     : tgg00_FileId;
            VAR rk          : tgg00_Lkey;
            get_next        : boolean;
            prepare_for_upd : boolean;
            VAR tree_pos    : tgg00_FilePos;
            VAR nptr        : tbd_node_ptrs);
 
VAR
      bLockTreeExcl : boolean;
      auxError      : tgg00_BasisError;
      fpos_trace    : tgg11_BdIntTrace;
      key_trace     : tgg11_BdKeyTrace;
      root_trace    : tgg11_BdRootTrace;
      current       : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrRoot_gg11 := NIL_PAGE_NO_GG00;
    IF  tree_pos.tpsPno_gg00 = NIL_PAGE_NO_GG00
    THEN
        BEGIN
        auxError                 := e_ok;
        key_trace.bdkTrType_gg11 := bdtrKey_egg11;
        key_trace.bdkKeyLen_gg11 := rk.keyLen_gg00;
        SAPDB_PascalMove ('VBD07 ',   8,    
              rk.keyLen_gg00, sizeof (key_trace.bdkKey_gg11),
              @rk.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
              gg06Min( rk.keyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
        b120InsertTrace (t, bd, b07cget_leaf,  (* PTS 1105706 TS 2000-02-24 *)
              sizeof (key_trace), @key_trace)
        END
    ELSE
        BEGIN
        fpos_trace.bdiTrType_gg11  := bdtrInt_egg11;
        fpos_trace.bdiInt_gg11 [0] := tree_pos.tpsPno_gg00;
        fpos_trace.bdiInt_gg11 [1] := tree_pos.tpsIndex_gg00;
        b120InsertTrace (t, bd, b07cget_leaf, (* PTS 1105706 TS 2000-02-24 *)
              sizeof (fpos_trace) - sizeof (fpos_trace.bdiInt_gg11 [2]), @fpos_trace)
        END
    (*ENDIF*) 
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd get leaf ');
t01treeid (bi, 'treeid      ', file_id);
IF  tree_pos.tpsPno_gg00 = NIL_PAGE_NO_GG00
THEN
    t01lkey (bi, rk);
(*ENDIF*) 
t01bool   (bi, 'get next    ', get_next);
t01bool   (bi, 'prep for upd', prepare_for_upd);
t01p2int4 (bi, 'leaf        ', tree_pos.tpsPno_gg00, 'index       ',
      tree_pos.tpsIndex_gg00);
&endif
b73cmd_count (icnext_rec);
WITH t DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        IF  tree_pos.tpsPno_gg00 = NIL_PAGE_NO_GG00
        THEN
            IF  (rk.keyLen_gg00 > KEY_MXSP00) OR (rk.keyLen_gg00 < 0)
            THEN
                trError_gg00 := e_illegal_key
            ELSE
                trError_gg00 := e_ok
            (*ENDIF*) 
        ELSE
            trError_gg00 := e_ok;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        IF  prepare_for_upd
        THEN
            BEGIN
            file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 + [bd_write_acc];
            bLockTreeExcl := LOCK_TREE_EXCL_BD00;
            END
        ELSE
            bLockTreeExcl := NOT LOCK_TREE_EXCL_BD00;
        (*ENDIF*) 
        IF  (nptr.np_ptr <> NIL) AND (nptr.np_ptr^.nd_id = file_id.fileRoot_gg00)
        THEN
            BEGIN (* => root_is_leaf *)
            bd30BuildCurrent (t, file_id, current);
            current.currRootNptrs_bd00 := nptr
            END
        ELSE
            bd30GetTree (t, file_id, current, m_get,
                  bLockTreeExcl, NOT SYNC_TREE_LOCK_BD00);
        (*ENDIF*) 
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            IF  nptr.np_ptr <> NIL
            THEN
                current.currCounter_bd00 := current.currCounter_bd00 + 1;
            (*ENDIF*) 
            root_trace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
            b30cget_result_leaf (rk, get_next, prepare_for_upd,
                  tree_pos, nptr, current)
            END;
        (*ENDIF*) 
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            IF  nptr.np_ptr <> NIL
            THEN
                current.currCounter_bd00 := current.currCounter_bd00 - 1;
            (* if root is leaf nptr should not be released implicit by destructor *)
            (*ENDIF*) 
            IF  current.currRootNptrs_bd00.np_ptr^.nd_level > LEAF_LEVEL_BD00
            THEN
                bd30ReleaseTree (current);
            (*ENDIF*) 
            file_id := current.curr_tree_id
            END
        ELSE
            bd30ReleaseTree (current);
        (*ENDIF*) 
        IF  prepare_for_upd
        THEN
            file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 - [bd_write_acc];
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
t01p2int4 (bi, 'leaf out    ', tree_pos.tpsPno_gg00,
      'index out   ', tree_pos.tpsIndex_gg00);
IF  t.trError_gg00 = e_ok
THEN
    t01page (bi, nptr.np_ptr^, 1, sizeof (nptr.np_ptr^.nd_full_header));
&endif
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b07cget_leaf, sizeof (root_trace), @root_trace);
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b07release_result_leaf (
            VAR t        : tgg00_TransContext;
            VAR file_id  : tgg00_FileId;
            node_changed : boolean;
            VAR nptr     : tbd_node_ptrs);
 
VAR
      pno_trace  : tgg11_BdIntTrace;  (* PTS 1105706 TS 2000-02-24 *)
      root_trace : tgg11_BdRootTrace; (* PTS 1105706 TS 2000-02-24 *)
      current    : tbd_current_tree;
 
BEGIN
&ifdef TRACE
t01name   (bi, '====> bd rel leaf ');
t01treeid (bi, 'treeid      ', file_id);
t01bool   (bi, 'node changed', node_changed);
IF  nptr.np_ptr <> NIL
THEN
    t01int4   (bi, 'leaf        ', nptr.np_ptr^.nd_id);
&endif
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    pno_trace.bdiTrType_gg11 := bdtrInt_egg11;
    IF  nptr.np_ptr = NIL
    THEN
        pno_trace.bdiInt_gg11 [0] := NIL_PAGE_NO_GG00
    ELSE
        pno_trace.bdiInt_gg11 [0] := nptr.np_ptr^.nd_id;
    (*ENDIF*) 
    b120InsertTrace (t, bd, b07crel_leaf, sizeof (pno_trace)
          - sizeof (pno_trace.bdiInt_gg11 [1])
          - sizeof (pno_trace.bdiInt_gg11 [2]), @pno_trace)
    END;
(*ENDIF*) 
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown
ELSE
    t.trError_gg00 := e_ok;
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok) AND (nptr.np_ptr <> NIL)
THEN
    BEGIN
    bd30BuildCurrent (t, file_id, current);
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        root_trace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
        IF  node_changed
        THEN
            b13w_release_node (nptr, current)
        ELSE
            b13r_release_node (nptr, current, lru_normal);
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b07crel_leaf, sizeof (root_trace), @root_trace);
    END;
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
