.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.tt 1 $SQL$Project Distributed Database System$VBD02$
.tt 2 $$$$
.tt 3 $JuergenP$filesysteminterface_2$$2001-03-12$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
Module  : filesysteminterface_2
=========
.sp
Purpose : base layer operations :
            - processing primary trees
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              b02add_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR b       : tgg00_Rec                (*ptocConst*));
 
        PROCEDURE
              bd02AddRecordWithSpecialKey (
                    VAR trans  : tgg00_TransContext;
                    VAR fileId : tgg00_FileId;
                    VAR rec    : tgg00_Rec);
 
        PROCEDURE
              b02calculate_page_count (VAR t : tgg00_TransContext;
                    VAR file_id      : tgg00_FileId;
                    VAR startkey     : tgg00_Lkey;
                    VAR stopkey      : tgg00_Lkey;
                    VAR page_count   : tsp00_Int4);
 
        PROCEDURE
              b02del_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Lkey               (*ptocConst*));
 
        PROCEDURE
              b02DelGarbage (VAR t : tgg00_TransContext;
                    VAR file_id   : tgg00_FileId;
                    VAR rk        : tgg00_Lkey             (*ptocConst*);
                    VAR wantedRef : tgg91_PageRef          (*ptocConst*));
 
        PROCEDURE
              b02eval_page_count (VAR t : tgg00_TransContext;
                    VAR file_id      : tgg00_FileId;
                    VAR startkey     : tgg00_Lkey;
                    VAR stopkey      : tgg00_Lkey;
                    count_records    : boolean;
                    VAR page_count   : tsp00_Int4;
                    VAR all_page_cnt : tsp00_Int4;
                    VAR record_cnt   : tsp00_Int4);
 
        PROCEDURE
              b02exists_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Lkey);
 
        PROCEDURE
              b02find_leaf (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR key     : tgg00_Lkey);
 
        PROCEDURE
              b02get_lock_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Lkey;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b02get_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Lkey               (*ptocConst*);
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b02kb_del_rec (VAR m  : tgg00_MessBlock;
                    pDeleteCmd      : tsp00_Addr;
                    VAR rk          : tgg00_Lkey;
                    VAR old_recbuf  : tgg00_Rec;
                    granted_lock    : tgg00_LockReqMode);
 
        PROCEDURE
              b02kb_ins_record (VAR m : tgg00_MessBlock;
                    pInsertCmd        : tsp00_Addr;
                    VAR b             : tgg00_Rec;
                    granted_lock      : tgg00_LockReqMode);
 
        PROCEDURE
              b02kb_select_rec (VAR t : tgg00_TransContext;
                    VAR file_id      : tgg00_FileId;
                    VAR RecKey       : tsp00_Key (* ptocSynonym tsp00_KeyPtr *);
                    VAR RecKeyLen    : tsp00_Int2;
                    VAR StopKey      : tsp00_Key (* ptocSynonym tsp00_KeyPtr *);
                    StopKeyLen       : tsp00_Int4;
                    recbuf_size      : tsp00_Int4;
                    recbuf_ptr       : tsp00_MoveObjPtr;
                    ignore_vwait     : boolean;
                    VAR sel          : tgg00_SelectFieldsParam;
                    VAR stack_desc   : tgg00_StackDesc;
                    VAR unqualified  : boolean;
                    VAR granted_lock : tgg00_LockReqMode);
 
        PROCEDURE
              b02kb_upd_rec (VAR m : tgg00_MessBlock;
                    pUpdateCmd     : tsp00_Addr;
                    VAR rk         : tgg00_Lkey;
                    VAR old_recbuf : tgg00_Rec;
                    VAR new_recbuf : tgg00_Rec;
                    granted_lock   : tgg00_LockReqMode);
 
        PROCEDURE
              b02MarkRecordDeleted (
                    VAR t          : tgg00_TransContext;
                    VAR file_id    : tgg00_FileId;
                    isDelete       : boolean;
                    VAR beforeRef  : tgg91_PageRef  (*ptocConst*);
                    VAR updTrans   : tgg91_TransNo  (*ptocConst*);
                    VAR rk         : tgg00_Lkey     (*ptocConst*);
                    pRec           : tgg00_RecPtr);
 
        PROCEDURE
              b02next_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Lkey;
                    inclusive   : boolean;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b02prefetch (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    pno         : tsp00_PageNo);
 
        PROCEDURE
              b02prev_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Lkey;
                    inclusive   : boolean;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b02repl_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR b       : tgg00_Rec                (*ptocConst*));
 
        PROCEDURE
              b02ReplaceRecord (VAR t : tgg00_TransContext;
                    VAR file_id     : tgg00_FileId;
                    VAR b           : tgg00_Rec (*ptocConst*);
                    useTransInfo    : boolean;
                    VAR beforeRef   : tgg91_PageRef (*ptocConst*);
                    VAR updTrans    : tgg91_TransNo (*ptocConst*));
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              filesysteminterface_1 :  VBD01;
 
        VAR
              b01downfilesystem : boolean;
 
      ------------------------------ 
 
        FROM
              filesysteminterface_3 :  VBD03;
 
        PROCEDURE
              bd03KeyVtrace (
                    VAR t       : tgg00_TransContext;
                    pKey1       : tsp00_KeyPtr;
                    KeyLen1     : tsp00_Int4;
                    pKey2       : tsp00_KeyPtr;
                    KeyLen2     : tsp00_Int4;
                    TraceObject : tgg00_VtraceType);
 
      ------------------------------ 
 
        FROM
              Trace : VBD120;
 
        PROCEDURE
              b120InsertTrace (VAR t   : tgg00_TransContext;
                    trace_layer  : tgg00_Debug;
                    trace_object : tgg00_VtraceType;
                    body_len     : tsp00_Int2;
                    trace_body   : tgg11_VtraceBodyPtr);
 
      ------------------------------ 
 
        FROM
              nodehandling         : VBD13;
 
        PROCEDURE
              bd13GetNode (VAR Current : tbd_current_tree;
                    Pno          : tsp00_PageNo;
                    PageLockMode : tbd00_PageLockMode;
                    NodeReq      : tbd_node_request;
                    VAR Nptrs    : tbd_node_ptrs);
 
        PROCEDURE
              b13r_release_node (VAR nptr : tbd_node_ptrs;
                    VAR current : tbd_current_tree;
                    lru_info    : tbd_lru_info);
 
      ------------------------------ 
 
        FROM
              treehandling : VBD30;
 
        PROCEDURE
              bd30AddToTree (
                    VAR recKey  : tgg00_Lkey;
                    VAR rec     : tgg00_Rec;
                    VAR current : tbd_current_tree);
 
        PROCEDURE
              bd30AddToTreeWithSpecialKey (
                    VAR recKey  : tgg00_Lkey;
                    VAR rec     : tgg00_Rec;
                    VAR current : tbd_current_tree);
 
        PROCEDURE
              bd30AddToTreeWithBeforeImage (
                    VAR recKey  : tgg00_Lkey;
                    VAR rec     : tgg00_Rec;
                    VAR m       : tgg00_MessBlock;
                    pInsertCmd  : tsp00_Addr;
                    grantedLock : tgg00_LockReqMode;
                    VAR current : tbd_current_tree);
 
        PROCEDURE
              bd30AddToTreeWithBeforeImageAndSpecialKey (
                    VAR recKey  : tgg00_Lkey;
                    VAR rec     : tgg00_Rec;
                    VAR m       : tgg00_MessBlock;
                    pInsertCmd  : tsp00_Addr;
                    grantedLock : tgg00_LockReqMode;
                    VAR current : tbd_current_tree);
 
        PROCEDURE
              bd30BuildCurrent (
                    VAR trans   : tgg00_TransContext;
                    VAR fileId  : tgg00_FileId;
                    VAR current : tbd_current_tree);
 
        PROCEDURE
              bd30DelFromTree (
                    VAR recKey  : tgg00_Lkey;
                    VAR current : tbd_current_tree);
 
        PROCEDURE
              bd30DelGarbageFromTree (
                    VAR recKey    : tgg00_Lkey;
                    VAR current   : tbd_current_tree;
                    VAR beforeRef : tgg91_PageRef);
 
        PROCEDURE
              bd30DelFromTreeWithBeforeImage (
                    VAR recKey  : tgg00_Lkey;
                    VAR oldRec  : tgg00_Rec;
                    VAR m       : tgg00_MessBlock;
                    pDeleteCmd  : tsp00_Addr;
                    grantedLock : tgg00_LockReqMode;
                    VAR current : tbd_current_tree);
 
        PROCEDURE
              bd30ExistRecord (
                    VAR recKey  : tgg00_Lkey;
                    VAR current : tbd_current_tree);
 
        PROCEDURE
              bd30FindLeaf (
                    VAR key     : tgg00_Lkey;
                    VAR current : tbd_current_tree);
 
        PROCEDURE
              bd30GetFromTree (
                    VAR recKey  : tgg00_Lkey;
                    VAR rec     : tgg00_Rec;
                    VAR current : tbd_current_tree;
                    wantedLock  : tgg00_LockReqMode);
 
        PROCEDURE
              bd30GetTree (
                    VAR trans            : tgg00_TransContext;
                    VAR fileId           : tgg00_FileId;
                    VAR current          : tbd_current_tree;
                    messType             : tgg00_MessType;
                    bLockTreeExcl        : boolean;
                    bSynchronizeExclLock : boolean);
 
        PROCEDURE
              bd30MarkDeletedFromTree (
                    VAR recKey    : tgg00_Lkey;
                    VAR current   : tbd_current_tree;
                    markForDelete : boolean;
                    VAR beforeRef : tgg91_PageRef;
                    VAR updTrans  : tgg91_TransNo;
                    pRec          : tgg00_RecPtr);
 
        PROCEDURE
              bd30NextFromTree (
                    VAR recKey   : tgg00_Lkey;
                    bInclusive   : boolean;
                    bWithSQLLock : boolean;
                    VAR rec      : tgg00_Rec;
                    VAR current  : tbd_current_tree);
 
        PROCEDURE
              bd30PrevFromTree (
                    VAR recKey   : tgg00_Lkey;
                    bInclusive   : boolean;
                    bWithSQLLock : boolean;
                    VAR rec      : tgg00_Rec;
                    VAR current  : tbd_current_tree);
 
        PROCEDURE
              bd30ReleaseTree (
                    VAR current : tbd_current_tree);
 
        PROCEDURE
              bd30ReplaceInTree (
                    VAR recKey      : tgg00_Lkey;
                    VAR rec         : tgg00_Rec;
                    VAR current     : tbd_current_tree;
                    VAR beforeRef   : tgg91_PageRef;
                    VAR updTrans    : tgg91_TransNo);
 
        PROCEDURE
              bd30ReplaceInTreeWithBeforeImage (
                    VAR recKey  : tgg00_Lkey;
                    VAR oldRec  : tgg00_Rec;
                    VAR newRec  : tgg00_Rec;
                    VAR m       : tgg00_MessBlock;
                    pUpdateCmd  : tsp00_Addr;
                    grantedLock : tgg00_LockReqMode;
                    VAR current : tbd_current_tree);
 
      ------------------------------ 
 
        FROM
              QualifiedRecords : VBD360;
 
        PROCEDURE
              bd360NextQualifiedRecordFromTree(
                    VAR current          : tbd_current_tree;
                    VAR pCurrRecKey      : tsp00_Key;
                    VAR currRecKeyLen    : tsp00_Int2;
                    VAR pStopKey         : tsp00_Key;
                    StopKeyLen           : tsp00_Int2;
                    VAR lockKey          : tgg00_Lkey;
                    recBufferSize        : tsp00_Int4;
                    pRecBuffer           : tsp00_MoveObjPtr;
                    VAR recBufferPos     : tsp00_Int4;
                    VAR sel              : tgg00_SelectFieldsParam;
                    VAR stackDesc        : tgg00_StackDesc;
                    VAR currResultCnt    : tsp00_Int4;
                    VAR bIsNotQualified  : boolean;
                    VAR bDoRemoveSQLLock : boolean;
                    VAR grantedLock      : tgg00_LockReqMode;
                    VAR unlockedPageNo   : tsp00_PageNo);
 
        PROCEDURE
              bd360PrevQualifiedRecordFromTree(
                    VAR current          : tbd_current_tree;
                    VAR pCurrRecKey      : tsp00_Key;
                    VAR currRecKeyLen    : tsp00_Int2;
                    VAR pStopKey         : tsp00_Key;
                    StopKeyLen           : tsp00_Int2;
                    VAR lockKey          : tgg00_Lkey;
                    recBufferSize        : tsp00_Int4;
                    pRecBuffer           : tsp00_MoveObjPtr;
                    VAR recBufferPos     : tsp00_Int4;
                    VAR sel              : tgg00_SelectFieldsParam;
                    VAR stackDesc        : tgg00_StackDesc;
                    VAR currResultCnt    : tsp00_Int4;
                    VAR bIsNotQualified  : boolean;
                    VAR bDoRemoveSQLLock : boolean;
                    VAR grantedLock      : tgg00_LockReqMode;
                    VAR unlockedPageNo   : tsp00_PageNo);
 
      ------------------------------ 
 
        FROM
              indexhandling : VBD50;
 
        PROCEDURE
              bd50CalculatePageCount (
                    VAR current   : tbd_current_tree;
                    VAR startSep  : tgg00_Lkey;
                    VAR stopSep   : tgg00_Lkey;
                    VAR pageCount : tsp00_Int4);
 
        PROCEDURE
              bd50EvalPageCount (
                    VAR start_key    : tgg00_Lkey;
                    VAR stop_key     : tgg00_Lkey;
                    count_records    : boolean;
                    VAR page_count   : tsp00_Int4;
                    VAR all_page_cnt : tsp00_Int4;
                    VAR record_cnt   : tsp00_Int4;
                    VAR current      : tbd_current_tree);
 
      ------------------------------ 
 
        FROM
              ref_statistic : VBD73;
 
        PROCEDURE
              b73cmd_count (statement_kind : tgg00_RefInfoIndex);
 
      ------------------------------ 
 
        FROM
              BD_Wrapper : VBD999;
 
        PROCEDURE
              bd999RestoreRecordHeader (
                    TaskId : tsp00_TaskId;
                    pRec   : tgg00_RecPtr);
 
      ------------------------------ 
 
        FROM
              FileDir_Wrapper : VBD998;
 
        PROCEDURE
              bd998GetPageAndRecordCount (
                    VAR trans          : tgg00_TransContext;
                    VAR surrogate      : tgg00_Surrogate;
                    VAR leafPageCount  : tsp00_Int4;
                    VAR indexPageCount : tsp00_Int4;
                    VAR entryCount     : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              KB_transaction : VKB53;
 
        PROCEDURE
              k53wait (VAR t  : tgg00_TransContext;
                    MessType  : tgg00_MessType;
                    MessType2 : tgg00_MessType2);
 
      ------------------------------ 
 
        FROM
              KB_Logging : vkb560;
 
        FUNCTION
              kb560IsSys1CatalogTable(
                    VAR tabId : tgg00_Surrogate) : boolean;
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01vtrace : tgg00_VtraceState;
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        FUNCTION
              gg06Min (
                    value1 : tsp00_Int4;
                    value2 : tsp00_Int4 ) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vsleep (pid : tsp00_TaskId;
                    limit : tsp00_Int2);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01basis_error (debug : tgg00_Debug;
                    nam   : tsp00_Sname;
                    b_err : tgg00_BasisError);
 
        PROCEDURE
              t01bool (debug : tgg00_Debug;
                    nam      : tsp00_Sname;
                    curr_bool: boolean);
 
        PROCEDURE
              t01buf (debug  : tgg00_Debug;
                    VAR buf  : tsp00_Buf;
                    startpos : integer;
                    endpos   : integer);
 
        PROCEDURE
              t01buf1 (debug  : tgg00_Debug;
                    VAR buf  : tsp00_Key;
                    startpos : integer;
                    endpos   : integer);
 
        PROCEDURE
              t01int4 (debug : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int4     : tsp00_Int4);
 
        PROCEDURE
              t01lkey (debug : tgg00_Debug;
                    VAR k : tgg00_Lkey);
 
        PROCEDURE
              t01name (debug : tgg00_Debug; nam  : tsp00_Name);
 
        PROCEDURE
              t01moveobj (debug : tgg00_Debug;
                    VAR moveobj : tsp00_MoveObj;
                    startpos    : tsp00_Int4;
                    endpos      : tsp00_Int4);
 
        PROCEDURE
              t01p2int4 (debug : tgg00_Debug;
                    nam_1 : tsp00_Sname;
                    int_1 : tsp00_Int4;
                    nam_2 : tsp00_Sname;
                    int_2 : tsp00_Int4);
 
        PROCEDURE
              t01sname (layer : tgg00_Debug;
                    nam : tsp00_Sname);
 
        PROCEDURE
              t01treeid (debug : tgg00_Debug;
                    nam        : tsp00_Sname;
                    VAR treeid : tgg00_FileId);
 
        PROCEDURE
              t01selfields (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname;
                    sfp   : tgg00_SelectFieldsParam);
&       endif
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              bd360NextQualifiedRecordFromTree;
 
              SAPDB_Int2 tsp00_Int2
              SAPDB_Int4  tsp00_Int4
 
        PROCEDURE
              bd360PrevQualifiedRecordFromTree;
 
              SAPDB_Int2 tsp00_Int2
              SAPDB_Int4  tsp00_Int4
&             ifdef trace
 
        PROCEDURE
              t01buf1;
 
              tsp00_Buf tsp00_Key
&             endif
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : JuergenP
.sp
.cp 3
Created : 1979-09-05
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-10-26
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.sp 2;.cp 4
.oc _/1;1._Processing_Primary_Trees
.sp 3
Primary tree entries are records that have the following
structure when they are transferred to a record buffer:
.nf
.sp 2
       2   2    kl bytes      v bytes
     --------------------------------------
     |rl |kl |   key   |  nonkeyfields    |
     --------------------------------------
 
     |rl| = 2 + 2 + kl + v <= maxrecordlength
 
.fo
.sp 2
Records are always left-justified (i.e. they start in position 1) when
they are entered in record buffers.
Each record has a record header that contains its record length
(rl <= MAX_RECLEN_GG00) and its record key length (kl <= PERM_KEY_MXSP00).
.sp 3;.cp 6
b02add_record (t,file_id,b)
.sp
The record from record buffer b is inserted in tree file_id, given the
tree exists and does not yet contain a record with the same key.
The meaning of parameter file_id can be found in the
b02get_(lock_)record specification.
.br
One of the following messages, among others, is sent to t.trError_gg00:
   - e_ok
   - b_file_not_found
   - b_duplicate_key
   - b_illegal_entrypos
   - b_invalid_entrypos
   - b_no_more_space
   - b_no_more_tempspace
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b02del_record (t,file_id,rk)
.sp
The record in tree file_id whose key matches the key entered in the key
buffer rk is deleted.
The meaning of parameter file_id can be found in the
b02get_(lock_)record specification.
.br
One of the following messages, among others, is sent to t.trError_gg00:
   - e_ok
   - b_file_not_found
   - b_illegal_key
   - b_illegal_entrypos
   - b_invalid_entrypos
   - b_key_not_found
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b02exists_record (t,fileid,rk)
.sp
In the file identified by fileid a search is carried out for the record
whose key matches the key entered in rk.
.br
One of the following messages, among others, is sent to t.trError_gg00:
   - e_ok
   - b_file_not_found
   - b_illegal_key
   - b_illegal_entrypos
   - b_invalid_entrypos
   - b_key_not_found
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b02get_(lock_)record (t,file_id,rk,b)
.sp
A search is carried out in tree file_id for the record whose key
matches the key entered in rk.
If this record exists, it is transferred to record buffer b.
The number file_id.fileversion indicates wether page number file_id.root
can be used in the following.
The set file_id.fileBdUse_gg00 contains information on
whether altered pages must be copied unbuffered to the secondary storage
(bd_unbuffered).
If the record variable file_id is identified as valid, it contains the
identification of the primary tree belonging to tree file_id.fn.
Otherwise the primary tree identification is assigned after the file
directory has been accessed and is then sent to the calling procedure.
.br
One of the following messages, among others, is sent to t.trError_gg00:
   - e_ok
   - b_file_not_found
   - b_illegal_key
   - b_illegal_entrypos
   - b_invalid_entrypos
   - b_key_not_found
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b02kb_del_rec (m, rk, old_recbuf, granted_lock)
.sp
The record in tree file_id whose key matches the key entered in the key
buffer rk is deleted.
The remaining parameters are passed to the KB layer due to logging
reasons.
.br
This procedure is called each time a key qualified delete is processed.
.br;One of the following messages, among others, is sent to
m.mb_trns^.trError_gg00:
   - e_ok
   - e_shutdown
   - e_illegal_key
.sp 3;.cp 6
b02kb_ins_record (m, b, granted_lock)
.sp
The record from record buffer b is inserted in tree m.mb_qual^.mtree,
given the tree exists and does not yet contain a record with the same
key.
The remaining parameters are passed to the KB layer due to logging and
optimization reasons.
.br
This procedure is called each time an insert is processed,
which has been issued by the user.
.br
One of the following messages, among others, is sent to
m.mb_trns^.trError_gg00:
   - e_ok
   - b_file_not_found
   - b_duplicate_key
   - b_illegal_entrypos
   - b_invalid_entrypos
   - b_no_more_space
   - b_no_more_tempspace
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b02kb_select_rec (t, file_id, rk, stopkey, b, sel, stack_desc,
 result_buf, unqualified, granted_lock)
.sp 3;.cp 6
b02kb_upd_rec (m, rk, old_recbuf, new_recbuf, log_part1, granted_lock)
.sp
The record from record buffer new_recbuf with key rk replaces the record
with the same key in tree file_id, given the tree contains such a
record.
The remaining parameters are passed to the KB layer due to logging and
optimization reasons.
.br
This procedure is called each time a key qualified update
is processed.
.br
One of the following messages, among others, is sent to
m.mb_trns^.trError_gg00:
   - e_ok
   - b_file_not_found
   - b_illegal_key
   - b_illegal_entrypos
   - b_invalid_entrypos
   - b_key_not_found
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b02next_record (t,file_id,rk,inclusive,b)
.sp
A search is carried out in tree file_id for the record with the key rk.
If inclusive=true and the record was found,
the record is copied to record buffer b.
.br;Otherwise, the record whose key follows the key rk (with
the records arranged in ascending order by keys) is copied to b.
If the tree contains no record with a key smaller than rk,
b_no_next_record is sent to t.trError_gg00.
If a record with key rk is not present, b_key_not_found is sent to
t.trError_gg00.
.br
The meaning of parameter file_id can be found in the
b02get_(lock_)record specification.
.br
One of the following messages, among others, is sent to t.trError_gg00:
   - e_ok
   - b_file_not_found
   - b_illegal_key
   - b_illegal_entrypos
   - b_invalid_entrypos
   - b_no_next_record
   - b_key_not_found
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b02prev_record (t,file_id,rk,inclusive,b)
.sp
A search is carried out in tree file_id for the record with the key rk.
If inclusive=true and the record was found,
the record is copied to record buffer b.
.br;Otherwise, the record whose key preceeds the key rk (with
the records arranged in ascending order by keys) is copied to b.
If the tree contains no record with a key smaller than rk,
b_no_prev_record is sent to t.trError_gg00.
If a record with key rk is not present, b_key_not_found is sent to
t.trError_gg00.
.br
The meaning of parameter file_id can be found in the
b02get_(lock_)record specification.
.br
One of the following messages, among others, is sent to t.trError_gg00:
   - e_ok
   - b_file_not_found
   - b_illegal_key
   - b_illegal_entrypos
   - b_invalid_entrypos
   - b_no_prev_record
   - b_key_not_found
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b02repl_record (t,file_id,b)
.sp
The record from record buffer b replaces the record with the same key in
tree file_id, given the tree contains such a record.
The meaning of parameter file_id can be found in the
b02get_(lock_)record specification.
.br
One of the following messages, among others, is sent to t.trError_gg00:
   - e_ok
   - b_file_not_found
   - b_key_not_found
   - b_illegal_entrypos
   - b_invalid_entrypos
   - b_no_more_space
   - b_no_more_tempspace
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b02select_record (t, file_id, rk, stopkey, b, sel, stack_desc,
.in 18
result_buf, unqualified)
.in 0
.sp
Supplies b with a record from tree file_id that fulfills a
qualification specified by the parameters sel and stack_desc.
The parameter rk specifies the position (record key) from where the
search starts and parameter sel.bd_mess2_type determines the type of
search carried out in the tree.
.br
bd_mess2_type can be assigned the following values:
.pb '~'
.in 1
.of 10
-~mm_next~: Searches for an entry with a key that is greater
than the key entered in rk and that fulfills the qualification.
If an entry is found, e_ok is returned; otherwise, e_no_next_record
is returned.
.in 1
.of 10
-~mm_prev~: Searches for an entry with a key that is smaller
than the key entered in rk and that fulfills the qualification.
If an entry is found, e_ok is returned; otherwise, e_no_prev_record
is returned.
.in 1
.of 10
-~mm_first~: Searches for an entry with a key that is greater
than or equal to the key entered in rk and that fulfills the
qualification.  If an entry is found, e_ok is returned; otherwise,
e_no_next_record is returned.
.in 1
.of 10
-~mm_last~: Searches for an entry with a key that is smaller than
or equal to the key entered in rk and that fulfills the
qualification.  If an entry is found, e_ok is returned;
otherwise, e_no_prev_record is returned.
.in 1
.of 10
-~mm_direct~: Searches for an entry with the record key rk
and checks whether it fulfills the qualification.
If the operation was successful, 'e_ok' is sent to "e".
If the specified key was not found, 'e_key_not_found'
is returned.
If the qualification is not fulfilled, "unqualified" is set to
TRUE and 'kb_qual_violation', 'kb_range_violation',
'kb_view_violatior' or 'kb_upd_view_violation' is sent to "t.trError_gg00".
.in 0
The following acknowledgements might also be sent:
   - b_file_not_found
   - b_illegal_key
   - b_illegal_entrypos
   - b_invalid_entrypos
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b02unload_table (t, tree_id, pno, pno_x, ret_buf_size, ret_buf,
                 ret_buf_len)
.sp
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
A global variable 'database_state' indicates by means of
'e_ok' that the file system has been generated and is
not shut down; otherwise it contains the message 'b_shutdown'.
The existence of a tree can generally be detected by accessing
the file directory.  In addition, the 'add' and 'repl' operations
are used to determine whether enough space is still available
in the secondary storage.
.sp
When a new tree is being created, a tree root is requested and an
entry identifying the tree is included in the file directory.
.sp
Entries in a tree are stored in the leaves of a B tree.
File routines are thus referred back to the appropriate
tree routine.  Before each tree routine is called, the operation
b30adjust_tree identifies which tree is being processed;
this means that, later on, certain information does not always
have to be carried along as a parameter.
.sp
When a checkpoint is set, only the system buffer
(as necessary) is written to the secondary storage.
.sp
If a file routine sends the message b_disk_not_accessible
to e, the physical integrity of the file system is no
longer secure!
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_number_of_retries  = 2;
 
 
(*------------------------------*) 
 
PROCEDURE
      b02add_record (VAR t : tgg00_TransContext;
            VAR file_id    : tgg00_FileId;
            VAR b          : tgg00_Rec);
 
VAR
      bSyncWithSVP : boolean;
      auxError     : tgg00_BasisError;
      key_trace    : tgg11_BdKeyTrace;
      root_trace   : tgg11_BdRootTrace;
      current      : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := b.recKeyLen_gg00;
    SAPDB_PascalMove ('VBD02 ',   1,    
          b.recKeyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @b.recKey_gg00.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( b.recKeyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b02add, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd add rec  ');
t01treeid (bi, 'treeid      ', file_id);
t01buf    (bi, b.recBuf_gg00, 1, b.recLen_gg00);
&endif
IF  ftsTemp_egg00 IN file_id.fileType_gg00
THEN
    BEGIN
    bSyncWithSVP := NOT SYNC_TREE_LOCK_BD00;
    b73cmd_count (icadd_rec)
    END
ELSE
    BEGIN
    bSyncWithSVP := SYNC_TREE_LOCK_BD00;
    b73cmd_count (iadd_rec);
    END;
(*ENDIF*) 
WITH t DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        IF  (b.recLen_gg00 > MAX_RECLEN_GG00) OR (b.recLen_gg00 < MIN_RECORD_LEN_BD00)
        THEN
            trError_gg00 := e_illegal_record
        ELSE
            IF  (b.recKeyLen_gg00 > PERM_KEY_MXSP00) OR (b.recKeyLen_gg00 < 0)
            THEN
                trError_gg00 := e_illegal_key
            ELSE
                trError_gg00 := e_ok;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 + [bd_write_acc];
        bd30GetTree (t, file_id, current, m_insert,
              NOT LOCK_TREE_EXCL_BD00, bSyncWithSVP);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            root_trace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
            bd30AddToTree (b.recKey_gg00, b, current);
            END;
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  trError_gg00 = e_ok
        THEN
            file_id := current.curr_tree_id;
        (*ENDIF*) 
        file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 - [bd_write_acc];
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b02add, sizeof (root_trace), @root_trace)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      bd02AddRecordWithSpecialKey (
            VAR trans  : tgg00_TransContext;
            VAR fileId : tgg00_FileId;
            VAR rec    : tgg00_Rec);
 
VAR
      rootTrace : tgg11_BdRootTrace;
      current   : tbd_current_tree;
 
BEGIN
&ifdef TRACE
t01name   (bi, '====> bd add rec  ');
t01treeid (bi, 'fileid      ', fileId);
t01buf    (bi, rec.recBuf_gg00, 1, rec.recLen_gg00);
&endif
b73cmd_count (iadd_rec);
WITH trans DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        IF  (rec.recLen_gg00 > MAX_RECLEN_GG00) OR (rec.recLen_gg00 < MIN_RECORD_LEN_BD00)
        THEN
            trError_gg00 := e_illegal_record
        ELSE
            IF  (rec.recKeyLen_gg00 > PERM_KEY_MXSP00) OR (rec.recKeyLen_gg00 < sizeof(tgg00_UniquePrimId))
            THEN
                trError_gg00 := e_illegal_key
            ELSE
                trError_gg00 := e_ok;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        fileId.fileBdUse_gg00 := fileId.fileBdUse_gg00 + [bd_write_acc];
        bd30GetTree( trans, fileId, current, m_insert, NOT LOCK_TREE_EXCL_BD00, SYNC_TREE_LOCK_BD00 );
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            rootTrace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
            bd30AddToTreeWithSpecialKey (rec.recKey_gg00, rec, current)
            END;
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  trError_gg00 = e_ok
        THEN
            fileId := current.curr_tree_id;
        (*ENDIF*) 
        fileId.fileBdUse_gg00 := fileId.fileBdUse_gg00 - [bd_write_acc];
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    rootTrace.bdrTrType_gg11 := bdtrRoot_egg11;
    rootTrace.bdrError_gg11  := trans.trError_gg00;
    b120InsertTrace (trans, bd, b02add, sizeof (rootTrace), @rootTrace)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02calculate_page_count (VAR t : tgg00_TransContext;
            VAR file_id      : tgg00_FileId;
            VAR startkey     : tgg00_Lkey;
            VAR stopkey      : tgg00_Lkey;
            VAR page_count   : tsp00_Int4);
 
VAR
      auxError         : tgg00_BasisError;
      eval_trace       : tgg11_BdEvalPagesTrace;
      key_trace        : tgg11_BdTwoKeysTrace;
      index_page_count : tsp00_Int4;
      record_count     : tsp00_Int4;
      retryCount       : integer;
      current          : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00  OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    eval_trace.bdeRootTrace_gg11.bdrRoot_gg11 := NIL_PAGE_NO_GG00;
    key_trace.bdtkTrType_gg11     := bdtrTwoKeys_egg11;
    key_trace.bdtkKeyLen_gg11 [0] := startkey.keyLen_gg00;
    key_trace.bdtkKeyLen_gg11 [1] := stopkey.keyLen_gg00;
    auxError                      := e_ok;
    SAPDB_PascalMove ('VBD02 ',   2,    
          startkey.keyLen_gg00, sizeof (key_trace.bdtkKey_gg11[0]),
          @startkey.keyVal_gg00, 1, @key_trace.bdtkKey_gg11[0], 1,
          gg06Min( startkey.keyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    auxError := e_ok;
    SAPDB_PascalMove ('VBD02 ',   3,    
          stopkey.keyLen_gg00, sizeof (key_trace.bdtkKey_gg11[1]),
          @stopkey.keyVal_gg00, 1, @key_trace.bdtkKey_gg11[1], 1,
          gg06Min( stopkey.keyLen_gg00,  sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b03eval, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01sname  (bi, 'bd calc pcnt');
t01treeid (bi, 'treeid      ', file_id);
t01lkey   (bi, startkey);
t01lkey   (bi, stopkey);
&endif
t.trError_gg00   := e_ok;
retryCount       := 1;
page_count       := 0;
index_page_count := 0;
record_count     := 0;
WITH t DO
    BEGIN
    IF  (startkey.keyLen_gg00 = 0) AND (stopkey.keyLen_gg00 = PERM_KEY_MXSP00)
    THEN
        (* try to get information from file directory if the *)
        (* the whole file should be looked at                *)
        bd998GetPageAndRecordCount (t, file_id.fileTabId_gg00,
              page_count, index_page_count, record_count);
    (*ENDIF*) 
    IF  page_count = 0
    THEN
        IF  (startkey.keyLen_gg00 > PERM_KEY_MXSP00) OR (startkey.keyLen_gg00 < 0) OR
            (stopkey.keyLen_gg00  > PERM_KEY_MXSP00) OR (stopkey.keyLen_gg00  < 0)
        THEN
            trError_gg00 := e_illegal_keylength
        ELSE
            IF  NOT (ftsPerm_egg00 in file_id.fileType_gg00)
            THEN
                trError_gg00 := e_shutdown
            ELSE
                BEGIN
                REPEAT
                    IF  b01downfilesystem
                    THEN
                        trError_gg00 := e_shutdown
                    ELSE
                        BEGIN
                        trError_gg00 := e_ok;
                        bd30GetTree (t, file_id, current, m_eval,
                              NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
                        IF  trError_gg00 = e_ok
                        THEN
                            BEGIN
                            file_id.fileRoot_gg00                     := current.curr_tree_id.fileRoot_gg00;
                            eval_trace.bdeRootTrace_gg11.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
                            bd50CalculatePageCount (current, startkey, stopkey, page_count)
                            END;
                        (*ENDIF*) 
                        bd30ReleaseTree (current);
                        IF  trError_gg00 = e_bd_leaf_unlocked
                        THEN
                            BEGIN
&                           ifdef TRACE
                            t01lkey (bi, startkey);
&                           endif
                            retryCount := retryCount + 1;
                            IF  retryCount > c_number_of_retries
                            THEN
                                vsleep (trTaskId_gg00, 0)
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                UNTIL
                    trError_gg00 <> e_bd_leaf_unlocked;
                (*ENDREPEAT*) 
                IF  trError_gg00 = e_ok
                THEN
                    file_id := current.curr_tree_id
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
t01int4        (bi, 'page count  ', page_count);
t01basis_error (bi, 'calc pc err ', t.trError_gg00);
&endif
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    eval_trace.bdeRootTrace_gg11.bdrTrType_gg11 := bdtrEvalPages_egg11;
    eval_trace.bdeRootTrace_gg11.bdrError_gg11  := t.trError_gg00;
    eval_trace.bdePageCnt_gg11    := page_count;
    eval_trace.bdeRecordCnt_gg11  := 0;
    eval_trace.bdeAllPageCnt_gg11 := 0;
    b120InsertTrace (t, bd, b03eval, sizeof (eval_trace), @eval_trace)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02del_record (VAR t : tgg00_TransContext;
            VAR file_id    : tgg00_FileId;
            VAR rk         : tgg00_Lkey);
 
VAR
      bSyncWithSVP : boolean;
      auxError     : tgg00_BasisError;
      key_trace    : tgg11_BdKeyTrace;
      root_trace   : tgg11_BdRootTrace;
      current      : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := rk.keyLen_gg00;
    SAPDB_PascalMove ('VBD02 ',   4,    
          rk.keyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @rk.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( rk.keyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b02del, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd del rec  ');
t01treeid (bi, 'treeid      ', file_id);
t01lkey   (bi, rk);
&endif
IF  ftsTemp_egg00 IN file_id.fileType_gg00
THEN
    BEGIN
    bSyncWithSVP := NOT SYNC_TREE_LOCK_BD00;
    b73cmd_count (icdel_rec)
    END
ELSE
    BEGIN
    bSyncWithSVP := SYNC_TREE_LOCK_BD00;
    b73cmd_count (idel_rec)
    END;
(*ENDIF*) 
WITH t DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        IF  (rk.keyLen_gg00 > PERM_KEY_MXSP00) OR (rk.keyLen_gg00 < 0)
        THEN
            trError_gg00 := e_illegal_key
        ELSE
            trError_gg00 := e_ok;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        file_id.fileBdUse_gg00  := file_id.fileBdUse_gg00 + [bd_write_acc];
        bd30GetTree (t, file_id, current, m_delete,
              NOT LOCK_TREE_EXCL_BD00, bSyncWithSVP);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            root_trace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
            bd30DelFromTree (rk, current)
            END;
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  trError_gg00 = e_ok
        THEN
            file_id := current.curr_tree_id;
        (*ENDIF*) 
        file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 - [bd_write_acc]
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b02del, sizeof (root_trace), @root_trace)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02DelGarbage (VAR t : tgg00_TransContext;
            VAR file_id   : tgg00_FileId;
            VAR rk        : tgg00_Lkey             (*ptocConst*);
            VAR wantedRef : tgg91_PageRef          (*ptocConst*));
 
VAR
      bSyncWithSVP : boolean;
      auxError     : tgg00_BasisError;
      key_trace    : tgg11_BdKeyTrace;
      root_trace   : tgg11_BdRootTrace;
      current      : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := rk.keyLen_gg00;
    SAPDB_PascalMove ('VBD02 ',   5,    
          rk.keyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @rk.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( rk.keyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b02del, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd del rec  ');
t01treeid (bi, 'treeid      ', file_id);
t01lkey   (bi, rk);
&endif
IF  ftsTemp_egg00 IN file_id.fileType_gg00
THEN
    BEGIN
    bSyncWithSVP := NOT SYNC_TREE_LOCK_BD00;
    b73cmd_count (icdel_rec)
    END
ELSE
    BEGIN
    bSyncWithSVP := SYNC_TREE_LOCK_BD00;
    b73cmd_count (idel_rec)
    END;
(*ENDIF*) 
WITH t DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        IF  (rk.keyLen_gg00 > PERM_KEY_MXSP00) OR (rk.keyLen_gg00 < 0)
        THEN
            trError_gg00 := e_illegal_key
        ELSE
            trError_gg00 := e_ok;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        file_id.fileBdUse_gg00  := file_id.fileBdUse_gg00 + [bd_write_acc];
        bd30GetTree (t, file_id, current, m_delete,
              NOT LOCK_TREE_EXCL_BD00, bSyncWithSVP);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            root_trace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
            bd30DelGarbageFromTree (rk, current, wantedRef)
            END;
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  trError_gg00 = e_ok
        THEN
            file_id := current.curr_tree_id;
        (*ENDIF*) 
        file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 - [bd_write_acc]
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b02del, sizeof (root_trace), @root_trace)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02eval_page_count (VAR t : tgg00_TransContext;
            VAR file_id      : tgg00_FileId;
            VAR startkey     : tgg00_Lkey;
            VAR stopkey      : tgg00_Lkey;
            count_records    : boolean;
            VAR page_count   : tsp00_Int4;
            VAR all_page_cnt : tsp00_Int4;
            VAR record_cnt   : tsp00_Int4);
 
VAR
      auxError         : tgg00_BasisError;
      eval_trace       : tgg11_BdEvalPagesTrace;
      key_trace        : tgg11_BdTwoKeysTrace;
      index_page_count : tsp00_Int4;
      current          : tbd_current_tree;
      maxkeylen        : integer;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR  g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    eval_trace.bdeRootTrace_gg11.bdrRoot_gg11 := NIL_PAGE_NO_GG00;
    key_trace.bdtkTrType_gg11     := bdtrTwoKeys_egg11;
    key_trace.bdtkKeyLen_gg11 [0] := startkey.keyLen_gg00;
    key_trace.bdtkKeyLen_gg11 [1] := stopkey.keyLen_gg00;
    auxError                      := e_ok;
    SAPDB_PascalMove ('VBD02 ',   6,    
          startkey.keyLen_gg00, sizeof (key_trace.bdtkKey_gg11[0]),
          @startkey.keyVal_gg00, 1, @key_trace.bdtkKey_gg11[0], 1,
          gg06Min( startkey.keyLen_gg00,  sizeof( tgg00_VtraceKey )), auxError);
    auxError := e_ok;
    SAPDB_PascalMove ('VBD02 ',   7,    
          stopkey.keyLen_gg00, sizeof (key_trace.bdtkKey_gg11[1]),
          @stopkey.keyVal_gg00, 1, @key_trace.bdtkKey_gg11[1], 1,
          gg06Min( stopkey.keyLen_gg00,  sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b03eval, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01sname  (bi, 'bd eval pcnt');
t01treeid (bi, 'treeid      ', file_id);
t01lkey   (bi, startkey);
t01lkey   (bi, stopkey);
t01int4   (bi, 'limitcount :', page_count);
t01bool   (bi, 'count recs  ', count_records);
&endif
page_count       := 0;
index_page_count := 0;
record_cnt       := 0;
WITH t DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        BEGIN
        IF  ftsPerm_egg00 in file_id.fileType_gg00
        THEN
            maxkeylen := PERM_KEY_MXSP00
        ELSE
            maxkeylen := KEY_MXSP00;
        (*ENDIF*) 
        IF  (startkey.keyLen_gg00 = 0) AND (stopkey.keyLen_gg00 = maxkeylen)
        THEN
            BEGIN
            (* try to get information from file directory if the *)
            (* the whole file should be sampled                  *)
            bd998GetPageAndRecordCount (t, file_id.fileTabId_gg00,
                  page_count, index_page_count, record_cnt);
            all_page_cnt   := page_count + index_page_count;
            END;
        (*ENDIF*) 
        IF  page_count = 0
        THEN
            BEGIN
            record_cnt   := -1;
            IF  (startkey.keyLen_gg00 > maxkeylen) OR (startkey.keyLen_gg00 < 0) OR
                (stopkey.keyLen_gg00  > maxkeylen) OR (stopkey.keyLen_gg00  < 0)
            THEN
                trError_gg00 := e_illegal_keylength
            ELSE
                BEGIN
                trError_gg00 := e_ok;
                bd30GetTree (t, file_id, current, m_eval,
                      NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
                IF  trError_gg00 = e_ok
                THEN
                    BEGIN
                    eval_trace.bdeRootTrace_gg11.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
                    bd50EvalPageCount (startkey, stopkey, count_records, page_count,
                          all_page_cnt, record_cnt, current)
                    END;
                (*ENDIF*) 
                bd30ReleaseTree (current);
                IF  trError_gg00 = e_ok
                THEN
                    file_id := current.curr_tree_id
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
t01p2int4      (bi, 'page count  ', page_count
      ,             'all page cnt', all_page_cnt);
t01int4        (bi, 'record count', record_cnt);
t01basis_error (bi, 'eval pc err ', t.trError_gg00);
&endif
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    eval_trace.bdeRootTrace_gg11.bdrTrType_gg11 := bdtrEvalPages_egg11;
    eval_trace.bdeRootTrace_gg11.bdrError_gg11  := t.trError_gg00;
    eval_trace.bdePageCnt_gg11    := page_count;
    eval_trace.bdeRecordCnt_gg11  := record_cnt;
    eval_trace.bdeAllPageCnt_gg11 := all_page_cnt;
    b120InsertTrace (t, bd, b03eval, sizeof (eval_trace), @eval_trace)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02exists_record (VAR t : tgg00_TransContext;
            VAR file_id       : tgg00_FileId;
            VAR rk            : tgg00_Lkey);
 
VAR
      auxError    : tgg00_BasisError;
      retry_count : integer;
      key_trace   : tgg11_BdKeyTrace;
      root_trace  : tgg11_BdRootTrace;
      current     : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := rk.keyLen_gg00;
    SAPDB_PascalMove ('VBD02 ',   8,    
          rk.keyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @rk.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( rk.keyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b02exists, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd exists re');
t01treeid (bi, 'treeid      ', file_id);
t01lkey   (bi, rk);
&endif
retry_count := 1;
WITH t DO
    BEGIN
    IF  (rk.keyLen_gg00 > PERM_KEY_MXSP00) OR (rk.keyLen_gg00 < 0)
    THEN
        trError_gg00 := e_illegal_key
    ELSE
        BEGIN
        REPEAT
            trError_gg00 := e_ok;
            IF  b01downfilesystem
            THEN
                trError_gg00 := e_shutdown
            ELSE
                BEGIN
                bd30GetTree (t, file_id, current, m_select,
                      NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
                IF  trError_gg00 = e_ok
                THEN
                    BEGIN
                    current.currUnlockAllowed_bd00 := true;
                    root_trace.bdrRoot_gg11        := current.curr_tree_id.fileRoot_gg00;
                    file_id.fileRoot_gg00          := current.curr_tree_id.fileRoot_gg00;
                    bd30ExistRecord (rk, current)
                    END;
                (*ENDIF*) 
                bd30ReleaseTree (current);
                IF  trError_gg00 = e_bd_leaf_unlocked
                THEN
                    BEGIN
                    retry_count := retry_count + 1;
                    IF  retry_count > c_number_of_retries
                    THEN
                        vsleep (trTaskId_gg00, 0)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            trError_gg00 <> e_bd_leaf_unlocked;
        (*ENDREPEAT*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b02exists, sizeof (root_trace), @root_trace)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02find_leaf (VAR t : tgg00_TransContext;
            VAR file_id   : tgg00_FileId;
            VAR key       : tgg00_Lkey);
 
VAR
      auxError    : tgg00_BasisError;
      retry_count : integer;
      key_trace   : tgg11_BdKeyTrace;
      root_trace  : tgg11_BdRootTrace;
      current     : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := key.keyLen_gg00;
    SAPDB_PascalMove ('VBD02 ',   9,    
          key.keyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @key.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( key.keyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b02get, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd find leaf');
t01treeid (bi, 'treeid      ', file_id);
t01lkey   (bi, key);
&endif
IF  ftsTemp_egg00 IN file_id.fileType_gg00
THEN
    b73cmd_count (icget_rec)
ELSE
    b73cmd_count (iget_rec);
(*ENDIF*) 
retry_count := 1;
WITH current, t DO
    BEGIN
    IF  (key.keyLen_gg00 > PERM_KEY_MXSP00) OR (key.keyLen_gg00 < 0)
    THEN
        trError_gg00 := e_illegal_key
    ELSE
        BEGIN
        REPEAT
            trError_gg00 := e_ok;
            IF  b01downfilesystem
            THEN
                trError_gg00 := e_shutdown
            ELSE
                BEGIN
                bd30GetTree (t, file_id, current, m_get,
                      NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
                IF  trError_gg00 = e_ok
                THEN
                    BEGIN
                    current.currUnlockAllowed_bd00 := true;
                    root_trace.bdrRoot_gg11        := current.curr_tree_id.fileRoot_gg00;
                    file_id.fileRoot_gg00          := current.curr_tree_id.fileRoot_gg00;
                    bd30FindLeaf (key, current)
                    END;
                (*ENDIF*) 
                bd30ReleaseTree (current);
                IF  trError_gg00 = e_bd_leaf_unlocked
                THEN
                    BEGIN
                    retry_count := retry_count + 1;
                    IF  retry_count > c_number_of_retries
                    THEN
                        vsleep (t.trTaskId_gg00, 0)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
        UNTIL
            trError_gg00 <> e_bd_leaf_unlocked;
        (*ENDREPEAT*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b02get, sizeof (root_trace), @root_trace)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02get_lock_record (
            VAR t       : tgg00_TransContext;
            VAR file_id : tgg00_FileId;
            VAR rk      : tgg00_Lkey;
            VAR b       : tgg00_Rec);
 
VAR
      auxError    : tgg00_BasisError;
      retry_count : integer;
      key_trace   : tgg11_BdKeyTrace;
      root_trace  : tgg11_BdRootTrace;
      current     : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := rk.keyLen_gg00;
    SAPDB_PascalMove ('VBD02 ',  10,    
          rk.keyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @rk.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( rk.keyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b02get, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd get lock ');
t01treeid (bi, 'treeid      ', file_id);
t01lkey   (bi, rk);
&endif
IF  ftsTemp_egg00 IN file_id.fileType_gg00
THEN
    b73cmd_count (icget_rec)
ELSE
    b73cmd_count (iget_rec);
(*ENDIF*) 
retry_count := 1;
WITH  t DO
    BEGIN
    IF  (rk.keyLen_gg00 > PERM_KEY_MXSP00) OR (rk.keyLen_gg00 < 0)
    THEN
        trError_gg00 := e_illegal_key
    ELSE
        BEGIN
        REPEAT
            trError_gg00 := e_ok;
            IF  b01downfilesystem
            THEN
                trError_gg00 := e_shutdown
            ELSE
                BEGIN
                bd30GetTree (t, file_id, current, m_get,
                      NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
                IF  trError_gg00 = e_ok
                THEN
                    BEGIN
                    current.currUnlockAllowed_bd00 := true;
                    root_trace.bdrRoot_gg11        := current.curr_tree_id.fileRoot_gg00;
                    file_id.fileRoot_gg00          := current.curr_tree_id.fileRoot_gg00;
                    bd30GetFromTree (rk, b, current, lckRowShare_egg00)
                    END;
                (*ENDIF*) 
                bd30ReleaseTree (current);
                IF  trError_gg00 = e_bd_leaf_unlocked
                THEN
                    BEGIN
                    retry_count := retry_count + 1;
                    IF  retry_count > c_number_of_retries
                    THEN
                        vsleep (trTaskId_gg00, 0)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
        UNTIL
            trError_gg00 <> e_bd_leaf_unlocked;
        (*ENDREPEAT*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
IF  t.trError_gg00 = e_ok
THEN
    t01buf (bi, b.recBuf_gg00, 1, b.recLen_gg00);
&endif
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b02get, sizeof (root_trace), @root_trace)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02get_record (VAR t : tgg00_TransContext;
            VAR file_id : tgg00_FileId;
            VAR rk      : tgg00_Lkey;
            VAR b       : tgg00_Rec);
 
VAR
      auxError    : tgg00_BasisError;
      retry_count : integer;
      key_trace   : tgg11_BdKeyTrace;
      root_trace  : tgg11_BdRootTrace;
      current     : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := rk.keyLen_gg00;
    SAPDB_PascalMove ('VBD02 ',  11,    
          rk.keyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @rk.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( rk.keyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b02get, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd get rec  ');
t01treeid (bi, 'treeid      ', file_id);
t01lkey   (bi, rk);
&endif
IF  ftsTemp_egg00 IN file_id.fileType_gg00
THEN
    b73cmd_count (icget_rec)
ELSE
    b73cmd_count (iget_rec);
(*ENDIF*) 
retry_count := 1;
WITH t DO
    BEGIN
    IF  (rk.keyLen_gg00 > PERM_KEY_MXSP00) OR (rk.keyLen_gg00 < 0)
    THEN
        trError_gg00 := e_illegal_key
    ELSE
        BEGIN
        REPEAT
            trError_gg00 := e_ok;
            IF  b01downfilesystem
            THEN
                trError_gg00 := e_shutdown
            ELSE
                BEGIN
                bd30GetTree (t, file_id, current, m_get,
                      NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
                IF  trError_gg00 = e_ok
                THEN
                    BEGIN
                    current.currUnlockAllowed_bd00 := true;
                    root_trace.bdrRoot_gg11        := current.curr_tree_id.fileRoot_gg00;
                    file_id.fileRoot_gg00          := current.curr_tree_id.fileRoot_gg00;
                    bd30GetFromTree (rk, b, current, lckFree_egg00)
                    END;
                (*ENDIF*) 
                bd30ReleaseTree (current);
                IF  trError_gg00 = e_bd_leaf_unlocked
                THEN
                    BEGIN
                    retry_count := retry_count + 1;
                    IF  retry_count > c_number_of_retries
                    THEN
                        vsleep (t.trTaskId_gg00, 0)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            trError_gg00 <> e_bd_leaf_unlocked;
        (*ENDREPEAT*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
IF  t.trError_gg00 = e_ok
THEN
    t01buf (bi, b.recBuf_gg00, 1, b.recLen_gg00);
&endif
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b02get, sizeof (root_trace), @root_trace)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02kb_del_rec (VAR m  : tgg00_MessBlock;
            pDeleteCmd      : tsp00_Addr;
            VAR rk          : tgg00_Lkey;
            VAR old_recbuf  : tgg00_Rec;
            granted_lock    : tgg00_LockReqMode);
 
VAR
      auxError   : tgg00_BasisError;
      key_trace  : tgg11_BdKeyTrace;
      root_trace : tgg11_BdRootTrace;
      current    : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := rk.keyLen_gg00;
    SAPDB_PascalMove ('VBD02 ',  12,    
          rk.keyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @rk.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( rk.keyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (m.mb_trns^, bd, b02kb_del, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd kbdel rec');
t01treeid (bi, 'treeid      ', m.mb_qual^.mtree);
t01lkey   (bi, rk);
&endif
IF  ftsTemp_egg00 IN m.mb_qual^.mtree.fileType_gg00
THEN
    b73cmd_count (icdel_rec)
ELSE
    b73cmd_count (idel_rec);
(*ENDIF*) 
WITH m.mb_trns^, m.mb_qual^ DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        IF  (rk.keyLen_gg00 > PERM_KEY_MXSP00) OR (rk.keyLen_gg00 < 0)
        THEN
            trError_gg00 := e_illegal_key
        ELSE
            trError_gg00 := e_ok;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        mtree.fileBdUse_gg00 := mtree.fileBdUse_gg00 + [bd_write_acc];
        bd30GetTree (m.mb_trns^, mtree, current, m.mb_type,
              NOT LOCK_TREE_EXCL_BD00, SYNC_TREE_LOCK_BD00);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            root_trace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
            bd30DelFromTreeWithBeforeImage (rk, old_recbuf, m, pDeleteCmd,
                  granted_lock, current)
            END;
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            mtree := current.curr_tree_id;
            IF  mtree.fileTfn_gg00 = tfnTable_egg00
            THEN
                BEGIN
                b73cmd_count (ideletes_rows_read);
                b73cmd_count (ideletes_rows_del);
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        mtree.fileBdUse_gg00 := mtree.fileBdUse_gg00 - [bd_write_acc]
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := m.mb_trns^.trError_gg00;
    b120InsertTrace (m.mb_trns^, bd, b02kb_del, sizeof (root_trace), @root_trace)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02kb_ins_record (VAR m : tgg00_MessBlock;
            pInsertCmd        : tsp00_Addr;
            VAR b             : tgg00_Rec;
            granted_lock      : tgg00_LockReqMode);
 
VAR
      auxError   : tgg00_BasisError;
      key_trace  : tgg11_BdKeyTrace;
      root_trace : tgg11_BdRootTrace;
      current    : tbd_current_tree;
 
BEGIN
IF  (g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00)
THEN
    BEGIN
    root_trace.bdrRoot_gg11 := NIL_PAGE_NO_GG00;
    IF  (m.mb_type2 <> mm_nokey) AND ( m.mb_type2 <> mm_specialkey)
    THEN
        BEGIN
        auxError                 := e_ok;
        key_trace.bdkTrType_gg11 := bdtrKey_egg11;
        key_trace.bdkKeyLen_gg11 := b.recKeyLen_gg00;
        SAPDB_PascalMove ('VBD02 ',  13,    
              b.recKeyLen_gg00, sizeof (key_trace.bdkKey_gg11),
              @b.recKey_gg00.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
              gg06Min( b.recKeyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
        b120InsertTrace (m.mb_trns^, bd, b02logadd, sizeof (key_trace), @key_trace)
        END
    (*ENDIF*) 
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd kbins rec');
t01treeid (bi, 'treeid      ', m.mb_qual^.mtree);
t01buf    (bi, b.recBuf_gg00, 1, b.recLen_gg00);
&endif
IF  ftsTemp_egg00 IN m.mb_qual^.mtree.fileType_gg00
THEN
    b73cmd_count (icadd_rec)
ELSE
    b73cmd_count (iadd_rec);
(*ENDIF*) 
WITH m.mb_trns^, m.mb_qual^ DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        IF  (b.recLen_gg00 > MAX_RECLEN_GG00) OR (b.recLen_gg00 < MIN_RECORD_LEN_BD00)
        THEN
            trError_gg00 := e_illegal_record
        ELSE
            BEGIN
            IF  (b.recKeyLen_gg00 > PERM_KEY_MXSP00) OR (b.recKeyLen_gg00 < 0)
            THEN
                trError_gg00 := e_illegal_key
            ELSE
                trError_gg00 := e_ok;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        mtree.fileBdUse_gg00 := mtree.fileBdUse_gg00 + [bd_write_acc];
        bd30GetTree (m.mb_trns^, mtree, current, m.mb_type,
              NOT LOCK_TREE_EXCL_BD00, SYNC_TREE_LOCK_BD00);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            root_trace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
            IF  m.mb_type2 = mm_specialkey
            THEN
                bd30AddToTreeWithBeforeImageAndSpecialKey (b.recKey_gg00,
                      b, m, pInsertCmd, granted_lock, current)
            ELSE
                bd30AddToTreeWithBeforeImage (b.recKey_gg00, b, m,
                      pInsertCmd, granted_lock, current)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            mtree := current.curr_tree_id;
            IF  mtree.fileTfn_gg00 = tfnTable_egg00
            THEN
                b73cmd_count (iinserts_rows);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        mtree.fileBdUse_gg00 := mtree.fileBdUse_gg00 - [bd_write_acc]
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := m.mb_trns^.trError_gg00;
    b120InsertTrace (m.mb_trns^, bd, b02logadd, sizeof (root_trace), @root_trace)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02kb_upd_rec (VAR m : tgg00_MessBlock;
            pUpdateCmd     : tsp00_Addr;
            VAR rk         : tgg00_Lkey;
            VAR old_recbuf : tgg00_Rec;
            VAR new_recbuf : tgg00_Rec;
            granted_lock   : tgg00_LockReqMode);
 
VAR
      auxError   : tgg00_BasisError;
      key_trace  : tgg11_BdKeyTrace;
      root_trace : tgg11_BdRootTrace;
      current    : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := rk.keyLen_gg00;
    SAPDB_PascalMove ('VBD02 ',  14,    
          rk.keyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @rk.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( rk.keyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (m.mb_trns^, bd, b02kb_repl, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd kbupd rec');
t01treeid (bi, 'treeid      ', m.mb_qual^.mtree);
t01lkey   (bi, rk);
&endif
IF  ftsTemp_egg00 IN m.mb_qual^.mtree.fileType_gg00
THEN
    b73cmd_count (icrepl_rec)
ELSE
    b73cmd_count (irepl_rec);
(*ENDIF*) 
WITH m.mb_trns^, m.mb_qual^ DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        IF  (rk.keyLen_gg00 > PERM_KEY_MXSP00) OR (rk.keyLen_gg00 < 0)
        THEN
            trError_gg00 := e_illegal_key
        ELSE
            trError_gg00 := e_ok;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        mtree.fileBdUse_gg00 := mtree.fileBdUse_gg00 + [bd_write_acc];
        bd30GetTree (m.mb_trns^, mtree, current, m.mb_type,
              NOT LOCK_TREE_EXCL_BD00, SYNC_TREE_LOCK_BD00);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            root_trace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
            bd30ReplaceInTreeWithBeforeImage (rk, old_recbuf, new_recbuf,
                  m, pUpdateCmd, granted_lock, current)
            END;
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            mtree := current.curr_tree_id;
            IF  mtree.fileTfn_gg00 = tfnTable_egg00
            THEN
                BEGIN
                b73cmd_count (iupdates_rows_read);
                b73cmd_count (iupdates_rows_upd)
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        mtree.fileBdUse_gg00 := mtree.fileBdUse_gg00 - [bd_write_acc];
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := m.mb_trns^.trError_gg00;
    b120InsertTrace (m.mb_trns^, bd, b02kb_repl, sizeof (root_trace), @root_trace)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02MarkRecordDeleted (
            VAR t          : tgg00_TransContext;
            VAR file_id    : tgg00_FileId;
            isDelete       : boolean;
            VAR beforeRef  : tgg91_PageRef;
            VAR updTrans   : tgg91_TransNo;
            VAR rk         : tgg00_Lkey;
            pRec           : tgg00_RecPtr);
 
VAR
      bSyncWithSVP : boolean;
      auxError     : tgg00_BasisError;
      key_trace    : tgg11_BdKeyTrace;
      root_trace   : tgg11_BdRootTrace;
      current      : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := rk.keyLen_gg00;
    SAPDB_PascalMove ('VBD02 ',  15,    
          rk.keyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @rk.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( rk.keyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b02del, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd del rec  ');
t01treeid (bi, 'treeid      ', file_id);
t01lkey   (bi, rk);
&endif
IF  ftsTemp_egg00 in file_id.fileType_gg00
THEN
    BEGIN
    bSyncWithSVP := NOT SYNC_TREE_LOCK_BD00;
    b73cmd_count (icdel_rec)
    END
ELSE
    BEGIN
    bSyncWithSVP := SYNC_TREE_LOCK_BD00;
    b73cmd_count (idel_rec);
    END;
(*ENDIF*) 
WITH t DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        IF  (rk.keyLen_gg00 > PERM_KEY_MXSP00) OR (rk.keyLen_gg00 < 0)
        THEN
            trError_gg00 := e_illegal_key
        ELSE
            trError_gg00 := e_ok;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        file_id.fileBdUse_gg00  := file_id.fileBdUse_gg00 + [bd_write_acc];
        bd30GetTree (t, file_id, current, m_delete,
              NOT LOCK_TREE_EXCL_BD00, bSyncWithSVP);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            root_trace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
            bd30MarkDeletedFromTree (rk, current, isDelete, beforeRef, updTrans, pRec)
            END;
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  trError_gg00 = e_ok
        THEN
            file_id := current.curr_tree_id;
        (*ENDIF*) 
        file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 - [bd_write_acc]
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b02del, sizeof (root_trace), @root_trace)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02next_record (VAR t : tgg00_TransContext;
            VAR file_id : tgg00_FileId;
            VAR rk      : tgg00_Lkey;
            inclusive   : boolean;
            VAR b       : tgg00_Rec);
 
VAR
      bWithSQLLock : boolean;
      auxError     : tgg00_BasisError;
      retry_count  : integer;
      key_trace    : tgg11_BdKeyTrace;
      root_trace   : tgg11_BdRootTrace;
      current      : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := rk.keyLen_gg00;
    SAPDB_PascalMove ('VBD02 ',  16,    
          rk.keyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @rk.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( rk.keyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b02next, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd next rec ');
t01treeid (bi, 'treeid      ', file_id);
t01lkey   (bi, rk);
&endif
IF  ftsTemp_egg00 in file_id.fileType_gg00
THEN
    b73cmd_count (icnext_rec)
ELSE
    b73cmd_count (inext_rec);
(*ENDIF*) 
retry_count := 1;
WITH current, t DO
    BEGIN
    IF  (
        (rk.keyLen_gg00 > PERM_KEY_MXSP00) AND
        (ftsPerm_egg00 in file_id.fileType_gg00)
        )
        OR
        (rk.keyLen_gg00 > KEY_MXSP00)
        OR
        (rk.keyLen_gg00 < 0)
    THEN
        trError_gg00 := e_illegal_key
    ELSE
        BEGIN
        REPEAT
            trError_gg00 := e_ok;
            IF  b01downfilesystem
            THEN
                trError_gg00 := e_shutdown
            ELSE
                BEGIN
                bd30GetTree (t, file_id, current, m_select,
                      NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
                IF  trError_gg00 = e_ok
                THEN
                    BEGIN
                    current.currUnlockAllowed_bd00 := true;
                    root_trace.bdrRoot_gg11        := current.curr_tree_id.fileRoot_gg00;
                    file_id.fileRoot_gg00          := current.curr_tree_id.fileRoot_gg00;
                    bWithSQLLock                   := kb560IsSys1CatalogTable (
                          current.curr_tree_id.fileTabId_gg00);
                    bd30NextFromTree (rk, inclusive, bWithSQLLock, b, current)
                    END;
                (*ENDIF*) 
                bd30ReleaseTree (current);
                IF  trError_gg00 = e_bd_leaf_unlocked
                THEN
                    BEGIN
                    retry_count := retry_count + 1;
                    IF  retry_count > c_number_of_retries
                    THEN
                        vsleep (t.trTaskId_gg00, 0)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            trError_gg00 <> e_bd_leaf_unlocked;
        (*ENDREPEAT*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
IF  (t.trError_gg00 = e_ok) OR (t.trError_gg00 = e_key_not_found)
THEN
    t01buf (bi, b.recBuf_gg00, 1, b.recLen_gg00);
&endif
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b02next, sizeof (root_trace), @root_trace)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02prefetch (VAR t : tgg00_TransContext;
            VAR file_id : tgg00_FileId;
            pno         : tsp00_PageNo);
 
VAR
      nptr    : tbd_node_ptrs;
      current : tbd_current_tree;
 
BEGIN
&ifdef TRACE
t01name   (bi, '====> bd prefetch ');
t01treeid (bi, 'treeid      ', file_id);
t01int4   (bi, 'pno         ', pno);
&endif
WITH t DO
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        BEGIN
        trError_gg00  := e_ok;
        nptr.np_ptr   := NIL;
        nptr.np_cbptr := NIL;
        (* TODO bd13LoadNode *)
        bd30BuildCurrent (t, file_id, current);
        bd13GetNode (current, pno, plmLock_ebd00, nr_for_read, nptr);
        IF  nptr.np_ptr <> NIL
        THEN
            b13r_release_node (nptr, current, lru_normal);
        (*ENDIF*) 
        trError_gg00 := e_ok (* ignore errors *)
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02prev_record (VAR t : tgg00_TransContext;
            VAR file_id : tgg00_FileId;
            VAR rk      : tgg00_Lkey;
            inclusive   : boolean;
            VAR b       : tgg00_Rec);
 
VAR
      bWithSQLLock : boolean;
      auxError     : tgg00_BasisError;
      retry_count  : integer;
      key_trace    : tgg11_BdKeyTrace;
      root_trace   : tgg11_BdRootTrace;
      current      : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := rk.keyLen_gg00;
    SAPDB_PascalMove ('VBD02 ',  17,    
          rk.keyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @rk.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( rk.keyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b02prev, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd prev rec ');
t01treeid (bi, 'treeid      ', file_id);
t01lkey   (bi, rk);
&endif
IF  ftsTemp_egg00 in file_id.fileType_gg00
THEN
    b73cmd_count (icprev_rec)
ELSE
    b73cmd_count (iprev_rec);
(*ENDIF*) 
retry_count := 1;
WITH t DO
    BEGIN
    IF  (
        (rk.keyLen_gg00 > PERM_KEY_MXSP00) AND
        (ftsPerm_egg00 in file_id.fileType_gg00)
        )
        OR
        (rk.keyLen_gg00 > KEY_MXSP00)
        OR
        (rk.keyLen_gg00 < 0)
    THEN
        trError_gg00 := e_illegal_key
    ELSE
        BEGIN
        REPEAT
            trError_gg00 := e_ok;
            IF  b01downfilesystem
            THEN
                trError_gg00 := e_shutdown
            ELSE
                BEGIN
                bd30GetTree (t, file_id, current, m_select,
                      NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
                IF  trError_gg00 = e_ok
                THEN
                    BEGIN
                    current.currUnlockAllowed_bd00 := true;
                    root_trace.bdrRoot_gg11        := current.curr_tree_id.fileRoot_gg00;
                    file_id.fileRoot_gg00          := current.curr_tree_id.fileRoot_gg00;
                    bWithSQLLock                   := kb560IsSys1CatalogTable (
                          current.curr_tree_id.fileTabId_gg00);
                    bd30PrevFromTree (rk, inclusive, bWithSQLLock, b, current)
                    END;
                (*ENDIF*) 
                bd30ReleaseTree (current);
                IF  trError_gg00 = e_bd_leaf_unlocked
                THEN
                    BEGIN
                    retry_count := retry_count + 1;
                    IF  retry_count > c_number_of_retries
                    THEN
                        vsleep (trTaskId_gg00, 0)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            trError_gg00 <> e_bd_leaf_unlocked;
        (*ENDREPEAT*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
IF  (t.trError_gg00 = e_ok) OR (t.trError_gg00 = e_key_not_found)
THEN
    t01buf (bi, b.recBuf_gg00, 1, b.recLen_gg00);
&endif
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b02prev, sizeof (root_trace), @root_trace)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02repl_record (VAR t : tgg00_TransContext;
            VAR file_id     : tgg00_FileId;
            VAR b           : tgg00_Rec);
 
VAR
      dummyRef   : tgg91_PageRef;
      dummyTrans : tgg91_TransNo;
 
BEGIN
b02ReplaceRecord (t, file_id, b, false, dummyRef, dummyTrans);
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02ReplaceRecord (VAR t : tgg00_TransContext;
            VAR file_id     : tgg00_FileId;
            VAR b           : tgg00_Rec;
            useTransInfo    : boolean;
            VAR beforeRef   : tgg91_PageRef;
            VAR updTrans    : tgg91_TransNo);
 
VAR
      bSyncWithSVP : boolean;
      auxError     : tgg00_BasisError;
      key_trace    : tgg11_BdKeyTrace;
      root_trace   : tgg11_BdRootTrace;
      current      : tbd_current_tree;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    auxError                 := e_ok;
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := b.recKeyLen_gg00;
    SAPDB_PascalMove ('VBD02 ',  18,    
          b.recKeyLen_gg00, sizeof (key_trace.bdkKey_gg11),
          @b.recKey_gg00.keyVal_gg00, 1, @key_trace.bdkKey_gg11, 1,
          gg06Min( b.recKeyLen_gg00, sizeof( tgg00_VtraceKey )), auxError);
    b120InsertTrace (t, bd, b02repl, sizeof (key_trace), @key_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd repl rec ');
t01treeid (bi, 'treeid      ', file_id);
t01buf    (bi, b.recBuf_gg00, 1, b.recLen_gg00);
&endif
IF  ftsTemp_egg00 in file_id.fileType_gg00
THEN
    BEGIN
    bSyncWithSVP := NOT SYNC_TREE_LOCK_BD00;
    b73cmd_count (icrepl_rec)
    END
ELSE
    BEGIN
    bSyncWithSVP := SYNC_TREE_LOCK_BD00;
    b73cmd_count (irepl_rec)
    END;
(*ENDIF*) 
WITH t DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        IF  (b.recLen_gg00 > MAX_RECLEN_GG00) OR (b.recLen_gg00 < MIN_RECORD_LEN_BD00)
        THEN
            trError_gg00 := e_illegal_record
        ELSE
            IF  (b.recKeyLen_gg00 > PERM_KEY_MXSP00) OR (b.recKeyLen_gg00 < 0)
            THEN
                trError_gg00 := e_illegal_key
            ELSE
                trError_gg00 := e_ok;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 + [bd_write_acc];
        bd30GetTree (t, file_id, current, m_update, NOT LOCK_TREE_EXCL_BD00, bSyncWithSVP);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            root_trace.bdrRoot_gg11 := current.curr_tree_id.fileRoot_gg00;
            bd30ReplaceInTree (b.recKey_gg00, b, current, beforeRef, updTrans);
            END;
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  trError_gg00 = e_ok
        THEN
            file_id := current.curr_tree_id;
        (*ENDIF*) 
        file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 - [bd_write_acc];
        bd999RestoreRecordHeader (trTaskId_gg00, @b);
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b02repl, sizeof (root_trace), @root_trace)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b02kb_select_rec (VAR t : tgg00_TransContext;
            VAR file_id       : tgg00_FileId;
            VAR RecKey        : tsp00_Key;
            VAR RecKeyLen     : tsp00_Int2;
            VAR StopKey       : tsp00_Key;
            StopKeyLen        : tsp00_Int4;
            recbuf_size       : tsp00_Int4;
            recbuf_ptr        : tsp00_MoveObjPtr;
            ignore_vwait      : boolean;
            VAR sel           : tgg00_SelectFieldsParam;
            VAR stack_desc    : tgg00_StackDesc;
            VAR unqualified   : boolean;
            VAR granted_lock  : tgg00_LockReqMode);
 
VAR
      bDoRemoveLock            : boolean; (* PTS 1117878 UH 2002-10-17 *)
      first_time               : boolean;
      aux_error                : tgg00_BasisError;
      loop_mess2_type          : tgg00_MessType2;
      trace_object             : tgg00_VtraceType;
      cur_res_cnt              : integer;
      init_result_len          : integer;
      recbuf_pos               : tsp00_Int4;
      NodeUnlocked             : tsp00_PageNo;
      old_error_leaf           : tsp00_PageNo;
&     ifdef TRACE
      init_m_result_addr       : tsp00_MoveObjPtr;
&     endif
      current                  : tbd_current_tree;
      key_trace                : tgg11_BdKeyTrace;
      root_trace               : tgg11_BdRootTrace;
      res_trace                : tgg11_BdIntTrace;
      lockKey                  : tgg00_Lkey;
 
BEGIN
(* *)
(* e_buffer_limit will be returned only if the given *)
(* buffer is too small and no row was inserted!      *)
(* If the buffer is to small but at least one row    *)
(* was inserted the messType2 is adjusted and the    *)
(* error code is set to e_ok                         *)
(* *)
(* if e_no_next_record is returned no more result    *)
(* rows are available and its not guaranteed that    *)
(* the given search keys are updated in this way     *)
(* that a subsequent call returns e_no_next_record   *)
(* again and a m_result_cnt of zero! The same        *)
(* behaviour for e_no_prev_record.                   *)
(* *)
bDoRemoveLock := false; (* PTS 1117878 UH 2002-10-17 *)
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    CASE sel.sfp_bd_mess2_type OF
        mm_first  :
            trace_object := b02first_qual;
        mm_next   :
            trace_object := b02next_qual;
        mm_direct :
            trace_object := b02direct_qual;
        mm_prev   :
            trace_object := b02prev_qual;
        mm_last   :
            trace_object := b02last_qual;
        OTHERWISE
        END;
    (*ENDCASE*) 
    root_trace.bdrRoot_gg11  := NIL_PAGE_NO_GG00;
    key_trace.bdkTrType_gg11 := bdtrKey_egg11;
    key_trace.bdkKeyLen_gg11 := RecKeyLen;
    IF  ( g01vtrace.vtrStrategy_gg00 )
    THEN
        BEGIN
        bd03KeyVtrace( t,
              @RecKey, RecKeyLen, @StopKey, StopKeyLen, trace_object);
        END
    ELSE
        BEGIN
        aux_error                := e_ok;
        SAPDB_PascalMove ('VBD02 ',  19,    
              RecKeyLen, sizeof (key_trace.bdkKey_gg11),
              @RecKey, 1, @key_trace.bdkKey_gg11, 1,
              gg06Min( RecKeyLen, sizeof( tgg00_VtraceKey )), aux_error);
        b120InsertTrace (t, bd, trace_object, sizeof (key_trace), @key_trace)
        END;
    (*ENDIF*) 
    END;
&ifdef TRACE
(*ENDIF*) 
WITH sel DO
    IF  (sfp_bd_mess2_type = mm_last) OR (sfp_bd_mess2_type = mm_prev)
    THEN
        t01name (bi, '====> bd prev qual')
    ELSE
        IF  sfp_bd_mess2_type = mm_direct
        THEN
            t01name (bi, '====> bd direcqual')
        ELSE
            t01name (bi, '====> bd next qual');
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
t01treeid (bi, 'treeid      ', file_id);
t01int4   (bi, 'page cnt    ', t.trRteCommPtr_gg00^.file_record_cnt);
t01buf1   (bi, RecKey, 1, RecKeyLen);
IF  sel.sfp_bd_use_stopkey
THEN
    t01buf1   (bi, StopKey, 1, StopKeyLen);
(*ENDIF*) 
t01bool (bi, 'ignore vwait', ignore_vwait);
IF  recbuf_ptr <> NIL
THEN
    t01int4 (bi, 'recbufSize  ', recbuf_size);
(*ENDIF*) 
t01selfields (bi, 'SelParam    ', sel);
&endif
CASE sel.sfp_bd_mess2_type OF
    mm_first, mm_next :
        loop_mess2_type := mm_next;
    mm_direct :
        loop_mess2_type := mm_direct;
    mm_prev, mm_last :
        loop_mess2_type := mm_prev;
    OTHERWISE
        loop_mess2_type := sel.sfp_bd_mess2_type
    END;
(*ENDCASE*) 
unqualified         := false;
first_time          := true;
old_error_leaf      := NIL_PAGE_NO_GG00;
NodeUnlocked        := NIL_PAGE_NO_GG00;
recbuf_pos          := 1;
cur_res_cnt         := 0;
init_result_len     := sel.sfp_result_length;
lockKey.keyLen_gg00 := 0;
IF  sel.sfp_m_result_cnt <= 0
THEN
    sel.sfp_m_result_cnt := 1;
&ifdef TRACE
(*ENDIF*) 
init_m_result_addr := sel.sfp_m_result_addr;
&endif
WITH t DO
    BEGIN
    IF  (
        (RecKeyLen > PERM_KEY_MXSP00) AND
        (ftsPerm_egg00 in file_id.fileType_gg00)
        )
        OR
        (RecKeyLen > KEY_MXSP00)
        OR
        (RecKeyLen < 0)
    THEN
        trError_gg00 := e_illegal_key
    ELSE
        IF  (trRteCommPtr_gg00^.to_cancel) AND (trError_gg00 = e_ok)
        THEN
            trError_gg00 := e_cancelled
        ELSE
            trError_gg00 := e_ok;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        IF  sel.sfp_bd_mess2_type = mm_direct
        THEN
            b73cmd_count (isel_direc)
        ELSE
            IF  (sel.sfp_bd_mess2_type = mm_last) OR (sel.sfp_bd_mess2_type = mm_prev)
            THEN
                b73cmd_count (isel_prev)
            ELSE
                b73cmd_count (isel_next);
            (*ENDIF*) 
        (*ENDIF*) 
        REPEAT
            trError_gg00 := e_ok;
            IF  b01downfilesystem
            THEN
                trError_gg00 := e_shutdown
            ELSE
                BEGIN
                bd30GetTree (t, file_id, current, sel.sfp_bd_mess_type,
                      NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00 );
                IF  trError_gg00 = e_ok
                THEN
                    BEGIN
                    current.currUnlockAllowed_bd00 := true;
                    root_trace.bdrRoot_gg11        := current.curr_tree_id.fileRoot_gg00;
                    file_id.fileRoot_gg00          := current.curr_tree_id.fileRoot_gg00;
                    sel.sfp_result_length          := init_result_len;
                    IF  (sel.sfp_bd_mess2_type = mm_last) OR (sel.sfp_bd_mess2_type = mm_prev)
                    THEN
                        bd360PrevQualifiedRecordFromTree( current, RecKey, RecKeyLen, StopKey, StopKeyLen,
                              lockKey, recbuf_size, recbuf_ptr, recbuf_pos, sel, stack_desc,
                              cur_res_cnt, unqualified, bDoRemoveLock, granted_lock, NodeUnlocked )
                    ELSE
                        bd360NextQualifiedRecordFromTree( current, RecKey, RecKeyLen, StopKey, StopKeyLen,
                              lockKey, recbuf_size, recbuf_ptr, recbuf_pos, sel, stack_desc,
                              cur_res_cnt, unqualified, bDoRemoveLock, granted_lock, NodeUnlocked );
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                bd30ReleaseTree (current);
                CASE trError_gg00 OF
                    e_bd_leaf_unlocked:
                        BEGIN
                        IF  old_error_leaf = NodeUnlocked
                        THEN
                            vsleep (trTaskId_gg00, 0)
                        ELSE
                            old_error_leaf := NodeUnlocked
                        (*ENDIF*) 
                        END;
                    e_lock_collision_with_inserted_row,
                    e_wait_for_lock_release:
                        BEGIN
                        IF  trError_gg00 = e_lock_collision_with_inserted_row
                        THEN
                            BEGIN
                            (* skip current record because it was just inserted *)
                            trError_gg00 := e_ok;
                            unqualified  := true;
                            END
                        ELSE
                            BEGIN
                            IF  NOT ignore_vwait
                            THEN
                                BEGIN
                                k53wait (t, sel.sfp_bd_mess_type, sel.sfp_bd_mess2_type);
                                IF  trError_gg00 = e_ok
                                THEN
                                    trError_gg00 := e_bd_leaf_unlocked;
                                (*ENDIF*) 
                                IF  trError_gg00 = e_lock_collision_with_inserted_row
                                THEN
                                    BEGIN
                                    (* skip current record because it was just inserted *)
                                    trError_gg00 := e_ok;
                                    unqualified  := true;
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        CASE loop_mess2_type OF
                            mm_next   :
                                sel.sfp_bd_mess2_type := mm_first;
                            mm_direct :
                                sel.sfp_bd_mess2_type := mm_direct;
                            mm_prev   :
                                sel.sfp_bd_mess2_type := mm_last;
                            OTHERWISE
                            END;
                        (*ENDCASE*) 
                        END;
                    e_buffer_limit: (* TS 1120770 2003-02-21 *)
                        BEGIN
                        IF  cur_res_cnt > 0 (* the buffer is large enough to store at least one row *)
                        THEN
                            BEGIN
                            trError_gg00 := e_ok;
                            IF  loop_mess2_type = mm_prev (* original was mm_prev or mm_last *)
                            THEN
                                sel.sfp_bd_mess2_type := mm_last
                            ELSE
                                sel.sfp_bd_mess2_type := mm_first
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END
                    OTHERWISE
                        sel.sfp_bd_mess2_type := loop_mess2_type;
                    END
                (*ENDCASE*) 
                END;
            (*ENDIF*) 
        UNTIL
            ((trError_gg00 <> e_ok) OR (NOT unqualified) OR
            (sel.sfp_bd_mess2_type = mm_direct))
            AND
            (trError_gg00 <> e_bd_leaf_unlocked);
        (*ENDREPEAT*) 
        IF  cur_res_cnt < sel.sfp_m_result_cnt
        THEN
            sel.sfp_m_result_cnt := cur_res_cnt;
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
IF  (sel.sfp_bd_mess2_type = mm_last) OR (sel.sfp_bd_mess2_type = mm_prev)
THEN
    t01basis_error (bi, 'qual prev er', t.trError_gg00)
ELSE
    t01basis_error (bi, 'qual next er', t.trError_gg00);
(*ENDIF*) 
t01int4 (bi, 'new page cnt', t.trRteCommPtr_gg00^.file_record_cnt);
WITH sel DO
    BEGIN
    t01p2int4 (bi, 'sfp_m_res_cn', sfp_m_result_cnt
          ,        'sfp_m_res_le', sfp_m_result_len);
    t01int4   (bi, 'sfp_res_len ', sfp_result_length);
    t01name   (bi, 'sfp_m_result:     ');
    IF  sfp_result_length < 80
    THEN
        t01moveobj (bi, init_m_result_addr^, 1, sfp_result_length)
    ELSE
        t01moveobj (bi, init_m_result_addr^, 1, 80);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  (t.trError_gg00 = e_ok) AND (recbuf_ptr <> NIL)
THEN
    t01moveobj (bi, recbuf_ptr^, 1, 80);
&endif
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    IF  ( g01vtrace.vtrStrategy_gg00 )
    THEN
        BEGIN
        res_trace.bdiTrType_gg11 := bdtrInt_egg11;
        res_trace.bdiInt_gg11[0] := sel.sfp_m_result_cnt;
        b120InsertTrace (t, bd, trace_object, sizeof (res_trace), @res_trace)
        END;
    (*ENDIF*) 
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, trace_object, sizeof (root_trace), @root_trace)
    END;
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
