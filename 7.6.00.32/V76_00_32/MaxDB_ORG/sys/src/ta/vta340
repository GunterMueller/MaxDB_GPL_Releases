/* @lastChanged: "1998-02-16 12:00"
 
 * @filename:   vta340
 * @purpose:    "TA_retrieval_output"
 * @release:    7.1.0.0
 * @see:        "-.-"
 *
 * @Copyright (c) 1998-2005 SAP AG"
 */
 
.tt 1 $SAP$LiveCache$VTA340$
.tt 3 $$TA_retrieval_output$2000-09-04$
 
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1998-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
***********************************************************
 
Module  : TA_retrieval_output
 
Define  :
 
        PROCEDURE
              t340gethandler (VAR upg : tta_user_proc_globals;
                    snd_packet   : tsp1_packet_ptr;
                    VAR ret_segm : tsp1_segment);
 
        PROCEDURE
              t340get1handler (VAR upg : tta_user_proc_globals;
                    VAR ret_segm : tsp1_segment);
 
        PROCEDURE
              t340fetchhandler (VAR upg : tta_user_proc_globals;
                    VAR ret_segm : tsp1_segment;
                    VAR org_segm : tsp1_segment;
                    sql_packet   : tsp1_packet_ptr;
                    VAR parseid  : tsp00_C12);
 
        PROCEDURE
              t340mfetchhandler (VAR upg : tta_user_proc_globals;
                    VAR ret_segm : tsp1_segment);
 
        PROCEDURE
              t340printresultcount (VAR upg : tta_user_proc_globals;
                    VAR ret_segm : tsp1_segment);
 
        PROCEDURE
              t340showresults (VAR upg : tta_user_proc_globals;
                    VAR ret_segm : tsp1_segment;
                    snd_packet   : tsp1_packet_ptr;
                    VAR parseid  : tsp00_C12);
 
        FUNCTION
              t340segmptr (VAR segm : tsp1_segment) : tsp1_segment_ptr;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              TA_driver_procedures : VTA320;
 
        PROCEDURE
              t320string_to_line (comment : tsp00_C40;
                    VAR commentline : tsp00_Line);
 
        PROCEDURE
              t320errmsg (VAR upg : tta_user_proc_globals;
                    VAR ret_segm : tsp1_segment);
 
        PROCEDURE
              t320dbcall (VAR upg   : tta_user_proc_globals;
                    sql_packet     : tsp1_packet_ptr;
                    VAR rcv_packet : tsp1_packet_ptr;
                    VAR returncode : tsp00_Int2;
                    VAR parseid    : tsp00_C12;
                    rescount       : tsp00_Int2);
 
        PROCEDURE
              t320drop_parseid (VAR upg : tta_user_proc_globals;
                    snd_packet  : tsp1_packet_ptr;
                    VAR parseid : tsp00_C12);
 
        PROCEDURE
              t320finish_part (VAR upg : tta_user_proc_globals;
                    packet_ptr : tsp1_packet_ptr;
                    VAR part   : tsp1_part);
 
        PROCEDURE
              t320GetVal (
                    VAR upg       : tta_user_proc_globals;
                    packet_ptr    : tsp1_packet_ptr;
                    VAR long_desc : tsp00_LongDescriptor;
                    VAR pData     : tsp1_part_ptr);
 
        PROCEDURE
              t320unicode2ascii (VAR upg : tta_user_proc_globals;
                    buf_size    : tsp00_Int4;
                    buf_ptr     : tsp00_MoveObjPtr;
                    VAR buf_len : tsp00_Int4);
 
        PROCEDURE
              t320buildbuffer (VAR line1 : tsp00_DataLine;
                    VAR cmd_segm : tsp1_segment);
 
        PROCEDURE
              t320resultcount_part (VAR upg : tta_user_proc_globals;
                    snd_packet : tsp1_packet_ptr;
                    VAR snd_segm : tsp1_segment;
                    result       : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        FUNCTION
              g17printable_char (c : char) : boolean;
 
        PROCEDURE
              g17int4to_line (int : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26first_segment_init (packet_ptr : tsp1_packet_ptr;
                    segm_kind                   : tsp1_segment_kind;
                    VAR first_segm_ptr          : tsp1_segment_ptr);
 
        PROCEDURE
              s26new_segment_init (packet_ptr : tsp1_packet_ptr;
                    segm_kind                 : tsp1_segment_kind;
                    VAR new_segm_ptr          : tsp1_segment_ptr;
                    VAR first_part_ptr        : tsp1_part_ptr);
 
        PROCEDURE
              s26new_part_init (packet_ptr : tsp1_packet_ptr;
                    VAR cmd_segm           : tsp1_segment;
                    VAR new_part_ptr       : tsp1_part_ptr);
 
        PROCEDURE
              s26find_part (VAR return_segm : tsp1_segment;
                    part_kind    : tsp1_part_kind;
                    VAR part_ptr : tsp1_part_ptr);
 
        FUNCTION
              s26segmptr (VAR segm : tsp1_segment) : tsp1_segment_ptr;
 
        PROCEDURE
              s26next_segment (VAR segm_ptr : tsp1_segment_ptr);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30lnr (VAR str : tsp00_KnlIdentifier;
                    val   : char;
                    start : tsp00_Int4;
                    cnt   : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30lnr_defbyte (str : tsp00_MoveObjPtr;
                    defbyte   : char;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              GET-Conversions : VSP40;
 
        PROCEDURE
              s40gbyte (VAR buf : tsp00_MoveObj;
                    pos         : tsp00_Int4;
                    len         : integer;
                    VAR dest    : tsp00_Line;
                    dpos        : tsp00_Int4;
                    dlen        : integer;
                    VAR truncated : boolean);
 
      ------------------------------ 
 
        FROM
              GETSTRING-Conversions : VSP42;
 
        PROCEDURE
              s42gstr (VAR buf : tsp00_MoveObj;
                    pos        : tsp00_Int4;
                    len        : integer;
                    frac       : integer;
                    origlen    : integer;
                    VAR dest   : tsp00_Line;
                    dpos       : tsp00_Int4;
                    VAR dlen   : integer;
                    VAR res    : tsp00_NumError);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              TA_test_procedures : VTA02;
 
        PROCEDURE
              t02buf (debug  : tut_debug;
                    VAR buf  : tsp00_LongDescriptor;
                    startpos : integer;
                    endpos   : integer);
 
        PROCEDURE
              t02int4 (layer : tut_debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t02str30 (debug : tut_debug; str30 : tsp00_C30);
&       endif
 
      ------------------------------ 
 
        FROM
              TA_terminal_IO : VTA09;
 
        PROCEDURE
              t09put (VAR term : tut_terminal;
                    VAR text : tsp00_Line; text_attr : char);
 
        PROCEDURE
              t09newscreen_page (VAR term : tut_terminal);
 
        PROCEDURE
              t09holding (VAR term : tut_terminal;
                    VAR pfkey : tut_pfkey);
 
        FUNCTION
              t09window_cols (VAR term : tut_terminal): integer;
 
        FUNCTION
              t09window_lines (VAR term : tut_terminal): integer;
 
      ------------------------------ 
 
        FROM
              TA_write_protfile : VTA12;
 
        PROCEDURE
              t12write_prot (VAR refer : tut_vf_fileref;
                    VAR ln    : tsp00_Line;
                    length    : integer;
                    VAR error : integer);
 
      ------------------------------ 
 
        FROM
              RTE_driver : VEN102;
 
        PROCEDURE
              sqlallocat (
                    length : tsp00_Int4;
                    VAR p  : tsp1_part_ptr;
                    VAR ok : boolean);
 
        PROCEDURE
              sqlfree (
                    p : tsp1_part_ptr);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              sqlallocat;
 
              tsp00_ObjAddr tsp1_part_ptr
 
        PROCEDURE
              sqlfree;
 
              tsp00_BufAddr  tsp1_part_ptr
 
        FUNCTION
              s30lnr;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              s40gbyte;
 
              tsp00_MoveObj tsp00_Line
 
        PROCEDURE
              s42gstr;
 
              tsp00_MoveObj   tsp00_Line
 
        PROCEDURE
              t09put;
 
              tsp00_C80 tsp00_Line
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ElkeZ
.sp
.cp 3
Created : 1983-01-21
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-09-04
.sp
***********************************************************
.sp
.cp 16
.fo
.oc _/1
Specification:
 
Ausgabe der durch GET oder FIND ermittelten Daten;
          Es benutzt das in vsp001 definierte (neue) Paketformat.
.fo;.cp 10
Ergebnisdarstellung:
.sp 1
.oc _/1;SELECT
Es wird die Anzahl der Ergebnisse ausgegeben:
             RESULTCOUNT:  nn
.sp;.in +6;.un 6
.oc _/1;GET
Pro Zeile wird ein Ergebnis mit zugeh?origem Feldnamen
ausgegeben:
 
      fieldname1: result1
      fieldname2: result2
         ...    :   ...
      fieldnamen: resultn
.sp;.un 6
.oc _/1;FETCH
Zusammen mit einer ?Uberschrift und einer Leerzeile werden
jeweils max. termpage-1 Zeilen ausgegeben. Gegebenenfalls k?onnen weitere
Ergebnisse  durch Ausl?osen der RETURN-Taste angefordert werden.
.nf
 
      Headerline  : fieldname 1 | fieldname 2 | fieldname n
      Spaceline   : ------------+-------------+------------
      Resultline 1: result 11   | result 21   | result n1
          :      2: result 12   | result 22   | result n2
          :              :      |   :         |    :
          :      m: result 1m   | result 2m   | result nm
 
.sp 2;.in -6
Meldungen der Terminalschnittstelle:
 
     - Enter command:
       Eingabeaufforderung.
     - SESSION END
     - INVALID COMMAND
       Kommando unbekannt.
     - INPUT REJECTED, MAXCOMMANDLENGTH EXCEEDED
       Eingabe insgesamt zu lang. Die letzte Eingabe
       verk?urzt versuchen und Kommando beenden.
     - MISSING FILENAME
       Es wurde kein Dateiname angegeben.
.sp 2
.oc _/1
2_Schnittstelle_zum_DB-System:
.fo
.sp 1
Die Benutzereingaben werden zu dba/dbs-calls gem?a?z
Anwendungsprogrammierer-Schnittstelle  aufgebaut.
Entsprechend werden Ergebnisse dem Kommunikationspuffer
entnommen.
.br
Nach einem FETCH oder GET befinden sich am Anfang des
Kommandobereiches Informationen (INFO) ?uber die Ergebnisfelder
sowie ein Z?ahler(COUNT), der die Anzahl der Ergebnisse angibt.
.sp 1
Der Aufbau ist folgenderma?zen:
.sp;.nf
  2 Byte     24 Byte             24 Byte
 -------------------------------------------
 | count | fieldinfo_1 | ... | fieldinfo_N |
 -------------------------------------------
.sp;.cp 12;.fo
wobei COUNT die Anzahl von FIELDINFOs angibt und FIELDINFO
folgendes Aussehen hat:
.sp;.nf
    18 Byte   1 Byte  1 Byte  1 Byte  1 Byte   2 Byte
 -------------------------------------------------------
 | fieldname | type | length | frac | in/out- | bufpos |
 |           |      |        |      | length  |        |
 -------------------------------------------------------
 
               00 : Fixed-Number
               01 : Float-Number
               02 : Char
               03 : Byte
               04 : Date
               05 : Time
               06 : String
               07 : virtual Float
.sp;.fo;.cp 2
LENGTH und FRAC enthalten die L?ange bzw. bei Fixed-Numberfeldern die
Anzahl der Nachkommastellen.
.br;.cp 3
IN/OUT-LENGTH gibt an, wie lang dieser Wert sein mu?z bzw. wird
(ggf. mit 00 hexadezimal bei Numbers und Blanks bei
Char-Feldern aufgef?ullt).
.br;.cp 3
Bei dem Datentyp Char wird IN/OUT-LENGTH = LENGTH+1 sein, da das
UNDEFSIGNAL-Byte die L?ange um eins erh?oht.
.br;.cp 2
Aus diesem Grund wird IN/OUT-LENGTH bei Numbers gleich der
internen Numberl?ange+1 sein.
.br;.cp 2
BUFPOS gibt die Position an, bei der
bei der Ausgabe das Ergebnis stehen wird.
.sp;.cp 4
Diese FIELDINFOs gelten f?ur alle Ausgabefelder in der
Reihenfolge ihres Auftretens. Das bedeutet, da?z ggf. ein Recordfeld
mehrmals beschrieben wird.
.CM *-END-* specification -------------------------------
.sp 2
.in
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.oc _/1
1_?Uberblick
.sp 1
Nach den Kommandos GET/FETCH werden die Ergebnisfeld-
informationen
aus dem Part2 des Auftragsblockes nach RESULTINFO ?ubernommen.
.sp 1
Bei einem FETCH-Kommando wird zun?achst festgestellt, ob die
Ergebnisfelder in eine Terminalzeile passen. Dementsprechend wird
die Ausgabe in Tabellenform durchgef?uhrt oder nicht. Es
werden Startposition und L?ange
f?ur jedes Ergebnisfeld ermittelt und in OUTINFO vermerkt.
Diese Informationen werden f?ur den Aufbau der ?Uberschrift
(HEADERBUILDER) und den Zeilenaufbau (TA34LINEBUILDER) ben?otigt.
.br
Da der Benutzer nur jeweils ein FETCH-Kommando eingibt, m?ussen
alle weiteren, bis zur Abarbeitung der Ergebnismenge, innerhalb
der Terminalschnitstelle aufgerufen werden (Procedure PAGEBUILDER).
.sp 2
.oc _/1;2_Datenstrukturen
.sp 1
RESULTINFO
.br
S?amtliche Ergebnisfeldinformationen sowie die Anzahl der
Ergebnisse werden hier vermerkt.
.sp 1
OUTINFO
.br
Hier werden nach dem ersten FETCH f?ur jedes Ergebnisfeld
Anfangsposition in der Ausgabezeile  und die L?ange eingetragen.
.sp 2
.oc _/1;3_Prozeduren
.sp 1
T340GETHANDLER
.sp 1
Zust?andig f?ur die Aufbereitung  der Ergebnisse
nach einem GET-Kommando (GET NEXT/GET DIRECT).
Es werden zun?achst die
Informationen ?uber die Ergebnisfelder beschafft (Bezeichnung,
Datentyp, L?ange und Anfangsposition im Datenteil).
.br
Anschlie?zend werde Zeilen wie folgt aufgebaut :
.br
          Name_des_Ergebnisfeldes: Ergebnis
.sp 1
F?ur die Formatierung in der Ausgabezeile wird immer die
tats?achliche L?ange im Puffer benutzt.
.sp 2
T340PUTNAME1
.sp 1
Plaziert den Namen eines Ergebnisfeldes und den Begrenzer (:)
in eine Ausgabezeile.
.sp 2
T340FETCHHANDLER
.sp 1
Zust?andig f?ur die Aufbereitung  der Ergebnisse
nach einem FETCH-Kommando.
.br
Es werden zun?achst die Informationen ?uber die Ergebnisfelder
beschafft. Aufgrund der L?angenangabe wird festgestellt, ob
die Ergebnisse in eine Terminalzeile passen.
Der Aufbau einer Terminalseite wird veranla?zt.
.sp 2
FIND_OUTPUT_LENGTH
.sp 1
Ermittelt f?ur jedes Ergebnisfeld die L?ange sowie die
Stellung in der Ausgabezeile. Diese Angaben werden in OUTINFO
vermerkt.
.sp 2
T340PAGEBUILDER
.sp 1
Nach einer ?Uberschriftszeile sowie einer Leerzeile werden die
einzelnen Ergebniszeilen mit Hilfe der Prozedur TA34LINEBUILDER
aufgebaut. Nach einer Ausgabe erfolgt jeweils ein neues
FETCH-Kommando. Dies geschieht solange, bis die Ergebnismenge
abgearbeitet ist oder der Zeilenz?ahler die Anzahl f?ur eine
Terminalseite erreicht hat.
Im letzten Fall wird die Ausgabe angehalten (Holding). Zur
Fortsetzung wird vom Benutzer ein RETURN (Returntaste) erwartet.
.sp 2
T340HEADERBUILDER
.sp 1
Aufbau der ?Uberschriftszeile mit den Namen der Ergebnisfelder.
.sp 2
T340TA34LINEBUILDER
.sp 1
Baut eine Terminalzeile nach einem FETCH auf.
.sp 2
T340PRINTRESULTCOUNT
.sp 1
Bereitet den RESULTCOUNT nach einem FIND-Kommando auf.
.sp 2
NUMBHANDLER
.sp 1
Holt Wert aus dem Kommunikationsbereich  und legt ihn
in der Ausgabezeile ab.
.sp 2
NAMELENGTH
.sp 1
Ermittelt die aktuelle L?ange eines STRINGs vom Typ NAME.
.sp 2
T340SHOW_ERGEBNISSE
.sp
Es werden die ?ubergebenen, s60maximal 18 SCREENLINEs unver?andert auf
dem Bildschirm ausgegeben. Wiederholung von SHOW FETCH bis
Result_set_exhausted.
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 20
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_showresult     = true;
      getdel           = ':' ;    (*delimiter after fieldname*)
      hyphen           = '-' ;    (* underline  FOR header *)
      table_cross      = '+' ;    (*column/space delimiter*)
      coldel           = '|' ;    (* column delimiter      *)
      mx_delimiter_ln  = 80;
      seplength        =  3;      (*space between resultcolumns*)
      result_set_exhausted  =   100;
      resultcount_msg  =
            'resultcount :                           ';
 
TYPE
 
      outinforec = RECORD
            pos    : integer; (*startpos in_outputline*)
            length : integer
      END;
 
      outinfotyp = ARRAY  [ 1..MAX_COL_PER_TAB_GG00 ]  OF outinforec;
 
 
(*------------------------------*) 
 
PROCEDURE
      ta340char_output (VAR upg : tta_user_proc_globals;
            VAR line1        : tsp00_DataLine;
            VAR data_part    : tsp1_part;
            bufpos           : tsp00_Int4;
            data_type        : tsp00_DataType;
            def_byte         : char;
            length           : tsp00_Int4;
            VAR output_needed: boolean);
 
VAR
      j          : integer;
      lcl_pos    : integer;
      lcl_length : integer;
      max_length : integer;
      finish     : boolean;
      k          : integer;
 
BEGIN
WITH data_part DO
    BEGIN
    CASE  data_type OF
        dlonga, dlonguni:
            length := 50;
        dstra, dstrb, dstruni:
            BEGIN
            IF  (* new feature 
                (upg.term_simulation = tasim_unicode) OR
                *)
                (data_type = dstruni)
            THEN
                max_length := 100
            ELSE
                max_length := 50;
            (*ENDIF*) 
            IF  length > max_length
            THEN
                length := max_length;
            (*ENDIF*) 
            END
        OTHERWISE;
        END;
    (*ENDCASE*) 
&   ifdef TRACE
    t02int4 (debug_ta, 'def_byte    ', ord (def_byte));
&   endif
    IF  (upg.swap = sw_normal) OR (def_byte <> csp_unicode_def_byte)
    THEN
        length := s30lnr_defbyte (@sp1p_buf, def_byte, bufpos, length)
    ELSE
        BEGIN
        k      := bufpos + length - 1;
        finish := false;
        WHILE (k > bufpos) AND NOT finish DO
            BEGIN
            IF  (sp1p_buf[k] <> csp_unicode_mark) OR
                (sp1p_buf[k-1] <> bsp_c1)
            THEN
                BEGIN
                length := k - bufpos + 1;
                finish := true;
                END
            ELSE
                k := k-2;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        IF  NOT finish
        THEN
            length := 0
        (*ENDIF*) 
        END;
    (*ENDIF*) 
&   ifdef TRACE
    t02int4 (debug_ta, 'length      ', length);
&   endif
    IF  length > 0
    THEN
        (* PTS 1107746 E.Z. *)
        IF  (data_type in [ dunicode, dvarcharuni, dstruni, dlonguni ]) 
        THEN
            t320unicode2ascii (upg, sp1p_buf_size,
                  @sp1p_buf[ bufpos ], length);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  line1.pos + length > LINE_MXSP00
    THEN
        BEGIN
        lcl_length:= length;
        FOR j := line1.length TO LINE_MXSP00 DO
            line1.text [ j ] := ' ';
        (*ENDFOR*) 
        t09put (upg.term^, line1.text, cut_protected);
        t12write_prot (upg.prot.refer, line1.text,
              line1.length, j);
        lcl_pos := bufpos;
        WHILE lcl_length > 0 DO
            BEGIN
            IF  lcl_length > 79
            THEN
                line1.length := 79
            ELSE
                line1.length := lcl_length;
            (*ENDIF*) 
            SAPDB_PascalForcedMove (sp1p_buf_size, sizeof(line1.text),
                  @sp1p_buf, lcl_pos, @line1.text, 1, line1.length);
            line1.pos  := 0;
            lcl_pos    := lcl_pos + line1.length;
            lcl_length := lcl_length - line1.length;
            IF  line1.length < LINE_MXSP00
            THEN
                FOR j := line1.length + 1 TO LINE_MXSP00 DO
                    line1.text [ j ] := ' ';
                (*ENDFOR*) 
            (*ENDIF*) 
            t09put (upg.term^, line1.text, cut_protected);
            t12write_prot (upg.prot.refer, line1.text,
                  line1.length, j)
            END;
        (*ENDWHILE*) 
        output_needed := false
        END
    ELSE
        BEGIN
        SAPDB_PascalForcedMove (sp1p_buf_size, sizeof(line1.text),
              @sp1p_buf, bufpos, @line1.text, line1.pos+1, length);
        line1.pos := line1.pos + length;
        IF  line1.pos > line1.length
        THEN
            line1.length := line1.pos;
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t340gethandler (VAR upg : tta_user_proc_globals;
            snd_packet   : tsp1_packet_ptr;
            VAR ret_segm : tsp1_segment);
 
VAR
      resultinfo   : tta_fields;
      is_space     : boolean;
      dummy        : integer;
      err          : integer;
      startpos     : integer;
 
BEGIN
upg.pfkey := pf_none;
ta340fill_resultinfo (upg, ret_segm, resultinfo);
is_space  :=
      resultinfo.cnt_res_fields <= (t09window_lines(upg.term^)-1) DIV 2;
t09newscreen_page (upg.term^);
t12write_prot (upg.prot.refer, upg.term^.blankline, 0, err);
startpos := 0;
dummy    := 0;
ta340result_line_oriented (upg, snd_packet, ret_segm, startpos,
      resultinfo, dummy, is_space);
t09holding (upg.term^, upg.pfkey)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t340get1handler (VAR upg : tta_user_proc_globals;
            VAR ret_segm : tsp1_segment);
 
VAR
      resultinfo     : tta_fields;
      is_space       : boolean;
      dummy          : integer;
      err            : integer;
      startpos       : integer;
 
BEGIN
ta340fill_resultinfo (upg, ret_segm, resultinfo);
is_space :=
      resultinfo.cnt_res_fields <= (t09window_lines(upg.term^)-1) DIV 2;
t09newscreen_page (upg.term^);
t12write_prot (upg.prot.refer, upg.term^.blankline, 0, err);
startpos := 0;
dummy    := 0;
ta340result_line_oriented (upg, NIL, ret_segm, startpos,
      resultinfo, dummy, is_space);
IF  upg.sqlmode = sqlm_oracle
THEN
    t340printresultcount (upg, ret_segm);
(*ENDIF*) 
t09holding (upg.term^, upg.pfkey)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta340result_line_oriented (VAR upg : tta_user_proc_globals;
            snd_packet     : tsp1_packet_ptr;
            VAR ret_segm   : tsp1_segment;
            VAR startpos   : integer;
            VAR resultinfo : tta_fields;
            VAR linecount  : integer;
            space_line     : boolean);
 
VAR
      ok              : boolean;
      long_name       : boolean;
      output_needed   : boolean;
      finish          : boolean;
      i               : integer;
      j               : integer;
      k               : integer;
      lcl_mv_len      : integer;
      lcl_pos         : integer;
      lcl_length      : integer;
      origlen         : integer;
      start_pos       : integer;
      length          : integer;
      line1           : tsp00_DataLine;
      line2           : tsp00_DataLine;
      numl            : integer;
      res             : tsp00_NumError;
      blank_id        : tsp00_KnlIdentifier;
      long_desc       : tsp00_LongDescriptor;
      data_part       : tsp1_part_ptr;
      pData           : tsp1_part_ptr;
      pSavedData      : tsp1_part_ptr;
 
LABEL
      999;
 
BEGIN
pSavedData := NIL;
&ifdef TRACE
t02str30 (debug_ta, 'ta340result_line_oriented     ');
&endif
SAPDB_PascalForcedFill (sizeof (blank_id), @blank_id, 1, sizeof (blank_id), bsp_c1);
i := 0;
s26find_part (ret_segm, sp1pk_data, data_part);
IF  data_part = NIL
THEN
    s26find_part (ret_segm, sp1pk_surrogate, data_part);
(*ENDIF*) 
IF  data_part <> NIL
THEN
    REPEAT
        line1.text    := upg.term^.blankline;
        line1.pos     := 0;
        line1.length  := 1;
        i             := succ (i);
        output_needed := true;
&       ifdef TRACE
        t02int4 (debug_ta, 'i           ', i);
        t02int4 (debug_ta, 'cnt_res_fiel', resultinfo.cnt_res_fields);
&       endif
        WITH data_part^, resultinfo, res_fieldparam[ i ] DO
            BEGIN
            putname1 (line1, res_fieldname[ i ]);
            long_name := line1.text[line1.pos] <> getdel;
            IF  long_name
            THEN
                BEGIN
                line2      := line1;
                line1.pos  := 0;
                line1.text := upg.term^.blankline;
                putshortenedname (line1, res_fieldname[ i ])
                END;
&           ifdef TRACE
            (*ENDIF*) 
            t02int4 (debug_ta, 'data_type   ', ord(sp1i_data_type));
&           endif
            line1.pos := line1.pos + 2;
            IF  line1.pos > line1.length
            THEN
                line1.length := line1.pos;
            (*ENDIF*) 
            CASE sp1i_data_type OF
                dfixed, dsmallint, dinteger :
                    numbhandler (sp1p_buf, startpos+sp1i_bufpos,
                          sp1i_length, sp1i_frac, sp1i_in_out_len, line1);
                dfloat, dvfloat :
                    BEGIN
                    IF  sp1i_in_out_len = NUMBER_MXGG04
                    THEN
                        origlen := csp_fixed
                    ELSE
                        origlen := sp1i_length;
                    (*ENDIF*) 
                    IF  sp1p_buf[ startpos+sp1i_bufpos ] = chr(0)
                    THEN
                        BEGIN
                        s42gstr (sp1p_buf, startpos+sp1i_bufpos+1,
                              sp1i_length, csp_float_frac, origlen,
                              line1.text, line1.pos+1, numl, res);
                        IF  NOT (res in [ num_ok, num_trunc ]) AND
                            (sp1i_in_out_len = NUMBER_MXGG04)
                        THEN
                            s42gstr (sp1p_buf,
                                  startpos+sp1i_bufpos+1, csp_fixed, csp_float_frac,
                                  csp_fixed, line1.text, line1.pos+1, numl, res)
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  sp1p_buf[ startpos+sp1i_bufpos ] = chr(254)
                        THEN
                            FOR j:= 1 TO sp1i_length + 6 DO
                                line1.text[ line1.pos+j ]:= '#'
                            (*ENDFOR*) 
                        ELSE
                            FOR j:= 1 TO sp1i_length + 6 DO
                                line1.text[ line1.pos+j ]:= '?';
                            (*ENDFOR*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    line1.length := line1.length + sp1i_length + 6
                    END;
                dcha, dvarchara, ddate, dtime, dtimestamp :
                    BEGIN
&                   ifdef LONGREC
                    IF  sp1i_in_out_len = 3076
                    THEN
                        output_needed := false
                    ELSE
&                       endif
                        IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_undef_byte
                        THEN
                            IF  (sp1p_buf[ startpos+sp1i_bufpos ] <> csp_ascii_blank) AND
                                NOT ((upg.term_simulation = tasim_unicode) AND
                                ( sp1p_buf[ startpos+sp1i_bufpos ] = csp_unicode_def_byte))
                            THEN
                                BEGIN
                                line1.text[ line1.pos+1 ] := 'M';
                                line1.text[ line1.pos+2 ] := 'I';
                                line1.text[ line1.pos+3 ] := 'S';
                                line1.text[ line1.pos+4 ] := 'T';
                                line1.length := line1.length + 4
                                END
                            ELSE
                                WITH resultinfo.res_fieldparam[ i ], data_part^ DO
                                    ta340char_output (upg, line1, data_part^,
                                          startpos+sp1i_bufpos+1, sp1i_data_type,
                                          sp1p_buf[ startpos+sp1i_bufpos ],
                                          sp1i_in_out_len-1,
                                          output_needed)
                                (*ENDWITH*) 
                            (*ENDIF*) 
                        ELSE
                            BEGIN
                            FOR j:= 1 TO 5 DO
                                line1.text[ line1.pos+j ]:= '?';
                            (*ENDFOR*) 
                            line1.length := line1.length + 5
                            END
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                dboolean :
                    BEGIN
&                   ifdef MAXCOLS
                    IF  sp1i_data_type = dboolean
                    THEN
                        output_needed := false;
&                   endif
                    (*ENDIF*) 
                    IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_undef_byte
                    THEN
                        IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_defined_byte
                        THEN
                            line1.text[ line1.pos+1 ]:= 'M'
                        ELSE
                            line1.text[ line1.pos+1 ] := chr (ord (
                                  sp1p_buf[startpos+sp1i_bufpos+1]) + ord('0'))
                        (*ENDIF*) 
                    ELSE
                        line1.text[ line1.pos+1 ]:= '?';
                    (*ENDIF*) 
                    line1.length := succ (line1.length)
                    END;
                (* PTS 1107746 E.Z. *)
                dunicode, dvarcharuni :
                    IF  false AND
                        ((upg.code_type < csp_unicode_swap) OR
                        (upg.term_simulation = tasim_ascii))
                    THEN
                        BEGIN
                        IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_undef_byte
                        THEN
                            IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_unicode_def_byte
                            THEN
                                BEGIN
                                line1.text[ line1.pos+1 ] := 'M';
                                line1.text[ line1.pos+2 ] := 'I';
                                line1.text[ line1.pos+3 ] := 'S';
                                line1.text[ line1.pos+4 ] := 'T';
                                line1.length := line1.length + 4
                                END
                            ELSE
                                WITH resultinfo.res_fieldparam[ i ], data_part^ DO
                                    ta340char_output (upg, line1, data_part^,
                                          startpos+sp1i_bufpos+1, sp1i_data_type,
                                          sp1p_buf[ startpos+sp1i_bufpos ],
                                          sp1i_in_out_len-1,
                                          output_needed)
                                (*ENDWITH*) 
                            (*ENDIF*) 
                        ELSE
                            BEGIN
                            FOR j:= 1 TO 5 DO
                                line1.text[ line1.pos+j ]:= '?';
                            (*ENDFOR*) 
                            line1.length := line1.length + 5
                            END
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        IF  upg.swap = sw_normal
                        THEN
                            j := s30lnr_defbyte (@sp1p_buf,
                                  sp1p_buf[ startpos+sp1i_bufpos ],
                                  startpos+sp1i_bufpos+1, sp1i_in_out_len-1)
                        ELSE
                            BEGIN
                            start_pos := startpos + sp1i_bufpos+1;
                            length    := sp1i_in_out_len-1;
                            k      := start_pos + length - 1;
                            finish := false;
                            WHILE (k > start_pos) AND NOT finish DO
                                BEGIN
                                IF  (sp1p_buf[k] <> csp_unicode_mark) OR
                                    (sp1p_buf[k-1] <> bsp_c1)
                                THEN
                                    BEGIN
                                    j := k - start_pos + 1;
                                    finish := true;
                                    END
                                ELSE
                                    k := k-2;
                                (*ENDIF*) 
                                END;
                            (*ENDWHILE*) 
                            IF  NOT finish
                            THEN
                                j := 0
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        (*IF  line1.pos+j > LINE_MXSP00
                              THEN
                              j := LINE_MXSP00-line1.pos;*)
&                       ifdef TRACE
                        t02int4 (debug_ta, 'j           ', j);
&                       endif
                        IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_undef_byte
                        THEN
                            IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_unicode_def_byte
                            THEN
                                BEGIN
                                line1.text[ line1.pos+1 ] := 'M';
                                line1.text[ line1.pos+2 ] := 'I';
                                line1.text[ line1.pos+3 ] := 'S';
                                line1.text[ line1.pos+4 ] := 'T';
                                line1.length := line1.length + 4
                                END
                            ELSE
                                ta340out_unicode (upg, line1, data_part^,
                                      startpos+sp1i_bufpos+1,
                                      sp1i_data_type, j,
                                      output_needed)
                            (*ENDIF*) 
                        ELSE
                            BEGIN
                            FOR lcl_length := 1 TO 5 DO
                                line1.text[ line1.pos+lcl_length ] := '?';
                            (*ENDFOR*) 
                            line1.length := line1.length+5
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                dchb, dvarcharb:
                    BEGIN
                    j := sp1i_length;
                    j := s30lnr_defbyte (@sp1p_buf,
                          sp1p_buf[ startpos+sp1i_bufpos ],
                          startpos+sp1i_bufpos+1, j);
                    IF  line1.pos+2*j > LINE_MXSP00
                    THEN
                        j := (LINE_MXSP00-line1.pos) DIV 2;
&                   ifdef TRACE
                    (*ENDIF*) 
                    t02int4 (debug_ta, 'j           ', j);
&                   endif
                    IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_undef_byte
                    THEN
                        IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_defined_byte
                        THEN
                            BEGIN
                            line1.text[ line1.pos+1 ] := 'M';
                            line1.text[ line1.pos+2 ] := 'I';
                            line1.text[ line1.pos+3 ] := 'S';
                            line1.text[ line1.pos+4 ] := 'T';
                            END
                        ELSE
                            s40gbyte (sp1p_buf, startpos+sp1i_bufpos+1,
                                  j, line1.text, line1.pos+1, 2*j, ok)
                        (*ENDIF*) 
                    ELSE
                        FOR lcl_length := 1 TO 2*j DO
                            line1.text[ line1.pos+lcl_length ] := '?';
                        (*ENDFOR*) 
                    (*ENDIF*) 
                    line1.length := line1.length+ 2*j
                    END;
                dstra, dstrb, dstruni, dlonga, dlonguni :
                    BEGIN
&                   ifdef trace
                    t02buf (debug_ta, long_desc, 1, sizeof(long_desc));
&                   endif
                    IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_undef_byte
                    THEN
                        BEGIN
                        SAPDB_PascalForcedMove (sp1p_buf_size, LONG_DESC_MXSP00,
                              @sp1p_buf, startpos + sp1i_bufpos + 1,
                              @long_desc, 1, LONG_DESC_MXSP00);
                        IF  long_desc.ld_valmode in
                            [ vm_datapart, vm_alldata, vm_lastdata, vm_data_trunc ]
                        THEN
                            BEGIN
                            IF  (* new feature
                                ((upg.term_simulation = tasim_unicode) AND
                                (sp1i_data_type <> dstrb))
                                OR *)
                                (sp1i_data_type = dstruni)
                                OR (sp1i_data_type = dlonguni)
                            THEN
                                BEGIN
                                j := long_desc.ld_vallen;
                                (*CASE upg.term_simulation OF
                                      tasim_unicode:*)
                                IF  long_desc.ld_vallen > 100
                                THEN
                                    j := 100;
                                (*OTHERWISE
                                      IF  long_desc.ld_vallen > 50
                                      THEN
                                      j := 50;
                                      END;*)
                                (*ENDIF*) 
                                ta340out_unicode (upg, line1,
                                      data_part^, long_desc.ld_valpos,
                                      dstruni, j, output_needed);
                                output_needed := true
                                END
                            ELSE
                                BEGIN
                                IF  long_desc.ld_vallen <= 50
                                THEN
                                    BEGIN
                                    j := long_desc.ld_vallen;
                                    SAPDB_PascalForcedMove (sp1p_buf_size, sizeof(line1.text),
                                          @sp1p_buf, long_desc.ld_valpos,
                                          @line1.text, line1.pos+1, j);
                                    line1.pos := line1.pos + j
                                    END
                                ELSE
                                    (* if long_long then *)
                                    BEGIN
                                    IF  line1.pos > line1.length
                                    THEN
                                        line1.length := line1.pos;
                                    (*ENDIF*) 
                                    t09put (upg.term^, line1.text, cut_protected);
                                    t12write_prot (upg.prot.refer,
                                          line1.text, line1.length, j);
                                    output_needed := false;
                                    ta340long_output (upg, line1, data_part^, long_desc, sp1i_data_type);
                                    END
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            (*         IF  long_desc.ld_vallen > 50
                                  THEN
                                  j := 50
                                  ELSE
                                  j := long_desc.ld_vallen;
                                  SAPDB_PascalForcedMove (sp1p_buf_size, sizeof(line1.text),
                                  sp1p_buf, long_desc.ld_valpos,
                                  line1.text, line1.pos+1, j);
                                  line1.pos := line1.pos + j
                                  END;
                                  *)
                            IF  line1.pos > line1.length
                            THEN
                                line1.length := line1.pos;
                            (*ENDIF*) 
                            END
                        ELSE
                            IF  (long_desc.ld_valmode = vm_nodata) AND (snd_packet <> NIL)
                            THEN
                                BEGIN
                                IF  pSavedData = NIL
                                THEN
                                    BEGIN
                                    sqlallocat (sizeof(tsp1_part_header) + data_part^.sp1p_buf_len, pSavedData, ok);
                                    IF  ok
                                    THEN
                                        BEGIN
                                        SAPDB_PascalForcedMove (sizeof(tsp1_part_header) + data_part^.sp1p_buf_len,
                                              sizeof(tsp1_part_header) + data_part^.sp1p_buf_len,
                                              @data_part^, 1, @pSavedData^, 1, sizeof(tsp1_part_header) + data_part^.sp1p_buf_len);
                                        data_part := pSavedData;
                                        END;
                                    (*ENDIF*) 
                                    END
                                ELSE
                                    BEGIN
&                                   ifdef TRACE
                                    t02str30 (debug_always, 'no more heap memory           ');
&                                   endif
                                    goto 999;
                                    END;
                                (*ENDIF*) 
                                long_desc.ld_intern_pos := 1;
                                long_desc.ld_infoset    := long_desc.ld_infoset + [ld_with_lock];
                                long_desc.ld_valind     := 1;
                                t320GetVal (upg, snd_packet, long_desc, pData);
                                IF  pData <> NIL
                                THEN
                                    ta340long_output (upg, line1, pData^, long_desc, sp1i_data_type);
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        FOR j:= 1 TO 5 DO
                            line1.text[ line1.pos+j ]:= '?';
                        (*ENDFOR*) 
                        line1.length:= line1.length + 5
                        END
                    (*ENDIF*) 
                    END;
                dunknown:
                    BEGIN
                    END
                END;
            (*ENDCASE*) 
            IF  output_needed
            THEN
                BEGIN
                IF  long_name
                THEN
                    WITH line2 DO
                        BEGIN
                        linecount := linecount + 1;
                        t09put (upg.term^, text, cut_protected);
                        t12write_prot (upg.prot.refer, text, pos, j)
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
                WITH line1 DO
                    BEGIN
                    t09put (upg.term^, text, cut_protected);
                    t12write_prot (upg.prot.refer, text, length, j)
                    END;
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            IF  space_line AND (i < resultinfo.cnt_res_fields)
            THEN
                t09put (upg.term^, upg.term^.blankline, cut_protected);
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    UNTIL
        (i = resultinfo.cnt_res_fields);
    (*ENDREPEAT*) 
(*ENDIF*) 
999 : ;
IF  pSavedData <> NIL
THEN
    sqlfree (pSavedData);
(*ENDIF*) 
WITH resultinfo.res_fieldparam[ resultinfo.cnt_res_fields ] DO
    startpos := startpos + sp1i_bufpos + sp1i_in_out_len - 1
(*ENDWITH*) 
END;   (*procedure_gethandler*)
 
(*------------------------------*) 
 
PROCEDURE
      ta340long_output (VAR upg : tta_user_proc_globals;
            VAR line1         : tsp00_DataLine;
            VAR data_part     : tsp1_part;
            VAR long_desc     : tsp00_LongDescriptor;
            datatype          : tsp00_DataType);
 
VAR
      dp : tsp00_Int4;
      cp : integer;
      i  : integer;
      j  : integer;
      cnt      : integer;
      start_dp : tsp00_Int4;
 
BEGIN
WITH line1, long_desc, data_part DO
    BEGIN
    text    := upg.term^.blankline;
    pos     := 23;
    length  := pos;
    text[1] := 'f';
    text[2] := 'r';
    text[3] := 'o';
    text[4] := 'm';
    text[13] := 't';
    text[14] := 'o';
    text[22] := ':';
    start_dp := ld_valpos;
    WHILE start_dp <= ld_valpos + ld_vallen - 1 DO
        BEGIN
        dp := start_dp;
        g17int4to_line (dp+1-ld_valpos, false, 6, 6, text);
        text[ pos ] := sp1p_buf[ dp ];
        dp  := succ(dp);
        cp  := pos;
        WHILE (text[cp] = sp1p_buf[ dp ]) AND
              (dp <= ld_valpos + ld_vallen - 1) DO
            dp := succ(dp);
        (*ENDWHILE*) 
        IF  (dp > succ(start_dp)) OR
            (dp > ld_valpos + ld_vallen - 1)
        THEN
            BEGIN
            g17int4to_line (dp-1+1-ld_valpos, false, 6, 16, text);
            length := pos;
            (* for LONG.vdnts - testcase and the difference of (non-) byte-swap machines *)
            IF  datatype = dstrb
            THEN
                FOR i := 1 TO line1.length DO
                    IF  line1.text[i] = chr(0)
                    THEN
                        line1.text[i] := '.';
                    (*ENDIF*) 
                (*ENDFOR*) 
            (*ENDIF*) 
            FOR j:= length+1 TO sizeof(text) DO
                text[j] := ' ';
            (*ENDFOR*) 
            t09put (upg.term^, line1.text, cut_protected);
            t12write_prot (upg.prot.refer,
                  line1.text, line1.length, j);
            start_dp := dp;
            pos     := 23;
            length  := pos;
            END
        ELSE
            BEGIN
            cnt := 1;
            WHILE (pos < sizeof(text)) AND
                  (dp <= ld_valpos + ld_vallen - 1) AND
                  (cnt > 0) DO
                BEGIN
                WHILE (cp <= pos) AND
                      (dp <= ld_valpos + ld_vallen - 1) AND
                      (text[cp] = sp1p_buf [ dp ]) DO
                    BEGIN
                    cp := succ(cp);
                    dp := succ(dp);
                    IF  cp > pos
                    THEN
                        BEGIN
                        cp := 23;
                        cnt := succ(cnt);
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWHILE*) 
                IF  cp <= pos
                THEN
                    IF  cp > 24
                    THEN
                        BEGIN
                        cnt := succ(cnt);
                        END
                    ELSE
                        BEGIN
                        dp := dp - (cp - 23);
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  (cnt = 1) AND (dp = ld_valpos + ld_vallen - 1)
                THEN
                    BEGIN
                    pos := succ(pos);
                    text[ pos ] := sp1p_buf[ dp ];
                    dp  := succ(dp);
                    END;
                (*ENDIF*) 
                IF  (cnt > 1) OR
                    (dp > ld_valpos + ld_vallen - 1) OR
                    (pos = sizeof(text))
                THEN
                    BEGIN
                    g17int4to_line (dp-1+1-ld_valpos, false, 6, 16, text);
                    length   := pos;
                    IF  datatype = dstrb
                    THEN
                        FOR i := 1 TO line1.length DO
                            IF  line1.text[i] = chr(0)
                            THEN
                                line1.text[i] := '.';
                            (*ENDIF*) 
                        (*ENDFOR*) 
                    (*ENDIF*) 
                    FOR j:= length+1 TO sizeof(text) DO
                        text[j] := ' ';
                    (*ENDFOR*) 
                    t09put (upg.term^, line1.text, cut_protected);
                    t12write_prot (upg.prot.refer,
                          line1.text, line1.length, j);
                    start_dp := dp;
                    pos      := 23;
                    length   := pos;
                    cnt      := 0;
                    END
                ELSE
                    BEGIN
                    pos := succ(pos);
                    text[ pos ] := sp1p_buf[ dp ];
                    dp  := succ(dp);
                    cp  := 23;
                    IF  pos = sizeof(text)
                    THEN
                        BEGIN
                        g17int4to_line (dp-1+1-ld_valpos, false, 6, 16, text);
                        length   := pos;
                        IF  datatype = dstrb
                        THEN
                            FOR i := 1 TO line1.length DO
                                IF  line1.text[i] = chr(0)
                                THEN
                                    line1.text[i] := '.';
                                (*ENDIF*) 
                            (*ENDFOR*) 
                        (*ENDIF*) 
                        t09put (upg.term^, line1.text, cut_protected);
                        t12write_prot (upg.prot.refer,
                              line1.text, line1.length, j);
                        start_dp := dp;
                        pos      := 23;
                        length   := pos;
                        cnt      := 0;
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            END
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    (* PTS 1105838 E.Z. *)
    text    := upg.term^.blankline;
    pos     := 8;
    length  := pos;
    text[1] := 'm';
    text[2] := 'a';
    text[3] := 'x';
    text[4] := 'l';
    text[5] := 'e';
    text[6] := 'n';
    text[7] := ':';
    start_dp := ld_valpos;
    g17int4to_line (ld_maxlen, false, 10, 9, text);
    length   := 21;
    t09put (upg.term^, line1.text, cut_protected);
    t12write_prot (upg.prot.refer,
          line1.text, line1.length, j);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta340out_unicode (VAR upg : tta_user_proc_globals;
            VAR line1         : tsp00_DataLine;
            VAR data_part     : tsp1_part;
            pos               : tsp00_Int4;
            data_type         : tsp00_DataType;
            length            : tsp00_Int4;
            VAR output_needed : boolean);
 
VAR
      k : integer;
 
BEGIN
IF  ta340isuniasc (upg, data_part.sp1p_buf, pos, length)
THEN
    ta340char_output (upg, line1, data_part,
          pos, data_type, csp_unicode_def_byte, length, output_needed)
ELSE
    BEGIN
    line1.length := line1.length+ 2*length;
    t09put (upg.term^, line1.text, cut_protected);
    t12write_prot (upg.prot.refer, line1.text, line1.length, k);
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      putshortenedname (VAR line1 : tsp00_DataLine;
            VAR text : tsp00_KnlIdentifier); (* called with part of packed rec*)
 
VAR
      i   : integer;
      len : integer;
 
BEGIN
len := NAME_MXSP00 - 3;
FOR i:= 1 TO len DO
    line1.text [ line1.pos+i ] := text [ i ];
(*ENDFOR*) 
FOR i:= 1 TO 3 DO
    line1.text [ line1.pos+len+i ] := '.';
(*ENDFOR*) 
line1.pos := line1.pos + len + 3 + 1;
line1.text [ line1.pos ] := getdel;
IF  line1.pos > line1.length
THEN
    line1.length := line1.pos
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      putname1 (VAR line1 : tsp00_DataLine;
            VAR text : tsp00_KnlIdentifier); (* called with part of packed rec*)
 
VAR
      i   : integer;
      len : integer;
 
BEGIN
len := s30lnr (text, bsp_c1, 1, sizeof (text));
&ifdef TRACE
t02int4 (debug_ta, 'len         ', ord (len));
&endif
IF  len < NAME_MXSP00
THEN
    len := NAME_MXSP00;
(*ENDIF*) 
FOR i:=1 TO len DO
    line1.text [ line1.pos+i ] := text  [ i ] ;
(*ENDFOR*) 
IF  len <= NAME_MXSP00
THEN
    BEGIN
    line1.pos := line1.pos + len + 1;
    line1.text [ line1.pos ] := getdel
    END
ELSE
    line1.pos := len;
(*ENDIF*) 
IF  line1.pos > line1.length
THEN
    line1.length := line1.pos
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t340fetchhandler (VAR upg : tta_user_proc_globals;
            VAR ret_segm : tsp1_segment;
            VAR org_segm : tsp1_segment;
            sql_packet   : tsp1_packet_ptr;
            VAR parseid  : tsp00_C12);
 
VAR
      outinfo         : outinfotyp;
      line_exceeded   : boolean;
      max_fieldlength : integer;
      resultinfo      : tta_fields;
 
BEGIN
upg.pfkey := pf_none;
upg.cnt   := 0;
ta340fill_resultinfo (upg, ret_segm, resultinfo);
ta340find_output_length (upg, resultinfo, outinfo, NOT c_showresult,
      line_exceeded, max_fieldlength);
IF  line_exceeded
THEN
    ta340output_line_oriented (upg, ret_segm, resultinfo,
          max_fieldlength, org_segm, sql_packet, parseid)
ELSE
    ta340pagebuilder (upg, ret_segm,
          outinfo, resultinfo, org_segm, sql_packet, parseid);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t340mfetchhandler (VAR upg : tta_user_proc_globals;
            VAR ret_segm : tsp1_segment);
 
VAR
      outinfo         : outinfotyp;
      line_exceeded   : boolean;
      max_fieldlength : integer;
      rescnt_part     : tsp1_part_ptr;
      data_part       : tsp1_part_ptr;
      resultinfo      : tta_fields;
 
BEGIN
upg.pfkey := pf_none;
upg.cnt   := 0;
ta340fill_resultinfo (upg, ret_segm, resultinfo);
ta340find_output_length (upg, resultinfo, outinfo, NOT c_showresult,
      line_exceeded, max_fieldlength);
s26find_part (ret_segm, sp1pk_resultcount, rescnt_part);
(* PTS 1105196 E.Z. *)
(*
      IF  upg.sqlmode = sqlm_oracle
      THEN
      *)
s26find_part (ret_segm, sp1pk_data, data_part)
      ;
(*
      ELSE
      data_part := NIL;
      *)
IF  rescnt_part <> NIL
THEN
    IF  (rescnt_part^.sp1p_buf[ 2 ] <> cgg04_zero_exponent)
        OR (ret_segm.sp1r_function_code = csp1_mselect_into_fc)
        OR ((data_part <> NIL) AND (data_part^.sp1p_arg_count > 0))
    THEN
        IF  line_exceeded
        THEN
            ta340m_output_line_oriented (upg, ret_segm,
                  resultinfo, max_fieldlength)
        ELSE
            ta340m_pagebuilder (upg, ret_segm, outinfo,
                  resultinfo)
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta340find_output_length (VAR upg : tta_user_proc_globals;
            VAR resultinfo      : tta_fields;
            VAR outinfo         : outinfotyp;
            showresult          : boolean;
            VAR line_exceeded   : boolean;
            VAR max_fieldlength : integer);
 
VAR
      namesize    : integer;
      start_pos   : integer;
      end_pos     : integer;
      i           : integer;
      window_cols : integer;
 
BEGIN
line_exceeded   := false;
start_pos       := 1;
end_pos         := 1;
max_fieldlength := 0;
window_cols     := t09window_cols (upg.term^);
FOR i := 1 TO resultinfo.cnt_res_fields DO
    BEGIN
    outinfo[ i ].pos := start_pos;
    WITH resultinfo, res_fieldparam[ i ] DO
        BEGIN
        CASE  sp1i_data_type OF
            dfixed, dsmallint, dinteger:
                IF  sp1i_in_out_len = NUMBER_MXGG04
                THEN
                    outinfo[ i ].length:= csp_fixed+6
                ELSE (*Platz fuer sum, avg *)
                    IF  sp1i_frac = 0
                    THEN
                        outinfo [ i ] .length := sp1i_length + 1
                    ELSE
                        outinfo [ i ] .length := sp1i_length + 2;
                    (*ENDIF*) 
                (*ENDIF*) 
            dboolean:
                BEGIN
&               ifdef MAXCOLS
                IF  sp1i_data_type = dboolean
                THEN
                    outinfo [ i ] .length := -1
                ELSE
&                   endif
                    IF  sp1i_length = 0
                    THEN
                        outinfo[ i ].length := 1
                    ELSE
                        outinfo[ i ].length := sp1i_length;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            dfloat, dvfloat:
                IF  sp1i_in_out_len = NUMBER_MXGG04
                THEN
                    outinfo[ i ].length := csp_fixed+6
                ELSE
                    outinfo[ i ].length := sp1i_length + 6;
                (*ENDIF*) 
            dcha, dvarchara, ddate, dtime, dtimestamp:
&               ifdef LONGREC
                IF  sp1i_length = 3075
                THEN
                    outinfo [ i ] .length := -1
                ELSE
&                   endif
                    outinfo [ i ] .length := sp1i_length;
                (*ENDIF*) 
            (* PTS 1107746 E.Z. *)
            dunicode, dvarcharuni :
                BEGIN
                IF  (showresult AND
                    (sp1i_length = sizeof (tsp00_Identifier) DIV 2))
                THEN      (* Output of SHOW and EXPLAIN should look *)
                    BEGIN (* the same, if for unicode or not.       *)
                    outinfo[ i ].length := 2*sp1i_length;
                    END
                ELSE
                    (*outinfo[ i ].length := sp1i_in_out_len-1;*)
                    (* klappt nicht, wenn nicht-ASCII-Daten drin sind *)
                    outinfo[ i ].length := sp1i_length;
                (*ENDIF*) 
                (*
                      IF  (upg.term_simulation = tasim_unicode) OR
                      (upg.term_simulation = tasim_ascii)   OR
                      (upg.code_type <= cgg_end_termsets)
                      THEN
                      outinfo[ i ].length := sp1i_length
                      ELSE
                      IF  upg.term_simulation <> tasim_unicode
                      THEN
                      sp1i_data_type := dcha;
                      *)
&               ifdef trace
                t02int4 (debug_ta, 'data_type   ', ord (sp1i_data_type));
                t02int4 (debug_ta, 'length      ', sp1i_length);
                t02int4 (debug_ta, 'in_out_len  ', sp1i_in_out_len);
                t02int4 (debug_ta, 'out.length  ', outinfo[ i ].length);
&               endif
                END;
            dchb, dvarcharb:
                outinfo[ i ].length:= 2*sp1i_length;
            dstra, dstrb, dstruni :
                outinfo[ i ].length := 50;
            dlonga, dlongb, dlonguni:
                outinfo[ i ].length := 50;
            dunknown:
                outinfo[ i ].length := 0
            END;
        (*ENDCASE*) 
        namesize := ta340namelength (res_fieldname[ i ]);
        IF  (res_fieldname[ i ] [ 1 ] = 'E') AND
            (res_fieldname[ i ] [ 2 ] = 'X') AND
            (res_fieldname[ i ] [ 3 ] = 'P') AND
            (res_fieldname[ i ] [ 4 ] = 'R') AND
            (res_fieldname[ i ] [ 5 ] in [ '1'..'9' ])
        THEN
            namesize := namesize + 6;
        (* will be filled up to EXPRESSIONx *)
        (*ENDIF*) 
        IF  (namesize > outinfo[ i ].length) AND (outinfo[ i ].length >= 0)
        THEN
            outinfo[ i ].length := namesize
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    IF  outinfo[ i ].length >= 0
    THEN
        BEGIN
        end_pos := start_pos + outinfo[ i ].length - 1;
        IF  i < resultinfo.cnt_res_fields
        THEN
            end_pos := end_pos + seplength + 1;
        (*ENDIF*) 
        line_exceeded := end_pos-1 > window_cols;
        END;
&   ifdef trace
    (*ENDIF*) 
    t02int4 (debug_ta, 'end_pos     ', end_pos);
    t02int4 (debug_ta, 'window_cols ', window_cols);
    t02int4 (debug_ta, 'line_exceede', ord (line_exceeded));
&   endif
    start_pos     := end_pos;
    IF  outinfo[ i ].length > max_fieldlength
    THEN
        max_fieldlength := outinfo[ i ].length
    (*ENDIF*) 
    END
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta340output_line_oriented (VAR upg : tta_user_proc_globals;
            VAR ret_segm    : tsp1_segment;
            VAR resultinfo  : tta_fields;
            max_fieldlength : integer;
            VAR fetch_segm  : tsp1_segment;
            snd_packet      : tsp1_packet_ptr;
            VAR parseid     : tsp00_C12);
 
VAR
      delline      : tsp00_Line;
      i            : integer;
      linecount    : integer;
      dellength    : integer;
      startpos     : integer;
      to_break     : boolean;
      ret_segm_ptr : tsp1_segment_ptr;
      rcv_packet   : tsp1_packet_ptr;
      returncode   : tsp00_Int2;
      res_cnt      : tsp00_ResNum;
      rescnt_part  : tsp1_part_ptr;
 
BEGIN
upg.pfkey := pf_none;
delline   := upg.term^.blankline;
dellength := max_fieldlength + NAME_MXSP00 + 3;
IF  dellength > mx_delimiter_ln
THEN
    dellength := mx_delimiter_ln;
(*ENDIF*) 
FOR i:=1 TO dellength DO
    delline [ i ] := hyphen;
(*ENDFOR*) 
linecount := 0;
to_break := false;
t09newscreen_page (upg.term^);
t12write_prot (upg.prot.refer, upg.term^.blankline, 0, i);
ret_segm_ptr := s26segmptr (ret_segm);
REPEAT
    startpos  := 0;
    upg.cnt   := succ (upg.cnt);
    linecount := linecount + resultinfo.cnt_res_fields + 1;
    (* +1: delimiterline *)
    ta340result_line_oriented (upg, NIL, ret_segm_ptr^, startpos,
          resultinfo, linecount, false);
    (* PTS 1107735*)
    s26find_part (ret_segm_ptr^, sp1pk_resultcount, rescnt_part);
    IF  rescnt_part <> NIL
    THEN
        res_cnt := rescnt_part^.sp1p_resnum;
    (*ENDIF*) 
    IF  (NOT upg.stop) AND (upg.pfkey = pf_none) AND
        (upg.execution = tek_pars_then_execute)
    THEN
        t320drop_parseid (upg, snd_packet, parseid);
    (*ENDIF*) 
    upg.curr_segm^.sp1s_segm_header := fetch_segm.sp1s_segm_header;
    upg.curr_segm^.sp1p_part_header := fetch_segm.sp1p_part_header;
    SAPDB_PascalForcedMove (fetch_segm.sp1p_buf_size, upg.curr_segm^.sp1p_buf_size,
          @fetch_segm.sp1p_buf, 1, @upg.curr_segm^.sp1p_buf, 1,
          fetch_segm.sp1p_buf_len);
    upg.info := false;
    t320dbcall (upg, snd_packet, rcv_packet, returncode,
          parseid, -1);
    IF  returncode <> cut_sql_req_failed
    THEN
        BEGIN
        IF  upg.more_segments = 0
        THEN
            upg.curr_ret_segm := s26segmptr(rcv_packet^.sp1_segm)
        ELSE
            BEGIN
            upg.curr_ret_segm := s26segmptr(rcv_packet^.sp1_segm);
            s26next_segment (upg.curr_ret_segm);
            END;
        (*ENDIF*) 
        ret_segm_ptr := upg.curr_ret_segm;
        END;
    (*ENDIF*) 
    IF  (returncode = 0) AND (upg.pfkey = pf_none)
    THEN
        BEGIN
        t09put (upg.term^, delline, cut_protected);
        t12write_prot (upg.prot.refer, delline, dellength, i);
        IF  linecount + resultinfo.cnt_res_fields
            >= t09window_lines (upg.term^)
        THEN
            BEGIN
            linecount := 0;
            t09holding (upg.term^, upg.pfkey);
            to_break  := upg.pfkey in [ pf_cancel, pf_end ];
            t09newscreen_page (upg.term^)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
UNTIL
    (returncode <> 0) OR upg.stop OR to_break OR (upg.pfkey <> pf_none);
(*ENDREPEAT*) 
IF  upg.pfkey = pf_none
THEN
    BEGIN
    (* PTS 1107735*)
    ta340rescnt_print (upg, res_cnt);
    IF  (returncode = result_set_exhausted) OR to_break
    THEN
        returncode:= 0
    ELSE
        IF  returncode <> cut_sql_req_failed
        THEN
            t320errmsg (upg, ret_segm_ptr^);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  NOT to_break
    THEN
        t09holding (upg.term^, upg.pfkey)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta340m_output_line_oriented (VAR upg : tta_user_proc_globals;
            VAR ret_segm    : tsp1_segment;
            VAR resultinfo  : tta_fields;
            max_fieldlength : integer);
 
VAR
      delline     : tsp00_Line;
      i           : integer;
      linecount   : integer;
      dellength   : integer;
      startpos    : integer;
      cnt         : integer;
      count       : integer;
      to_break    : boolean;
      data_part   : tsp1_part_ptr;
 
BEGIN
upg.pfkey := pf_none;
delline   := upg.term^.blankline;
dellength := max_fieldlength + NAME_MXSP00 + 3;
IF  dellength > mx_delimiter_ln
THEN
    dellength := mx_delimiter_ln;
(*ENDIF*) 
FOR i:=1 TO dellength DO
    delline [ i ] := hyphen;
(*ENDFOR*) 
linecount := 0;
to_break := false;
t09newscreen_page (upg.term^);
t12write_prot (upg.prot.refer, upg.term^.blankline, 0, i);
s26find_part (ret_segm, sp1pk_data, data_part);
IF  data_part <> NIL
THEN
    cnt := data_part^.sp1p_arg_count
ELSE
    cnt := 0;
(*ENDIF*) 
startpos := 0;
count    := 0;
REPEAT
    upg.cnt:= succ(upg.cnt);
    linecount := linecount + resultinfo.cnt_res_fields + 1;
    (* +1: delimiterline *)
    ta340result_line_oriented (upg, NIL, ret_segm, startpos,
          resultinfo, linecount, false);
    count:= succ(count);
    IF  count < cnt
    THEN
        BEGIN
        t09put (upg.term^, delline, cut_protected);
        t12write_prot (upg.prot.refer, delline, dellength, i)
        END;
    (*ENDIF*) 
    IF  linecount + resultinfo.cnt_res_fields
        >= t09window_lines (upg.term^)
    THEN
        BEGIN
        linecount := 0;
        t09holding (upg.term^, upg.pfkey);
        to_break  := upg.pfkey in [ pf_cancel, pf_end ];
        t09newscreen_page (upg.term^)
        END
    (*ENDIF*) 
UNTIL
    (count = cnt) OR to_break;
(*ENDREPEAT*) 
IF  upg.sqlmode = sqlm_oracle
THEN
    t340printresultcount (upg, ret_segm);
(*ENDIF*) 
IF  NOT to_break
THEN
    t09holding (upg.term^, upg.pfkey)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta340pagebuilder (VAR upg : tta_user_proc_globals;
            VAR ret_segm   : tsp1_segment;
            VAR outinfo    : outinfotyp;
            VAR resultinfo : tta_fields;
            VAR fetch_segm : tsp1_segment;
            snd_packet     : tsp1_packet_ptr;
            VAR parseid    : tsp00_C12);
 
VAR
      outline      : tsp00_DataLine;
      header       : tsp00_DataLine;
      delline      : tsp00_Line;
      to_break     : boolean;
      i            : integer;
      linecount    : integer;
      startpos     : integer;
      data_part    : tsp1_part_ptr;
      rcv_packet   : tsp1_packet_ptr;
      ret_segm_ptr : tsp1_segment_ptr;
      returncode   : tsp00_Int2;
      res_cnt      : tsp00_ResNum;
      rescnt_part  : tsp1_part_ptr;
 
BEGIN
upg.pfkey := pf_none;
to_break  := false;
headerbuilder (upg, outinfo, resultinfo, header, delline);
ret_segm_ptr := s26segmptr (ret_segm);
REPEAT
    t09newscreen_page (upg.term^);
    t09put (upg.term^, header.text, cut_protected);
    t09put (upg.term^, delline, cut_protected);
    t12write_prot (upg.prot.refer, upg.term^.blankline, 0, i);
    t12write_prot (upg.prot.refer, header.text, header.length, i);
    t12write_prot (upg.prot.refer, delline, header.length, i);
    linecount := 2;
    REPEAT
        upg.cnt   := succ(upg.cnt);
        startpos  := 0;
        linecount := succ(linecount);
        (* PTS 1107735*)
        s26find_part (ret_segm_ptr^, sp1pk_data, data_part);
        IF  data_part <> NIL
        THEN
            ta340linebuilder (upg, data_part,
                  startpos, outinfo, resultinfo, outline);
        (*ENDIF*) 
        t09put (upg.term^, outline.text, cut_protected);
        t12write_prot (upg.prot.refer, outline.text, outline.length, i);
        s26find_part (ret_segm_ptr^, sp1pk_resultcount, rescnt_part);
        IF  rescnt_part <> NIL
        THEN
            res_cnt := rescnt_part^.sp1p_resnum;
        (*ENDIF*) 
        IF  (NOT upg.stop) AND (upg.pfkey = pf_none) AND
            (upg.execution = tek_pars_then_execute)
        THEN
            t320drop_parseid (upg, snd_packet, parseid);
        (*ENDIF*) 
        upg.curr_segm^.sp1s_segm_header := fetch_segm.sp1s_segm_header;
        upg.curr_segm^.sp1p_part_header := fetch_segm.sp1p_part_header;
        SAPDB_PascalForcedMove (fetch_segm.sp1p_buf_size, upg.curr_segm^.sp1p_buf_size,
              @fetch_segm.sp1p_buf, 1, @upg.curr_segm^.sp1p_buf, 1,
              fetch_segm.sp1p_buf_len);
        t320dbcall (upg, snd_packet, rcv_packet, returncode,
              parseid, -1);
        IF  returncode <> cut_sql_req_failed
        THEN
            BEGIN
            IF  upg.more_segments = 0
            THEN
                upg.curr_ret_segm := s26segmptr(rcv_packet^.sp1_segm)
            ELSE
                BEGIN
                upg.curr_ret_segm := s26segmptr(rcv_packet^.sp1_segm);
                s26next_segment (upg.curr_ret_segm);
                END;
            (*ENDIF*) 
            ret_segm_ptr := upg.curr_ret_segm;
            END;
        (*ENDIF*) 
    UNTIL
        (returncode <> 0) OR upg.stop
        OR (linecount >= t09window_lines (upg.term^))
        OR (upg.pfkey <> pf_none);
    (*ENDREPEAT*) 
    IF  (returncode = 0) AND (upg.pfkey = pf_none)
    THEN
        BEGIN
        t09holding (upg.term^, upg.pfkey);
        to_break := upg.pfkey in [ pf_cancel, pf_end ]
        END
    (*ENDIF*) 
UNTIL
    (returncode <> 0) OR to_break OR (upg.pfkey <> pf_none);
(*ENDREPEAT*) 
IF  upg.pfkey = pf_none
THEN
    BEGIN
    (* PTS 1107735*)
    ta340rescnt_print (upg, res_cnt);
    IF  (returncode = result_set_exhausted) OR to_break
    THEN
        returncode:= 0
    ELSE
        t320errmsg (upg, ret_segm_ptr^);
    (*ENDIF*) 
    IF  NOT to_break
    THEN
        t09holding (upg.term^, upg.pfkey)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta340m_pagebuilder (VAR upg : tta_user_proc_globals;
            VAR ret_segm   : tsp1_segment;
            VAR outinfo    : outinfotyp;
            VAR resultinfo : tta_fields);
 
VAR
      outline     : tsp00_DataLine;
      header      : tsp00_DataLine;
      delline     : tsp00_Line;
      to_break    : boolean;
      i           : integer;
      linecount   : integer;
      startpos    : integer;
      cnt         : integer;
      count       : integer;
      data_part   : tsp1_part_ptr;
 
BEGIN
upg.pfkey := pf_none;
to_break  := false;
headerbuilder (upg, outinfo, resultinfo, header, delline);
count     := 0;
startpos  := 0;
s26find_part (ret_segm, sp1pk_data, data_part);
IF  data_part <> NIL
THEN
    cnt := data_part^.sp1p_arg_count;
(*ENDIF*) 
IF  cnt > 0
THEN
    BEGIN
    REPEAT
        t09newscreen_page (upg.term^);
        t09put (upg.term^, header.text, cut_protected);
        t09put (upg.term^, delline, cut_protected);
        t12write_prot (upg.prot.refer, upg.term^.blankline, 0, i);
        t12write_prot (upg.prot.refer, header.text, header.length, i);
        t12write_prot (upg.prot.refer, delline, header.length, i);
        linecount := 2;
        REPEAT
            upg.cnt   := succ (upg.cnt);
            linecount := succ (linecount);
            ta340linebuilder (upg, data_part,
                  startpos, outinfo, resultinfo, outline);
            count     := succ (count);
            t09put (upg.term^, outline.text, cut_protected);
            t12write_prot (upg.prot.refer, outline.text, outline.length, i);
        UNTIL
            (count = cnt)
            OR (linecount >= t09window_lines (upg.term^));
        (*ENDREPEAT*) 
        t09holding (upg.term^, upg.pfkey);
        to_break := upg.pfkey in [ pf_cancel, pf_end ]
    UNTIL
        (count = cnt) OR to_break;
    (*ENDREPEAT*) 
    IF  upg.sqlmode = sqlm_oracle
    THEN
        t340printresultcount (upg, ret_segm)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      headerbuilder (VAR upg : tta_user_proc_globals;
            VAR outinfo      : outinfotyp;
            VAR resultinfo   : tta_fields;
            VAR header       : tsp00_DataLine;
            VAR delline      : tsp00_Line);
 
VAR
      i   : integer;
      j   : integer;
      col : tsp00_KnlIdentifier;
 
BEGIN
header.text   := upg.term^.blankline;
header.pos    := 0;
header.length := 1;
FOR i:=1 TO LINE_MXSP00 DO
    delline [ i ] := hyphen;
(*ENDFOR*) 
i := 0;
REPEAT
    i := succ (i);
    WITH resultinfo, res_fieldparam[ i ] ,outinfo [ i ]  DO
        IF  length >= 0
        THEN
            BEGIN
            col:= res_fieldname[ i ];
            FOR j:=1 TO ta340namelength(col) DO
                IF  pos + j - 1 <= sizeof (header.text)
                THEN
                    header.text [ pos + j - 1 ]  := col[ j ] ;
                (*ENDIF*) 
            (*ENDFOR*) 
            header.pos   := pos + length - 1;
            IF  (i < resultinfo.cnt_res_fields) AND
                (header.pos < sizeof (header.text))
            THEN
                BEGIN
                j := seplength DIV 2;
                header.pos := header.pos + seplength;
                header.text [ header.pos-j ]  := coldel;
                delline [ header.pos-j ] := table_cross
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDWITH*) 
UNTIL
    (i = resultinfo.cnt_res_fields);
(*ENDREPEAT*) 
header.length := header.pos;
FOR i:= header.length+1 TO LINE_MXSP00 DO
    delline [ i ] := ' '
(*ENDFOR*) 
END;   (*procedure_headerbuilder*)
 
(*------------------------------*) 
 
PROCEDURE
      ta340linebuilder (VAR upg   : tta_user_proc_globals;
            data_part        : tsp1_part_ptr;
            VAR startpos     : tsp00_Int4;
            VAR outinfo      : outinfotyp;
            VAR resultinfo   : tta_fields;
            VAR outline      : tsp00_DataLine);
 
VAR
      i               : integer;
      j               : integer;
      origlen         : integer;
      ok              : boolean;
      numl            : integer;
      res             : tsp00_NumError;
      uni_length      : tsp00_Int4;
      long_desc       : tsp00_LongDescriptor;
      output_needed   : boolean;
 
BEGIN
i := 0;
outline.text   := upg.term^.blankline;
outline.pos    := 0;
outline.length := 1;
REPEAT
    i := succ(i);
    IF  outinfo [ i ].length >= 0
    THEN
        BEGIN
        WITH data_part^, outinfo [ i ], resultinfo, res_fieldparam[ i ]  DO
            BEGIN
            outline.pos := pos - 1;
            IF  outline.pos > outline.length
            THEN
                outline.length := outline.pos;
            (*ENDIF*) 
            CASE sp1i_data_type OF
                dfixed, dsmallint, dinteger :
                    numbhandler (sp1p_buf, startpos+sp1i_bufpos,
                          sp1i_length, sp1i_frac, sp1i_in_out_len, outline);
                dfloat, dvfloat :
                    BEGIN
                    IF  sp1p_buf[ startpos+sp1i_bufpos ] = chr(0)
                    THEN
                        BEGIN
                        IF  sp1i_in_out_len = NUMBER_MXGG04
                        THEN
                            origlen := csp_fixed
                        ELSE
                            origlen := sp1i_length;
                        (*ENDIF*) 
                        s42gstr (sp1p_buf, startpos+sp1i_bufpos+1,
                              sp1i_length, csp_float_frac, origlen, outline.text,
                              outline.pos+1, numl, res);
                        IF  NOT (res in [ num_ok, num_trunc ]) AND
                            (sp1i_in_out_len = NUMBER_MXGG04)
                        THEN
                            s42gstr (sp1p_buf, startpos+sp1i_bufpos+1,
                                  csp_fixed, csp_float_frac, csp_fixed,
                                  outline.text, outline.pos+1, numl, res)
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  sp1p_buf[ startpos+sp1i_bufpos ] = chr(254)
                        THEN
                            FOR j:= 1 TO outinfo[ i ].length DO
                                outline.text[ outline.pos+j ]:= '#'
                            (*ENDFOR*) 
                        ELSE
                            FOR j:= 1 TO outinfo[ i ].length DO
                                outline.text[ outline.pos+j ]:= '?';
                            (*ENDFOR*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    outline.length:= outline.length+outinfo[ i ].length
                    END;
                dcha, dvarchara, ddate, dtime, dtimestamp :
                    BEGIN
                    IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_undef_byte
                    THEN
                        IF  (sp1p_buf[ startpos+sp1i_bufpos ] <> csp_ascii_blank) AND
                            NOT ((upg.term_simulation = tasim_unicode) AND
                            ( sp1p_buf[ startpos+sp1i_bufpos ] = csp_unicode_def_byte))
                        THEN
                            BEGIN
                            outline.text[ outline.pos+1 ] := 'M';
                            outline.text[ outline.pos+2 ] := 'I';
                            outline.text[ outline.pos+3 ] := 'S';
                            outline.text[ outline.pos+4 ] := 'T';
                            outline.length := outline.length + 4
                            END
                        ELSE
                            BEGIN
                            j := sp1i_length;
                            IF  outline.pos + j > LINE_MXSP00
                            THEN
                                j := LINE_MXSP00 - outline.pos;
                            (*ENDIF*) 
                                SAPDB_PascalForcedMove (sp1p_buf_size, sizeof(outline.text),
                                      @sp1p_buf, startpos+sp1i_bufpos+1,
                                      @outline.text, outline.pos+1, j);
                            (*ENDIF*) 
                            outline.pos := outline.pos + j;
                            IF  outline.pos > outline.length
                            THEN
                                outline.length := outline.pos;
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                    ELSE
                        BEGIN
                        FOR j:= 1 TO outinfo[ i ].length DO
                            outline.text[ outline.pos+j ]:= '?';
                        (*ENDFOR*) 
                        outline.length:= outline.length + outinfo[ i ].length
                        END
                    (*ENDIF*) 
                    END;
                dboolean :
                    BEGIN
                    IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_undef_byte
                    THEN
                        IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_defined_byte
                        THEN
                            outline.text[ outline.pos+1 ]:= 'M'
                        ELSE
                            outline.text[ outline.pos+1 ] :=
                                  chr(ord(sp1p_buf[startpos+sp1i_bufpos+1]) + ord('0'))
                        (*ENDIF*) 
                    ELSE
                        outline.text[ outline.pos+1 ]:= '?';
                    (*ENDIF*) 
                    outline.length := succ (outline.length)
                    END;
                dchb, dvarcharb :
                    BEGIN
                    IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_undef_byte
                    THEN
                        IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_defined_byte
                        THEN
                            BEGIN
                            outline.text[ outline.pos+1 ] := 'M';
                            outline.text[ outline.pos+2 ] := 'I';
                            outline.text[ outline.pos+3 ] := 'S';
                            outline.text[ outline.pos+4 ] := 'T';
                            END
                        ELSE
                            s40gbyte (sp1p_buf, startpos+sp1i_bufpos+1,
                                  sp1i_length, outline.text, outline.pos+1,
                                  2*sp1i_length, ok)
                        (*ENDIF*) 
                    ELSE
                        FOR j:= 1 TO outinfo[ i ].length DO
                            outline.text[ outline.pos+j ]:= '?';
                        (*ENDFOR*) 
                    (*ENDIF*) 
                    outline.length := outline.length + outinfo[ i ].length
                    END;
                (* PTS 1107746 E.Z. *)
                dunicode, dvarcharuni :
                    BEGIN
                    IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_undef_byte
                    THEN
                        IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_unicode_def_byte
                        THEN
                            BEGIN
                            outline.text[ outline.pos+1 ] := 'M';
                            outline.text[ outline.pos+2 ] := 'I';
                            outline.text[ outline.pos+3 ] := 'S';
                            outline.text[ outline.pos+4 ] := 'T';
                            outline.length := outline.length + 4
                            END
                        ELSE
                            IF  true
                                (* upg.term_simulation = tasim_unicode*)
                            THEN
                                BEGIN
                                uni_length := 2 * sp1i_length;
                                t320unicode2ascii (upg, sp1p_buf_size,
                                      @sp1p_buf[ startpos+sp1i_bufpos+1 ],
                                      uni_length);
                                SAPDB_PascalForcedMove (sp1p_buf_size, sizeof(outline.text),
                                      @sp1p_buf, startpos+sp1i_bufpos+1,
                                      @outline.text, outline.pos+1, uni_length)
                                END
                            ELSE
                                s40gbyte (sp1p_buf, startpos+sp1i_bufpos+1,
                                      sp1i_in_out_len-1, outline.text, outline.pos+1,
                                      2*(sp1i_in_out_len-1), ok)
                            (*ENDIF*) 
                        (*ENDIF*) 
                    ELSE
                        FOR j:= 1 TO outinfo[ i ].length DO
                            outline.text[ outline.pos+j ]:= '?';
                        (*ENDFOR*) 
                    (*ENDIF*) 
                    outline.length := outline.length + outinfo[ i ].length
                    END;
                dstra, dstrb, dstruni, dlonga, dlonguni:
                    BEGIN
&                   ifdef TRACE
                    t02int4 (debug_ta, 'startpos    ', startpos);
                    t02int4 (debug_ta, 'sp1i_bufpos ', sp1i_bufpos);
&                   endif
                    IF  sp1p_buf[ startpos+sp1i_bufpos ] <> csp_undef_byte
                    THEN
                        BEGIN
                        SAPDB_PascalForcedMove (sp1p_buf_size, LONG_DESC_MXSP00,
                              @sp1p_buf, startpos + sp1i_bufpos + 1,
                              @long_desc, 1, LONG_DESC_MXSP00);
                        IF  long_desc.ld_valmode in
                            [ vm_datapart, vm_alldata, vm_lastdata, vm_data_trunc ]
                        THEN
                            BEGIN
                            IF  (* new feature
                                (upg.term_simulation = tasim_unicode)
                                OR *)
                                (sp1i_data_type = dstruni)
                                OR (sp1i_data_type = dlonguni)
                            THEN
                                BEGIN
                                IF  long_desc.ld_vallen > 100
                                THEN
                                    j := 100
                                ELSE
                                    j := long_desc.ld_vallen;
                                (*ENDIF*) 
                                ta340out_unicode (upg, outline, data_part^,
                                      long_desc.ld_valpos,
                                      dstruni, j, output_needed)
                                END
                            ELSE
                                BEGIN
                                IF  long_desc.ld_vallen > 50
                                THEN
                                    j := 50
                                ELSE
                                    j := long_desc.ld_vallen;
                                (*ENDIF*) 
                                SAPDB_PascalForcedMove (sp1p_buf_size, sizeof(outline.text),
                                      @sp1p_buf, long_desc.ld_valpos,
                                      @outline.text, outline.pos+1, j)
                                END;
                            (*ENDIF*) 
                            outline.pos := outline.pos + 50;
                            IF  outline.pos > outline.length
                            THEN
                                outline.length := outline.pos;
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        FOR j:= 1 TO outinfo[ i ].length DO
                            outline.text[ outline.pos+j ]:= '?';
                        (*ENDFOR*) 
                        outline.length:= outline.length + outinfo[ i ].length
                        END
                    (*ENDIF*) 
                    END;
                dunknown:
                    BEGIN
                    END
                END
            (*ENDCASE*) 
            END;
        (*ENDWITH*) 
        IF  i < resultinfo.cnt_res_fields
        THEN
            BEGIN
            j := seplength DIV 2;
            outline.pos := outinfo[ i+1 ].pos-2-j;
            IF  outline.pos > outline.length
            THEN
                outline.length := outline.pos;
            (*ENDIF*) 
            IF  outline.pos <= sizeof (outline.text)
            THEN
                outline.text [ outline.pos+1 ] := coldel;
            (*ENDIF*) 
            outline.pos := outinfo[ i+1 ].pos-1;
            IF  outline.pos > outline.length
            THEN
                outline.length := outline.pos
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
UNTIL
    (i >= resultinfo.cnt_res_fields) OR
    (outline.pos > sizeof (outline.text));
(*ENDREPEAT*) 
WITH resultinfo.res_fieldparam[ resultinfo.cnt_res_fields ] DO
    startpos := startpos + sp1i_bufpos + sp1i_in_out_len - 1
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t340printresultcount (VAR upg : tta_user_proc_globals;
            VAR ret_segm : tsp1_segment);
 
CONST
      n_delete          = 'DELETE      ';
 
VAR
      rescnt_part : tsp1_part_ptr;
 
BEGIN
s26find_part (ret_segm, sp1pk_resultcount, rescnt_part);
IF  (rescnt_part <> NIL) AND (ret_segm.sp1r_returncode = 0)
THEN
    BEGIN
    ta340rescnt_print (upg, rescnt_part^.sp1p_resnum);
    END
(*ENDIF*) 
END; (*procedure_printresult*)
 
(*------------------------------*) 
 
PROCEDURE
      ta340rescnt_print (VAR upg : tta_user_proc_globals;
            VAR res_cnt : tsp00_ResNum);
 
VAR
      numl    : integer;
      i       : integer;
      ln      : tsp00_Line;
      res     : tsp00_NumError;
      ptr     : tsp00_MoveObjPtr;
 
BEGIN
upg.pfkey := pf_none;
t320string_to_line (resultcount_msg, ln);
(* Since there exists only one version of s42gstr, *)
(* we have to cast the res_cnt to a moveobject.    *)
ptr := @res_cnt;
s42gstr (ptr^, 2, csp_resnum_deflen, 0, csp_resnum_deflen,
      ln, 25, numl, res);
IF  ln[ 34 ] = '-'
THEN
    BEGIN
    ln[ 29 ]:= 'u';
    ln[ 30 ]:= 'n';
    ln[ 31 ]:= 'k';
    ln[ 32 ]:= 'n';
    ln[ 33 ]:= 'o';
    ln[ 34 ]:= 'w';
    ln[ 35 ]:= 'n'
    END;
(*ENDIF*) 
t09put (upg.term^, upg.term^.blankline, cut_protected);
t09put (upg.term^, ln, cut_protected);
t12write_prot (upg.prot.refer, upg.term^.blankline, 0, i);
t12write_prot (upg.prot.refer, ln, 24+numl, i);
t09holding (upg.term^, upg.pfkey)
END;
 
(*------------------------------*) 
 
PROCEDURE
      numbhandler (VAR buf : tsp00_MoveObj;
            pos       : integer;
            n         : integer;
            m         : integer;
            in_out_l  : integer;
            VAR line1 : tsp00_DataLine);
 
VAR
      numl    : integer;
      num     : tsp00_NumStr;
      i       : integer;
      origlen : integer;
      res     : tsp00_NumError;
 
BEGIN
IF  buf[ pos ] = csp_undef_byte
THEN
    BEGIN
    SAPDB_PascalForcedFill (sizeof (num), @num, 1, sizeof (num), '?');
    IF  m = 0
    THEN
        numl:= n+1
    ELSE
        numl:= n+2;
    (*ENDIF*) 
    FOR i := 1 TO numl DO
        line1.text [ line1.pos+i ] := num [ i ];
    (*ENDFOR*) 
    END
ELSE
    IF  buf[ pos ] = csp_oflw_byte
    THEN
        BEGIN
        SAPDB_PascalForcedFill (sizeof (num), @num, 1, sizeof (num), '#');
        IF  m = 0
        THEN
            numl:= n+1
        ELSE
            numl:= n+2;
        (*ENDIF*) 
        FOR i := 1 TO numl DO
            line1.text [ line1.pos+i ] := num [ i ];
        (*ENDFOR*) 
        END
    ELSE
        BEGIN
        IF  in_out_l = NUMBER_MXGG04
        THEN
            origlen := csp_fixed
        ELSE
            origlen := n;
        (*ENDIF*) 
        s42gstr (buf, pos+1, n, m, origlen, line1.text, line1.pos+1,
              numl, res);
        IF  NOT (res in [ num_ok, num_trunc ]) AND (in_out_l = NUMBER_MXGG04)
        THEN
            s42gstr (buf, pos+1, csp_fixed, csp_float_frac, csp_fixed,
                  line1.text, line1.pos+1, numl, res);
        (*ENDIF*) 
        IF  res <> num_ok
        THEN
            BEGIN
            line1.text[ line1.pos+1 ] := 'M';
            line1.text[ line1.pos+2 ] := 'I';
            line1.text[ line1.pos+3 ] := 'S';
            line1.text[ line1.pos+4 ] := 'T'
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
line1.pos := line1.pos + numl;
IF  line1.pos > line1.length
THEN
    line1.length := line1.pos;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ta340namelength (vstring: tsp00_KnlIdentifier) : integer;
      (* vstring may not be VAR, because called with part of packed record*)
 
BEGIN
ta340namelength := s30lnr (vstring, bsp_c1, 1, sizeof (vstring));
END;
 
(*------------------------------*) 
 
PROCEDURE
      t340showresults (VAR upg : tta_user_proc_globals;
            VAR ret_segm   : tsp1_segment;
            snd_packet     : tsp1_packet_ptr;
            VAR parseid    : tsp00_C12);
 
CONST
      n_invisible =
            'INVISIBLE                                                       ';
      c_exit_loop = MAX_INT2_SP00;
 
VAR
      line_exceeded   : boolean;
      is_explain      : boolean;
      finish          : boolean;
      sequence_explain: boolean;
      max_fieldlength : integer;
      i               : integer;
      j               : integer;
      k               : integer;
      maxunicode_cols : integer;
      sh_fetch        : tsp00_C20;
      cnt             : tsp00_Int4;
      startpos        : tsp00_Int4;
      start_pos       : tsp00_Int4;
      length          : tsp00_Int4;
      delta           : integer;
      ergnam          : tsp00_KnlIdentifier;
      ergnam_len      : tsp00_Int4;
      outinfo         : outinfotyp;
      resultinfo      : tta_fields;
      fetch_segm      : tsp1_segment_ptr;
      fetch_segm_buf  : tsp00_Buf8K;
      rcv_packet      : tsp1_packet_ptr;
      cmd_segm        : tsp1_segment_ptr;
      cmd_part        : tsp1_part_ptr;
      data_part       : tsp1_part_ptr;
      resname_part    : tsp1_part_ptr;
      returncode      : tsp00_Int2;
      in_line         : tsp00_DataLine;
      c40             : tsp00_C40;
 
BEGIN
SAPDB_PascalForcedFill (sizeof (ergnam), @ergnam, 1, sizeof (ergnam), bsp_c1);
upg.pfkey    := pf_none;
upg.cnt      := 0;
upg.inlength := 0;
ta340fill_resultinfo (upg, ret_segm, resultinfo);
ta340find_output_length (upg, resultinfo, outinfo, c_showresult,
      line_exceeded, max_fieldlength);
s26find_part (ret_segm, sp1pk_resulttablename, resname_part);
IF  resname_part <> NIL
THEN
    WITH resname_part^ DO
        BEGIN
        ergnam_len := sp1p_buf_len;
        SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (ergnam),
              @sp1p_buf, 1, @ergnam, 1, ergnam_len);
        IF  upg.term_simulation = tasim_unicode
        THEN
            t320unicode2ascii (upg, sizeof (ergnam),
                  @ergnam, ergnam_len)
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  (resname_part <> NIL) AND (ergnam <> n_invisible)
THEN
    BEGIN
    IF  (NOT upg.stop) AND (upg.pfkey = pf_none) AND
        (upg.execution = tek_pars_then_execute)
    THEN
        t320drop_parseid (upg, snd_packet, parseid);
    (*ENDIF*) 
    s26first_segment_init (snd_packet, sp1sk_cmd, cmd_segm);
    s26new_part_init (snd_packet, cmd_segm^, cmd_part);
    cmd_part^.sp1p_part_kind := sp1pk_command;
    maxunicode_cols := 3;
    is_explain := upg.first_token = 'EXPLAIN     ';
    sequence_explain := is_explain AND
          (upg.second_token = 'SEQUENCE    ');
    IF  sequence_explain
    THEN
        maxunicode_cols := 1;
    (*ENDIF*) 
    IF  (upg.more_segments > 0) AND (upg.is_connected)
    THEN
        BEGIN
        c40 := 'SELECT ''abc''||''def''INTO :a FROM DUAL    ';
        SAPDB_PascalForcedMove (sizeof(c40), sizeof(tsp00_Line),
              @c40, 1, @in_line.text, 1, sizeof(c40));
        in_line.pos    := 38;
        in_line.length := 38;
        t320buildbuffer (in_line, cmd_segm^);
        t320finish_part (upg, snd_packet, cmd_part^);
        cmd_segm^.sp1c_with_info := true;
        s26new_segment_init (snd_packet, sp1sk_cmd, cmd_segm, cmd_part);
        upg.curr_segm := cmd_segm;
        s26new_part_init (snd_packet, cmd_segm^, cmd_part);
        cmd_part^.sp1p_part_kind := sp1pk_command;
&       ifdef TRACE
        (*
              t02int4   (debug_ta, 'REQUEST: ref', upg.reference);
              IF  t02trace (debug_ta)
              THEN
              x05packet (upg.term^, upg.prot.refer, t02is_minbuf,
              t02buflength_max,
              'TESTOUTPUT  ', snd_packet);
              *)
&       endif
        END;
    (*ENDIF*) 
    sh_fetch  := 'FETCH   INTO   :X,:Y';
    FOR i:= 1 TO 6 DO
        cmd_part^.sp1p_buf[ i ]:= sh_fetch[ i ];
    (*ENDFOR*) 
    FOR i:= 1 TO sizeof (ergnam) DO
        cmd_part^.sp1p_buf[ 6+i ]:= ergnam[ i ];
    (*ENDFOR*) 
    FOR i:= 8 TO 17 DO
        cmd_part^.sp1p_buf[ sizeof (ergnam)-1 + i ]:= sh_fetch[ i ];
    (*ENDFOR*) 
    cmd_part^.sp1p_buf_len := 16+sizeof (ergnam);
    IF  is_explain
    THEN
        BEGIN
        FOR j := 0 TO 8 DO
            FOR i := 1 TO 3 DO
                cmd_part^.sp1p_buf[ sizeof (ergnam)-1 + 17 + j*3 + i ]:=
                      sh_fetch[ 17+i ];
            (*ENDFOR*) 
        (*ENDFOR*) 
        cmd_part^.sp1p_buf_len := cmd_part^.sp1p_buf_len + 9*3;
        END;
    (*ENDIF*) 
    t320finish_part (upg, snd_packet, cmd_part^);
    fetch_segm := @fetch_segm_buf;
    fetch_segm^.sp1s_segm_header := cmd_segm^.sp1s_segm_header;
    fetch_segm^.sp1p_part_header := cmd_segm^.sp1p_part_header;
    SAPDB_PascalForcedMove (cmd_segm^.sp1p_buf_size, fetch_segm^.sp1p_buf_size,
          @cmd_segm^.sp1p_buf, 1, @fetch_segm^.sp1p_buf, 1,
          cmd_segm^.sp1p_buf_len);
    IF  is_explain
    THEN
        BEGIN (* use mfetch *)
        cmd_segm^.sp1c_mass_cmd := true;
        t320resultcount_part (upg, snd_packet,
              cmd_segm^, 300)
        END;
    (*ENDIF*) 
    t320dbcall (upg, snd_packet, rcv_packet, returncode, parseid, 300);
    IF  upg.pfkey = pf_none
    THEN
        IF  returncode = 0
        THEN
            BEGIN
            IF  is_explain
            THEN
                BEGIN
                s26find_part (upg.curr_ret_segm^, sp1pk_data, data_part);
                IF  data_part <> NIL
                THEN
                    BEGIN
                    cnt      := 1;
                    startpos := 0;
                    WHILE cnt <= data_part^.sp1p_arg_count DO
                        BEGIN
                        FOR i := 1 TO maxunicode_cols DO
                            WITH resultinfo.res_fieldparam[i] DO
                                BEGIN
                                IF  (upg.swap = sw_normal) OR
                                    (data_part^.sp1p_buf[startpos+sp1i_bufpos]
                                    <> csp_unicode_def_byte)
                                THEN
                                    j := s30lnr_defbyte (
                                          @data_part^.sp1p_buf[startpos+sp1i_bufpos],
                                          data_part^.sp1p_buf[startpos+sp1i_bufpos],
                                          2, sp1i_in_out_len-1)
                                ELSE
                                    BEGIN
                                    start_pos := startpos + sp1i_bufpos+1;
                                    length    := sp1i_in_out_len-1;
                                    k      := start_pos + length - 1;
                                    finish := false;
                                    WHILE (k > start_pos) AND NOT finish DO
                                        BEGIN
                                        IF  (data_part^.sp1p_buf[k] <> csp_unicode_mark) OR
                                            (data_part^.sp1p_buf[k-1] <> bsp_c1)
                                        THEN
                                            BEGIN
                                            j := k - start_pos + 1;
                                            finish := true;
                                            END
                                        ELSE
                                            k := k-2;
                                        (*ENDIF*) 
                                        END;
                                    (*ENDWHILE*) 
                                    IF  NOT finish
                                    THEN
                                        j := 0;
&                                   ifdef TRACE
                                    (*ENDIF*) 
                                    t02int4(debug_ta, 'j           ', j);
&                                   endif
                                    END;
                                (*ENDIF*) 
                                IF  (data_part^.sp1p_buf[startpos+sp1i_bufpos]
                                    = csp_unicode_def_byte)
                                THEN
                                    BEGIN
                                    IF  j > 2*NAME_MXSP00
                                    THEN
                                        cnt := c_exit_loop
                                    (*ENDIF*) 
                                    END
                                ELSE
                                    IF  j > NAME_MXSP00
                                    THEN
                                        cnt := c_exit_loop
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                END;
                            (*ENDWITH*) 
                        (*ENDFOR*) 
                        WITH resultinfo.res_fieldparam[
                             resultinfo.cnt_res_fields ] DO
                            startpos := startpos + sp1i_bufpos +
                                  sp1i_in_out_len - 1;
                        (*ENDWITH*) 
                        cnt := cnt + 1;
                        END;
                    (*ENDWHILE*) 
                    IF  cnt < c_exit_loop
                    THEN
                        BEGIN
                        delta := 0;
                        FOR i := 1 TO 3 DO
                            BEGIN
                            resultinfo.res_fieldparam[i].sp1i_length :=
                                  NAME_MXSP00;
                            outinfo[i].pos := outinfo[i].pos - delta;
                            delta          := delta +
                                  outinfo[i].length - NAME_MXSP00;
                            outinfo[i].length := NAME_MXSP00
                            END;
                        (*ENDFOR*) 
                        FOR i := 4 TO resultinfo.cnt_res_fields DO
                            outinfo[i].pos := outinfo[i].pos - delta;
                        (*ENDFOR*) 
                        ta340m_pagebuilder (upg, upg.curr_ret_segm^, outinfo,
                              resultinfo)
                        END
                    ELSE
                        ta340m_output_line_oriented (upg, upg.curr_ret_segm^,
                              resultinfo, max_fieldlength)
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                (* *** CN 01.02.95  hidden: explain VIEW select ... *** *)
                IF  (line_exceeded AND
                    (((upg.second_token <> 'SELECT      ') AND
                    (  upg.second_token <> 'VIEW        ')) OR
                    ((upg.code_type > csp_unicode) AND
                    (upg.term_simulation <> tasim_ascii))))
                    OR (upg.second_token = 'OPTIMIZE    ')
                THEN
                    ta340output_line_oriented (upg, upg.curr_ret_segm^,
                          resultinfo, max_fieldlength,
                          fetch_segm^, snd_packet, parseid)
                ELSE
                    ta340pagebuilder (upg, upg.curr_ret_segm^,
                          outinfo, resultinfo, fetch_segm^, snd_packet,
                          parseid);
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            IF  (returncode <> 100) AND (returncode <> cut_sql_req_failed)
            THEN
                t320errmsg (upg, upg.curr_ret_segm^)
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END
ELSE
    t340printresultcount (upg, ret_segm)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta340fill_resultinfo (VAR upg : tta_user_proc_globals;
            VAR ret_segm   : tsp1_segment;
            VAR resultinfo : tta_fields);
 
VAR
      shortinfo_part   : tsp1_part_ptr;
      columnnames_part : tsp1_part_ptr;
      curr_pos         : tsp00_Int2;
      curr_ident       : tsp00_Int2;
      curr_length      : tsp00_Int4;
 
BEGIN
IF  upg.inlength > 0
THEN
    resultinfo := upg.infparams
ELSE
    BEGIN
&   ifdef TRACE
    t02int4 (debug_ta, 'Neu ermittel', upg.inlength);
&   endif
    IF  NOT upg.variable_input
    THEN
        s26find_part (ret_segm,
              sp1pk_shortinfo, shortinfo_part)
    ELSE
        s26find_part (ret_segm,
              sp1pk_vardata_shortinfo, shortinfo_part);
    (*ENDIF*) 
    IF  shortinfo_part <> NIL
    THEN
        WITH shortinfo_part^, resultinfo DO
            BEGIN
&           ifdef TRACE
            t02int4 (debug_ta, 'shortinfos #', sp1p_arg_count);
&           endif
            cnt_res_fields := sp1p_arg_count;
            SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (res_fieldparam),
                  @sp1p_buf, 1, @res_fieldparam, 1, sp1p_buf_len)
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    s26find_part (ret_segm,
          sp1pk_columnnames, columnnames_part);
    IF  columnnames_part <> NIL
    THEN
        WITH columnnames_part^, resultinfo DO
            BEGIN
&           ifdef TRACE
            t02int4 (debug_ta, 'columnnames#', sp1p_arg_count);
&           endif
            curr_pos := 1;
            FOR curr_ident := 1 TO sp1p_arg_count DO
                BEGIN
                curr_length := ord (sp1p_buf[ curr_pos ]);
                curr_pos    := succ (curr_pos);
                SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (tsp00_KnlIdentifier),
                      @sp1p_buf, curr_pos,
                      @res_fieldname[ curr_ident ], 1, curr_length);
                SAPDB_PascalForcedFill (sizeof (res_fieldname[ curr_ident ]),
                      @res_fieldname[ curr_ident ], curr_length+1,
                      sizeof (tsp00_KnlIdentifier) - curr_length, ' ');
                curr_pos := curr_pos + curr_length;
                IF  upg.term_simulation = tasim_unicode
                THEN
                    t320unicode2ascii (upg,
                          sizeof (res_fieldname[ curr_ident ]),
                          @res_fieldname[ curr_ident ], curr_length);
                (*ENDIF*) 
                END
            (*ENDFOR*) 
            END
        (*ENDWITH*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ta340isuniasc (VAR upg : tta_user_proc_globals;
            VAR moveobj : tsp00_MoveObj;
            buf_pos : tsp00_Int4;
            len     : tsp00_Int4) : boolean;
 
VAR
      ok : boolean;
      i  : tsp00_Int4;
 
BEGIN
ok := true;
i  := 0;
IF  upg.swap = sw_normal
THEN
    WHILE ok AND (i < len) DO
        BEGIN
        ok := (moveobj[ buf_pos+i ]    = csp_unicode_mark) AND
              (moveobj[ buf_pos+i+1 ] >= ' ');
        i  := i + 2
        END
    (*ENDWHILE*) 
ELSE
    WHILE ok AND (i < len) DO
        BEGIN
        ok := (moveobj[ buf_pos+i   ] >= ' ') AND
              (moveobj[ buf_pos+i+1 ] = csp_unicode_mark);
        i  := i + 2
        END;
    (*ENDWHILE*) 
(*ENDIF*) 
ta340isuniasc := ok
END;
 
(*------------------------------*) 
 
FUNCTION
      t340segmptr (VAR segm : tsp1_segment) : tsp1_segment_ptr;
 
BEGIN
t340segmptr := s26segmptr (segm)
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
