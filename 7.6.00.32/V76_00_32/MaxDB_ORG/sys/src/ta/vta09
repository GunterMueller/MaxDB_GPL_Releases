/* @lastChanged: "1998-02-16 12:00"
 
 * @filename:   vta09
 * @purpose:    "TA_terminal_IO"
 * @release:    7.1.0.0
 * @see:        "-.-"
 *
 * @Copyright (c) 1998-2005 SAP AG"
 */
 
.tt 1 $SAP$LiveCache$VTA09$
.tt 3 $$TA_terminal_IO$1998-05-25$
 
.nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 1998-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
***********************************************************
 
Module  : TA_terminal_IO
 
Define  :
 
        PROCEDURE
              t09clear_screen_string (VAR term : tut_terminal);
 
        FUNCTION
              t09columns_window (VAR term : tut_terminal): integer;
 
        PROCEDURE
              t09display (VAR term : tut_terminal;
                    display_on     : boolean);
 
        PROCEDURE
              t09endscreen (VAR term : tut_terminal);
 
        FUNCTION
              t09external_retcode (VAR term : tut_terminal) : integer;
 
        PROCEDURE
              t09fileinput (VAR term : tut_terminal;
                    VAR batch_fn     : tsp00_VFilename;
                    VAR param_line   : tut_param_ln;
                    VAR errtext      : tsp00_ErrText;
                    VAR return_code  : tsp00_Int2);
 
        PROCEDURE
              t09frame (VAR term : tut_terminal; on : boolean);
 
        PROCEDURE
              t09get (VAR term : tut_terminal;
                    VAR ln     : tsp00_Line;
                    VAR pfkey  : tut_pfkey);
 
        PROCEDURE
              t09getcursor_line (VAR term : tut_terminal;
                    VAR ln    : tsp00_Line;
                    VAR pfkey : tut_pfkey);
 
        PROCEDURE
              t09getmenu (VAR term : tut_terminal;
                    size           : integer;
                    msg_attr       : char;
                    upper_case     : boolean;
                    VAR msg        : tut_c20_array;
                    VAR selected   : integer;
                    VAR pfkey      : tut_pfkey;
                    VAR ln         : tsp00_Line;
                    VAR ok         : boolean);
 
        PROCEDURE
              t09get1name (VAR term : tut_terminal;
                    msg             : tsp00_C20;
                    msg_attr        : char;
                    in_attr         : char;
                    in_len          : integer;
                    upper_case      : boolean;
                    VAR in_name     : tsp00_Name;
                    VAR pfkey       : tut_pfkey);
 
        PROCEDURE
              t09get2name (VAR term : tut_terminal;
                    msg1         : tsp00_C20;
                    msg2         : tsp00_C20;
                    msg1_attr    : char;
                    msg2_attr    : char;
                    in1_attr     : char;
                    in2_attr     : char;
                    in1_len      : integer;
                    in2_len      : integer;
                    upper_case1  : boolean;
                    upper_case2  : boolean;
                    VAR in1_name : tsp00_Name;
                    VAR in2_name : tsp00_Name;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              t09getc256 (VAR term : tut_terminal;
                    msg           : tsp00_C20;
                    msg_attr      : char;
                    in_attr       : char;
                    in_len        : integer;
                    upper_case    : boolean;
                    VAR in_c256   : tsp00_C256;
                    VAR pfkey     : tut_pfkey);
 
        PROCEDURE
              t09goto_bottom (VAR term : tut_terminal);
 
        PROCEDURE
              t09header (VAR term : tut_terminal;
                    left_msg      : tsp00_C20;
                    right_msg     : tsp00_C20);
 
        PROCEDURE
              t09help (VAR term : tut_terminal;
                    msg         : tsp00_C20;
                    upper_case  : boolean;
                    VAR ln      : tsp00_Line;
                    VAR pfkey   : tut_pfkey);
 
        PROCEDURE
              t09holding (VAR term : tut_terminal;
                    VAR pfkey      : tut_pfkey);
 
        PROCEDURE
              t09initscreen (VAR term : tut_terminal;
                    is_batch          : boolean;
                    is_virt_term      : boolean;
                    is_prompting      : boolean;
                    color_foreground  : tsp00_VtColor;
                    color_bright      : tsp00_VtColor;
                    color_background  : tsp00_VtColor;
                    color_wng_foregr  : tsp00_VtColor;
                    color_wng_backgr  : tsp00_VtColor;
                    VAR batch_fn      : tsp00_VFilename;
                    VAR ext_param     : tsp00_Line;
                    VAR is_ok         : boolean);
 
        FUNCTION
              t09is_empty_window (VAR term : tut_terminal): boolean;
 
        FUNCTION
              t09is_window_full (VAR term : tut_terminal;
                    wanted_lines: integer): boolean;
 
        PROCEDURE
              t09mask (VAR term   : tut_terminal;
                    count_names   : integer;
                    mask_size     : integer;
                    VAR mask_spec : tut_term_mask;
                    return_pfkey  : boolean;
                    VAR pfkey     : tut_pfkey);
 
        PROCEDURE
              t09mask_c256_n (VAR term : tut_terminal;
                    count_names   : integer;
                    mask_size     : integer;
                    VAR mask_spec : tut_term_mask;
                    return_pfkey  : boolean;
                    VAR pfkey     : tut_pfkey);
 
        PROCEDURE
              t09menu (VAR term  : tut_terminal;
                    size         : integer;
                    msg_attr     : char;
                    VAR msg      : tut_c20_array;
                    VAR selected : integer;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              t09msgheader (VAR term : tut_terminal;
                    msg     : tsp00_C30;
                    is_perm : boolean);
 
        PROCEDURE
              t09newscreen_page (VAR term : tut_terminal);
 
        PROCEDURE
              t09pfkeys (VAR term : tut_terminal; on : boolean);
 
        FUNCTION
              t09prot_linesize (VAR term : tut_terminal): integer;
 
        PROCEDURE
              t09put (VAR term : tut_terminal;
                    VAR ln     : tsp00_Line;
                    text_attr  : char);
 
        PROCEDURE
              t09put20 (VAR term : tut_terminal;
                    ln20         : tsp00_C20;
                    text_attr    : char);
 
        PROCEDURE
              t09put30 (VAR term : tut_terminal;
                    ln30         : tsp00_C30;
                    text_attr    : char);
 
        PROCEDURE
              t09put60 (VAR term : tut_terminal;
                    ln60         : tsp00_C60;
                    text_attr    : char);
 
        PROCEDURE
              t09putmsg (VAR term     : tut_terminal;
                    VAR msg           : tsp00_Line;
                    is_warning        : boolean;
                    immediate_display : boolean);
 
        PROCEDURE
              t09readscreen_string (VAR term : tut_terminal;
                    VAR pfkey : tut_pfkey);
 
        FUNCTION
              t09retcode (VAR term : tut_terminal) : integer;
 
        PROCEDURE
              t09returncode_set (VAR term : tut_terminal;
                    retcode : integer);
 
        PROCEDURE
              t09right_left_holding (VAR term : tut_terminal;
                    turn_right     : boolean;
                    turn_left      : boolean;
                    VAR is_running : boolean;
                    VAR pfkey      : tut_pfkey);
 
        PROCEDURE
              t09sendscreen (VAR term : tut_terminal);
 
        PROCEDURE
              t09setpf1 (VAR term : tut_terminal; pfkey_label : tsp00_C8);
 
        PROCEDURE
              t09string_get_screen (VAR term : tut_terminal;
                    VAR ln        : tsp00_Line;
                    VAR last_line : boolean);
 
        FUNCTION
              t09unused_window_lines (VAR term : tut_terminal): integer;
 
        PROCEDURE
              t09uppercase_line (VAR ln : tsp00_Line;
                    lwb : integer;
                    upb : integer);
 
        FUNCTION
              t09window_cols (VAR term : tut_terminal): integer;
 
        FUNCTION
              t09window_lines (VAR term : tut_terminal): integer;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              TA_RTE_functions : VTA05;
 
        PROCEDURE
              t05newline;
 
        PROCEDURE
              t05write_term (VAR ln : tsp00_Line);
 
        PROCEDURE
              t05readterm (prompting_sign : char;
                    VAR ln : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              TA_file_read : VTA13;
 
        PROCEDURE
              t13close_file (VAR term : tut_terminal);
 
        PROCEDURE
              t13openfile (VAR term : tut_terminal;
                    VAR batch_fn    : tsp00_VFilename;
                    VAR param_line  : tut_param_ln;
                    VAR errtext     : tsp00_ErrText;
                    VAR is_ok       : boolean);
 
        PROCEDURE
              t13readfile (VAR term : tut_terminal;
                    VAR pfkey       : tut_pfkey);
 
      ------------------------------ 
 
        FROM
              RTE_driver : VEN102;
 
        PROCEDURE
              sqlton (multi_task : boolean;
                    VAR term_ref : tsp00_Int4;
                    VAR desc     : tsp00_TerminalDescription;
                    VAR ok       : boolean);
 
        PROCEDURE
              sqltio (term_ref       : tsp00_Int4;
                    VAR screen       : tsp00_ScreenBufAddr;
                    VAR attributes   : tsp00_ScreenBufAddr;
                    refresh          : boolean;
                    VAR cursorzeile  : tsp00_Int2;
                    VAR cursorspalte : tsp00_Int2;
                    VAR hif          : tsp00_HifParms;
                    VAR options      : tsp00_VtOptions;
                    VAR result       : tsp00_VtResult;
                    VAR ok           : boolean);
 
        PROCEDURE
              sqltoff (term_ref       : tsp00_Int4;
                    VAR screen_buf    : tsp00_ScreenBufAddr;
                    VAR attribute_buf : tsp00_ScreenBufAddr;
                    VAR msg           : tsp00_VtMsg);
 
        PROCEDURE
              sqlttable (
                    i          : tsp00_Int2;
                    att        : tsp00_VtAttrib;
                    foreground : tsp00_VtColor;
                    background : tsp00_VtColor);
&       ifdef WINDOWS
 
      ------------------------------ 
 
        FROM
              Virtual-Terminal : VWS21WC;
 
        PROCEDURE
              sqltsysline (
                    term_ref     : tsp00_Int4;
                    screen_nr    : tsp00_Int2;
                    VAR sys_text : tsp00_Line;
                    VAR sys_attr : tsp00_Line;
                    VAR ok       : boolean);
&       endif
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : JuergenA
.sp
.cp 3
Created : 1982-01-29
.sp
.cp 3
.sp
.cp 3
Release :      Date : 1998-05-25
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.pb '~'
.cp 7
T09CLEAR_SCREEN_STRING
.sp
L?oscht den String, der durch T09READ_SCREEN_STRING definiert wurde.
Diese Prozedur wird ben?otigt,
wenn nicht alle Zeilen durch T09STRING_GET_SCREEN ?ubertragen
wurden. T09CLEAR_SCREEN_STRING hat keinen Effekt, wenn alle Zeilen
gelesen wurden.
.sp 2;.cp 4
T09DEF_SCREEN_HEADER
.sp
Ein Seitenkopf wird mit der angegebenen Titelzeile f?ur jede
Bildschirmseite definiert und eine neue Seite
auf dem Bildschirm erzeugt.
.sp 2;.cp 3
T09DISPLAY
.sp
Die Bildschirmausgabe wird ein- bzw. ausgeschaltet.
.sp 2;.cp 3
T09END_SCREEN
.sp
Terminal-IO wird beendet.
.sp 2;.cp 6
T09FILE_INPUT
.sp
Die Eingaben werden aus der angegebenen Datei FN mit
dem default Filetype
VDNMAC und dem default Filemode '*' gelesen.
Bei EOF wird mit der vorherigen Eingabedatei oder mit dem
urspr?unglichen Eingabemodus fortgefahren.
.sp 2;.cp 4
T09FRAME
.sp
Umsetzung des Bildschirmlayouts. Ein Rahmen wird erzeugt, wenn
ON true ist. T09FRAME erzeugt keinen neuen Bildschirm. Daher
sollte unmittelbar nach dieser Prozedur T09DEF_SCREEN_HEADER
aufgerufen werden. Das Zur?ucksetzen auf ein Layout ohne Rahmen
kann auch implizit mittels T09UNDEF_SCREEN_HEADER erfolgen.
.sp 2;.cp 5
T09GET
.sp
Eine Zeile wird unprotected vom Bildschirm eingelesen und mit mit
Leerzeichen aufgef?ullt. PFKEY liefert die evtl. bet?atigte
Funktionstaste.
.sp 2;.cp 4
T09GET_MENU
.sp
Es wird am Bildschirm analog zu T09MENU ein Menue erzeugt
und abgearbeitet. Sollte SELECTED nicht innerhalb der angegebenen
SIZE liegen, so wird OK auf false gesetzt
und mit LN die Terminal-Eingabe geliefert, wobei durch UPPER_CASE
signalisiert wird, da?z alle Kleinbuchstaben in Gro?ze umgeformt
werden, sofern sie au?zerhalb eines Strings stehen.
.sp 2;.cp 4
T09GETHOSTNAME
.sp
Ein Feld der L?ange MAXHOSTNAMELENGTH wird eingelesen,
indem auf einer Zeile beginnend an der Position
GET1NAME_MSG_POS die MSG entsprechend dem VT-Attribut MSG_ATTR und
an der Position GET1NAME_IN_POS das editierbare Feld
IN_NAME entsprechend dem VT-Attribut IN_ATTR ausgegeben wird, d.h. an
IN_NAME mu?z vor dem Prozeduraufruf ein Default-Wert zugwiesen werden.
PFKEY gibt die zuletzt bet?atigte Funktionstaste an.
Beim Standard-IO oder bei der Dateieingabe
ist der Defaultwert unwirksam.
.sp 2;.cp 4
T09GET1NAME
.sp
Ein Feld der L?ange MAXNAMELENGTH wird eingelesen,
indem auf einer Zeile beginnend an der Position
GET1NAME_MSG_POS die MSG entsprechend dem VT-Attribut MSG_ATTR und
an der Position GET1NAME_IN_POS das editierbare Feld
IN_NAME entsprechend dem VT-Attribut IN_ATTR ausgegeben wird, d.h. an
IN_NAME mu?z vor dem Prozeduraufruf ein Default-Wert zugwiesen werden.
Ist UPPER_CASE = true, so wird IN_NAME in Gro?zschreibung konvertiert.
PFKEY gibt die zuletzt bet?atigte Funktionstaste an.
Beim Standard-IO oder bei der Dateieingabe ist
der Defaultwert unwirksam.
.sp 2;.cp 4
T09GET2NAME
.sp
Analog zu GET1NAME werden zwei Felder der L?ange MAXNAMELENGTH
eingelesen, indem auf einer Zeile beginnend an der Position
GET1NAME_MSG_POS die MSG1 und bei GET2NAME_MSG_POS die MSG2
entsprechend den VT-Attributen MSG1_ATTR bzw. MSG2_ATTR und
an den Position GET1NAME_IN_POS und GET2NAME_IN_POS die
editierbaren Felder IN1_NAME bzw.
IN2_NAME entsprechend den VT-Attributen
IN_ATTR1/2 ausgegeben werden, d.h. an beide Eingabevariablen
mu?z vor dem Prozeduraufruf ein Default-Wert zugwiesen werden.
IN1_NAME bzw. IN2_NAME werden in Gro?zschreibung konvertiert,
falls UPPER_CASE1 bzw. UPPER_CASE2 true ist.
PFKEY gibt die zuletzt bet?atigte Funktionstaste an.
Bei Standard-IO oder bei der Dateieingabe ist der Defaultwert unwirksam.
.sp 2;.cp 4
T09HELP
.sp
Falls MSG ungleich Blank ist, wird die Message mittels
T09MSGPUT_SCREEN_MSG ausgegeben. Danach wird die TOP_MSG-Zeile
als Eingabezeile umdefiniert und eine Zeile eingelesen.
Ist UPPER_CASE = true, so wird die eingelesene Zeile LN
in Gro?zschreibung konvertiert.
PFKEY gibt die zuletzt bet?atigte Funktionstaste an.
.sp 2;.cp 5
T09HOLDING_SCREEN
.sp
Nach der Ausgabe der Holding-Message wird auf das Dr?ucken der
Enter-Taste oder einer Funktionstaste gewartet.
PFKEY gibt die bet?atigte Funktionstaste an.
.sp 2;.cp 4
T09INIT_SCREEN
.sp
Initialisierung des Bildschirmspeichers und der Ein-/Ausgabe.
Bei IS_BATCH~=~TRUE werden die Eingaben nicht vom Terminal sondern
aus einer Datei, deren Filename in der PARAM_LN angegeben ist
(vgl. T09FILE_INPUT). ist PASCAL_IO~=~TRUE
dann erfolgen die Ein-/Ausgaben nicht ?uber das virtuelle Terminal
sondern durch Pascal read/write.
.sp 2;.cp 4
T09MASK
.sp
Es wird eine Bildschirm-Maske mit COUNT_NAMES Feldern der L?ange
MAXNAMELENGTH und COUNT_HOSTNAMES Feldern der L?ange MAXHOSTNAMELENGTH
analog zu den zeilenorientierten Prozeduren GET1/2NAME bzw.
GETHOSTNAME erzeugt. Die Felder m?ussen durch Defaultwerte vorbelegt
sein, die aber bei Standard-IO oder bei der Dateieingabe unwirksam sind.
Die Felder des Arrays IN_NAME werden in Gro?zschreibung konvertiert,
falls UPPER_CASE true ist.
PFKEY gibt die zuletzt bet?atigte Funktionstaste an.
.sp 2;.cp 4
T09MENU
.sp
Es wird am Bildschirm ein Menue erzeugt, das aus SIZE Feldern
aus dem Array MSG besteht. Die Felder werden entsprechend dem
VT-Attribut MSG_ATTR ausgegeben. Felder, die nur aus Leerzeichen
bestehen, werden ohne Nummer als Zwischenraum angezeigt. Entsprechend
?andert sich die Numerierung auf dem Bildschirm. Es k?onnen dann
die Nummern auf dem Bildschirm oder die Bezeichnungen der Felder
(KEINE Umwandlung in Gro?zbuchstaben!) eingegeben werden.
Als Ergebnis der Auswahl wird der Integer SELECTED geliefert, der
sich nach dem ?ubergebenen MSG-Array richtet und
im Bereich 1 bis SIZE liegt. Nach Bet?atigen
einer Funktionstaste wird diese durch PFKEY geliefert und
SELECTED auf 1 gesetzt.
.sp 2;.cp 6
T09MSG_HEADER
.sp
In der Titelzeile werden beginnend an der Position POS 20 Zeichen
durch den Text MSG ersetzt. Die ge?anderte Titelzeile
wird auf dem Bildschirm ausgegeben und bleibt nur bis zum n?achsten
Bildschirmaufbau erhalten.
.sp 2;.cp 4
T09MSGPUT_SCREEN_MSG
.sp
Eine Zeile wird als Message auf der untersten Zeile
bright_protected ausgegeben.
.sp 2;.cp 4
T09NEW_SCREEN_PAGE
.sp
Eine neue Bildschirmseite wird erzeugt und der Cursor auf den Anfang der
ersten Zeile (unterhalb des Seitenkopfes) gesetzt.
.sp 2;.cp 4
T09PERM_MSG_HEADER
.sp
In der Titelzeile werden beginnend an der Position POS 30 Zeichen
durch den Text MSG ersetzt. Die ge?anderte Titelzeile
wird erst mit dem n?achsten Bildschirmaufbau ausgegeben und bleibt
bis zu einem entsprechendem T09PERM_MSG_HEADER oder bis
T09DEF/UNDEF_SCREEN_HEADER erhalten.
.sp 2;.cp 5
T09PFKEYS
.sp
Bei ON = FALSE stehen nur die Pfkeys ENTER, PF09 (end_key)
und PF05 (do_key) zur Verf?ugung, alle anderen bewirken nur ein
reset, damit die Menues oder Masken nicht zerst?orrt werden.
.sp 2;.cp 5
T09PUT
.sp
Die ersten 79 Zeichen der Zeile TEXT werden entsprechend dem
VT-Attribut TEXT_ATTR auf dem Bildschirm ausgegeben.
TEXT darf nur druckbare Zeichen enthalten.
.sp 2;.cp 4
T09PUT20
.sp
Die 20 Zeichen lange Zeile TEXT wird entsprechend dem VT-Attribut
TEXT_ATTR auf dem Bildschirm ausgegeben.
.sp 2;.cp 4
T09PUT30
.sp
Die 30 Zeichen lange Zeile TEXT wird entsprechend dem VT-Attribut
TEXT_ATTR auf dem Bildschirm ausgegeben.
.sp 2;.cp 4
T09PUT60
.sp
Die 60 Zeichen lange Zeile TEXT wird entsprechend dem VT-Attribut
TEXT_ATTR auf dem Bildschirm ausgegeben.
.sp 2;.cp 4
T09READ_SCREEN_STRING
.sp
Durch Eingaben am Terminal wird der Bildschirmspeicher mittels
T09GET_SCREEN gef?ullt bis
eine Zeile durch gelesen wird, die
au?zerhalb eines Strings das Endezeichen enth?alt.
Die Zeilen k?onnen anschlie?zend mit T01STRING_GET_SCREEN
aus dem Bildschirmspeicher geholt werden.
.sp 2;.cp 4
T09RETCODE
.SP
Liefert den zuletzt durch T09RETURNCODE_SET definierten Returncode,
der Returncode wird mit 0 initialisiert.
.sp 2;.cp 3
T09RETURNCODE_SET
.SP
Definiert den Returncode.
.sp 2;.cp 6
T09STRING_GET_SCREEN
.sp
?Ubertr?agt eine Zeile, die zuvor bei T09READ_SCREEN_STRING
eingegeben wurde, aus dem Bildschirmspeicher.
Wenn es sich um die letzte Zeile handelt,
wird LAST_LINE auf true gesetzt.
.sp 2;.cp 5
T09UNDEF_SCREEN_HEADER
.sp
Der Seitenkopf wird gel?oscht, auf eine Bildschirmlayout ohne
Rahmen umgeschaltet und eine neue Seite auf dem Bildschirm
erzeugt.
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.cp 8;.oc _/1;Funktionstasten
bei t09pfkeys (true)
.sp;.hi 16
PF01,~HELP Die PFKEY-Belegung 'PF_HELP' wird gesetzt.
.sp
PF02,~SK07,~CANCEL Break: Die globale Variable IS_BREAK wird gesetzt.
Au?zerdem wird die PFKEY-Belegung 'PF_CANCEL' gesetzt.
.sp;.cp 2
PF03,~SK09,~END Die PFKEY-Belegung 'PF_END' wird gesetzt.
.sp;.cp 5
PF05,~SK01 Holding wird bis zum n?achsten
t09get, das au?zerhalb eines
Files aufgerufen wird, abgeschaltet. Au?zerdem wird die Zeile, auf der
der Cursor steht, wie bei der Entertaste ?ubertragen.
.sp;.cp 6
PF07,~UP Ausgabe der vorhergehenden Bildschirmseite.
.sp;.cp 4
PF08,~DOWN Ausgabe der n?achsten
Bildschirmseite oder der nachfolgenden Zeilen,
deren Anzahl durch die Holdangabe festgelegt ist.
.sp
PF09,~SK02 Ausgabe des letzten Kommandos
.of;.sp;.cp 2
.sp;.of 7
PF11,~SK05,~INSERT An der Cursorposition wird die Zeile dupliziert.
.sp 2;.cp 8;.oc _/1;Funktionstasten
bei t09pfkeys (false)
.sp;.hi 16
PF03,~SK09,~END Die PFKEY-Belegung 'PF_END' wird gesetzt.
.sp;.cp 5
PF05,~SK01 G?ultig nur wenn HOLDING erscheint.
Holding wird bis zum n?achsten t09get, das au?zerhalb eines
Files aufgerufen wird, abgeschaltet.
Au?zerdem wird die Zeile, auf der
der Cursor steht, wie bei der Entertaste ?ubertragen.
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      (*
      CHARACTER  *)
      c_endsign        = '!';
      double_quote     = '"';
      default_param    = '==                ';
      prompting_sign   = '>';
      string_delimiter = '''';
      (*
      PFKEY MESSAGE  *)
      m01='     F2:exit F3:end F5:nohold F7:up F8:down F9:prev F12:dupl';
      m02='                  F2:exit  F3:end  F5:nohold  F7:up  F8:down';
      m03='                                F3:end  F5:nohold  F11:right';
      m04='                                 F3:end  F5:nohold  F10:left';
      m05='                      F3:end  F5:nohold  F10:left  F11:right';
      m06='                                           F3:end  F5:nohold';
      m07='                                                      F3:end';
      (*
      MESSAGE  *)
      holding_msg            = 'HOLDING             ';
      holding_left_right_msg = 'HOLDING   <<< / >>> ';
      holding_left_msg       = 'HOLDING   <<<       ';
      holding_right_msg      = 'HOLDING   >>>       ';
      illegal_input_msg      = 'ILLEGAL INPUT       ';
      running_msg            = 'RUNNING ...         ';
      (*
      LABEL  *)
      str_cancel_label = 'CANCEL  ';
      str_dupl_label   = 'DUPL    ';
      str_end_label    = 'END     ';
      str_is_pfkey     = 'PFKEY   ';
      str_left_label   = 'LEFT    ';
      str_nohold_label = 'NOHOLD  ';
      str_right_label  = 'RIGHT   ';
      str_prev_label   = 'PREV CMD';
      (*
      BOOL  *)
      c_get_input       = true;
      c_hold_cursor     = true;
      c_immediate_displ = true;
      c_multi_task      = true;
      c_one_window_only = true;
      c_refresh         = true;
      c_return_pfkey    = true;
      c_set_left_right  = true;
      c_upper_case      = true;
      c_use_default     = true;
      c_warning         = true;
      (*
      INTEGER  *)
      c_default_cols           =   80;
      c_default_lines          =   24;
      c_default_prot_linesize  =   72;
      c_out                    =    1;
      c_in                     =    2;
      get1name_in_pos          =   22;
      get1name_msg_pos         =    1;
      get2name_in_pos          =   62;
      get2name_msg_pos         =   41;
      label_cancel             =    7;
      label_dupl               =    3;
      label_end                =    9;
      label_help               =    1;
      label_left               =    4;
      label_nohold             =    1;
      label_prev               =    2;
      label_right              =    5;
      c_msg_size               =   mxsp_c20;
      rc_batch_file_not_found  =    1;
      screen_header_offset     =    1;
      screen_header_msg_offset =   23;
      mx_screen_header_msg     =   30;
      (*
      COLOR ATTR                   int    hex   mode         color_tab*)
      c_protected_color          =   3; (* 03   0=read           3    *)
      c_bright_protected_color   =   4; (* 04   0=read           4    *)
      c_unprotected_color        = 131; (* 83   1=read/write     3    *)
      c_bright_unprotected_color = 132; (* 84   1=read/write     4    *)
      c_invisible_color          = 133; (* 85   1=read/write     5    *)
      c_internal_msg_color       =   6; (* 06   0=read           6    *)
      c_warning_color            =   7; (* 07   0=read           7    *)
      (*
      COLOR TABLE *)
      c_colortab_normal       =  3;
      c_colortab_bright       =  4;
      c_colortab_invisible    =  5;
      c_colortab_internal_msg =  6;
      c_colortab_warning      =  7;
 
TYPE
 
      int_addr = RECORD
            CASE boolean OF
                true :
                    (out : integer);
                false :
                    (adr : tsp00_ScreenBufAddr);
                END;
            (*ENDCASE*) 
 
 
 
(*------------------------------*) 
 
PROCEDURE
      t09clear_screen_string (VAR term : tut_terminal);
 
BEGIN
term.first_cmd_line := 0
END;
 
(*------------------------------*) 
 
FUNCTION
      t09columns_window (VAR term : tut_terminal): integer;
 
BEGIN
(* one byte is reserved for the field attribute *)
t09columns_window := term.window_cols - 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09display (VAR term : tut_terminal;
            display_on     : boolean);
 
BEGIN
term.is_display := display_on AND term.screen_available
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09endscreen (VAR term : tut_terminal);
 
VAR
      i       : integer;
      end_msg : tsp00_VtMsg;
 
BEGIN
FOR i := 1 TO sizeof (end_msg) DO
    end_msg [i] := ' ';
(*ENDFOR*) 
IF  term.is_virt_term
THEN
    sqltoff (term.term_ref, term.screen_buf, term.screen_att, end_msg);
(*ENDIF*) 
WHILE term.curr_inputfile > 0 DO
    t13close_file (term)
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      t09external_retcode (VAR term : tut_terminal) : integer;
 
BEGIN
t09external_retcode := term.retcode_external
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09fileinput (VAR term : tut_terminal;
            VAR batch_fn     : tsp00_VFilename;
            VAR param_line   : tut_param_ln;
            VAR errtext      : tsp00_ErrText;
            VAR return_code  : tsp00_Int2);
 
CONST
      retcode_file_not_found = -903;
 
VAR
      is_ok : boolean;
 
BEGIN
return_code := 0;
is_ok       := true;
IF  term.curr_inputfile >= cut_max_files_term
THEN
    BEGIN
    errtext := 'TOO MANY FILES                          ';
    is_ok   := false
    END
ELSE
    t13openfile (term, batch_fn, param_line, errtext, is_ok);
(*ENDIF*) 
IF  NOT is_ok
THEN
    return_code := retcode_file_not_found;
(*ENDIF*) 
term.retcode := return_code
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09frame (VAR term : tut_terminal; on : boolean);
 
VAR
      frame_char : char;
 
BEGIN
IF  on
THEN
    BEGIN
    frame_char        := csp_horizontal_bar;
    term.is_frame     := true;
    term.header_lines := 2;
    term.window_lines := term.screen_lines - term.header_lines - 3
    END
ELSE
    BEGIN
    frame_char        := ' ';
    term.is_frame     := false;
    term.header_lines := 0;
    term.window_lines := term.screen_lines - term.header_lines - 2
    END;
(*ENDIF*) 
IF  term.has_sysline
THEN
    term.window_lines := term.window_lines + 1;
(*ENDIF*) 
IF  term.is_virt_term AND term.screen_available
THEN
    BEGIN
    term.screen_buf^[term.top_frame_offset] := cut_start_of_field;
    SAPDB_PascalForcedFill (term.screen_chars, @term.screen_buf^,
          term.top_frame_offset + 1, term.window_cols - 1, frame_char);
    SAPDB_PascalForcedFill (term.screen_chars, @term.screen_att^,
          term.top_frame_offset + 1, term.screen_cols - 1,
          ta09color (cut_protected));
    term.screen_buf^[term.bottom_frame_offset] := cut_start_of_field;
    SAPDB_PascalForcedFill (term.screen_chars, @term.screen_buf^,
          term.bottom_frame_offset + 1, term.window_cols-1, frame_char);
    SAPDB_PascalForcedFill (term.screen_chars, @term.screen_att^,
          term.bottom_frame_offset + 1, term.screen_cols - 1,
          ta09color (cut_protected))
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09get (VAR term : tut_terminal;
            VAR ln     : tsp00_Line;
            VAR pfkey  : tut_pfkey);
 
BEGIN
ta09getline (term, ln, NOT c_use_default, c_hold_cursor, pfkey)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09getcursor_line (VAR term : tut_terminal;
            VAR ln    : tsp00_Line;
            VAR pfkey : tut_pfkey);
 
BEGIN
ta09getline (term, ln, NOT c_use_default, NOT c_hold_cursor, pfkey)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09getmenu (VAR term : tut_terminal;
            size           : integer;
            msg_attr       : char;
            upper_case     : boolean;
            VAR msg        : tut_c20_array;
            VAR selected   : integer;
            VAR pfkey      : tut_pfkey;
            VAR ln         : tsp00_Line;
            VAR ok         : boolean);
 
CONST
      (* PTS 1000203 JA 1997-11-12 *)
      c_right_column = 41; (* 10 bytes margin + 1/2 str60 *)
 
VAR
      i           : integer;
      fieldno     : integer;
      halfsize    : integer;
      display_no  : ARRAY [1..20] OF integer;
      str60       : tsp00_C60;
      blank_str60 : tsp00_C60;
      command     : tsp00_C20;
 
BEGIN
pfkey := pf_none;
t09goto_bottom (term); (* PTS 1000203 JA 1997-11-12 *)
FOR i := 1 TO 60 DO
    blank_str60 [i] := ' ';
(*ENDFOR*) 
halfsize := (size+1) DIV 2;
i := 1;
FOR fieldno := 1 TO size DO
    IF  msg [fieldno] = bsp_c20
    THEN
        display_no [fieldno] := 0
    ELSE
        BEGIN
        display_no [fieldno] := i;
        i := i + 1
        END;
    (*ENDIF*) 
(*ENDFOR*) 
t09newscreen_page (term);
FOR fieldno := 1 TO halfsize DO
    BEGIN
    str60 := blank_str60;
    IF  display_no [fieldno] > 0
    THEN
        BEGIN
        IF  display_no [fieldno] > 9
        THEN
            str60 [1] := chr(ord('0') + display_no [fieldno] DIV 10);
        (*ENDIF*) 
        str60 [2] := chr(ord('0') + display_no [fieldno] MOD 10);
        IF  msg [fieldno][1] = '-'
        THEN
            str60 [1+4] := '-'
        ELSE
            FOR i := 1 TO c_msg_size DO
                str60 [i+4] := msg [fieldno][i]
            (*ENDFOR*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  fieldno + halfsize <= size
    THEN
        BEGIN
        IF  display_no [fieldno + halfsize] > 0
        THEN
            BEGIN
            IF  display_no [fieldno + halfsize] > 9
            THEN
                str60 [31] := chr(ord('0')
                      + display_no [fieldno + halfsize] DIV 10);
            (*ENDIF*) 
            str60 [32] := chr(ord('0') +
                  display_no [fieldno + halfsize] MOD 10);
            IF  msg [fieldno + halfsize] [1] = '-'
            THEN
                str60 [1+34] := '-'
            ELSE
                FOR i := 1 TO c_msg_size DO
                    str60 [i+34] := msg [fieldno + halfsize] [i]
                (*ENDFOR*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    t09put60 (term, str60, msg_attr)
    END;
(*ENDFOR*) 
ta09getline (term, ln, c_use_default,
      NOT c_hold_cursor, (* PTS 1000203 JA 1997-11-12 *)
      pfkey);
IF  pfkey = pf_none
THEN
    BEGIN
    t09goto_bottom (term); (* PTS 1000203 JA 1997-11-12 *)
    IF  term.currcol >= c_right_column
    THEN
        (* PTS 1000203 JA 1997-11-12 *)
        i := c_right_column
    ELSE
        i := 1;
    (*ENDIF*) 
    WHILE (i < sizeof(ln) - 1) AND (ln [i] = ' ') DO
        i := i + 1;
    (*ENDWHILE*) 
    IF  ln [i+1] = ' '
    THEN
        selected :=  ord (ln [i  ]) - ord ('0')
    ELSE
        selected := (ord (ln [i  ]) - ord ('0')) * 10
              +      ord (ln [i+1]) - ord ('0');
    (*ENDIF*) 
    ok := false;
    IF  selected > 0
    THEN
        BEGIN
        fieldno := 1;
        WHILE NOT ok AND (fieldno <= size) DO
            IF  display_no [fieldno] = selected
            THEN
                ok := true
            ELSE
                fieldno := fieldno + 1
            (*ENDIF*) 
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    IF  ok
    THEN
        selected := fieldno
    ELSE
        BEGIN
        FOR i := 1 TO c_msg_size DO
            command [i] := ln [i];
        (*ENDFOR*) 
        i := 1;
        selected := 0;
        REPEAT
            IF  (command = msg [i]) AND (command <> bsp_c20)
            THEN
                selected := i;
            (*ENDIF*) 
            i := i + 1
        UNTIL
            (i > size) OR (selected > 0);
        (*ENDREPEAT*) 
        IF  selected > 0
        THEN
            ok := true
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  NOT ok AND upper_case
    THEN
        t09uppercase_line (ln, 1, sizeof (ln))
    (*ENDIF*) 
    END;
(*ENDIF*) 
t09putmsg (term, term.blankline, NOT c_warning, NOT c_immediate_displ)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09get1name (VAR term : tut_terminal;
            msg             : tsp00_C20;
            msg_attr        : char;
            in_attr         : char;
            in_len          : integer;
            upper_case      : boolean;
            VAR in_name     : tsp00_Name;
            VAR pfkey       : tut_pfkey);
 
VAR
      i         : integer;
      io_return : tsp00_VtResult;
      in_ln     : tsp00_Line;
 
BEGIN
pfkey := pf_none;
t09goto_bottom (term); (* PTS 1000203 JA 1997-11-12 *)
IF  term.is_inputfile OR term.is_batch OR NOT term.is_virt_term
THEN
    BEGIN
    in_ln := term.blankline;
    FOR i := 1 TO sizeof (in_name) DO
        in_ln [i] := in_name [i];
    (*ENDFOR*) 
    t09put20 (term, msg, msg_attr);
    ta09getline (term, in_ln, c_use_default, c_hold_cursor, pfkey);
    SAPDB_PascalForcedMove (sizeof (in_ln), sizeof (in_name),
          @in_ln, 1, @in_name, 1, sizeof (in_name))
    END
ELSE
    BEGIN
    ta09next_line (term);
    term.lines        [term.currline] := term.blank_window_line;
    WITH term.ln_desc [term.currline] DO
        BEGIN
        ld_type          := lt_get1name;
        ld_attr1 [c_out] := msg_attr;
        ld_attr1 [c_in ] := in_attr;
        ld_in_code1      := false;
        IF  (in_len < 1) OR (in_len > NAME_MXSP00)
        THEN
            ld_in_len1 := NAME_MXSP00
        ELSE
            ld_in_len1 := in_len
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    SAPDB_PascalForcedMove (sizeof (msg), sizeof (term.lines [term.currline]),
          @msg, 1, @term.lines [term.currline],
          get1name_msg_pos, c_msg_size);
    term.lines [term.currline] [get1name_in_pos-1] := in_attr;
    SAPDB_PascalForcedMove (sizeof (in_name), sizeof (term.lines [term.currline]),
          @in_name, 1,
          @term.lines [term.currline], get1name_in_pos,
          sizeof (in_name));
    term.currcol := get1name_in_pos;
    ta09build_page (term, c_get_input, NOT c_set_left_right,
          NOT c_return_pfkey, pfkey, io_return);
    SAPDB_PascalForcedMove (sizeof (term.lines [term.currline]), sizeof (in_name),
          @term.lines [term.currline], get1name_in_pos,
          @in_name, 1, sizeof (in_name));
    IF  in_len < NAME_MXSP00
    THEN
        in_name [in_len+1] := ' '
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  upper_case
THEN
    ta09upper_case_name (in_name);
(*ENDIF*) 
ta09n_remove_double_quotes (in_name);
t09putmsg (term, term.blankline, NOT c_warning, NOT c_immediate_displ)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09get2name (VAR term : tut_terminal;
            msg1         : tsp00_C20;
            msg2         : tsp00_C20;
            msg1_attr    : char;
            msg2_attr    : char;
            in1_attr     : char;
            in2_attr     : char;
            in1_len      : integer;
            in2_len      : integer;
            upper_case1  : boolean;
            upper_case2  : boolean;
            VAR in1_name : tsp00_Name;
            VAR in2_name : tsp00_Name;
            VAR pfkey    : tut_pfkey);
 
VAR
      io_result : tsp00_VtResult;
 
BEGIN
pfkey := pf_none;
t09goto_bottom (term); (* PTS 1000203 JA 1997-11-12 *)
IF  term.is_inputfile OR term.is_batch OR NOT term.is_virt_term
THEN
    BEGIN
    t09get1name (term, msg1, msg1_attr, in1_attr, in1_len, upper_case1,
          in1_name, pfkey);
    IF  pfkey = pf_none
    THEN
        t09get1name (term, msg2, msg2_attr, in2_attr, in2_len,
              upper_case2, in2_name, pfkey)
    (*ENDIF*) 
    END
ELSE
    BEGIN
    ta09next_line (term);
    term.lines        [term.currline] := term.blank_window_line;
    WITH term.ln_desc [term.currline] DO
        BEGIN
        ld_type          := lt_get2name;
        ld_attr1 [c_out] := msg1_attr;
        ld_attr2 [c_out] := msg2_attr;
        ld_attr1 [c_in ] := in1_attr;
        ld_attr2 [c_in ] := in2_attr;
        ld_in_code1      := false;
        ld_in_code2      := false;
        IF  (in1_len < 1) OR (in1_len > NAME_MXSP00)
        THEN
            ld_in_len1 := NAME_MXSP00
        ELSE
            ld_in_len1 := in1_len;
        (*ENDIF*) 
        IF  (in2_len < 1) OR (in2_len > NAME_MXSP00)
        THEN
            ld_in_len2 := NAME_MXSP00
        ELSE
            ld_in_len2 := in2_len
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    SAPDB_PascalForcedMove (sizeof (msg1), sizeof (term.lines [term.currline]),
          @msg1, 1, @term.lines [term.currline], get1name_msg_pos,
          sizeof (msg1));
    SAPDB_PascalForcedMove (sizeof (in1_name), sizeof (term.lines [term.currline]),
          @in1_name, 1, @term.lines [term.currline], get1name_in_pos,
          sizeof (in1_name));
    SAPDB_PascalForcedMove (sizeof (msg2), sizeof (term.lines [term.currline]),
          @msg2, 1, @term.lines [term.currline], get2name_msg_pos,
          sizeof (msg2));
    SAPDB_PascalForcedMove (sizeof (in2_name), sizeof (term.lines [term.currline]),
          @in2_name, 1,
          @term.lines [term.currline], get2name_in_pos,
          sizeof (in2_name));
    term.currcol := get1name_in_pos;
    ta09build_page (term, c_get_input, NOT c_set_left_right,
          NOT c_return_pfkey, pfkey, io_result);
    SAPDB_PascalForcedMove (sizeof (term.lines [term.currline]), sizeof (in1_name),
          @term.lines [term.currline],
          get1name_in_pos, @in1_name, 1, sizeof (in1_name));
    IF  in1_len < NAME_MXSP00
    THEN
        in1_name [in1_len+1] := ' ';
    (*ENDIF*) 
    SAPDB_PascalForcedMove (sizeof (term.lines [term.currline]), sizeof (in2_name),
          @term.lines [term.currline],
          get2name_in_pos, @in2_name, 1, sizeof (in2_name));
    IF  in2_len < NAME_MXSP00
    THEN
        in2_name [in2_len+1] := ' ';
    (*ENDIF*) 
    IF  upper_case1
    THEN
        ta09upper_case_name (in1_name);
    (*ENDIF*) 
    IF  upper_case2
    THEN
        ta09upper_case_name (in2_name);
    (*ENDIF*) 
    ta09n_remove_double_quotes (in1_name);
    ta09n_remove_double_quotes (in2_name)
    END;
(*ENDIF*) 
t09putmsg (term, term.blankline, NOT c_warning, NOT c_immediate_displ)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09getc256 (VAR term : tut_terminal;
            msg           : tsp00_C20;
            msg_attr      : char;
            in_attr       : char;
            in_len        : integer;
            upper_case    : boolean;
            VAR in_c256    : tsp00_C256;
            VAR pfkey     : tut_pfkey);
 
VAR
      i         : integer;
      trunc_c256 : integer;
      io_result : tsp00_VtResult;
      in_ln     : tsp00_Line;
 
BEGIN
pfkey := pf_none;
t09goto_bottom (term); (* PTS 1000203 JA 1997-11-12 *)
IF  term.is_inputfile OR term.is_batch OR NOT term.is_virt_term
THEN
    BEGIN
    FOR i := 1 TO sizeof (in_ln) DO
        in_ln [i] := in_c256 [i];
    (*ENDFOR*) 
    t09put20 (term, msg, msg_attr);
    ta09getline (term, in_ln, c_use_default, c_hold_cursor, pfkey);
    in_c256 := term.blankfilename;
    FOR i := 1 TO sizeof(in_ln) DO
        in_c256 [i] := in_ln [i]
    (*ENDFOR*) 
    END
ELSE
    BEGIN
    trunc_c256 := term.window_cols - get1name_in_pos;
    IF  trunc_c256 > sizeof (in_c256)
    THEN
        trunc_c256 := sizeof (in_c256);
    (*ENDIF*) 
    ta09next_line (term);
    term.lines        [term.currline] := term.blank_window_line;
    WITH term.ln_desc [term.currline] DO
        BEGIN
        ld_type           := lt_getc256;
        ld_attr1 [c_out] := msg_attr;
        ld_attr1 [c_in ] := in_attr;
        ld_in_code1       := false;
        IF  (in_len < 1) OR (in_len > trunc_c256)
        THEN
            ld_in_len1 := trunc_c256
        ELSE
            ld_in_len1 := in_len
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    SAPDB_PascalForcedMove (sizeof (msg), sizeof (term.lines [term.currline]),
          @msg, 1, @term.lines [term.currline],
          get1name_msg_pos, sizeof (msg));
    SAPDB_PascalForcedMove (sizeof (in_c256), sizeof (term.lines [term.currline]),
          @in_c256, 1, @term.lines [term.currline], get1name_in_pos,
          trunc_c256);
    term.currcol := get1name_in_pos;
    ta09build_page (term, c_get_input, NOT c_set_left_right,
          NOT c_return_pfkey, pfkey, io_result);
    IF  NOT (pfkey in [pf_cancel, pf_end])
    THEN
        BEGIN
        in_c256 := term.blankfilename;
        SAPDB_PascalForcedMove (sizeof (term.lines [term.currline]), sizeof (in_c256),
              @term.lines [term.currline], get1name_in_pos,
              @in_c256, 1, trunc_c256);
        IF  in_len < sizeof (in_c256)
        THEN
            in_c256 [in_len+1] := ' '
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  upper_case
THEN
    ta09upper_c256 (in_c256);
(*ENDIF*) 
ta09c256_remove_double_quotes (in_c256);
t09putmsg (term, term.blankline, NOT c_warning, NOT c_immediate_displ)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09goto_bottom (VAR term : tut_terminal);
 
BEGIN
ta09rolldown (term, NOT c_one_window_only)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09header (VAR term : tut_terminal;
            left_msg      : tsp00_C20;
            right_msg     : tsp00_C20);
 
CONST
      c_right_msg_space = 20;
 
VAR
      holding      : boolean;
      right_offset : integer;
      ln           : tsp00_Line;
 
BEGIN
right_offset := term.window_cols - c_right_msg_space;
IF  NOT term.is_virt_term
THEN
    BEGIN
    IF  term.is_display
    THEN
        BEGIN
        t05newline;
        ln := term.blankline;
        SAPDB_PascalForcedMove (sizeof (left_msg), sizeof (ln),
              @left_msg, 1, @ln, 1, sizeof (left_msg));
        SAPDB_PascalForcedMove (sizeof (right_msg), sizeof (ln),
              @right_msg, 1, @ln, right_offset+1, sizeof (right_msg));
        t05write_term (ln);
        t05newline
        END
    (*ENDIF*) 
    END
ELSE
    IF  term.screen_available
    THEN
        BEGIN
        holding := term.is_holding;
        term.is_holding := false;
        term.screen_buf^[screen_header_offset] := cut_start_of_field;
        SAPDB_PascalForcedMove (sizeof (left_msg), term.screen_chars,
              @left_msg, 1,
              @term.screen_buf^, screen_header_offset + 1,
              sizeof (left_msg));
        term.screen_buf^[screen_header_msg_offset] :=
              cut_start_of_field;
        SAPDB_PascalForcedFill (term.screen_chars, @term.screen_buf^,
              screen_header_msg_offset + 1, mx_screen_header_msg, ' ');
        term.screen_buf^[term.window_cols - 2 - c_msg_size] :=
              cut_start_of_field;
        SAPDB_PascalForcedMove (sizeof (right_msg), term.screen_chars,
              @right_msg, 1,
              @term.screen_buf^, term.window_cols - sizeof (right_msg),
              sizeof (right_msg));
        t09newscreen_page (term);
        term.is_holding := holding
        END
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09help (VAR term : tut_terminal;
            msg         : tsp00_C20;
            upper_case  : boolean;
            VAR ln      : tsp00_Line;
            VAR pfkey   : tut_pfkey);
 
VAR
      i         : integer;
      offset    : integer;
      io_result : tsp00_VtResult;
      screen_ln : tsp00_Line;
 
BEGIN
term.help_state := true;
IF  msg <> bsp_c20
THEN
    BEGIN
    ln := term.blankline;
    FOR i := 1 TO c_msg_size DO
        ln [i] := msg [i];
    (*ENDFOR*) 
    t09putmsg (term, ln, NOT c_warning, NOT c_immediate_displ)
    END;
(*ENDIF*) 
ln := term.blankline;
IF  NOT term.is_virt_term
THEN
    BEGIN
    screen_ln := term.blank_window_line;
    t05readterm (prompting_sign, screen_ln);
    IF  screen_ln [1] = prompting_sign
    THEN
        offset := 1
    ELSE
        offset := 0;
    (*ENDIF*) 
    SAPDB_PascalForcedMove (sizeof (ln), sizeof (ln),
          @screen_ln, offset+1,  @ln, 1, term.window_cols - 1)
    END
ELSE
    BEGIN
    term.screen_buf^[term.help_line_offset] := cut_start_of_field;
    term.screen_buf^[term.help_line_offset + term.window_cols] :=
          cut_end_of_field;
    term.screen_buf^[term.help_line_offset + term.screen_cols] :=
          cut_start_of_field;
    term.screen_buf^[term.help_line_offset + 1] := prompting_sign;
    SAPDB_PascalForcedFill (term.screen_chars, @term.screen_buf^,
          term.help_line_offset + 2, term.window_cols - 2, ' ');
    SAPDB_PascalForcedFill(term.screen_chars, @term.screen_att^, term.help_line_offset+1,
          term.window_cols - 1, ta09color (cut_unprotected));
    ta09build_page (term, c_get_input, NOT c_set_left_right,
          NOT c_return_pfkey, pfkey, io_result);
    IF  term.screen_buf^[term.help_line_offset+1] <> prompting_sign
    THEN
        offset := 0
    ELSE
        offset := 1;
    (*ENDIF*) 
    SAPDB_PascalForcedMove (term.screen_chars, sizeof (ln),
          @term.screen_buf^, term.help_line_offset + 1 + offset,
          @ln, 1, term.window_cols - 1 - offset);
    SAPDB_PascalForcedFill (term.screen_chars, @term.screen_buf^,
          term.help_line_offset+1, term.window_cols - 1, ' ');
    term.screen_buf^[term.help_line_offset + c_msg_size + 1] :=
          cut_start_of_field;
    SAPDB_PascalForcedFill(term.screen_chars, @term.screen_att^, term.help_line_offset+1,
          term.window_cols - 1, ta09color (cut_protected));
    term.help_state := false
    END;
(*ENDIF*) 
IF  upper_case
THEN
    t09uppercase_line (ln, 1, term.window_cols)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09holding (VAR term : tut_terminal;
            VAR pfkey      : tut_pfkey);
 
VAR
      io_result : tsp00_VtResult;
 
BEGIN
pfkey := pf_none;
IF  NOT term.is_inputfile AND NOT term.is_batch AND term.is_holding
    AND term.is_virt_term AND term.is_display
THEN
    BEGIN
    IF  NOT term.use_pfkeys
    THEN
        BEGIN
        term.hif.slabels [label_nohold]     := str_nohold_label;
        term.hif.llabels [label_nohold] [1] := str_nohold_label
        END;
    (*ENDIF*) 
    ta09display_internal_msg (term, NOT c_immediate_displ,
          holding_msg, io_result);
    ta09build_page (term, c_get_input, NOT c_set_left_right,
          NOT c_return_pfkey, pfkey, io_result);
    IF  term.is_holding
    THEN
        ta09display_internal_msg (term, NOT c_immediate_displ,
              bsp_c20, io_result);
    (*ENDIF*) 
    IF  NOT term.use_pfkeys
    THEN
        BEGIN
        term.hif.slabels [label_nohold]     := bsp_c8;
        term.hif.llabels [label_nohold] [1] := bsp_c8
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
t09putmsg (term, term.blankline, NOT c_warning, NOT c_immediate_displ)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09initscreen (VAR term : tut_terminal;
            is_batch          : boolean;
            is_virt_term      : boolean;
            is_prompting      : boolean;
            color_foreground  : tsp00_VtColor;
            color_bright      : tsp00_VtColor;
            color_background  : tsp00_VtColor;
            color_wng_foregr  : tsp00_VtColor;
            color_wng_backgr  : tsp00_VtColor;
            VAR batch_fn      : tsp00_VFilename;
            VAR ext_param     : tsp00_Line;
            VAR is_ok         : boolean);
 
VAR
      bright_attr : tsp00_VtAttrib;
      dummy_pfkey : tut_pfkey;
      i           : integer;
      k           : integer;
      rc          : tsp00_Int2;
      errtext     : tsp00_ErrText;
      term_desc   : tsp00_TerminalDescription;
      param_line  : tut_param_ln;
 
BEGIN
term.io_ok             := true;
term.is_batch          := is_batch AND NOT is_prompting;
term.is_virt_term      := is_virt_term;
term.screen_available  := true;
term_desc.num_of_lines := c_default_lines; (* default *)
term_desc.num_of_cols  := c_default_cols;  (* default *)
term_desc.has_sysline  := false;           (* default *)
term.is_display        := true;
term.prime_number [1]  := 0;
IF  is_virt_term
THEN
    BEGIN
    term_desc.content_buf   := NIL;      (* security *)
    term_desc.attribute_buf := NIL;      (* security *)
    sqlton (NOT c_multi_task, term.term_ref, term_desc, term.io_ok);
    term.screen_buf := term_desc.content_buf;
    term.screen_att := term_desc.attribute_buf;
    END;
(*ENDIF*) 
IF  term.io_ok AND is_virt_term
THEN
    BEGIN
    IF  (color_foreground in term_desc.colors) AND
        (color_bright     in term_desc.colors) AND
        (color_background in term_desc.colors) AND
        (color_wng_foregr in term_desc.colors) AND
        (color_wng_backgr in term_desc.colors) AND
        (color_foreground <> color_background) AND
        (color_bright     <> color_background) AND
        (color_wng_foregr <> color_wng_backgr)
    THEN
        BEGIN
        sqlttable (c_colortab_normal, [ ],
              color_foreground, color_background);
        IF  (color_foreground = vt_black)
            OR
            ((color_foreground = vt_blue) AND (color_background in
            [vt_green, vt_light_blue, vt_pink, vt_white,vt_yellow]))
            OR
            ((color_foreground = vt_pink  ) AND
            ( color_background = vt_white))
            OR
            (color_foreground = vt_red)
        THEN
            bright_attr    := [ ]         (* JA 1997-10-13 *)
                  (* bright_attr := [vt_bright] (* JA 1996-09-20 *)
        ELSE
            bright_attr := [vt_bright];
        (*ENDIF*) 
        sqlttable (c_colortab_bright, bright_attr,
              color_bright, color_background);
        sqlttable (c_colortab_invisible, [vt_invisible],
              color_foreground, color_background);
        sqlttable (c_colortab_internal_msg, [ ],
              color_background, color_foreground);
        IF  (color_wng_foregr = vt_black)
            OR
            ((color_wng_foregr = vt_blue) AND (color_wng_backgr in
            [vt_green, vt_light_blue, vt_pink, vt_white,vt_yellow]))
            OR
            ((color_foreground = vt_pink  ) AND
            ( color_background = vt_white))
            OR
            (color_wng_foregr = vt_red)
        THEN
            (* bright_attr := [ ]         JA 1996-09-20 *)
            bright_attr := [vt_bright] (* JA 1996-09-20 *)
        ELSE
            bright_attr := [vt_bright];
        (*ENDIF*) 
        sqlttable (c_colortab_warning, bright_attr,
              color_wng_foregr, color_wng_backgr)
        END
    ELSE
        BEGIN
        sqlttable (c_colortab_normal, [ ],
              vt_default_color, vt_default_color);
        sqlttable (c_colortab_bright, [vt_bright],
              vt_default_color, vt_default_color);
        sqlttable (c_colortab_invisible, [vt_invisible],
              vt_default_color, vt_default_color);
        sqlttable (c_colortab_internal_msg, [vt_bright],
              vt_default_color, vt_default_color);
        sqlttable (c_colortab_warning, [vt_bright],
              vt_default_color, vt_default_color)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  term.io_ok
THEN
    BEGIN
    term.screen_lines      := term_desc.num_of_lines;
    term.screen_cols       := term_desc.num_of_cols;
    term.screen_chars      := term.screen_lines * term.screen_cols;
    IF  term.screen_chars > sizeof (term.screen_buf^)
    THEN
        term.io_ok := false; (* JA 1997-10-15 *)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  term.io_ok
THEN
    BEGIN
    term.has_sysline       := term_desc.has_sysline;
    term.curr_inputfile    := 0;
    term.is_inputfile      := false;
    term.is_holding        := true;
    term.is_mask           := false;
    term.is_cmd_read       := false;
    term.is_frame          := false;
    term.use_pfkeys        := false;
    term.is_reset_called   := false;
    term.help_state        := false;
    term.retcode           :=  0;
    term.retcode_external  := -1; (* undef *)
    term.header_lines      :=  0;
    term.window_lines      := term.screen_lines - term.header_lines - 2;
    IF  term.has_sysline
    THEN
        term.window_lines := term.window_lines + 1;
    (*ENDIF*) 
    IF  term.screen_cols > sizeof (tsp00_Line)
    THEN
        term.window_cols := sizeof (tsp00_Line)
    ELSE
        term.window_cols := term.screen_cols;
    (*ENDIF*) 
    SAPDB_PascalForcedFill (sizeof (term.blankfilename),
          @term.blankfilename, 1, sizeof (term.blankfilename), ' ');
    SAPDB_PascalForcedFill (sizeof (term.blankline),
          @term.blankline, 1, sizeof (term.blankline), ' ');
    term.blank_window_line := term.blankline;
    FOR i := 1 TO cut_max_lines_term DO
        WITH term.ln_desc [i] DO
            BEGIN
            term.lines [i]   := term.blank_window_line;
            ld_new_page      := false;
            ld_attr1 [c_out] := cut_protected;
            ld_attr2 [c_out] := cut_protected;
            ld_attr1 [c_in ] := cut_protected;
            ld_attr2 [c_in ] := cut_protected;
            term.ln_desc[i].ld_type := lt_normal
            END;
        (*ENDWITH*) 
    (*ENDFOR*) 
    FOR k := 1 TO cut_max_cmds_term DO
        BEGIN
        FOR i := 1 TO cut_max_cmd_lines_term DO
            term.last_cmd_lines [k] [i] := term.blank_window_line;
        (*ENDFOR*) 
        term.count_cmd_lines [k] := 0
        END;
    (*ENDFOR*) 
    term.last_cmd_no := 1;
    WITH term DO
        BEGIN
        top               := 1;
        bottom            := 1;
        currline          := 0;
        currcol           := 1;
        window_top        := 0;
        window_bottom     := 0;
        window_currline   := 0;
        first_cmd_line    := 0;
        put_linecount     := 0;
        used_window_lines := 0;
        END;
    (*ENDWITH*) 
    FOR i := 1 TO cut_max_files_term DO
        BEGIN
        term.inputfile  [i].utvf_handle := 0;
        term.inputfile  [i].utvf_filler := 0;
        term.inputfilpos[i]             := 0;
        term.inputfn    [i]             := term.blankfilename
        END;
    (*ENDFOR*) 
    IF  is_virt_term
    THEN
        BEGIN
        term.top_frame_offset:= term.screen_cols;
        term.msg_line_offset :=(term.screen_lines-1) * term.screen_cols;
        IF  term.has_sysline
        THEN
            BEGIN
            term.help_line_offset    :=
                  (term.screen_lines - 1) * term.screen_cols;
            term.bottom_frame_offset :=
                  (term.screen_lines - 2) * term.screen_cols
            END
        ELSE
            BEGIN
            term.help_line_offset    :=
                  (term.screen_lines - 2) * term.screen_cols;
            term.bottom_frame_offset :=
                  (term.screen_lines - 3) * term.screen_cols
            END;
        (*ENDIF*) 
        IF  term.screen_available
        THEN
            BEGIN
            SAPDB_PascalForcedFill (term.screen_chars, @term.screen_buf^,
                  1, term.screen_chars, ' ');
            SAPDB_PascalForcedFill (term.screen_chars, @term.screen_att^,
                  1, term.screen_chars, ta09color (cut_protected));
            term.screen_buf^[term.help_line_offset] :=
                  cut_start_of_field;
            term.screen_buf^[term.help_line_offset + c_msg_size + 1] :=
                  cut_start_of_field;
            IF  NOT term.has_sysline
            THEN
                term.screen_buf^[term.msg_line_offset] :=
                      cut_start_of_field;
            (*ENDIF*) 
            term.screen_buf^[term.screen_chars] := cut_end_of_field;
            term.screen_changed := true
            END;
        (*ENDIF*) 
        WITH term.hif DO
            BEGIN
            SAPDB_PascalForcedFill (sizeof (sys_text), @sys_text , 1,
                  sizeof (sys_text), ' ');
            SAPDB_PascalForcedFill (sizeof (sys_attr), @sys_attr , 1,
                  sizeof (sys_attr), ta09color (cut_protected));
            sys_text [1] := cut_start_of_field;
            sys_text [LINE_MXSP00] := cut_end_of_field;
            insert_label.text  := ' INSERT ';
            insert_label.colnr := 1;
            insert_label.att   := cut_protected;
            IF  term.has_sysline
            THEN
                insert_label.lno := term.screen_lines - 2
            ELSE
                insert_label.lno := term.screen_lines - 1;
            (*ENDIF*) 
            FOR i := 1 TO csp_sk_number DO
                BEGIN
                slabels [i]     := bsp_c8;
                llabels [i] [1] := bsp_c8;
                llabels [i] [2] := bsp_c8
                END;
            (*ENDFOR*) 
            IF  term_desc.labels = no_sk_labels
            THEN
                slabels [label_end] := str_is_pfkey
            ELSE
                BEGIN
                slabels [label_end]     := str_end_label;
                llabels [label_end] [1] := str_end_label
                END
            (*ENDIF*) 
            END
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    IF  is_batch
    THEN
        BEGIN
        IF  batch_fn <> term.blankfilename
        THEN
            BEGIN
            SAPDB_PascalForcedMove (sizeof (ext_param), sizeof (param_line),
                  @ext_param, 1, @param_line, 1, sizeof (ext_param));
            SAPDB_PascalForcedFill (sizeof (param_line), @param_line,
                  1+sizeof (ext_param),
                  sizeof (param_line)-sizeof(ext_param), ' ');
            t09fileinput (term, batch_fn, param_line, errtext, rc);
            IF  rc <> 0
            THEN
                term.retcode := rc_batch_file_not_found
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  NOT is_virt_term
        THEN
            BEGIN
            term.is_display       := false;
            term.screen_available := false
            END
        ELSE
            IF  term.screen_available AND (rc = 0)
            THEN
                ta09set_running_msg (term, true)
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  term.io_ok AND is_virt_term
THEN
    BEGIN
    IF  (term_desc.num_of_lines < c_default_lines) OR
        (term_desc.num_of_cols  < c_default_cols )
    THEN
        BEGIN
        t09newscreen_page (term);
        t09put20 (term, ' WINDOW TOO SMALL   ', cut_bright_protected);
        t09put20 (term, '   (min 80x24)      ', cut_protected);
        t09holding (term, dummy_pfkey);
        t09endscreen (term);
        term.io_ok        := false;
        term.is_virt_term := false
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
is_ok := term.io_ok (* This parameter should go away in the future. *)
END;
 
(*------------------------------*) 
 
FUNCTION
      t09is_empty_window (VAR term : tut_terminal): boolean;
 
BEGIN
t09is_empty_window := term.used_window_lines <= 0
END;
 
(*------------------------------*) 
 
FUNCTION
      t09is_window_full (VAR term : tut_terminal;
            wanted_lines: integer): boolean;
 
BEGIN
t09is_window_full :=
      (term.used_window_lines + wanted_lines > term.window_lines)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09mask (VAR term   : tut_terminal;
            count_names   : integer;
            mask_size     : integer;
            VAR mask_spec : tut_term_mask;
            return_pfkey  : boolean;
            VAR pfkey     : tut_pfkey);
 
VAR
      name_space_line   : boolean;
      c256_space_line    : boolean;
      infile_get_input  : boolean;
      i                 : integer;
      fieldno           : integer;
      msg_offset        : integer;
      in_offset         : integer;
      curr              : integer;
      first_line        : integer;
      first_window_line : integer;
      cursor_line       : integer;
      cursor_col        : integer;
      last_line         : integer;
      last_window_line  : integer;
      first_c256_line    : integer;
      trunc_c256         : integer;
      aux_name          : tsp00_Name;
      aux_c256           : tsp00_C256;
      default_c256       : tsp00_C256;
      io_result         : tsp00_VtResult;
 
BEGIN
pfkey := pf_none;
t09goto_bottom (term); (* PTS 1000203 JA 1997-11-12 *)
infile_get_input := false;
IF  term.is_inputfile
THEN
    BEGIN
    i := 1;
    WHILE NOT infile_get_input AND (i <= mask_size) DO
        BEGIN
        infile_get_input :=
              (mask_spec[i].msg_in_attr [c_in] <> cut_bright_protected)
              AND
              (mask_spec[i].msg_in_attr [c_in] <> cut_protected);
        i := i + 1
        END
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
IF  infile_get_input OR term.is_batch OR NOT term.is_virt_term
THEN
    BEGIN
    i := 1;
    WHILE (pfkey = pf_none) AND (i <= count_names) DO
        BEGIN
        WITH mask_spec [i] DO
            IF  (msg_in_attr [c_in] <> cut_protected       ) AND
                (msg_in_attr [c_in] <> cut_bright_protected)
            THEN
                BEGIN
                aux_name := in_name;
                t09get1name (term, msg, msg_in_attr [c_out],
                      msg_in_attr [c_in], in_len, upper_case,
                      in_name, pfkey);
                IF  in_name = default_param
                THEN
                    in_name := aux_name
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
        i := i + 1
        END;
    (*ENDWHILE*) 
    IF  count_names + 1 <= mask_size
    THEN
        BEGIN
        default_c256 := term.blankfilename;
        aux_name    := default_param;
        FOR i := 1 TO sizeof (aux_name) DO
            default_c256 [i] := aux_name [i]
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    i := count_names + 1;
    WHILE (pfkey = pf_none) AND (i <= mask_size) DO
        BEGIN
        WITH mask_spec [i] DO
            IF  (msg_in_attr [c_in] <> cut_protected       ) AND
                (msg_in_attr [c_in] <> cut_bright_protected)
            THEN
                BEGIN
                aux_c256 := in_c256;
                t09getc256 (term, msg, msg_in_attr [c_out],
                      msg_in_attr[c_in], in_len, upper_case,
                      in_c256, pfkey);
                IF  in_c256 = default_c256
                THEN
                    in_c256 := aux_c256
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
        i := i + 1
        END
    (*ENDWHILE*) 
    END
ELSE
    BEGIN
    trunc_c256 := term.window_cols - get1name_in_pos;
    IF  trunc_c256 > sizeof (tsp00_C256)
    THEN
        trunc_c256 := sizeof (tsp00_C256);
    (*ENDIF*) 
    cursor_line     := 0;
    cursor_col      := 0;
    first_c256_line  := 0;
    term.is_mask    := true;
    IF  term.window_currline +  2 * ((count_names + 1) DIV 2)
        - 1 + mask_size - count_names <= term.window_lines
    THEN
        name_space_line := true
    ELSE
        name_space_line := false;
    (*ENDIF*) 
    FOR fieldno := 1 TO count_names DO
        BEGIN
        IF  (fieldno MOD 2) = 1
        THEN
            BEGIN
            IF  (fieldno > 1) AND name_space_line
            THEN
                t09put (term, term.blank_window_line, cut_protected);
            (*ENDIF*) 
            ta09next_line (term);
            curr             := term.currline;
            last_line        := curr;
            last_window_line := term.window_currline;
            IF  fieldno = 1
            THEN
                BEGIN
                first_line        := curr;
                first_window_line := term.window_currline
                END;
            (*ENDIF*) 
            term.lines [curr] := term.blank_window_line;
            WITH term.ln_desc [curr] DO
                BEGIN
                WITH mask_spec [fieldno] DO
                    BEGIN
                    ld_attr1    := msg_in_attr;
                    ld_in_code1 := code_input;
                    IF  (in_len < 1) OR (in_len > NAME_MXSP00)
                    THEN
                        ld_in_len1 := NAME_MXSP00
                    ELSE
                        ld_in_len1 := in_len;
                    (*ENDIF*) 
                    IF  (cursor_col = 0) AND
                        (msg_in_attr [c_in] <> cut_protected) AND
                        (msg_in_attr [c_in] <> cut_bright_protected)
                    THEN
                        BEGIN
                        cursor_line := term.window_currline;
                        cursor_col  := get1name_in_pos
                        END
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                IF  fieldno < count_names
                THEN
                    WITH mask_spec [fieldno+1] DO
                        BEGIN
                        ld_type     := lt_get2name;
                        ld_attr2    := msg_in_attr;
                        ld_in_code2 := code_input;
                        IF  (in_len < 1) OR (in_len > NAME_MXSP00)
                        THEN
                            ld_in_len2 := NAME_MXSP00
                        ELSE
                            ld_in_len2 := in_len;
                        (*ENDIF*) 
                        IF  (cursor_col = 0) AND
                            (msg_in_attr [c_in] <> cut_protected) AND
                            (msg_in_attr [c_in] <> cut_bright_protected)
                        THEN
                            BEGIN
                            cursor_line := term.window_currline;
                            cursor_col  := get2name_in_pos
                            END
                        (*ENDIF*) 
                        END
                    (*ENDWITH*) 
                ELSE
                    ld_type := lt_get1name
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
            msg_offset := get1name_msg_pos-1;
            in_offset  := get1name_in_pos-1;
            END
        ELSE
            BEGIN
            msg_offset := get2name_msg_pos-1;
            in_offset  := get2name_in_pos-1
            END;
        (*ENDIF*) 
        SAPDB_PascalForcedMove (sizeof (mask_spec [fieldno].msg),
              sizeof (term.lines [curr]),
              @mask_spec [fieldno].msg, 1,
              @term.lines [curr], msg_offset+1,
              sizeof (mask_spec [fieldno].msg));
        SAPDB_PascalForcedMove (sizeof (mask_spec [fieldno].in_name),
              sizeof (term.lines [curr]),
              @mask_spec [fieldno].in_name, 1,
              @term.lines[curr], in_offset+1,
              sizeof (mask_spec [fieldno].in_name))
        END;
    (*ENDFOR*) 
    IF  term.window_currline + 2 * (mask_size - count_names)
        <= term.window_lines
    THEN
        c256_space_line := true
    ELSE
        BEGIN
        c256_space_line := false;
        IF  (term.window_currline + 1 + mask_size - count_names
            <= term.window_lines)
            AND
            (count_names > 0)
        THEN
            t09put (term, term.blank_window_line, cut_protected)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    FOR fieldno := count_names + 1 TO mask_size DO
        BEGIN
        IF  c256_space_line AND (fieldno > 1)
        THEN
            t09put (term, term.blank_window_line, cut_protected);
        (*ENDIF*) 
        ta09next_line (term);
        curr             := term.currline;
        last_line        := curr;
        last_window_line := term.window_currline;
        IF  fieldno = count_names + 1
        THEN
            BEGIN
            first_c256_line := curr;
            IF  count_names = 0
            THEN
                BEGIN
                first_line        := curr;
                first_window_line := term.window_currline
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        term.lines   [curr]         := term.blank_window_line;
        term.ln_desc [curr].ld_type := lt_getc256;
        WITH mask_spec [fieldno] DO
            BEGIN
            term.ln_desc [curr].ld_attr1    := msg_in_attr;
            term.ln_desc [curr].ld_in_code1 := false;
            IF  (in_len < 1) OR (in_len > trunc_c256)
            THEN
                term.ln_desc [curr].ld_in_len1 := trunc_c256
            ELSE
                term.ln_desc [curr].ld_in_len1 := in_len;
            (*ENDIF*) 
            SAPDB_PascalForcedMove (sizeof (msg), sizeof (term.lines [curr]),
                  @msg, 1, @term.lines [curr], get1name_msg_pos,
                  sizeof (msg));
            SAPDB_PascalForcedMove (sizeof (in_c256), sizeof (term.lines [curr]),
                  @in_c256, 1, @term.lines [curr], get1name_in_pos,
                  trunc_c256);
            IF  (cursor_col = 0) AND
                (msg_in_attr [c_in] <> cut_protected) AND
                (msg_in_attr [c_in] <> cut_bright_protected)
            THEN
                BEGIN
                cursor_line := term.window_currline;
                cursor_col  := get1name_in_pos
                END
            (*ENDIF*) 
            END
        (*ENDWITH*) 
        END;
    (*ENDFOR*) 
    term.currline := first_line;
    IF  cursor_col = 0
    THEN
        BEGIN
        term.window_currline := first_window_line;
        term.currcol         := 1
        END
    ELSE
        BEGIN
        term.window_currline := cursor_line;
        term.currcol         := cursor_col
        END;
    (*ENDIF*) 
    IF  NOT term.is_inputfile
    THEN
        BEGIN
        IF  cursor_col = 0
        THEN (* show only ==> holding *)
            ta09display_internal_msg (term, NOT c_immediate_displ,
                  holding_msg, io_result);
        (*ENDIF*) 
        ta09build_page (term, c_get_input, NOT c_set_left_right,
              return_pfkey, pfkey, io_result);
        IF  cursor_col = 0
        THEN (* show only ==> reset holding msg *)
            ta09display_internal_msg (term, NOT c_immediate_displ,
                  bsp_c20, io_result)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (pfkey = pf_none) OR
        (return_pfkey AND (pfkey in [pf_up, pf_down, pf_end, pf_run]))
    THEN
        BEGIN
        curr := first_line;
        FOR fieldno := 1 TO count_names DO
            BEGIN
            IF  (fieldno MOD 2) = 1
            THEN
                in_offset := get1name_in_pos-1
            ELSE
                in_offset := get2name_in_pos-1;
            (*ENDIF*) 
            WITH mask_spec [fieldno] DO
                BEGIN
                SAPDB_PascalForcedMove (sizeof (term.lines [curr]), sizeof (in_name),
                      @term.lines [curr],
                      in_offset+1, @in_name, 1, sizeof (in_name));
                IF  in_len < sizeof (in_name)
                THEN
                    in_name [in_len+1] := ' ';
                (*ENDIF*) 
                IF  code_input
                THEN
                    BEGIN
                    in_name [3] := ' ';
                    in_name [6] := ' '
                    END;
                (*ENDIF*) 
                IF  upper_case
                THEN
                    ta09upper_case_name (in_name);
                (*ENDIF*) 
                ta09n_remove_double_quotes (in_name)
                END;
            (*ENDWITH*) 
            IF  (fieldno MOD 2) = 0
            THEN
                BEGIN
                IF  name_space_line
                THEN
                    curr := ((curr + 1) MOD cut_max_lines_term) + 1
                ELSE
                    curr := (curr MOD cut_max_lines_term) + 1
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        curr := first_c256_line;
        FOR fieldno := count_names + 1
              TO mask_size DO
            BEGIN
            WITH mask_spec [fieldno] DO
                BEGIN
                SAPDB_PascalForcedMove (sizeof (term.lines [curr]), sizeof (in_c256),
                      @term.lines [curr], get1name_in_pos,
                      @in_c256, 1, trunc_c256);
                IF  in_len < sizeof (in_c256)
                THEN
                    in_c256 [in_len+1] := ' ';
                (*ENDIF*) 
                IF  upper_case
                THEN
                    ta09upper_c256 (in_c256);
                (*ENDIF*) 
                ta09c256_remove_double_quotes (in_c256)
                END;
            (*ENDWITH*) 
            IF  c256_space_line
            THEN
                curr := ((curr+1) MOD cut_max_lines_term) + 1
            ELSE
                curr := (curr MOD cut_max_lines_term) + 1
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    term.currline        := last_line;
    term.window_currline := last_window_line;
    term.is_mask         := false
    END;
(*ENDIF*) 
t09putmsg (term, term.blankline, NOT c_warning, NOT c_immediate_displ)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09mask_c256_n (VAR term : tut_terminal;
            count_names   : integer;
            mask_size     : integer;
            VAR mask_spec : tut_term_mask;
            return_pfkey  : boolean;
            VAR pfkey     : tut_pfkey);
 
VAR
      use_space_line    : boolean;
      infile_get_input  : boolean;
      i                 : integer;
      fieldno           : integer;
      msg_offset        : integer;
      in_offset         : integer;
      curr              : integer;
      first_line        : integer;
      first_window_line : integer;
      cursor_line       : integer;
      cursor_col        : integer;
      last_line         : integer;
      last_window_line  : integer;
      first_c256_line    : integer;
      trunc_c256         : integer;
      aux_name          : tsp00_Name;
      aux_c256           : tsp00_C256;
      default_c256       : tsp00_C256;
      io_result         : tsp00_VtResult;
 
BEGIN
pfkey := pf_none;
t09goto_bottom (term); (* PTS 1000203 JA 1997-11-12 *)
infile_get_input := false;
IF  term.is_inputfile
THEN
    BEGIN
    i := 1;
    WHILE NOT infile_get_input AND (i <= mask_size) DO
        BEGIN
        infile_get_input :=
              (mask_spec[i].msg_in_attr [c_in] <> cut_bright_protected)
              AND
              (mask_spec[i].msg_in_attr [c_in] <> cut_protected);
        i := i + 1
        END
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
IF  infile_get_input OR term.is_batch OR NOT term.is_virt_term
THEN
    BEGIN
    IF  count_names + 1 <= mask_size
    THEN
        BEGIN
        default_c256 := term.blankfilename;
        aux_name    := default_param;
        FOR i := 1 TO sizeof (aux_name) DO
            default_c256 [i] := aux_name [i]
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    i := count_names + 1;
    WHILE (pfkey = pf_none) AND (i <= mask_size) DO
        BEGIN
        WITH mask_spec [i] DO
            IF  (msg_in_attr [c_in] <> cut_protected       ) AND
                (msg_in_attr [c_in] <> cut_bright_protected)
            THEN
                BEGIN
                aux_c256 := in_c256;
                t09getc256 (term, msg, msg_in_attr [c_out],
                      msg_in_attr[c_in], in_len, upper_case,
                      in_c256, pfkey);
                IF  in_c256 = default_c256
                THEN
                    in_c256 := aux_c256
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
        i := i + 1
        END;
    (*ENDWHILE*) 
    i := 1;
    WHILE (pfkey = pf_none) AND (i <= count_names) DO
        BEGIN
        WITH mask_spec [i] DO
            IF  (msg_in_attr [c_in] <> cut_protected       ) AND
                (msg_in_attr [c_in] <> cut_bright_protected)
            THEN
                BEGIN
                aux_name := in_name;
                t09get1name (term, msg, msg_in_attr [c_out],
                      msg_in_attr [c_in], in_len, upper_case,
                      in_name, pfkey);
                IF  in_name = default_param
                THEN
                    in_name := aux_name
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
        i := i + 1
        END
    (*ENDWHILE*) 
    END
ELSE
    BEGIN
    trunc_c256 := term.window_cols - get1name_in_pos;
    IF  trunc_c256 > sizeof (tsp00_C256)
    THEN
        trunc_c256 := sizeof (tsp00_C256);
    (*ENDIF*) 
    cursor_line    := 0;
    cursor_col     := 0;
    first_c256_line := 0;
    term.is_mask   := true;
    use_space_line :=
          term.window_currline
          +  2 * ((count_names + 1) DIV 2)
          +  2 * (mask_size - count_names)
          <= term.window_lines;
    FOR fieldno := count_names + 1 TO mask_size DO
        BEGIN
        IF  use_space_line AND (fieldno > count_names + 1)
        THEN
            t09put (term, term.blank_window_line, cut_protected);
        (*ENDIF*) 
        ta09next_line (term);
        curr             := term.currline;
        last_line        := curr;
        last_window_line := term.window_currline;
        IF  fieldno = count_names + 1
        THEN
            BEGIN
            first_c256_line    := curr;
            first_window_line := term.window_currline;
            END;
        (*ENDIF*) 
        term.lines   [curr]         := term.blank_window_line;
        term.ln_desc [curr].ld_type := lt_getc256;
        WITH mask_spec [fieldno] DO
            BEGIN
            term.ln_desc [curr].ld_attr1    := msg_in_attr;
            term.ln_desc [curr].ld_in_code1 := false;
            IF  (in_len < 1) OR (in_len > trunc_c256)
            THEN
                term.ln_desc [curr].ld_in_len1 := trunc_c256
            ELSE
                term.ln_desc [curr].ld_in_len1 := in_len;
            (*ENDIF*) 
            SAPDB_PascalForcedMove (sizeof (msg), sizeof (term.lines [curr]),
                  @msg, 1, @term.lines [curr], get1name_msg_pos,
                  sizeof (msg));
            SAPDB_PascalForcedMove (sizeof (in_c256), sizeof (term.lines [curr]),
                  @in_c256, 1, @term.lines [curr], get1name_in_pos,
                  trunc_c256);
            IF  (cursor_col = 0) AND
                (msg_in_attr [c_in] <> cut_protected) AND
                (msg_in_attr [c_in] <> cut_bright_protected)
            THEN
                BEGIN
                cursor_line := term.window_currline;
                cursor_col  := get1name_in_pos
                END
            (*ENDIF*) 
            END
        (*ENDWITH*) 
        END;
    (*ENDFOR*) 
    FOR fieldno := 1 TO count_names DO
        BEGIN
        IF  (fieldno MOD 2) = 1
        THEN
            BEGIN
            IF  use_space_line
            THEN
                t09put (term, term.blank_window_line, cut_protected);
            (*ENDIF*) 
            ta09next_line (term);
            curr             := term.currline;
            last_line        := curr;
            last_window_line := term.window_currline;
            IF  fieldno = 1
            THEN
                BEGIN
                first_line := curr;
                IF  count_names = mask_size
                THEN
                    first_window_line := term.window_currline
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            term.lines [curr] := term.blank_window_line;
            WITH term.ln_desc [curr] DO
                BEGIN
                WITH mask_spec [fieldno] DO
                    BEGIN
                    ld_attr1    := msg_in_attr;
                    ld_in_code1 := code_input;
                    IF  (in_len < 1) OR (in_len > NAME_MXSP00)
                    THEN
                        ld_in_len1 := NAME_MXSP00
                    ELSE
                        ld_in_len1 := in_len;
                    (*ENDIF*) 
                    IF  (cursor_col = 0) AND
                        (msg_in_attr [c_in] <> cut_protected) AND
                        (msg_in_attr [c_in] <> cut_bright_protected)
                    THEN
                        BEGIN
                        cursor_line := term.window_currline;
                        cursor_col  := get1name_in_pos
                        END
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                IF  fieldno < count_names
                THEN
                    WITH mask_spec [fieldno+1] DO
                        BEGIN
                        ld_type     := lt_get2name;
                        ld_attr2    := msg_in_attr;
                        ld_in_code2 := code_input;
                        IF  (in_len < 1) OR (in_len > NAME_MXSP00)
                        THEN
                            ld_in_len2 := NAME_MXSP00
                        ELSE
                            ld_in_len2 := in_len;
                        (*ENDIF*) 
                        IF  (cursor_col = 0) AND
                            (msg_in_attr [c_in] <> cut_protected) AND
                            (msg_in_attr [c_in] <> cut_bright_protected)
                        THEN
                            BEGIN
                            cursor_line := term.window_currline;
                            cursor_col  := get2name_in_pos
                            END
                        (*ENDIF*) 
                        END
                    (*ENDWITH*) 
                ELSE
                    ld_type := lt_get1name
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
            msg_offset := get1name_msg_pos-1;
            in_offset  := get1name_in_pos-1;
            END
        ELSE
            BEGIN
            msg_offset := get2name_msg_pos-1;
            in_offset  := get2name_in_pos-1
            END;
        (*ENDIF*) 
        SAPDB_PascalForcedMove (sizeof (mask_spec [fieldno].msg),
              sizeof (term.lines [curr]),
              @mask_spec [fieldno].msg, 1,
              @term.lines [curr], msg_offset+1,
              sizeof (mask_spec [fieldno].msg));
        SAPDB_PascalForcedMove (sizeof (mask_spec [fieldno].in_name),
              sizeof (term.lines [curr]),
              @mask_spec [fieldno].in_name, 1,
              @term.lines[curr], in_offset+1,
              sizeof (mask_spec [fieldno].in_name))
        END;
    (*ENDFOR*) 
    term.currline := first_window_line;
    IF  cursor_col = 0
    THEN
        BEGIN
        term.window_currline := first_window_line;
        term.currcol         := 1
        END
    ELSE
        BEGIN
        term.window_currline := cursor_line;
        term.currcol         := cursor_col
        END;
    (*ENDIF*) 
    IF  NOT term.is_inputfile
    THEN
        BEGIN
        IF  cursor_col = 0
        THEN (* show only ==> holding *)
            ta09display_internal_msg (term, NOT c_immediate_displ,
                  holding_msg, io_result);
        (*ENDIF*) 
        ta09build_page (term, c_get_input, NOT c_set_left_right,
              return_pfkey, pfkey, io_result);
        IF  cursor_col = 0
        THEN (* show only ==> reset holding msg *)
            ta09display_internal_msg (term, NOT c_immediate_displ,
                  bsp_c20, io_result)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (pfkey = pf_none) OR
        (return_pfkey AND (pfkey in [pf_up, pf_down, pf_end, pf_run]))
    THEN
        BEGIN
        curr := first_line;
        FOR fieldno := 1 TO count_names DO
            BEGIN
            IF  (fieldno MOD 2) = 1
            THEN
                in_offset := get1name_in_pos-1
            ELSE
                in_offset := get2name_in_pos-1;
            (*ENDIF*) 
            WITH mask_spec [fieldno] DO
                BEGIN
                SAPDB_PascalForcedMove (sizeof (term.lines [curr]), sizeof (in_name),
                      @term.lines [curr],
                      in_offset+1, @in_name, 1, sizeof (in_name));
                IF  in_len < sizeof (in_name)
                THEN
                    in_name [in_len+1] := ' ';
                (*ENDIF*) 
                IF  code_input
                THEN
                    BEGIN
                    in_name [3] := ' ';
                    in_name [6] := ' '
                    END;
                (*ENDIF*) 
                IF  upper_case
                THEN
                    ta09upper_case_name (in_name);
                (*ENDIF*) 
                ta09n_remove_double_quotes (in_name)
                END;
            (*ENDWITH*) 
            IF  (fieldno MOD 2) = 0
            THEN
                BEGIN
                IF  use_space_line
                THEN
                    curr := ((curr + 1) MOD cut_max_lines_term) + 1
                ELSE
                    curr := (curr MOD cut_max_lines_term) + 1
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        curr := first_c256_line;
        FOR fieldno := count_names + 1 TO mask_size DO
            BEGIN
            WITH mask_spec [fieldno] DO
                BEGIN
                SAPDB_PascalForcedMove (sizeof (term.lines [curr]), sizeof (in_c256),
                      @term.lines [curr], get1name_in_pos,
                      @in_c256, 1, trunc_c256);
                IF  in_len < sizeof (in_c256)
                THEN
                    in_c256 [in_len+1] := ' ';
                (*ENDIF*) 
                IF  upper_case
                THEN
                    ta09upper_c256 (in_c256);
                (*ENDIF*) 
                ta09c256_remove_double_quotes (in_c256)
                END;
            (*ENDWITH*) 
            IF  use_space_line
            THEN
                curr := ((curr+1) MOD cut_max_lines_term) + 1
            ELSE
                curr := (curr MOD cut_max_lines_term) + 1
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    term.currline        := last_line;
    term.window_currline := last_window_line;
    term.is_mask         := false
    END;
(*ENDIF*) 
t09putmsg (term, term.blankline, NOT c_warning, NOT c_immediate_displ)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09menu (VAR term  : tut_terminal;
            size         : integer;
            msg_attr     : char;
            VAR msg      : tut_c20_array;
            VAR selected : integer;
            VAR pfkey    : tut_pfkey);
 
VAR
      ok          : boolean;
      show_errmsg : boolean;
      io_result   : tsp00_VtResult;
      ln          : tsp00_Line;
 
BEGIN
show_errmsg := false;
ok          := false;
REPEAT
    ln := term.blankline;
    t09getmenu (term, size, msg_attr, NOT c_upper_case, msg,
          selected, pfkey, ln, ok);
    IF  NOT ok
    THEN
        BEGIN
        IF  pfkey <> pf_none
        THEN
            selected := 1;
        (*ENDIF*) 
        IF  (selected < 1) OR (selected > size)
        THEN
            BEGIN
            show_errmsg := true;
            ta09display_internal_msg (term, NOT c_immediate_displ,
                  illegal_input_msg, io_result);
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
UNTIL
    ((selected >= 1) AND (selected <= size)) OR (pfkey <> pf_none);
(*ENDREPEAT*) 
IF  show_errmsg
THEN
    ta09display_internal_msg (term, NOT c_immediate_displ,
          bsp_c20, io_result)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09msgheader (VAR term : tut_terminal;
            msg     : tsp00_C30;
            is_perm : boolean);
 
VAR
      cursor_col  : tsp00_Int2;
      cursor_line : tsp00_Int2;
      options     : tsp00_VtOptions;
      io_result   : tsp00_VtResult;
      old_msg     : tsp00_C30;
 
BEGIN
IF  term.is_virt_term AND term.is_display
THEN
    BEGIN
    SAPDB_PascalForcedMove (term.screen_chars, sizeof (old_msg),
          @term.screen_buf^, screen_header_msg_offset + 1,
          @old_msg, 1, sizeof (old_msg));
    SAPDB_PascalForcedMove (sizeof (msg), term.screen_chars,
          @msg, 1,
          @term.screen_buf^, screen_header_msg_offset + 1,
          sizeof (msg));
    IF  NOT is_perm
    THEN
        BEGIN
        WITH options DO
            BEGIN
            wait_for_input        := false;
            usage_mode            := vt_form;
            return_on_last        := false;
            return_on_first       := false;
            returnkeys            := [vt_enter .. vt_end_key,
                  vt_mouse_down .. vt_mouse_dbl]; (* PTS 1000203 JA 1997-11-12 *)
            reject_keys           := [ ];
            bell                  := false;
            mark                  := vt_mark_off;
            first_line_changed    := 1;
            last_line_changed     := term.screen_lines;
            screen2_first_changed := 0;
            screen2_last_changed  := 0;
            overtype              := false
            END;
        (*ENDWITH*) 
        cursor_line := term.window_currline + term.header_lines;
        cursor_col  := term.currcol;
&       ifdef WINDOWS
        sqltsysline (term.term_ref, 1, term.hif.sys_text,
              term.hif.sys_attr, term.io_ok);
&       endif
        sqltio (term.term_ref, term.screen_buf, term.screen_att,
              NOT c_refresh, cursor_line, cursor_col,
              term.hif, options, io_result, term.io_ok);
        SAPDB_PascalForcedMove (sizeof (old_msg), term.screen_chars,
              @old_msg, 1,
              @term.screen_buf^, screen_header_msg_offset + 1,
              sizeof (old_msg))
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09newscreen_page (VAR term : tut_terminal);
 
VAR
      pfkey     : tut_pfkey;
      io_result : tsp00_VtResult;
 
BEGIN
IF  NOT term.is_virt_term
THEN
    BEGIN
    IF  term.is_display
    THEN
        t05newline
    (*ENDIF*) 
    END
ELSE
    BEGIN
    pfkey := pf_none;
    IF  term.is_inputfile AND NOT term.is_batch
        AND (term.window_currline > 0)
    THEN
        BEGIN
        term.is_inputfile := false;
        t09holding (term, pfkey);
        IF  (pfkey <> pf_cancel) AND (pfkey <> pf_end)
        THEN
            term.is_inputfile := true
        ELSE
            BEGIN
            t13close_file (term);
            IF  term.curr_inputfile <= 0
            THEN
                BEGIN
                IF  NOT term.is_display
                THEN
                    term.is_display := term.screen_available;
                (*ENDIF*) 
                term.is_inputfile := false
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (term.put_linecount > 0) AND term.is_display
    THEN
        ta09build_page (term, NOT c_get_input, NOT c_set_left_right,
              NOT c_return_pfkey, pfkey, io_result);
    (*ENDIF*) 
    term.used_window_lines := 0;
    term.window_currline   := 0;
    term.currcol           := 1;
    IF  NOT term.use_pfkeys
    THEN
        term.currline := term.window_bottom;
    (*ENDIF*) 
    term.window_top := (term.currline MOD cut_max_lines_term) + 1;
    term.ln_desc [term.window_top].ld_new_page := true
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09pfkeys (VAR term : tut_terminal; on : boolean);
 
VAR
      i : integer;
 
BEGIN
WITH term.hif DO
    IF  slabels [label_end] <> str_is_pfkey
    THEN
        BEGIN
        FOR i := 1 TO csp_sk_number DO
            BEGIN
            slabels [i]     := bsp_c8;
            llabels [i] [1] := bsp_c8;
            llabels [i] [2] := bsp_c8
            END;
        (*ENDFOR*) 
        IF  on
        THEN
            BEGIN
            slabels [label_end   ]     := str_end_label;
            llabels [label_end   ] [1] := str_end_label;
            slabels [label_cancel]     := str_cancel_label;
            llabels [label_cancel] [1] := str_cancel_label;
            slabels [label_nohold]     := str_nohold_label;
            llabels [label_nohold] [1] := str_nohold_label
            END
        ELSE
            BEGIN
            slabels [label_end]     := str_end_label;
            llabels [label_end] [1] := str_end_label
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
term.use_pfkeys := on
END;
 
(*------------------------------*) 
 
FUNCTION
      t09prot_linesize (VAR term : tut_terminal): integer;
 
BEGIN
IF  term.window_cols = c_default_cols
THEN
    t09prot_linesize := c_default_prot_linesize
ELSE
    t09prot_linesize := term.window_cols -1
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09put (VAR term : tut_terminal;
            VAR ln     : tsp00_Line;
            text_attr  : char);
 
VAR
      pfkey     : tut_pfkey;
      io_result : tsp00_VtResult;
 
BEGIN
IF  term.is_display
THEN
    BEGIN
    ta09next_line (term);
    term.lines   [term.currline] := ln;
    term.ln_desc [term.currline].ld_attr1 [c_out] := text_attr;
    term.ln_desc [term.currline].ld_type          := lt_normal;
    IF  NOT term.is_virt_term
    THEN
        t05write_term (ln)
    ELSE
        IF  term.put_linecount >= term.window_lines
        THEN
            ta09build_page (term, NOT c_get_input, NOT c_set_left_right,
                  NOT c_return_pfkey, pfkey, io_result)
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09put20 (VAR term : tut_terminal;
            ln20         : tsp00_C20;
            text_attr    : char);
 
VAR
      ln : tsp00_Line;
 
BEGIN
ln := term.blank_window_line;
SAPDB_PascalForcedMove (sizeof (ln20), sizeof (ln),
      @ln20, 1, @ln, 1, sizeof (ln20));
t09put (term, ln, text_attr)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09put30 (VAR term : tut_terminal;
            ln30         : tsp00_C30;
            text_attr    : char);
 
VAR
      i  : integer;
      ln : tsp00_Line;
 
BEGIN
ln := term.blank_window_line;
FOR i:=1 TO sizeof (ln30) DO
    ln [i] := ln30 [i];
(*ENDFOR*) 
t09put (term, ln, text_attr)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09put60 (VAR term : tut_terminal;
            ln60         : tsp00_C60;
            text_attr    : char);
 
VAR
      i  : integer;
      ln : tsp00_Line;
 
BEGIN
ln := term.blank_window_line;
FOR i:=1 TO 60 DO
    ln [i+10] := ln60 [i];
(*ENDFOR*) 
t09put (term, ln, text_attr)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09putmsg (VAR term     : tut_terminal;
            VAR msg           : tsp00_Line;
            is_warning        : boolean;
            immediate_display : boolean);
 
VAR
      dummy_pfkey : tut_pfkey;
      io_result   : tsp00_VtResult;
 
BEGIN
IF  term.is_display
THEN
    BEGIN
    IF  NOT term.is_virt_term
    THEN
        t05write_term (msg)
    ELSE
        BEGIN
        IF  term.has_sysline
        THEN
            BEGIN
            SAPDB_PascalForcedMove (sizeof (msg), sizeof (term.hif.sys_text),
                  @msg, 1, @term.hif.sys_text, 2, term.window_cols - 1);
            term.hif.sys_text [1]         := cut_start_of_field;
            term.hif.sys_text [LINE_MXSP00] := cut_end_of_field;
            IF  is_warning AND (msg <> term.blankline)
            THEN
                SAPDB_PascalForcedFill (sizeof (term.hif.sys_attr),
                      @term.hif.sys_attr , 1, sizeof (term.hif.sys_attr),
                      chr (c_warning_color))
            ELSE
                SAPDB_PascalForcedFill (sizeof (term.hif.sys_attr),
                      @term.hif.sys_attr, 1, sizeof (term.hif.sys_attr),
                      ta09color (cut_bright_protected))
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            term.screen_buf^[term.msg_line_offset] :=
                  cut_start_of_field;
            SAPDB_PascalForcedMove (sizeof (msg), term.screen_chars, @msg, 1,
                  @term.screen_buf^, term.msg_line_offset + 1,
                  term.window_cols - 1);
            term.screen_buf^[term.msg_line_offset+term.screen_cols] :=
                  cut_end_of_field;
            IF  is_warning AND (msg <> term.blankline)
            THEN
                SAPDB_PascalForcedFill (term.screen_chars, @term.screen_att^,
                      term.msg_line_offset + 1, term.screen_cols - 1,
                      chr (c_warning_color))
            ELSE
                SAPDB_PascalForcedFill (term.screen_chars, @term.screen_att^,
                      term.msg_line_offset + 1, term.screen_cols - 1,
                      ta09color (cut_bright_protected))
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  immediate_display
        THEN
            ta09build_page (term, NOT c_get_input, NOT c_set_left_right,
                  NOT c_return_pfkey, dummy_pfkey, io_result)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09readscreen_string (VAR term : tut_terminal;
            VAR pfkey : tut_pfkey);
 
CONST
      endsign1 = '/';
      endsign2 = '*';
 
VAR
      in_string1 : boolean;
      in_string2 : boolean;
      is_first   : boolean;
      i          : integer;
      cmd_no     : integer;
      count      : integer;
      prev_line  : integer;
      io_result  : tsp00_VtResult;
      ln         : tsp00_Line;
 
BEGIN
term.hif.slabels [label_dupl]     := str_dupl_label;
term.hif.llabels [label_dupl] [1] := str_dupl_label;
term.hif.slabels [label_prev]     := str_prev_label;
term.hif.llabels [label_prev] [1] := str_prev_label;
term.is_cmd_read    := true;
term.first_cmd_line := 0;
term.last_cmd_line  := 0;
in_string1          := false;
in_string2          := false;
is_first            := true;
WHILE (term.last_cmd_line < 1) AND (pfkey = pf_none) AND term.io_ok DO
    BEGIN
    ta09getline (term, ln, NOT c_use_default, c_hold_cursor, pfkey);
    IF  pfkey = pf_none
    THEN
        BEGIN
        IF  is_first
        THEN
            BEGIN
            term.first_cmd_line := term.currline;
            prev_line           := term.currline
            END;
        (*ENDIF*) 
        is_first := false;
        IF  NOT in_string1 AND NOT in_string2 AND
            (ln [1] = endsign1) AND (ln [2] = endsign2)
        THEN
            term.last_cmd_line := prev_line
        ELSE
            BEGIN
            i := 1;
            REPEAT
                IF  (ln [i] = string_delimiter) AND NOT in_string2
                THEN
                    in_string1 := NOT in_string1
                ELSE
                    IF  (ln [i] = double_quote) AND NOT in_string1
                    THEN
                        in_string2 := NOT in_string2
                    ELSE
                        IF  (ln [i] = c_endsign)
                            AND NOT in_string1 AND NOT in_string2
                        THEN
                            IF  i = term.window_cols
                            THEN
                                term.last_cmd_line := term.currline
                            ELSE
                                IF  ln[i+1] <> '='
                                THEN
                                    term.last_cmd_line := term.currline;
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                i := i + 1
            UNTIL
                (i > term.window_cols) OR (term.last_cmd_line > 0);
            (*ENDREPEAT*) 
            END;
        (*ENDIF*) 
        prev_line := term.currline
        END
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  pfkey = pf_none
THEN
    BEGIN
    i      := term.first_cmd_line - 1;
    count  := 0;
    cmd_no := term.last_cmd_no;
    cmd_no := (cmd_no MOD cut_max_cmds_term) + 1;
    REPEAT
        i     := (i MOD cut_max_lines_term) + 1;
        count := count + 1;
        term.last_cmd_lines [cmd_no] [count] := term.lines [i];
    UNTIL
        (i = term.last_cmd_line) OR (count >= cut_max_cmd_lines_term);
    (*ENDREPEAT*) 
    term.count_cmd_lines [cmd_no] := count;
    term.last_cmd_no := cmd_no;
    IF  (term.is_batch OR term.is_inputfile)
        AND (term.put_linecount > 0)
        AND term.is_virt_term AND term.is_display
    THEN
        ta09build_page (term, NOT c_get_input, NOT c_set_left_right,
              NOT c_return_pfkey, pfkey, io_result)
    (*ENDIF*) 
    END;
(*ENDIF*) 
term.is_cmd_read := false;
term.hif.slabels [label_dupl]     := bsp_c8;
term.hif.llabels [label_dupl] [1] := bsp_c8;
term.hif.slabels [label_prev]     := bsp_c8;
term.hif.llabels [label_prev] [1] := bsp_c8
END;
 
(*------------------------------*) 
 
FUNCTION
      t09retcode (VAR term : tut_terminal) : integer;
 
BEGIN
t09retcode := term.retcode
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09returncode_set (VAR term : tut_terminal;
            retcode : integer);
 
BEGIN
term.retcode := retcode
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09right_left_holding (VAR term : tut_terminal;
            turn_right     : boolean;
            turn_left      : boolean;
            VAR is_running : boolean;
            VAR pfkey      : tut_pfkey);
 
VAR
      io_result : tsp00_VtResult;
      msg       : tsp00_C20;
 
BEGIN
pfkey      := pf_none;
is_running := false;
IF  NOT term.is_inputfile AND NOT term.is_batch AND term.is_holding
    AND term.is_virt_term AND term.is_display
THEN
    BEGIN
    IF  NOT term.use_pfkeys
    THEN
        BEGIN
        term.hif.slabels [label_nohold]     := str_nohold_label;
        term.hif.llabels [label_nohold] [1] := str_nohold_label
        END;
    (*ENDIF*) 
    IF  turn_left
    THEN
        BEGIN
        term.hif.slabels [label_left]     := str_left_label;
        term.hif.llabels [label_left] [1] := str_left_label
        END;
    (*ENDIF*) 
    IF  turn_right
    THEN
        BEGIN
        term.hif.slabels [label_right]     := str_right_label;
        term.hif.llabels [label_right] [1] := str_right_label
        END;
    (*ENDIF*) 
    IF  turn_left AND turn_right
    THEN
        msg := holding_left_right_msg
    ELSE
        IF  turn_left
        THEN
            msg := holding_left_msg
        ELSE
            msg := holding_right_msg;
        (*ENDIF*) 
    (*ENDIF*) 
    ta09display_internal_msg (term, NOT c_immediate_displ,
          msg, io_result);
    ta09build_page (term, c_get_input, c_set_left_right,
          NOT c_return_pfkey, pfkey, io_result);
    IF  term.is_holding
    THEN
        ta09display_internal_msg (term, NOT c_immediate_displ,
              bsp_c20, io_result);
    (*ENDIF*) 
    IF  NOT term.use_pfkeys
    THEN
        BEGIN
        term.hif.slabels [label_nohold]     := bsp_c8;
        term.hif.llabels [label_nohold] [1] := bsp_c8
        END;
    (*ENDIF*) 
    term.hif.slabels [label_left ]     := bsp_c8;
    term.hif.llabels [label_left ] [1] := bsp_c8;
    term.hif.slabels [label_right]     := bsp_c8;
    term.hif.llabels [label_right] [1] := bsp_c8
    END;
(*ENDIF*) 
is_running := NOT term.is_holding
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09sendscreen (VAR term : tut_terminal);
 
BEGIN
WHILE term.curr_inputfile > 0 DO
    t13close_file (term)
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09setpf1 (VAR term : tut_terminal; pfkey_label : tsp00_C8);
 
BEGIN
term.hif.slabels [label_help]     := pfkey_label;
term.hif.llabels [label_help] [1] := pfkey_label
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09string_get_screen (VAR term : tut_terminal;
            VAR ln        : tsp00_Line;
            VAR last_line : boolean);
 
VAR
      pos : integer;
 
BEGIN
IF  term.first_cmd_line < 1
THEN
    BEGIN
    term.first_cmd_line := term.currline;
    term.last_cmd_line  := term.currline
    END;
(*ENDIF*) 
ln := term.blankline;
IF  term.lines [term.first_cmd_line] [1] = prompting_sign
THEN
    pos := 2
ELSE
    pos := 1;
(*ENDIF*) 
SAPDB_PascalForcedMove (sizeof (term.lines [term.first_cmd_line]), sizeof (ln),
      @term.lines [term.first_cmd_line], pos,
      @ln, 1, term.window_cols - pos);
IF  term.first_cmd_line = term.last_cmd_line
THEN
    BEGIN
    last_line := true;
    term.first_cmd_line := 0
    END
ELSE
    BEGIN
    last_line := false;
    term.first_cmd_line :=
          (term.first_cmd_line MOD cut_max_lines_term) + 1
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      t09unused_window_lines (VAR term : tut_terminal): integer;
 
BEGIN
IF  term.window_lines - term.used_window_lines > 0
THEN
    t09unused_window_lines := term.window_lines - term.used_window_lines
ELSE
    t09unused_window_lines := 0
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t09uppercase_line (VAR ln : tsp00_Line;
            lwb : integer;
            upb : integer);
 
VAR
      i          : integer;
      is_string1 : boolean;
      is_string2 : boolean;
 
BEGIN
is_string1 := false;
is_string2 := false;
FOR i := lwb TO upb DO
    BEGIN
    IF  ln [i] = string_delimiter
    THEN
        is_string1 := NOT is_string1
    ELSE
        IF  (ln [i] = double_quote) AND NOT is_string1
        THEN
            is_string2 := NOT is_string2;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  (ln [i] in ['a'..'i', 'j'..'r',  's'..'z'])
        AND NOT is_string1 AND NOT is_string2
    THEN
        ln [i] := chr (ord (ln [i]) + ord('A') - ord ('a'))
    (*ENDIF*) 
    END
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      t09window_cols (VAR term : tut_terminal): integer;
 
BEGIN
t09window_cols := term.window_cols -1
END;
 
(*------------------------------*) 
 
FUNCTION
      t09window_lines (VAR term : tut_terminal): integer;
 
BEGIN
t09window_lines := term.window_lines
END;
 
(*======================local functions=========================*)
(*------------------------------*) 
 
PROCEDURE
      ta09build_page (VAR term : tut_terminal;
            get_input          : boolean;
            set_left_right     : boolean;
            return_pfkey       : boolean;
            VAR pfkey          : tut_pfkey;
            VAR io_result      : tsp00_VtResult);
 
VAR
      is_key_ok       : boolean;
      curr            : integer;
      i               : integer;
      label_len       : integer;
      msg_pos         : integer;
      pos             : integer;
      screen_offset   : integer;
      bottom_pos      : integer;
      old_currline    : integer;
      old_window_curr : integer;
      cursor_col      : tsp00_Int2;
      cursor_line     : tsp00_Int2;
      options         : tsp00_VtOptions;
      cmd_no          : integer;
      (* ======== pfkey message =====*)
      pfkey_msg_len   : tsp00_Int2;
      pfkey_msg       : tsp00_C60;
 
BEGIN
&ifdef test
write ('********** build_page:');
IF  term.screen_available
THEN
    write (' screen_available');
(*ENDIF*) 
IF  get_input
THEN
    write (' get_input');
(*ENDIF*) 
writeln;
&endif
IF  term.screen_available
THEN
    BEGIN
    term.put_linecount       := 0;
    io_result.screen_changed := false;
    cmd_no                   := term.last_cmd_no;
    REPEAT
        is_key_ok              := false;
        curr                   := term.window_top;
        screen_offset          := term.header_lines * term.screen_cols;
        term.used_window_lines := 0;
        IF  term.window_currline > 0
        THEN
            REPEAT
                term.used_window_lines := term.used_window_lines + 1;
                SAPDB_PascalForcedMove (sizeof (term.lines [curr]),
                      term.screen_chars, @term.lines [curr],
                      1, @term.screen_buf^, screen_offset + 1,
                      term.window_cols - 1);
                IF  screen_offset > 0
                THEN
                    term.screen_buf^[screen_offset] :=
                          cut_start_of_field
                ELSE
                    term.screen_buf^[1] := cut_start_of_field;
                (*ENDIF*) 
                WITH term.ln_desc [curr] DO
                    BEGIN
                    IF  ld_type = lt_normal
                    THEN
                        SAPDB_PascalForcedFill (term.screen_chars, @term.screen_att^,
                              screen_offset + 1, term.window_cols - 1,
                              ta09color (ld_attr1 [c_out]))
                    ELSE
                        BEGIN
                        SAPDB_PascalForcedFill (term.screen_chars, @term.screen_att^,
                              screen_offset + 1, term.window_cols - 1,
                              ta09color (cut_protected));
                        SAPDB_PascalForcedFill (term.screen_chars, @term.screen_att^,
                              screen_offset + 1, c_msg_size,
                              ta09color (ld_attr1 [c_out]));
                        pos := screen_offset + c_msg_size + 1;
                        term.screen_buf^[pos] := cut_start_of_field;
                        pos := pos + 1;
                        SAPDB_PascalForcedFill (term.screen_chars, @term.screen_att^,
                              pos, ld_in_len1,
                              ta09color (ld_attr1 [c_in]));
                        IF  ld_in_code1
                        THEN
                            BEGIN
                            term.screen_buf^[pos+2] :=
                                  cut_start_of_field;
                            term.screen_buf^[pos+5] :=
                                  cut_start_of_field
                            END;
                        (*ENDIF*) 
                        term.screen_buf^[pos + ld_in_len1] :=
                              cut_end_of_field
                        END;
                    (*ENDIF*) 
                    IF  ld_type = lt_get2name
                    THEN
                        BEGIN
                        pos := pos + NAME_MXSP00;
                        term.screen_buf^[pos] := cut_start_of_field;
                        pos := pos + 1;
                        SAPDB_PascalForcedFill (term.screen_chars, @term.screen_att^,
                              pos, c_msg_size,
                              ta09color (ld_attr2 [c_out]));
                        pos := pos + c_msg_size;
                        term.screen_buf^[pos] := cut_start_of_field;
                        pos := pos + 1;
                        SAPDB_PascalForcedFill (term.screen_chars, @term.screen_att^,
                              pos, ld_in_len2,
                              ta09color (ld_attr2 [c_in]));
                        IF  ld_in_code2
                        THEN
                            BEGIN
                            term.screen_buf^[pos+2] :=
                                  cut_start_of_field;
                            term.screen_buf^[pos+5] :=
                                  cut_start_of_field
                            END;
                        (*ENDIF*) 
                        term.screen_buf^[pos + ld_in_len2] :=
                              cut_end_of_field
                        END
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                screen_offset := screen_offset + term.screen_cols;
                curr := (curr MOD cut_max_lines_term) + 1;
            UNTIL
                (term.used_window_lines >= term.window_lines) OR
                (curr = (term.window_bottom MOD cut_max_lines_term) +1);
            (*ENDREPEAT*) 
        (*ENDIF*) 
        IF  term.is_frame
        THEN
            bottom_pos := term.bottom_frame_offset
        ELSE
            bottom_pos := term.bottom_frame_offset + term.screen_cols;
        (*ENDIF*) 
        IF  ((term.used_window_lines < term.window_lines) AND
            (screen_offset < bottom_pos))
        THEN
            BEGIN
            term.screen_buf^[screen_offset] := cut_end_of_field;
            SAPDB_PascalForcedFill (term.screen_chars, @term.screen_buf^,
                  screen_offset + 1, bottom_pos - screen_offset - 1,
                  ' ');
            SAPDB_PascalForcedFill (term.screen_chars, @term.screen_att^,
                  screen_offset + 1, bottom_pos - screen_offset - 1,
                  ta09color (cut_protected));
            END;
        (*ENDIF*) 
        term.screen_buf^[term.help_line_offset] := cut_start_of_field;
        IF  term.help_state
        THEN
            BEGIN
            IF  term.has_sysline
            THEN
                cursor_line := term.screen_lines
            ELSE
                cursor_line := term.screen_lines - 1;
            (*ENDIF*) 
            cursor_col  := 2;
            END
        ELSE
            BEGIN
            cursor_line := term.window_currline + term.header_lines;
            cursor_col  := term.currcol;
            IF  get_input AND
                (term.hif.slabels [label_end] = str_is_pfkey)
            THEN
                BEGIN
                IF  term.use_pfkeys
                THEN
                    BEGIN
                    IF  term.is_cmd_read
                    THEN
                        pfkey_msg := m01
                    ELSE
                        pfkey_msg := m02
                    (*ENDIF*) 
                    END
                ELSE
                    IF  set_left_right
                    THEN
                        BEGIN
                        IF  term.hif.slabels [label_left] = bsp_c8
                        THEN
                            pfkey_msg := m03
                        ELSE
                            IF  term.hif.slabels [label_right] = bsp_c8
                            THEN
                                pfkey_msg := m04
                            ELSE
                                pfkey_msg := m05
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  term.hif.slabels [label_nohold]
                            = str_nohold_label
                        THEN
                            pfkey_msg := m06
                        ELSE
                            pfkey_msg := m07;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                pfkey_msg_len := term.window_cols - c_msg_size - 2;
                IF  pfkey_msg_len > mxsp_c60
                THEN
                    pfkey_msg_len := mxsp_c60;
                (*ENDIF*) 
                IF  term.hif.slabels [label_help] <> bsp_c8
                THEN
                    BEGIN
                    msg_pos := 1;
                    WHILE (msg_pos < sizeof (pfkey_msg)) AND
                          (pfkey_msg [msg_pos] = ' ') DO
                        msg_pos := msg_pos + 1;
                    (*ENDWHILE*) 
                    label_len := sizeof (term.hif.slabels [label_help]);
                    WHILE (label_len > 1) AND
                          (term.hif.slabels [label_help] [label_len] = ' ') DO
                        label_len := label_len - 1;
                    (*ENDWHILE*) 
                    msg_pos := msg_pos - 3 - label_len - 1;
                    IF  msg_pos < 1
                    THEN
                        msg_pos := 1;
                    (*ENDIF*) 
                    pfkey_msg [msg_pos  ] := 'F';
                    pfkey_msg [msg_pos+1] := '1';
                    pfkey_msg [msg_pos+2] := ':';
                    FOR i := 1 TO label_len DO
                        pfkey_msg [msg_pos+2+i] := term.hif.slabels [label_help] [i]
                    (*ENDFOR*) 
                    END;
                (*ENDIF*) 
                SAPDB_PascalForcedMove (sizeof (pfkey_msg), term.screen_chars,
                      @pfkey_msg, 1 + sizeof (pfkey_msg) - pfkey_msg_len,
                      @term.screen_buf^, term.help_line_offset
                      + term.window_cols - pfkey_msg_len,
                      pfkey_msg_len);
                END
            ELSE
                SAPDB_PascalForcedFill (term.screen_chars, @term.screen_buf^,
                      term.help_line_offset + c_msg_size + 2,
                      term.window_cols - c_msg_size - 2, ' ')
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        WITH options DO
            BEGIN
            wait_for_input        := get_input;
            usage_mode            := vt_form;
            return_on_last        := false;
            return_on_first       := false;
            returnkeys            := [vt_enter .. vt_end_key,
                  vt_mouse_down ..vt_mouse_dbl]; (* PTS 1000203 JA 1997-11-12 *)
            reject_keys           := [ ];
            bell                  := false;
            mark                  := vt_mark_off;
            first_line_changed    := 1;
            last_line_changed     := term.screen_lines;
            screen2_first_changed := 0;
            screen2_last_changed  := 0;
            overtype              := false;
            END;
        (*ENDWITH*) 
        term.io_ok := true;
&       ifdef test
        writeln ('********** build_page (before IO):');
        file_out_screen (term);
&       endif
&       ifdef WINDOWS
        sqltsysline (term.term_ref, 1, term.hif.sys_text,
              term.hif.sys_attr, term.io_ok);
&       endif
        sqltio (term.term_ref, term.screen_buf, term.screen_att,
              NOT c_refresh, cursor_line, cursor_col,
              term.hif, options, io_result, term.io_ok);
&       ifdef test
        writeln ('********** build_page (after IO):');
        file_out_screen (term);
&       endif
        IF  term.is_reset_called
        THEN
            BEGIN
            io_result.keystroke.key := vt_end_key;
            pfkey                   := pf_end;
            is_key_ok               := true;
            IF  NOT term.is_inputfile
            THEN
                term.is_reset_called := false;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  get_input
        THEN
            BEGIN
            pfkey         := pf_none;
            curr          := term.window_top;
            screen_offset := term.header_lines * term.screen_cols;
            REPEAT
                SAPDB_PascalForcedMove (term.screen_chars, sizeof (term.lines [curr]),
                      @term.screen_buf^, screen_offset + 1,
                      @term.lines [curr], 1, term.window_cols);
                curr := (curr MOD cut_max_lines_term) + 1;
                screen_offset := screen_offset + term.screen_cols;
            UNTIL
                (curr  = (term.window_bottom MOD cut_max_lines_term) +1)
                OR (screen_offset >= term.screen_chars);
            (*ENDREPEAT*) 
            old_currline         := term.currline;
            old_window_curr      := term.window_currline;
            IF  (io_result.keystroke.key = vt_mouse_down) OR
                (io_result.keystroke.key = vt_mouse_dbl )
            THEN
                (* PTS 1000203 JA 1997-11-12 *)
                BEGIN
                term.currcol         := io_result.keystroke.mouse_x;
                term.window_currline := io_result.keystroke.mouse_y - term.header_lines;
                IF  (io_result.keystroke.key = vt_mouse_dbl)
                    AND
                    (term.window_currline > term.window_lines)
                    AND
                    (io_result.keystroke.mouse_y
                    > term.help_line_offset DIV term.window_cols)
                THEN
                    ta09mouse_pfkey_click (term, term.currcol,
                          io_result.keystroke.key)
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                term.currcol         := cursor_col;
                term.window_currline := cursor_line - term.header_lines
                END;
            (*ENDIF*) 
            IF  (term.window_currline < 1) OR
                (term.window_currline > term.window_lines)
            THEN
                BEGIN
                term.window_currline := old_window_curr;
                term.currcol         := 1
                END;
            (*ENDIF*) 
            term.currline:= (term.window_top + term.window_currline - 1)
                  MOD cut_max_lines_term;
            IF  term.currline = 0
            THEN
                term.currline := cut_max_lines_term;
            (*ENDIF*) 
            IF  ((term.window_top <= term.window_bottom) AND
                ((term.currline > term.window_bottom) OR
                (term.currline < term.window_top)))
                OR
                ((term.window_top > term.window_bottom) AND
                (term.currline < term.window_top) AND
                (term.currline > term.window_bottom))
            THEN
                BEGIN
                term.currcol         := 1;
                term.window_currline := old_window_curr;
                term.currline        := old_currline
                END;
            (*ENDIF*) 
            IF  (io_result.keystroke.key = vt_mouse_down)
                AND
                (term.ln_desc [term.currline].ld_type <> lt_normal)
            THEN
                (* PTS 1000203 JA 1997-11-12 *)
                BEGIN
                IF  term.currcol < get1name_in_pos
                THEN
                    term.currcol := get1name_in_pos
                ELSE
                    IF  (term.ln_desc [term.currline].ld_type = lt_get2name)
                        AND
                        (term.currcol > get2name_msg_pos) AND
                        (term.currcol < get2name_in_pos )
                    THEN
                        term.currcol := get2name_in_pos
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
&           ifdef test
            (*ENDIF*) 
            writeln ('********** lines (after IO):');
            file_out_lines (term);
&           endif
            IF  set_left_right
            THEN
                CASE io_result.keystroke.key OF
                    vt_pf10, vt_sk04, vt_left_key:
                        BEGIN
                        IF  term.hif.slabels [label_left]
                            = str_left_label
                        THEN
                            BEGIN
                            pfkey     := pf_left;
                            is_key_ok := true
                            END
                        (*ENDIF*) 
                        END;
                    vt_pf11, vt_sk05, vt_right_key:
                        BEGIN
                        IF  term.hif.slabels [label_right]
                            = str_right_label
                        THEN
                            BEGIN
                            pfkey     := pf_right;
                            is_key_ok := true
                            END
                        (*ENDIF*) 
                        END;
                    OTHERWISE
                        pfkey := pf_none
                    END;
                (*ENDCASE*) 
            (*ENDIF*) 
            IF  term.use_pfkeys AND (pfkey = pf_none)
            THEN
                CASE io_result.keystroke.key OF
                    vt_enter, vt_cmd_key, vt_do_key, vt_mouse_dbl:
                        BEGIN
                        IF  return_pfkey
                        THEN
                            pfkey := pf_run
                        ELSE
                            (* PTS 1000203 JA 1997-11-12 *)
                            IF  io_result.keystroke.key <> vt_mouse_dbl
                            THEN
                                term.currcol := 1;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        is_key_ok    := true
                        END;
                    vt_pf01, vt_help_key:
                        IF  NOT term.help_state AND
                            (term.hif.slabels [label_help] <> bsp_c8)
                        THEN
                            BEGIN
                            pfkey     := pf_help;
                            is_key_ok := true
                            END;
                        (*ENDIF*) 
                    vt_pf02, vt_sk07, vt_cancel_key:
                        IF  NOT term.help_state
                        THEN
                            BEGIN
                            pfkey        := pf_cancel;
                            term.currcol := 1;
                            is_key_ok    := true
                            END;
                        (*ENDIF*) 
                    vt_pf03, vt_sk09, vt_end_key:
                        BEGIN
                        pfkey     := pf_end;
                        is_key_ok := true
                        END;
                    vt_pf05, vt_sk01:
                        IF  NOT term.help_state
                        THEN
                            BEGIN
                            term.currcol    := 1;
                            term.is_holding := false;
                            is_key_ok       := true;
                            ta09set_running_msg (term, true);
                            END;
                        (*ENDIF*) 
                    vt_pf07, vt_up_key:
                        IF  return_pfkey
                        THEN
                            BEGIN
                            pfkey     := pf_up;
                            is_key_ok := true
                            END
                        ELSE
                            ta09rollup (term);
                        (*ENDIF*) 
                    vt_pf08, vt_down_key:
                        IF  return_pfkey
                        THEN
                            BEGIN
                            pfkey     := pf_down;
                            is_key_ok := true
                            END
                        ELSE
                            ta09rolldown (term, c_one_window_only);
                        (*ENDIF*) 
                    vt_pf09, vt_sk02:
                        IF  NOT term.is_mask AND term.is_cmd_read
                        THEN
                            BEGIN
                            ta09display_last_string (term, cmd_no);
                            cmd_no := cmd_no - 1;
                            IF  cmd_no < 1
                            THEN
                                cmd_no := cut_max_cmds_term
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    vt_pf12, vt_sk03, vt_insert_key:
                        IF  (term.ln_desc [term.currline].
                            ld_type = lt_normal)
                            AND
                            (term.ln_desc [term.currline].
                            ld_attr1 [c_out] in
                            [cut_unprotected, cut_bright_unprotected])
                            AND
                            NOT term.is_mask AND term.is_cmd_read
                        THEN
                            ta09insert_line (term);
                        (*ENDIF*) 
                    OTHERWISE
                        BEGIN
                        END
                    END
                (*ENDCASE*) 
            ELSE
                IF  pfkey = pf_none
                THEN
                    CASE io_result.keystroke.key OF
                        vt_enter, vt_cmd_key, vt_do_key, vt_mouse_dbl:
                            BEGIN
                            (* PTS 1000203 JA 1997-11-12 *)
                            IF  io_result.keystroke.key <> vt_mouse_dbl
                            THEN
                                term.currcol := 1;
                            (*ENDIF*) 
                            is_key_ok    := true
                            END;
                        vt_pf01, vt_help_key:
                            IF  NOT term.help_state AND
                                (term.hif.slabels [label_help] <> bsp_c8)
                            THEN
                                BEGIN
                                pfkey     := pf_help;
                                is_key_ok := true
                                END;
                            (*ENDIF*) 
                        vt_pf03, vt_sk09, vt_end_key:
                            BEGIN
                            pfkey     := pf_end;
                            is_key_ok := true
                            END;
                        vt_pf05, vt_sk01:
                            IF  term.hif.slabels [label_nohold]
                                = str_nohold_label
                            THEN
                                BEGIN
                                term.currcol    := 1;
                                term.is_holding := false;
                                is_key_ok       := true;
                                ta09set_running_msg (term, true)
                                END;
                            (*ENDIF*) 
                        OTHERWISE
                            is_key_ok := false
                        END
                    (*ENDCASE*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
    UNTIL
        is_key_ok OR NOT get_input OR NOT term.io_ok
    (*ENDREPEAT*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ta09color (attr : char): char;
 
BEGIN
IF  attr = cut_protected
THEN
    ta09color := chr (c_protected_color)
ELSE
    IF  attr = cut_bright_protected
    THEN
        ta09color := chr (c_bright_protected_color)
    ELSE
        IF  attr = cut_unprotected
        THEN
            ta09color := chr (c_unprotected_color)
        ELSE
            IF  attr = cut_bright_unprotected
            THEN
                ta09color := chr (c_bright_unprotected_color)
            ELSE
                IF  attr = cut_invisible
                THEN
                    ta09color := chr (c_invisible_color)
                ELSE
                    ta09color := attr
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta09c256_remove_double_quotes (VAR n : tsp00_C256);
 
VAR
      found : boolean;
      i     : integer;
      aux_n : tsp00_C256;
 
BEGIN
IF  n [1] = double_quote
THEN
    BEGIN
    SAPDB_PascalForcedFill (sizeof(aux_n), @aux_n, 1, sizeof(aux_n), ' ');
    i     := 1;
    found := false;
    WHILE NOT found AND (i < sizeof (n)) DO
        IF  n [i+1] = double_quote
        THEN
            found := true
        ELSE
            BEGIN
            aux_n [i] := n [i+1];
            i := i + 1
            END;
        (*ENDIF*) 
    (*ENDWHILE*) 
    IF  found
    THEN
        n := aux_n
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta09display_internal_msg (VAR term : tut_terminal;
            immediate_display : boolean;
            msg               : tsp00_C20;
            VAR io_result     : tsp00_VtResult);
 
VAR
      dummy_pfkey : tut_pfkey;
      len         : integer;
      ln          : tsp00_Line;
 
BEGIN
IF  NOT term.is_virt_term AND term.is_display
THEN
    BEGIN
    ln := term.blank_window_line;
    SAPDB_PascalForcedMove (sizeof (msg), sizeof (ln), @msg, 1, @ln, 1, sizeof (msg));
    t05write_term (ln)
    END
ELSE
    BEGIN
    IF  term.is_display AND term.screen_available
    THEN
        BEGIN
        SAPDB_PascalForcedMove (sizeof (msg), term.screen_chars,
              @msg, 1, @term.screen_buf^, term.help_line_offset + 1,
              sizeof (msg));
        IF  msg = bsp_c20
        THEN
            SAPDB_PascalForcedFill (term.screen_chars, @term.screen_att^,
                  term.help_line_offset + 1, c_msg_size,
                  ta09color (cut_protected))
        ELSE
            BEGIN
            len := c_msg_size;
            WHILE (len > 1) AND (msg [len] = ' ') DO
                len := len - 1;
            (*ENDWHILE*) 
            SAPDB_PascalForcedFill (term.screen_chars, @term.screen_att^,
                  term.help_line_offset + 1, len,
                  chr (c_internal_msg_color));
            IF  len < c_msg_size
            THEN
                BEGIN
                term.screen_buf^[term.help_line_offset + len + 1] :=
                      cut_end_of_field;
                SAPDB_PascalForcedFill (term.screen_chars, @term.screen_att^,
                      term.help_line_offset + len + 1, c_msg_size - len,
                      ta09color (cut_protected))
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  immediate_display
        THEN
            BEGIN
            ta09build_page (term, NOT c_get_input, NOT c_set_left_right,
                  NOT c_return_pfkey, dummy_pfkey, io_result);
            SAPDB_PascalForcedFill (term.screen_chars, @term.screen_buf^,
                  term.help_line_offset + 1, c_msg_size, ' ')
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta09display_last_string (VAR term : tut_terminal;
            cmd_no : integer);
 
VAR
      curr : integer;
 
BEGIN
FOR curr := 1 TO term.count_cmd_lines [cmd_no] DO
    BEGIN
    ta09next_line (term);
    term.lines [term.currline] :=
          term.last_cmd_lines [cmd_no] [curr];
    term.ln_desc [term.currline].ld_attr1 [c_out] := cut_unprotected;
    term.ln_desc [term.currline].ld_type          := lt_normal
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta09file_read (VAR term : tut_terminal;
            VAR pfkey         : tut_pfkey);
 
VAR
      io_result : tsp00_VtResult;
 
BEGIN
IF  term.curr_inputfile <= 0
THEN
    pfkey := pf_cancel
ELSE
    BEGIN
    t13readfile (term, pfkey);
    IF  pfkey = pf_none
    THEN
        BEGIN
        term.currcol := 1;
        IF  term.is_display
        THEN
            BEGIN
            IF  NOT term.is_virt_term
            THEN
                t05write_term (term.lines [term.currline])
            ELSE
                IF  (term.put_linecount>= term.window_lines)
                    OR  NOT term.is_cmd_read
                THEN
                    ta09build_page (term, NOT c_get_input,
                          NOT c_set_left_right, NOT c_return_pfkey,
                          pfkey, io_result)
                (*ENDIF*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta09getline (VAR term : tut_terminal;
            VAR ln          : tsp00_Line;
            use_default     : boolean;
            hold_cursor     : boolean;
            VAR pfkey       : tut_pfkey);
 
VAR
      is_term_read : boolean;
      pos          : integer;
      input_line   : integer;
      io_result    : tsp00_VtResult;
 
BEGIN
pfkey := pf_none;
is_term_read := false;
ta09next_line (term);
IF  term.is_inputfile
THEN
    ta09file_read (term, pfkey);
(*ENDIF*) 
IF  NOT term.is_inputfile AND (pfkey = pf_none)
THEN
    BEGIN
    IF  NOT term.is_holding
    THEN
        BEGIN
        term.is_holding := true;
        ta09set_running_msg (term, false)
        END;
    (*ENDIF*) 
    IF  term.is_batch
    THEN
        ta09file_read (term, pfkey)
    ELSE
        IF  NOT term.is_virt_term
        THEN
            BEGIN
            t05readterm (prompting_sign, term.lines [term.currline]);
            term.currcol := 1
            END
        ELSE
            BEGIN
            IF  (term.ln_desc [term.currline].ld_attr1 [c_out]
                in [cut_protected, cut_bright_protected])
                OR (term.ln_desc [term.currline].ld_type <> lt_normal)
                OR use_default
            THEN
                BEGIN
                term.ln_desc [term.currline].ld_attr1 [c_out] :=
                      cut_unprotected;
                term.ln_desc [term.currline].ld_type := lt_normal;
                IF  use_default
                THEN
                    SAPDB_PascalForcedMove (sizeof (ln),
                          sizeof (term.lines [term.currline]),
                          @ln, 1, @term.lines [term.currline], 2,
                          term.window_cols - 1)
                ELSE
                    term.lines [term.currline] := term.blank_window_line
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            term.lines [term.currline] [1] := prompting_sign;
            term.currcol := 2;
            input_line   := term.currline;
            is_term_read := true;
            ta09build_page (term, c_get_input, NOT c_set_left_right,
                  NOT c_return_pfkey, pfkey, io_result);
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  NOT hold_cursor OR term.use_pfkeys OR NOT is_term_read
THEN
    input_line := term.currline;
(*ENDIF*) 
ln := term.blankline;
IF  term.lines [input_line] [1] = prompting_sign
THEN
    pos := 2
ELSE
    pos := 1;
(*ENDIF*) 
SAPDB_PascalForcedMove (sizeof (term.lines [input_line]), sizeof (ln),
      @term.lines [input_line], pos,
      @ln, 1, term.window_cols - pos);
IF  term.count_cmd_lines
    [(term.last_cmd_no MOD cut_max_cmds_term) + 1] = 0
THEN
    BEGIN
    term.last_cmd_no := (term.last_cmd_no MOD cut_max_cmds_term) + 1;
    term.count_cmd_lines [term.last_cmd_no]     := 1;
    term.last_cmd_lines  [term.last_cmd_no] [1] :=
          term.lines [input_line]
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta09insert_line (VAR term : tut_terminal);
 
VAR
      i : integer;
 
BEGIN
IF  (term.bottom MOD cut_max_lines_term) + 1 = term.top
THEN
    BEGIN
    IF  term.window_top <> term.top
    THEN
        term.top := (term.top MOD cut_max_lines_term) + 1
    ELSE
        BEGIN
        term.bottom := term.bottom - 1;
        IF  term.bottom < 1
        THEN
            term.bottom := cut_max_lines_term
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (term.currline <= term.bottom) AND
    (term.bottom   <> cut_max_lines_term)
THEN
    BEGIN
    FOR i := term.bottom DOWNTO term.currline DO
        BEGIN
        term.lines   [i+1] := term.lines   [i];
        term.ln_desc [i+1] := term.ln_desc [i]
        END;
    (*ENDFOR*) 
    term.bottom := term.bottom + 1
    END
ELSE
    BEGIN
    IF  term.bottom < cut_max_lines_term
    THEN
        BEGIN
        FOR i:=term.bottom DOWNTO 1 DO
            BEGIN
            term.lines   [i+1] := term.lines   [i];
            term.ln_desc [i+1] := term.ln_desc [i]
            END;
        (*ENDFOR*) 
        term.bottom := term.bottom + 1
        END
    ELSE
        term.bottom := 1;
    (*ENDIF*) 
    term.lines   [1] := term.lines   [cut_max_lines_term];
    term.ln_desc [1] := term.ln_desc [cut_max_lines_term];
    FOR i := cut_max_lines_term - 1 DOWNTO term.currline DO
        BEGIN
        term.lines   [i+1] := term.lines   [i];
        term.ln_desc [i+1] := term.ln_desc [i]
        END
    (*ENDFOR*) 
    END;
(*ENDIF*) 
IF  term.ln_desc [term.currline].ld_new_page
THEN
    term.ln_desc [(term.currline MOD cut_max_lines_term) + 1].
          ld_new_page := false;
(*ENDIF*) 
term.window_bottom := (term.window_bottom MOD cut_max_lines_term) + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta09mouse_pfkey_click (VAR term : tut_terminal;
            mouse_currcol     : tsp00_Int2;
            VAR keystroke_key : tsp00_VtKey);
 
CONST
      c_pfkey_sign = 'F';
 
VAR
      found    : boolean;
      pos      : integer;
      pfkey_c2 : tsp00_C2;
 
BEGIN
found := false;
pos   := term.help_line_offset + mouse_currcol;
IF  (pos > 1) AND (pos <= term.screen_chars)
THEN
    WHILE NOT found AND (pos > term.help_line_offset) DO
        IF  term.screen_buf^[pos] = c_pfkey_sign
        THEN
            found := true
        ELSE
            pos := pos - 1;
        (*ENDIF*) 
    (*ENDWHILE*) 
(*ENDIF*) 
IF  found
THEN
    BEGIN
    pfkey_c2 [1] := term.screen_buf^[pos+1];
    pfkey_c2 [2] := term.screen_buf^[pos+2];
    IF  pfkey_c2 = '1:'
    THEN
        keystroke_key := vt_pf01
    ELSE
        IF  pfkey_c2 = '2:'
        THEN
            keystroke_key := vt_pf02
        ELSE
            IF  pfkey_c2 = '3:'
            THEN
                keystroke_key := vt_pf03
            ELSE
                IF  pfkey_c2 = '5:'
                THEN
                    keystroke_key := vt_pf05
                ELSE
                    IF  pfkey_c2 = '7:'
                    THEN
                        keystroke_key := vt_pf07
                    ELSE
                        IF  pfkey_c2 = '8:'
                        THEN
                            keystroke_key := vt_pf08
                        ELSE
                            IF  pfkey_c2 = '9:'
                            THEN
                                keystroke_key := vt_pf09
                            ELSE
                                IF  pfkey_c2 = '10'
                                THEN
                                    keystroke_key := vt_pf10
                                ELSE
                                    IF  pfkey_c2 = '11'
                                    THEN
                                        keystroke_key := vt_pf11
                                    ELSE
                                        IF  pfkey_c2 = '12'
                                        THEN
                                            keystroke_key := vt_pf12
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta09n_remove_double_quotes (VAR n : tsp00_Name);
 
VAR
      found : boolean;
      i     : integer;
      aux_n : tsp00_Name;
 
BEGIN
IF  n [1] = double_quote
THEN
    BEGIN
    aux_n := bsp_name;
    i     := 1;
    found := false;
    WHILE NOT found AND (i < sizeof (n)) DO
        IF  n [i+1] = double_quote
        THEN
            found := true
        ELSE
            BEGIN
            aux_n [i] := n [i+1];
            i := i + 1
            END;
        (*ENDIF*) 
    (*ENDWHILE*) 
    IF  found
    THEN
        n := aux_n
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta09next_line (VAR term : tut_terminal);
 
BEGIN
IF  term.currline = term.window_bottom
THEN
    BEGIN
    IF  term.window_bottom = term.bottom
    THEN
        BEGIN
        term.bottom := (term.bottom MOD cut_max_lines_term) + 1;
        WITH term.ln_desc [term.bottom] DO
            BEGIN
            ld_attr1 [c_out] := cut_protected;
            ld_attr2 [c_out] := cut_protected;
            ld_attr1 [c_in ] := cut_protected;
            ld_attr2 [c_in ] := cut_protected;
            ld_in_code1      := false;
            ld_in_code2      := false;
            ld_in_len1       := 0;
            ld_in_len2       := 0;
            ld_type          := lt_normal
            END;
        (*ENDWITH*) 
        IF  term.bottom = term.top
        THEN
            term.top := (term.top MOD cut_max_lines_term) + 1;
        (*ENDIF*) 
        term.lines [term.bottom] := term.blank_window_line
        END;
    (*ENDIF*) 
    term.window_bottom:= (term.window_bottom MOD cut_max_lines_term) +1;
    IF  term.window_bottom <> term.window_top
    THEN
        term.ln_desc [term.window_bottom].ld_new_page := false
    (*ENDIF*) 
    END;
(*ENDIF*) 
term.currline := (term.currline MOD cut_max_lines_term) + 1;
IF  term.window_currline >= term.window_lines
THEN
    term.window_top := (term.window_top MOD cut_max_lines_term) + 1
ELSE
    term.window_currline := term.window_currline + 1;
(*ENDIF*) 
term.currcol := 1;
term.put_linecount     := term.put_linecount     + 1;
term.used_window_lines := term.used_window_lines + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta09rolldown (VAR term : tut_terminal;
            one_window_only  : boolean);
 
VAR
      i : integer;
 
BEGIN
WHILE term.currline <> term.window_bottom  DO
    BEGIN
    term.window_currline := term.window_currline + 1;
    term.currline := (term.currline MOD cut_max_lines_term) + 1
    END;
(*ENDWHILE*) 
IF  (term.ln_desc[(term.currline MOD cut_max_lines_term)+1].ld_new_page)
    AND one_window_only
    AND (term.currline <> term.bottom)
THEN
    BEGIN
    term.currline        := (term.currline MOD cut_max_lines_term) + 1;
    term.window_top      := term.currline;
    term.window_currline := 1;
    term.window_bottom   := term.currline;
    i := 1;
    WHILE (NOT term.ln_desc [(term.window_bottom MOD
          cut_max_lines_term)+1].ld_new_page
          AND (term.window_bottom <> term.bottom))
          AND (i < term.window_lines) DO
        BEGIN
        term.window_bottom :=
              (term.window_bottom MOD cut_max_lines_term) + 1;
        i := i + 1
        END
    (*ENDWHILE*) 
    END
ELSE
    BEGIN
    i := 0;
    WHILE (i < term.window_lines)
          AND
          NOT (term.ln_desc [(term.currline MOD cut_max_lines_term)+1].
          ld_new_page AND one_window_only)
          AND
          (term.currline <> term.bottom) DO
        BEGIN
        IF  term.window_currline >= term.window_lines
        THEN
            term.window_top :=
                  (term.window_top MOD cut_max_lines_term) + 1
        ELSE
            term.window_currline := term.window_currline + 1;
        (*ENDIF*) 
        term.currline      := (term.currline MOD cut_max_lines_term) +1;
        term.window_bottom := term.currline;
        i := i + 1
        END
    (*ENDWHILE*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta09rollup (VAR term : tut_terminal);
 
VAR
      set_up : boolean;
      i      : integer;
      count  : integer;
 
BEGIN
WHILE (term.currline <> term.window_top) AND
      (term.currline <> term.first_cmd_line) DO
    BEGIN
    term.window_currline := term.window_currline - 1;
    term.currline        := term.currline - 1;
    IF  term.currline < 1
    THEN
        term.currline := cut_max_lines_term
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
count  := 0;
i      := term.currline;
set_up := true;
WHILE set_up AND (i <> term.top) AND (i <> term.first_cmd_line) DO
    BEGIN
    count := count + 1;
    i     := i - 1;
    IF  i < 1
    THEN
        i := cut_max_lines_term;
    (*ENDIF*) 
    set_up := (count < term.window_lines)
          AND NOT term.ln_desc [i].ld_new_page
    END;
(*ENDWHILE*) 
IF  count > 0
THEN
    BEGIN
    term.window_bottom := term.currline - 1;
    IF  term.window_bottom < 1
    THEN
        term.window_bottom := cut_max_lines_term;
    (*ENDIF*) 
    term.window_top      := i;
    term.currline        := term.window_top;
    term.window_currline := 1
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta09set_running_msg (VAR term : tut_terminal; on : boolean);
 
VAR
      io_result : tsp00_VtResult;
      msg       : tsp00_C20;
 
BEGIN
IF  on
THEN
    msg := running_msg
ELSE
    msg := bsp_c20;
(*ENDIF*) 
ta09display_internal_msg (term, NOT c_immediate_displ,
      msg, io_result);
ta09terminal_out (term)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta09terminal_out (VAR term : tut_terminal);
 
VAR
      cursor_col   : tsp00_Int2;
      cursor_line  : tsp00_Int2;
      options      : tsp00_VtOptions;
      dummy_result : tsp00_VtResult;
 
BEGIN
IF  term.help_state
THEN
    BEGIN
    cursor_line := term.screen_lines - 1;
    cursor_col  := 2
    END
ELSE
    BEGIN
    cursor_line := term.window_currline + term.header_lines;
    cursor_col  := term.currcol
    END;
(*ENDIF*) 
WITH options DO
    BEGIN
    wait_for_input        := false;
    usage_mode            := vt_form;
    return_on_last        := false;
    return_on_first       := false;
    returnkeys            := [vt_enter .. vt_end_key,
          vt_mouse_down ..vt_mouse_dbl]; (* PTS 1000203 JA 1997-11-12 *)
    reject_keys           := [ ];
    bell                  := false;
    mark                  := vt_mark_off;
    first_line_changed    := 1;
    last_line_changed     := term.screen_lines;
    screen2_first_changed := 0;
    screen2_last_changed  := 0;
    overtype              := false;
    END;
(*ENDWITH*) 
&ifdef WINDOWS
sqltsysline (term.term_ref, 1, term.hif.sys_text,
      term.hif.sys_attr, term.io_ok);
&endif
sqltio (term.term_ref, term.screen_buf, term.screen_att,
      NOT c_refresh, cursor_line, cursor_col,
      term.hif, options, dummy_result, term.io_ok)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta09upper_case_name (VAR n : tsp00_Name);
 
VAR
      i          : integer;
      is_string1 : boolean;
      is_string2 : boolean;
 
BEGIN
is_string1 := false;
is_string2 := false;
FOR i := 1 TO sizeof (n) DO
    BEGIN
    IF  n [i] = string_delimiter
    THEN
        is_string1 := NOT is_string1
    ELSE
        IF  (n [i] = double_quote) AND NOT is_string1
        THEN
            is_string2 := NOT is_string2;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  (n [i] in ['a'..'i', 'j'..'r',  's'..'z'])
        AND NOT is_string1 AND NOT is_string2
    THEN
        n [i] := chr (ord (n [i]) + ord('A') - ord('a'))
    (*ENDIF*) 
    END
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta09upper_c256 (VAR n : tsp00_C256);
 
VAR
      i          : integer;
      is_string1 : boolean;
      is_string2 : boolean;
 
BEGIN
is_string1 := false;
is_string2 := false;
FOR i := 1 TO sizeof (n) DO
    BEGIN
    IF  n [i] = string_delimiter
    THEN
        is_string1 := NOT is_string1
    ELSE
        IF  (n [i] = double_quote) AND NOT is_string1
        THEN
            is_string2 := NOT is_string2;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  (n [i] in ['a'..'i', 'j'..'r',  's'..'z'])
        AND NOT is_string1 AND NOT is_string2
    THEN
        n [i] := chr (ord (n [i]) + ord('A') - ord('a'))
    (*ENDIF*) 
    END
(*ENDFOR*) 
END;
 
&ifdef test
(*=================trace functions only===================*)
(*------------------------------*) 
 
PROCEDURE
      file_out_lines (VAR term : tut_terminal);
 
VAR
      end_ok : boolean;
      i      : integer;
 
BEGIN
i := term.window_top;
REPEAT
    end_ok := (i = term.window_bottom);
    writeln ( chr(ord('0') + i DIV 100),
          chr(ord('0') + (i DIV 10) MOD 10),
          chr(ord('0') +  i MOD 10));
    writeln (term.lines [i]:term.window_cols);
    i := (i MOD cut_max_lines_term) + 1
UNTIL
    end_ok
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      file_out_screen (VAR term : tut_terminal);
 
VAR
      i       : integer;
      k       : integer;
      offset  : integer;
      out_len : integer;
      ln      : tsp00_Line;
 
BEGIN
IF  term.screen_cols > LINE_MXSP00
THEN
    out_len := LINE_MXSP00
ELSE
    out_len := term.screen_cols;
(*ENDIF*) 
i      := 1;
offset := 0;
ln     := term.blankline;
WHILE i <= term.screen_lines DO
    BEGIN
    writeln ( chr(ord('0') + (i DIV 10) MOD 10),
          chr(ord('0') +  i MOD 10));
    SAPDB_PascalForcedMove (term.screen_chars, sizeof (ln),
          @term.screen_buf^, offset + 1, @ln, 1, out_len);
    writeln (ln:out_len);
    SAPDB_PascalForcedMove (term.screen_chars, sizeof (ln),
          @term.screen_att^, offset + 1, @ln, 1, out_len);
    FOR k := 1 TO out_len DO
        IF  ln [k] = cut_protected
        THEN
            ln [k] := 'p'
        ELSE
            IF  ln [k] = cut_unprotected
            THEN
                ln [k] := 'u'
            ELSE
                IF  ln [k] = cut_bright_protected
                THEN
                    ln [k] := 'P'
                ELSE
                    IF  ln [k] = cut_bright_unprotected
                    THEN
                        ln [k] := 'U'
                    ELSE
                        IF  ln [k] = cut_invisible
                        THEN
                            ln [k] := 'i';
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDFOR*) 
    writeln (ln:out_len);
    offset := offset + term.screen_cols;
    i := i + 1
    END
(*ENDWHILE*) 
END;
 
&endif
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
