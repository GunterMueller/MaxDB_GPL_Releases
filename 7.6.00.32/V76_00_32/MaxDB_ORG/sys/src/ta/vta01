.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VTA01$
.tt 2 $$$
.TT 3 $ElkeZ$Test_Procedures$2000-11-08$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : Test_Procedures
=========
.sp
Purpose : Writes test output into the vtrace
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              ta01dump_state_set (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    s     : tgg00_DumpStateSet);
 
        PROCEDURE
              cccinit (VAR ccv : tsp00_Ccc);
 
        PROCEDURE
              cccoutp (n : tsp00_C20; ccv : tsp00_Ccc);
 
        PROCEDURE
              cccprint (tt : tsp00_Trace);
 
        PROCEDURE
              t01addr (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname (*ptocSynonym const char**);
                    bufaddr  : tsp00_BufAddr (*ptocSynonym const void**));
 
        PROCEDURE
              t01addr_1 (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname (*ptocSynonym const char**);
                    bufaddr    : tsp00_BufAddr (*ptocSynonym void**));
 
        PROCEDURE
              t01addr_2 (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname (*ptocSynonym const char**);
                    bufaddr    : tsp00_BufAddr (*ptocSynonym void**));
 
        PROCEDURE
              t01addr_3 (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname (*ptocSynonym const char**);
                    bufaddr    : tsp00_BufAddr (*ptocSynonym void**));
 
        PROCEDURE
              t01addr2 (
                    debug     : tgg00_Debug;
                    nam1      : tsp00_Sname (*ptocSynonym const char**);
                    bufaddr1  : tsp00_BufAddr (*ptocSynonym void**);
                    nam2      : tsp00_Sname (*ptocSynonym const char**);
                    bufaddr2  : tsp00_BufAddr (*ptocSynonym void**));
 
        PROCEDURE
              t01aptree (
                    debug       : tgg00_Debug;
                    VAR ap_tree : tsp00_MoveObj (*ptocSynonym void**);
                    node_cnt    : integer;
                    hint_node   : tsp00_Int2);
 
        PROCEDURE
              t01basis_error (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    b_err : tgg00_BasisError);
 
        PROCEDURE
              t01bduse (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    s     : tgg00_BdUseSet);
 
        PROCEDURE
              t01bool (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname (*ptocSynonym const char**);
                    curr_bool: boolean);
 
        PROCEDURE
              t01bool2 (
                    debug     : tgg00_Debug;
                    nam1      : tsp00_Sname (*ptocSynonym const char**);
                    bool1     : boolean;
                    nam2      : tsp00_Sname (*ptocSynonym const char**);
                    bool2     : boolean);
 
        PROCEDURE
              t01buf (
                    debug    : tgg00_Debug;
                    VAR buf  : tsp00_Buf (*ptocSynonym void**);
                    startpos : integer;
                    endpos   : integer);
 
        PROCEDURE
              t01buf1 (
                    debug    : tgg00_Debug;
                    VAR buf  : tsp00_Buf (*ptocSynonym void**);
                    startpos : integer;
                    endpos   : integer);
 
        PROCEDURE
              t01char (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    c     : char);
 
        PROCEDURE
              t01counter (
                    debug       : tgg00_Debug;
                    nam         : tsp00_Sname (*ptocSynonym const char**);
                    counter     : tsp00_8ByteCounter);
 
        PROCEDURE
              t01cpp_trace (
                    VAR proc_name : tsp00_C30 (*ptocSynonym const char**);
                    is_start      : boolean);
 
        PROCEDURE
              t01c2int (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname (*ptocSynonym const char**);
                    int2      : tsp00_C2);
 
        PROCEDURE
              t01c4int (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname (*ptocSynonym const char**);
                    int4      : tsp00_C4);
 
        PROCEDURE
              t01c18 (
                    debug : tgg00_Debug;
                    msg   : tsp00_C18 (*ptocSynonym const char**));
 
        PROCEDURE
              t01c32 (
                    debug : tgg00_Debug;
                    msg   : tsp00_C32 (*ptocSynonym const char**));
 
        PROCEDURE
              t01c64 (
                    debug   : tgg00_Debug;
                    VAR msg : tsp00_C64 (*ptocSynonym const char**));
 
        PROCEDURE
              t01c30 (
                    debug : tgg00_Debug;
                    msg   : tsp00_C30 (*ptocSynonym const char**));
 
        PROCEDURE
              t01c40 (
                    debug : tgg00_Debug;
                    msg   : tsp00_C40 (*ptocSynonym const char**));
 
        PROCEDURE
              t01devname (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    d     : tsp00_DevName (*ptocSynonym const char**));
 
        PROCEDURE
              t01filename (
                    debug : tgg00_Debug;
                    fn    : tgg00_Filename (*ptocSynonym const char**));
 
        PROCEDURE
              t01filetype (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    s     : tgg00_FiletypeSet);
 
        PROCEDURE
              ta01FileVers (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname (*ptocSynonym const char**);
                    VAR FileVers  : tgg91_FileVersion);
 
        PROCEDURE
              t01handling (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    s     : tgg00_HandlingSet);
 
        PROCEDURE
              t01identifier (
                    debug      : tgg00_Debug;
                    identifier : tsp00_Identifier (*ptocSynonym const char**));
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname (*ptocSynonym const char**);
                    int4     : tsp00_Int4);
 
        PROCEDURE
              t01int4_addr (
                    debug         : tgg00_Debug;
                    nam1          : tsp00_Sname (*ptocSynonym const char**);
                    int4          : tsp00_Int4;
                    nam2          : tsp00_Sname (*ptocSynonym const char**);
                    bufaddr       : tsp00_BufAddr (*ptocSynonym void**));
 
        FUNCTION
              t01istrace (
                    debug       : tgg00_Debug;
                    session     : tgg91_SessionNo) : boolean;
 
        PROCEDURE
              t01key (
                    debug   : tgg00_Debug;
                    nam     : tsp00_Sname (*ptocSynonym const char**);
                    VAR k   : tgg00_Lkey);
 
        PROCEDURE
              t01lkey (
                    debug : tgg00_Debug;
                    VAR k : tgg00_Lkey);
 
        PROCEDURE
              t01lidentifier (
                    debug      : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier (*ptocSynonym const char**));
 
        PROCEDURE
              t01line (
                    debug  : tgg00_Debug;
                    VAR ln : tsp00_Line (*ptocSynonym const char**));
 
        PROCEDURE
              t01bufline (
                    debug       : tgg00_Debug;
                    VAR ln      : tsp00_Line (*ptocSynonym const char**);
                    len         : integer);
 
        PROCEDURE
              t01lmulti_switch (
                    VAR s20      : tsp00_C20;
                    VAR s201     : tsp00_C20;
                    VAR on_text  : tsp00_C16;
                    VAR off_text : tsp00_C16;
                    on_count     : integer);
 
        PROCEDURE
              t01localstate (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    s     : tgg00_TransState);
 
        PROCEDURE
              t01lock (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname (*ptocSynonym const char**);
                    VAR lock : tgg00_Lock);
 
        PROCEDURE
              t01lockmode (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname (*ptocSynonym const char**);
                    lock_mode    : tgg00_LockReqMode);
 
        PROCEDURE
              t01lockstate (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname (*ptocSynonym const char**);
                    lock_state    : tgg00_LockReqState);
 
        PROCEDURE
              t01long_qual (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname (*ptocSynonym const char**);
                    VAR long_qual : tgg00_LongQual);
 
        PROCEDURE
              t01longdescriptor (
                    debug     : tgg00_Debug;
                    long_desc : tsp00_LongDescriptor);
 
        PROCEDURE
              t01ldb_longdescblock (
                    debug     : tgg00_Debug;
                    long_desc : tsp00_LongDescBlock);
 
        PROCEDURE
              t01mblock_header (
                    debug             : tgg00_Debug;
                    nam               : tsp00_Sname (*ptocSynonym const char**);
                    VAR mbuf_header   : tgg00_MessBufHeader;
                    trans_ptr         : tgg00_TransContextPtr);
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname (*ptocSynonym const char**);
                    VAR m         : tgg00_MessBlock);
 
        PROCEDURE
              t01messmaxstack (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname (*ptocSynonym const char**);
                    mess_type : tgg00_MessType;
                    int4      : tsp00_Int4);
 
        PROCEDURE
              t01messtype (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname (*ptocSynonym const char**);
                    mess_type    : tgg00_MessType);
 
        PROCEDURE
              t01mess2type (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname (*ptocSynonym const char**);
                    mess2_type    : tgg00_MessType2);
 
        PROCEDURE
              t01minbuf (min_wanted : boolean);
 
        PROCEDURE
              t01moveobj (
                    debug       : tgg00_Debug;
                    VAR moveobj : tsp00_MoveObj (*ptocSynonym const void**);
                    startpos    : tsp00_Int4;
                    endpos      : tsp00_Int4);
 
        PROCEDURE
              t01msgcheck (
                    msg             : tsp00_C30 (*ptocSynonym const char**);
                    check_condition : boolean;
                    bad_int         : tsp00_Int4);
 
        PROCEDURE
              t01multiswitch (
                    VAR s20  : tsp00_C20 (*ptocSynonym const char**);
                    VAR s201 : tsp00_C20 (*ptocSynonym const char**));
 
        PROCEDURE
              t01mxerrmsg (
                    nam        : tsp00_Name (*ptocSynonym const char**);
                    int_wrong  : tsp00_Int4;
                    int_ok     : tsp00_Int4);
 
        PROCEDURE
              t01name (
                    debug : tgg00_Debug;
                    nam   : tsp00_Name (*ptocSynonym const char**));
 
        PROCEDURE
              t01name1 (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname (*ptocSynonym const char**);
                    n         : tsp00_Name (*ptocSynonym const char**));
 
        PROCEDURE
              t01op (
                    debug  : tgg00_Debug;
                    nam    : tsp00_Sname (*ptocSynonym const char**);
                    op     : tgg00_StackOpType);
 
        PROCEDURE
              t01op_func (
                    debug  : tgg00_Debug;
                    nam    : tsp00_Sname;
                    op     : tgg00_StackOpFunc);
 
        PROCEDURE
              t01opmsg (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    msg   : tsp00_Opmsg);
 
        PROCEDURE
              t01page (
                    debug    : tgg00_Debug;
                    VAR buf  : tsp00_Page (*ptocSynonym void**);
                    startpos : tsp00_Int4;
                    endpos   : tsp00_Int4);
 
        PROCEDURE
              t01page_ref (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname (*ptocSynonym const char**);
                    VAR PageRef  : tgg91_PageRef);
 
        PROCEDURE
              t01page_type (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname (*ptocSynonym const char**);
                    pagetype  : tgg00_PageType;
                    pagetype2 : tgg00_PageType2);
 
        PROCEDURE
              t01p2int4 (
                    debug : tgg00_Debug;
                    nam_1 : tsp00_Sname (*ptocSynonym const char**);
                    int_1 : tsp00_Int4;
                    nam_2 : tsp00_Sname (*ptocSynonym const char**);
                    int_2 : tsp00_Int4);
 
        PROCEDURE
              t01p4int4 (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    int_1 : tsp00_Int4;
                    int_2 : tsp00_Int4;
                    int_3 : tsp00_Int4;
                    int_4 : tsp00_Int4);
 
        PROCEDURE
              t01stqual (
                    debug      : tgg00_Debug;
                    VAR qual   : tgg00_QualBuf;
                    stack_addr : tgg00_StackListPtr);
 
        PROCEDURE
              t01qual (debug : tgg00_Debug; VAR part1 : tgg00_QualBuf);
 
        PROCEDURE
              t01qual1 (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR part1 : tgg00_QualBuf);
 
        PROCEDURE
              t01real (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname (*ptocSynonym const char**);
                    re       : tsp00_Longreal;
                    digits   : integer);
 
        PROCEDURE
              t01separator (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname (*ptocSynonym const char**);
                    separator     : tgg00_RecPtr);
 
        PROCEDURE
              ta01Session (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname (*ptocSynonym const char**);
                    VAR session  : tgg91_SessionNo);
 
        PROCEDURE
              ta01SessionTrans (
                    debug             : tgg00_Debug;
                    nam               : tsp00_Sname (*ptocSynonym const char**);
                    VAR session       : tgg91_SessionNo;
                    VAR trans         : tgg91_TransNo;
                    VAR write_trans   : tgg91_TransNo;
                    VAR subtrans      : tgg00_SubtransNo);
 
        PROCEDURE
              t01setmaxbuflength (max_len : tsp00_Int4);
 
        PROCEDURE
              t01SetSingleUser;
 
        PROCEDURE
              t01sinit;
 
        PROCEDURE
              t01site (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname (*ptocSynonym const char**);
                    site     : tgg00_ServerdbNo);
 
        PROCEDURE
              t01sname (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**));
 
        PROCEDURE
              t01stackentry (
                    debug          : tgg00_Debug;
                    VAR st         : tgg00_StackEntry;
                    entry_index    : integer);
 
        PROCEDURE
              t01statistics (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname (*ptocSynonym const char**);
                    VAR info : tgg00_SampleInfo);
 
        PROCEDURE
              t01stdesc (
                    debug          : tgg00_Debug;
                    nam            : tsp00_Sname (*ptocSynonym const char**);
                    VAR stack_desc : tgg00_StackDesc);
 
        PROCEDURE
              t01stackdesc (
                    debug          : tgg00_Debug;
                    nam            : tsp00_Sname (*ptocSynonym const char**);
                    stack_addr     : tgg00_StackListPtr;
                    VAR stack_desc : tgg00_StackDesc);
 
        PROCEDURE
              t01str30 (
                    debug : tgg00_Debug;
                    str30 : tsp00_C30 (*ptocSynonym const char**));
 
        PROCEDURE
              ta01Subtrans (
                    debug          : tgg00_Debug;
                    nam            : tsp00_Sname (*ptocSynonym const char**);
                    VAR SubtransNo : tgg00_SubtransNo);
 
        PROCEDURE
              t01surrogate (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname (*ptocSynonym const char**);
                    VAR tabid : tgg00_Surrogate);
 
        PROCEDURE
              t01RestoreSwitchAdjustments;
 
        PROCEDURE
              t01SaveSwitchAdjustments (turnOff : boolean);
 
        PROCEDURE
              t01tabid (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname (*ptocSynonym const char**);
                    VAR tabid : tgg00_Surrogate);
 
        FUNCTION
              t01trace (debug : tgg00_Debug) : boolean;
 
        PROCEDURE
              t01trans (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname (*ptocSynonym const char**);
                    VAR t     : tgg00_TransContext);
 
        PROCEDURE
              ta01TransNo (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname (*ptocSynonym const char**);
                    VAR TransNo  : tgg91_TransNo);
 
        PROCEDURE
              t01treeid (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname (*ptocSynonym const char**);
                    VAR treeid : tgg00_FileId);
 
        PROCEDURE
              t01valueto_c64 (
                    VAR s   : tsp00_C64;
                    pos     : integer;
                    val2    : tsp00_Int2;
                    val4    : tsp00_Int4;
                    is_int2 : boolean);
 
        PROCEDURE
              t01vffn (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    fn    : tsp00_VFilename (*ptocSynonym const char**));
 
        PROCEDURE
              t01vftype (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    ft    : tsp00_VfType);
 
        PROCEDURE
              t01warningset (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    warn  : tsp00_WarningSet);
 
        PROCEDURE
              t01write_line (VAR ln : tsp00_Line (*ptocSynonym const char**));
              (*ptocExport hta01_1.h*)
 
        PROCEDURE
              t01packet (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname (*ptocSynonym const char**);
                    packet_ptr : tsp1_packet_ptr);
 
        PROCEDURE
              t01packet_part (
                    debug           : tgg00_Debug;
                    VAR packet_part : tsp1_part);
 
        PROCEDURE
              t01segment (
                    debug       : tgg00_Debug;
                    VAR segm    : tsp1_segment);
              (*ptocExport hta01_2.h*)
 
        PROCEDURE
              ta01Oid (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname (*ptocSynonym const char**);
                    VAR oid  : tgg00_OidSpace (*ptocSynonym ggg92.h:tgg92_KernelOid&*));
              (*ptocExport hta01_3.h*)
 
        PROCEDURE
              t01strategy (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname (*ptocSynonym const char**);
                    VAR strategy : tgg07_StrategyInfo);
 
        PROCEDURE
              t01strat_enum (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    strat : tgg07_StratEnum);
 
        PROCEDURE
              t01showkind (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname; (*ptocSynonym const char**)
                    show_kind : tgg00_ShowKind);
 
        PROCEDURE
              t01qual_kind (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname (*ptocSynonym const char**);
                    qual_kind : tgg00_QualKind);
 
        PROCEDURE
              t01subq_kind (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname (*ptocSynonym const char**);
                    subq_kind : tgg07_SubqKind);
 
        PROCEDURE
              t01distinct_kind (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname (*ptocSynonym const char**);
                    dist_kind : tgg04_Distinct);
 
        PROCEDURE
              t01execution_kind (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname (*ptocSynonym const char**);
                    ex_kind   : tak_execution_kind);
 
        PROCEDURE
              t01comp_result (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname (*ptocSynonym const char**);
                    comp_res  : tsp00_LcompResult);
 
        PROCEDURE
              t01command_kind (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname (*ptocSynonym const char**);
                    command_kind : tak_commandkind);
 
        PROCEDURE
              t01corr_type (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname (*ptocSynonym const char**);
                    corr_type : tak_corr_type);
 
        PROCEDURE
              t01recursive_state (
                    debug           : tgg00_Debug;
                    nam             : tsp00_Sname (*ptocSynonym const char**);
                    recursive_state : tak_recursive_state);
 
        PROCEDURE
              t01columnset (
                    debug           : tgg00_Debug;
                    nam             : tsp00_Sname (*ptocSynonym const char**);
                    columnset       : tak_columnset);
 
        PROCEDURE
              t01knl_identifier (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname (*ptocSynonym const char**);
                    identifier : tsp00_KnlIdentifier (*ptocSynonym const char**));
 
        PROCEDURE
              t01optimize_info (
                    debug      : tgg00_Debug;
                    VAR stack_desc  : tgg00_StackDesc;
                    data_addr       : tsp00_MoveObjPtr);
 
        PROCEDURE
              t01catalog_entrytype (
                    debug      : tgg00_Debug;
                    etype      : tsp00_Char);
 
        PROCEDURE
              t01set_bool_debug_or_trace;
 
        PROCEDURE
              t01disable_debug_or_trace;
 
        PROCEDURE
              t01fp_kind (
                    debug   : tgg00_Debug;
                    nam     : tsp00_Sname (*ptocSynonym const char**);
                    fp_kind : tak_fp_kind_type_ptr);
 
        PROCEDURE
              t01p2bool (
                    debug : tgg00_Debug;
                    nam_1 : tsp00_Sname (*ptocSynonym const char**);
                    bool1 : boolean;
                    nam_2 : tsp00_Sname (*ptocSynonym const char**);
                    bool2 : boolean);
 
        PROCEDURE
              t01fetch_desc(
                    debug       : tgg00_Debug;
                    nam         : tsp00_Sname;
                    VAR mf_desc : tgg00_FetchDesc);
 
        PROCEDURE
              t01dist_optim(
                    debug       : tgg00_Debug;
                    nam         : tsp00_Sname;
                    dist_optim  : tsp00_Int2);
 
        PROCEDURE
              t01init_line (
                    VAR ln      : tsp00_Line;
                    VAR ln_len  : integer;
                    nam         : tsp00_Sname);
 
        PROCEDURE
              t01p2real (
                    debug  : tgg00_Debug;
                    nam_1  : tsp00_Sname;
                    real_1 : tsp00_Longreal;
                    nam_2  : tsp00_Sname;
                    real_2 : tsp00_Longreal;
                    digits : integer);
 
        PROCEDURE
              t01trace_symbol(
                    debug   : tgg00_Debug;
                    name    : tsp00_Sname;
                    symb    : tak_sc_symbol);
 
        PROCEDURE
              t01trace_kw(
                    debug   : tgg00_Debug;
                    name    : tsp00_Sname;
                    kw      : tak_keyword);
 
        PROCEDURE
              t01Int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Name;
                    int4     : tsp00_Int4);
 
        PROCEDURE
              t01line_c60 (
                    debug : tgg00_Debug;
                    ln_p1 : tsp00_C60 (*ptocSynonym const char**));
 
        PROCEDURE
              t01selfields (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    sfp   : tgg00_SelectFieldsParam);
 
        PROCEDURE
              t01rowno (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    rowno : tsp00_Int4);
 
        PROCEDURE
              t01refinfoindex (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname (*ptocSynonym const char**);
                    idx   : tgg00_RefInfoIndex);
 
        PROCEDURE
              t01strat_access_mode (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    access   : tgg07_StratAccessModSet);
 
        PROCEDURE
              t01colpropset (
                    debug : tgg00_Debug;
                    nam : tsp00_Sname;
                    s   : tak00_colpropset);
 
        PROCEDURE
              t01union_kind (
                    debug   : tgg00_Debug;
                    nam     : tsp00_Sname;
                    ukind   : tak_union_kind;
                    uis_all : boolean);
 
        PROCEDURE
              t01ttfntemp (
                    debug   : tgg00_Debug;
                    nam     : tsp00_Sname;
                    ttfn    : tgg00_TfnTemp);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Syntax-Tree-Printer : VAK99;
 
        PROCEDURE
              a99print_nodes (
                    VAR ap_tree : tsp00_MoveObj;
                    node_cnt : integer;
                    hint_node: tsp00_Int2
                    );
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01blankfilename  : tsp00_VFilename;
 
      ------------------------------ 
 
        FROM
              error_text_handling : VBD06;
 
        PROCEDURE
              b06check_mxbd (VAR ok : boolean);
 
      ------------------------------ 
 
        FROM
              Trace : VBD120;
 
        PROCEDURE
              b120InsertTrace (VAR t   : tgg00_TransContext;
                    trace_layer  : tgg00_Debug;
                    trace_object : tgg00_VtraceType;
                    body_len     : tsp00_Int2;
                    trace_body   : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01_into_res_name      : tsp00_KnlIdentifier;
              a01_zero_res_name      : tsp00_KnlIdentifier;
              a01_union_fill_resname : tsp00_KnlIdentifier;
 
      ------------------------------ 
 
        FROM
              AK_byteswap_and_locset : VAK04;
 
        PROCEDURE
              a04check_mxak( VAR ok : boolean );
 
      ------------------------------ 
 
        FROM
              Trace_Strategy_1 : VAK725;
 
        PROCEDURE
              a725gg_strategy (
                    debug      : tgg00_Debug;
                    VAR strat  : tgg07_StrategyInfo);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01vtrace       : tgg00_VtraceState;
 
        PROCEDURE
              g01check_mxgg (VAR ok : boolean);
 
        PROCEDURE
              g01opmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C24;
                    msg_value : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : vgg06;
 
        PROCEDURE
              gg06Cint6ToLine (
                    VAR Cint6   : tgg90_Cint6;
                    VAR LineLen : integer;
                    VAR Line    : tsp00_Line);
 
        PROCEDURE
              gg06FileVersToLine (
                    VAR FileVers : tgg91_FileVersion;
                    VAR LineLen : integer;
                    VAR Line    : tsp00_Line);
 
        PROCEDURE
              gg06OidToLine (
                    VAR oid          : tgg00_OidSpace;
                    VAR LineLen      : integer;
                    VAR Line         : tsp00_Line);
 
        PROCEDURE
              gg06SessionToLine (
                    VAR SessionNo : tgg91_SessionNo;
                    VAR LineLen : integer;
                    VAR Line    : tsp00_Line);
 
        PROCEDURE
              gg06TransToLine (
                    VAR TransNo : tgg91_TransNo;
                    VAR LineLen : integer;
                    VAR Line    : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17ttfntemp_to_line (
                    ttfn       : tgg00_TfnTemp;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line );
 
        PROCEDURE
              g17st2op_func (
                    op          : tgg00_StackOpFunc;
                    VAR len     : integer;
                    VAR msg     : tsp00_Sname);
 
        PROCEDURE
              g17longreal_to_line (
                    re        : tsp00_Longreal;
                    digits    : integer;
                    pos       : integer;
                    VAR ln    : tsp00_Line);
 
        PROCEDURE
              g17dump_state_set (
                    dump_state : tgg00_DumpStateSet;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17basis_err_to_line (
                    b_err      : tgg00_BasisError;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17bd_use_set_to_line (
                    bd_use     : tgg00_BdUseSet;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17cmdsegm_head (
                    VAR cmdsegm_head : tsp1_segment_header;
                    VAR ln1_len : integer;
                    VAR ln1     : tsp00_Line;
                    VAR ln2_len : integer;
                    VAR ln2     : tsp00_Line;
                    VAR ln3_len : integer;
                    VAR ln3     : tsp00_Line);
 
        PROCEDURE
              g17counter_to_line (
                    counter               : tsp00_8ByteCounter;
                    VAR ln_len            : integer;
                    VAR ln                : tsp00_Line);
 
        PROCEDURE
              g17c2int_to_line (
                    int2             : tsp00_C2;
                    VAR ln_len       : integer;
                    VAR ln           : tsp00_Line);
 
        PROCEDURE
              g17c4int_to_line (
                    int4             : tsp00_C4;
                    VAR ln_len       : integer;
                    VAR ln           : tsp00_Line);
 
        PROCEDURE
              g17filename (
                    nam             : tsp00_Sname;
                    VAR fn          : tgg00_Filename;
                    line_indent     : integer;
                    VAR first_ln    : tsp00_Line;
                    VAR second_ln   : tsp00_Line;
                    VAR third_ln    : tsp00_Line;
                    VAR is_third_ln : boolean);
 
        PROCEDURE
              g17filetype_to_line (
                    filetype     : tgg00_FiletypeSet;
                    is_edit_mode : boolean;
                    VAR ln_len   : integer;
                    VAR ln       : tsp00_Line);
 
        PROCEDURE
              g17handling_set_to_line (
                    handling   : tgg00_HandlingSet;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17hexto_line (
                    c          : char;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17intern_warning_item_to_line (
                    warning_item : tsp1_intern_warning;
                    VAR ln_len   : integer;
                    VAR ln       : tsp00_Line);
 
        PROCEDURE
              g17int4to_line (
                    int4      : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_Line);
 
        PROCEDURE
              g17lockmode_to_line (
                    lock_mode  : tgg00_LockReqMode;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17lockstate_to_line (
                    lock_state : tgg00_LockReqState;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17messtype_to_line (
                    mess_type  : tgg00_MessType;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17mess2type_to_line (
                    mess2_type : tgg00_MessType2;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17nameto_line (
                    n           : tsp00_Name;
                    VAR ln_len  : integer;
                    VAR ln      : tsp00_Line);
 
        PROCEDURE
              g17onestackentry (
                    VAR st             : tgg00_StackEntry;
                    entry_index        : integer;
                    VAR ln             : tsp00_Line;
                    VAR is_second_ln   : boolean;
                    VAR second_ln      : tsp00_Line);
 
        PROCEDURE
              g17packet_head (
                    nam             : tsp00_Sname;
                    VAR packet_head : tsp1_packet_header;
                    VAR ln_len      : integer;
                    VAR ln          : tsp00_Line);
 
        PROCEDURE
              g17page_ref_to_line (
                    VAR page_ref : tgg91_PageRef;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17pagetype_to_line (
                    pagetype   : tgg00_PageType;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17pagetype2_to_line (
                    pagetype2  : tgg00_PageType2;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17parthead (
                    VAR part_head : tsp1_part_header;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        FUNCTION
              g17printable_char (c : char) : boolean;
 
        PROCEDURE
              g17returnsegm_head (
                    VAR retsegm_head : tsp1_segment_header;
                    VAR ln1_len      : integer;
                    VAR ln1          : tsp00_Line;
                    VAR ln2_len      : integer;
                    VAR ln2          : tsp00_Line);
 
        PROCEDURE
              gg17SessionTransToLine (
                    VAR session      : tgg91_SessionNo;
                    VAR trans        : tgg91_TransNo;
                    VAR writetransid : tgg91_TransNo;
                    VAR subtrans     : tgg00_SubtransNo;
                    VAR ln_len       : integer;
                    VAR ln           : tsp00_Line);
 
        PROCEDURE
              g17siteto_line (
                    site           : tgg00_ServerdbNo;
                    VAR ln_len     : integer;
                    VAR ln         : tsp00_Line);
 
        PROCEDURE
              g17sname_to_line (
                    n             : tsp00_Sname;
                    VAR ln_len    : integer;
                    VAR ln        : tsp00_Line);
 
        PROCEDURE
              g17st1op (
                    op      : tgg00_StackOpType;
                    VAR len : integer;
                    VAR msg : tsp00_Sname);
 
        PROCEDURE
              g17trans_state_to_line (
                    trans_state : tgg00_TransState;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17trimint4_to_line (
                    int4       : tsp00_Int4;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17warning_item_to_line (
                    warning_item : tsp00_Warnings;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17vftype (
                    ft         : tsp00_VfType;
                    VAR ln_len : tsp00_Int4;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17paraminfo_to_line (
                    VAR pi     : tsp1_param_info;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17showkind_to_line (
                    show_kind   : tgg00_ShowKind;
                    VAR ln_len  : integer;
                    VAR ln      : tsp00_Line);
 
        PROCEDURE
              g17access_mode_set (
                    access_state : tgg07_StratAccessModSet;
                    VAR ln_len   : integer;
                    VAR ln       : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              KernelAdministration_Interface : VGG999;
 
        PROCEDURE
              gg999Abort (writeCore : boolean);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        FUNCTION
              s20buf_to_int4 (
                    VAR source    : tgg00_RecBody;
                    source_pos    : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s20buf_to_int4_1 (
                    VAR source    : tsp00_MoveObj;
                    source_pos    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26next_segment (VAR segm_ptr : tsp1_segment_ptr);
 
        PROCEDURE
              s26nextpart (VAR part_ptr : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30lnr (
                    VAR str   : tsp00_Line;
                    val       : char;
                    start     : tsp00_Int4;
                    cnt       : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vabort (write_core : boolean);
 
        PROCEDURE
              vgetpid (VAR pid : tsp00_TaskId);
 
        PROCEDURE
              vsinit;
 
        PROCEDURE
              vscheck (VAR maxstacksize : tsp00_Int4);
 
        PROCEDURE
              vsoverflow;
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              a99print_nodes;
 
              tak_ap_max_tree tsp00_MoveObj
 
        PROCEDURE
              b120InsertTrace;
 
              tgg11_VtraceBodyPtr tsp00_Addr
 
        FUNCTION
              s20buf_to_int4;
 
              tsp00_MoveObj tgg00_RecBody
 
        FUNCTION
              s30lnr;
 
              tsp00_MoveObj tsp00_Line
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ElkeZ
.sp
.cp 3
Created : 1985-02-06
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-11-08
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.nf
PROCEDURE  TD_INT / TD_INT2 / TD_INT4:
.sp 1;.fo
Gibt den Namen nam mit der angegebenen Integerzahl aus.
.sp 2;.cp 3
PROCEDURE  TD_2INT4
.sp 1;.fo
Gibt die Namen nam1/2 mit den beiden angegebenen Integerzahlen aus.
.sp 2;.cp 3
PROCEDURE  TD_4INT4
.sp 1;.fo
Gibt den Namen nam mit den vier angegebenen Integerzahlen aus.
.sp 2;.cp 3
PROCEDURE  TD_REAL:
.sp 1;.fo
Gibt den Namen nam mit der angegebenen Realzahl aus.
.sp 2;.cp 3
PROCEDURE  TD_CHAR:
.sp 1;.fo
Gibt den Namen nam mit dem angegebenen Charakter in
Hochkomma aus.
.sp 2;.cp 3
PROCEDURE  TD_CHECK:
.sp 1;.fo
Prueft ob die als Argument uebergebene Konsistenzbedingung er-
fuellt ist; falls nicht wird im langsamen System ein Absturz
erzeugt;
.sp 2;.cp 3
PROCEDURE  TD_CRASH:
.sp 1;.fo
Erzeugt im langsamen System einen Absturz; dient zum Erkennen
von unvorhergesehenen Situationen, die im schnellen System
nicht beachtet werden
.sp 2;.cp 3
PROCEDURE  TD_LINE:
.sp 1;.fo
Gibt einen Text, der in Line angegeben ist,
aus.
.sp 2;.cp 3
PROCEDURE  TD_STRING30:
.sp 1;.fo
Gibt einen String (30 Lang), der in str angegeben ist,
aus.
.sp 2;.cp 3
PROCEDURE  TD_NAME:
.sp 1;.fo
Gibt einen Namen, der in nam angegeben ist,
aus.
.sp 2;.cp 3
PROCEDURE  TD_LOC_SET:
.sp 1;.fo
Gibt den Locnoset, der in loc angegeben ist,
in Interndarstellung und Hexadecimal aus.
.sp 2;.cp 3
PROCEDURE  TD_VAL:
.sp 1;.fo
Gibt einen Value, der in val angegeben ist,
in Interndarstellung aus,
und Hexadecimal ?uber den Drucker.
.sp 2;.cp 3
PROCEDURE TD_KEY:
.sp 1;.fo
Gibt einen Key, der in k angegeben ist, aus.
.sp 2;.cp 3
PROCEDURE TD_FILENAME:
.sp 1;.fo
Gibt einen Filename, der in fn angegeben ist, aus.
.sp 2;.cp 3
PROCEDURE  TD_BUF:
.sp 1;.fo
Gibt einen Buffer, der in buf angegeben ist,
evtl. ?ubers Terminal und
?uber den File prot in Hexadecimaldarstellung aus.
Die Ausgabepositionen werden mit startposang und endpose
angegeben. Ist endpose = 0, so wird ab pos = 1 und endpose
wird errechnet, d. h. alle Blanks im Ende des
Puffers werden nicht gedruckt.
.sp 2;.cp 3
PROCEDURE  TD_PRINT_BUF:
.sp
Die  Treminal-Ausgabe wird ausgeschaltet, und t01buf aufgerufen.
Anschlie?zend wird die  alte Terminal-Angabe wieder
gesetzt.
.sp 2;.cp 3
PROCEDURE  CCCPRINT:
.sp;.fo
Druckroutine f?ur den Trace. Druckt am Anfang  einer
Routine 'vdn-name
Routinen-name *', wenn f?ur die entsprechende Schicht der Trace
verlangt wird.
Die Procedure wird bei dem Exec-Aufruf VDNPASC
automatisch in jede Routine gesetzt.
Alle Proceduren aus VGG09, VTA02 und VTA01 werden nicht
gedruckt.
.sp 2;.cp 3
PROCEDURE  TD_MESS_BUFFER:
.sp;.fo
Druckt einen Mess_bufer aus mit den Komponenten
mess_type, mess_string_length und mess_string.
.sp 2;.cp 3
PROCEDURE  TD_READ_INT:
.sp 1;.fo
Liest eine Integerzahl ?ubers Terminal ein.
.sp 2;.cp 3
PROCEDURE  CCCCOUNT:
.sp;.fo
Z?ahlt die Anzahl der Ausf?uhrungen einer Routine.
.sp 2;.cp 3
PROCEDURE  CCCINIT:
.sp;.fo
Initiatisiert die globale Variable f?ur die Zeitmessungen.
.sp 2;.cp 3
PROCEDURE  TIMERANF:
.sp;.fo
Berechnung der Anfangszeit.
.sp 2;.cp 3
PROCEDURE  TIMEREND:
.sp;.fo
Berechnung der verbrauchten Zeit und Aufsummierung
in der globalen Variablen.
.sp 2;.cp 3
PROCEDURE  CCCOUTP:
.sp;.fo
Schreibt f?ur eine Routine die globale Variable der
Messergebnisse in den File 'prot'.
.CM *-END-* specification -------------------------------
.sp 2;.cp 3
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      PACKET_INDENT       =  9;
      SECOND_COLUMN_POS   = 40;
      (* *)
      CALL_FUNCTION_SIGN  = '>';
      LEAVE_FUNCTION_SIGN = ' ';
      STR_DELIMITER       = '''';
      (* *)
      TDSTOP           = 'TDSTOP          ';
      (**)
      DOUBLE_NUMBERING = true;
      EDIT_MODE        = true;
      WITH_ZERO        = true;
      WRITE_CORE       = true;
 
TYPE
 
      states_td = RECORD
            on_text        : tsp00_Trace;
            off_text       : tsp00_Trace;
            on_count       : integer;
            maxlength      : tsp00_Int4;
            last_layer     : char;
            minbuf         : boolean;
            use_stacksize  : boolean;
            debug_or_trace : boolean;
            trace_ak       : boolean;
            trace_bd       : boolean;
            trace_dg       : boolean;
            trace_en       : boolean;
            trace_gg       : boolean;
            trace_in       : boolean;
            trace_kb       : boolean;
            trace_ra       : boolean;
            trace_sp       : boolean;
            debugging      : SET OF tgg00_Debug;
            blankline      : tsp00_Line
      END;
 
 
      hexbuf_line = RECORD
            CASE integer OF
                1:
                    (ln : tsp00_Line);
                2:
                    (prefix : tsp00_C4)
                END;
            (*ENDCASE*) 
 
      tta01_small_stack = ARRAY [1..100] OF tgg00_StackEntry;
 
VAR
      td                : states_td;
      ta01SwitchContext : states_td;
      ta01SingleUser    : boolean;
      ta01SwitchLevel   : integer;
 
 
(*------------------------------*) 
 
PROCEDURE
      cccinit (VAR ccv : tsp00_Ccc);
 
BEGIN
ccv.count := 0
END;
 
(*------------------------------*) 
 
PROCEDURE
      cccoutp (n : tsp00_C20; ccv : tsp00_Ccc);
 
VAR
      i       : integer;
      n_count : tsp00_C20;
      ln      : tsp00_Line;
 
BEGIN
n_count := 'count :             ';
ln      := td.blankline;
i := 1;
WHILE i <= 16 DO
    BEGIN
    ln [i] := n [i];
    i := succ(i)
    END;
(*ENDWHILE*) 
i := 1;
WHILE i <= 7 DO
    BEGIN
    ln [20+i] := n_count [i];
    i := succ(i)
    END;
(*ENDWHILE*) 
g17int4to_line (ccv.count, false, 11, 28, ln);
ta01vtrace_write (ln, 38)
END;
 
(*------------------------------*) 
 
PROCEDURE
      cccprint (tt : tsp00_Trace);
      (******** hta01.h ********)
 
CONST
      c_procedur_escape_sign = '<';
 
VAR
      switched_on    : boolean;
      trace_en_gg_sp : boolean;
      trace_output   : boolean;
      ln_len         : integer;
      move_err       : tgg00_BasisError;
      stacksize      : tsp00_Int4;
      msg            : tsp00_C24;
      ln             : tsp00_Line;
      start_layer    : integer;
 
BEGIN
switched_on := false;
stacksize   := 0;
start_layer := 1;
vsoverflow;
&ifdef STACKCHK
vscheck (stacksize);
(* PTS 1110953 E.Z. *)
&ENDIF
IF  td.on_text = tt
THEN
    BEGIN
    td.on_count := td.on_count - 1;
    IF  td.on_count = 0
    THEN
        BEGIN
        IF  td.off_text = TDSTOP
        THEN
            BEGIN
            msg := bsp_c24;
            ln_len := 1;
            WHILE ln_len <= sizeof (tt) DO
                BEGIN
                msg [ln_len] := tt [ln_len];
                ln_len := succ(ln_len)
                END;
            (*ENDWHILE*) 
            g01opmsg (sp3p_console, sp3m_warning, csp3_msg,
                  'TDSTOP  ', msg, 0);
            gg999Abort (NOT WRITE_CORE)
            END
        ELSE
            BEGIN
            td.on_text        := bsp_c16;
            td.debug_or_trace := true;
            switched_on       := true
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  td.debug_or_trace
THEN
    BEGIN
    IF  (td.off_text = tt) AND NOT switched_on
    THEN
        BEGIN
        td.debug_or_trace := false;
        td.off_text       := bsp_c16
        END
    ELSE
        BEGIN
        trace_output   := false;
        trace_en_gg_sp := false;
        IF  (tt [start_layer] = c_procedur_escape_sign)
        THEN
            start_layer := succ(start_layer);
        (*ENDIF*) 
        CASE tt [start_layer]  OF
            'a' , 'A':
                IF  td.trace_ak
                THEN
                    BEGIN
                    trace_output  := true;
                    td.last_layer := tt [start_layer]
                    END;
                (*ENDIF*) 
            'b' , 'B':
                IF  td.trace_bd
                THEN
                    BEGIN
                    trace_output  := true;
                    td.last_layer := tt [start_layer]
                    END;
                (*ENDIF*) 
            'd' , 'D':
                IF  td.trace_dg
                THEN
                    BEGIN
                    trace_output  := true;
                    td.last_layer := tt [start_layer]
                    END;
                (*ENDIF*) 
            'e' , 'E':
                IF  td.trace_en
                THEN
                    trace_en_gg_sp := true;
                (*ENDIF*) 
            'g' , 'G':
                IF  td.trace_gg
                THEN
                    trace_en_gg_sp := true;
                (*ENDIF*) 
            'i' , 'I':
                IF  td.trace_in
                THEN
                    BEGIN
                    trace_output  := true;
                    td.last_layer := tt [start_layer]
                    END;
                (*ENDIF*) 
            'k' , 'K':
                IF  td.trace_kb
                THEN
                    BEGIN
                    trace_output  := true;
                    td.last_layer := tt [start_layer]
                    END;
                (*ENDIF*) 
            's' , 'S':
                IF  td.trace_sp
                THEN
                    trace_en_gg_sp := true;
                (*ENDIF*) 
            'r' , 'R':
                IF  td.trace_ra
                THEN
                    BEGIN
                    trace_output  := true;
                    td.last_layer := tt [start_layer]
                    END;
                (*ENDIF*) 
            OTHERWISE
                trace_output := true
            END;
        (*ENDCASE*) 
        IF  trace_en_gg_sp
        THEN
            CASE td.last_layer OF
                'a' , 'A':
                    IF  td.trace_ak
                    THEN
                        trace_output := true;
                    (*ENDIF*) 
                'b' , 'B':
                    IF  td.trace_bd
                    THEN
                        trace_output := true;
                    (*ENDIF*) 
                'd' , 'D':
                    IF  td.trace_dg
                    THEN
                        trace_output := true;
                    (*ENDIF*) 
                'i' , 'I':
                    IF  td.trace_in
                    THEN
                        trace_output := true;
                    (*ENDIF*) 
                'k' , 'K':
                    IF  td.trace_kb
                    THEN
                        trace_output := true;
                    (*ENDIF*) 
                OTHERWISE
                    trace_output := false
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        IF  trace_output
        THEN
            BEGIN
            ln       := td.blankline;
            move_err := e_ok;
            SAPDB_PascalMove ('VTA01 ',   1,    
                  sizeof (tt), sizeof (ln),
                  @tt, 1, @ln, 2, sizeof (tt), move_err);
            IF  td.use_stacksize
            THEN
                BEGIN
                g17int4to_line (stacksize, false, 11,
                      1 + sizeof(tt) + 2, ln);
                ln_len := 1 + sizeof (tt) + 1 + 11
                END
            ELSE
                ln_len := 1 + sizeof (tt);
            (*ENDIF*) 
            ta01function_trace_write (ln, ln_len)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01addr (
            debug    : tgg00_Debug;
            nam      : tsp00_Sname;
            bufaddr  : tsp00_BufAddr);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      i      : integer;
      ln     : tsp00_Line;
 
      addr_str : RECORD
            CASE boolean OF
                true:
                    (a : tsp00_BufAddr);
                false:
                    (c : tsp00_C8);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    IF  bufaddr = NIL
    THEN
        g17sname_to_line ('nil         ', ln_len, ln)
    ELSE
        BEGIN
        addr_str.a := bufaddr;
        i := 1;
        WHILE i <= sizeof (bufaddr) DO
            BEGIN
            g17hexto_line (addr_str.c [i], ln_len, ln);
            i := succ(i)
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01addr_1 (
            debug      : tgg00_Debug;
            nam        : tsp00_Sname;
            bufaddr    : tsp00_BufAddr);
 
BEGIN
t01addr (debug, nam, bufaddr)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01addr_2 (
            debug      : tgg00_Debug;
            nam        : tsp00_Sname;
            bufaddr    : tsp00_BufAddr);
 
BEGIN
t01addr (debug, nam, bufaddr)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01addr_3 (
            debug      : tgg00_Debug;
            nam        : tsp00_Sname;
            bufaddr    : tsp00_BufAddr);
 
BEGIN
t01addr (debug, nam, bufaddr)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01addr2 (
            debug     : tgg00_Debug;
            nam1      : tsp00_Sname;
            bufaddr1  : tsp00_BufAddr;
            nam2      : tsp00_Sname;
            bufaddr2  : tsp00_BufAddr);
      (******** hta01.h ********)
 
VAR
      move_err : tgg00_BasisError;
      length   : integer;
      index    : integer;
      line     : tsp00_Line;
 
      addr_str : RECORD
            CASE integer OF
                0:
                    (a : tsp00_BufAddr);
                1:
                    (c : tsp00_C8);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (line, length, nam1);
    IF  bufaddr1 = NIL
    THEN
        g17sname_to_line ('nil         ', length, line)
    ELSE
        BEGIN
        addr_str.a := bufaddr1;
        index := 1;
        WHILE index <= sizeof (bufaddr1) DO
            BEGIN
            g17hexto_line (addr_str.c [index], length, line);
            index := succ(index)
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    length   := pred (SECOND_COLUMN_POS);
    move_err := e_ok;
    SAPDB_PascalMove ('VTA01 ',   2,    
          sizeof (nam2), sizeof (line),
          @nam2, 1, @line, length + 1, sizeof (nam2), move_err);
    length        := length + sizeof (nam2) + 2;
    line [length] := ':';
    length        := length + 1;
    IF  bufaddr2 = NIL
    THEN
        g17sname_to_line ('nil         ', length, line)
    ELSE
        BEGIN
        addr_str.a := bufaddr2;
        index := 1;
        WHILE index <= sizeof (bufaddr2) DO
            BEGIN
            g17hexto_line (addr_str.c [index], length, line);
            index := succ(index)
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    ta01vtrace_write (line, length)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01aptree (
            debug       : tgg00_Debug;
            VAR ap_tree : tsp00_MoveObj;
            node_cnt    : integer;
            hint_node   : tsp00_Int2);
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    a99print_nodes (ap_tree, node_cnt, hint_node)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01basis_error (
            debug : tgg00_Debug;
            nam   : tsp00_Sname;
            b_err : tgg00_BasisError);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    g17basis_err_to_line (b_err, ln_len, ln);
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01bduse (
            debug : tgg00_Debug;
            nam : tsp00_Sname;
            s   : tgg00_BdUseSet);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    ln_len := ln_len - 1;
    g17bd_use_set_to_line (s, ln_len, ln);
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01bool (
            debug    : tgg00_Debug;
            nam      : tsp00_Sname;
            curr_bool: boolean);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    CASE ord (curr_bool) OF
        0:
            g17sname_to_line ('false       ', ln_len, ln);
        1:
            g17sname_to_line ('true        ', ln_len, ln);
        OTHERWISE
            BEGIN
            (* error case : neither 0 nor 1 *)
            g17sname_to_line    ('***         ', ln_len, ln);
            g17trimint4_to_line (ord (curr_bool),     ln_len, ln)
            END
        END;
    (*ENDCASE*) 
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01bool2 (
            debug     : tgg00_Debug;
            nam1      : tsp00_Sname;
            bool1     : boolean;
            nam2      : tsp00_Sname;
            bool2     : boolean);
      (******** hta01.h ********)
 
VAR
      move_err : tgg00_BasisError;
      ln_len   : integer;
      ln       : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam1);
    CASE ord (bool1) OF
        0:
            g17sname_to_line ('false       ', ln_len, ln);
        1:
            g17sname_to_line ('true        ', ln_len, ln);
        OTHERWISE
            BEGIN
            (* error case : neither 0 nor 1 *)
            g17sname_to_line    ('***         ', ln_len, ln);
            g17trimint4_to_line (ord (bool1),    ln_len, ln)
            END
        END;
    (*ENDCASE*) 
    ln_len   := SECOND_COLUMN_POS - 1;
    move_err := e_ok;
    SAPDB_PascalMove ('VTA01 ',   3,    
          sizeof (nam2), sizeof (ln),
          @nam2, 1, @ln, ln_len+1, sizeof (nam2), move_err);
    ln_len      := ln_len + sizeof (nam2) + 2;
    ln [ln_len] := ':';
    CASE ord (bool2) OF
        0:
            g17sname_to_line (' false      ', ln_len, ln);
        1:
            g17sname_to_line (' true       ', ln_len, ln);
        OTHERWISE
            BEGIN
            (* error case : neither 0 nor 1 *)
            g17sname_to_line    (' ***        ', ln_len, ln);
            g17trimint4_to_line (ord (bool2),    ln_len, ln)
            END
        END;
    (*ENDCASE*) 
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01buf (
            debug    : tgg00_Debug;
            VAR buf  : tsp00_Buf;
            startpos : integer;
            endpos   : integer);
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    ta01obj_display ('BUFFER      ', @buf, sizeof (buf),
          startpos, endpos, NOT DOUBLE_NUMBERING, startpos)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01buf1 (
            debug    : tgg00_Debug;
            VAR buf  : tsp00_Buf;
            startpos : integer;
            endpos   : integer);
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    ta01obj_display ('BUFFER      ', @buf, sizeof (buf),
          startpos, endpos, NOT DOUBLE_NUMBERING, startpos)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01char (
            debug    : tgg00_Debug;
            nam      : tsp00_Sname;
            c        : char);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    ln_len      := ln_len + 1;
    ln [ln_len] := STR_DELIMITER;
    IF  g17printable_char (c)
    THEN
        BEGIN
        ln [ln_len+1] := c;
        ln [ln_len+2] := STR_DELIMITER
        END
    ELSE
        BEGIN
        g17hexto_line (c, ln_len, ln);
        ln [ln_len+1] := STR_DELIMITER;
        ln [ln_len+2] := 'h'
        END;
    (*ENDIF*) 
    ln_len := ln_len + 2;
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01counter (
            debug       : tgg00_Debug;
            nam         : tsp00_Sname;
            counter     : tsp00_8ByteCounter);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
(* PTS 1103743 JA 1999-08-25 *)
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    g17counter_to_line (counter, ln_len, ln);
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01cpp_trace (
            VAR proc_name : tsp00_C30;
            is_start : boolean);
      (******** hta01.h ********)
 
CONST
      c_layer_byte =  1;
 
VAR
      end_of_name    : boolean;
      switched_on    : boolean;
      trace_output   : boolean;
      i              : integer;
      layer_byte1    : char;
      layer_byte2    : char;
      trace_name     : tsp00_Trace;
      msg            : tsp00_C24;
      ln             : tsp00_Line;
 
BEGIN
IF  td.debug_or_trace
THEN
    BEGIN
    switched_on := false;
    end_of_name := false;
    IF  is_start AND (td.on_text <> bsp_c16)
    THEN
        BEGIN
        FOR i := 1 TO sizeof (trace_name) DO
            BEGIN
            IF  proc_name [i] = chr (0)
            THEN
                end_of_name := true;
            (*ENDIF*) 
            IF  end_of_name
            THEN
                trace_name [i] := ' '
            ELSE
                trace_name [i] := proc_name [i]
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        IF  td.on_text = trace_name
        THEN
            BEGIN
            td.on_count := td.on_count - 1;
            IF  td.on_count = 0
            THEN
                BEGIN
                IF  td.off_text = TDSTOP
                THEN
                    BEGIN
                    msg := bsp_c24;
                    i   := 1;
                    WHILE i <= sizeof (trace_name) DO
                        BEGIN
                        msg [i] := trace_name [i];
                        i       := succ(i)
                        END;
                    (*ENDWHILE*) 
                    g01opmsg (sp3p_console, sp3m_warning, csp3_msg,
                          'TDSTOP  ', msg, 0);
                    gg999Abort (NOT WRITE_CORE)
                    END
                ELSE
                    BEGIN
                    td.on_text        := bsp_c16;
                    td.debug_or_trace := true;
                    switched_on       := true
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  td.debug_or_trace AND
            (td.off_text = trace_name) AND NOT switched_on
        THEN
            BEGIN
            td.debug_or_trace := false;
            td.off_text       := bsp_c16
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  td.debug_or_trace
    THEN
        BEGIN
        trace_output := false;
        IF  proc_name [c_layer_byte] = 'c'
        THEN
            BEGIN
            layer_byte1 := proc_name [c_layer_byte+1];
            layer_byte2 := proc_name [c_layer_byte+2];
            END
        ELSE
            BEGIN
            layer_byte1 := proc_name [c_layer_byte  ];
            layer_byte2 := proc_name [c_layer_byte+1];
            END;
        (*ENDIF*) 
        CASE layer_byte1 OF
            'a' , 'A':
                IF  td.trace_ak
                    OR
                    ((layer_byte2 <> 'k') AND
                    ( layer_byte2 <> 'K'))
                THEN
                    trace_output := true;
                (*ENDIF*) 
            'b' , 'B':
                IF  td.trace_bd
                    OR
                    ((layer_byte2 <> 'd') AND
                    ( layer_byte2 <> 'D'))
                THEN
                    trace_output := true;
                (*ENDIF*) 
            'd' , 'D':
                IF  td.trace_dg
                    OR
                    ((layer_byte2 <> 'g') AND
                    ( layer_byte2 <> 'G'))
                THEN
                    trace_output := true;
                (*ENDIF*) 
            'e' , 'E':
                IF  td.trace_en
                    OR
                    ((layer_byte2 <> 'n') AND
                    ( layer_byte2 <> 'N'))
                THEN
                    trace_output := true;
                (*ENDIF*) 
            'g' , 'G':
                IF  td.trace_gg
                    OR
                    ((layer_byte2 <> 'g') AND
                    ( layer_byte2 <> 'G'))
                THEN
                    trace_output := true;
                (*ENDIF*) 
            'i' , 'I':
                IF  td.trace_in
                    OR
                    ((layer_byte2 <> 'n') AND
                    ( layer_byte2 <> 'N'))
                THEN
                    trace_output := true;
                (*ENDIF*) 
            'k' , 'K':
                IF  td.trace_kb
                    OR
                    ((layer_byte2 <> 'b') AND
                    ( layer_byte2 <> 'B'))
                THEN
                    trace_output := true;
                (*ENDIF*) 
            'r' , 'R':
                IF  td.trace_ra
                    OR
                    ((layer_byte2 <> 'a') AND
                    ( layer_byte2 <> 'A'))
                THEN
                    trace_output := true;
                (*ENDIF*) 
            's' , 'S':
                IF  td.trace_sp
                    OR
                    ((layer_byte2 <> 'p') AND
                    ( layer_byte2 <> 'P'))
                THEN
                    trace_output := true;
                (*ENDIF*) 
            OTHERWISE
                trace_output := true
            END;
        (*ENDCASE*) 
        IF  trace_output
        THEN
            BEGIN
            ln := td.blankline;
            IF  is_start
            THEN
                ln [1] := CALL_FUNCTION_SIGN
            ELSE
                BEGIN
                ln [1] := LEAVE_FUNCTION_SIGN;
                END;
            (*ENDIF*) 
            i := 1;
            end_of_name := false;
            WHILE (i <= sizeof (proc_name)) AND NOT end_of_name DO
                BEGIN
                IF  proc_name [i] = chr (0)
                THEN
                    end_of_name := true
                ELSE
                    ln [1+i] := proc_name [i];
                (*ENDIF*) 
                i := i + 1
                END;
            (*ENDWHILE*) 
            ta01function_trace_write (ln, i);  (* len = 1 + i - 1 *)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01c2int (
            debug     : tgg00_Debug;
            nam       : tsp00_Sname;
            int2      : tsp00_C2);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    g17c2int_to_line (int2, ln_len, ln);
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01c4int (
            debug     : tgg00_Debug;
            nam       : tsp00_Sname;
            int4      : tsp00_C4);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    g17c4int_to_line (int4, ln_len, ln);
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01c18 (debug : tgg00_Debug; msg : tsp00_C18);
 
VAR
      i  : integer;
      ln : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln := td.blankline;
    i := 1;
    WHILE i <= sizeof (msg) DO
        BEGIN
        IF  g17printable_char (msg [i])
        THEN
            ln [i] := msg [i]
        ELSE
            ln [i] := '.';
        (*ENDIF*) 
        i := succ(i)
        END;
    (*ENDWHILE*) 
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01c32 (debug : tgg00_Debug; msg : tsp00_C32);
 
VAR
      i  : integer;
      ln : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln := td.blankline;
    i := 1;
    WHILE i <= sizeof (msg) DO
        BEGIN
        IF  g17printable_char (msg [i])
        THEN
            ln [i] := msg [i]
        ELSE
            ln [i] := '.';
        (*ENDIF*) 
        i := succ(i)
        END;
    (*ENDWHILE*) 
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01c64 (debug : tgg00_Debug; VAR msg : tsp00_C64);
 
VAR
      i  : integer;
      ln : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln := td.blankline;
    i := 1;
    WHILE i <= sizeof (msg) DO
        BEGIN
        IF  g17printable_char (msg [i])
        THEN
            ln [i] := msg [i]
        ELSE
            ln [i] := '.';
        (*ENDIF*) 
        i := succ(i)
        END;
    (*ENDWHILE*) 
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01c30 (debug : tgg00_Debug; msg : tsp00_C30);
 
VAR
      i  : integer;
      ln : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln := td.blankline;
    i := 1;
    WHILE i <= sizeof (msg) DO
        BEGIN
        IF  g17printable_char (msg [i])
        THEN
            ln [i] := msg [i]
        ELSE
            ln [i] := '.';
        (*ENDIF*) 
        i := succ(i)
        END;
    (*ENDWHILE*) 
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01c40 (debug : tgg00_Debug; msg : tsp00_C40);
 
VAR
      i  : integer;
      ln : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln := td.blankline;
    i := 1;
    WHILE i <= sizeof (msg) DO
        BEGIN
        IF  g17printable_char (msg [i])
        THEN
            ln [i] := msg [i]
        ELSE
            ln [i] := '.';
        (*ENDIF*) 
        i := succ(i)
        END;
    (*ENDWHILE*) 
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01devname (
            debug : tgg00_Debug;
            nam : tsp00_Sname;
            d   : tsp00_DevName);
 
VAR
      i      : integer;
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    ln_len      := ln_len + 1;
    ln [ln_len] := STR_DELIMITER;
    i := 1;
    WHILE i <= sizeof (d) DO
        BEGIN
        IF  g17printable_char (d [i])
        THEN
            ln [ln_len + i] := d [i]
        ELSE
            ln [ln_len + i] := '.';
        (*ENDIF*) 
        i := succ(i)
        END;
    (*ENDWHILE*) 
    ln_len      := ln_len + sizeof (d) + 1;
    ln [ln_len] := STR_DELIMITER;
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01dump_state_set (
            debug : tgg00_Debug;
            nam : tsp00_Sname;
            s   : tgg00_DumpStateSet);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    ln_len := ln_len - 1;
    g17dump_state_set (s, ln_len, ln);
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01filename (
            debug : tgg00_Debug;
            fn : tgg00_Filename);
      (******** hta01.h ********)
 
VAR
      is_ln3 : boolean;
      ln1    : tsp00_Line;
      ln2    : tsp00_Line;
      ln3    : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    g17filename ('filename    ', fn, 0, ln1, ln2, ln3, is_ln3);
    t01write_line (ln1);
    t01write_line (ln2);
    IF  is_ln3
    THEN
        t01write_line (ln3)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01filetype (
            debug : tgg00_Debug;
            nam : tsp00_Sname;
            s   : tgg00_FiletypeSet);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    ln_len := ln_len - 1;
    g17filetype_to_line (s, NOT EDIT_MODE, ln_len, ln);
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01FileVers (
            debug         : tgg00_Debug;
            nam           : tsp00_Sname;
            VAR FileVers  : tgg91_FileVersion);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    gg06FileVersToLine (FileVers, ln_len, ln);
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01handling (
            debug : tgg00_Debug;
            nam : tsp00_Sname;
            s   : tgg00_HandlingSet);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    ln_len := ln_len - 1;
    g17handling_set_to_line (s, ln_len, ln);
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01identifier (
            debug      : tgg00_Debug;
            identifier : tsp00_Identifier);
 
VAR
      i  : integer;
      ln : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln := td.blankline;
    i := 1;
    WHILE i <= sizeof (identifier) DO
        BEGIN
        IF  g17printable_char (identifier [i])
        THEN
            ln [i] := identifier [i]
        ELSE
            ln [i] := '.';
        (*ENDIF*) 
        i := succ(i)
        END;
    (*ENDWHILE*) 
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01Int4 (
            debug : tgg00_Debug;
            nam  : tsp00_Name;
            int4 : tsp00_Int4);
 
VAR
      ln : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln := td.blankline;
    ta01name_int4_to_line (nam, sizeof(tsp00_Name)+1, int4, 11, 1, ln);
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01int4 (
            debug : tgg00_Debug;
            nam  : tsp00_Sname;
            int4 : tsp00_Int4);
      (******** hta01.h ********)
 
VAR
      ln : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln := td.blankline;
    ta01sname_int4_to_line (nam, 13, int4, 11, 1, ln);
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01int4_addr (
            debug         : tgg00_Debug;
            nam1          : tsp00_Sname;
            int4          : tsp00_Int4;
            nam2          : tsp00_Sname;
            bufaddr       : tsp00_BufAddr);
 
VAR
      move_err : tgg00_BasisError;
      length   : integer;
      index    : integer;
      line     : tsp00_Line;
 
      addr_str : RECORD
            CASE integer OF
                0:
                    (a : tsp00_BufAddr);
                1:
                    (c : tsp00_C8);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    line := td.blankline;
    ta01sname_int4_to_line (nam1, 13, int4, 11, 1, line);
    length   := pred (SECOND_COLUMN_POS);
    move_err := e_ok;
    SAPDB_PascalMove ('VTA01 ',   4,    
          sizeof (nam2), sizeof (line),
          @nam2, 1, @line, length + 1, sizeof (nam2), move_err);
    length        := length + sizeof(nam2) + 2;
    line [length] := ':';
    length        := succ (length);
    IF  bufaddr = NIL
    THEN
        g17sname_to_line ('nil         ', length, line)
    ELSE
        BEGIN
        addr_str.a := bufaddr;
        index := 1;
        WHILE index <= sizeof (bufaddr) DO
            BEGIN
            g17hexto_line (addr_str.c [index], length, line);
            index := succ(index)
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    ta01vtrace_write (line, length)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      t01istrace (
            debug       : tgg00_Debug;
            session     : tgg91_SessionNo) : boolean;
 
BEGIN
t01istrace :=
      ((debug = td_always) OR
      ( td.debug_or_trace AND (debug in td.debugging))
      )
      AND
      ((g01vtrace.vtrSession_gg00.ci4_gg00 = cgg_nil_session) OR
      ( g01vtrace.vtrSession_gg00          = session))
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01key (
            debug   : tgg00_Debug;
            nam     : tsp00_Sname;
            VAR k   : tgg00_Lkey);
      (******** hta01.h ********)
 
VAR
      display_bytes : boolean;
      is_fullkey    : boolean;
      i             : integer;
      ln_len        : integer;
      ln            : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    display_bytes := false;
    t01init_line (ln, ln_len, nam);
    IF  k.keyLen_gg00 < 0
    THEN
        BEGIN
        g17sname_to_line ('*** keyLen= ', ln_len, ln);
        g17trimint4_to_line (k.keyLen_gg00, ln_len, ln)
        END
    ELSE
        IF  k.keyLen_gg00 = 0
        THEN
            g17sname_to_line ('ZEROKEY     ', ln_len, ln)
        ELSE
            IF  (k.keyLen_gg00 = 1) AND (k.keyVal_gg00 [1] = csp_undef_byte)
            THEN
                g17nameto_line ('UNDEFKEY, keyLen=1', ln_len, ln)
            ELSE
                BEGIN
                is_fullkey := true;
                i := 1;
                WHILE is_fullkey AND (i <= k.keyLen_gg00) DO
                    BEGIN
                    IF  k.keyVal_gg00 [i] <> chr (255)
                    THEN
                        is_fullkey := false;
                    (*ENDIF*) 
                    i := succ(i)
                    END;
                (*ENDWHILE*) 
                IF  is_fullkey
                THEN
                    BEGIN
                    g17nameto_line ('FULLKEY, keyLen=  ', ln_len, ln);
                    g17trimint4_to_line (k.keyLen_gg00, ln_len, ln)
                    END
                ELSE
                    display_bytes := true
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  NOT display_bytes
    THEN
        t01write_line (ln)
    ELSE
        ta01obj_display (nam, @k.keyVal_gg00, sizeof (k.keyVal_gg00),
              1, k.keyLen_gg00, NOT DOUBLE_NUMBERING, 1)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01lkey (
            debug : tgg00_Debug;
            VAR k : tgg00_Lkey);
      (******** hta01.h ********)
 
BEGIN
t01key (debug, 'KEY         ', k)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01lidentifier (
            debug      : tgg00_Debug;
            identifier : tsp00_KnlIdentifier);
 
VAR
      i  : integer;
      ln : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln := td.blankline;
    i := 1;
    WHILE i <= sizeof (identifier) DO
        BEGIN
        IF  g17printable_char (identifier [i])
        THEN
            ln [i] := identifier [i]
        ELSE
            ln [i] := '.';
        (*ENDIF*) 
        i := succ(i)
        END;
    (*ENDWHILE*) 
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01line (debug : tgg00_Debug; VAR ln : tsp00_Line);
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    t01write_line (ln)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01bufline (
            debug       : tgg00_Debug;
            VAR ln      : tsp00_Line;
            len         : integer);
      (******** hta01.h ********)
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    ta01vtrace_write (ln, len)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01lmulti_switch (
            VAR s20      : tsp00_C20;
            VAR s201     : tsp00_C20;
            VAR on_text  : tsp00_C16;
            VAR off_text : tsp00_C16;
            on_count     : integer);
 
BEGIN
td.on_text  := bsp_c16;
td.off_text := bsp_c16;
td.on_count := 0;
ta01trace_set (s20);
ta01test_set  (s201);
td.debug_or_trace := false;
td.on_text        := on_text;
td.off_text       := off_text;
td.on_count       := on_count;
IF  td.off_text = TDSTOP
THEN
    td.debug_or_trace := true
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01localstate (
            debug : tgg00_Debug;
            nam : tsp00_Sname;
            s   : tgg00_TransState);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    ln_len := ln_len - 1;
    g17trans_state_to_line (s, ln_len, ln);
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01lock (
            debug    : tgg00_Debug;
            nam      : tsp00_Sname;
            VAR lock : tgg00_Lock);
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01sname     (debug, nam);
    t01tabid     (debug, '.lockTabId  ', lock.lockTabId_gg00 );
    t01site      (debug, '.lockSite   ', lock.lockSite_gg00  );
    t01lockmode  (debug, '.lockMode   ', lock.lockMode_gg00  );
    t01lockstate (debug, '.lockState  ', lock.lockState_gg00 );
    t01int4      (debug, '.lockKeyLen ', lock.lockKeyLen_gg00);
    t01int4      (debug, '.lockKeyPos ', lock.lockKeyPos_gg00)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01lockmode (
            debug        : tgg00_Debug;
            nam          : tsp00_Sname;
            lock_mode    : tgg00_LockReqMode);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    g17lockmode_to_line (lock_mode, ln_len, ln);
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01lockstate (
            debug         : tgg00_Debug;
            nam           : tsp00_Sname;
            lock_state    : tgg00_LockReqState);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    ln_len := ln_len - 1;
    g17lockstate_to_line (lock_state, ln_len, ln);
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01long_qual (
            debug         : tgg00_Debug;
            nam           : tsp00_Sname;
            VAR long_qual : tgg00_LongQual);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    WITH long_qual DO
        BEGIN
        ln     := td.blankline;
        ln_len := 0;
        g17sname_to_line ('---         ', ln_len, ln);
        ln_len := ln_len + 1;
        g17sname_to_line (nam, ln_len, ln);
        ln_len := ln_len + 1;
        g17sname_to_line ('---         ', ln_len, ln);
        ta01vtrace_write (ln, ln_len);
        t01p2int4    (debug, 'lq_pos      ', lq_pos
              ,              'lq_len      ', lq_len);
        t01p2int4    (debug, 'lq_long_size', lq_long_size
              ,              'lq_data_offs', lq_data_offset);
        t01bool      (debug, 'long_in_file', lq_long_in_file);
        t01bool      (debug, 'trunc/is_pat', lq_trunc_req);
        t01int4      (debug, 'lq_code     ', ord (lq_code));
        t01bool      (debug, 'lq_first_ins', lq_first_insert);
        t01bool      (debug, 'lq_readahead', lq_last_part_of_usercmd);
        t01bool      (debug, 'lq_readahead', lq_prefetch);
        t01char      (debug, 'lq_expand_ch', lq_expand_char [1]);
        t01surrogate (debug, 'lock tabid  ', lq_lock_tabid)
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01longdescriptor (
            debug     : tgg00_Debug;
            long_desc : tsp00_LongDescriptor);
 
BEGIN
WITH long_desc DO
    BEGIN
    (* PTS 1105838 E.Z. *)
    t01surrogate (debug, 'ldDescriptor', ld_descriptor);
    t01surrogate (debug, 'ldTabid     ', ld_tabid);
    IF  ld_stream IN ld_state
    THEN
        t01int4 (debug, 'ld_stream   ', 1);
    (*ENDIF*) 
    IF  ld_use_conversion IN ld_state
    THEN
        t01int4 (debug, 'ldUseConvers', ord (ld_use_conversion));
    (*ENDIF*) 
    IF  ld_use_toascii IN ld_state
    THEN
        t01int4 (debug, 'ldUseToAscii', 1);
    (*ENDIF*) 
    IF  ld_use_ucs_2_swap IN ld_state
    THEN
        t01int4 (debug, 'ldUseUCS2Swp', 1);
    (*ENDIF*) 
    IF  ld_short_scol IN ld_state
    THEN
        t01int4 (debug, 'ldShortScol ', ord (ld_short_scol));
    (*ENDIF*) 
    IF  ld_first_insert IN ld_state
    THEN
        t01int4 (debug, 'ldFirstInsrt', 1);
    (*ENDIF*) 
    IF  ld_copy IN ld_state
    THEN
        t01int4 (debug, 'ldCopy      ', 1);
    (*ENDIF*) 
    IF  ld_first_call IN ld_state
    THEN
        t01int4 (debug, 'ldFirstCAll ', 1);
    (*ENDIF*) 
    t01int4 (debug, 'ldMaxLen    ', ld_maxlen);
    t01int4 (debug, 'ldInternPos ', ld_intern_pos);
    IF  (ld_ex_trigger in ld_infoset)
    THEN
        t01int4 (debug, 'ldExTrigger ', ord (ld_ex_trigger));
    (*ENDIF*) 
    IF  (ld_with_lock in ld_infoset)
    THEN
        t01int4 (debug, 'ldWithLock  ', ord (ld_with_lock));
    (*ENDIF*) 
    CASE ld_valmode OF
        vm_datapart     :
            t01sname (debug, 'vmDataPart  ');
        vm_alldata      :
            t01sname (debug, 'vmAllData   ');
        vm_lastdata     :
            t01sname (debug, 'vmLastData  ');
        vm_nodata       :
            t01sname (debug, 'vmNoData    ');
        vm_no_more_data :
            t01sname (debug, 'vmNoMoreData');
        vm_last_putval :
            t01sname (debug, 'vmLastPutVal');
        vm_data_trunc :
            t01sname (debug, 'vmDataTrunc ');
        OTHERWISE
            t01int4  (debug, 'vm_otherwise', ord (ld_valmode));
        END;
    (*ENDCASE*) 
    t01int4 (debug, 'ldValpos    ', ld_valpos);
    t01int4 (debug, 'ldVallen    ', ld_vallen)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01ldb_longdescblock (
            debug     : tgg00_Debug;
            long_desc : tsp00_LongDescBlock);
 
BEGIN
WITH long_desc DO
    BEGIN
    t01surrogate (debug, 'ldbDescrptor', ldb_descriptor);
    t01int4      (debug, 'ldbCurPageno', ldb_curr_pageno);
    t01int4      (debug, 'ldbCurrPos  ', ldb_curr_pos);
    t01site      (debug, 'ldbServrdbNo', ldb_serverdb_no);
    t01int4      (debug, 'ldbRplicated', ord (ldb_replicated));
    IF  ldb_use_conversion IN ldb_change
    THEN
        t01int4 (debug,  'ldbUseConver', ord (ldb_use_conversion));
    (*ENDIF*) 
    t01int4 (debug,      'ldbInternPos', ldb_intern_pos);
    IF  (ldb_ex_trigger in ldb_infoset)
    THEN
        t01int4 (debug,  'ldbExTrigger', ord (ldb_ex_trigger));
    (*ENDIF*) 
    IF  (ldb_with_lock in ldb_infoset)
    THEN
        t01int4 (debug,  'ldbWithLock ', ord (ldb_with_lock));
    (*ENDIF*) 
    CASE ldb_valmode OF
        vm_datapart     :
            t01sname (debug, 'vmDataPart  ');
        vm_alldata      :
            t01sname (debug, 'vmAllData   ');
        vm_lastdata     :
            t01sname (debug, 'vmLastData  ');
        vm_nodata       :
            t01sname (debug, 'vmNoData    ');
        vm_no_more_data :
            t01sname (debug, 'vmNoMoreData');
        vm_last_putval :
            t01sname (debug, 'vmLastPutVal');
        vm_data_trunc :
            t01sname (debug, 'vmDataTrunc ');
        OTHERWISE
            t01int4  (debug, 'vm_otherwise', ord (ldb_valmode));
        END;
    (*ENDCASE*) 
    t01int4 (debug, 'ldbFullLen  ', ldb_full_len);
    t01int4 (debug, 'ldbValpos   ', ldb_valpos);
    t01int4 (debug, 'ldbVallen   ', ldb_vallen)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01mblock_header (
            debug             : tgg00_Debug;
            nam               : tsp00_Sname;
            VAR mbuf_header   : tgg00_MessBufHeader;
            trans_ptr         : tgg00_TransContextPtr);
 
VAR
      ln_len : integer;
      n      : tsp00_Name;
      ln     : tsp00_Line;
 
      univ_ptr : RECORD
            CASE integer OF
                1:
                    (bufaddr       : tsp00_BufAddr);
                2:
                    (rte_comm_ptr  : tsp00_RteCommAddr);
                3:
                    (bd_tcache_ptr : tgg00_TempDataCachePtr);
                4 :
                    (seq_info_ptr  : tgg00_CurrSeqInfoPtr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    WITH mbuf_header DO
        BEGIN
        t01init_line (ln, ln_len, nam);
        IF  trans_ptr <> NIL
        THEN
            BEGIN
            gg17SessionTransToLine (trans_ptr^.trSessionId_gg00, trans_ptr^.trTransId_gg00,
                  trans_ptr^.trWriteTransId_gg00, trans_ptr^.trSubtransId_gg00, ln_len, ln);
            ln_len := ln_len + 2;
            END;
        (*ENDIF*) 
        g17messtype_to_line (mb_type, ln_len, ln);
        IF  mb_type2 <> mm_nil
        THEN
            BEGIN
            ln_len := ln_len + 1;
            g17mess2type_to_line (mb_type2, ln_len, ln);
            END;
        (*ENDIF*) 
        ta01vtrace_write (ln, ln_len);
        CASE mb_struct OF
            mbs_nil:
                n := 'mbs_nil           ';
            mbs_buf:
                n := 'mbs_buf           ';
            mbs_double_buf:
                n := 'mbs_double_buf    ';
            mbs_save_restore:
                n := 'mbs_save_restore  ';
            mbs_link:
                n := 'mbs_link          ';
            mbs_lock:
                n := 'mbs_lock          ';
            mbs_result:
                n := 'mbs_result        ';
            mbs_stack_addr:
                n := 'mbs_stack_addr    ';
            mbs_stat_info:
                n := 'mbs_stat_info     ';
            mbs_col_stat_info:
                n := 'mbs_col_stat_info ';
            mbs_tree_id:
                n := 'mbs_tree_id       ';
            mbs_util:
                n := 'mbs_util          ';
            mbs_long:
                n := 'mbs_long          ';
            mbs_verify:
                n := 'mbs_verify        ';
            OTHERWISE:
                BEGIN
                n := bsp_name;
                t01int4 (debug, 'mb_struct   ', ord (mb_struct))
                END
            END;
        (*ENDCASE*) 
        IF  n <> bsp_name
        THEN
            t01name1  (debug, 'mb_struct   ', n);
        (*ENDIF*) 
        t01site       (debug, 'mb_src_site ', mb_src_site);
        t01bool       (debug, 'mb_reply    ', mb_reply);
        (* PTS 1103743 JA 1999-08-25 *)
        IF  trans_ptr <> NIL
        THEN
            BEGIN
            t01p2int4  (debug, 'trTaskId    ', trans_ptr^.trTaskId_gg00
                  ,            'trIndex     ', trans_ptr^.trIndex_gg00);
            t01int4    (debug, 'trBdExclLcks', trans_ptr^.trBdExclFileLocks_gg00);
            t01counter (debug, 'trRowLocks  ', trans_ptr^.trRowLocksPerSqlCmd_gg00);
            t01int4       (debug, 'trChild     ', trans_ptr^.trChild_gg00);
            ta01TransNo   (debug, 'trWriteTrId ', trans_ptr^.trWriteTransId_gg00);
            ta01TransNo   (debug, 'trCnsistView', trans_ptr^.trConsistView_gg00);
            t01localstate (debug, 'trState     ', trans_ptr^.trState_gg00);
            t01warningset (debug, 'trWarning   ', trans_ptr^.trWarning_gg00);
            t01int4       (debug, 'trSessAuxCnt', trans_ptr^.trSessionAuxCounter_gg00);
            t01int4       (debug, 'trTempCount ', trans_ptr^.trTempCount_gg00);
            t01counter    (debug, 'trIoCount   ', trans_ptr^.trIoCount_gg00);
            univ_ptr.rte_comm_ptr := trans_ptr^.trRteCommPtr_gg00;
            t01addr (debug, 'trRteCommPtr', univ_ptr.bufaddr);
            univ_ptr.bd_tcache_ptr := trans_ptr^.trBdTcachePtr_gg00;
            t01addr (debug, 'trBdTcachPtr', univ_ptr.bufaddr);
            univ_ptr.seq_info_ptr  := trans_ptr^.trSeqInfoPtr_gg00;
            t01addr       (debug, 'trSeqInfoPtr', univ_ptr.bufaddr);
            IF  trans_ptr^.trRteCommPtr_gg00 <> NIL
            THEN
                IF  trans_ptr^.trRteCommPtr_gg00^.to_cancel
                THEN
                    t01bool (debug, 'to_cancel   ',
                          trans_ptr^.trRteCommPtr_gg00^.to_cancel)
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        t01p2int4 (debug, 'mb_qual_len ', mb_qual_len
              ,           'mb_data_len ', mb_data_len);
        t01int4   (debug, 'mb_strat_len', mb_strat_len);
        IF  trans_ptr <> NIL
        THEN
            IF  trans_ptr^.trError_gg00 = e_ok
            THEN
                t01name1  (debug, 'trError     ', 'e_ok              ')
            ELSE
                t01basis_error (debug, '**** trError', trans_ptr^.trError_gg00)
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01messblock (
            debug         : tgg00_Debug;
            nam           : tsp00_Sname;
            VAR m         : tgg00_MessBlock);
 
VAR
      doTrace  : boolean;
      i        : integer;
      num      : tsp00_Int2;
      pos      : tsp00_Int2;
      len      : tsp00_Int2;
 
      univ_ptr : RECORD
            CASE integer OF
                1:
                    (bufaddr     : tsp00_BufAddr);
                2:
                    (data_ptr    : tgg00_DataPartPtr);
                3:
                    (qual_ptr    : tgg00_QualBufPtr);
                4:
                    (st_ptr      : tgg00_StackListPtr);
                5:
                    (moveobj_ptr : tsp00_MoveObjPtr);
                6:
                    (mblock_ptr  : tgg00_MessBlockPtr);
                7:
                    (trans_ptr   : tgg00_TransContextPtr)
                END;
            (*ENDCASE*) 
 
 
      _str            : RECORD
            CASE boolean OF
                true  :
                    (strat_char : tsp00_C1);
                false :
                    (strat_enum : tgg07_StratEnum);
                END;
            (*ENDCASE*) 
 
      move_err        : tgg00_BasisError;
      strat           : tgg07_StrategyInfo;
 
BEGIN
IF  m.mb_trns <> NIL
THEN
    doTrace := t01istrace (debug, m.mb_trns^.trSessionId_gg00)
ELSE
    doTrace := (debug = td_always) OR
          (td.debug_or_trace AND (debug in td.debugging));
(*ENDIF*) 
IF  doTrace
THEN
    WITH m DO
        BEGIN
        t01mblock_header (debug, nam, mb_header, mb_trns);
        t01p2int4 (debug, 'mb_data_size', mb_data_size
              ,           'mb_st_size  ', mb_st_size);
        t01p2int4 (debug, 'mb_qual_size', mb_qual_size
              ,           'mb_st_max   ', mb_st_max);
        t01p2int4 (debug, 'mb_work_st_m', mb_work_st_max
              ,           'mb_workbuf_s', mb_workbuf_size);
        t01int4   (debug, 'mb_strat_siz', mb_strat_size);
        univ_ptr.data_ptr := mb_data;
        t01addr   (debug, 'mb_data     ', univ_ptr.bufaddr);
        FOR i := 0 TO cgg_valuelistoffset - 1 DO
            BEGIN
            univ_ptr.moveobj_ptr := mb_fieldlists[i];
            CASE i OF
                cgg_idx_literal_valuefieldlist     :
                    t01addr   (debug, 'literalflist', univ_ptr.bufaddr);
                cgg_idx_param_valuefieldlist       :
                    t01addr   (debug, 'params_flist', univ_ptr.bufaddr);
                cgg_idx_pars_result_valuefieldlist :
                    t01addr   (debug, 'presultflist', univ_ptr.bufaddr);
                cgg_idx_ex_result_valuefieldlist   :
                    t01addr   (debug, 'eresultflist', univ_ptr.bufaddr);
                OTHERWISE
                    t01addr   (debug, 'mb_fieldlist', univ_ptr.bufaddr);
                END
            (*ENDCASE*) 
            END;
        (*ENDFOR*) 
        univ_ptr.qual_ptr := mb_qual;
        t01addr   (debug, 'mb_qual     ', univ_ptr.bufaddr);
        univ_ptr.moveobj_ptr := mb_strat;
        t01addr   (debug, 'mb_strat    ', univ_ptr.bufaddr);
        univ_ptr.st_ptr := mb_st;
        t01addr   (debug, 'mb_st       ', univ_ptr.bufaddr);
        univ_ptr.st_ptr := mb_work_st;
        t01addr   (debug, 'mb_work_st  ', univ_ptr.bufaddr);
        univ_ptr.moveobj_ptr := mb_workbuf;
        t01addr   (debug, 'mb_workbuf  ', univ_ptr.bufaddr);
        univ_ptr.mblock_ptr := mb_next_mblock;
        t01addr   (debug, 'mb_next_mblo', univ_ptr.bufaddr);
        univ_ptr.trans_ptr := mb_trns;
        t01addr   (debug, 'mb_trns     ', univ_ptr.bufaddr);
        (* *)
        IF  (mb_qual    <> NIL) AND
            (mb_qual_len > 0  )
        THEN
            CASE mb_struct OF
                mbs_nil, mbs_buf, mbs_link, mbs_result, mbs_stat_info,
                mbs_col_stat_info, mbs_double_buf:
                    BEGIN
                    IF  mb_struct = mbs_nil
                    THEN
                        t01sname (debug, '*** mbs_nil ');
                    (*ENDIF*) 
                    ta01obj_display ('MB_QUAL     ', @mb_qual^,
                          mb_qual_size, 1, mb_qual_len,
                          NOT DOUBLE_NUMBERING, 1)
                    END;
                mbs_save_restore:
                    ta01user_hm (debug, mb_qual^);
                mbs_lock:
                    BEGIN
                    t01int4 (debug, 'lock count  ', mb_qual^.mlock_cnt);
                    i := 1;
                    WHILE (i <= mb_qual^.mlock_cnt) AND
                          (i <= MAX_QUALBUF_LOCKS_GG00) DO
                        BEGIN
                        t01int4(debug,'lock index  ',i);
                        t01lock(debug,'lock        ',mb_qual^.mlock[i]);
                        i := i + 1
                        END
                    (*ENDWHILE*) 
                    END;
                mbs_long:
                    BEGIN
                    t01treeid (debug,'treeid      ',mb_qual^.mtree);
                    t01stackdesc (debug,'STACK DESC  ',
                          mb_st, mb_qual^.mstack_desc);
                    t01long_qual (debug,'long qual   ',
                          mb_qual^.ml_long_qual);
                    END;
                mbs_stack_addr:
                    BEGIN
                    t01treeid (debug, 'treeid      ', mb_qual^.mtree);
                    t01stackdesc (debug, 'STACK DESC  ',
                          mb_st, mb_qual^.mstack_desc);
                    IF  mb_qual_len > MB_PART1_HEAD_MXGG00
                    THEN
                        BEGIN
                        IF  (mb_type  = m_create_index) AND
                            (mb_type2 = mm_participant)
                        THEN
                            t01treeid (debug, 'invtreeid   ',
                                  mb_qual^.mlinktree)
                        ELSE
                            BEGIN
                            t01buf (debug, mb_qual^.buf,
                                  MB_PART1_HEAD_MXGG00 + 1, mb_qual_len);
                            IF  mb_type = m_fetch
                            THEN
                                IF  mb_qual^.mf_desc.m_data <> NIL
                                THEN
                                    BEGIN
                                    univ_ptr.data_ptr := mb_qual^.mf_desc.m_data;
                                    t01buf (debug, univ_ptr.bufaddr^,
                                          1, 20);
                                    END
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                mbs_tree_id:
                    BEGIN
                    t01treeid (debug, 'treeid      ', mb_qual^.mtree);
                    IF  mb_qual_len > sizeof (mb_qual^.mtree)
                    THEN
                        ta01obj_display ('MB_QUAL     ', @mb_qual^,
                              mb_qual_size, 1, mb_qual_len,
                              NOT DOUBLE_NUMBERING, 1)
                    (*ENDIF*) 
                    END;
                mbs_util:
                    ta01util_mut_part1 (debug, mb_qual^);
                mbs_verify:
                    BEGIN
                    t01treeid (debug, 'treeid      ', mb_qual^.mv_tree);
                    t01p2int4    (debug, 'longcount   ', mb_qual^.mv_longcnt
                          ,              'newlongcount', mb_qual^.mv_newlongcnt);
                    t01bool (debug, 'extended    ', mb_qual^.mv_extended);
                    END;
                OTHERWISE;
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        IF  (mb_data    <> NIL) AND
            (mb_data_len > 0  )
        THEN
            BEGIN
            IF  (mb_type = m_change) AND (mb_type2 = mm_key)
            THEN
                ta01part2_change_key (debug, mb_data^.mbp_rec)
            ELSE
                BEGIN
                IF  mb_struct = mbs_nil
                THEN
                    t01sname (debug, '*** mbs_nil ');
                (*ENDIF*) 
                ta01obj_display ('MB_DATA     ', @mb_data^,
                      mb_data_size, 1, mb_data_len,
                      NOT DOUBLE_NUMBERING, 1)
                END;
            (*ENDIF*) 
            IF  (m.mb_qual <> NIL                ) AND
                (m.mb_struct = mbs_stack_addr    ) AND
                (m.mb_qual^.mst_optimize_pos > 0 )
            THEN
                BEGIN
                t01optimize_info( debug, m.mb_qual^.mstack_desc, @m.mb_data^.mbp_buf );
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (mb_strat <> NIL) AND
            (mb_strat_len > 0)
        THEN
            BEGIN
            ta01obj_display ('MB_STRAT    ', @mb_strat^,
                  mb_strat_size, 1, mb_strat_len,
                  NOT DOUBLE_NUMBERING, 1)
            END;
        (*ENDIF*) 
        IF  (mb_struct in [ mbs_long, mbs_stack_addr ]) AND
            (mb_qual <> NIL )                           AND
            (mb_qual^.mstack_desc.mtrigger_cnt > 0)     AND
            (m.mb_st <> NIL)
        THEN
            WITH mb_qual^.mtrigger_info DO
                BEGIN
                t01treeid (debug, 'triggertree ', tiqb_tree_id);
                t01int4   (debug, 'trigger_cnt ', tiqb_trigger_count);
                FOR i := 1 TO tiqb_trigger_count DO
                    WITH tiqb_trigger_info[i] DO
                        BEGIN
                        t01messtype (debug, 'tg_messType ', tg_messType);
                        t01int4 (debug, 'param_pos   ', tg_param_pos);
                        t01int4 (debug, 'param_cnt   ', tg_param_cnt);
                        t01int4 (debug, 'qual_pos    ', tg_qual_pos);
                        t01int4 (debug, 'qual_cnt    ', tg_qual_cnt);
                        t01int4 (debug, 'upd_set_size', tg_updated_set_size);
                        END;
                    (*ENDWITH*) 
                (*ENDFOR*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  (mb_struct in [ mbs_long, mbs_stack_addr ]) AND
            (mb_qual <> NIL )                           AND
            (mb_qual^.mstack_desc.mstrat_pos > 0)       AND
            (m.mb_st <> NIL)
        THEN
            IF  (m.mb_st^[ mb_qual^.mstack_desc.mstrat_pos ].epos > 0) AND
                (m.mb_st^[ mb_qual^.mstack_desc.mstrat_pos ].epos +
                m.mb_st^[ mb_qual^.mstack_desc.mstrat_pos ].elen_var - 1 <= m.mb_strat_len ) AND
                (m.mb_strat <> NIL )
            THEN
                BEGIN
                move_err := e_ok;
                i := m.mb_st^[ mb_qual^.mstack_desc.mstrat_pos ].elen_var;
                IF  ( i > sizeof(strat) )
                THEN
                    (* strat_more_than_one *)
                    i := sizeof(strat);
                (*ENDIF*) 
                SAPDB_PascalMove ('VTA01 ',   5,    
                      m.mb_strat_size, sizeof (strat),
                      @m.mb_strat^,
                      m.mb_st^[ mb_qual^.mstack_desc.mstrat_pos ].epos,
                      @strat, 1, i, move_err);
                IF  move_err = e_ok
                THEN
                    a725gg_strategy( debug, strat );
                (*ENDIF*) 
                IF  ( strat.str_strategy = strat_more_than_one )
                THEN
                    BEGIN
                    num := 1;
                    pos := m.mb_st^[ m.mb_qual^.mstrat_pos ].epos +
                          STRATEGY_START_MXGG07;
                    WHILE ( num <= strat.str_cnt_strat ) DO
                        BEGIN
                        _str.strat_char[ 1 ] := m.mb_strat^[ pos ];
                        len := s20buf_to_int4_1( m.mb_strat^, pos + 4 );
                        (* get strategy *)
                        SAPDB_PascalForcedMove ( m.mb_strat_size, sizeof( strat ),
                              @m.mb_strat^,
                              pos + cgg07_stratpos_offs,
                              @strat, STRATEGY_START_MXGG07 + 1,
                              len);
                        strat.str_strategy := _str.strat_enum;
                        a725gg_strategy( debug, strat );
                        num := succ(num);
                        pos := pos + len + cgg07_stratpos_offs;
                        END;
                    (*ENDWHILE*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01messmaxstack (
            debug     : tgg00_Debug;
            nam       : tsp00_Sname;
            mess_type : tgg00_MessType;
            int4      : tsp00_Int4);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    g17messtype_to_line (mess_type, ln_len, ln);
    g17int4to_line (int4, false, 8, 37, ln);
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01messtype (
            debug        : tgg00_Debug;
            nam          : tsp00_Sname;
            mess_type    : tgg00_MessType);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    g17messtype_to_line (mess_type, ln_len, ln);
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01mess2type (
            debug         : tgg00_Debug;
            nam           : tsp00_Sname;
            mess2_type    : tgg00_MessType2);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    g17mess2type_to_line (mess2_type, ln_len, ln);
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01minbuf (min_wanted : boolean);
 
BEGIN
td.minbuf := min_wanted
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01moveobj (
            debug       : tgg00_Debug;
            VAR moveobj : tsp00_MoveObj;
            startpos    : tsp00_Int4;
            endpos      : tsp00_Int4);
      (******** hta01.h ********)
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    ta01obj_display ('MOVEOBJ     ', @moveobj, sizeof (moveobj),
          startpos, endpos, NOT DOUBLE_NUMBERING, startpos)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01msgcheck (
            msg             : tsp00_C30;
            check_condition : boolean;
            bad_int         : tsp00_Int4);
 
VAR
      move_err : tgg00_BasisError;
      opmsg    : tsp00_C24;
 
BEGIN
IF  NOT check_condition
THEN
    BEGIN
    move_err := e_ok;
    SAPDB_PascalMove ('VTA01 ',   6,    
          sizeof (msg), sizeof (opmsg),
          @msg, 1, @opmsg, 1, sizeof (opmsg), move_err);
    g01opmsg (sp3p_console, sp3m_error, csp3_msg, csp3_n_check,
          opmsg, bad_int);
    gg999Abort (WRITE_CORE)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01multiswitch (VAR s20 : tsp00_C20; VAR s201 : tsp00_C20);
 
BEGIN
td.on_text  := bsp_c16;
td.off_text := bsp_c16;
td.on_count := 0;
ta01trace_set (s20);
ta01test_set  (s201);
t01set_bool_debug_or_trace
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01disable_debug_or_trace;
 
BEGIN
td.debug_or_trace := false;
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01mxerrmsg (
            nam        : tsp00_Name;
            int_wrong  : tsp00_Int4;
            int_ok     : tsp00_Int4);
 
VAR
      move_err : tgg00_BasisError;
      opmsg    : tsp00_C24;
 
BEGIN
opmsg    := bsp_c24;
move_err := e_ok;
SAPDB_PascalMove ('VTA01 ',   7,    
      sizeof (nam), sizeof (opmsg),
      @nam, 1, @opmsg, 1, sizeof (nam), move_err);
g01opmsg (sp3p_console, sp3m_error, csp3_msg, csp3_n_check,
      opmsg, int_wrong);
g01opmsg (sp3p_console, sp3m_error, csp3_msg, csp3_n_check,
      '   sizeof (...)         ', int_ok)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01name (debug : tgg00_Debug; nam : tsp00_Name);
      (******** hta01.h ********)
 
VAR
      i  : integer;
      ln : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln := td.blankline;
    i := 1;
    WHILE i <= sizeof (nam) DO
        BEGIN
        IF  g17printable_char (nam [i])
        THEN
            ln [i] := nam [i]
        ELSE
            ln [i] := '.';
        (*ENDIF*) 
        i := succ(i)
        END;
    (*ENDWHILE*) 
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01name1 (
            debug     : tgg00_Debug;
            nam       : tsp00_Sname;
            n         : tsp00_Name);
      (******** hta01.h ********)
 
VAR
      i      : integer;
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    i := 1;
    WHILE i <= sizeof (n) DO
        BEGIN
        IF  g17printable_char (n [i])
        THEN
            ln [ln_len + i] := n [i]
        ELSE
            ln [ln_len + i] := '.';
        (*ENDIF*) 
        i := succ(i)
        END;
    (*ENDWHILE*) 
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01Oid (
            debug    : tgg00_Debug;
            nam      : tsp00_Sname;
            VAR oid  : tgg00_OidSpace);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    gg06OidToLine (oid, ln_len, ln);
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01op (
            debug  : tgg00_Debug;
            nam    : tsp00_Sname;
            op     : tgg00_StackOpType);
 
VAR
      move_err : tgg00_BasisError;
      len      : integer;
      ln_len   : integer;
      n        : tsp00_Sname;
      ln       : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    g17st1op (op, len, n);
    move_err := e_ok;
    SAPDB_PascalMove ('VTA01 ',   8,    
          sizeof (n), sizeof (ln),
          @n, 1, @ln, ln_len + 2, len, move_err);
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01opmsg (
            debug : tgg00_Debug;
            nam : tsp00_Sname;
            msg : tsp00_Opmsg);
 
VAR
      i      : integer;
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    i := 1;
    WHILE i <= sizeof (msg) DO
        BEGIN
        IF  g17printable_char (msg [i])
        THEN
            ln [ln_len + i] := msg [i]
        ELSE
            ln [ln_len + i] := '.';
        (*ENDIF*) 
        i := succ(i)
        END;
    (*ENDWHILE*) 
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01packet (
            debug      : tgg00_Debug;
            nam        : tsp00_Sname;
            packet_ptr : tsp1_packet_ptr);
 
VAR
      ln_len   : integer;
      segm_no  : integer;
      segm_ptr : tsp1_segment_ptr;
      ln       : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    g17packet_head (nam, packet_ptr^.sp1_header, ln_len, ln);
    ta01vtrace_write (ln, ln_len);
    segm_ptr := @packet_ptr^.sp1_segm;
    segm_no := 1;
    WHILE segm_no <= packet_ptr^.sp1_header.sp1h_no_of_segm DO
        BEGIN
        IF  segm_no > 1
        THEN
            s26next_segment (segm_ptr);
        (*ENDIF*) 
        t01segment (debug, segm_ptr^);
        segm_no := succ(segm_no)
        END
    (*ENDWHILE*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01packet_part (
            debug           : tgg00_Debug;
            VAR packet_part : tsp1_part);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
      pi_ptr : ^tsp1_param_info;
      i      : integer;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    WITH packet_part DO
        BEGIN
        g17parthead (sp1p_part_header, ln_len, ln);
        ta01vtrace_write (ln, ln_len);
        IF  sp1p_buf_len > 0
        THEN
            IF  (sp1p_part_kind = sp1pk_shortinfo) OR
                (sp1p_part_kind = sp1pk_output_cols_no_parameter)
            THEN
                BEGIN
                i := 1;
                WHILE i <= sp1p_arg_count DO
                    BEGIN
                    ln := td.blankline;
                    g17int4to_line (i, false, 3, PACKET_INDENT, ln);
                    ln[ PACKET_INDENT+3 ] := '.';
                    ln_len := PACKET_INDENT+5;
                    pi_ptr := @sp1p_buf[1 + (i-1)*sizeof(tsp1_param_info)];
                    g17paraminfo_to_line (pi_ptr^, ln_len, ln);
                    ta01vtrace_write (ln, ln_len);
                    i := succ(i);
                    END;
                (*ENDWHILE*) 
                END
            ELSE
                ta01obj_display ('partbuf     ', @sp1p_buf, sp1p_buf_size,
                      1, sp1p_buf_len, NOT DOUBLE_NUMBERING, 1)
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01page (
            debug    : tgg00_Debug;
            VAR buf  : tsp00_Page;
            startpos : tsp00_Int4;
            endpos   : tsp00_Int4);
      (******** hta01.h ********)
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    ta01obj_display ('PAGE        ', @buf, sizeof (buf),
          startpos, endpos, NOT DOUBLE_NUMBERING, startpos)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01page_ref (
            debug         : tgg00_Debug;
            nam           : tsp00_Sname;
            VAR PageRef   : tgg91_PageRef);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    g17page_ref_to_line (PageRef, ln_len, ln);
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01page_type (
            debug     : tgg00_Debug;
            nam       : tsp00_Sname;
            pagetype  : tgg00_PageType;
            pagetype2 : tgg00_PageType2);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    g17pagetype_to_line (pagetype, ln_len, ln);
    IF  pagetype2 <> pt2Nil_egg00
    THEN
        BEGIN
        ln_len      := succ (ln_len);
        ln [ln_len] := '/'
        END;
    (*ENDIF*) 
    g17pagetype2_to_line (pagetype2, ln_len, ln);
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01p2int4 (
            debug : tgg00_Debug;
            nam_1 : tsp00_Sname;
            int_1 : tsp00_Int4;
            nam_2 : tsp00_Sname;
            int_2 : tsp00_Int4);
      (******** hta01.h ********)
 
VAR
      ln : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln := td.blankline;
    ta01sname_int4_to_line (nam_1, 13, int_1, 11, 1, ln);
    ta01sname_int4_to_line (nam_2, 13, int_2, 11, SECOND_COLUMN_POS, ln);
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01p4int4 (
            debug : tgg00_Debug;
            nam   : tsp00_Sname;
            int_1 : tsp00_Int4;
            int_2 : tsp00_Int4;
            int_3 : tsp00_Int4;
            int_4 : tsp00_Int4);
      (******** hta01.h ********)
 
VAR
      ln : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln := td.blankline;
    ta01sname_int4_to_line (nam, 13, int_1, 11,  1, ln);
    g17int4to_line (int_2, false, 11, 29, ln);
    g17int4to_line (int_3, false, 11, 42, ln);
    g17int4to_line (int_4, false, 11, 55, ln);
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01stqual (
            debug      : tgg00_Debug;
            VAR qual   : tgg00_QualBuf;
            stack_addr : tgg00_StackListPtr);
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01treeid (debug, 'treeid      ', qual.mtree);
    t01stackdesc (debug, 'STACK DESC  ', stack_addr, qual.mstack_desc)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01qual (debug : tgg00_Debug; VAR part1 : tgg00_QualBuf);
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01treeid (debug, 'treeid      ', part1.mtree);
    t01stdesc (debug, 'STACK DESC  ', part1.mstack_desc)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01qual1 (
            debug     : tgg00_Debug;
            nam       : tsp00_Sname;
            VAR part1 : tgg00_QualBuf);
 
VAR
      _ln     : tsp00_Line;
      _lnln   : integer;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    _lnln   := 0;
    _ln     := td.blankline;
    g17sname_to_line (nam, _lnln, _ln);
    _ln[ sizeof(tsp00_Name) + 1] := ':';
    t01line( debug, _ln );
    t01stdesc (debug, 'STACK DESC  ', part1.mstack_desc)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01real (
            debug    : tgg00_Debug;
            nam      : tsp00_Sname;
            re       : tsp00_Longreal;
            digits   : integer);
 
VAR
      pos          : integer;  (* index to line                     *)
      exp          : integer;  (* represents exponent of r          *)
      valid_digits : integer;  (* initial digits of r as an integer *)
      i            : integer;
      r            : tsp00_Longreal;
      ln           : tsp00_Line; (* buffer to build up display-line   *)
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    r := re;
    t01init_line (ln, pos, nam);
    pos := pos + 1;
    IF  r = 0
    THEN
        ln [pos] := '0'
    ELSE
        BEGIN
        IF  r < 0
        THEN
            BEGIN
            ln [pos] := '-';
            r        := -r
            END;
        (*ENDIF*) 
        ln [pos+1] := '0';
        ln [pos+2] := '.';
        pos        := pos + 3;
        exp        := 0; (* represents exponent of real number *)
        WHILE r >= 1 DO
            BEGIN
            r   := r / 10;
            exp := exp + 1
            END;
        (*ENDWHILE*) 
        WHILE r < 0.1 DO
            BEGIN
            r   := r * 10;
            exp := exp - 1;
            END;
        (*ENDWHILE*) 
        (* at this point exp is the exponent and r the *)
        (* fraction with 0.1 <= r < 1                  *)
        i := 1;
        WHILE i <= digits DO
            BEGIN
            r := r * 10;
            i := succ(i)
            END;
        (*ENDWHILE*) 
        (* exponent function not available with all Pascal-Compilers *)
        valid_digits := trunc (r); (* reduce to demanded acuracy *)
        g17int4to_line (valid_digits, true, digits, pos, ln);
        (*WITH_ZERO: necessary as truncation yields 0.0999... from 0.1*)
        pos      := pos + digits;
        ln [pos] := 'E';
        IF  exp < 0
        THEN
            BEGIN
            ln [pos+1] := '-';
            exp        := -exp
            END
        ELSE
            ln [pos+1] := '+';
        (*ENDIF*) 
        pos := pos + 2;
        g17int4to_line (exp, true, 2, pos, ln); (*display exponent *)
        END;
    (*ENDIF*) 
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01segment (
            debug       : tgg00_Debug;
            VAR segm    : tsp1_segment);
 
VAR
      curr_warn : tsp00_Warnings;
      curriwarn : tsp1_intern_warning;
      ln1_len   : integer;
      ln2_len   : integer;
      ln3_len   : integer;
      part_no   : integer;
      part_ptr  : tsp1_part_ptr;
      ln1       : tsp00_Line;
      ln2       : tsp00_Line;
      ln3       : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    IF  segm.sp1s_segm_kind = sp1sk_cmd
    THEN
        BEGIN
        g17cmdsegm_head (segm.sp1s_segm_header,
              ln1_len, ln1, ln2_len, ln2, ln3_len, ln3);
        ta01vtrace_write (ln1, ln1_len);
        ta01vtrace_write (ln2, ln2_len);
        IF  ln3_len > 0
        THEN
            ta01vtrace_write (ln3, ln3_len)
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        g17returnsegm_head (segm.sp1s_segm_header,
              ln1_len, ln1, ln2_len, ln2);
        ta01vtrace_write (ln1, ln1_len);
        IF  ln2_len > 0
        THEN
            ta01vtrace_write (ln2, ln2_len);
        (*ENDIF*) 
        IF  segm.sp1r_extern_warning <> [ ]
        THEN
            BEGIN
            curr_warn := warn0_exist;
            WHILE curr_warn <= warn15_user_defined_code DO
                BEGIN
                IF  curr_warn in segm.sp1r_extern_warning
                THEN
                    BEGIN
                    ln1     := td.blankline;
                    ln1_len := PACKET_INDENT;
                    g17sname_to_line ('external    ', ln1_len, ln1);
                    ln1_len := ln1_len + 1;
                    g17warning_item_to_line (curr_warn, ln1_len, ln1);
                    ta01vtrace_write (ln1, ln1_len)
                    END;
                (*ENDIF*) 
                curr_warn := succ(curr_warn)
                END
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        IF  segm.sp1r_intern_warning <> [ ]
        THEN
            BEGIN
            curriwarn := sp1iw_warn0_resultset_closed;
            WHILE curriwarn <= sp1iw_warn15 DO
                BEGIN
                IF  curriwarn in segm.sp1r_intern_warning
                THEN
                    BEGIN
                    ln1     := td.blankline;
                    ln1_len := PACKET_INDENT;
                    g17sname_to_line ('internal    ', ln1_len, ln1);
                    ln1_len := ln1_len + 1;
                    g17intern_warning_item_to_line (curriwarn, ln1_len, ln1);
                    ta01vtrace_write (ln1, ln1_len)
                    END;
                (*ENDIF*) 
                curriwarn := succ(curriwarn)
                END
            (*ENDWHILE*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    part_ptr := @segm.sp1p_part;
    part_no := 1;
    WHILE (part_no <= segm.sp1s_no_of_parts) AND
          (part_ptr <> NIL) DO
        BEGIN
        IF  part_no > 1
        THEN
            s26nextpart (part_ptr);
        (*ENDIF*) 
        IF  part_ptr <> NIL
        THEN
            t01packet_part (debug, part_ptr^);
        (*ENDIF*) 
        part_no := succ(part_no)
        END
    (*ENDWHILE*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01separator (
            debug         : tgg00_Debug;
            nam           : tsp00_Sname;
            separator     : tgg00_RecPtr);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    g17sname_to_line ('sepLen:     ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (separator^.recLen_gg00, ln_len, ln);
    g17sname_to_line (';  root:    ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (s20buf_to_int4 (separator^.recBody_gg00, separator^.recKeyLen_gg00+1),
          ln_len, ln);
    t01write_line (ln);
    t01key (debug, nam, separator^.recKey_gg00)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01Session (
            debug        : tgg00_Debug;
            nam          : tsp00_Sname;
            VAR session  : tgg91_SessionNo);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    gg06SessionToLine (session, ln_len, ln);
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01SessionTrans (
            debug             : tgg00_Debug;
            nam               : tsp00_Sname;
            VAR session       : tgg91_SessionNo;
            VAR trans         : tgg91_TransNo;
            VAR write_trans   : tgg91_TransNo;
            VAR subtrans      : tgg00_SubtransNo);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    gg17SessionTransToLine (session, trans, write_trans, subtrans, ln_len, ln);
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01setmaxbuflength (max_len : tsp00_Int4);
 
BEGIN
IF  (max_len > 0) AND (max_len <= sizeof(tsp00_MoveObj))
THEN
    td.maxlength := max_len
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01SetSingleUser;
 
BEGIN
ta01SingleUser  := true;
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01sinit;
 
VAR
      ok  : boolean;
      i   : integer;
      c20 : tsp00_C20;
 
BEGIN
vsinit;
td.minbuf         := false;
td.use_stacksize  := false;
&ifdef STACKCHK
td.use_stacksize  := true;
&endif
td.maxlength      := sizeof (tsp00_MoveObj);
td.debugging      := [ ];
i := 1;
WHILE i <= sizeof(td.blankline) DO
    BEGIN
    td.blankline[ i ] := ' ';
    i := succ(i)
    END;
(*ENDWHILE*) 
td.on_text  := bsp_c16;
td.off_text := bsp_c16;
td.on_count := 0;
c20         := bsp_c20;
ta01trace_set (c20);
td.last_layer := 'T';
c20           := bsp_c20;
ta01test_set (c20);
t01set_bool_debug_or_trace;
ta01SwitchLevel := 0;
ta01SingleUser  := false;
(* PTS 1110953 E.Z. *)
ok := true;
b06check_mxbd  (ok);
g01check_mxgg  (ok);
a04check_mxak (ok);
IF  NOT ok
THEN
    vabort (NOT WRITE_CORE)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01site (
            debug    : tgg00_Debug;
            nam      : tsp00_Sname;
            site     : tgg00_ServerdbNo);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    g17siteto_line (site, ln_len, ln);
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01sname (debug : tgg00_Debug; nam : tsp00_Sname);
      (******** hta01.h ********)
 
VAR
      i  : integer;
      ln : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln := td.blankline;
    i := 1;
    WHILE i <= sizeof (nam) DO
        BEGIN
        IF  g17printable_char (nam [i])
        THEN
            ln [i] := nam [i]
        ELSE
            ln [i] := '.';
        (*ENDIF*) 
        i := succ(i)
        END;
    (*ENDWHILE*) 
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01stackentry (
            debug          : tgg00_Debug;
            VAR st         : tgg00_StackEntry;
            entry_index    : integer);
 
VAR
      is_second_ln : boolean;
      ln           : tsp00_Line;
      second_ln    : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    g17onestackentry (st, entry_index, ln, is_second_ln, second_ln);
    t01write_line (ln);
    IF  is_second_ln
    THEN
        t01write_line (second_ln)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01statistics (
            debug : tgg00_Debug;
            nam : tsp00_Sname;
            VAR info : tgg00_SampleInfo);
 
VAR
      ln_len, stat_index : integer;
      ln : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln     := td.blankline;
    ln_len := 0;
    g17sname_to_line ('---         ', ln_len, ln);
    ln_len := ln_len + 1;
    g17sname_to_line (nam, ln_len, ln);
    g17sname_to_line (' ---        ', ln_len, ln);
    ta01vtrace_write (ln, ln_len);
    ln     := td.blankline;
    ln_len := 0;
    g17sname_to_line ('SampleInfo  ', ln_len, ln);
    ta01vtrace_write (ln, ln_len);
    (* leafnodes is read by *)
    (* ak28upd_column_list *)
    (* ak28value_cnt *)
    (* a28single_index_stat *)
    (* a28table_upd_statistics *)
    (* ak42print_tab_index *)
    (* sec_key_cnt is read by *)
    (* a28single_index_stat *)
    (* ak42print_tab_index *)
    t01p2int4  (debug,'leafnodes   ', info.leafnodes
          ,           'sec_key_cnt ', info.sec_key_cnt);
    (* prim_key_cnt is read by *)
    (* a28single_index_stat *)
    (* ak42print_tab_index *)
    (* avg_prim_per_list is read by *)
    (* a28single_index_stat *)
    (* ak42print_tab_index *)
    t01p2int4  (debug,'prim_key_cnt', info.prim_key_cnt
          ,           'avg_prim_per', info.avg_prim_per_list);
    (* records is read by *)
    (* ak28upd_column_list *)
    (* ak28value_cnt *)
    (* a28table_upd_statistics *)
    (* ak42print_tab_index *)
    t01int4    (debug,'records(pri)', info.records);
    stat_index := 0;
    (* dist_values are read by ak28cnt_values *)
    (* dist_values[1] is read by ak42column_statistics *)
    REPEAT
        stat_index := succ (stat_index);
        IF  info.dist_values [stat_index] > 0
        THEN
            t01int4 (debug, 'dist_values '
                  ,     info.dist_values [stat_index])
        ELSE
            stat_index := MAX_COL_PER_TAB_GG00
        (*ENDIF*) 
    UNTIL
        stat_index >= MAX_COL_PER_TAB_GG00;
    (*ENDREPEAT*) 
    (* all_stringcol_pages is read by a42_get_pagecount *)
    (* nodes is read by a42_get_pagecount *)
    (*                  a42table_statistics *)
    (*                  ak42print_tab_index *)
    t01p2int4  (debug,'all_stringco', info.all_stringcol_pages
          ,           'nodes       ', info.nodes);
    (* null_value_cnt is read by ak42column_statistics *)
    (* min_sec_key_len is read by ak42column_statistics *)
    (*                            ak42print_tab_index *)
    t01p2int4  (debug,'null_value_c', info.null_value_cnt
          ,           'min_sec_key_', info.min_sec_key_len);
    (* max_sec_key_len is read by ak42column_statistics *)
    (*                            ak42print_tab_index *)
    (* avg_sec_key_len is read by ak42column_statistics *)
    (*                            ak42print_tab_index *)
    t01p2int4  (debug,'max_sec_key_', info.max_sec_key_len
          ,           'avg_sec_key_', info.avg_sec_key_len);
    ln     := td.blankline;
    ln_len := 0;
    g17nameto_line   ('for ak42print only', ln_len, ln);
    ta01vtrace_write (ln, ln_len);
    (* the following fields are for ak42print_tab_index only *)
    t01p2int4  (debug,'treecov     ', info.treecov
          ,           'rootcov     ', info.rootcov);
    t01p2int4  (debug,'indexcov    ', info.indexcov
          ,           'min_indexcov', info.min_indexcov);
    t01p2int4  (debug,'max_indexcov', info.max_indexcov
          ,           'leafcov     ', info.leafcov);
    t01p2int4  (debug,'min_leafcov ', info.min_leafcov
          ,           'max_leafcov ', info.max_leafcov);
    t01p2int4  (debug,'rec_per_page', info.rec_per_page
          ,           'ave_rec_lent', info.ave_rec_length);
    t01p2int4  (debug,'min_rec_lent', info.min_rec_length
          ,           'max_rec_lent', info.max_rec_length);
    t01p2int4  (debug,'ave_key_leng', info.ave_key_length
          ,           'indexnodes  ', info.indexnodes);
    t01p2int4  (debug,'ave_sep_lent', info.ave_sep_length
          ,           'min_key_lent', info.min_key_length);
    t01p2int4  (debug,'max_key_lent', info.max_key_length
          ,           'min_sep_lent', info.min_sep_length);
    t01p2int4  (debug,'max_sep_lent', info.max_sep_length
          ,           'min_rec_per_', info.min_rec_per_page);
    t01p2int4  (debug,'max_rec_per_', info.max_rec_per_page
          ,           'hight       ', info.hight);
    t01filetype(debug,'filet       ', info.smplFileType_gg00);
    t01int4    (debug,'defined_stri', info.defined_stringcols);
    t01p2int4  (debug,'min_len_stri', info.min_len_stringcol
          ,           'max_len_stri', info.max_len_stringcol);
    t01p2int4  (debug,'ave_len_stri', info.ave_len_stringcol
          ,           'min_stringco', info.min_stringcol_pages);
    t01p2int4  (debug,'max_stringco', info.max_stringcol_pages
          ,           'ave_stringco', info.ave_stringcol_pages);
    t01p2int4  (debug,'invsel_1    ', info.invsel_1
          ,           'invsel_5    ', info.invsel_5);
    t01p2int4  (debug,'invsel_10   ', info.invsel_10
          ,           'invsel_25   ', info.invsel_25);
    t01p2int4  (debug,'invsel_notse', info.invsel_notsel
          ,           'min_prim_per', info.min_prim_per_list);
    t01p2int4  (debug,'max_prim_per', info.max_prim_per_list
          ,           'rootsegm    ', info.rootsegm);
    (* reclen_oflw    for intern use only in vbd72 *)
    (* strcollen_oflw for intern use only in vbd72 *)
    (* separators       is not used at all *)
    (* splitted_records is not used at all *)
    (* fname            is not used at all *)
    (* distinct_values  is not used at all *)
    (* invsel_oflw      is not used at all *)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01stdesc (
            debug          : tgg00_Debug;
            nam            : tsp00_Sname;
            VAR stack_desc : tgg00_StackDesc);
 
BEGIN
t01stackdesc (debug, nam, stack_desc.mst_addr, stack_desc);
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01stackdesc (
            debug          : tgg00_Debug;
            nam            : tsp00_Sname;
            stack_addr     : tgg00_StackListPtr;
            VAR stack_desc : tgg00_StackDesc);
 
CONST
      c_int2_cnt = 20;
 
VAR
      is_second_ln  : boolean;
      values_found  : boolean;
      i2            : tsp00_IntMapC2;
      i             : integer;
      ln_len        : integer;
      highest_stack : integer;
      stackptr      : integer;
      st_start      : integer;
      st_stop       : integer;
      ln            : tsp00_Line;
      second_ln     : tsp00_Line;
 
      univ_ptr : RECORD
            CASE integer OF
                2:
                    (s          : tgg00_StEntryAddr);
                3:
                    (bufaddr    : tsp00_BufAddr);
                4:
                    (stack_addr : tgg00_StackListPtr)
                END;
            (*ENDCASE*) 
 
 
      univ_stack_desc : RECORD
            CASE integer OF
                1:
                    (st_desc : tgg00_StackDesc);
                2:
                    (int2_arr: PACKED ARRAY [1..c_int2_cnt] OF tsp00_Int2)
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    values_found := false;
    IF  (stack_addr             = NIL) AND
        (stack_desc.mst_max     =   0) AND
        (stack_desc.mfirst_free =   1)
    THEN
        BEGIN
        univ_stack_desc.st_desc := stack_desc;
        i := 1;
        WHILE NOT values_found AND (i <= c_int2_cnt) DO
            IF  univ_stack_desc.int2_arr [i] = 0
            THEN
                i := i + 1
            ELSE
                values_found := true
            (*ENDIF*) 
        (*ENDWHILE*) 
        END
    ELSE
        values_found := true;
    (*ENDIF*) 
    IF  NOT values_found
    THEN
        BEGIN
        ln     := td.blankline;
        ln_len := 0;
        g17nameto_line   ('stack_desc  : EMP ', ln_len, ln);
        g17nameto_line   ('TY (mst_addr: NIL;', ln_len, ln);
        g17nameto_line   ('  firstfree : 1)  ', ln_len, ln);
        ta01vtrace_write (ln, ln_len)
        END
    ELSE
        WITH stack_desc DO
            BEGIN
            highest_stack := 0;
            ln     := td.blankline;
            ln_len := 0;
            g17sname_to_line ('---         ', ln_len, ln);
            ln_len := ln_len + 1;
            g17sname_to_line (nam, ln_len, ln);
            g17sname_to_line (' ---        ', ln_len, ln);
            ta01vtrace_write (ln, ln_len);
            univ_ptr.stack_addr := stack_addr;
            t01addr (debug, 'mst_addr    ', univ_ptr.bufaddr);
            ta01vtrace_write (td.blankline, 1);
            ln     := td.blankline;
            ln_len := 0;
            g17sname_to_line ('st_max   :  ', ln_len, ln);
            g17int4to_line   (mst_max, false, 5, ln_len+1, ln);
            ln_len        := ln_len + 5;
            g17sname_to_line ('; optimize :', ln_len, ln);
            g17int4to_line   (mst_optimize_pos, false, 5, ln_len+1, ln);
            ln_len        := ln_len + 5;
            g17sname_to_line ('; firstfree:', ln_len, ln);
            g17int4to_line   (mfirst_free, false, 5, ln_len+1, ln);
            ln_len        := ln_len + 5;
            ta01vtrace_write (ln, ln_len);
            ln            := td.blankline;
            ln_len        := 0;
            g17sname_to_line ('special  :  ', ln_len, ln);
            IF  mspecial = 0
            THEN
                g17sname_to_line ('    0;      ', ln_len, ln)
            ELSE
                BEGIN
                ln_len := ln_len + 1;
                g17trimint4_to_line (mspecial, ln_len, ln);
                ln_len      := ln_len + 1;
                ln [ln_len] := '/';
                i2.mapInt_sp00  := mspecial;
                g17hexto_line (i2.mapC2_sp00 [1], ln_len, ln);
                g17hexto_line (i2.mapC2_sp00 [2], ln_len, ln)
                END;
            (*ENDIF*) 
            g17sname_to_line (' bool     : ', ln_len, ln);
            IF  ord (mbool) = 0
            THEN
                g17sname_to_line (' FALSE      ', ln_len, ln)
            ELSE
                IF  ord (mbool) = 1
                THEN
                    g17sname_to_line (' TRUE       ', ln_len, ln)
                ELSE
                    g17trimint4_to_line (ord(mbool), ln_len, ln);
                (*ENDIF*) 
            (*ENDIF*) 
            g17sname_to_line ('; state:    ', ln_len, ln);
            IF  ( mstack_state = [] )
            THEN
                g17sname_to_line (' <empty>    ', ln_len, ln)
            ELSE
                BEGIN
                IF  ( ssSubquery_egg00 in mstack_state )
                THEN
                    g17sname_to_line (' Subquery   ', ln_len, ln);
                (*ENDIF*) 
                IF  ( ssConstParamExpr_egg00 in mstack_state )
                THEN
                    g17sname_to_line (' ConstParam ', ln_len, ln);
                (*ENDIF*) 
                IF  ( ssCopyRow_egg00 in mstack_state )
                THEN
                    g17sname_to_line (' ssCopyRow  ', ln_len, ln);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            ta01vtrace_write (ln, ln_len);
            (* PTS 1105092 E.Z. *)
            ln     := td.blankline;
            ln_len := 0;
            g17sname_to_line ('sqlmode  :  ', ln_len, ln);
            CASE msqlmode OF
                sqlm_ansi :
                    g17sname_to_line (' ANSI       ', ln_len, ln);
                sqlm_db2  :
                    g17sname_to_line (' DB2        ', ln_len, ln);
                sqlm_oracle :
                    g17sname_to_line (' ORACLE     ', ln_len, ln);
                OTHERWISE :
                    g17sname_to_line (' INTERNAL   ', ln_len, ln);
                END;
            (*ENDCASE*) 
            ta01vtrace_write (ln, ln_len);
            ta01vtrace_write (td.blankline, 1);
            ln      := td.blankline;
            ln_len  := 0;
            g17sname_to_line ('col_pos  :  ', ln_len, ln);
            g17int4to_line   (mcol_pos, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            g17sname_to_line ('; mult_pos :', ln_len, ln);
            g17int4to_line   (mmult_pos, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            g17sname_to_line ('; qual_pos :', ln_len, ln);
            g17int4to_line   (mqual_pos, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            g17sname_to_line ('; view_pos: ', ln_len, ln);
            g17int4to_line   (mview_pos, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            ta01vtrace_write (ln, ln_len);
            ln      := td.blankline;
            ln_len  := 0;
            g17sname_to_line ('col_cnt  :  ', ln_len, ln);
            g17int4to_line   (mcol_cnt, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            g17sname_to_line ('; mult_cnt :', ln_len, ln);
            g17int4to_line   (mmult_cnt, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            g17sname_to_line ('; qual_cnt :', ln_len, ln);
            g17int4to_line   (mqual_cnt, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            g17sname_to_line ('; view_cnt: ', ln_len, ln);
            g17int4to_line   (mview_cnt, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            ta01vtrace_write (ln, ln_len);
            ta01vtrace_write (td.blankline, 1);
            ln      := td.blankline;
            ln_len  := 0;
            g17sname_to_line ('upd_pos  :  ', ln_len, ln);
            g17int4to_line   (mupd_pos, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            g17sname_to_line ('; link_pos :', ln_len, ln);
            g17int4to_line   (mlink_pos, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            g17sname_to_line ('; strat_pos:', ln_len, ln);
            g17int4to_line   (mstrat_pos, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            g17sname_to_line ('; str_pos : ', ln_len, ln);
            g17int4to_line   (mstring_pos, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            ta01vtrace_write (ln, ln_len);
            ln      := td.blankline;
            ln_len  := 0;
            g17sname_to_line ('upd_cnt  :  ', ln_len, ln);
            g17int4to_line   (mupd_cnt, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            g17sname_to_line ('; link_cnt :', ln_len, ln);
            g17int4to_line   (mlink_cnt, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            g17sname_to_line ('; strat_cnt:', ln_len, ln);
            g17int4to_line   (mstrat_cnt, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            g17sname_to_line ('; str_cnt : ', ln_len, ln);
            g17int4to_line   (mstring_cnt, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            ta01vtrace_write (ln, ln_len);
            ta01vtrace_write (td.blankline, 1);
            ln     := td.blankline;
            ln_len := 0;
            g17sname_to_line ('iqual_pos:  ', ln_len, ln);
            g17int4to_line   (minvqual_pos, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            g17sname_to_line ('; trigg_pos:', ln_len, ln);
            g17int4to_line   (mtrigger_pos, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            g17sname_to_line ('; resq_pos: ', ln_len, ln);
            g17int4to_line   (mresqual_pos, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            ta01vtrace_write (ln, ln_len);
            ln     := td.blankline;
            ln_len := 0;
            g17sname_to_line ('iqual_cnt:  ', ln_len, ln);
            g17int4to_line   (minvqual_cnt, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            g17sname_to_line ('; trigg_cnt:', ln_len, ln);
            g17int4to_line   (mtrigger_cnt, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            g17sname_to_line ('; resq_cnt: ', ln_len, ln);
            g17int4to_line   (mresqual_cnt, false, 5, ln_len+1, ln);
            ln_len := ln_len + 5;
            ta01vtrace_write (ln, ln_len);
            ta01vtrace_write (td.blankline, 1);
            IF  stack_addr <> NIL
            THEN
                BEGIN
                IF  mcol_cnt > 0
                THEN
                    BEGIN
                    stackptr := mcol_pos - 1;
                    IF  highest_stack < stackptr + mcol_cnt
                    THEN
                        highest_stack := stackptr + mcol_cnt;
                    (*ENDIF*) 
                    t01int4 (debug, 'col_cnt     ', mcol_cnt);
                    IF  (stackptr + mcol_cnt <= mst_max) AND (stackptr >= 0)
                    THEN
                        BEGIN
                        i := 1;
                        WHILE i <= mcol_cnt DO
                            BEGIN
                            g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                                  is_second_ln, second_ln);
                            t01write_line (ln);
                            IF  is_second_ln
                            THEN
                                t01write_line (second_ln);
                            (*ENDIF*) 
                            i := succ(i)
                            END
                        (*ENDWHILE*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  mmult_cnt > 0
                THEN
                    BEGIN
                    stackptr := mmult_pos - 1;
                    IF  highest_stack < stackptr + mmult_cnt
                    THEN
                        highest_stack := stackptr + mmult_cnt;
                    (*ENDIF*) 
                    t01int4 (debug, 'mult_cnt    ', mmult_cnt);
                    IF  (stackptr + mmult_cnt <= mst_max) AND
                        (stackptr >= 0)
                    THEN
                        BEGIN
                        i := 1;
                        WHILE i <= mmult_cnt DO
                            BEGIN
                            g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                                  is_second_ln, second_ln);
                            t01write_line (ln);
                            IF  is_second_ln
                            THEN
                                t01write_line (second_ln);
                            (*ENDIF*) 
                            i := succ(i)
                            END
                        (*ENDWHILE*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  mqual_cnt > 0
                THEN
                    BEGIN
                    stackptr := mqual_pos - 1;
                    IF  highest_stack < stackptr + mqual_cnt
                    THEN
                        highest_stack := stackptr + mqual_cnt;
                    (*ENDIF*) 
                    t01int4 (debug, 'qual_cnt    ', mqual_cnt);
                    IF  (stackptr + mqual_cnt <= mst_max) AND
                        (stackptr >= 0)
                    THEN
                        BEGIN
                        i := 1;
                        WHILE i <= mqual_cnt DO
                            BEGIN
                            g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                                  is_second_ln, second_ln);
                            t01write_line (ln);
                            IF  is_second_ln
                            THEN
                                t01write_line (second_ln);
                            (*ENDIF*) 
                            IF  stack_addr^ [stackptr+i].etype = st_parseid
                            THEN
                                ta01parseid (stack_addr, stack_desc, i);
                            (*ENDIF*) 
                            i := succ(i)
                            END
                        (*ENDWHILE*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  minvqual_cnt > 0
                THEN
                    BEGIN
                    stackptr := minvqual_pos - 1;
                    IF  highest_stack < stackptr + minvqual_cnt
                    THEN
                        highest_stack := stackptr + minvqual_cnt;
                    (*ENDIF*) 
                    t01int4 (debug, 'minvqual_cnt', minvqual_cnt);
                    IF  (stackptr + minvqual_cnt <= mst_max) AND
                        (stackptr >= 0)
                    THEN
                        BEGIN
                        i := 1;
                        WHILE i <= minvqual_cnt DO
                            BEGIN
                            g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                                  is_second_ln, second_ln);
                            t01write_line (ln);
                            IF  is_second_ln
                            THEN
                                t01write_line (second_ln);
                            (*ENDIF*) 
                            i := succ(i)
                            END
                        (*ENDWHILE*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  mresqual_cnt > 0
                THEN
                    BEGIN
                    stackptr := mresqual_pos - 1;
                    IF  highest_stack < stackptr + mresqual_cnt
                    THEN
                        highest_stack := stackptr + mresqual_cnt;
                    (*ENDIF*) 
                    t01int4 (debug, 'mresqual_cnt', mresqual_cnt);
                    IF  (stackptr + mresqual_cnt <= mst_max) AND
                        (stackptr >= 0)
                    THEN
                        BEGIN
                        i := 1;
                        WHILE i <= mresqual_cnt DO
                            BEGIN
                            g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                                  is_second_ln, second_ln);
                            t01write_line (ln);
                            IF  is_second_ln
                            THEN
                                t01write_line (second_ln);
                            (*ENDIF*) 
                            i := succ(i)
                            END
                        (*ENDWHILE*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  mupd_cnt > 0
                THEN
                    BEGIN
                    stackptr := mupd_pos - 1;
                    IF  highest_stack < stackptr + mupd_cnt
                    THEN
                        highest_stack := stackptr + mupd_cnt;
                    (*ENDIF*) 
                    t01int4 (debug, 'upd_cnt     ', mupd_cnt);
                    IF  (stackptr + mupd_cnt <= mst_max) AND (stackptr >= 0)
                    THEN
                        BEGIN
                        i := 1;
                        WHILE i <= mupd_cnt DO
                            BEGIN
                            g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                                  is_second_ln, second_ln);
                            t01write_line (ln);
                            IF  is_second_ln
                            THEN
                                t01write_line (second_ln);
                            (*ENDIF*) 
                            i := succ(i)
                            END
                        (*ENDWHILE*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  mlink_cnt > 0
                THEN
                    BEGIN
                    stackptr := mlink_pos - 1;
                    IF  highest_stack < stackptr + mlink_cnt
                    THEN
                        highest_stack := stackptr + mlink_cnt;
                    (*ENDIF*) 
                    t01int4   (debug, 'link_cnt    ', mlink_cnt);
                    IF  (stackptr + mlink_cnt <= mst_max) AND
                        (stackptr >= 0)
                    THEN
                        BEGIN
                        i := 1;
                        WHILE i <= mlink_cnt DO
                            BEGIN
                            g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                                  is_second_ln, second_ln);
                            t01write_line (ln);
                            IF  is_second_ln
                            THEN
                                t01write_line (second_ln);
                            (*ENDIF*) 
                            i := succ(i)
                            END
                        (*ENDWHILE*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  mstrat_cnt > 0
                THEN
                    BEGIN
                    stackptr := mstrat_pos - 1;
                    IF  highest_stack < stackptr + mstrat_cnt
                    THEN
                        highest_stack := stackptr + mstrat_cnt;
                    (*ENDIF*) 
                    t01int4 (debug, 'strat_cnt   ', mstrat_cnt);
                    IF  (stackptr + mstrat_cnt <= mst_max) AND
                        (stackptr >= 0)
                    THEN
                        BEGIN
                        i := 1;
                        WHILE i <= mstrat_cnt DO
                            BEGIN
                            g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                                  is_second_ln, second_ln);
                            t01write_line (ln);
                            IF  is_second_ln
                            THEN
                                t01write_line (second_ln);
                            (*ENDIF*) 
                            i := succ(i)
                            END
                        (*ENDWHILE*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  mstring_cnt > 0
                THEN
                    BEGIN
                    stackptr := mstring_pos - 1;
                    IF  highest_stack < stackptr + mstring_cnt
                    THEN
                        highest_stack := stackptr + mstring_cnt;
                    (*ENDIF*) 
                    t01int4 (debug, 'string_cnt  ', mstring_cnt);
                    IF  (stackptr + mstring_cnt <= mst_max) AND
                        (stackptr >= 0)
                    THEN
                        BEGIN
                        i := 1;
                        WHILE i <= mstring_cnt DO
                            BEGIN
                            g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                                  is_second_ln, second_ln);
                            t01write_line (ln);
                            IF  is_second_ln
                            THEN
                                t01write_line (second_ln);
                            (*ENDIF*) 
                            i := succ(i)
                            END
                        (*ENDWHILE*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  mtrigger_cnt > 0
                THEN
                    BEGIN
                    stackptr := mtrigger_pos - 1;
                    IF  highest_stack < stackptr + mtrigger_cnt
                    THEN
                        highest_stack := stackptr + mtrigger_cnt;
                    (*ENDIF*) 
                    t01int4 (debug, 'trigger_cnt ', mtrigger_cnt);
                    IF  (stackptr + mtrigger_cnt <= mst_max) AND
                        (stackptr >= 0)
                    THEN
                        BEGIN
                        i := 1;
                        WHILE i <= mtrigger_cnt DO
                            BEGIN
                            g17onestackentry (stack_addr^ [stackptr+i], stackptr+i, ln,
                                  is_second_ln, second_ln);
                            t01write_line (ln);
                            IF  is_second_ln
                            THEN
                                t01write_line (second_ln);
                            (*ENDIF*) 
                            i := succ(i)
                            END
                        (*ENDWHILE*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  (mfirst_free - 1 > highest_stack) OR
                    (((mcol_pos > mstrat_pos + mstrat_cnt) OR
                    (mresqual_pos > mstrat_pos + mstrat_cnt)) AND
                    (mstrat_cnt > 0))
                THEN
                    (* *** mm_with_join or mm_join_with_last_tab *** *)
                    BEGIN
                    IF  (mfirst_free - 1 > highest_stack)
                    THEN
                        BEGIN
                        st_start := highest_stack + 1;
                        st_stop  := mfirst_free - 1;
                        END
                    ELSE
                        BEGIN
                        st_start := mstrat_pos + mstrat_cnt;
                        IF  (mresqual_pos > mstrat_pos + mstrat_cnt)
                        THEN
                            st_stop  := mresqual_pos - 1
                        ELSE
                            st_stop  := mcol_pos - 1;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    ln     := td.blankline;
                    ln_len := 0;
                    g17nameto_line ('cols to be        ', ln_len, ln);
                    g17nameto_line (' shifted from i-1.', ln_len, ln);
                    g17nameto_line ('th result to i.th ', ln_len, ln);
                    g17nameto_line (' result :         ', ln_len, ln);
                    g17int4to_line   (st_stop - (mstrat_pos + mstrat_cnt) + 1,
                          false, 5, ln_len + 1, ln);
                    t01write_line( ln );
                    i := st_start;
                    WHILE i <= st_stop DO
                        BEGIN
                        g17onestackentry (stack_addr^ [ i ], i, ln,
                              is_second_ln, second_ln);
                        t01write_line (ln);
                        IF  is_second_ln
                        THEN
                            t01write_line (second_ln);
                        (*ENDIF*) 
                        i := succ(i)
                        END
                    (*ENDWHILE*) 
                    END;
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01str30 (debug : tgg00_Debug; str30 : tsp00_C30);
 
VAR
      i  : integer;
      ln : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln := td.blankline;
    i := 1;
    WHILE i <= sizeof (str30) DO
        BEGIN
        IF  g17printable_char (str30 [i])
        THEN
            ln [i] := str30 [i]
        ELSE
            ln [i] := '.';
        (*ENDIF*) 
        i := succ(i)
        END;
    (*ENDWHILE*) 
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01Subtrans (
            debug          : tgg00_Debug;
            nam            : tsp00_Sname;
            VAR SubtransNo : tgg00_SubtransNo);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    g17int4to_line (SubtransNo, false, 11, ln_len, ln);
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01surrogate (
            debug         : tgg00_Debug;
            nam           : tsp00_Sname;
            VAR tabid     : tgg00_Surrogate);
      (******** hta01.h ********)
 
VAR
      i      : integer;
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    i := 1;
    WHILE i <= sizeof(tabid) DO
        BEGIN
        g17hexto_line (tabid [i], ln_len, ln);
        IF  i = sizeof (tgg00_ServerdbNo)
        THEN
            ln_len := ln_len + 1;
        (*ENDIF*) 
        i := succ(i)
        END;
    (*ENDWHILE*) 
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01RestoreSwitchAdjustments;
 
BEGIN
IF  ta01SingleUser
THEN
    BEGIN
    ta01SwitchLevel := ta01SwitchLevel - 1;
    IF  ta01SwitchLevel = 0
    THEN
        td := ta01SwitchContext;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01SaveSwitchAdjustments (turnOff : boolean);
 
VAR
      s20 : tsp00_C20;
      p   : ^tsp00_C20;
 
BEGIN
IF  ta01SingleUser
THEN
    BEGIN
    IF  ta01SwitchLevel = 0
    THEN
        ta01SwitchContext := td;
    (*ENDIF*) 
    ta01SwitchLevel := ta01SwitchLevel + 1;
    ta01SwitchContext := td;
    IF  turnOff
    THEN
        BEGIN
        s20 := bsp_c20;
        t01multiswitch (s20, s20);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01tabid (
            debug     : tgg00_Debug;
            nam       : tsp00_Sname;
            VAR tabid : tgg00_Surrogate);
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    t01surrogate (debug, nam, tabid)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      t01trace (debug : tgg00_Debug) : boolean;
      (******** hta01.h ********)
 
BEGIN
t01trace := (debug = td_always) OR
      (td.debug_or_trace AND (debug in td.debugging))
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01trans (
            debug     : tgg00_Debug;
            nam       : tsp00_Sname;
            VAR t     : tgg00_TransContext);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
      univ_ptr : RECORD
            CASE integer OF
                1:
                    (bufaddr       : tsp00_BufAddr);
                2:
                    (rte_comm_ptr  : tsp00_RteCommAddr);
                3:
                    (bd_tcache_ptr : tgg00_TempDataCachePtr);
                4 :
                    (seq_info_ptr  : tgg00_CurrSeqInfoPtr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  t01istrace (debug, t.trSessionId_gg00)
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    gg17SessionTransToLine (t.trSessionId_gg00, t.trTransId_gg00, t.trWriteTransId_gg00,
          t.trSubtransId_gg00, ln_len, ln);
    ta01vtrace_write (ln, ln_len);
    t01p2int4     (debug, 'trTaskId    ', t.trTaskId_gg00
          ,               'trIndex     ', t.trIndex_gg00);
    t01p2int4     (debug, 'trBdExclLcks', t.trBdExclFileLocks_gg00
          ,               'trChild     ', t.trChild_gg00);
    ta01TransNo   (debug, 'trWriteTrId ', t.trWriteTransId_gg00);    (* PTS 1108234 JA 2000-11-17 *)
    ta01TransNo   (debug, 'trCnsistView', t.trConsistView_gg00);     (* PTS 1108234 JA 2000-11-17 *)
    t01localstate (debug, 'trState     ', t.trState_gg00);
    t01warningset (debug, 'trWarning   ', t.trWarning_gg00);
    t01int4       (debug, 'trSessAuxCnt', t.trSessionAuxCounter_gg00);
    t01int4       (debug, 'trTempCount ', t.trTempCount_gg00);
    t01counter    (debug, 'trIoCount   ', t.trIoCount_gg00); (* PTS 1103743 JA 1999-08-25 *)
    t01counter    (debug, 'trRowLocks  ', t.trRowLocksPerSqlCmd_gg00);
    univ_ptr.rte_comm_ptr := t.trRteCommPtr_gg00;
    t01addr       (debug, 'trRteCommPtr', univ_ptr.bufaddr);
    univ_ptr.bd_tcache_ptr := t.trBdTcachePtr_gg00;
    t01addr       (debug, 'trBdTcachPtr', univ_ptr.bufaddr);
    univ_ptr.seq_info_ptr  := t.trSeqInfoPtr_gg00;
    t01addr       (debug, 'trSeqInfoPtr', univ_ptr.bufaddr);
    IF  t.trRteCommPtr_gg00 <> NIL
    THEN
        BEGIN
        IF  t.trRteCommPtr_gg00^.to_cancel
        THEN
            t01bool (debug, 'to_cancel   ',
                  t.trRteCommPtr_gg00^.to_cancel)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        t01name1 (debug, 'trError     ', 'e_ok              ')
    ELSE
        t01basis_error (debug, '**** trError', t.trError_gg00)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01TransNo (
            debug        : tgg00_Debug;
            nam          : tsp00_Sname;
            VAR TransNo  : tgg91_TransNo);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    gg06TransToLine (TransNo, ln_len, ln);
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01treeid (
            debug      : tgg00_Debug;
            nam        : tsp00_Sname;
            VAR treeid : tgg00_FileId);
      (******** hta01.h ********)
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    WITH treeid DO
        BEGIN
        ln     := td.blankline;
        ln_len := 0;
        g17sname_to_line ('---         ', ln_len, ln);
        ln_len := ln_len + 1;
        g17sname_to_line (nam, ln_len, ln);
        ln_len := ln_len + 1;
        g17sname_to_line ('---         ', ln_len, ln);
        ta01vtrace_write (ln, ln_len);
        t01int4     (debug, 'fileRootChck', fileRootCheck_gg00);
        t01p2int4   (debug, 'fileRoot    ', fileRoot_gg00
              ,             'fileLeafNods', fileLeafNodes_gg00);
        t01page_ref (debug, 'fileUserRef ', fileUserRef_gg00);
        ta01FileVers(debug, 'fileVersion ', fileVersion_gg00);
        t01handling (debug, 'fileHandling', fileHandling_gg00);
        t01bduse    (debug, 'fileBdUse   ', fileBdUse_gg00);
        t01filetype (debug, 'fileType    ', fileType_gg00);
        t01filename (debug, fileName_gg00)
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01valueto_c64 (
            VAR s   : tsp00_C64;
            pos     : integer;
            val2    : tsp00_Int2;
            val4    : tsp00_Int4;
            is_int2 : boolean);
 
TYPE
 
      int2_4_c = RECORD
            CASE integer OF
                1 :
                    (num2 : tsp00_Int2);
                2 :
                    (num4 : tsp00_Int4);
                3 :
                    (str  : tsp00_C4)
                END;
            (*ENDCASE*) 
 
 
VAR
      neg     : boolean;
      inp_pos : integer;
      i2      : tsp00_Int2;
      i4      : tsp00_Int4;
      r       : int2_4_c;
 
BEGIN
neg := false;
IF  is_int2
THEN
    BEGIN
    inp_pos := pos + 5;
    r.num2  := val2
    END
ELSE
    BEGIN
    inp_pos := pos + 10;
    r.num4  := val4
    END;
(*ENDIF*) 
IF  ((is_int2) AND (r.num2 < 0))
    OR (NOT is_int2 AND (r.num4 < 0))
THEN
    neg := true;
(*ENDIF*) 
IF  is_int2
THEN
    BEGIN
    r.num2 := abs (r.num2);
    REPEAT
        i2            := r.num2 MOD 10;
        r.num2        := r.num2 DIV 10;
        i2            := i2 + ord ('0');
        s [ inp_pos ] := chr (i2);
        inp_pos       := inp_pos -1
    UNTIL
        (r.num2 = 0) OR (inp_pos = pos)
    (*ENDREPEAT*) 
    END
ELSE
    BEGIN
    r.num4 := abs (r.num4);
    REPEAT
        i4            := r.num4 MOD 10;
        r.num4        := r.num4 DIV 10;
        i4            := i4 + ord ('0');
        s [ inp_pos ] := chr (i4);
        inp_pos       := inp_pos -1
    UNTIL
        (r.num4 = 0) OR (inp_pos = pos)
    (*ENDREPEAT*) 
    END;
(*ENDIF*) 
IF  neg
THEN
    s [ inp_pos ] := '-';
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01vffn (
            debug    : tgg00_Debug;
            nam      : tsp00_Sname;
            fn       : tsp00_VFilename);
 
VAR
      i      : integer;
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    i := 1;
    WHILE i <= (sizeof (ln) - ln_len) DO (* PTS 1113051 M.Ki *)
        BEGIN
        IF  g17printable_char (fn [i])
        THEN
            ln [ln_len + i] := fn [i]
        ELSE
            ln [ln_len + i] := '.';
        (*ENDIF*) 
        i := succ(i)
        END;
    (*ENDWHILE*) 
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01vftype (
            debug : tgg00_Debug;
            nam : tsp00_Sname;
            ft  : tsp00_VfType);
 
VAR
      ln_len : tsp00_Int4;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    g17vftype (ft, ln_len, ln);
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01warningset (
            debug : tgg00_Debug;
            nam  : tsp00_Sname;
            warn : tsp00_WarningSet);
 
VAR
      curr_warn : tsp00_Warnings;
      ln_len    : integer;
      ln        : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    IF  warn <> [ ]
    THEN
        FOR curr_warn := warn0_exist
              TO warn15_user_defined_code DO
            IF  curr_warn in warn
            THEN
                BEGIN
                ln     := td.blankline;
                ln_len := sizeof(nam) + 3;
                g17warning_item_to_line (curr_warn, ln_len, ln);
                ta01vtrace_write (ln, ln_len)
                END
            (*ENDIF*) 
        (*ENDFOR*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01strategy (
            debug        : tgg00_Debug;
            nam          : tsp00_Sname;
            VAR strategy : tgg07_StrategyInfo);
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    a725gg_strategy( debug, strategy );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01strat_enum (
            debug : tgg00_Debug;
            nam   : tsp00_Sname;
            strat : tgg07_StratEnum);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln          := td.blankline;
    ln_len      := 0;
    g17sname_to_line (nam, ln_len, ln);
    ln_len      := sizeof (nam) + 2;
    ln [ln_len] := ':';
    ln_len      := succ (ln_len);
    CASE strat OF
        strat_key_equal_fetch:
            g17nameto_line ('key equal fetch   ', ln_len, ln);
        strat_key_equal:
            g17nameto_line ('key equal         ', ln_len, ln);
        strat_key_in:
            g17nameto_line ('key in            ', ln_len, ln);
        strat_key_subq:
            g17nameto_line ('key subq          ', ln_len, ln);
        strat_inv_range:
            g17nameto_line ('inv range         ', ln_len, ln);
        strat_inv_in:
            g17nameto_line ('inv in            ', ln_len, ln);
        strat_inv_subq:
            g17nameto_line ('inv subq          ', ln_len, ln);
        strat_key_range:
            g17nameto_line ('key range         ', ln_len, ln);
        strat_inv_range_merge_fetch:
            g17nameto_line ('inv rng merge fetc', ln_len, ln);
        strat_inv_range_fetch:
            g17nameto_line ('inv range fetch   ', ln_len, ln);
        strat_key_range_fetch:
            g17nameto_line ('key range fetch   ', ln_len, ln);
        strat_more_than_one:
            g17nameto_line ('more than one     ', ln_len, ln);
        strat_join_inv:
            g17nameto_line ('join inv          ', ln_len, ln);
        strat_undecided:
            g17nameto_line ('undecided         ', ln_len, ln);
        strat_join_key_next:
            g17nameto_line ('join key next     ', ln_len, ln);
        strat_join_key_equal:
            g17nameto_line ('join key equal    ', ln_len, ln);
        strat_join_viewkey:
            g17nameto_line ('join viewkey      ', ln_len, ln);
        strat_join_all_keys_equal:
            g17nameto_line ('join all keys equa', ln_len, ln);
        strat_join_key_range:
            g17nameto_line ('join key range    ', ln_len, ln);
        strat_join_all_inv_equal:
            g17nameto_line ('join all inv equal', ln_len, ln);
        strat_join_inv_range:
            g17nameto_line ('join inv range    ', ln_len, ln);
        strat_catalog:
            g17nameto_line ('catalog           ', ln_len, ln);
        strat_no_result:
            g17nameto_line ('no result set     ', ln_len, ln);
        strat_viewkey:
            g17nameto_line ('viewkey           ', ln_len, ln);
        OTHERWISE
            g17nameto_line ('new strat         ', ln_len, ln)
        END;
    (*ENDCASE*) 
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01write_line (VAR ln : tsp00_Line);
 
BEGIN
ta01vtrace_write (ln, s30lnr (ln, ' ', 1, sizeof(ln)))
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01user_hm (
            debug     : tgg00_Debug;
            VAR part1 : tgg00_QualBuf);
 
VAR
      i : integer;
      n : tsp00_Name;
 
BEGIN
t01name (debug, '-- SAVE_RESTORE --');
WITH part1.msave_restore DO
    BEGIN
    t01p2int4 (debug, 'BufCount    ', sripBlocksize_gg00
          ,           'HostTapeNum ', sripHostTapeNum_gg00    );
    t01bool2  (debug, 'IsAutoLoad  ', sripIsAutoLoad_gg00
          ,           'WithCheckpt ', sripWithCheckpoint_gg00 );
    t01int4   (debug, 'FileVersion ', sripFileVersion_gg00    );
    t01bool2  (debug, 'IsRestoreCon', sripIsRestoreConfig_gg00
          ,           'CompleteSegm', sripOnlyCompleteSegments_gg00);
    t01sname  (debug,                 sripUtilCmdId_gg00.utidId_gg00);
    t01name   (debug,                 sripConfigDbName_gg00   );
    t01bool2  (debug, 'WithFormat  ', sripWithFormat_gg00
          ,           'NoReleaseLog', sripNoReleaseLog_gg00);
    n := bsp_c18;
    i := 1;
    WHILE i <= DATE_MXSP00 DO
        BEGIN
        n [i] := sripUntilDate_gg00 [i];
        i     := succ(i)
        END;
    (*ENDWHILE*) 
    i := 1;
    WHILE i <= TIME_MXSP00 DO
        BEGIN
        n [DATE_MXSP00+2+i] := sripUntilTime_gg00 [i];
        i                   := succ(i)
        END;
    (*ENDWHILE*) 
    t01name1  (debug, 'until       ', n);
    i := 1;
    WHILE i <= sripHostTapeNum_gg00 DO
        BEGIN
        IF  sripHostTapecount_gg00 [i] <> MAX_INT4_SP00
        THEN
            t01p2int4 (debug, 'HostTapecoun', sripHostTapecount_gg00 [i]
                  ,           'index       ', i);
        (*ENDIF*) 
        IF  sripHostTapenames_gg00 [i] <> b01blankfilename
        THEN
            BEGIN
            t01int4 (debug, 'index       ', i);
            t01vffn (debug, 'HostTapename', sripHostTapenames_gg00 [i])
            END;
        (*ENDIF*) 
        t01vftype (debug, 'HostFiletype', sripHostFiletypes_gg00 [i]);
        i := succ(i)
        END;
    (*ENDWHILE*) 
    IF  sripMedianame_gg00 <> bsp_c64
    THEN
        BEGIN
        t01sname (debug, 'Medianame   ');
        t01c64 (debug, sripMedianame_gg00)
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01init_line (
            VAR ln      : tsp00_Line;
            VAR ln_len  : integer;
            nam         : tsp00_Sname);
 
VAR
      move_err : tgg00_BasisError;
 
BEGIN
ln       := td.blankline;
IF  nam <> bsp_sname
THEN
    BEGIN
    move_err := e_ok;
    SAPDB_PascalMove ('VTA01 ',   9,    
          sizeof (nam), sizeof (ln),
          @nam, 1, @ln, 1, sizeof (nam), move_err);
    ln_len      := sizeof (nam) + 2;
    ln [ln_len] := ':';
    ln_len      := ln_len + 1;
    END
ELSE
    ln_len := 0;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ta01label_in_str (lab : tsp00_C2; str : tsp00_C20) : boolean;
 
VAR
      found : boolean;
      i     : integer;
 
BEGIN
found := false;
i     := 1;
REPEAT
    IF  (lab [1] = str [i]) AND (lab [2] = str [i+1])
    THEN
        found := true
    ELSE
        i := i + 1
    (*ENDIF*) 
UNTIL
    found OR (i > 19);
(*ENDREPEAT*) 
ta01label_in_str := found
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01name_int4_to_line (
            n       : tsp00_Name;
            n_len   : integer;
            int4    : tsp00_Int4;
            int_len : integer;
            ln_pos  : integer;
            VAR ln  : tsp00_Line);
 
VAR
      move_err  : tgg00_BasisError;
      len       : integer;
      n_nil_pno : tsp00_Sname;
 
BEGIN
IF  n_len > sizeof(n)
THEN
    len := sizeof(n)
ELSE
    len := n_len;
(*ENDIF*) 
move_err := e_ok;
SAPDB_PascalMove ('VTA01 ',  10,    
      sizeof (n), sizeof (ln),
      @n, 1, @ln, ln_pos, len, move_err);
ln [ln_pos + n_len] := ':';
IF  (int4 = NIL_PAGE_NO_GG00) AND (int_len >= 7)
THEN
    BEGIN
    n_nil_pno := 'nil_pno     ';
    move_err  := e_ok;
    SAPDB_PascalMove ('VTA01 ',  11,    
          sizeof (n_nil_pno), sizeof (ln),
          @n_nil_pno, 1, @ln, ln_pos + n_len + 2, 7, move_err)
    END
ELSE
    g17int4to_line (int4, false, int_len, ln_pos + n_len + 1, ln)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01sname_int4_to_line (
            n       : tsp00_Sname;
            n_len   : integer;
            int4    : tsp00_Int4;
            int_len : integer;
            ln_pos  : integer;
            VAR ln  : tsp00_Line);
 
VAR
      move_err  : tgg00_BasisError;
      len       : integer;
      n_nil_pno : tsp00_Sname;
 
BEGIN
IF  n_len > sizeof(n)
THEN
    len := sizeof(n)
ELSE
    len := n_len;
(*ENDIF*) 
move_err := e_ok;
SAPDB_PascalMove ('VTA01 ',  12,    
      sizeof (n), sizeof (ln),
      @n, 1, @ln, ln_pos, len, move_err);
ln [ln_pos + n_len] := ':';
IF  (int4 = NIL_PAGE_NO_GG00) AND (int_len >= 7)
THEN
    BEGIN
    n_nil_pno := 'nil_pno     ';
    move_err  := e_ok;
    SAPDB_PascalMove ('VTA01 ',  13,    
          sizeof (n_nil_pno), sizeof (ln),
          @n_nil_pno, 1, @ln, ln_pos + n_len + 2, 7, move_err)
    END
ELSE
    g17int4to_line (int4, false, int_len, ln_pos + n_len + 1, ln)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01obj_display (
            nam              : tsp00_Sname;
            buf              : tsp00_ObjAddr;
            buf_size         : tsp00_Int4;
            startpos         : tsp00_Int4;
            endpos           : tsp00_Int4;
            double_numbering : boolean;
            start_numbering  : tsp00_Int4);
 
CONST
      c_maxbuf_bytes_per_line = 20;
      c_min_char_count        =  3;
      c_minbuf_bytes_per_line = 30;
      (* *)
      mx_maxbuf_byte   =  3;
      mx_maxbuf_prefix =  4;
      mx_minbuf_byte   =  2;
      mx_minbuf_prefix =  5;
      (* *)
      c_ascii_prefix  = 'asc:';
      c_chr_prefix    = 'chr:';
      c_dec_prefix    = 'dec:';
      c_hex_prefix    = 'hex:';
      c_pos_prefix    = 'pos:';
      (* *)
      c_minbuf_indicator  = '@';
 
VAR
      skip_output    : boolean;
      last_skipped   : boolean;
      upb            : tsp00_Int4;
      buf_pos        : tsp00_Int4;
      numb_pos       : tsp00_Int4;
      out_pos        : tsp00_Int4;
      pos_displ      : tsp00_Int4;
      skip_numb_pos  : tsp00_Int4;
      ln_len         : integer;
      i              : integer;
      bytes_per_line : integer;
      byte_count     : tsp00_Int4;
      chrline        : hexbuf_line;
      decline        : hexbuf_line;
      hexline        : hexbuf_line;
      posline        : hexbuf_line;
      posline_2      : hexbuf_line;
 
BEGIN
ta01vtrace_write (td.blankline, 1);
IF  td.minbuf
THEN
    bytes_per_line := c_minbuf_bytes_per_line
ELSE
    bytes_per_line := c_maxbuf_bytes_per_line;
(*ENDIF*) 
IF  (startpos < 1) OR (startpos > buf_size)
THEN
    BEGIN
    buf_pos := 1;
    upb     := bytes_per_line
    END
ELSE
    BEGIN
    buf_pos := startpos;
    IF  (endpos < startpos) OR (endpos > buf_size)
    THEN
        upb := buf_pos + bytes_per_line - 1
    ELSE
        upb := endpos
    (*ENDIF*) 
    END;
(*ENDIF*) 
numb_pos   := start_numbering;
chrline.ln := td.blankline;
ln_len     := 0;
g17sname_to_line (nam, ln_len, chrline.ln);
g17sname_to_line (' from       ', ln_len, chrline.ln);
ln_len := ln_len + 1;
g17trimint4_to_line (numb_pos, ln_len, chrline.ln);
g17sname_to_line (' TO         ', ln_len, chrline.ln);
ln_len := ln_len + 1;
g17trimint4_to_line (numb_pos + upb - buf_pos, ln_len, chrline.ln);
IF  double_numbering AND NOT td.minbuf
THEN
    BEGIN
    g17sname_to_line (' (FROM      ', ln_len, chrline.ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (buf_pos, ln_len, chrline.ln);
    g17sname_to_line (' TO         ', ln_len, chrline.ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (upb, ln_len, chrline.ln);
    ln_len := ln_len + 1;
    chrline.ln [ln_len] := ')'
    END;
(*ENDIF*) 
IF  buf_pos <> startpos
THEN
    BEGIN
    g17sname_to_line ('   *** from ', ln_len, chrline.ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (startpos, ln_len, chrline.ln)
    END;
(*ENDIF*) 
IF  upb <> endpos
THEN
    BEGIN
    g17sname_to_line ('   *** to   ', ln_len, chrline.ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (endpos, ln_len, chrline.ln)
    END;
(*ENDIF*) 
IF  upb > startpos + td.maxlength - 1
THEN
    BEGIN
    g17nameto_line (' (truncated at    ', ln_len, chrline.ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (startpos + td.maxlength, ln_len, chrline.ln);
    ln_len := ln_len + 1;
    chrline.ln [ln_len] := ')';
    upb := startpos + td.maxlength - 1
    END;
(*ENDIF*) 
ta01vtrace_write (chrline.ln, ln_len);
last_skipped  := false;
REPEAT
    skip_output := false;
    IF  (buf_pos > startpos) AND (buf_pos + bytes_per_line - 1 < upb)
    THEN
        BEGIN
        i := buf_pos;
        skip_output := true;
        REPEAT
            IF  buf^[i-bytes_per_line] <> buf^[i]
            THEN
                skip_output := false;
            (*ENDIF*) 
            i := i + 1
        UNTIL
            NOT skip_output OR (i >= buf_pos + bytes_per_line)
        (*ENDREPEAT*) 
        END;
    (*ENDIF*) 
    IF  skip_output AND NOT last_skipped
    THEN
        BEGIN
        last_skipped  := true;
        skip_numb_pos := numb_pos
        END;
    (*ENDIF*) 
    IF  skip_output
    THEN
        BEGIN
        buf_pos  := buf_pos  + bytes_per_line;
        numb_pos := numb_pos + bytes_per_line
        END
    ELSE
        IF  last_skipped
            OR
            (NOT td.minbuf AND (buf_pos > startpos))
        THEN
            (* write number of skipped bytes  OR  write blank line *)
            BEGIN
            IF  last_skipped
            THEN
                BEGIN
                last_skipped := false;
                chrline.ln   := td.blankline;
                ln_len       := 0;
                g17sname_to_line   ('     ...    ', ln_len, chrline.ln);
                ln_len := ln_len + 1;
                g17trimint4_to_line (skip_numb_pos, ln_len, chrline.ln);
                g17sname_to_line   (' TO         ', ln_len, chrline.ln);
                ln_len := ln_len + 1;
                g17trimint4_to_line (numb_pos-1,    ln_len, chrline.ln);
                IF  double_numbering AND NOT td.minbuf
                THEN
                    BEGIN
                    ln_len := ln_len + 2;
                    chrline.ln [ln_len] := '(';
                    g17trimint4_to_line (buf_pos - numb_pos
                          + skip_numb_pos, ln_len, chrline.ln);
                    g17sname_to_line (' TO         ',
                          ln_len, chrline.ln);
                    ln_len := ln_len + 1;
                    g17trimint4_to_line (buf_pos-1, ln_len, chrline.ln);
                    ln_len := ln_len + 1;
                    chrline.ln [ln_len] := ')'
                    END;
                (*ENDIF*) 
                ta01vtrace_write (chrline.ln, ln_len)
                END
            ELSE
                ta01vtrace_write (td.blankline, 1)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  NOT skip_output
    THEN
        BEGIN
        hexline.ln := td.blankline;
        chrline.ln := td.blankline;
        IF  td.minbuf
        THEN
            BEGIN
            g17int4to_line (numb_pos, NOT WITH_ZERO,
                  mx_minbuf_prefix, 1, chrline.ln);
            out_pos := mx_minbuf_prefix + 1
            END
        ELSE
            BEGIN
            out_pos          := mx_maxbuf_prefix + 1;
            posline.ln       := td.blankline;
            posline_2.ln     := td.blankline;
            decline.ln       := td.blankline;
            posline.prefix   := c_pos_prefix;
            posline_2.prefix := c_pos_prefix;
            decline.prefix   := c_dec_prefix;
            hexline.prefix   := c_hex_prefix;
            chrline.prefix   := c_chr_prefix;
            END;
        (*ENDIF*) 
        byte_count := 0;
        REPEAT
            byte_count := byte_count + 1;
            IF  NOT td.minbuf
            THEN
                BEGIN
                IF  byte_count = 1
                THEN
                    BEGIN
                    IF  (numb_pos < 1000)
                        AND double_numbering
                    THEN
                        g17int4to_line (numb_pos, NOT WITH_ZERO,
                              mx_maxbuf_byte, out_pos, posline.ln)
                    ELSE
                        g17int4to_line (numb_pos, NOT WITH_ZERO,
                              mx_maxbuf_prefix + mx_maxbuf_byte, 1,
                              posline.ln)
                    (*ENDIF*) 
                    END
                ELSE
                    IF  (numb_pos < 100)
                        OR
                        (byte_count MOD 2 = 1)
                    THEN
                        BEGIN
                        IF  numb_pos < 1000
                        THEN
                            pos_displ := numb_pos
                        ELSE
                            pos_displ := numb_pos MOD 1000;
                        (*ENDIF*) 
                        g17int4to_line (pos_displ,
                              (numb_pos >= 1000),
                              mx_maxbuf_byte, out_pos, posline.ln)
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  double_numbering
                THEN
                    BEGIN
                    IF  byte_count = 1
                    THEN
                        g17int4to_line (buf_pos, NOT WITH_ZERO,
                              mx_maxbuf_prefix + mx_maxbuf_byte, 1,
                              posline_2.ln)
                    ELSE
                        IF  (buf_pos < 100)
                            OR
                            (byte_count MOD 2 = 1)
                        THEN
                            BEGIN
                            IF  buf_pos < 1000
                            THEN
                                pos_displ := buf_pos
                            ELSE
                                pos_displ := buf_pos MOD 1000;
                            (*ENDIF*) 
                            g17int4to_line (pos_displ,
                                  (buf_pos >= 1000),
                                  mx_maxbuf_byte, out_pos,
                                  posline_2.ln)
                            END
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                g17int4to_line (ord (buf^[buf_pos]), NOT WITH_ZERO, 3,
                      out_pos, decline.ln);
                END
            ELSE
                (* minbuf without blank space *)
                out_pos := out_pos - 1;
            (*ENDIF*) 
            ;
            (* minbuf, maxbuf *)
            ln_len := out_pos;
            g17hexto_line (buf^[buf_pos], ln_len, hexline.ln);
            IF  g17printable_char (buf^[buf_pos])
            THEN
                chrline.ln [out_pos+2] := buf^[buf_pos]
            ELSE
                IF  td.minbuf
                THEN
                    BEGIN
                    IF  (byte_count MOD  2  = 1) AND
                        (byte_count MOD 10 <> 1)
                    THEN
                        chrline.ln [out_pos+1] := '|'
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  td.minbuf
            THEN
                BEGIN
                out_pos := 1 + out_pos + mx_minbuf_byte;
                IF  byte_count MOD 10 = 0
                THEN
                    out_pos := out_pos + 1
                (*ENDIF*) 
                END
            ELSE
                out_pos := out_pos + mx_maxbuf_byte;
            (*ENDIF*) 
            buf_pos  := buf_pos  + 1;
            numb_pos := numb_pos + 1
        UNTIL
            (byte_count >= bytes_per_line) OR (buf_pos > upb);
        (*ENDREPEAT*) 
        IF  td.minbuf
        THEN
            BEGIN
            hexline.ln [2] := c_minbuf_indicator;
            hexline.ln [3] := c_minbuf_indicator
            END
        ELSE
            BEGIN
            ta01vtrace_write (posline.ln, out_pos-1);
            IF  double_numbering
            THEN
                ta01vtrace_write (posline_2.ln, out_pos-1);
            (*ENDIF*) 
            ta01vtrace_write (decline.ln, out_pos-1)
            END;
        (*ENDIF*) 
        ta01vtrace_write (hexline.ln, out_pos-1);
        ta01vtrace_write (chrline.ln, out_pos-1);
        END
    (*ENDIF*) 
UNTIL
    buf_pos > upb;
(*ENDREPEAT*) 
ta01vtrace_write (td.blankline, 1)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01part2_change_key (
            debug     : tgg00_Debug;
            VAR part2 : tgg00_Rec);
 
VAR
      is_second_ln : boolean;
      move_err     : tgg00_BasisError;
      i2           : tsp00_IntMapC2;
      i            : integer;
      tree         : tgg00_FileId;
      ln           : tsp00_Line;
      second_ln    : tsp00_Line;
      st           : tta01_small_stack;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    move_err := e_ok;
    SAPDB_PascalMove ('VTA01 ',  14,    
          sizeof (part2.buf), sizeof (tree),
          @part2.buf, 1, @tree, 1, sizeof (tree), move_err);
    t01treeid (debug, 'src tree id ', tree);
    t01write_line (td.blankline);
    i2.mapC2_sp00 [1] := part2.buf [FILE_ID_MXGG00 + 1];
    i2.mapC2_sp00 [2] := part2.buf [FILE_ID_MXGG00 + 2];
    move_err      := e_ok;
    SAPDB_PascalMove ('VTA01 ',  15,    
          sizeof (part2.buf), sizeof (tree), @part2.buf,
          sizeof (tree) + i2.mapInt_sp00 * sizeof (tgg00_StackEntry) + 3,
          @tree, 1, sizeof (tree), move_err);
    t01treeid (debug, 'src index id', tree);
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01set_bool_debug_or_trace;
 
BEGIN
td.debug_or_trace := (td.debugging <> [ ]);
IF  NOT td.debug_or_trace
THEN
    BEGIN
    IF  td.trace_ak OR td.trace_bd OR td.trace_dg OR
        td.trace_en OR td.trace_gg OR td.trace_in OR
        td.trace_kb OR td.trace_sp OR td.trace_ra
    THEN
        td.debug_or_trace := true
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01trace_set (VAR s20 : tsp00_C20);
 
BEGIN
td.trace_ak := ta01label_in_str ('AK', s20);
td.trace_bd := ta01label_in_str ('BD', s20);
td.trace_dg := ta01label_in_str ('DG', s20);
td.trace_en := ta01label_in_str ('EN', s20);
td.trace_gg := ta01label_in_str ('GG', s20);
td.trace_in := ta01label_in_str ('IN', s20);
td.trace_kb := ta01label_in_str ('KB', s20);
td.trace_sp := ta01label_in_str ('SP', s20);
td.trace_ra := ta01label_in_str ('RA', s20);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01test_set (VAR s20 : tsp00_C20);
 
BEGIN
td.debugging := [ ];
IF  ta01label_in_str ('AK', s20)
THEN
    td.debugging := td.debugging + [
          vtr_ak,
          ak_cach,
          ak_sem,
          ak_strat,
          ak_syn ];
(*ENDIF*) 
IF  ta01label_in_str ('AC', s20)
THEN
    td.debugging := td.debugging + [ ak_cach ];
(*ENDIF*) 
IF  ta01label_in_str ('AI', s20)
THEN
    td.debugging := td.debugging + [ ak_isolev ];
(*ENDIF*) 
IF  ta01label_in_str ('AJ', s20)
THEN
    td.debugging := td.debugging + [ ak_join ];
(*ENDIF*) 
IF  ta01label_in_str ('AS', s20)
THEN
    td.debugging := td.debugging + [ ak_sem ];
(*ENDIF*) 
IF  ta01label_in_str ('AT', s20)
THEN
    td.debugging := td.debugging + [ ak_strat ];
(*ENDIF*) 
IF  ta01label_in_str ('AY', s20)
THEN
    td.debugging := td.debugging + [ ak_syn ];
(*ENDIF*) 
IF  ta01label_in_str ('ST', s20)
THEN
    td.debugging := td.debugging + [ st_stack ];
(*ENDIF*) 
IF  ta01label_in_str ('BD', s20)
THEN
    td.debugging := td.debugging + [
          bd,
          bd_buf,
          bd_byte,
          bd_index,
          bd_inv,
          bd_io,
          bd_keym,
          bd_lock,
          bd_oflw,
          bd_psm,
          bd_tbuf ];
(*ENDIF*) 
IF  ta01label_in_str ('BB', s20)
THEN
    td.debugging := td.debugging + [ bd_buf ];
(*ENDIF*) 
IF  ta01label_in_str ('BC', s20)
THEN
    td.debugging := td.debugging + [ bd_idx_create ];
(*ENDIF*) 
IF  ta01label_in_str ('BX', s20)
THEN
    td.debugging := td.debugging + [ bd_index ];
(*ENDIF*) 
IF  ta01label_in_str ('BV', s20)
THEN
    td.debugging := td.debugging + [ bd_inv ];
(*ENDIF*) 
IF  ta01label_in_str ('BO', s20)
THEN
    td.debugging := td.debugging + [ bd_io ];
(*ENDIF*) 
IF  ta01label_in_str ('BL', s20)
THEN
    td.debugging := td.debugging + [ bd_lock ];
(*ENDIF*) 
IF  ta01label_in_str ('BF', s20)
THEN
    td.debugging := td.debugging + [ bd_oflw ];
(*ENDIF*) 
IF  ta01label_in_str ('BQ', s20)
THEN
    td.debugging := td.debugging + [ bd_ioqueue ];
(*ENDIF*) 
IF  ta01label_in_str ('BP', s20)
THEN
    td.debugging := td.debugging + [ bd_psm ];
(*ENDIF*) 
IF  ta01label_in_str ('BI', s20)
THEN
    td.debugging := td.debugging + [ bi ];
(*ENDIF*) 
IF  ta01label_in_str ('BM', s20)
THEN
    td.debugging := td.debugging + [ bd_keym ];
(*ENDIF*) 
IF  ta01label_in_str ('BT', s20)
THEN
    td.debugging := td.debugging + [ bd_tbuf ];
(*ENDIF*) 
IF  ta01label_in_str ('BY', s20)
THEN
    td.debugging := td.debugging + [ bd_byte ];
(*ENDIF*) 
IF  ta01label_in_str ('FH', s20)
THEN
    td.debugging := td.debugging + [ fs_ak ];
(*ENDIF*) 
IF  ta01label_in_str ('FL', s20)
THEN
    td.debugging := td.debugging + [ fs_kb ];
(*ENDIF*) 
IF  ta01label_in_str ('GG', s20)
THEN
    td.debugging := td.debugging + [ gg ];
(*ENDIF*) 
IF  ta01label_in_str ('KB', s20)
THEN
    td.debugging := td.debugging + [
          kb,
          kb_dist,
          kb_funct,
          kb_lock,
          kb_qual,
          kb_save,
          kb_sel ];
(*ENDIF*) 
IF  ta01label_in_str ('KD', s20)
THEN
    td.debugging := td.debugging + [ kb_dist ];
(*ENDIF*) 
IF  ta01label_in_str ('KE', s20)
THEN
    td.debugging := td.debugging + [ kb_lockentry ];
(*ENDIF*) 
IF  ta01label_in_str ('KF', s20)
THEN
    td.debugging := td.debugging + [ kb_funct ];
(*ENDIF*) 
IF  ta01label_in_str ('KL', s20)
THEN
    td.debugging := td.debugging + [ kb_lock ];
(*ENDIF*) 
IF  ta01label_in_str ('KN', s20)
THEN
    td.debugging := td.debugging + [ kb_dist ];
(*ENDIF*) 
IF  ta01label_in_str ('KQ', s20)
THEN
    td.debugging := td.debugging + [ kb_qual ];
(*ENDIF*) 
IF  ta01label_in_str ('KS', s20)
THEN
    td.debugging := td.debugging + [ kb_sel ];
(*ENDIF*) 
IF  ta01label_in_str ('KV', s20)
THEN
    td.debugging := td.debugging + [ kb_save ];
(*ENDIF*) 
IF  ta01label_in_str ('PR', s20)
THEN
    td.debugging := td.debugging + [ sproc, sproc_call, sproc_sql ];
(*ENDIF*) 
IF  ta01label_in_str ('PC', s20)
THEN
    td.debugging := td.debugging + [ sproc_call ];
(*ENDIF*) 
IF  ta01label_in_str ('PI', s20)
THEN
    td.debugging := td.debugging + [ sproc ];
(*ENDIF*) 
IF  ta01label_in_str ('PS', s20)
THEN
    td.debugging := td.debugging + [ sproc_sql ];
(*ENDIF*) 
IF  ta01label_in_str ('RA', s20)
THEN
    td.debugging := td.debugging + [ drda ];
(*ENDIF*) 
IF  ta01label_in_str ('TP', s20)
THEN
    td.debugging := td.debugging + [ test_ak ];
(*ENDIF*) 
IF  ta01label_in_str ('TB', s20)
THEN
    td.debugging := td.debugging + [ test_bd ];
(*ENDIF*) 
IF  ta01label_in_str ('TK', s20)
THEN
    td.debugging := td.debugging + [ test_kb ];
(*ENDIF*) 
IF  ta01label_in_str ('UC', s20)
THEN
    td.debugging := td.debugging + [ unicode ];
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01util_mut_part1 (
            debug     : tgg00_Debug;
            VAR part1 : tgg00_QualBuf);
 
VAR
      move_err : tgg00_BasisError;
      i        : integer;
      ln_len   : integer;
      n        : tsp00_Sname;
      ln       : tsp00_Line;
 
BEGIN
WITH part1 DO
    BEGIN
    t01treeid    (debug, 'treeid      ', mtree);
    t01int4      (debug, 'diag_type   ', ord (mut_diag_type));
    t01bool      (debug, 'config      ', mut_config);
    t01p2int4    (debug, 'pool_size   ', mut_pool_size
          ,              'index_no    ', mut_index_no );
    t01p2int4    (debug, 'pno         ', mut_pno
          ,              'pno2        ', mut_pno2     );
    t01int4      (debug, 'count       ', mut_count    );
    t01surrogate (debug, 'surrogate   ', mut_surrogate);
    n  := 'authname    ';
    t01init_line (ln, ln_len, n);
    i := 1;
    WHILE i <= sizeof (mut_authname) DO
        BEGIN
        ln [ln_len + i] := mut_authname [i];
        i := succ(i)
        END;
    (*ENDWHILE*) 
    n        := 'tabname     ';
    move_err := e_ok;
    SAPDB_PascalMove ('VTA01 ',  16,    
          sizeof (n), sizeof (ln),
          @n, 1, @ln, SECOND_COLUMN_POS, sizeof (n), move_err);
    ln_len      := SECOND_COLUMN_POS + sizeof (n) + 1;
    ln [ln_len] := ':';
    move_err    := e_ok;
    SAPDB_PascalMove ('VTA01 ',  17,    
          sizeof (mut_tabname), sizeof (ln),
          @mut_tabname, 1, @ln, ln_len + 2, sizeof (mut_tabname),
          move_err);
    t01write_line (ln);
    t01vffn (debug, 'dev         ', mut_dev      );
    t01vffn (debug, 'dev2        ', mut_dev2     );
    t01vffn (debug, 'hostfn      ', mut_hostfn   );
    ta01dump_state_set (debug, 'dump state  ', mut_dump_state)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01function_trace_write (VAR ln : tsp00_Line; ln_len : integer);
 
VAR
      aux_t : tgg00_TransContext;
 
BEGIN
vgetpid (aux_t.trTaskId_gg00);
aux_t.trSessionId_gg00.ci4_gg00    := cgg_nil_session;
aux_t.trTransId_gg00.ci6_gg00      := cgg_nil_trans;
aux_t.trWriteTransId_gg00.ci6_gg00 := cgg_nil_trans;                 (* PTS 1108234 JA 2000-11-17 *)
aux_t.trSubtransId_gg00            := 0;
b120InsertTrace (aux_t, ta, vttSlowTrace_egg00, ln_len, @ln)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01parseid (
            stack_addr        : tgg00_StackListPtr;
            VAR stack_desc    : tgg00_StackDesc;
            VAR i             : integer);
 
VAR
      ix       : integer;
      src_st   : tsp00_Int4;
      stackptr : tsp00_Int4;
      paramCnt : tsp00_Int4;
      pBuf     : ^tsp00_Buf;
 
BEGIN
stackptr := stack_desc.mqual_pos + i - 1;
IF  stack_desc.mbool
THEN
    BEGIN
    pBuf := @stack_addr^[stackptr+1];
    t01buf (td_always, pBuf^, 1, sizeof(tsp00_C12));
    END
ELSE
    t01str30  (td_always, '     NOT PARSED               ');
(*ENDIF*) 
i := i + 2;
paramCnt := stack_addr^[stackptr].epos;
IF  paramCnt > 0
THEN
    BEGIN
    t01str30  (td_always, '     Parameter Description :  ');
    stackptr := stackptr + 3;
    FOR ix := 1 TO paramCnt DO
        BEGIN
        IF  stackptr <= stack_desc.mqual_pos + stack_desc.mqual_cnt - 1
        THEN
            BEGIN
            t01p2int4 (td_always, '     dstpos ', stack_addr^[stackptr].epos,
                  'dstlen      ', stack_addr^[stackptr].elen_var);
            src_st := stack_addr^[stackptr].eindex;
            IF  src_st <= stack_desc.mqual_pos + stack_desc.mqual_cnt - 1
            THEN
                t01p2int4 (td_always, '     srcpos ', stack_addr^[src_st].epos,
                      'srclen      ', stack_addr^[src_st].elen_var);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        stackptr := stackptr + 1
        END;
    (*ENDFOR*) 
    i := i + paramCnt
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01vtrace_write (VAR ln : tsp00_Line; ln_len : integer);
 
VAR
      aux_t : tgg00_TransContext;
 
BEGIN
vgetpid (aux_t.trTaskId_gg00);
aux_t.trSessionId_gg00.ci4_gg00    := cgg_nil_session;
aux_t.trTransId_gg00.ci6_gg00      := cgg_nil_trans;
aux_t.trWriteTransId_gg00.ci6_gg00 := cgg_nil_trans;                 (* PTS 1108234 JA 2000-11-17 *)
aux_t.trSubtransId_gg00            := 0;
b120InsertTrace (aux_t, ta, td_none, ln_len, @ln)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01qual_kind (
            debug     : tgg00_Debug;
            nam       : tsp00_Sname;
            qual_kind : tgg00_QualKind);
 
VAR
      ln_len       : integer;
      ln           : tsp00_Line;
      print_number : boolean;
      msg          : tsp00_Sname;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln          := td.blankline;
    ln_len      := 0;
    g17sname_to_line (nam, ln_len, ln);
    ln_len      := sizeof (nam) + 2;
    ln [ln_len] := ':';
    ln_len      := succ (ln_len);
    print_number := false;
    CASE qual_kind OF
        primary_only :
            msg := 'prim_only   ';
        inv_only :
            msg := 'inv_only    ';
        inv_and_primary :
            msg := 'inv and prim';
        OTHERWISE
            BEGIN
            msg          := 'QUAL_KIND=  ';
            print_number := true
            END
        END;
    (*ENDCASE*) 
    g17sname_to_line (msg, ln_len, ln);
    IF  print_number
    THEN
        g17trimint4_to_line (ord (qual_kind), ln_len, ln);
    (*ENDIF*) 
    ta01vtrace_write (ln, ln_len);
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01subq_kind (
            debug     : tgg00_Debug;
            nam       : tsp00_Sname;
            subq_kind : tgg07_SubqKind);
 
VAR
      ln_len       : integer;
      ln           : tsp00_Line;
      print_number : boolean;
      msg          : tsp00_Sname;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln          := td.blankline;
    ln_len      := 0;
    g17sname_to_line (nam, ln_len, ln);
    ln_len      := sizeof (nam) + 2;
    ln [ln_len] := ':';
    ln_len      := succ (ln_len);
    print_number := false;
    CASE subq_kind OF
        no_subquery :
            msg := 'no subq     ';
        query_in_subq :
            msg := 'query in sub';
        normal_subquery :
            msg := 'norm subq   ';
        OTHERWISE
            BEGIN
            msg          := 'SUBQ_KIND=  ';
            print_number := true
            END
        END;
    (*ENDCASE*) 
    g17sname_to_line (msg, ln_len, ln);
    IF  print_number
    THEN
        g17trimint4_to_line (ord (subq_kind), ln_len, ln);
    (*ENDIF*) 
    ta01vtrace_write (ln, ln_len);
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01distinct_kind (
            debug     : tgg00_Debug;
            nam       : tsp00_Sname;
            dist_kind : tgg04_Distinct);
 
VAR
      ln_len       : integer;
      ln           : tsp00_Line;
      print_number : boolean;
      msg          : tsp00_Name;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln          := td.blankline;
    ln_len      := 0;
    g17sname_to_line (nam, ln_len, ln);
    ln_len      := sizeof (nam) + 2;
    ln [ln_len] := ':';
    ln_len      := succ (ln_len);
    print_number := false;
    CASE dist_kind OF
        no_distinct :
            msg := 'no distinct       ';
        full_distinct :
            msg := 'full distinct     ';
        distinct_without_warning_byte :
            msg := 'dist without wbyte';
        OTHERWISE
            BEGIN
            msg          := 'DIST_KIND=        ';
            print_number := true
            END
        END;
    (*ENDCASE*) 
    g17nameto_line (msg, ln_len, ln);
    IF  print_number
    THEN
        g17trimint4_to_line (ord (dist_kind), ln_len, ln);
    (*ENDIF*) 
    ta01vtrace_write (ln, ln_len);
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01execution_kind (
            debug     : tgg00_Debug;
            nam       : tsp00_Sname;
            ex_kind   : tak_execution_kind);
 
VAR
      ln_len       : integer;
      ln           : tsp00_Line;
      print_number : boolean;
      msg          : tsp00_Name;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln          := td.blankline;
    ln_len      := 0;
    g17sname_to_line (nam, ln_len, ln);
    ln_len      := sizeof (nam) + 2;
    ln [ln_len] := ':';
    ln_len      := succ (ln_len);
    print_number := false;
    CASE ex_kind OF
        only_parsing :
            msg := 'only parsing      ';
        only_executing :
            msg := 'only executing    ';
        parsing_executing :
            msg := 'parsing executing ';
        pars_then_execute :
            msg := 'pars then execute ';
        only_syntax :
            msg := 'only syntax       ';
        OTHERWISE
            BEGIN
            msg          := 'EX_KIND=          ';
            print_number := true
            END
        END;
    (*ENDCASE*) 
    g17nameto_line (msg, ln_len, ln);
    IF  print_number
    THEN
        g17trimint4_to_line (ord (ex_kind), ln_len, ln);
    (*ENDIF*) 
    ta01vtrace_write (ln, ln_len);
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01comp_result (
            debug     : tgg00_Debug;
            nam       : tsp00_Sname;
            comp_res  : tsp00_LcompResult);
 
VAR
      ln_len       : integer;
      ln           : tsp00_Line;
      print_number : boolean;
      msg          : tsp00_Name;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln          := td.blankline;
    ln_len      := 0;
    g17sname_to_line (nam, ln_len, ln);
    ln_len      := sizeof (nam) + 2;
    ln [ln_len] := ':';
    ln_len      := succ (ln_len);
    print_number := false;
    CASE comp_res OF
        l_less :
            msg := 'less              ';
        l_equal :
            msg := 'equal             ';
        l_greater :
            msg := 'greater           ';
        l_undef :
            msg := 'undef             ';
        OTHERWISE
            BEGIN
            msg          := 'COMP_RES=         ';
            print_number := true
            END
        END;
    (*ENDCASE*) 
    g17nameto_line( msg, ln_len, ln );
    IF  print_number
    THEN
        g17trimint4_to_line( ord( comp_res ), ln_len, ln );
    (*ENDIF*) 
    ta01vtrace_write( ln, ln_len );
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01command_kind (
            debug        : tgg00_Debug;
            nam          : tsp00_Sname (*ptocSynonym const char**);
            command_kind : tak_commandkind);
 
VAR
      ln_len       : integer;
      ln           : tsp00_Line;
      print_number : boolean;
      msg          : tsp00_Name;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln          := td.blankline;
    ln_len      := 0;
    g17sname_to_line (nam, ln_len, ln);
    ln_len      := sizeof (nam) + 2;
    ln [ln_len] := ':';
    ln_len      := succ (ln_len);
    print_number := false;
    CASE command_kind OF
        single_command:
            msg := 'single cmd        ';
        complex_view_command:
            msg := 'complex view cmd  ';
        union_command:
            msg := 'union cmd         ';
        subquery_command:
            msg := 'subquery cmd      ';
        sub_in_complex_command:
            msg := 'sub in complex cmd';
        sub_in_union_command:
            msg := 'sub in union cmd  ';
        last_command:
            msg := 'last cmd          ';
        show_command:
            msg := 'show cmd          ';
        union_in_sub_command:
            msg := 'union in sub cmd  ';
        link_command:
            msg := 'link cmd          ';
        internal_create_tab_command:
            msg := 'int create tab cmd';
        corr_in_union_command:
            msg := 'corr in union cmd ';
        OTHERWISE
            BEGIN
            msg          := 'COMMAND_KIND=     ';
            print_number := true
            END
        END;
    (*ENDCASE*) 
    g17nameto_line( msg, ln_len, ln );
    IF  print_number
    THEN
        g17trimint4_to_line( ord( command_kind ), ln_len, ln );
    (*ENDIF*) 
    ta01vtrace_write( ln, ln_len );
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01corr_type (
            debug     : tgg00_Debug;
            nam       : tsp00_Sname (*ptocSynonym const char**);
            corr_type : tak_corr_type);
 
VAR
      ln_len       : integer;
      ln           : tsp00_Line;
      print_number : boolean;
      msg          : tsp00_Name;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln          := td.blankline;
    ln_len      := 0;
    g17sname_to_line (nam, ln_len, ln);
    ln_len      := sizeof (nam) + 2;
    ln [ln_len] := ':';
    ln_len      := succ (ln_len);
    print_number := false;
    CASE corr_type OF
        no_correlation:
            msg := 'no corr           ';
        correlation:
            msg := 'correlation       ';
        first_correlation:
            msg := 'first corr        ';
        lowest_of_correlation:
            msg := 'lowest of corr    ';
        having_correlation:
            msg := 'having corr       ';
        OTHERWISE
            BEGIN
            msg          := 'CORR_TYPE=        ';
            print_number := true
            END
        END;
    (*ENDCASE*) 
    g17nameto_line( msg, ln_len, ln );
    IF  print_number
    THEN
        g17trimint4_to_line( ord( corr_type ), ln_len, ln );
    (*ENDIF*) 
    ta01vtrace_write( ln, ln_len );
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01recursive_state (
            debug           : tgg00_Debug;
            nam             : tsp00_Sname (*ptocSynonym const char**);
            recursive_state : tak_recursive_state);
 
VAR
      ln_len       : integer;
      ln           : tsp00_Line;
      print_number : boolean;
      msg          : tsp00_Name;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln          := td.blankline;
    ln_len      := 0;
    g17sname_to_line (nam, ln_len, ln);
    ln_len      := sizeof (nam) + 2;
    ln [ln_len] := ':';
    ln_len      := succ (ln_len);
    print_number := false;
    CASE recursive_state OF
        rs_no_recursive_select:
            msg := 'no recursive sel  ';
        rs_recursive_select:
            msg := 'recursive select  ';
        rs_check_select_list:
            msg := 'check select list ';
        rs_first_select:
            msg := 'first select      ';
        rs_last_select:
            msg := 'last select       ';
        OTHERWISE
            BEGIN
            msg          := 'RECUR_STATE=      ';
            print_number := true
            END
        END;
    (*ENDCASE*) 
    g17nameto_line( msg, ln_len, ln );
    IF  print_number
    THEN
        g17trimint4_to_line( ord( recursive_state ), ln_len, ln );
    (*ENDIF*) 
    ta01vtrace_write( ln, ln_len );
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01columnset (
            debug           : tgg00_Debug;
            nam             : tsp00_Sname;
            columnset       : tak_columnset);
 
VAR
      _ix       : tsp00_Int2;
      _ln_len   : integer;
      _line     : tsp00_Line;
 
BEGIN
IF  t01trace( debug )
THEN
    BEGIN
    _line   := td.blankline;
    _ln_len := 0;
    g17sname_to_line( nam, _ln_len, _line );
    _ln_len := sizeof( nam ) + 2;
    _line[ _ln_len ] := ':';
    _ln_len := _ln_len + 2;
    IF  columnset = []
    THEN
        BEGIN
        g17sname_to_line( 'EMPTY       ', _ln_len, _line );
        END
    ELSE
        FOR _ix := 0 TO MAX_COL_PER_TAB_GG00 DO
            BEGIN
            IF  ( _ix in columnset )
            THEN
                BEGIN
                g17trimint4_to_line( _ix, _ln_len, _line );
                _ln_len := succ( _ln_len );
                IF  ( _ln_len > 70 ) AND ( _ix < MAX_COL_PER_TAB_GG00 )
                THEN
                    BEGIN
                    t01line( debug, _line );
                    _line   := td.blankline;
                    _ln_len := sizeof( nam ) + 4;
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    t01line( debug, _line );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01knl_identifier (
            debug      : tgg00_Debug;
            nam        : tsp00_Sname;
            identifier : tsp00_KnlIdentifier);
 
VAR
      i  : integer;
      j  : integer;
      ln : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln := td.blankline;
    i := 0;
    g17sname_to_line (nam, i, ln);
    i      := sizeof (nam) + 2;
    ln [i] := ':';
    i      := i + 2;
    IF  identifier = a01_into_res_name
    THEN
        BEGIN
        g17nameto_line( '<a01_into_res_name', i, ln );
        g17nameto_line( '>                 ', i, ln );
        END
    ELSE
        IF  identifier = a01_zero_res_name
        THEN
            BEGIN
            g17nameto_line( '<a01_zero_res_name', i, ln );
            g17nameto_line( '>                 ', i, ln );
            END
        ELSE
            IF  identifier = a01_union_fill_resname
            THEN
                BEGIN
                g17nameto_line( '<a01_union_res_nam', i, ln );
                g17nameto_line( 'e>                ', i, ln );
                END
            ELSE
                FOR j := 1 TO sizeof (identifier) DO
                    BEGIN
                    IF  g17printable_char (identifier [j])
                    THEN
                        ln [i] := identifier [j]
                    ELSE
                        ln [i] := '.';
                    (*ENDIF*) 
                    i := succ(i);
                    END;
                (*ENDFOR*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    t01write_line (ln);
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01optimize_info (
            debug           : tgg00_Debug;
            VAR stack_desc  : tgg00_StackDesc;
            data_addr       : tsp00_MoveObjPtr);
 
VAR
      _ix          : tsp00_Int2;
      _line        : tsp00_Line;
      _optimize_ptr: tsp00_MoveObjPtr;
 
BEGIN
IF  t01trace( debug ) AND ( stack_desc.mst_optimize_pos > 0 )
THEN
    BEGIN
    t01name( debug, '--optimize info-- ');
    FOR _ix := 1 TO stack_desc.mqual_cnt DO
        BEGIN
        _line := td.blankline;
        g17int4to_line( _ix, false, 5, 1, _line );
        _line[ 6 ] := '.';
        g17int4to_line( ord( data_addr^[ stack_desc.mst_optimize_pos + _ix - 1 ] ),
              false, 5, 8, _line );
        t01write_line( _line );
        END;
    (*ENDFOR*) 
    t01name( debug, '--- raw data ---- ');
    _optimize_ptr := @data_addr^[ stack_desc.mst_optimize_pos ];
    t01moveobj (kb_qual, _optimize_ptr^, 1, stack_desc.mqual_cnt);
    t01name( debug, '----------------- ');
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01catalog_entrytype (
            debug      : tgg00_Debug;
            etype      : tsp00_Char);
 
VAR
      _ln : tsp00_Line;
      _i  : integer;
 
BEGIN
IF  t01trace( debug )
THEN
    BEGIN
    _ln := td.blankline;
    _i := 0;
    g17sname_to_line( 'entry type  ', _i, _ln );
    _i        := 14;
    _ln[ _i ] := ':';
    _i        := _i + 2;
    CASE etype  OF
        '\00' :
            g17sname_to_line( 'dummy       ', _i, _ln );
        cak_ctable :
            g17sname_to_line( 'table       ', _i, _ln );
        cak_cpriv :
            g17sname_to_line( 'priv        ', _i, _ln );
        cak_cprivuser :
            g17sname_to_line( 'privuser    ', _i, _ln );
        cak_cviewtext :
            g17sname_to_line( 'viewtext    ', _i, _ln );
        cak_cviewdesc :
            g17sname_to_line( 'viewdesc    ', _i, _ln );
        cak_clinkdef :
            g17sname_to_line( 'linkdef     ', _i, _ln );
        cak_cprivproc :
            g17sname_to_line( 'privproc    ', _i, _ln );
        cak_cdefault :
            g17sname_to_line( 'entry type  ', _i, _ln );
        cak_cconstraint :
            g17sname_to_line( 'constraint  ', _i, _ln );
        cak_cforeignkey :
            g17sname_to_line( 'foreignkey  ', _i, _ln );
        cak_cprimarykey :
            g17sname_to_line( 'primarykey  ', _i, _ln );
        cak_ctrigger :
            g17sname_to_line( 'trigger     ', _i, _ln );
        cak_cconstraintname :
            g17sname_to_line( 'constr name ', _i, _ln );
        cak_calterdate :
            g17sname_to_line( 'alterdate   ', _i, _ln );
        cak_cpermmessblock :
            g17sname_to_line( 'permmessbloc', _i, _ln );
        cak_ccontainer :
            g17sname_to_line( 'container   ', _i, _ln );
        cak_cviewqual_basis :
            g17sname_to_line( 'viewqualbasi', _i, _ln );
        cak_cviewqual_join :
            g17sname_to_line( 'viewqualjoin', _i, _ln );
        cak_cviewqual_join_check :
            g17sname_to_line( 'vqualjoinchk', _i, _ln );
        cak_cviewqual_stack :
            g17sname_to_line( 'viewqualstac', _i, _ln );
        cak_cviewqual_expcol :
            g17sname_to_line( 'viewqualexpc', _i, _ln );
        cak_cviewqual_derivedcol :
            g17sname_to_line( 'viewqualderi', _i, _ln );
        cak_ctableref :
            g17sname_to_line( 'tableref    ', _i, _ln );
        cak_cuser :
            g17sname_to_line( 'user        ', _i, _ln );
        cak_cserverdb :
            g17sname_to_line( 'serverdb    ', _i, _ln );
        cak_csiteset :
            g17sname_to_line( 'siteset     ', _i, _ln );
        cak_cserverdbname :
            g17sname_to_line( 'serverdbname', _i, _ln );
        cak_cdomain :
            g17sname_to_line( 'domain      ', _i, _ln );
        cak_cusertab :
            g17sname_to_line( 'usertab     ', _i, _ln );
        cak_cusage :
            g17sname_to_line( 'usage       ', _i, _ln );
        cak_csysdba :
            g17sname_to_line( 'sysdba      ', _i, _ln );
        cak_cprocpriv :
            g17sname_to_line( 'procpriv    ', _i, _ln );
        cak_cuserref :
            g17sname_to_line( 'userref     ', _i, _ln );
        cak_cdomainref :
            g17sname_to_line( 'domainref   ', _i, _ln );
        cak_cmapset :
            g17sname_to_line( 'mapset      ', _i, _ln );
        cak_csequence :
            g17sname_to_line( 'sequence    ', _i, _ln );
        cak_csequencepriv :
            g17sname_to_line( 'sequencepriv', _i, _ln );
        cak_db2csiteset :
            g17sname_to_line( 'db2siteset  ', _i, _ln );
        cak_cuserid :
            g17sname_to_line( 'userid      ', _i, _ln );
        cak_cseqfree :
            g17sname_to_line( 'seqfree     ', _i, _ln );
        cak_cfuncref :
            g17sname_to_line( 'funcref     ', _i, _ln );
        cak_cfunccode :
            g17sname_to_line( 'funccode    ', _i, _ln );
        cak_ccomment :
            g17sname_to_line( 'comment     ', _i, _ln );
        cak_cdomainusage :
            g17sname_to_line( 'domainusage ', _i, _ln );
        cak_cstatistics :
            g17sname_to_line( 'statistics  ', _i, _ln );
        cak_cmindex :
            g17sname_to_line( 'mindex      ', _i, _ln );
        cak_croletab :
            g17sname_to_line( 'roletab     ', _i, _ln );
        cak_cmethod :
            g17sname_to_line( 'method      ', _i, _ln );
        cak_cmethodref :
            g17sname_to_line( 'methodref   ', _i, _ln );
        cak_ctype_uid :
            g17sname_to_line( 'type_uid    ', _i, _ln );
        cak_cmethodinfo :
            g17sname_to_line( 'methodinfo  ', _i, _ln );
        cak_cclassmap :
            g17sname_to_line( 'classmap    ', _i, _ln );
        cak_cversion :
            g17sname_to_line( 'version     ', _i, _ln );
        cak_cschemaref :
            g17sname_to_line( 'schemaref   ', _i, _ln );
        cak_cschema :
            g17sname_to_line( 'schema      ', _i, _ln );
        cak_ctemp :
            g17sname_to_line( 'temp        ', _i, _ln );
        cak_cparsinfo :
            g17sname_to_line( 'parseinfo   ', _i, _ln );
        cak_cjparsinfo :
            g17sname_to_line( 'jparseinfo  ', _i, _ln );
        cak_ccorrinfo :
            g17sname_to_line( 'corrinfo    ', _i, _ln );
        cak_cshortinfo :
            g17sname_to_line( 'shortinfo   ', _i, _ln );
        cak_cstratinfo :
            g17sname_to_line( 'stratinfo   ', _i, _ln );
        cak_cunionrec :
            g17sname_to_line( 'unionrec    ', _i, _ln );
        cak_cviewkey :
            g17sname_to_line( 'viewkey     ', _i, _ln );
        cak_ccomplex :
            g17sname_to_line( 'complex     ', _i, _ln );
        (* PTS 1111575 E.Z. *)
        cak_ctemppriv :
            g17sname_to_line( 'temppriv    ', _i, _ln );
        cak_cressiteinfo :
            g17sname_to_line( 'ressiteinfo ', _i, _ln );
        cak_clinkparsinfo :
            g17sname_to_line( 'linkparseinf', _i, _ln );
        cak_ctriggerparsinfo :
            g17sname_to_line( 'triggerparsi', _i, _ln );
        cak_csubtrans :
            g17sname_to_line( 'subtrans    ', _i, _ln );
        cak_cstored_cmd :
            g17sname_to_line( 'stored_cmd  ', _i, _ln );
        cak_cchangeinfos :
            g17sname_to_line( 'changeinfos ', _i, _ln );
        cak_clongliteral :
            g17sname_to_line( 'longliteral ', _i, _ln );
        cak_clogged_temp :
            g17sname_to_line( 'logged_temp ', _i, _ln );
        cak_cresult :
            g17sname_to_line( 'result      ', _i, _ln );
        cak_creskey :
            g17sname_to_line( 'reskey      ', _i, _ln );
        cak_cresname :
            g17sname_to_line( 'resname     ', _i, _ln );
        cak_ctempprocref :
            g17sname_to_line( 'tempprocref ', _i, _ln );
        cak_ctemptableref :
            g17sname_to_line( 'temptableref', _i, _ln );
        cak_ctempdefault :
            g17sname_to_line( 'tempdefault ', _i, _ln );
        cak_ctempconstraint :
            g17sname_to_line( 'tempconstrai', _i, _ln );
        cak_ctempviewdesc :
            g17sname_to_line( 'tempviewdesc', _i, _ln );
        cak_ctempscoldesc :
            g17sname_to_line( 'tempscoldesc', _i, _ln );
        cak_ctempviewtext :
            g17sname_to_line( 'tempviewtext', _i, _ln );
        cak_ctmpconstraintname :
            g17sname_to_line( 'tmpconstrnam', _i, _ln );
        cak_clinkpos :
            g17sname_to_line( 'linkpos     ', _i, _ln );
        cak_cdbprocparsinfo :
            g17sname_to_line( 'dbprocparsin', _i, _ln );
        cak_ccolnames :
            g17sname_to_line( 'colnames    ', _i, _ln );
        cak_cmessblock :
            g17sname_to_line( 'messblock   ', _i, _ln );
        cak_ccommand_info :
            g17sname_to_line( 'command_info', _i, _ln );
        cak_chint :
            g17sname_to_line( 'hint        ', _i, _ln );
        cak_cjparsinfo_joinarr :
            g17sname_to_line( 'jpars joinar', _i, _ln );
        cak_cjparsinfo_eqarr :
            g17sname_to_line( 'jpars eqarr ', _i, _ln );
        cak_cjparsinfo_table :
            g17sname_to_line( 'jpars table ', _i, _ln );
        OTHERWISE
            BEGIN
            g17sname_to_line( 'unknown     ', _i, _ln );
            END;
        END;
    (*ENDCASE*) 
    t01line( debug, _ln );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01fp_kind (
            debug   : tgg00_Debug;
            nam     : tsp00_Sname;
            fp_kind : tak_fp_kind_type_ptr);
 
VAR
      ln_len       : integer;
      ln           : tsp00_Line;
      print_number : boolean;
      msg          : tsp00_Sname;
      fp_k         : tak_fp_kind_type;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln          := td.blankline;
    ln_len      := 0;
    g17sname_to_line (nam, ln_len, ln);
    ln_len      := sizeof (nam) + 2;
    ln [ln_len] := ':';
    ln_len      := succ (ln_len);
    print_number := false;
    CASE fp_kind^ OF
        fp_catalog_column :
            msg := 'catalog col ';
        fp_result_name :
            msg := 'result name ';
        fp_current_of_key :
            msg := 'curr of key ';
        fp_escape_val :
            msg := 'escape val  ';
        fp_fill_part2_to_len :
            msg := 'fill part2  ';
        fp_ordered_select_key :
            msg := 'ord sel key ';
        fp_pseudo_ins_select :
            msg := 'psd ins sel ';
        fp_reclen :
            msg := 'reclen      ';
        fp_temp_table_key :
            msg := 'tmp tab key ';
        fp_use_old_values_up_to_len :
            msg := 'use old val ';
        fp_verify_constraint :
            msg := 'ver constr  ';
        fp_verify_view :
            msg := 'ver vire    ';
        fp_verify_not_null :
            msg := 'ver not null';
        fp_viewkey_to_mess_buf :
            msg := 'viewk to mes';
        fp_val_varcol_with_len :
            msg := 'val vcol w l';
        fp_val_all_with_len :
            msg := 'val all w l ';
        fp_val_all_without_l :
            msg := 'val all wo l';
        fp_lock_val :
            msg := 'lock val    ';
        fp_last_lock :
            msg := 'last lock   ';
        fp_selord_val_no_len :
            msg := 'selord val  ';
        fp_val_from_res_buffer :
            msg := 'val f resbuf';
        OTHERWISE
            BEGIN
            msg          := 'FP_KIND=    ';
            print_number := true
            END
        END;
    (*ENDCASE*) 
    g17sname_to_line (msg, ln_len, ln);
    IF  print_number
    THEN
        BEGIN
        fp_k := fp_kind^;
        g17trimint4_to_line (ord (fp_k), ln_len, ln);
        END;
    (*ENDIF*) 
    ta01vtrace_write (ln, ln_len);
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01showkind (
            debug     : tgg00_Debug;
            nam       : tsp00_Sname;
            show_kind : tgg00_ShowKind);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln          := td.blankline;
    ln_len      := 0;
    g17sname_to_line (nam, ln_len, ln);
    ln_len      := sizeof (nam) + 2;
    ln [ln_len] := ':';
    ln_len      := succ (ln_len);
    g17showkind_to_line( show_kind, ln_len, ln );
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta01name_bool_to_line (
            n       : tsp00_Sname;
            n_len   : integer;
            bool    : boolean;
            ln_pos  : integer;
            VAR ln  : tsp00_Line);
 
VAR
      move_err  : tgg00_BasisError;
      len       : integer;
      n_nil_pno : tsp00_Sname;
 
BEGIN
IF  n_len > sizeof(n)
THEN
    len := sizeof(n)
ELSE
    len := n_len;
(*ENDIF*) 
move_err := e_ok;
SAPDB_PascalMove ('VTA01 ',  18,    
      sizeof (n), sizeof (ln),
      @n, 1, @ln, ln_pos, len, move_err);
ln [ln_pos + n_len] := ':';
ln_pos := ln_pos + n_len + 1;
IF  bool
THEN
    g17sname_to_line ('true        ', ln_pos, ln)
ELSE
    g17sname_to_line ('false       ', ln_pos, ln);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01p2bool (
            debug : tgg00_Debug;
            nam_1 : tsp00_Sname (*ptocSynonym const char**);
            bool1 : boolean;
            nam_2 : tsp00_Sname (*ptocSynonym const char**);
            bool2 : boolean);
 
VAR
      ln : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln := td.blankline;
    ta01name_bool_to_line (nam_1, 13, bool1, 1, ln);
    ta01name_bool_to_line (nam_2, 13, bool2, SECOND_COLUMN_POS, ln);
    t01write_line (ln)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01dist_optim(
            debug       : tgg00_Debug;
            nam         : tsp00_Sname;
            dist_optim  : tsp00_Int2);
 
VAR
      ln     : tsp00_Line;
      ln_len : integer;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    ln := td.blankline;
    ln_len := 0;
    g17sname_to_line (nam, ln_len, ln);
    ln_len := sizeof(nam) + 2;
    ln[ ln_len ] := ':';
    ln_len := succ(ln_len);
    CASE dist_optim OF
        NO_DISTINCT_OPTIM_GG07 :
            g17nameto_line( 'no dist optim     ', ln_len, ln );
        AUTO_DISTINCT_OPTIM_GG07:
            g17nameto_line( 'auto dist optim   ', ln_len, ln );
        INV_DISTINCT_OPTIM_GG07:
            g17nameto_line( 'inv dist optim    ', ln_len, ln );
        OTHERWISE
            BEGIN
            g17nameto_line( 'dist optim key len', ln_len, ln );
            g17int4to_line( dist_optim, false, 5, ln_len, ln );
            END;
        END;
    (*ENDCASE*) 
    t01write_line (ln);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01fetch_desc(
            debug       : tgg00_Debug;
            nam         : tsp00_Sname;
            VAR mf_desc : tgg00_FetchDesc);
 
VAR
 
      univ_ptr : RECORD
            CASE integer OF
                1:
                    (bufaddr     : tsp00_BufAddr);
                2:
                    (data_ptr    : tgg00_DataPartPtr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01sname (debug, nam);
    t01p2bool(debug, 'm_res_build ', mf_desc.m_res_build,
          'use_inv     ', fs_use_inv in mf_desc.m_fetch_state);
    t01p2bool(debug, 'use_stop    ', fs_use_stop in mf_desc.m_fetch_state,
          'single      ', fs_single in mf_desc.m_fetch_state);
    t01p2bool  (debug, 'use_recs    ', fs_use_recs in mf_desc.m_fetch_state,
          'reverse fetc', fs_reverse_fetch in mf_desc.m_fetch_state );
    t01p2int4(debug, 'm_keylen    ', mf_desc.m_keylen,
          'm_leng      ', mf_desc.m_leng);
    t01p2int4(debug, 'm_cnt       ', mf_desc.m_cnt,
          'm_rescnt    ', mf_desc.m_rescnt);
    t01int4(debug, 'm_searched_p', mf_desc.m_searched_pages );
    t01rowno(debug, 'm_rowno     ', mf_desc.m_rowno);
    t01dist_optim(debug, 'm_dist_optim', mf_desc.m_dist_optim);
    t01qual_kind (debug, 'm_qual_kind ',    mf_desc.m_qual_kind);
    univ_ptr.data_ptr  := mf_desc.m_data;
    t01addr (debug, 'm_data      ', univ_ptr.bufaddr);
    IF  ( fs_use_inv in mf_desc.m_fetch_state )
    THEN
        t01key (debug, 'm_startkey l', mf_desc.m_startkeys.listkey);
    (*ENDIF*) 
    t01key (debug, 'm_startkey r', mf_desc.m_startkeys.reckey);
    IF  ( fs_use_inv in mf_desc.m_fetch_state )
    THEN
        t01key (debug, 'm_stopkey  l', mf_desc.m_stopkeys.listkey);
    (*ENDIF*) 
    t01key (debug, 'm_stopkey  r', mf_desc.m_stopkeys.reckey);
    IF  ( fs_use_inv in mf_desc.m_fetch_state )
    THEN
        t01key (debug, 'm_firstkey l', mf_desc.m_firstkeys.listkey);
    (*ENDIF*) 
    t01key (debug, 'm_firstkey r', mf_desc.m_firstkeys.reckey);
    IF  ( fs_use_inv in mf_desc.m_fetch_state )
    THEN
        t01key (debug, 'm_start     ', mf_desc.m_start);
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01p2real (
            debug  : tgg00_Debug;
            nam_1  : tsp00_Sname;
            real_1 : tsp00_Longreal;
            nam_2  : tsp00_Sname;
            real_2 : tsp00_Longreal;
            digits : integer);
 
VAR
      _ln   : tsp00_Line;
      _lnln : integer;
      _i    : integer;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (_ln, _lnln, nam_1);
    g17longreal_to_line(real_1, digits, _lnln, _ln);
    _lnln := _lnln + digits + 11;
    _i := _lnln;
    g17sname_to_line (nam_2, _lnln, _ln);
    _lnln := _i + sizeof(tsp00_Sname) + 3;
    _ln[ _lnln - 1 ] := ':';
    g17longreal_to_line(real_2, digits, _lnln, _ln);
    t01line( debug, _ln );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01trace_symbol(
            debug   : tgg00_Debug;
            name    : tsp00_Sname;
            symb    : tak_sc_symbol);
 
VAR
      _ln   : tsp00_Line;
      _lnln : integer;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (_ln, _lnln, name);
    CASE symb OF
        s_unknown:
            g17sname_to_line('unkown      ', _lnln, _ln);
        s_comma:
            g17sname_to_line('comma       ', _lnln, _ln);
        s_divide:
            g17sname_to_line('divide      ', _lnln, _ln);
        s_eof:
            g17sname_to_line('eof         ', _lnln, _ln);
        s_equal:
            g17sname_to_line('equal       ', _lnln, _ln);
        s_greater:
            g17sname_to_line('greater     ', _lnln, _ln);
        s_greater_or_eq:
            g17sname_to_line('greater_o_eq', _lnln, _ln);
        s_leftpar:
            g17sname_to_line('leftpar     ', _lnln, _ln);
        s_less:
            g17sname_to_line('less        ', _lnln, _ln);
        s_less_or_eq:
            g17sname_to_line('less_or_eq  ', _lnln, _ln);
        s_minus:
            g17sname_to_line('minus       ', _lnln, _ln);
        s_plus:
            g17sname_to_line('plus        ', _lnln, _ln);
        s_point:
            g17sname_to_line('point       ', _lnln, _ln);
        s_rightpar:
            g17sname_to_line('rightpar    ', _lnln, _ln);
        s_semicolon:
            g17sname_to_line('semicolon   ', _lnln, _ln);
        s_asterisk:
            g17sname_to_line('asterisk    ', _lnln, _ln);
        s_unequal:
            g17sname_to_line('unequal     ', _lnln, _ln);
        s_key:
            g17sname_to_line('key         ', _lnln, _ln);
        s_not_null:
            g17sname_to_line('not_null:   ', _lnln, _ln);
        s_ascii:
            g17sname_to_line('ascii       ', _lnln, _ln);
        s_byte:
            g17sname_to_line('byte        ', _lnln, _ln);
        s_byte_string:
            g17sname_to_line('byte_string ', _lnln, _ln);
        s_date:
            g17sname_to_line('date        ', _lnln, _ln);
        s_time:
            g17sname_to_line('time        ', _lnln, _ln);
        s_user:
            g17sname_to_line('user        ', _lnln, _ln);
        s_notin:
            g17sname_to_line('notin       ', _lnln, _ln);
        s_in:
            g17sname_to_line('in          ', _lnln, _ln);
        s_notbetween:
            g17sname_to_line('not between ', _lnln, _ln);
        s_between:
            g17sname_to_line('between     ', _lnln, _ln);
        s_default:
            g17sname_to_line('default     ', _lnln, _ln);
        s_character:
            g17sname_to_line('character   ', _lnln, _ln);
        s_fixed:
            g17sname_to_line('fixed       ', _lnln, _ln);
        s_float:
            g17sname_to_line('fload       ', _lnln, _ln);
        s_file:
            g17sname_to_line('file        ', _lnln, _ln);
        s_smallint:
            g17sname_to_line('smallint    ', _lnln, _ln);
        s_varchar:
            g17sname_to_line('varchar     ', _lnln, _ln);
        s_longvarchar:
            g17sname_to_line('longvarchar ', _lnln, _ln);
        s_integer:
            g17sname_to_line('integer     ', _lnln, _ln);
        s_fixed_point_literal:
            g17sname_to_line('fi point lit', _lnln, _ln);
        s_floating_point_literal:
            g17sname_to_line('fl point lit', _lnln, _ln);
        s_identifier:
            g17sname_to_line('identifier  ', _lnln, _ln);
        s_authid:
            g17sname_to_line('authid      ', _lnln, _ln);
        s_tablename:
            g17sname_to_line('tablename   ', _lnln, _ln);
        s_columnname:
            g17sname_to_line('colunmname  ', _lnln, _ln);
        s_parameter_name:
            g17sname_to_line('parameter na', _lnln, _ln);
        s_special_identifier:
            g17sname_to_line('spec identif', _lnln, _ln);
        s_string_literal:
            g17sname_to_line('string liter', _lnln, _ln);
        s_unsigned_integer:
            g17sname_to_line('unsigned int', _lnln, _ln);
        s_null:
            g17sname_to_line('null        ', _lnln, _ln);
        s_desc:
            g17sname_to_line('desc        ', _lnln, _ln);
        s_or:
            g17sname_to_line('or          ', _lnln, _ln);
        s_not:
            g17sname_to_line('not         ', _lnln, _ln);
        s_and:
            g17sname_to_line('and         ', _lnln, _ln);
        s_is_not_null:
            g17sname_to_line('is not null ', _lnln, _ln);
        s_is_null:
            g17sname_to_line('is null     ', _lnln, _ln);
        s_count:
            g17sname_to_line('count       ', _lnln, _ln);
        s_avg:
            g17sname_to_line('avg         ', _lnln, _ln);
        s_min:
            g17sname_to_line('min         ', _lnln, _ln);
        s_max:
            g17sname_to_line('max         ', _lnln, _ln);
        s_sum:
            g17sname_to_line('sum         ', _lnln, _ln);
        s_abs:
            g17sname_to_line('abs         ', _lnln, _ln);
        s_trunc:
            g17sname_to_line('trunc       ', _lnln, _ln);
        s_div:
            g17sname_to_line('div         ', _lnln, _ln);
        s_mod:
            g17sname_to_line('mod         ', _lnln, _ln);
        s_concat:
            g17sname_to_line('concat      ', _lnln, _ln);
        s_substr:
            g17sname_to_line('substr      ', _lnln, _ln);
        s_trim:
            g17sname_to_line('trim        ', _lnln, _ln);
        s_length:
            g17sname_to_line('length      ', _lnln, _ln);
        s_vsize:
            g17sname_to_line('vsize       ', _lnln, _ln);
        s_upper:
            g17sname_to_line('upper       ', _lnln, _ln);
        s_lower:
            g17sname_to_line('lower       ', _lnln, _ln);
        s_lpad:
            g17sname_to_line('lpad        ', _lnln, _ln);
        s_rpad:
            g17sname_to_line('rpad        ', _lnln, _ln);
        s_num:
            g17sname_to_line('num         ', _lnln, _ln);
        s_chr:
            g17sname_to_line('chr         ', _lnln, _ln);
        s_all:
            g17sname_to_line('all         ', _lnln, _ln);
        s_any:
            g17sname_to_line('any         ', _lnln, _ln);
        s_reference_name:
            g17sname_to_line('ref name    ', _lnln, _ln);
        s_asc:
            g17sname_to_line('asc         ', _lnln, _ln);
        s_all_priv:
            g17sname_to_line('all priv    ', _lnln, _ln);
        s_owner:
            g17sname_to_line('owner       ', _lnln, _ln);
        s_insert:
            g17sname_to_line('insert      ', _lnln, _ln);
        s_delete:
            g17sname_to_line('delete      ', _lnln, _ln);
        s_update:
            g17sname_to_line('update      ', _lnln, _ln);
        s_select:
            g17sname_to_line('select      ', _lnln, _ln);
        s_selupd:
            g17sname_to_line('selupd      ', _lnln, _ln);
        s_index:
            g17sname_to_line('index       ', _lnln, _ln);
        s_rfill:
            g17sname_to_line('rfill       ', _lnln, _ln);
        s_lfill:
            g17sname_to_line('lfill       ', _lnln, _ln);
        s_dis_count:
            g17sname_to_line('dis count   ', _lnln, _ln);
        s_dis_avg:
            g17sname_to_line('dis avg     ', _lnln, _ln);
        s_dis_sum:
            g17sname_to_line('dis sum     ', _lnln, _ln);
        s_vs_decimal:
            g17sname_to_line('vs decimal  ', _lnln, _ln);
        s_vs_zoned:
            g17sname_to_line('vs zoned    ', _lnln, _ln);
        s_all_count:
            g17sname_to_line('all count   ', _lnln, _ln);
        s_adddate:
            g17sname_to_line('adddate     ', _lnln, _ln);
        s_subdate:
            g17sname_to_line('subdate     ', _lnln, _ln);
        s_datediff:
            g17sname_to_line('datediff    ', _lnln, _ln);
        s_dayofweek:
            g17sname_to_line('dayofweek   ', _lnln, _ln);
        s_weekofyear:
            g17sname_to_line('weekofyear  ', _lnln, _ln);
        s_dayofyear:
            g17sname_to_line('dayofyear   ', _lnln, _ln);
        s_addtime:
            g17sname_to_line('addtime     ', _lnln, _ln);
        s_subtime:
            g17sname_to_line('subtime     ', _lnln, _ln);
        s_timediff:
            g17sname_to_line('timediff    ', _lnln, _ln);
        s_next_day:
            g17sname_to_line('next day    ', _lnln, _ln);
        s_rowno:
            g17sname_to_line('rowno       ', _lnln, _ln);
        s_maketime:
            g17sname_to_line('maketime    ', _lnln, _ln);
        s_round:
            g17sname_to_line('round       ', _lnln, _ln);
        s_mapchar:
            g17sname_to_line('mapchar     ', _lnln, _ln);
        s_usergroup:
            g17sname_to_line('usergroup   ', _lnln, _ln);
        s_packed:
            g17sname_to_line('packed      ', _lnln, _ln);
        s_binary:
            g17sname_to_line('binary      ', _lnln, _ln);
        s_makedate:
            g17sname_to_line('makedate    ', _lnln, _ln);
        s_exists:
            g17sname_to_line('exists      ', _lnln, _ln);
        s_expand:
            g17sname_to_line('expand      ', _lnln, _ln);
        s_stamp:
            g17sname_to_line('stamp       ', _lnln, _ln);
        s_mult:
            g17sname_to_line('mult        ', _lnln, _ln);
        s_like:
            g17sname_to_line('like        ', _lnln, _ln);
        s_notlike:
            g17sname_to_line('notlike     ', _lnln, _ln);
        s_sounds:
            g17sname_to_line('sounds      ', _lnln, _ln);
        s_notsounds:
            g17sname_to_line('notsounds   ', _lnln, _ln);
        s_value:
            g17sname_to_line('value       ', _lnln, _ln);
        s_func_char:
            g17sname_to_line('func char   ', _lnln, _ln);
        s_day:
            g17sname_to_line('day         ', _lnln, _ln);
        s_days:
            g17sname_to_line('days        ', _lnln, _ln);
        s_digits:
            g17sname_to_line('digits      ', _lnln, _ln);
        s_hex:
            g17sname_to_line('hex         ', _lnln, _ln);
        s_hour:
            g17sname_to_line('hour        ', _lnln, _ln);
        s_microsecond:
            g17sname_to_line('microsecond ', _lnln, _ln);
        s_minute:
            g17sname_to_line('minute      ', _lnln, _ln);
        s_month:
            g17sname_to_line('month       ', _lnln, _ln);
        s_second:
            g17sname_to_line('second      ', _lnln, _ln);
        s_timestamp:
            g17sname_to_line('timestamp   ', _lnln, _ln);
        s_year:
            g17sname_to_line('year        ', _lnln, _ln);
        s_timezone:
            g17sname_to_line('timezone    ', _lnln, _ln);
        s_alter:
            g17sname_to_line('alter       ', _lnln, _ln);
        s_outer_join:
            g17sname_to_line('outer join  ', _lnln, _ln);
        s_soundex:
            g17sname_to_line('soundex     ', _lnln, _ln);
        s_double_precision:
            g17sname_to_line('double preci', _lnln, _ln);
        s_link:
            g17sname_to_line('link        ', _lnln, _ln);
        s_number :
            g17sname_to_line('number      ', _lnln, _ln);
        s_sysdba:
            g17sname_to_line('sysdba      ', _lnln, _ln);
        s_func_date:
            g17sname_to_line('func_date   ', _lnln, _ln);
        s_func_time:
            g17sname_to_line('func_time   ', _lnln, _ln);
        s_func_timestamp:
            g17sname_to_line('func timesta', _lnln, _ln);
        s_colon:
            g17sname_to_line('colon       ', _lnln, _ln);
        s_hostfilename:
            g17sname_to_line('hostfilename', _lnln, _ln);
        s_midnight:
            g17sname_to_line('midnight    ', _lnln, _ln);
        s_graphic:
            g17sname_to_line('graphic     ', _lnln, _ln);
        s_vargraphic:
            g17sname_to_line('vargraphic  ', _lnln, _ln);
        s_long_varchar:
            g17sname_to_line('long varchar', _lnln, _ln);
        s_long_vargraphic:
            g17sname_to_line('long_vargrap', _lnln, _ln);
        s_noround:
            g17sname_to_line('noround     ', _lnln, _ln);
        s_is_true:
            g17sname_to_line('is true     ', _lnln, _ln);
        s_is_not_true:
            g17sname_to_line('is not true ', _lnln, _ln);
        s_is_false:
            g17sname_to_line('is false    ', _lnln, _ln);
        s_is_not_false:
            g17sname_to_line('is not false', _lnln, _ln);
        s_to_number:
            g17sname_to_line('to number   ', _lnln, _ln);
        s_ltrim:
            g17sname_to_line('ltrim       ', _lnln, _ln);
        s_rtrim:
            g17sname_to_line('rtrim       ', _lnln, _ln);
        s_initcap:
            g17sname_to_line('initcap     ', _lnln, _ln);
        s_translate:
            g17sname_to_line('translate   ', _lnln, _ln);
        s_replace:
            g17sname_to_line('replace     ', _lnln, _ln);
        s_ceil:
            g17sname_to_line('ceil        ', _lnln, _ln);
        s_floor:
            g17sname_to_line('floor       ', _lnln, _ln);
        s_sign:
            g17sname_to_line('sign        ', _lnln, _ln);
        s_mod_func:
            g17sname_to_line('mod func    ', _lnln, _ln);
        s_sqrt:
            g17sname_to_line('sqrt        ', _lnln, _ln);
        s_power:
            g17sname_to_line('power       ', _lnln, _ln);
        s_exp:
            g17sname_to_line('exp         ', _lnln, _ln);
        s_ln:
            g17sname_to_line('ln          ', _lnln, _ln);
        s_log:
            g17sname_to_line('log         ', _lnln, _ln);
        s_sin:
            g17sname_to_line('sin         ', _lnln, _ln);
        s_cos:
            g17sname_to_line('cos         ', _lnln, _ln);
        s_tan:
            g17sname_to_line('tan         ', _lnln, _ln);
        s_sinh:
            g17sname_to_line('sinh        ', _lnln, _ln);
        s_cosh:
            g17sname_to_line('cosh        ', _lnln, _ln);
        s_tanh:
            g17sname_to_line('tanh        ', _lnln, _ln);
        s_greatest:
            g17sname_to_line('greatest    ', _lnln, _ln);
        s_least:
            g17sname_to_line('least       ', _lnln, _ln);
        s_decode:
            g17sname_to_line('decode      ', _lnln, _ln);
        s_stddev:
            g17sname_to_line('stddev      ', _lnln, _ln);
        s_dis_stddev:
            g17sname_to_line('dis stddev  ', _lnln, _ln);
        s_variance:
            g17sname_to_line('variance    ', _lnln, _ln);
        s_dis_variance:
            g17sname_to_line('dis variance', _lnln, _ln);
        s_chr_ora:
            g17sname_to_line('chr ora     ', _lnln, _ln);
        s_hextoraw:
            g17sname_to_line('hextoraw    ', _lnln, _ln);
        s_add_months:
            g17sname_to_line('add months  ', _lnln, _ln);
        s_last_day:
            g17sname_to_line('last day    ', _lnln, _ln);
        s_months_between:
            g17sname_to_line('months betwe', _lnln, _ln);
        s_dba:
            g17sname_to_line('dba         ', _lnln, _ln);
        s_nextval:
            g17sname_to_line('nextval     ', _lnln, _ln);
        s_sequence:
            g17sname_to_line('sequence    ', _lnln, _ln);
        s_to_24_char:
            g17sname_to_line('to 24 char  ', _lnln, _ln);
        s_uid:
            g17sname_to_line('uid         ', _lnln, _ln);
        s_rowid:
            g17sname_to_line('rowid       ', _lnln, _ln);
        s_user_func:
            g17sname_to_line('user func   ', _lnln, _ln);
        s_currval:
            g17sname_to_line('currval     ', _lnln, _ln);
        s_real:
            g17sname_to_line('real        ', _lnln, _ln);
        s_new_time:
            g17sname_to_line('new time    ', _lnln, _ln);
        s_to_date:
            g17sname_to_line('to_date     ', _lnln, _ln);
        s_to_char:
            g17sname_to_line('to char     ', _lnln, _ln);
        s_old_long:
            g17sname_to_line('old long    ', _lnln, _ln);
        s_acos:
            g17sname_to_line('acos        ', _lnln, _ln);
        s_asin:
            g17sname_to_line('asin        ', _lnln, _ln);
        s_atan:
            g17sname_to_line('atan        ', _lnln, _ln);
        s_atan2:
            g17sname_to_line('atan2       ', _lnln, _ln);
        s_cot:
            g17sname_to_line('cot         ', _lnln, _ln);
        s_log10:
            g17sname_to_line('log10       ', _lnln, _ln);
        s_pi:
            g17sname_to_line('pi          ', _lnln, _ln);
        s_radians:
            g17sname_to_line('radians     ', _lnln, _ln);
        s_degrees:
            g17sname_to_line('degrees     ', _lnln, _ln);
        s_left:
            g17sname_to_line('left        ', _lnln, _ln);
        s_right:
            g17sname_to_line('right       ', _lnln, _ln);
        s_space:
            g17sname_to_line('space       ', _lnln, _ln);
        s_dayofmonth:
            g17sname_to_line('dayofmonth  ', _lnln, _ln);
        s_monthname:
            g17sname_to_line('monthname   ', _lnln, _ln);
        s_boolean:
            g17sname_to_line('boolean     ', _lnln, _ln);
        s_true:
            g17sname_to_line('true        ', _lnln, _ln);
        s_false:
            g17sname_to_line('false       ', _lnln, _ln);
        s_toidentifier:
            g17sname_to_line('toidentifier', _lnln, _ln);
        s_degree:
            g17sname_to_line('degree      ', _lnln, _ln);
        s_cast:
            g17sname_to_line('cast        ', _lnln, _ln);
        s_database:
            g17sname_to_line('database    ', _lnln, _ln);
        s_where:
            g17sname_to_line('where       ', _lnln, _ln);
        s_having:
            g17sname_to_line('having      ', _lnln, _ln);
        s_dayname:
            g17sname_to_line('dayname     ', _lnln, _ln);
        s_unicode:
            g17sname_to_line('unicode     ', _lnln, _ln);
        s_mbcs:
            g17sname_to_line('mbcs        ', _lnln, _ln);
        s_transaction:
            g17sname_to_line('transaction ', _lnln, _ln);
        s_serial:
            g17sname_to_line('serial      ', _lnln, _ln);
        s_method_call:
            g17sname_to_line('method call ', _lnln, _ln);
        s_hint:
            g17sname_to_line('hint        ', _lnln, _ln);
        s_utcdiff:
            g17sname_to_line('utcdiff     ', _lnln, _ln);
        s_utcdate:
            g17sname_to_line('utcdate     ', _lnln, _ln);
        s_get_schema:
            g17sname_to_line('get schema  ', _lnln, _ln);
        s_get_name:
            g17sname_to_line('get name    ', _lnln, _ln);
        s_case:
            g17sname_to_line('case        ', _lnln, _ln);
        OTHERWISE
            BEGIN
            g17sname_to_line('???? ord=   ', _lnln, _ln);
            g17int4to_line( ord(symb), false, 5, _lnln, _ln );
            END;
        END;
    (*ENDCASE*) 
    t01line( debug, _ln );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01trace_kw(
            debug   : tgg00_Debug;
            name    : tsp00_Sname;
            kw      : tak_keyword);
 
VAR
      _ln       : tsp00_Line;
      _lnln     : integer;
      _move_err : tgg00_BasisError;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (_ln, _lnln, name);
    _move_err := e_ok;
    SAPDB_PascalMove ('VTA01 ',  19,    
          sizeof (tak_keyword), sizeof (_ln),
          @kw, 1, @_ln, _lnln + 1, sizeof (tak_keyword), _move_err);
    IF  _move_err = e_ok
    THEN
        t01line( debug, _ln );
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01line_c60 (
            debug : tgg00_Debug;
            ln_p1 : tsp00_C60 (*ptocSynonym const char**));
 
VAR
      _ln       : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    _ln := td.blankline;
    SAPDB_PascalForcedMove( sizeof(_ln), sizeof(_ln),
          @ln_p1, 1, @_ln, 1, sizeof(ln_p1) );
    t01line( debug, _ln );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01selfields (
            debug : tgg00_Debug;
            nam   : tsp00_Sname (*ptocSynonym const char**);
            sfp   : tgg00_SelectFieldsParam);
 
VAR
      ln       : tsp00_Line;
      ln_len   : integer;
 
      univ_ptr : RECORD
            CASE integer OF
                1:
                    (bufaddr        : tsp00_BufAddr);
                2:
                    (movobjptr      : tsp00_MoveObjPtr);
                3:
                    (keyaddr        : tsp00_KeyAddr);
                4:
                    (stacklistptr   : tgg00_StackListPtr);
                5:
                    (twokeysptr     : tgg00_TwoKeysPtr);
                6:
                    (stentryptr     : tgg00_StEntryAddr);
                7:
                    (addr           : tsp00_Addr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    t01write_line (ln);
    univ_ptr.movobjptr := sfp.sfp_data_addr;
    t01addr (debug, 'data_addr   ', univ_ptr.bufaddr);
    t01addr (debug, 'rec_addr    ', sfp.sfp_rec_addr);
    univ_ptr.keyaddr := sfp.sfp_primkey_addr;
    t01addr (debug, 'primkey_addr', univ_ptr.bufaddr);
    univ_ptr.stacklistptr := sfp.sfp_work_st_addr;
    t01addr (debug, 'work_st     ', univ_ptr.bufaddr);
    univ_ptr.movobjptr := sfp.sfp_workbuf_addr;
    t01addr (debug, 'workbuf_addr', univ_ptr.bufaddr);
    univ_ptr.movobjptr := sfp.sfp_oldrec_addr;
    t01addr (debug, 'oldrec_addr ', univ_ptr.bufaddr);
    t01addr (debug, 'pl_ptr      ', sfp.sfp_pl_ptr);
    univ_ptr.movobjptr := sfp.sfp_m_result_addr;
    t01addr (debug, 'm_result_add', univ_ptr.bufaddr);
    univ_ptr.twokeysptr := sfp.sfp_m_firstkeys_addr;
    t01addr (debug, 'm_firstkeys_', univ_ptr.bufaddr);
    t01int4( debug, 'dat_size    ', sfp.sfp_data_size );
    t01int4( debug, 'work_st_size', sfp.sfp_work_st_size );
    t01int4( debug, 'workbuf_size', sfp.sfp_workbuf_size );
    t01int4( debug, 'workbuf_len ', sfp.sfp_workbuf_len );
    t01int4( debug, 'act_cntresul', sfp.sfp_act_cntresult );
    t01int4( debug, 'rows_qual   ', sfp.sfp_rows_qual );
    t01int4( debug, 'rows_read   ', sfp.sfp_rows_read );
    t01int4( debug, 'm_result_siz', sfp.sfp_m_result_size );
    t01int4( debug, 'm_result_len', sfp.sfp_m_result_len );
    t01int4( debug, 'm_result_cnt', sfp.sfp_m_result_cnt );
    t01int4( debug, 'rec_len     ', sfp.sfp_rec_len );
    t01int4( debug, 'rec_key_len ', sfp.sfp_rec_key_len );
    t01int4( debug, 'oldkey_len  ', sfp.sfp_oldkey_len );
    t01int4( debug, 'oldrec_len  ', sfp.sfp_oldrec_len );
    t01int4( debug, 'oldrec_pos  ', sfp.sfp_oldrec_pos );
    t01int4( debug, 'result_lengt', sfp.sfp_result_length );
    t01int4( debug, 'output_offse', sfp.sfp_output_offset );
    t01int4( debug, 'work_st_max ', sfp.sfp_work_st_max );
    t01int4( debug, 'resrec_maxle', sfp.sfp_resrec_maxlen );
    t01messtype( debug, 'bd_mess_type', sfp.sfp_bd_mess_type );
    t01mess2type( debug, 'bd_mess2_typ', sfp.sfp_bd_mess2_type );
    t01bool2( debug, 'check_for_re', sfp.sfp_check_for_result,
          'bd_return_kn', sfp.sfp_bd_return_knf );
    t01qual_kind (debug, 'bd_inv_only ', sfp.sfp_bd_inv_only );
    t01bool2( debug, 'bd_use_stopk', sfp.sfp_bd_use_stopkey,
          'first_qual  ', sfp.sfp_first_qual );
    t01bool( debug, 'result_wante', sfp.sfp_result_wanted );
    univ_ptr.stentryptr := sfp.sfp_work_st_top;
    t01addr (debug, 'work_st_top ', univ_ptr.bufaddr);
    univ_ptr.stentryptr := sfp.sfp_work_st_bottom;
    t01addr (debug, 'work_st_bott', univ_ptr.bufaddr);
    univ_ptr.stentryptr := sfp.sfp_work_st_last;
    t01addr (debug, 'work_st_last', univ_ptr.bufaddr);
    t01int4( debug, 'workbuf_top ', sfp.sfp_workbuf_top );
    t01bool2( debug, 'check_new_re', sfp.sfp_check_new_rec,
          'optimized   ', sfp.sfp_optimized );
    t01int4( debug, 'sqlmode     ', ord(sfp.sfp_sqlmode) );
    t01int4( debug, 'dateTimeForm', ord(sfp.sfp_dateTimeFormat) );
    univ_ptr.addr := sfp.sfp_acv_addr;
    t01addr (debug, 'acv_addr    ', univ_ptr.bufaddr);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01rowno (
            debug : tgg00_Debug;
            nam   : tsp00_Sname (*ptocSynonym const char**);
            rowno : tsp00_Int4);
 
VAR
      _line     : tsp00_Line;
      _ln_len   : integer;
 
BEGIN
_line   := td.blankline;
_ln_len := 0;
g17sname_to_line( nam, _ln_len, _line );
_line[sizeof(tsp00_Sname) + 2] := ':';
_ln_len := sizeof( tsp00_Sname ) + 3;
IF  (rowno >= cgg04_valid_rowno)
THEN
    BEGIN
    g17nameto_line( '                  ', _ln_len, _line );
    _ln_len := succ( _ln_len );
    g17trimint4_to_line( rowno, _ln_len, _line );
    END
ELSE
    BEGIN
    CASE rowno OF
        cgg04_one_record_at_most_internal:
            BEGIN
            g17nameto_line( 'one row at most   ', _ln_len, _line );
            g17nameto_line( ' internal         ', _ln_len, _line );
            END;
        cgg04_one_record_at_most_oracle:
            BEGIN
            g17nameto_line( 'one row at most   ', _ln_len, _line );
            g17nameto_line( ' oracle           ', _ln_len, _line );
            END;
        cgg04_subquery_one_record:
            g17nameto_line( 'subquery one row  ', _ln_len, _line );
        cgg04_no_rowno_predicate:
            g17nameto_line( 'no ROWNO predicate', _ln_len, _line );
        cgg04_at_least_one_record:
            g17nameto_line( 'at least one row  ', _ln_len, _line );
        OTHERWISE
            BEGIN
            g17sname_to_line( 'unknown =   ', _ln_len, _line );
            _ln_len := _ln_len + 2;
            g17trimint4_to_line( rowno, _ln_len, _line );
            END;
        END;
    (*ENDCASE*) 
    END;
(*ENDIF*) 
t01line( debug, _line );
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01refinfoindex (
            debug : tgg00_Debug;
            nam   : tsp00_Sname (*ptocSynonym const char**);
            idx   : tgg00_RefInfoIndex);
 
VAR
      _line     : tsp00_Line;
      _ln_len   : integer;
 
BEGIN
_line   := td.blankline;
_ln_len := 0;
g17sname_to_line( nam, _ln_len, _line );
_line[sizeof(tsp00_Sname) + 2] := ':';
_ln_len := sizeof( tsp00_Sname ) + 3;
CASE idx OF
    isql_commands:
        g17nameto_line( 'isql_commands     ', _ln_len, _line );
    iprepares:
        g17nameto_line( 'iprepares         ', _ln_len, _line );
    iprepares_again:
        g17nameto_line( 'iprepares_again   ', _ln_len, _line );
    iexecutes:
        g17nameto_line( 'iexecutes         ', _ln_len, _line );
    icommits:
        g17nameto_line( 'icommits          ', _ln_len, _line );
    irollbacks:
        g17nameto_line( 'irollbacks        ', _ln_len, _line );
    ilocks:
        g17nameto_line( 'ilocks            ', _ln_len, _line );
    ibegin_subtrans:
        g17nameto_line( 'ibegin_subtrans   ', _ln_len, _line );
    iend_subtrans:
        g17nameto_line( 'iend_subtrans     ', _ln_len, _line );
    irollback_subtrans:
        g17nameto_line( 'irollback_subtrans', _ln_len, _line );
    icreates:
        g17nameto_line( 'icreates          ', _ln_len, _line );
    ialters:
        g17nameto_line( 'ialters           ', _ln_len, _line );
    idrops:
        g17nameto_line( 'idrops            ', _ln_len, _line );
    iselects:
        g17nameto_line( 'iselects          ', _ln_len, _line );
    iselects_rows_read:
        g17nameto_line( 'iselects_rows_read', _ln_len, _line );
    iselects_rows_qual:
        g17nameto_line( 'iselects_rows_qual', _ln_len, _line );
    iinserts:
        g17nameto_line( 'iinserts          ', _ln_len, _line );
    iinserts_rows:
        g17nameto_line( 'iinserts_rows     ', _ln_len, _line );
    iupdates:
        g17nameto_line( 'iupdates          ', _ln_len, _line );
    iupdates_rows_read:
        g17nameto_line( 'iupdates_rows_read', _ln_len, _line );
    iupdates_rows_upd:
        g17nameto_line( 'iupdates_rows_upd ', _ln_len, _line );
    ideletes:
        g17nameto_line( 'ideletes          ', _ln_len, _line );
    ideletes_rows_read:
        g17nameto_line( 'ideletes_rows_read', _ln_len, _line );
    ideletes_rows_del:
        g17nameto_line( 'ideletes_rows_del ', _ln_len, _line );
    iinternal_dbproc_calls:
        g17nameto_line( 'iinternal_dbproc_c', _ln_len, _line );
    iexternal_dbproc_calls:
        g17nameto_line( 'iexternal_dbproc_c', _ln_len, _line );
    iinternal_trigger_calls:
        g17nameto_line( 'iinternal_trigger_', _ln_len, _line );
    iexternal_trigger_calls:
        g17nameto_line( 'iexternal_trigger_', _ln_len, _line );
    iprim_key:
        g17nameto_line( 'iprim_key         ', _ln_len, _line );
    iprim_key_read:
        g17nameto_line( 'iprim_key_read    ', _ln_len, _line );
    iprim_key_qual:
        g17nameto_line( 'iprim_key_qual    ', _ln_len, _line );
    iprim_key_range:
        g17nameto_line( 'iprim_key_range   ', _ln_len, _line );
    iprim_read_key_range:
        g17nameto_line( 'iprim_read_key_ran', _ln_len, _line );
    iprim_qual_key_range:
        g17nameto_line( 'iprim_qual_key_ran', _ln_len, _line );
    iindex:
        g17nameto_line( 'iindex            ', _ln_len, _line );
    iindex_read:
        g17nameto_line( 'iindex_read       ', _ln_len, _line );
    iindex_qual:
        g17nameto_line( 'iindex_qual       ', _ln_len, _line );
    iindex_range:
        g17nameto_line( 'iindex_range      ', _ln_len, _line );
    iindex_range_read:
        g17nameto_line( 'iindex_range_read ', _ln_len, _line );
    iindex_range_qual:
        g17nameto_line( 'iindex_range_qual ', _ln_len, _line );
    iis_index:
        g17nameto_line( 'iis_index         ', _ln_len, _line );
    iis_index_read:
        g17nameto_line( 'iis_index_read    ', _ln_len, _line );
    iis_index_qual:
        g17nameto_line( 'iis_index_qual    ', _ln_len, _line );
    iis_index_range:
        g17nameto_line( 'iis_index_range   ', _ln_len, _line );
    iis_index_read_range:
        g17nameto_line( 'iis_index_read_ran', _ln_len, _line );
    iis_index_qual_range:
        g17nameto_line( 'iis_index_qual_ran', _ln_len, _line );
    itable_scan:
        g17nameto_line( 'itable_scan       ', _ln_len, _line );
    itable_scan_read:
        g17nameto_line( 'itable_scan_read  ', _ln_len, _line );
    itable_scan_qual:
        g17nameto_line( 'itable_scan_qual  ', _ln_len, _line );
    iis_index_scan:
        g17nameto_line( 'iis_index_scan    ', _ln_len, _line );
    iis_index_scan_read:
        g17nameto_line( 'iis_index_scan_rea', _ln_len, _line );
    iis_index_scan_qual:
        g17nameto_line( 'iis_index_scan_qua', _ln_len, _line );
    imem_sorts:
        g17nameto_line( 'imem_sorts        ', _ln_len, _line );
    imem_sorts_rows_read:
        g17nameto_line( 'imem_sorts_rows_re', _ln_len, _line );
    iins_sorts:
        g17nameto_line( 'iins_sorts        ', _ln_len, _line );
    iins_sorts_rows_ins:
        g17nameto_line( 'iins_sorts_rows_in', _ln_len, _line );
    OTHERWISE
        BEGIN
        g17trimint4_to_line( ord(idx), _ln_len, _line );
        END;
    END;
(*ENDCASE*) 
t01line( debug, _line );
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01op_func (
            debug  : tgg00_Debug;
            nam    : tsp00_Sname;
            op     : tgg00_StackOpFunc);
 
VAR
      move_err : tgg00_BasisError;
      len      : integer;
      ln_len   : integer;
      n        : tsp00_Sname;
      ln       : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    g17st2op_func (op, len, n);
    move_err := e_ok;
    SAPDB_PascalMove ('VTA01 ',  20,    
          sizeof (n), sizeof (ln),
          @n, 1, @ln, ln_len + 2, len, move_err);
    t01write_line (ln)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01strat_access_mode (
            debug    : tgg00_Debug;
            nam      : tsp00_Sname;
            access   : tgg07_StratAccessModSet);
 
VAR
      ln       : tsp00_Line;
      ln_len   : integer;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    g17access_mode_set (access, ln_len, ln);
    t01write_line (ln)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01colpropset (
            debug : tgg00_Debug;
            nam : tsp00_Sname;
            s   : tak00_colpropset);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (ln, ln_len, nam);
    ln_len := ln_len - 1;
    IF  s = [ ]
    THEN
        g17sname_to_line (' empty      ', ln_len, ln)
    ELSE
        BEGIN
        IF  ctkey IN s
        THEN
            g17sname_to_line (' ctkey      ', ln_len, ln);
        (*ENDIF*) 
        IF  ctopt IN s
        THEN
            g17sname_to_line (' ctopt      ', ln_len, ln);
        (*ENDIF*) 
        IF  ctdefault IN s
        THEN
            g17sname_to_line (' ctdefault  ', ln_len, ln);
        (*ENDIF*) 
        IF  ctcomment IN s
        THEN
            g17sname_to_line (' ctcomment  ', ln_len, ln);
        (*ENDIF*) 
        IF  ctmulti IN s
        THEN
            g17sname_to_line (' ctmulti    ', ln_len, ln);
        (*ENDIF*) 
        IF  ctlink IN s
        THEN
            g17sname_to_line (' ctlink     ', ln_len, ln);
        (*ENDIF*) 
        IF  ctdropped IN s
        THEN
            g17sname_to_line (' ctdropped  ', ln_len, ln);
        (*ENDIF*) 
        IF  ctexpression IN s
        THEN
            g17sname_to_line (' ctexpressn ', ln_len, ln);
        (*ENDIF*) 
        IF  ctinvisible IN s
        THEN
            g17sname_to_line (' ctinvisible', ln_len, ln);
        (*ENDIF*) 
        IF  ctcatalog IN s
        THEN
            g17sname_to_line (' ctcatalog  ', ln_len, ln);
        (*ENDIF*) 
        IF  ctviewname IN s
        THEN
            g17sname_to_line (' ctviewname ', ln_len, ln);
        (*ENDIF*) 
        IF  ctjoinviewkey IN s
        THEN
            g17sname_to_line (' ctjoinview ', ln_len, ln);
        (*ENDIF*) 
        IF  ctdomain IN s
        THEN
            g17sname_to_line (' ctdomain   ', ln_len, ln);
        (*ENDIF*) 
        IF  ctaltered IN s
        THEN
            g17sname_to_line (' ctaltered  ', ln_len, ln);
        (*ENDIF*) 
        IF  ctserial IN s
        THEN
            g17sname_to_line (' ctserial   ', ln_len, ln);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    ta01vtrace_write (ln, ln_len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01union_kind (
            debug   : tgg00_Debug;
            nam     : tsp00_Sname;
            ukind   : tak_union_kind;
            uis_all : boolean);
 
VAR
      _ln       : tsp00_Line;
      _ln_len   : integer;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (_ln, _ln_len, nam);
    CASE ukind OF
        uis_none:
            g17sname_to_line ('none        ', _ln_len, _ln);
        uis_union:
            g17sname_to_line ('UNION       ', _ln_len, _ln);
        uis_except:
            g17sname_to_line ('EXCEPT      ', _ln_len, _ln);
        uis_intersect:
            g17sname_to_line ('INTERSECT   ', _ln_len, _ln);
        OTHERWISE
            g17sname_to_line ('!unknown!   ', _ln_len, _ln);
        END;
    (*ENDCASE*) 
    IF  ( uis_all )
    THEN
        g17sname_to_line (' ALL        ', _ln_len, _ln);
    (*ENDIF*) 
    t01write_line (_ln);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t01ttfntemp (
            debug   : tgg00_Debug;
            nam     : tsp00_Sname;
            ttfn    : tgg00_TfnTemp);
 
VAR
      _ln       : tsp00_Line;
      _ln_len   : integer;
 
BEGIN
IF  (debug = td_always) OR
    (td.debug_or_trace AND (debug in td.debugging))
THEN
    BEGIN
    t01init_line (_ln, _ln_len, nam);
    g17ttfntemp_to_line(ttfn, _ln_len, _ln);
    ta01vtrace_write (_ln, _ln_len)
    END;
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
