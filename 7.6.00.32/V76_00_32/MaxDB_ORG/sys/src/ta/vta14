/* @lastChanged: "1999-08-30"
 
 * @filename:   vta14
 * @purpose:    "TA_buf_display"
 * @release:    7.2.0.0
 * @see:        "-.-"
 *
 * @Copyright (c) 1999-2005 SAP AG"
 */
 
.tt 1 $SAP$LiveCache$VTA14$
.tt 3 $$TA_buf_display$1999-08-30$
 
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
***********************************************************
 
Module  : TA_buf_display
 
Define  :
 
        PROCEDURE
              t14bufdimension (VAR term : tut_terminal;
                    scan                : tut_diag_scan;
                    VAR bytes_per_line  : integer;
                    VAR line_size       : integer;
                    VAR lines_per_buf   : integer);
 
        PROCEDURE
              t14bufdisplay (VAR term : tut_terminal;
                    VAR protfile      : tut_vf_fileref;
                    scan              : tut_diag_scan;
                    msg               : tsp00_C30;
                    VAR buf           : tsp00_MoveObj;
                    buf_size          : tsp00_Int4;
                    startpos          : tsp00_Int4;
                    endpos            : tsp00_Int4;
                    start_numbering   : tsp00_Int4;
                    VAR break_pos     : tsp00_Int4;
                    VAR pfkey         : tut_pfkey);
 
        PROCEDURE
              t14display_msg (VAR term : tut_terminal; msg : tsp00_C20);
 
        PROCEDURE
              t14editbuf (VAR term : tut_terminal;
                    VAR protfile   : tut_vf_fileref;
                    VAR buf        : tsp00_MoveObj;
                    buf_size       : tsp00_Int4;
                    buf_offset     : tsp00_Int4;
                    VAR file_pos   : tut_file_pos;
                    edit_scan      : tut_diag_scan;
                    VAR is_saved   : boolean;
                    VAR pfkey      : tut_pfkey);
 
        PROCEDURE
              t14int4from_line (VAR term : tut_terminal;
                    VAR ln  : tsp00_Line;
                    ln_pos  : integer;
                    ln_len  : integer;
                    VAR int : tsp00_Int4;
                    VAR ok  : boolean);
 
        PROCEDURE
              t14logentry_edit (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    VAR node     : tsp00_MoveObj;
                    VAR file_pos : tut_file_pos;
                    entry_pos    : tsp00_Int4;
                    entry_length : tsp00_Int4;
                    VAR is_saved : boolean;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              t14object_edit (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    VAR node     : tsp00_MoveObj;
                    VAR file_pos : tut_file_pos;
                    obj_pos      : tsp00_Int4;
                    VAR is_saved : boolean;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              t14record_edit (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    VAR node     : tsp00_MoveObj;
                    node_size    : tsp00_Int4;
                    VAR file_pos : tut_file_pos;
                    edit_scan    : tut_diag_scan;
                    VAR is_saved : boolean;
                    VAR pfkey    : tut_pfkey);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        FUNCTION
              gg06Int4FromUint2 (Uint2 : tsp00_Uint2): tsp00_Int4;
 
        PROCEDURE
              gg06Int4ToUint2 (Int4 : tsp00_Int4;
                    VAR Uint2       : tsp00_Uint2);
 
        FUNCTION
              gg06PnoGet (VAR Cint4 : tgg90_Cint4): tsp00_Int4;
 
        PROCEDURE
              gg06PnoPut (VAR Cint4 : tgg90_Cint4; int4 : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17hexto_line (c : char;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17int4to_line (int : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_Line);
 
        PROCEDURE
              g17messtype_to_line (mess_type : tgg00_MessType;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17mess2type_to_line (mess2_type : tgg00_MessType2;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        FUNCTION
              g17printable_char (c : char) : boolean;
 
        PROCEDURE
              g17sname_to_line (n : tsp00_Sname;
                    VAR ln_len    : integer;
                    VAR ln        : tsp00_Line);
 
        PROCEDURE
              g17trimint4_to_line (int : tsp00_Int4;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              TA_terminal_IO : VTA09;
 
        PROCEDURE
              t09getcursor_line (VAR t09 : tut_terminal;
                    VAR ln    : tsp00_Line;
                    VAR pfkey : tut_pfkey);
 
        PROCEDURE
              t09get1name (VAR t09 : tut_terminal;
                    msg            : tsp00_C20;
                    msg_attr       : char;
                    in_attr        : char;
                    in_len         : integer;
                    upper_case     : boolean;
                    VAR in_name    : tsp00_Name;
                    VAR pfkey      : tut_pfkey);
 
        PROCEDURE
              t09get2name (VAR t09 : tut_terminal;
                    msg1,        msg2        : tsp00_C20;
                    msg1_attr,   msg2_attr   : char;
                    in1_attr,    in2_attr    : char;
                    in1_len,     in2_len     : integer;
                    upper_case1, upper_case2 : boolean;
                    VAR in1_name,in2_name    : tsp00_Name;
                    VAR pfkey                : tut_pfkey);
 
        PROCEDURE
              t09goto_bottom (VAR term : tut_terminal);
 
        PROCEDURE
              t09holding (VAR t09 : tut_terminal;
                    VAR pfkey     : tut_pfkey);
 
        FUNCTION
              t09is_empty_window (VAR term : tut_terminal): boolean;
 
        FUNCTION
              t09is_window_full (VAR term : tut_terminal;
                    wanted_lines: integer): boolean;
 
        PROCEDURE
              t09newscreen_page (VAR t09 : tut_terminal);
 
        PROCEDURE
              t09pfkeys (VAR term : tut_terminal; on : boolean);
 
        PROCEDURE
              t09put (VAR t09 : tut_terminal;
                    VAR text  : tsp00_Line;
                    text_attr : char);
 
        PROCEDURE
              t09put60 (VAR term : tut_terminal;
                    ln60         : tsp00_C60;
                    text_attr    : char);
 
        PROCEDURE
              t09putmsg (VAR t09      : tut_terminal;
                    VAR text          : tsp00_Line;
                    is_warning        : boolean;
                    immediate_display : boolean);
 
        PROCEDURE
              t09setpf1 (VAR term : tut_terminal; pfkey_label : tsp00_C8);
 
        FUNCTION
              t09window_cols (VAR term : tut_terminal): integer;
 
        FUNCTION
              t09unused_window_lines (VAR term : tut_terminal): integer;
 
        PROCEDURE
              t09uppercase_line (VAR ln : tsp00_Line;
                    lwb : integer;
                    upb : integer);
 
      ------------------------------ 
 
        FROM
              TA_write_protfile : VTA12;
 
        PROCEDURE
              t12write_prot (VAR fileref : tut_vf_fileref;
                    VAR ln    : tsp00_Line;
                    length    : integer;
                    VAR error : integer);
 
      ------------------------------ 
 
        FROM
              XT_logscan : VXT04;
 
        PROCEDURE
              x04afterimagehead_display (VAR term : tut_terminal;
                    VAR protfile      : tut_vf_fileref;
                    scan              : tut_diag_scan;
                    VAR buf           : tsp00_MoveObj;
                    buf_size          : tsp00_Int4;
                    entry_offset      : tsp00_Int2;
                    entry_length      : tsp00_Int4;
                    currentIOSequence : tsp00_Int4;
                    VAR pfkey         : tut_pfkey;
                    VAR ln            : tsp00_Line;
                    VAR ln_len        : integer;
                    VAR err           : integer);
 
      ------------------------------ 
 
        FROM
              XT_page_display : VXT07;
 
        PROCEDURE
              x07debug_page (VAR term : tut_terminal;
                    VAR protfile      : tut_vf_fileref;
                    header_only       : boolean;
                    VAR file_pos      : tut_file_pos;
                    VAR buf           : tsp00_MoveObj;
                    buf_size          : tsp00_Int4;
                    VAR pfkey         : tut_pfkey);
 
        PROCEDURE
              x07edit_page (VAR term : tut_terminal;
                    VAR protfile     : tut_vf_fileref;
                    VAR file_pos     : tut_file_pos;
                    VAR buf          : tsp00_MoveObj;
                    buf_size         : tsp00_Int4;
                    VAR pfkey        : tut_pfkey);
 
        PROCEDURE
              x07keys_display (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    VAR file_pos : tut_file_pos;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
      ------------------------------ 
 
        FROM
              XT_dump_display : VXT08;
 
        PROCEDURE
              x08beforeimage_edit_display (VAR term : tut_terminal;
                    VAR prot   : tut_vf_fileref;
                    scan       : tut_diag_scan;
                    VAR buf    : tsp00_MoveObj;
                    buf_size   : tsp00_Int4;
                    buf_offset : tsp00_Int4;
                    VAR pfkey  : tut_pfkey);
 
        PROCEDURE
              x08fdir_rec_edit (VAR term : tut_terminal;
                    VAR prot   : tut_vf_fileref;
                    VAR buf    : tsp00_MoveObj;
                    buf_size   : tsp00_Int4;
                    buf_offset : tsp00_Int4;
                    is_edit    : boolean;
                    VAR pfkey  : tut_pfkey);
 
        PROCEDURE
              x08obj_edit (VAR term : tut_terminal;
                    VAR prot   : tut_vf_fileref;
                    VAR buf    : tsp00_MoveObj;
                    buf_size   : tsp00_Int4;
                    buf_offset : tsp00_Int4;
                    is_edit    : boolean;
                    VAR pfkey  : tut_pfkey);
 
        PROCEDURE
              x08rec_edit (VAR term : tut_terminal;
                    VAR prot   : tut_vf_fileref;
                    VAR buf    : tsp00_MoveObj;
                    buf_size   : tsp00_Int4;
                    buf_offset : tsp00_Int4;
                    is_edit    : boolean;
                    is_catalog : boolean;
                    page_type2 : tgg00_PageType2;
                    VAR pfkey  : tut_pfkey);
 
        PROCEDURE
              x08tree_index_rec_edit (VAR term : tut_terminal;
                    VAR prot   : tut_vf_fileref;
                    VAR buf    : tsp00_MoveObj;
                    buf_size   : tsp00_Int4;
                    buf_offset : tsp00_Int4;
                    is_edit    : boolean;
                    VAR pfkey  : tut_pfkey);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedOverlappingMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : JuergenA
.sp
.cp 3
Created : 1987-04-08
.sp
.cp 3
.sp
.cp 3
Release :      Date : 1999-06-16
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.CM *-END-* specification -------------------------------
.sp 4
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
(* trace text von cccprint *)
CONST
      c_edit_lines        =  8;
      c_header_line_count =  1;
      c_int4_digits       = 10;
      c_maxbuf_block      = 10;
      c_maxbuf_lines      =  5;
      c_maxint4_string    = '2147483647';
      c_minbuf_block      = 10;
      c_minbuf_lines      =  2;
      mx_int4_displ       = 11;
      mx_maxbuf_byte      =  3;
      mx_maxbuf_prefix    =  4;
      mx_minbuf_byte      =  2;
      mx_minbuf_prefix    =  5;
      mx_pos_displ        =  5;
      mx_yes_no           =  2;
      of_col_type         =  6;
      of_first_col        = 25;
      of_key_pos          = 10;
      of_second_col       = 57;
      (* *)
      c_chr_prefix        = 'chr:';
      c_c2_prefix         = 'c2 :';
      c_c4_prefix         = 'c4 :';
      c_dec_prefix        = 'dec:';
      c_hex_prefix        = 'hex:';
      c_int2_prefix       = 'int2';
      c_int4_prefix       = 'int4';
      c_pos_prefix        = 'pos:';
      c_u2_prefix         = 'u2 :';
      (* *)
      c_pfkey_help        = 'help    ';
      c_pfkey_none        = bsp_c8;
      (* *)
      c_bool_indicator    = 'B';
      c_int_indicator     = 'I';
      c_minbuf_indicator  = '@';
      c_mtype_indicator   = 'M';
      c_mtype2_indicator  = 'N';
      c_set_indicator     = 'S';
      (* *)
      msg_illegal_len     = 'ILLEGAL LENGTH      ';
      msg_illegal_pos     = 'ILLEGAL POSITION    ';
      (* *)
      c_edit        = true;
      c_header_only = true;
      c_immed_displ = true;
      c_on          = true;
      c_upper       = true;
      c_warning     = true;
      c_with_zero   = true;
 
TYPE
 
      hexbuf_line = RECORD
            CASE integer OF
                1:
                    (ln : tsp00_Line);
                2:
                    (prefix : tsp00_C4)
                END;
            (*ENDCASE*) 
 
 
      int_map_c4 = RECORD
            CASE boolean OF
                TRUE:
                    (map_i4 : tsp00_Int4);
                FALSE:
                    (map_c4 : tsp00_C4)
                END;
            (*ENDCASE*) 
 
 
 
(*------------------------------*) 
 
PROCEDURE
      t14bufdimension (VAR term : tut_terminal;
            scan                : tut_diag_scan;
            VAR bytes_per_line  : integer;
            VAR line_size       : integer;
            VAR lines_per_buf   : integer);
 
BEGIN
IF  utds_minbuf in scan
THEN
    BEGIN
    lines_per_buf  := c_minbuf_lines;
    bytes_per_line :=
          (((t09window_cols (term) - mx_minbuf_prefix)
          DIV mx_minbuf_byte)
          DIV c_minbuf_block) * c_minbuf_block;
    IF  mx_minbuf_prefix
        + bytes_per_line * mx_minbuf_byte
        + ((bytes_per_line - 1) DIV c_minbuf_block) (*block delimiter*)
        > t09window_cols (term)
    THEN
        bytes_per_line := bytes_per_line - c_minbuf_block;
    (*ENDIF*) 
    line_size :=
          mx_minbuf_prefix
          + bytes_per_line * mx_minbuf_byte
          + ((bytes_per_line - 1) DIV c_minbuf_block)
    END
ELSE
    BEGIN
    lines_per_buf := c_maxbuf_lines;
    IF  utds_double_numbering in scan
    THEN
        lines_per_buf := lines_per_buf + 1;
    (*ENDIF*) 
    bytes_per_line :=
          (((t09window_cols (term) - mx_maxbuf_prefix)
          DIV mx_maxbuf_byte)
          DIV c_maxbuf_block) * c_maxbuf_block;
    line_size :=
          mx_maxbuf_prefix
          + bytes_per_line * mx_maxbuf_byte
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t14bufdisplay (VAR term : tut_terminal;
            VAR protfile      : tut_vf_fileref;
            scan              : tut_diag_scan;
            msg               : tsp00_C30;
            VAR buf           : tsp00_MoveObj;
            buf_size          : tsp00_Int4;
            startpos          : tsp00_Int4;
            endpos            : tsp00_Int4;
            start_numbering   : tsp00_Int4;
            VAR break_pos     : tsp00_Int4;
            VAR pfkey         : tut_pfkey);
 
CONST
      min_char_count = 3;
 
VAR
      skip_output    : boolean;
      last_skipped   : boolean;
      is_blank       : boolean;
      blank_only     : boolean;
      vt_attr        : char;
      cint4          : tgg90_Cint4;
      upb            : tsp00_Int4;
      buf_pos        : tsp00_Int4;
      numb_pos       : tsp00_Int4;
      out_pos        : tsp00_Int4;
      pos_displ      : tsp00_Int4;
      skip_numb_pos  : tsp00_Int4;
      dummy_int      : integer;
      line_size      : integer;
      lines_per_buf  : integer;
      ln_len         : integer;
      i              : integer;
      err            : integer;
      bytes_per_line : integer;
      byte_count     : tsp00_Int4;
      char_count     : tsp00_Int4;
      prev_char_cnt  : tsp00_Int4;
      i2             : tsp00_IntMapC2;
      i4             : int_map_c4;
      i4_overflow    : int_map_c4;
      chrline        : hexbuf_line;
      c2_line        : hexbuf_line;
      c4_line        : hexbuf_line;
      decline        : hexbuf_line;
      hexline        : hexbuf_line;
      int2_line      : hexbuf_line;
      int4_line      : hexbuf_line;
      posline        : hexbuf_line;
      posline_2      : hexbuf_line;
      spaceline      : tsp00_Line;
      u2_line        : hexbuf_line;
      odd_bytecount  : boolean;
 
BEGIN
break_pos := 0;
pfkey     := pf_none;
IF  utds_edit in scan
THEN
    BEGIN
    vt_attr := cut_unprotected;
    ta14edit_bufdimension (term, buf_size - startpos + start_numbering,
          dummy_int, bytes_per_line, line_size, lines_per_buf);
    i4_overflow.map_i4 := -MAX_INT4_SP00;
    FOR i := 1 TO 4 DO
        IF  i4_overflow.map_c4 [i] = chr(1)
        THEN
            i4_overflow.map_c4 [i] := chr(0)
        (*ENDIF*) 
    (*ENDFOR*) 
    END
ELSE
    BEGIN
    vt_attr := cut_protected;
    t14bufdimension (term, scan, bytes_per_line, line_size,
          lines_per_buf)
    END;
(*ENDIF*) 
IF  (startpos < 1) OR (startpos > buf_size)
THEN
    BEGIN
    buf_pos := 1;
    upb     := bytes_per_line
    END
ELSE
    BEGIN
    buf_pos := startpos;
    IF  (endpos < startpos) OR (endpos > buf_size)
    THEN
        upb := buf_size
    ELSE
        upb := endpos
    (*ENDIF*) 
    END;
(*ENDIF*) 
numb_pos := start_numbering;
IF  utds_edit in scan
THEN
    BEGIN
    t09put (term, term.blankline, cut_protected);
    t12write_prot (protfile, term.blankline, 1, err)
    END
ELSE
    BEGIN
    chrline.ln := term.blankline;
    ln_len     := 0;
    g17sname_to_line ('BUFFER FROM ', ln_len, chrline.ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (numb_pos, ln_len, chrline.ln);
    g17sname_to_line (' TO         ', ln_len, chrline.ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (numb_pos + upb - buf_pos, ln_len, chrline.ln);
    IF  (utds_double_numbering in scan)
        AND
        NOT (utds_minbuf in scan)
    THEN
        BEGIN
        g17sname_to_line (' (FROM      ', ln_len, chrline.ln);
        ln_len := ln_len + 1;
        g17trimint4_to_line (buf_pos, ln_len, chrline.ln);
        g17sname_to_line (' TO         ', ln_len, chrline.ln);
        ln_len := ln_len + 1;
        g17trimint4_to_line (upb, ln_len, chrline.ln);
        ln_len := ln_len + 1;
        chrline.ln [ln_len] := ')'
        END;
    (*ENDIF*) 
    IF  buf_pos <> startpos
    THEN
        BEGIN
        g17sname_to_line ('   *** from ', ln_len, chrline.ln);
        ln_len := ln_len + 1;
        g17trimint4_to_line (startpos, ln_len, chrline.ln)
        END;
    (*ENDIF*) 
    IF  upb <> endpos
    THEN
        BEGIN
        g17sname_to_line ('   *** to   ', ln_len, chrline.ln);
        ln_len := ln_len + 1;
        g17trimint4_to_line (endpos, ln_len, chrline.ln)
        END;
    (*ENDIF*) 
    IF  ((utds_minbuf in scan               ) OR
        ( upb - buf_pos + 1 < bytes_per_line))
        AND
        (msg = bsp_c30)
    THEN
        posline := chrline
    ELSE
        BEGIN
        posline.ln := term.blankline;
        IF  msg = bsp_c30
        THEN
            SAPDB_PascalForcedMove (sizeof (chrline.ln), sizeof (posline.ln),
                  @chrline.ln, 1, @posline.ln, line_size-ln_len+1, ln_len)
        ELSE
            BEGIN
            SAPDB_PascalForcedMove (sizeof (msg), sizeof (posline.ln), @msg, 1,
                  @posline.ln, 1, sizeof (msg));
            IF  upb - buf_pos >= bytes_per_line
            THEN
                SAPDB_PascalForcedMove (sizeof (chrline.ln), sizeof (posline.ln),
                      @chrline.ln, 1,
                      @posline.ln, line_size - ln_len + 1, ln_len)
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    t12write_prot (protfile, posline.ln, sizeof (posline.ln), err);
    IF  utds_display in scan
    THEN
        BEGIN
        IF  msg = bsp_c30
        THEN
            t09put (term, posline.ln, cut_protected)
        ELSE
            t09put (term, posline.ln, cut_bright_protected)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
last_skipped  := false;
prev_char_cnt := 0;
char_count    := 0;
blank_only    := true;
REPEAT
    skip_output := false;
    IF  (buf_pos > startpos) AND (buf_pos + bytes_per_line - 1 < upb)
        AND NOT (utds_edit in scan)
    THEN
        BEGIN
        i := buf_pos;
        skip_output := true;
        REPEAT
            IF  buf [i-bytes_per_line] <> buf [i]
            THEN
                skip_output := false;
            (*ENDIF*) 
            i := i + 1
        UNTIL
            NOT skip_output OR (i >= buf_pos + bytes_per_line)
        (*ENDREPEAT*) 
        END;
    (*ENDIF*) 
    IF  skip_output AND NOT last_skipped
    THEN
        BEGIN
        last_skipped  := true;
        skip_numb_pos := numb_pos
        END;
    (*ENDIF*) 
    IF  skip_output
    THEN
        BEGIN
        buf_pos  := buf_pos  + bytes_per_line;
        numb_pos := numb_pos + bytes_per_line
        END
    ELSE
        IF  last_skipped
            OR
            (   NOT (utds_minbuf in scan)
            AND NOT (utds_edit   in scan)
            AND     (buf_pos > startpos )
            AND     (blank_only OR (char_count = 0)) )
        THEN
            (* write number of skipped bytes  OR  write blank line *)
            BEGIN
            IF  (utds_display in scan)
                AND
                t09is_window_full (term, 1 + lines_per_buf)
            THEN
                BEGIN
                t09holding (term, pfkey);
                IF  pfkey = pf_none
                THEN
                    t09newscreen_page (term);
                (*ENDIF*) 
                IF  pfkey <> pf_none
                THEN
                    break_pos := buf_pos
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  last_skipped AND (pfkey = pf_none)
            THEN
                BEGIN
                last_skipped := false;
                chrline.ln   := term.blankline;
                ln_len       := 0;
                g17sname_to_line   ('     ...    ', ln_len, chrline.ln);
                ln_len := ln_len + 1;
                g17trimint4_to_line (skip_numb_pos, ln_len, chrline.ln);
                g17sname_to_line   (' TO         ', ln_len, chrline.ln);
                ln_len := ln_len + 1;
                g17trimint4_to_line (numb_pos-1,    ln_len, chrline.ln);
                IF  (utds_double_numbering in scan)
                    AND
                    NOT (utds_minbuf in scan)
                THEN
                    BEGIN
                    ln_len := ln_len + 2;
                    chrline.ln [ln_len] := '(';
                    g17trimint4_to_line (buf_pos - numb_pos
                          + skip_numb_pos, ln_len, chrline.ln);
                    g17sname_to_line (' TO         ',
                          ln_len, chrline.ln);
                    ln_len := ln_len + 1;
                    g17trimint4_to_line (buf_pos-1, ln_len, chrline.ln);
                    ln_len := ln_len + 1;
                    chrline.ln [ln_len] := ')'
                    END;
                (*ENDIF*) 
                t12write_prot (protfile, chrline.ln, ln_len, err);
                IF  (pfkey = pf_none) AND (utds_display in scan)
                THEN
                    t09put (term, chrline.ln, cut_protected);
                (*ENDIF*) 
                END
            ELSE
                IF  pfkey = pf_none
                THEN
                    BEGIN
                    t12write_prot (protfile, term.blankline, 1, err);
                    IF  (utds_display in scan)
                        AND NOT t09is_empty_window (term)
                    THEN
                        t09put (term, term.blankline, cut_protected)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  NOT skip_output AND (pfkey = pf_none)
    THEN
        BEGIN
        hexline.ln := term.blankline;
        chrline.ln := term.blankline;
        IF  utds_minbuf in scan
        THEN
            BEGIN
            g17int4to_line (numb_pos, NOT c_with_zero,
                  mx_minbuf_prefix, 1, chrline.ln);
            out_pos := mx_minbuf_prefix + 1
            END
        ELSE
            BEGIN
            out_pos          := mx_maxbuf_prefix + 1;
            posline.ln       := term.blankline;
            posline_2.ln     := term.blankline;
            decline.ln       := term.blankline;
            posline.prefix   := c_pos_prefix;
            decline.prefix   := c_dec_prefix;
            hexline.prefix   := c_hex_prefix;
            chrline.prefix   := c_chr_prefix;
            IF  utds_edit in scan
            THEN
                BEGIN
                c2_line.ln       := term.blankline;
                c4_line.ln       := term.blankline;
                int2_line.ln     := term.blankline;
                int4_line.ln     := term.blankline;
                spaceline        := term.blankline;
                u2_line.ln       := term.blankline;
                c2_line.prefix   := c_c2_prefix;
                c4_line.prefix   := c_c4_prefix;
                int2_line.prefix := c_int2_prefix;
                int4_line.prefix := c_int4_prefix;
                u2_line.prefix   := c_u2_prefix
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        byte_count := 0;
        char_count := 0;
        blank_only := true;
        REPEAT
            byte_count := byte_count + 1;
            IF  NOT (utds_minbuf in scan)
            THEN
                BEGIN
                IF  utds_edit in scan
                THEN
                    BEGIN
                    IF  byte_count = 1
                    THEN
                        BEGIN
                        int2_line.ln [out_pos] := ':';
                        int4_line.ln [out_pos] := ':'
                        END;
                    (*ENDIF*) 
                    out_pos := out_pos + 1;
                    IF  byte_count > 1
                    THEN
                        BEGIN
                        posline.ln    [out_pos] := '|';
                        posline_2.ln  [out_pos] := '|';
                        decline.ln    [out_pos] := '|';
                        hexline.ln    [out_pos] := '|';
                        chrline.ln    [out_pos] := '|';
                        spaceline     [out_pos] := '+';
                        IF  byte_count MOD 2 = 1
                        THEN
                            BEGIN
                            c2_line.ln   [out_pos] := '|';
                            u2_line.ln   [out_pos] := '|';
                            int2_line.ln [out_pos] := '|'
                            END;
                        (*ENDIF*) 
                        IF  byte_count MOD 4 = 1
                        THEN
                            BEGIN
                            c4_line.ln   [out_pos] := '|';
                            int4_line.ln [out_pos] := '|'
                            END;
                        (*ENDIF*) 
                        out_pos := out_pos + 1
                        END;
                    (*ENDIF*) 
                    IF  numb_pos < 1000
                    THEN
                        i := 3
                    ELSE
                        i := 4;
                    (*ENDIF*) 
                    IF  buf_size - startpos + start_numbering >= 10000
                    THEN
                        i := i + 1;
                    (*ENDIF*) 
                    g17int4to_line (numb_pos, NOT c_with_zero, i,
                          out_pos, posline.ln);
                    IF  utds_double_numbering in scan
                    THEN
                        BEGIN
                        IF  buf_pos < 1000
                        THEN
                            i := 3
                        ELSE
                            i := 4;
                        (*ENDIF*) 
                        IF  buf_size >= 10000
                        THEN
                            i := i + 1;
                        (*ENDIF*) 
                        g17int4to_line (buf_pos, NOT c_with_zero, i,
                              out_pos, posline_2.ln)
                        END;
                    (*ENDIF*) 
                    IF  buf_size >= 10000
                    THEN
                        BEGIN
                        spaceline [out_pos] := '-';
                        out_pos := out_pos + 1
                        END;
                    (*ENDIF*) 
                    spaceline [out_pos  ] := '-';
                    spaceline [out_pos+1] := '-';
                    spaceline [out_pos+2] := '-';
                    spaceline [out_pos+3] := '-';
                    END
                ELSE
                    (* maxbuf *)
                    BEGIN
                    IF  byte_count = 1
                    THEN
                        BEGIN
                        IF  (numb_pos < 1000)
                            AND NOT (utds_double_numbering in scan)
                        THEN
                            g17int4to_line (numb_pos, NOT c_with_zero,
                                  mx_maxbuf_byte, out_pos, posline.ln)
                        ELSE
                            g17int4to_line (numb_pos, NOT c_with_zero,
                                  mx_maxbuf_prefix + mx_maxbuf_byte, 1,
                                  posline.ln)
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  (numb_pos < 100)
                            OR
                            (byte_count MOD 2 = 1)
                        THEN
                            BEGIN
                            IF  numb_pos < 1000
                            THEN
                                pos_displ := numb_pos
                            ELSE
                                pos_displ := numb_pos MOD 1000;
                            (*ENDIF*) 
                            g17int4to_line (pos_displ,
                                  (numb_pos >= 1000),
                                  mx_maxbuf_byte, out_pos, posline.ln)
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  utds_double_numbering in scan
                    THEN
                        BEGIN
                        IF  byte_count = 1
                        THEN
                            g17int4to_line (buf_pos, NOT c_with_zero,
                                  mx_maxbuf_prefix + mx_maxbuf_byte, 1,
                                  posline_2.ln)
                        ELSE
                            IF  (buf_pos < 100)
                                OR
                                (byte_count MOD 2 = 1)
                            THEN
                                BEGIN
                                IF  buf_pos < 1000
                                THEN
                                    pos_displ := buf_pos
                                ELSE
                                    pos_displ := buf_pos MOD 1000;
                                (*ENDIF*) 
                                g17int4to_line (pos_displ,
                                      (buf_pos >= 1000),
                                      mx_maxbuf_byte, out_pos,
                                      posline_2.ln)
                                END
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                g17int4to_line (ord (buf [buf_pos]), NOT c_with_zero, 3,
                      out_pos, decline.ln);
                END
            ELSE
                (* minbuf without blank space *)
                out_pos := out_pos - 1;
            (*ENDIF*) 
            ;
            (* edit, minbuf, maxbuf *)
            ln_len := out_pos;
            g17hexto_line (buf [buf_pos], ln_len, hexline.ln);
            IF  g17printable_char (buf [buf_pos])
            THEN
                chrline.ln [out_pos+2] := buf [buf_pos]
            ELSE
                IF  utds_minbuf in scan
                THEN
                    BEGIN
                    odd_bytecount := (byte_count MOD  2) = 1;
                    IF  odd_bytecount AND
                        (byte_count MOD 10 <> 1)
                    THEN
                        chrline.ln [out_pos+1] := '|'
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  utds_edit in scan
            THEN
                BEGIN
                IF  byte_count MOD 2 = 0
                THEN
                    BEGIN
                    cint4.ci4_gg00 [1] := chr (0);
                    cint4.ci4_gg00 [2] := chr (0);
                    cint4.ci4_gg00 [3] := buf [buf_pos-1];
                    cint4.ci4_gg00 [4] := buf [buf_pos  ];
                    (* *)
                    i2.mapC2_sp00 [1] := buf [buf_pos-1];
                    i2.mapC2_sp00 [2] := buf [buf_pos  ];
                    (* *)
                    g17int4to_line (gg06Int4FromUint2 (i2.mapInt_sp00),
                          NOT c_with_zero, 6, out_pos-3, u2_line.ln);
                    g17int4to_line (gg06PnoGet (cint4),
                          NOT c_with_zero, 6, out_pos-3, c2_line.ln);
                    g17int4to_line (i2.mapInt_sp00,
                          NOT c_with_zero, 6, out_pos-3, int2_line.ln)
                    END;
                (*ENDIF*) 
                IF  byte_count MOD 4 = 0
                THEN
                    BEGIN
                    FOR i := 1 TO 4 DO
                        i4.map_c4 [i] := buf [buf_pos-4+i];
                    (*ENDFOR*) 
                    cint4.ci4_gg00 := i4.map_c4;
                    IF  i4.map_c4 = i4_overflow.map_c4
                    THEN
                        BEGIN
                        int4_line.ln [out_pos-1] := '-';
                        int4_line.ln [out_pos  ] := '.';
                        int4_line.ln [out_pos+1] := '-'
                        END
                    ELSE
                        g17int4to_line (i4.map_i4,
                              NOT c_with_zero, 12, out_pos-9, int4_line.ln);
                    (*ENDIF*) 
                    IF  gg06PnoGet (cint4) >= 0
                    THEN
                        g17int4to_line (gg06PnoGet (cint4),
                              NOT c_with_zero, 12, out_pos-9, c4_line.ln)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  utds_minbuf in scan
            THEN
                BEGIN
                out_pos := 1 + out_pos + mx_minbuf_byte;
                IF  byte_count MOD 10 = 0
                THEN
                    out_pos := out_pos + 1
                (*ENDIF*) 
                END
            ELSE
                out_pos := out_pos + mx_maxbuf_byte;
            (*ENDIF*) 
            buf_pos  := buf_pos  + 1;
            numb_pos := numb_pos + 1
        UNTIL
            (byte_count >= bytes_per_line) OR (buf_pos > upb);
        (*ENDREPEAT*) 
        IF  (utds_display in scan)
            AND
            t09is_window_full (term, lines_per_buf)
        THEN
            BEGIN
            t09holding (term, pfkey);
            IF  pfkey = pf_none
            THEN
                t09newscreen_page (term);
            (*ENDIF*) 
            IF  pfkey <> pf_none
            THEN
                break_pos := buf_pos
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (pfkey = pf_none) AND (utds_display in scan)
        THEN
            BEGIN
            IF  NOT (utds_minbuf in scan)
            THEN
                BEGIN
                t09put (term, posline.ln, cut_protected);
                IF  utds_double_numbering in scan
                THEN
                    t09put (term, posline_2.ln, cut_protected);
                (*ENDIF*) 
                IF  utds_edit in scan
                THEN
                    t09put (term, spaceline, cut_protected);
                (*ENDIF*) 
                t09put (term, decline.ln, vt_attr);
                END;
            (*ENDIF*) 
            t09put (term, hexline.ln, vt_attr);
            t09put (term, chrline.ln, vt_attr);
            END;
        (*ENDIF*) 
        IF  pfkey = pf_none
        THEN
            BEGIN
            IF  utds_edit in scan
            THEN
                BEGIN
                t09put (term, c2_line.ln,   vt_attr);
                t09put (term, u2_line.ln,   vt_attr);
                t09put (term, int2_line.ln, vt_attr);
                t09put (term, c4_line.ln,   vt_attr);
                t09put (term, int4_line.ln, vt_attr)
                END;
            (*ENDIF*) 
            IF  utds_minbuf in scan
            THEN
                BEGIN
                hexline.ln [2] := c_minbuf_indicator;
                hexline.ln [3] := c_minbuf_indicator
                END
            ELSE
                BEGIN
                t12write_prot (protfile, posline.ln, out_pos-1,err);
                IF  utds_double_numbering in scan
                THEN
                    t12write_prot (protfile, posline_2.ln,
                          out_pos-1, err);
                (*ENDIF*) 
                t12write_prot (protfile, decline.ln, out_pos-1,err)
                END;
            (*ENDIF*) 
            t12write_prot (protfile, hexline.ln, out_pos-1, err);
            t12write_prot (protfile, chrline.ln, out_pos-1, err);
            IF  utds_edit in scan
            THEN
                BEGIN
                t12write_prot (protfile, c2_line.ln,   out_pos-1, err);
                t12write_prot (protfile, u2_line.ln,   out_pos-1, err);
                t12write_prot (protfile, int2_line.ln, out_pos-1, err);
                t12write_prot (protfile, c4_line.ln,   out_pos-1, err);
                t12write_prot (protfile, int4_line.ln, out_pos-1, err)
                END;
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
UNTIL
    (buf_pos > upb) OR (pfkey <> pf_none)
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t14display_msg (VAR term : tut_terminal; msg : tsp00_C20);
 
VAR
      ln : tsp00_Line;
 
BEGIN
ln := term.blankline;
SAPDB_PascalForcedMove (sizeof (msg), sizeof (ln), @msg, 1, @ln, 1, sizeof (msg));
t09putmsg (term, ln, c_warning, NOT c_immed_displ)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t14editbuf (VAR term : tut_terminal;
            VAR protfile   : tut_vf_fileref;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR file_pos   : tut_file_pos;
            edit_scan      : tut_diag_scan;
            VAR is_saved   : boolean;
            VAR pfkey      : tut_pfkey);
 
VAR
      is_ok          : boolean;
      is_quit        : boolean;
      is_cmd         : boolean;
      is_locate_cmd  : boolean;
      pfkeys_used    : boolean;
      indicator      : char;
      scan           : tut_diag_scan;
      c              : char;
      dummy_err      : integer;
      cint4          : tgg90_Cint4;
      i              : tsp00_Int4;
      lwb            : tsp00_Int4;
      upb            : tsp00_Int4;
      type_upb       : tsp00_Int4;
      dummy_pos      : tsp00_Int4;
      dummy_size     : integer;
      bytes_per_line : integer;
      char_per_byte  : integer;
      curr_col       : integer;
      curr_col_len   : integer;
      col_type_pos   : integer;
      lines_per_buf  : integer;
      minbuf_bytes   : integer;
      minbuf_lines   : integer;
      byte_offset    : integer;
      i2             : tsp00_IntMapC2;
      i4             : int_map_c4;
      int_4          : tsp00_Int4;
      new_lwb        : tsp00_Int4;
      bool_value     : tsp00_C6;
      mtype_value    : tsp00_Name;
      in_line        : hexbuf_line;
      node_ptr       : tbd_nodeptr;
      ln             : tsp00_Line;
      ln_len         : integer;
      err            : integer;
 
BEGIN
lwb       := buf_offset + 1;
is_saved  := false;
is_quit   := false;
t14bufdimension (term, [utds_minbuf],
      minbuf_bytes, dummy_size, minbuf_lines);
ta14edit_bufdimension (term, buf_size, char_per_byte,
      bytes_per_line, dummy_size, lines_per_buf);
pfkeys_used := term.use_pfkeys;
t09pfkeys (term, NOT c_on);
REPEAT
    is_ok := false;
    IF  buf_size > lwb + bytes_per_line - 1
    THEN
        upb := lwb + bytes_per_line - 1
    ELSE
        upb := buf_size;
    (*ENDIF*) 
    REPEAT
        is_cmd        := false;
        is_locate_cmd := false;
        t09newscreen_page (term);
        IF  edit_scan <> [ ]
        THEN
            t12write_prot (protfile, term.blankline, 1, dummy_err);
        (*ENDIF*) 
        IF  utds_page_header in edit_scan
        THEN
            x07edit_page (term, protfile, file_pos, buf, buf_size, pfkey)
        ELSE
            IF  utds_rec in edit_scan
            THEN
                BEGIN
                node_ptr := @buf;
                IF  (node_ptr^.nd_pt = ptData_egg00)
                    AND
                    ((node_ptr^.nd_pt2 = pt2Tab_egg00       ) OR     (* PTS 1103799 JA 1999-08-30 *)
                    ( node_ptr^.nd_pt2 = pt2Inv_egg00       ) OR
                    ( node_ptr^.nd_pt2 = pt2InvSubtree_egg00))
                THEN
                    BEGIN
                    IF  (pmFdir_egg00 in node_ptr^.nd_pmode) AND (node_ptr^.nd_level = LEAF_LEVEL_BD00)
                    THEN
                        x08fdir_rec_edit (term, protfile, buf, buf_size, buf_offset, c_edit, pfkey)
                    ELSE
                        IF  node_ptr^.nd_level = LEAF_LEVEL_BD00
                        THEN
                            x08rec_edit (term, protfile, buf, buf_size, buf_offset, c_edit,
                                  (pmCatalog_egg00 in node_ptr^.nd_pmode), node_ptr^.nd_pt2, pfkey)
                        ELSE
                            x08tree_index_rec_edit (term, protfile, buf, buf_size, buf_offset,
                                  c_edit, pfkey)
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    IF  (node_ptr^.nd_pt = ptData_egg00)
                        AND
                        ((node_ptr^.nd_pt2 = pt2Object_egg00      ) OR
                        ( node_ptr^.nd_pt2 = pt2VarObject_egg00   ) OR
                        ( node_ptr^.nd_pt2 = pt2ContObject_egg00  ))
                    THEN
                        x08obj_edit (term, protfile, buf, buf_size, buf_offset, c_edit, pfkey);
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  (node_ptr^.nd_pt = ptData_egg00)
                    AND
                    (node_ptr^.nd_pt2 = pt2UndoLog_egg00)
                THEN
                    x08beforeimage_edit_display (term, protfile, edit_scan,
                          buf, buf_size, buf_offset, pfkey);
                (*ENDIF*) 
                IF  (node_ptr^.nd_pt = ptLog_egg00)
                    OR
                    ((node_ptr^.nd_pt = ptData_egg00)
                    AND
                    (node_ptr^.nd_pt2 = pt2RedoLog_egg00))
                THEN
                    x04afterimagehead_display (term, protfile, edit_scan,
                          buf, buf_size, buf_offset, buf_size-buf_offset,
                          -1, pfkey,
                          ln, ln_len, err);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  t09is_window_full (term, 1 + c_edit_lines + 1)
        THEN
            BEGIN
            t09holding (term, pfkey);
            IF  pfkey = pf_none
            THEN
                BEGIN
                t09newscreen_page (term);
                IF  utds_page_header in edit_scan
                THEN
                    x07debug_page (term, protfile, c_header_only,
                          file_pos, buf, buf_size, pfkey)
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  pfkey = pf_none
        THEN
            BEGIN
            scan := [utds_display, utds_edit];
            IF  buf_offset > 0
            THEN
                scan := scan + [utds_double_numbering];
            (*ENDIF*) 
            t14bufdisplay (term, protfile, scan, bsp_c30,
                  buf, buf_size, lwb, upb, lwb - buf_offset,
                  dummy_pos, pfkey)
            END;
        (*ENDIF*) 
        IF  pfkey = pf_none
        THEN
            BEGIN
            t09pfkeys  (term, edit_scan <> [ ]);
            t09setpf1 (term, c_pfkey_help);
            t09getcursor_line (term, in_line.ln, pfkey);
            t09setpf1 (term, c_pfkey_none)
            END;
        (*ENDIF*) 
        t09pfkeys (term, NOT c_on);
        t14display_msg (term, bsp_c20);
        IF  (pfkey = pf_help)
            OR
            ((pfkey = pf_none)
            AND ((in_line.prefix  = 'HELP') OR
            (     in_line.prefix  = 'help') OR
            (     in_line.ln[ 1 ] = '?'   ) ))
        THEN
            BEGIN
            pfkey := pf_none;
            t09goto_bottom    (term);
            t09newscreen_page (term);
            ta14help   (term);
            t09holding (term, pfkey)
            END;
        (*ENDIF*) 
        IF  ((in_line.prefix = 'TYPE') OR (in_line.prefix = 'type'))
            AND (pfkey = pf_none)
        THEN
            BEGIN
            is_cmd   := true;
            type_upb := lwb - 1 +
                  ((t09unused_window_lines(term) - c_header_line_count)
                  DIV minbuf_lines) * minbuf_bytes;
            IF  type_upb > buf_size
            THEN
                type_upb := buf_size;
            (*ENDIF*) 
            t14bufdisplay (term, protfile,
                  [utds_minbuf, utds_display], bsp_c30,
                  buf, buf_size, lwb, type_upb, lwb - buf_offset,
                  dummy_pos, pfkey);
            IF  pfkey = pf_none
            THEN
                t09holding (term, pfkey);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  ((in_line.prefix = 'FILL') OR (in_line.prefix = 'fill'))
            AND (pfkey = pf_none)
        THEN
            BEGIN
            is_cmd := true;
            ta14fill (term, protfile, buf, buf_size, buf_offset, lwb,
                  pfkey)
            END;
        (*ENDIF*) 
        IF  ((in_line.prefix = 'MOVE') OR (in_line.prefix = 'move'))
            AND (pfkey = pf_none)
        THEN
            BEGIN
            is_cmd := true;
            ta14move (term, protfile, buf, buf_size, buf_offset, lwb,
                  pfkey)
            END;
        (*ENDIF*) 
        IF  (in_line.ln = term.blankline) AND (pfkey = pf_none)
        THEN
            is_cmd := true
        (*ENDIF*) 
    UNTIL
        NOT is_cmd OR (pfkey <> pf_none);
    (*ENDREPEAT*) 
    IF  pfkey = pf_none
    THEN
        BEGIN
        byte_offset := mx_maxbuf_prefix;
        IF  in_line.prefix = c_dec_prefix
        THEN
            BEGIN
            i := lwb;
            REPEAT
                t14int4from_line (term, in_line.ln,
                      byte_offset + char_per_byte - 3, 3,
                      int_4, is_ok);
                IF  is_ok AND (int_4 >= 0) AND (int_4 <= 255)
                THEN
                    buf [i] := chr (int_4);
                (*ENDIF*) 
                i := i + 1;
                byte_offset := byte_offset + char_per_byte
            UNTIL
                (i > upb) OR NOT is_ok;
            (*ENDREPEAT*) 
            is_ok := true
            END;
        (*ENDIF*) 
        IF  in_line.prefix = c_hex_prefix
        THEN
            BEGIN
            t09uppercase_line (in_line.ln, 1, sizeof (in_line.ln));
            i := lwb;
            REPEAT
                ta14hex_from_line (term, in_line.ln,
                      byte_offset + char_per_byte - 2, c, is_ok);
                IF  is_ok
                THEN
                    buf [i] := c;
                (*ENDIF*) 
                i := i + 1;
                byte_offset := byte_offset + char_per_byte
            UNTIL
                (i > upb) OR NOT is_ok;
            (*ENDREPEAT*) 
            is_ok := true
            END;
        (*ENDIF*) 
        IF  in_line.prefix = c_chr_prefix
        THEN
            BEGIN
            i := lwb;
            REPEAT
                c := in_line.ln [byte_offset + char_per_byte - 1];
                IF  c <> ' '
                THEN
                    buf [i] := c;
                (*ENDIF*) 
                i := i + 1;
                byte_offset := byte_offset + char_per_byte
            UNTIL
                i > upb;
            (*ENDREPEAT*) 
            is_ok := true
            END;
        (*ENDIF*) 
        IF  in_line.prefix = c_c2_prefix
        THEN
            BEGIN
            i     := lwb;
            is_ok := true;
            WHILE (i+1 <= upb) AND is_ok DO
                BEGIN
                t14int4from_line (term, in_line.ln, byte_offset + 2,
                      2 * char_per_byte - 2, int_4, is_ok);
                IF  is_ok AND
                    (int_4 >= MIN_UINT2_SP00) AND (int_4 <= MAX_UINT2_SP00)
                THEN
                    BEGIN
                    gg06PnoPut (cint4, int_4);
                    buf [i  ] := cint4.ci4_gg00 [3];
                    buf [i+1] := cint4.ci4_gg00 [4]
                    END;
                (*ENDIF*) 
                i := i + 2;
                byte_offset := byte_offset + 2 * char_per_byte
                END;
            (*ENDWHILE*) 
            is_ok := true
            END;
        (*ENDIF*) 
        IF  in_line.prefix = c_u2_prefix
        THEN
            BEGIN
            i     := lwb;
            is_ok := true;
            WHILE (i+1 <= upb) AND is_ok DO
                BEGIN
                t14int4from_line (term, in_line.ln, byte_offset + 2,
                      2 * char_per_byte - 2, int_4, is_ok);
                IF  is_ok AND
                    (int_4 >= MIN_UINT2_SP00) AND (int_4 <= MAX_UINT2_SP00)
                THEN
                    BEGIN
                    gg06Int4ToUint2 (int_4, i2.mapInt_sp00);
                    buf [i  ] := i2.mapC2_sp00 [1];
                    buf [i+1] := i2.mapC2_sp00 [2]
                    END;
                (*ENDIF*) 
                i := i + 2;
                byte_offset := byte_offset + 2 * char_per_byte
                END;
            (*ENDWHILE*) 
            is_ok := true
            END;
        (*ENDIF*) 
        IF  in_line.prefix = c_int2_prefix
        THEN
            BEGIN
            i     := lwb;
            is_ok := true;
            WHILE (i+1 <= upb) AND is_ok DO
                BEGIN
                t14int4from_line (term, in_line.ln, byte_offset + 2,
                      2 * char_per_byte - 2, int_4, is_ok);
                IF  is_ok AND
                    (int_4 >= -MAX_INT2_SP00) AND (int_4 <= MAX_INT2_SP00)
                THEN
                    BEGIN
                    i2.mapInt_sp00 := int_4;
                    buf [i  ]  := i2.mapC2_sp00 [1];
                    buf [i+1]  := i2.mapC2_sp00 [2]
                    END;
                (*ENDIF*) 
                i := i + 2;
                byte_offset := byte_offset + 2 * char_per_byte
                END;
            (*ENDWHILE*) 
            is_ok := true
            END;
        (*ENDIF*) 
        IF  in_line.prefix = c_c4_prefix
        THEN
            BEGIN
            i     := lwb;
            is_ok := true;
            WHILE (i+3 <= upb) AND is_ok DO
                BEGIN
                IF  ta14is_nil_pno (in_line.ln, byte_offset+1)
                THEN
                    i4.map_i4 := NIL_PAGE_NO_GG00
                ELSE
                    t14int4from_line (term, in_line.ln, byte_offset + 2,
                          4 * char_per_byte - 2, i4.map_i4, is_ok);
                (*ENDIF*) 
                IF  is_ok
                THEN
                    BEGIN
                    gg06PnoPut (cint4, int_4);
                    buf [i  ] := cint4.ci4_gg00 [1];
                    buf [i+1] := cint4.ci4_gg00 [2];
                    buf [i+2] := cint4.ci4_gg00 [3];
                    buf [i+3] := cint4.ci4_gg00 [4]
                    END;
                (*ENDIF*) 
                i := i + 4;
                byte_offset := byte_offset + 4 * char_per_byte
                END;
            (*ENDWHILE*) 
            is_ok := true
            END;
        (*ENDIF*) 
        IF  in_line.prefix = c_int4_prefix
        THEN
            BEGIN
            i     := lwb;
            is_ok := true;
            WHILE (i+3 <= upb) AND is_ok DO
                BEGIN
                IF  ta14is_nil_pno (in_line.ln, byte_offset+1)
                THEN
                    i4.map_i4 := NIL_PAGE_NO_GG00
                ELSE
                    t14int4from_line (term, in_line.ln, byte_offset + 2,
                          4 * char_per_byte - 2, i4.map_i4, is_ok);
                (*ENDIF*) 
                IF  is_ok
                THEN
                    BEGIN
                    buf [i  ] := i4.map_c4 [1];
                    buf [i+1] := i4.map_c4 [2];
                    buf [i+2] := i4.map_c4 [3];
                    buf [i+3] := i4.map_c4 [4]
                    END;
                (*ENDIF*) 
                i := i + 4;
                byte_offset := byte_offset + 4 * char_per_byte
                END;
            (*ENDWHILE*) 
            is_ok := true
            END;
        (*ENDIF*) 
        IF  NOT is_ok
        THEN
            BEGIN
            t09uppercase_line (in_line.ln, 1, sizeof (in_line.ln));
            IF  in_line.prefix = 'SAVE'
            THEN
                is_saved := true
            ELSE
                IF  in_line.prefix = 'QUIT'
                THEN
                    BEGIN
                    is_quit := true;
                    pfkey   := pf_end
                    END
                ELSE
                    IF  in_line.prefix = 'RR  '
                    THEN
                        BEGIN
                        IF  buf_size - PAGE_TRAILER_MXGG00 + 1 > 0
                        THEN
                            lwb := buf_size - PAGE_TRAILER_MXGG00 + 1
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  in_line.ln [1] = 'R'
                        THEN
                            BEGIN
                            IF  lwb + (bytes_per_line DIV 4) * 4
                                <= buf_size
                            THEN
                                lwb := lwb + (bytes_per_line DIV 4) * 4
                            (*ENDIF*) 
                            END
                        ELSE
                            IF  in_line.ln [1] = 'L'
                            THEN
                                BEGIN
                                IF  lwb - (bytes_per_line DIV 4) * 4
                                    >= buf_offset + 1
                                THEN
                                    lwb := lwb -(bytes_per_line DIV 4)*4
                                ELSE
                                    lwb := buf_offset + 1
                                (*ENDIF*) 
                                END
                            ELSE
                                BEGIN
                                t14int4from_line (term, in_line.ln,
                                      1, of_col_type, new_lwb, is_ok);
                                IF  is_ok
                                THEN
                                    BEGIN
                                    new_lwb := new_lwb + buf_offset;
                                    IF  (new_lwb >= buf_offset + 1) AND
                                        (new_lwb <= buf_size      )
                                    THEN
                                        BEGIN
                                        lwb           := new_lwb;
                                        is_locate_cmd := true
                                        END;
                                    (*ENDIF*) 
                                    END
                                (*ENDIF*) 
                                END
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (pfkey = pf_none) AND is_locate_cmd
    THEN
        (* handle VXT08 input *)
        BEGIN
        curr_col     := 1;
        curr_col_len := 0;
        i            := lwb;
        is_ok        := true;
        REPEAT
            IF  curr_col = 1
            THEN
                BEGIN
                col_type_pos := of_col_type + 1;
                byte_offset  := of_first_col
                END
            ELSE
                BEGIN
                col_type_pos := of_col_type + 3;
                byte_offset  := of_second_col
                END;
            (*ENDIF*) 
            IF  (in_line.ln [col_type_pos+1] >= '0') AND
                (in_line.ln [col_type_pos+1] <= '9')
            THEN
                curr_col_len :=
                      ord (in_line.ln [col_type_pos+1]) - ord ('0')
            ELSE
                is_ok := false;
            (*ENDIF*) 
            IF  is_ok
            THEN
                BEGIN
                indicator := in_line.ln [col_type_pos];
                IF  (indicator = c_int_indicator)
                    AND
                    ((curr_col_len = 1) OR
                    ( curr_col_len = 2) OR
                    ( curr_col_len = 4))
                THEN
                    BEGIN
                    IF  ta14is_nil_pno (in_line.ln, byte_offset)
                    THEN
                        i4.map_i4 := NIL_PAGE_NO_GG00
                    ELSE
                        t14int4from_line (term, in_line.ln,
                              byte_offset + 1,
                              mx_int4_displ, i4.map_i4, is_ok);
                    (*ENDIF*) 
                    IF  is_ok AND (curr_col_len = 1)
                    THEN
                        BEGIN
                        IF  (i4.map_i4 >=   0) AND
                            (i4.map_i4 <= 255)
                        THEN
                            buf [i] := chr (i4.map_i4)
                        ELSE
                            is_ok := false
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  is_ok AND (curr_col_len = 2)
                        THEN
                            BEGIN
                            IF  (i4.map_i4 >= MIN_INT2_SP00) AND
                                (i4.map_i4 <= MAX_INT2_SP00)
                            THEN
                                BEGIN
                                i2.mapInt_sp00 := i4.map_i4;
                                buf [i  ]  := i2.mapC2_sp00 [1];
                                buf [i+1]  := i2.mapC2_sp00 [2]
                                END
                            (*ENDIF*) 
                            END
                        ELSE
                            IF  is_ok AND (curr_col_len = 4)
                            THEN
                                BEGIN
                                buf [i  ] := i4.map_c4 [1];
                                buf [i+1] := i4.map_c4 [2];
                                buf [i+2] := i4.map_c4 [3];
                                buf [i+3] := i4.map_c4 [4]
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    is_ok := true
                    END
                ELSE
                    IF  (indicator = c_bool_indicator)
                        AND
                        (curr_col_len = 1)
                    THEN
                        BEGIN
                        SAPDB_PascalForcedMove (sizeof(in_line.ln), sizeof (bool_value),
                              @in_line.ln, byte_offset+1, @bool_value, 1,
                              sizeof (bool_value));
                        IF  bool_value = 'TRUE  '
                        THEN
                            buf [i] := chr (ord (true))
                        ELSE
                            IF  bool_value = 'FALSE '
                            THEN
                                buf [i] := chr (ord (false))
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  ((indicator = c_mtype_indicator ) OR
                            ( indicator = c_mtype2_indicator))
                            AND
                            (curr_col_len = 1)
                        THEN
                            BEGIN
                            SAPDB_PascalForcedMove (sizeof (in_line.ln),
                                  sizeof (mtype_value),
                                  @in_line.ln, byte_offset+1,
                                  @mtype_value, 1,
                                  sizeof (mtype_value));
                            IF  indicator = c_mtype_indicator
                            THEN
                                ta14mtype_assign  (mtype_value, buf, i)
                            ELSE
                                ta14mtype2_assign (mtype_value, buf, i)
                            (*ENDIF*) 
                            END
                        ELSE
                            IF  (indicator = c_set_indicator)
                                AND
                                (curr_col     = 1) AND
                                (curr_col_len = 1)
                            THEN
                                ta14set_assign (in_line.ln,
                                      byte_offset, buf, i);
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                i := i + curr_col_len
                END;
            (*ENDIF*) 
            curr_col := curr_col + 1
        UNTIL
            (curr_col > 2) OR NOT is_ok
        (*ENDREPEAT*) 
        END;
    (*ENDIF*) 
    IF  (pfkey = pf_end) AND NOT is_saved AND NOT is_quit
    THEN
        BEGIN
        pfkey := pf_none;
        ta14display_leave_msg (term);
        t09holding (term, pfkey)
        END
    (*ENDIF*) 
UNTIL
    is_saved OR (pfkey <> pf_none);
(*ENDREPEAT*) 
t09pfkeys (term, pfkeys_used)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t14int4from_line (VAR term : tut_terminal;
            VAR ln  : tsp00_Line;
            ln_pos  : integer;
            ln_len  : integer;
            VAR int : tsp00_Int4;
            VAR ok  : boolean);
 
VAR
      intstring : PACKED ARRAY [1..c_int4_digits] OF char;
      factor    : tsp00_Int4;
      intlength : integer;
      i, pos    : integer;
      startpos  : integer;
      msg       : tsp00_C20;
 
BEGIN
ok        := true;
intlength := 0;
startpos  := ln_pos;
WHILE (startpos < ln_pos + ln_len - 1) AND (ln [startpos] = ' ') DO
    startpos := startpos + 1;
(*ENDWHILE*) 
IF  ln [startpos] = '-'
THEN
    pos := startpos + 1
ELSE
    pos := startpos;
(*ENDIF*) 
WHILE (pos < ln_pos + ln_len) AND
      (ln [pos] >= '0') AND (ln [pos] <= '9') DO
    BEGIN
    intlength := intlength + 1;
    pos := pos + 1
    END;
(*ENDWHILE*) 
IF  (intlength = 0) OR (ln [pos] <> ' ')
THEN
    BEGIN
    ok       := false;
    msg      := 'INVALID NUMBER ('' '')';
    msg [18] := ln [pos];
    t14display_msg (term, msg)
    END;
(*ENDIF*) 
IF  ok AND (intlength > c_int4_digits)
THEN
    BEGIN
    ok := false;
    t14display_msg (term, 'NUMBER TOO LONG     ')
    END;
(*ENDIF*) 
IF  ok AND (intlength = c_int4_digits)
THEN
    BEGIN
    FOR i := 1 TO c_int4_digits DO
        intstring [i] := ln [pos - c_int4_digits - 1 + i];
    (*ENDFOR*) 
    IF  intstring > c_maxint4_string
    THEN
        BEGIN
        ok := false;
        t14display_msg (term, 'NUMBER TOO LARGE    ')
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ok
THEN
    BEGIN
    pos    := pos - 1;
    int    := 0;
    factor := 1;
    FOR i := 1 TO intlength DO
        BEGIN
        int := int + factor * (ord (ln [pos]) - ord ('0'));
        pos := pos - 1;
        IF  i < intlength
        THEN
            factor := factor * 10
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    IF  ln [startpos] = '-'
    THEN
        int := - int
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t14logentry_edit (VAR term : tut_terminal;
            VAR protfile : tut_vf_fileref;
            VAR node     : tsp00_MoveObj;
            VAR file_pos : tut_file_pos;
            entry_pos    : tsp00_Int4;
            entry_length : tsp00_Int4;
            VAR is_saved : boolean;
            VAR pfkey    : tut_pfkey);
 
VAR
      pfkeys_used : boolean;
      node_ptr    : tbd_nodeptr;
 
BEGIN
is_saved    := false;
pfkey       := pf_none;
pfkeys_used := term.use_pfkeys;
node_ptr    := @node;
t14editbuf (term, protfile, node,
      entry_pos - 1 + entry_length,
      entry_pos - 1,
      file_pos, [utds_rec], is_saved, pfkey);
IF  pfkey = pf_end
THEN
    pfkey := pf_none;
(*ENDIF*) 
t09pfkeys (term, pfkeys_used)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t14object_edit (VAR term : tut_terminal;
            VAR protfile : tut_vf_fileref;
            VAR node     : tsp00_MoveObj;
            VAR file_pos : tut_file_pos;
            obj_pos      : tsp00_Int4;
            VAR is_saved : boolean;
            VAR pfkey    : tut_pfkey);
 
VAR
      pfkeys_used : boolean;
      node_ptr    : tbd_nodeptr;
 
BEGIN
is_saved    := false;
pfkey       := pf_none;
pfkeys_used := term.use_pfkeys;
node_ptr    := @node;
t14editbuf (term, protfile, node,
      obj_pos - 1 + gg06Int4FromUint2 (node_ptr^.nd_obj_frame_len),
      obj_pos - 1,
      file_pos, [utds_rec], is_saved, pfkey);
IF  pfkey = pf_end
THEN
    pfkey := pf_none;
(*ENDIF*) 
t09pfkeys (term, pfkeys_used)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t14record_edit (VAR term : tut_terminal;
            VAR protfile : tut_vf_fileref;
            VAR node     : tsp00_MoveObj;
            node_size    : tsp00_Int4;
            VAR file_pos : tut_file_pos;
            edit_scan    : tut_diag_scan;
            VAR is_saved : boolean;
            VAR pfkey    : tut_pfkey);
 
VAR
      is_ok      : boolean;
      curr_saved : boolean;
      pfkeys_used: boolean;
      dummy_err  : integer;
      rec_pos    : tsp00_Int4;
      rec_len    : tsp00_Int4;
      i2         : tsp00_IntMapC2;
      in_line    : tsp00_Line;
 
BEGIN
is_saved    := false;
pfkey       := pf_none;
pfkeys_used := term.use_pfkeys; (* PTS 1000215 JA 1997-11-14 *)
REPEAT
    rec_pos    := 0;
    rec_len    := 0;
    is_ok      := false;
    in_line    := term.blankline;
    curr_saved := false;
    t09newscreen_page (term);
    t12write_prot (protfile, term.blankline, 1, dummy_err);
    x07keys_display (term, protfile, file_pos, node, node_size, pfkey);
    IF  pfkey = pf_none
    THEN
        BEGIN
        IF  t09is_window_full (term, 1)
        THEN
            BEGIN
            t09holding (term, pfkey);
            IF  pfkey = pf_none
            THEN
                t09newscreen_page (term)
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  pfkey = pf_none
    THEN
        BEGIN
        t09pfkeys (term, c_on);
        t09getcursor_line (term, in_line, pfkey);
        t09pfkeys (term, NOT c_on);
        END;
    (*ENDIF*) 
    IF  (pfkey = pf_none)
        AND
        (in_line [of_key_pos-3] = 'p') AND
        (in_line [of_key_pos-2] = 'o') AND
        (in_line [of_key_pos-1] = 's')
        AND
        (in_line [of_key_pos + mx_pos_displ + 1] = ')')
    THEN
        BEGIN
        in_line [of_key_pos + mx_pos_displ + 1] := ' ';
        t14int4from_line (term, in_line, of_key_pos + 1,
              mx_pos_displ, rec_pos, is_ok);
        IF  is_ok
        THEN
            is_ok := (rec_pos >= 1) AND (rec_pos + 3 <= node_size)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  is_ok AND (pfkey = pf_none)
    THEN
        BEGIN
        i2.mapC2_sp00 [1] := node [rec_pos  ];
        i2.mapC2_sp00 [2] := node [rec_pos+1];
        rec_len       := i2.mapInt_sp00;
        is_ok         := rec_pos - 1 + rec_len <= node_size
        END;
    (*ENDIF*) 
    IF  is_ok AND (pfkey = pf_none)
    THEN
        BEGIN
        t14editbuf (term, protfile, node, rec_pos - 1 + rec_len,
              rec_pos - 1, file_pos, edit_scan, curr_saved, pfkey);
        IF  pfkey = pf_end
        THEN
            pfkey := pf_none;
        (*ENDIF*) 
        IF  curr_saved
        THEN
            is_saved := true
        (*ENDIF*) 
        END
    (*ENDIF*) 
UNTIL
    NOT is_ok OR (pfkey <> pf_none);
(*ENDREPEAT*) 
t09pfkeys (term, pfkeys_used) (* PTS 1000215 JA 1997-11-14 *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta14display_leave_msg (VAR term : tut_terminal);
 
BEGIN
t09put   (term, term.blankline, cut_protected);
t09put60 (term,
      'If you want to leave the EDIT mode, restrike the END key    ',
      cut_bright_protected)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta14edit_bufdimension (VAR term : tut_terminal;
            buf_size           : tsp00_Int4;
            VAR char_per_byte  : integer;
            VAR bytes_per_line : integer;
            VAR line_size      : integer;
            VAR lines_per_buf  : integer);
 
BEGIN
IF  buf_size >= 10000
THEN
    char_per_byte := 6
ELSE
    char_per_byte := 5;
(*ENDIF*) 
bytes_per_line :=
      (t09window_cols (term) - mx_maxbuf_prefix) DIV char_per_byte;
line_size     := mx_maxbuf_prefix + bytes_per_line * char_per_byte;
lines_per_buf := c_edit_lines
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta14fill (VAR term : tut_terminal;
            VAR protfile : tut_vf_fileref;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4;
            buf_offset   : tsp00_Int4;
            init_pos     : tsp00_Int4;
            VAR pfkey    : tut_pfkey);
 
CONST
      c_margin_bytes = 5;
 
VAR
      is_ok        : boolean;
      fill_char    : char;
      ln_pos       : integer;
      ln_len       : integer;
      count        : integer;
      maxbuf_bytes : integer;
      dummy_int_1  : integer;
      dummy_int_2  : integer;
      i            : tsp00_Int4;
      lwb          : tsp00_Int4;
      upb          : tsp00_Int4;
      dummy_pos    : tsp00_Int4;
      fill_len     : tsp00_Int4;
      fill_pos     : tsp00_Int4;
      n            : tsp00_Name;
      n_endpos     : tsp00_Name;
      ln           : tsp00_Line;
 
BEGIN
count    := 0;
is_ok    := true;
fill_pos := init_pos;
t14bufdimension (term, [ ], maxbuf_bytes, dummy_int_1, dummy_int_2);
REPEAT
    count := count + 1;
    t09newscreen_page (term);
    lwb := init_pos;
    IF  lwb + maxbuf_bytes - 1 > buf_size
    THEN
        upb := buf_size
    ELSE
        upb := lwb + maxbuf_bytes - 1;
    (*ENDIF*) 
    t14bufdisplay (term, protfile, [utds_display], bsp_c30,
          buf, buf_size, lwb, upb, lwb - buf_offset, dummy_pos, pfkey);
    t09put (term, term.blankline, cut_protected);
    ln     := term.blankline;
    ln_len := 0;
    g17trimint4_to_line (init_pos - buf_offset, ln_len, ln);
    n := bsp_name;
    FOR i := 1 TO sizeof (n) DO
        n [i] := ln [i];
    (*ENDFOR*) 
    t09get1name (term, '                POS:', cut_bright_protected,
          cut_unprotected, mx_int4_displ, c_upper, n, pfkey);
    t09putmsg (term, term.blankline, NOT c_warning, NOT c_immed_displ);
    IF  pfkey = pf_none
    THEN
        BEGIN
        SAPDB_PascalForcedMove (sizeof (n), sizeof (ln), @n, 1, @ln, 1, sizeof (n));
        t14int4from_line (term, ln, 1, sizeof (n), fill_pos, is_ok);
        IF  is_ok
        THEN
            BEGIN
            fill_pos := fill_pos + buf_offset;
            IF  (fill_pos <= buf_offset) OR (fill_pos > buf_size)
            THEN
                BEGIN
                is_ok := false;
                t14display_msg (term, msg_illegal_pos)
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
UNTIL
    is_ok OR (pfkey <> pf_none) OR (count >= 3);
(*ENDREPEAT*) 
IF  (pfkey = pf_none) AND NOT is_ok
THEN
    pfkey := pf_end;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    IF  fill_pos - c_margin_bytes > buf_offset
    THEN
        lwb := fill_pos - c_margin_bytes
    ELSE
        lwb := buf_offset + 1;
    (*ENDIF*) 
    upb := lwb + maxbuf_bytes - 1;
    IF  upb > buf_size
    THEN
        upb := buf_size
    (*ENDIF*) 
    END;
(*ENDIF*) 
count := 0;
is_ok := false;
WHILE NOT is_ok AND (pfkey = pf_none) AND (count < 3) DO
    BEGIN
    count := count + 1;
    t09newscreen_page (term);
    t14bufdisplay (term, protfile, [utds_display], bsp_c30,
          buf, buf_size, lwb, upb, lwb - buf_offset, dummy_pos, pfkey);
    ln     := term.blankline;
    ln_pos := mx_maxbuf_prefix + 1 + mx_maxbuf_byte * (fill_pos - lwb);
    ln [ln_pos  ] := '|';
    ln [ln_pos+1] := '=';
    ln [ln_pos+2] := '>';
    t09put (term, ln, cut_bright_protected);
    t09put (term, term.blankline, cut_protected);
    n        := bsp_name;
    n_endpos := bsp_name;
    t09get2name (term, '        FILL LENGTH:', 'or      FILL ENDPOS:',
          cut_bright_protected, cut_bright_protected, cut_unprotected,
          cut_unprotected, mx_int4_displ, mx_int4_displ,
          c_upper, c_upper, n, n_endpos, pfkey);
    t09putmsg (term, term.blankline, NOT c_warning, NOT c_immed_displ);
    IF  pfkey = pf_none
    THEN
        BEGIN
        ln := term.blankline;
        IF  n <> bsp_name
        THEN
            SAPDB_PascalForcedMove (sizeof (n), sizeof (ln),
                  @n, 1, @ln, 1, sizeof (n))
        ELSE
            SAPDB_PascalForcedMove (sizeof (n_endpos), sizeof (ln),
                  @n_endpos, 1, @ln, 1, sizeof (n_endpos));
        (*ENDIF*) 
        t14int4from_line (term, ln, 1, sizeof (n), fill_len, is_ok);
        IF  is_ok
        THEN
            BEGIN
            IF  n <> bsp_name
            THEN
                (* length specified *)
                BEGIN
                IF  (fill_len < 1) OR
                    (fill_pos + fill_len - 1 > buf_size)
                THEN
                    BEGIN
                    t14display_msg (term, msg_illegal_len);
                    is_ok := false
                    END
                (*ENDIF*) 
                END
            ELSE
                (* endpos specified *)
                BEGIN
                fill_len := fill_len + buf_offset;
                IF  (fill_len < fill_pos) OR (fill_len > buf_size)
                THEN
                    BEGIN
                    t14display_msg (term, msg_illegal_pos);
                    is_ok := false
                    END
                ELSE
                    fill_len := fill_len - fill_pos + 1
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  (pfkey = pf_none) AND NOT is_ok
THEN
    pfkey := pf_end;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    t09newscreen_page (term);
    t14bufdisplay (term, protfile, [utds_display], bsp_c30,
          buf, buf_size, lwb, upb, lwb - buf_offset, dummy_pos, pfkey);
    ln := term.blankline;
    ln [ln_pos] := '|';
    IF  fill_pos + fill_len - 1 > upb
    THEN
        BEGIN
        ln_len := mx_maxbuf_prefix + mx_maxbuf_byte * (upb - lwb + 1);
        ln [ln_len] := '>'
        END
    ELSE
        BEGIN
        ln_len := mx_maxbuf_prefix
              + mx_maxbuf_byte * (fill_pos - lwb + fill_len);
        ln [ln_len] := '|'
        END;
    (*ENDIF*) 
    ln_pos := ln_pos + 1;
    WHILE ln_pos < ln_len DO
        BEGIN
        ln [ln_pos] := '=';
        ln_pos      := ln_pos + 1
        END;
    (*ENDWHILE*) 
    t09put (term, ln, cut_bright_protected);
    t09put (term, term.blankline, cut_protected);
    IF  fill_pos + fill_len - 1 > upb
    THEN
        BEGIN
        IF  fill_pos + fill_len - 1 > upb + maxbuf_bytes
        THEN
            BEGIN
            upb := fill_pos + fill_len - 1;
            IF  upb + c_margin_bytes <= buf_size
            THEN
                upb := upb + c_margin_bytes
            ELSE
                upb := buf_size;
            (*ENDIF*) 
            lwb := upb - maxbuf_bytes + 1
            END
        ELSE
            BEGIN
            lwb := upb + 1;
            upb := upb + maxbuf_bytes;
            IF  upb > buf_size
            THEN
                upb := buf_size
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        t14bufdisplay (term, protfile, [utds_display], bsp_c30,
              buf, buf_size, lwb, upb, lwb - buf_offset,
              dummy_pos, pfkey);
        ln     := term.blankline;
        ln_pos := mx_maxbuf_prefix + 1;
        ln_len := mx_maxbuf_prefix +
              mx_maxbuf_byte * (fill_pos - lwb + fill_len);
        ln [ln_len] := '|';
        WHILE ln_pos < ln_len DO
            BEGIN
            ln [ln_pos] := '=';
            ln_pos      := ln_pos + 1
            END;
        (*ENDWHILE*) 
        t09put (term, ln, cut_bright_protected);
        t09put (term, term.blankline, cut_protected)
        END;
    (*ENDIF*) 
    n := bsp_name;
    t09putmsg (term, term.blankline, NOT c_warning, NOT c_immed_displ);
    t09get1name (term, '    fill char / hex:', cut_bright_protected,
          cut_unprotected, 2, NOT c_upper, n, pfkey);
    t09putmsg (term, term.blankline, NOT c_warning, NOT c_immed_displ)
    END;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    IF  n [2] = ' '
    THEN
        fill_char := n [1]
    ELSE
        BEGIN
        ln := term.blankline;
        SAPDB_PascalForcedMove (sizeof (n), sizeof (ln), @n, 1, @ln, 1, sizeof (n));
        t09uppercase_line (ln, 1, 3);
        IF  ln [1] = 'X'
        THEN
            i := 2
        ELSE
            i := 1;
        (*ENDIF*) 
        ta14hex_from_line (term, ln, i, fill_char, is_ok);
        IF  NOT is_ok
        THEN
            pfkey := pf_end
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    ln     := term.blankline;
    ln_len := 0;
    g17sname_to_line ('FILL from   ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (fill_pos - buf_offset, ln_len, ln);
    g17sname_to_line (' to         ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (fill_pos + fill_len - 1 - buf_offset,
          ln_len, ln);
    g17sname_to_line (' (length    ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (fill_len, ln_len, ln);
    ln_len      := ln_len + 1;
    ln [ln_len] := ')';
    t09put (term, term.blankline, cut_protected);
    t09put (term, ln, cut_bright_protected);
    t09put (term, term.blankline, cut_protected);
    n := 'y                 ';
    t09get1name (term, 'EXECUTE FILL ? (y/n)', cut_bright_protected,
          cut_unprotected, mx_yes_no, c_upper, n, pfkey)
    END;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    IF  n = 'Y                 '
    THEN
        FOR i := fill_pos TO fill_pos + fill_len - 1 DO
            buf [i] := fill_char
        (*ENDFOR*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  pfkey = pf_end
THEN
    pfkey := pf_none
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta14help (VAR term : tut_terminal);
 
BEGIN
t09put   (term, term.blankline, cut_protected);
t09put60 (term,
      '<pos>  goto the specified position                          ',
      cut_protected);
t09put60 (term,
      'l      goto left                                            ',
      cut_protected);
t09put60 (term,
      'r      goto right                                           ',
      cut_protected);
t09put60 (term,
      'rr     goto the end of the page                             ',
      cut_protected);
t09put   (term, term.blankline, cut_protected);
t09put60 (term,
      'fill                                                        ',
      cut_protected);
t09put60 (term,
      'move                                                        ',
      cut_protected);
t09put   (term, term.blankline, cut_protected);
t09put60 (term,
      'type   displays the buffer (starting at edit position)      ',
      cut_protected);
t09put   (term, term.blankline, cut_protected);
t09put60 (term,
      'quit   leaves the EDIT mode without any changes             ',
      cut_protected);
t09put60 (term,
      'save   leaves the EDIT mode                                 ',
      cut_protected)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta14hex_from_line (VAR term : tut_terminal;
            VAR ln     : tsp00_Line;
            ln_pos     : integer;
            VAR result : char;
            VAR ok     : boolean);
 
VAR
      c          : char;
      i          : integer;
      int_result : integer;
      msg        : tsp00_C20;
 
BEGIN
ok := true;
i  := 0;
int_result := 0;
REPEAT
    c := ln [ln_pos+i];
    IF  (c >= '0') AND (c <= '9')
    THEN
        int_result := int_result + ord(c) - ord('0')
    ELSE
        IF  (c >= 'A') AND (c <= 'F')
        THEN
            int_result := int_result + ord(c) - ord('A') + 10
        ELSE
            BEGIN
            ok  := false;
            msg := 'INVALID HEX ('' '')   ';
            msg [15] := c;
            t14display_msg (term, msg)
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  i = 0
    THEN
        int_result := int_result * 16;
    (*ENDIF*) 
    i := i + 1;
UNTIL
    (i > 1) OR NOT ok;
(*ENDREPEAT*) 
IF  ok
THEN
    result := chr(int_result)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ta14is_nil_pno (VAR ln : tsp00_Line;
            ln_offset : integer) : boolean;
 
CONST
      c_nil_pno1 = 'nil_pno ';
      c_nil_pno2 = 'NIL_PNO ';
 
VAR
      is_nil_pno : boolean;
      offset     : integer;
      i          : integer;
      n          : tsp00_C8;
 
BEGIN
is_nil_pno := false;
offset     := ln_offset;
IF  offset + 1 < sizeof (ln)
THEN
    BEGIN
    WHILE (ln [offset+1] = ' ') AND (offset + 1 < sizeof (ln)) DO
        offset := offset + 1;
    (*ENDWHILE*) 
    IF  offset + sizeof (n) <= sizeof (ln)
    THEN
        BEGIN
        FOR i := 1 TO sizeof (n) DO
            n [i] := ln [offset+i];
        (*ENDFOR*) 
        is_nil_pno :=
              (n = c_nil_pno1) OR
              (n = c_nil_pno2)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
ta14is_nil_pno := is_nil_pno
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta14move (VAR term : tut_terminal;
            VAR protfile : tut_vf_fileref;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4;
            buf_offset   : tsp00_Int4;
            init_pos     : tsp00_Int4;
            VAR pfkey    : tut_pfkey);
 
CONST
      msg_destin = 'DESTIN:                       ';
 
VAR
      is_ok        : boolean;
      scan         : tut_diag_scan;
      source_pos   : tsp00_Int4;
      destin_pos   : tsp00_Int4;
      move_len     : tsp00_Int4;
      source_upb   : tsp00_Int4;
      destin_lwb   : tsp00_Int4;
      destin_upb   : tsp00_Int4;
      dummy_pos    : tsp00_Int4;
      count        : tsp00_Int4;
      i            : tsp00_Int4;
      maxbuf_bytes : integer;
      minbuf_bytes : integer;
      dummy_int_1  : integer;
      dummy_int_2  : integer;
      ln_len       : integer;
      offset       : integer;
      n            : tsp00_Name;
      n_endpos     : tsp00_Name;
      msg_source   : tsp00_C30;
      ln           : tsp00_Line;
 
BEGIN
msg_source := 'SOURCE:                       ';
count      := 0;
is_ok      := true;
t14bufdimension (term, [ ], maxbuf_bytes, dummy_int_1, dummy_int_2);
t14bufdimension (term, [utds_minbuf], minbuf_bytes,
      dummy_int_1, dummy_int_2);
REPEAT
    count := count + 1;
    t09newscreen_page (term);
    IF  buf_offset + maxbuf_bytes > buf_size
    THEN
        source_upb := buf_size
    ELSE
        source_upb := buf_offset + maxbuf_bytes;
    (*ENDIF*) 
    t14bufdisplay (term, protfile, [utds_display], msg_source,
          buf, buf_size, init_pos, source_upb, init_pos - buf_offset,
          dummy_pos, pfkey);
    t09put (term, term.blankline, cut_protected);
    ln     := term.blankline;
    ln_len := 0;
    g17trimint4_to_line (init_pos - buf_offset, ln_len, ln);
    n := bsp_name;
    FOR i := 1 TO sizeof (n) DO
        n [i] := ln [i];
    (*ENDFOR*) 
    t09get1name (term, '         SOURCE POS:', cut_bright_protected,
          cut_unprotected, mx_int4_displ, c_upper, n, pfkey);
    t09putmsg (term, term.blankline, NOT c_warning, NOT c_immed_displ);
    IF  pfkey = pf_none
    THEN
        BEGIN
        SAPDB_PascalForcedMove (sizeof (n), sizeof (ln), @n, 1, @ln, 1, sizeof (n));
        t14int4from_line (term, ln, 1, sizeof (n), source_pos, is_ok);
        IF  is_ok
        THEN
            BEGIN
            source_pos := source_pos + buf_offset;
            IF  (source_pos <= buf_offset) OR (source_pos > buf_size)
            THEN
                BEGIN
                is_ok := false;
                t14display_msg (term, msg_illegal_pos)
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
UNTIL
    is_ok OR (pfkey <> pf_none) OR (count >= 3);
(*ENDREPEAT*) 
IF  (pfkey = pf_none) AND NOT is_ok
THEN
    pfkey := pf_end;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    IF  source_pos + maxbuf_bytes - 1 <= buf_size
    THEN
        source_upb := source_pos + maxbuf_bytes - 1
    ELSE
        source_upb := buf_size
    (*ENDIF*) 
    END;
(*ENDIF*) 
count := 0;
is_ok := false;
WHILE NOT is_ok AND (pfkey = pf_none) AND (count < 3) DO
    BEGIN
    count := count + 1;
    t09newscreen_page (term);
    t14bufdisplay (term, protfile, [utds_display], msg_source,
          buf, buf_size, source_pos, source_upb,
          source_pos - buf_offset, dummy_pos, pfkey);
    t09put (term, term.blankline, cut_protected);
    IF  buf_offset + maxbuf_bytes > buf_size
    THEN
        destin_upb := buf_size
    ELSE
        destin_upb := buf_offset + maxbuf_bytes;
    (*ENDIF*) 
    t14bufdisplay (term, protfile, [utds_display], msg_destin,
          buf, buf_size, buf_offset+1, destin_upb, 1, dummy_pos, pfkey);
    t09put (term, term.blankline, cut_protected);
    n := '1                 ';
    t09get1name (term, '         DESTIN POS:', cut_bright_protected,
          cut_unprotected, mx_int4_displ, c_upper, n, pfkey);
    t09putmsg (term, term.blankline, NOT c_warning, NOT c_immed_displ);
    IF  pfkey = pf_none
    THEN
        BEGIN
        SAPDB_PascalForcedMove (sizeof (n), sizeof (ln), @n, 1, @ln, 1, sizeof (n));
        t14int4from_line (term, ln, 1, sizeof (n), destin_pos, is_ok);
        IF  is_ok
        THEN
            BEGIN
            destin_pos := destin_pos + buf_offset;
            IF  (destin_pos <= buf_offset) OR (destin_pos > buf_size)
            THEN
                BEGIN
                is_ok := false;
                t14display_msg (term, msg_illegal_pos)
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  (pfkey = pf_none) AND NOT is_ok
THEN
    pfkey := pf_end;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    IF  destin_pos + maxbuf_bytes - 1 <= buf_size
    THEN
        destin_upb := destin_pos + maxbuf_bytes - 1
    ELSE
        destin_upb := buf_size
    (*ENDIF*) 
    END;
(*ENDIF*) 
count := 0;
is_ok := false;
WHILE NOT is_ok AND (pfkey = pf_none) AND (count < 3) DO
    BEGIN
    count := count + 1;
    t09newscreen_page (term);
    t14bufdisplay (term, protfile, [utds_display], msg_source,
          buf, buf_size, source_pos, source_upb,
          source_pos - buf_offset, dummy_pos, pfkey);
    t09put (term, term.blankline, cut_protected);
    t14bufdisplay (term, protfile, [utds_display], msg_destin,
          buf, buf_size, destin_pos, destin_upb,
          destin_pos - buf_offset, dummy_pos, pfkey);
    t09put (term, term.blankline, cut_protected);
    n := bsp_name;
    n_endpos := bsp_name;
    t09get2name (term, '        MOVE LENGTH:', 'or    SOURCE ENDPOS:',
          cut_bright_protected, cut_bright_protected, cut_unprotected,
          cut_unprotected, mx_int4_displ, mx_int4_displ,
          c_upper, c_upper, n, n_endpos, pfkey);
    t09putmsg (term, term.blankline, NOT c_warning, NOT c_immed_displ);
    IF  pfkey = pf_none
    THEN
        BEGIN
        IF  n <> bsp_name
        THEN
            SAPDB_PascalForcedMove (sizeof (n), sizeof (ln), @n, 1, @ln, 1, sizeof (n))
        ELSE
            SAPDB_PascalForcedMove (sizeof (n_endpos), sizeof (ln), @n_endpos, 1,
                  @ln, 1, sizeof (n_endpos));
        (*ENDIF*) 
        t14int4from_line (term, ln, 1, sizeof (n), move_len, is_ok);
        IF  is_ok
        THEN
            BEGIN
            IF  n <> bsp_name
            THEN
                (* length specified *)
                BEGIN
                IF  (source_pos + move_len - 1 > buf_size) OR
                    (destin_pos + move_len - 1 > buf_size) OR
                    (move_len < 1)
                THEN
                    BEGIN
                    is_ok := false;
                    t14display_msg (term, msg_illegal_len)
                    END
                (*ENDIF*) 
                END
            ELSE
                (* endpos specified *)
                BEGIN
                move_len := move_len - buf_offset;
                IF  (move_len < source_pos) OR (move_len > buf_size)
                THEN
                    BEGIN
                    is_ok := false;
                    t14display_msg (term, msg_illegal_pos)
                    END
                ELSE
                    BEGIN
                    move_len := move_len - source_pos + 1;
                    IF  destin_pos + move_len - 1 > buf_size
                    THEN
                        BEGIN
                        is_ok := false;
                        t14display_msg (term, msg_illegal_len)
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  (pfkey = pf_none) AND NOT is_ok
THEN
    pfkey := pf_end;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    t09newscreen_page (term);
    IF  move_len > 4 * minbuf_bytes
    THEN
        BEGIN
        msg_source := 'SOURCE (trunc):               ';
        source_upb := source_pos + 4 * minbuf_bytes - 1
        END
    ELSE
        source_upb := source_pos + move_len - 1;
    (*ENDIF*) 
    IF  move_len > 2 * maxbuf_bytes
    THEN
        scan := [utds_minbuf, utds_display]
    ELSE
        scan := [utds_display];
    (*ENDIF*) 
    t14bufdisplay (term, protfile, scan, msg_source,
          buf, buf_size, source_pos, source_upb,
          source_pos - buf_offset, dummy_pos, pfkey);
    IF  destin_pos > 5
    THEN
        destin_lwb := destin_pos - 5
    ELSE
        destin_lwb := 1;
    (*ENDIF*) 
    IF  destin_upb + maxbuf_bytes - 1 <= buf_size
    THEN
        destin_upb := destin_lwb + maxbuf_bytes - 1
    ELSE
        destin_upb := buf_size;
    (*ENDIF*) 
    IF  destin_upb < destin_pos + move_len - 1
    THEN
        count := destin_upb - destin_pos + 1
    ELSE
        count := move_len;
    (*ENDIF*) 
    count  := count * 3;
    ln     := term.blankline;
    offset := mx_maxbuf_prefix +
          (destin_pos - destin_lwb) * mx_maxbuf_byte;
    ln [offset+2] := '|';
    FOR i := 3 TO count DO
        ln [offset+i] := '=';
    (*ENDFOR*) 
    IF  destin_upb < destin_pos + move_len - 1
    THEN
        ln [offset + count+1] := '>'
    ELSE
        ln [offset + count  ] := '|';
    (*ENDIF*) 
    t09put (term, term.blankline, cut_bright_protected);
    t14bufdisplay (term, protfile, [utds_display], msg_destin,
          buf, buf_size, destin_lwb, destin_upb,
          destin_lwb - buf_offset, dummy_pos, pfkey);
    t09put (term, ln, cut_bright_protected);
    t09put (term, term.blankline, cut_protected);
    ln     := term.blankline;
    ln_len := 0;
    g17sname_to_line ('MOVE from   ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (source_pos - buf_offset, ln_len, ln);
    ln_len      := ln_len + 1;
    ln [ln_len] := '-';
    g17trimint4_to_line (source_pos + move_len - 1 - buf_offset,
          ln_len, ln);
    g17sname_to_line (' to         ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (destin_pos - buf_offset, ln_len, ln);
    ln_len      := ln_len + 1;
    ln [ln_len] := '-';
    g17trimint4_to_line (destin_pos + move_len - 1 - buf_offset,
          ln_len, ln);
    g17sname_to_line (' (length    ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (move_len, ln_len, ln);
    ln_len      := ln_len + 1;
    ln [ln_len] := ')';
    t09put (term, ln, cut_bright_protected);
    t09put (term, term.blankline, cut_protected);
    n := 'y                 ';
    t09get1name (term, 'EXECUTE MOVE ? (y/n)', cut_bright_protected,
          cut_unprotected, mx_yes_no, c_upper, n, pfkey)
    END;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    IF  n = 'Y                 '
    THEN
        BEGIN
        IF  source_pos < destin_pos
        THEN
            FOR i := move_len-1 DOWNTO 0 DO
                buf[ destin_pos+i ] := buf[ source_pos+i ]
            (*ENDFOR*) 
        ELSE
            SAPDB_PascalForcedOverlappingMove (buf_size, buf_size, @buf, source_pos,
                  @buf, destin_pos, move_len)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  pfkey = pf_end
THEN
    pfkey := pf_none
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta14mtype_assign (VAR mtype_value : tsp00_Name;
            VAR buf : tsp00_MoveObj;
            buf_pos : tsp00_Int4);
 
VAR
      found  : boolean;
      curr   : tgg00_MessType;
      ln_len : integer;
 
      univ_ln : RECORD
            CASE integer OF
                1:
                    (ln : tsp00_Line);
                2:
                    (n  : tsp00_Name)
                END;
            (*ENDCASE*) 
 
 
BEGIN
found := false;
curr  := m_nil;
REPEAT
    univ_ln.n := bsp_name;
    ln_len    := 0;
    g17messtype_to_line (curr, ln_len, univ_ln.ln);
    t09uppercase_line (univ_ln.ln, 1, sizeof (univ_ln.n));
    IF  univ_ln.n = mtype_value
    THEN
        found := true
    ELSE
        IF  curr = m_autosave
        THEN
            curr := m_nil
        ELSE
            curr := succ (curr)
        (*ENDIF*) 
    (*ENDIF*) 
UNTIL
    found OR (curr = m_nil);
(*ENDREPEAT*) 
IF  found
THEN
    buf [buf_pos] := chr (ord (curr))
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta14mtype2_assign (VAR mtype_value : tsp00_Name;
            VAR buf : tsp00_MoveObj;
            buf_pos : tsp00_Int4);
 
VAR
      found  : boolean;
      curr   : tgg00_MessType2;
      ln_len : integer;
 
      univ_ln : RECORD
            CASE integer OF
                1:
                    (ln : tsp00_Line);
                2:
                    (n  : tsp00_Name)
                END;
            (*ENDCASE*) 
 
 
BEGIN
found := false;
curr  := mm_nil;
REPEAT
    univ_ln.n := bsp_name;
    ln_len    := 0;
    g17mess2type_to_line (curr, ln_len, univ_ln.ln);
    t09uppercase_line (univ_ln.ln, 1, sizeof (univ_ln.n));
    IF  univ_ln.n = mtype_value
    THEN
        found := true
    ELSE
        IF  curr = mm_checkpoint
        THEN
            curr := mm_nil
        ELSE
            curr := succ (curr)
        (*ENDIF*) 
    (*ENDIF*) 
UNTIL
    found OR (curr = mm_nil);
(*ENDREPEAT*) 
IF  found
THEN
    buf [buf_pos] := chr (ord (curr))
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta14set_assign (VAR ln : tsp00_Line;
            ln_offset : integer;
            VAR buf   : tsp00_MoveObj;
            buf_pos   : tsp00_Int4);
 
CONST
      c_unused_bit_sign = '-';
 
VAR
      pos      : integer;
      curr_bit : integer;
 
      univ_set : RECORD
            CASE integer OF
                1:
                    (c : tsp00_C2);
                2:
                    (s : PACKED SET OF 0..7);
                END;
            (*ENDCASE*) 
 
 
BEGIN
univ_set.s := [ ];
curr_bit   := 0;
pos        := ln_offset + 1;
REPEAT
    WHILE (ln [pos] = ' ') AND (pos < sizeof (ln)) DO
        pos := pos + 1;
    (*ENDWHILE*) 
    IF  (ln [pos] <> c_unused_bit_sign) AND (ln [pos] <> ' ')
    THEN
        univ_set.s := univ_set.s + [curr_bit];
    (*ENDIF*) 
    WHILE (ln [pos] <> ' ') AND (pos < sizeof (ln)) DO
        pos := pos + 1;
    (*ENDWHILE*) 
    curr_bit := curr_bit + 1
UNTIL
    (curr_bit > 7) OR (pos >= sizeof (ln));
(*ENDREPEAT*) 
buf [buf_pos] := univ_set.c [1]
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
