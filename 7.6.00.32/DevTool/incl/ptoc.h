/* @(#)ptoc.h		2.0.5  1996-09-03  SQL DBS
 * Copyright SQL Datenbanksysteme GmbH, 1992, 1993
 *
 * 1.5.97 1994-Jan-10 J.Bruehe  ALPHA has correct 'memcmp' (unsigned), use it
 * 1.5.95 1993-Nov-11 Bruehe/Hofer  address arithmetic (vsp35 equivalent)
 * 1.5.95 1993-Oct-21 J.Bruehe  Omit the leading 't_' from '_iorechd'
 */

#include           <string.h>

#if defined (__OS2__) || defined (_WIN32)

#include           <stdio.h>
#include           <string.h>
#include           <math.h>
#include           <time.h>

#endif


#if defined (_WIN32)

#pragma warning (disable : 4047 4133 4146 4307 4308 4756 4116)

#if !defined(_System)
#define _System
#endif

#endif

#if defined(__OS2__) || defined(_WIN32)
#define sql__trunc(value)                           ((long)(value))
#define sql__sin(value)                             sin(value)
#define sql__srand(value)                           (long)sql__seed_v;sql__seed_v = (value)
#define sql__rd()                                   ( (double) (rand()) ) / (double) 32767;
#define sql__clock()                                ( (clock() * 1000) / CLOCKS_PER_SEC )
#define sql__ckl()                                  ( (clock() * 1000) / CLOCKS_PER_SEC )
#define sql__ucmp                                   memcmp

#define vabort() _vabort( __LINE__, __FILE__)
#endif


/*
 *  Function to use for memory-to-memory copy.
 */
#define __PTCCPY_ memcpy

/*
 *  Function to use for filling a block of memory with a byte pattern.
 */
#define _ptoc_MEMSET memset

/* T31 specific version obsolete for TOS 4.1 and higher */

/*
 *  Function to use for unsigned memory-to-memory comparison.
 *  Include all machines whose memcmp executes true unsigned comparison.
 *  All other machines use our own function sql__ucmp.
 */
#if T31 || SEQUENT || HP9 || NMP || ALPHA || SUN && SVR4 || __OS2__ || _WIN32
#define __PTCCMP_ memcmp
#else
#define __PTCCMP_ sql__ucmp
#endif

/*
 *  Condition when to use __PTCCPY_ instead of inline copy.
 *  If not defined, inline copy will not be used.
 *  If BYTE_STRUCT is defined, inline copy will always be used.
 */
#if __OS2__
#define __PTCUSECPY_(x) (((x)&1) || ((x) > 1000))
#else
#if T31
#define __PTCUSECPY_(x) (((x)&1) || ((x) > 100))
#else
#if I386
#define __PTCUSECPY_(x) ((x) > 180)
#else
#if SUN || sun
#define __PTCUSECPY_(x) ((x) > 10)
#else
#if HP9
#define __PTCUSECPY_(x) ((x) > 16)
#else
#if OSF1
/* #define __PTCUSECPY_(x,L,R) ((x) > 33 || ((x) > 43 && !L&7 && !R&7)) */
#define __PTCUSECPY_(x) ((x) > 33)
#else
#endif /*OSF1*/
#endif /*HP9*/
#endif /*SUN*/
#endif /*I386*/
#endif /*T31*/
#endif /*__OS2__*/

#if T31
#define sqlabs abs
#endif

/*
 *  _ptoc_ASSIGN
 */
#if BYTE_STRUCT
#define _ptoc_ASSIGN(typ,size,left,right) { \
        struct _ptoc_TEMPSTRUCT { typ space[size]; }; \
        *(struct _ptoc_TEMPSTRUCT *)(left) = \
        *(struct _ptoc_TEMPSTRUCT *)(right); \
        }
#else
#ifdef  __PTCUSECPY_
#define _ptoc_ASSIGN(typ,size,left,right) { \
        if ( __PTCUSECPY_(sizeof(typ)*size) ) \
            __PTCCPY_(left,right,sizeof(typ)*size); \
        else { \
            struct _ptoc_TEMPSTRUCT { typ space[size]; }; \
            *(struct _ptoc_TEMPSTRUCT *)(left) = \
            *(struct _ptoc_TEMPSTRUCT *)(right); \
            } \
        }
#else
#define _ptoc_ASSIGN(typ,size,left,right) { \
            __PTCCPY_(left,right,sizeof(typ)*size); \
        }
#endif /*__PTCUSECPY_*/
#endif /*BYTE_STRUCT*/

/*
 *  SQLMOVC generated by comppc for fixed length moves.
 */
#if BYTE_STRUCT
#define SQLMOVC(size1,size2,val1,p1,val2,p2,cnt) { \
        char *cval1 = (char*) val1 ; \
        char *cval2 = (char*) val2 ; \
        struct _ptoc_TEMPSTRUCT { char  space[cnt]; }; \
        if ((p1 + cnt - 1 > size1) || (p2 + cnt - 1 > size2) || \
            (p1 <= 0) || (p2 <= 0)) { \
            int *null = 0 ; \
            *null = 1 ; \
            } \
        *(struct _ptoc_TEMPSTRUCT *)(cval2+p2-1) = \
        *(struct _ptoc_TEMPSTRUCT *)(cval1+p1-1); \
        }
#else
#ifdef  __PTCUSECPY_
#define SQLMOVC(size1,size2,val1,p1,val2,p2,cnt) { \
        char *cval1 = (char*) val1 ; \
        char *cval2 = (char*) val2 ; \
        if ((p1 + cnt - 1 > size1) || (p2 + cnt - 1 > size2) || \
            (p1 <= 0) || (p2 <= 0)) { \
            int *null = 0 ; \
            *null = 1 ; \
            } \
        if ( __PTCUSECPY_(cnt) ) \
            __PTCCPY_(cval2+p2-1,cval1+p1-1,cnt); \
        else { \
            struct _ptoc_TEMPSTRUCT { char  space[cnt]; }; \
            *(struct _ptoc_TEMPSTRUCT *)(cval2+p2-1) = \
            *(struct _ptoc_TEMPSTRUCT *)(cval1+p1-1); \
            } \
        }
#else
#define SQLMOVC(size1,size2,val1,p1,val2,p2,cnt) { \
        s10mv(size1,size2,val1,p1,val2,p2,cnt); \
        }
#endif /*__PTCUSECPY_*/
#endif /*BYTE_STRUCT*/

#define _ptoc_MOVE(typ,size,left,right)   __PTCCPY_(left,right,sizeof(typ)*size)
#define _ptoc_MEMCMP(typ,size,left,right) __PTCCMP_(left,right,sizeof(typ)*size)

/*
 *  This is to prevent sign extension.   IST 29.04.92
 */
#if OSF1
#define sql__ord(x) ((unsigned long)(x))
#else
#define sql__ord(x) ((unsigned)(x))
#endif

#define PTOC_CONST(name,value) enum { name = value }

enum { l0_false = 0, l0_true = 1 };
enum { l0_minchar = '\0', l0_maxchar = '\177' };
enum { l0_minint = -2147483647, l0_maxint = 2147483647 };

typedef  struct {
    unsigned char (*_fileptr);
    int _lcount;
    int _llimit;
    int (*_fbuf);
} _iorechd ;

extern int        _argc;
extern int        *_argv;
extern int        *_envp;

#if defined (__OS2__) || defined (_WIN32)

extern _iorechd   sql__input;
extern _iorechd   sql__output;
extern _iorechd   sql__err;
extern _iorechd*  input;
extern _iorechd*  output;

#if defined (__OS2__) && defined (MFSIZE)
int        os2_argc;
char**     os2_argv;
#endif

#else

extern unsigned char sql__input[];
extern unsigned char sql__output[];
extern unsigned char sql__err[];

#define output  sql__output     /* problem in dump_hdg.P   JH*/
#define input   sql__input      /* problem in DSF.P        JB 1992-Jul-10 */

#endif


#if defined (__OS2__) || defined (_WIN32)

int            _System   sql__ic   ( int  , ... );
unsigned char* _System   sql__pcnst( void*, ... );
long*          _System   sql__scnst( void*, ... );

#else

extern long sql__clock();
extern int sql__ic();
extern double sql__rd();
extern long sql__srand();
extern double sql__sin();
extern long sql__trunc();

extern unsigned char *sql__pcnst();
extern long *sql__scnst();
#endif

extern long *sql__setadd();
extern double sql__atan();
extern long sql__ca();
extern double sql__cos();
extern void sql__perrorp();
extern int sql__catchae();
extern double sql__exp();
extern long sql__expp();
extern char *sql__nlf();
extern _iorechd *sql__gn();
extern double sql__ln();
extern long sql__max();
extern long *sql__multi();
extern char *sql__nname();
extern char *sql__nil();
extern long sql__pred();
extern _iorechd *sql__closep();
extern char sql__1r();
extern long sql__intr();
extern long sql__er();
extern double sql__lor();
extern int sql__nre();
extern int sql__erq();
extern int sql__ltl();
extern int sql__lel();
extern int sql__gtl();
extern int sql__ger();
extern long sql__round();
extern long sql__setrang();
extern double sql__sqrt();
extern long *sql__setmin();
extern long sql__succ();
extern int sql__endof();
extern int sql__endol();
extern _iorechd *sql__ut();
extern unsigned char    * sql__pstrcpy();
#if ! defined(__OS2__) && ! defined(_WIN32)
extern long               sql__ckl();
#endif
extern int                sql__compare();
extern int                sql__endof();
extern int                sql__endol();
extern unsigned char    * sql__psetadd();
extern unsigned char    * sql__psetco();
extern int                sql__psetge();
extern int                sql__psetgt();
extern int                sql__psetle();
extern int                sql__psetlt();
extern unsigned char    * sql__psetm();
extern unsigned char    * sql__pstrcat();
extern int                sql__pstrcomp();
extern unsigned char    * sql__setsub();
extern char             * sql__setco();
extern int                sql__ucmp();

#if !defined(__OS2__) && !defined(_WIN32)
#define vbegexcl (*vbegexcl_func_ptr)
#endif

#define s35add_bufaddr(addr,pos) \
    ((tsp_bufaddr) ((unsigned long) ( ((char *) addr) + (pos) ) ))

#define s35add_moveobj_ptr(addr,pos) \
    ((tsp_moveobj_ptr) ((unsigned long) ( ((char *) addr) + (pos) ) ))

#define s35add_addr1(addr,pos) \
    ((tsp00_Addr) ((unsigned long) ( ((char *) addr) + (pos-1) ) ))

#define s35inc_st(addr,pos) \
    ((tgg_st_entry_addr) ((unsigned long) ( ((tgg_stack_entry *) addr) + (pos) ) ))

#define s35lt_bufaddr(addr1,addr2) \
    ((char *) addr1 < (char *) addr2)

#define s35le_bufaddr(addr1,addr2) \
    ((char *) addr1 <= (char *) addr2)

#define s35gt_bufaddr(addr1,addr2) \
    ((char *) addr1 > (char *) addr2)

#define s35ge_bufaddr(addr1,addr2) \
    ((char *) addr1 >= (char *) addr2)

#define s35op_case(A,B,C,D) \
   (*A) (B,C,D)

