.ad 8
.bm 8
.fm 4
.bt $Copyright by   Software AG, 1993$$Page %$
.tm 12
.hm 6
.hs 3
.tt 1 $NME$Project Distributed Database System$vos12uc$
.tt 2 $$$
.tt 3 $R.Roedling$SQLARGS$1997-03-12$
***********************************************************
.nf


    ========== licence begin LGPL
    Copyright (C) 2002 SAP AG

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    ========== licence end

.fo
.nf
.sp
Module  :
=========
.sp
Purpose :
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :

.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :

.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :

.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : R.Roedling
.sp
.cp 3
Created : 1992-12-10
.sp
.cp 3
Version : 1994-01-27
.sp
.cp 3
Release :  6.2 	 Date : 1997-03-12
.br
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:

.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:

.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:

.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
/*PRETTY*/
//
//  MODULE - SQLARGS
//


//
//  INCLUDE FILES
//


//
//  DEFINES
//
#define MOD__  "VOS12UC : "
#define MF__   MOD__"UNDEFINED"


#define MAX_IDENT_CNT           3
#define OPT_AND_ARG_CNT         25

#define PRECOMPILER_OPTION_STRING                               \
       "CORTXYlcoVWswhiLqpezu:b:d:n:U:r:y:F:P:I:t:m:S:D:M:H:E:G:x:"

#define PRECOMPILER_RUNTIME_OPTION_STRING                       \
       "OTXNWRZfu:d:n:U:y:S:F:I:t:B:Y:L:x:"

#define DIALOG_COMPONENT_OPTION_STRING                          \
       "APVLTcsu:d:n:U:r:b:R:B:O:e:i:S:y:I:t:C:x:"

#define AUDIT_OPTION_STRING                                     \
       "Vu:d:n:U:S:I:t:y:c:l:o:x:N:"

#define ARGL_OPTION_STRING                                      \
        "u:d:r:b:"

#define USERX_OPTION_STRING                                     \
        "Vu:b:"

// Errortexts


//
//  MACROS
//
#ifdef DEBUG
static char _TmpStr[500 + 1] ;

#define _PToC(_Str) \
           (sql47c_ptoc( _TmpStr, _Str, min(sizeof(_Str),500)), _TmpStr)
#endif

#define PUTBIT(b,i)             \
        { b [ ( unsigned ) i / 8 ] |=  ( 1 << (( unsigned ) i % 8 )); }
#define CLRBIT(b,i)             \
        { b [ ( unsigned ) i / 8 ] &= ~( 1 << (( unsigned ) i % 8 )); }
#define TSTBIT(b,i)             \
        ( b [ ( unsigned ) i / 8 ] &   ( 1 << (( unsigned ) i % 8 ))  )


//
//  LOCAL TYPE AND STRUCT DEFINITIONS
//
typedef struct {
    PSZ                 pszIdent      [ MAX_IDENT_CNT ] ;
    LONG                lIdentLen     [ MAX_IDENT_CNT ] ;
    BOOL                bIdentToUpper [ MAX_IDENT_CNT ] ;
} CTU_REC;             // --- convert to upper structure

typedef  CTU_REC       *PCTU_REC;

typedef struct sql_arg_line_record {
    tsp_knl_identifier     username;
    NAME                   password;
    SQL_DBNAME             dbname;
    C12                    cmd;
    VF_FILENAME            filename;
    C40                    aname;
    LINE                   arguments;
} ARG_LINE_REC;
typedef ARG_LINE_REC*           PARG_LINE_REC;

//
//  EXTERNAL VARIABLES
//
extern int        sql80_OptInd;
extern int        sql80_OptErr;
extern char*      sql80_OptArg;



//
//  EXPORTED VARIABLES
//
#if defined(_WIN32)
  int     WinArgc;                // imported and set by ptoclib:_pmain.c
  char**  WinArgv;
#else
  int     os2_argc = 0;           // exported for ptoc
  char**  os2_argv = NULL;        // exported for ptoc
#endif


//
//  LOCAL VARIABLES
//


//
//  LOCAL FUNCTION PROTOTYPES
//

// === LOCAL FUNCTIONS FOR SQLARG3 ============================================

static VOID ArgsInit
            (   tsp4_xuser_record  *prcUserParams,
                SQL_PASSWORD        acPassword,
                tsp4_xuserset       ucXuserType,
                PBOOLEAN            pbEnvDBNameFound,
                PBOOLEAN            pbOk,
                ERRORTEXT           acErrorText     );

static VOID PrecompilerArgsInit
            (   tsp4_args_options  *prcArgsOptions  );

static VOID PrecompilerRunTimeArgsInit
            (   tsp4_args_options  *prcArgsOptions  );

static VOID DialogComponentArgsInit
            (   tsp4_args_options  *prcArgsOptions  );

static VOID AuditArgsInit
            (   tsp4_args_options  *prcArgsOptions  );

static VOID UserXArgsInit
            ( tsp4_args_options  *prcArgsOptions );

static VOID PrecompilerOptionsAnalysis
            (   tsp4_xuser_record  *prcUserParams,
                SQL_PASSWORD        acPassword,
                tsp4_args_options  *prcArgsOptions,
                tsp4_xuserset       ucXuserType,
                INT                 nArgumentCount,
                PCHAR*              apszArguments,
                BOOLEAN             bEnvDBNameFound,
                PBOOLEAN            pbOk,
                ERRORTEXT           acErrorText     );

static VOID PrecompilerRunTimeOptionsAnalysis
            (   tsp4_xuser_record  *prxUserParams,
                SQL_PASSWORD        acPassword,
                tsp4_args_options  *prcArgsOptions,
                tsp4_xuserset       ucXuserType,
                INT                 nArgc,
                PCHAR*              apszArgv,
                BOOLEAN             bEnvDBNameFound,
                PBOOLEAN            pbOk,
                ERRORTEXT           acErrorText     );

static VOID DialogComponentOptionsAnalysis
            (   tsp4_xuser_record  *prcUserParams,
                SQL_PASSWORD        acPassword,
                tsp4_args_options  *prcArgsOptions,
                tsp4_xuserset       ucXuserType,
                INT                 nArgumentCount,
                PCHAR*              apszArguments,
                BOOLEAN             bEnvDBNameFound,
                PBOOLEAN            pbOk,
                ERRORTEXT           acErrorText     );

static VOID UserXOptionsAnalysis
            (   tsp4_xuser_record  *prcUserParams,
                SQL_PASSWORD        acPassword,
                tsp4_args_options  *prcArgsOptions,
                tsp4_xuserset       ucXuserType,
                INT                 nArgumentCount,
                PCHAR*              apszArguments,
                BOOLEAN             bEnvDBNameFound,
                PBOOLEAN            pbOk,
                ERRORTEXT           acErrorText         );

static VOID AuditOptionsAnalysis
            (   tsp4_xuser_record  *prcUserParams,
                SQL_PASSWORD        acPassword,
                tsp4_args_options  *prcArgsOptions,
                tsp4_xuserset       ucXuserType,
                INT                 nArgumentCount,
                PCHAR*              apszArguments,
                BOOLEAN             bEnvDBNameFound,
                PBOOLEAN            pbOk,
                ERRORTEXT           acErrorText     );


static VOID MakeArgs
            (   INT                 nOptionChar,
                tsp4_component      eComponent,
                tsp4_xuser_record  *prcUserParams,
                tsp4_args_options  *prcArgsOptions,
                tsp4_xuserset       ucXuserType,
                INT                 nArgc,
                PCHAR*              apszArgv,
                BOOLEAN             bEnvDBNameFound,
                ERRORTEXT           acErrorText,
                PBOOLEAN            pbOk            );

static VOID MakeMyArgs
            (   INT                 nOptionChar,
                tsp4_component      eComponent,
                tsp4_xuser_record  *prcUserParams,
                tsp4_args_options  *prcArgsOptions,
                tsp4_xuserset       ucXuserType,
                INT                 nArgc,
                PCHAR*              apszArgv,
                BOOLEAN             bEnvDBNameFound,
                ERRORTEXT           acErrorText,
                PBOOLEAN            pbOk            );

static VOID MakeUserPassword
            (   tsp4_xuser_record  *prcUserParams,
                SQL_PASSWORD        acPassword,
                PBOOLEAN            pbOk,
                ERRORTEXT           acErrorText     );

static VOID MakeDBId
            (   tsp4_xuser_record  *prcUserParams,
                tsp4_xuserset       ucXuserType     );

static VOID MakeDBNode
            (   tsp4_xuser_record  *prcUserParams,
                tsp4_xuserset       ucXuserType     );

static VOID MakeDBLang
            (   tsp4_xuser_record  *prcUserParams,
                tsp4_xuserset       ucXuserType     );

static VOID MakeUserKey
            (   tsp4_xuser_record  *prcUserParams,
                tsp4_xuserset       ucXuserType,
                BOOLEAN             bEnvDBNameFound,
                ERRORTEXT           acErrorText,
                PBOOLEAN            pbOk            );

static VOID MakeSqlMode
            (   tsp4_xuser_record  *prcUserParams,
                tsp4_xuserset       ucXuserType     );

static VOID MakeIsolation
            (   tsp4_xuser_record  *prcUserParams ,
                tsp4_xuserset       ucXuserType     );

static VOID MakeTimeOut
            (   tsp4_xuser_record  *prcUserParams,
                tsp4_xuserset       ucXuserType     );

static VOID MakeCacheLimit
            (   tsp4_xuser_record  *prcUserParams,
                tsp4_xuserset       ucXuserType     );

static VOID MakePrecompilerInputFn
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakePrecompilerTraceFn
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakePrecompilerProgFn
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakePrecompilerMargin
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakePrecompilerDateTime
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakePrecompilerSysTpMon
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakePrecompilerMode
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakePrecompilerCAnsi
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakePrecompilerUnicode
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakePrecompilerPacketSize
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakePrecompilerRunTimeTraceFn
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakePrecompilerRunTimeMFetch
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakePrecompilerRunTimeStmtCnt
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakePrecompilerRunTimeLimit
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakeDialogComponentRFn
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakeDialogComponentBFn
            (   tsp4_args_options  *prcArgsOptions );

static VOID MakeDialogComponentObj
            (   tsp4_args_options  *prcArgsOptions,
                tsp4_command_mode   OptCommMode,
                INT                 nMaxObjNames,
                PBOOLEAN            pbOk,
                ERRORTEXT           acErrorText     );

static VOID MakeDialogComponentCodeType
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakeDialogComponentExport
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakeDialogComponentImport
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakeAuditCntrl
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakeAuditLogfile
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakeAuditLogBlockSize
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakeAuditOutput
            (   tsp4_args_options  *prcArgsOptions  );

static VOID MakeUserXComponentBFn
            (   tsp4_args_options  *prcArgsOptions  );


// === LOCAL FUNCTIONS FOR SQLARGS, SQLARGL ===================================

static VOID MakeUserPasswordLine
            (   PARG_LINE_REC       prcArgLine,
                PBOOLEAN            pbUserNameFound,
                PBOOLEAN            pbPasswordFound     );

static VOID MakeDBName
            (   PCHAR*              apszArgv,
                PARG_LINE_REC       prcArgLine,
                PBOOLEAN            pbDBNameFound       );

static VOID MakeCmd
            (   PCHAR               pszCmdType,
                PARG_LINE_REC       prcArgLine,
                PBOOLEAN            pbCmdFound,
                PBOOLEAN            pbFileNameFound     );

static VOID MakeArgLine
            (   INT                 nArgc,
                PCHAR*              apszArgv,
                PARG_LINE_REC       prcArgLine,
                PBOOLEAN            pbArgumentsFound,
                PBOOLEAN            pbCmdFound,
                PBOOLEAN            pbFileNameFound,
                INT                 nOptionChar         );

static VOID MakeLine
            (   PCHAR               pszArgIn,
                PINT                pnArgInIndex,
                INT                 nLineLength,
                INT                 nSeparator,
                PINT                pnArgOutIndex,
                PCHAR               pszArgOut           );

static VOID BuildArgLineFromStruct
            (   PCHAR               psArgs,
                PARG_LINE_REC       prcArgLineRec,
                BOOLEAN             bUserNameFound,
                BOOLEAN             bPasswordFound,
                BOOLEAN             bDBNameFound,
                BOOLEAN             bCmdFound,
                BOOLEAN             bFileNameFound,
                BOOLEAN             bArgumentsFound     );


// === OTHER LOCAL FUNCTIONS ==================================================


static VOID MoveToUpper         (   PCHAR       psString,
                                    INT         nStringSize          );

static VOID CheckIdents         (   PCTU_REC    pCtU,
                                    CHAR        cSep,
                                    LONG        lMaxIdent,
                                    PBOOLEAN    pbOk,
                                    ERRORTEXT   acErrorText          );
static INT  StrLen              (   CHAR*       psStr,
                                    INT         nLength              );

static INT  StrChr              (   CHAR*       pszStr,
                                    INT         nCharacter,
                                    INT         nBegin,
                                    INT         nEnd                 );


//
// ========================== GLOBAL FUNCTIONS ================================
//

VOID _stdcall sc_sqlarg3 (  tsp4_xuser_record  *prcUserParams,
                            SQL_PASSWORD        acPassword,
                            tsp4_args_options  *prcArgsOptions,
                            tsp4_xuserset       aucXuserType,
                            ERRORTEXT           acErrorText,
                            PBOOLEAN            pbOk  )
  {
  #undef  MF__
  #define MF__ MOD__"sc_sqlarg3"

  DBGPAS;

  sc_sqlarg3 ( prcUserParams, acPassword, prcArgsOptions,
               aucXuserType, acErrorText, pbOk  );
  }

/*------------------------------*/

VOID    sqlarg3 (   tsp4_xuser_record  *prcUserParams,
                    SQL_PASSWORD        acPassword,
                    tsp4_args_options  *prcArgsOptions,
                    tsp4_xuserset       aucXuserType,
                    ERRORTEXT           acErrorText,
                    PBOOLEAN            pbOk            )
{
    #undef  MF__
    #define MF__ MOD__"sqlarg3"


    tsp4_component eComponent;
    INT            nArgc;
    PCHAR*         apszArgv;
    BOOLEAN        bEnvDBNameFound;


    DBGIN;

    // initialize some of the return parameter
    ArgsInit ( prcUserParams, acPassword,
               aucXuserType, &bEnvDBNameFound, pbOk, acErrorText );

    sql80_OptInd  = 1;
    sql80_OptErr  = 0;
    sql80_OptArg  = NULL;

    // look for the component within the option record
    // it must be in the correct range
    eComponent = prcArgsOptions -> opt_component;

    if ((( INT ) eComponent < COMP_PRECOMPILER ) ||
        (( INT ) eComponent > COMP_PARAM       )) {

        *pbOk = FALSE;

        DBG1 (( MF__, ERRMSG_NO_COMP_SPECIFIED ));
        MSGD  (( ERR_NO_COMP_SPECIFIED ));
        sql46c_build_error_string ( acErrorText, ERRMSG_NO_COMP_SPECIFIED, 0 );

        DBGOUT;
        return;
    }


    #if defined(_WIN32)
      nArgc    = WinArgc;
      apszArgv = WinArgv;
    #else
      // return of the addresses of nArgc and apszArgv
      // ( not the system argv and argc !!!! )
      nArgc    = os2_argc;   // exported from ptoc
      apszArgv = os2_argv;   // exported from ptoc
    #endif

    DBG3 (( MF__, "nArgc = %d", nArgc ));
    if ( nArgc > 0 ) {
        DBG3 (( MF__, "apszArgv [ 0 ] = \"%s\"", apszArgv [ 0 ] ));
        DBG3 (( MF__, "apszArgv [ nArgc - 1 ] = \"%s\"",
                       apszArgv [ nArgc - 1 ] ));
    }


    // jump to the component's option analysis

    DBG3 (( MF__, "Component = %d", eComponent ));

    switch ( eComponent ) {
        case COMP_PRECOMPILER :
            PrecompilerArgsInit ( prcArgsOptions );
            PrecompilerOptionsAnalysis ( prcUserParams, acPassword,
                                         prcArgsOptions, aucXuserType,
                                         nArgc, apszArgv,
                                         bEnvDBNameFound, pbOk, acErrorText );
        break;

        case COMP_PC_RUNTIME :
            PrecompilerRunTimeArgsInit ( prcArgsOptions );
            PrecompilerRunTimeOptionsAnalysis ( prcUserParams, acPassword,
                                                prcArgsOptions, aucXuserType,
                                                nArgc, apszArgv,
                                                bEnvDBNameFound,
                                                pbOk, acErrorText );
        break;

        case COMP_EASY    :
        case COMP_QUERY   :
        case COMP_DIALOG  :
        case COMP_APPL    :
        case COMP_LOAD    :
        case COMP_UTILITY :
        case COMP_PARAM   :
            DialogComponentArgsInit ( prcArgsOptions );
            DialogComponentOptionsAnalysis ( prcUserParams, acPassword,
                                             prcArgsOptions, aucXuserType,
                                             nArgc, apszArgv, bEnvDBNameFound,
                                             pbOk, acErrorText );
        break;

        case COMP_AUDIT :
            AuditArgsInit ( prcArgsOptions );
            AuditOptionsAnalysis ( prcUserParams, acPassword,
                                   prcArgsOptions, aucXuserType,
                                   nArgc, apszArgv,
                                   bEnvDBNameFound, pbOk, acErrorText );
        break;
        case COMP_USER    :
            UserXArgsInit ( prcArgsOptions );
            UserXOptionsAnalysis ( prcUserParams, acPassword,
                                   prcArgsOptions, aucXuserType,
                                   nArgc, apszArgv,
                                   bEnvDBNameFound, pbOk, acErrorText );
        break;
    }

    DBG3 (( MF__, "Password = \"%s\"", _PToC( acPassword )));
    DBG3 (( MF__, "prcUserParams -> xu_serverdb = \"%s\"",
                   _PToC( prcUserParams -> xu_serverdb )));
    DBG3 (( MF__, "prcUserParams -> xu_dblang   = \"%s\"",
                   _PToC( prcUserParams -> xu_dblang   )));

    DBGOUT;
}

/*------------------------------*/

VOID _stdcall sc_sqlargl ( argline acArgs  )
  {
  #undef  MF__
  #define MF__ MOD__"sc_sqlargl"

  DBGPAS;

  sqlargl ( acArgs );
  }

/*------------------------------*/

VOID    sqlargl (   argline acArgs  )
{
    #undef  MF__
    #define MF__ MOD__"sqlargl"
    PCHAR*          apszArgv;
    INT             nArgc;
    INT             nOptionChar;
    BOOLEAN         bMoreArgs;
    BOOLEAN         bUserNameFound  = FALSE;
    BOOLEAN         bPasswordFound  = FALSE;
    BOOLEAN         bDBNameFound    = FALSE;
    BOOLEAN         bCmdFound       = FALSE;
    BOOLEAN         bFileNameFound  = FALSE;
    BOOLEAN         bArgumentsFound = FALSE;
    ARG_LINE_REC    rcArgLine;


    DBGIN;

    // initialize return parameter
    memset (( PCHAR ) acArgs, ' ', MAXARGLINELENGTH);

    // initialize internel vars
    bMoreArgs   = TRUE;
    nOptionChar = ' ';

    // initialize global and extern vars
    sql80_OptInd  = 1;
    sql80_OptErr  = 0;
    sql80_OptArg  = NULL;

    #if defined(_WIN32)
      nArgc    = WinArgc;
      apszArgv = WinArgv;
    #else
      // return of the addresses of nArgc and apszArgv
      // ( not the system argv and argc !!!! )
      nArgc    = os2_argc;   // exported from ptoc
      apszArgv = os2_argv;   // exported from ptoc
    #endif

    DBG3 (( MF__, "argc              = %d", nArgc                      ));
    DBG3 (( MF__, "argv [ 0 ]        = \"%s\"", apszArgv [ 0 ]         ));
    DBG3 (( MF__, "argv [ argc - 1 ] = \"%s\"", apszArgv [ nArgc - 1 ] ));

    // parameter existing?
    if ( nArgc > 1 ) {
        // get options
        while ((( nOptionChar =
                      sql80_GetOpt ( nArgc, apszArgv, ARGL_OPTION_STRING )) != -1 ) &&
                  bMoreArgs ) {

            DBG3 (( MF__, "nOptionChar   = %c", nOptionChar ));
            DBG3 (( MF__, "sql80_OptInd = %d", sql80_OptInd ));

            switch ( nOptionChar ) {
                case 'u' :
                    MakeUserPasswordLine ( &rcArgLine, &bUserNameFound,
                                           &bPasswordFound );
                break;

                case 'd' :
                    MakeDBName ( apszArgv, &rcArgLine, &bDBNameFound );
                break;

                case 'r' :
                    MakeCmd ( "run", &rcArgLine, &bCmdFound, &bFileNameFound );
                break;

                case 'b' :
                    MakeCmd ( "batch", &rcArgLine,
                              &bCmdFound, &bFileNameFound );
                break;

                case '?' :
                    MakeArgLine ( nArgc, apszArgv, &rcArgLine,
                                  &bArgumentsFound, &bCmdFound,
                                  &bFileNameFound, '?' );
                    bMoreArgs = FALSE;
                break;
            }
        }

        // get other arguments
        if ( bMoreArgs )
            MakeArgLine ( nArgc, apszArgv, &rcArgLine,
                          &bArgumentsFound, &bCmdFound, &bFileNameFound, ' ' );

        // build up the arg line using the elements from sal structure
        BuildArgLineFromStruct ( acArgs, &rcArgLine, bUserNameFound,
                                 bPasswordFound, bDBNameFound,
                                 bCmdFound, bFileNameFound, bArgumentsFound );
    }

    DBGOUT;
}

//
// ========================== LOCAL FUNCTIONS =================================
//


static VOID ArgsInit    (   tsp4_xuser_record  *prcUserParams,
                            SQL_PASSWORD        acPassword,
                            tsp4_xuserset       ucXuserType,
                            PBOOLEAN            pbEnvDBNameFound,
                            PBOOLEAN            pbOk,
                            ERRORTEXT           acErrorText     )
{
    #undef  MF__
    #define MF__ MOD__"ArgsInit"


    tsp4_xuser_record   rcLocalUserParams;
    APIRET              rc;
    PSZ                 pszServerDB, pszDBLang ;


    DBGIN;

    *pbOk = TRUE ;

    // defaults of return parameters outside the option record
    *pbEnvDBNameFound = FALSE ;

    memset ( prcUserParams -> xu_servernode, ' ',
             sizeof ( prcUserParams -> xu_servernode ));


    *pbEnvDBNameFound = sql01c_get_serverdb ( &pszServerDB );

    if ( *pbEnvDBNameFound == TRUE )
      sql47c_ctop ( prcUserParams -> xu_serverdb, pszServerDB,
                    sizeof ( prcUserParams -> xu_serverdb ));
    else
      memset ( prcUserParams -> xu_serverdb, ' ',
               sizeof ( prcUserParams -> xu_serverdb ));

    memset ( prcUserParams -> xu_user,     ' ',
             sizeof ( prcUserParams -> xu_user));
    memset ( prcUserParams -> xu_password, '\0',
             sizeof ( prcUserParams -> xu_password ));
    memset ( prcUserParams -> xu_sqlmode,  ' ',
             sizeof ( prcUserParams -> xu_sqlmode ));

    prcUserParams -> xu_cachelimit = - 1 ;
    prcUserParams -> xu_timeout    = - 1 ;
    prcUserParams -> xu_isolation  = - 1 ;

    memset ( acPassword,  ' ',  sizeof ( SQL_PASSWORD ));
    memset ( ucXuserType, '\0', sizeof ( tsp4_xuserset )) ;

    if ( sql01c_get_dblang ( &pszDBLang ) )
      sql47c_ctop ( prcUserParams -> xu_dblang, pszDBLang,
                    sizeof ( prcUserParams -> xu_dblang ));
    else
      memset ( prcUserParams -> xu_dblang, ' ',
                    sizeof ( prcUserParams -> xu_dblang ));

    PUTBIT ( ucXuserType, SP4XU_SQL_USERMASK );

    // --- xu_key = DEFAULT_USER, check for errors
    memcpy ( rcLocalUserParams.xu_key, DEFAULT_USER,
             sizeof ( rcLocalUserParams.xu_key ));

    DBG3 (( MF__, "rcLocalUserParams.xu_key = \"%s\"",
                   _PToC ( rcLocalUserParams.xu_key )));

    rc = sql13u_getuser ( &rcLocalUserParams, acErrorText );

    if ( rc == ERROR_ACCESS_DENIED )
        *pbOk = FALSE;


    if ( rc == NO_ERROR ) {
        memcpy ( prcUserParams -> xu_user,
                 rcLocalUserParams.xu_user,
                 sizeof ( prcUserParams -> xu_user ));
        memcpy ( prcUserParams -> xu_password,
                 rcLocalUserParams.xu_password,
                 sizeof ( prcUserParams -> xu_password ));
        memcpy ( prcUserParams -> xu_sqlmode,
                 rcLocalUserParams.xu_sqlmode,
                 sizeof ( prcUserParams -> xu_sqlmode ));
        memcpy ( prcUserParams -> xu_servernode,
                 rcLocalUserParams.xu_servernode,
                 sizeof ( prcUserParams -> xu_servernode ));
        memcpy ( prcUserParams -> xu_serverdb,
                 rcLocalUserParams.xu_serverdb,
                 sizeof ( prcUserParams -> xu_serverdb ));
        memcpy ( prcUserParams -> xu_dblang,
                 rcLocalUserParams.xu_dblang,
                 sizeof ( prcUserParams -> xu_dblang ));

//      MoveToUpper ( prcUserParams -> xu_serverdb,
//                    sizeof (  prcUserParams -> xu_serverdb ));

        prcUserParams -> xu_cachelimit = rcLocalUserParams.xu_cachelimit;
        prcUserParams -> xu_timeout    = rcLocalUserParams.xu_timeout;
        prcUserParams -> xu_isolation  = rcLocalUserParams.xu_isolation;

        PUTBIT ( ucXuserType, SP4XU_SQL_USERDEFAULT );
        CLRBIT ( ucXuserType, SP4XU_SQL_USERMASK );

        *pbEnvDBNameFound = FALSE ;
    }

    if ( *pbEnvDBNameFound ) {
        PUTBIT ( ucXuserType, SP4XU_SQL_SERVERDB );
        DBG3 (( MF__, "DBName in environment" ));
    }

    DBG3 (( MF__, "prcUserParams -> xu_key = \"%s\"",
                   _PToC ( prcUserParams -> xu_key )));

    DBG3 (( MF__, "prcUserParams -> xu_servernode = \"%s\"",
                   _PToC ( prcUserParams -> xu_servernode )));

    DBG3 (( MF__, "prcUserParams -> xu_serverdb = \"%s\"",
                   _PToC ( prcUserParams -> xu_serverdb )));

    DBG3 (( MF__, "prcUserParams -> xu_user = \"%s\"",
                   _PToC ( prcUserParams -> xu_user )));

    DBG3 (( MF__, "Password = \"%s\"",
                   _PToC ( prcUserParams -> xu_password )));

    DBG3 (( MF__, "prcUserParams -> xu_sqlmode = \"%s\"",
                   _PToC ( prcUserParams -> xu_sqlmode )));

    DBG3 (( MF__, "prcUserParams -> xu_cachelimit = %d",
                   prcUserParams -> xu_cachelimit ));

    DBG3 (( MF__, "prcUserParams -> xu_timeout = %d",
                   prcUserParams -> xu_timeout ));

    DBG3 (( MF__, "prcUserParams -> xu_isolation = %d",
                   prcUserParams -> xu_isolation ));

    DBG3 (( MF__, "DB Name found = %f", *pbEnvDBNameFound ));

    DBGOUT;
}



/*------------------------------*/


static VOID PrecompilerArgsInit (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"PrecompilerArgsInit"


    DBGIN;

    // defaults for the option record PRECOMPILER
    memset ( prcArgsOptions -> components.prec.opt_modulefn, ' ',
             sizeof ( prcArgsOptions -> components.prec.opt_modulefn ));

    memset ( prcArgsOptions -> components.prec.opt_tracefile, ' ',
             sizeof ( prcArgsOptions -> components.prec.opt_tracefile ));

    prcArgsOptions -> components.prec.opt_prognamel = 0;
    memset ( prcArgsOptions -> components.prec.opt_progname, ' ',
             sizeof ( prcArgsOptions -> components.prec.opt_progname ));

    prcArgsOptions -> components.prec.opt_modulenamel = 0;
    memset ( prcArgsOptions -> components.prec.opt_modulename, ' ',
             sizeof ( prcArgsOptions -> components.prec.opt_modulename ));

    prcArgsOptions -> components.prec.opt_tpmonidl = 0;
    memset ( prcArgsOptions -> components.prec.opt_tpmonid, ' ',
             sizeof ( prcArgsOptions -> components.prec.opt_tpmonid ));

    prcArgsOptions -> components.prec.opt_begmar   = 0;
    prcArgsOptions -> components.prec.opt_endmar   = 0;
    prcArgsOptions -> components.prec.opt_prof     = 1;
    prcArgsOptions -> components.prec.opt_trace    = 0;
    prcArgsOptions -> components.prec.opt_fnind    = 0;
    prcArgsOptions -> components.prec.opt_datetime = 1;
    prcArgsOptions -> components.prec.opt_dyn      = 0;
    prcArgsOptions -> components.prec.opt_tpmon    = 0;
    prcArgsOptions -> components.prec.opt_mode     = 2;
    prcArgsOptions -> components.prec.opt_extern   = 1;
    prcArgsOptions -> components.prec.opt_cansi    = 0;
    prcArgsOptions -> components.prec.opt_comp     = 1;
    prcArgsOptions -> components.prec.opt_packetsize= 0;

    prcArgsOptions -> components.prec.opt_list        = FALSE;
    prcArgsOptions -> components.prec.opt_precom      = FALSE;
    prcArgsOptions -> components.prec.opt_traceswitch = FALSE;
    prcArgsOptions -> components.prec.opt_comment     = FALSE;
    prcArgsOptions -> components.prec.opt_silent      = FALSE;
    prcArgsOptions -> components.prec.opt_nowarn      = FALSE;
    prcArgsOptions -> components.prec.opt_lineno      = FALSE;
    prcArgsOptions -> components.prec.opt_lib         = FALSE;
    prcArgsOptions -> components.prec.opt_quote       = TRUE;
    prcArgsOptions -> components.prec.opt_decpoint    = TRUE;
    prcArgsOptions -> components.prec.opt_tabformat   = FALSE;
    prcArgsOptions -> components.prec.opt_version     = FALSE;
    prcArgsOptions -> components.prec.opt_help        = FALSE;
    prcArgsOptions -> components.prec.opt_unicode     = FALSE;

    prcArgsOptions -> components.prec.opt_quo   = '\'';
    prcArgsOptions -> components.prec.opt_point = '.';

    memset ( prcArgsOptions->components.prec.opt_puser_args, ' ',
             sizeof ( prcArgsOptions->
                      components.prec.opt_puser_args ));

    DBGOUT;
}


/*------------------------------*/


static VOID PrecompilerRunTimeArgsInit
            (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"PrecompilerRunTimeArgsInit"


    DBGIN;

    // defaults for the option record PRECOMPILER RUNTIME
    memset ( prcArgsOptions -> components.pc_rt.opt_rtracefile,
             ' ',
             sizeof ( prcArgsOptions -> components.pc_rt.opt_rtracefile ));

    prcArgsOptions->components.pc_rt.opt_rtrace      = 0;
    prcArgsOptions->components.pc_rt.opt_rprof       = 0;
    prcArgsOptions->components.pc_rt.opt_rmfetch     = 1;
    prcArgsOptions->components.pc_rt.opt_rstmt_cnt   = 0;
    prcArgsOptions->components.pc_rt.opt_rtime_limit = 0;
    prcArgsOptions->components.pc_rt.opt_rfiller     = 0;

    prcArgsOptions ->
    components.pc_rt.opt_rnotracetime = FALSE;
    prcArgsOptions ->
    components.pc_rt.opt_rtraceswitch = FALSE;
    prcArgsOptions ->
    components.pc_rt.opt_rnosdf       = FALSE;
    prcArgsOptions ->
    components.pc_rt.opt_rfiller1     = FALSE;

    memset ( prcArgsOptions->
               components.pc_rt.opt_ruser_args, ' ',
             sizeof ( prcArgsOptions->
               components.pc_rt.opt_ruser_args ));

    DBGOUT;
}



/*------------------------------*/


static VOID DialogComponentArgsInit (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"DialogComponentArgsInit"


    DBGIN;

    // defaults for the option record DIALOG COMPONENTS AND UTILITY
    memset ( prcArgsOptions -> components.dcomp_util.opt_object_owner,
             ' ',
             sizeof ( prcArgsOptions -> components.dcomp_util.opt_object_owner));

    memset ( prcArgsOptions -> components.dcomp_util.opt_object_name1,
             ' ',
             sizeof ( prcArgsOptions -> components.dcomp_util.opt_object_name1));

    memset ( prcArgsOptions -> components.dcomp_util.opt_object_name2,
             ' ',
             sizeof ( prcArgsOptions -> components.dcomp_util.opt_object_name2));

    memset ( prcArgsOptions -> components.dcomp_util.opt_runfile,
             ' ',
             sizeof ( prcArgsOptions -> components.dcomp_util.opt_runfile ));

    memset ( prcArgsOptions -> components.dcomp_util.opt_parameter,
             ' ',
             sizeof ( prcArgsOptions -> components.dcomp_util.opt_parameter ));

    prcArgsOptions -> components.dcomp_util.opt_append    = FALSE;
    prcArgsOptions -> components.dcomp_util.opt_prompt    = FALSE;
    prcArgsOptions -> components.dcomp_util.opt_codeonly  = FALSE;
    prcArgsOptions -> components.dcomp_util.opt_utility_session  = FALSE;

    prcArgsOptions -> components.dcomp_util.opt_comm_mode = SP4CM_SQL_NONE;
    prcArgsOptions -> components.dcomp_util.opt_code      = is_codeneutral;

    DBGOUT;
}


/*------------------------------*/


static VOID AuditArgsInit   (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"AuditArgsInit"


    DBGIN;

    // defaults for the option record AUDIT
    memset ( prcArgsOptions -> components.aud.opt_aud_control, ' ',
             sizeof ( prcArgsOptions -> components.aud.opt_aud_control ));

    memset ( prcArgsOptions -> components.aud.opt_aud_logfile, ' ',
             sizeof ( prcArgsOptions -> components.aud.opt_aud_logfile ));

    memset ( prcArgsOptions -> components.aud.opt_aud_output, ' ',
             sizeof ( prcArgsOptions -> components.aud.opt_aud_output ));

    prcArgsOptions -> components.aud.opt_aud_log_blocksize = 8 ;
    prcArgsOptions -> components.aud.opt_aud_comm_mode = SP4CM_SQL_NONE;

    DBGOUT;
}


/*------------------------------*/


static VOID UserXArgsInit ( tsp4_args_options  *prcArgsOptions )
{
    #undef  MF__
    #define MF__ MOD__"UserXArgsInit"


    DBGIN;

    // defaults for the option record USERX
    memset ( prcArgsOptions -> components.ux.opt_ux_runfile, ' ',
             sizeof ( prcArgsOptions -> components.ux.opt_ux_runfile ));

    prcArgsOptions -> components.ux.opt_ux_comm_mode = SP4CM_SQL_NONE;

    DBGOUT;
}



/*------------------------------*/


static VOID PrecompilerOptionsAnalysis
            (   tsp4_xuser_record  *prcUserParams,
                SQL_PASSWORD        acPassword,
                tsp4_args_options  *prcArgsOptions,
                tsp4_xuserset       ucXuserType,
                INT                 nArgumentCount,
                PCHAR*              apszArguments,
                BOOLEAN             bEnvDBNameFound,
                PBOOLEAN            pbOk,
                ERRORTEXT           acErrorText         )
{
    #undef  MF__
    #define MF__ MOD__"PrecompilerOptionsAnalysis"


    BOOLEAN bMoreArgs;
    INT     nOptionChar;


    DBGIN;

    // initialize internel vars
    bMoreArgs   = TRUE;
    nOptionChar = ' ';

    DBG3 (( MF__, "nArgumentCount = %d", nArgumentCount ));

    // parameter existing ?
    if ( nArgumentCount > 1 ) {
        // get options
        while ((( nOptionChar =
                      sql80_GetOpt ( nArgumentCount, apszArguments,
                                      PRECOMPILER_OPTION_STRING )) != -1 ) &&
                  bMoreArgs                                                &&
                  *pbOk ) {

            DBG3 (( MF__, "Option character = %c", nOptionChar ));
            DBG3 (( MF__, "sql80_OptInd = %d", sql80_OptInd ));

            switch ( nOptionChar ) {
                // general option args
                case 'u' :
                    MakeUserPassword ( prcUserParams,
                                       acPassword, pbOk, acErrorText );
                    PUTBIT ( ucXuserType, SP4XU_SQL_USERPARMS );
                    CLRBIT ( ucXuserType, SP4XU_SQL_USERMASK );
                break;

                case 'd' :
                    MakeDBId ( prcUserParams, ucXuserType );
                break;

                case 'n' :
                    MakeDBNode ( prcUserParams, ucXuserType);
                break;

                case 'U' :
                    MakeUserKey ( prcUserParams, ucXuserType,
                                  bEnvDBNameFound, acErrorText, pbOk );
                break;

                case 'S' :
                    MakeSqlMode ( prcUserParams, ucXuserType );
                break;

                case 'I' :
                    MakeIsolation ( prcUserParams, ucXuserType);
                break;

                case 't' :
                    MakeTimeOut ( prcUserParams, ucXuserType );
                break;

                case 'y' :
                    MakeCacheLimit ( prcUserParams, ucXuserType );
                break;

                case 'x' :
                    MakeDBLang ( prcUserParams, ucXuserType);
                break;

                // option args with arguments

                case 'r' :
                    MakePrecompilerInputFn ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'F' :
                    MakePrecompilerTraceFn ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'P' :
                    MakePrecompilerProgFn ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'm' :
                    MakePrecompilerMargin ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'D' :
                    MakePrecompilerDateTime ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'M' :
                    MakePrecompilerSysTpMon ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'H' :
                    MakePrecompilerMode ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'E' :
                    MakePrecompilerCAnsi ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'G' :
                    MakePrecompilerUnicode ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'b' :
                    MakePrecompilerPacketSize ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                // optargs with no arguments
                case 'C' :
                    prcArgsOptions -> components.prec.opt_comp = 0;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );

                    DBG3 (( MF__, "opt_comp = %d",
                                   prcArgsOptions ->
                                   components.prec.opt_comp ));
                break;

                case 'R' :
                    prcArgsOptions -> components.prec.opt_prof = 0;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_prof = %d",
                                   prcArgsOptions ->
                                   components.prec.opt_prof ));
                break;

                case 'O' :
                    prcArgsOptions ->
                    components.prec.opt_trace = 4;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_trace = %d",
                                   prcArgsOptions ->
                                   components.prec.opt_trace ));
                break;

                case 'T' :
                    prcArgsOptions ->
                    components.prec.opt_trace = 2;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_trace = %d",
                                   prcArgsOptions ->
                                   components.prec.opt_trace ));
                break;

                case 'X' :
                    prcArgsOptions ->
                    components.prec.opt_trace = 3;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_trace = %d",
                                   prcArgsOptions ->
                                   components.prec.opt_trace ));
                break;

                case 'Y' :
                    prcArgsOptions -> components.prec.opt_dyn = 1;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_dyn = %d",
                                   prcArgsOptions ->
                                   components.prec.opt_dyn ));
                break;

                case 'l' :
                    prcArgsOptions ->
                    components.prec.opt_list = TRUE;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_list = %d",
                                   prcArgsOptions ->
                                   components.prec.opt_list ));
                break;

                case 'c' :
                    prcArgsOptions ->
                    components.prec.opt_precom = TRUE;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_precom = %d",
                                   prcArgsOptions ->
                                   components.prec.opt_precom ));
                break;

                case 'o' :
                    prcArgsOptions ->
                    components.prec.opt_comment = TRUE;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_comment = %d",
                                  prcArgsOptions ->
                                  components.prec.opt_comment ));
                break;

                case 'W' :
                    prcArgsOptions ->
                    components.prec.opt_traceswitch = TRUE;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_traceswitch = %d",
                                   prcArgsOptions -> components.
                                                     prec.
                                                     opt_traceswitch ));
                break;

                case 's' :
                    prcArgsOptions ->
                    components.prec.opt_silent = TRUE;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_silent = %d",
                                   prcArgsOptions ->
                                   components.prec.opt_silent ));
                break;

                case 'w' :
                    prcArgsOptions ->
                    components.prec.opt_nowarn = TRUE;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_nowarn = %d",
                                   prcArgsOptions ->
                                   components.prec.opt_nowarn ));
                break;

                case 'i' :
                    prcArgsOptions ->
                    components.prec.opt_lineno = TRUE;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_lineno = %d",
                                   prcArgsOptions ->
                                   components.prec.opt_lineno ));
                break;

                case 'L' :
                    prcArgsOptions ->
                    components.prec.opt_lib = TRUE;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_lib = %d",
                                   prcArgsOptions ->
                                   components.prec.opt_lib ));
                break;

                case 'q' :
                    prcArgsOptions ->
                    components.prec.opt_quote = FALSE;
                    prcArgsOptions ->
                    components.prec.opt_quo = '\"';
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_quote = %d",
                                   prcArgsOptions ->
                                   components.prec.opt_quote ));
                    DBG3 (( MF__, "opt_quo = %c",
                                   prcArgsOptions ->
                                   components.prec.opt_quo ));
                break;

                case 'p' :
                    prcArgsOptions ->
                    components.prec.opt_decpoint = FALSE;
                    prcArgsOptions ->
                    components.prec.opt_point = ',';
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_decpoint = %d",
                                   prcArgsOptions -> components.
                                                     prec.
                                                     opt_decpoint ));
                    DBG3 (( MF__, "opt_point = %c",
                                   prcArgsOptions ->
                                   components.prec.opt_point ));
                break;

                case 'z' :
                    prcArgsOptions ->
                    components.prec.opt_tabformat = TRUE;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_tabformat = %d",
                                   prcArgsOptions ->
                                   components.prec.opt_tabformat ));
                break;
                case 'e' :
                    prcArgsOptions ->
                    components.prec.opt_extern = 0;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_extern = %d",
                                   prcArgsOptions ->
                                   components.prec.opt_extern ));
                break;

                case 'V' :
                    prcArgsOptions ->
                    components.prec.opt_version = TRUE;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_version = %d",
                                   prcArgsOptions ->
                                   components.prec.opt_version ));
                break;

                case 'h' :
                    prcArgsOptions ->
                    components.prec.opt_help = TRUE;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_help = %d",
                                   prcArgsOptions ->
                                   components.prec.opt_help ));
                break;

                // all the other arguments
                case '?' :
                    // --- precompiler don't want to stop at ill option
                    bMoreArgs = FALSE;
                break;
            }   // switch ( nOptionChar )
        }   // while ()

        if (( bMoreArgs ) && ( pbOk )) {
            MakeArgs ( ' ', COMP_PRECOMPILER,
                       prcUserParams, prcArgsOptions, ucXuserType,
                       nArgumentCount, apszArguments,
                       bEnvDBNameFound, acErrorText, pbOk);
        }
    }   // if ( nArgumentCount > 1 )

    DBG3 (( MF__, "ucXuserType [ 0 ] = %d", ucXuserType [ 0 ] ));
    DBG3 (( MF__, "ucXuserType [ 1 ] = %d", ucXuserType [ 1 ] ));

    DBGOUT;
}


/*------------------------------*/


static VOID PrecompilerRunTimeOptionsAnalysis
            (   tsp4_xuser_record  *prcUserParams,
                SQL_PASSWORD        acPassword,
                tsp4_args_options  *prcArgsOptions,
                tsp4_xuserset       ucXuserType,
                INT                 nArgc,
                PCHAR*              apszArgv,
                BOOLEAN             bEnvDBNameFound,
                PBOOLEAN            pbOk,
                ERRORTEXT           acErrorText         )
{
    #undef  MF__
    #define MF__ MOD__"PrecompilerRunTimeOptionsAnalysis"


    BOOLEAN         bMoreArgs;
    INT             nOptionChar;
    INT             nMyArgc;
    PCHAR           apszMyArgv [ OPT_AND_ARG_CNT ];
    PCHAR           pszOptionString;
    INT             nIndex1, nIndex2;
    INT             nLength;
    C132C           szSQLOpt;
    #if defined ( _WIN32 )
     APIRET         rc = NO_ERROR;
     BOOL           fSQLOptEnabled;
    #endif


    DBGIN;

    // initialize internel vars
    bMoreArgs = TRUE;
    nOptionChar = ' ';
    nMyArgc = 0;

    memset ( apszMyArgv, 0, OPT_AND_ARG_CNT );


    // get the precompiler runtime options and build up an apszArguments-array
    // and a nArgumentCount-count by reading the env var SQLOPTIONS
    pszOptionString = ( PCHAR ) getenv ( "SQLOPT" );

    if ( pszOptionString ) {
      strncpy ( szSQLOpt, pszOptionString, sizeof(szSQLOpt) - 1 );
      pszOptionString = szSQLOpt;
    }

    #if defined ( _WIN32 )
     if ( !pszOptionString ) {
          rc = sql13u_get_options_sqlopt ( &fSQLOptEnabled,
                                           szSQLOpt, sizeof(szSQLOpt) - 1);

          if (( rc == NO_ERROR ) && ( fSQLOptEnabled == TRUE ))
              pszOptionString = szSQLOpt;
     }
    #endif

    if ( pszOptionString ) {
        // set apszMyArgv [ 0 ] to something, because you need something
        apszMyArgv [ 0 ] = "precomp_runtime";
        nLength = strlen ( pszOptionString );

        DBG3 (( MF__, "pszOptionsString = \"%s\"", pszOptionString ));
        DBG3 (( MF__, "nLength = %d", nLength ));
        DBG3 (( MF__, "apszMyArgv [ 0 ] = \"%s\"", apszMyArgv [ 0 ] ));


        // extract every option and argument
        for ( nIndex1 = 0 ; nIndex1 < nLength ; nIndex1++ ) {
            if ( pszOptionString [ nIndex1 ] != ' ' ) {
                nMyArgc++;

                DBG3 (( MF__, "&opt_string [ %d ] = 0x%x",
                               nIndex1, &pszOptionString [ nIndex1 ] ));

                // take over the string
                apszMyArgv [ nMyArgc ] = &pszOptionString [ nIndex1 ];

                // skip string
                for ( nIndex2 = nIndex1; nIndex2 < nLength; nIndex2++ ) {
                    if ( pszOptionString [ nIndex2 ] == ' ' )
                        break;
                }

                // string end
                pszOptionString [ nIndex2 ] = '\0';
                nIndex1 = nIndex2;

                DBG3 (( MF__, "apszMyArgv [ %d ] = \"%s\"",
                               nMyArgc, apszMyArgv [ nMyArgc ] ));
            }   // if ()
        }   // for ()

        nMyArgc++;
    }   // if ()

    DBG3 (( MF__, "nMyArgc = %d", nMyArgc ));

    // parameter existing ?

    if ( nMyArgc > 1 ) {
        // get options
        while ((( nOptionChar =
                      sql80_GetOpt ( nMyArgc, apszMyArgv,
                                      PRECOMPILER_RUNTIME_OPTION_STRING)) != -1) &&
                  bMoreArgs                                                      &&
                  *pbOk ) {

            DBG3 (( MF__, "nOptionChar = %c", nOptionChar ));
            DBG3 (( MF__, "sql80_OptInd = %d", sql80_OptInd ));

            switch ( nOptionChar ) {
                // general optargs
                case 'u' :
                    MakeUserPassword ( prcUserParams,
                                     acPassword, pbOk, acErrorText );
                    PUTBIT ( ucXuserType, SP4XU_SQL_USERPARMS );
                    CLRBIT ( ucXuserType, SP4XU_SQL_USERMASK );
                break;

                case 'd' :
                    MakeDBId ( prcUserParams, ucXuserType );
                break;

                case 'n' :
                    MakeDBNode ( prcUserParams , ucXuserType);
                break;

                case 'U' :
                    MakeUserKey ( prcUserParams, ucXuserType,
                                  bEnvDBNameFound, acErrorText, pbOk );
                break;

                case 'S' :
                    MakeSqlMode ( prcUserParams, ucXuserType );
                break;

                case 'I' :
                    MakeIsolation ( prcUserParams, ucXuserType);
                break;

                case 't' :
                    MakeTimeOut ( prcUserParams, ucXuserType );
                break;

                case 'y' :
                    MakeCacheLimit ( prcUserParams, ucXuserType );
                break;

                case 'x' :
                    MakeDBLang ( prcUserParams, ucXuserType);
                break;

                // optargs with arguments
                case 'F' :
                    MakePrecompilerRunTimeTraceFn ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'B' :
                    MakePrecompilerRunTimeMFetch ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'Y' :
                    MakePrecompilerRunTimeStmtCnt ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'L' :
                    MakePrecompilerRunTimeLimit ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                // opargs with no arguments
                case 'O' :
                    prcArgsOptions ->
                    components.pc_rt.opt_rtrace = 4;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_rtrace = %d",
                                   prcArgsOptions -> components.
                                                     pc_rt.
                                                     opt_rtrace ));
                break;

                case 'T' :
                    prcArgsOptions ->
                    components.pc_rt.opt_rtrace = 2;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_rtrace = %d",
                                   prcArgsOptions -> components.
                                                     pc_rt.
                                                     opt_rtrace ));
                break;

                case 'X' :
                    prcArgsOptions ->
                    components.pc_rt.opt_rtrace = 3;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_rtrace = %d",
                                   prcArgsOptions -> components.
                                                     pc_rt.
                                                     opt_rtrace ));
                break;

                case 'R' :
                    prcArgsOptions ->
                    components.pc_rt.opt_rprof = 1;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_rprof = %d",
                                   prcArgsOptions -> components.
                                                     pc_rt.
                                                     opt_rprof ));
                break;

                case 'Z' :
                    prcArgsOptions ->
                    components.pc_rt.opt_rprof = 2;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_rprof = %d",
                                   prcArgsOptions -> components.
                                                     pc_rt.
                                                     opt_rprof ));
                break;

                case 'N' :
                    prcArgsOptions ->
                    components.pc_rt.opt_rnotracetime = TRUE;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_rnotraceti = %d",
                                   prcArgsOptions -> components.
                                                     pc_rt.
                                                     opt_rnotracetime ));
                break;

                case 'W' :
                    prcArgsOptions ->
                    components.pc_rt.opt_rtraceswitch = TRUE;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_rtraceswit = %d",
                                   prcArgsOptions -> components.
                                                     pc_rt.
                                                     opt_rtraceswitch ));
                break;

                case 'f' :
                    prcArgsOptions ->
                    components.pc_rt.opt_rnosdf = TRUE;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_rnosdf = %d",
                                   prcArgsOptions -> components.
                                                     pc_rt.
                                                     opt_rnosdf ));
                break;

                // all the other arguments
                case '?' :
                    // --- precompiler don't want to stop at ill option
                    bMoreArgs = FALSE;
                break;
            }   // switch ( nOptionChar )
        }   // while ()

        // all the other arguments, nOptionChar = -1
        if (( bMoreArgs ) && ( pbOk )) {
            MakeMyArgs ( ' ', COMP_PC_RUNTIME,
                         prcUserParams, prcArgsOptions, ucXuserType,
                         nArgc, apszArgv, bEnvDBNameFound, acErrorText, pbOk );
        }
    }   // if ( nMyArgc > 1 )


    DBG3 (( MF__, "ucXuserType [ 0 ] = %d", ucXuserType [ 0 ] ));
    DBG3 (( MF__, "ucXuserType [ 1 ] = %d", ucXuserType [ 1 ] ));

    DBGOUT;
}


/*------------------------------*/


static VOID DialogComponentOptionsAnalysis
            (   tsp4_xuser_record  *prcUserParams,
                SQL_PASSWORD        acPassword,
                tsp4_args_options  *prcArgsOptions,
                tsp4_xuserset       ucXuserType,
                INT                 nArgumentCount,
                PCHAR*              apszArguments,
                BOOLEAN             bEnvDBNameFound,
                PBOOLEAN            pbOk,
                ERRORTEXT           acErrorText         )
{
    #undef  MF__
    #define MF__ MOD__"DialogComponentOptionsAnalysis"


    BOOLEAN bMoreArgs;
    INT     nOptionChar;


    DBGIN;

    // initialize internel vars
    bMoreArgs   = TRUE;
    nOptionChar = ' ';

    DBG3 (( MF__, "nArgumentCount = %d", nArgumentCount ));

    // parameter existing ?
    if ( nArgumentCount > 1 ) {
        // get options

        while ((( nOptionChar =
                      sql80_GetOpt ( nArgumentCount, apszArguments,
                                      DIALOG_COMPONENT_OPTION_STRING )) != -1 ) &&
                  bMoreArgs                                                     &&
                  *pbOk ) {

            DBG3 (( MF__, "nOptionChar = %c", nOptionChar ));
            DBG3 (( MF__, "sql80_OptInd = %d", sql80_OptInd ));

            switch ( nOptionChar ) {
                // general optargs
                case 'u' :
                    MakeUserPassword ( prcUserParams,
                                       acPassword, pbOk, acErrorText );
                    PUTBIT ( ucXuserType, SP4XU_SQL_USERPARMS );
                    CLRBIT ( ucXuserType, SP4XU_SQL_USERMASK );
                break;

                case 'd' :
                    MakeDBId ( prcUserParams, ucXuserType );
                break;

                case 'n' :
                    MakeDBNode ( prcUserParams , ucXuserType);
                break;

                case 'U' :
                    MakeUserKey ( prcUserParams, ucXuserType,
                                  bEnvDBNameFound, acErrorText, pbOk );
                break;

                case 'S' :
                    MakeSqlMode ( prcUserParams, ucXuserType );
                break;

                case 'I' :
                    MakeIsolation ( prcUserParams, ucXuserType);
                break;

                case 't' :
                    MakeTimeOut ( prcUserParams, ucXuserType );
                break;

                case 'y' :
                    MakeCacheLimit ( prcUserParams, ucXuserType );
                break;

                case 'x' :
                    MakeDBLang ( prcUserParams, ucXuserType);
                break;

                // optargs with arguments
                case 'r' :
                    MakeDialogComponentRFn ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'b' :
                    MakeDialogComponentBFn ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'R' :
                    if (( prcArgsOptions -> opt_component == COMP_DIALOG ) ||
                        ( prcArgsOptions -> opt_component == COMP_APPL   )) {
                        MakeDialogComponentObj ( prcArgsOptions, SP4CM_SQL_RUN_OBJECT,
                                                 2, pbOk, acErrorText );
                    }
                    else {
                        MakeDialogComponentObj ( prcArgsOptions, SP4CM_SQL_RUN_OBJECT,
                                                 1, pbOk, acErrorText );
                    }

                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'B' :
                    if (( prcArgsOptions -> opt_component == COMP_DIALOG ) ||
                        ( prcArgsOptions -> opt_component == COMP_APPL   )) {
                        MakeDialogComponentObj ( prcArgsOptions, SP4CM_SQL_BATCH_OBJECT,
                                                 2, pbOk, acErrorText );
                    }
                    else {
                        MakeDialogComponentObj ( prcArgsOptions, SP4CM_SQL_BATCH_OBJECT,
                                                 1, pbOk, acErrorText );
                    }
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'O' :
                    MakeDialogComponentObj ( prcArgsOptions, SP4CM_SQL_LIST, 1,
                                             pbOk, acErrorText );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'C' :
                    MakeDialogComponentCodeType ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'e' :
                    MakeDialogComponentExport ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'i' :
                    MakeDialogComponentImport ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                // optargs with no arguments
                case 'A' :
                    prcArgsOptions ->
                    components.dcomp_util.opt_append = TRUE;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_append = %d",
                                   prcArgsOptions ->
                                   components.
                                   dcomp_util.
                                   opt_append ));
                break;

                case 'P' :
                    prcArgsOptions ->
                    components.dcomp_util.opt_prompt = TRUE;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_prompt = %d",
                                   prcArgsOptions ->
                                   components.
                                   dcomp_util.
                                   opt_prompt ));
                break;

                case 'c' :
                    prcArgsOptions -> components.
                                      dcomp_util.
                                      opt_codeonly = TRUE;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_codeonly = %d",
                                   prcArgsOptions ->
                                   components.
                                   dcomp_util.
                                   opt_codeonly ));
                break;

                case 'V' :
                    prcArgsOptions -> components.
                                      dcomp_util.
                                      opt_comm_mode = SP4CM_SQL_COMP_VERS;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_comm_mode = %d",
                                   prcArgsOptions ->
                                   components.
                                   dcomp_util.
                                   opt_comm_mode ));
                break;

                case 's' :
                    prcArgsOptions -> components.
                                      dcomp_util.
                                      opt_comm_mode = SP4CM_SQL_SELECT;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_comm_mode = %d",
                                   prcArgsOptions ->
                                   components.
                                   dcomp_util.
                                   opt_comm_mode ));
                break;

                case 'T' :
                    prcArgsOptions -> components.
                                      dcomp_util.
                                      opt_utility_session = TRUE ;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_comm_mode = %d",
                                   prcArgsOptions ->
                                   components.
                                   dcomp_util.
                                   opt_utility_session ));
                break;

                case 'L' :
                    prcArgsOptions -> components.
                                      dcomp_util.
                                      opt_comm_mode = SP4CM_SQL_LIST_COMMAND;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_comm_mode = %d",
                                   prcArgsOptions ->
                                   components.
                                   dcomp_util.
                                   opt_comm_mode ));
                break;

                // all the other arguments
                case '?' :
                    MakeArgs ( '?', COMP_EASY,
                               prcUserParams, prcArgsOptions, ucXuserType,
                               nArgumentCount, apszArguments,
                               bEnvDBNameFound, acErrorText, pbOk );
                    bMoreArgs = FALSE;
                break;
            }   // switch ()
        }   // while ()
        if (( bMoreArgs ) && ( pbOk )) {
            MakeArgs ( ' ', COMP_EASY,
                       prcUserParams, prcArgsOptions, ucXuserType,
                       nArgumentCount, apszArguments,
                       bEnvDBNameFound, acErrorText, pbOk );
        }
    }   // if ()

    DBG3 (( MF__, "ucXuserType [ 0 ] = %d", ucXuserType [ 0 ] ));
    DBG3 (( MF__, "ucXuserType [ 1 ] = %d", ucXuserType [ 1 ] ));

    DBGOUT;
}


/*------------------------------*/


static VOID AuditOptionsAnalysis
            (   tsp4_xuser_record  *prcUserParams,
                SQL_PASSWORD        acPassword,
                tsp4_args_options  *prcArgsOptions,
                tsp4_xuserset       ucXuserType,
                INT                 nArgumentCount,
                PCHAR*              apszArguments,
                BOOLEAN             bEnvDBNameFound,
                PBOOLEAN            pbOk,
                ERRORTEXT           acErrorText         )
{
    #undef  MF__
    #define MF__ MOD__"AuditOptionsAnalysis"


    BOOLEAN bMoreArgs;
    INT     nOptionChar;


    DBGIN;

    // initialize internel vars
    bMoreArgs    = TRUE;
    nOptionChar = ' ';

    DBG3 (( MF__, "nArgumentCount = %d", nArgumentCount ));

    // parameter existing ?
    if ( nArgumentCount > 1 ) {
        // get options
        while ((( nOptionChar =
                      sql80_GetOpt ( nArgumentCount, apszArguments,
                                      AUDIT_OPTION_STRING )) != - 1 ) &&
                  bMoreArgs                                           &&
                  *pbOk ) {

            DBG3 (( MF__, "nOptionChar = %c", nOptionChar ));
            DBG3 (( MF__, "sql80_OptInd = %d", sql80_OptInd ));

            switch ( nOptionChar ) {
                // general optargs
                case 'u' :
                    MakeUserPassword ( prcUserParams,
                                     acPassword, pbOk, acErrorText );
                    PUTBIT ( ucXuserType, SP4XU_SQL_USERPARMS );
                    CLRBIT ( ucXuserType, SP4XU_SQL_USERMASK );
                break;

                case 'd' :
                    MakeDBId ( prcUserParams, ucXuserType );
                break;

                case 'n' :
                    MakeDBNode ( prcUserParams , ucXuserType);
                break;

                case 'U' :
                    MakeUserKey ( prcUserParams, ucXuserType,
                                  bEnvDBNameFound, acErrorText, pbOk );
                break;

                case 'S' :
                    MakeSqlMode ( prcUserParams, ucXuserType );
                break;

                case 'I' :
                    MakeIsolation ( prcUserParams, ucXuserType);
                break;

                case 't' :
                    MakeTimeOut ( prcUserParams, ucXuserType );
                break;

                case 'y' :
                    MakeCacheLimit ( prcUserParams, ucXuserType );
                break;

                case 'x' :
                    MakeDBLang ( prcUserParams, ucXuserType);
                break;

                // optargs with arguments
                case 'c' :
                    MakeAuditCntrl ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'l' :
                    MakeAuditLogfile ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'N' :
                    MakeAuditLogBlockSize ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                case 'o' :
                    MakeAuditOutput ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                // opargs with no arguments
                case 'V' :
                    prcArgsOptions ->
                    components.aud.opt_aud_comm_mode = SP4CM_SQL_COMP_VERS;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_aud_comm_mod = %d",
                                   prcArgsOptions ->
                                   components.aud.opt_aud_comm_mode ));
                break;

                // all the other arguments
                case '?' :
                    MakeArgs ( '?', COMP_AUDIT,
                               prcUserParams, prcArgsOptions, ucXuserType,
                               nArgumentCount, apszArguments,
                               bEnvDBNameFound, acErrorText, pbOk );
                    bMoreArgs = FALSE;
                break;
            }   // switch ()
        }   // while ()

        if (( bMoreArgs ) && ( pbOk )) {
            MakeArgs ( ' ', COMP_AUDIT,
                       prcUserParams, prcArgsOptions, ucXuserType,
                       nArgumentCount, apszArguments,
                       bEnvDBNameFound, acErrorText, pbOk );
        }
    }   // if ()

    DBG3 (( MF__, "ucXuserType [ 0 ] = %d", ucXuserType [ 0 ] ));
    DBG3 (( MF__, "ucXuserType [ 1 ] = %d", ucXuserType [ 1 ] ));

    DBGOUT;
}


/*------------------------------*/

static VOID UserXOptionsAnalysis
            (   tsp4_xuser_record  *prcUserParams,
                SQL_PASSWORD        acPassword,
                tsp4_args_options  *prcArgsOptions,
                tsp4_xuserset       ucXuserType,
                INT                 nArgumentCount,
                PCHAR*              apszArguments,
                BOOLEAN             bEnvDBNameFound,
                PBOOLEAN            pbOk,
                ERRORTEXT           acErrorText         )
{
    #undef  MF__
    #define MF__ MOD__"UserXOptionsAnalysis"


    BOOLEAN bMoreArgs;
    INT     nOptionChar;


    DBGIN;

    // initialize internel vars
    bMoreArgs    = TRUE;
    nOptionChar = ' ';

    DBG3 (( MF__, "nArgumentCount = %d", nArgumentCount ));

    // parameter existing ?
    if ( nArgumentCount > 1 ) {
        // get options
        while ((( nOptionChar =
                      sql80_GetOpt ( nArgumentCount, apszArguments,
                                      USERX_OPTION_STRING )) != - 1 ) &&
                  bMoreArgs                                           &&
                  *pbOk ) {

            DBG3 (( MF__, "nOptionChar = %c", nOptionChar ));
            DBG3 (( MF__, "sql80_OptInd = %d", sql80_OptInd ));

            switch ( nOptionChar ) {
                // general optargs
                case 'u' :
                    MakeUserPassword ( prcUserParams,
                                     acPassword, pbOk, acErrorText );
                    PUTBIT ( ucXuserType, SP4XU_SQL_USERPARMS );
                    CLRBIT ( ucXuserType, SP4XU_SQL_USERMASK );
                break;


                // opargs with no arguments
                case 'V' :
                    prcArgsOptions ->
                    components.ux.opt_ux_comm_mode = SP4CM_SQL_COMP_VERS;
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                    DBG3 (( MF__, "opt_ux_comm_mod = %d",
                                   prcArgsOptions ->
                                   components.ux.opt_ux_comm_mode ));
                break;

                case 'b' :
                    MakeUserXComponentBFn ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                break;

                // all the other arguments
                case '?' :
                    MakeArgs ( '?', COMP_USER,
                               prcUserParams, prcArgsOptions, ucXuserType,
                               nArgumentCount, apszArguments,
                               bEnvDBNameFound, acErrorText, pbOk );
                    bMoreArgs = FALSE;
                break;
            }   // switch ()
        }   // while ()

        if (( bMoreArgs ) && ( pbOk )) {
            MakeArgs ( ' ', COMP_USER,
                       prcUserParams, prcArgsOptions, ucXuserType,
                       nArgumentCount, apszArguments,
                       bEnvDBNameFound, acErrorText, pbOk );
        }
    }   // if ()

    DBG3 (( MF__, "ucXuserType [ 0 ] = %d", ucXuserType [ 0 ] ));
    DBG3 (( MF__, "ucXuserType [ 1 ] = %d", ucXuserType [ 1 ] ));

    DBGOUT;
}


/*------------------------------*/


static VOID MakeArgs    (   INT                 nOptionChar,
                            tsp4_component      eComponent,
                            tsp4_xuser_record  *prcUserParams,
                            tsp4_args_options  *prcArgsOptions,
                            tsp4_xuserset       ucXuserType,
                            INT                 nArgc,
                            PCHAR*              apszArgv,
                            BOOLEAN             bEnvDBNameFound,
                            ERRORTEXT           acErrorText,
                            PBOOLEAN            pbOk            )
{
    #undef  MF__
    #define MF__ MOD__"MakeArgs"


    INT     nTestChar0;
    INT     nTestChar1;
    INT     nLength;
    INT     nArgNumber;
    INT     nOutIndex;
    INT     nSize;
    PCHAR   psArgumentString;
    APIRET  rc;
    BOOLEAN bArgLineExists = FALSE;


    DBGIN;

    if ( nOptionChar == '?' ) {
        // look for option names
        // if found take over
        DBG3 (( MF__, "sql80_OptInd ( nOptionChar = ? ) = %d", sql80_OptInd ));

        nTestChar0 = apszArgv [ sql80_OptInd - 1 ] [ 0 ];
        nTestChar1 = apszArgv [ sql80_OptInd - 1 ] [ 1 ];

        DBG3 (( MF__, "apszArgv [ sql80_OptInd - 1 ] = \"%s\"",
                       apszArgv [ sql80_OptInd - 1 ]  ));

        DBG3 (( MF__, "nTestChar0 = %c", nTestChar0 ));
        DBG3 (( MF__, "nTestChar1 = %c", nTestChar1 ));

        if (( nTestChar0 == '-' || nTestChar0 == '/' ) &&
            ( nTestChar1 == 'R' || nTestChar1 == 'B' ||
              nTestChar1 == 'r' || nTestChar1 == 'b' )) {

            switch ( eComponent ) {
              case COMP_EASY    :
              case COMP_QUERY   :
              case COMP_DIALOG  :
              case COMP_APPL    :
              case COMP_LOAD    :
              case COMP_PARAM   :
              case COMP_UTILITY :

                 // get command, set runfile to STDIN
                 switch ( nTestChar1 ) {
                     case 'r' :
                         prcArgsOptions -> components.
                                           dcomp_util.
                                           opt_comm_mode = SP4CM_SQL_RUN;

                         PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );

                         memcpy ( prcArgsOptions -> components.
                                                    dcomp_util.
                                                    opt_runfile,
                                  "STDIN", 5 );
                     break;

                     case 'b' :
                         prcArgsOptions -> components.
                                           dcomp_util.
                                           opt_comm_mode = SP4CM_SQL_BATCH;

                         PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );

                         memcpy ( prcArgsOptions -> components.
                                                    dcomp_util.
                                                    opt_runfile,
                                  "STDIN", 5 );
                     break;
                     case 'B' :

                         memset ( prcArgsOptions -> components.
                                     dcomp_util.
                                     opt_object_owner,
                                  ' ',
                                  sizeof( prcArgsOptions -> components.
                                     dcomp_util.
                                     opt_object_owner));

                         memset ( prcArgsOptions -> components.
                                     dcomp_util.
                                     opt_object_name1,
                                  ' ',
                                  sizeof( prcArgsOptions -> components.
                                          dcomp_util.
                                          opt_object_name1));

                         memset ( prcArgsOptions -> components.
                                     dcomp_util.
                                     opt_object_name2,
                                  ' ',
                                  sizeof( prcArgsOptions -> components.
                                           dcomp_util.
                                           opt_object_name2));

                         prcArgsOptions -> components.
                             dcomp_util.
                             opt_comm_mode =  SP4CM_SQL_BATCH_OBJECT;

                         PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );

                     break;

                     case 'R' :
                         memset ( prcArgsOptions -> components.
                                     dcomp_util.
                                     opt_object_owner,
                                  ' ',
                                  sizeof( prcArgsOptions -> components.
                                     dcomp_util.
                                     opt_object_owner));

                         memset ( prcArgsOptions -> components.
                                     dcomp_util.
                                     opt_object_name1,
                                  ' ',
                                  sizeof( prcArgsOptions -> components.
                                          dcomp_util.
                                          opt_object_name1));

                         memset ( prcArgsOptions -> components.
                                     dcomp_util.
                                     opt_object_name2,
                                  ' ',
                                  sizeof( prcArgsOptions -> components.
                                           dcomp_util.
                                           opt_object_name2));

                         prcArgsOptions -> components.
                           dcomp_util.
                           opt_comm_mode =  SP4CM_SQL_RUN_OBJECT;

                         PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );

                     break;
                 }
              break;
              case COMP_USER    :
                 switch ( nTestChar1 ) {
                     case 'b' :
                         prcArgsOptions -> components.ux.
                            opt_ux_comm_mode = SP4CM_SQL_BATCH;

                         PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );

                         memcpy ( prcArgsOptions -> components.ux.
                                    opt_ux_runfile,
                                  "STDIN", 5 );
                     break;
                 }
              break;

            }

            DBGOUT;

            return;
        }
        else {

            // may be there was a 'U'
            if (( nTestChar0 == '-' || nTestChar0 == '/' ) &&
                ( nTestChar1 == 'U' )) {
                // check for error conditions
                if ( TSTBIT ( ucXuserType, SP4XU_SQL_USERPARMS  )  |
                     TSTBIT ( ucXuserType, SP4XU_SQL_SERVERNODE )  |
                     TSTBIT ( ucXuserType, SP4XU_SQL_MODE       )  |
                     TSTBIT ( ucXuserType, SP4XU_SQL_ISOLATION  )  |
                     TSTBIT ( ucXuserType, SP4XU_SQL_TIMEOUT    )  |
                     TSTBIT ( ucXuserType, SP4XU_SQL_CACHELIMIT )) {

                    *pbOk = FALSE;

                    DBG1 (( MF__, ERRMSG_WRONG_OPTION_SEQUENCE ));
                    MSGD  (( ERR_WRONG_OPTION_SEQUENCE ));
                    sql46c_build_error_string ( acErrorText,
                                                ERRMSG_WRONG_OPTION_SEQUENCE,
                                                0 );
                    DBGOUT;

                    return;
                }

                if ( !bEnvDBNameFound && TSTBIT ( ucXuserType, SP4XU_SQL_SERVERDB)) {
                    *pbOk = FALSE;

                    DBG1 (( MF__, ERRMSG_WRONG_OPTION_SEQUENCE ));
                    MSGD  (( ERR_WRONG_OPTION_SEQUENCE ));
                    sql46c_build_error_string ( acErrorText,
                                                ERRMSG_WRONG_OPTION_SEQUENCE,
                                                0 );
                    DBGOUT;
                    return;
                }

                PUTBIT ( ucXuserType, SP4XU_SQL_USERDEFAULT );
                CLRBIT ( ucXuserType, SP4XU_SQL_USERMASK );

                memcpy ( prcUserParams->xu_key, DEFAULT_USER,
                         sizeof ( prcUserParams->xu_key ));

                rc = sql13u_getuser ( prcUserParams, acErrorText );

                if ( rc != NO_ERROR )
                    *pbOk = FALSE;

                DBG3 (( MF__, "ucXuserType [ 0 ] = %d", ucXuserType [ 0 ] ));
                DBG3 (( MF__, "ucXuserType [ 1 ] = %d", ucXuserType [ 1 ] ));

                DBG3 (( MF__, "prcUserParams -> xu_key = \"%s\"",
                        _PToC ( prcUserParams -> xu_key )));
                DBG3 (( MF__, "prcUserParams -> xu_servernode = \"%s\"",
                        _PToC ( prcUserParams -> xu_servernode )));
                DBG3 (( MF__, "prcUserParams -> xu_serverdb = \"%s\"",
                        _PToC ( prcUserParams -> xu_serverdb )));
                DBG3 (( MF__, "prcUserParams -> xu_user = \"%s\"",
                        _PToC ( prcUserParams -> xu_user )));
                DBG3 (( MF__, "prcUserParams -> xu_sqlmode = \"%s\"",
                        _PToC ( prcUserParams -> xu_sqlmode )));

                DBG3 (( MF__, "prcUserParams -> xu_cachelimit = %d",
                        prcUserParams -> xu_cachelimit ));
                DBG3 (( MF__, "prcUserParams -> xu_timeout = %d",
                        prcUserParams -> xu_timeout ));
                DBG3 (( MF__, "prcUserParams -> xu_isolation = %d",
                        prcUserParams -> xu_isolation ));

                DBGOUT;

                return;
            }
            else {
                // no regular option, reduce sql80_OptInd but be sure to do this
                // only you have found an '-?' expression
                // ? : means only one char

                if (( sql80_OptInd > 1 )                              &&
                    ( strlen ( apszArgv [ sql80_OptInd - 1 ] ) == 2 ) &&
                    ( nTestChar0 == '-' || nTestChar0 == '/' )) {
                    sql80_OptInd --;
                }
            }
        }
    }

    // take over args into arg line; if an arg line exists
    // but be sure you have an argument
    if ( nArgc > sql80_OptInd ) {
        DBG3 (( MF__, "eComponent = %d", eComponent ));
        DBG3 (( MF__, "sql80_OptInd     = %d", sql80_OptInd ));

        switch ( eComponent ) {
            case COMP_PRECOMPILER  :
                if ( prcArgsOptions->
                       components.prec.opt_modulefn[0] == ' ' ) {
                    sql80_OptArg = apszArgv [ sql80_OptInd++ ];
                    MakePrecompilerInputFn ( prcArgsOptions );
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                }
                nSize = sizeof ( prcArgsOptions -> components.
                                                   prec.
                                                   opt_puser_args );
                psArgumentString = prcArgsOptions -> components.
                                                     prec.
                                                     opt_puser_args;
                bArgLineExists = TRUE;

            break;

            case COMP_PC_RUNTIME   :
                nSize = sizeof ( prcArgsOptions -> components.
                                                   pc_rt.
                                                   opt_ruser_args );
                psArgumentString = prcArgsOptions -> components.
                                                     pc_rt.
                                                     opt_ruser_args;
                bArgLineExists = TRUE;
            break;

            case COMP_EASY    :
            case COMP_QUERY   :
            case COMP_DIALOG  :
            case COMP_APPL    :
            case COMP_LOAD    :
            case COMP_UTILITY :
                nSize = sizeof ( prcArgsOptions -> components.
                                                   dcomp_util.
                                                   opt_parameter );
                psArgumentString = prcArgsOptions -> components.
                                                     dcomp_util.
                                                     opt_parameter;
                bArgLineExists = TRUE;
            break;

            default :
                bArgLineExists = FALSE;
            break;
        }

        if ( bArgLineExists ) {
            nOutIndex = 0;

            for ( nArgNumber = sql80_OptInd; nArgNumber < nArgc; nArgNumber++ ) {
                nLength = strlen ( apszArgv [ nArgNumber ] );

                DBG3 (( MF__, "nLength(apszArgv[nArgNumber] = %d", nLength ));

                if ( nLength > 0 ) {
                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );
                }

                if ( nOutIndex + nLength  <= nSize ) {
                    memcpy ( psArgumentString + nOutIndex,
                             apszArgv [ nArgNumber ], nLength );

                    nOutIndex += nLength + 1;
                }
                else
                    break;
            }
        }
    }

    DBGOUT;
}


/*------------------------------*/


static VOID MakeMyArgs  (   INT                 nOptionChar,
                            tsp4_component      eComponent,
                            tsp4_xuser_record  *prcUserParams,
                            tsp4_args_options  *prcArgsOptions,
                            tsp4_xuserset       ucXuserType,
                            INT                 nArgc,
                            PCHAR*              apszArgv,
                            BOOLEAN             bEnvDBNameFound,
                            ERRORTEXT           acErrorText,
                            PBOOLEAN            pbOk                )
{
    #undef  MF__
    #define MF__ MOD__"MakeMyArgs"


    INT     nTestChar0;
    INT     nTestChar1;
    APIRET  rc;


    DBGIN;

    if ( nOptionChar == '?' ) {
        // look for option names, if found take over
        DBG3 (( MF__, "sql80_OptInd  ( nOptionChar = ? ) = %d", sql80_OptInd ));

        nTestChar0 = apszArgv [ sql80_OptInd - 1 ] [ 0 ];
        nTestChar1 = apszArgv [ sql80_OptInd - 1 ] [ 1 ];

        DBG3 (( MF__,
                "apszArgv [ sql80_OptInd - 1 ] = \"%s\"", apszArgv [ sql80_OptInd - 1 ]  ));
        DBG3 (( MF__, "nTestChar0 = %c", nTestChar0 ));
        DBG3 (( MF__, "nTestChar1 = %c", nTestChar1 ));

        if (( nTestChar0 == '-' || nTestChar0 == '/' ) &&
            ( nTestChar1 == 'r' || nTestChar1 == 'b' )) {

            // get command, set runfile to STDIN
            switch ( nTestChar1 ) {
                case 'r' :
                    prcArgsOptions -> components.
                                      dcomp_util.
                                      opt_comm_mode = SP4CM_SQL_RUN;

                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );

                    memcpy ( prcArgsOptions -> components.
                                               dcomp_util.
                                               opt_runfile,
                             "STDIN", 5 );
                break;

                case 'b' :
                    prcArgsOptions -> components.
                                      dcomp_util.
                                      opt_comm_mode = SP4CM_SQL_BATCH;

                    PUTBIT ( ucXuserType, SP4XU_SQL_PARAMS );

                    memcpy ( prcArgsOptions -> components.
                                               dcomp_util.
                                               opt_runfile,
                             "STDIN", 5 );
                break;
            }

            DBG3 (( MF__, "opt_comm_mode = %d",
                    prcArgsOptions -> components.
                                      dcomp_util.
                                      opt_comm_mode ));
            DBG3 (( MF__, "opt_runfile = \"%s\"",
                    _PToC ( prcArgsOptions -> components.
                                              dcomp_util.
                                              opt_runfile )));

            DBGOUT;

            return;
        }
        else {
            // may be there was a 'U'
            if (( nTestChar0 == '-'  ||  nTestChar0 == '/' ) &&
                ( nTestChar1 == 'U' )) {
                // check for error conditions
                if ( TSTBIT ( ucXuserType, SP4XU_SQL_USERPARMS  )  |
                     TSTBIT ( ucXuserType, SP4XU_SQL_SERVERNODE )  |
                     TSTBIT ( ucXuserType, SP4XU_SQL_MODE       )  |
                     TSTBIT ( ucXuserType, SP4XU_SQL_ISOLATION  )  |
                     TSTBIT ( ucXuserType, SP4XU_SQL_TIMEOUT    )  |
                     TSTBIT ( ucXuserType, SP4XU_SQL_CACHELIMIT )) {

                    *pbOk = FALSE;

                    DBG1 (( MF__, ERRMSG_WRONG_OPTION_SEQUENCE ));
                    MSGD  (( ERR_WRONG_OPTION_SEQUENCE ));
                    sql46c_build_error_string ( acErrorText,
                                                ERRMSG_WRONG_OPTION_SEQUENCE,
                                                0 );

                    DBGOUT;

                    return;
                }

                if ( !bEnvDBNameFound && TSTBIT ( ucXuserType, SP4XU_SQL_SERVERDB )){
                    *pbOk = FALSE;
                    DBG1 (( MF__, ERRMSG_WRONG_OPTION_SEQUENCE ));
                    MSGD  (( ERR_WRONG_OPTION_SEQUENCE ));
                    sql46c_build_error_string ( acErrorText,
                                                ERRMSG_WRONG_OPTION_SEQUENCE,
                                                0 );

                    DBGOUT;

                    return;
                }

                PUTBIT ( ucXuserType, SP4XU_SQL_USERDEFAULT );
                CLRBIT ( ucXuserType, SP4XU_SQL_USERMASK );

                memcpy ( prcUserParams -> xu_key, DEFAULT_USER, 
                         sizeof ( prcUserParams -> xu_key ));

                rc = sql13u_getuser ( prcUserParams, acErrorText );

                if ( rc != NO_ERROR )
                    *pbOk = FALSE;

                DBG3 (( MF__, "ucXuserType [ 0 ] = %d", ucXuserType [ 0 ] ));
                DBG3 (( MF__, "ucXuserType [ 1 ] = %d", ucXuserType [ 1 ] ));

                DBG3 (( MF__, "prcUserParams -> xu_key = \"%s\"",
                        _PToC ( prcUserParams -> xu_key )));
                DBG3 (( MF__, "prcUserParams -> xu_servernode = \"%s\"",
                        _PToC ( prcUserParams -> xu_servernode )));
                DBG3 (( MF__, "prcUserParams -> xu_serverdb = \"%s\"",
                        _PToC ( prcUserParams -> xu_serverdb )));
                DBG3 (( MF__, "prcUserParams -> xu_user = \"%s\"",
                        _PToC ( prcUserParams -> xu_user )));
                DBG3 (( MF__, "prcUserParams -> xu_sqlmode = \"%s\"",
                        _PToC ( prcUserParams -> xu_sqlmode )));

                DBG3 (( MF__, "prcUserParams -> xu_cachelimit = %d",
                        prcUserParams -> xu_cachelimit ))
                DBG3 (( MF__, "prcUserParams -> xu_timeout = %d",
                        prcUserParams -> xu_timeout ))

                DBG3 (( MF__, "prcUserParams -> xu_isolation = %d",
                        prcUserParams -> xu_isolation ))

                DBGOUT;

                return;
            }
            else {
                // no regular option, reduce sql80_OptInd but be sure to do this
                // only you have found an '-?' expression
                // ? : means only one char
                if (( sql80_OptInd > 1 )                              &&
                    ( strlen ( apszArgv [ sql80_OptInd - 1 ] ) == 2 ) &&
                    ( nTestChar0 == '-' || nTestChar0 == '/' )) {
                    sql80_OptInd --;
                }
            }
        }
    }

    // take over args into arg line; if an arg line exists
    // but be sure you have an argument

    if ( nArgc > sql80_OptInd ) {
        DBG3 (( MF__, "eComponent = %d", eComponent ));
        DBG3 (( MF__, "sql80_OptInd = %d", sql80_OptInd ));

        switch ( eComponent ) {
            case COMP_PC_RUNTIME   :
                *pbOk = FALSE;

                DBG1 (( MF__, ERRMSG_NO_VALID_OPTION ));
                MSGD  (( ERR_NO_VALID_OPTION ));
                sql46c_build_error_string ( acErrorText,
                                            ERRMSG_NO_VALID_OPTION,
                                            0 );

                DBGOUT;

                return;
        }
    }

    DBGOUT;
}


/*------------------------------*/


static VOID MakeUserPassword    (   tsp4_xuser_record  *prcUserParams,
                                    SQL_PASSWORD        acPassword,
                                    PBOOLEAN            pbOk,
                                    ERRORTEXT           acErrorText     )
{
    #undef  MF__
    #define MF__ MOD__"MakeUserPassword"

    CTU_REC         CtU;
    BOOLEAN         bUIdToUpper;
    BOOLEAN         bPasswordToUpper;
    INT             nLength;
    PSZ             pszStart1Addr;
    PSZ             pszStart2Addr;
    ULONG           ulLength1;
    ULONG           ulLength2;


    DBGIN;

    // get userid ( only if it exists )
    if ( strlen ( sql80_OptArg ) > 0 ) {
        // initialize user id, password string and conv_to_upper

        memset ( prcUserParams -> xu_user, ' ',
                 sizeof ( prcUserParams -> xu_user ));
        memset ( acPassword, ' ', sizeof ( SQL_PASSWORD ));

        // check user id and password, maybe you don't need to convert upper
        CheckIdents ( &CtU, ',', 2, pbOk, acErrorText );

        if ( !*pbOk ) {
            DBGOUT;
            return;
        }

        pszStart1Addr    =  CtU.pszIdent     [0];
        ulLength1        =  CtU.lIdentLen    [0];
        bUIdToUpper      =  CtU.bIdentToUpper[0];

        pszStart2Addr    =  CtU.pszIdent     [1];
        ulLength2        =  CtU.lIdentLen    [1];
        bPasswordToUpper =  CtU.bIdentToUpper[1];


        // determinate length of user id
        nLength = sizeof ( prcUserParams -> xu_user );

        // check length
        if ( ulLength1 > 0 ) {
            if ( ulLength1 > (ULONG)nLength )
                ulLength1 = (ULONG)nLength;

            // copy without '\0'
            memcpy ( prcUserParams -> xu_user, pszStart1Addr , ulLength1 );

            // if necessary convert string to upper
            if ( bUIdToUpper ) {
                MoveToUpper ( prcUserParams -> xu_user, ulLength1 );
            }

            DBG3 (( MF__, "prcUserParams -> xu_user = \"%s\"",
                            _PToC ( prcUserParams -> xu_user )));
        }

        // get password if uLength2 > 0
        if ( ulLength2 > 0 ) {
            // determinate length of password
            nLength = sizeof ( SQL_PASSWORD );

            // check length
            if ( ulLength2 > (ULONG)nLength )
                ulLength2 = (ULONG)nLength;

            // copy without '\0'
            memcpy ( acPassword, pszStart2Addr , ulLength2 );

            // if necessary convert string to upper
            if ( bPasswordToUpper ) {
                MoveToUpper ( acPassword, ulLength2 );
            }

            DBG3 (( MF__, "acPassword = \"%s\"", _PToC ( acPassword )));
        }
    }

    DBGOUT;
}


/*------------------------------*/


static VOID MakeDBId    (   tsp4_xuser_record  *prcUserParams,
                            tsp4_xuserset       ucXuserType     )
{
    #undef  MF__
    #define MF__ MOD__"MakeDBId"


    SQL_NODEIDC     acNodeId;
    SQL_DBNAMEC     acDBName;


    DBGIN;

    // get servernode ( only if it exists )
    if ( strlen ( sql80_OptArg )) {
        // initialize serverdb string

        memset ( prcUserParams -> xu_serverdb, ' ', 
                 sizeof ( prcUserParams -> xu_serverdb ));

        // if nessecary split serverdb and servernode
        acNodeId [ 0 ] = (CHAR) 0;             // init the node to empty
        strncpy ( acDBName, sql80_OptArg, sizeof ( SQL_DBNAMEC ));

        DBG3 (( MF__, "acDBName ( original ) = \"%s\"", acDBName ));

        sql17u_split_dbname ( acDBName, acNodeId );

        DBG3 (( MF__, "acDBName ( after splitdbname ) = \"%s\"", acDBName ));
        DBG3 (( MF__, "acNodeId ( after splitdbname ) = \"%s\"", acNodeId ));

        // take over C-names into pascal vars
        sql47c_ctop ( prcUserParams -> xu_serverdb,
                      acDBName, 
                      (SHORT) sizeof ( prcUserParams -> xu_serverdb ));

//      MoveToUpper ( prcUserParams -> xu_serverdb, strlen ( acDBName ) );

        if ( strlen ( acNodeId )) {
            // initialize servernode string
            memset ( prcUserParams -> xu_servernode, ' ', 
                     sizeof ( prcUserParams -> xu_servernode ));

            // get servernode
            sql47c_ctop ( prcUserParams -> xu_servernode,
                         acNodeId, 
                         (SHORT) sizeof ( prcUserParams -> xu_servernode ));

            // get servernode
            PUTBIT ( ucXuserType, SP4XU_SQL_SERVERNODE );
        }

        DBG3 (( MF__, "prcUserParams -> xu_serverdb = \"%s\"",
                _PToC ( prcUserParams -> xu_serverdb )));
        DBG3 (( MF__, "prcUserParams -> xu_servernode = \"%s\"",
                _PToC ( prcUserParams -> xu_servernode )));
    }

    PUTBIT ( ucXuserType, SP4XU_SQL_SERVERDB );
    CLRBIT ( ucXuserType, SP4XU_SQL_USERMASK );
    DBGOUT;
}


/*------------------------------*/


static VOID MakeDBNode  (   tsp4_xuser_record  *prcUserParams, 
                            tsp4_xuserset       ucXuserType     )
{
    #undef  MF__
    #define MF__ MOD__"MakeDBNode"


    INT nArgLength;
    INT nLength;


    DBGIN;

    // get servernode
    memset ( prcUserParams -> xu_servernode, ' ', 
             sizeof ( prcUserParams -> xu_servernode ));
    nArgLength = strlen ( sql80_OptArg );
    nLength = sizeof ( prcUserParams -> xu_servernode );

    if ( nArgLength > nLength )
        nArgLength = nLength;

    memcpy ( prcUserParams -> xu_servernode, sql80_OptArg, nArgLength );

    DBG3 (( MF__, "prcUserParams -> xu_servernode = \"%s\"",
            _PToC ( prcUserParams -> xu_servernode )));

    PUTBIT ( ucXuserType, SP4XU_SQL_SERVERNODE );
    CLRBIT ( ucXuserType, SP4XU_SQL_USERMASK );
    DBGOUT;
}


/*------------------------------*/


static VOID MakeDBLang  (   tsp4_xuser_record  *prcUserParams, 
                            tsp4_xuserset       ucXuserType     )
{
    #undef  MF__
    #define MF__ MOD__"MakeDBLang"


    INT nArgLength;
    INT nLength;


    DBGIN;

    // get dblang
    memset ( prcUserParams -> xu_dblang, ' ', 
             sizeof ( prcUserParams -> xu_dblang ));
    nArgLength = strlen ( sql80_OptArg );
    nLength = sizeof ( prcUserParams -> xu_dblang );

    if ( nArgLength > nLength )
        nArgLength = nLength;

    memcpy ( prcUserParams -> xu_dblang, sql80_OptArg, nArgLength );

    DBG3 (( MF__, "prcUserParams -> xu_dblang = \"%s\"",
            _PToC ( prcUserParams -> xu_dblang )));

    PUTBIT ( ucXuserType, SP4XU_SQL_DBLANG );
    CLRBIT ( ucXuserType, SP4XU_SQL_USERMASK );
    DBGOUT;
}


/*------------------------------*/


static VOID MakeUserKey (   tsp4_xuser_record  *prcUserParams,
                            tsp4_xuserset       ucXuserType,
                            BOOLEAN             bEnvDBNameFound,
                            ERRORTEXT           acErrorText,
                            PBOOLEAN            pbOk                )
{
    #undef  MF__
    #define MF__ MOD__"MakeUserKey"


    INT     nLength;
    INT     nArgLength;
    APIRET  rc;


    DBGIN;

    // get userkey and ucXuserType
    nLength    = sizeof ( prcUserParams -> xu_key );
    nArgLength = strlen ( sql80_OptArg );

    if ( nArgLength > nLength )
        nArgLength = nLength;

    if ( !strcmp ( sql80_OptArg, "prompt" ) || !strcmp ( sql80_OptArg, "PROMPT" )) {
        PUTBIT ( ucXuserType, SP4XU_SQL_USERMASK );
    }
    else {
        // check for error conditions
        if ( TSTBIT ( ucXuserType, SP4XU_SQL_USERPARMS  )  |
             TSTBIT ( ucXuserType, SP4XU_SQL_SERVERNODE )  |
             TSTBIT ( ucXuserType, SP4XU_SQL_MODE       )  |
             TSTBIT ( ucXuserType, SP4XU_SQL_ISOLATION  )  |
             TSTBIT ( ucXuserType, SP4XU_SQL_TIMEOUT    )  |
             TSTBIT ( ucXuserType, SP4XU_SQL_CACHELIMIT )) {

            *pbOk = FALSE;

            DBG1 (( MF__, ERRMSG_WRONG_OPTION_SEQUENCE ));
            MSGD  (( ERR_WRONG_OPTION_SEQUENCE ));
            memcpy ( acErrorText, ERRMSG_WRONG_OPTION_SEQUENCE, 
                     sizeof ( ERRORTEXT ));
            sql46c_build_error_string ( acErrorText,
                                        ERRMSG_WRONG_OPTION_SEQUENCE, 0 );

            DBGOUT;

            return;
        }

        if ( !bEnvDBNameFound && TSTBIT ( ucXuserType, SP4XU_SQL_SERVERDB )) {
            *pbOk = FALSE;

            DBG1 (( MF__, ERRMSG_WRONG_OPTION_SEQUENCE ));
            MSGD  (( ERR_WRONG_OPTION_SEQUENCE ));
            sql46c_build_error_string ( acErrorText,
                                        ERRMSG_WRONG_OPTION_SEQUENCE, 0 );

            DBGOUT;

            return;
        }

        // copy without '\0'
        if ( BLANKS_ONLY ( sql80_OptArg )) {
            memset ( prcUserParams -> xu_key, ' ', 
                     sizeof ( prcUserParams -> xu_key ));
            memcpy ( prcUserParams -> xu_key, DEFAULT_USER, 
                     sizeof ( prcUserParams -> xu_key ));
            PUTBIT ( ucXuserType, SP4XU_SQL_USERDEFAULT );
            CLRBIT ( ucXuserType, SP4XU_SQL_USERMASK );
        }
        else {
            memset ( prcUserParams -> xu_key, ' ', 
                     sizeof ( prcUserParams -> xu_key ));
            memcpy ( prcUserParams -> xu_key, sql80_OptArg, nArgLength );

            PUTBIT ( ucXuserType, SP4XU_SQL_USERKEY );
            CLRBIT ( ucXuserType, SP4XU_SQL_USERMASK );
            CLRBIT ( ucXuserType, SP4XU_SQL_USERDEFAULT );
        }

        // calling getuser because of a specified user key
        rc = sql13u_getuser ( prcUserParams, acErrorText );

        if ( rc != NO_ERROR )
            *pbOk = FALSE;
//      else
//          MoveToUpper ( prcUserParams -> xu_serverdb, 
//                        sizeof ( prcUserParams -> xu_serverdb ));

        DBG3 (( MF__, "prcUserParams -> xu_key = \"%s\"",
                _PToC ( prcUserParams -> xu_key )));
        DBG3 (( MF__, "prcUserParams -> xu_servernode = \"%s\"",
                _PToC ( prcUserParams -> xu_servernode )));
        DBG3 (( MF__, "prcUserParams -> xu_serverdb = \"%s\"",
                _PToC ( prcUserParams -> xu_serverdb )));
        DBG3 (( MF__, "prcUserParams -> xu_user = \"%s\"",
                _PToC ( prcUserParams -> xu_user )));
        DBG3 (( MF__, "prcUserParams -> xu_sqlmode = \"%s\"",
                _PToC ( prcUserParams -> xu_sqlmode )));

        DBG3 (( MF__, "prcUserParams -> xu_cachelimit = %d",
                       prcUserParams -> xu_cachelimit ));
        DBG3 (( MF__, "prcUserParams -> xu_timeout = %d",
                       prcUserParams -> xu_timeout ));
        DBG3 (( MF__, "prcUserParams -> xu_isolation = %d",
                       prcUserParams -> xu_isolation ));
    }

    DBG3 (( MF__, "ucXuserType [ 0 ] = %d", ucXuserType [ 0 ] ));
    DBG3 (( MF__, "ucXuserType [ 1 ] = %d", ucXuserType [ 1 ] ));

    DBGOUT;
}


/*------------------------------*/


static VOID MakeSqlMode (   tsp4_xuser_record  *prcUserParams,
                            tsp4_xuserset       ucXuserType     )
{
    #undef  MF__
    #define MF__ MOD__"MakeSqlMode"


    INT nLength;
    INT nArgLength;


    DBGIN;

    // get sqlmode
    memset ( prcUserParams -> xu_sqlmode, ' ', 
             sizeof ( prcUserParams -> xu_sqlmode ));
    nLength    = sizeof ( prcUserParams -> xu_key );
    nArgLength = strlen ( sql80_OptArg );

    if ( nArgLength > nLength )
        nArgLength = nLength;

    // copy without '\0'
    memcpy ( prcUserParams -> xu_sqlmode, sql80_OptArg, nArgLength );

    DBG3 (( MF__, "prcUserParams -> xu_sqlmode = \"%s\"",
            _PToC ( prcUserParams -> xu_sqlmode )));

    PUTBIT ( ucXuserType, SP4XU_SQL_MODE );
    CLRBIT ( ucXuserType, SP4XU_SQL_USERMASK );
    DBGOUT;
}


/*------------------------------*/


static VOID MakeIsolation   (   tsp4_xuser_record  *prcUserParams,
                                tsp4_xuserset       ucXuserType     )
{
    #undef  MF__
    #define MF__ MOD__"MakeIsolation"


    BOOLEAN bNoAlphaFound;
    INT     nArgLength;
    INT     nIndex;


    DBGIN;

    // get isolation level and test for the digits 0 through 9
    nArgLength    = strlen ( sql80_OptArg );
    bNoAlphaFound = TRUE;

    for ( nIndex = 0; nIndex < nArgLength; nIndex++ ) {
        if ( isalpha ( sql80_OptArg [ nIndex ] )) {
            bNoAlphaFound = FALSE;

            break;
        }
    }

    if ( bNoAlphaFound )
        prcUserParams -> xu_isolation = atoi ( sql80_OptArg );

    DBG3 (( MF__, "prcUserParams -> xu_isolation = %d",
                   prcUserParams -> xu_isolation ));

    PUTBIT ( ucXuserType, SP4XU_SQL_ISOLATION );
    CLRBIT ( ucXuserType, SP4XU_SQL_USERMASK );
    DBGOUT;
}


/*------------------------------*/


static VOID MakeTimeOut (   tsp4_xuser_record  *prcUserParams,
                            tsp4_xuserset       ucXuserType     )
{
    #undef  MF__
    #define MF__ MOD__"MakeTimeOut"


    BOOLEAN bNoAlphaFound;
    INT     nArgLength;
    INT     nIndex;
    LONG    lTimeOut;


    DBGIN;

    // get timeout and test for the digits 0 through 9
    nArgLength    = strlen ( sql80_OptArg );
    bNoAlphaFound = TRUE;

    for ( nIndex = 0; nIndex < nArgLength; nIndex++ ) {
        if ( isalpha ( sql80_OptArg [ nIndex ] )) {
            bNoAlphaFound = FALSE;

            break;
        }
    }

    if ( bNoAlphaFound )
      {
      lTimeOut = atol ( sql80_OptArg );

      if (( lTimeOut < 32768L ) && ( nArgLength <= 5 ))
        prcUserParams -> xu_timeout = (INT2)lTimeOut;
      else
        prcUserParams -> xu_timeout = (INT2)32767;
      }
    else
      prcUserParams -> xu_timeout = (INT2)32767;


    DBG3 (( MF__, "prcUserParams -> xu_timeout = %d",
                   prcUserParams -> xu_timeout ));

    PUTBIT ( ucXuserType, SP4XU_SQL_TIMEOUT );
    CLRBIT ( ucXuserType, SP4XU_SQL_USERMASK );
    DBGOUT;
}


/*------------------------------*/


static VOID MakeCacheLimit  (   tsp4_xuser_record  *prcUserParams,
                                tsp4_xuserset       ucXuserType     )
{
    #undef  MF__
    #define MF__ MOD__"MakeCacheLimit"


    BOOLEAN bNoAlphaFound;
    INT     nArgLength;
    INT     nIndex;


    DBGIN;

    // get timeout and test for the digits 0 through 9
    nArgLength    = strlen ( sql80_OptArg );
    bNoAlphaFound = TRUE;

    for ( nIndex = 0; nIndex < nArgLength; nIndex++ ) {
        if ( isalpha ( sql80_OptArg [ nIndex ] )) {
            bNoAlphaFound = FALSE;

            break;
        }
    }

    if ( bNoAlphaFound )
        prcUserParams -> xu_cachelimit = atoi ( sql80_OptArg );

    DBG3 (( MF__, "prcUserParams -> xu_cachelimit = %d",
                   prcUserParams -> xu_cachelimit ));

    PUTBIT ( ucXuserType, SP4XU_SQL_CACHELIMIT );
    CLRBIT ( ucXuserType, SP4XU_SQL_USERMASK );
    DBGOUT;
}



/*------------------------------*/


static VOID MakePrecompilerInputFn  (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakePrecompilerInputFn"


    INT             nArgLength;
    INT             nLength;
    INT             nCount;
    PSZ             pszBegin;
    PSZ             pszTmp1;
    PSZ             pszTmp2;
    PSZ             pszEnd;


    DBGIN;

    // get file name
    nArgLength = strlen ( sql80_OptArg );
    nLength    = sizeof ( prcArgsOptions ->
                          components.prec.opt_modulefn );

    if ( nArgLength > nLength )
        nArgLength = nLength;

    prcArgsOptions -> components.prec.opt_fnind =
                                                    (INT2) sql80_OptInd - 1;
    memcpy ( prcArgsOptions -> components.prec.opt_modulefn,
             sql80_OptArg, nArgLength );

    // extract file name that means: no path and no suffix
    // ( path/modulename.suffix )
    pszEnd   = strrchr ( sql80_OptArg, '.' );
    pszTmp1  = strrchr ( sql80_OptArg, '\\' );
    pszTmp2  = strrchr ( sql80_OptArg, '/' );

    pszBegin = max( pszTmp1, pszTmp2 );


    if ( pszBegin == NULL )
        pszBegin = sql80_OptArg;
    else
        pszBegin++;

    if (( pszEnd == NULL ) || (pszEnd <= pszBegin))
        pszEnd = sql80_OptArg + strlen ( sql80_OptArg );

    nLength = sizeof ( prcArgsOptions ->
                       components.prec.opt_modulename );
    nCount  = pszEnd - pszBegin;

    if ( nCount > nLength )
        nCount = nLength;

    memcpy ( prcArgsOptions -> components.prec.opt_modulename,
             pszBegin, nCount );

    prcArgsOptions -> components.prec.opt_modulenamel = nCount;

    DBG3 (( MF__, "opt_modulefn = \"%s\"",
            _PToC ( prcArgsOptions ->
                    components.prec.opt_modulefn )));
    DBG3 (( MF__, "opt_modulename = \"%s\"",
            _PToC ( prcArgsOptions ->
                    components.prec.opt_modulename )));
    DBG3 (( MF__, "opt_modulenamel= %d",
            prcArgsOptions -> components.prec.opt_modulenamel ));

    DBGOUT;
}


/*------------------------------*/


static VOID MakePrecompilerTraceFn  (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakePrecompilerTraceFn"


    INT nArgLength;
    INT nLength;


    DBGIN;

    // get trace name
    nArgLength = strlen ( sql80_OptArg );
    nLength    = sizeof ( prcArgsOptions ->
                          components.prec.opt_tracefile );

    if ( nArgLength > nLength )
        nArgLength = nLength;

    memcpy ( prcArgsOptions -> components.prec.opt_tracefile,
             sql80_OptArg, nArgLength );

    DBG3 (( MF__, "opt_tracefile = \"%s\"",
            _PToC ( prcArgsOptions ->
                    components.prec.opt_tracefile )));

    DBGOUT;
}


/*------------------------------*/


static VOID MakePrecompilerProgFn   (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakePrecompilerProgFn"


    INT nArgLength;
    INT nLength;


    DBGIN;

    // get prog name and nLength of prog name
    nArgLength = strlen ( sql80_OptArg );
    nLength    = sizeof ( prcArgsOptions ->
                          components.prec.opt_progname );

    if ( nArgLength > nLength )
        nArgLength = nLength;

    prcArgsOptions -> components.prec.opt_prognamel = nArgLength;
    memcpy ( prcArgsOptions -> components.prec.opt_progname,
             sql80_OptArg, nArgLength );

    DBG3 (( MF__, "opt_prognamel = %d",
            prcArgsOptions -> components.prec.opt_prognamel ));
    DBG3 (( MF__, "opt_progname = \"%s\"",
            _PToC ( prcArgsOptions ->
                    components.prec.opt_progname )));

    DBGOUT;
}


/*------------------------------*/


static VOID MakePrecompilerMargin   (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakePrecompilerMargin"


    BOOLEAN         bEndMarginFound;
    BOOLEAN         bNoAlphaFound;
    INT             nArgLength;
    INT             nLength;
    INT             nLengthFirst;
    INT             nIndex;
    PSZ             pszStartAddr;
    PSZ             pszCommaAddr ;
    C4              acTmpMargin;


    DBGIN;

    // get begin margin determinate comma position, the start pos of sql80_OptArg
    // and the begin margin string nLength
    bEndMarginFound = TRUE;
    nArgLength      = strlen ( sql80_OptArg );
    pszCommaAddr    = strchr ( sql80_OptArg, ',' );
    pszStartAddr    = sql80_OptArg;
    nLength         = pszCommaAddr  - pszStartAddr ;

    // check nLength
    if ( !pszCommaAddr  ) {
        bEndMarginFound = FALSE;
        nLength         = nArgLength;
    }

    // convert string to int and take over it
    nLengthFirst  = nLength + 1;
    bNoAlphaFound = TRUE;

    memset ( acTmpMargin, ' ', sizeof ( acTmpMargin ));

    for ( nIndex = 0; ( nIndex < nLength ) &&
                      ( nIndex < sizeof ( acTmpMargin)); nIndex++ ) {
        if ( isalpha ( sql80_OptArg [ nIndex ] )) {
            bNoAlphaFound = FALSE;

            break;
        }
        else
            acTmpMargin [ nIndex ] = sql80_OptArg [ nIndex ];
    }

    if ( bNoAlphaFound )
        prcArgsOptions ->
        components.prec.opt_begmar = atoi ( acTmpMargin );

    // get end margin ',' if it was found
    if ( bEndMarginFound ) {
        // get the beginning of end margin and determinate nLength of
        // end margin
        pszCommaAddr ++;
        nLength = pszStartAddr  + nArgLength - pszCommaAddr ;

        // convert string to int and take over it
        bNoAlphaFound = TRUE;

        memset ( acTmpMargin, ' ', sizeof ( acTmpMargin ));

        for ( nIndex = 0; ( nIndex < nLength ) &&
                          ( nIndex < sizeof ( acTmpMargin )); nIndex++ ) {
            if ( isalpha ( sql80_OptArg [ nIndex + nLengthFirst ] )) {
                bNoAlphaFound = FALSE;

                break;
            }
            else
                acTmpMargin [ nIndex ] = sql80_OptArg [ nIndex + nLengthFirst ];
        }

        if ( bNoAlphaFound )
            prcArgsOptions ->
            components.prec.opt_endmar = atoi ( acTmpMargin );
    }

    DBG3 (( MF__, "opt_begmar = %d",
            prcArgsOptions -> components.prec.opt_begmar ));

    DBG3 (( MF__, "opt_endmar = %d",
            prcArgsOptions -> components.prec.opt_endmar ));

    DBGOUT;
}


/*------------------------------*/


static VOID MakePrecompilerDateTime (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakePrecompilerDateTime"


    DBGIN;

    // get date type
    if ( !strcmp ( sql80_OptArg, "iso" ))
        prcArgsOptions -> components.prec.opt_datetime = 2;

    if ( !strcmp ( sql80_OptArg, "usa" ))
        prcArgsOptions -> components.prec.opt_datetime = 3;

    if ( !strcmp ( sql80_OptArg, "eur" ))
        prcArgsOptions -> components.prec.opt_datetime = 4;

    if ( !strcmp ( sql80_OptArg, "jis" ))
        prcArgsOptions -> components.prec.opt_datetime = 5;

    DBG3 (( MF__, "opt_datetime = %d",
              prcArgsOptions -> components.prec.opt_datetime ));

    DBGOUT;
}


/*------------------------------*/


static VOID MakePrecompilerSysTpMon (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakePrecompilerSysTpMon"


    BOOLEAN         bTpMonFound;
    INT             nArgLength;
    INT             nLength1;
    INT             nLength2;
    PSZ             pszStartAddr ;
    PSZ             pszCommaAddr ;
    CHAR            acTmpSys [ 9 ];


    DBGIN;

    // get sys, determinate comma position, the start position of sql80_OptArg
    // and the sys string nLength

    bTpMonFound  = TRUE;
    nArgLength   = strlen ( sql80_OptArg );
    pszCommaAddr = strchr ( sql80_OptArg, ',' );
    pszStartAddr = sql80_OptArg;
    nLength2     = pszCommaAddr  - pszStartAddr ;

    // check nLength
    if ( !pszCommaAddr  ) {
        bTpMonFound = FALSE;
        nLength2    = nArgLength;
    }

    // copy with '\0'
    if ( nLength2 < sizeof ( acTmpSys )) {
        strncpy ( acTmpSys, sql80_OptArg, ( size_t ) nLength2 );
        acTmpSys [ nLength2 ] = '\0';
    }
    else {
        strncpy ( acTmpSys, sql80_OptArg, sizeof ( acTmpSys ) - 1 );
        acTmpSys [ sizeof ( acTmpSys ) - 1 ] = '\0';
    }

    DBG3 (( MF__, "acTmpSys = \"%s\"", acTmpSys ));

    // determinate tpmon
    if ( !strcmp ( acTmpSys, "cics" ))
        prcArgsOptions -> components.prec.opt_tpmon = 1;

    if ( !strcmp ( acTmpSys, "pccics" ))
        prcArgsOptions -> components.prec.opt_tpmon = 2;

    if ( !strcmp ( acTmpSys, "aim" ))
        prcArgsOptions -> components.prec.opt_tpmon = 3;

    if ( !strcmp ( acTmpSys, "utm" ))
        prcArgsOptions -> components.prec.opt_tpmon = 4;

    DBG3 (( MF__, "opt_tpmon = %d",
            prcArgsOptions -> components.prec.opt_tpmon ));

    // get tpmonid if ',' was found
    if ( bTpMonFound ) {
        // get the beginning of tpmonid and the nLength of tpmonid field,
        // determinate nLength of tpmonid
        pszCommaAddr ++;
        nLength1 = sizeof ( prcArgsOptions ->
                            components.prec.opt_tpmonid );
        nLength2 = pszStartAddr  + nArgLength - pszCommaAddr ;

        // check nLength

        if ( nLength2 > nLength1 )
            nLength2 = nLength1;


        // copy without '\0'
        memcpy ( prcArgsOptions -> components.prec.opt_tpmonid,
                 pszCommaAddr , nLength2 );

        DBG3 (( MF__, "opt_tpmonid = \"%s\"",
                _PToC ( prcArgsOptions ->
                        components.prec.opt_tpmonid )));
    }

    DBGOUT;
}


/*------------------------------*/


static VOID MakePrecompilerMode (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakePrecompilerMode"


    DBGIN;

    // get sql mode
    if ( !strcmp ( sql80_OptArg, "syntax" ))
        prcArgsOptions -> components.prec.opt_mode = 1;

    if ( !strcmp ( sql80_OptArg, "nocheck" ))
        prcArgsOptions -> components.prec.opt_mode = 0;

    DBG3 (( MF__, "opt_mode = %d",
            prcArgsOptions -> components.prec.opt_mode ));

    DBGOUT;
}


/*------------------------------*/


static VOID MakePrecompilerCAnsi    (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakePrecompilerCAnsi"


    DBGIN;

    // get sql cansi

    if ( !strcmp ( sql80_OptArg, "cansi" ))
        prcArgsOptions -> components.prec.opt_cansi = 1;
    else
    if ( !strcmp ( sql80_OptArg, "cplus" ))
        prcArgsOptions -> components.prec.opt_cansi = 2;
    else
    if ( !strcmp ( sql80_OptArg, "ansi85" ))
        prcArgsOptions -> components.prec.opt_cansi = 3;

    DBG3 (( MF__, "opt_cansi = %d",
            prcArgsOptions -> components.prec.opt_cansi ));
}

/*------------------------------*/

static VOID MakePrecompilerUnicode (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakePrecompilerUnicode"


    DBGIN;

    // get sql mode
   if ( !strcmp ( sql80_OptArg, "unicode" ))
     prcArgsOptions -> components.prec.opt_unicode = TRUE ;

   DBG3 (( MF__, "opt_unicode = %d",
           prcArgsOptions -> components.prec.opt_unicode ));

    DBGOUT;
}


/*------------------------------*/

static VOID MakePrecompilerPacketSize
            (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakePrecompilerPacketSize"


    BOOLEAN bNoAlphaFound;
    INT     nArgLength;
    INT     nIndex;


    DBGIN;

    nArgLength    = strlen ( sql80_OptArg );
    bNoAlphaFound = TRUE;

    for ( nIndex = 0; nIndex < nArgLength; nIndex ++ ) {
        if ( isalpha ( sql80_OptArg [ nIndex ] )) {
            bNoAlphaFound = FALSE;

            break;
        }
    }

    if ( bNoAlphaFound )
        prcArgsOptions -> components.prec.opt_packetsize = 
                          atoi ( sql80_OptArg );

    DBG3 (( MF__, "opt_packetsize = %d",prcArgsOptions -> components.
                                                          prec.
                                                          opt_packetsize ));

    DBGOUT;
}

/*------------------------------*/


static VOID MakePrecompilerRunTimeTraceFn
            (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakePrecompilerRunTimeTraceFn"


    INT nArgLength;
    INT nLength;


    DBGIN;

    // get trace name
    nArgLength = strlen ( sql80_OptArg );
    nLength    = sizeof ( prcArgsOptions ->
                          components.pc_rt.opt_rtracefile );

    if ( nArgLength > nLength )
        nArgLength = nLength;

    memcpy ( prcArgsOptions -> components.
                               pc_rt.
                               opt_rtracefile,
             sql80_OptArg, nArgLength );

    DBG3 (( MF__, "opt_rtracefile = \"%s\"",
            _PToC ( prcArgsOptions -> components.
                                      pc_rt.
                                      opt_rtracefile )));

    DBGOUT;
}

/*------------------------------*/

static VOID MakePrecompilerRunTimeStmtCnt
            (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakePrecompilerRunTimeStmtCnt"


    BOOLEAN bNoAlphaFound;
    INT     nArgLength;
    INT     nIndex;


    DBGIN;

    nArgLength    = strlen ( sql80_OptArg );
    bNoAlphaFound = TRUE;

    for ( nIndex = 0; nIndex < nArgLength; nIndex ++ ) {
        if ( isalpha ( sql80_OptArg [ nIndex ] )) {
            bNoAlphaFound = FALSE;

            break;
        }
    }

    if ( bNoAlphaFound )
        prcArgsOptions -> components.
                          pc_rt.
                          opt_rstmt_cnt = atoi ( sql80_OptArg );

    DBG3 (( MF__, "opt_rstmt_cnt = %d",prcArgsOptions -> components.
                                                       pc_rt.
                                                       opt_rstmt_cnt ));

    DBGOUT;
}

/*------------------------------*/


static VOID MakePrecompilerRunTimeLimit
            (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakePrecompilerRunTimeLimit"


    BOOLEAN bNoAlphaFound;
    INT     nArgLength;
    INT     nIndex;


    DBGIN;

    nArgLength    = strlen ( sql80_OptArg );
    bNoAlphaFound = TRUE;

    for ( nIndex = 0; nIndex < nArgLength; nIndex ++ ) {
        if ( isalpha ( sql80_OptArg [ nIndex ] )) {
            bNoAlphaFound = FALSE;

            break;
        }
    }

    if ( bNoAlphaFound )
        prcArgsOptions -> components.
                          pc_rt.
                          opt_rtime_limit = atoi ( sql80_OptArg );

    DBG3 (( MF__, "opt_rtime_limit = %d",prcArgsOptions -> components.
                                                       pc_rt.
                                                       opt_rtime_limit ));

    DBGOUT;
}

/*------------------------------*/


static VOID MakePrecompilerRunTimeMFetch
            (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakePrecompilerRunTimeMFetch"


    BOOLEAN bNoAlphaFound;
    INT     nArgLength;
    INT     nIndex;


    DBGIN;

    // get mfetch count and test for the digits 0 through 9
    nArgLength    = strlen ( sql80_OptArg );
    bNoAlphaFound = TRUE;

    for ( nIndex = 0; nIndex < nArgLength; nIndex ++ ) {
        if ( isalpha ( sql80_OptArg [ nIndex ] )) {
            bNoAlphaFound = FALSE;

            break;
        }
    }

    if ( bNoAlphaFound )
        prcArgsOptions -> components.
                          pc_rt.
                          opt_rmfetch = atoi ( sql80_OptArg );

    DBG3 (( MF__, "opt_rmfetch = %d",prcArgsOptions -> components.
                                                       pc_rt.
                                                       opt_rmfetch ));

    DBGOUT;
}


/*------------------------------*/


static VOID MakeDialogComponentRFn  (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakeDialogComponentRFn"


    INT nArgLength;
    INT nLength;


    DBGIN;

    // get runfile
    nArgLength = strlen ( sql80_OptArg );
    nLength    = sizeof ( prcArgsOptions -> components.
                                            dcomp_util.
                                            opt_runfile );

    if ( nArgLength > nLength )
        nArgLength = nLength;

    memcpy ( prcArgsOptions -> components.
                               dcomp_util.opt_runfile,
             sql80_OptArg, nArgLength );

    // get command mode
    prcArgsOptions -> components.
                      dcomp_util.
                      opt_comm_mode = SP4CM_SQL_RUN;

    DBG3 (( MF__, "opt_runfile = \"%s\"",
            _PToC ( prcArgsOptions -> components.
                                      dcomp_util.
                                      opt_runfile )));
    DBG3 (( MF__, "opt_comm_mode = %d",
            prcArgsOptions -> components.
                              dcomp_util.
                              opt_comm_mode ));

    DBGOUT;
}


/*------------------------------*/


static VOID MakeDialogComponentBFn  (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakeDialogComponentBFn"


    INT nArgLength;
    INT nLength;


    DBGIN;

    // get runfile
    nArgLength = strlen ( sql80_OptArg );
    nLength    = sizeof ( prcArgsOptions -> components.
                                            dcomp_util.
                                            opt_runfile );

    if ( nArgLength > nLength )
        nArgLength = nLength;

    memcpy ( prcArgsOptions -> components.
                               dcomp_util.opt_runfile,
             sql80_OptArg, nArgLength );

    // get command mode
    prcArgsOptions -> components.
                      dcomp_util.opt_comm_mode = SP4CM_SQL_BATCH;

    DBG3 (( MF__, "opt_runfile = \"%s\"",
            _PToC ( prcArgsOptions -> components.
                                      dcomp_util.
                                      opt_runfile )));
    DBG3 (( MF__, "opt_comm_mode = %d",
            prcArgsOptions -> components.
                              dcomp_util.opt_comm_mode ));

    DBGOUT;
}


/*------------------------------*/


static VOID MakeDialogComponentObj (   tsp4_args_options  *prcArgsOptions,
                                       tsp4_command_mode   OptCommMode,
                                       INT                 nMaxObjNames,
                                       PBOOLEAN            pbOk,
                                       ERRORTEXT           acErrorText )
{
    #undef  MF__
    #define MF__ MOD__"MakeDialogComponentObj"

    CTU_REC         CtU;
    INT             nLengthObjectOwner;
    INT             nLengthObjectName1;
    INT             nLengthObjectName2;
    INT             nLengthObject;
    INT             nLength1;
    INT             nLength2;

    DBGIN;

    // initialize
    nLengthObjectOwner = sizeof ( prcArgsOptions -> components.
                                                    dcomp_util.
                                                    opt_object_owner );
    nLengthObjectName1 = sizeof ( prcArgsOptions -> components.
                                                    dcomp_util.
                                                    opt_object_name1 );
    nLengthObjectName2 = sizeof ( prcArgsOptions -> components.
                                                    dcomp_util.
                                                    opt_object_name2 );

    if ( nMaxObjNames == 2 ) {
        CheckIdents ( &CtU, '.', 3, pbOk, acErrorText );

        if ( !*pbOk ) {
            DBGOUT;
            return;
        }

        if ( ( CtU.lIdentLen[0] > 0 ) &&
             ( CtU.lIdentLen[1] > 0 ) &&
             ( CtU.lIdentLen[2] > 0 ) ) {

            if ( CtU.lIdentLen[0] > nLengthObjectOwner )
                nLengthObject = nLengthObjectOwner;
            else
                nLengthObject = CtU.lIdentLen[0];

            if ( CtU.lIdentLen[1] > nLengthObjectName1 )
                nLength1 = nLengthObjectName1;
            else
                nLength1 = CtU.lIdentLen[1];

            if ( CtU.lIdentLen[2] > nLengthObjectName2 )
                nLength2 = nLengthObjectName2;
            else
                nLength2 = CtU.lIdentLen[2];

            memcpy ( prcArgsOptions -> components.
                                       dcomp_util.
                                       opt_object_owner,
                     CtU.pszIdent[0], nLengthObject );

            memcpy ( prcArgsOptions -> components.
                                       dcomp_util.
                                       opt_object_name1,
                     CtU.pszIdent[1], nLength1 );

            memcpy ( prcArgsOptions -> components.
                                       dcomp_util.
                                       opt_object_name2,
                     CtU.pszIdent[2], nLength2 );

            if ( CtU.bIdentToUpper[0] ) {
                MoveToUpper ( prcArgsOptions -> components.
                                                dcomp_util.
                                                opt_object_owner,
                              nLengthObject );
            }

            if ( CtU.bIdentToUpper[1] ) {
                MoveToUpper ( prcArgsOptions -> components.
                                                dcomp_util.
                                                opt_object_name1,
                              nLength1 );
            }

            if ( CtU.bIdentToUpper[2] ) {
                MoveToUpper ( prcArgsOptions -> components.
                                                dcomp_util.
                                                opt_object_name2,
                              nLength2 );
            }
        }
        else if ( ( CtU.lIdentLen[0] >  0 ) &&
                  ( CtU.lIdentLen[1] >  0 ) &&
                  ( CtU.lIdentLen[2] == 0 ) ) {

            if ( CtU.lIdentLen[0] > nLengthObjectName1 )
                nLength1 = nLengthObjectName1;
            else
                nLength1 = CtU.lIdentLen[0];

            if ( CtU.lIdentLen[1] > nLengthObjectName2 )
                nLength2 = nLengthObjectName2;
            else
                nLength2 = CtU.lIdentLen[1];


            memcpy ( prcArgsOptions -> components.
                                       dcomp_util.
                                       opt_object_name1,
                     CtU.pszIdent[0], nLength1 );

            memcpy ( prcArgsOptions -> components.
                                       dcomp_util.
                                       opt_object_name2,
                     CtU.pszIdent[1], nLength2 );


            if ( CtU.bIdentToUpper[0] ) {
                MoveToUpper ( prcArgsOptions -> components.
                                                dcomp_util.
                                                opt_object_name1,
                              nLength1 );
            }

            if ( CtU.bIdentToUpper[1] ) {
                MoveToUpper ( prcArgsOptions -> components.
                                                dcomp_util.
                                                opt_object_name2,
                              nLength2 );
            }
        }
        else if ( ( CtU.lIdentLen[0] >  0 ) &&
                  ( CtU.lIdentLen[1] == 0 ) &&
                  ( CtU.lIdentLen[2] == 0 ) ) {

            if ( CtU.lIdentLen[0] > nLengthObjectName1 )
                nLength1 = nLengthObjectName1;
            else
                nLength1 = CtU.lIdentLen[0];


            memcpy ( prcArgsOptions -> components.
                                       dcomp_util.
                                       opt_object_name1,
                     CtU.pszIdent[0], nLength1 );


            if ( CtU.bIdentToUpper[0] ) {
                MoveToUpper ( prcArgsOptions -> components.
                                                dcomp_util.
                                                opt_object_name1,
                              nLength1 );
            }
        }
        else {
            *pbOk = FALSE;
            memcpy ( acErrorText, ERRMSG_ILLEGAL_DIALOG_OBJ, sizeof ( ERRORTEXT ) );
            sql46c_build_error_string ( acErrorText, ERRMSG_ILLEGAL_DIALOG_OBJ,
                                        0 );
            DBGOUT;
            return;
        }
    }
    // determinate object owner and name1
    else if ( nMaxObjNames == 1 ) {
        CheckIdents ( &CtU, '.', 2, pbOk, acErrorText );

        if ( !*pbOk ) {
            DBGOUT;
            return;
        }

        if ( ( CtU.lIdentLen[0] >  0 ) &&
             ( CtU.lIdentLen[1] >  0 ) &&
             ( CtU.lIdentLen[2] == 0 ) ) {

            if ( CtU.lIdentLen[0] > nLengthObjectOwner )
                nLengthObject = nLengthObjectOwner;
            else
                nLengthObject = CtU.lIdentLen[0];

            if ( CtU.lIdentLen[1] > nLengthObjectName1 )
                nLength1 = nLengthObjectName1;
            else
                nLength1 = CtU.lIdentLen[1];

            memcpy ( prcArgsOptions -> components.
                                       dcomp_util.
                                       opt_object_owner,
                     CtU.pszIdent[0], nLengthObject );

            memcpy ( prcArgsOptions -> components.
                                       dcomp_util.
                                       opt_object_name1,
                     CtU.pszIdent[1], nLength1 );

            if ( CtU.bIdentToUpper[0] ) {
                MoveToUpper ( prcArgsOptions -> components.
                                                dcomp_util.
                                                opt_object_owner,
                              nLengthObject );
            }

            if ( CtU.bIdentToUpper[1] ) {
                MoveToUpper ( prcArgsOptions -> components.
                                                dcomp_util.
                                                opt_object_name1,
                              nLength1 );
            }

        }
        else if ( ( CtU.lIdentLen[0] >  0 ) &&
                  ( CtU.lIdentLen[1] == 0 ) &&
                  ( CtU.lIdentLen[2] == 0 ) ) {

            if ( CtU.lIdentLen[0] > nLengthObjectName1 )
                nLength1 = nLengthObjectName1;
            else
                nLength1 = CtU.lIdentLen[0];


            memcpy ( prcArgsOptions -> components.
                                       dcomp_util.
                                       opt_object_name1,
                     CtU.pszIdent[0], nLength1 );


            if ( CtU.bIdentToUpper[0] ) {
                MoveToUpper ( prcArgsOptions -> components.
                                                dcomp_util.
                                                opt_object_name1,
                              nLength1 );
            }
        }
        else {
            *pbOk = FALSE;
            sql46c_build_error_string ( acErrorText, ERRMSG_ILLEGAL_DIALOG_OBJ,
                                        0 );
            DBGOUT;
            return;
        }
    }
    else {
        *pbOk = FALSE;
        sql46c_build_error_string ( acErrorText, ERRMSG_ILLEGAL_DIALOG_OBJ, 0 );
        DBGOUT;
        return;
    }

    // get command mode
    prcArgsOptions -> components.
                      dcomp_util.opt_comm_mode = OptCommMode;

    DBG3 (( MF__, "opt_obj_owner = \"%s\"",
            _PToC ( prcArgsOptions -> components.
                                      dcomp_util.
                                      opt_object_owner )));
    DBG3 (( MF__, "opt_obj_name1 = \"%s\"",
            _PToC ( prcArgsOptions -> components.
                                      dcomp_util.
                                      opt_object_name1 )));
    DBG3 (( MF__, "opt_obj_name2 = \"%s\"",
            _PToC ( prcArgsOptions -> components.
                                      dcomp_util.
                                      opt_object_name2 )));
    DBG3 (( MF__, "opt_comm_mode = %d",
            prcArgsOptions -> components.
                              dcomp_util.opt_comm_mode ));

    DBGOUT;
    return;
}


/*------------------------------*/


static VOID MakeDialogComponentCodeType
            (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakeDialogComponentCodeType"


    DBGIN;

    // get code type
    if ( !strcmp ( sql80_OptArg, "asc" ))
        prcArgsOptions ->
        components.dcomp_util.opt_code = is_ascii;

    if ( !strcmp ( sql80_OptArg, "ebc" ))
        prcArgsOptions ->
        components.dcomp_util.opt_code = is_ebcdic;

    DBG3 (( MF__, "opt_code = %d",
            prcArgsOptions -> components.
                              dcomp_util.opt_code ));

    DBGOUT;
}


/*------------------------------*/


static VOID MakeDialogComponentExport ( tsp4_args_options  *prcArgsOptions )
{
    #undef  MF__
    #define MF__ MOD__"MakeDialogComponentExport"


    BOOLEAN         bFNameFound;
    INT             nArgLen;
    INT             nLength1, nLength2;
    PSZ             pszStartAddr ;
    PSZ             pszCommaAddr ;


    DBGIN;

    // get object name1 :
    // determinate comma position, the start position of sql80_OptArg and the object
    // name1 string length

    bFNameFound  = TRUE;
    nArgLen      = strlen ( sql80_OptArg );
    pszCommaAddr = strchr ( sql80_OptArg, ',' );
    pszStartAddr = sql80_OptArg;
    nLength2     = pszCommaAddr  - pszStartAddr ;
    nLength1     = sizeof ( prcArgsOptions -> components.
                                             dcomp_util.
                                             opt_object_name1 );

    // check length
    if ( !pszCommaAddr  ) {
        bFNameFound = FALSE;
        nLength2    = nArgLen;
    }

    if ( nLength2 > nLength1 )
        nLength2 = nLength1;

    // copy without '\0'
    memcpy ( prcArgsOptions -> components.
                               dcomp_util.
                               opt_object_name1,
             sql80_OptArg, nLength2 );

    // get runfile if ',' was found
    if ( bFNameFound ) {
        // get the beginning of runfile and the length of runfile field,
        // determinate length of runfile
        pszCommaAddr ++;
        nLength1 = sizeof ( prcArgsOptions -> components.
                                              dcomp_util.
                                              opt_runfile );

        nLength2 = pszStartAddr  + nArgLen - pszCommaAddr ;

        // check length
        if ( nLength2 > nLength1 )
            nLength2 = nLength1;

        // copy without '\0'
        memcpy ( prcArgsOptions -> components.
                                   dcomp_util.
                                   opt_runfile,
                 pszCommaAddr , nLength2 );
    }

    // get command mode
    prcArgsOptions ->
    components.dcomp_util.opt_comm_mode = SP4CM_SQL_EXPORT;

    DBG3 (( MF__, "opt_obj_name1 = \"%s\"",
            _PToC ( prcArgsOptions -> components.
                                      dcomp_util.
                                      opt_object_name1 )));
    DBG3 (( MF__, "opt_runfile = \"%s\"",
            _PToC ( prcArgsOptions -> components.
                                      dcomp_util.
                                      opt_runfile )));
    DBG3 (( MF__, "opt_comm_mode = %d",
            prcArgsOptions -> components.
                              dcomp_util.opt_comm_mode ));

    DBGOUT;
}


/*------------------------------*/


static VOID MakeDialogComponentImport ( tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakeDialogComponentImport"


    INT nArgLen;
    INT nLength;


    DBGIN;

    // get runfile
    nArgLen = strlen ( sql80_OptArg );
    nLength = sizeof ( prcArgsOptions -> components.
                                         dcomp_util.
                                         opt_runfile );

    if ( nArgLen > nLength )
        nArgLen = nLength;

    memcpy ( prcArgsOptions -> components.
                               dcomp_util.
                               opt_runfile,
             sql80_OptArg, nArgLen );

    // get command mode
    prcArgsOptions -> components.
                      dcomp_util.opt_comm_mode = SP4CM_SQL_IMPORT;

    DBG3 (( MF__, "opt_comm_mode = %d",
            prcArgsOptions -> components.
                              dcomp_util.opt_comm_mode ));

    DBG3 (( MF__, "opt_runfile = \"%s\"",
            _PToC ( prcArgsOptions -> components.
                                      dcomp_util.
                                      opt_parameter )));

    DBGOUT;
}


/*------------------------------*/


static VOID MakeAuditCntrl  (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakeAuditCntrl"


    INT nArgLen;
    INT nLength;


    DBGIN;

    // get audit control
    nArgLen = strlen ( sql80_OptArg );
    nLength = sizeof ( prcArgsOptions ->
                       components.aud.opt_aud_control );

    if ( nArgLen > nLength )
        nArgLen = nLength;

    memcpy ( prcArgsOptions -> components.aud.opt_aud_control,
             sql80_OptArg, nArgLen );

    DBG3 (( MF__, "opt_aud_control = \"%s\"",
            _PToC ( prcArgsOptions -> components.aud.opt_aud_control )));

    DBGOUT;
}


/*------------------------------*/


static VOID MakeAuditLogfile    (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakeAuditLogfile"


    INT nArgLen;
    INT nLength;


    DBGIN;

    // get logfile
    nArgLen = strlen ( sql80_OptArg );
    nLength = sizeof ( prcArgsOptions -> components.aud.opt_aud_logfile );

    if ( nArgLen > nLength )
        nArgLen = nLength;

    memcpy ( prcArgsOptions -> components.aud.opt_aud_logfile,
             sql80_OptArg, nArgLen );

    DBG3 (( MF__, "opt_aud_logfile = \"%s\"",
            _PToC ( prcArgsOptions -> components.aud.opt_aud_logfile )));

    DBGOUT;
}

/*------------------------------*/

static VOID MakeAuditLogBlockSize (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakeAuditLogBlockSize"

    BOOLEAN bNoAlphaFound;
    INT     nArgLength;
    INT     nIndex;


    DBGIN;

    // get blocksize for audit logfile, check the digits 0 through 9
    nArgLength    = strlen ( sql80_OptArg );
    bNoAlphaFound = TRUE;

    for ( nIndex = 0; nIndex < nArgLength; nIndex++ ) {
        if ( isalpha ( sql80_OptArg [ nIndex ] )) {
            bNoAlphaFound = FALSE;

            break;
        }
    }

    if ( bNoAlphaFound )
      prcArgsOptions -> components.aud.opt_aud_log_blocksize = 
                        atoi ( sql80_OptArg ) ;

    DBG3 (( MF__, "opt_aud_log_blocksize = \"%d\"",
             prcArgsOptions -> components.aud.opt_aud_log_blocksize ));

    DBGOUT;
}


/*------------------------------*/


static VOID MakeAuditOutput (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakeAuditOutput"


    INT nArgLen;
    INT nLength;


    DBGIN;

    // get audit output
    nArgLen = strlen ( sql80_OptArg );
    nLength = sizeof ( prcArgsOptions ->
                       components.aud.opt_aud_output );

    if ( nArgLen > nLength )
        nArgLen = nLength;

    memcpy ( prcArgsOptions ->
           components.aud.opt_aud_output, sql80_OptArg, nArgLen );

    DBG3 (( MF__, "opt_aud_output = \"%s\"",
            _PToC ( prcArgsOptions -> components.aud.
                                      opt_aud_output )));

    DBGOUT;
}


/*------------------------------*/

static VOID MakeUserXComponentBFn  (   tsp4_args_options  *prcArgsOptions  )
{
    #undef  MF__
    #define MF__ MOD__"MakeUserXComponentBFn"


    INT nArgLength;
    INT nLength;


    DBGIN;

    // get runfile
    nArgLength = strlen ( sql80_OptArg );
    nLength    = sizeof ( prcArgsOptions -> components.ux.
                            opt_ux_runfile );

    if ( nArgLength > nLength )
        nArgLength = nLength;

    memcpy ( prcArgsOptions -> components.ux.opt_ux_runfile,
             sql80_OptArg, nArgLength );

    // get command mode
    prcArgsOptions -> components.ux.opt_ux_comm_mode = SP4CM_SQL_BATCH;

    DBG3 (( MF__, "opt_ux_runfile = \"%s\"",
            _PToC ( prcArgsOptions -> components.ux.opt_ux_runfile )));
    DBG3 (( MF__, "opt_comm_mode = %d",
            prcArgsOptions -> components.ux.opt_ux_comm_mode ));

    DBGOUT;
}

/*------------------------------*/


static VOID MakeUserPasswordLine (  PARG_LINE_REC   prcArgLine,
                                    PBOOLEAN        pbUserNameFound,
                                    PBOOLEAN        pbPasswordFound     )
{
    #undef  MF__
    #define MF__ MOD__"MakeUserPasswordLine"


    INT nSeparatorIndex;
    INT nNull;


    DBGIN;

    // initialize internel vars
    *pbUserNameFound = TRUE;
    *pbPasswordFound = TRUE;

    memset (( PCHAR ) prcArgLine -> username, ' ',
            sizeof ( prcArgLine -> username ));
    memset (( PCHAR ) prcArgLine -> password, ' ',
            sizeof ( prcArgLine -> password ));

    nSeparatorIndex = 0;
    nNull           = 0;

    // get user name
    MakeLine ( sql80_OptArg, &nSeparatorIndex, sizeof ( prcArgLine -> username ),
               ',', &nNull, prcArgLine -> username );

    DBG3 (( MF__, "prcArgLine -> username = \"%s\"",
            _PToC ( prcArgLine -> username )));

    // get password if ',' was found
    if ( sql80_OptArg [ nSeparatorIndex ] == ',' ) {
        nNull = 0;
        nSeparatorIndex++;

        MakeLine ( sql80_OptArg, &nSeparatorIndex, nSeparatorIndex +
                 ( INT ) sizeof ( prcArgLine -> password ),
                   ' ', &nNull, prcArgLine -> password );

        DBG3 (( MF__, "prcArgLine -> password = \"%s\"",
                _PToC ( prcArgLine -> password )));
    }
    else {
        // get password, but first look for ','
        nSeparatorIndex = StrChr  ( sql80_OptArg, ',',
                                    nSeparatorIndex, MAXARGLINELENGTH );

        DBG3 (( MF__, "nSeparatorIndex = %d", nSeparatorIndex ));

        if ( nSeparatorIndex != 0 ) {
            nNull = 0;
            nSeparatorIndex++;
            MakeLine ( sql80_OptArg, &nSeparatorIndex,
                     ( INT ) sizeof ( prcArgLine -> password ) +
                       nSeparatorIndex, ' ', &nNull,
                       prcArgLine -> password );

            DBG3 (( MF__, "prcArgLine -> password = \"%s\"",
                    _PToC ( prcArgLine -> password )));
        }
    }

    DBGOUT;
}


/*------------------------------*/


static VOID MakeDBName  (   PCHAR*          apszArgv,
                            PARG_LINE_REC   prcArgLine,
                            PBOOLEAN        pbDBNameFound   )
{
    #undef  MF__
    #define MF__ MOD__"MakeDBName"


    INT     nNull;
    PSZ     pszBegin;
    PSZ     pszTmp1;
    PSZ     pszTmp2;
    CHAR    acDBNameString [ MX_DBNAME + 1 ];


    DBGIN;

    // initialize vars
    *pbDBNameFound = TRUE;
    nNull = 0;

    memset (( PCHAR ) prcArgLine -> dbname, ' ', sizeof ( prcArgLine -> dbname ));
    memset (( PCHAR ) acDBNameString, ' ', sizeof ( acDBNameString ));

    // get the program name because only utility needs
    // the dbname quoted in "'" ( 'dbname' )
    pszTmp1  = strrchr ( apszArgv [ 0 ], '\\' );
    pszTmp2  = strrchr ( apszArgv [ 0 ], '/' );

    pszBegin = max( pszTmp1, pszTmp2 );

    if ( pszBegin == NULL )
        pszBegin = apszArgv [ 0 ];
    else
        pszBegin++;

    DBG3 (( MF__, "pszBegin = 0x%x", pszBegin ));

    if ( !strcmp ( pszBegin, "utility" )) {
        strcpy  ( acDBNameString, "'" );
        strncat ( acDBNameString, sql80_OptArg, sizeof ( acDBNameString ) - 3 );
        strcat  ( acDBNameString, "'" );

        DBG3 (( MF__, "utility was called" ));
    }
    else {
        strncpy ( acDBNameString, sql80_OptArg, sizeof ( acDBNameString ) - 1 );
        acDBNameString [ sizeof ( acDBNameString ) - 1 ] = 0;

        DBG3 (( MF__, "utility was not called" ));
    }

    DBG3 (( MF__, "acDBNameString = \"%s\"", _PToC (acDBNameString )));

    // get data base name
    MakeLine ( acDBNameString, &nNull, sizeof ( prcArgLine -> dbname ), ' ',
               &nNull, prcArgLine -> dbname );

    MoveToUpper ( prcArgLine -> dbname, sizeof ( prcArgLine -> dbname ));

    DBG3 (( MF__, "prcArgLine -> dbname = \"%s\"",
            _PToC ( prcArgLine -> dbname )));

    DBGOUT;
}


/*------------------------------*/


static VOID MakeCmd (   PCHAR           pszCmdType,
                        PARG_LINE_REC   prcArgLine,
                        PBOOLEAN        pbCmdFound,
                        PBOOLEAN        pbFileNameFound     )
{
    #undef  MF__
    #define MF__ MOD__"MakeCmd"


    INT nNull;


    DBGIN;

    DBG3 (( MF__, "pszCmdType = \"%s\"", pszCmdType ));

    // initialize internel vars
    memset (( PCHAR ) prcArgLine -> cmd, ' ', sizeof ( prcArgLine -> cmd ));
    memset (( PCHAR ) prcArgLine -> filename, ' ', sizeof ( prcArgLine -> filename ));

    nNull            = 0;
    *pbCmdFound      = TRUE;
    *pbFileNameFound = TRUE;

    // get command
    MakeLine ( pszCmdType, &nNull, sizeof ( prcArgLine -> cmd ), ' ',
               &nNull, prcArgLine -> cmd );

    DBG3 (( MF__, "prcArgLine -> cmd = \"%s\"",
            _PToC ( prcArgLine -> cmd )));

    // get file name
    nNull = 0;
    MakeLine ( sql80_OptArg, &nNull, sizeof ( prcArgLine -> filename ), ' ',
               &nNull, prcArgLine -> filename );

    DBG3 (( MF__, "prcArgLine -> filename = \"%s\"",
            _PToC ( prcArgLine -> filename )));

    DBGOUT;
}


/*------------------------------*/


static VOID MakeArgLine (   INT             nArgc,
                            PCHAR*          apszArgv,
                            PARG_LINE_REC   prcArgLine,
                            PBOOLEAN        pbArgumentsFound,
                            PBOOLEAN        pbCmdFound,
                            PBOOLEAN        pbFileNameFound,
                            INT             nOptionChar         )
{
    #undef  MF__
    #define MF__ MOD__"MakeArgLine"


    INT     nTestChar0;
    INT     nTestChar1;
    INT     nArgumentNo;
    INT     nOutIndex;
    INT     nSize;
    INT     nTmpSize;
    INT     nNull;
    PCHAR   pszCmdType;


    DBGIN;

    if ( nOptionChar == '?' ) {
        // look for option names - if found take over
        DBG3 (( MF__, "sql80_OptInd  ( nOptionChar == '?' ) = %d", sql80_OptInd ));

        nTestChar0 = apszArgv [ sql80_OptInd - 1 ] [ 0 ];
        nTestChar1 = apszArgv [ sql80_OptInd - 1 ] [ 1 ];

        DBG3 (( MF__, "argv [ sql80_OptInd - 1 ] = \"%s\"", apszArgv [ sql80_OptInd - 1 ] ));
        DBG3 (( MF__, "nTestChar0          = %c", nTestChar0 ));
        DBG3 (( MF__, "nTestChar1          = %c", nTestChar1 ));


        if (( nTestChar0 == '-' || nTestChar0 == '/' ) &&
            ( nTestChar1 == 'r' || nTestChar1 == 'b' )) {
            *pbCmdFound = TRUE;

            memset (( PCHAR ) prcArgLine -> cmd, ' ',
                    sizeof ( prcArgLine -> cmd ));

            switch ( nTestChar1 ) {
                case 'r' :
                    pszCmdType = "run";
                break;

                case 'b' :
                    pszCmdType = "batch";
                break;
            }

            // get command
            nNull = 0;
            MakeLine ( pszCmdType, &nNull, sizeof ( prcArgLine -> cmd ),
                       ' ', &nNull, prcArgLine -> cmd );

            DBG3 (( MF__, "prcArgLine -> cmd = \"%s\"",
                    _PToC ( prcArgLine -> cmd )));

            // 'STDIN' becomes filename
            *pbFileNameFound = TRUE;
            memset (( PCHAR ) prcArgLine -> filename, ' ',
                    sizeof ( prcArgLine -> filename ));
            nNull = 0;
            MakeLine ( "STDIN", &nNull, sizeof ( prcArgLine -> filename ),
                       ' ', &nNull, prcArgLine -> filename );

            DBG3 (( MF__, "prcArgLine -> filename = \"%s\"",
                    _PToC ( prcArgLine -> filename )));
        }
        else {
            // no regular option, reduce sql80_OptInd but be sure to do this only
            // you have found an '-?' expression
            // ? : means only one character
            if ( sql80_OptInd > 1                              &&
                 strlen ( apszArgv [ sql80_OptInd - 1 ] ) == 2 &&
                 ( nTestChar0 == '-' ||  nTestChar0 == '/' )) {

                sql80_OptInd--;
            }
        }
    }

    // take over args into arg line
    DBG3 (( MF__, "sql80_OptInd = %d", sql80_OptInd ));
    nOutIndex = -1;
    nSize = sizeof ( prcArgLine -> arguments );
    nTmpSize = sizeof ( prcArgLine -> arguments );
    *pbArgumentsFound = TRUE;
    memset (( PCHAR ) prcArgLine -> arguments, ' ',
            sizeof ( prcArgLine -> arguments ));

    for ( nArgumentNo = sql80_OptInd; nArgumentNo < nArgc; nArgumentNo++ ) {
        nNull = 0;
        nOutIndex++;
        MakeLine ( apszArgv [ nArgumentNo ], &nNull, nTmpSize, ' ',
                   &nOutIndex, prcArgLine -> arguments );
        nTmpSize = nSize - nOutIndex + 1;
    }

    DBG3 (( MF__, "prcArgLine -> arguments = \"%s\"",
            _PToC ( prcArgLine -> arguments )));

    DBGOUT;
}


/*------------------------------*/


static VOID MakeLine    (   PCHAR   pszArgIn,
                            PINT    pnArgInIndex,
                            INT     nLineLength,
                            INT     nSeparator,
                            PINT    pnArgOutIndex,
                            PCHAR   pszArgOut       )
{
    #undef  MF__
    #define MF__ MOD__"MakeLine"


    INT nArgLength;
    INT nInIndex;
    INT nOutIndex;


    DBGIN;

    DBG3 (( MF__, "pszArgIn       = \"%s\"",   pszArgIn      ));
    DBG3 (( MF__, "*pnArgInIndex  = %d",  *pnArgInIndex  ));
    DBG3 (( MF__, "nLineLength    = %d",   nLineLength   ));
    DBG3 (( MF__, "nSeparator     = '%c'", nSeparator    ));
    DBG3 (( MF__, "*pnArgOutIndex = %d",  *pnArgOutIndex ));

    // take all the elements you have got and make a line
    // how long is the next element?
    nArgLength = strlen ( pszArgIn );

    DBG3 (( MF__, "nArgLength = %d", nArgLength ));

    // put one element into the line
    for ( nInIndex = *pnArgInIndex, nOutIndex = *pnArgOutIndex;
          nInIndex < nArgLength && nInIndex < nLineLength &&
          pszArgIn [ nInIndex ] != nSeparator;
          nOutIndex++, nInIndex++ ) {

        pszArgOut [ nOutIndex ] = pszArgIn [ nInIndex ];
    }

    *pnArgOutIndex = nOutIndex;
    *pnArgInIndex  = nInIndex;

    DBG3 (( MF__, "*pnArgInIndex  = %d", *pnArgInIndex ))
    DBG3 (( MF__, "*pnArgOutIndex = %d", *pnArgOutIndex ))
    DBG3 (( MF__, "pszArgOut      = \"%s\"",  pszArgOut ));

    DBGOUT;
}


/*------------------------------*/


static VOID BuildArgLineFromStruct  (   PCHAR           psArgs,
                                        PARG_LINE_REC   prcArgLine,
                                        BOOLEAN         bUserNameFound,
                                        BOOLEAN         bPasswordFound,
                                        BOOLEAN         bDBNameFound,
                                        BOOLEAN         bCmdFound,
                                        BOOLEAN         bFileNameFound,
                                        BOOLEAN         bArgumentsFound     )
{
    #undef  MF__
    #define MF__ MOD__"BuildArgLineFromStruct"


    INT nArgIndex;
    INT nArgCount1;
    INT nArgCount2;
    INT nArgCount3;
    INT nIndex;


    DBGIN;

    DBG3 (( MF__, "prcArgLine -> username  = \"%s\"",
            _PToC ( prcArgLine -> username )));
    DBG3 (( MF__, "prcArgLine -> password  = \"%s\"",
            _PToC ( prcArgLine -> password )));
    DBG3 (( MF__, "prcArgLine -> dbname    = \"%s\"",
            _PToC ( prcArgLine -> dbname )));
    DBG3 (( MF__, "prcArgLine -> cmd       = \"%s\"",
            _PToC ( prcArgLine -> cmd )));
    DBG3 (( MF__, "prcArgLine -> filename  = \"%s\"",
            _PToC ( prcArgLine -> filename )));
    DBG3 (( MF__, "prcArgLine -> arguments = \"%s\"",
            _PToC ( prcArgLine -> arguments )));

    // initialize local vars
    nArgIndex  = 0;
    nArgCount1 = 0;
    nArgCount2 = 0;
    nArgCount3 = 0;

    // build up user-passwd-dbname string
    nArgCount1 = StrLen ( prcArgLine -> username,
                          sizeof ( prcArgLine -> username ));
    nArgCount2 = StrLen ( prcArgLine -> password,
                          sizeof ( prcArgLine -> username ));
    nArgCount3 = StrLen ( prcArgLine -> dbname,
                          sizeof ( prcArgLine -> username ));

    if (( bUserNameFound && nArgCount1 > 0 ) ||
        ( bPasswordFound && nArgCount2 > 0 ) ||
        ( bDBNameFound   && nArgCount3 > 0 )) {

        psArgs [ nArgIndex ] = '(';
        nArgIndex++;

        for ( nIndex = 0;
              nIndex < nArgCount1 && nArgIndex < MAXARGLINELENGTH;
              nIndex++, nArgIndex++ ) {

            psArgs [ nArgIndex ] = prcArgLine -> username [ nIndex ];
        }

        psArgs [ nArgIndex ] = ',';
        nArgIndex++;

        DBG3 (( MF__, "nArgIndex = %d", nArgIndex ));

        for ( nIndex = 0;
              nIndex < nArgCount2 && nArgIndex < MAXARGLINELENGTH;
              nIndex++, nArgIndex++ ) {

            psArgs [ nArgIndex ] = prcArgLine -> password [ nIndex ];
        }

        psArgs [ nArgIndex ] = ',';
        nArgIndex++;

        DBG3 (( MF__, "nArgIndex = %d", nArgIndex ));

        for ( nIndex = 0;
              nIndex < nArgCount3 && nArgIndex < MAXARGLINELENGTH;
              nIndex++, nArgIndex++ ) {

            psArgs [ nArgIndex ] = prcArgLine -> dbname [ nIndex ];
        }

        psArgs [ nArgIndex ] = ')';
        nArgIndex++;

        DBG3 (( MF__, "nArgIndex = %d", nArgIndex ));
    }

    // build up command string
    nArgCount1 = StrLen ( prcArgLine -> cmd,
                          sizeof ( prcArgLine -> cmd ));

    if ( bCmdFound && nArgCount1 > 0 ) {
        if ( nArgIndex > 0 ) {
            DBG3 (( MF__, "nArgIndex = %d", nArgIndex ));

            psArgs [ nArgIndex ] = ' ';
            nArgIndex++;
        }

        for ( nIndex = 0;
              nIndex < nArgCount1 && nArgIndex < MAXARGLINELENGTH;
              nIndex++, nArgIndex++ ) {

            psArgs [ nArgIndex ] = prcArgLine -> cmd [ nIndex ];
        }

        DBG3 (( MF__, "nArgIndex = %d", nArgIndex ));
    }

    // build up filename string
    nArgCount1 = StrLen ( prcArgLine -> filename,
                          sizeof ( prcArgLine -> filename ));

    if ( bFileNameFound && nArgCount1 > 0 ) {
        if ( nArgIndex > 0 ) {
            DBG3 (( MF__, "nArgIndex = %d", nArgIndex ));

            psArgs [ nArgIndex ] = ' ';
            nArgIndex++;
        }

        psArgs [ nArgIndex ] = '\'';
        nArgIndex++;

        for ( nIndex = 0;
              nIndex < nArgCount1 && nArgIndex < MAXARGLINELENGTH;
              nIndex++, nArgIndex++ ) {

            psArgs [ nArgIndex ] = prcArgLine -> filename [ nIndex ];
        }

        psArgs [ nArgIndex ] = '\'';
        nArgIndex++;

        DBG3 (( MF__, "nArgIndex = %d", nArgIndex ));
    }

    // build up argument string
    nArgCount1 = StrLen ( prcArgLine -> arguments,
                          sizeof ( prcArgLine -> arguments ));

    if ( bArgumentsFound && nArgCount1 > 0 ) {
        if ( nArgIndex > 0 ) {
            DBG3 (( MF__, "nArgIndex = %d", nArgIndex ));

            psArgs [ nArgIndex ] = ' ';
            nArgIndex ++;
        }

        for ( nIndex = 0;
              nIndex < nArgCount1 && nArgIndex < MAXARGLINELENGTH;
              nIndex++, nArgIndex ++ ) {

            psArgs [ nArgIndex ] = prcArgLine -> arguments [ nIndex ];
        }

        DBG3 (( MF__, "nArgIndex = %d", nArgIndex ));
    }

    DBGOUT;
}


/*------------------------------*/


static VOID MoveToUpper (   PCHAR   psString,
                            INT     nStringSize     )
{
    #undef  MF__
    #define MF__ MOD__"MoveToUpper"


    INT nIndex;


    DBGIN;

    // convert to upper
    for ( nIndex = 0; nIndex < nStringSize; nIndex++ )
        psString [ nIndex ] = toupper ( psString [ nIndex ] ) ;

    DBGOUT;
}


/*------------------------------*/


static VOID CheckIdents ( PCTU_REC  pCtU,
                          CHAR      cSep,
                          LONG      lMaxIdent,
                          PBOOLEAN  pbOk,
                          ERRORTEXT acErrorText )
{
    #undef  MF__
    #define MF__ MOD__"CheckIdents"
    LONG                    lCnt;
    ULONG                   ulLenArg;
    PSZ                     pszSepAddr;
    PSZ                     pszStart;
    PSZ                     pszEnd;
    BOOL                    bSepFound      = FALSE;
    LONG                    lQuoteCounter  = 0;
    PSZ                     pszTmp         = NULL;
    PSZ                     pszFirstQuote  = NULL;
    PSZ                     pszSecondQuote = NULL;

    DBGIN;

    *pbOk = TRUE;
    memset ( pCtU, 0, sizeof (CTU_REC));

    ulLenArg   = strlen ( sql80_OptArg );
    pszStart   = sql80_OptArg;
    pszEnd     = pszStart + ulLenArg ;   // --- including "\0"

    DBG3 (( MF__, "pszStart         ( 1 ) = %x", pszStart ));
    DBG3 (( MF__, "pszEnd                 = %x", pszEnd   ));
    DBG3 (( MF__, "ulLenArg               = %d", ulLenArg ));

    pszTmp =  pszStart;

    do {
        pszTmp = strchr ( pszTmp, '\'' );

        if ( pszTmp ) {
            lQuoteCounter ++;
            pszTmp ++;
            }

    } while ( pszTmp );


    if ( lQuoteCounter % 2 ) {
        *pbOk = FALSE;
        sql46c_build_error_string ( acErrorText, ERRMSG_MISSING_QUOTE, 0 );
        DBG3 (( MF__, "lQuoteCounter = %d", lQuoteCounter ));
        DBGOUT;
        return;
    }

    // --- initialize internel parameters again
    pszFirstQuote  = NULL;
    pszSecondQuote = NULL;

    // --- check every part of the argument string
    for ( lCnt = 0;  pszStart != pszEnd ; lCnt ++ ) {

        DBG3 (( MF__, "pszStart ( 2 ) = %x", pszStart ))
        DBG3 (( MF__, "lCnt           = %d", lCnt   ))

        if ( lCnt >= lMaxIdent )  {
            *pbOk = FALSE;
            sql46c_build_error_string ( acErrorText, ERRMSG_ILLEGAL_ARGUMENT,
                                        0 );
            DBGOUT;
            return;
        }

        // --- first sign of the argumnet part == seperator
        //     skip to the next part
        if ( strchr ( pszStart, cSep ) == pszStart ) {
            pszStart ++;
            if ( bSepFound ) {
                *pbOk = FALSE;
                sql46c_build_error_string ( acErrorText,
                                            ERRMSG_DOUBLE_SEPERATOR, 0 );
                DBGOUT;
                return;
            }
            bSepFound = TRUE;
            DBG3 (( MF__, "pszStart ( seperator found ) = %x", pszStart ));
            continue;
        }

        // --- reset bSepFound flag
        bSepFound = FALSE;

        // --- point to '\''
        pszFirstQuote  = strchr ( pszStart, '\'' );

        DBG3 (( MF__, "pszFirstQuote ( 1 ) = %x", pszFirstQuote ));

        // --- be sure you are at the beginning of the part
        if ( pszFirstQuote != pszStart ) pszFirstQuote = NULL;

        if ( pszFirstQuote ) {
            pszSecondQuote = strchr ( pszFirstQuote + 1, '\'');
            DBG3 (( MF__, "pszSecondQuote  = %x", pszSecondQuote  ));
        }


        // --- quote count correct?
        if ( ( pszFirstQuote ) && ( ! pszSecondQuote ) ) {
            *pbOk = FALSE;
            sql46c_build_error_string ( acErrorText,
                                        ERRMSG_MISSING_QUOTE, 0 );
            DBGOUT;
            return;
        }
        //
        // --- get string
        //
        if ( pszFirstQuote ) {
            pCtU->pszIdent      [ lCnt ] = pszFirstQuote + 1;
            pCtU->lIdentLen     [ lCnt ] = pszSecondQuote - pszFirstQuote - 1;
            pCtU->bIdentToUpper [ lCnt ] = FALSE;

            DBG3 (( MF__, "pCtU->pszIdent [ lCnt ] ( quoted )      = %x",
                    pCtU->pszIdent [ lCnt ] ))
            DBG3 (( MF__, "pCtU->lIdentLen [ lCnt ] ( quoted )     = %d",
                    pCtU->lIdentLen [ lCnt ] ))
            DBG3 (( MF__, "pCtU->bIdentToUpper [ lCnt ] ( quoted ) = %f",
                    pCtU->bIdentToUpper [ lCnt ] ))


            // ---- find seperator
            if ( ( pszSepAddr = strchr ( pszSecondQuote, cSep ) ) != NULL ) {
                bSepFound = TRUE;
                DBG3 (( MF__, "pszSepAddr ( found, quoted str ) = %x", pszSepAddr ))
            }
            else {
                // --- seperator not found
                bSepFound    = FALSE;
                pszSepAddr   = pszEnd;
                DBG3 (( MF__, "pszSepAddr (not found, quoted str) = %x", pszSepAddr ))

                // --- check error conditions
                if ( pszEnd > ( pszSecondQuote + 1 ) ) {
                    *pbOk = FALSE;
                    sql46c_build_error_string ( acErrorText,
                                                ERRMSG_ILLEGAL_ARGUMENT, 0 );
                    DBGOUT;
                    return;
                }
            }
        }
        else {
            // --- find seperator
            if ( ( pszSepAddr = strchr ( pszStart, cSep ) ) != NULL ) {

                bSepFound = TRUE;
                DBG3 (( MF__, "pszSepAddr ( found, not quoted ) = %x", pszSepAddr ))
            }
            else {
                // --- seperator not found
                bSepFound    = FALSE;
                pszSepAddr   = pszEnd;
                DBG3 (( MF__, "pszSepAddr (not found, not quoted) = %x", pszSepAddr ))
            }


            pCtU->pszIdent      [ lCnt ] = pszStart;
            pCtU->lIdentLen     [ lCnt ] = pszSepAddr - pszStart;
            pCtU->bIdentToUpper [ lCnt ] = TRUE;

            DBG3 (( MF__, "pCtU->pszIdent [ lCnt ] ( not quoted )      = %x",
                    pCtU->pszIdent [ lCnt ] ))
            DBG3 (( MF__, "pCtU->lIdentLen [ lCnt ] ( not quoted )     = %d",
                    pCtU->lIdentLen [ lCnt ] ))
            DBG3 (( MF__, "pCtU->bIdentToUpper [ lCnt ] ( not quoted ) = %f",
                    pCtU->bIdentToUpper [ lCnt ] ))
        }

        pszStart = pszSepAddr;
        if ( pszStart != pszEnd ) pszStart ++;
    }

    DBGOUT;
    return;
}

/*------------------------------*/

static int StrLen ( CHAR*   psStr,
                    INT     nLength )
{
    #undef  MF__
    #define MF__ MOD__"StrLen"


    int nIndex;


    DBGIN;

    DBG3 (( MF__, "psStr   = %s", _PToC( psStr) ));
    DBG3 (( MF__, "nLength = %d", nLength ));

    // this function looks for the end of strings which do not ends with \0
    for ( nIndex = nLength - 1; nIndex >= 0; nIndex-- ) {
        if ( psStr [ nIndex ] != ' ' && psStr [ nIndex ] != '\0' )
            break;
    }

    DBG3 (( MF__, "nIndex + 1 = %d", nIndex + 1 ));

    DBGOUT;

    return nIndex + 1;
}


// ----------------------------------------------------------------------------


static INT StrChr   ( CHAR*   pszStr,
                      INT     nCharacter,
                      INT     nBegin,
                      INT     nEnd )
{
    #undef  MF__
    #define MF__ MOD__"StrChr"


    int nIndex;


    DBGIN;

    DBG3 (( MF__, "pszStr     = %s", pszStr     ));
    DBG3 (( MF__, "nCharacter = %c", nCharacter ));
    DBG3 (( MF__, "nBegin     = %d", nBegin     ));
    DBG3 (( MF__, "nEnd       = %d", nEnd       ));

    // StrChr returns the position of the first occurrence in string pszStr
    // of character c
    for ( nIndex = nBegin;
          (nIndex < nEnd) && (pszStr [ nIndex ] != '\0');
          nIndex ++ ) {
        if ( pszStr [ nIndex ] == nCharacter )
            break;
    }

    if ( pszStr [ nIndex ] != nCharacter )
        nIndex = 0;

    DBG3 (( MF__, "nIndex = %d", nIndex ));

    DBGOUT;

    return nIndex;
}

//
// =============================== END ========================================
//
.CM *-END-* code ----------------------------------------
.SP 2
***********************************************************
.PA
