<HTML>
<HEAD>
  <TITLE>expatc</TITLE>
</HEAD>
<BODY>
<H1>
  expatc: Compile DTD to expat
</H1>
<P>
  <HR>
<H3>
  Schema properties
</H3>
<DL>
  <DT>
    &lt;!-- P: <B>defaultproperty</B>.element.&lt;property
    name&gt;=&lt;property value&gt; --&gt;
  <DD>
    This is similar to specifying <BR>
    &lt;!-- P: &lt;element name&gt;.&lt;property name&gt;=&lt;property value&gt;
    --&gt;<BR>
    for every element. <BR>
  <DT>
    &lt;!-- P: <B>defaultproperty</B>.attribute.&lt;property
    name&gt;=&lt;property value&gt; --&gt;
  <DD>
    This is similar to specifying <BR>
    &lt;!-- P: &lt;element name&gt;.&lt;attribute name&gt;.&lt;property
    name&gt;=&lt;property value&gt; --&gt;<BR>
    for every attribute<BR>
  <DT>
    &lt;!-- P:
    <A NAME="parseconversion"><B>parseconversion</B></A>.&lt;data
    type&gt;=&lt;function name&gt; --&gt;
  <DD>
    the generated code will contain a call to &lt;function name&gt; to convert
    from char&nbsp;* to &lt;data type&gt;. If &lt;function name&gt; contains
    %s, then %s will be replaced with the attribute value.<BR>
  <DT>
    &lt;!-- P: <B>allocator</B>=&lt;expr&gt; --&gt;
  <DD>
    storage for objects will be allocated from &lt;expr&gt;<BR>
    Example: &lt;!-- allocator=this-&gt;getAllocator () --&gt; where this is
    the parser class.<BR>
  <DT>
    &lt;!-- P: <A NAME="customcode"><B>customcode</B></A>.&lt;snippet
    name&gt;=&lt;statement&gt; --&gt;
  <DD>
    There exists several hooks where a code snippet can be inserted by the code
    generator. By using customcode, the same snippet can be referenced from several
    places.<BR>
  <DT>
    &lt;!-- P:
    <B><A NAME="attributealias">attributealias</A></B>.&lt;attribute
    name&gt;=&lt;expression&gt; --&gt;
  <DD>
    For every attribute with name &lt;attribute name&gt;, the value is not taken
    from the XML document. Instead, &lt;expression&gt; is generated by the parser.
    (This is like a dynamic #FIXED attribute.)<BR>
  <DT>
    &lt;!-- P: default.constructor.arguments=&lt;name list&gt; --&gt;
  <DD>
    &lt;name list&gt; is a comma separated list of identifiers. The first parameters
    of every element constructor are the
    <A HREF="#attributealias">attributealias</A> entries for these names.<BR>
    Example: <FONT COLOR="Green"><BR>
    &lt;!-- P: attributealias.xmlonly=XMLOnly () --&gt;<BR>
    &lt;!-- P: default.constructor.arguments=xmlonly --&gt;</FONT><BR>
    ==&gt; ... new Chapter (XML_Only (), ...)<BR>
  <DT>
    &lt;!-- P: <B>attributes</B>.&lt;attribute
    name&gt;.<B>datatype</B>=&lt;datatype&gt; --&gt;
  <DD>
    This declares the data type for every attribute named &lt;attribute
    name&gt;.<BR>
  <DT>
    &lt;!-- P: <B>parser.hpp.0</B>=&lt;filename&gt; --&gt;
  <DD>
    #include "&lt;filename&gt;" is added to the generated file. Multiple files
    can be specified with parser.hpp.1 etc.
</DL>
<H3>
  Element properties
</H3>
<DL>
  <DT>
    &lt;!-- P: &lt;element
    name&gt;.<B>realclassprefix</B>=&lt;prefix&gt; --&gt;
  <DD>
    the name of the object class is constructed as &lt;prefix&gt;&lt;element
    name&gt;<BR>
    Example: <FONT COLOR="Green">&lt;!-- P:
    Outline.realclassprefix=FOMTEST_--&gt;</FONT><BR>
  <DT>
    &lt;!-- P: &lt;element
    name&gt;.<B>handlerclassprefix</B>=&lt;prefix&gt; --&gt;
  <DD>
    the name of the handler class is constructed as
    &lt;prefix&gt;&lt;element name&gt;Handler<BR>
    Example: <FONT COLOR="Green">&lt;!-- P:
    Outline.handlerclassprefix=FOMTEST_--&gt;</FONT><BR>
  <DT>
    &lt;!-- P: &lt;element
    name&gt;.<B>includepattern</B>=&lt;pattern&gt; --&gt;
  <DD>
    inserts an #include directive into the generated file.<BR>
    Example: <FONT COLOR="Green">&lt;!-- P:
    Outline.includepattern=XML/FOMParser/Test/%s.hpp --&gt;</FONT><BR>
    ==&gt; #include "XML/FOMParser/Test/FOMTEST_Outline.hpp"<BR>
  <DT>
    &lt;!-- P: &lt;element name&gt;.&lt;sub element
    name&gt;.<B>setter</B>=&lt;setter&gt; --&gt;
  <DD>
    the name of the method to set the sub element (default set&lt;sub element
    name&gt;).<BR>
  <DT>
    &lt;!-- P: &lt;element name&gt;.<B>isString</B> --&gt;
    <UL>
      <LI>
	the tag may contain only character data
      <LI>
	no object of class &lt;element name&gt; is constructed
      <LI>
	a C++ string containing the character data is passed to containing lements
    </UL>
  <DD>
    Example: <BR>
    DTD: &lt;!-- P: Title.isString --&gt;<BR>
    DTD: &lt;!ELEMENT Title (PCDATA)&gt;<BR>
    C++: FOMTEST_Chapter::setTitle (const char &amp; data);<BR>
  <DT>
    &lt;!-- P: &lt;element name&gt;.<B>isGroup</B> --&gt;
  <DD>
    this is similar to declaring an abstract super class.<BR>
  <DT>
    &lt;!-- P: &lt;element name&gt;.<B>group</B>=&lt;super class&gt; --&gt;
  <DD>
    this declares &lt;element name&gt; as a sub class of &lt;super class&gt;.
    &lt;element name&gt; tags may appear whenever &lt;super class&gt; is referenced
    in the DTD.<BR>
  <DT>
    &lt;!-- P: &lt;element name&gt;.<B>postnew</B>=&lt;statement&gt; --&gt;
  <DD>
    &lt;statement&gt; is inserted after the call to the constructor. This is
    useful to insert the newly created object into additional containers.
    &lt;statement&gt; can be a C++ statement or a name for which a
    <A HREF="#customcode">customcode</A>-Property exists.<BR>
  <DT>
    &lt;!-- P: &lt;element name&gt;.postclose=&lt;statement&gt; --&gt;
  <DD>
    &lt;statement&gt; is inserted after the closing tag has been found.
    &lt;statement&gt; can be a C++ statement or a name for which a
    <A HREF="#customcode">customcode</A>-Property exists.
</DL>
<H3>
  Attribute properties
</H3>
<DL>
  <DT>
    &lt;!-- P: &lt;element name&gt;.&lt;attribute
    name&gt;.<B>setter</B>=&lt;setter&gt; --&gt;
  <DD>
    the name of the method to set the attribute (default set&lt;attribute
    name&gt;).<BR>
  <DT>
    &lt;!-- P: &lt;element name&gt;.&lt;attribute
    name&gt;.<B>datatype</B>=&lt;datatype&gt; --&gt;
  <DD>
    the C++ data type of the attribute (default char *). Attribute values are
    converted from char * to this data type. see
    <A HREF="#parseconversion">parseconversion</A><BR>
  <DT>
    &lt;!-- P: &lt;element name&gt;.&lt;attribute
    name&gt;.<B>constructorparameter</B>=&lt;bool&gt; --&gt;
  <DD>
    specifies whether the attribute is passed as part of the constructor (true)
    or with a separate call to the setter method (false). The default is false.<BR>
</DL>
<P>
  <HR>
<P>
2002-06-12 DanielD
<P>
</BODY></HTML>
