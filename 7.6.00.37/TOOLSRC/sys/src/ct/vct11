.CM *ID* VCT11    VDN      changed on 1992-11-23-16.57.44 by CARSTEN   *
.CM
.bm  6
.fm  3
.fs  1
.ad  5
.tm 10
.hm  4
.hs  3
.bt $Copyright by   Software AG, 1996$$Page %$
.tt 1 $SQL$Project Distributed Database System$VCT11$
.tt 2 $$$$
.tt 3 $C. Segieth$PRETTY$1996-12-10$
***********************************************************
.nf


    ========== licence begin LGPL
    Copyright (C) 2002 SAP AG

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    ========== licence end

.fo
.nf
.sp
Module  : PRETTY
=========
.sp
Purpose : Modules written in the module frame are structured
          with blanks in nested statements and lines between
          functions and procedures  to be read easier and to
          get one layout for all modules.
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROGRAM
              VCT11;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              String_utilities : VCT02;
 
        VAR
              c02outf         : tsp_int4;
              c02uplo        : integer;
 
        PROCEDURE
              c02init;
 
        PROCEDURE
              c02linelength_init (l : integer);
 
        PROCEDURE
              c02fncat (
                    VAR s      : tsp_vfilename;
                    VAR s1     : tsp_line;
                    VAR start1 : tsp_int4;
                    VAR s2     : tsp_name;
                    s60len2       : tsp_int4);
 
        FUNCTION
              c02getline (
                    infileno   : tsp_int4;
                    VAR ln     : tct_line) : tsp_vf_return;
 
        FUNCTION
              c02process_state_ok (
                    process    : tct_do;
                    errfileno  : tsp_int4) : boolean;
 
        FUNCTION
              c02strpos (
                    VAR ln     : tct_line;
                    nstr       : tsp_name) : tsp_int4;
 
        PROCEDURE
              c02vfwrite (
                    fno        : tsp_int4;
                    VAR buf    : tct_line);
 
        PROCEDURE
              c02int4to_line (
                    int        : tsp_int4;
                    with_zero  : boolean;
                    int_len    : integer;
                    ln_pos     : integer;
                    VAR ln     : tsp_line);
 
        PROCEDURE
              c02putname (
                    VAR ln     : tct_line;
                    pos        : integer;
                    nam        : tsp_name);
 
        PROCEDURE
              c02blankline (VAR ln : tct_line);
 
        FUNCTION
              c02chrpos (
                    VAR ln   : tct_line;
                    beg      : tsp_int4;
                    c        : char) : tsp_int2;
 
        PROCEDURE
              c02getword (
                    VAR ln   : tct_line;
                    VAR beg  : tsp_int2;
                    VAR word : tsp_name);
 
        FUNCTION
              c02equal_string (
                    VAR nam1 : tsp_name;
                    VAR nam2 : tsp_name) : boolean;
 
      ------------------------------ 
 
        FROM
              RTE_driver : VEN102;

&       if $OS = WIN32 
        VAR
              WinArgc : tsp_int4;
              __argc  : tsp_int4;
              WinArgv : tsp_moveobj_ptr;
              __argv  : tsp_moveobj_ptr;
&       endif

        PROCEDURE
              sqlargl (VAR args    : tsp_line);
 
        PROCEDURE
              sqlresult (result : tsp_int1);
 
        PROCEDURE
              sqldattime (
                    VAR d      : tsp_date;
                    VAR t      : tsp_time);
 
        PROCEDURE
              sqlfinish (terminate : boolean);
 
        PROCEDURE
              sqlfopen (VAR hostfile : tsp_vfilename;
                    direction      : tsp_opcodes;
                    resource       : tsp_vf_resource;
                    VAR hostfileno : tsp_int4;
                    VAR format     : tsp_vf_format;
                    VAR rec_len    : tsp_int4;
                    poolptr        : tsp_int4;
                    buf_count      : tsp_int2;
                    VAR block      : tct_lineaddr;
                    VAR error      : tsp_vf_return;
                    VAR errtext    : tsp_errtext);
 
        PROCEDURE
              sqlfclose (VAR hostfileno : tsp_int4;
                    erase             : boolean;
                    poolptr           : tsp_int4;
                    buf_count         : tsp_int2;
                    block             : tct_lineaddr;
                    VAR error         : tsp_vf_return;
                    VAR errtext       : tsp_errtext);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-10 : VSP10;
 
        PROCEDURE
              s10fil (
                    size       : tsp_int4;
                    VAR m      : tsp_line;
                    pos        : tsp_int4;
                    len        : tsp_int4;
                    fillchar   : char);
 
        PROCEDURE
              s10mv1 (
                    size1      : namepositions;
                    size2      : tsp_int4;
                    VAR val1   : tsp_name;
                    p1         : tsp_int4;
                    VAR val2   : tsp_line;
                    p2         : tsp_int4;
                    anz        : tsp_int4 );
 
        PROCEDURE
              s10mv2 (
                    size1      : tsp_int4;
                    size2      : tsp_int4;
                    VAR val1   : tsp_line;
                    p1         : tsp_int4;
                    VAR val2   : tsp_lname;
                    p2         : tsp_int4;
                    anz        : tsp_int4 );
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30: VSP30;
 
        FUNCTION
              s30klen (   VAR str  : tsp_line;
                    val      : char;
                    cnt      : integer) : integer;
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              s30klen;
 
              tsp_moveobj       tsp_line
 
        PROCEDURE
              s10fil;
 
              tsp_moveobj       tsp_line
 
        PROCEDURE
              s10mv1;
 
              tsp_moveobj       tsp_name
              tsp_int4          namepositions
              tsp_moveobj       tsp_line
 
        PROCEDURE
              s10mv2;
 
              tsp_moveobj       tsp_line
              tsp_moveobj       tsp_lname
 
        PROCEDURE
              sqlfopen;
 
              tsp_vf_bufaddr tct_lineaddr
 
        PROCEDURE
              sqlfclose;
 
              tsp_vf_bufaddr tct_lineaddr
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 8
Author  : C.Segieth                  (Origin: E.Zabach)
.sp
Created : 1988-07-12
.sp
Version : 1996-12-10
.sp
Release :  6.2 	 Date : 1996-12-10
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
.CM *-END-* description ---------------------------------
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      (*   version - number, put to the bottom of the processed module *)
      n_vct_version   = 'PRETTY  3.09      ';
      n_vct_date      = ' 1992-11-23       ';
      c_dist_prettvers = 8;     (* right distance from 'lines_of_code' *)
&     if $OS = VMSP
      (* 'sqlfinish' in VM/SP can't leave recursive-procedures from   *)
      (* the bottom of the hierarchic levels. so we have to jump to   *)
      (* the end of the code to the last statements of the main-part. *)
 
LABEL
      9999;
&     endif
 
CONST
&     if $OS = VMSP
      n_ftm_error      = ' ERROR A          ';
      l_ftm_error      =   8;
      n_ftm_pretty     = ' PRETTY A         ';
      l_ftm_pretty     =   9;
      n_ftm_source     = ' VDN *            ';
      l_ftm_source     =   6;
      x_cr             = '\0d';
&     else
      (*  UNIX, ... *)
      n_ftm_error      = '.err              ';
      l_ftm_error      =   4;
      n_ftm_pretty     = '.pre              ';
      l_ftm_pretty     =   4;
      n_ftm_source     = '                  ';
      l_ftm_source     =   0;
      x_cr             = '\0d';
&     endif
      (* old pretty values :     -- *)
      in_begin         =  0;  (*  0 *)
      in_case          =  4;  (*    *)
      in_casepoint     =  4;  (*    *)
      in_co_if         =  4;  (*  5 *)
      in_co_while      =  6;  (*    *)
      in_co_with       =  5;  (*    *)
      in_continue      =  6;  (* 12 *)
      in_ctv           =  6;  (*  6 *)
      in_for           =  4;  (*  4 *)
      in_proc          =  6;  (*  6 *)
      in_record        =  6;  (*  6 *)
      in_repeat        =  4;  (*  7 *)
      in_then          =  4;  (*  4 *)
      in_until         =  4;  (*  6 *)
      in_usedef        =  8;  (*  8 *)
      in_while         =  4;  (*  6 *)
      in_with          =  4;  (*  5 *)
      len_words        = 35;
      max_offset       = 50;
      max_push_depth   = 40; (* war bis PRETTY 3.07 auf 30 *)
      maxpascallinelen = 72;
      n_and            = 'AND               ';
      n_array          = 'ARRAY             ';
      n_bt             = '.bt               ';
      n_case           = 'CASE              ';
      n_code_w         = 'code              ';
      n_com_end        = '(*END             ';
      n_com_error      = '(*+++ERROR        ';
      n_dash           = '---------------   ';
      n_det_errors     = 'detected errors : ';
      n_div            = 'DIV               ';
      n_do             = 'DO                ';
      n_downto         = 'DOWNTO            ';
      n_e_blank        = '                  ';
      n_e_longline     = 'line is too long  ';
      n_e_maxpush1     = 'maximum depth (30)';
      n_e_maxpush2     = 'for intend reached';
      n_e_missdo       = '"DO" missing      ';
      n_e_missend      = '"END" missing     ';
      n_e_missendcase  = '"ENDCASE" missing ';
      n_e_missendspec  = '".cm ende missing"';
      n_e_missuntil    = '"UNTIL" missing   ';
      n_e_notallowhere = 'not allowed here  ';
      n_e_routinend    = 'end of routine    ';
      n_e_unbalanced   = 'unbalanced "END"  ';
      n_else           = 'ELSE              ';
      n_endif          = 'ENDIF             ';
      n_endwhile       = 'ENDWHILE          ';
      n_endfor         = 'ENDFOR            ';
      n_endrepeat      = 'ENDREPEAT         ';
      n_endwith        = 'ENDWITH           ';
      n_endcase        = 'ENDCASE           ';
      n_false          = 'FALSE             ';
      n_for            = 'FOR               ';
      n_if             = 'IF                ';
      n_in             = 'IN                ';
      n_init_error     = 'line_____msg______';
      n_label          = 'LABEL             ';
      n_main           = 'MAIN              ';
      n_mod            = 'MOD               ';
      n_nil            = 'NIL               ';
      n_not            = 'NOT               ';
      n_of             = 'OF                ';
      n_opt_noblank    = 'NOBLANK           '; (* option for &ifdef *)
      n_or             = 'OR                ';
      n_otherwise      = 'OTHERWISE         ';
      n_packed         = 'PACKED            ';
      n_page           = '$$Page %$         ';
      n_pretty         = 'PRETTY            ';
      n_record         = 'RECORD            ';
      n_repeat         = 'REPEAT            ';
      n_script_cp      = '(*SCRIPT*.cp 20 *)';
      n_semicolon      = ';                 ';
      n_set            = 'SET               ';
      n_then           = 'THEN              ';
      n_to             = 'TO                ';
      n_true           = 'TRUE              ';
      n_type           = 'TYPE              ';
      n_until          = 'UNTIL             ';
      n_while          = 'WHILE             ';
      n_with           = 'WITH              ';
      x_ampersand      = '&';
      x_asterisk       = '*';
      x_colon          = ':';
      x_dollar         = '$';
      x_equal          = '=';
      x_hyphen         = '-';
      x_komma          = ',';
      x_parenth_cl     = ')';
      x_parenth_op     = '(';
      x_curve_cl       = '}';
      x_curve_op       = '{';
      x_period         = '.';
      x_quote          = '''';
      x_semicolon      = ';';
      x_slash          = '/';
      x_underln        = '_';
 
TYPE
      namepositions = 0..mxsp_name;
 
      tp_c11_record    = RECORD
            offsets         : ARRAY [ 0..max_push_depth ] OF tsp_int2;
            keywords        : ARRAY [ 1..len_words ] OF tsp_name;
            end_of_process  : boolean;
            infile_is_open  : boolean;
            in_proc_ctv     : boolean;
            intend_continue : boolean;
            intend_cclines  : boolean;
            is_comment      : boolean;
            is_keyword      : boolean;
            its_a_case      : boolean;
            its_frompart    : boolean;
            its_prog        : boolean;
            take_it         : boolean;
            c11fill1        : boolean;
            act_date        : tsp_date;
            act_time        : tsp_time;
            vdn_modul_name  : tct_vdn_name;
            ferr_text       : tsp_errtext;
            line_number     : tsp_int2;
            begpos_in_actln : tsp_int2;
            clcount         : tsp_int2;
            cond_output     : tsp_int2;
            count           : tsp_int2;
            detected_errors : tsp_int2;
            endpos_in_actln : tsp_int2;
            firstchar       : tsp_int2;
            offset          : tsp_int2;
            push_depth      : tsp_int2;
            stcount         : tsp_int2;
            process_state   : tct_do;
            ferr            : tsp_vf_return;
            infile          : tsp_int4;
            outfile         : tsp_int4;
            blankline       : tsp_line;
            name_line       : tsp_name;
            little_digit_ul : SET OF char;
            signs           : SET OF CHAR;
            c11fill2        : tsp_int2;
            hline           : tct_line;
            actln           : tct_line;
            outln           : tct_line;
            bufadr          : tct_lineaddr;
            check_linelength: boolean;
            sizecheck_cnt   : integer;
      END;
 
 
VAR
      c11_cnt      : integer;
      c11_digits   : SET OF char;
      c11_capitals : SET OF char;
      c11_littles  : SET OF char;
      c11_glob     : tp_c11_record;
 
 
(*------------------------------*) 
 
FUNCTION
      c11_compare  (
            cline : tsp_line;
            cname : tsp_name
            ) : boolean ;
 
VAR
      is_equal : boolean;
      i        : integer;
 
BEGIN
i        := 1;
is_equal := true;
WHILE ((is_equal) AND (i <= mxsp_name)) DO
    BEGIN
    is_equal := ( cline [ i ]  =  cname[ i ] );
    i        := succ (i);
    END;
(*ENDWHILE*) 
c11_compare := is_equal;
END;
 
(*------------------------------*) 
 
FUNCTION
      c11_eq_resp_case  (
            first    : tsp_name;
            second   : tsp_name;
            startpos : integer;
            len      : integer
            ) : boolean ;
 
VAR
      is_equal : boolean;
      i        : integer;
      act_pos  : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    i := 1;
    act_pos := startpos-1;
    is_equal := true;
    WHILE ((is_equal) AND (i <= len)) DO
        BEGIN
        is_equal := ( first [ act_pos+i ]  =  second [ i ] );
        i := succ (i);
        END;
    (*ENDWHILE*) 
    c11_eq_resp_case := is_equal;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      c11_eq_ign_case (
            ln    : tct_line;
            nstr  : tsp_name;
            start : integer
            ) : boolean;
 
VAR
      pos_1       : integer;
      j       : integer;
      r       : integer;
      namlen  : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    pos_1     := start;
    namlen := mxsp_name;
    WHILE ((namlen > 1) AND (nstr[ namlen ] = bsp_c1)) DO
        namlen := namlen - 1;
    (*ENDWHILE*) 
    j := 1;
    r := abs(ord(nstr [ 1 ]) - ord(ln.l[ pos_1 ]));
    WHILE (((r = 0) OR (r = c02uplo)) AND
          (pos_1 <= ln.len) AND (j < namlen)) DO
        BEGIN
        j     := succ (j);
        pos_1 := succ (pos_1);
        r     := abs(ord(nstr[ j ]) - ord(ln.l[ pos_1 ]));
        END;
    (*ENDWHILE*) 
    IF  (((r = 0) OR (r = c02uplo)) AND (j = namlen))
    THEN
        c11_eq_ign_case := true
    ELSE
        c11_eq_ign_case := false
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      push (shift_right : integer);
 
BEGIN
WITH c11_glob DO
    BEGIN
    offsets [ push_depth ] := offset;
    push_depth := succ (push_depth);
    IF  push_depth > max_push_depth
    THEN
        BEGIN
        write_errmsg (n_e_maxpush1, 18);
        write_errmsg (n_e_maxpush2, 18);
        END
    ELSE
        IF  ((shift_right > 0) AND (offset >= max_offset))
        THEN
            (* the line is full ... *)
            IF  shift_right = in_continue
            THEN
                offset := offset+3
            ELSE
                offset := succ (offset)
            (*ENDIF*) 
        ELSE
            offset := offset + shift_right;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      skipbl (VAR begpos, endpos : tsp_int2);
 
BEGIN
WITH c11_glob DO
    BEGIN
    begpos := endpos;
    WHILE ((begpos <= actln.len) AND (actln.l[ begpos ] = bsp_c1)) DO
        begpos := begpos+1;
    (*ENDWHILE*) 
    IF  endpos = 1
    THEN
        firstchar := begpos;
    (*ENDIF*) 
    endpos := begpos;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      read_one_line;
 
VAR
      i : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    c02blankline (actln);
    ferr := c02getline (infile, actln);
    actln.l [ actln.len + 1 ] := x_cr;
    IF   ferr <> vf_ok
    THEN
        end_of_process := true;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      give_identifier  (
            VAR startpos   : tsp_linepositions;
            endpos         : integer;
            VAR len_result : tsp_linepositions;
            VAR result     : tsp_line);
 
VAR
      pos_in_line : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    WHILE ((startpos <= endpos) AND
          (NOT (actln.l[ startpos ] IN little_digit_ul))) DO
        startpos := startpos+1;
    (*ENDWHILE*) 
    pos_in_line := startpos;
    len_result := 0;
    IF  ((startpos > 1) AND (startpos <= endpos))
    THEN
        IF  actln.l [ startpos - 1 ] IN c11_capitals
        THEN
            BEGIN
            result [ 1 ] := actln.l [ startpos - 1 ];
            startpos := startpos-1;
            len_result := 1
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    WHILE ((pos_in_line <= endpos) AND
          (actln.l[ pos_in_line ] IN little_digit_ul) AND
          (len_result < mxsp_line)) DO
        BEGIN
        len_result := len_result+1;
        result[ len_result ] := actln.l[ pos_in_line ];
        pos_in_line := pos_in_line+1
        END;
    (*ENDWHILE*) 
    s10fil (mxsp_line, result, len_result+1, mxsp_line-len_result, bsp_c1);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      s60uppcase (startpos, endpos : integer);
 
VAR
      start_array, end_array,k  : integer;
      ident      : tsp_dataline;
      short_str  : tsp_name;
      found      : boolean;
 
BEGIN
WITH c11_glob, ident DO
    BEGIN
    pos := startpos;
    give_identifier (pos, endpos, length, text);
    WHILE length > 0 DO
        BEGIN
        IF  ( (length > 1)
            AND (length < 10) )
        THEN
            BEGIN
            FOR k := 1 TO 10 DO
                short_str [ k ] := text [ k ];
            (*ENDFOR*) 
            CASE length OF
                2 :
                    BEGIN
                    start_array := 1;
                    end_array   := 5
                    END;
                3 :
                    BEGIN
                    start_array := 6;
                    end_array   := 14
                    END;
                4 :
                    BEGIN
                    start_array := 15;
                    end_array   := 21
                    END;
                5 :
                    BEGIN
                    start_array := 22;
                    end_array   := 27
                    END;
                6 :
                    BEGIN
                    start_array := 28;
                    end_array   := 31
                    END;
                7, 8, 9 :
                    BEGIN
                    start_array := 32;
                    end_array   := 35
                    END
                END;
            (*ENDCASE*) 
            found := false;
            WHILE ((start_array <= end_array) AND
                  NOT (found)) DO
                BEGIN
                IF  c11_eq_resp_case (keywords[ start_array ], short_str, 1, length)
                THEN
                    BEGIN
                    found := true;
                    FOR k := pos TO pos + length - 1 DO
                        actln.l [ k ] := chr (ord(actln.l[ k ])
                              + ord ('A') - ord ('a'))
                    (*ENDFOR*) 
                    END;
                (*ENDIF*) 
                start_array := succ (start_array)
                END
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        pos := pos + length;
        give_identifier (pos, endpos, length, text)
        END;
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      keyw_upc (startpos : integer);
 
VAR
      position, endposition : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    position := startpos;
    IF  NOT is_comment
    THEN
        BEGIN
        WHILE ((actln.l[ position ] = bsp_c1) AND
              (actln.l[ position ] <> x_cr)) DO
            position := position+1;
        (*ENDWHILE*) 
        endposition := position;
        WHILE ((actln.l[ endposition ] <> x_parenth_op) AND
              (actln.l[ endposition ] <> x_curve_op) AND
              (actln.l[ endposition ] <> x_quote) AND
              (actln.l[ endposition ] <> x_cr)) DO
            endposition := endposition+1;
        (*ENDWHILE*) 
        IF  actln.l[ endposition ] = x_cr
        THEN
            BEGIN
            IF  endposition - position > 1
            THEN
                s60uppcase (position, endposition - 1)
            (*ENDIF*) 
            END
        ELSE
            IF  actln.l[ endposition ] = x_quote
            THEN
                BEGIN
                IF  endposition - position > 1
                THEN
                    s60uppcase (position, endposition - 1);
                (*ENDIF*) 
                position := endposition+1;
                WHILE ((actln.l[ position ] <> x_cr) AND
                      (actln.l[ position ] <> x_quote)) DO
                    position := position+1;
                (*ENDWHILE*) 
                IF  actln.l[ position ] = x_quote
                THEN
                    BEGIN
                    position := position+1;
                    WHILE ((actln.l[ position ] <> x_cr) AND
                          (actln.l[ position ] = bsp_c1)) DO
                        position := position+1;
                    (*ENDWHILE*) 
                    IF  actln.l[ position ] <> x_cr
                    THEN
                        keyw_upc (position)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  endposition - position > 1
                THEN
                    s60uppcase (position, endposition - 1);
                (*ENDIF*) 
                IF  actln.l[ endposition+1 ] = x_asterisk
                THEN
                    BEGIN
                    is_comment := true;
                    keyw_upc (endposition + 2)
                    END
                ELSE
                    IF  actln.l[ endposition ] = x_curve_op
                    THEN
                        BEGIN
                        is_comment := true;
                        keyw_upc (endposition + 1)
                        END
                    ELSE
                        keyw_upc (endposition + 1)
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        WHILE (((actln.l[ position ] <> x_asterisk) OR
              (actln.l[ position+1 ] <> x_parenth_cl)) AND
              (actln.l[ position ] <> x_curve_cl) AND
              (actln.l[ position ] <> x_cr)) DO
            position := position+1;
        (*ENDWHILE*) 
        IF  actln.l[ position ] <> x_cr
        THEN
            BEGIN
            is_comment := false;
            IF  actln.l[ position ] = x_curve_cl
            THEN
                keyw_upc (position+1)
            ELSE
                keyw_upc (position+2)
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      catch_identifier (
            VAR result          : tsp_line;
            VAR begpos, endpos : tsp_int2);
 
VAR
      index : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    skipbl (begpos, endpos);
    IF  begpos > actln.len
    THEN
        BEGIN
        read_text;
        END;
    (*ENDIF*) 
    WHILE ((actln.l[ begpos ] = x_parenth_op) AND
          (actln.l[ begpos+1 ] = x_asterisk)) OR
          (actln.l[ begpos ] = x_curve_op) DO
        BEGIN
        output_of_text (begpos, -1);
        skipbl (begpos, endpos)
        END;
    (*ENDWHILE*) 
    WHILE ((begpos = 1) AND (actln.l[ 1 ] = x_ampersand)) DO
        BEGIN
        output_of_text (begpos, 0);
        skipbl (begpos, endpos)
        END;
    (*ENDWHILE*) 
    WHILE ((actln.l[ begpos ] = x_parenth_op) AND
          (actln.l[ begpos+1 ] = x_asterisk)) OR
          (actln.l[ begpos ] = x_curve_op) DO
        BEGIN
        output_of_text (begpos, -1);
        skipbl (begpos, endpos)
        END;
    (*ENDWHILE*) 
    index := 1;
    IF  actln.l [ begpos ] = x_quote
    THEN
        BEGIN
        endpos := begpos+1;
        result [ 1 ] := x_quote;
        index := 2;
        WHILE ((index <= mxsp_line) AND
              (endpos <= actln.len) AND
              (actln.l[ endpos ] <> x_quote)) DO
            BEGIN
            result [ index ] := actln.l [ endpos ];
            endpos := endpos+1;
            index := index+1
            END;
        (*ENDWHILE*) 
        IF  ((actln.l[ endpos ] = x_quote) AND
            (index <= mxsp_line))
        THEN
            BEGIN
            result [ index ] := x_quote;
            index := index+1;
            endpos := endpos+1
            END
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        WHILE ((actln.l[ endpos ] IN signs) AND
              (index <= mxsp_line)) DO
            BEGIN
            result [ index ] := actln.l [ endpos ];
            endpos := endpos+1;
            index := index+1
            END
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    WHILE index <= mxsp_line DO
        BEGIN
        result [ index ] := bsp_c1;
        index := index+1
        END         ;
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      give_upcase_word (
            VAR upc_word : tsp_name;
            endpos       : integer;
            VAR length   : tsp_int2);
 
VAR
      ind : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    length := 0;
    ind := endpos;
    WHILE ((length < mxsp_name) AND
          (actln.l[ ind ] IN c11_capitals)) DO
        BEGIN
        length := length+1;
        upc_word [ length ] := actln.l [ ind ];
        ind := ind+1
        END;
    (*ENDWHILE*) 
    FOR ind := length+1 TO mxsp_name DO
        upc_word[ ind ] := bsp_c1;
    (*ENDFOR*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      st_begin (VAR next_word : tsp_line);
 
BEGIN
WITH c11_glob DO
    BEGIN
    push (in_begin);
    output_of_text (begpos_in_actln, 5);
    WHILE NOT is_keyword DO
        sprocess_statement;
    (*ENDWHILE*) 
    catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
    IF  NOT (c11_compare (next_word, cct_n_end))
    THEN
        BEGIN
        write_errmsg (n_e_missend, 13);
        endpos_in_actln := begpos_in_actln;
        IF  NOT (c11_compare (next_word, n_until))
        THEN
            is_keyword := false
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        is_keyword := false;
        WHILE ((actln.l[ endpos_in_actln ] = bsp_c1) AND
              (endpos_in_actln <= actln.len)) DO
            endpos_in_actln := endpos_in_actln+1;
        (*ENDWHILE*) 
        IF  ((endpos_in_actln = actln.len+1) OR
            (actln.l[ endpos_in_actln ] <> x_semicolon))
        THEN
            output_of_text (begpos_in_actln, 3)
        ELSE
            output_of_text (begpos_in_actln, endpos_in_actln-
                  begpos_in_actln+1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    pop;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      st_if (VAR next_word : tsp_line);
 
VAR
      len_line   : integer;
      i          : integer;
      k          : integer;
      first_line : boolean;
      its_found  : boolean;
      search_beg : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    i := 0;
    len_line := actln.len;
    (* shift if-condition to right *)
    WHILE i <= in_co_if - 3 DO
        BEGIN
        IF  actln.l[ endpos_in_actln+i ] <> bsp_c1
        THEN
            BEGIN
            k := succ(actln.len);
            WHILE k >= endpos_in_actln+i DO
                BEGIN
                actln.l[ succ(k) ] := actln.l[ k ];
                k := pred(k)
                END;
            (*ENDWHILE*) 
            actln.l[ succ(k) ] := bsp_c1;
            actln.len := succ(actln.len)
            END;
        (*ENDIF*) 
        i := succ(i)
        END;
    (*ENDWHILE*) 
    first_line      := true;
    its_found       := false;
    endpos_in_actln := endpos_in_actln+actln.len-len_line;
    WHILE NOT its_found DO
        BEGIN
        search_beg := endpos_in_actln;
        search_word_in_line (n_then, 4, its_found,
              search_beg, endpos_in_actln);
        IF  its_found
        THEN
            BEGIN
            IF  endpos_in_actln - in_then > begpos_in_actln
            THEN
                output_of_text (begpos_in_actln, endpos_in_actln-5-
                      begpos_in_actln)
            (*ENDIF*) 
            END
        ELSE
            IF  endpos_in_actln > begpos_in_actln
            THEN
                output_of_text (begpos_in_actln, endpos_in_actln-
                      begpos_in_actln);
            (*ENDIF*) 
        (*ENDIF*) 
        IF  first_line
        THEN
            BEGIN
            push (in_co_if);
            first_line := false
            END
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    (* keyword 'then' found *)
    pop;
    output_of_text (begpos_in_actln, 4);
    push (in_then);
    sprocess_statement;
    pop;
    catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
    endpos_in_actln := begpos_in_actln;
    IF  c11_compare (next_word, n_else )
    THEN
        BEGIN
        is_keyword := false;
        output_of_text (begpos_in_actln, 4);
        push (in_then);
        sprocess_statement;
        pop
        END;
    (*ENDIF*) 
    write_end_com (n_endif);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      st_while_with (VAR next_word : tsp_line);
 
VAR
      do_found   : boolean;
      do_error   : boolean;
      first_line : boolean;
      search_beg : integer;
      old_search : integer;
      old_endpos : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    do_found   := false;
    first_line := true;
    WHILE NOT do_found DO
        BEGIN
        search_beg := endpos_in_actln;
        search_word_in_line (n_do, 2, do_found, search_beg,
              endpos_in_actln);
        IF  NOT do_found
        THEN
            BEGIN
            old_search := search_beg;
            old_endpos := endpos_in_actln;
            do_error   := false;
            search_word_in_line (cct_n_begin, 5, do_error, search_beg,
                  endpos_in_actln);
            IF  NOT do_error
            THEN
                BEGIN
                endpos_in_actln := old_endpos;
                search_beg      := old_search;
                search_word_in_line (n_semicolon, 1, do_error, search_beg,
                      endpos_in_actln);
                END;
            (*ENDIF*) 
            IF  do_error
            THEN
                BEGIN
                write_errmsg(n_e_missdo, 12);
                (* if 'BEGIN' or ';' is found, we assume, that the 'DO' has *)
                (* been forgotten. so *)
                (* set 'do_found' to 'true' to leave the processing of the *)
                (* while/with - condition. pretty should go on correctly.  *)
                do_found := true;
                END;
            (*ENDIF*) 
            endpos_in_actln := old_endpos;
            search_beg      := old_search;
            END;
        (*ENDIF*) 
        IF  endpos_in_actln > begpos_in_actln
        THEN
            output_of_text (begpos_in_actln, endpos_in_actln-
                  begpos_in_actln);
        (*ENDIF*) 
        IF  first_line
        THEN
            BEGIN
            IF  c11_compare (next_word, n_while )
            THEN
                push (in_co_while)
            ELSE
                push (in_co_with);
            (*ENDIF*) 
            first_line := false
            END;
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    pop;
    IF  c11_compare (next_word, n_while )
    THEN
        push (in_while)
    ELSE
        push (in_with);
    (*ENDIF*) 
    sprocess_statement;
    pop;
    IF  c11_compare (next_word, n_while )
    THEN
        write_end_com (n_endwhile)
    ELSE
        write_end_com (n_endwith);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      st_for (VAR next_word : tsp_line);
 
VAR
      first_line : boolean;
      its_found  : boolean;
      search_beg : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    its_found  := false;
    first_line := true;
    WHILE NOT its_found DO
        BEGIN
        search_beg := endpos_in_actln;
        search_word_in_line (n_do, 2, its_found, search_beg,
              endpos_in_actln);
        IF  its_found
        THEN
            BEGIN
            IF  actln.l[ endpos_in_actln ] = 'W'
            THEN
                its_found := false
            ELSE
                IF  endpos_in_actln > begpos_in_actln
                THEN
                    output_of_text (begpos_in_actln, endpos_in_actln-
                          begpos_in_actln)
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            IF  endpos_in_actln > begpos_in_actln
            THEN
                output_of_text (begpos_in_actln, endpos_in_actln-
                      begpos_in_actln);
            (*ENDIF*) 
        (*ENDIF*) 
        IF  (first_line AND
            (begpos_in_actln = endpos_in_actln))
        THEN
            BEGIN
            push (in_continue);
            first_line := false
            END
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    pop;
    push (in_for);
    sprocess_statement;
    pop;
    write_end_com (n_endfor);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      st_repeat (VAR next_word : tsp_line);
 
BEGIN
WITH c11_glob DO
    BEGIN
    output_of_text (begpos_in_actln, 6);
    push (in_repeat);
    WHILE NOT is_keyword DO
        sprocess_statement;
    (*ENDWHILE*) 
    pop;
    catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
    IF  NOT (c11_compare (next_word, n_until ))
    THEN
        BEGIN
        write_errmsg(n_e_missuntil, 15);
        endpos_in_actln := begpos_in_actln;
        IF  NOT (c11_compare (next_word, cct_n_end ))
        THEN
            is_keyword := false
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        is_keyword      := false;
        output_of_text (begpos_in_actln, 5);
        push (in_until);
        stcount         := stcount-1;
        intend_continue := false;
        sprocess_statement;
        intend_continue := true;
        pop
        END;
    (*ENDIF*) 
    write_end_com (n_endrepeat);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      st_case (VAR next_word : tsp_line);
 
VAR
      go_on       : boolean;
      first_line  : boolean;
      its_found   : boolean;
      its_reached : boolean;
      i           : integer;
      search_beg  : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    its_found  := false;
    first_line := true;
    WHILE NOT its_found DO
        BEGIN
        search_beg := endpos_in_actln;
        search_word_in_line (n_of, 2, its_found, search_beg,
              endpos_in_actln);
        IF  endpos_in_actln > begpos_in_actln
        THEN
            output_of_text (begpos_in_actln, endpos_in_actln-
                  begpos_in_actln);
        (*ENDIF*) 
        IF  first_line
        THEN
            BEGIN
            push (in_continue);
            first_line := false
            END
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    pop;
    push (in_case);
    its_found := false;
    WHILE NOT its_found DO
        BEGIN
        begpos_in_actln := endpos_in_actln;
        catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
        IF  c11_compare (next_word, cct_n_end )
        THEN
            BEGIN
            is_keyword := false;
            its_found  := true
            END
        ELSE
            IF  c11_compare (next_word, n_otherwise )
            THEN
                BEGIN
                is_keyword := false;
                WHILE ((endpos_in_actln <= actln.len) AND
                      (actln.l[ endpos_in_actln ] = bsp_c1 )) DO
                    endpos_in_actln := endpos_in_actln + 1;
                (*ENDWHILE*) 
                IF  actln.l[ endpos_in_actln ] = x_colon
                THEN
                    output_of_text (begpos_in_actln, endpos_in_actln + 1
                          - begpos_in_actln)
                ELSE
                    output_of_text (begpos_in_actln, 9);
                (*ENDIF*) 
                push (in_casepoint);
                sprocess_statement;
                pop
                END
            ELSE
                BEGIN
                its_reached := false;
                WHILE NOT its_reached DO
                    BEGIN
                    WHILE ((endpos_in_actln <= actln.len) AND
                          (actln.l[ endpos_in_actln ] <> x_colon)) DO
                        endpos_in_actln := endpos_in_actln+1;
                    (*ENDWHILE*) 
                    IF  actln.l[ endpos_in_actln ] = x_colon
                    THEN
                        IF  actln.l[ endpos_in_actln+1 ] <> x_equal
                        THEN
                            IF  its_a_case
                            THEN
                                BEGIN
                                output_of_text (begpos_in_actln, endpos_in_actln -
                                      begpos_in_actln + 1);
                                push (in_casepoint);
                                i := endpos_in_actln;
                                WHILE ((i < actln.len) AND (actln.l[ i ] = bsp_c1)) DO
                                    i := i + 1;
                                (*ENDWHILE*) 
                                IF  actln.l[ i ] = x_parenth_op
                                THEN
                                    BEGIN
                                    go_on := true;
                                    WHILE go_on DO
                                        BEGIN
                                        i := begpos_in_actln;
                                        IF  i = 1
                                        THEN
                                            IF  actln.l[ i ] = x_parenth_cl
                                            THEN
                                                go_on := false
                                            ELSE
                                                i := succ(i);
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                        WHILE (go_on AND (i <= actln.len)) DO
                                            BEGIN
                                            IF  ((actln.l[ i ] = x_parenth_cl) AND
                                                NOT (actln.l[ i-1 ] IN [ x_asterisk, x_period ]))
                                            THEN
                                                go_on := false;
                                            (*ENDIF*) 
                                            i := succ(i)
                                            END;
                                        (*ENDWHILE*) 
                                        sprocess_statement;
                                        END;
                                    (*ENDWHILE*) 
                                    its_reached := true
                                    END
                                ELSE
                                    BEGIN
                                    endpos_in_actln := begpos_in_actln;
                                    sprocess_statement;
                                    its_reached     := true
                                    END;
                                (*ENDIF*) 
                                pop;
                                END
                            ELSE
                                BEGIN
                                output_of_text (begpos_in_actln, endpos_in_actln-
                                      begpos_in_actln+1);
                                push (in_casepoint);
                                sprocess_statement;
                                pop;
                                its_reached := true
                                END
                            (*ENDIF*) 
                        ELSE
                            BEGIN
                            write_errmsg(n_e_missendcase, 17);
                            endpos_in_actln := begpos_in_actln;
                            its_reached     := true;
                            its_found       := true
                            END
                        (*ENDIF*) 
                    ELSE
                        output_of_text (begpos_in_actln, 0);
                    (*ENDIF*) 
                    END;
                (*ENDWHILE*) 
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  c11_compare (next_word, cct_n_end )
    THEN
        output_of_text (begpos_in_actln, 3);
    (*ENDIF*) 
    pop;
    write_end_com (n_endcase);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ct11_g10found (VAR next_word : tsp_line) : boolean;
 
VAR
      iword : tsp_lname;
      i     : integer;
 
BEGIN
(* check from bottom to top because of name-equality in *)
(* local values and parts of global defined types (vak73 for example) *)
iword := '                                ';
s10mv2 (mxsp_line, mxsp_lname, next_word, 1, iword, 1, 5);
IF  (iword = 'g10mv                           ')
    OR (iword = 'g10fi                           ')
THEN
    ct11_g10found := true
ELSE
    ct11_g10found := false
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      st_normal (VAR next_word : tsp_line);
 
VAR
      first_line   : boolean;
      its_reached  : boolean;
      i            : integer;
      len_line     : tsp_int2;
      capital_word : tsp_name;
 
BEGIN
WITH c11_glob DO
    BEGIN
    IF  (   (next_word[ 1 ] IN c11_capitals)
        AND (next_word[ 2 ] IN c11_capitals)
        AND NOT (c11_compare (next_word, n_not))
        AND NOT (c11_compare (next_word, cct_n_from))
        AND take_it )
    THEN
        BEGIN
        write_errmsg(n_e_blank, 2);
        is_keyword      := true;
        endpos_in_actln := begpos_in_actln
        END
    ELSE
        BEGIN
        IF  ct11_g10found (next_word)
        THEN
            BEGIN
            WHILE actln.l[ endpos_in_actln ] = ' ' DO
                endpos_in_actln := succ(endpos_in_actln);
            (*ENDWHILE*) 
            endpos_in_actln := succ(endpos_in_actln);
            capital_word := '        ,    ,    ';
            capital_word[ 1 ] := x_quote;
            FOR i := 1 TO 6 DO
                capital_word[ 1+i ] := vdn_modul_name[ i ];
            (*ENDFOR*) 
            capital_word[ 8 ] := x_quote;
            sizecheck_cnt := succ(sizecheck_cnt);
            i := sizecheck_cnt;
            IF  sizecheck_cnt > 99
            THEN
                BEGIN
                capital_word[ 11 ] := chr(sizecheck_cnt DIV 100 + ord('0'));
                i := i MOD 100;
                END;
            (*ENDIF*) 
            IF  sizecheck_cnt > 9
            THEN
                BEGIN
                capital_word[ 12 ] := chr(i DIV 10 + ord('0'));
                i := i MOD 10
                END;
            (*ENDIF*) 
            capital_word[ 13 ] := chr(i + ord('0'));
            s10mv1(mxsp_name, mxsp_line, capital_word, 1,
                  actln.l, endpos_in_actln, mxsp_name);
            actln.len := endpos_in_actln + mxsp_name - 1;
            endpos_in_actln := pred(endpos_in_actln);
            END;
        (*ENDIF*) 
        first_line  := true;
        its_reached := false;
        WHILE (   NOT (is_keyword)
              AND NOT (its_reached) ) DO
            BEGIN
            IF  actln.l[ 1 ] <> x_ampersand
            THEN
                WHILE (   NOT (is_keyword)
                      AND (endpos_in_actln <= actln.len)
                      AND (actln.l[ endpos_in_actln ] <> x_semicolon)) DO
                    BEGIN
                    WHILE (   endpos_in_actln <= actln.len)
                          AND (NOT ( actln.l[ endpos_in_actln ] IN
                          (c11_capitals +
                          [ x_quote, x_parenth_op, x_semicolon,
                          x_curve_op ]) ) )
                          DO
                        endpos_in_actln := endpos_in_actln+1;
                    (*ENDWHILE*) 
                    IF  (   (endpos_in_actln <= actln.len)
                        AND (actln.l[ endpos_in_actln ] <> x_semicolon))
                    THEN
                        CASE actln.l[ endpos_in_actln ] OF
                            x_parenth_op :
                                IF  actln.l[ endpos_in_actln+1 ] = x_asterisk
                                THEN
                                    IF  is_comment
                                    THEN
                                        endpos_in_actln := actln.len+1
                                    ELSE
                                        BEGIN
                                        WHILE (   (endpos_in_actln < actln.len)
                                              AND ((actln.l[ endpos_in_actln ] <> x_asterisk) OR
                                              (actln.l[ endpos_in_actln+1 ] <> x_parenth_cl))) DO
                                            endpos_in_actln := endpos_in_actln+1;
                                        (*ENDWHILE*) 
                                        endpos_in_actln := endpos_in_actln+2
                                        END
                                    (*ENDIF*) 
                                ELSE
                                    endpos_in_actln := endpos_in_actln+1;
                                (*ENDIF*) 
                            x_curve_op :
                                IF  is_comment
                                THEN
                                    endpos_in_actln := actln.len+1
                                ELSE
                                    BEGIN
                                    WHILE (   (endpos_in_actln < actln.len)
                                          AND (actln.l[ endpos_in_actln+1 ] <> x_curve_cl)) DO
                                        endpos_in_actln := endpos_in_actln+1;
                                    (*ENDWHILE*) 
                                    endpos_in_actln := endpos_in_actln+1
                                    END;
                                (*ENDIF*) 
                            x_quote :
                                BEGIN
                                endpos_in_actln := endpos_in_actln+1;
                                WHILE (   (endpos_in_actln <= actln.len)
                                      AND (actln.l[ endpos_in_actln ] <> x_quote))
                                      DO
                                    endpos_in_actln := endpos_in_actln+1;
                                (*ENDWHILE*) 
                                endpos_in_actln := endpos_in_actln+1
                                END;
                            OTHERWISE
                                BEGIN
                                give_upcase_word (capital_word, endpos_in_actln, len_line);
                                IF  take_it
                                THEN
                                    IF  (  (capital_word = n_and)
                                        OR (capital_word = n_div)
                                        OR (capital_word = n_false)
                                        OR (capital_word = cct_n_from)
                                        OR (capital_word = n_in)
                                        OR (capital_word = n_mod)
                                        OR (capital_word = n_nil)
                                        OR (capital_word = n_not)
                                        OR (capital_word = n_or)
                                        OR (capital_word = n_true)
                                        OR (len_line = 1))
                                    THEN
                                        endpos_in_actln := endpos_in_actln+len_line
                                    ELSE
                                        is_keyword := true
                                    (*ENDIF*) 
                                ELSE
                                    IF  (   (capital_word <> cct_n_end  )
                                        AND (capital_word <> n_record    ))
                                    THEN
                                        endpos_in_actln := endpos_in_actln+len_line
                                    ELSE
                                        is_keyword := true
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                END
                            END
                        (*ENDCASE*) 
                    (*ENDIF*) 
                    END;
                (*ENDWHILE*) 
            (*ENDIF*) 
            IF  is_keyword
            THEN
                BEGIN
                IF  endpos_in_actln > begpos_in_actln
                THEN
                    IF  capital_word <> n_record
                    THEN
                        output_of_text (begpos_in_actln,
                              endpos_in_actln-begpos_in_actln)
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                IF  actln.l[ endpos_in_actln ] = x_semicolon
                THEN
                    BEGIN
                    its_reached := true;
                    output_of_text (begpos_in_actln, endpos_in_actln-
                          begpos_in_actln+1)
                    END
                ELSE
                    output_of_text (begpos_in_actln, 0);
                (*ENDIF*) 
            (*ENDIF*) 
            IF  first_line
            THEN
                IF  intend_continue
                THEN
                    BEGIN
                    push (in_continue);
                    first_line := false
                    END
                ELSE
                    BEGIN
                    push ( 0 );
                    first_line := false
                    END
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        pop
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      sprocess_statement;
 
VAR
      next_word   : tsp_line;
      case_select : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
    IF  c11_compare (next_word, cct_n_begin )
    THEN
        case_select := 1
    ELSE
        IF  c11_compare (next_word, n_if )
        THEN
            case_select := 2
        ELSE
            IF  (  c11_compare (next_word, n_while)
                OR c11_compare (next_word, n_with ) )
            THEN
                case_select := 3
            ELSE
                IF  c11_compare (next_word, n_for )
                THEN
                    case_select := 4
                ELSE
                    IF  c11_compare (next_word, n_repeat )
                    THEN
                        case_select := 5
                    ELSE
                        IF  c11_compare (next_word, n_case )
                        THEN
                            case_select := 6
                        ELSE
                            IF  (  c11_compare (next_word, cct_n_end )
                                OR c11_compare (next_word, n_until ))
                            THEN
                                case_select := 7
                            ELSE
                                case_select := 8;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  ((case_select > 1) AND (case_select <> 7))
    THEN
        stcount := stcount+count;
    (*ENDIF*) 
    CASE case_select OF
        1 :
            st_begin (next_word);
        2 :
            st_if (next_word);
        3 :
            st_while_with (next_word);
        4 :
            st_for (next_word);
        5 :
            st_repeat (next_word);
        6 :
            st_case (next_word);
        7 :
            BEGIN
            is_keyword      := true;
            endpos_in_actln := begpos_in_actln
            END;
        OTHERWISE
            st_normal (next_word)
        END;
    (*ENDCASE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      search_word_in_line (
            srch_word       : tsp_name;
            len_line        : integer;
            VAR   its_found : boolean;
            begpos          : integer;
            VAR   endpos_in_actln : tsp_int2
            );
 
VAR
      word_index  : integer;
      beg_comment : integer;
      end_comment : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    its_found    := false;
    word_index  := pos_resp_case (srch_word, begpos, len_line);
    beg_comment := pos_resp_case (cct_n_combeg, begpos, 2);
    IF  (   ((beg_comment = 0) OR (beg_comment > word_index))
        AND (word_index > 0))
    THEN
        IF  word_index > 1
        THEN
            IF  actln.l[ word_index-1 ] <> x_quote
            THEN
                BEGIN
                its_found       := true;
                endpos_in_actln := word_index+len_line
                END
            ELSE
                search_word_in_line (srch_word, len_line, its_found,
                      word_index+len_line, endpos_in_actln)
            (*ENDIF*) 
        ELSE
            BEGIN
            its_found       := true;
            endpos_in_actln := word_index+len_line
            END
        (*ENDIF*) 
    ELSE
        IF  beg_comment > 0
        THEN
            BEGIN
            end_comment := pos_ign_case (cct_n_comend, beg_comment+2, 2);
            IF  (   (end_comment <> 0)
                AND (end_comment < word_index))
            THEN
                BEGIN
                its_found       := true;
                endpos_in_actln := word_index+len_line
                END
            ELSE
                IF  end_comment = 0
                THEN
                    BEGIN
                    endpos_in_actln := beg_comment;
                    IF  (   (beg_comment = begpos)
                        AND (begpos_in_actln = begpos))
                    THEN
                        output_of_text (beg_comment, -1)
                    (*ENDIF*) 
                    END
                ELSE
                    endpos_in_actln := end_comment+2
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            endpos_in_actln := actln.len+1;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      pop;
 
BEGIN
WITH c11_glob DO
    BEGIN
    push_depth := push_depth-1;
    IF  push_depth = 0
    THEN
        BEGIN
        offset     := 1;
        push_depth := 1
        END
    ELSE
        offset := offsets [ push_depth ];
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      equal_resp (first    : tsp_line;
            second   : tsp_name;
            startpos : integer;
            len      : integer) : boolean ;
 
VAR
      is_equal : boolean;
      i        : integer;
      act_pos  : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    i        := 1;
    act_pos  := startpos-1;
    is_equal := true;
    WHILE ((is_equal) AND (i <= len)) DO
        BEGIN
        is_equal := ( first[ act_pos+i ] = second[ i ] );
        i := succ(i);
        END;
    (*ENDWHILE*) 
    equal_resp := is_equal;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      pos_ign_case (
            target          : tsp_name;
            startpos, length : integer) : integer;
 
VAR
      position : integer;
      found : boolean;
 
BEGIN
WITH c11_glob DO
    BEGIN
    found := false;
    position := startpos-1;
    WHILE ((position <= actln.len-length) AND NOT (found)) DO
        BEGIN
        position := succ(position);
        found := c11_eq_ign_case (actln, target, position)
        END;
    (*ENDWHILE*) 
    IF  NOT found
    THEN
        BEGIN
        pos_ign_case := 0;
        END
    ELSE
        BEGIN
        pos_ign_case := position;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      pos_resp_case (
            target          : tsp_name;
            startpos, length : integer) : integer;
 
VAR
      position : integer;
      found : boolean;
 
BEGIN
WITH c11_glob DO
    BEGIN
    found    := false;
    position := startpos-1;
    WHILE ((position <= actln.len-length) AND NOT (found)) DO
        BEGIN
        position := succ(position);
        found    := equal_resp(actln.l, target, position, length)
        END;
    (*ENDWHILE*) 
    IF  NOT found
    THEN
        BEGIN
        pos_resp_case := 0;
        END
    ELSE
        BEGIN
        pos_resp_case := position;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      check_offset;
 
BEGIN
WITH c11_glob DO
    BEGIN
    IF  (offset <> 1) AND (NOT (in_proc_ctv))
        AND (
        (   process_state = do_searchcode)    (* work_in_struct *)
        OR (process_state = do_prettyresult)  (* work_in_code *)
        )
    THEN
        BEGIN
        write_errmsg(n_e_missend, 13);
        push_depth := 1;
        offset     := 1;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      read_text;
 
VAR
      line_found : boolean;
      int_l     : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    actln.l[ 1 ] := x_period;
    WHILE (   (NOT (ferr = vf_eof))
          AND (actln.l[ 1 ] = x_period)
          AND (NOT end_of_process)) DO
        BEGIN
        line_found := false;
        WHILE (   (NOT (ferr = vf_eof))
              AND (NOT end_of_process)
              AND (NOT line_found) ) DO
            BEGIN
            line_found := true;
            read_one_line;
            IF  actln.len = 0
            THEN
                line_found := false
            ELSE
                BEGIN
                FOR int_l := 1 TO actln.len DO
                    IF  ord(actln.l[ int_l ]) = 9
                    THEN
                        actln.l[ int_l ] := bsp_c1;
                    (*ENDIF*) 
                (*ENDFOR*) 
                IF  (   c11_eq_ign_case ( actln, n_dash, 8)
                    AND (actln.len > mxsp_name+6))
                    (* some 'special' lines should be ignored by PRETTY *)
                THEN
                    line_found := false
                ELSE
                    BEGIN
                    endpos_in_actln := 1;
                    skipbl (begpos_in_actln, endpos_in_actln);
                    IF  (  (begpos_in_actln = actln.len+1)
                        OR equal_resp(actln.l, n_com_end,    begpos_in_actln,  5)
                        OR equal_resp(actln.l, n_com_error,  begpos_in_actln, 10)
                        OR equal_resp(actln.l, n_script_cp,  begpos_in_actln, 10)
                        )
                    THEN
                        line_found := false
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        IF  c11_eq_ign_case ( actln, cct_n_cm, 1)
        THEN
            IF  pos_ign_case (cct_n_endpart, 5, 7) <> 0
            THEN
                BEGIN
                (* the end of a specific section is reached *)
                write_linend;
                IF  pos_ign_case (n_code_w, 11, 4) <> 0
                THEN
                    BEGIN (* end of code-part reached - stop processing *)
                    (* action of label 10 *)
                    IF  (offset <> 1) AND NOT (in_proc_ctv)
                    THEN
                        BEGIN
                        write_errmsg(n_e_missend, 13);
                        push_depth := 1;
                        offset     := 1;
                        END;
                    (*ENDIF*) 
                    IF  actln.len <> 0
                    THEN
                        write_actline;
                    (*ENDIF*) 
                    sequential_program;
                    IF  NOT c02process_state_ok (process_state, c02outf)
                    THEN
                        detected_errors := succ(detected_errors);
                    (*ENDIF*) 
                    IF  detected_errors <> 0
                    THEN
                        BEGIN
                        hline.l[ 1 ] := bsp_c1;
                        hline.len    := 1;
                        c02vfwrite (c02outf, hline);
                        name_line   := cct_n_prettyspec;
                        s10mv1 ( mxsp_name, mxsp_line, name_line, 1, hline.l, 1, 10);
                        hline.l[ 11 ] := bsp_c1;
                        hline.l[ 12 ] := bsp_c1;
                        name_line := n_det_errors;
                        s10mv1 ( mxsp_name, mxsp_line, name_line, 1, hline.l, 13, 18);
                        c02int4to_line ( detected_errors, false, 6, 31, hline.l);
                        hline.len := 36;
                        c02vfwrite (c02outf, hline);
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    (* end of any other than code-part reached *)
                    (* action of label 20 *)
                    check_offset;
                    write_actline;
                    sequential_program;
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  (ferr = vf_eof)  OR  end_of_process
    THEN
        BEGIN
&       if $OS = VMSP
        (* see comment at the label-definition at top of code *)
        goto 9999;
&       else
        (* action of label 9999 *)
        close_files;
        sqlfinish(true);
&       endif
        END
    ELSE
        BEGIN
        IF  c11_eq_ign_case ( actln, cct_n_author, 1)
        THEN
            BEGIN
            write_errmsg(n_e_missendspec, 18);
            (* action of label 20 *)
            write_actline;
            sequential_program;
            END;
        (*ENDIF*) 
        IF  actln.l[ begpos_in_actln ] <> x_ampersand
        THEN
            IF  NOT its_frompart
            THEN
                keyw_upc (begpos_in_actln)
            ELSE
                BEGIN
                int_l := begpos_in_actln;
                WHILE (   (actln.l[ int_l ] <> x_cr)
                      AND (actln.l[ int_l ] <> x_semicolon)) DO
                    int_l := succ(int_l);
                (*ENDWHILE*) 
                keyw_upc (int_l)
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      print_text (from_pos, pos_cnt : integer);
 
VAR
      prt_txt_cnt, prt_pos, i : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    clcount := clcount+1;
    prt_pos := pos_cnt;
    IF  prt_pos = 0
    THEN
        prt_pos := actln.len-from_pos+1;
    (*ENDIF*) 
    IF  prt_pos = 0
    THEN
        write_linend
    ELSE
        BEGIN
        prt_txt_cnt := offset;
        IF  (   (offset+prt_pos > mxsp_line)
            AND (prt_pos < mxsp_line))
        THEN
            offset := mxsp_line-prt_pos;
        (*ENDIF*) 
        IF  actln.l[ from_pos ] <> x_ampersand
        THEN
            BEGIN
            FOR i := 1 TO offset-1 DO
                write_char (bsp_c1);
            (*ENDFOR*) 
            FOR i := 0 TO prt_pos-1 DO
                write_char (actln.l[ from_pos+i ]);
            (*ENDFOR*) 
            END
        ELSE
            BEGIN
            (* print a 'conditional-compiling-control-line' *)
            write_char (actln.l[ from_pos ]);
            IF  intend_cclines
            THEN
                (* suppress the blanks - if wanted by option *)
                IF  cond_output = 0
                THEN
                    FOR i := 1 TO offset-2 DO
                        write_char (bsp_c1)
                    (*ENDFOR*) 
                ELSE
                    FOR i := 1 TO cond_output DO
                        write_char (bsp_c1);
                    (*ENDFOR*) 
                (*ENDIF*) 
            (*ENDIF*) 
            i := from_pos+1;
            WHILE (   (i <= from_pos+prt_pos-1)
                  AND (actln.l[ i ] = bsp_c1)) DO
                i := succ(i);
            (*ENDWHILE*) 
            WHILE i <= from_pos+prt_pos-1 DO
                BEGIN
                write_char (actln.l[ i ]);
                i := succ(i)
                END
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        write_linend;
        offset := prt_txt_cnt
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      output_of_text (
            from_pos : integer;
            apos     : integer);
 
VAR
      chr_count    : integer;
      from_ptr     : integer;
      pos_cnt      : integer;
      found        : boolean;
      its_intended : boolean;
 
BEGIN
WITH c11_glob DO
    BEGIN
    from_ptr     := from_pos;
    pos_cnt      := apos;
    its_intended := false;
    IF  (  (pos_cnt = 0)
        OR (actln.len <= pos_cnt+from_pos-1))
    THEN
        BEGIN
        IF  (   (from_pos = firstchar)
            AND (offset   = firstchar)
            AND (actln.l[ from_pos ] <> x_ampersand))
        THEN
            BEGIN
            write_actline;
            clcount := clcount+1
            END
        ELSE
            print_text (from_pos, 0);
        (*ENDIF*) 
        read_text;
        END
    ELSE
        BEGIN
        IF  pos_cnt = -1
        THEN
            endpos_in_actln := from_pos
        ELSE
            endpos_in_actln := from_pos+pos_cnt;
        (*ENDIF*) 
        skipbl (begpos_in_actln, endpos_in_actln);
        IF  (   (actln.l[ endpos_in_actln ] = x_parenth_op)
            AND (actln.l[ endpos_in_actln+1 ]  = x_asterisk))OR
            (    actln.l[ endpos_in_actln ]  = x_curve_op)
        THEN
            BEGIN
            IF  actln.l[ endpos_in_actln ] <> x_curve_op
            THEN
                endpos_in_actln := endpos_in_actln+2;
            (*ENDIF*) 
            found := false;
            WHILE NOT found DO
                BEGIN
                IF  is_comment
                THEN
                    BEGIN
                    print_text ( from_ptr , actln.len+1- from_ptr );
                    read_text;
                    IF  offset - offsets[ push_depth-1 ] < in_continue
                    THEN
                        BEGIN
                        its_intended := true;
                        push (in_continue)
                        END;
                    (*ENDIF*) 
                    from_ptr := endpos_in_actln
                    END
                ELSE
                    BEGIN
                    REPEAT
                        endpos_in_actln := endpos_in_actln+1
                    UNTIL
                        (   ((actln.l[ endpos_in_actln-1 ] = x_asterisk)
                        AND  (actln.l[ endpos_in_actln ] = x_parenth_cl))
                        OR   (actln.l[ endpos_in_actln ] = x_curve_cl)
                        OR (endpos_in_actln > actln.len));
                    (*ENDREPEAT*) 
                    chr_count       := endpos_in_actln- from_ptr +1;
                    endpos_in_actln := endpos_in_actln+1;
                    found           := true;
                    skipbl (begpos_in_actln, endpos_in_actln);
                    IF  endpos_in_actln > actln.len
                    THEN
                        BEGIN
                        print_text ( from_ptr , chr_count);
                        BEGIN
                        read_text;
                        END;
                        END
                    ELSE
                        BEGIN
                        print_text ( from_ptr , chr_count);
                        begpos_in_actln := endpos_in_actln
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            IF  its_intended
            THEN
                pop
            (*ENDIF*) 
            END
        ELSE
            IF  (   (actln.l[ endpos_in_actln ]  = x_semicolon)
                AND (actln.l[ from_pos+pos_cnt-1 ]  <> x_semicolon))
            THEN
                BEGIN
                print_text (from_pos, endpos_in_actln-from_pos+1);
                IF  endpos_in_actln = actln.len
                THEN
                    BEGIN
                    read_text;
                    END
                ELSE
                    BEGIN
                    endpos_in_actln := endpos_in_actln+1;
                    begpos_in_actln := endpos_in_actln
                    END
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                print_text (from_pos, pos_cnt);
                IF  endpos_in_actln = actln.len+1
                THEN
                    BEGIN
                    read_text;
                    END;
                (*ENDIF*) 
                begpos_in_actln := endpos_in_actln
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    (*     IF  actln.l[ begpos_in_actln ] = x_ampersand *)
    (*     THEN *)
    (*         output_of_text (begpos_in_actln, 0); *)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      write_end_com (comment : tsp_name);
 
VAR
      j : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    clcount := clcount+1;
    s10fil(mxsp_line, outln.l, 1, offset-1, bsp_c1);
    c02putname(outln, offset,    cct_n_combeg);
    c02putname(outln, outln.len, comment);
    c02putname(outln, outln.len, cct_n_comend);
    write_linend;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      init;
 
VAR
      k          : integer;
      l          : integer;
      ddd        : tsp_date;
      ttt        : tsp_time;
      ord_little : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    c02init;
    actln.adr := @actln.l;
    outln.adr := @outln.l;
    hline.adr := @hline.l;
    c02linelength_init(mxsp_line);
    sqldattime ( ddd, ttt ) ;
    act_date        := ddd ;
    act_time        := ttt ;
    FOR l := 1 TO mxsp_line DO
        blankline[ l ] := bsp_c1;
    (*ENDFOR*) 
    outln.l         := blankline;
    outln.len       := 0;
    begpos_in_actln := 1;
    endpos_in_actln := 1;
    line_number     := 0;
    offsets[ 0 ]    := 1;
    its_a_case      := false;
    end_of_process  := false;
    in_proc_ctv     := false;
    intend_continue := true;
    is_comment      := false;
    clcount         := 0;
    ord_little      := ord('a')-ord('A');
    c11_digits      := [ '0'..'9' ] ;
    c11_capitals    := [ 'A'..'I', 'J'..'R', 'S'..'Z' ] ;
    c11_littles     := [ 'a'..'i', 'j'..'r', 's'..'z' ] ;
    little_digit_ul := c11_littles + c11_digits + [ x_underln ] ;
    signs           := c11_capitals + little_digit_ul + [ x_quote ];
    count           := 0;
    detected_errors := 0;
    infile_is_open  := false;
    its_frompart    := false;
    take_it         := true;
    offset          := 1;
    process_state   := do_searchvdn;
    is_keyword      := false;
    stcount         := 0;
    push_depth      := 1;
    keywords[ 1 ]   := n_if;
    keywords[ 2 ]   := n_do;
    keywords[ 3 ]   := n_or;
    keywords[ 4 ]   := n_to;
    keywords[ 5 ]   := n_of;
    keywords[ 6 ]   := cct_n_end;
    keywords[ 7 ]   := n_for;
    keywords[ 8 ]   := cct_n_var;
    keywords[ 9 ]   := n_not;
    keywords[ 10 ]  := n_set;
    keywords[ 11 ]  := n_and;
    keywords[ 12 ]  := n_mod;
    keywords[ 13 ]  := n_div;
    keywords[ 14 ]  := n_nil;
    keywords[ 15 ]  := n_then;
    keywords[ 16 ]  := n_else;
    keywords[ 17 ]  := n_case;
    keywords[ 18 ]  := n_type;
    keywords[ 19 ]  := cct_n_from;
    keywords[ 20 ]  := n_with;
    keywords[ 21 ]  := n_main;
    keywords[ 22 ]  := cct_n_begin;
    keywords[ 23 ]  := n_while;
    keywords[ 24 ]  := cct_n_const;
    keywords[ 25 ]  := n_until;
    keywords[ 26 ]  := n_array;
    keywords[ 27 ]  := n_label;
    keywords[ 28 ]  := n_repeat;
    keywords[ 29 ]  := n_record;
    keywords[ 30 ]  := n_downto;
    keywords[ 31 ]  := n_packed;
    keywords[ 32 ]  := cct_n_program;
    keywords[ 33 ]  := cct_n_function;
    keywords[ 34 ]  := cct_n_procedure;
    keywords[ 35 ]  := n_otherwise;
    FOR k := 1 TO 35 DO
        FOR l := 1 TO mxsp_name DO
            IF  keywords[ k, l ]  <> bsp_c1
            THEN
                keywords[ k, l ] := chr(ord(keywords[ k, l ] )+
                      ord_little);
            (*ENDIF*) 
        (*ENDFOR*) 
    (*ENDFOR*) 
    sqlresult(0); (* set the default - value *)
    sizecheck_cnt := 0;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      bprocess_block;
 
VAR
      next_word : tsp_line;
      k         : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    push_depth := 1;
    offset     := 1;
    catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
    IF  (  c11_compare (next_word, cct_n_procedure )
        OR c11_compare (next_word, cct_n_function ))
    THEN
        BEGIN
        c02putname(outln, 0, cct_n_combeg);
        c02putname(outln, outln.len, n_dash);
        c02putname(outln, outln.len, n_dash);
        c02putname(outln, outln.len, cct_n_comend);
        write_linend;
&       ifdef SCRIPT
        c02putname(outln, 0, n_script_cp);
        write_linend;
&       endif
        write_linend;
        clcount := clcount+2;
        IF  c11_compare (next_word, cct_n_procedure )
        THEN
            output_of_text (begpos_in_actln, 9)
        ELSE
            output_of_text (begpos_in_actln, 8);
        (*ENDIF*) 
        header(false);
        ctv;
        catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
        IF  c11_compare (next_word, cct_n_begin )
        THEN
            BEGIN
            count           := 1;
            endpos_in_actln := begpos_in_actln;
            sprocess_statement;
            count           := 0
            END
        ELSE
            write_errmsg(n_e_blank, 2)
        (*ENDIF*) 
        END
    ELSE
        IF  c11_compare (next_word, cct_n_program )
        THEN
            extra (true)
        ELSE
            IF  (   c11_compare (next_word, cct_n_begin )
                AND (its_prog = true))
            THEN
                extra (false)
            ELSE
                BEGIN
                endpos_in_actln := begpos_in_actln;
                IF  (  c11_compare (next_word, cct_n_const )
                    OR c11_compare (next_word, n_type )
                    OR c11_compare (next_word, n_label )
                    OR c11_compare (next_word, cct_n_var ))
                THEN
                    ctv
                ELSE
                    BEGIN
                    is_keyword := false;
                    write_errmsg(n_e_unbalanced, 16);
                    WHILE
                          (   NOT (c11_compare (next_word, cct_n_procedure))
                          AND NOT (c11_compare (next_word, cct_n_function))
                          AND NOT (c11_compare (next_word, cct_n_program))
                          AND NOT (c11_compare (next_word, cct_n_const))
                          AND NOT (c11_compare (next_word, n_label))
                          AND NOT (c11_compare (next_word, n_type))
                          AND NOT (c11_compare (next_word, cct_n_var))
                          AND NOT (c11_compare (next_word, cct_n_begin ) AND (its_prog = true))
                          ) DO
                        BEGIN
                        output_of_text (begpos_in_actln, 0);
                        catch_identifier (next_word, begpos_in_actln, endpos_in_actln)
                        END;
                    (*ENDWHILE*) 
                    endpos_in_actln := begpos_in_actln
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    write_linend;
    clcount := clcount+1;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      header (may_main : boolean);
 
VAR
      first_line : boolean;
      found_cnt  : tsp_int2;
      next_word  : tsp_line;
 
BEGIN
WITH c11_glob DO
    BEGIN
    push (in_proc);
    found_cnt  := 0;
    first_line := true;
    WHILE found_cnt = 0 DO
        BEGIN
        bracket_begin (found_cnt);
        IF  found_cnt = 2
        THEN (* x_parenth_op found*)
            BEGIN
            found_cnt       := 0;
            endpos_in_actln := endpos_in_actln+1;
            WHILE found_cnt <= 1 DO
                BEGIN
                bracket_end (found_cnt);
                output_of_text (begpos_in_actln, endpos_in_actln-
                      begpos_in_actln);
                IF  first_line
                THEN
                    BEGIN
                    push (in_continue);
                    first_line := false
                    END;
                (*ENDIF*) 
                IF  found_cnt = 3
                THEN
                    BEGIN
                    write_errmsg(n_e_blank, 2);
                    found_cnt       := 0;
                    endpos_in_actln := endpos_in_actln+1
                    END
                (*ENDIF*) 
                END
            (*ENDWHILE*) 
            END
        ELSE
            output_of_text (begpos_in_actln, endpos_in_actln-
                  begpos_in_actln);
        (*ENDIF*) 
        IF  first_line
        THEN
            BEGIN
            push (in_continue);
            first_line := false
            END
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    pop;
    catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
    endpos_in_actln := begpos_in_actln;
    IF  (c11_compare (next_word, n_main )  AND  may_main)
    THEN
        output_of_text (begpos_in_actln, 0);
    (*ENDIF*) 
    pop;
    write_linend;
    clcount := clcount+1;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      bracket_begin (VAR found_cnt : tsp_int2);
 
VAR
      its_the_end : boolean;
 
BEGIN
WITH c11_glob DO
    BEGIN
    its_the_end     := false;
    endpos_in_actln := endpos_in_actln-1;
    WHILE ((found_cnt = 0) AND  NOT its_the_end  AND
          (endpos_in_actln <= actln.len)) DO
        BEGIN
        endpos_in_actln := endpos_in_actln+1;
        IF  actln.l[ endpos_in_actln ] = x_parenth_op
        THEN
            IF  actln.l[ endpos_in_actln+1 ] = x_asterisk
            THEN
                BEGIN
                its_the_end := true;
                IF  begpos_in_actln = endpos_in_actln
                THEN
                    endpos_in_actln := endpos_in_actln-1
                (*ENDIF*) 
                END
            ELSE
                found_cnt := 2
            (*ENDIF*) 
        ELSE
            IF  actln.l[ endpos_in_actln ] = x_curve_op
            THEN
                found_cnt := 2
            ELSE
                IF  actln.l[ endpos_in_actln ] = x_semicolon
                THEN
                    BEGIN
                    found_cnt       := 1;
                    endpos_in_actln := endpos_in_actln+1
                    END
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      bracket_end (VAR found_cnt : tsp_int2);
 
VAR
      index : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    index := endpos_in_actln;
    WHILE ((found_cnt <= 0) AND (index <= actln.len)) DO
        BEGIN
        IF  actln.l[ index ] = x_parenth_cl
        THEN
            IF  index > 1
            THEN
                BEGIN
                IF  actln.l[ index-1 ] <> x_asterisk
                THEN
                    found_cnt := succ(found_cnt)
                (*ENDIF*) 
                END
            ELSE
                found_cnt := succ(found_cnt)
            (*ENDIF*) 
        ELSE
            IF  (actln.l[ index ] = x_curve_cl)
                OR (actln.l[ index ] = x_curve_op)
            THEN
                BEGIN
                END
            ELSE
                IF  actln.l[ index ] = x_parenth_op
                THEN
                    IF  actln.l[ index+1 ] <> x_asterisk
                    THEN
                        IF  found_cnt = 0
                        THEN
                            found_cnt := -1 (* procedure in parateter - list *)
                        ELSE
                            BEGIN
                            index     := index-2;
                            found_cnt := 3
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        index := index+1
        END;
    (*ENDWHILE*) 
    endpos_in_actln := index;
    WHILE ((found_cnt = 1) AND (index <= actln.len)) DO
        BEGIN
        IF  actln.l[ index ] = x_semicolon
        THEN
            BEGIN
            found_cnt       := 2;
            endpos_in_actln := index+1
            END;
        (*ENDIF*) 
        index := index+1
        END;
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      v_p_f (
            must_semi : boolean;
            may_from  : boolean;
            may_main  : boolean);
      (* 3rd parameter may be deleted later *)
      (* it seems to be unused in v_p_f     *)
 
VAR
      next_word : tsp_line;
      its_found : boolean;
 
BEGIN
WITH c11_glob DO
    BEGIN
    catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
    endpos_in_actln := begpos_in_actln;
    IF  (   NOT (c11_compare (next_word, cct_n_var))
        AND NOT (c11_compare (next_word, cct_n_procedure))
        AND NOT (c11_compare (next_word, cct_n_function))
        AND NOT (c11_compare (next_word, cct_n_program))
        AND NOT (c11_compare (next_word, cct_n_from ) AND may_from)
        )
    THEN
        BEGIN
        write_errmsg(n_e_notallowhere, 16);
        WHILE (   NOT (c11_compare (next_word, cct_n_var))
              AND NOT (c11_compare (next_word, cct_n_procedure))
              AND NOT (c11_compare (next_word, cct_n_function))
              AND NOT (c11_compare (next_word, cct_n_program)) ) DO
            BEGIN
            output_of_text (1, actln.len);
            catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
            END;
        (*ENDWHILE*) 
        endpos_in_actln := begpos_in_actln
        END;
    (*ENDIF*) 
    IF  c11_compare (next_word, cct_n_program )
    THEN
        BEGIN
        extra (true);
        catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
        endpos_in_actln := begpos_in_actln
        END;
    (*ENDIF*) 
    IF  c11_compare (next_word, cct_n_var )
    THEN
        ctv;
    (*ENDIF*) 
    catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
    WHILE (  c11_compare (next_word, cct_n_procedure )
          OR c11_compare (next_word, cct_n_function )) DO
        BEGIN
        output_of_text (begpos_in_actln, 9);
        IF  NOT must_semi
        THEN
            header(true)
        ELSE
            BEGIN
            its_found       := false;
            push (in_proc);
            endpos_in_actln := endpos_in_actln-1;
            WHILE ((NOT its_found) AND (endpos_in_actln < actln.len)) DO
                BEGIN
                endpos_in_actln := endpos_in_actln+1;
                IF  actln.l[ endpos_in_actln ] = x_semicolon
                THEN
                    its_found := true
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            IF  NOT its_found
            THEN
                BEGIN
                endpos_in_actln            := endpos_in_actln+1;
                actln.len                  := actln.len+1;
                actln.l[ endpos_in_actln ] := x_semicolon
                END;
            (*ENDIF*) 
            output_of_text (begpos_in_actln, endpos_in_actln -
                  begpos_in_actln + 1);
            pop;
            write_linend;
            clcount := clcount+1
            END;
        (*ENDIF*) 
        catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
        END;
    (*ENDWHILE*) 
    endpos_in_actln := begpos_in_actln;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ctv;
 
VAR
      next_word    : tsp_line;
      old_word     : tsp_line;
      int_record   : integer;
      its_a_record : boolean;
 
BEGIN
WITH c11_glob DO
    BEGIN
    in_proc_ctv := true;
    catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
    WHILE (  c11_compare (next_word, cct_n_const )
          OR c11_compare (next_word, n_type )
          OR c11_compare (next_word, n_label )
          OR c11_compare (next_word, cct_n_var )
          ) DO
        BEGIN
        its_a_record := false;
        IF  (  c11_compare (next_word, cct_n_const )
            OR c11_compare (next_word, n_label ) )
        THEN
            output_of_text (begpos_in_actln, 5)
        ELSE
            output_of_text (begpos_in_actln, 4);
        (*ENDIF*) 
        push (in_ctv);
        old_word := next_word;
        catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
        WHILE ( NOT (next_word[ 1 ] IN c11_capitals)) OR its_a_record DO
            BEGIN
            its_a_case  := false;
            IF  c11_compare (old_word, cct_n_const)
            THEN
                int_record := 0
            ELSE
                int_record := pos_resp_case (n_record, endpos_in_actln, 6);
            (*ENDIF*) 
            IF  int_record > 0
            THEN
                BEGIN
                IF  push_depth = 2
                THEN
                    write_linend;
                (*ENDIF*) 
                output_of_text (begpos_in_actln, int_record-begpos_in_actln+6);
                its_a_record := true;
                catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
                push (in_record)
                END;
            (*ENDIF*) 
            IF  c11_compare (next_word, n_case )
            THEN
                its_a_case := true;
            (*ENDIF*) 
            take_it         := false;
            endpos_in_actln := begpos_in_actln;
            sprocess_statement;
            take_it         := true;
            catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
            IF  its_a_record
            THEN
                IF  its_a_case
                THEN
                    BEGIN
                    its_a_case   := false;
                    its_a_record := false;
                    pop;
                    write_linend
                    END
                ELSE
                    WHILE c11_compare (next_word, cct_n_end) DO
                        BEGIN
                        pop;
                        is_keyword := false;
                        IF  actln.l[ endpos_in_actln ] = x_semicolon
                        THEN
                            endpos_in_actln := endpos_in_actln+1;
                        (*ENDIF*) 
                        output_of_text (begpos_in_actln, endpos_in_actln-
                              begpos_in_actln);
                        IF  ((push_depth = 2) OR (push_depth = 3))
                        THEN
                            BEGIN
                            its_a_record := false;
                            write_linend
                            END;
                        (*ENDIF*) 
                        catch_identifier (next_word, begpos_in_actln, endpos_in_actln)
                        END
                    (*ENDWHILE*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        IF  its_a_record
        THEN
            BEGIN
            pop;
            write_errmsg(n_e_missend, 13)
            END
        ELSE
            IF  ((NOT its_a_record) AND c11_compare (next_word, cct_n_end ))
            THEN
                BEGIN
                IF  actln.l[ endpos_in_actln ] = x_semicolon
                THEN
                    endpos_in_actln := endpos_in_actln+1;
                (*ENDIF*) 
                output_of_text (begpos_in_actln, endpos_in_actln-
                      begpos_in_actln);
                write_errmsg(n_e_missend, 13);
                catch_identifier (next_word, begpos_in_actln, endpos_in_actln)
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        pop;
        write_linend;
        clcount := clcount+1
        END;
    (*ENDWHILE*) 
    endpos_in_actln := begpos_in_actln;
    in_proc_ctv     := false;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      fprocess_from_part;
 
VAR
      next_word : tsp_line;
 
BEGIN
WITH c11_glob DO
    BEGIN
    catch_identifier (next_word, begpos_in_actln, endpos_in_actln);
    IF  c11_compare (next_word, cct_n_from )
    THEN
        BEGIN
        its_frompart := true;
        output_of_text (begpos_in_actln, 4);
        its_frompart := false;
        push (in_ctv);
        take_it      := false;
        sprocess_statement;
        pop;
        take_it      := true;
        write_linend
        END
    ELSE
        BEGIN
        write_errmsg(n_e_blank, 2);
        output_of_text (begpos_in_actln, endpos_in_actln-
              begpos_in_actln)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      extra (bool_parameter : boolean);
 
VAR
      j : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    IF  bool_parameter
    THEN
        BEGIN
        its_prog := true;
        output_of_text (begpos_in_actln, 7);
        header(false)
        END
    ELSE
        BEGIN
        endpos_in_actln := begpos_in_actln;
        count := 1;
        c02putname(outln, 0, cct_n_combeg);
        c02putname(outln, outln.len, n_dash);
        c02putname(outln, outln.len, n_dash);
        c02putname(outln, outln.len, cct_n_comend);
        write_linend;
&       ifdef SCRIPT
        c02putname(outln, 0, n_script_cp);
        write_linend;
&       endif
        write_linend;
        clcount := clcount+2;
        sprocess_statement;
        count   := 0;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      catch_vdn_name : boolean;
 
VAR
      func_result : boolean;
      i           : integer;
      j           : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    func_result := false;
    (* look for the line WITH the module-name  '.tt 1$...$VCT11$'  *)
    IF  c11_eq_ign_case ( actln, cct_n_tt1, 1)
    THEN
        BEGIN
        vdn_modul_name := bsp_c8;
        func_result    := true;
        i              := 1;
        j              := 0;
        REPEAT
            IF  actln.l[ i ] = x_dollar
            THEN
                j := succ(j);
            (*ENDIF*) 
            i := succ(i);
            (* the module-name is the third param OF .tt *)
        UNTIL
            (j = 3) OR (i > actln.len);
        (*ENDREPEAT*) 
        j := 1;
        WHILE  (actln.l[ i ] <> x_dollar) AND (i <= actln.len) DO
            BEGIN
            vdn_modul_name[ j ] := actln.l[ i ];
            i                   := succ(i);
            j                   := succ(j);
            END;
        (*ENDWHILE*) 
        END
    ELSE
        BEGIN
        (* look for the line with '.bt $Copyright...$$' *)
        (* Die 'Copyright'-Zeile wird jetzt nicht mehr von SCRIPT in   *)
        (* die Datei geschrieben, da wir jetzt zwei verschiedene Ver-  *)
        (* sionen fuer Release 2.4 und 3.0 haben (SAG + SQL) / (SAG).  *)
        (* Der Copyright-Vermerk wird vom XEDIT-Macro TT3 geschrieben. *)
        (* Erkennungszeichen in der Zeile ist das ',' vor der Jahresz. *)
        IF  c11_eq_ign_case (actln, n_bt, 1)
        THEN
            WITH actln DO
                BEGIN
                i := 1;
                WHILE  (actln.l[ i ] <> x_komma) AND (i <= actln.len) DO
                    i := succ(i);
                (*ENDWHILE*) 
                len           := i;
                l [ len + 1 ] := bsp_c1;
                l [ len + 2 ] := act_date [ 1 ];
                l [ len + 3 ] := act_date [ 2 ];
                l [ len + 4 ] := act_date [ 3 ];
                l [ len + 5 ] := act_date [ 4 ];
                len           := len + 5;
                c02putname (actln, 0, n_page);
                l [ len ]     := bsp_c1;
                len           := pred (len);
&               ifdef debug
                writeln ('actln.len = ', actln.len);
                writeln ('actln.l   =>', actln.l, '<');
                write   ('actln.l   =>');
                FOR i := 1 TO actln.len DO
                    write('+');
                (*ENDFOR*) 
                writeln ('<');
&               endif
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    catch_vdn_name := func_result
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      write_line_count;
 
VAR
      i            : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    c02putname (outln, 0, cct_n_sp2);
    write_linend;
    actln.len      := 59;
    s10fil(mxsp_line, actln.l, 1, actln.len, '*');
    write_actline;
    (*           statements  *)
    actln.l        := blankline;
    c02putname( actln, 1, cct_n_prettyspec);
    actln.len      := 12;
    c02putname( actln, 0, cct_n_statements);
    c02int4to_line(stcount, false, 10, succ(actln.len), actln.l);
    actln.len      := actln.len + 10;
    write_actline;
    (*           lines_of_code  *)
    actln.l        := blankline;
    actln.len      := 0;
    c02putname( actln, 0, cct_n_prettyspec);
    actln.len      := 12;
    c02putname( actln, 0, cct_n_lines_of_code);
    c02int4to_line(clcount, false, 10, succ(actln.len), actln.l);
    actln.len      := actln.len + 10 + c_dist_prettvers;
    c02putname(actln, 0, n_vct_version);
    write_actline;
    (* --------- lines_in_file  *)
    actln.l        := blankline;
    c02putname( actln, 1, cct_n_prettyspec);
    actln.len      := 12;
    c02putname( actln, 0, cct_n_lines_in_file);
    c02int4to_line(line_number+2, false, 10, actln.len+1, actln.l);
    actln.len      := actln.len + 10 + c_dist_prettvers;
    c02putname(actln, 0, n_vct_date);
    write_actline;
    (* --------- .pa  *)
    c02putname (outln, 0, cct_n_pa);
    write_linend;
    stcount        := 0;
    clcount        := 0;
    end_of_process := true;
    process_state  := do_workend;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      write_actline;
 
BEGIN
WITH c11_glob DO
    BEGIN
    outln.l   := actln.l;
    outln.len := actln.len;
    actln.len := 0;
    write_linend;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      write_char (character : CHAR);
 
BEGIN
WITH c11_glob, outln DO
    BEGIN
    len      := succ(len);
    l[ len ] := character;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      write_linend;
 
VAR
      b_len : integer;
      first : integer;
      i     : integer;
      line_ok : boolean;
 
BEGIN
WITH c11_glob, outln DO
    BEGIN
    line_number := succ(line_number);
    line_ok     := true;
    IF  len = 0
    THEN
        BEGIN
        len    := 1;
        l[ 1 ] := bsp_c1;
        END
    (*==========*)
    ELSE
        BEGIN
        (*           ** check the non_null line ** *)
        IF  check_linelength AND (len > maxpascallinelen)
        THEN
            BEGIN
            first := 0;
            b_len := len - maxpascallinelen;
            FOR i := 1 TO b_len + 1 DO
                IF  ((l[ i ] <> bsp_c1) AND (first = 0))
                THEN
                    first := i;
                (*ENDIF*) 
            (*ENDFOR*) 
            IF  (first <> 0) AND (first <= b_len)
            THEN
                line_ok := false;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    (*ENDIF*) 
    (*==========*)
    ;
    c02vfwrite(outfile, outln);
    IF  NOT(line_ok)
    THEN
        write_errmsg(n_e_longline, 17);
    (*ENDIF*) 
    len := 0;
    l   := blankline;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      close_files;
 
VAR
      dummy : boolean;
 
BEGIN
WITH c11_glob DO
    BEGIN
    (* IF not do_workend THEN write error into the error_file *)
    IF  NOT (c02process_state_ok (process_state, c02outf))
    THEN
        BEGIN
        sqlresult(11);
        write_linend;
        (* ... write error to bottom of '<fn> PRETTY' *)
        dummy := c02process_state_ok (process_state, outfile);
        END;
    (*ENDIF*) 
    sqlfclose (c02outf, (detected_errors = 0), 0, 0,
          bufadr, ferr, ferr_text);
    IF  infile_is_open
    THEN
        BEGIN
        sqlfclose (infile,  false, 0, 0, bufadr, ferr, ferr_text);
        sqlfclose (outfile, false, 0, 0, bufadr, ferr, ferr_text);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      get_option (VAR args : tsp_line);
 
VAR
      begpos  : tsp_int2;
      argln   : tct_line;
      option1 : tsp_name;
 
BEGIN
WITH  c11_glob  DO
    BEGIN
    argln.l        := args;
    argln.len      := s30klen(args, bsp_c1, mxsp_line);
    intend_cclines := true;
    (*      1.: check for a '('         *)
    begpos         := 1;
    begpos         := c02chrpos(argln, begpos, '(');
    IF  begpos <> 0
    THEN
        BEGIN
        (*      2.: get the option 1        *)
        begpos := succ(begpos);
        WHILE (args[ begpos ] = bsp_c1)
              AND (argln.len > begpos)
              DO
            begpos := succ(begpos);
        (*ENDWHILE*) 
        c02getword(argln, begpos, option1);
        (* ******************************************* *)
        (*      for later use (2nd option, .. ]       *)
        (* IF  (option1 <> blankname) THEN BEGIN *)
        (* WHILE (args[ begpos ] = blank) *)
        (* AND (argln.len > begpos) DO *)
        (* begpos := succ(begpos); *)
        (* c02_getword(argln, begpos, option2) END *)
        (* ******************************************* *)
        END
    ELSE
        BEGIN
        option1    := bsp_name;
        (* option2 := blankname; *)
        END;
    (*ENDIF*) 
    name_line := n_opt_noblank;
    IF  c02equal_string (option1, name_line)
    THEN
        intend_cclines := false
    ELSE
        intend_cclines := true;
    (*ENDIF*) 
&   IF $OS = UNIX
    (* Differenzen zw. langsamem und schnellem System !!! *)
    (* Also gibt es erst mal keinen Unterschied !      CS *)
    intend_cclines := true;
&   ENDIF
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      open_files : boolean;
 
VAR
      i           : tsp_int4;
      argl        : tsp_line;
      pretty_fn   : tsp_vfilename;
      source_fn   : tsp_vfilename;
      error_fn    : tsp_vfilename;
      func_result : boolean;
      reclen      : tsp_int4;
      errtext     : tsp_errtext;
      error       : boolean;
      format      : tsp_vf_format;
 
BEGIN
WITH  c11_glob  DO
    BEGIN
    sqlargl  (argl);
    get_option (argl);
    i         := 1;
    ferr      := vf_ok;
    error_fn  := bsp_c64;
    name_line := n_ftm_error;
    c02fncat (error_fn, argl, i, name_line, l_ftm_error);
    (* try to open the error - file *)
    format := vf_plaintext;
    reclen := 0;
    sqlfopen (error_fn, voverwrite, vf_stack, c02outf, format,
          reclen, 0, 0, bufadr, ferr,ferr_text);
    IF  (ferr = vf_ok)
    THEN
        BEGIN
        i         := 1;
        reclen    := 0;
        name_line := n_ftm_source;
        source_fn := bsp_c64;
        c02fncat (source_fn, argl, i, name_line, l_ftm_source);
        (* try to open the input-file *)
        sqlfopen (source_fn, vread, vf_stack, infile, format,
              reclen, 0, 0, bufadr, ferr,ferr_text);
        IF  (ferr = vf_ok)
        THEN
            BEGIN
            i          := 1;
            reclen     := 0;
            name_line  := n_ftm_pretty;
            pretty_fn  := bsp_c64;
            c02fncat (pretty_fn, argl, i, name_line, l_ftm_pretty);
            (* try to open the output-file *)
            sqlfopen (pretty_fn, voverwrite, vf_stack, outfile, format,
                  reclen, 0, 0, bufadr, ferr,ferr_text);
            IF  (ferr = vf_ok)
            THEN
                BEGIN
                func_result := true;
                END
            ELSE
                BEGIN
                func_result := false;
                END
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            func_result := false;
            write_errmsg ('in_file not found.', 18);
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        func_result := false;
        END;
    (*ENDIF*) 
    open_files     := func_result;
    infile_is_open := func_result;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      write_errmsg (errline : tsp_name; errlen : integer);
 
VAR
      out          : tct_line;
      i            : integer;
 
BEGIN
WITH c11_glob, out DO
    BEGIN
    out.adr := @out.l;
    IF  detected_errors = 0
    THEN
        BEGIN
        (* initialise the error file *)
        name_line  := n_init_error;
        s10mv1(mxsp_name, mxsp_line, name_line, 1, l, 1, 18);
        s10fil(mxsp_line, l, 19, 24, '_');
        out.len := 42;
        c02vfwrite (c02outf, out);
        l[ 1 ]  := bsp_c1;
        out.len := 1;
        c02vfwrite (c02outf, out);
        sqlresult(11);
        END;
    (*ENDIF*) 
    line_number    := succ(line_number);
    (* write the line_number and the err_msg into the error-file *)
    c02int4to_line ( line_number, false, 5, 1, l);
    l[ 6 ]         := bsp_c1;
    l[ 7 ]         := x_colon;
    l[ 8 ]         := bsp_c1;
    l[ 9 ]         := bsp_c1;
    len            := 9;
    s10mv1( mxsp_name, mxsp_line, errline, 1, l, len+1, errlen);
    len            := len+errlen;
    c02vfwrite (c02outf, out);
    detected_errors := succ(detected_errors);
    IF  infile_is_open
    THEN
        BEGIN
        (* write the err_msg into the output-file *)
        clcount    := succ(clcount);
        len        := offset-1;
        s10fil(mxsp_line, l, 1, len, bsp_c1);
        name_line  := cct_n_combeg;
        s10mv1( mxsp_name, mxsp_line, name_line, 1, l, offset, 2);
        len        := len+2;
        name_line  := cct_n_error;
        s10mv1( mxsp_name, mxsp_line, name_line, 1, l, succ(len), 12);
        len        := len+12;
        s10mv1( mxsp_name, mxsp_line, errline, 1, l, succ(len), errlen);
        len        := len+errlen;
        name_line  := cct_n_comend;
        s10mv1( mxsp_name, mxsp_line, name_line, 1, l, succ(len), 2);
        len        := len+2;
        c02vfwrite (outfile, out);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      cpprocess_code_part;
 
VAR
      scan_part : boolean;
      i : integer;
 
BEGIN
WITH c11_glob DO
    BEGIN
    offset         := 1;
    push_depth     := 1;
    stcount        := 0;
    clcount        := 0;
    write_actline;
    is_comment     := false;
    take_it        := true;
    read_text;
    IF  pos_ign_case (n_pretty, 1, 6) = 0
    THEN
        BEGIN
        outln.len  := 0;
        write_linend;
        write_linend;
        (* process the code-part of a pascal source file *)
        (*         or the structure-part of a file *)
        WHILE true DO
            BEGIN
            bprocess_block
            END
        (*ENDWHILE*) 
        END
    ELSE
        BEGIN
        (* ======================================== *)
        (* this part must'n be processed by PRETTY  *)
        (* (i.e. the CODE-part of an ASSEMBLER file *)
        (* or a STRUCTURE-part with english words.  *)
        (* ======================================== *)
        scan_part      := true;
        check_linelength := false;
        write_actline;
        WHILE (   NOT (ferr = vf_eof)
              AND NOT (end_of_process)
              AND scan_part   ) DO
            BEGIN
            read_one_line;
            IF  c11_eq_ign_case ( actln, cct_n_cm, 1)
                AND (c02strpos(actln, cct_n_endpart) > 4)
            THEN
                BEGIN
                (* this should be the end of the structure | code-part *)
                IF  c02strpos(actln, n_code_w) > 12
                THEN
                    BEGIN
                    (* this is the end of the code-part *)
                    write_actline;
                    write_line_count;
                    END
                ELSE
                    BEGIN
                    (* this must be the end of the structure-part *)
                    write_actline;
                    scan_part := false;
                    END;
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  c11_eq_ign_case ( actln, cct_n_pa, 1)
                THEN
                    BEGIN
                    write_line_count;
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  (   (NOT  equal_resp(actln.l, cct_n_prettyspec, 1, 10))
                AND  NOT (end_of_process)  AND  scan_part )
            THEN
                BEGIN
                write_actline;
                stcount := succ(stcount);
                clcount := succ(clcount)
                END
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      sequential_program;
 
VAR
      m          : integer;
      l          : integer;
      lp         : integer;
      its_ok     : boolean;
      first_line : boolean;
      next_word  : tsp_line;
 
BEGIN
WITH c11_glob DO
    BEGIN
    WHILE ((NOT (ferr = vf_eof)) AND (NOT end_of_process)) DO
        BEGIN
        read_one_line;
        cond_output := 0;
        check_linelength := false;
        CASE process_state OF
            do_searchvdn :
                BEGIN
                (* catch_vdn replaces the date in the '.bt Copyright'  *)
                (* the line '.bt $...$' must be in front of '.tt 1 ... *)
                IF  catch_vdn_name
                THEN
                    process_state := do_searchdef;
                (*ENDIF*) 
                write_actline
                END;
            do_searchdef :
                IF  NOT c11_eq_ign_case (actln, cct_n_define, 1)
                THEN
                    write_actline
                ELSE
                    BEGIN
                    process_state := do_searchuse;
                    check_linelength := true;
                    cond_output   := 7;
                    output_of_text (1, 9);
                    push (in_usedef );
                    write_linend;
                    IF  ((vdn_modul_name[ 4 ] = '0') AND (vdn_modul_name[ 5 ] = '0'))
                    THEN
                        ctv
                    ELSE
                        v_p_f (false, false, true);
                    (*ENDIF*) 
                    pop;
                    offset        := 1;
                    push_depth    := 1;
                    write_actline
                    END;
                (*ENDIF*) 
            do_searchuse :
                IF  NOT c11_eq_ign_case ( actln, cct_n_use, 1)
                THEN
                    write_actline
                ELSE
                    BEGIN
                    process_state := do_searchsyn;
                    check_linelength := true;
                    cond_output   := 7;
                    first_line    := true;
                    offset        := 1;
                    push_depth    := 1;
                    output_of_text (1, 9);
                    push (in_usedef );
                    write_linend;
                    WHILE true DO
                        BEGIN
                        IF  NOT first_line
                        THEN
                            BEGIN
                            (* write a dash-line between two different modules *)
                            s10fil(mxsp_line, outln.l, 1, 7, bsp_c1);
                            outln.len := 7;
                            c02putname(outln, outln.len, n_dash);
                            c02putname(outln, outln.len, n_dash);
                            write_linend;
                            write_linend;
                            END;
                        (*ENDIF*) 
                        first_line := false;
                        fprocess_from_part;
                        v_p_f (false, true, false)
                        END;
                    (*ENDWHILE*) 
                    END;
                (*ENDIF*) 
            do_searchsyn :
                IF  NOT c11_eq_ign_case ( actln, cct_n_synonym, 1)
                THEN
                    write_actline
                ELSE
                    BEGIN
                    process_state := do_searchversion;
                    check_linelength := true;
                    offset        := 1;
                    push_depth    := 1;
                    output_of_text (1, 9);
                    push (in_usedef );
                    write_linend;
                    WHILE true DO
                        BEGIN
                        v_p_f(true, false, false);
                        push (in_proc);
                        catch_identifier (next_word, begpos_in_actln,
                              endpos_in_actln);
                        endpos_in_actln := begpos_in_actln;
                        WHILE (   NOT (c11_compare (next_word, cct_n_procedure))
                              AND NOT (c11_compare (next_word, cct_n_function))) DO
                            BEGIN
                            output_of_text (begpos_in_actln, actln.len);
                            catch_identifier (next_word, begpos_in_actln,
                                  endpos_in_actln);
                            endpos_in_actln := begpos_in_actln
                            END;
                        (*ENDWHILE*) 
                        write_linend;
                        pop
                        END
                    (*ENDWHILE*) 
                    END;
                (*ENDIF*) 
            do_searchversion :
                IF  NOT c11_eq_ign_case ( actln, cct_n_version, 1)
                THEN
                    write_actline
                ELSE
                    BEGIN
                    (* change the date in this line to the actual date *)
                    actln.l[ 10 ] := bsp_c1;
                    actln.l[ 11 ] := act_date [ 1 ];
                    actln.l[ 12 ] := act_date [ 2 ];
                    actln.l[ 13 ] := act_date [ 3 ];
                    actln.l[ 14 ] := act_date [ 4 ];
                    actln.l[ 15 ] := x_hyphen;
                    actln.l[ 16 ] := act_date [ 5 ];
                    actln.l[ 17 ] := act_date [ 6 ];
                    actln.l[ 18 ] := x_hyphen;
                    actln.l[ 19 ] := act_date [ 7 ];
                    actln.l[ 20 ] := act_date [ 8 ];
                    actln.len     := 20;
                    write_actline;
                    process_state := do_searchstruct;
                    END;
                (*ENDIF*) 
            do_searchstruct :
                IF  NOT c11_eq_ign_case ( actln, cct_n_structure, 1)
                THEN
                    write_actline
                ELSE
                    BEGIN
                    (* the structure-part should be processed like the code_part *)
                    (* because the 'pseudo-code' has to be pretty, too. *)
                    process_state := do_searchcode;
                    cpprocess_code_part;
                    END;
                (*ENDIF*) 
            do_searchcode :
                IF  NOT c11_eq_ign_case ( actln, cct_n_code, 1)
                THEN
                    write_actline
                ELSE
                    BEGIN
                    process_state := do_prettyresult;
                    check_linelength := true;
                    (* make the code-part pretty ... *)
                    cpprocess_code_part;
                    END;
                (*ENDIF*) 
            do_prettyresult :
                BEGIN
                process_state     := do_workend;
                write_line_count;
                END;
            do_workend :
                BEGIN
                END
            END
        (*ENDCASE*) 
        END;
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
END;
 
(*-  m a i n    p r o g r a m  -*)
(*------------------------------*) 
 
BEGIN
& if $OS = WIN32 
WinArgc := __argc;
WinArgv := __argv;
& endif
init;
IF  open_files
THEN
    sequential_program
ELSE
    sqlresult(11);
(*ENDIF*) 
(*    label 20 removed *)
(*    label 10 removed *)
&if $OS = VMSP
(* see comment at the label-definition at top of code *)
9999 :;
close_files;
sqlfinish(true);
&else
(* label 9999 removed *)
&endif
END
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
*-PRETTY-*  statements    :       1359
*-PRETTY-*  lines of code :       3688        PRETTY  3.09 
*-PRETTY-*  lines in file :       3987         1992-11-23 
.PA 
