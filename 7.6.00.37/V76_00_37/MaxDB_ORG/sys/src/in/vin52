.CM  SCRIPT , Version - 1.1 , last edited by E.Stils
.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VIN52$
.tt 2 $$$
.TT 3 $$Logical Screen - Variants$1998-05-28$
***********************************************************
.nf
 
.nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : logical_screen_variants
=========
.sp
Purpose : Logical Screen: Environment Dependent Procedures
.sp
&       if $OS=UNIX
&          define hifmode 1
&       else
&          ifdef WINDOWS
&             define hifmode 1
&          else
&             if $OS=MSDOS
&                define pcmode 1
&             endif
&          endif
&       endif
.CM *-END-* purpose -------------------------------------
.sp
Define  :
 
&       ifdef pcmode
        VAR
              i52pcfkey    : tsp00_VtKey;
              i52pcffct    : tin_ls_releasemode;
              i52funclabel : boolean;
              i52callevel  : integer;
&       endif
 
        PROCEDURE
              i52init;
 
        PROCEDURE
              i52pfkeymap;
&       ifdef PCMODE
 
        PROCEDURE
              i52pckeymap;
&       endif
&       ifdef hifmode
 
        PROCEDURE
              i52skkeymap;
&       endif
&       ifdef WINDOWS
 
        PROCEDURE
              i52winlayout (
                    inputarea_length : tin_natural;
                    msglines         : tin_natural);
&       else
&       ifdef PCMODE
 
        PROCEDURE
              i52pclayout (
                    workarea_length     : tsp00_Int2;
                    functionmenu_length : tin_natural;
                    inputarea_length    : tin_natural;
                    msglines            : tin_natural);
&       else
 
        PROCEDURE
              i52ibmlayout (
                    workarea_length     : tsp00_Int2;
                    functionmenu_length : tin_natural;
                    inputarea_length    : tin_natural;
                    msglines            : tin_natural);
 
        PROCEDURE
              i52unixlayout (
                    workarea_length     : tsp00_Int2;
                    functionmenu_length : tin_natural;
                    inputarea_length    : tin_natural;
                    msglines            : tin_natural);
&       ifdef hifmode
 
        PROCEDURE
              i52sklayout (
                    workarea_length  : tsp00_Int2;
                    inputarea_length : tin_natural;
                    msglines         : tin_natural);
&       endif
&       endif
&       endif
&       ifdef hifmode
 
        PROCEDURE
              i52skmenu (
                    VAR hif : tsp00_HifParms);
&       endif
 
        PROCEDURE
              i52pflabels (
                    fct_cursorpos      : tin_ls_releasemode;
                    functionline_label : boolean);
&       ifdef pcmode
 
        PROCEDURE
              i52pclabels (
                    VAR fct            : tin_ls_releasemode;
                    opt                : tin_menu_comment;
                    functionline_label : boolean);
&       endif
 
        FUNCTION
              i52pffunction (
                    fno : integer) : tin_ls_releasemode;
 
        PROCEDURE
              i52activekeys (
                    VAR active_keys : tsp00_VtKeys);
 
        PROCEDURE
              i52keysettrans (
                    VAR inp : tin_ls_key_set;
                    VAR res : tsp00_VtKeys);
 
        FUNCTION
              i52keytrans (
                    rf : tin_ls_releasemode) : tsp00_VtKey ;
 
        FUNCTION
              i52rf (
                    rk : tsp00_VtKey) : tin_ls_releasemode;
 
        PROCEDURE
              i52mfset (
                    VAR msgnos : tin_msgnos);
 
        PROCEDURE
              i52lsmsg (
                    msgno        : integer;
                    VAR textline : tin_screenline;
                    VAR length   : tin_natural);
 
        PROCEDURE
              i52substmsg (
                    msgno        : integer;
                    VAR textline : tin_screenline;
                    VAR length   : tin_natural);
 
        PROCEDURE
              i52fromscreenpos (
                    VAR pos       : tin_ls_position;
                    VAR screenlno : tin_natural;
                    VAR screencol : tin_natural);
 
        PROCEDURE
              i52toscreenpos (
                    lno            : tin_natural;
                    col            : tin_natural;
                    preferred_part : tin_ls_part;
                    VAR pos        : tin_ls_position);
 
        FUNCTION
              in5230 : tsp00_Int4;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              global_variable : VIN01;
 
        VAR
              i01g : tin_global_in_vars;
&       ifdef pcmode
 
      ------------------------------ 
 
        FROM
              menu_io : VIN65;
 
        PROCEDURE
              i65menu (
                    VAR menu        : tin_screenline;
                    menu_length     : integer;
                    VAR comments    : shortbuffer;
                    comments_length : integer;
                    VAR parms       : tin_menu_display_option;
                    VAR res         : tin_menu_returnparms);
 
      ------------------------------ 
 
        FROM
              get_config_values : VIN66P;
 
        PROCEDURE
              i66config (
                    VAR fn     : tsp00_VFilename;
                    VAR result : pc_config_list);
&       endif
 
      ------------------------------ 
 
        FROM
              Code-Translation : VIN32 ;
 
        FUNCTION
              i32toupper (
                    c : char ) : char;
 
        FUNCTION
              i32tolower (
                    c : char ) : char;
 
        PROCEDURE
              i32deftranstables(
                    VAR ig : tin_global_in_record);
 
      ------------------------------ 
 
        FROM
              logical_screen : VIN50;
 
        PROCEDURE
              i50clear (
                    screen_part : tin_ls_part );
 
      ------------------------------ 
 
        FROM
              logical_screen_layout : VIN51;
 
        PROCEDURE
              i51size (
                    screen_part    : tin_ls_part;
                    VAR partlength : tin_natural;
                    VAR partwidth  : tin_natural);
 
      ------------------------------ 
 
        FROM
              logical_screen_procedures : VIN53;
 
        PROCEDURE
              i53changelimits (
                    sno   : tsp00_Int2;
                    rowno : tsp00_Int2);
 
        PROCEDURE
              i53put1field (
                    VAR field        : tin_screenline;
                    length           : integer;
                    sno              : tsp00_Int2;
                    field_slno       : integer;
                    field_scol       : integer;
                    VAR ft           : tin_ls_fieldtype;
                    maxlines,maxcols : integer;
                    vt_screen        : tsp00_ScreenBufAddr;
                    vt_att           : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53put2field (
                    VAR field        : tsp00_C12;
                    length           : integer;
                    sno              : tsp00_Int2;
                    field_slno       : integer;
                    field_scol       : integer;
                    VAR ft           : tin_ls_fieldtype;
                    maxlines,maxcols : integer;
                    vt_screen        : tsp00_ScreenBufAddr;
                    vt_att           : tsp00_ScreenBufAddr);
 
      ------------------------------ 
 
        FROM
              logical_screen_help_procedures : VIN54;
 
        PROCEDURE
              i54resolvedefaults (
                    part           : tin_ls_part;
                    VAR field_type : tin_ls_fieldtype);
&       ifdef PCMODE
 
        PROCEDURE
              i54changewidth (
                    part : tin_ls_part;
                    diff : tsp00_Int2);
&       endif
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;       
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;    
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;    
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30klen (
                    VAR str : tin_ls_sk_label;
                    val     : char; cnt : integer) : integer;
 
        FUNCTION
              s30lnr1 (
                    VAR str : tsp00_C40;
                    val     : char;
                    start   : tsp00_Int4;
                    cnt     : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              RTE_driver : VEN102 ;
 
        PROCEDURE
              sqlabort;
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              s30lnr1;
 
              tsp00_MoveObj tsp00_C40
 
        PROCEDURE
              i65menu;
 
              tsp00_Buf tin_screenline
 
        PROCEDURE
              i53put1field;
 
              tsp00_MoveObj tin_screenline
 
        PROCEDURE
              i53put2field;
 
              tsp00_MoveObj tsp00_C12
 
        FUNCTION
              s30klen;
 
              tsp00_MoveObj tin_ls_sk_label
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1986-08-29
.sp
.cp 3
.sp
.cp 3
Release :      Date : 1998-05-28
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
Dieser Modul enth?alt Prozeduren des Logischen Bildschirms, die
umgebungsabh?angig sind.
.sp;Es ist m?oglich, da?z dieser Modul noch um einige dieser
Prozeduren f?ur andere Umgebungen erweitert wird.
.sp 2;.cp 12;.nf
PROCEDURE
      i52init;
.sp 2;.fo
Initialisierung dieses Moduls.
.sp 2;.cp 12;.nf
PROCEDURE
      i52pfkeymap;
.sp 2;.fo
Belegt die Zuordnungstabelle zwischen den PF-Tasten des Virtuellen
Terminals
und den logischen Terminalfunktionen des Logischen Bildschirms
f?ur IBM-Umgebungen (VM, DOS, MVS usw ]
.sp 2;.cp 12;.nf
PROCEDURE
      i52pckeymap;
.sp 2;.fo
Belegt die Zuordnungstabelle zwischen den Funktionstasten des Virtuellen
Terminals
und den logischen Terminalfunktionen des Logischen Bildschirms
f?ur PC-Umgebungen (MS-DOS).
.sp 2;.cp 12;.nf
PROCEDURE
      i52skkeymap;
.sp 2;.fo
Belegt die Zuordnungstabelle zwischen den Softkeys des Virtuellen
Terminals
und den logischen Terminalfunktionen des Logischen Bildschirms
f?ur Unix-Umgebungen.
.sp 2;.cp 12;.nf
PROCEDURE
      i52ibmlayout (
            functionmenu_length : ti_natural;
            inputarea_length    : ti_natural);
.sp 2;.fo
Richtet die logischen Bildschirmbereiche f?ur IBM-Umgebungen ein.
.sp 2;.cp 12;.nf
PROCEDURE
      i52unixlayout (
            functionmenu_length : ti_natural;
            inputarea_length    : ti_natural);
.sp 2;.fo
Richtet die logischen Bildschirmbereiche f?ur Unix-Umgebungen
(ohne Softkeys) ein.
.sp 2;.cp 12;.nf
PROCEDURE
      i52sklayout (
            inputarea_length : ti_natural);
.sp 2;.fo
Richtet die logischen Bildschirmbereiche f?ur Unix-Umgebungen
(mit Softkeys) ein.
.sp 2;.cp 12;.nf
PROCEDURE
      i52skmenu (
            VAR hif : hif_parms);
.sp 2;.fo
bereitet das Softkey-Men?u f?ur die Ausgabe durch i05_io_screen vor.
.sp 2;.cp 12;.nf
PROCEDURE
      i52pflabels (
            fct_cursorpos : ti_ls_releasemode;
 
                  functionline_label  : boolean);
 
.sp 2;.fo
schreibt die entsprechenden Felder f?ur die PF-Tasten-Labels in die
Bildschirmpuffer.
.sp 2;.cp 12;.nf
PROCEDURE
      i52pclabels (
            fct_cursorpos : ti_ls_releasemode);
.sp 2;.fo
schreibt die entsprechenden Felder f?ur die Funktionstasten-Labels in die
Bildschirmpuffer.
Im Gegensatz zu den PF-Labels wird vor die Tatennr. ein "F" geschrieben,
wie bei PCs ?ublich. ("F1=Help")
.sp 2;.cp 12;.nf
PROCEDURE
      i52activekeys (
            VAR active_keys : vt_keys);
.sp 2;.fo
liefert einen SET der Terminal-Tasten zur?uck,
die aktivierten Bildschirmfunktionen entsprechen.
.sp 2;.cp 12;.nf
FUNCTION
      i52rf (
            rk : ti_vt_releasemode) : ti_ls_releasemode;
.sp 2;.fo
Zuordnung von Terminal-Tasten zu log. Bildschirmfunktionen
abh. von der Umgebung.
.sp 2;.cp 12;.nf
PROCEDURE
      i52lsmsg (
            msgno        : integer;
                  VAR textline : ti_screenline;
                  VAR length   : ti_natural);
.sp 2;.fo
(nur intern f?ur VIN50) liefert eine Meldungszeile f?ur den Bildschirm-
aufbau (z.B. Systemname) zur?uck.
.sp 2;.cp 12;.nf
PROCEDURE
      i52fromscreenpos (
            VAR pos       : ti_ls_position;
                  VAR screenlno : ti_natural;
                  VAR screencol : ti_natural);
.sp 2;.fo
rechnet logische Bildschirmpositionen in absolute Positionen um.
.sp 2;.cp 12;.nf
PROCEDURE
      i52toscreenpos (
            lno     : ti_natural;
            col     : ti_natural;
            VAR pos : ti_ls_position);
.sp 2;.fo
Umkehrung von i52fromscreenpos.
.sp 2;.cp 12;.nf
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
 
Code    :
 
 
CONST
      mx_shortbuffer = 1024;
      maxpflines = 2;
      nr_pfkeys = 12;
      blank12    = '            ';
      (* ls_msgno *)
      msg_menu_label = 0;
      msg_undef = 1;
      msg_sysname = 2;
      msg_commands_msg = 3;
      msg_commands_label = 4;
      msg_commandline    = 6;
      msg_exitdialog     = 7;
      (* *)
 
TYPE
      pfcount = 1..nr_pfkeys;
 
      text12 = RECORD
            len : tin_natural;
            txt : tsp00_C12;
      END;
 
 
      text8 = RECORD
            len : tin_natural;
            txt : tsp00_C8;
      END;
 
      shortbuffer = PACKED ARRAY [ 1 .. mx_shortbuffer ] OF char;
 
      comments_rec = RECORD
            len : tsp00_Int2;
            buf : shortbuffer;
      END;
 
 
      internal_pftab_comp = RECORD
            pf_nr     : pfcount;
            highlight : boolean;
            CASE boolean OF
                true :
                    (menu_item_12 : text12);
                false:
                    (menu_item_8  : text8);
                END;
            (*ENDCASE*) 
 
 
      internal_pftab = RECORD
            tab : ARRAY [  pfcount ] OF internal_pftab_comp;
            tablen : 0..nr_pfkeys;
            last_on_first_line : 0..nr_pfkeys;
      END;
 
      layout_order = ARRAY [  1..3  ] OF cin_ls_inputarea .. cin_ls_sysline;
      save_lines = ARRAY [1..4 ] OF tin_screenline;
&     ifdef PCMODE
 
VAR
      i52menu     : tsp00_String;
      i52comments : comments_rec;
&     endif
 
 
(*------------------------------*) 
 
FUNCTION
      in5230 : tsp00_Int4;
 
BEGIN
(* linkcheck function *)
in5230 := 219020525;
END; (* in5230 *)
 
(*------------------------------*) 
 
PROCEDURE
      i52init;
 
BEGIN
i32deftranstables( i01g^ );
&ifdef PCMODE
i52menu.length := 0;
&endif
END; (* i52init *)
 
(*------------------------------*) 
 
PROCEDURE
      i52pfkeymap;
 
BEGIN
WITH i01g^.key_type DO
    BEGIN
    key_map [f1 ] := vt_pf05;
    key_map [f2 ] := vt_pf09;
    key_map [f3 ] := vt_pf12;
    key_map [f4 ] := vt_pf10;
    key_map [f5 ] := vt_pf11;
    key_map [f6 ] := vt_pf06;
    key_map [f7 ] := vt_pf02;
    key_map [f8 ] := vt_pf04;
    key_map [f9 ] := vt_pf03;
    IF  vt_help_key IN i01g^.vt.desc.returnkeys
    THEN
        BEGIN
        key_map [f_help ] := vt_help_key;
        key_map [ f10 ] := vt_pf01 ;
        END
    ELSE
        BEGIN
        key_map [f_help ] := vt_pf01;
        key_map [ f10 ] := vt_unknown;
        END ;
    (*ENDIF*) 
    IF  vt_up_key IN i01g^.vt.desc.returnkeys
    THEN
        BEGIN
        key_map [f_up ] := vt_up_key;
        key_map [ f11 ] := vt_pf07;
        END
    ELSE
        BEGIN
        key_map [f_up ] := vt_pf07;
        key_map [ f11 ] := vt_unknown;
        END ;
    (*ENDIF*) 
    IF  vt_down_key IN i01g^.vt.desc.returnkeys
    THEN
        BEGIN
        key_map [f_down ] := vt_down_key;
        key_map [ f12  ] := vt_pf08
        END
    ELSE
        BEGIN
        key_map [f_down ] := vt_pf08;
        key_map [ f12  ] := vt_unknown;
        END ;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* i52pfkeymap *)
 
&ifdef PCMODE
(*------------------------------*) 
 
PROCEDURE
      i52pckeymap;
 
BEGIN
preset_pckeymap;
ddb4_ini_keymap;
i52pfkeymap;
END; (* i52pckeymap *)
 
(*------------------------------*) 
 
PROCEDURE
      preset_pckeymap;
 
BEGIN
WITH i01g^.key_type DO
    BEGIN
    key_map [ f_help  ] := vt_pf01;
    key_map [ f9  ]     := vt_pf02;
    key_map [ f1  ]     := vt_unknown;
    key_map [ f6  ]     := vt_unknown;
    key_map [ f2  ]     := vt_unknown;
    key_map [ f3  ]     := vt_unknown;
    key_map [ f7  ]     := vt_unknown;
    key_map [ f8  ]     := vt_unknown;
    key_map [ f4  ]     := vt_unknown;
    key_map [ f5  ]     := vt_unknown;
    key_map [ f_up  ]   := vt_up_key;
    key_map [ f_down  ] := vt_down_key;
    END;
(*ENDWITH*) 
END; (* preset_pckeymap *)
 
(*------------------------------*) 
 
PROCEDURE
      ddb4_ini_keymap;
 
CONST
      config_file       =
            '%DBROOT%\DDB4.INI                                               ';
 
VAR
      fn      : tsp00_VFilename;
      conlist : pc_config_list;
 
BEGIN
fn := config_file;
set_config_keys(conlist);
i66config(fn, conlist);
get_config_entries(conlist);
END; (* ddb4_ini_keymap *)
 
(*------------------------------*) 
 
PROCEDURE
      set_config_keys (
            VAR conlist : pc_config_list);
 
VAR
      i : integer;
 
BEGIN
WITH conlist DO
    BEGIN
    FOR i := 1 TO 9 DO
        BEGIN
        arr [i] .key := 'F                       ';
        arr [i] .key [2]  := chr( ord('0') + i );
        END;
    (*ENDFOR*) 
    arr [10] .key := 'F10                     ';
    length := 10;
    END;
(*ENDWITH*) 
END; (* set_config_keys *)
 
(*------------------------------*) 
 
PROCEDURE
      get_config_entries (
            VAR conlist : pc_config_list);
 
VAR
      pf    : tsp00_VtKey;
      index : integer;
 
BEGIN
index := 0;
FOR pf := vt_pf01 TO vt_pf10 DO
    BEGIN
    index := index + 1;
    IF  conlist.arr [index] .result [1]  <> chr(0)
    THEN
        get_1_configentry(pf, conlist.arr [index] .result);
    (*ENDIF*) 
    END;
(*ENDFOR*) 
END; (* get_config_entries *)
 
(*------------------------------*) 
 
PROCEDURE
      get_1_configentry (
            pf                : tsp00_VtKey;
            VAR function_text : tsp00_C40);
 
VAR
      func       : tin_prog_function; (* f1..f_help *)
      is_defined : boolean;
 
BEGIN
IF  function_text = bsp_c40
THEN
    BEGIN
    find_pf_in_keymap(pf, func, is_defined);
    pf := vt_unknown;
    END
ELSE
    get_prog_function(function_text, func, is_defined);
(*ENDIF*) 
IF  is_defined
THEN
    WITH i01g^.key_type DO
        key_map [ func  ] := pf;
    (*ENDWITH*) 
(*ENDIF*) 
END; (* get_1_configentry *)
 
(*------------------------------*) 
 
PROCEDURE
      find_pf_in_keymap (
            pf             : tsp00_VtKey;
            VAR func       : tin_prog_function;
            VAR is_defined : boolean);
 
VAR
      first : boolean;
 
BEGIN
func := f1;
is_defined := false;
first := true;
WITH i01g^.key_type DO
    REPEAT
        IF  first
        THEN
            first := false
        ELSE
            func := succ(func);
        (*ENDIF*) 
        is_defined := key_map [ func  ] = pf;
    UNTIL
        is_defined OR (func = f_help);
    (*ENDREPEAT*) 
(*ENDWITH*) 
END; (* find_pf_in_keymap *)
 
(*------------------------------*) 
 
PROCEDURE
      get_prog_function (
            VAR function_text : tsp00_C40;
            VAR func          : tin_prog_function;
            VAR is_defined    : boolean);
 
CONST
      key_help = 'HELP                                    ';
 
VAR
      c : char;
 
BEGIN
is_defined := true;
IF  s30lnr1(function_text,bsp_c1,1,40) = 1 (* only 1 character *)
THEN
    BEGIN
    c := function_text [1] ;
    CASE c OF
        '1':
            func := f1;
        '2':
            func := f2;
        '3':
            func := f3;
        '4':
            func := f4;
        '5':
            func := f5;
        '6':
            func := f6;
        '7':
            func := f7;
        '8':
            func := f8;
        '9':
            func := f9;
        OTHERWISE:
            is_defined := false;
        END;
    (*ENDCASE*) 
    END
ELSE
    IF  upper_equal(key_help, function_text)
    THEN
        func := f_help
    ELSE
        is_defined := false;
    (*ENDIF*) 
(*ENDIF*) 
END; (* get_prog_function *)
 
(*------------------------------*) 
 
FUNCTION
      upper_equal (
            key           : tsp00_C40;
            VAR mixed_val : tsp00_C40) : boolean;
 
VAR
      upper_val : tsp00_C40;
      i         : integer;
 
BEGIN
FOR i := 1 TO 40 DO
    upper_val [i]  := uppercase_52(mixed_val [i] );
(*ENDFOR*) 
upper_equal := (key = upper_val);
END; (* upper_equal *)
 
&endif
&ifdef hifmode
(*------------------------------*) 
 
PROCEDURE
      i52skkeymap;
 
BEGIN
WITH i01g^.key_type DO
    BEGIN
&   ifdef WINDOWS
    key_map [ f7  ] := vt_sk01;
    key_map [ f9  ] := vt_sk02;
    key_map [ f8  ] := vt_sk03;
    key_map [ f1  ] := vt_sk04;
    key_map [ f6  ] := vt_sk05;
    key_map [ f2  ] := vt_sk06;
    key_map [ f4  ] := vt_sk07;
    key_map [ f5  ] := vt_sk08;
    key_map [ f3  ] := vt_sk09;
&   else
    key_map [ f1  ] := vt_sk01;
    key_map [ f2  ] := vt_sk02;
    key_map [ f3  ] := vt_sk03;
    key_map [ f4  ] := vt_sk04;
    key_map [ f5  ] := vt_sk05;
    key_map [ f6  ] := vt_sk06;
    key_map [ f7  ] := vt_sk07;
    key_map [ f8  ] := vt_sk08;
    key_map [ f9  ] := vt_sk09;
&   endif
    key_map [ f10 ] := vt_unknown;
    key_map [ f11 ] := vt_unknown;
    key_map [ f12 ] := vt_unknown;
    key_map [ f_help  ] := vt_help_key;
    key_map [ f_up  ] := vt_up_key;
    key_map [ f_down  ] := vt_down_key;
    END
(*ENDWITH*) 
END; (* i52skkeymap *)
 
&endif
&ifdef hifmode
(*------------------------------*) 
 
PROCEDURE
      i52skmenu (
            VAR hif : tsp00_HifParms);
 
CONST
      blank_label = '        ';
 
VAR
      pk       : tin_prog_function;
      label_nr : integer;
      sk       : tin_vt_releasemode;
 
BEGIN
WITH i01g^.key_type DO
    FOR pk := f1 TO f_down DO
        BEGIN
        sk := key_map [  pk ] ;
        IF  (sk >= vt_sk01)
            AND (sk <= vt_sk09 )
        THEN
            BEGIN
            label_nr := ord(sk) - ord(vt_sk01) + 1;
&           ifdef WINDOWS
            set_hif_slabel(pk, label_nr, hif);
&           else
            IF  pk IN i01g^.key_type.activated
            THEN
                BEGIN
                set_hif_slabel(pk, label_nr, hif);
                END
            ELSE
                hif.slabels [ label_nr  ] := blank_label;
            (*ENDIF*) 
&           endif
            hif.llabels [ label_nr  ] [1]  := hif.slabels [ label_nr ] ;
            (* provisorisch : *)
            hif.llabels [ label_nr  ] [2]  := bsp_c8;
            END;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
(*ENDWITH*) 
END; (* i52skmenu *)
 
(*------------------------------*) 
 
PROCEDURE
      set_hif_slabel(
            pk       : tin_prog_function;
            label_nr : integer;
            VAR hif  : tsp00_HifParms);
 
VAR
      i          : integer;
      l          : tin_ls_sk_label;
      full_label : tsp00_C8;
      llen       : integer;
 
BEGIN
l := i01g^.key_type.key_labels [ pk ] ;
llen := s30klen (l, bsp_c1, csp_lslabel);
upper_lower_i52( l, full_label, llen );
FOR i:= 1 TO llen DO
    hif.slabels [ label_nr ] [i] := full_label [i] ;
(*ENDFOR*) 
FOR i := llen + 1 TO csp_lslabel DO
    hif.slabels [ label_nr ] [ i ] := bsp_c1;
(*ENDFOR*) 
END; (* set_hif_slabel *)
 
&endif
(*------------------------------*) 
 
PROCEDURE
      upper_lower_i52 (
            VAR src  : tin_ls_sk_label;
            VAR dest : tsp00_C8;
            len      : integer);
 
VAR
      i     : integer;
      upper : boolean;
 
BEGIN
upper := true;
dest := bsp_c8;
FOR i := 1 TO len DO
    BEGIN
&   ifdef WINDOWS
    dest [i] := src [i];
&   else
    IF  upper
    THEN
        dest [ i ] := uppercase_52(src [i] )
    ELSE
        dest [ i ] := lowercase_52(src [i] );
    (*ENDIF*) 
    upper := src [i] = '-';
&   endif
    END;
(*ENDFOR*) 
END; (* upper_lower_i52 *)
 
(*------------------------------*) 
 
FUNCTION
      uppercase_52 (
            c : char) : char;
 
BEGIN
uppercase_52 := i32toupper(c);
END; (* uppercase_52 *)
 
(*------------------------------*) 
 
FUNCTION
      lowercase_52 (
            c : char) : char;
 
BEGIN
lowercase_52 := i32tolower(c);
END; (* lowercase_52 *)
 
&ifdef WINDOWS
(*------------------------------*) 
 
PROCEDURE
      i52winlayout (
            inputarea_length : tin_natural;
            msglines         : tin_natural);
 
VAR
      i    : integer;
      part : tin_ls_part;
 
BEGIN
IF  inputarea_length = 0
THEN
    WITH i01g^.key_type DO
        activated := activated - [  f_cmd ] ;
    (*ENDWITH*) 
(*ENDIF*) 
IF  msglines > 0
THEN
    msglines := msglines - 1; (* systemline *)
(*ENDIF*) 
WITH i01g^.ls DO
    FOR i := 1 TO nr_screens DO
        BEGIN
        FOR part := cin_ls_header TO cin_ls_sysline DO
            BEGIN
            description [i] [  part ] .first_line := 0;
            description [i] [  part ] .last_line := 0;
            description [i] [  part ] .first_col := 0;
            description [i] [  part ] .last_col := 0;
            END;
        (*ENDFOR*) 
        description [i] [ cin_ls_workarea] .first_line :=
              description [i] [ cin_ls_basic_window] .first_line;
        description [i] [ cin_ls_workarea] .last_line :=
              description [i] [ cin_ls_basic_window] .last_line;
        description [i] [ cin_ls_workarea] .first_col :=
              description [i] [ cin_ls_basic_window] .first_col;
        description [i] [ cin_ls_workarea] .last_col :=
              description [i] [ cin_ls_basic_window] .last_col;
        description [i] [ cin_ls_sysline] .first_line := - msglines;
        description [i] [ cin_ls_sysline] .last_line := - 1;
        description [i] [ cin_ls_sysline] .first_col :=
              description [i] [ cin_ls_basic_window] .first_col;
        description [i] [ cin_ls_sysline] .last_col :=
              description [i] [ cin_ls_basic_window] .last_col;
        description [i] [ cin_ls_inputarea] .first_line := - inputarea_length;
        description [i] [ cin_ls_inputarea] .last_line := -1;
        description [i] [ cin_ls_inputarea] .first_col :=
              description [i] [ cin_ls_basic_window] .first_col;
        description [i] [ cin_ls_inputarea] .last_col :=
              description [i] [ cin_ls_basic_window] .last_col;
        END;
    (*ENDFOR*) 
(*ENDWITH*) 
END; (* i52winlayout *)
 
&else
&ifdef PCMODE
(*------------------------------*) 
 
PROCEDURE
      i52pclayout (
            workarea_length     : tsp00_Int2;
            functionmenu_length : tin_natural;
            inputarea_length    : tin_natural;
            msglines            : tin_natural);
 
VAR
      order : layout_order;
      i     : integer;
 
BEGIN
IF  functionmenu_length = 1
THEN
    functionmenu_length := 2;
(*ENDIF*) 
order [1]  := cin_ls_inputarea;
order [2]  := cin_ls_functionmenu;
order [3]  := cin_ls_sysline;
WITH i01g^.vt.desc DO
    common_layout (workarea_length, functionmenu_length,
          inputarea_length, msglines,
          order, has_sysline);
(*ENDWITH*) 
i54changewidth(cin_ls_workarea, 2);
i54changewidth(cin_ls_inputarea, 2);
IF  inputarea_length > 0
THEN
    WITH i01g^.ls DO
        (* separation line *)
        FOR i := 1 TO nr_screens DO
            BEGIN
            WITH description [i] [  cin_ls_workarea  ] DO
                IF  (last_line > 0)
                THEN
                    last_line := last_line - 1;
                (*ENDIF*) 
            (*ENDWITH*) 
            WITH description [i] [  cin_ls_inputarea  ] DO
                IF  (last_line > 0)
                THEN
                    BEGIN
                    first_line := first_line - 1;
                    last_line := last_line - 1;
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
            END;
        (*ENDFOR*) 
    (*ENDWITH*) 
(*ENDIF*) 
END; (* i52pclayout *)
 
&else
(*------------------------------*) 
 
PROCEDURE
      i52ibmlayout (
            workarea_length     : tsp00_Int2;
            functionmenu_length : tin_natural;
            inputarea_length    : tin_natural;
            msglines            : tin_natural);
 
VAR
      order : layout_order;
 
BEGIN
order [1]  := cin_ls_functionmenu;
order [2]  := cin_ls_sysline;
order [3]  := cin_ls_inputarea;
WITH i01g^.vt.desc DO
    common_layout(workarea_length, functionmenu_length,
          inputarea_length,msglines,
          order,has_sysline);
(*ENDWITH*) 
END; (* i52ibmlayout *)
 
(*------------------------------*) 
 
PROCEDURE
      i52unixlayout (
            workarea_length     : tsp00_Int2;
            functionmenu_length : tin_natural;
            inputarea_length    : tin_natural;
            msglines            : tin_natural);
 
VAR
      order : layout_order;
 
BEGIN
order [1]  := cin_ls_functionmenu;
order [2]  := cin_ls_inputarea;
order [3]  := cin_ls_sysline;
WITH i01g^.vt.desc DO
    BEGIN
    IF  has_sysline AND (msglines < 1)
    THEN
        msglines := 1;
    (*ENDIF*) 
    common_layout(workarea_length, functionmenu_length,
          inputarea_length,msglines,
          order,has_sysline);
    END;
(*ENDWITH*) 
END; (* i52unixlayout *)
 
&ifdef hifmode
(*------------------------------*) 
 
PROCEDURE
      i52sklayout (
            workarea_length  : tsp00_Int2;
            inputarea_length : tin_natural;
            msglines         : tin_natural);
 
CONST
      functionmenu_length = 0;
 
VAR
      order : layout_order;
 
BEGIN
order [1]  := cin_ls_functionmenu;
order [2]  := cin_ls_inputarea;
order [3]  := cin_ls_sysline;
WITH i01g^.vt.desc DO
    common_layout(workarea_length, functionmenu_length,
          inputarea_length,msglines,
          order,has_sysline);
(*ENDWITH*) 
END; (* i52sklayout *)
 
&endif
&endif
(*------------------------------*) 
 
PROCEDURE
      common_layout (
            workarea_length     : tsp00_Int2;
            functionmenu_length : tin_natural;
            inputarea_length    : tin_natural;
            msglines            : tin_natural;
            order               : layout_order;
            has_sysline         : boolean);
 
VAR
      bottomline    : tin_natural;
      part          : tin_ls_part;
      i,j           : integer;
      partlength    : tin_natural;
      worklines     : tin_natural;
      worklines_odd : boolean;
 
BEGIN
IF  i01g^.ls.nr_screens > 1
THEN
    BEGIN
    worklines := i01g^.ls.description [2]
          [ cin_ls_basic_window] .last_line
          - functionmenu_length;
    IF  has_sysline
    THEN
        (*Changed at 88/11/30*)
        worklines := worklines + 1;
    (*ENDIF*) 
    WITH i01g^.ls.description [1] [ cin_ls_basic_window ] DO
        IF  workarea_length >= 0
        THEN
            last_line := basic_window_length( workarea_length,
                  inputarea_length, msglines )
        ELSE
            last_line := worklines DIV i01g^.ls.nr_screens;
        (*ENDIF*) 
    (*ENDWITH*) 
    WITH i01g^.ls.description [2] [ cin_ls_basic_window ] DO
        BEGIN
        first_line := i01g^.ls.description [1]
              [ cin_ls_basic_window] .last_line + 1;
        worklines_odd := ((worklines DIV 2) * 2 ) <> worklines;
        IF  worklines_odd
        THEN
            first_line := first_line + 1;
        (*ENDIF*) 
        first_col := i01g^.ls.description [1]
              [ cin_ls_basic_window] .first_col;
        last_col := i01g^.ls.description [1]
              [ cin_ls_basic_window] .last_col;
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
FOR i := 1 TO i01g^.ls.nr_screens DO
    BEGIN
    WITH i01g^.ls.description [i] [ cin_ls_basic_window ] DO
        bottomline := last_line;
    (*ENDWITH*) 
    WITH i01g^.ls DO
        BEGIN
        WITH description [i] [  cin_ls_header  ] DO
            BEGIN
            first_line := description [i] [ cin_ls_basic_window] .first_line;
            last_line := first_line;
            END;
        (*ENDWITH*) 
        FOR j := 3 DOWNTO 1 DO
            BEGIN
            part := order [j] ;
            WITH description [i] [  part  ] DO
                BEGIN
                CASE part OF
                    cin_ls_inputarea:
                        partlength := inputarea_length;
                    cin_ls_sysline:
                        BEGIN
                        partlength := msglines;
                        IF  (i = i01g^.ls.nr_screens)
                            AND has_sysline
                        THEN
                            partlength := partlength - 1;
                        (*ENDIF*) 
                        END;
                    cin_ls_functionmenu:
                        IF  i < i01g^.ls.nr_screens
                        THEN
                            partlength := 0
                        ELSE
                            partlength := functionmenu_length;
                        (*ENDIF*) 
                    END;
                (*ENDCASE*) 
                IF  partlength > 0
                THEN
                    BEGIN
                    last_line := bottomline;
                    first_line := last_line - partlength + 1;
                    bottomline := first_line - 1;
                    END
                ELSE
                    BEGIN
                    last_line := 0;
                    first_line := last_line;
                    END;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
            END;
        (*ENDFOR*) 
        WITH description [i] [  cin_ls_workarea  ] DO
            BEGIN
            last_line := bottomline - 1;
            first_line := description [i] [  cin_ls_header ] .last_line + 2;
            END;
        (*ENDWITH*) 
        FOR part := cin_ls_header TO cin_ls_sysline DO
            WITH description [i] [  part  ] DO
                BEGIN
                first_col := description [i] [ cin_ls_basic_window] .first_col;
                last_col := description [i] [ cin_ls_basic_window] .last_col;
                END;
            (*ENDWITH*) 
        (*ENDFOR*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDFOR*) 
END; (* common_layout *)
 
(*------------------------------*) 
 
FUNCTION
      basic_window_length (
            workarea_length  : tsp00_Int2;
            inputarea_length : tsp00_Int2;
            msglines         : tsp00_Int2 ) : tsp00_Int2;
 
CONST
      headerlines = 1;
      workarea_border = 2;
 
VAR
      length : tsp00_Int2;
 
BEGIN
length := headerlines + workarea_length + workarea_border +
      inputarea_length + msglines;
basic_window_length := length;
END; (* basic_window_length *)
 
&endif
(*------------------------------*) 
 
PROCEDURE
      i52pflabels (
            fct_cursorpos      : tin_ls_releasemode;
            functionline_label : boolean);
&     ifndef pcmode
 
VAR
      printpos         : tin_ls_position;
      pftab            : internal_pftab;
      width            : tin_natural;
      available_length : tin_natural;
      next_free        : tin_ls_position;
      sno              : integer;
      labels_ok        : boolean;
&     endif
 
BEGIN
&ifndef pcmode
sno := i01g^.ls.nr_screens;
IF  i01g^.ls.description [sno]  [cin_ls_functionmenu] .first_line > 0
THEN
    BEGIN
    i50clear(cin_ls_functionmenu);
    build_internal_pftab(pftab);
    IF  pftab.tablen > 0
    THEN
        BEGIN
        WITH next_free DO
            BEGIN
            screen_nr := sno;
            screen_part := cin_ls_functionmenu;
            sline := 1;
            scol := cin_first_scol;
            END;
        (*ENDWITH*) 
        IF  functionline_label
        THEN
            put_menu_label(next_free);
        (*ENDIF*) 
        WITH i01g^.ls.description [sno]  [ cin_ls_functionmenu  ] DO
            width := last_col - first_col + 1;
        (*ENDWITH*) 
        available_length := width - next_free.scol;
        get_pfparms(next_free,available_length,
              pftab,printpos,labels_ok);
        IF  labels_ok
        THEN
            output_function_menu(next_free,pftab,printpos,fct_cursorpos)
        ELSE
            i50clear(cin_ls_functionmenu);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
&endif
(*ENDIF*) 
END; (* i52pflabels *)
 
&ifdef pcmode
(*------------------------------*) 
 
PROCEDURE
      i52pclabels (
            VAR fct            : tin_ls_releasemode;
            opt                : tin_menu_comment;
            functionline_label : boolean);
 
VAR
      parms         : tin_menu_display_option;
      res           : tin_menu_returnparms;
      oldmsg,oldatt : save_lines;
      back          : boolean;
      sno           : integer;
      fm_scol       : integer;
      oldactive     : tin_ls_key_set; (* B.M. Rel 3.0.0C 9 Apr 1991 *)
 
BEGIN
oldactive := i01g^.key_type.activated; (* B.M. Rel 3.0.0C 9 Apr 1991 *)
IF  opt = interactive_menu
THEN
    BEGIN
    save_old_lines(oldmsg,oldatt);
    END;
(*ENDIF*) 
IF  opt = display_only
THEN
    build_pc_functionmenu(i52menu.text,i52menu.length,
          i52comments.buf, i52comments.len);
(*ENDIF*) 
IF  i52menu.length > 0
THEN
    BEGIN
    set_pc_menuparms(opt,parms);
    sno := i01g^.ls.nr_screens;
    fm_scol :=
          i01g^.ls.description [ sno ]  [cin_ls_functionmenu] .first_col;
    IF  functionline_label
    THEN
        put_pcmenu_label;
    (*ENDIF*) 
    WITH parms DO
        IF  opt = position_result_only
        THEN
            (* first_col was changed by PUT_PCMENU_LABEL *)
            selection_pos.scol := selection_pos.scol
                  - i01g^.ls.description [ sno ]  [cin_ls_functionmenu] .first_col
                  + fm_scol;
        (*ENDIF*) 
    (*ENDWITH*) 
    i52pcfkey := vt_escape_key;
    i52pcffct := f_undo;
    (* B.M. Rel 3.0.0C 9 Apr 1991 *)
    i01g^.key_type.activated := i01g^.key_type.activated + [  f_enter ] ;
    i65menu(i52menu.text, i52menu.length,
          i52comments.buf, i52comments.len, parms, res);
    i52pcffct := f_local;  (* ???? *)
    IF  opt <> display_only
    THEN
        BEGIN
        get_pc_returnfunction(res,fct,back);
        IF  back
        THEN
            BEGIN
            restore_old_lines(oldmsg,oldatt);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    i01g^.ls.description [ sno ]  [cin_ls_functionmenu] .first_col :=
          fm_scol;
    END
ELSE
    BEGIN
    i52pcfkey := vt_unknown;
    i50clear(cin_ls_functionmenu);
    END;
(*ENDIF*) 
(* B.M. Rel 3.0.0C 9 Apr 1991 *)
i01g^.key_type.activated := oldactive;
&ifdef PCMODE
i52funclabel := functionline_label;
&endif
END; (* i52pclabels *)
 
(*------------------------------*) 
 
PROCEDURE
      save_old_lines (
            VAR oldmsg,oldatt : save_lines);
 
VAR
      msglines : tin_natural;
      fctlines : tin_natural;
      cols     : tin_natural;
      i        : integer;
 
BEGIN
i51size(cin_ls_functionmenu,fctlines,cols);
i51size(cin_ls_sysline,msglines,cols);
FOR i := 1 TO fctlines DO
    save_1_old_line(cin_ls_functionmenu,i,
          oldmsg [i] ,oldatt [i] );
(*ENDFOR*) 
FOR i := 1 TO msglines DO
    save_1_old_line(cin_ls_sysline,i,
          oldmsg [fctlines+i] ,oldatt [fctlines+i] );
(*ENDFOR*) 
END; (* save_old_lines *)
 
(*------------------------------*) 
 
PROCEDURE
      restore_old_lines (
            VAR oldmsg,oldatt : save_lines);
 
VAR
      msglines : tin_natural;
      fctlines : tin_natural;
      cols     : tin_natural;
      i        : integer;
 
BEGIN
i51size(cin_ls_functionmenu,fctlines,cols);
i51size(cin_ls_sysline,msglines,cols);
FOR i := 1 TO fctlines DO
    restore_1_old_line(cin_ls_functionmenu,i,
          oldmsg [i] ,oldatt [i] );
(*ENDFOR*) 
FOR i := 1 TO msglines DO
    restore_1_old_line(cin_ls_sysline,i,
          oldmsg [fctlines+i] ,oldatt [fctlines+i] );
(*ENDFOR*) 
END; (* restore_old_lines *)
 
(*------------------------------*) 
 
PROCEDURE
      save_1_old_line (
            part              : tin_ls_part;
            lno               : integer;
            VAR oldmsg,oldatt : tin_screenline);
 
VAR
      first_lno, scol : tin_natural;
      spos            : integer;
 
BEGIN
first_pos_of_screenpart(part,first_lno,scol);
lno := first_lno + lno - 1;
scol := 1; (* save whole line *)
WITH i01g^.vt,desc DO
    BEGIN
    spos := ( lno - 1 ) * num_of_cols + scol;
    s10mv(SCREEN_CHARS_MXSP00,mxin_screenline,
          @content_buf^,spos,
          @oldmsg,1,num_of_cols);
    s10mv(SCREEN_CHARS_MXSP00,mxin_screenline,
          @attribute_buf^,spos,
          @oldatt,1,num_of_cols);
    END;
(*ENDWITH*) 
END; (* save_1_old_line *)
 
(*------------------------------*) 
 
PROCEDURE
      restore_1_old_line (
            part              : tin_ls_part;
            lno               : integer;
            VAR oldmsg,oldatt : tin_screenline);
 
VAR
      first_lno, scol : tin_natural;
      spos            : integer;
 
BEGIN
first_pos_of_screenpart(part,first_lno,scol);
lno := first_lno + lno - 1;
i53changelimits(lno);
scol := 1; (* restore whole line *)
WITH i01g^.vt,desc DO
    BEGIN
    spos := ( lno - 1 ) * num_of_cols + scol;
    s10mv(mxin_screenline,SCREEN_CHARS_MXSP00,
          @oldmsg,1,
          @content_buf^,spos,num_of_cols);
    s10mv(mxin_screenline,SCREEN_CHARS_MXSP00,
          @oldatt,1,
          @attribute_buf^,spos,num_of_cols);
    END;
(*ENDWITH*) 
END; (* restore_1_old_line *)
 
(*------------------------------*) 
 
PROCEDURE
      first_pos_of_screenpart (
            part         : tin_ls_part;
            VAR lno,scol : tin_natural);
 
VAR
      pos : tin_ls_position;
 
BEGIN
WITH pos DO
    BEGIN
    screen_nr := i01g^.ls.nr_screens;
    screen_part := part;
    sline := 1;
    scol := 1;
    END;
(*ENDWITH*) 
i52fromscreenpos(pos,lno,scol);
END; (* first_pos_of_screenpart *)
 
(*------------------------------*) 
 
PROCEDURE
      put_pcmenu_label;
 
VAR
      llength    : tin_natural;
      labl       : tin_screenline;
      llno, lcol : tin_natural;
      ft         : tin_ls_fieldtype;
      sno        : integer;
 
BEGIN
first_pos_of_screenpart(cin_ls_functionmenu,llno,lcol);
i52lsmsg(msg_commands_label,labl,llength);
WITH ft DO
    BEGIN
    field_att := cin_ls_enhanced;
    fieldmode := [  ] ;
    END;
(*ENDWITH*) 
i54resolvedefaults (cin_ls_functionmenu, ft);
IF  (llno > 0) AND (lcol > 0)
THEN (* functionmenu really defined *)
    WITH i01g^.vt,desc DO
        i53put1field(labl,llength,1, llno,lcol,ft,
              num_of_lines,num_of_cols,
              content_buf ,attribute_buf );
    (*ENDWITH*) 
(*ENDIF*) 
sno := i01g^.ls.nr_screens;
WITH i01g^.ls.description [ sno ]  [cin_ls_functionmenu ] DO
    first_col := first_col + llength + 4;
(*ENDWITH*) 
END; (* put_pcmenu_label *)
 
(*------------------------------*) 
 
PROCEDURE
      build_pc_functionmenu (
            VAR menu        : tsp00_Line;
            VAR menu_length : tsp00_LinePositions;
            VAR comments    : shortbuffer;
            VAR clen        : tsp00_Int2);
 
VAR
      f : tin_ls_releasemode;
 
BEGIN
menu_length := 0;
clen := 0;
mfetch_shortcomments;
build_1_functionlabel(f_help, menu, menu_length);
fetch_1_shorthelp( f_help, comments, clen);
FOR f := f1 TO f9 DO
    BEGIN
    build_1_functionlabel(f, menu, menu_length);
    fetch_1_shorthelp( f, comments, clen);
    END;
(*ENDFOR*) 
build_1_functionlabel(f_exit, menu, menu_length);
fetch_1_shorthelp( f_exit, comments, clen);
END; (* build_pc_functionmenu *)
 
(*------------------------------*) 
 
PROCEDURE
      build_1_functionlabel (
            f               : tin_ls_releasemode;
            VAR menu        : tsp00_Line;
            VAR menu_length : tsp00_LinePositions);
 
VAR
      llen       : integer;
      full_label : tsp00_C8;
 
BEGIN
IF  f IN i01g^.key_type.activated
THEN
    BEGIN
    get_flabel(f, full_label, llen);
    IF  llen > 0
    THEN
        BEGIN
        menu_length := menu_length + 1;
        menu [menu_length ] := chr(llen);
        s10mv(8 ,mxin_screenline,
              @full_label,1,
              @menu,menu_length+1,llen);
        menu_length := menu_length + llen;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END; (* build_1_functionlabel *)
 
(*------------------------------*) 
 
PROCEDURE
      fetch_1_shorthelp(
            f            : tin_ls_releasemode;
            VAR comments : shortbuffer;
            VAR clen     : tsp00_Int2);
 
VAR
      llen : integer;
      cmmt : tin_screenline;
 
BEGIN
IF  f IN i01g^.key_type.activated
THEN
    BEGIN
    fetch_cmmt(f, cmmt, llen);
    clen := clen + 1;
    comments [clen ] := chr(llen);
    IF  llen > 0
    THEN
        BEGIN
        s10mv(LINE_MXSP00,mx_shortbuffer,
              @cmmt,1,
              @comments,clen+1,llen);
        clen := clen + llen;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END; (* fetch_1_shorthelp *)
 
(*------------------------------*) 
 
PROCEDURE
      get_flabel (
            f              : tin_ls_releasemode;
            VAR full_label : tsp00_C8;
            VAR llen       : integer);
 
VAR
      pf      : tin_vt_releasemode;
      pos     : integer;
      f_label : tin_ls_sk_label;
 
BEGIN
IF  f = f_exit
THEN
    f_label := 'eXit    '
ELSE
    f_label := i01g^.key_type.key_labels [f] ;
(*ENDIF*) 
llen := s30klen (f_label, bsp_c1, csp_lslabel);
IF  llen > 0
THEN
    BEGIN
    upper_lower_i52( f_label, full_label, llen );
    pos := llen;
    IF  (f >= f1)
        AND (f <= f_down)
    THEN
        WITH i01g^.key_type DO
            pf := key_map [ f  ]
        (*ENDWITH*) 
    ELSE
        pf := vt_unknown;
    (*ENDIF*) 
    IF  (pf >= vt_pf01)
        AND (pf <= vt_pf10)
    THEN
        BEGIN
        pos := pos + 1;
        full_label [pos ] := '(';
        pos := pos + 1;
        full_label [pos ] := 'F';
        pos := pos + 1;
        IF  pf < vt_pf10
        THEN
            full_label [pos ] := chr( ord('1')
                  + ord(pf) - ord(vt_pf01) )
        ELSE
            BEGIN
            full_label [pos ] := '1';  (* "F10" *)
            pos := pos + 1;
            full_label [pos ] := '0';
            END;
        (*ENDIF*) 
        pos := pos + 1;
        full_label [pos ] := ')';
        END;
    (*ENDIF*) 
    llen := pos;
    END;
(*ENDIF*) 
END; (* get_flabel *)
 
(*------------------------------*) 
 
PROCEDURE
      move_functionlabel (
            VAR f_label     : tsp00_C8;
            llen            : integer;
            VAR menu        : tin_screenline;
            VAR menu_length : integer);
 
BEGIN
s10mv(8 ,mxin_screenline,
      @f_label,1,
      @menu,menu_length+1,llen);
menu_length := menu_length + llen;
END; (* move_functionlabel *)
 
(*------------------------------*) 
 
PROCEDURE
      set_pc_menuparms (
            opt       : tin_menu_comment;
            VAR parms : tin_menu_display_option);
 
VAR
      length : tin_natural;
 
BEGIN
WITH parms DO
    BEGIN
    screen_nr := i01g^.ls.nr_screens;
    part := cin_ls_functionmenu;
    display := opt;
    IF  opt = position_result_only
    THEN
        selection_pos := i01g^.vt.parms.mouse_pos;
    (*ENDIF*) 
    centered := false;
    maxcols := 0;
    comment := act_comment;
    show_selection := [  f_enter ] ;
    confirm_with_enter := false;
    i52lsmsg(msg_commands_msg,sysmsg,length);
    errmsg [1]  := chr(0);
    init_itemno := 1;
    END;
(*ENDWITH*) 
END; (* set_pc_menuparms *)
 
(*------------------------------*) 
 
PROCEDURE
      get_pc_returnfunction (
            VAR res  : tin_menu_returnparms;
            VAR fct  : tin_ls_releasemode;
            VAR back : boolean);
 
VAR
      i       : integer;
      f       : tin_ls_releasemode;
      exists  : boolean;
 
BEGIN
f := f_clear;
WITH res DO
    BEGIN
    IF  itemno > 0
    THEN
        BEGIN
        f := f_help;
        FOR i := 1 TO itemno DO
            BEGIN
            IF  i > 1
            THEN
                f := next_rf(f);
            (*ENDIF*) 
            WITH i01g^.key_type DO
                REPEAT
                    exists := f IN activated;
                    IF  exists
                    THEN
                        exists := (f = f_exit)
                              OR (key_labels [f]  [1]  <> bsp_c1);
                    (*ENDIF*) 
                    IF  NOT exists
                    THEN
                        f := next_rf(f);
                    (*ENDIF*) 
                UNTIL
                    exists;
                (*ENDREPEAT*) 
            (*ENDWITH*) 
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    i01g^.ls.fctline_cursor := f;
    IF  rf = f_enter
    THEN
        BEGIN
        fct := f;
        i01g^.vt.parms.key.key := vt_enter;
        END
    ELSE
        fct := rf;
    (*ENDIF*) 
    back := (rf = f_undo )
          (*   AND (i01g^.vt.parms.key.key = vt_escape_key); *)
    END;
(*ENDWITH*) 
END; (* get_pc_returnfunction *)
 
(*------------------------------*) 
 
FUNCTION
      next_rf (
            rf : tin_ls_releasemode) : tin_ls_releasemode;
 
BEGIN
IF  rf = f_help
THEN
    next_rf := f1
ELSE
    IF  rf < f9
    THEN
        next_rf := succ(rf)
    ELSE
        next_rf := f_exit;
    (*ENDIF*) 
(*ENDIF*) 
END; (* next_rf *)
 
&endif
&ifndef pcmode
(*------------------------------*) 
 
PROCEDURE
      build_internal_pftab (
            VAR pftab : internal_pftab);
 
VAR
      p           : tin_vt_releasemode;
      pf_nr       : tin_natural;
      pfcnt       : tin_natural;
      fct_label   : text8;
      is_defined  : boolean;
      active_keys : tsp00_VtKeys;
      high        : boolean;
 
BEGIN
i52activekeys( active_keys );
WITH pftab DO
    BEGIN
    pfcnt:=0;
    FOR p := vt_pf01 TO vt_pf12 DO
        BEGIN
        get_pf_label(p,active_keys,fct_label,high,is_defined);
        IF  is_defined
        THEN
            BEGIN
            pfcnt := pfcnt + 1;
            WITH tab [pfcnt ] DO
                BEGIN
                menu_item_8  := fct_label;
                pf_nr := ord(p) - ord(vt_pf01) + 1;
                highlight := high;
                END;
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    tablen := pfcnt;
    END;
(*ENDWITH*) 
END; (* build_internal_pftab *)
 
(*------------------------------*) 
 
PROCEDURE
      get_pf_label (
            p              : tsp00_VtKey;
            active_keys    : tsp00_VtKeys;
            VAR fct_label  : text8;
            VAR high       : boolean;
            VAR is_defined : boolean);
 
VAR
      fct_key  : tin_ls_releasemode;
      pf_label : tin_ls_sk_label;
 
BEGIN
is_defined := p IN active_keys;
IF  is_defined
THEN
    BEGIN
    fct_key := i52rf(p);
    IF  fct_key > f_down
    THEN
        is_defined := false
    ELSE
        BEGIN
        pf_label := i01g^.key_type.key_labels [fct_key] ;
        fct_label.len := s30klen (pf_label,bsp_c1,csp_lslabel);
        IF  fct_label.len = 0
        THEN
            is_defined := false
        ELSE
            upper_lower_i52( pf_label, fct_label.txt, fct_label.len );
        (*ENDIF*) 
        IF  is_defined
        THEN
            high := fct_key IN i01g^.key_type.highlighted;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END; (* get_pf_label *)
 
(*------------------------------*) 
 
PROCEDURE
      put_menu_label (
            VAR next_free : tin_ls_position);
 
VAR
      textline  : tin_screenline;
      printline : tin_natural;
      printcol  : tin_natural;
      length    : tin_natural;
      ft        : tin_ls_fieldtype;
      pf_pos    : tin_ls_position;
 
BEGIN
i52lsmsg(msg_menu_label,textline,length);
init_fieldtype_i50(ft);
i54resolvedefaults (cin_ls_functionmenu, ft);
pf_pos := next_free;
i52fromscreenpos(pf_pos,printline,printcol);
WITH i01g^.vt,desc DO
    i53put1field(textline,length,pf_pos.screen_nr,
          printline,printcol, ft,
          num_of_lines,num_of_cols,
          content_buf ,attribute_buf );
(*ENDWITH*) 
next_free.scol := next_free.scol + length + 1;
END; (* put_menu_label *)
 
(*------------------------------*) 
 
PROCEDURE
      init_fieldtype_i50 (
            VAR ft : tin_ls_fieldtype);
 
BEGIN
WITH ft DO
    BEGIN
    field_att  := cin_ls_normal;
    fieldmode  := [  ] ;
    END;
(*ENDWITH*) 
END; (* init_fieldtype_i50 *)
 
(*------------------------------*) 
 
PROCEDURE
      get_pfparms (
            next_free        : tin_ls_position;
            available_length : tin_natural;
            VAR pftab        : internal_pftab;
            VAR printpos     : tin_ls_position;
            VAR labels_ok    : boolean);
 
VAR
      total_length : tin_natural;
      line_length  : tin_natural;
      maxpflines   : tin_natural;
      sno          : integer;
      width        : tin_natural;
 
BEGIN
sno := i01g^.ls.nr_screens;
WITH i01g^.ls.description [sno]  [cin_ls_functionmenu ] DO
    BEGIN
    maxpflines := last_line - first_line + 1;
    width := last_col - first_col + 1;
    END;
(*ENDWITH*) 
WITH pftab DO
    BEGIN
    last_on_first_line := tablen;
    total_length := total_pflength(pftab);
    IF  maxpflines > 1
    THEN
        IF  total_length > available_length
        THEN (* 2 pflines *)
            BEGIN
            last_on_first_line := (tablen+1) DIV 2;
            total_length := total_pflength(pftab);
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    labels_ok := true;
    WHILE (total_length > available_length) AND labels_ok DO
        BEGIN
        clip_longest_label(pftab,labels_ok);
        IF  labels_ok
        THEN
            total_length := total_length - 1;
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  labels_ok
    THEN
        BEGIN
        build_complete_labels(pftab);
        line_length := pfline_length(pftab,last_on_first_line);
        printpos := next_free;
        printpos.scol := (width DIV 2)
              - (line_length DIV 2) + 1;
        IF  printpos.scol < next_free.scol
        THEN
            printpos.scol := next_free.scol;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* get_pfparms *)
 
(*------------------------------*) 
 
PROCEDURE
      output_function_menu (
            next_free     : tin_ls_position;
            VAR pftab     : internal_pftab;
            printpos      : tin_ls_position;
            fct_cursorpos : tin_ls_releasemode);
 
VAR
      printcol       : tin_natural;
      pf_index       : tin_natural;
      rel_pf         : tin_natural;
      pflinenr       : 0..2;
      printline      : tin_natural;
      fct_key        : tin_vt_releasemode;
      fct_nr         : integer;
      maxpflines     : tin_natural;
      width          : tin_natural;
      ft             : tin_ls_fieldtype;
      pf_pos         : tin_ls_position;
 
BEGIN
pf_pos := printpos;
WITH pf_pos DO
    IF  scol < next_free.scol
    THEN
        scol := next_free.scol;
    (*ENDIF*) 
(*ENDWITH*) 
fct_key := i52_pf_key(fct_cursorpos);
fct_nr := ord(fct_key) - ord(vt_pf01) + 1;
pf_index := 0;
WITH i01g^.ls.description [pf_pos.screen_nr]  [cin_ls_functionmenu ] DO
    BEGIN
    maxpflines := last_line - first_line + 1;
    width      := last_col  - first_col  + 1;
    END;
(*ENDWITH*) 
FOR pflinenr := 1 TO maxpflines DO
    BEGIN
    pf_pos.sline := pflinenr;
    IF  pflinenr > 1
    THEN
        (* begin of second line *)
        BEGIN
        next_free.scol := cin_first_scol;
        next_free.sline := next_free.sline + 1;
        pf_pos.sline := next_free.sline;
        pf_pos.scol := printpos.scol;
        END;
    (*ENDIF*) 
    IF  pf_index >= pftab.tablen
    THEN
        pf_pos.scol := width;
    (*ENDIF*) 
    rel_pf := 0;
    WHILE (rel_pf < pftab.last_on_first_line)
          AND ( pf_index < pftab.tablen ) DO
        BEGIN
        rel_pf := rel_pf + 1;
        pf_index := pf_index + 1;
        init_fieldtype_i50(ft);
        i54resolvedefaults (cin_ls_functionmenu, ft);
        WITH pftab.tab [pf_index ] DO
            BEGIN
            IF  highlight
            THEN
                BEGIN
                ft.field_att := cin_ls_enhanced;
                i54resolvedefaults (cin_ls_functionmenu, ft);
                END;
            (*ENDIF*) 
            WITH i01g^.vt,desc,menu_item_12 DO
                BEGIN
                i52fromscreenpos(pf_pos,printline,printcol);
                i53put2field(txt,len, pf_pos.screen_nr,
                      printline, printcol,
                      ft,
                      num_of_lines,num_of_cols,
                      content_buf ,attribute_buf );
                END;
            (*ENDWITH*) 
            IF  fct_nr = pftab.tab [pf_index] .pf_nr
            THEN
                i01g^.ls.cursorpos := pf_pos;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        next_printpos(pftab,pf_index,pf_pos.scol);
        END;
    (*ENDWHILE*) 
    END;
(*ENDFOR*) 
END; (* output_function_menu *)
 
(*------------------------------*) 
 
FUNCTION
      one_label_length (
            VAR pftab : internal_pftab;
            pf_ind    : integer) : tin_natural;
 
VAR
      lablen   : integer;
      pf_nr    : pfcount;
 
BEGIN
lablen := 0;
WITH pftab DO
    BEGIN
    pf_nr := tab [pf_ind] .pf_nr;
    IF  pf_nr >= 10
    THEN
        lablen := lablen + 1; (* space for 2nd decimal *)
    (*ENDIF*) 
    lablen := lablen + 2; (* number + equal_sign *)
    lablen := lablen
          + pftab.tab [pf_ind] .menu_item_12.len;
    lablen := lablen + 1; (* blank *)
    END;
(*ENDWITH*) 
one_label_length := lablen;
END; (* one_label_length *)
 
(*------------------------------*) 
 
FUNCTION
      total_pflength (
            VAR pftab : internal_pftab) : tin_natural;
 
VAR
      total_length : integer;
      index        : pfcount;
      second_index : integer;
      lablen       : integer;
      lablen2      : integer;
 
BEGIN
total_length := 0;
WITH pftab DO
    FOR index := 1 TO last_on_first_line DO
        BEGIN
        lablen := one_label_length(pftab, index);
        second_index := index + last_on_first_line;
        IF  second_index <= tablen
        THEN
            BEGIN
            lablen2 := one_label_length(pftab, second_index);
            IF  lablen < lablen2
            THEN
                lablen := lablen2;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        total_length := total_length + lablen;
        END;
    (*ENDFOR*) 
(*ENDWITH*) 
total_pflength := total_length - 1; (* drop last blank *)
END; (* total_pflength *)
 
(*------------------------------*) 
 
PROCEDURE
      clip_longest_label (
            VAR pftab     : internal_pftab;
            VAR labels_ok : boolean);
 
VAR
      maxlen : integer;
      maxlab : integer;
      i,j    : integer;
 
BEGIN
maxlen := 0;
maxlab := 0;
WITH pftab DO
    BEGIN
    FOR i := 1 TO last_on_first_line DO
        BEGIN
        IF  tab [ i ] .menu_item_12.len > maxlen
        THEN
            BEGIN
            maxlen := tab [ i ] .menu_item_12.len;
            maxlab := i;
            END;
        (*ENDIF*) 
        j := i + last_on_first_line;
        IF  j <= tablen
        THEN
            IF  tab [ j ] .menu_item_12.len > maxlen
            THEN
                BEGIN
                maxlen := tab [ j ] .menu_item_12.len;
                maxlab := i;
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    labels_ok := (maxlen > 1);
    IF  labels_ok
    THEN
        BEGIN
        WITH tab [ maxlab ] .menu_item_12 DO
            IF  len = maxlen
            THEN
                len := len - 1;
            (*ENDIF*) 
        (*ENDWITH*) 
        j := maxlab + last_on_first_line;
        IF  j <= tablen
        THEN
            WITH tab [ j ] .menu_item_12 DO
                IF  len = maxlen
                THEN
                    len := len - 1;
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* clip_longest_label *)
 
(*------------------------------*) 
 
PROCEDURE
      build_complete_labels (
            VAR pftab : internal_pftab);
 
VAR
      item_length    : integer;
      first_cmdnr    : pfcount;
      first_keynr    : tin_natural;
      first_item     : tsp00_C12;
      second_labelnr : integer;
      second_keynr   : tin_natural;
      second_item    : tsp00_C12;
      flength        : tin_natural;
 
BEGIN
FOR first_cmdnr :=1 TO pftab.last_on_first_line DO
    BEGIN
    item_length := 0;
    first_item  := blank12;
    second_item := blank12;
    WITH pftab DO
        BEGIN
        first_keynr := tab [first_cmdnr] .pf_nr;
        second_labelnr := first_cmdnr + pftab.last_on_first_line;
        IF  second_labelnr <= pftab.tablen
        THEN
            second_keynr := tab [second_labelnr] .pf_nr
        ELSE
            second_keynr := 0;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    IF  second_keynr >= 10
    THEN
        BEGIN
        item_length := item_length + 1;
        second_item [item_length ] := '1'
        END;
    (*ENDIF*) 
    IF  first_keynr >= 10
    THEN
        BEGIN
        IF  second_keynr = 0
        THEN
            item_length := item_length+1;
        (*ENDIF*) 
        first_item [item_length ] := '1'
        END
    ELSE
        IF  second_keynr >= 10
        THEN
            first_item [item_length ] := bsp_c1;
        (*ENDIF*) 
    (*ENDIF*) 
    item_length := item_length + 1;
    first_item [item_length ] :=
          chr((first_keynr MOD 10)+ord('0'));
    IF  second_keynr > 0
    THEN
        second_item [item_length ] :=
              chr((second_keynr MOD 10) + ord('0'));
    (*ENDIF*) 
    item_length := item_length + 1;
    first_item [item_length ] := '=';
    IF  second_keynr > 0
    THEN
        second_item [item_length ] := '=';
    (*ENDIF*) 
    WITH pftab.tab [first_cmdnr ] DO
        BEGIN
        s10mv(12,12,
              @menu_item_12.txt,1,
              @first_item,item_length+1,menu_item_12.len);
        flength := menu_item_12.len;
        END;
    (*ENDWITH*) 
    IF  second_keynr>0
    THEN
        WITH pftab.tab [second_labelnr ] DO
            BEGIN
            s10mv(SNAME_MXSP00,SNAME_MXSP00,
                  @menu_item_12.txt,1,
                  @second_item,item_length+1,menu_item_12.len);
            IF  flength < menu_item_12.len
            THEN
                flength := menu_item_12.len;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    item_length := item_length + flength;
    WITH pftab DO
        BEGIN
        WITH tab [first_cmdnr] .menu_item_12 DO
            BEGIN
            txt := first_item;
            len := item_length;
            END;
        (*ENDWITH*) 
        IF  second_keynr > 0
        THEN
            WITH tab [second_labelnr] .menu_item_12 DO
                BEGIN
                txt := second_item;
                len := item_length;
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDFOR*) 
END; (* build_complete_labels *)
 
(*------------------------------*) 
 
FUNCTION
      pfline_length (
            VAR pftab              : internal_pftab;
            last_key_on_first_line : pfcount) : tin_natural;
 
VAR
      pf_index : pfcount;
      length   : integer;
      width    : tin_natural;
 
BEGIN
length := 0;
FOR pf_index := 1 TO last_key_on_first_line DO
    (* length of text12 plus one blank *)
    length := length + pftab.tab [pf_index] .menu_item_12.len + 1;
(*ENDFOR*) 
(* drop last blank *)
length := length - 1;
(* limit to width *)
WITH i01g^.ls,description [nr_screens]  [ cin_ls_functionmenu  ] DO
    width := last_col - first_col + 1;
(*ENDWITH*) 
IF  length > width - 1
THEN
    length := width - 1;
(*ENDIF*) 
pfline_length := length;
END; (* pfline_length *)
 
&endif
(*------------------------------*) 
 
FUNCTION
      i52pffunction (
            fno : integer) : tin_ls_releasemode;
 
VAR
      pf          : tin_vt_releasemode;
      fct_key     : tin_ls_releasemode;
      found_pf    : tin_vt_releasemode;
      active_keys : tsp00_VtKeys;
      pf_label    : tin_ls_sk_label;
      i           : integer;
      len         : integer;
 
BEGIN
found_pf := vt_unknown;
i52activekeys(active_keys);
i := 0;
FOR pf := vt_pf01 TO vt_pf12 DO
    IF  found_pf = vt_unknown
    THEN
        BEGIN
        IF  pf IN active_keys
        THEN
            BEGIN
            fct_key := i52rf(pf);
            pf_label := i01g^.key_type.key_labels [fct_key] ;
            len := s30klen (pf_label,bsp_c1,csp_lslabel);
            IF  len > 0
            THEN
                BEGIN
                i := i + 1;
                IF  fno = i
                THEN
                    found_pf := pf;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDFOR*) 
IF  found_pf = vt_unknown
THEN
    i52pffunction := f_clear
ELSE
    i52pffunction := i52rf(found_pf);
(*ENDIF*) 
END; (* i52pffunction *)
 
(*------------------------------*) 
 
PROCEDURE
      i52activekeys (
            VAR active_keys : tsp00_VtKeys);
 
BEGIN
i52keysettrans ( i01g^.key_type.activated, active_keys );
IF  f_local IN i01g^.key_type.activated
THEN
    active_keys := active_keys + i01g^.vt.opt.returnkeys;
&ifdef pcmode
(*ENDIF*) 
IF  i52pcfkey <> vt_unknown
THEN
    active_keys := active_keys + [  i52pcfkey ] ;
&endif
(*ENDIF*) 
END; (* i52activekeys *)
 
(*------------------------------*) 
 
PROCEDURE
      i52keysettrans (
            VAR inp : tin_ls_key_set;
            VAR res : tsp00_VtKeys);
 
VAR
      rf   : tin_ls_releasemode;
      keys : tsp00_VtKeys;
 
BEGIN
res := [  ] ;
FOR rf := f1 TO f_end DO
    IF  rf IN inp
    THEN
        BEGIN
        (* IF  rf IN [  f1 .. f_down  ] *)
        IF  (rf >= f1)
            AND (rf <= f_down )
        THEN
            keys := [  i01g^.key_type.key_map [ rf  ]  ]
        ELSE
            CASE rf OF
                f_enter:
                    keys := [  vt_enter, vt_do_key ] ;
                f_clear:
                    keys := [  vt_clear ] ;
                f_cancel:
                    BEGIN
                    keys := [  vt_cancel_key ] ;
&                   if $OS = UNIX
&                   else
                    keys := keys + [  vt_unknown ] ;
&                   endif
                    END;
                f_left:
                    keys := [  vt_left_key ] ;
                f_right:
                    keys := [  vt_right_key ] ;
                f_pick:
                    keys := [  vt_pick_key ] ;
                f_put:
                    keys := [  vt_put_key ] ;
                f_mark:
                    keys := [  vt_mark_key ] ;
                f_select:
                    keys := [  vt_select_key ] ;
                f_move:
                    keys := [  vt_move_key ] ;
                f_copy:
                    keys := [  vt_copy_key ] ;
                f_insert:
                    keys := [  vt_insert_key ] ;
                f_delete:
                    keys := [  vt_delete_key ] ;
                f_top:
                    keys := [  vt_top_key ] ;
                f_bottom:
                    keys := [  vt_bottom_key ] ;
                f_cursor_home:
                    keys := [  vt_cursor_home ] ;
                f_cursor_end:
                    keys := [  vt_cursor_end ] ;
                f_cursor_bol:
                    keys := [  vt_cursor_bol ] ;
                f_cursor_eol:
                    keys := [  vt_cursor_eol ] ;
                f_undo:
                    keys := [  vt_undo_key ] ;
                f_cmd:
                    keys := [  vt_cmd_key ] ;
                f_local:
                    keys := [  vt_character_key,
                          vt_cursor_up .. vt_del_eof,
                          vt_mouse_down, vt_mouse_up, vt_mouse_move ] ;
                f_vscroll:
                    keys := [  vt_vscroll ] ;
                f_hscroll:
                    keys := [  vt_hscroll ] ;
                f_file_open:
                    keys := [  vt_file_open ] ;
                f_file_save:
                    keys := [  vt_file_save ] ;
                f_exit:
                    keys := [  vt_exit ] ;
                f_print:
                    keys := [  vt_print ] ;
                f_find:
                    keys := [  vt_find ] ;
                f_replace:
                    keys := [  vt_replace ] ;
                f_mouse_dbl:
                    keys := [ vt_mouse_dbl ];
                f_mouse_up:
                    keys := [ vt_mouse_up ];
                f_mouse_down:
                    keys := [ vt_mouse_down ];
                f_end:
                    keys := [  vt_end_key ] ;
                f_control:
                    keys := [  vt_control_key ] ;
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        res := res + keys;
        END;
    (*ENDIF*) 
(*ENDFOR*) 
END; (* i52keysettrans *)
 
(*------------------------------*) 
 
FUNCTION
      i52_pf_key (
            rf : tin_ls_releasemode) : tin_vt_releasemode;
 
VAR
      new_rk : tin_vt_releasemode;
 
BEGIN
IF  rf <= f_down
THEN
    WITH i01g^.key_type DO
        new_rk := key_map [ rf  ]
    (*ENDWITH*) 
ELSE
    new_rk := vt_unknown;
(*ENDIF*) 
i52_pf_key := new_rk;
END; (* i52_pf_key *)
 
(*------------------------------*) 
 
FUNCTION
      i52keytrans (
            rf : tin_ls_releasemode) : tsp00_VtKey ;
 
VAR
      new_rk : tsp00_VtKey;
 
BEGIN
IF  (rf >= f1) AND (rf <= f_down)
THEN
    WITH i01g^.key_type DO
        new_rk := key_map [ rf  ]
    (*ENDWITH*) 
ELSE
    CASE rf OF
        f_enter:
            new_rk := vt_enter;
        f_clear:
            new_rk := vt_clear;
        f_left:
            new_rk := vt_left_key;
        f_right:
            new_rk := vt_right_key;
        f_cmd:
            new_rk := vt_cmd_key;
        f_pick:
            new_rk := vt_pick_key;
        f_put:
            new_rk := vt_put_key;
        f_mark:
            new_rk := vt_mark_key;
        f_select:
            new_rk := vt_select_key;
        f_move:
            new_rk := vt_move_key;
        f_copy:
            new_rk := vt_copy_key;
        f_insert:
            new_rk := vt_insert_key;
        f_delete:
            new_rk := vt_delete_key;
        f_top:
            new_rk := vt_top_key;
        f_bottom:
            new_rk := vt_bottom_key;
        f_cursor_home:
            new_rk := vt_cursor_home;
        f_cursor_end:
            new_rk := vt_cursor_end;
        f_cursor_bol:
            new_rk := vt_cursor_bol;
        f_cursor_eol:
            new_rk := vt_cursor_eol;
        f_cancel:
            new_rk := vt_cancel_key;
        f_undo:
            new_rk := vt_undo_key;
        f_mouse_dbl:
            new_rk := vt_mouse_dbl;
        f_mouse_up:
            new_rk := vt_mouse_up;
        f_mouse_down:
            new_rk := vt_mouse_down;
        f_end:
            new_rk := vt_end_key;
        f_control:
            new_rk := vt_control_key;
        f_vscroll:
            new_rk := vt_vscroll;
        f_hscroll:
            new_rk := vt_hscroll;
        f_file_open:
            new_rk := vt_file_open;
        f_file_save:
            new_rk := vt_file_save;
        f_exit:
            new_rk := vt_exit;
        f_print:
            new_rk := vt_print;
        f_find:
            new_rk := vt_find;
        f_replace:
            new_rk := vt_replace;
        OTHERWISE:
            new_rk := vt_unknown;
        END;
    (*ENDCASE*) 
(*ENDIF*) 
i52keytrans := new_rk;
END; (* i52keytrans *)
 
(*------------------------------*) 
 
FUNCTION
      i52rf (
            rk : tsp00_VtKey) : tin_ls_releasemode;
 
VAR
      new_fct : tin_ls_releasemode;
      found   : boolean;
 
BEGIN
new_fct := f1;
&ifdef pcmode
IF  (rk = vt_unknown)
    OR (rk <> i52pcfkey)
THEN
    found := false
ELSE
    BEGIN
    new_fct := i52pcffct;
    found := true
    END;
(*ENDIF*) 
&else
found := false;
&endif
WITH i01g^.key_type DO
    WHILE (NOT found) AND (new_fct <= f_down) DO
        BEGIN
        found := (key_map [ new_fct  ] = rk);
        IF  NOT found
        THEN
            new_fct := succ(new_fct);
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
(*ENDWITH*) 
IF  NOT found
THEN
    CASE rk OF
        vt_enter,vt_do_key:
            new_fct := f_enter;
        vt_clear:
            new_fct := f_clear;
        vt_unknown:
            new_fct := f_cancel;
        vt_left_key:
            new_fct := f_left;
        vt_right_key:
            new_fct := f_right;
        vt_cmd_key:
            new_fct := f_cmd;
        vt_pick_key:
            new_fct := f_pick;
        vt_put_key:
            new_fct := f_put;
        vt_mark_key:
            new_fct := f_mark;
        vt_select_key:
            new_fct := f_select;
        vt_move_key:
            new_fct := f_move;
        vt_copy_key:
            new_fct := f_copy;
        vt_insert_key:
            new_fct := f_insert;
        vt_delete_key:
            new_fct := f_delete;
        vt_top_key:
            new_fct := f_top;
        vt_bottom_key:
            new_fct := f_bottom;
        vt_cursor_home:
            new_fct := f_cursor_home;
        vt_cursor_end:
            new_fct := f_cursor_end;
        vt_cursor_bol:
            new_fct := f_cursor_bol;
        vt_cursor_eol:
            new_fct := f_cursor_eol;
        vt_cancel_key:
            new_fct := f_cancel;
        vt_undo_key:
            new_fct := f_undo;
        vt_end_key:
            new_fct := f_end;
        vt_control_key:
            new_fct := f_control;
        vt_mouse_dbl:
            new_fct := f_mouse_dbl;
        vt_mouse_up:
            new_fct := f_mouse_up;
        vt_mouse_down:
            new_fct := f_mouse_down;
        vt_vscroll:
            new_fct := f_vscroll;
        vt_hscroll:
            new_fct := f_hscroll;
        vt_file_open:
            new_fct := f_file_open;
        vt_file_save:
            new_fct := f_file_save;
        vt_exit:
            new_fct := f_exit;
        vt_print:
            new_fct := f_print;
        vt_find:
            new_fct := f_find;
        vt_replace:
            new_fct := f_replace;
        OTHERWISE:
            new_fct := f_local;
        END;
    (*ENDCASE*) 
(*ENDIF*) 
i52rf := new_fct;
END; (* i52rf *)
 
(*------------------------------*) 
 
PROCEDURE
      next_printpos (
            VAR pftab    : internal_pftab;
            pf_index     : pfcount;
            VAR printpos : tin_natural);
 
VAR
      nextpos   : tin_natural;
      sno       : tin_natural;
 
BEGIN
WITH pftab.tab [pf_index] .menu_item_12 DO
    nextpos := printpos + len + 1;
(*ENDWITH*) 
sno := i01g^.ls.nr_screens;
WITH i01g^.ls.description [sno]  [cin_ls_functionmenu ] DO
    IF  nextpos <= last_col
    THEN
        printpos := nextpos
    ELSE
        printpos := last_col;
    (*ENDIF*) 
(*ENDWITH*) 
END; (* next_printpos *)
 
(*------------------------------*) 
 
PROCEDURE
      i52lsmsg (
            msgno        : integer;
            VAR textline : tin_screenline;
            VAR length   : tin_natural);
 
BEGIN
i52substmsg ( msgno, textline, length );
END; (* i52lsmsg *)
 
(*------------------------------*) 
 
PROCEDURE
      i52substmsg (
            msgno        : integer;
            VAR textline : tin_screenline;
            VAR length   : tin_natural);
 
VAR
      text   : tsp00_C20;
 
BEGIN
CASE msgno OF
    msg_sysname:
        BEGIN
        length := mxin_sysname;
        text := cin_sysname;
        END;
    msg_undef:
        BEGIN
        length := 15;
        text := 'key not defined     ';
        END;
    msg_menu_label:
        BEGIN
        length := 8;
        text := 'PF keys:            ';
        END;
    msg_commands_msg:
        BEGIN
        length := 15;
        text := 'Select Function     ';
        END;
    msg_commands_label:
        BEGIN
        length := 10;
        text := 'Functions:          ';
        END;
    msg_commandline:
        BEGIN
        length := 11;
        text := 'Commandline         ';
        END;
    msg_exitdialog:
        BEGIN
        length := 17;
        text := 'End this session?   ';
        END;
    OTHERWISE:
        length := 0;
    END;
(*ENDCASE*) 
s10mv(20,mxin_screenline,
      @text,1,
      @textline,1,length);
SAPDB_PascalForcedFill (mxin_screenline,@textline,length+1,mxin_screenline-length,
      bsp_c1);
END; (* i52substmsg *)
 
(*------------------------------*) 
 
PROCEDURE
      i52mfset (
            VAR msgnos : tin_msgnos);
 
BEGIN
msgnos := msgnos;
END; (* i52mfset *)
 
(*------------------------------*) 
 
PROCEDURE
      i52fromscreenpos (
            VAR pos       : tin_ls_position;
            VAR screenlno : tin_natural;
            VAR screencol : tin_natural);
 
VAR
      limit : tsp00_Int2;
      col   : tsp00_Int2;
      lno   : tsp00_Int2;
 
BEGIN
check_ls_position(pos);
IF  pos.screen_part = cin_ls_whole_screen
THEN
    BEGIN
    lno := pos.sline;
    col := pos.scol;
    END
ELSE
    IF  pos.screen_part = cin_ls_undef_part
    THEN
        BEGIN
        lno := 0;
        col := 0;
        END
    ELSE
        BEGIN
        WITH pos,i01g^.ls.description [screen_nr]  [ screen_part  ] DO
            IF  first_col <= 0
            THEN
                BEGIN
                lno := 0;
                col := 0;
                END
            ELSE
                BEGIN
                col := first_col  + scol  - 1;
                lno := first_line + sline - 1;
                limit := last_line;
                IF  screen_part = cin_ls_workarea
                THEN
                    BEGIN
&                   ifdef PCMODE
                    limit := limit + 2; (* frame *)
&                   else
                    limit := limit + 1; (* frame *)
&                   endif
                    END;
&               ifdef PCMODE
                (*ENDIF*) 
                IF  screen_part = cin_ls_inputarea
                THEN
                    IF  limit > 0
                    THEN
                        limit := limit + 1; (* frame *)
&                   endif
                    (*ENDIF*) 
                (*ENDIF*) 
                lno := limit_linenumber ( lno, limit, screen_nr, screen_part );
                IF  col > last_col
                THEN
                    col := last_col;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  lno < 0
THEN
    screenlno := 0
ELSE
    screenlno := lno;
(*ENDIF*) 
IF  col < 0
THEN
    screencol := 0
ELSE
    screencol := col;
(*ENDIF*) 
END; (* i52fromscreenpos *)
 
(*------------------------------*) 
 
FUNCTION
      limit_linenumber (
            lno         : tsp00_Int2;
            limit       : tsp00_Int2;
            screen_nr   : tin_screencount;
            screen_part : tin_ls_part ) : integer ;
 
BEGIN (* B.M. 02.02.95 Release 6.1.1 CL 12 *)
IF  lno > limit
THEN
    BEGIN
    IF  is_in_sysline ( screen_nr, screen_part )
    THEN
        (* This will cause i50put1field to take the sysline. *)
        lno := 0
    ELSE
        lno := limit;
    (*ENDIF*) 
    END ;
(*ENDIF*) 
limit_linenumber := lno ;
END; (* limit_linenumber *)
 
(*------------------------------*) 
 
FUNCTION
      is_in_sysline (
            screen_nr   : tin_screencount;
            screen_part : tin_ls_part ) : boolean ;
 
BEGIN
is_in_sysline := false ;
IF  screen_nr = i01g^.ls.nr_screens
    (* lower screen *)
THEN
    IF  screen_part = cin_ls_sysline
    THEN
        IF  i01g^.vt.desc.has_sysline
        THEN
            is_in_sysline := true ;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
END; (* is_in_sysline *)
 
(*------------------------------*) 
 
PROCEDURE
      i52toscreenpos (
            lno            : tin_natural;
            col            : tin_natural;
            preferred_part : tin_ls_part;
            VAR pos        : tin_ls_position);
 
VAR
      part      : tin_ls_part;
      found     : boolean;
      finished  : boolean;
      screen_nr : tin_natural;
 
BEGIN
&ifdef WINDOWS
screen_nr := 1; (* !!! *)
&else
WITH i01g^.ls.description [1] [ cin_ls_basic_window ] DO
    IF  lno <= last_line
    THEN
        screen_nr := 1
    ELSE
        screen_nr := 2;
    (*ENDIF*) 
(*ENDWITH*) 
&endif
found := false;
&ifdef WINDOWS
IF  preferred_part = cin_ls_workarea
THEN
    BEGIN
    found := true;
    pos.screen_nr := 1; (* !!! *)
    pos.screen_part := cin_ls_workarea;
    pos.sline := lno;
    IF  col = 0
    THEN
        pos.scol := 0
    ELSE
        pos.scol := col - 1;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  NOT found
THEN
&   endif
    BEGIN
    finished := false;
    (*IF  preferred_part IN [  ls_basic_window..ls_sysline ] *)
    IF  (preferred_part >= cin_ls_basic_window)
        AND (preferred_part <= cin_ls_sysline)
    THEN
        BEGIN
        search_part_for_position(lno,col,screen_nr,
              preferred_part,pos,found);
        END;
    (*ENDIF*) 
    part := cin_ls_header;
    WHILE (NOT found) AND (NOT finished)  DO
        BEGIN
        search_part_for_position(lno,col,screen_nr,part,pos,found);
        IF  NOT found
        THEN
            IF  part < cin_ls_sysline
            THEN
                part := succ(part)
            ELSE
                finished := true;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  NOT found
    THEN
        search_part_for_position(lno,col,screen_nr,
              cin_ls_basic_window,pos,found);
    (*ENDIF*) 
    IF  NOT found
    THEN
        BEGIN
        pos.screen_nr := screen_nr;
        pos.screen_part := cin_ls_whole_screen;
        pos.sline := lno;
        pos.scol  := col;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END; (* i52toscreenpos *)
 
(*------------------------------*) 
 
PROCEDURE
      search_part_for_position (
            lno,col   : tin_natural;
            screen_nr : tin_natural;
            part      : tin_ls_part;
            VAR pos   : tin_ls_position;
            VAR found : boolean);
 
VAR
      fline : tsp00_Int2;
      lline : tsp00_Int2;
 
BEGIN
WITH i01g^.ls.description [screen_nr]  [ part  ] DO
    BEGIN
    fline := first_line;
    lline := last_line;
    IF  part = cin_ls_workarea
    THEN
        BEGIN
        IF  fline > 1
        THEN
            fline := fline - 1;
        (*ENDIF*) 
        IF  lline < i01g^.vt.desc.num_of_lines
        THEN
            lline := lline + 1;
        (*ENDIF*) 
        END;
    (*IF  (lno IN [  fline .. lline  ] )
          AND (col IN [  first_col .. last_col  ] )*)
    (*ENDIF*) 
    IF  (lno >= fline)
        AND (lno <= lline )
        AND (col >= first_col)
        AND (col <= last_col )
    THEN
        BEGIN
        found := true;
        pos.screen_nr := screen_nr;
        pos.screen_part := part;
        pos.sline := lno - first_line + 1;
        pos.scol  := col - first_col  + 1;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* search_part_for_position *)
 
(*------------------------------*) 
 
PROCEDURE
      check_ls_position (
            VAR pos : tin_ls_position);
 
BEGIN
WITH pos DO
    BEGIN
    IF  i01g^.ls.nr_screens = 1
    THEN
        screen_nr := 1;
    (* IF  NOT (screen_nr IN [ 1..maxscreens] ) *)
    (*ENDIF*) 
    IF  ( screen_nr < 1)
        OR (screen_nr > mxin_screens)
    THEN
        lspos_not_ok; (* stmt 5 *)
    (*IF  NOT (screen_part IN [  ls_whole_screen .. ls_undef_part  ] ) *)
    (*ENDIF*) 
    IF  (screen_part < cin_ls_whole_screen)
        OR (screen_part > cin_ls_undef_part )
    THEN
        lspos_not_ok; (* stmt 7 *)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* check_ls_position *)
 
(*------------------------------*) 
 
PROCEDURE
      lspos_not_ok;
      (* produce syserror *)
 
BEGIN
sqlabort;
END; (* lspos_not_ok *)
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
