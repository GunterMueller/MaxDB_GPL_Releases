.CM  SCRIPT , Version - 1.1 , last edited by holger
.pa
.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VIN21$
.tt 2 $$$
.TT 3 $$SQLDB-command-interface$1998-12-07$
***********************************************************
.nf
 
.nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : SQLDB-command-interface
=========
.sp
Purpose : Ease of use for the sql packet (real coding)
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
&       ifndef INLINK
        PROCEDURE
              i21connect (
                    g_area          : tin_global_in_vars;
                    installation    : boolean;
                    VAR charsetname : tsp00_KnlIdentifier;
                    VAR status      : tin_connect_status);
 
        PROCEDURE
              i21dbnoreset (
                    g_area : tin_global_in_vars);
 
        PROCEDURE
              i21disconnect (
                    g_area : tin_global_in_vars);
 
        PROCEDURE
              i21mdbsrelease (
                    g_area         : tin_global_in_vars;
                    VAR dbname_arg : tsp00_DbName);
 
        PROCEDURE
              i21mdbsrterelease (
                    g_area         : tin_global_in_vars;
                    VAR dbname_arg : tsp00_DbName);
 
        PROCEDURE
              i21oldsenderid (
                    g_area : tin_global_in_vars);
 
        PROCEDURE
              i21rebuild_session (
                    g_area     : tin_global_in_vars;
                    VAR status : tin_connect_status);
 
        PROCEDURE
              i21release (
                    g_area     : tin_global_in_vars);
 
        PROCEDURE
              i21rterelease (
                    g_area     : tin_global_in_vars);
 
        PROCEDURE
              i21scspecialconnect (
                    g_area          : tin_global_in_vars;
                    VAR status      : tin_connect_status);
 
        PROCEDURE
              i21setdbno (
                    g_area             : tin_global_in_vars;
                    VAR symbolicdbname : tsp00_DbName;
                    VAR switch_rc      : tin_connect_status );
 
        PROCEDURE
              i21setsqlptr (
                    g_area    : tin_global_in_vars;
                    packet_no : integer);
 
        PROCEDURE
              i21switchsession (
                    g_area     : tin_global_in_vars;
                    session_no : integer);
&       endif
 
        PROCEDURE
              i21abort;
 
        PROCEDURE
              i21advsegment (
                    g_area : tin_global_in_vars);
 
        PROCEDURE
              i21advpart (
                    g_area : tin_global_in_vars);
 
        PROCEDURE
              i21alternativesegment (
                    g_area      : tin_global_in_vars;
                    switch_stat : tin_switch_type );
 
        PROCEDURE
              i21ansimsgtext (
                    g_area  : tin_global_in_vars;
                    VAR msg : tin_screenline);
 
        FUNCTION
              i21buflen (
                    g_area  : tin_global_in_vars) : tsp00_Int4;
 
        PROCEDURE
              i21check_stmt (
                    g_area        : tin_global_in_vars;
                    is_unicode    : boolean;
                    VAR statement : tin_check_sql);
 
        PROCEDURE
              i21chngargcount (
                    g_area    : tin_global_in_vars;
                    argcount  : tsp00_Int2);
 
        PROCEDURE
              i21chngattributes (
                    g_area      : tin_global_in_vars;
                    attributes  : tsp1_part_attr);
 
        PROCEDURE
              i21chngcodetype (
                    g_area    : tin_global_in_vars;
                    mess_code : tsp00_CodeType);
 
        PROCEDURE
              i21chngcommit (
                    g_area    : tin_global_in_vars;
                    commit    : boolean);
 
        PROCEDURE
              i21chngcostwarn (
                    g_area    : tin_global_in_vars;
                    costwarn  : boolean);
 
        PROCEDURE
              i21chnginfo (
                    g_area    : tin_global_in_vars;
                    with_info : boolean);
 
        PROCEDURE
              i21chngmasscmd (
                    g_area     : tin_global_in_vars;
                    is_masscmd : boolean);
 
        PROCEDURE
              i21chngmesstype (
                    g_area    : tin_global_in_vars;
                    messtype  : tsp1_cmd_mess_type);
 
        PROCEDURE
              i21chngmode (
                    g_area    : tin_global_in_vars;
                    sqlmode   : tsp1_sqlmode);
 
        PROCEDURE
              i21chngpartkind (
                    g_area    : tin_global_in_vars;
                    part_kind : tsp1_part_kind);
 
        PROCEDURE
              i21chngproducer (
                    g_area    : tin_global_in_vars;
                    producer  : tsp1_producer);
 
        PROCEDURE
              i21cleanreset (
                    g_area : tin_global_in_vars;
                    m_type : tsp1_cmd_mess_type);
 
        PROCEDURE
              i21dbcrash (
                    g_area : tin_global_in_vars );
 
        FUNCTION
              i21dbok (
                    g_area : tin_global_in_vars ) : boolean;
 
        PROCEDURE
              i21errortext (
                    g_area  : tin_global_in_vars;
                    VAR msg : tin_screenline);
 
        PROCEDURE
              i21fetchrest (
                    g_area : tin_global_in_vars);
 
        PROCEDURE
              i21findpart (
                    g_area    : tin_global_in_vars;
                    part_kind : tsp1_part_kind);
 
        PROCEDURE
              i21finish_part (
                    g_area   : tin_global_in_vars);
 
        PROCEDURE
              i21gbuf (
                    g_area   : tin_global_in_vars;
                    buf_pos  : tsp00_Int4;
                    VAR val  : tsp00_MoveObj;
                    val_pos  : tsp00_Int4;
                    move_len : tsp00_Int4);
 
        PROCEDURE
              i21g1buf (
                    g_area   : tin_global_in_vars;
                    buf_pos  : tsp00_Int4;
                    VAR val  : tsp00_MoveObj;
                    val_pos  : tsp00_Int4;
                    move_len : tsp00_Int4);
 
        PROCEDURE
              i21g2buf (
                    g_area   : tin_global_in_vars;
                    buf_pos  : tsp00_Int4;
                    VAR val  : tsp00_MoveObj;
                    val_pos  : tsp00_Int4;
                    move_len : tsp00_Int4);
 
        PROCEDURE
              i21g3buf (
                    g_area   : tin_global_in_vars;
                    buf_pos  : tsp00_Int4;
                    VAR val  : tsp00_MoveObj;
                    val_pos  : tsp00_Int4;
                    move_len : tsp00_Int4);
 
        PROCEDURE
              i21g4buf (
                    g_area   : tin_global_in_vars;
                    buf_pos  : tsp00_Int4;
                    VAR val  : tsp00_MoveObj;
                    val_pos  : tsp00_Int4;
                    move_len : tsp00_Int4);
 
        PROCEDURE
              i21g5buf (
                    g_area   : tin_global_in_vars;
                    buf_pos  : tsp00_Int4;
                    VAR val  : tsp00_MoveObj;
                    val_pos  : tsp00_Int4;
                    move_len : tsp00_Int4);
 
        PROCEDURE
              i21gbval (
                    g_area      : tin_global_in_vars;
                    l_val       : tin_natural;
                    b_pos       : tsp00_Int4;
                    VAR val     : tsp00_Buf;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21g1bval (
                    g_area      : tin_global_in_vars;
                    l_val       : tin_natural;
                    b_pos       : tsp00_Int4;
                    VAR val     : tsp00_Buf;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21g2bval (
                    g_area      : tin_global_in_vars;
                    l_val       : tin_natural;
                    b_pos       : tsp00_Int4;
                    VAR val     : tsp00_Buf;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21g3bval (
                    g_area      : tin_global_in_vars;
                    l_val       : tin_natural;
                    b_pos       : tsp00_Int4;
                    VAR val     : tsp00_Buf;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21g4bval (
                    g_area      : tin_global_in_vars;
                    l_val       : tin_natural;
                    b_pos       : tsp00_Int4;
                    VAR val     : tsp00_Buf;
                    VAR is_null : boolean);
 
        FUNCTION
              i21gchar (
                    g_area       : tin_global_in_vars;
                    b_pos        : tsp00_Int4) : char;
 
        PROCEDURE
              i21gcolname (
                    g_area      : tin_global_in_vars;
                    pos         : tsp00_Int4;
                    VAR cname   : tsp00_KnlIdentifier;
                    VAR namlen  : integer);
 
        PROCEDURE
              i21gcount (
                    g_area    : tin_global_in_vars;
                    VAR count : tsp00_Int4);
 
        PROCEDURE
              i21gdescriptor (
                    g_area       : tin_global_in_vars;
                    VAR descript : tsp00_C8);
 
        PROCEDURE
              i21gettrans_tables (
                    g_area    : tin_global_in_vars);
 
        PROCEDURE
              i21getval (
                    g_area      : tin_global_in_vars;
                    l_val       : tin_natural;
                    b_pos       : tsp00_Int4;
                    VAR val     : tsp00_Buf;
                    pos         : tsp00_Int2;
                    maxsize     : tsp00_Int2;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21gloadfield (
                    g_area  : tin_global_in_vars;
                    info_no : tin_natural;
                    VAR ffi : tsp7_ffield_info);
 
        PROCEDURE
              i21gparaminfo (
                    g_area    : tin_global_in_vars;
                    info_no   : tin_natural;
                    VAR pi    : tsp1_param_info;
                    VAR found : boolean);
 
        PROCEDURE
              i21gparsid (
                    g_area     : tin_global_in_vars;
                    VAR parsid : tin_parsid);
 
        PROCEDURE
              i21gpival (
                    g_area      : tin_global_in_vars;
                    VAR pi      : tsp1_param_info;
                    val_size    : tsp00_Int4;
                    VAR val     : tsp00_MoveObj;
                    VAR val_len : tsp00_Int4;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21g1pival (
                    g_area      : tin_global_in_vars;
                    VAR pi      : tsp1_param_info;
                    val_size    : tsp00_Int4;
                    VAR val     : tsp00_MoveObj;
                    VAR val_len : tsp00_Int4;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21g2pival (
                    g_area      : tin_global_in_vars;
                    VAR pi      : tsp1_param_info;
                    val_size    : tsp00_Int4;
                    VAR val     : tsp00_MoveObj;
                    VAR val_len : tsp00_Int4;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21g3pival (
                    g_area      : tin_global_in_vars;
                    VAR pi      : tsp1_param_info;
                    val_size    : tsp00_Int4;
                    VAR val     : tsp00_MoveObj;
                    VAR val_len : tsp00_Int4;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21g4pival (
                    g_area      : tin_global_in_vars;
                    VAR pi      : tsp1_param_info;
                    val_size    : tsp00_Int4;
                    VAR val     : tsp00_MoveObj;
                    VAR val_len : tsp00_Int4;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21grescount (
                    g_area     : tin_global_in_vars;
                    VAR known  : boolean;
                    VAR count  : tsp00_Int4);
 
        PROCEDURE
              i21gsetval (
                    data_part : tsp1_part_ptr;
                    b_pos     : tsp00_Int4;
                    b_len     : tsp00_Int2;
                    l_val     : tin_natural;
                    VAR val   : tsp00_Buf);
 
        PROCEDURE
              i21g1setval (
                    data_part : tsp1_part_ptr;
                    b_pos     : tsp00_Int4;
                    b_len     : tsp00_Int2;
                    l_val     : tin_natural;
                    VAR val   : tsp00_Buf);
 
        PROCEDURE
              i21g2setval (
                    data_part : tsp1_part_ptr;
                    b_pos     : tsp00_Int4;
                    b_len     : tsp00_Int2;
                    l_val     : tin_natural;
                    VAR val   : tsp00_Buf);
 
        PROCEDURE
              i21g3setval (
                    data_part : tsp1_part_ptr;
                    b_pos     : tsp00_Int4;
                    b_len     : tsp00_Int2;
                    l_val     : tin_natural;
                    VAR val   : tsp00_Buf);
 
        PROCEDURE
              i21g4setval (
                    data_part : tsp1_part_ptr;
                    b_pos     : tsp00_Int4;
                    b_len     : tsp00_Int2;
                    l_val     : tin_natural;
                    VAR val   : tsp00_Buf);
 
        PROCEDURE
              i21g5setval (
                    data_part : tsp1_part_ptr;
                    b_pos     : tsp00_Int4;
                    b_len     : tsp00_Int2;
                    l_val     : tin_natural;
                    VAR val   : tsp00_Buf);
 
        PROCEDURE
              i21gvalcount (
                    g_area    : tin_global_in_vars;
                    VAR count : integer);
 
        PROCEDURE
              i21gpartval (
                    g_area      : tin_global_in_vars;
                    l_part      : tin_natural;
                    l_val       : tin_natural;
                    VAR pos     : tsp00_Int4;
                    VAR val     : tsp00_Buf;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21gval (
                    g_area      : tin_global_in_vars;
                    l_val       : tin_natural;
                    VAR pos     : tsp00_Int4;
                    VAR val     : tsp00_Buf;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21g1val (
                    g_area      : tin_global_in_vars;
                    l_val       : tin_natural;
                    VAR pos     : tsp00_Int4;
                    VAR val     : tsp00_Buf;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21g2val (
                    g_area      : tin_global_in_vars;
                    l_val       : tin_natural;
                    VAR pos     : tsp00_Int4;
                    VAR val     : tsp00_Buf;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21g3val (
                    g_area      : tin_global_in_vars;
                    l_val       : tin_natural;
                    VAR pos     : tsp00_Int4;
                    VAR val     : tsp00_Buf;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21gxval (
                    g_area      : tin_global_in_vars;
                    l_val       : tin_natural;
                    VAR pos     : tsp00_Int4;
                    VAR val     : tsp00_Buf;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21g1xval (
                    g_area      : tin_global_in_vars;
                    l_val       : tin_natural;
                    VAR pos     : tsp00_Int4;
                    VAR val     : tsp00_Buf;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21g2xval (
                    g_area      : tin_global_in_vars;
                    l_val       : tin_natural;
                    VAR pos     : tsp00_Int4;
                    VAR val     : tsp00_Buf;
                    VAR is_null : boolean);
 
        PROCEDURE
              i21initadbs (
                    g_area : tin_global_in_vars);
 
        PROCEDURE
              i21initcommand (
                    g_area    : tin_global_in_vars;
                    mess_type : tsp1_cmd_mess_type);
 
        PROCEDURE
              i21initdbtable (
                    g_area : tin_global_in_vars);
 
        PROCEDURE
              i21initexecute (
                    g_area  : tin_global_in_vars;
                    VAR pid : tin_parsid);
 
        PROCEDURE
              i21initpackets (
                    g_area       : tin_global_in_vars;
                    packet_ptr   : tsp1_packet_ptr;
                    from_receive : boolean);
 
        PROCEDURE
              i21initparse (
                    g_area : tin_global_in_vars);
 
        PROCEDURE
              i21initretsegm (
                    g_area : tin_global_in_vars);
 
        FUNCTION
              i21lnr (
                    g_area       : tin_global_in_vars;
                    val          : char;
                    start        : tsp00_Int4;
                    cnt          : tsp00_Int4) : tsp00_Int4;
 
        PROCEDURE
              i21mfetch (
                    g_area       : tin_global_in_vars;
                    in_unicode   : boolean;
                    m_type       : tsp1_cmd_mess_type;
                    count        : tsp00_Int4;
                    dir          : tin_fetch_dir;
                    VAR res_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              i21mfparse (
                    g_area       : tin_global_in_vars;
                    dir          : tin_fetch_dir;
                    cols         : integer;
                    VAR res_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              i21mfpos (
                    g_area       : tin_global_in_vars;
                    in_unicode   : boolean;
                    m_type       : tsp1_cmd_mess_type;
                    count        : tin_natural;
                    fetchpos     : tsp00_Int4;
                    VAR res_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              i21movecmnd (
                    g_area : tin_global_in_vars;
                    VAR s  : tsp00_MoveObj;
                    pos    : tin_natural;
                    l_s    : tin_natural);
 
        PROCEDURE
              i21newcmd (
                    g_area : tin_global_in_vars;
                    m_type : tsp1_cmd_mess_type);
 
        PROCEDURE
              i21newpart (
                    g_area    : tin_global_in_vars;
                    part_kind : tsp1_part_kind);
 
        PROCEDURE
              i21nextpart_init (
                    g_area       : tin_global_in_vars);
 
        PROCEDURE
              i21parg (
                    g_area      : tin_global_in_vars;
                    l_arg       : tin_natural;
                    VAR pos     : tsp00_Int4;
                    VAR arg     : tsp00_Buf;
                    is_null     : boolean);
 
        PROCEDURE
              i21p1arg (
                    g_area      : tin_global_in_vars;
                    l_arg       : tin_natural;
                    VAR pos     : tsp00_Int4;
                    VAR arg     : tsp00_C20;
                    is_null     : boolean);
 
        PROCEDURE
              i21p2arg (
                    g_area      : tin_global_in_vars;
                    l_arg       : tin_natural;
                    VAR pos     : tsp00_Int4;
                    VAR arg     : tsp00_Buf;
                    is_null     : boolean);
 
        FUNCTION
              i21partfreespace (
                    g_area  : tin_global_in_vars) : tsp00_Int4;
 
        PROCEDURE
              i21fbarg (
                    g_area  : tin_global_in_vars;
                    VAR arg : tsp00_Buf;
                    b_pos   : tsp00_Int4;
                    l_arg   : tin_natural;
                    defbyte : char;
                    l_field : tin_natural;
                    is_null : boolean);
 
        PROCEDURE
              i21pbarg (
                    g_area  : tin_global_in_vars;
                    VAR arg : tsp00_Buf;
                    b_pos   : tsp00_Int4;
                    l_arg   : tin_natural;
                    is_null : boolean);
 
        PROCEDURE
              i21p1barg (
                    g_area  : tin_global_in_vars;
                    VAR arg : tsp00_Buf;
                    b_pos   : tsp00_Int4;
                    l_arg   : tin_natural;
                    is_null : boolean);
 
        PROCEDURE
              i21p2barg (
                    g_area  : tin_global_in_vars;
                    VAR arg : tsp00_Buf;
                    b_pos   : tsp00_Int4;
                    l_arg   : tin_natural;
                    is_null : boolean);
 
        PROCEDURE
              i21p3barg (
                    g_area  : tin_global_in_vars;
                    VAR arg : tsp00_Buf;
                    b_pos   : tsp00_Int4;
                    l_arg   : tin_natural;
                    is_null : boolean);
 
        PROCEDURE
              i21p4barg (
                    g_area  : tin_global_in_vars;
                    VAR arg : tsp00_Buf;
                    b_pos   : tsp00_Int4;
                    l_arg   : tin_natural;
                    is_null : boolean);
 
        PROCEDURE
              i21prescount (
                    g_area     : tin_global_in_vars;
                    VAR count  : tsp00_Int4);
 
        PROCEDURE
              i21putstring (
                    g_area  : tin_global_in_vars;
                    VAR arg : tsp00_MoveObj;
                    b_pos   : tsp00_Int2;
                    l_arg   : tsp00_Int2;
                    is_null : boolean);
 
        PROCEDURE
              i21pbuf (
                    g_area   : tin_global_in_vars;
                    buf_pos  : tsp00_Int4;
                    VAR val  : tsp00_MoveObj;
                    from_pos : tsp00_Int4;
                    move_len : tsp00_Int4);
 
        PROCEDURE
              i21p1buf (
                    g_area   : tin_global_in_vars;
                    buf_pos  : tsp00_Int4;
                    VAR val  : tsp00_MoveObj;
                    from_pos : tsp00_Int4;
                    move_len : tsp00_Int4);
 
        PROCEDURE
              i21p2buf (
                    g_area   : tin_global_in_vars;
                    buf_pos  : tsp00_Int4;
                    VAR val  : tsp00_MoveObj;
                    from_pos : tsp00_Int4;
                    move_len : tsp00_Int4);
 
        PROCEDURE
              i21p3buf (
                    g_area   : tin_global_in_vars;
                    buf_pos  : tsp00_Int4;
                    VAR val  : tsp00_MoveObj;
                    from_pos : tsp00_Int4;
                    move_len : tsp00_Int4);
 
        PROCEDURE
              i21p4buf (
                    g_area   : tin_global_in_vars;
                    buf_pos  : tsp00_Int4;
                    VAR val  : tsp00_MoveObj;
                    from_pos : tsp00_Int4;
                    move_len : tsp00_Int4);
 
        PROCEDURE
              i21pcmnd (
                    g_area : tin_global_in_vars;
                    VAR s  : tsp00_Buf;
                    l_s    : tin_natural);
 
        PROCEDURE
              i21p1cmnd (
                    g_area : tin_global_in_vars;
                    VAR s  : tsp00_C20;
                    l_s    : tin_natural);
 
        PROCEDURE
              i21p2cmnd (
                    g_area : tin_global_in_vars;
                    VAR s  : tsp00_C40;
                    l_s    : tin_natural);
 
        PROCEDURE
              i21p3cmnd (
                    g_area : tin_global_in_vars;
                    VAR s  : tsp00_C70;
                    l_s    : tin_natural);
 
        PROCEDURE
              i21p4cmnd (
                    g_area : tin_global_in_vars;
                    VAR s  : tsp00_Buf;
                    l_s    : tin_natural);
 
        PROCEDURE
              i21p5cmnd (
                    g_area : tin_global_in_vars;
                    VAR s  : tsp00_Buf;
                    l_s    : tin_natural);
 
        PROCEDURE
              i21pccmnd (
                    g_area : tin_global_in_vars;
                    c      : char);
 
        PROCEDURE
              i21pcmd (
                    g_area : tin_global_in_vars;
                    s      : tsp00_C30);
 
        PROCEDURE
              i21pcname (
                    g_area  : tin_global_in_vars;
                    VAR nam : tsp00_KnlIdentifier);
 
        PROCEDURE
              i21pcuname (
                    g_area  : tin_global_in_vars;
                    VAR nam : tsp00_KnlIdentifier);
 
        PROCEDURE
              i21pdescriptor (
                    g_area       : tin_global_in_vars;
                    VAR descript : tsp00_C8);
 
        PROCEDURE
              i21pparsid (
                    g_area     : tin_global_in_vars;
                    VAR parsid : tin_parsid);
 
        PROCEDURE
              i21ppw (
                    g_area : tin_global_in_vars;
                    VAR pw : tsp00_CryptPw );
 
        PROCEDURE
              i21pstring (
                    g_area : tin_global_in_vars;
                    VAR s  : tsp00_Buf;
                    l_s    : tin_natural);
 
        PROCEDURE
              i21p1string (
                    g_area : tin_global_in_vars;
                    VAR s  : tsp00_Buf;
                    l_s    : tin_natural);
 
        PROCEDURE
              i21p2string (
                    g_area : tin_global_in_vars;
                    VAR s  : tsp00_Buf;
                    l_s    : tin_natural);
 
        PROCEDURE
              i21p3string (
                    g_area : tin_global_in_vars;
                    VAR s  : tsp00_Buf;
                    l_s    : tin_natural);
 
        PROCEDURE
              i21p4string (
                    g_area : tin_global_in_vars;
                    VAR s  : tsp00_Buf;
                    l_s    : tin_natural);
 
        PROCEDURE
              i21p5string (
                    g_area : tin_global_in_vars;
                    VAR s  : tsp00_Buf;
                    l_s    : tin_natural);
 
        PROCEDURE
              i21repcmnd (
                    g_area : tin_global_in_vars;
                    c      : char);
 
        PROCEDURE
              i21request (
                    g_area        : tin_global_in_vars;
                    VAR rq_status : tin_connect_status);
 
        PROCEDURE
              i21receive (
                    g_area         : tin_global_in_vars;
                    VAR rc_status  : tin_connect_status;
                    VAR sqlstate   : tsp00_SqlState;
                    VAR returncode : tsp00_Int2;
                    VAR errorpos   : tsp00_Int4);
 
        PROCEDURE
              i21reset (
                    g_area : tin_global_in_vars;
                    m_type : tsp1_cmd_mess_type);
 
        PROCEDURE
              i21rfpos (
                    g_area       : tin_global_in_vars;
                    m_type       : tsp1_cmd_mess_type;
                    count        : tsp00_Int4;
                    fetchpos     : tsp00_Int4;
                    VAR res_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              i21senderid (
                    g_area : tin_global_in_vars;
                    compid : tsp00_C3);
 
        PROCEDURE
              i21setksession (
                    g_area     : tin_global_in_vars;
                    VAR parsid : tin_parsid);
 
        PROCEDURE
              i21tosendreset (
                    g_area : tin_global_in_vars);
 
        FUNCTION
              i21validpid (
                    g_area     : tin_global_in_vars;
                    VAR parsid : tin_parsid) : boolean;
 
        FUNCTION
              i21valisnull (
                    g_area  : tin_global_in_vars;
                    pos     : tsp00_Int4) : boolean;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
&       ifndef INLINK
        FROM
              Binary_String_Conversions : VIN35;
 
        PROCEDURE
              i35intlj_into_str (
                    source_num     : tsp00_Int4;
                    VAR result_str : tsp00_C20;
                    VAR res_len    : integer);
&       endif
&       ifdef INLINK
 
      ------------------------------ 
 
        FROM
              DBS_Commands : VAK93;
 
        FUNCTION
              a93return_to_kernel (acv_addr : tin_acv_address) : boolean;
 
        PROCEDURE
              a93request (
                    acv               : tin_acv_address;
                    sql_packet        : tsp1_packet_ptr;
                    VAR returncode    : tsp1_comm_error);
 
        PROCEDURE
              a93receive (
                    acv               : tin_acv_address;
                    VAR sql_packet    : tsp1_packet_ptr);
&       endif
&       ifdef INLINK
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vabort (write_core : boolean);
&       else
 
      ------------------------------ 
 
        FROM
              RTE_driver : VEN102;
 
        PROCEDURE
              sqlabort;
 
        PROCEDURE
              sqltermid (
                    VAR terminalid : tsp00_TermId);
 
        PROCEDURE
              sqluid (
                    VAR uid : tsp00_TaskId);
 
        PROCEDURE
              sqlaconnect (
                    uid                 : tsp00_TaskId;
                    VAR servernode      : tsp00_NodeId;
                    VAR serverdb        : tsp00_DbName;
                    service             : tsp00_Service;
                    packet_cnt          : tsp00_Int4;
                    VAR reference       : tsp00_Int4;
                    VAR sql_packet_size : tsp00_Int4;
                    VAR sql_packet_list : tsp1_packet_list;
                    VAR errtext         : tsp00_ErrText;
                    VAR returncode      : tsp1_comm_error);
 
        PROCEDURE
              sqlareceive (
                    reference             : tsp00_Int4;
                    VAR res_packet_ptr    : tsp1_packet_ptr;
                    VAR res_packet_length : tsp00_Int4;
                    VAR errtext           : tsp00_ErrText;
                    VAR returncode        : tsp1_comm_error);
 
        PROCEDURE
              sqlarelease (
                    reference : tsp00_Int4);
 
        PROCEDURE
              sqlarequest (
                    reference         : tsp00_Int4;
                    sql_packet_ptr    : tsp1_packet_ptr;
                    sql_packet_length : tsp00_Int4;
                    VAR errtext       : tsp00_ErrText;
                    VAR returncode    : tsp1_comm_error);
 
        PROCEDURE
              sqlcharsetname (
                    VAR charsetname : tsp00_KnlIdentifier );
&       endif
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;       
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;    
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;    
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26nextpart (VAR part_ptr : tsp1_part_ptr);
 
        PROCEDURE
              s26find_part (
                    VAR segm     : tsp1_segment;
                    part_kind    : tsp1_part_kind;
                    VAR part_ptr : tsp1_part_ptr);
 
        PROCEDURE
              s26finish_part (
                    packet_ptr      : tsp1_packet_ptr;
                    VAR finish_part : tsp1_part);
 
        PROCEDURE
              s26first_segment_init (
                    packet_ptr         : tsp1_packet_ptr;
                    segm_kind          : tsp1_segment_kind;
                    VAR first_segm_ptr : tsp1_segment_ptr);
 
        PROCEDURE
              s26new_part_init (
                    packet_ptr       : tsp1_packet_ptr;
                    VAR segm         : tsp1_segment;
                    VAR new_part_ptr : tsp1_part_ptr);
 
        PROCEDURE
              s26new_segment_init (
                    packet_ptr         : tsp1_packet_ptr;
                    segm_kind          : tsp1_segment_kind;
                    VAR new_segm_ptr   : tsp1_segment_ptr;
                    VAR first_part_ptr : tsp1_part_ptr);
 
        PROCEDURE
              s26next_segment (
                    VAR segm_ptr : tsp1_segment_ptr);
 
        FUNCTION
              s26packet_len (
                    packet_ptr : tsp1_packet_ptr) : tsp00_Int4;
 
        FUNCTION
              s26partptr (
                    VAR part : tsp1_part) : tsp1_part_ptr;
 
        FUNCTION
              s26segmptr (
                    VAR segm : tsp1_segment) : tsp1_segment_ptr;
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30 ;
 
        FUNCTION
              s30gad (VAR b : tsp00_C70) : tsp00_MoveObjPtr;
 
        FUNCTION
              s30gad1 (VAR b : char) : tsp00_MoveObjPtr;
 
        FUNCTION
              s30gad2 (VAR b : tsp00_MoveObj) : tsp00_MoveObjPtr;
 
        FUNCTION
              s30lnr (
                    VAR str : tsp00_MoveObj;
                    val     : char;
                    start   : tsp00_Int4;
                    cnt     : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              GET-Conversions : VSP40;
 
        PROCEDURE
              s40glint (
                    VAR buf  : tsp00_ResNum;
                    pos      : tsp00_Int4;
                    len      : integer;
                    VAR dest : tsp00_Int4;
                    VAR res  : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              PUT-Conversions: VSP41;
 
        PROCEDURE
              s41p4int (
                    VAR buf : tsp00_ResNum;
                    pos     : tsp00_Int4;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-60 : VSP60 ;
 
        FUNCTION
              s60tocap (
                    c : char ) : char;
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80 : VSP80;
 
        PROCEDURE
              s80uni_trans (
                    src_ptr         : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Version : VSP100;
 
        PROCEDURE
              sp100_GetSenderIDVersionP  (
                    VAR SenderIDP    : tsp00_C5);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
&       ifdef INLINK
        PROCEDURE
              a93request;
 
              tak_acv_address tin_acv_address;
 
        FUNCTION
              a93return_to_kernel;
 
              tak_acv_address tin_acv_address
&             endif
 
        PROCEDURE
              i35intlj_into_str;
 
              tsp00_C10 tsp00_C20
 
        PROCEDURE
              s40glint;
 
              tsp00_MoveObj tsp00_ResNum
 
        PROCEDURE
              s41p4int;
 
              tsp00_MoveObj tsp00_ResNum
 
        PROCEDURE
              m90buf1;
 
              tsp00_Buf tsp00_ErrText
 
        PROCEDURE
              m90buf2;
 
              tsp00_Buf tsp00_MoveObj
 
        FUNCTION
              s30gad;
 
              tsp00_MoveObj          tsp00_C70
              tsp00_Addr             tsp00_MoveObjPtr
 
        FUNCTION
              s30gad1;
 
              tsp00_MoveObj          char
              tsp00_Addr             tsp00_MoveObjPtr
 
        FUNCTION
              s30gad2;
 
              tsp00_Addr             tsp00_MoveObjPtr
 
        PROCEDURE
              sqltermid;
 
              tsp00_TermId tsp00_TermId
 
        PROCEDURE
              sqluid;
 
              tsp00_TaskId tsp00_TaskId
 
        PROCEDURE
              sqlaconnect;
 
              tsp00_TaskId     tsp00_TaskId
              tsp00_NodeId     tsp00_NodeId
              tsp00_DbName     tsp00_DbName
              tsp00_Service    tsp00_Service
              tsp00_Int4       tsp00_Int4
              tsp00_Int4       tsp00_Int4
              tsp00_Int4       tsp00_Int4
              tsp00_ErrText    tsp00_ErrText
 
        PROCEDURE
              sqlareceive;
 
              tsp00_Int4       tsp00_Int4
              tsp1_packet_ptr  tsp1_packet_ptr
              tsp00_Int4       tsp00_Int4
              tsp00_ErrText    tsp00_ErrText
 
        PROCEDURE
              sqlarelease;
 
              tsp00_Int4 tsp00_Int4
 
        PROCEDURE
              sqlarequest;
 
              tsp00_Int4    tsp00_Int4
              tsp00_Int4    tsp00_Int4
              tsp00_ErrText tsp00_ErrText
 
        PROCEDURE
              sqlcharsetname;
 
              tsp00_KnlIdentifier tsp00_KnlIdentifier
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1995-05-29
.sp
.cp 3
.sp
.cp 3
Release :      Date : 1998-12-07
.sp
***********************************************************
.sp
.cp 20
.fo
.oc _/1
Specification:
 
In g_area gibt es einen curr_part_ptr, der immer korrekt belegt
sein muss, sonst wird abort aufgerufen. Die Initialisierung
erfolgt in i21reset, weitergesetzt wird er von i21nextpart_init
und i21newcmd.
.sp
Wenn ein Kommando aus Schluesselwoertern und Daten besteht,
ruft man erst i21reset auf, baut dann das Kommando mit i21pcmnd-
-Prozeduren auf, ruft dann i21nextpart_init auf und kann dann
die Daten mit Hilfe der i21parg-Prozeduren eintragen. Die part_kind
des durch curr_part_ptr bezeichneten Kommandoteils wird fuer den
ersten Teil mit sp1pk_command, fuer die weiteren Teile mit
sp1pk_data vorbelegt.
.sp
Es ist sehr vorzuziehen, von nun an die put-arg-Routinen zu benutzen
und nicht mehr selbst zu moven, weil auch im part_header Informationen
gepflegt werden muessen.
.sp
Alle GET-Routinen gehen davon aus, dass curr_part_ptr den Teil
bezeichnet, in dem die gewuenschten Daten (parsid, fieldinfos,
SELECT-Ergebnisse o.ae.) zu finden sind.
.sp
Von i21receive wird curr_part_ptr auf den ersten part des ersten
Ergebnisses gesetzt. Man kann in einer Schleife bis sp1r_no_of_parts
(im rcv_packet-segm_header) die part_kind abfragen, entsprechende
Verarbeitungsroutinen aufrufen und dann mit s26next_part den
naechsten Teil dieses Ergebnisses holen. Ggf. kann man sich mit
s26next_segment die Ergebnisse weiterer Kommandos abholen.
.sp
.nf;.sp
    PROCEDURE
          i21connect (
                g_area          : tin_global_in_vars;
                installation    : boolean;
                VAR charsetname : tsp00_C18;
                VAR status      : tin_connect_status);
.sp;.fo
Connect auf der durch dbno bezeichneten Datenbank. Alle Parameter
werden aus der globalen Variablen g_area entnommen. Belegung durch
VIN02, VIN25, VIN27.
.sp;.nf
 
    PROCEDURE
          i21dbnoreset (
                g_area : tin_global_in_vars);
.sp;.fo
dbno wird auf 1 gesetzt, alle VIN-Prozeduren greifen also anschliessend
auf die erste Datenbank zu.
.sp;.nf
    PROCEDURE
          i21disconnect (
                g_area : tin_global_in_vars);
.sp;.fo
Die Verbindungen zu allen durch additional_connect angesprochenen
Datenbanken werden geloest. Die Hauptverbindung (dbno 1) bleibt
dabei bestehen. Prozedurname ist irrefuehrend, es handelt sich
tatsaechlich um ein release.
.sp;.nf
    PROCEDURE
          i21oldsenderid (
                g_area : tin_global_in_vars);
.sp;.fo
Mit dieser Prozedur kann die Anwendung dem Kern ein aelteres Release
(3.1.2 und frueher) vorgaukeln, um so offiziell abgeschaffte Funktio-
nalitaet zu aktivieren.
.sp;.nf
    PROCEDURE
          i21rebuild_session (
                g_area     : tin_global_in_vars;
                VAR status : tin_connect_status);
.sp;.fo
Diese Prozedur ersetzt i21reconnect und erneuert nur die Datenbank-
verbindung, das alte Kommando ist weg. Das muss so sein, weil mit
der neuen LZU der Timeout das Auftragssegment freigibt, bevor die
Komponenten wissen, dass sie es kopieren muessten.
i20rebuild_session ersetzt i27reconnect.
.sp;.nf
    PROCEDURE
          i21release (
                g_area     : tin_global_in_vars);
.sp;.fo
Beenden der Datenbankverbindung, die durch dbno bestimmt ist.
.sp;.nf
    PROCEDURE
          i21senderid (
                g_area : tin_global_in_vars;
                compid : tsp00_C3);
.sp;.fo
Mit der neuen Auftragsschnittstelle besteht die senderid aus den
beiden Teilen appl_version (Konstante, in der Prozedur deklariert)
und application (Prozedurparameter compid).
.sp;.nf
    PROCEDURE
          i21scspecialconnect (
                g_area          : tin_global_in_vars;
                VAR status      : tin_connect_status);
.sp;.fo
Es wird nur eine LZU-Verbindung zwischen Komponente und Kern
aufgebaut, nicht auch noch eine logische, Resourcen verbrauchende
User-Session. In dieser Spezial-"Session" sind einige Kern-Befehle
möglich, insbesondere kann abgefragt werden, wie weit ein SAVE
fortgeschritten ist.
.sp;.nf
    PROCEDURE
          i21setdbno (
                g_area             : tin_global_in_vars;
                VAR symbolicdbname : tsp00_DbName;
                VAR switch_rc      : tin_connect_status );
.sp;.fo
Wenn symbolicdbname belegt ist, wird die dadurch bezeichnete
Datenbank zur aktuellen (ggf. wird ein connect ausgefuehrt),
sonst die erste Datenbank (dbno = 1).
.sp
bis hierher Prozeduren, die nicht fuer STORED PROCs benutzt werden
.sp;.nf
    PROCEDURE
          i21alternativesegment (
                g_area      : tin_global_in_vars;
                switch_stat : tin_switch_type );
.sp;.fo
Sehr vorsichtige Methode, das andere der beiden Auftragssegmente
anzusprechen. Wenn switch_stat und s_nest einander nicht entsprechen,
erfolgt ein abort.
.sp;.nf
    PROCEDURE
          i21ansimsgtext (
                g_area  : tin_global_in_vars;
                VAR msg : tin_screenline);
.sp;.fo
Der Fehlertext des ersten fehlerhaften Kommandos wird zum Aufbau
der Meldung benutzt. Diese enthaelt ausserdem den zugehoerigen
sqlstate.
.sp;.nf
    FUNCTION
          i21buflen (
                g_area  : tin_global_in_vars) : tsp00_Int4;
.sp;.fo
Die Laenge des aktuellen Part-Puffers wird zurueckgeliefert.
.sp;.nf
    PROCEDURE
          i21check_stmt (
                g_area        : tin_global_in_vars;
                VAR statement : tin_check_sql);
.sp;.fo
Der Pointer auf den aktuellen Teil des Auftrages muss genau
auf den Kommandoteil zeigen, in dem das zu untersuchende
Kommando steht.
.sp;.nf
    PROCEDURE
          i21chng... (
                g_area    : tin_global_in_vars;
                einer der folgenden Parameter:
                sqlmode   : tsp1_sqlmode;
                producer  : tsp1_producer;
                commit    : boolean;
                costwarn  : boolean;
                with_info : boolean);
.sp;.fo
Die Defaulteinstellung im Kommandosegmentheader wird
entsprechend den Vorgaben umgesetzt.
.sp;.nf
    PROCEDURE
          i21dbcrash (
                g_area : tin_global_in_vars );
.sp;.fo
Hilfsprozedur zum Simulieren eines Crashs auf der Datenbank dbno.
.sp;.nf
    FUNCTION
          i21dbok (
                g_area : tin_global_in_vars ) : boolean;
.sp;.fo
Abfrage, ob die Datenbank dbno den Status rc_ok hat.
.sp;.nf
    PROCEDURE
          i21errortext (
                g_area  : tin_global_in_vars;
                VAR msg : tin_screenline);
.sp;.fo
Der Fehlertext des ersten fehlerhaften Kommandos wird zum Aufbau
der Meldung benutzt. Diese enthaelt ausserdem die Fehlernummer.
.sp;.nf
    PROCEDURE
          i21fetchrest (
                g_area : tin_global_in_vars);
.sp;.fo
Vorbereiten des Kommandos FETCH REST (reset und pcmnd). Keine
Vorarbeiten erforderlich. Impliziter Typ ist sp1m_dbs.
.sp;.nf
    PROCEDURE
          i21findpart (
                g_area    : tin_global_in_vars;
                part_kind : tsp1_part_kind);
.sp;.fo
Diese Prozedur ruft nur dann s26find_part auf, wenn curr_part_ptr
nicht auf den richtigen part zeigt. s26find_part muss immer von
vorn suchen, weil nicht vorausgesetzt wird, dass der part_ptr
belegt ist.
.sp;.nf
    PROCEDURE
          i21finish_part (
                g_area   : tin_global_in_vars);
.sp;.fo
Diese Prozedur muss aufgerufen werden, wenn ein Kommando ganz
fertig aufgebaut ist, vor dem request.
.sp;.nf
    PROCEDURE
          i21gbuf (
                g_area   : tin_global_in_vars;
                buf_pos  : tsp00_Int4;
                VAR val  : tsp00_MoveObj;
                val_pos  : tsp00_Int4;
                move_len : tsp00_Int4);
.sp;.fo
Diese Prozedur dient beispielsweise dazu, Stuecke eines LONG-Wertes
in den Puffer val zu uebertragen. Sie ueberspringt kein undef-Byte.
Wenn val_pos + move_len - 1 > sp1p_buf_len, dann abort!
.sp;.nf
    PROCEDURE
          i21gbval (
                g_area      : tin_global_in_vars;
                l_val       : tin_natural;
                b_pos       : tsp00_Int4;
                VAR val     : tsp00_Buf;
                VAR is_null : boolean);
.sp;.fo
Die Anwendung ist selbst dafuer verantwortlich, curr_part_ptr auf
den part zeigen zu lassen, in dem die gewuenschten Daten stehen.
.sp;.nf
    FUNCTION
          i21gchar (
                g_area       : tin_global_in_vars;
                b_pos        : tsp00_Int4) : char;
.sp;.fo
Das Zeichen, welches im aktuellen Part-Puffer an der Position
b_pos steht, wird zurueckgeliefert.
.sp;.nf
    PROCEDURE
          i21gcolname (
                g_area      : tin_global_in_vars;
                pos         : tsp00_Int4;
                VAR cname   : tsp00_Name;
                VAR namlen  : integer);
.sp;.fo
Pos muss auf das Laengenbyte des gewuenschten Spaltennamens zeigen.
Der Name wird mit Blanks aufgefuellt. Wenn die Pufferlaenge kleiner
ist als pos, wird ein Blankname und namlen = 0 zurueckgeliefert.
.sp;.nf
    PROCEDURE
          i21gdescriptor (
                g_area       : tin_global_in_vars;
                VAR descript : tsp00_C8);
.sp;.fo
Ich nehme an, dass der Deskriptor (eines OPEN COLUMN etc. Kommandos)
allein in einem part der Art sp1pk_data steht und ein defined_byte
hat.
.sp;.nf
    PROCEDURE
          i21gettrans_tables (
                g_area    : tin_global_in_vars);
.sp;.fo
Zur Vermeidung zyklischer Referenzen zwischen vin27 und vin32
und weil es in Wirklichkeit keine Prozedur gibt, mit der man
mehrere Argumente ohne undef_bytes lesen kann. Ersetzt die
gleichnamige Prozedur aus vin27.
.sp;.nf
    PROCEDURE
          i21getval (
                g_area      : tin_global_in_vars;
                l_val       : tin_natural;
                b_pos       : tsp00_Int4;
                VAR val     : tsp00_Buf;
                pos         : tsp00_Int2;
                maxsize     : tsp00_Int2;
                VAR is_null : boolean);
.sp;.fo
Im Unterschied zu den anderen gval-Prozeduren wird das Ergebnis
hier nicht unbedingt an Position 1 der Ergebnispuffers geschrieben.
Ein explizites abort geschieht, wenn dabei maxsize (Groesse des
Puffers val) ueberschritten wuerde.
.sp;.nf
    PROCEDURE
          i21gloadfield (
                g_area  : tin_global_in_vars;
                info_no : tin_natural;
                VAR ffi : tsp7_ffield_info);
.sp;.fo
Ich nehme an, dass die ffield_infos in einem part der Art sp1pk_data
stehen, der die table_description enthaelt.
.sp;.nf
    PROCEDURE
          i21gparaminfo (
                g_area    : tin_global_in_vars;
                info_no   : tin_natural;
                VAR pi    : tsp1_param_info;
                VAR found : boolean);
.sp;.fo
Ersetzt i21gshortfield und i21gfieldinfo. Fuer die Spaltennamen,
die i21gfieldinfo lieferte, ist nun i21gcolname aufzurufen.
.sp;.nf
    PROCEDURE
          i21gparsid (
                g_area     : tin_global_in_vars;
                VAR parsid : tin_parsid);
.sp;.fo
Fuehrt implizit i21findpart (..., sp1pk_parsid) aus.
.sp;.nf
    PROCEDURE
          i21gpival (
                g_area      : tin_global_in_vars;
                VAR pi      : tsp1_param_info;
                val_size    : tsp00_Int4;
                VAR val     : tsp00_Buf;
                VAR is_null : boolean);
.sp;.fo
pi wird benutzt, um das defined_byte zu finden (-> is_null) und ggf.
den Wert zu lesen (Start ist bufpos + 1, Länge ist Min (val_size,
pi.in_out_l - 1).
Die Anwendung ist selbst dafuer verantwortlich, curr_part_ptr auf
den part zeigen zu lassen, in dem die gewuenschten Daten stehen.
.sp;.nf
    PROCEDURE
          i21grescount (
                g_area     : tin_global_in_vars;
                VAR known  : boolean;
                VAR count  : tsp00_Int4);
.sp;.fo
Diese Prozedur liefert einen count, der vom Kern als number angeliefert
wurde und in einem part der Art sp1pk_resultcount zu finden ist.
Es handelt sich dabei z.B. um die Anzahl von einem UPDATE betroffener
Tabellenzeilen. Wenn die Anzahl nicht bekannt ist, liefert der Kern
die Zahl -1 (z.B. bei nicht aufgebauter SELECT-Ergebnismenge).
.br
Die Vorgaengerprozedur lieferte auch die Information, ob es sich
um ein single_select handelt. Das ist dann der Fall, wenn
das Ergebnis nicht erst beim Fetch, sondern schon beim Select
angeliefert wird. Anwendungen, die an dieser Information interessiert
sind, koennen entweder (wie oben beschrieben) mit s26next_part die
parts abarbeiten oder mit s26find_retpart einen part der Art
sp1pk_data suchen.
.sp;.nf
    PROCEDURE
          i21gsetval (
                data_part : tsp1_part_ptr;
                b_pos     : tsp00_Int4;
                b_len     : tsp00_Int2;
                l_val     : tin_natural;
                VAR val   : tsp00_Buf);
.sp;.fo
Speziell fuer die Benutzung durch vin09, wo abwechselnd ein field_info
und ein Datenwert gelesen werden. Um curr_part_ptr nicht dauernd
umsetzen zu muessen, wird hier der data_part_ptr mitgegeben. NULL-Werte
kommen per definitionem nicht vor, Werte werden ggf. mit Blanks
aufgefuellt.
.sp;.nf
    PROCEDURE
          i21gvalcount (
                g_area    : tin_global_in_vars;
                VAR count : integer);
.sp;.fo
Diese Prozedur liefert einen count, der vom Kern als int2 im part header
angeliefert wird, er ist nicht Teil des Datenpuffers. Das Ergebnis ist
z.B. die Anzahl vin tsp1_param_infos oder die Anzahl der beim
MFETCH gelieferten Zeilen.
Ersatz fuer i21gmfcount und i21gspcount.
.sp;.fo
PROCEDURE
      i21gval (
            g_area      : tin_global_in_vars;
            l_val       : tin_natural;
            VAR pos     : tsp00_Int4;
            VAR val     : tsp00_Buf;
            VAR is_null : boolean);
.sp;.fo
Die Prozedur ist geeignet, Werte wie die SET-Parameter zu lesen,
deren Bedeutung und Laenge feststeht. Beim ersten Aufruf muss pos den
Wert 1 haben. Zurueckgeliefert wird der erste Wert und die Position
des naechsten Wertes, pos ist also ein in-out-Parameter.
.sp;.nf
    PROCEDURE
          i21initdbtable (
                g_area : tin_global_in_vars);
.sp;.fo
Initialisierung fuer Multi-DB-Betrieb.
.sp;.nf
    FUNCTION
          i21lnr (
                g_area       : tin_global_in_vars;
                val          : char;
                start        : tsp00_Int4;
                cnt          : tsp00_Int4) : tsp00_Int4;
.sp;.fo
s30lnr-Aufruf, bei dem der aktuelle part-Puffer als Puffer uebergeben
wird.
.sp;.nf
    PROCEDURE
          i21mfetch (
                g_area       : tin_global_in_vars;
                in_unicode   : boolean;
                m_type       : tsp1_cmd_mess_type;
                count        : tin_natural;
                dir          : tin_fetch_dir;
                VAR res_name : tsp00_Name);
.sp;.fo
Vorbereiten des Kommandos MFETCH (FIRST, ...) (reset und pcmnd). Keine
Vorarbeiten erforderlich. Parameter in_unicode gibt an, ob die
Schluesselwoerter in UNICODE geschrieben werden sollen.
.sp;.nf
    PROCEDURE
          i21mfparse (
                g_area       : tin_global_in_vars;
                dir          : tin_fetch_dir;
                cols         : integer;
                VAR res_name : tsp00_Name);
.sp;.fo
Vorbereiten des Kommandos MFETCH (FIRST, ...) (reset und pcmnd). Keine
Vorarbeiten erforderlich. Impliziter Typ ist sp1m_parse.
.sp;.nf
    PROCEDURE
          i21mfpos (
                g_area       : tin_global_in_vars;
                in_unicode   : boolean;
                m_type       : tsp1_cmd_mess_type;
                count        : tin_natural;
                fetchpos     : tsp00_Int4;
                VAR res_name : tsp00_Name);
.sp;.fo
Vorbereiten des Kommandos MFETCH POS (reset und pcmnd). Keine
Vorarbeiten erforderlich. Message-Typ wie uebergeben.
count gibt an, wieviele Ergebnisse gewuenscht werden, fetchpos
bezeichnet die Startzeile in der Ergebnistabelle. Parameter
in_unicode gibt an, ob die Schluesselwoerter in UNICODE geschrieben
werden sollen.
.sp;.nf
    PROCEDURE
          i21movecmnd (
                g_area : tin_global_in_vars;
                VAR s  : tsp00_MoveObj;
                pos    : tin_natural;
                l_s    : tin_natural);
.sp;.fo
Im Gegensatz zu den i21pcmnd-Routinen wird hier nicht zwangslaeufig
ab Position 1 gelesen. Das spezifizierte Stueck des Puffers wird
an das aufgebaute Kommando angehaengt.
.sp;.nf
    PROCEDURE
          i21newcmd (
                g_area : tin_global_in_vars;
                m_type : tsp1_cmd_mess_type);
.sp;.fo
i21reset initialisiert den Auftragsheader und den Header des
ersten Kommandos. Mit dieser Prozedur kann der Header von
weiteren Kommandos initialisiert werden, die im selben Auftrag
geschickt werden sollen.
.sp;.nf
    PROCEDURE
          i21nextpart_init (
                g_area       : tin_global_in_vars);
.sp;.fo
Diese Prozedur arbeitet mit dem snd_packet! Sie ruft implizit
finish_part auf und initialisiert dann einen weiteren part
im selben Kommando. Wenn viele Kommandos mit einem Auftrag
geschickt werden, ist die Prozedur teuer, weil aus dem
curr_part_ptr nicht hervorgeht, zu welchem cmd_segm er gehoert,
d.h. man muss sich Kommando fuer Kommando vorwaertshangeln. Sollte
sich diese Anwendung als haeufig erweisen, dann muessen wir neben
dem curr_part_ptr auch noch einen curr_segm_ptr in g_area halten.
.sp;.nf
    PROCEDURE
          i21parg (
                g_area      : tin_global_in_vars;
                l_arg       : tin_natural;
                VAR pos     : tsp00_Int4;
                VAR arg     : tsp00_Buf;
                is_null     : boolean);
.sp;.fo
Die Prozedur ist geeignet, Werte wie die SET-Parameter zu schreiben,
deren Reihenfolge und Laenge feststeht. Beim ersten Aufruf muss
pos den Wert 1 haben. Zurueckgeliefert wird die Position, an die
der naechste Wert geschrieben werden kann. Der arg_count wird
jedesmal erhoeht.
.sp;.nf
    FUNCTION
          i21partfreespace (
                g_area  : tin_global_in_vars) : tsp00_Int4;
.sp;.fo
Die Funktion liefert die Anzahl der noch freien Bytes im
durch curr_part_ptr bezeichneten part (egal, ob command- oder
data-part). Ersatz fuer i21cmndfreespace und i21argfreespace.
.sp;.nf
    PROCEDURE
          i21pbarg (
                g_area  : tin_global_in_vars;
                VAR arg : tsp00_Buf;
                b_pos   : tsp00_Int4;
                l_arg   : tin_natural;
                is_null : boolean);
.sp;.fo
Ich habe auf ein abort verzichtet, falls nicht p_reset oder der
Wert laenger ist als der vorhandene Platz. In diesen Faellen tut
die Prozedur einfach nichts. Sonst schreibt sie den Wert an die
durch b_pos bezeichnete Stelle und erhoeht den arg_count. Part_kind
muss von der Anwendung selbst gesetzt werden.
.sp;.nf
    PROCEDURE
          i21pbuf (
                g_area   : tin_global_in_vars;
                buf_pos  : tsp00_Int4;
                VAR val  : tsp00_MoveObj;
                from_pos : tsp00_Int4;
                move_len : tsp00_Int4);
.sp;.fo
Diese Prozedur dient beispielsweise dazu, Stuecke eines LONG-Wertes
in das Auftragssegment zu uebertragen. Sie schreibt kein undef-Byte
und veraendert nicht sp1p_arg_count.
.sp;.nf
    PROCEDURE
          i21pcmnd (
                g_area : tin_global_in_vars;
                VAR s  : tsp00_Buf;
                l_s    : tin_natural);
.sp;.fo
Ein Stueck Kommandotext wird an das aufgebaute Kommando angehaengt.
Einige der pcmnd-Routinen schreiben Objekte fester Laenge (z.B.
username) und brauchen den Parameter l_s nicht. Allen pcmnd-Prozeduren
gemeinsam ist, dass sie nichts tun, wenn p_reset nicht gilt.
.sp;.nf
    PROCEDURE
          i21pdescriptor (
                g_area       : tin_global_in_vars;
                VAR descript : tsp00_C8);
.sp;.fo
Diese Prozedur gehoert zu den i21parg-Routinen und schreibt das
Argument fester L?ange descript. Arg_count wird erhoeht.
.sp;.nf
    PROCEDURE
          i21pparsid (
                g_area     : tin_global_in_vars;
                VAR parsid : tin_parsid);
.sp;.fo
Diese Prozedur schreibt das Spezialkommando fester L?ange parsid.
Die Anwendung muss entscheiden, ob part_kind sp1pk_parsid oder
sp1pk_parsid_of_select zutrifft.
.sp;.nf
    PROCEDURE
          i21ppw (
                g_area : tin_global_in_vars;
                VAR pw : tsp00_CryptPw );
.sp;.fo
Diese Prozedur gehoert zu den i21parg-Routinen und schreibt das
Argument fester L?ange pw. Arg_count wird erhoeht.
.sp;.nf
    PROCEDURE
          i21pstring (
                g_area : tin_global_in_vars;
                VAR s  : tsp00_Buf;
                l_s    : tin_natural);
.sp;.fo
Diese Prozedur gehoert zu den i21pcmnd-Routinen und schreibt die
Zeichenkette s eingeschlossen in einfache quotes und mit abschliessendem
Komma. Siehe auch i21repcmnd.
.sp;.nf
    PROCEDURE
          i21repcmnd (
                g_area : tin_global_in_vars;
                c      : char);
.sp;.fo
Statt wie i21pccmnd ein Zeichen an den Kommandostring anzuhaengen,
ueberschreibt diese Prozedur das letzte Zeichen (z.B. das letzte
Komma einer i21pstring-Kette ersetzen durch Klammer zu).
.sp;.nf
    PROCEDURE
          i21request (
                g_area        : tin_global_in_vars;
                VAR rq_status : tin_connect_status);
.sp;.fo
Der vorbereitete Auftrag wird an den Datenbankkern geschickt.
.sp;.nf
    PROCEDURE
          i21receive (
                g_area         : tin_global_in_vars;
                VAR rc_status  : tin_connect_status;
                VAR sqlstate   : tsp00_SqlState;
                VAR returncode : tsp00_Int2;
                VAR errorpos   : tsp00_Int4);
.sp;.fo
Das Ergebnis des an den Datenbankkern geschickten Auftrages wird
abgeholt. Dies muss geschehen, bevor ein eventuell im zweiten
Auftragssegment vorbereiteter Auftrag abgeschickt wird.
.sp;.nf
    PROCEDURE
          i21reset (
                g_area : tin_global_in_vars;
                m_type : tsp1_cmd_mess_type);
.sp;.fo
Ein neuer Auftrag wird vorbereitet. Rte_header und header des
Auftragssegmentes werden initialisiert, das erste cmd_segm mit
seinem ersten part wird eingerichtet. Auf diesen part zeigt
curr_part_ptr.
.sp;.nf
    PROCEDURE
          i21rfpos (
                g_area       : tin_global_in_vars;
                m_type       : tsp1_cmd_mess_type;
                count        : tin_natural;
                fetchpos     : tsp00_Int4;
                VAR res_name : tsp00_KnlIdentifier);
.sp;.fo
Vorbereiten des Kommandos RFETCH POS (reset und pcmnd). Keine
Vorarbeiten erforderlich. Message-Typ wie uebergeben.
count gibt an, wieviele Ergebnisse gewuenscht werden, fetchpos
bezeichnet die Startzeile in der Ergebnistabelle.
.sp;.nf
    PROCEDURE
          i21setksession (
                g_area     : tin_global_in_vars;
                VAR parsid : tin_parsid);
.sp;.fo
Offensichtlich ist in den ersten vier Bytes der parsid die session-
-Nummer enthalten, denn diese werden als ksession der aktuellen
Datenbank vermerkt.
.sp;.nf
    PROCEDURE
          i21setsqlptr (
                g_area    : tin_global_in_vars;
                packet_no : integer);
.sp;.fo
Packet_no gibt die Nummer des gewuenschten curr_packet an,
sql_ptr wird entsprechend umgesetzt.
.sp;.nf
    PROCEDURE
          i21tosendreset (
                g_area : tin_global_in_vars);
.sp;.fo
Die Pointer werden nach dem Receive so umgesetzt, dass derselbe Auftrag
noch einmal abgeschickt werden kann. Das Kommando bleibt ja unveraendert
im send_packet stehen.
.sp;.nf
    FUNCTION
          i21validpid (
                g_area     : tin_global_in_vars;
                VAR parsid : tin_parsid) : boolean;
.sp;.fo
Nachdem mit i21setksession der signifikante Teil einer bekannt
gueltigen parsid aufgehoben wurde, kann nun durch Vergleich
festgestellt werden, ob die gegebene parsid in der aktuellen
session gueltig ist.
.sp;.fo
FUNCTION
      i21valisnull (
            g_area : tin_global_in_vars;
            pos    : tsp00_Int4) : boolean;
.sp;.fo
Die Funktion liefert TRUE, wenn im aktuellen Part an der Position
pos ein undef_byte steht.
 
.CM *-END-* specification -------------------------------
.sp 2.fo
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      database_okay           = 0;
      database_not_accessible = -8000;
      user_not_connected      = -8001;
      packet_stat_error       = -8888;
      no_memory_for_restab    = -904;
 
 
(*------------------------------*) 
 
PROCEDURE
      i21advpart (
            g_area : tin_global_in_vars);
 
BEGIN
WITH g_area^.sql_ptr^ DO
    s26nextpart (curr_part_ptr);
(*ENDWITH*) 
END; (* i21advpart *)
 
(*------------------------------*) 
 
PROCEDURE
      i21advsegment (
            g_area : tin_global_in_vars);
 
BEGIN
WITH g_area^.sql_ptr^ DO
    BEGIN
    s26next_segment ( curr_segm_ptr);
    curr_part_ptr := NIL;
    END;
(*ENDWITH*) 
END; (* i21advsegment *)
 
(*------------------------------*) 
 
PROCEDURE
      i21cleanreset (
            g_area : tin_global_in_vars;
            m_type : tsp1_cmd_mess_type);
 
BEGIN
WITH g_area^, sql_ptr^  DO
    BEGIN
    IF  (packet_stat = p_waiting) OR
        (packet_stat = p_reset)
    THEN
        BEGIN
        WITH snd_packet_ptr^.sp1_header DO
            BEGIN
            sp1h_mess_code := i20.code_type;
            sp1h_mess_swap := i20.swap;
            sp1h_appl_version := g_area^.i20.appl_version;
            sp1h_application  := g_area^.i20.application;
            END;
        (*ENDWITH*) 
        s26first_segment_init (snd_packet_ptr, sp1sk_cmd,
              curr_segm_ptr);
        curr_segm_ptr^.sp1c_mess_type := m_type;
        curr_segm_ptr^.sp1c_mass_cmd := false;
        curr_part_ptr := NIL;
        packet_stat:= p_reset;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* i21cleanreset *)
 
&ifndef INLINK
(*------------------------------*) 
 
PROCEDURE
      i21connect (
            g_area          : tin_global_in_vars;
            installation    : boolean;
            VAR charsetname : tsp00_KnlIdentifier;
            VAR status      : tin_connect_status);
 
BEGIN
i21_xconnect ( g_area, installation, charsetname, status );
END; (* i21connect *)
 
(*------------------------------*) 
 
PROCEDURE
      i21dbnoreset (
            g_area : tin_global_in_vars);
 
BEGIN
i21switchsession (g_area, 1);
END; (* i21dbnoreset *)
 
(*------------------------------*) 
 
PROCEDURE
      i21mdbsrelease (
            g_area         : tin_global_in_vars;
            VAR dbname_arg : tsp00_DbName);
 
VAR
      i : integer;
 
BEGIN
WITH g_area^ DO
    FOR i := 2 TO mxin_dbs DO
        WITH session [i] DO
            BEGIN
            IF  dbname_arg = symbolic_dbname
            THEN
                BEGIN
                i21switchsession (g_area, i);
                i21release (g_area);
                symbolic_dbname  := bsp_dbname;
                as_utility := false;
                nolog_session := false;
                i21switchsession (g_area, 1);
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDFOR*) 
(*ENDWITH*) 
END; (* i21mdbsrelease *)
 
(*------------------------------*) 
 
PROCEDURE
      i21mdbsrterelease (
            g_area         : tin_global_in_vars;
            VAR dbname_arg : tsp00_DbName);
 
VAR
      i : integer;
 
BEGIN
WITH g_area^ DO
    FOR i := 2 TO mxin_dbs DO
        WITH session [i] DO
            BEGIN
            IF  dbname_arg = symbolic_dbname
            THEN
                BEGIN
                i21switchsession (g_area, i);
                i21rterelease (g_area);
                symbolic_dbname  := bsp_dbname;
                as_utility := false;
                nolog_session := false;
                i21switchsession (g_area, 1);
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDFOR*) 
(*ENDWITH*) 
END; (* i21mdbsrterelease *)
 
(*------------------------------*) 
 
PROCEDURE
      i21disconnect (
            g_area : tin_global_in_vars);
 
VAR
      i : integer;
 
BEGIN
FOR i := 2 TO mxin_dbs DO
    BEGIN
    IF  g_area^.session [i].symbolic_dbname <> bsp_dbname
    THEN
        BEGIN
        i21switchsession (g_area, i);
        i21release (g_area);
        g_area^.session [i].symbolic_dbname := bsp_dbname
        END;
    (*ENDIF*) 
    END;
(*ENDFOR*) 
i21switchsession (g_area, 1);
END; (* i21disconnect *)
 
(*------------------------------*) 
 
PROCEDURE
      i21oldsenderid (
            g_area : tin_global_in_vars);
 
VAR
      termid        : tsp00_TermId;
      i             : integer;
      offset        : integer;
 
BEGIN
sqltermid (termid);
i := mxsp_termid;
WHILE termid [i] = bsp_c1 DO
    i := i - 1;
(*ENDWHILE*) 
IF  i < mxsp_c8
THEN
    offset := 1
ELSE
    offset := i - mxsp_c8;
(*ENDIF*) 
FOR i := 1 TO mxsp_c5 DO
    g_area^.i20.appl_version [i] := termid [offset + i];
(*ENDFOR*) 
offset := offset + mxsp_c5;
FOR i := 1 TO mxsp_c3 DO
    g_area^.i20.application [i] := termid [offset + i];
(*ENDFOR*) 
END; (* i21oldsenderid *)
 
(*------------------------------*) 
 
PROCEDURE
      i21rebuild_session (
            g_area     : tin_global_in_vars;
            VAR status : tin_connect_status);
 
VAR
      charsetname : tsp00_KnlIdentifier;
 
BEGIN
sqlcharsetname (charsetname);
g_area^.session [g_area^.dbno].connect_status := rc_ok;
i21connect (g_area, false, charsetname, status);
END; (* i21rebuild_session *)
 
(*------------------------------*) 
 
PROCEDURE
      i21release (
            g_area     : tin_global_in_vars);
 
CONST
      c_str     = 'COMMIT WORK RELEASE ';
      c_str_len = 20;
 
VAR
      s          : tsp00_C20;
      status     : tin_connect_status;
      sqlstate   : tsp00_SqlState;
      returncode : tsp00_Int2;
      errorpos   : tsp00_Int4;
      m_type     : tsp1_cmd_mess_type;
 
BEGIN
WITH g_area^ DO
    BEGIN
    IF  session [dbno].is_connected
    THEN
        BEGIN
        IF  session [dbno].as_utility
        THEN
            m_type := sp1m_utility
        ELSE
            m_type := sp1m_dbs;
        (*ENDIF*) 
        i21reset (g_area, m_type);
        s := c_str;
        i21p1cmnd (g_area, s, c_str_len);
        i21request (g_area, status);
        IF  status = rc_ok
        THEN
            i21receive (g_area, status, sqlstate, returncode, errorpos);
        (* ENDE release *)
        (*ENDIF*) 
        IF  status <> rc_timeout
        THEN
            BEGIN
            in21_rte_release (g_area);
            END;
        (*ENDIF*) 
        sql_ptr^.packet_stat := p_waiting;
        g_area^.session [dbno].is_connected := FALSE;
        END;
    (*ENDIF*) 
    END; (* ENDE stop_session *)
(*ENDWITH*) 
END; (* i21release *)
 
&ifndef INLINK
(*------------------------------*) 
 
PROCEDURE
      i21scspecialconnect (
            g_area          : tin_global_in_vars;
            VAR status      : tin_connect_status);
 
VAR
      aid         : tsp00_TaskId;
      result      : tsp1_comm_error;
      errtext     : tsp00_ErrText;
 
BEGIN
IF  i21dbok (g_area)
THEN
    BEGIN
    sqluid (aid);
    WITH g_area^ DO
        BEGIN
        (* regardless of session[dbno].as_utility, service := sql_user *)
        session [dbno].service := sql_user;
        errtext := bsp_c40;
        in21_rte_connect (g_area, aid, errtext, result);
        IF  result <> sp1ce_ok
        THEN
            in21_rte_errtext (g_area, errtext);
        (*ENDIF*) 
        status := in21_transformed_result (g_area, result);
        END; (* ENDE start_session *)
    (*ENDWITH*) 
    g_area^.session [g_area^.dbno].is_connected := (status = rc_ok);
    IF  NOT (status in [rc_ok, rc_timeout, rc_dbms_start_required] )
    THEN
        BEGIN
        WITH g_area^ DO
            BEGIN
            in21_rte_release (g_area);
            g_area^.session [g_area^.dbno].is_connected := FALSE;
            END;
        (*ENDWITH*) 
        END; (* ENDE stop_session *)
    (*ENDIF*) 
    g_area^.session [g_area^.dbno].connect_status := status;
    END
ELSE
    status := g_area^.session [g_area^.dbno].connect_status;
(*ENDIF*) 
END; (* in21scspecialconnect *)
 
&endif
(*------------------------------*) 
 
PROCEDURE
      i21setdbno (
            g_area             : tin_global_in_vars;
            VAR symbolicdbname : tsp00_DbName;
            VAR switch_rc      : tin_connect_status );
 
VAR
      i           : integer;
      found       : boolean;
      charsetname : tsp00_KnlIdentifier;
 
BEGIN
IF  symbolicdbname <> bsp_dbname
THEN
    BEGIN
    found := FALSE;
    i := 1;
    WHILE (i <= mxin_dbs) AND (NOT found) DO
        BEGIN
        IF  symbolicdbname = g_area^.session [i].symbolic_dbname
        THEN
            BEGIN
            found := TRUE;
            i21switchsession (g_area, i);
            IF  NOT g_area^.session [i].is_connected
            THEN
                BEGIN
                sqlcharsetname (charsetname); (* ADIS #1001741 *)
                i21_xconnect (g_area, false, charsetname, switch_rc);
                END
            ELSE
                switch_rc := rc_ok;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        i := i + 1;
        END;
    (*ENDWHILE*) 
    IF  NOT found
    THEN
        switch_rc := rc_unknown_symbolic_dbname;
    (*ENDIF*) 
    END
ELSE
    BEGIN
    switch_rc    := rc_ok;
    i21switchsession (g_area, 1);
    END;
(*ENDIF*) 
END; (* i21setdbno *)
 
&endif
(*------------------------------*) 
 
PROCEDURE
      i21alternativesegment (
            g_area      : tin_global_in_vars;
            switch_stat : tin_switch_type );
 
VAR
      error : boolean;
 
BEGIN
error := false;
WITH g_area^, session [dbno] DO
    BEGIN
    IF  switch_stat = switch_on
    THEN
        BEGIN
        IF  packet_nesting = 0
        THEN
            BEGIN
            IF  curr_packet = 1
            THEN
                curr_packet := 2
            ELSE
                curr_packet := 1;
            (*ENDIF*) 
            packet_nesting := 1;
            END
        ELSE
            error := true;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        IF  packet_nesting = 1
        THEN
            BEGIN
            IF  curr_packet = 1
            THEN
                curr_packet := 2
            ELSE
                curr_packet := 1;
            (*ENDIF*) 
            packet_nesting := 0;
            END
        ELSE
            error := true;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    sql_ptr := @packet_control [curr_packet];
    END;
(*ENDWITH*) 
IF  error
THEN
    i21abort;
(*ENDIF*) 
END; (* i21alternativesegment *)
 
(*------------------------------*) 
 
PROCEDURE
      i21ansimsgtext (
            g_area  : tin_global_in_vars;
            VAR msg : tin_screenline);
 
VAR
      translate : boolean;
      len       : integer;
      max       : tsp00_Int4;
 
BEGIN
WITH g_area^.sql_ptr^  DO
    BEGIN
    in21_find_errortext (g_area, translate);
    SAPDB_PascalForcedFill (mxin_screenline, @msg, 1, mxin_screenline, ' ');
    IF  curr_part_ptr <> NIL
    THEN
        BEGIN
        s10mv (SQLSTATE_MXSP00,mxin_screenline,
              @curr_segm_ptr^.sp1r_sqlstate,1,
              @msg,1,SQLSTATE_MXSP00);
        WITH curr_part_ptr^ DO
            BEGIN
            IF  translate
            THEN
                max := 140
            ELSE
                max := 70;
            (*ENDIF*) 
            IF  sp1p_buf_len > max
            THEN
                len := max
            ELSE
                len := sp1p_buf_len;
            (*ENDIF*) 
            IF  translate
            THEN
                BEGIN
                max := sizeof (msg) - SQLSTATE_MXSP00 - 1;
                in21_msg_trans (g_area,
                      s30gad1 (msg [SQLSTATE_MXSP00 + 2]), len, max)
                END
            ELSE
                s10mv (sp1p_buf_size,sizeof (msg),
                      @sp1p_buf,1,
                      @msg,SQLSTATE_MXSP00 + 2,len);
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* i21ansimsgtext *)
 
(*------------------------------*) 
 
FUNCTION
      i21buflen (
            g_area  : tin_global_in_vars) : tsp00_Int4;
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        i21buflen := curr_part_ptr^.sp1p_buf_len;
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21buflen *)
 
(*------------------------------*) 
 
PROCEDURE
      i21check_stmt (
            g_area        : tin_global_in_vars;
            is_unicode    : boolean;
            VAR statement : tin_check_sql);
 
CONST
      k_commit            = 'COMMIT    ';
      k_connect           = 'CONNECT   ';
      k_crosstab          = 'CROSSTAB  ';
      k_dbproc            = 'DBPROC    ';
      k_delete            = 'DELETE    ';
      k_direct            = 'DIRECT    ';
      k_explain           = 'EXPLAIN   ';
      k_fetch             = 'FETCH     ';
      k_first             = 'FIRST     ';
      k_format            = 'FORMAT    ';
      k_language          = 'LANGUAGE  ';
      k_last              = 'LAST      ';
      k_mfetch            = 'MFETCH    ';
      k_next              = 'NEXT      ';
      k_prev              = 'PREV      ';
      k_release           = 'RELEASE   ';
      k_role              = 'ROLE      ';
      k_rollback          = 'ROLLBACK  ';
      k_select            = 'SELECT    ';
      k_session           = 'SESSION   ';
      k_set               = 'SET       ';
      k_show              = 'SHOW      ';
      k_statistics        = 'STATISTICS';
      k_update            = 'UPDATE    ';
 
VAR
      s10       : tsp00_C10;
      pos       : tsp00_Int4;
 
BEGIN
WITH g_area^.sql_ptr^ , curr_part_ptr^ DO
    BEGIN
    IF  is_unicode
    THEN
        BEGIN
        pos := 2;
        WHILE (sp1p_buf [pos] in [' ', '(']) AND (pos <= sp1p_buf_len) DO
            IF  sp1p_buf [pos - 1] = csp_unicode_mark
            THEN
                pos := pos + 2
            ELSE
                pos := sp1p_buf_len + 1;
            (*ENDIF*) 
        (*ENDWHILE*) 
        END
    ELSE
        BEGIN
        pos := 1;
        WHILE (sp1p_buf [pos] in [' ', '(']) AND (pos <= sp1p_buf_len) DO
            pos := pos + 1;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    s10 := bsp_c10;
    in21_word (is_unicode, sp1p_buf, sp1p_buf_len, pos, s10);
    END;
(*ENDWITH*) 
IF  s10 [1] <= 'K'
THEN
    BEGIN
    IF  s10 = k_commit
    THEN
        statement := cs_commit
    ELSE
        IF  s10 = k_connect
        THEN
            statement := cs_connect
        ELSE
            IF  s10 = k_crosstab
            THEN
                statement := cs_crosstab
            ELSE
                IF  s10 = k_dbproc
                THEN
                    statement := cs_dbproc
                ELSE
                    IF  s10 = k_delete
                    THEN
                        statement := cs_delete
                    ELSE
                        IF  s10 = k_explain
                        THEN
                            statement := cs_explain
                        ELSE
                            IF  s10 = k_fetch
                            THEN
                                statement := cs_fetch
                            ELSE
                                statement := cs_nothing_special;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END
ELSE
    BEGIN
    IF  s10 = k_mfetch
    THEN
        statement := cs_mfetch
    ELSE
        IF  s10 = k_rollback
        THEN
            statement := cs_rollback
        ELSE
            IF  s10 = k_select
            THEN
                statement := cs_select
            ELSE
                IF  s10 = k_set
                THEN
                    statement := cs_set_others
                ELSE
                    IF  s10 = k_show
                    THEN
                        statement := cs_show
                    ELSE
                        IF  s10 = k_update
                        THEN
                            statement := cs_update
                        ELSE
                            statement := cs_nothing_special;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (statement = cs_commit) OR
    (statement = cs_rollback)
THEN
    WITH g_area^.sql_ptr^ , curr_part_ptr^ DO
        BEGIN
        (* COMMIT /WORK/ RELEASE or ROLLBACK /WORK/ RELEASE *)
        in21_next_char (is_unicode, sp1p_buf, sp1p_buf_len, pos);
        s10 := bsp_c10;
        in21_word (is_unicode, sp1p_buf, sp1p_buf_len, pos, s10);
        IF  s10 = k_release
        THEN
            statement := cs_release
        ELSE
            BEGIN
            in21_next_char (is_unicode, sp1p_buf, sp1p_buf_len, pos);
            s10 := bsp_c10;
            in21_word (is_unicode, sp1p_buf, sp1p_buf_len, pos, s10);
            IF  s10 = k_release
            THEN
                statement := cs_release;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  (statement = cs_select)
THEN
    WITH g_area^.sql_ptr^ , curr_part_ptr^ DO
        BEGIN
        in21_next_char (is_unicode, sp1p_buf, sp1p_buf_len, pos);
        s10 := bsp_c10;
        in21_word (is_unicode, sp1p_buf, sp1p_buf_len, pos, s10);
        IF  s10 = k_direct
        THEN
            statement := cs_select_direct
        ELSE
            IF  s10 = k_first
            THEN
                statement := cs_select_first
            ELSE
                IF  s10 = k_last
                THEN
                    statement := cs_select_last
                ELSE
                    IF  s10 = k_next
                    THEN
                        statement := cs_select_next
                    ELSE
                        IF  s10 = k_prev
                        THEN
                            statement := cs_select_prev;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  (statement = cs_set_others)
THEN
    WITH g_area^.sql_ptr^ , curr_part_ptr^ DO
        BEGIN
        in21_next_char (is_unicode, sp1p_buf, sp1p_buf_len, pos);
        s10 := bsp_c10;
        in21_word (is_unicode, sp1p_buf, sp1p_buf_len, pos, s10);
        IF  s10 = k_format
        THEN
            statement := cs_set_format
        ELSE
            IF  s10 = k_language
            THEN
                statement := cs_set_language
            ELSE
                IF  s10 = k_role
                THEN
                    statement := cs_set_role
                ELSE
                    IF  s10 = k_session
                    THEN
                        statement := cs_set_session;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  (statement = cs_update)
THEN
    WITH g_area^.sql_ptr^ , curr_part_ptr^ DO
        BEGIN
        in21_next_char (is_unicode, sp1p_buf, sp1p_buf_len, pos);
        s10 := 'STATISTICS';
        in21_word (is_unicode, sp1p_buf, sp1p_buf_len, pos, s10);
        IF  s10 = k_statistics
        THEN
            statement := cs_update_stat
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END; (* i21check_stmt *)
 
(*------------------------------*) 
 
PROCEDURE
      i21chngargcount (
            g_area    : tin_global_in_vars;
            argcount  : tsp00_Int2);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        curr_part_ptr^.sp1p_arg_count := argcount;
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21chngargcount *)
 
(*------------------------------*) 
 
PROCEDURE
      i21chngattributes (
            g_area      : tin_global_in_vars;
            attributes  : tsp1_part_attr);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        curr_part_ptr^.sp1p_attributes := attributes;
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21chngattributes *)
 
(*------------------------------*) 
 
PROCEDURE
      i21chngcodetype (
            g_area    : tin_global_in_vars;
            mess_code : tsp00_CodeType);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  packet_stat = p_reset
    THEN
        WITH snd_packet_ptr^.sp1_header DO
            sp1h_mess_code := mess_code;
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21chngcodetype *)
 
(*------------------------------*) 
 
PROCEDURE
      i21chngcommit (
            g_area    : tin_global_in_vars;
            commit    : boolean);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_segm_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  curr_segm_ptr^.sp1s_segm_kind <> sp1sk_cmd
        THEN
            i21abort
        ELSE
            IF  packet_stat = p_reset
            THEN
                curr_segm_ptr^.sp1c_commit_immediately := commit;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21chngcommit *)
 
(*------------------------------*) 
 
PROCEDURE
      i21chngcostwarn (
            g_area    : tin_global_in_vars;
            costwarn  : boolean);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_segm_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  curr_segm_ptr^.sp1s_segm_kind <> sp1sk_cmd
        THEN
            i21abort
        ELSE
            IF  packet_stat = p_reset
            THEN
                curr_segm_ptr^.sp1c_ignore_costwarning :=
                      NOT costwarn;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21chngcostwarn *)
 
(*------------------------------*) 
 
PROCEDURE
      i21chnginfo (
            g_area    : tin_global_in_vars;
            with_info : boolean);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_segm_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  curr_segm_ptr^.sp1s_segm_kind <> sp1sk_cmd
        THEN
            i21abort
        ELSE
            IF  packet_stat = p_reset
            THEN
                curr_segm_ptr^.sp1c_with_info := with_info;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21chnginfo *)
 
(*------------------------------*) 
 
PROCEDURE
      i21chngmasscmd (
            g_area     : tin_global_in_vars;
            is_masscmd : boolean);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_segm_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  curr_segm_ptr^.sp1s_segm_kind <> sp1sk_cmd
        THEN
            i21abort
        ELSE
            IF  packet_stat = p_reset
            THEN
                curr_segm_ptr^.sp1c_mass_cmd := is_masscmd;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21chngmasscmd *)
 
(*------------------------------*) 
 
PROCEDURE
      i21chngmesstype (
            g_area    : tin_global_in_vars;
            messtype  : tsp1_cmd_mess_type);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_segm_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  curr_segm_ptr^.sp1s_segm_kind <> sp1sk_cmd
        THEN
            i21abort
        ELSE
            IF  packet_stat = p_reset
            THEN
                curr_segm_ptr^.sp1c_mess_type := messtype;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21chngmesstype *)
 
(*------------------------------*) 
 
PROCEDURE
      i21chngmode (
            g_area    : tin_global_in_vars;
            sqlmode   : tsp1_sqlmode);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_segm_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  curr_segm_ptr^.sp1s_segm_kind <> sp1sk_cmd
        THEN
            i21abort
        ELSE
            curr_segm_ptr^.sp1c_sqlmode := sqlmode;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21chngmode *)
 
(*------------------------------*) 
 
PROCEDURE
      i21chngpartkind (
            g_area    : tin_global_in_vars;
            part_kind : tsp1_part_kind);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        curr_part_ptr^.sp1p_part_kind := part_kind;
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21chngpartkind *)
 
(*------------------------------*) 
 
PROCEDURE
      i21chngproducer (
            g_area    : tin_global_in_vars;
            producer  : tsp1_producer);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_segm_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  curr_segm_ptr^.sp1s_segm_kind <> sp1sk_cmd
        THEN
            i21abort
        ELSE
            IF  packet_stat = p_reset
            THEN
                curr_segm_ptr^.sp1c_producer := producer;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21chngproducer *)
 
(*------------------------------*) 
 
PROCEDURE
      i21dbcrash (
            g_area : tin_global_in_vars );
 
BEGIN
WITH g_area^.session [g_area^.dbno] DO
    BEGIN
    is_connected := false;
    connect_status := rc_crash;
    END;
(*ENDWITH*) 
END; (* i21dbcrash *)
 
(*------------------------------*) 
 
FUNCTION
      i21dbok (
            g_area : tin_global_in_vars ) : boolean;
 
BEGIN
i21dbok := g_area^.session [g_area^.dbno].connect_status = rc_ok;
END; (* i21dbok *)
 
(*------------------------------*) 
 
PROCEDURE
      i21errortext (
            g_area  : tin_global_in_vars;
            VAR msg : tin_screenline);
 
VAR
      translate : boolean;
      pos       : integer;
      abs_code  : integer;
      errcode   : tsp00_Int2;
      len       : tsp00_Int4;
      err_ptr   : tsp00_MoveObjPtr;
 
BEGIN
translate := false;
IF  i21dbok (g_area)
    (* IF  (g_area^.sql_ptr <> NIL) AND
          (g_area^.sql_ptr^.rcv_packet_ptr <> NIL) *)
THEN
    BEGIN
    in21_find_errortext (g_area, translate);
    WITH g_area^.sql_ptr^ DO
        IF  curr_part_ptr <> NIL
        THEN
            BEGIN
            err_ptr := s30gad2 (curr_part_ptr^.sp1p_buf);
            errcode := curr_segm_ptr^.sp1r_returncode;
            len := curr_part_ptr^.sp1p_buf_len;
            IF  translate
            THEN
                len := len DIV 2;
            (*ENDIF*) 
            END
        ELSE
            IF  g_area^.i20.errcode = no_memory_for_restab
            THEN
                BEGIN
                err_ptr := s30gad (g_area^.i20.errmsg);
                errcode := g_area^.i20.errcode;
                len     := sizeof(g_area^.i20.errmsg);
                END
            ELSE
                err_ptr := NIL;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDWITH*) 
    END
ELSE
    BEGIN
    err_ptr := s30gad (g_area^.i20.errmsg);
    errcode := g_area^.i20.errcode;
    len     := sizeof(g_area^.i20.errmsg);
    END;
(*ENDIF*) 
SAPDB_PascalForcedFill (mxin_screenline, @msg, 1, mxin_screenline, bsp_c1);
IF  err_ptr <> NIL
THEN
    BEGIN
    IF  errcode <> 0
    THEN
        BEGIN
        pos := 6;
        abs_code := abs (errcode);
        WHILE (pos > 1) AND (abs_code > 0) DO
            BEGIN
            msg [pos] := chr (ord ('0') + (abs_code MOD 10));
            abs_code := abs_code DIV 10;
            pos := pos - 1;
            END;
        (*ENDWHILE*) 
        IF  errcode < 0
        THEN
            msg [pos ] := '-';
        (*ENDIF*) 
        IF  len > sizeof (msg) - 7
        THEN
            len := sizeof (msg) - 7;
        (*ENDIF*) 
        IF  translate
        THEN
            in21_msg_trans (g_area, s30gad1 (msg [8]), len * 2, len)
        ELSE
            s10mv (MOVEOBJ_MXSP00,mxin_screenline,
                  @err_ptr^,1,
                  @msg,8,len);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END; (* i21errortext *)
 
(*------------------------------*) 
 
PROCEDURE
      i21fetchrest (
            g_area : tin_global_in_vars);
 
CONST
      mf_str     = 'FETCH REST          ';
      mf_str_len = 11;
 
VAR
      s      : tsp00_C20;
 
BEGIN
IF  (g_area^.sql_ptr^.packet_stat = p_waiting)
    OR (g_area^.sql_ptr^.packet_stat = p_reset)
THEN
    i21reset (g_area, sp1m_dbs);
(*ENDIF*) 
s := mf_str;
i21p1cmnd (g_area, s, mf_str_len);
i21finish_part (g_area);
END; (* i21fetchrest *)
 
(*------------------------------*) 
 
PROCEDURE
      i21findpart (
            g_area    : tin_global_in_vars;
            part_kind : tsp1_part_kind);
 
BEGIN
WITH g_area^.sql_ptr^ DO
    BEGIN
    s26find_part (curr_segm_ptr^, part_kind, curr_part_ptr);
    END;
(*ENDWITH*) 
END; (* i21findpart *)
 
(*------------------------------*) 
 
PROCEDURE
      i21finish_part (
            g_area   : tin_global_in_vars);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    s26finish_part (snd_packet_ptr, curr_part_ptr^);
(*ENDWITH*) 
END; (* i21finish_part *)
 
(*------------------------------*) 
 
PROCEDURE
      i21gbuf (
            g_area   : tin_global_in_vars;
            buf_pos  : tsp00_Int4;
            VAR val  : tsp00_MoveObj;
            val_pos  : tsp00_Int4;
            move_len : tsp00_Int4);
 
BEGIN
(* curr_part_ptr must denote partkind = sp1pk_data *)
(* or other value part *)
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        WITH curr_part_ptr^ DO
            BEGIN
            IF  buf_pos + move_len - 1 <= sp1p_buf_len
            THEN
                s10mv (sp1p_buf_size,sizeof (val),
                      @sp1p_buf,buf_pos,
                      @val,val_pos,move_len)
            ELSE
                i21abort;
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21gbuf *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g1buf (
            g_area   : tin_global_in_vars;
            buf_pos  : tsp00_Int4;
            VAR val  : tsp00_MoveObj;
            val_pos  : tsp00_Int4;
            move_len : tsp00_Int4);
 
BEGIN
i21gbuf (g_area, buf_pos, val, val_pos, move_len);
END; (* i21g1buf *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g2buf (
            g_area   : tin_global_in_vars;
            buf_pos  : tsp00_Int4;
            VAR val  : tsp00_MoveObj;
            val_pos  : tsp00_Int4;
            move_len : tsp00_Int4);
 
BEGIN
i21gbuf (g_area, buf_pos, val, val_pos, move_len);
END; (* i21g2buf *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g3buf (
            g_area   : tin_global_in_vars;
            buf_pos  : tsp00_Int4;
            VAR val  : tsp00_MoveObj;
            val_pos  : tsp00_Int4;
            move_len : tsp00_Int4);
 
BEGIN
i21gbuf (g_area, buf_pos, val, val_pos, move_len);
END; (* i21g3buf *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g4buf (
            g_area   : tin_global_in_vars;
            buf_pos  : tsp00_Int4;
            VAR val  : tsp00_MoveObj;
            val_pos  : tsp00_Int4;
            move_len : tsp00_Int4);
 
BEGIN
i21gbuf (g_area, buf_pos, val, val_pos, move_len);
END; (* i21g4buf *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g5buf (
            g_area   : tin_global_in_vars;
            buf_pos  : tsp00_Int4;
            VAR val  : tsp00_MoveObj;
            val_pos  : tsp00_Int4;
            move_len : tsp00_Int4);
 
BEGIN
i21gbuf (g_area, buf_pos, val, val_pos, move_len);
END; (* i21g5buf *)
 
(*------------------------------*) 
 
PROCEDURE
      i21gbval (
            g_area      : tin_global_in_vars;
            l_val       : tin_natural;
            b_pos       : tsp00_Int4;
            VAR val     : tsp00_Buf;
            VAR is_null : boolean);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        WITH curr_part_ptr^ DO
            BEGIN
            IF  b_pos + l_val <= sp1p_buf_size
            THEN
                BEGIN
                IF  sp1p_buf [b_pos] = csp_undef_byte
                THEN
                    is_null := true
                ELSE
                    BEGIN
                    is_null := false;
                    s10mv (sp1p_buf_size,sizeof (val),
                          @sp1p_buf,b_pos + csp_attr_byte,
                          @val,1,l_val);
                    END;
                (*ENDIF*) 
                END
            ELSE
                is_null := true
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21gbval *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g1bval (
            g_area      : tin_global_in_vars;
            l_val       : tin_natural;
            b_pos       : tsp00_Int4;
            VAR val     : tsp00_Buf;
            VAR is_null : boolean);
 
BEGIN
i21gbval (g_area, l_val, b_pos, val, is_null);
END; (* i21g1bval *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g2bval (
            g_area      : tin_global_in_vars;
            l_val       : tin_natural;
            b_pos       : tsp00_Int4;
            VAR val     : tsp00_Buf;
            VAR is_null : boolean);
 
BEGIN
i21gbval (g_area, l_val, b_pos, val, is_null);
END; (* i21g2bval *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g3bval (
            g_area      : tin_global_in_vars;
            l_val       : tin_natural;
            b_pos       : tsp00_Int4;
            VAR val     : tsp00_Buf;
            VAR is_null : boolean);
 
BEGIN
i21gbval (g_area, l_val, b_pos, val, is_null);
END; (* i21g3bval *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g4bval (
            g_area      : tin_global_in_vars;
            l_val       : tin_natural;
            b_pos       : tsp00_Int4;
            VAR val     : tsp00_Buf;
            VAR is_null : boolean);
 
BEGIN
i21gbval (g_area, l_val, b_pos, val, is_null);
END; (* i21g4bval *)
 
(*------------------------------*) 
 
FUNCTION
      i21gchar (
            g_area       : tin_global_in_vars;
            b_pos        : tsp00_Int4) : char;
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        i21gchar := curr_part_ptr^.sp1p_buf [b_pos];
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21gchar *)
 
(*------------------------------*) 
 
PROCEDURE
      i21gcolname (
            g_area      : tin_global_in_vars;
            pos         : tsp00_Int4;
            VAR cname   : tsp00_KnlIdentifier;
            VAR namlen  : integer);
 
BEGIN
(* curr_part_ptr must denote partkind = sp1pk_columnnames *)
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        WITH curr_part_ptr^ DO
            BEGIN
            cname := bsp_c64;
            IF  sp1p_buf_len > pos
            THEN
                namlen := ord (sp1p_buf [pos])
            ELSE
                namlen := 0;
            (*ENDIF*) 
            IF  (sp1p_buf_len >= pos + namlen) AND (namlen > 0)
            THEN
                s10mv (sp1p_buf_size,sizeof (cname),
                      @sp1p_buf,pos + 1,
                      @cname,1,namlen);
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21gcolname *)
 
(*------------------------------*) 
 
PROCEDURE
      i21gdescriptor (
            g_area       : tin_global_in_vars;
            VAR descript : tsp00_C8);
 
BEGIN
(* curr_part_ptr must denote partkind = sp1pk_data *)
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        WITH curr_part_ptr^ DO
            IF  sp1p_buf_len > mxsp_c8
            THEN
                (* skip defined_byte *)
                s10mv (sp1p_buf_size,sizeof (descript),
                      @sp1p_buf,2,
                      @descript,1,mxsp_c8)
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21gdescriptor *)
 
(*------------------------------*) 
 
PROCEDURE
      i21gettrans_tables (
            g_area    : tin_global_in_vars);
 
VAR
      i               : integer;
      offset          : integer;
      trans_tab_count : integer;
      old_ptr         : tsp1_part_ptr;
 
BEGIN
(* 1: CAPITAL TO SMALL *)
(* 2: SMALL TO CAPITAL *)
(* 3: ASCII TO EBCDIC  *)
(* 4: EBCDIC TO ASCII  *)
(* 5: CHARSET TO STD   *)
(* 6: STD TO CHARSET   *)
g_area^.i20.code_type :=
      g_area^.sql_ptr^.rcv_packet_ptr^.sp1_header.sp1h_mess_code;
WITH g_area^, sql_ptr^  DO
    BEGIN
    old_ptr := curr_part_ptr;
    i21findpart (g_area, sp1pk_conv_tables_returned);
    IF  curr_part_ptr = NIL
    THEN
        curr_part_ptr:= old_ptr
    ELSE
        WITH curr_part_ptr^ DO
            BEGIN
            trans_tab_count := sp1p_arg_count;
            offset := 0;
            FOR i := cin_to_small TO trans_tab_count DO
                BEGIN
                s10mv (sp1p_buf_size,sizeof (i32.transtables [i]),
                      @sp1p_buf,offset + 1,
                      @i32.transtables [i],1,mxsp_c256);
                offset := offset + mxsp_c256;
                END;
            (*ENDFOR*) 
            END
        (*ENDWITH*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END; (* i21gettrans_tables *)
 
(*------------------------------*) 
 
PROCEDURE
      i21getval (
            g_area      : tin_global_in_vars;
            l_val       : tin_natural;
            b_pos       : tsp00_Int4;
            VAR val     : tsp00_Buf;
            pos         : tsp00_Int2;
            maxsize     : tsp00_Int2;
            VAR is_null : boolean);
 
BEGIN
(* curr_part_ptr must denote partkind = sp1pk_data *)
(* or other value part *)
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        WITH curr_part_ptr^ DO
            BEGIN
            IF  b_pos + l_val <= sp1p_buf_size
            THEN
                BEGIN
                IF  sp1p_buf [b_pos] = csp_undef_byte
                THEN
                    is_null := true
                ELSE
                    BEGIN
                    is_null := false;
                    IF  pos + l_val - 1 > maxsize
                    THEN
                        i21abort
                    ELSE
                        s10mv (sp1p_buf_size,sizeof (val),
                              @sp1p_buf,b_pos + csp_attr_byte,
                              @val,pos,l_val);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                is_null := true
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21getval *)
 
(*------------------------------*) 
 
PROCEDURE
      i21gloadfield (
            g_area  : tin_global_in_vars;
            info_no : tin_natural;
            VAR ffi : tsp7_ffield_info);
 
CONST
      offset = 136; (* see tsp7_table_description *)
 
VAR
      pos          : tsp00_Int4;
 
BEGIN
(* ffield_infos to be found in part sp1pk_data? *)
WITH g_area^.sql_ptr^  DO
    BEGIN
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        WITH curr_part_ptr^ DO
            IF  sp1p_buf_len >= info_no * sizeof (ffi)
            THEN
                BEGIN
                pos := offset + (info_no - 1) * sizeof (ffi) + 1;
                s10mv (sp1p_buf_size,sizeof (ffi),
                      @sp1p_buf,pos,
                      @ffi,1,sizeof (ffi));
                END
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END; (* i21gloadfield *)
 
(*------------------------------*) 
 
PROCEDURE
      i21gparsid (
            g_area     : tin_global_in_vars;
            VAR parsid : tin_parsid);
 
BEGIN
i21findpart (g_area, sp1pk_parsid);
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        WITH curr_part_ptr^ DO
            IF  sp1p_buf_len >= mxin_parsid
            THEN
                s10mv (sp1p_buf_size,sizeof (parsid),
                      @sp1p_buf,1,
                      @parsid,1,mxin_parsid)
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21gparsid *)
 
(*------------------------------*) 
 
PROCEDURE
      i21grescount (
            g_area     : tin_global_in_vars;
            VAR known  : boolean;
            VAR count  : tsp00_Int4);
 
VAR
      res      : tsp00_NumError;
 
BEGIN
(* curr_part_ptr must denote partkind = sp1pk_resultcount *)
(* single: call s26find_part, partkind = sp1pk_data *)
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        WITH curr_part_ptr^ DO
            IF  sp1p_resnum [1] = csp_defined_byte
            THEN
                BEGIN
                s40glint (sp1p_resnum, 2, 10, count, res);
                known := (res = num_ok) AND (count <> -1);
                END
            ELSE
                known := false;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21grescount *)
 
(*------------------------------*) 
 
PROCEDURE
      i21gsetval (
            data_part : tsp1_part_ptr;
            b_pos     : tsp00_Int4;
            b_len     : tsp00_Int2;
            l_val     : tin_natural;
            VAR val   : tsp00_Buf);
 
VAR
      actlen : integer;
 
BEGIN
IF  data_part = NIL
THEN
    i21abort
ELSE
    WITH data_part^ DO
        IF  b_pos + l_val <= sp1p_buf_size
        THEN
            BEGIN
            IF  b_len < l_val
            THEN
                BEGIN
                actlen := b_len;
                SAPDB_PascalForcedFill (mxsp_buf, @val, b_len + 1, l_val - b_len, bsp_c1);
                END
            ELSE
                actlen := l_val;
            (*ENDIF*) 
            IF  sp1p_buf [b_pos] = csp_undef_byte
            THEN
                SAPDB_PascalForcedFill (mxsp_buf, @val, 1, actlen, bsp_c1)
            ELSE
                s10mv (sp1p_buf_size,sizeof (val),
                      @sp1p_buf,b_pos + csp_attr_byte,
                      @val,1,actlen);
            (*ENDIF*) 
            END
        ELSE
            SAPDB_PascalForcedFill (mxsp_buf, @val, 1, l_val, bsp_c1);
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDIF*) 
END; (* i21gsetval *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g1setval (
            data_part : tsp1_part_ptr;
            b_pos     : tsp00_Int4;
            b_len     : tsp00_Int2;
            l_val     : tin_natural;
            VAR val   : tsp00_Buf);
 
BEGIN
i21gsetval (data_part, b_pos, b_len, l_val, val);
END; (* i21g1setval *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g2setval (
            data_part : tsp1_part_ptr;
            b_pos     : tsp00_Int4;
            b_len     : tsp00_Int2;
            l_val     : tin_natural;
            VAR val   : tsp00_Buf);
 
BEGIN
i21gsetval (data_part, b_pos, b_len, l_val, val);
END; (* i21g2setval *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g3setval (
            data_part : tsp1_part_ptr;
            b_pos     : tsp00_Int4;
            b_len     : tsp00_Int2;
            l_val     : tin_natural;
            VAR val   : tsp00_Buf);
 
BEGIN
i21gsetval (data_part, b_pos, b_len, l_val, val);
END; (* i21g3setval *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g4setval (
            data_part : tsp1_part_ptr;
            b_pos     : tsp00_Int4;
            b_len     : tsp00_Int2;
            l_val     : tin_natural;
            VAR val   : tsp00_Buf);
 
BEGIN
i21gsetval (data_part, b_pos, b_len, l_val, val);
END; (* i21g4setval *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g5setval (
            data_part : tsp1_part_ptr;
            b_pos     : tsp00_Int4;
            b_len     : tsp00_Int2;
            l_val     : tin_natural;
            VAR val   : tsp00_Buf);
 
BEGIN
i21gsetval (data_part, b_pos, b_len, l_val, val);
END; (* i21g5setval *)
 
(*------------------------------*) 
 
PROCEDURE
      i21gparaminfo (
            g_area    : tin_global_in_vars;
            info_no   : tin_natural;
            VAR pi    : tsp1_param_info;
            VAR found : boolean);
 
VAR
      pos          : tsp00_Int4;
 
BEGIN
(* curr_part_ptr must denote partkind = sp1pk_shortinfo *)
WITH g_area^.sql_ptr^  DO
    BEGIN
    found := false;
    IF  (curr_part_ptr = NIL) OR
        (curr_part_ptr^.sp1p_part_kind <> sp1pk_shortinfo)
    THEN
        s26find_part (curr_segm_ptr^, sp1pk_shortinfo, curr_part_ptr);
    (*ENDIF*) 
    IF  curr_part_ptr = NIL
    THEN
        found := false
    ELSE
        WITH curr_part_ptr^ DO
            IF  sp1p_arg_count >= info_no
            THEN
                BEGIN
                pos := (info_no - 1) * sizeof(pi) + 1;
                s10mv (sp1p_buf_size,sizeof (pi),
                      @sp1p_buf,pos,
                      @pi,1,sizeof(pi));
                found := true;
                END
            ELSE
                found := false;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END; (* i21gparaminfo *)
 
(*------------------------------*) 
 
PROCEDURE
      i21gpival (
            g_area      : tin_global_in_vars;
            VAR pi      : tsp1_param_info;
            val_size    : tsp00_Int4;
            VAR val     : tsp00_MoveObj;
            VAR val_len : tsp00_Int4;
            VAR is_null : boolean);
 
BEGIN
IF  pi.sp1i_in_out_len - 1 > val_size
THEN
    val_len := val_size
ELSE
    val_len := pi.sp1i_in_out_len - 1;
(*ENDIF*) 
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        WITH curr_part_ptr^ DO
            BEGIN
            IF  pi.sp1i_bufpos + val_len <= sp1p_buf_size
            THEN
                BEGIN
                IF  sp1p_buf [pi.sp1i_bufpos] = csp_undef_byte
                THEN
                    is_null := true
                ELSE
                    BEGIN
                    is_null := false;
                    s10mv (sp1p_buf_size,sizeof (val),
                          @sp1p_buf,pi.sp1i_bufpos + csp_attr_byte,
                          @val,1,val_len);
                    END;
                (*ENDIF*) 
                END
            ELSE
                is_null := true
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21gpival *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g1pival (
            g_area      : tin_global_in_vars;
            VAR pi      : tsp1_param_info;
            val_size    : tsp00_Int4;
            VAR val     : tsp00_MoveObj;
            VAR val_len : tsp00_Int4;
            VAR is_null : boolean);
 
BEGIN
i21gpival (g_area, pi, val_size, val, val_len, is_null);
END; (* i21g1pival *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g2pival (
            g_area      : tin_global_in_vars;
            VAR pi      : tsp1_param_info;
            val_size    : tsp00_Int4;
            VAR val     : tsp00_MoveObj;
            VAR val_len : tsp00_Int4;
            VAR is_null : boolean);
 
BEGIN
i21gpival (g_area, pi, val_size, val, val_len, is_null);
END; (* i21g2pival *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g3pival (
            g_area      : tin_global_in_vars;
            VAR pi      : tsp1_param_info;
            val_size    : tsp00_Int4;
            VAR val     : tsp00_MoveObj;
            VAR val_len : tsp00_Int4;
            VAR is_null : boolean);
 
BEGIN
i21gpival (g_area, pi, val_size, val, val_len, is_null);
END; (* i21g3pival *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g4pival (
            g_area      : tin_global_in_vars;
            VAR pi      : tsp1_param_info;
            val_size    : tsp00_Int4;
            VAR val     : tsp00_MoveObj;
            VAR val_len : tsp00_Int4;
            VAR is_null : boolean);
 
BEGIN
i21gpival (g_area, pi, val_size, val, val_len, is_null);
END; (* i21g4pival *)
 
(*------------------------------*) 
 
PROCEDURE
      i21gcount (
            g_area    : tin_global_in_vars;
            VAR count : tsp00_Int4);
 
VAR
      known : boolean;
 
BEGIN
count := 0;
WITH g_area^.sql_ptr^  DO
    BEGIN
    s26find_part (curr_segm_ptr^, sp1pk_resultcount, curr_part_ptr);
    IF  curr_part_ptr <> NIL
    THEN
        BEGIN
        i21grescount (g_area, known, count);
        IF  NOT known
        THEN
            count := -1;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i21gvalcount (
            g_area    : tin_global_in_vars;
            VAR count : integer);
 
BEGIN
(* replaces i20gmfcount (case a) and i20gspcount (case b) *)
(* case a: curr_part_ptr must denote partkind = sp1pk_data *)
(* case b: curr_part_ptr must denote partkind = sp1pk_getinfo *)
(*         or sp1pk_shortinfo or, for fastload, sp1pk_data *)
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        (* zero param infos are returned as no part *)
        count := 0
    ELSE
        count := curr_part_ptr^.sp1p_arg_count;
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21gvalcount *)
 
(*------------------------------*) 
 
PROCEDURE
      i21gpartval (
            g_area      : tin_global_in_vars;
            l_part      : tin_natural;
            l_val       : tin_natural;
            VAR pos     : tsp00_Int4;
            VAR val     : tsp00_Buf;
            VAR is_null : boolean);
 
BEGIN
(* returned pos is last byte of val + 1, i.e. next pos *)
WITH g_area^.sql_ptr^  DO
    IF  (curr_part_ptr = NIL) OR
        (curr_part_ptr^.sp1p_part_kind <> sp1pk_data)
    THEN
        s26find_part (curr_segm_ptr^, sp1pk_data, curr_part_ptr);
    (*ENDIF*) 
(*ENDWITH*) 
WITH g_area^.sql_ptr^  DO
    IF  (curr_part_ptr = NIL)
    THEN
        i21abort
    ELSE
        WITH curr_part_ptr^ DO
            BEGIN
            IF  pos + l_val <= sp1p_buf_size
            THEN
                BEGIN
                IF  sp1p_buf [pos] = csp_undef_byte
                THEN
                    BEGIN
                    is_null := true;
                    END
                ELSE
                    BEGIN
                    is_null := false;
                    s10mv (sp1p_buf_size,sizeof (val),
                          @sp1p_buf,pos + csp_attr_byte,
                          @val,1,l_part);
                    pos := pos + csp_attr_byte + l_val;
                    END;
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                is_null := true;
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21gpartval *)
 
(*------------------------------*) 
 
PROCEDURE
      i21gval (
            g_area      : tin_global_in_vars;
            l_val       : tin_natural;
            VAR pos     : tsp00_Int4;
            VAR val     : tsp00_Buf;
            VAR is_null : boolean);
 
BEGIN
(* returned pos is last byte of val + 1, i.e. next pos *)
WITH g_area^.sql_ptr^  DO
    IF  (curr_part_ptr = NIL) OR
        (curr_part_ptr^.sp1p_part_kind <> sp1pk_data)
    THEN
        s26find_part (curr_segm_ptr^, sp1pk_data, curr_part_ptr);
    (*ENDIF*) 
(*ENDWITH*) 
WITH g_area^.sql_ptr^  DO
    IF  (curr_part_ptr = NIL)
    THEN
        i21abort
    ELSE
        WITH curr_part_ptr^ DO
            BEGIN
            IF  pos + l_val <= sp1p_buf_size
            THEN
                BEGIN
                IF  sp1p_buf [pos] = csp_undef_byte
                THEN
                    BEGIN
                    is_null := true;
                    END
                ELSE
                    BEGIN
                    is_null := false;
                    s10mv (sp1p_buf_size,sizeof (val),
                          @sp1p_buf,pos + csp_attr_byte,
                          @val,1,l_val);
                    pos := pos + csp_attr_byte + l_val;
                    END;
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                is_null := true;
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21gval *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g1val (
            g_area      : tin_global_in_vars;
            l_val       : tin_natural;
            VAR pos     : tsp00_Int4;
            VAR val     : tsp00_Buf;
            VAR is_null : boolean);
 
BEGIN
i21gval (g_area, l_val, pos, val, is_null);
END; (* i21g1val *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g2val (
            g_area      : tin_global_in_vars;
            l_val       : tin_natural;
            VAR pos     : tsp00_Int4;
            VAR val     : tsp00_Buf;
            VAR is_null : boolean);
 
BEGIN
i21gval (g_area, l_val, pos, val, is_null);
END; (* i21g2val *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g3val (
            g_area      : tin_global_in_vars;
            l_val       : tin_natural;
            VAR pos     : tsp00_Int4;
            VAR val     : tsp00_Buf;
            VAR is_null : boolean);
 
BEGIN
i21gval (g_area, l_val, pos, val, is_null);
END; (* i21g3val *)
 
(*------------------------------*) 
 
PROCEDURE
      i21gxval (
            g_area      : tin_global_in_vars;
            l_val       : tin_natural;
            VAR pos     : tsp00_Int4;
            VAR val     : tsp00_Buf;
            VAR is_null : boolean);
 
BEGIN
(* returned pos is last byte of val + 1, i.e. next pos *)
WITH g_area^.sql_ptr^  DO
    IF  (curr_part_ptr = NIL)
    THEN
        i21abort
    ELSE
        WITH curr_part_ptr^ DO
            BEGIN
            IF  pos + l_val <= sp1p_buf_size
            THEN
                BEGIN
                IF  sp1p_buf [pos] = csp_undef_byte
                THEN
                    BEGIN
                    is_null := true;
                    END
                ELSE
                    BEGIN
                    is_null := false;
                    s10mv (sp1p_buf_size,sizeof (val),
                          @sp1p_buf,pos + csp_attr_byte,
                          @val,1,l_val);
                    pos := pos + csp_attr_byte + l_val;
                    END;
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                is_null := true;
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21gval *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g1xval (
            g_area      : tin_global_in_vars;
            l_val       : tin_natural;
            VAR pos     : tsp00_Int4;
            VAR val     : tsp00_Buf;
            VAR is_null : boolean);
 
BEGIN
i21gxval (g_area, l_val, pos, val, is_null);
END; (* i21g1xval *)
 
(*------------------------------*) 
 
PROCEDURE
      i21g2xval (
            g_area      : tin_global_in_vars;
            l_val       : tin_natural;
            VAR pos     : tsp00_Int4;
            VAR val     : tsp00_Buf;
            VAR is_null : boolean);
 
BEGIN
i21gxval (g_area, l_val, pos, val, is_null);
END; (* i21g2xval *)
 
(*------------------------------*) 
 
PROCEDURE
      i21initadbs (
            g_area : tin_global_in_vars);
 
BEGIN
i21reset (g_area, sp1m_dbs);
WITH g_area^.sql_ptr^.curr_part_ptr^ DO
    sp1p_part_kind := sp1pk_command;
(*ENDWITH*) 
END; (* i21initadbs *)
 
(*------------------------------*) 
 
PROCEDURE
      i21initcommand (
            g_area : tin_global_in_vars;
            mess_type : tsp1_cmd_mess_type);
 
BEGIN
i21reset (g_area, mess_type);
WITH g_area^.sql_ptr^.curr_part_ptr^ DO
    sp1p_part_kind := sp1pk_command;
(*ENDWITH*) 
END; (* i21initcommand *)
 
(*------------------------------*) 
 
PROCEDURE
      i21initdbtable (
            g_area : tin_global_in_vars);
 
VAR
      i : integer;
 
BEGIN
g_area^.session [1].is_connected := true;
&ifndef INLINK
FOR i := 2 TO mxin_dbs DO
    BEGIN
    g_area^.session [i].is_connected := false;
    g_area^.session [i].symbolic_dbname := bsp_dbname;
    END;
(*ENDFOR*) 
&endif
END; (* i21initdbtable *)
 
(*------------------------------*) 
 
PROCEDURE
      i21initexecute (
            g_area  : tin_global_in_vars;
            VAR pid : tin_parsid);
 
BEGIN
i21reset (g_area, sp1m_execute);
WITH g_area^.sql_ptr^.curr_part_ptr^ DO
    sp1p_part_kind := sp1pk_parsid;
(*ENDWITH*) 
i21pparsid (g_area, pid);
i21newpart (g_area, sp1pk_data);
END; (* i21initexecute *)
 
(*------------------------------*) 
 
PROCEDURE
      i21initpackets (
            g_area       : tin_global_in_vars;
            packet_ptr   : tsp1_packet_ptr;
            from_receive : boolean);
 
BEGIN
WITH g_area^.sql_ptr^ DO
    BEGIN
    IF  from_receive
    THEN
        BEGIN
        rcv_packet_ptr := packet_ptr;
        packet_stat := p_received;
        END
    ELSE
        BEGIN
        snd_packet_ptr := packet_ptr;
        rcv_packet_ptr := NIL;
        packet_stat := p_waiting;
        END;
    (*ENDIF*) 
    curr_segm_ptr := @packet_ptr^.sp1_segm;
    curr_part_ptr := NIL;
    END;
(*ENDWITH*) 
END; (* i21initpackets *)
 
(*------------------------------*) 
 
PROCEDURE
      i21initparse (
            g_area : tin_global_in_vars);
 
BEGIN
i21reset (g_area, sp1m_parse);
WITH g_area^.sql_ptr^.curr_part_ptr^ DO
    sp1p_part_kind := sp1pk_command;
(*ENDWITH*) 
END; (* i21initparse *)
 
(*------------------------------*) 
 
PROCEDURE
      i21initretsegm (
            g_area : tin_global_in_vars);
 
BEGIN
WITH g_area^, sql_ptr^  DO
    BEGIN
    WITH snd_packet_ptr^.sp1_header DO
        BEGIN
        sp1h_mess_code := i20.code_type;
        sp1h_mess_swap := i20.swap;
        sp1h_appl_version := g_area^.i20.appl_version;
        sp1h_application  := g_area^.i20.application;
        END;
    (*ENDWITH*) 
    s26first_segment_init (snd_packet_ptr, sp1sk_return,
          curr_segm_ptr);
    s26new_part_init (snd_packet_ptr, curr_segm_ptr^, curr_part_ptr);
    curr_part_ptr^.sp1p_part_kind := sp1pk_data;
    curr_segm_ptr^.sp1c_mess_type := sp1m_execute;
    curr_segm_ptr^.sp1c_mass_cmd  := false;
    END;
(*ENDWITH*) 
END; (* i21initretsegm *)
 
(*------------------------------*) 
 
FUNCTION
      i21lnr (
            g_area       : tin_global_in_vars;
            val          : char;
            start        : tsp00_Int4;
            cnt          : tsp00_Int4) : tsp00_Int4;
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        WITH curr_part_ptr^ DO
            i21lnr := s30lnr (sp1p_buf, val, start, cnt);
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21lnr *)
 
(*------------------------------*) 
 
PROCEDURE
      i21mfetch (
            g_area       : tin_global_in_vars;
            in_unicode   : boolean;
            m_type       : tsp1_cmd_mess_type;
            count        : tsp00_Int4;
            dir          : tin_fetch_dir;
            VAR res_name : tsp00_KnlIdentifier);
 
CONST
      mf_str     = 'FETCH               ';
      df_str     = ' FIRST              ';
      dl_str     = ' LAST               ';
      dp_str     = ' PREV               ';
      dn_str     = ' NEXT               ';
      dr_str     = ' REST               ';
      mf_str_len = 7;
      is_masscmd = true;
 
VAR
      u_len : integer;
      u     : tsp00_C40;
      s     : tsp00_C20;
 
BEGIN
IF  (g_area^.sql_ptr^.packet_stat = p_waiting)
    OR (g_area^.sql_ptr^.packet_stat = p_reset)
THEN
    WITH g_area^ DO
        BEGIN
        i21reset (g_area, m_type);
        IF  in_unicode
        THEN
            IF  g_area^.i20.swap = sw_normal
            THEN
                i21chngcodetype (g_area, csp_unicode)
            ELSE
                i21chngcodetype (g_area, csp_unicode_swap);
            (*ENDIF*) 
        (*ENDIF*) 
        i21chngmasscmd (g_area, is_masscmd);
        s := mf_str;
        IF  in_unicode
        THEN
            BEGIN
            in21_unicode20 (g_area, s, mf_str_len, u, u_len);
            i21p2cmnd (g_area, u, u_len);
            END
        ELSE
            i21p1cmnd (g_area, s, mf_str_len);
        (*ENDIF*) 
        CASE dir OF
            mf_first :
                s := df_str;
            mf_prev  :
                s := dp_str;
            mf_last  :
                s := dl_str;
            mf_next  :
                s := dn_str;
            mf_rest  :
                s := dr_str;
            END;
        (*ENDCASE*) 
        IF  in_unicode
        THEN
            BEGIN
            in21_unicode20 (g_area, s, mf_str_len, u, u_len);
            i21p2cmnd (g_area, u, u_len);
            END
        ELSE
            i21p1cmnd (g_area, s, mf_str_len);
        (*ENDIF*) 
        i21pcname (g_area, res_name);
        i21prescount (g_area, count);
        END
    (*ENDWITH*) 
(*ENDIF*) 
END; (* i21mfetch *)
 
(*------------------------------*) 
 
PROCEDURE
      i21mfparse (
            g_area       : tin_global_in_vars;
            dir          : tin_fetch_dir;
            cols         : integer;
            VAR res_name : tsp00_KnlIdentifier);
 
CONST
      mf_str     = 'FETCH               ';
      df_str     = ' FIRST              ';
      dl_str     = ' LAST               ';
      dp_str     = ' PREV               ';
      dn_str     = ' NEXT               ';
      di_str     = ' POS ( ? )          ';
      dr_str     = ' REST               ';
      mf_str_len = 11;
      is_masscmd = true;
 
VAR
      s             : tsp00_C20;
      i             : integer;
 
BEGIN
IF  (g_area^.sql_ptr^.packet_stat = p_waiting)
    OR (g_area^.sql_ptr^.packet_stat = p_reset)
THEN
    WITH g_area^ DO
        BEGIN
        i21reset (g_area, sp1m_parse);
        i21chngmasscmd (g_area, is_masscmd);
        s := mf_str;
        i21p1cmnd (g_area, s, mf_str_len);
        CASE dir OF
            mf_first :
                s := df_str;
            mf_prev  :
                s := dp_str;
            mf_last  :
                s := dl_str;
            mf_next  :
                s := dn_str;
            mf_pos   :
                s := di_str;
            mf_rest  :
                s := dr_str;
            END;
        (*ENDCASE*) 
        i21p1cmnd (g_area, s, mf_str_len);
        i21pcname (g_area, res_name);
        IF  cols > 0
        THEN
            BEGIN
            s := ' INTO ?             ';
            i21p1cmnd (g_area, s, 8 );
            s := ' ,?                 ';
            FOR i := 2 TO cols DO
                i21p1cmnd (g_area, s, 3 );
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        i21finish_part (g_area);
        END
    (*ENDWITH*) 
(*ENDIF*) 
END; (* i21mfparse *)
 
(*------------------------------*) 
 
PROCEDURE
      i21mfpos (
            g_area       : tin_global_in_vars;
            in_unicode   : boolean;
            m_type       : tsp1_cmd_mess_type;
            count        : tin_natural;
            fetchpos     : tsp00_Int4;
            VAR res_name : tsp00_KnlIdentifier);
 
CONST
      mf_str     = 'FETCH  POS (        ';
      mp_str     = '                   )';
      mf_str_len = 20;
      not_null   = false;
 
VAR
      i             : integer;
      u_len         : integer;
      u             : tsp00_C40;
      s             : tsp00_C20;
      wanted        : tsp_int_map_c2;
      fetch_pos     : tsp00_Int4;
      pos           : tsp00_Int4;
 
BEGIN
IF  (g_area^.sql_ptr^.packet_stat = p_waiting)
    OR (g_area^.sql_ptr^.packet_stat = p_reset)
THEN
    WITH g_area^ DO
        BEGIN
        i21reset (g_area, m_type);
        IF  in_unicode
        THEN
            IF  g_area^.i20.swap = sw_normal
            THEN
                i21chngcodetype (g_area, csp_unicode)
            ELSE
                i21chngcodetype (g_area, csp_unicode_swap);
            (*ENDIF*) 
        (*ENDIF*) 
        s := mf_str;
        IF  in_unicode
        THEN
            BEGIN
            in21_unicode20 (g_area, s, mf_str_len, u, u_len);
            i21p2cmnd (g_area, u, u_len);
            END
        ELSE
            i21p1cmnd (g_area, s, mf_str_len);
        (*ENDIF*) 
        s := mp_str;
        i := 18;
        fetch_pos := fetchpos;
        WHILE (i > 0) AND (fetch_pos > 0) DO
            BEGIN
            s [i] := chr (ord ('0') + (fetch_pos MOD 10));
            fetch_pos := fetch_pos DIV 10;
            i := i - 1;
            END;
        (*ENDWHILE*) 
        IF  in_unicode
        THEN
            BEGIN
            in21_unicode20 (g_area, s, mf_str_len, u, u_len);
            i21p2cmnd (g_area, u, u_len);
            END
        ELSE
            i21p1cmnd (g_area, s, mf_str_len);
        (*ENDIF*) 
        i21pcname (g_area, res_name);
        i21nextpart_init (g_area);
        wanted.map_int := count;
        s := bsp_c20;
        s [1] := wanted.map_c2 [1];
        s [2] := wanted.map_c2 [2];
        pos := 1;
        i21p1arg (g_area, mxsp_c2, pos, s, not_null);
        i21finish_part (g_area);
        END
    (*ENDWITH*) 
(*ENDIF*) 
END; (* i21mfpos *)
 
(*------------------------------*) 
 
PROCEDURE
      i21movecmnd (
            g_area : tin_global_in_vars;
            VAR s  : tsp00_MoveObj;
            pos    : tin_natural;
            l_s    : tin_natural);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                s10mv (sizeof (s),sp1p_buf_size,
                      @s,pos,
                      @sp1p_buf,sp1p_buf_len + 1,l_s);
                sp1p_buf_len := sp1p_buf_len + l_s
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21movecmnd *)
 
(*------------------------------*) 
 
PROCEDURE
      i21newcmd (
            g_area : tin_global_in_vars;
            m_type : tsp1_cmd_mess_type);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    BEGIN
    IF  packet_stat = p_reset
    THEN
        BEGIN
        s26new_segment_init (snd_packet_ptr, sp1sk_cmd,
              curr_segm_ptr, curr_part_ptr);
        curr_segm_ptr^.sp1c_mess_type := m_type;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* i21newcmd *)
 
(*------------------------------*) 
 
PROCEDURE
      i21newpart (
            g_area    : tin_global_in_vars;
            part_kind : tsp1_part_kind);
 
BEGIN
WITH g_area^.sql_ptr^ DO
    BEGIN
    IF  curr_part_ptr <> NIL
    THEN
        s26finish_part (snd_packet_ptr, curr_part_ptr^);
    (*ENDIF*) 
    s26new_part_init (snd_packet_ptr, curr_segm_ptr^, curr_part_ptr);
    curr_part_ptr^.sp1p_part_kind := part_kind;
    END;
(*ENDWITH*) 
END; (* i21newpart *)
 
(*------------------------------*) 
 
PROCEDURE
      i21nextpart_init (
            g_area       : tin_global_in_vars);
 
BEGIN
(* finish given part of last command *)
(* init new part at the end of current segment *)
(* return address of this new part *)
WITH g_area^.sql_ptr^  DO
    IF  (curr_segm_ptr = NIL) OR (curr_part_ptr = NIL)
    THEN
        i21abort
    ELSE
        IF  curr_segm_ptr^.sp1s_segm_kind = sp1sk_cmd
        THEN
            BEGIN
            s26finish_part (snd_packet_ptr, curr_part_ptr^);
            s26new_part_init (snd_packet_ptr,
                  curr_segm_ptr^, curr_part_ptr)
            END
        ELSE
            BEGIN
            s26finish_part (rcv_packet_ptr, curr_part_ptr^);
            s26new_part_init (rcv_packet_ptr,
                  curr_segm_ptr^, curr_part_ptr)
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21nextpart_init *)
 
(*------------------------------*) 
 
PROCEDURE
      i21parg (
            g_area      : tin_global_in_vars;
            l_arg       : tin_natural;
            VAR pos     : tsp00_Int4;
            VAR arg     : tsp00_Buf;
            is_null     : boolean);
 
BEGIN
(* initialize "pos" with 1, then write one argument after the other *)
(* without touching "pos" again *)
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                IF  pos + l_arg <= sp1p_buf_size
                THEN
                    BEGIN
                    IF  is_null
                    THEN
                        SAPDB_PascalForcedFill (sp1p_buf_size, @sp1p_buf, pos,
                              csp_attr_byte + l_arg, csp_undef_byte)
                    ELSE
                        BEGIN
                        sp1p_buf [pos] := csp_defined_byte;
                        s10mv (sizeof (arg),sp1p_buf_size,
                              @arg,1,
                              @sp1p_buf,pos + csp_attr_byte,l_arg);
                        END;
                    (*ENDIF*) 
                    pos := pos + csp_attr_byte + l_arg;
                    IF  sp1p_buf_len = 0
                    THEN
                        sp1p_arg_count := 1
                    ELSE
                        sp1p_arg_count := sp1p_arg_count + 1;
                    (*ENDIF*) 
                    sp1p_buf_len := pos - 1;
                    END
                (*ENDIF*) 
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21parg *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p1arg (
            g_area      : tin_global_in_vars;
            l_arg       : tin_natural;
            VAR pos     : tsp00_Int4;
            VAR arg     : tsp00_C20;
            is_null     : boolean);
 
BEGIN
(* initialize "pos" with 1, then write one argument after the other *)
(* without touching "pos" again *)
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                IF  pos + l_arg <= sp1p_buf_size
                THEN
                    BEGIN
                    IF  is_null
                    THEN
                        SAPDB_PascalForcedFill (sp1p_buf_size, @sp1p_buf, pos,
                              csp_attr_byte + l_arg, csp_undef_byte)
                    ELSE
                        BEGIN
                        sp1p_buf [pos] := csp_defined_byte;
                        s10mv (sizeof (arg),sp1p_buf_size,
                              @arg,1,
                              @sp1p_buf,pos + csp_attr_byte,l_arg);
                        END;
                    (*ENDIF*) 
                    pos := pos + csp_attr_byte + l_arg;
                    IF  sp1p_buf_len = 0
                    THEN
                        sp1p_arg_count := 1
                    ELSE
                        sp1p_arg_count := sp1p_arg_count + 1;
                    (*ENDIF*) 
                    sp1p_buf_len := pos - 1;
                    END
                (*ENDIF*) 
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21p1arg *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p2arg (
            g_area      : tin_global_in_vars;
            l_arg       : tin_natural;
            VAR pos     : tsp00_Int4;
            VAR arg     : tsp00_Buf;
            is_null     : boolean);
 
BEGIN
i21parg (g_area, l_arg, pos, arg, is_null);
END; (* i21p2arg *)
 
(*------------------------------*) 
 
FUNCTION
      i21partfreespace (
            g_area  : tin_global_in_vars) : tsp00_Int4;
 
BEGIN
WITH g_area^.sql_ptr^ DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        WITH curr_part_ptr^ DO
            BEGIN
            i21partfreespace := (sp1p_buf_size - sp1p_buf_len)
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21partfreespace *)
 
(*------------------------------*) 
 
PROCEDURE
      i21fbarg (
            g_area  : tin_global_in_vars;
            VAR arg : tsp00_Buf;
            b_pos   : tsp00_Int4;
            l_arg   : tin_natural;
            defbyte : char;
            l_field : tin_natural;
            is_null : boolean);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                IF  (b_pos + l_arg <= sp1p_buf_size) AND
                    (b_pos + l_field <= sp1p_buf_size)
                THEN
                    BEGIN
                    IF  is_null
                    THEN
                        SAPDB_PascalForcedFill (sp1p_buf_size, @sp1p_buf, b_pos,
                              csp_attr_byte + l_field, csp_undef_byte)
                    ELSE
                        BEGIN
                        sp1p_buf [b_pos] := defbyte;
                        s10mv (sizeof (arg),sp1p_buf_size,
                              @arg,1,
                              @sp1p_buf,b_pos + csp_attr_byte,l_arg);
                        SAPDB_PascalForcedFill (sp1p_buf_size, @sp1p_buf,
                              b_pos + csp_attr_byte + l_arg,
                              l_field - l_arg, defbyte)
                        END;
                    (*ENDIF*) 
                    IF  sp1p_buf_len = 0
                    THEN
                        sp1p_arg_count := 1
                    ELSE
                        sp1p_arg_count := sp1p_arg_count + 1;
                    (*ENDIF*) 
                    IF  b_pos > sp1p_buf_len
                    THEN
                        sp1p_buf_len := b_pos + l_field;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21fbarg *)
 
(*------------------------------*) 
 
PROCEDURE
      i21pbarg (
            g_area  : tin_global_in_vars;
            VAR arg : tsp00_Buf;
            b_pos   : tsp00_Int4;
            l_arg   : tin_natural;
            is_null : boolean);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                IF  b_pos + l_arg <= sp1p_buf_size
                THEN
                    BEGIN
                    IF  is_null
                    THEN
                        SAPDB_PascalForcedFill (sp1p_buf_size, @sp1p_buf, b_pos,
                              csp_attr_byte + l_arg, csp_undef_byte)
                    ELSE
                        BEGIN
                        sp1p_buf [b_pos] := csp_defined_byte;
                        s10mv (sizeof (arg),sp1p_buf_size,
                              @arg,1,
                              @sp1p_buf,b_pos + csp_attr_byte,l_arg);
                        END;
                    (*ENDIF*) 
                    IF  sp1p_buf_len = 0
                    THEN
                        sp1p_arg_count := 1
                    ELSE
                        sp1p_arg_count := sp1p_arg_count + 1;
                    (*ENDIF*) 
                    IF  b_pos > sp1p_buf_len
                    THEN
                        sp1p_buf_len := b_pos + l_arg;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21pbarg *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p1barg (
            g_area  : tin_global_in_vars;
            VAR arg : tsp00_Buf;
            b_pos   : tsp00_Int4;
            l_arg   : tin_natural;
            is_null : boolean);
 
BEGIN
i21pbarg (g_area, arg, b_pos, l_arg, is_null);
END; (* i21p1barg *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p2barg (
            g_area  : tin_global_in_vars;
            VAR arg : tsp00_Buf;
            b_pos   : tsp00_Int4;
            l_arg   : tin_natural;
            is_null : boolean);
 
BEGIN
i21pbarg (g_area, arg, b_pos, l_arg, is_null);
END; (* i21p2barg *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p3barg (
            g_area  : tin_global_in_vars;
            VAR arg : tsp00_Buf;
            b_pos   : tsp00_Int4;
            l_arg   : tin_natural;
            is_null : boolean);
 
BEGIN
i21pbarg (g_area, arg, b_pos, l_arg, is_null);
END; (* i21p3barg *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p4barg (
            g_area  : tin_global_in_vars;
            VAR arg : tsp00_Buf;
            b_pos   : tsp00_Int4;
            l_arg   : tin_natural;
            is_null : boolean);
 
BEGIN
i21pbarg (g_area, arg, b_pos, l_arg, is_null);
END; (* i21p4barg *)
 
(*------------------------------*) 
 
PROCEDURE
      i21prescount (
            g_area     : tin_global_in_vars;
            VAR count  : tsp00_Int4);
 
VAR
      res      : tsp00_NumError;
 
BEGIN
i21newpart (g_area, sp1pk_resultcount);
WITH g_area^.sql_ptr^, curr_part_ptr^ DO
    BEGIN
    sp1p_resnum [1] := csp_defined_byte;
    s41p4int (sp1p_resnum, 2, count, res);
    sp1p_buf_len := sizeof (sp1p_resnum);
    END;
(*ENDWITH*) 
i21finish_part (g_area);
END; (* i21prescount *)
 
(*------------------------------*) 
 
PROCEDURE
      i21putstring (
            g_area  : tin_global_in_vars;
            VAR arg : tsp00_MoveObj;
            b_pos   : tsp00_Int2;
            l_arg   : tsp00_Int2;
            is_null : boolean);
 
VAR
      arg_pos : integer;
 
BEGIN
IF  g_area^.sql_ptr^.packet_stat = p_reset
THEN
    WITH g_area^.sql_ptr^.curr_part_ptr^ DO
        BEGIN
        arg_pos := b_pos;
        IF  is_null
        THEN
            sp1p_buf [ arg_pos ] := csp_undef_byte
        ELSE
            sp1p_buf [ arg_pos ] := csp_defined_byte;
        (*ENDIF*) 
        arg_pos := arg_pos + 1;
        s10mv (MOVEOBJ_MXSP00,sp1p_buf_size,
              @arg,1,
              @sp1p_buf,arg_pos,l_arg);
        sp1p_buf_len := sp1p_buf_len + l_arg + 1
        END
    (*ENDWITH*) 
(*ENDIF*) 
END; (* i21putstring *)
 
(*------------------------------*) 
 
PROCEDURE
      i21pbuf (
            g_area   : tin_global_in_vars;
            buf_pos  : tsp00_Int4;
            VAR val  : tsp00_MoveObj;
            from_pos : tsp00_Int4;
            move_len : tsp00_Int4);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                IF  buf_pos + move_len - 1 <= sp1p_buf_size
                THEN
                    BEGIN
                    s10mv (sizeof (val),sp1p_buf_size,
                          @val,from_pos,
                          @sp1p_buf,buf_pos,move_len);
                    IF  buf_pos > sp1p_buf_len
                    THEN
                        sp1p_buf_len := buf_pos + move_len - 1;
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21pbuf *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p1buf (
            g_area   : tin_global_in_vars;
            buf_pos  : tsp00_Int4;
            VAR val  : tsp00_MoveObj;
            from_pos : tsp00_Int4;
            move_len : tsp00_Int4);
 
BEGIN
i21pbuf (g_area, buf_pos, val, from_pos, move_len);
END; (* i21p1buf *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p2buf (
            g_area   : tin_global_in_vars;
            buf_pos  : tsp00_Int4;
            VAR val  : tsp00_MoveObj;
            from_pos : tsp00_Int4;
            move_len : tsp00_Int4);
 
BEGIN
i21pbuf (g_area, buf_pos, val, from_pos, move_len);
END; (* i21p2buf *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p3buf (
            g_area   : tin_global_in_vars;
            buf_pos  : tsp00_Int4;
            VAR val  : tsp00_MoveObj;
            from_pos : tsp00_Int4;
            move_len : tsp00_Int4);
 
BEGIN
i21pbuf (g_area, buf_pos, val, from_pos, move_len);
END; (* i21p3buf *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p4buf (
            g_area   : tin_global_in_vars;
            buf_pos  : tsp00_Int4;
            VAR val  : tsp00_MoveObj;
            from_pos : tsp00_Int4;
            move_len : tsp00_Int4);
 
BEGIN
i21pbuf (g_area, buf_pos, val, from_pos, move_len);
END; (* i21p4buf *)
 
(*------------------------------*) 
 
PROCEDURE
      i21pcmnd (
            g_area : tin_global_in_vars;
            VAR s  : tsp00_Buf;
            l_s    : tin_natural);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                s10mv (sizeof (s),sp1p_buf_size,
                      @s,1,
                      @sp1p_buf,sp1p_buf_len + 1,l_s);
                sp1p_buf_len := sp1p_buf_len + l_s
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21pcmnd *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p1cmnd (
            g_area : tin_global_in_vars;
            VAR s  : tsp00_C20;
            l_s    : tin_natural);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                s10mv (sizeof (s),sp1p_buf_size,
                      @s,1,
                      @sp1p_buf,sp1p_buf_len + 1,l_s);
                sp1p_buf_len := sp1p_buf_len + l_s
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21p1cmnd *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p2cmnd (
            g_area : tin_global_in_vars;
            VAR s  : tsp00_C40;
            l_s    : tin_natural);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                s10mv (sizeof (s),sp1p_buf_size,
                      @s,1,
                      @sp1p_buf,sp1p_buf_len + 1,l_s);
                sp1p_buf_len := sp1p_buf_len + l_s
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21p2cmnd *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p3cmnd (
            g_area : tin_global_in_vars;
            VAR s  : tsp00_C70;
            l_s    : tin_natural);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                s10mv (sizeof (s),sp1p_buf_size,
                      @s,1,
                      @sp1p_buf,sp1p_buf_len + 1,l_s);
                sp1p_buf_len := sp1p_buf_len + l_s
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21p3cmnd *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p4cmnd (
            g_area : tin_global_in_vars;
            VAR s  : tsp00_Buf;
            l_s    : tin_natural);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                s10mv (sizeof (s),sp1p_buf_size,
                      @s,1,
                      @sp1p_buf,sp1p_buf_len + 1,l_s);
                sp1p_buf_len := sp1p_buf_len + l_s
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21p4cmnd *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p5cmnd (
            g_area : tin_global_in_vars;
            VAR s  : tsp00_Buf;
            l_s    : tin_natural);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                s10mv (sizeof (s),sp1p_buf_size,
                      @s,1,
                      @sp1p_buf,sp1p_buf_len + 1,l_s);
                sp1p_buf_len := sp1p_buf_len + l_s
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21p5cmnd *)
 
(*------------------------------*) 
 
PROCEDURE
      i21pccmnd (
            g_area : tin_global_in_vars;
            c      : char);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                sp1p_buf [sp1p_buf_len + 1] := c;
                sp1p_buf_len := sp1p_buf_len + 1
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21pccmnd *)
 
(*------------------------------*) 
 
PROCEDURE
      i21pcmd (
            g_area : tin_global_in_vars;
            s      : tsp00_C30);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                s10mv (sizeof (s),sp1p_buf_size,
                      @s,1,
                      @sp1p_buf,sp1p_buf_len + 1,mxsp_c30);
                sp1p_buf_len := sp1p_buf_len + mxsp_c30
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21pcmd *)
 
(*------------------------------*) 
 
PROCEDURE
      i21pcname (
            g_area  : tin_global_in_vars;
            VAR nam : tsp00_KnlIdentifier);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                s10mv (sizeof (nam),sp1p_buf_size,
                      @nam,1,
                      @sp1p_buf,sp1p_buf_len + 1,sizeof (nam) DIV 2);
                sp1p_buf_len := sp1p_buf_len + sizeof (nam) DIV 2;
                (* DIV 2 because name is enclosed in quotes *)
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21pcname *)
 
(*------------------------------*) 
 
PROCEDURE
      i21pcuname (
            g_area  : tin_global_in_vars;
            VAR nam : tsp00_KnlIdentifier);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                s10mv (sizeof (nam),sp1p_buf_size,
                      @nam,1,
                      @sp1p_buf,sp1p_buf_len + 1,sizeof (nam));
                sp1p_buf_len := sp1p_buf_len + sizeof (nam);
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21pcuname *)
 
(*------------------------------*) 
 
PROCEDURE
      i21pdescriptor (
            g_area       : tin_global_in_vars;
            VAR descript : tsp00_C8);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                IF  sp1p_buf_len = 0
                THEN
                    sp1p_arg_count := 1
                ELSE
                    sp1p_arg_count := sp1p_arg_count + 1;
                (*ENDIF*) 
                sp1p_buf [sp1p_buf_len + 1] := csp_defined_byte;
                s10mv (sizeof (descript),sp1p_buf_size,
                      @descript,1,
                      @sp1p_buf,sp1p_buf_len + 2,mxsp_c8);
                sp1p_buf_len := sp1p_buf_len + 1 + mxsp_c8
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21pdescriptor *)
 
(*------------------------------*) 
 
PROCEDURE
      i21pparsid (
            g_area     : tin_global_in_vars;
            VAR parsid : tin_parsid);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                s10mv (sizeof (parsid),sp1p_buf_size,
                      @parsid,1,
                      @sp1p_buf,sp1p_buf_len + 1,mxin_parsid);
                sp1p_buf_len := sp1p_buf_len + mxin_parsid
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21pparsid *)
 
(*------------------------------*) 
 
PROCEDURE
      i21ppw (
            g_area : tin_global_in_vars;
            VAR pw : tsp00_CryptPw );
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                IF  sp1p_buf_len = 0
                THEN
                    sp1p_arg_count := 1
                ELSE
                    sp1p_arg_count := sp1p_arg_count + 1;
                (*ENDIF*) 
                sp1p_buf [sp1p_buf_len + 1] := csp_defined_byte;
                s10mv (sizeof (pw),sp1p_buf_size,
                      @pw,1,
                      @sp1p_buf,sp1p_buf_len + 2,CRYPTPW_MXSP00);
                sp1p_buf_len := sp1p_buf_len + 1 + CRYPTPW_MXSP00
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21ppw *)
 
(*------------------------------*) 
 
PROCEDURE
      i21pstring (
            g_area : tin_global_in_vars;
            VAR s  : tsp00_Buf;
            l_s    : tin_natural);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                BEGIN
                sp1p_buf [sp1p_buf_len + 1] := '''';
                s10mv (sizeof (s),sp1p_buf_size,
                      @s,1,
                      @sp1p_buf,sp1p_buf_len + 2,l_s);
                sp1p_buf_len := sp1p_buf_len + 1 + l_s;
                sp1p_buf [sp1p_buf_len + 1] := '''';
                sp1p_buf [sp1p_buf_len + 2] := ',';
                sp1p_buf_len := sp1p_buf_len + 2;
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21pstring *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p1string (
            g_area : tin_global_in_vars;
            VAR s  : tsp00_Buf;
            l_s    : tin_natural);
 
BEGIN
i21pstring (g_area, s, l_s);
END; (* i21p1string *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p2string (
            g_area : tin_global_in_vars;
            VAR s  : tsp00_Buf;
            l_s    : tin_natural);
 
BEGIN
i21pstring (g_area, s, l_s);
END; (* i21p2string *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p3string (
            g_area : tin_global_in_vars;
            VAR s  : tsp00_Buf;
            l_s    : tin_natural);
 
BEGIN
i21pstring (g_area, s, l_s);
END; (* i21p3string *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p4string (
            g_area : tin_global_in_vars;
            VAR s  : tsp00_Buf;
            l_s    : tin_natural);
 
BEGIN
i21pstring (g_area, s, l_s);
END; (* i21p4string *)
 
(*------------------------------*) 
 
PROCEDURE
      i21p5string (
            g_area : tin_global_in_vars;
            VAR s  : tsp00_Buf;
            l_s    : tin_natural);
 
BEGIN
i21pstring (g_area, s, l_s);
END; (* i21p5string *)
 
(*------------------------------*) 
 
PROCEDURE
      i21repcmnd (
            g_area : tin_global_in_vars;
            c      : char);
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        IF  packet_stat = p_reset
        THEN
            WITH curr_part_ptr^ DO
                sp1p_buf [sp1p_buf_len] := c;
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21repcmnd *)
 
(*------------------------------*) 
 
PROCEDURE
      i21request (
            g_area        : tin_global_in_vars;
            VAR rq_status : tin_connect_status);
 
VAR
      length   : tsp00_Int4;
      retcode  : tsp1_comm_error;
      errtext  : tsp00_ErrText;
 
BEGIN
IF  (g_area^.sql_ptr^.packet_stat = p_reset)
    AND i21dbok (g_area)
THEN
    WITH g_area^, sql_ptr^  DO
        BEGIN
        i21finish_part (g_area);
        length := s26packet_len (snd_packet_ptr);
        snd_packet_ptr^.sp1_header.sp1h_varpart_len := length;
        (* ========================================================= *)
        (* Fuer Thomas : Den Datenbereich des Kerns findest du unter *)
        (*               g_area^.p_k_global (int4).                  *)
        (* ========================================================= *)
&       ifdef INLINK
        a93request (g_area^.p_k_global,
              snd_packet_ptr, retcode);
        IF  a93return_to_kernel ( g_area^.p_k_global )
        THEN
            g_area^.session [g_area^.dbno].connect_status := rc_crash;
&       else
        (*ENDIF*) 
        sqlarequest (session [dbno].reference,
              snd_packet_ptr, length, errtext, retcode);
        IF  retcode <> sp1ce_ok
        THEN
            in21_rte_errtext (g_area, errtext);
&       endif
        (*ENDIF*) 
        rq_status := in21_transformed_result (g_area, retcode);
        IF  rq_status = rc_timeout
        THEN
            BEGIN
&           ifndef INLINK
            in21_rte_release (g_area);
&           endif
            END
        ELSE
            packet_stat:= p_requested;
        (*ENDIF*) 
        session [dbno].connect_status := rq_status;
        END
    (*ENDWITH*) 
ELSE
    BEGIN
    rq_status := g_area^.session [g_area^.dbno].connect_status;
    END;
(*ENDIF*) 
END; (* i21request *)
 
(*------------------------------*) 
 
PROCEDURE
      i21receive (
            g_area         : tin_global_in_vars;
            VAR rc_status  : tin_connect_status;
            VAR sqlstate   : tsp00_SqlState;
            VAR returncode : tsp00_Int2;
            VAR errorpos   : tsp00_Int4);
 
VAR
      length  : tsp00_Int4;
      retcode : tsp1_comm_error;
      errtext : tsp00_ErrText;
 
BEGIN
WITH g_area^, sql_ptr^  DO
    BEGIN
    rc_status := session [dbno].connect_status;
    returncode := 0;
    IF  (rc_status = rc_ok) AND
        (packet_stat <> p_requested)
    THEN
        BEGIN
        returncode := packet_stat_error; (* -8888 *)
        errorpos := 1;
        END;
    (*ENDIF*) 
    IF  (rc_status = rc_ok) AND (returncode = 0)
    THEN
        BEGIN
&       ifdef INLINK
        retcode := sp1ce_ok;
        a93receive (g_area^.p_k_global, rcv_packet_ptr);
&       else
        rcv_packet_ptr:= snd_packet_ptr;
        sqlareceive (session [dbno].reference ,
              rcv_packet_ptr, length, errtext, retcode);
        IF  retcode <> sp1ce_ok
        THEN
            in21_rte_errtext (g_area, errtext);
&       endif
        (*ENDIF*) 
        IF  retcode = sp1ce_ok
        THEN
            BEGIN
            WITH rcv_packet_ptr^ DO
                curr_segm_ptr := s26segmptr (sp1_segm);
            (*ENDWITH*) 
            WITH curr_segm_ptr^ DO
                BEGIN
                sqlstate   := sp1r_sqlstate;
                returncode := sp1r_returncode;
                errorpos   := sp1r_errorpos;
                curr_part_ptr := s26partptr (sp1p_part);
                END;
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
        rc_status := in21_transformed_result (g_area, retcode);
        IF  (rc_status = rc_ok) AND
            (returncode = no_memory_for_restab)
        THEN
            rc_status := rc_implicit_release;
        (*ENDIF*) 
        IF  (rc_status = rc_timeout) OR
            (rc_status = rc_implicit_release)
        THEN
            BEGIN
&           ifndef INLINK
            IF  (rc_status = rc_implicit_release)
            THEN
                in21_sql_errtext (g_area);
            (*ENDIF*) 
            in21_rte_release (g_area);
&           endif
            END;
        (*ENDIF*) 
        IF  (rc_status = rc_ok) AND (returncode <> database_okay)
        THEN
            BEGIN
&           ifdef garbage
            IF  returncode = database_not_accessible
            THEN
                rc_status := rc_restart_required;
&           endif
            (*ENDIF*) 
            IF  returncode = user_not_connected
            THEN
                rc_status := rc_logon_required;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        packet_stat:= p_waiting;
        session [dbno].connect_status := rc_status;
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END; (* i21receive *)
 
(*------------------------------*) 
 
PROCEDURE
      i21reset (
            g_area : tin_global_in_vars;
            m_type : tsp1_cmd_mess_type);
 
BEGIN
IF  i21dbok (g_area)
THEN
    WITH g_area^, sql_ptr^  DO
        BEGIN
        IF  (packet_stat = p_waiting) OR
            (packet_stat = p_reset)
        THEN
            BEGIN
            WITH snd_packet_ptr^.sp1_header DO
                BEGIN
                sp1h_mess_code := i20.code_type;
                sp1h_mess_swap := i20.swap;
                sp1h_appl_version := g_area^.i20.appl_version;
                sp1h_application  := g_area^.i20.application;
                END;
            (*ENDWITH*) 
            s26first_segment_init (snd_packet_ptr, sp1sk_cmd,
                  curr_segm_ptr);
            s26new_part_init (snd_packet_ptr, curr_segm_ptr^, curr_part_ptr);
            curr_part_ptr^.sp1p_part_kind := sp1pk_command;
            curr_segm_ptr^.sp1c_mess_type := m_type;
            curr_segm_ptr^.sp1c_mass_cmd := false;
            packet_stat:= p_reset;
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END; (* i21reset *)
 
(*------------------------------*) 
 
PROCEDURE
      i21rfpos (
            g_area       : tin_global_in_vars;
            m_type       : tsp1_cmd_mess_type;
            count        : tsp00_Int4;
            fetchpos     : tsp00_Int4;
            VAR res_name : tsp00_KnlIdentifier);
 
CONST
      mf_str     = 'RFETCH  POS (       ';
      mp_str     = '                   )';
      mf_str_len = 20;
      is_masscmd = true;
 
VAR
      i             : integer;
      s             : tsp00_C20;
 
BEGIN
IF  (g_area^.sql_ptr^.packet_stat = p_waiting)
    OR (g_area^.sql_ptr^.packet_stat = p_reset)
THEN
    WITH g_area^ DO
        BEGIN
        i21reset (g_area, m_type);
        i21chngmasscmd (g_area, is_masscmd);
        s := mf_str;
        i21p1cmnd (g_area, s, mf_str_len);
        s := mp_str;
        i := 18;
        WHILE (i > 0) AND (fetchpos > 0) DO
            BEGIN
            s [i] := chr (ord ('0') + (fetchpos MOD 10));
            fetchpos := fetchpos DIV 10;
            i := i - 1;
            END;
        (*ENDWHILE*) 
        i21p1cmnd (g_area, s, mf_str_len);
        IF  res_name <> bsp_knl_identifier
        THEN
            BEGIN
            i21pccmnd (g_area, ' ');
            i21pccmnd (g_area, '"');
            i21pcname (g_area, res_name);
            i21pccmnd (g_area, '"');
            END;
        (*ENDIF*) 
        i21prescount (g_area, count);
        END
    (*ENDWITH*) 
(*ENDIF*) 
END; (* i21rfpos *)
 
(*------------------------------*) 
 
PROCEDURE
      i21senderid (
            g_area : tin_global_in_vars;
            compid : tsp00_C3);
 
BEGIN
(* in former versions "senderid" contained last part of termid *)
g_area^.i20.application  := compid;
sp100_GetSenderIDVersionP (g_area^.i20.appl_version);
END; (* i21senderid *)
 
(*------------------------------*) 
 
PROCEDURE
      i21setksession (
            g_area     : tin_global_in_vars;
            VAR parsid : tin_parsid);
 
VAR
      i : integer;
 
BEGIN
WITH g_area^, session [dbno] DO
    BEGIN
    FOR i := 1 TO sizeof (ksession ) DO
        ksession [i] := parsid [i];
    (*ENDFOR*) 
    END
(*ENDWITH*) 
END; (* i21setksession *)
 
(*------------------------------*) 
 
PROCEDURE
      i21setsqlptr (
            g_area    : tin_global_in_vars;
            packet_no : integer);
 
BEGIN
WITH g_area^, session [dbno] DO
    IF  (packet_no >= 1) AND (packet_no <= 2)
    THEN
        BEGIN
        curr_packet := packet_no;
        sql_ptr := @packet_control [curr_packet];
        END
    ELSE
        i21abort;
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21setsqlptr *)
 
(*------------------------------*) 
 
PROCEDURE
      i21switchsession (
            g_area     : tin_global_in_vars;
            session_no : integer);
 
BEGIN
WITH g_area^, session [session_no] DO
    BEGIN
    dbno := session_no;
    sql_ptr := @packet_control [curr_packet];
    END;
(*ENDWITH*) 
END; (* i21switchsession *)
 
(*------------------------------*) 
 
PROCEDURE
      i21tosendreset (
            g_area : tin_global_in_vars);
 
BEGIN
WITH g_area^, sql_ptr^  DO
    BEGIN
    curr_segm_ptr := s26segmptr (snd_packet_ptr^.sp1_segm);
    curr_part_ptr := s26partptr (curr_segm_ptr^.sp1p_part);
    packet_stat   := p_reset;
    END;
(*ENDWITH*) 
END; (* i21tosendreset *)
 
(*------------------------------*) 
 
FUNCTION
      i21validpid (
            g_area     : tin_global_in_vars;
            VAR parsid : tin_parsid) : boolean;
 
BEGIN
WITH g_area^, session [dbno] DO
    BEGIN
    IF  (ksession [1] <> parsid [1]) OR
        (ksession [2] <> parsid [2]) OR
        (ksession [3] <> parsid [3]) OR
        (ksession [4] <> parsid [4])
    THEN
        i21validpid := false
    ELSE
        i21validpid := parsid <> bin_parseid;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* i21validpid *)
 
(*------------------------------*) 
 
FUNCTION
      i21valisnull (
            g_area  : tin_global_in_vars;
            pos     : tsp00_Int4) : boolean;
 
BEGIN
WITH g_area^.sql_ptr^  DO
    IF  curr_part_ptr = NIL
    THEN
        i21abort
    ELSE
        i21valisnull := curr_part_ptr^.sp1p_buf [pos]
              = csp_undef_byte;
    (*ENDIF*) 
(*ENDWITH*) 
END; (* i21valisnull *)
 
(*------------------------------*) 
 
PROCEDURE
      i21abort;
&     ifdef INLINK
 
CONST
      c_write_core  = true;
&     endif
 
VAR
      nilptr : ^integer;
 
BEGIN
&ifdef INLINK
vabort (c_write_core);
&else
nilptr := NIL;
nilptr^ := 0;
sqlabort;
&endif
END; (* i21abort *)
 
&ifndef INLINK
(*------------------------------*) 
 
PROCEDURE
      in21_connect_command (
            g_area           : tin_global_in_vars;
            installation     : boolean;
            VAR charsetname  : tsp00_KnlIdentifier);
 
CONST
      c_str         = 'CONNECT             ';
      c_str_len     = 8;
      i_str         = ' IDENTIFIED BY :PW  ';
      i_str_len     = 20;
      s_str         = ' SQLMODE ADABAS     ';
      s_str_len     = 20;
      il_str        = ' ISOLATION LEVEL    ';
      il_str_len    = 17;
      to_str        = ' TIMEOUT            ';
      to_str_len    = 9;
      cl_str        = ' CACHELIMIT         ';
      cl_str_len    = 12;
      cset_str      = ' TERMCHAR SET       ';
      cset_str_len  = 14;
      mbset_str     = ' CHARACTER SET      ';
      mbset_str_len = 15;
      nolog_str     = ' NOLOG              ';
      nolog_str_len = 8;
 
VAR
      i             : integer;
      l             : integer;
      termid        : tsp00_TermId;
      str           : tsp00_C20;
      m_type        : tsp1_cmd_mess_type;
      max_ident_len : integer;
 
BEGIN
IF  g_area^.session [g_area^.dbno].as_utility
THEN
    m_type := sp1m_utility
ELSE
    m_type := sp1m_dbs;
(*ENDIF*) 
sqltermid (termid);
WITH g_area^ DO
    BEGIN
    (* reset code_type (changed in VIN27), otherwise reconnect fails *)
    IF  ' ' = csp_ascii_blank
    THEN
        i20.code_type := csp_ascii
    ELSE
        i20.code_type := csp_ebcdic;
    (*ENDIF*) 
    i21reset (g_area, m_type);
    IF  installation
    THEN
        i21chngproducer (g_area, sp1pr_installation);
    (* connect *)
    (*ENDIF*) 
    str := c_str;
    i21p1cmnd (g_area, str, c_str_len);
    (* username *)
    i21pccmnd (g_area,'"');
    max_ident_len := sizeof (tsp00_KnlIdentifier) DIV 2;
    FOR i := 1 TO max_ident_len DO
        BEGIN
        IF  session [dbno].connect_id [i] = '"'
        THEN
            i21pccmnd (g_area,'"');
        (*ENDIF*) 
        i21pccmnd (g_area, session [dbno].connect_id [i]);
        END;
    (*ENDFOR*) 
    i21pccmnd (g_area,'"');
    (* identified by :pw *)
    str := i_str;
    i21p1cmnd (g_area, str, i_str_len);
    IF  NOT session [dbno].as_utility
    THEN
        BEGIN
        (* sqlmode option is not variable, explicit spec of ADABAS *)
        str := s_str;
        i21p1cmnd (g_area, str, s_str_len);
        IF  NOT session [dbno].nolog_session
        THEN
            BEGIN
            (* isolation level *)
            str := il_str;
            i21p1cmnd (g_area, str, il_str_len);
            i35intlj_into_str (session [dbno].isolationlevel , str, l);
            i21p1cmnd (g_area, str, l);
            END;
        (* timeout *)
        (*ENDIF*) 
        IF  session [dbno].timeout >= 0
        THEN
            (* timeout *)
            BEGIN
            str := to_str;
            i21p1cmnd (g_area, str, to_str_len);
            i35intlj_into_str (session [dbno].timeout, str, l);
            i21p1cmnd (g_area, str, l);
            END;
        (*ENDIF*) 
        IF  session [dbno].cachelimit > 0
        THEN
            (* cachelimit *)
            BEGIN
            str := cl_str;
            i21p1cmnd (g_area, str, cl_str_len);
            i35intlj_into_str (session [dbno].cachelimit, str, l);
            i21p1cmnd (g_area, str, l);
            END;
        (*ENDIF*) 
        IF  charsetname <> bsp_knl_identifier
        THEN
            (* termchar set *)
            BEGIN
            str := cset_str;
            i21p1cmnd (g_area, str, cset_str_len);
            i21pcname (g_area, charsetname);
            END;
        (*ENDIF*) 
        IF  (multibyte.dblang <> bsp_knl_identifier)
        THEN
            (* multibyte set *)
            BEGIN
            str := mbset_str;
            i21p1cmnd (g_area, str, mbset_str_len);
            i21pcname (g_area,multibyte.dblang);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  session [dbno].nolog_session
    THEN
        BEGIN
        str := nolog_str;
        i21p1cmnd (g_area, str, nolog_str_len);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
WITH g_area^, sql_ptr^ , session [dbno] DO
    BEGIN
    i21nextpart_init (g_area);
    WITH curr_part_ptr^ DO
        BEGIN
        sp1p_buf [sp1p_buf_len + 1] := csp_defined_byte;
        s10mv (sizeof (password),sp1p_buf_size,
              @password,1,
              @sp1p_buf,sp1p_buf_len + 2,CRYPTPW_MXSP00);
        sp1p_buf_len := sp1p_buf_len + 1 + CRYPTPW_MXSP00;
        sp1p_buf [sp1p_buf_len + 1] := csp_defined_byte;
        s10mv (sizeof (termid),sp1p_buf_size,
              @termid,1,
              @sp1p_buf,sp1p_buf_len + 2,mxsp_termid);
        sp1p_buf_len := sp1p_buf_len + 1 + mxsp_termid
        END;
    (*ENDWITH*) 
    s26finish_part (snd_packet_ptr, curr_part_ptr^);
    END;
(*ENDWITH*) 
END; (* in21_connect_command *)
 
&endif
(*------------------------------*) 
 
PROCEDURE
      in21_find_errortext (
            g_area           : tin_global_in_vars;
            VAR translate    : boolean);
 
VAR
      i            : integer;
 
BEGIN
WITH g_area^.sql_ptr^  DO
    BEGIN
    curr_segm_ptr := s26segmptr (rcv_packet_ptr^.sp1_segm);
    curr_part_ptr := NIL;
    WITH rcv_packet_ptr^.sp1_header DO
        BEGIN
        translate := sp1h_mess_code <> g_area^.i20.code_type;
        FOR i := 1 TO sp1h_no_of_segm DO
            BEGIN
            IF  curr_part_ptr = NIL
            THEN
                s26find_part (curr_segm_ptr^, sp1pk_errortext,
                      curr_part_ptr);
            (*ENDIF*) 
            IF  (curr_part_ptr = NIL) AND (i < sp1h_no_of_segm)
            THEN
                s26next_segment (curr_segm_ptr);
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDWITH*) 
END; (* in21_find_errortext *)
 
(*------------------------------*) 
 
PROCEDURE
      in21_msg_trans (
            g_area      : tin_global_in_vars;
            msg_ptr     : tsp00_MoveObjPtr;
            msg_len     : integer;
            VAR res_len : tsp00_Int4);
 
VAR
      packet_code : tsp00_Int2;
      trans_ret   : tsp8_uni_error;
      errpos      : tsp00_Int4;
 
BEGIN
packet_code :=
      g_area^.sql_ptr^.rcv_packet_ptr^.sp1_header.sp1h_mess_code;
WITH g_area^.multibyte, g_area^.sql_ptr^.curr_part_ptr^  DO
    s80uni_trans (s30gad1 (sp1p_buf [1]), msg_len, packet_code,
          msg_ptr, res_len, dblang_idx,
          [ ], trans_ret, errpos);
(*ENDWITH*) 
END; (* in21_msg_trans *)
 
(*------------------------------*) 
 
PROCEDURE
      in21_next_char (
            is_unicode : boolean;
            VAR cmd    : tsp00_MoveObj;
            cmd_len    : tsp00_Int4;
            VAR pos    : tsp00_Int4);
 
BEGIN
IF  pos <= cmd_len
THEN
    IF  is_unicode
    THEN
        WHILE (cmd [pos] = ' ') AND (pos <= cmd_len) DO
            IF  cmd [pos - 1] = csp_unicode_mark
            THEN
                pos := pos + 2
            ELSE
                pos := cmd_len + 1
            (*ENDIF*) 
        (*ENDWHILE*) 
    ELSE
        WHILE (cmd [pos] = ' ') AND (pos < cmd_len) DO
            pos := pos + 1;
        (*ENDWHILE*) 
    (*ENDIF*) 
(*ENDIF*) 
END; (* in21_next_char *)
 
&ifndef INLINK
(*------------------------------*) 
 
PROCEDURE
      in21_rte_errtext (
            g_area      : tin_global_in_vars;
            VAR errtext : tsp00_ErrText);
 
CONST
      rte_returncode = csp_minint2;
 
BEGIN
WITH g_area^.i20 DO
    BEGIN
    SAPDB_PascalForcedFill (sizeof (errmsg), @errmsg, 1, sizeof (errmsg), bsp_c1);
    s10mv (sizeof (errtext),sizeof (errmsg),
          @errtext,1,
          @errmsg,1,sizeof (errtext));
    errcode := rte_returncode;
    END;
(*ENDWITH*) 
END; (* in21_rte_errtext *)
 
(*------------------------------*) 
 
PROCEDURE
      in21_sql_errtext (
            g_area : tin_global_in_vars);
 
CONST
      rte_returncode = csp_minint2;
 
VAR
      translate : boolean;
      len       : tsp00_Int4;
 
BEGIN
in21_find_errortext (g_area, translate);
WITH g_area^, sql_ptr^ DO
    BEGIN
    SAPDB_PascalForcedFill (sizeof (i20.errmsg),
          @i20.errmsg, 1, sizeof (i20.errmsg), bsp_c1);
    IF  curr_part_ptr <> NIL
    THEN
        BEGIN
        i20.errcode := curr_segm_ptr^.sp1r_returncode;
        len := curr_part_ptr^.sp1p_buf_len;
        IF  translate
        THEN
            len := len DIV 2;
        (*ENDIF*) 
        IF  len > sizeof (i20.errmsg)
        THEN
            len := sizeof (i20.errmsg);
        (*ENDIF*) 
        IF  translate
        THEN
            in21_msg_trans (g_area, s30gad1 (i20.errmsg [1]), len * 2,
                  len)
        ELSE
            s10mv (curr_part_ptr^.sp1p_buf_size,sizeof (i20.errmsg),
                  @curr_part_ptr^.sp1p_buf,1,
                  @i20.errmsg,1,len);
        (*ENDIF*) 
        END
    ELSE
        i20.errcode := rte_returncode;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* in21_sql_errtext *)
 
(*------------------------------*) 
 
PROCEDURE
      in21_rte_connect (
            g_area      : tin_global_in_vars;
            aid         : tsp00_TaskId;
            VAR errtext : tsp00_ErrText;
            VAR result  : tsp1_comm_error);
 
VAR
      i                   : integer;
      packet_size         : tsp00_Int4;
      aligned_packet_size : tsp00_Int4;
      packet_list         : tsp1_packet_list;
 
BEGIN
WITH g_area^, session [dbno]  DO
    BEGIN
    sqlaconnect (aid, nodeid, serverdb , service, cin_maxpackets,
          reference, packet_size, packet_list, errtext, result);
    IF  (result <> sp1ce_ok)
    THEN
        in21_rte_errtext (g_area, errtext);
    (*ENDIF*) 
    IF  (result = sp1ce_ok) AND
        (packet_control [1].snd_packet_ptr = NIL) AND
        (packet_control [2].snd_packet_ptr = NIL)
    THEN
        BEGIN
        packet_control [1].snd_packet_ptr := packet_list [1];
        packet_control [2].snd_packet_ptr := packet_list [2];
        aligned_packet_size := (packet_size DIV csp1_part_align_length)
              * csp1_part_align_length;
        FOR i := 1 TO cin_maxpackets DO
            BEGIN
            WITH packet_control [i], snd_packet_ptr^ DO
                BEGIN
                sp1_header.sp1h_varpart_size :=
                      aligned_packet_size - sizeof (sp1_header);
                rcv_packet_ptr := snd_packet_ptr;
                curr_segm_ptr  := @snd_packet_ptr^.sp1_segm;
                curr_part_ptr  := @curr_segm_ptr^.sp1p_part;
                END;
            (*ENDWITH*) 
            END
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    sql_ptr := @packet_control[curr_packet];
    END;
(*ENDWITH*) 
END; (* in21_rte_connect *)
 
(*------------------------------*) 
 
PROCEDURE
      in21_rte_release (
            g_area      : tin_global_in_vars);
 
VAR
      i : integer;
 
BEGIN
WITH g_area^, session [dbno]  DO
    BEGIN
    sqlarelease (reference);
    FOR i := 1 TO cin_maxpackets DO
        BEGIN
        packet_control [i].snd_packet_ptr := NIL;
        packet_control [i].rcv_packet_ptr := NIL;
        packet_control [i].curr_segm_ptr  := NIL;
        packet_control [i].curr_part_ptr  := NIL;
        END;
    (*ENDFOR*) 
    is_connected := false;
    END;
(*ENDWITH*) 
END; (* in21_rte_release *)
 
(*------------------------------*) 
 
PROCEDURE
      i21rterelease (
            g_area     : tin_global_in_vars);
 
BEGIN
WITH g_area^ DO
    BEGIN
    IF  session [dbno].is_connected
    THEN
        BEGIN
        in21_rte_release (g_area);
        sql_ptr^.packet_stat := p_waiting;
        g_area^.session [dbno].is_connected := FALSE;
        END;
    (*ENDIF*) 
    END; (* ENDE stop_session *)
(*ENDWITH*) 
END; (* i21rterelease *)
 
&endif
(*------------------------------*) 
 
FUNCTION
      in21_transformed_result (
            g_area : tin_global_in_vars;
            result : tsp1_comm_error) : tin_connect_status;
 
BEGIN
CASE result OF
    sp1ce_ok :
        in21_transformed_result := rc_ok;
    sp1ce_tasklimit :
        BEGIN
        in21_transformed_result := rc_too_many_users;
        END;
    sp1ce_timeout :
        BEGIN
        in21_transformed_result := rc_timeout;
        END;
    sp1ce_crash :
        BEGIN
        in21_transformed_result := rc_timeout;
        END;
    sp1ce_start_required :
        BEGIN
        in21_transformed_result := rc_dbms_start_required;
        END;
    sp1ce_shutdown :
        BEGIN
        in21_transformed_result := rc_restart_required;
        END;
    sp1ce_send_line_down,
    sp1ce_receive_line_down,
    sp1ce_packet_limit :
        BEGIN
        in21_transformed_result := rc_too_many_databases;
        END;
    OTHERWISE
        (* sp1ce_notok, *)
        BEGIN
        IF  g_area^.dbno = 1
        THEN
            g_area^.session [g_area^.dbno].connect_status := rc_crash;
        (*ENDIF*) 
        in21_transformed_result := rc_dbms_start_required;
        END;
    END
(*ENDCASE*) 
END; (* in21_transformed_result *)
 
(*------------------------------*) 
 
PROCEDURE
      in21_unicode20 (
            g_area    : tin_global_in_vars;
            VAR s     : tsp00_C20;
            s_len     : integer;
            VAR u     : tsp00_C40;
            VAR u_len : integer);
 
VAR
      i : integer;
 
BEGIN
u_len := 0;
i     := 0;
IF  g_area^.i20.swap = sw_normal
THEN
    WHILE i < s_len DO
        BEGIN
        u_len := u_len + 2;
        i := i + 1;
        u [u_len - 1] := csp_unicode_mark;
        u [u_len    ] := s [i];
        END
    (*ENDWHILE*) 
ELSE
    WHILE i < s_len DO
        BEGIN
        u_len := u_len + 2;
        i := i + 1;
        u [u_len - 1] := s [i];
        u [u_len    ] := csp_unicode_mark;
        END;
    (*ENDWHILE*) 
(*ENDIF*) 
END; (* in21_unicode20 *)
 
(*------------------------------*) 
 
PROCEDURE
      in21_word (
            is_unicode : boolean;
            VAR cmd    : tsp00_MoveObj;
            cmd_len    : tsp00_Int4;
            VAR pos    : tsp00_Int4;
            VAR word   : tsp00_C10);
 
VAR
      i : integer;
 
BEGIN
i := 1;
IF  pos <= cmd_len
THEN
    IF  is_unicode
    THEN
        WHILE (cmd [pos] <> ' ') AND (pos < cmd_len) AND (i <= 10) DO
            IF  cmd [pos - 1] <> csp_unicode_mark
            THEN
                pos := cmd_len + 1
            ELSE
                BEGIN
                word [i]  := s60tocap (cmd [pos] );
                i := i + 1;
                pos := pos + 2;
                END
            (*ENDIF*) 
        (*ENDWHILE*) 
    ELSE
        WHILE (cmd [pos] <> ' ') AND (pos < cmd_len) AND (i <= 10) DO
            BEGIN
            word [i]  := s60tocap (cmd [pos] );
            i := i + 1;
            pos := pos + 1;
            END;
        (*ENDWHILE*) 
    (*ENDIF*) 
(*ENDIF*) 
END; (* in21_word *)
 
&ifndef INLINK
(*------------------------------*) 
 
PROCEDURE
      i21_xconnect (
            g_area          : tin_global_in_vars;
            installation    : boolean;
            VAR charsetname : tsp00_KnlIdentifier;
            VAR status      : tin_connect_status);
 
VAR
      aid         : tsp00_TaskId;
      result      : tsp1_comm_error;
      sqlstate    : tsp00_SqlState;
      returncode  : tsp00_Int2;
      errorpos    : tsp00_Int4;
      errtext     : tsp00_ErrText;
 
BEGIN
(* first, re- and additional connect only if .. *)
IF  i21dbok (g_area)
THEN
    BEGIN
    sqluid (aid);
    WITH g_area^ DO
        BEGIN
        errtext := bsp_c40;
        IF  session [dbno].as_utility
        THEN
            session [dbno].service := sql_utility
        ELSE
            session [dbno].service := sql_user;
        (*ENDIF*) 
        in21_rte_connect (g_area, aid, errtext, result);
        IF  result <> sp1ce_ok
        THEN
            in21_rte_errtext (g_area, errtext);
        (*ENDIF*) 
        status := in21_transformed_result (g_area, result);
        END; (* ENDE start_session *)
    (*ENDWITH*) 
    IF  status = rc_ok
    THEN
        BEGIN
        WITH g_area^ DO
            session [dbno].ksession := '    ';
        (*ENDWITH*) 
        in21_connect_command (g_area, installation, charsetname);
        i21request (g_area, status);
        IF  status = rc_ok
        THEN
            BEGIN
            i21receive (g_area, status, sqlstate, returncode, errorpos);
            END;
        (*ENDIF*) 
        IF  status = rc_ok
        THEN
            BEGIN
            g_area^.i20.code_type := g_area^.sql_ptr^.rcv_packet_ptr^.
                  sp1_header.sp1h_mess_code;
            IF  returncode <> 0
            THEN
                BEGIN
                status := rc_user_or_pswd_illegal;
                in21_sql_errtext (g_area);
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        g_area^.session [g_area^.dbno].is_connected := (status = rc_ok);
        END; (* ENDE connect *)
    (*ENDIF*) 
    IF  NOT (status in [rc_ok, rc_timeout, rc_dbms_start_required] )
    THEN
        BEGIN
        WITH g_area^ DO
            BEGIN
            in21_rte_release (g_area);
            g_area^.session [g_area^.dbno].is_connected := FALSE;
            END;
        (*ENDWITH*) 
        END; (* ENDE stop_session *)
    (*ENDIF*) 
    g_area^.session [g_area^.dbno].connect_status := status;
    END
ELSE
    status := g_area^.session [g_area^.dbno].connect_status;
(*ENDIF*) 
END; (* in21_xconnect *)
 
&endif
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
