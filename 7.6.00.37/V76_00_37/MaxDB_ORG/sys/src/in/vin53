.CM  SCRIPT , Version - 1.1 , last edited by holger
.CM Anfang
.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VIN53$
.tt 2 $$$
.TT 3 $$ls_screen_io$1996-04-16$
***********************************************************
.nf
 
.nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : logical_screen_procedures
=========
.sp
Purpose : Ein/Ausgabe ?uber das virtuelle Terminal
 
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              i53clear (
                    att               : tin_ls_attribute_index;
                    maxlines, maxcols : integer;
                    vt_screen         : tsp00_ScreenBufAddr;
                    vt_att            : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53clwindow (
                    sno                 : tsp00_Int2;
                    first_row,first_col : integer;
                    last_row, last_col  : integer;
                    ft                  : tin_ls_fieldtype;
                    maxlines,maxcols    : integer;
                    vt_screen           : tsp00_ScreenBufAddr;
                    vt_att              : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53put1field (
                    VAR field        : tsp00_MoveObj;
                    length           : integer;
                    sno              : tsp00_Int2;
                    field_slno       : integer;
                    field_scol       : integer;
                    VAR field_type   : tin_ls_fieldtype;
                    maxlines,maxcols : integer;
                    vt_screen        : tsp00_ScreenBufAddr;
                    vt_att           : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53put2field (
                    VAR field        : tsp00_MoveObj;
                    length           : integer;
                    sno              : tsp00_Int2;
                    field_slno       : integer;
                    field_scol       : integer;
                    VAR field_type   : tin_ls_fieldtype;
                    maxlines,maxcols : integer;
                    vt_screen        : tsp00_ScreenBufAddr;
                    vt_att           : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53put3field (
                    VAR field        : tsp00_MoveObj;
                    length           : integer;
                    sno              : tsp00_Int2;
                    field_slno       : integer;
                    field_scol       : integer;
                    VAR field_type   : tin_ls_fieldtype;
                    maxlines,maxcols : integer;
                    vt_screen        : tsp00_ScreenBufAddr;
                    vt_att           : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53put4field (
                    VAR field        : tsp00_MoveObj;
                    length           : integer;
                    sno              : tsp00_Int2;
                    field_slno       : integer;
                    field_scol       : integer;
                    VAR field_type   : tin_ls_fieldtype;
                    maxlines,maxcols : integer;
                    vt_screen        : tsp00_ScreenBufAddr;
                    vt_att           : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53put5field (
                    VAR field        : tsp00_MoveObj;
                    length           : integer;
                    sno              : tsp00_Int2;
                    field_slno       : integer;
                    field_scol       : integer;
                    VAR field_type   : tin_ls_fieldtype;
                    maxlines,maxcols : integer;
                    vt_screen        : tsp00_ScreenBufAddr;
                    vt_att           : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53erasefield(
                    field_slno       : integer;
                    field_scol       : integer;
                    maxlines,maxcols : integer;
                    vt_screen        : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53put1attribute (
                    sno              : tsp00_Int2;
                    field_slno       : integer;
                    field_scol       : integer;
                    VAR field_type   : tin_ls_fieldtype;
                    maxcols          : integer;
                    vt_att           : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53put2attribute (
                    sno              : tsp00_Int2;
                    field_slno       : integer;
                    field_scol       : integer;
                    VAR field_type   : tin_ls_fieldtype;
                    maxcols          : integer;
                    vt_att           : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53fillattribute (
                    sno              : tsp00_Int2;
                    field_slno       : integer;
                    field_scol       : integer;
                    count            : integer;
                    VAR field_type   : tin_ls_fieldtype;
                    maxcols          : integer;
                    vt_att           : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53fieldtypetochars (
                    ft      : tin_ls_fieldtype;
                    VAR att : char);
 
        PROCEDURE
              i53setprotected (
                    row               : integer;
                    lines             : integer;
                    maxcols           : integer;
                    vt_att            : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53nextfield (
                    VAR row,col       : integer;
                    VAR length        : integer;
                    VAR found         : boolean;
                    VAR field_changed : boolean;
                    maxlines          : integer;
                    maxcols           : integer;
                    vt_screen         : tsp00_ScreenBufAddr;
                    vt_att            : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53skipfield (
                    VAR row,col : integer;
                    VAR found   : boolean;
                    maxlines    : integer;
                    maxcols     : integer;
                    vt_screen   : tsp00_ScreenBufAddr);
 
        FUNCTION
              i53isinput(
                    vt_screen : tsp00_ScreenBufAddr;
                    vt_att    : tsp00_ScreenBufAddr;
                    pos       : integer) : boolean;
 
        FUNCTION
              i53length (
                    row,col   : integer;
                    maxlines  : integer;
                    maxcols   : integer;
                    vt_screen : tsp00_ScreenBufAddr) : integer;
 
        PROCEDURE
              i53getfield (
                    row,col        : integer;
                    VAR length     : integer;
                    VAR input      : tin_screenline;
                    maxcols        : integer;
                    vt_screen      : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53setunchanged (
                    row,col,length : integer;
                    maxcols        : integer;
                    vt_att         : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53attchange (
                    sno            : tsp00_Int2;
                    win            : tin_ls_window;
                    VAR ft         : tin_ls_fieldtype;
                    maxcols        : integer;
                    vt_att         : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53changelimits (
                    sno   : tsp00_Int2;
                    rowno : tsp00_Int2);
 
        FUNCTION
              i53tobufpos (
                    lno, col : integer;
                    maxcols  : integer) : integer;
 
        PROCEDURE
              i53frombufpos (
                    pos     : integer;
                    maxcols : integer;
                    VAR row : integer;
                    VAR col : integer);
 
        PROCEDURE
              i53screenaddresses (
                    sno          : tsp00_Int2;
                    VAR screen   : tsp00_ScreenBufAddr;
                    VAR att      : tsp00_ScreenBufAddr;
                    VAR maxlines : tsp00_Int2;
                    VAR maxcols  : tsp00_Int2);
 
        PROCEDURE
              i53getlineattributes (
                    sno              : tsp00_Int2;
                    field_slno       : integer;
                    field_scol       : integer;
                    count            : integer;
                    VAR attr_line    : tin_screenline;
                    maxcols          : integer;
                    vt_att           : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53putlineattributes (
                    sno              : tsp00_Int2;
                    field_slno       : integer;
                    field_scol       : integer;
                    count            : integer;
                    VAR attr_line    : tin_screenline;
                    maxcols          : integer;
                    vt_att           : tsp00_ScreenBufAddr);
 
        PROCEDURE
              i53rareplace_attr (
                    VAR in_attr_line  : tin_screenline;
                    VAR out_attr_line : tin_screenline;
                    attr_line_len     : integer;
                    new_att           : tin_ls_attribute_index );
 
        FUNCTION
              i53fchanged (
                    vt_att   : tsp00_ScreenBufAddr;
                    lno, col : integer;
                    length   : integer;
                    maxcols  : integer ) : boolean;
 
        PROCEDURE
              i53check_field_for_multibyte (
                    VAR field  : tsp00_MoveObj;
                    length     : integer);
 
        FUNCTION
              in5330 : tsp00_Int4;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              global_variable : VIN01;
 
        VAR
              i01g : tin_global_in_vars;
&       ifdef WINDOWS
 
      ------------------------------ 
 
        FROM
              logical_screen_modules : VIN56 ;
 
        VAR
              i56recursion : tsp00_Int2;
              i56desc2     : tsp00_TerminalDescription ;
&       endif
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;       
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;    
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;    
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30lenl (
                    VAR str : tsp00_ScreenBuf;
                    val     : char;
                    start   : tsp00_Int4;
                    cnt     : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30klen (VAR str : tin_screenline;
                    val : char;
                    cnt : integer) : integer;
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80: VSP80;
 
        FUNCTION
              s80uni_chartype(
                    str_ptr         : tsp00_MoveObjPtr;
                    VAR str_len     : tsp00_Int4;
                    str_codeset     : tsp00_Int2): tsp8_uni_error;
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        FUNCTION
              s30lenl;
 
              tsp00_MoveObj tsp00_ScreenBuf;
 
        FUNCTION
              s30klen;
 
              tsp00_MoveObj tin_screenline
 
        PROCEDURE
              m90buf;
 
              tsp00_Buf tsp00_ScreenBuf
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1984-07-30
.sp
.cp 3
.sp
.cp 3
Release :  6.1.2     Date : 1995-11-01
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
This module fills the 3 screen buffers for the virtual terminal.  It
requires no information on the layout of the dialog components
(as opposed to VIN50).
.sp;Only the following constants and types are used:
.sp 2;.nf;.in +10
CONST
      maxmovelength     = 8192;
      screen_chars  = (* >= maxcols * maxlines *);
      blank          = ' ';
      mi_screenline       = (* >= maxcols *);
 
TYPE
      screenbuffer   =  PACKED ARRAY [ 1..max_screen_chars ] OF char;
      ti_screenline      = PACKED ARRAY [ 1..mi_screenline ] OF char;
      vt_mode = ( vt_bright, vt_inverse, vt_blink,
                  vt_underline, vt_invisible, vt_mixed, vt_greyed);
      vt_attrib = PACKED SET OF vt_mode;
      vt_color = (default_color, vt_white, vt_black, vt_red,
                  vt_green, vt_yellow, vt_blue, vt_pink, vt_light_blue);
      vt_inputmode  = (vt_output, vt_input );
      ti_ls_fieldtype = RECORD
            foreground : vt_color;
            background : vt_color;
            field_att  : vt_attrib;
            fieldmode  : vt_inputmode;
      END;
.in 0;.fo
.oc _/1;The procedures
.sp 2
In the following, the SCREENBUFFERs
.sp;.in +12;.nf
VT_SCREEN
VT_ATT
VT_COL
.sp;.fo;.in -12
designate the buffers for screen contents, screen attributes and screen
colors.
.sp;MAXLINES and MAXCOLS are the entries for screen size in
lines and columns, respectively, that have been returned by
VTON in the TERMINAL_DESCRIPTION.
.cp 12;.nf
PROCEDURE
      i53clear (
            background    : vt_color;
            maxchars      : integer;
            VAR vt_screen : screenbuffer;
            VAR vt_att    : screenbuffer);
.sp 2;.fo
Initializes the screen buffer.  For the next VTINOUT, an empty
screen with the background color BACKGROUND would be output.
.sp 2;.cp 12;.nf
PROCEDURE
      i53clwindow (
            first_row,first_col : integer;
            last_row, last_col  : integer;
            ft                  : ti_ls_fieldtype;
            maxlines,maxcols    : integer;
            VAR vt_screen       : screenbuffer;
            VAR vt_att          : screenbuffer);
.sp 2;.fo
Deletes a window from the screen form.  This window begins at
(first_row,first_col) and ends at (last_row,last_col).
The presentation of the background (color, attribute) is specified
in FT.
.sp 2;.cp 12;.nf
PROCEDURE
      i53put1field (
            VAR field        : moveobject;
            length           : integer;
            field_slno       : integer;
            field_scol       : integer;
            field_type       : ti_ls_fieldtype;
                  maxlines,maxcols : integer;
            VAR vt_screen    : screenbuffer;
            VAR vt_att       : screenbuffer;
            VAR vt_col       : screenbuffer);
.sp 2;.fo
Fills the screen buffer with the text contents from FIELD (length LENGTH)
at the position (field_slno,field_scol).  The field is output with an
attribute and colors from FIELD_TYPE.
.sp 2;.cp 12;.nf
PROCEDURE
      i53put2field .. i53put5field
.sp 2;.fo
Duplicates of i53put1field for use with synonyms.
.sp 2;.cp 12;.nf
PROCEDURE
      i53put1attribute (
            field_slno       : integer;
            field_scol       : integer;
            field_type       : ti_ls_fieldtype;
                  maxlines,maxcols : integer;
            VAR vt_att       : screenbuffer;
            VAR vt_col       : screenbuffer);
.sp 2;.fo
Places the attribute and the color specified via FIELD_TYPE at the
position (field_slno,field_scol) in the screen buffers.
This procedure is used for mixed fields.
.sp 2;.cp 12;.nf
PROCEDURE
      i53fieldtypetochars (
            ft      : ti_ls_fieldtype;
                  VAR att : char);
.sp 2;.fo
Converts the entries in FT into characters for color and attribute as
they are used to SAPDB_PascalForcedFill the screen buffer.
.sp 2;.cp 12;.nf
PROCEDURE
      i53nextfield (
            VAR row,col       : integer;
            VAR length        : integer;
            VAR found         : boolean;
                  VAR field_changed : boolean;
            maxlines          : integer;
            maxcols           : integer;
            VAR vt_screen     : screenbuffer;
            VAR vt_att        : screenbuffer);
.sp 2;.fo
This procedure and the next one are required for reading in inputs
from the screen buffers.
.sp;i53nextfield positions the pointers ROW and COL to the next
input field in VT_SCREEN (sequence runs from upper left to lower right).
The first time, ROW and COL can both be set to 0.
.br;LENGTH is the length of the field found;
.br;FOUND is FALSE if no other field was found;
.br;FIELD_CHANGED is true if the field was changed by the user.
.sp 2;.cp 12;.nf
PROCEDURE
      i53getfield (
            row,col       : integer;
            VAR length    : integer;
            VAR input     : ti_screenline;
            maxcols       : integer;
                   VAR vt_screen : screenbuffer);
.sp 2;.fo
returns the contents of the screen buffer at the position (row,col).
.sp;At the time of the call, LENGTH is the length of the field as it
was defined (and returned by i53nextfield); at the time of the return,
it indicates the current length (trailing blanks are trimmed).
.sp;.oc _/1;Important!
.sp;Before i53getfield, i53nextfield absolutely must be called if the exact
position is unknown.
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
TYPE
      byte = 0..255;
      bit = 0..1;
 
      int_to_attribute = PACKED RECORD
            CASE boolean OF
                true:
                    (b : byte);
                false:
                    (a : tsp00_VtAttrib);
                END;
            (*ENDCASE*) 
 
 
 
(*------------------------------*) 
 
FUNCTION
      in5330 : tsp00_Int4;
 
BEGIN
(* linkcheck function *)
in5330 := 219020409;
END;
 
(*------------------------------*) 
 
PROCEDURE
      i53clear (
            att               : tin_ls_attribute_index;
            maxlines, maxcols : integer;
            vt_screen         : tsp00_ScreenBufAddr;
            vt_att            : tsp00_ScreenBufAddr);
 
VAR
      maxchars : integer;
      i        : integer;
 
BEGIN
&ifdef WINDOWS
IF  (i56recursion = 0)
THEN
&   endif
    IF  (vt_screen <> NIL)
        AND (vt_att <> NIL)
    THEN
        BEGIN
        maxchars := maxlines * maxcols;
        SAPDB_PascalForcedFill (SCREEN_CHARS_MXSP00,@vt_screen^,1,maxchars,bsp_c1);
        vt_screen^ [1]  := chr(csp_vt_eof);
        (* background att *)
        SAPDB_PascalForcedFill (SCREEN_CHARS_MXSP00,@vt_att^,1,maxchars,chr(att));
        i := 1;
        REPEAT
            vt_att^ [i]  := chr(cin_ls_normal);
            (* h.b. 16.12.92 *)
            i := i + maxcols;
        UNTIL
            i > maxchars;
        (*ENDREPEAT*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END; (* i53clear *)
 
(*------------------------------*) 
 
PROCEDURE
      i53clwindow (
            sno                 : tsp00_Int2;
            first_row,first_col : integer;
            last_row, last_col  : integer;
            ft                  : tin_ls_fieldtype;
            maxlines,maxcols    : integer;
            vt_screen           : tsp00_ScreenBufAddr;
            vt_att              : tsp00_ScreenBufAddr);
 
VAR
      pos      : integer;
      att      : char;
      length   : integer;
      row,col  : integer;
      old_mark : char;
      end_pos  : integer;
 
BEGIN
&ifdef WINDOWS
IF  (i56recursion = 0)
THEN
&   endif
    IF  (vt_screen <> NIL)
        AND (vt_att <> NIL)
    THEN
        BEGIN
        IF  last_row > maxlines
        THEN
            last_row := maxlines;
        (*ENDIF*) 
        IF  first_row <= last_row
        THEN
            BEGIN
            i53changelimits(sno, first_row);
            i53changelimits(sno, last_row);
            i53fieldtypetochars(ft,att);
            FOR row := first_row TO last_row DO
                BEGIN
                pos := (row - 1) * maxcols + first_col;
                length := last_col - first_col + 1;
                IF  pos = 1
                THEN
                    BEGIN
                    pos := 2;
                    length := length - 1;
                    END;
                (*ENDIF*) 
                get_actual_fieldmark(vt_screen, vt_att,
                      pos, length-1, maxlines*maxcols, old_mark);
                end_pos := pos + length - 1;
                IF  ord(vt_screen^ [end_pos] ) > csp_vt_socf
                THEN
                    vt_screen^ [end_pos ] := old_mark;
                (*ENDIF*) 
                SAPDB_PascalForcedFill (SCREEN_CHARS_MXSP00,@vt_screen^,pos,length-1,chr(csp_vt_eof));
                SAPDB_PascalForcedFill (SCREEN_CHARS_MXSP00,@vt_att^,pos,length,att);
                END;
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END; (* i53clwindow *)
 
(*------------------------------*) 
 
PROCEDURE
      i53put1field (
            VAR field        : tsp00_MoveObj;
            length           : integer;
            sno              : tsp00_Int2;
            field_slno       : integer;
            field_scol       : integer;
            VAR field_type   : tin_ls_fieldtype;
            maxlines,maxcols : integer;
            vt_screen        : tsp00_ScreenBufAddr;
            vt_att           : tsp00_ScreenBufAddr);
 
VAR
      att      : char;
      old_mark : char;
      pos      : integer;
      fpos     : integer;
      maxchars : integer;
 
BEGIN
maxchars := maxlines * maxcols;
&ifdef WINDOWS
IF  (i56recursion = 0)
THEN
&   endif
    IF  (vt_screen <> NIL)
        AND (vt_att <> NIL)
        AND (field_slno <= maxlines)
        AND (field_scol <= maxcols )
    THEN
        BEGIN
        i53changelimits(sno, field_slno);
        pos := i53tobufpos(field_slno, field_scol, maxcols) ;
        fpos := 1;
        IF  pos = 1
        THEN
            BEGIN
            fpos := 2;
            pos := pos + 1;
            length := length - 1;
            END
        ELSE (* B.M. 17.08.93 Release 3.1.3 *)
            IF  pos + length > maxchars + 1
            THEN
                length := maxchars - pos + 1;
            (*ENDIF*) 
        (*ENDIF*) 
        get_actual_fieldmark(vt_screen, vt_att,
              pos, length, maxchars, old_mark);
        (* =================================== *)
        (* B.J. 26.1.94: damit es auch in den  *)
        (* feldorientierten Masken tut.        *)
        (* IF  [  ls_input, ls_continued ] <= field_type.fieldmode *)
        (* =================================== *)
        IF  ls_continued IN field_type.fieldmode
        THEN
            vt_screen^ [pos-1 ] := chr(csp_vt_socf)
        ELSE
            vt_screen^ [pos-1 ] := chr(csp_vt_soncf);
        (*ENDIF*) 
        (* text *)
        IF  i01g^.multibyte.dblang <> bsp_knl_identifier
        THEN
            i53check_field_for_multibyte (field, length);
        (*ENDIF*) 
        s10mv(MOVEOBJ_MXSP00,SCREEN_CHARS_MXSP00,
              @field,fpos,
              @vt_screen^,pos,length);
        (* attribute bytes *)
        fieldtype_to_char(field_type,att);
        SAPDB_PascalForcedFill (SCREEN_CHARS_MXSP00,@vt_att^,pos,length,att);
        pos := pos + length; (* behind field *)
        IF  (pos < maxchars) (* B.M. 17.08.93 Release 3.1.3 *)
        THEN
            BEGIN
            IF  (ord(vt_screen^ [pos] ) <> csp_vt_soncf)
                AND (ord(vt_screen^ [pos] ) <> csp_vt_socf)
            THEN
                vt_screen^ [ pos ] := old_mark; (* SOF or EOF *)
            (*ENDIF*) 
            END
        ELSE
            IF  (pos = maxchars )
            THEN
                vt_screen^ [ pos ] := chr( csp_vt_eof );
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END; (* i53put1field *)
 
(*------------------------------*) 
 
PROCEDURE
      i53put2field (
            VAR field        : tsp00_MoveObj;
            length           : integer;
            sno              : tsp00_Int2;
            field_slno       : integer;
            field_scol       : integer;
            VAR field_type   : tin_ls_fieldtype;
            maxlines,maxcols : integer;
            vt_screen        : tsp00_ScreenBufAddr;
            vt_att           : tsp00_ScreenBufAddr);
 
BEGIN
i53put1field(field,length,sno, field_slno,field_scol,
      field_type,maxlines,maxcols,
      vt_screen,vt_att);
END; (* i53put2field *)
 
(*------------------------------*) 
 
PROCEDURE
      i53put3field (
            VAR field        : tsp00_MoveObj;
            length           : integer;
            sno              : tsp00_Int2;
            field_slno       : integer;
            field_scol       : integer;
            VAR field_type   : tin_ls_fieldtype;
            maxlines,maxcols : integer;
            vt_screen        : tsp00_ScreenBufAddr;
            vt_att           : tsp00_ScreenBufAddr);
 
BEGIN
i53put1field(field,length,sno, field_slno,field_scol,
      field_type,maxlines,maxcols,
      vt_screen,vt_att);
END; (* i53put2field *)
 
(*------------------------------*) 
 
PROCEDURE
      i53put4field (
            VAR field        : tsp00_MoveObj;
            length           : integer;
            sno              : tsp00_Int2;
            field_slno       : integer;
            field_scol       : integer;
            VAR field_type   : tin_ls_fieldtype;
            maxlines,maxcols : integer;
            vt_screen        : tsp00_ScreenBufAddr;
            vt_att           : tsp00_ScreenBufAddr);
 
BEGIN
i53put1field(field,length,sno, field_slno,field_scol,
      field_type,maxlines,maxcols,
      vt_screen,vt_att);
END; (* i53put2field *)
 
(*------------------------------*) 
 
PROCEDURE
      i53put5field (
            VAR field        : tsp00_MoveObj;
            length           : integer;
            sno              : tsp00_Int2;
            field_slno       : integer;
            field_scol       : integer;
            VAR field_type   : tin_ls_fieldtype;
            maxlines,maxcols : integer;
            vt_screen        : tsp00_ScreenBufAddr;
            vt_att           : tsp00_ScreenBufAddr);
 
BEGIN
i53put1field(field,length,sno, field_slno,field_scol,
      field_type,maxlines,maxcols,
      vt_screen,vt_att);
END; (* i53put2field *)
 
(*------------------------------*) 
 
PROCEDURE
      i53erasefield (
            field_slno       : integer;
            field_scol       : integer;
            maxlines,maxcols : integer;
            vt_screen        : tsp00_ScreenBufAddr);
 
VAR
      pos : integer;
 
BEGIN
&ifdef WINDOWS
IF  (i56recursion = 0)
THEN
&   endif
    IF  (vt_screen <> NIL)
    THEN
        BEGIN
        pos := (field_slno - 1) * maxcols + field_scol;
        IF  (pos <= maxlines * maxcols)
            AND (pos >  1)
        THEN
            vt_screen^ [pos-1 ] := chr(csp_vt_eof);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END; (* i53erasefield *)
 
(*------------------------------*) 
 
PROCEDURE
      i53put1attribute (
            sno              : tsp00_Int2;
            field_slno       : integer;
            field_scol       : integer;
            VAR field_type   : tin_ls_fieldtype;
            maxcols          : integer;
            vt_att           : tsp00_ScreenBufAddr);
 
VAR
      pos : integer;
      att : char;
 
BEGIN
&ifdef WINDOWS
IF  (i56recursion = 0)
THEN
&   endif
    IF  (vt_att <> NIL)
    THEN
        BEGIN
        i53changelimits(sno, field_slno);
        pos := (field_slno - 1) * maxcols + field_scol;
        fieldtype_to_char(field_type,att);
        vt_att^ [pos ] := att;
        END;
    (*ENDIF*) 
(*ENDIF*) 
END; (* i53put1attribute *)
 
(*------------------------------*) 
 
PROCEDURE
      i53put2attribute (
            sno              : tsp00_Int2;
            field_slno       : integer;
            field_scol       : integer;
            VAR field_type   : tin_ls_fieldtype;
            maxcols          : integer;
            vt_att           : tsp00_ScreenBufAddr);
 
BEGIN
i53put1attribute(sno, field_slno, field_scol, field_type,
      maxcols, vt_att);
END; (* i53put2attribute *)
 
(*------------------------------*) 
 
PROCEDURE
      i53fillattribute (
            sno              : tsp00_Int2;
            field_slno       : integer;
            field_scol       : integer;
            count            : integer;
            VAR field_type   : tin_ls_fieldtype;
            maxcols          : integer;
            vt_att           : tsp00_ScreenBufAddr);
 
VAR
      pos : integer;
      att : char;
 
BEGIN
&ifdef WINDOWS
IF  (i56recursion = 0)
THEN
&   endif
    IF  (vt_att <> NIL)
    THEN
        BEGIN
        i53changelimits(sno, field_slno);
        pos := (field_slno - 1) * maxcols + field_scol;
        fieldtype_to_char(field_type,att);
        vt_att^ [pos ] := att;
        SAPDB_PascalForcedFill (SCREEN_CHARS_MXSP00, @vt_att^, pos, count, att);
        END;
    (*ENDIF*) 
(*ENDIF*) 
END; (* i53fillattribute *)
 
(*------------------------------*) 
 
PROCEDURE
      i53getlineattributes (
            sno              : tsp00_Int2;
            field_slno       : integer;
            field_scol       : integer;
            count            : integer;
            VAR attr_line    : tin_screenline;
            maxcols          : integer;
            vt_att           : tsp00_ScreenBufAddr);
 
VAR
      pos : integer;
 
BEGIN
IF  (vt_att <> NIL)
THEN
    BEGIN
    i53changelimits(sno, field_slno);
    pos := (field_slno - 1) * maxcols + field_scol;
    IF  count > 0
    THEN
        s10mv(SCREEN_CHARS_MXSP00,mxin_screenline,
              @vt_att^,pos,
              @attr_line,1,count);
    (*ENDIF*) 
    END;
(*ENDIF*) 
END; (* i53getlineattributes *)
 
(*------------------------------*) 
 
PROCEDURE
      i53putlineattributes (
            sno              : tsp00_Int2;
            field_slno       : integer;
            field_scol       : integer;
            count            : integer;
            VAR attr_line    : tin_screenline;
            maxcols          : integer;
            vt_att           : tsp00_ScreenBufAddr);
 
VAR
      pos : integer;
 
BEGIN
IF  (vt_att <> NIL)
THEN
    BEGIN
    i53changelimits(sno, field_slno);
    pos := (field_slno - 1) * maxcols + field_scol;
    IF  count > 0
    THEN
        s10mv(mxin_screenline,SCREEN_CHARS_MXSP00,
              @attr_line,1,
              @vt_att^,pos,count);
    (*ENDIF*) 
    END;
(*ENDIF*) 
END; (* i53putlineattributes *)
 
(*------------------------------*) 
 
PROCEDURE
      i53fieldtypetochars (
            ft      : tin_ls_fieldtype;
            VAR att : char);
 
BEGIN
fieldtype_to_char(ft,att);
END; (* i53fieldtypetochar *)
 
(*------------------------------*) 
 
PROCEDURE
      i53skipfield (
            VAR row,col : integer;
            VAR found   : boolean;
            maxlines    : integer;
            maxcols     : integer;
            vt_screen   : tsp00_ScreenBufAddr);
 
VAR
      pos       : integer;
      rel_pos   : integer;
      rel_pos2  : integer;
      maxlength : integer;
 
BEGIN
&ifdef WINDOWS
IF  (i56recursion = 0)
THEN
&   endif
    IF  (vt_screen <> NIL)
    THEN
        BEGIN
        pos := (row - 1) * maxcols + col (*+ 1*); (* next pos *)
        IF  pos <= 0
        THEN
            pos := 1;
        (*ENDIF*) 
        maxlength := maxcols * maxlines - pos + 1;
        rel_pos := s30lenl (vt_screen^,chr(csp_vt_soncf),pos,maxlength);
        rel_pos2 := s30lenl (vt_screen^,chr(csp_vt_socf),pos,maxlength);
        IF  rel_pos2 < rel_pos
        THEN
            rel_pos := rel_pos2;
        (*ENDIF*) 
        found := (rel_pos < maxlength);
        IF  found
        THEN
            pos := pos + rel_pos + 1; (* skip stf *)
        (*ENDIF*) 
        IF  found
        THEN
            i53frombufpos(pos, maxcols, row, col);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END; (* i53skipfield *)
 
(*------------------------------*) 
 
PROCEDURE
      i53setprotected (
            row     : integer;
            lines   : integer;
            maxcols : integer;
            vt_att  : tsp00_ScreenBufAddr);
 
VAR
      pos,i  : integer;
      length : integer;
 
BEGIN
&ifdef WINDOWS
IF  (i56recursion = 0)
THEN
&   endif
    IF  (vt_att <> NIL)
    THEN
        BEGIN
        pos := (row - 1) * maxcols; (* col = 1 *)
        length := maxcols * lines;
        FOR i := pos+1 TO pos+length DO
            (* highest bit to 0 *)
            IF  ord(vt_att^ [i] ) >= 128
            THEN
                vt_att^ [i]  := chr( ord(vt_att^ [i] ) - 128 );
            (*ENDIF*) 
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i53nextfield (
            VAR row,col       : integer;
            VAR length        : integer;
            VAR found         : boolean;
            VAR field_changed : boolean;
            maxlines          : integer;
            maxcols           : integer;
            vt_screen         : tsp00_ScreenBufAddr;
            vt_att            : tsp00_ScreenBufAddr);
 
VAR
      pos       : integer;
      stop      : boolean;
 
BEGIN
found := false;
&ifdef WINDOWS
IF  (i56recursion = 0)
THEN
&   endif
    IF  (vt_screen <> NIL)
        AND (vt_att <> NIL)
    THEN
        BEGIN
        REPEAT
            i53skipfield(row,col, found, maxlines, maxcols, vt_screen);
            stop := NOT found;
            IF  NOT stop
            THEN
                BEGIN
                pos := (row - 1) * maxcols + col;
                found := i53isinput(vt_screen, vt_att, pos);
                END;
            (*ENDIF*) 
        UNTIL
            found OR stop;
        (*ENDREPEAT*) 
        IF  found
        THEN
            BEGIN
            (* row := ((pos - 1) DIV maxcols) + 1; *)
            (* col := ((pos - 1) MOD maxcols) + 1; *)
            length := i53length(row, col, maxlines, maxcols, vt_screen);
            field_changed := inputfield_changed(vt_att,  pos, length);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END; (* i53nextfield *)
 
(*------------------------------*) 
 
FUNCTION
      i53fchanged (
            vt_att   : tsp00_ScreenBufAddr;
            lno, col : integer;
            length   : integer;
            maxcols  : integer ) : boolean;
 
VAR
      pos : integer;
 
BEGIN
pos := i53tobufpos ( lno, col, maxcols );
i53fchanged := inputfield_changed(vt_att,  pos, length);
END;
 
(*------------------------------*) 
 
FUNCTION
      i53isinput(
            vt_screen : tsp00_ScreenBufAddr;
            vt_att    : tsp00_ScreenBufAddr;
            pos       : integer) : boolean;
 
VAR
      ft : tin_ls_fieldtype;
 
BEGIN
&ifdef WINDOWS
IF  (i56recursion = 0)
THEN
&   endif
    IF  (vt_screen <> NIL)
        AND (vt_att <> NIL)
    THEN
        BEGIN
        char_to_ft_52 (vt_att^ [pos] ,ft);
        IF  ls_mixed IN ft.fieldmode
        THEN
            i53isinput := has_inputchar(vt_screen,vt_att,pos)
        ELSE
            i53isinput := (ls_input IN ft.fieldmode);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      i53length (
            row,col   : integer;
            maxlines  : integer;
            maxcols   : integer;
            vt_screen : tsp00_ScreenBufAddr) : integer;
 
VAR
      maxchars    : integer;
      length, pos : integer;
      stop        : boolean;
 
BEGIN
length := 0;
&ifdef WINDOWS
IF  (i56recursion = 0)
THEN
&   endif
    IF  (vt_screen <> NIL)
    THEN
        BEGIN
        maxchars := maxcols * maxlines(*- 1*);
        pos := (row - 1) * maxcols + col;
        REPEAT
            stop := (pos >= maxchars);
            IF  NOT stop
            THEN
                stop := ord( vt_screen^ [pos ] ) <= csp_vt_socf;
            (*ENDIF*) 
            IF  NOT stop
            THEN
                BEGIN
                length := length + 1;
                pos := pos + 1;
                END;
            (*ENDIF*) 
        UNTIL
            stop;
        (*ENDREPEAT*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
i53length := length;
END; (* i53length *)
 
(*------------------------------*) 
 
FUNCTION
      has_inputchar (
            vt_screen : tsp00_ScreenBufAddr;
            vt_att    : tsp00_ScreenBufAddr;
            pos       : integer) : boolean;
 
CONST
      stf = 1;
 
VAR
      i  : integer;
      ft : tin_ls_fieldtype;
 
BEGIN
&ifdef WINDOWS
IF  (i56recursion = 0)
THEN
&   endif
    IF  (vt_screen <> NIL)
        AND (vt_att <> NIL)
    THEN
        BEGIN
        i := pos - 1;
        REPEAT
            i := i + 1;
            IF  ord(vt_screen^ [i] ) > stf
            THEN
                char_to_ft_52 (vt_att^ [ i ] ,ft);
            (*ENDIF*) 
        UNTIL
            (ord(vt_screen^ [i] ) <= stf)
            OR (ls_input IN ft.fieldmode);
        (*ENDREPEAT*) 
        has_inputchar := (ord(vt_screen^ [i] ) > stf)
        END
    ELSE
        has_inputchar := false;
    (*ENDIF*) 
(*ENDIF*) 
END; (* has_inputchar *)
 
(*------------------------------*) 
 
PROCEDURE
      i53getfield (
            row,col    : integer;
            VAR length : integer;
            VAR input  : tin_screenline;
            maxcols    : integer;
            vt_screen  : tsp00_ScreenBufAddr);
 
VAR
      pos : integer;
 
BEGIN
&ifdef WINDOWS
IF  (i56recursion = 0)
THEN
&   endif
    IF  (vt_screen <> NIL)
    THEN
        BEGIN
        pos := (row - 1) * maxcols + col;
        s10mv(SCREEN_CHARS_MXSP00,mxin_screenline,
              @vt_screen^,pos,
              @input,1,length);
        length := s30klen (input,bsp_c1,length);
        END
    ELSE
        length := 0;
    (*ENDIF*) 
(*ENDIF*) 
END; (* i53getfield *)
 
(*=====================================================*)
(*------------------------------*) 
 
PROCEDURE
      fieldtype_to_char (
            ft      : tin_ls_fieldtype;
            VAR att : char);
 
VAR
      n : integer;
      a : tin_ls_fmode;
 
BEGIN
WITH ft DO
    BEGIN
    n := 0;
    FOR a := ls_input TO ls_mixed DO
        BEGIN
        n := 2 * n; (* shift left *)
        IF  a IN fieldmode
        THEN
            n := n + 1;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    END;
(*ENDWITH*) 
n := 2 * n; (* change bit is 0 *)
n := n * 16; (* shift 4 bits left *)
n := n + ft.field_att;
att := chr(n);
END; (* fieldtype_to_char *)
 
(*------------------------------*) 
 
PROCEDURE
      char_to_ft_52 (
            att    : char;
            VAR ft : tin_ls_fieldtype);
 
VAR
      m : integer;
      a : tin_ls_fmode;
 
BEGIN
m := ord(att);
WITH ft DO
    BEGIN
    field_att := m MOD 16; (* lower half is attribute index *)
    fieldmode := [  ] ;
    m := m DIV 16; (* upper half *)
    m := m DIV 2; (* skip changed bit *)
    FOR a := ls_mixed DOWNTO ls_input DO
        BEGIN
        IF  (m MOD 2) = 1
        THEN
            fieldmode := fieldmode + [  a ] ;
        (*ENDIF*) 
        m := m DIV 2
        END;
    (*ENDFOR*) 
    END;
(*ENDWITH*) 
END; (* char_to_ft_52 *)
 
(*------------------------------*) 
 
PROCEDURE
      get_actual_fieldmark (
            screen     : tsp00_ScreenBufAddr;
            attributes : tsp00_ScreenBufAddr;
            pos        : integer;
            length     : integer;
            maxchars   : integer;
            VAR mark   : char);
 
VAR
      found : boolean;
      i     : integer;
 
BEGIN
&ifdef WINDOWS
IF  (i56recursion = 0)
THEN
&   endif
    IF  (screen <> NIL)
        AND (attributes <> NIL)
    THEN
        BEGIN
        i := pos;
        REPEAT
            found := ord(screen^ [i] ) <= csp_vt_socf;
            IF  NOT found
            THEN
                i := i - 1;
            (*ENDIF*) 
        UNTIL
            found OR (i = 0);
        (*ENDREPEAT*) 
        IF  found
        THEN
            BEGIN
            mark := screen^ [ i ] ;
            IF  ord(mark) = csp_vt_socf
            THEN
                mark := chr(csp_vt_soncf);
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            i := 1;
            mark := chr(csp_vt_eof);
            END;
        (*ENDIF*) 
        FOR i := 1 TO length+1 DO
            IF  pos+i-1 > maxchars
            THEN
                mark := chr(csp_vt_eof)
            ELSE
                IF  ord(screen^ [pos+i-1] ) <= csp_vt_socf
                THEN
                    mark := screen^ [pos+i-1] ;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END; (* get_actual_fieldma *)
 
(*------------------------------*) 
 
FUNCTION
      inputfield_changed (
            vt_att    : tsp00_ScreenBufAddr;
            first_pos : integer;
            length    : integer ) : boolean;
 
VAR
      flag    : bit;
      changed : boolean;
      att     : integer;
      i       : integer;
 
BEGIN
changed := false;
&ifdef WINDOWS
IF  (i56recursion = 0)
THEN
&   endif
    IF  (vt_att <> NIL)
    THEN
        BEGIN
        i := first_pos;
        IF  length = 0
        THEN
            length := 1;
        (*ENDIF*) 
        WHILE (NOT changed) AND  (i < first_pos + length) DO
            BEGIN
            att := ord( vt_att^ [i]  );
            (* get lowest bit of upper half *)
            att := att DIV 16;
            flag := att MOD 2;
            changed := changed OR (flag <> 0);
            i := i + 1;
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
inputfield_changed := changed;
END; (* inputfield_changed *)
 
(*------------------------------*) 
 
PROCEDURE
      i53setunchanged (
            row,col,length : integer;
            maxcols        : integer;
            vt_att         : tsp00_ScreenBufAddr);
 
VAR
      pos,i       : integer;
      att, hi, lo : integer;
 
BEGIN
&ifdef WINDOWS
IF  (i56recursion = 0)
THEN
&   endif
    IF  (vt_att <> NIL)
    THEN
        BEGIN
        pos := (row - 1) * maxcols + col - 1;
        FOR i := pos+1 TO pos+length DO
            BEGIN
            att := ord( vt_att^ [i]  );
            (* clear lowest bit of upper half *)
            lo := att MOD 16;
            hi := att DIV 16;
            (* clear lowest bit *)
            hi := (hi DIV 2) * 2;
            att := 16 * hi + lo;
            vt_att^ [i]  := chr( att );
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END; (* i53setunchanged *)
 
(*------------------------------*) 
 
PROCEDURE
      i53attchange (
            sno     : tsp00_Int2;
            win     : tin_ls_window;
            VAR ft  : tin_ls_fieldtype;
            maxcols : integer;
            vt_att  : tsp00_ScreenBufAddr);
 
VAR
      pos        : integer;
      length     : integer;
      row,col    : integer;
      i          : integer;
 
BEGIN
(*fieldtype_to_char(ft,att); !!! *)
&ifdef WINDOWS
IF  (i56recursion = 0)
THEN
&   endif
    IF  (vt_att <> NIL)
    THEN
        BEGIN
        WITH win DO
            BEGIN
            length := last_col - first_col + 1;
            pos := (first_line - 1) * maxcols + first_col;
            IF  length > 0
            THEN
                BEGIN
                i53changelimits(sno, first_line);
                i53changelimits(sno, last_line);
                FOR row := first_line TO last_line DO
                    BEGIN
                    FOR i := 1 TO length DO
                        change_1_attribute(vt_att, pos+i-1, ft);
                    (*ENDFOR*) 
                    pos := pos + maxcols;
                    END;
                (*ENDFOR*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END; (* i53attchange *)
 
(*------------------------------*) 
 
PROCEDURE
      change_1_attribute (
            vt_att : tsp00_ScreenBufAddr;
            pos    : integer;
            new_ft : tin_ls_fieldtype);
 
VAR
      att    : char;
      old_ft : tin_ls_fieldtype;
 
BEGIN
att := vt_att^ [pos] ;
char_to_ft_52(att,old_ft);
IF  i01g^.vt.parms.change_backgr_attr
THEN
    BEGIN
    IF  old_ft.field_att = cin_ls_invisible
    THEN
        new_ft.field_att := cin_ls_invisible;
    (*ENDIF*) 
    END
ELSE
    new_ft.field_att := old_ft.field_att;
(*ENDIF*) 
fieldtype_to_char(new_ft,att);
vt_att^ [pos ] := att;
END; (* change_1_attribute *)
 
(*------------------------------*) 
 
PROCEDURE
      i53changelimits (
            sno   : tsp00_Int2;
            rowno : tsp00_Int2);
 
VAR
      temp : tsp00_Int2;
 
BEGIN
&ifdef WINDOWS
IF  (sno > 1)
THEN
    temp := i01g^.vt.opt.screen2_first_changed
ELSE
&   endif
    temp := i01g^.vt.opt.first_line_changed ;
(*ENDIF*) 
IF  rowno < temp
THEN
    temp := rowno;
&ifdef WINDOWS
(*ENDIF*) 
IF  (sno > 1)
THEN
    i01g^.vt.opt.screen2_first_changed  := temp
ELSE
&   endif
    i01g^.vt.opt.first_line_changed     := temp ;
(*ENDIF*) 
&ifdef WINDOWS
IF  (sno > 1)
THEN
    temp := i01g^.vt.opt.screen2_last_changed
ELSE
&   endif
    temp := i01g^.vt.opt.last_line_changed ;
(*ENDIF*) 
IF  rowno > temp
THEN
    temp := rowno;
&ifdef WINDOWS
(*ENDIF*) 
IF  (sno > 1)
THEN
    i01g^.vt.opt.screen2_last_changed  := temp
ELSE
&   endif
    i01g^.vt.opt.last_line_changed     := temp ;
(*ENDIF*) 
END; (* i53changelimits *)
 
(*------------------------------*) 
 
FUNCTION
      i53tobufpos (
            lno, col : integer;
            maxcols  : integer) : integer;
 
VAR
      pos : integer;
 
BEGIN
pos := (lno - 1) * maxcols + col;
i53tobufpos := pos;
END; (* i53tobufpos *)
 
(*------------------------------*) 
 
PROCEDURE
      i53frombufpos (
            pos     : integer;
            maxcols : integer;
            VAR row : integer;
            VAR col : integer);
 
BEGIN
row := ((pos - 1) DIV maxcols) + 1;
col := ((pos - 1) MOD maxcols) + 1;
END; (* i53frombufpos *)
 
(*------------------------------*) 
 
PROCEDURE
      i53screenaddresses (
            sno          : tsp00_Int2;
            VAR screen   : tsp00_ScreenBufAddr;
            VAR att      : tsp00_ScreenBufAddr;
            VAR maxlines : tsp00_Int2;
            VAR maxcols  : tsp00_Int2);
 
BEGIN
WITH i01g^.vt,desc DO
    IF  ok
    THEN
        BEGIN
&       ifdef WINDOWS
        IF  sno = 1
        THEN
            BEGIN
            screen := content_buf;
            att := attribute_buf;
            maxlines := num_of_lines;
            maxcols := num_of_cols;
            END
        ELSE
            BEGIN
            screen := i56desc2.content_buf;
            att    := i56desc2.attribute_buf;
            maxlines := i56desc2.num_of_lines;
            maxcols  := i56desc2.num_of_cols;
            END;
        (*ENDIF*) 
&       else
        screen := content_buf;
        att := attribute_buf;
        maxlines := num_of_lines;
        maxcols := num_of_cols;
&       endif
        END
    ELSE
        BEGIN
        screen := NIL;
        att := NIL;
        maxlines := 0;
        maxcols := 0;
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i53rareplace_attr (
            VAR in_attr_line  : tin_screenline;
            VAR out_attr_line : tin_screenline;
            attr_line_len     : integer;
            new_att           : tin_ls_attribute_index );
 
VAR
      old_att : integer;
      int_att : integer;
      i       : integer;
 
BEGIN
FOR i := 1 TO  attr_line_len DO
    BEGIN
    int_att   := ord ( in_attr_line[i] );
    old_att   := int_att MOD 16;
    out_attr_line[i] := chr ( int_att - old_att + new_att );
    END;
(*ENDFOR*) 
END; (* change_attr *)
 
(*------------------------------*) 
 
PROCEDURE
      i53check_field_for_multibyte (
            VAR field  : tsp00_MoveObj;
            length     : integer);
 
VAR
      i       : integer;
      charlen : integer;
      stop    : boolean;
 
BEGIN
IF  length > 0
THEN
    BEGIN
    i := 0;
    stop := false;
    WITH i01g^, multibyte DO
        BEGIN
        WHILE (i < length) AND NOT stop DO
            BEGIN
            IF  length - i >= csp8_ranges
            THEN
                charlen := csp8_ranges
            ELSE
                charlen := length - i;
            (*ENDIF*) 
            CASE (s80uni_chartype( @(field [ i + 1 ]), charlen, dblang_idx)) OF
                uni_is_singlebyte:
                    i := succ( i );
                uni_is_multibyte:
                    i := i + charlen
                OTHERWISE:
                    stop := true;
                END;
            (*ENDCASE*) 
            END;
        (*ENDWHILE*) 
        WHILE (length > i) DO
            BEGIN
            field [ i + 1 ] := bsp_c1;
            i := i + 1;
            END;
        (*ENDWHILE*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
