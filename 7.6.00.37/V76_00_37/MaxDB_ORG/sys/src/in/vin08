.CM  SCRIPT , Version - 1.1 , last edited by D.Dittmar
.pa
.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VIN08$
.tt 2 $$$
.TT 3 $$inscreen-setparms$2000-01-07$
***********************************************************
.nf
 
 .nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : inscreen-setparms
=========
.sp
Purpose : I/O procedures for SET
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              i08replacesetparms (
                    VAR show    : tin_show_set;
                    VAR input   : tin_ls_input_field;
                    VAR csr_pos : tin_ls_position;
                    VAR msg_no  : integer;
                    VAR err_no  : integer;
                    read_screen : boolean);
 
        PROCEDURE
              i08altersetparm (
                    setid   : tsp00_Int2;
                    VAR buf : tin_screenline;
                    len     : tsp00_Int2;
                    VAR rc  : tsp00_Int2 );
 
        PROCEDURE
              i08formatalter (
                    VAR datebuf : tin_screenline;
                    datelen     : tsp00_Int2;
                    VAR timebuf : tin_screenline;
                    timelen     : tsp00_Int2;
                    VAR rc      : tsp00_Int2 );
 
        PROCEDURE
              i08restoresetparms (
                    VAR save_set : tin_set_parms_record);
 
        FUNCTION
              in0830 : tsp00_Int4;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              global_variable : VIN01;
 
        VAR
              i01g : tin_global_in_vars;
 
      ------------------------------ 
 
        FROM
              messages : VIN03 ;
 
        PROCEDURE
              i03check_mlanguage (
                    language : tin_language_id;
                    VAR ok   : boolean);
 
      ------------------------------ 
 
        FROM
              printersets : VIN06;
 
        PROCEDURE
              i06newprint (
                    VAR print_name : tsp00_Name;
                    VAR ok         : boolean );
 
        PROCEDURE
              i06newattr (
                    VAR attr_name : tsp00_Name;
                    VAR ok        : boolean );
 
      ------------------------------ 
 
        FROM
              general-setprocedures : VIN09;
 
        PROCEDURE
              i09mdblang (
                    i01g : tin_global_in_vars);
 
        PROCEDURE
              i09mdbformat (
                    i01g : tin_global_in_vars);
 
        PROCEDURE
              i09onoff (
                    i01g        : tin_global_in_vars;
                    VAR input   : tin_ls_input_field;
                    VAR on_off  : boolean;
                    VAR csr_pos : tin_ls_position;
                    VAR msg_no  : integer);
 
        PROCEDURE
              i09upper_input (
                    VAR input : tin_ls_input_field);
 
        FUNCTION
              i09minmaxverified (
                    VAR input   : tin_ls_input_field;
                    minval      : integer;
                    maxval      : integer;
                    original    : integer;
                    VAR csr_pos : tin_ls_position;
                    VAR msg_no  : integer) : tsp00_Int2;
 
        PROCEDURE
              i09numeric_value (
                    VAR input   : tin_ls_input_field;
                    VAR val     : tsp00_Int4;
                    VAR csr_pos : tin_ls_position;
                    VAR msg_no  : integer);
 
      ------------------------------ 
 
        FROM
              Output of Date and Time : VIN41;
 
        PROCEDURE
              i41dparse (
                    VAR mask   : tin_date_mask;
                    VAR error  : integer;
                    VAR errpos : tin_natural);
 
        PROCEDURE
              i41tparse (
                    VAR mask   : tin_date_mask;
                    VAR error  : integer;
                    VAR errpos : tin_natural);
 
        PROCEDURE
              i41tsparse (
                    VAR mask   : tin_date_mask;
                    VAR error  : integer;
                    VAR errpos : tin_natural);
 
      ------------------------------ 
 
        FROM
              logical_screen : VIN50;
 
        PROCEDURE
              i50getfield (
                    VAR vt_input    : tin_ls_input_field;
                    VAR field_found : boolean);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-60: VSP60;
 
        FUNCTION
              s60tocap (
                    c : char ) : char;
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              m90buf2;
 
              tsp00_Buf         tin_screenline
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1985-06-06
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-01-07
.sp
***********************************************************
.sp
.cp 20
.fo
.oc _/1
Specification:
 
 
.CM *-END-* specification -------------------------------
.sp 2.fo
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
(*------------------------------*) 
 
FUNCTION
      in0830 : tsp00_Int4;
 
BEGIN
(* linkcheck function *)
in0830 := 219020723;
END;
 
(*------------------------------*) 
 
PROCEDURE
      i08replacesetparms (
            VAR show    : tin_show_set;
            VAR input   : tin_ls_input_field;
            VAR csr_pos : tin_ls_position;
            VAR msg_no  : integer;
            VAR err_no  : integer;
            read_screen : boolean);
 
VAR
      j            : integer;
      dcnt         : integer;
      val          : tsp00_Int4;
      save_version : tsp00_C4;
      len          : integer;
      quote_found  : boolean;
      ok           : boolean;
      date_pos     : tin_ls_position;
 
LABEL
      999;
 
BEGIN
dcnt := 0;
date_pos := csr_pos;
WITH i01g^.set_parms DO
    BEGIN
    IF  to_be_read (show, cin_set_language, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_lang (input, language, csr_pos, msg_no);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_null, input, read_screen, msg_no,
        quote_found)
    THEN
        BEGIN
        IF  quote_found
        THEN
            BEGIN
            msg_no := cin_setmsg_wrong_quote;
            csr_pos := input.fld_pos;
            END
        ELSE
            BEGIN
            FOR j := 1 TO input.len DO
                null  [j]  := input.buf  [j] ;
            (*ENDFOR*) 
            FOR j := input.len + 1 TO mxin_null_string DO
                null  [j]  := ' ';
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_boolean, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_bool (input, bool_presentation, csr_pos, msg_no);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_decimal, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_dec (input, decimal, csr_pos, msg_no);
    (*ENDIF*) 
    IF  msg_no <> cin_setmsg_go_ahead
    THEN
        goto 999;
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_date, input, read_screen, err_no,
        quote_found)
    THEN
        BEGIN
        repl_date_or_time (input, csr_pos, dcnt, msg_no, err_no,
              cin_set_date);
        date_pos := input.fld_pos;
        END;
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_time, input, read_screen, err_no,
        quote_found)
    THEN
        BEGIN
        repl_date_or_time (input, csr_pos, dcnt, msg_no, err_no,
              cin_set_time);
        date_pos := input.fld_pos;
        END;
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_timestamp, input, read_screen, err_no,
        quote_found)
    THEN
        BEGIN
        repl_date_or_time (input, csr_pos, dcnt, msg_no, err_no,
              cin_set_timestamp);
        date_pos := input.fld_pos;
        END;
    (*ENDIF*) 
    IF  err_no = cin_setmsg_go_ahead
    THEN
        BEGIN
        check_free_mixture (ok);
        IF  NOT ok
        THEN
            BEGIN
            msg_no := cin_setmsg_date_time;
            csr_pos := date_pos;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (msg_no <> cin_setmsg_go_ahead) OR
        (err_no <> cin_setmsg_go_ahead)
    THEN
        goto 999;
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_sep, input, read_screen, msg_no,
        quote_found)
    THEN
        BEGIN
        len := l_sep;
        repl_sep (input, sep, len, csr_pos, msg_no);
        l_sep := len;
        END;
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_printformat, input, read_screen,
        msg_no, quote_found)
    THEN
        repl_printformat (input, quote_found, act_print_name,
              csr_pos, msg_no);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_copy, input, read_screen, msg_no,
        quote_found)
    THEN
        copy := i09minmaxverified (input, 1, mxin_copy, copy, csr_pos,
              msg_no);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_syseditor, input, read_screen, msg_no,
        quote_found)
    THEN
        BEGIN
        IF  quote_found
        THEN
            BEGIN
            msg_no := cin_setmsg_wrong_quote;
            csr_pos := input.fld_pos;
            END
        ELSE
            BEGIN
            j := 1;
            syseditor := bsp_c40;
            WHILE  (j <= input.len) AND (j <= 40) DO
                BEGIN
                syseditor  [j]  := input.buf  [j] ;
                j := j + 1;
                END;
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  msg_no <> cin_setmsg_go_ahead
    THEN
        goto 999;
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_lopres, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_presentation (input, quote_found, lopres, csr_pos, msg_no);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_loadprot, input, read_screen, msg_no,
        quote_found)
    THEN
        BEGIN
        IF  quote_found
        THEN
            BEGIN
            msg_no := cin_setmsg_wrong_quote;
            csr_pos := input.fld_pos;
            END
        ELSE
            BEGIN
            FOR j := 1 TO input.len DO
                loadprot  [j]  := input.buf  [j] ;
            (*ENDFOR*) 
            FOR j := succ(input.len) TO sizeof (loadprot) DO
                loadprot [j] := ' ';
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_transize, input, read_screen, msg_no,
        quote_found)
    THEN
        BEGIN
        i09numeric_value (input, val, csr_pos, msg_no);
        IF  val <= 0
        THEN
            BEGIN
            msg_no := cin_setmsg_positive_number;
            csr_pos := input.fld_pos;
            END
        ELSE
            transize := val;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  msg_no <> cin_setmsg_go_ahead
    THEN
        goto 999;
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_yepres, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_presentation (input, quote_found, yepres, csr_pos, msg_no);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_lt_pres, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_pres (input, quote_found, lt_pres, csr_pos, msg_no,
              cin_set_lt_pres);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_le_pres, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_pres (input, quote_found, le_pres, csr_pos, msg_no,
              cin_set_le_pres);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_gt_pres, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_pres (input, quote_found, gt_pres, csr_pos, msg_no,
              cin_set_gt_pres);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_ge_pres, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_pres (input, quote_found, ge_pres, csr_pos, msg_no,
              cin_set_ge_pres);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_eq_pres, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_pres (input, quote_found, eq_pres, csr_pos, msg_no,
              cin_set_eq_pres);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_ne_pres, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_pres (input, quote_found, ne_pres, csr_pos, msg_no,
              cin_set_ne_pres);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_not_pres, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_pres (input, quote_found, not_pres, csr_pos, msg_no,
              cin_set_not_pres);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_in_pres, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_pres (input, quote_found, in_pres, csr_pos, msg_no,
              cin_set_in_pres);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_betw_pres, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_pres (input, quote_found, betw_pres, csr_pos, msg_no,
              cin_set_betw_pres);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_sounds_pres, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_pres (input, quote_found, sounds_pres, csr_pos, msg_no,
              cin_set_sounds_pres);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_delimiter, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_char (input, false, delimiter, csr_pos, msg_no);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_fillchar, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_char (input, true, fillchar, csr_pos, msg_no);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_graficchar, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_char (input, true, graficchar, csr_pos, msg_no);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_ignore_case, input, read_screen, msg_no,
        quote_found)
    THEN
        i09onoff (i01g, input, ignore_case, csr_pos, msg_no);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_actualize_menu, input,
        read_screen, msg_no, quote_found)
    THEN
        i09onoff (i01g, input, actualize_menu, csr_pos, msg_no);
    (*ENDIF*) 
    IF  msg_no <> cin_setmsg_go_ahead
    THEN
        goto 999;
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_qupres, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_presentation (input, quote_found, qupres, csr_pos, msg_no);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_queryprot, input, read_screen, msg_no,
        quote_found)
    THEN
        BEGIN
        IF  quote_found
        THEN
            msg_no := cin_setmsg_wrong_quote
        ELSE
            BEGIN
            FOR j := 1 TO input.len DO
                queryprot  [j]  := input.buf  [j] ;
            (*ENDFOR*) 
            FOR j := succ(input.len) TO sizeof (queryprot) DO
                queryprot [j] := ' ';
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_autoprot, input, read_screen, msg_no,
        quote_found)
    THEN
        i09onoff (i01g, input, autoprot, csr_pos, msg_no);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_sqltime, input, read_screen, msg_no,
        quote_found)
    THEN
        i09onoff (i01g, input, sqltime, csr_pos, msg_no);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_history, input, read_screen, msg_no,
        quote_found)
    THEN
        i09onoff (i01g, input, history, csr_pos, msg_no);
    (*ENDIF*) 
    IF  msg_no <> cin_setmsg_go_ahead
    THEN
        goto 999;
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_plpres, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_presentation (input, quote_found, plpres, csr_pos, msg_no);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_controlpres, input, read_screen, msg_no,
        quote_found)
    THEN
        repl_presentation (input, quote_found, plpres, csr_pos, msg_no);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_plprot, input, read_screen, msg_no,
        quote_found)
    THEN
        BEGIN
        IF  quote_found
        THEN
            msg_no := cin_setmsg_wrong_quote
        ELSE
            BEGIN
            FOR j := 1 TO input.len DO
                plprot  [j]  := input.buf  [j] ;
            (*ENDFOR*) 
            FOR j := succ(input.len) TO sizeof (plprot) DO
                plprot [j] := ' ';
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_pretty, input, read_screen, msg_no,
        quote_found)
    THEN
        i09onoff (i01g, input, pretty, csr_pos, msg_no);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_nesting, input, read_screen, msg_no,
        quote_found)
    THEN
        nesting := i09minmaxverified (input, 1, 99, nesting,
              csr_pos, msg_no);
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_code_area, input, read_screen, msg_no,
        quote_found)
    THEN
        BEGIN
        i09numeric_value (input, val, csr_pos, msg_no);
        IF  val <= 0
        THEN
            BEGIN
            msg_no := cin_setmsg_positive_number;
            csr_pos := input.fld_pos;
            END
        ELSE
            code_area := val;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_value_area, input, read_screen, msg_no,
        quote_found)
    THEN
        BEGIN
        i09numeric_value (input, val, csr_pos, msg_no);
        IF  val <= 0
        THEN
            BEGIN
            msg_no := cin_setmsg_positive_number;
            csr_pos := input.fld_pos;
            END
        ELSE
            value_area := val;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_dia_version,
        input, read_screen, msg_no, quote_found)
    THEN
        BEGIN
        IF  quote_found
        THEN
            msg_no := cin_setmsg_wrong_quote
        ELSE
            BEGIN
            save_version := dia_version;
            dia_version := '    ';
            j := 1;
            WHILE  (j <= input.len) AND (j <= 4) DO
                BEGIN
                dia_version  [j]  := s60tocap (input.buf  [j]) ;
                j := j + 1;
                END;
            (*ENDWHILE*) 
            IF  ( dia_version <> cin_k_hist ) AND
                ( dia_version <> cin_k_test ) AND
                ( dia_version <> cin_k_prod ) AND
                ( dia_version <> cin_k_work ) AND
                ( dia_version <> cin_k_all  )
            THEN
                BEGIN
                dia_version := save_version;
                msg_no := cin_setmsg_invalid_input;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  msg_no <> cin_setmsg_go_ahead
        THEN
            csr_pos := input.fld_pos;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  to_be_read (show, cin_set_dia_target_langs,
        input, read_screen, msg_no, quote_found)
    THEN
        BEGIN
        IF  quote_found
        THEN
            msg_no := cin_setmsg_wrong_quote
        ELSE
            BEGIN
            j := 1;
            dia_target_langs := bsp_c24;
            WHILE  (j <= input.len) AND (j <= 24) DO
                BEGIN
                dia_target_langs  [j]  := input.buf  [j] ;
                j := j + 1;
                END;
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        IF  msg_no <> cin_setmsg_go_ahead
        THEN
            csr_pos := input.fld_pos;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  msg_no <> cin_setmsg_go_ahead
    THEN
        goto 999;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
999 :
END; (* i08replacesetparms *)
 
(*------------------------------*) 
 
PROCEDURE
      i08altersetparm (
            setid   : tsp00_Int2;
            VAR buf : tin_screenline;
            len     : tsp00_Int2;
            VAR rc  : tsp00_Int2 );
 
VAR
      input   : tin_ls_input_field;
      csr_pos : tin_ls_position;
      msg_no  : integer;
      err_no  : integer;
      show    : tin_show_set;
      ok      : boolean;
 
BEGIN
IF  ( setid >= cin_set_language ) AND ( setid <= mxin_setparms )
THEN
    WITH i01g^.set_parms DO
        BEGIN
        input.buf := buf;
        input.len := len;
        input.fld_pos.scol := 1;
        input.fld_pos.sline := 1;
        csr_pos := input.fld_pos;
        msg_no := cin_setmsg_go_ahead;
        err_no := cin_setmsg_go_ahead;
        show := [ setid] ;
        i08replacesetparms (show, input, csr_pos, msg_no, err_no, false);
        IF  ( err_no <> cin_setmsg_go_ahead )
        THEN
            msg_no := err_no;
        (*ENDIF*) 
        IF  ( msg_no = cin_setmsg_go_ahead )
        THEN
            rc := 0
        ELSE
            rc := msg_no;
        (*ENDIF*) 
        IF  rc = 0
        THEN
            CASE setid OF
                cin_set_language :
                    i09mdblang (i01g);
                cin_set_date, cin_set_time, cin_set_timestamp:
                    i09mdbformat (i01g);
                cin_set_plpres, cin_set_controlpres:
                    i06newattr ( plpres, ok );
                OTHERWISE
                    (* replace done, additional action not required *)
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        END
    (*ENDWITH*) 
ELSE
    rc := cin_setmsg_invalid_input;
(*ENDIF*) 
END; (* i08altersetparm *)
 
(*------------------------------*) 
 
PROCEDURE
      i08formatalter (
            VAR datebuf : tin_screenline;
            datelen     : tsp00_Int2;
            VAR timebuf : tin_screenline;
            timelen     : tsp00_Int2;
            VAR rc      : tsp00_Int2 );
 
VAR
      input   : tin_ls_input_field;
      csr_pos : tin_ls_position;
      msg_no  : integer;
      err_no  : integer;
      dcnt    : integer;
      ok      : boolean;
 
BEGIN
dcnt := 1; (* update timestamp implicitly *)
WITH i01g^.set_parms DO
    BEGIN
    input.buf := datebuf;
    input.len := datelen;
    input.fld_pos.scol := 1;
    msg_no := cin_setmsg_go_ahead;
    err_no := cin_setmsg_go_ahead;
    repl_date_or_time ( input, csr_pos, dcnt, msg_no, err_no,
          cin_set_date);
    IF  ( err_no = cin_setmsg_go_ahead )
    THEN
        BEGIN
        input.buf := timebuf;
        input.len := timelen;
        input.fld_pos.scol := 1;
        repl_date_or_time ( input, csr_pos, dcnt, msg_no, err_no,
              cin_set_time );
        END;
    (*ENDIF*) 
    IF  ( msg_no = cin_setmsg_go_ahead ) AND
        ( err_no = cin_setmsg_go_ahead )
    THEN
        BEGIN
        check_free_mixture (ok);
        IF  NOT ok
        THEN
            msg_no := cin_setmsg_date_time;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  ( err_no <> cin_setmsg_go_ahead )
    THEN
        rc := err_no
    ELSE
        IF  ( msg_no <> cin_setmsg_go_ahead )
        THEN
            rc := msg_no
        ELSE
            rc := 0;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  rc = 0
    THEN
        i09mdbformat (i01g);
    (*ENDIF*) 
    END
(*ENDWITH*) 
END; (* i08formatalter *)
 
(*------------------------------*) 
 
PROCEDURE
      i08restoresetparms (
            VAR save_set : tin_set_parms_record);
 
VAR
      ok            : boolean;
      change_lang   : boolean;
      change_format : boolean;
      change_print  : boolean;
      change_plpres : boolean;
      change_lopres : boolean;
      change_yepres : boolean;
      change_qupres : boolean;
      running       : tsp4_component;
 
BEGIN
running := i01g^.i20.comp_enum;
WITH i01g^.set_parms DO
    BEGIN
    change_lang := language <> save_set.language;
    change_format := ((time.msk <> save_set.time.msk) OR
          (date.msk <> save_set.date.msk));
    change_print := act_print_name <> save_set.act_print_name;
    (* Change of presentation is also necessary if an attribute
          (* has changed. The whole presentation before and after
          (* have to be compared. Instaed of that for SQL-PL the old
          (* presentation is always restored. B.J. 5.5.95
          *)
    change_plpres := (*( plpres <> save_set.plpres ) AND*)
          ( running = sp4co_sql_dialog );
    change_lopres := ( lopres <> save_set.lopres ) AND
          ( running = sp4co_sql_load );
    change_yepres := ( yepres <> save_set.yepres ) AND
          ( running = sp4co_sql_easy );
    change_qupres := ( qupres <> save_set.qupres ) AND
          ( running = sp4co_sql_query );
    i01g^.set_parms := save_set;
    IF  change_lang
    THEN
        i09mdblang (i01g);
    (*ENDIF*) 
    IF  change_format
    THEN
        i09mdbformat (i01g);
    (*ENDIF*) 
    IF  change_print
    THEN
        i06newprint (act_print_name, ok);
    (*ENDIF*) 
    IF  change_plpres
    THEN
        i06newattr (plpres, ok);
    (*ENDIF*) 
    IF  change_lopres
    THEN
        i06newattr (lopres, ok);
    (*ENDIF*) 
    IF  change_yepres
    THEN
        i06newattr (yepres, ok);
    (*ENDIF*) 
    IF  change_qupres
    THEN
        i06newattr (qupres, ok);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      to_be_read (
            VAR show        : tin_show_set;
            parm            : integer;
            VAR input       : tin_ls_input_field;
            read_field      : boolean;
            msg_no          : integer;
            VAR quote_found : boolean ) : boolean;
 
VAR
      i           : integer;
      field_found : boolean;
 
BEGIN
field_found := true;
quote_found := false;
IF  (parm in show) AND
    ((msg_no = cin_setmsg_go_ahead) OR (msg_no = cin_setmsg_date_time))
THEN
    BEGIN
    IF  read_field
    THEN
        BEGIN
        i50getfield (input, field_found);
        field_found := field_found AND input.changed;
        END;
    (*ENDIF*) 
    IF  field_found
    THEN
        BEGIN
        FOR i := 1 TO input.len DO
            IF  input.buf [i] = ''''
            THEN
                quote_found := true;
            (*ENDIF*) 
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    to_be_read := field_found;
    END
ELSE
    to_be_read := false;
(*ENDIF*) 
END; (* to_be_read *)
 
(*------------------------------*) 
 
PROCEDURE
      repl_lang (
            VAR input    : tin_ls_input_field;
            VAR language : tin_language_id;
            VAR csr_pos  : tin_ls_position;
            VAR msg_no   : integer);
 
VAR
      i        : integer;
      old_lang : tin_language_id;
      ok       : boolean;
 
BEGIN
IF  input.len > 0
THEN
    BEGIN
    old_lang := language;
    i09upper_input (input);
    FOR i := 1 TO input.len DO
        language  [i]  := input.buf  [i] ;
    (*ENDFOR*) 
    FOR i := input.len + 1 TO 3 DO
        language  [i]  := ' ';
    (*ENDFOR*) 
    i03check_mlanguage (language, ok);
    IF  NOT ok
    THEN
        BEGIN
        language := old_lang;
        msg_no := cin_setmsg_lang_not_supported;
        csr_pos := input.fld_pos;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END; (* repl_lang *)
 
(*------------------------------*) 
 
PROCEDURE
      repl_presentation (
            VAR input     : tin_ls_input_field;
            quote_found   : boolean;
            VAR pres_name : tsp00_Name;
            VAR csr_pos   : tin_ls_position;
            VAR msg_no    : integer);
 
VAR
      i    : integer;
      ok   : boolean;
      attr : tsp00_Name;
 
BEGIN
IF  quote_found
THEN
    BEGIN
    msg_no := cin_setmsg_wrong_quote;
    csr_pos := input.fld_pos;
    END
ELSE
    IF  input.len > 0
    THEN
        BEGIN
        attr := bsp_c18;
        FOR i := 1 TO mxsp_name DO
            attr  [i]  := input.buf  [i] ;
        (*ENDFOR*) 
        FOR i := input.len + 1 TO mxsp_name DO
            attr [i]  := ' ';
        (*ENDFOR*) 
        IF  attr <> pres_name
        THEN
            BEGIN
            i06newattr (attr, ok);
            IF  ok
            THEN
                pres_name := attr
            ELSE
                BEGIN
                msg_no  := cin_setmsg_presentation;
                csr_pos := input.fld_pos;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END; (* repl_presentation *)
 
(*------------------------------*) 
 
PROCEDURE
      repl_printformat (
            VAR input          : tin_ls_input_field;
            quote_found        : boolean;
            VAR act_print_name : tsp00_Name;
            VAR csr_pos        : tin_ls_position;
            VAR msg_no         : integer);
 
VAR
      i    : integer;
      ok   : boolean;
      form : tsp00_Name;
 
BEGIN
IF  quote_found
THEN
    BEGIN
    msg_no := cin_setmsg_wrong_quote;
    csr_pos := input.fld_pos;
    END
ELSE
    IF  input.len > 0
    THEN
        BEGIN
        form := bsp_c18;
        FOR i := 1 TO mxsp_name DO
            form  [i]  := input.buf  [i] ;
        (*ENDFOR*) 
        FOR i := input.len + 1 TO mxsp_name DO
            form [i]  := ' ';
        (*ENDFOR*) 
        IF  form <> act_print_name
        THEN
            BEGIN
            i06newprint (form, ok);
            IF  ok
            THEN
                act_print_name := form
            ELSE
                BEGIN
                msg_no  := cin_setmsg_printformat;
                csr_pos := input.fld_pos;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END; (* repl_printformat *)
 
(*------------------------------*) 
 
PROCEDURE
      repl_sep (
            VAR input   : tin_ls_input_field;
            VAR sep     : tin_sep_string;
            VAR length  : integer;
            VAR csr_pos : tin_ls_position;
            VAR msg_no  : integer );
 
VAR
      i, j        : integer;
      s           : tin_sep_string;
      endchar     : char;
      quote_found : boolean;
 
BEGIN
endchar := ' ';
quote_found := false;
SAPDB_PascalForcedFill (mxin_sep_string, @s, 1, mxin_sep_string, ' ');
WITH input DO
    BEGIN
    i := 1;
    WHILE (i <= len) AND (buf  [i]  = ' ') DO
        i := i + 1;
    (*ENDWHILE*) 
    IF  buf [i] = ''''
    THEN
        BEGIN
        endchar := '''';
        quote_found := true;
        i := i + 1;
        END;
    (*ENDIF*) 
    j := 0;
    WHILE (buf [i] <> endchar) AND (i <= len) AND
          (j < mxin_sep_string) AND (buf [i] <> '''') DO
        BEGIN
        j := j + 1;
        IF  quote_found
        THEN
            s [j] := buf [i]
        ELSE
            s [j] := s60tocap (buf [i]);
        (*ENDIF*) 
        i := i + 1;
        END;
    (*ENDWHILE*) 
    IF  (quote_found AND (buf [i] <> endchar)) OR
        (NOT quote_found AND (buf [i] = ''''))
    THEN
        BEGIN
        msg_no := cin_setmsg_wrong_quote;
        csr_pos := input.fld_pos;
        END
    ELSE
        BEGIN
        sep := s;
        length := j;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* repl_sep *)
 
(*------------------------------*) 
 
PROCEDURE
      repl_dec (
            VAR input   : tin_ls_input_field;
            VAR decimal : tsp_decimal_presentation;
            VAR csr_pos : tin_ls_position;
            VAR msg_no  : integer);
 
VAR
      thoustoken     : char;
      zero_token     : char;
      thoustoken_set : SET OF char;
      zeropoint_set  : SET OF char;
 
BEGIN
thoustoken_set := [  ' ', '.', ',', cin_no_thousand_groups ] ;
zeropoint_set := [  '.', ',' ] ;
WITH decimal DO
    BEGIN
    IF  input.len > 0
    THEN
        BEGIN
        IF  input.buf  [2]  = '/'
        THEN
            thoustoken:= cin_no_thousand_groups
        ELSE
            thoustoken := input.buf  [2] ;
        (*ENDIF*) 
        IF  input.buf  [4]  <> '/'
        THEN
            zero_token := input.buf  [4]
        ELSE
            zero_token := input.buf  [3] ;
        (*ENDIF*) 
        IF  (thoustoken = zero_token) OR
            NOT (thoustoken in thoustoken_set) OR
            NOT (zero_token in zeropoint_set)
        THEN
            BEGIN
            msg_no := cin_setmsg_formats_are;
            csr_pos := input.fld_pos;
            END
        ELSE
            BEGIN
            thousand_token := thoustoken;
            zero_point := zero_token;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* repl_dec *)
 
(*------------------------------*) 
 
PROCEDURE
      repl_bool (
            VAR input     : tin_ls_input_field;
            VAR curr_bool : tin_bool_presentation;
            VAR csr_pos   : tin_ls_position;
            VAR msg_no    : integer);
 
VAR
      i, j     :  integer;
      savebool :  tin_bool_presentation;
 
BEGIN
WITH curr_bool DO
    BEGIN
    IF  input.len > 0
    THEN
        BEGIN
        savebool := curr_bool;
        i := 1;
        truestr := bsp_c10;
        WHILE (i <= input.len) AND (i <= mxin_bool_string)
              AND (input.buf [i] <> '/') DO
            BEGIN
            truestr [i] := input.buf  [i];
            i := i + 1;
            END;
        (*ENDWHILE*) 
        IF  input.buf [i] = '/'
        THEN
            BEGIN
            j := 1;
            i := i + 1;
            falsestr := bsp_c10;
            WHILE (i <= input.len) AND (j <= mxin_bool_string) DO
                BEGIN
                falsestr [j] := input.buf  [i];
                j := j + 1;
                i := i + 1;
                END;
            (*ENDWHILE*) 
            END
        ELSE
            BEGIN
            curr_bool := savebool;
            msg_no := cin_setmsg_invalid_input;
            csr_pos := input.fld_pos;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* repl_bool *)
 
(*------------------------------*) 
 
PROCEDURE
      repl_pres (
            VAR input   : tin_ls_input_field;
            quote_found : boolean;
            VAR pres    : tsp00_C40;
            VAR csr_pos : tin_ls_position;
            VAR msg_no  : integer;
            i           : integer);
 
VAR
      j : integer;
      k : integer;
 
BEGIN
IF  quote_found
THEN
    BEGIN
    msg_no := cin_setmsg_wrong_quote;
    csr_pos := input.fld_pos;
    END
ELSE
    WITH input DO
        BEGIN
        pres := bsp_c40;
        k := 0;
        FOR j := 1 TO input.len DO
            pres [j] := input.buf  [j] ;
        (*ENDFOR*) 
        FOR j := 1 TO 40 DO
            IF  pres  [j]  IN [  '&', '%'  ]
            THEN
                k := k + 1;
            (*ENDIF*) 
        (*ENDFOR*) 
        IF  (i in [ cin_set_lt_pres..cin_set_not_pres, cin_set_sounds_pres] )
        THEN
            CASE k OF
                0 :
                    msg_no := cin_setmsg_missing_ampersand;
                1 :
                    ;
                OTHERWISE:
                    msg_no := cin_setmsg_too_many_ampersands;
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        IF  (i in [ cin_set_in_pres, cin_set_betw_pres] )
        THEN
            CASE k OF
                0 :
                    msg_no := cin_setmsg_missing_ampersand;
                1 :
                    msg_no := cin_setmsg_missing_ampersand;
                2 :
                    ;
                OTHERWISE:
                    msg_no := cin_setmsg_too_many_ampersands;
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        IF  (msg_no = cin_setmsg_missing_ampersand) OR
            (msg_no = cin_setmsg_too_many_ampersands)
        THEN
            csr_pos := input.fld_pos;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END; (* repl_pres *)
 
(*------------------------------*) 
 
PROCEDURE
      repl_date_or_time (
            VAR input   : tin_ls_input_field;
            VAR csr_pos : tin_ls_position;
            VAR dcnt    : integer;
            VAR msg_no  : integer;
            VAR err_no  : integer;
            which_one   : integer);
 
VAR
      error        : integer;
      errpos       : tin_natural;
      dm_type      : tin_dmtype;
 
BEGIN
dcnt := dcnt + 1;
IF  (dcnt = 3) AND (msg_no = cin_setmsg_date_time)
THEN
    msg_no := cin_setmsg_go_ahead;
(*ENDIF*) 
error := 0;
IF  input.len > 0
THEN
    WITH i01g^.set_parms DO
        CASE which_one OF
            cin_set_date :
                BEGIN
                in081_read_mask (input, date);
                i41dparse (date, error, errpos);
                END;
            cin_set_time :
                BEGIN
                in081_read_mask (input, time);
                i41tparse (time, error, errpos);
                END;
            OTHERWISE
                BEGIN
                in081_read_mask (input, timestamp);
                i41tsparse (timestamp, error, errpos);
                END;
            END;
        (*ENDCASE*) 
    (*ENDWITH*) 
(*ENDIF*) 
IF  (input.len > 0) AND (error = 0)
THEN
    WITH i01g^.set_parms DO
        CASE which_one OF
            cin_set_date :
                BEGIN
                dm_type := date.dm_type;
                IF  time.dm_type <> dm_type
                THEN
                    BEGIN
                    in081_upd_mask (time, dm_type);
                    i41tparse (time, error, errpos);
                    error := cin_setmsg_date_time;
                    END
                ELSE
                    IF  time.dm_type = dm_free
                    THEN
                        i41tparse (time, error, errpos);
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  timestamp.dm_type <> dm_type
                THEN
                    BEGIN
                    in081_upd_mask (timestamp, dm_type);
                    i41tsparse (timestamp, error, errpos);
                    error := cin_setmsg_date_time;
                    END
                ELSE
                    IF  (timestamp.dm_type = dm_free) AND (error = 0)
                    THEN
                        i41tsparse (timestamp, error, errpos);
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            cin_set_time :
                BEGIN
                dm_type := time.dm_type;
                IF  date.dm_type <> dm_type
                THEN
                    BEGIN
                    in081_upd_mask (date, dm_type);
                    i41dparse (date, error, errpos);
                    error := cin_setmsg_date_time;
                    END
                ELSE
                    IF  date.dm_type = dm_free
                    THEN
                        i41dparse (date, error, errpos);
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  timestamp.dm_type <> dm_type
                THEN
                    BEGIN
                    in081_upd_mask (timestamp, dm_type);
                    i41tsparse (timestamp, error, errpos);
                    error := cin_setmsg_date_time;
                    END
                ELSE
                    IF  (timestamp.dm_type = dm_free) AND (error = 0)
                    THEN
                        i41tsparse (timestamp, error, errpos);
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            OTHERWISE
                BEGIN
                dm_type := timestamp.dm_type;
                IF  date.dm_type <> dm_type
                THEN
                    BEGIN
                    in081_upd_mask (date, dm_type);
                    i41dparse (date, error, errpos);
                    error := cin_setmsg_date_time;
                    END
                ELSE
                    IF  date.dm_type = dm_free
                    THEN
                        i41dparse (date, error, errpos);
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  time.dm_type <> dm_type
                THEN
                    BEGIN
                    in081_upd_mask (time, dm_type);
                    i41tparse (time, error, errpos);
                    error := cin_setmsg_date_time;
                    END
                ELSE
                    IF  (time.dm_type = dm_free) AND (error = 0)
                    THEN
                        i41tparse (time, error, errpos);
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            END;
        (*ENDCASE*) 
    (*ENDWITH*) 
(*ENDIF*) 
IF  error <> 0
THEN
    BEGIN
    IF  error = cin_setmsg_date_time
    THEN
        msg_no := error
    ELSE
        err_no := error;
    (*ENDIF*) 
    csr_pos := input.fld_pos;
    IF  error = cin_setmsg_date_time
    THEN
        errpos := 1;
    (*ENDIF*) 
    WITH csr_pos DO
        scol := scol + errpos - 1;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END; (* repl_date_or_time *)
 
(*------------------------------*) 
 
PROCEDURE
      check_free_mixture (
            VAR ok : boolean);
 
VAR
      error        : integer;
      errpos       : tin_natural;
      free_mixture : boolean;
 
BEGIN
free_mixture := false;
WITH i01g^.set_parms DO
    IF  date.dm_type = dm_free
    THEN
        BEGIN
        IF  time.dm_type <> dm_free
        THEN
            free_mixture := true
        ELSE
            IF  timestamp.dm_type <> dm_free
            THEN
                free_mixture := true;
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        IF  (time.dm_type = dm_free) OR (timestamp.dm_type = dm_free)
        THEN
            free_mixture := true;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
IF  free_mixture
THEN
    WITH i01g^.set_parms DO
        BEGIN
        in081_upd_mask (date, dm_int);
        i41dparse (date, error, errpos);
        in081_upd_mask (time, dm_int);
        i41tparse (time, error, errpos);
        in081_upd_mask (timestamp, dm_int);
        i41tsparse (timestamp, error, errpos);
        ok := false;
        END
    (*ENDWITH*) 
ELSE
    ok := true;
(*ENDIF*) 
END; (* check_free_mixture *)
 
(*------------------------------*) 
 
PROCEDURE
      in081_read_mask (
            VAR input    : tin_ls_input_field;
            VAR any_date : tin_date_mask);
 
VAR
      j         : integer;
      k         : integer;
 
BEGIN
WITH input, any_date DO
    BEGIN
    k := len;
    WHILE (k > 1) AND (buf [k]  = ' ') DO
        k := k - 1;
    (*ENDWHILE*) 
    IF  k > mxin_date_mask_string
    THEN
        k := mxin_date_mask_string;
    (*ENDIF*) 
    FOR j := 1 TO k DO
        msk [j]  := buf [j] ;
    (*ENDFOR*) 
    FOR j := k + 1 TO mxin_date_mask_string DO
        msk [j]  := ' ';
    (*ENDFOR*) 
    mlen := k;
    END;
(*ENDWITH*) 
END; (* in081_read_mask *)
 
(*------------------------------*) 
 
PROCEDURE
      in081_upd_mask (
            VAR any_date : tin_date_mask;
            dm_type      : tin_dmtype);
 
BEGIN
IF  dm_type = dm_iso
THEN
    BEGIN
    any_date.msk  := cin_key_iso;
    any_date.mlen := mxin_key_iso;
    END
ELSE
    IF  dm_type = dm_usa
    THEN
        BEGIN
        any_date.msk  := cin_key_usa;
        any_date.mlen := mxin_key_usa;
        END
    ELSE
        IF  dm_type = dm_eur
        THEN
            BEGIN
            any_date.msk  := cin_key_eur;
            any_date.mlen := mxin_key_eur;
            END
        ELSE
            IF  dm_type = dm_jis
            THEN
                BEGIN
                any_date.msk  := cin_key_jis;
                any_date.mlen := mxin_key_jis;
                END
            ELSE
                IF  dm_type = dm_int
                THEN
                    BEGIN
                    any_date.msk  := cin_key_int;
                    any_date.mlen := mxin_key_int;
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
END; (* in081_upd_mask *)
 
(*------------------------------*) 
 
PROCEDURE
      repl_char (
            VAR input     : tin_ls_input_field;
            blank_allowed : boolean;
            VAR inpchar   : char;
            VAR csr_pos   : tin_ls_position;
            VAR msg_no    : integer);
 
BEGIN
IF  input.len > 0
THEN
    inpchar := input.buf  [1]
ELSE
    IF  blank_allowed
    THEN
        inpchar := bsp_c1
    ELSE
        BEGIN
        msg_no := cin_setmsg_no_blank;
        csr_pos := input.fld_pos;
        END;
    (*ENDIF*) 
(*ENDIF*) 
END; (* repl_char *)
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
