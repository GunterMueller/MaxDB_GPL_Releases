.CM  SCRIPT , Version - 1.1 , last edited by holger
.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VIN10$
.tt 2 $$$
.TT 3 $$dialog_editor$1998-06-17$
***********************************************************
.nf
 
.nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : dialog_editor
=========
.sp
Purpose : Editor for SQL-DB QUERY, LOAD, DIALOG, EASY
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              i10edit (
                    VAR eform   : tin_eform_buffer;
                    VAR evars   : tin_eform_vars;
                    VAR display : tin_display_parms;
                    VAR cmd     : tin_cmd_type;
                    VAR relkey  : tin_ls_releasemode);
 
        PROCEDURE
              i10editbyte (
                    VAR eform    : tin_eform_buffer;
                    VAR evars    : tin_eform_vars;
                    VAR display  : tin_display_parms;
                    VAR cmd      : tin_cmd_type;
                    VAR relkey   : tin_ls_releasemode;
                    VAR code_type : tsp00_CodeType );
 
        PROCEDURE
              i10doubleedit (
                    VAR eform1  : tin_eform_buffer;
                    VAR evars1  : tin_eform_vars;
                    VAR eform2  : tin_eform_buffer;
                    VAR evars2  : tin_eform_vars;
                    VAR display : tin_display_parms;
                    VAR cmd1    : tin_cmd_type;
                    VAR cmd2    : tin_cmd_type;
                    VAR relkey  : tin_ls_releasemode);
 
        PROCEDURE
              i10list (
                    VAR eform   : tin_eform_buffer;
                    VAR evars   : tin_eform_vars;
                    VAR display : tin_display_parms;
                    VAR cmd     : tin_cmd_type;
                    VAR relkey  : tin_ls_releasemode;
                    response    : boolean);
 
        PROCEDURE
              i10info (
                    mode     : tin_mode_field;
                    VAR msg  : tin_screenline;
                    response : boolean);
 
        PROCEDURE
              i10msgout (
                    VAR msg  : tin_screenline );
 
        PROCEDURE
              i10execute (
                    mode        : tin_mode_field;
                    VAR csr_pos : tin_ls_position);
 
        PROCEDURE
              i10sformclear (
                    VAR sform : tin_sform);
 
        PROCEDURE
              i10outscreen (
                    VAR sform   : tin_sform;
                    VAR display : tin_display_parms;
                    VAR scroll  : tin_display_range;
                    VAR relkey  : tin_ls_releasemode;
                    response    : boolean);
 
        PROCEDURE
              i10reportoutscreen (
                    VAR display    : tin_display_parms;
                    VAR cmd        : tin_cmd_type;
                    VAR relkey     : tin_ls_releasemode;
                    screen_io      : boolean;
                    set_cursor     : boolean);
 
        PROCEDURE
              i10init (
                    VAR display : tin_display_parms);
 
        PROCEDURE
              i10insertlabel (
                    VAR field_pos : tin_ls_position );
 
        PROCEDURE
              i10mfset  (
                    VAR msg_nos : tin_msgnos );
 
        PROCEDURE
              i10tetrans_eform (
                    VAR eform    : tin_eform_buffer;
                    VAR evars    : tin_eform_vars;
                    source_type  : tsp00_CodeType );
 
        PROCEDURE
              i10tltrans_elines (
                    VAR eform    : tin_eform_buffer;
                    VAR evars    : tin_eform_vars;
                    source_type  : tsp00_CodeType;
                    dest_type    : tsp00_CodeType );
 
        PROCEDURE
              i10sysedit (
                    VAR eform    : tin_eform_buffer;
                    VAR evars    : tin_eform_vars;
                    VAR display  : tin_display_parms;
                    VAR cmd      : tin_cmd_type;
                    VAR ok       : boolean );
 
        FUNCTION
              in1030 : tsp00_Int4;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              dialog_editor_functions : VIN11;
 
        FUNCTION
              i11keychange : boolean;
 
        PROCEDURE
              i11content_message (
                    msg_id          : tin_edit_msg;
                    msg_length      : tin_natural;
                    VAR msg_content : tsp00_C10;
                    VAR text        : tin_screenline;
                    VAR err_flag    : boolean);
 
        PROCEDURE
              i11getdark_eline_count (
                    VAR prefix     : tin_prefix_type;
                    start_this     : tin_natural;
                    this           : integer;
                    VAR dark_count : tin_natural );
 
        FUNCTION
              i11isdark_ln (
                    VAR prefix    : tin_prefix_type;
                    this_eline_no : tin_natural;
                    VAR this_lno  : tin_natural ) : boolean;
 
        PROCEDURE
              i11exeditcmds (
                    VAR eform   : tin_eform_buffer;
                    VAR evars   : tin_eform_vars;
                    VAR display : tin_display_parms;
                    VAR edit    : tin_edit_work_area);
 
        PROCEDURE
              i11exrelkeycmd (
                    VAR eform   : tin_eform_buffer;
                    VAR evars   : tin_eform_vars;
                    VAR display : tin_display_parms;
                    VAR edit    : tin_edit_work_area;
                    VAR cmd     : tin_cmd_type;
                    VAR relkey  : tin_ls_releasemode;
                    VAR block   : tin_ed_winmark_type );
 
        PROCEDURE
              i11sortprefix (
                    VAR prefix : tin_prefix_type);
 
        PROCEDURE
              i11message (
                    msg_id       : tin_edit_msg;
                    VAR msg_text : tin_screenline;
                    VAR err_flag : boolean);
 
      ------------------------------ 
 
        FROM
              dialog_editor_li_functions : VIN13;
 
        PROCEDURE
              i13geget_editor (
                    VAR cmd : tin_cmd_type;
                    VAR pos : tsp00_Int2;
                    VAR ok  : boolean );
 
        PROCEDURE
              i13sesystem_editor (
                    VAR eform    : tin_eform_buffer;
                    VAR evars    : tin_eform_vars;
                    VAR display  : tin_display_parms;
                    VAR edit     : tin_edit_work_area;
                    VAR cmd      : tin_cmd_type;
                    VAR pos      : tsp00_Int2;
                    VAR exec_ok  : boolean );
 
        PROCEDURE
              i13doublelicmds (
                    VAR display : tin_display_parms;
                    VAR edit    : tin_edit_work_area;
                    VAR kom_nr  : tsp00_Uint1 );
 
        PROCEDURE
              i13exlicmds (
                    VAR eform   : tin_eform_buffer;
                    VAR evars   : tin_eform_vars;
                    VAR display : tin_display_parms;
                    VAR edit    : tin_edit_work_area;
                    VAR cmd     : tin_cmd_type;
                    VAR relkey  : tin_ls_releasemode;
                    VAR kom_nr  : tsp00_Uint1;
                    list        : boolean);
 
      ------------------------------ 
 
        FROM
              standard_editor_functions : VIN14;
 
        FUNCTION
              i14clcut_line (
                    VAR eform     : tin_eform_buffer;
                    VAR evars     : tin_eform_vars;
                    VAR max_lnlen : tin_natural ) : boolean;
 
        FUNCTION
              i14lolen_overflow (
                    VAR eform     : tin_eform_buffer;
                    VAR evars     : tin_eform_vars;
                    VAR this      : tin_natural;
                    VAR max_lnlen : tin_natural ) : boolean;
 
        PROCEDURE
              i14geteline (
                    VAR eform  : tin_eform_buffer;
                    VAR evars  : tin_eform_vars;
                    VAR line   : tin_eline;
                    line_nr    : tin_natural;
                    VAR length : tin_natural;
                    VAR error  : boolean);
 
        PROCEDURE
              i14puteline (
                    VAR eform : tin_eform_buffer;
                    VAR evars : tin_eform_vars;
                    VAR line  : tin_eline;
                    line_nr   : tin_natural;
                    length    : tin_natural;
                    VAR error : boolean);
 
        PROCEDURE
              i14setuplinecount (
                    VAR eform : tin_eform_buffer;
                    VAR evars : tin_eform_vars);
 
        FUNCTION
              i14linelength (
                    VAR eform : tin_eform_buffer;
                    VAR evars : tin_eform_vars;
                    line_nr   : tin_natural) : tin_natural;
 
      ------------------------------ 
 
        FROM
              global_variable : VIN01;
 
        VAR
              i01g : tin_global_in_vars;
 
      ------------------------------ 
 
        FROM
              messages : VIN03;
 
        PROCEDURE
              i03mfrange (
                    msgno1     : tsp00_Int2;
                    msgno2     : tsp00_Int2;
                    VAR msgnos : tin_msgnos);
 
        PROCEDURE
              i03mfset (
                    msgno      : tsp00_Int2;
                    VAR msgnos : tin_msgnos);
 
      ------------------------------ 
 
        FROM
              pick-put-functions: VIN15;
 
        PROCEDURE
              i15pickhelp (
                    VAR display : tin_display_parms );
 
      ------------------------------ 
 
        FROM
              SQLDB-command-interface: VIN20;
 
        FUNCTION
              i20dbok : boolean;
 
      ------------------------------ 
 
        FROM
              Code-Translation : VIN32;
 
        PROCEDURE
              i32t1translate (
                    source_code     : tsp00_Uint1;
                    dest_code       : tsp00_Uint1;
                    VAR source      : tin_eline;
                    spos            : integer;
                    VAR destination : tin_eline;
                    dpos            : integer;
                    len             : integer );
 
      ------------------------------ 
 
        FROM
              logical_screen : VIN50;
 
        PROCEDURE
              i50clear (
                    part : tin_ls_part);
 
        PROCEDURE
              i50info (
                    VAR modes : tsp00_VtAttrib;
                    VAR keys  : tin_ls_key_set);
 
        PROCEDURE
              i50insertlabel (
                    VAR lab : tsp00_VtLabel;
                    ft      : tin_ls_fieldtype;
                    pos     : tin_ls_position);
 
        PROCEDURE
              i50put1field (
                    VAR field  : tsp00_C10;
                    length     : tin_natural;
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype);
 
        PROCEDURE
              i50put2field (
                    VAR field  : tin_screenline;
                    length     : tin_natural;
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype);
 
        PROCEDURE
              i50put3field (
                    VAR field  : tin_mode_field;
                    length     : tin_natural;
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype);
 
        PROCEDURE
              i50put5field (
                    VAR field  : tin_screenline;
                    length     : tin_natural;
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype);
 
        PROCEDURE
              i50putattribute (
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype);
 
        PROCEDURE
              i50getwindow (
                    first_pos          : tin_ls_position;
                    window_len         : tin_natural;
                    window_width       : tin_natural;
                    VAR window_changed : boolean);
 
        PROCEDURE
              i50getfield (
                    VAR vt_input    : tin_ls_input_field;
                    VAR field_found : boolean);
 
      ------------------------------ 
 
        FROM
              logical_screen_layout : VIN51;
 
        PROCEDURE
              i51size2 (
                    sno            : integer;
                    screen_part    : tin_ls_part;
                    VAR partlength : tin_natural;
                    VAR partwidth  : tin_natural);
 
        PROCEDURE
              i51offwindow (
                    VAR restore : boolean );
 
        PROCEDURE
              i51split (
                    screens : tin_natural);
 
        PROCEDURE
              i51onwindow (
                    defined_part : tin_ls_part;
                    VAR win      : tin_screen_window;
                    VAR ok       : boolean );
 
        PROCEDURE
              i51layout (
                    functionmenu_length : tin_natural;
                    inputarea_length    : tin_natural;
                    msglines            : tin_natural);
 
        PROCEDURE
              i51size (
                    screen_part : tin_ls_part;
                    VAR length  : tin_natural;
                    VAR width   : tin_natural);
 
      ------------------------------ 
 
        FROM
              logical_screen_modules : VIN56;
 
        PROCEDURE
              i56errormessage ( screen_nr : tsp00_Int2;
                    VAR field : tin_screenline;
                    length    : tin_natural );
 
        PROCEDURE
              i56title (
                    blinking_modefield : boolean;
                    screen_nr          : integer;
                    VAR title          : tsp00_OnlineHeader);
 
        PROCEDURE
              i56vrange (
                    screen_nr  : integer;
                    VAR lbl    : tsp00_C8;
                    VAR vrange : tin_display_range);
 
        PROCEDURE
              i56putlabels (
                    fct_cursorpos      : tin_ls_releasemode;
                    functionline_label : boolean);
 
        PROCEDURE
              i56putframe (
                    with_name   :  boolean;
                    with_parms  :  boolean );
 
        PROCEDURE
              i56hrange(
                    screen_no  : integer;
                    VAR hrange : tin_display_range);
&       ifdef WINDOWS
              (* B.M. Rel 3.0.1I 15 Jun 1992 *)
 
        PROCEDURE
              i56setmark (
                    screen_nr     : tsp00_Int2;
                    screenpart    : tin_ls_part;
                    mode          : tsp00_VtMark;
                    top, left     : tsp00_Int2;
                    bottom, right : tsp00_Int2 );
 
        PROCEDURE
              i56getmark (
                    screen_nr         : tsp00_Int2;
                    screenpart        : tin_ls_part;
                    VAR mode          : tsp00_VtMark;
                    VAR top, left     : tsp00_Int2;
                    VAR bottom, right : tsp00_Int2 );
 
        PROCEDURE
              i56standardbox (
                    mode      : tsp00_VtUsageMode;
                    immediate : boolean ;
                    on        : boolean );
              (* M.Rathmann for i10outscreen April, 19, 1995 *)
 
        PROCEDURE
              i56dlgbox (
                    box_id          : tsp00_Int2;
                    style           : tsp00_DlgBoxStyle;
                    screenpart      : tin_ls_part;
                    VAR trigger     : tin_ls_key_set;
                    immediate       : boolean;
                    callback_switch : tsp00_Int2;
                    context         : tsp00_BufAddr;
                    ok_button       : tin_ls_releasemode;
                    cancel_button   : tin_ls_releasemode);
 
        PROCEDURE
              i56dlgremove (
                    boxid : tsp00_Int2 );
&       endif
 
      ------------------------------ 
 
        FROM
              logical_screen_IO : VIN57;
 
        PROCEDURE
              i57ioscreen (
                    VAR csr_pos        : tin_ls_position;
                    VAR rf             : tin_ls_releasemode;
                    VAR screen_changed : boolean);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30klen (
                    VAR str : tin_screenline;
                    val     : char;
                    cnt     : integer) : integer;
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        FUNCTION
              s20int4_to_int2 (
                    i : tsp00_Int4) : tsp00_Int2;
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              i50put1field;
 
              tsp00_MoveObj tsp00_C10
 
        PROCEDURE
              i50put2field;
 
              tsp00_MoveObj tin_screenline
 
        PROCEDURE
              i50put3field;
 
              tsp00_MoveObj tin_mode_field
 
        PROCEDURE
              s30klen;
 
              tsp00_MoveObj  tin_screenline
 
        PROCEDURE
              i50put5field;
 
              tsp00_MoveObj tin_screenline
 
        PROCEDURE
              m90buf;
 
              tsp00_Buf  tin_prefix_content
 
        PROCEDURE
              m90buf1;
 
              tsp00_Buf tin_ls_sk_label;
 
        PROCEDURE
              m90buf2;
 
              tsp00_Buf tin_eline;
 
        PROCEDURE
              i32t1translate;
 
              tsp00_MoveObj tin_eline
              tsp00_MoveObj tin_eline
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1986-11-13
.sp
.cp 3
.sp
.cp 3
Release :      Date : 1998-06-17
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.sb;Description of the editor form (eform)
.br;-----------------------------------------
.sp 2
The structure of the editor form and some operations on it are
described below.
.sp 3;.cp 8;.nf
CONST
      maxmovelength  = 8192;
TYPE
      moveobject     = PACKED ARRAY [ 1..maxmovelength ]
                                                OF char;
.sp 3;.fo
The editor form is an 8-kbyte buffer of the type moveobject.
The user inputs are stored there in a line-oriented sequence.
.sp
The individual lines have no fixed length or position; leading blanks
are not stored and there are no end-of-line markers.
.sp
Each line is provided with a length entry and the number of
(unstored) leading blanks.
.sp
A line has the following layout:
.sp 2;.nf
 1 byte    1 byte
-------------------------------------------------
| line    | leading   | line contents           |
| length  | blanks    | (w/o leading blanks)    |
-------------------------------------------------
.sp 2;
Line length     : Total length of a line in the buffer
                  in bytes.
 
leading blanks  : Number of leading blanks (shown in this way
                  to minimize storage space).
.sp 2;.fo
In addition to the pure data buffer, there are several variables
(ti_eform_vars) that are necessary for a complete description and
handling:
.sp 2;.cp 10;.nf
TYPE
 tin_eform_vars     = RECORD
   size     : tin_natural;  (max. length of the eform in bytes)
   elength  : tin_natural;  (current length of the eform in bytes)
   lines    : tin_natural;  (number of lines entered)
   act_line : tin_natural;  (current line)
   act_pos  : tin_natural;  (initial position of
                                 the current line)
 END;
.sp 2;.fo
In order to simplify working with eform, there is a series of
procedures (VIN14) that can be used to process individual lines
(read, write, delete, etc] .  Eform should be accessed via these
procedures only.
.sp 2;.nf
CONST
      mxin_eline       = 132;
TYPE
      tin_eline        = PACKED ARRAY [ 1..mxin_eline ] OF char;
.sp 2;.fo
The procedures in VIN14 operate on the eform in a line-oriented
manner and use the TYPE tin_eline as a line.
.sp
The individual lines are addressed by their sequence numbers.
.sp 2
The dialog editor processes just such an
.oc _/1;editor form.
Each line has a 3-character
.oc _/1;prefix
for inputting editor statements and a 79-character
.oc _/1;input area
for user data (e.g. QUERY and DATALOAD statements,
DIALOG routines and FORM masks).
.sp;
The
.oc _/1;editor statements
refer to an individual line or line block.
They can be specified with upper-case or lower-case letters.
In the case of block statements, the quantity is to be specified
by a digit (1 to 9) (default 1).
The following functions are available:
.sp ;.cp 8;.of +7
In
After this line, n new lines are inserted and initialized with
blanks.
.of -7;.sp ;.cp 4;.of +7
Dn
Beginning with this line, n lines are deleted.
.of -7;.sp ;.cp 4;.of +7
DD
Beginning with this line, all lines are deleted up to and including
the next line that is also flagged in this way.
.of -7;.sp ;.cp 4;.of +7
>n
The contents of this line are shifted to the right by n columns.
.of -7;.sp ;.cp 4;.of +7
>>n
The contents of all lines from this line to the next one that is
also flagged with >> are shifted to the right by n columns.
.of -7;.sp ;.cp 4;.of +7
<n
The contents of this line are shifted to the left by n columns.
.of -7;.sp ;.cp 4;.of +7
<<n
The contents of all lines from this line to the next one that is
also flagged with << are shifted to the left by n columns.
.of -7;.sp ;.cp 4;.of +7
"n
This line is duplicated n times.
.of -7;.sp ;.cp 4;.of +7
""
The line sequence from this line up to and including the next line that
is also flagged in this way is duplicated.
.of -7;.sp ;.cp 10;.of +7
C
This line is copied after the next line that is flagged with F or before
the next line that is flagged with P.
.of -7;.sp ;.of +7
CC
The line sequence from this line up to and including the next line that
is also flagged in this way is copied after the next line flagged with F
or before the next line flagged with P.
.of -7;.sp ;.of +7
M
Same as C except that the line is deleted from the old position.
.of -7;.sp ;.of +7
MM
Same as CC except that the lines are deleted from the old position.
.of -7;.sp ;.of +7
/
The relevant line is centered on the screen
.of -7
.sp ;.cp 4
The function keys Pf7, Pf8, Pf10 and Pf11 move the form upwards,
downwards, to the left and to the right on the screen;
if the cursor is located on a line of the form, Pf7/8 move the
form until this line borders the edge of the section being
displayed.
.sp ;.cp 4
With the function key Pf4, the currently gathered contents of the editor form
can be out put via the printer.
.sp 3;.cp 20
.sp;.cp 9;.fo
The following procedures are available for calling the editor:
.sp ;.cp 9;.nf
PROCEDURE
      i10edit (
            VAR eform   : eform_type;
                  VAR display : tin_display_parms;
            VAR cmd     : tin_cmd_type;
                  VAR relkey  : tin_ls_releasemode);
.sp;.fo
This procedure requests that the editor take over the dialog with
the user.  The calling environment passes:
.sp;.nf
   1. an editor form (eform)
   2. the display parameters (display) for outputting
      this form to the screen (see below)
   3. the initial assignment of the command line (cmd)
.sp;.fo
The editor displays the editor form that was passed on the screen
according to the display parameters and executes the user's
statements.  It retains control of the dialog until the user
.sp;.nf;.cp 3
   a) writes something in the command line on the screen or
   b) presses the function key Pf01, Pf03, Pf05, Pf06,
      Pf09 or Pf12.
.sp;.fo
In the case of ENTER, Pf03, Pf04, Pf05, Pf07, Pf08, Pf10 and Pf11,
whatever editor statements are contained in the prefix are executed first,
and then the function assigned to that key.
.sp
As its result, the editor returns to the calling environment:
.sp;.nf
   1. the last status of the editor form (eform),
   2. the display parameters that were last valid (display)
   3. the current contents of the command line (cmd)
   4. the input/function key that was last pressed (relkey)
      (ti_vt_releasemode: see Logical screen)
.sp 2;.cp 9
PROCEDURE
      i10info (
            mode     : tin_mode_field;
            VAR msg  : tin_screenline;
                  response : boolean);
.sp;.fo
This procedure is called if the editor form currently on the screen
is to remain visible while the external environment (e.g. REFLEX/QUERY)
executes a function.
.sp
The procedure overwrites the mode_field in the header line of the
editor screen with 'EXECUTE' and outputs the passed messages msg1
and msg2 to the two message lines.
.sp 2;.cp 8;.nf
PROCEDURE
      i10outscreen (
            VAR sform   : tin_sform;
                  VAR display : tin_display_parms;
                  VAR scroll  : tin_display_range;
                  VAR cmd     : tin_cmd_type;
                  VAR relkey  : tin_ls_releasemode;
                  response    : boolean);
.sp;.fo
This procedure serves to output a form of the type sform.
No more than 18 lines can be output; there is no prefix area and no editor
options.
.sp
In addition to the usual parameters, are the following:
.sp;.nf
response : false - control is relinquished immediately after display
           true  - control is relinquished when any release
                   key is pressed.
.sp
scroll   : the range of lines displayed (e.g. 001-018) and the
           scrolling options (left <<<----, right ---->>>,
           both <<<---->>>, nothing ----)
.sp;.fo
The current contents of the command line and the designation of
the key that is pressed are returned in the parameters
CMND and RELKEY.
.sp 2;.cp 8;.nf
PROCEDURE
      i10sformclear (
            VAR sform : tin_sform);
.sp;.fo
Initialization of the sform form with blanks.
.sp 2;.cp 8;.nf
PROCEDURE
      i10list (
            VAR eform   : eform_type;
            VAR display : tin_display_parms;
            VAR cmd     : tin_cmd_type;
            VAR relkey  : tin_ls_releasemode;
                  response    : boolean);
.sp
Via this procedure, the editor is activated in the list mode.
The output area is write-protected and the prefix is superimposed with
blanks.  If the parameter 'response' has the value TRUE, the dialog
user can shift the form window using the function keys
PF07, PF08, PF10 and PF11 and output the form via the virtual printer
using PF04.
.sp
The list mode is exited via
.sp;.nf
    - an input in the command line of the screen.
.sp
    - pressing one of the function keys not mentioned
      above.
.sp;.fo
If the parameter RESPONSE has the value FALSE, the calling
program recovers control immediately.
.sp
The form is returned to the user unchanged.  The current contents
of the command line and the designation of the key that was last
pressed are passed in the parameters CMND and RELKEY.
.sp 2;.cp 8;.nf
PROCEDURE
      i10init (
            VAR display : tin_display_parms);
.sp;.fo
This procedure takes over the initialization of the display parameters
(display) before the very first call.  They must not be assigned when
the call is issued.
.sp;.cp 11;.fo
The
.oc _/1;display parameters
control specific details when an editor form is output to the
screen.  When the editor is called, they must be assigned valid
values and are defined as follows:
.sp;.cp 12;.nf
 tin_display_parms :
      frame         : parameter for the header line, message line,
                      key assignments (see below)
      upper_margin  : pointer to the first line to be
                      displayed (e.g. 1)
      left_margin   : number of the first column to be
                      displayed (e.g. 1)
      csr_pos       : cursor position
      pick          : buffer for buffering blocks
      split_screen  : if true, the screen is split
      active_screen : only if split_screen = true
      my_layout     : if true, layout is determined by
                      the caller
      changed       : is set if the contents of eform have
                      changed.
.sp 2;.cp 11;.fo
The
.oc _/1;header line
on the screen has the following uniform layout for
the dialog components:
.sp;.cp 13;.nf
  2-11    10 positions, identifier of the active component
    12     1 blank
 13-24    12 positions, identifier of the mode
    25     1 blank
 26-61    36 positions, for additional information
    62     1 blank
 63-70     8 positions, userid of the active user
 71-72     2 blanks
 73-75     3 positions, no. of the first line displayed
    76     1 position, '-'
 77-79     3 positions, no. of the last line displayed
.sp 2;.cp 11;.fo
The sections of the header line that are to be preset by the calling
environment are combined in the following type:
.sp;.nf
 tsp00_OnlineHeader :
      id_field      : identifier of the active
                      component (e.g. QUERY 2.1)
      mode_field    : identifier of the current
                      mode (e.g. INPUT)
      text_field    : additional information
                      (optional)
      user_field    : userid of the active user
.sp
               ***********************
.sp;.cp 7;.fo
For the return of an
.oc _/1;online command
entered in the command line by the user
(e.g. STORE),
a command buffer is used that has the following format:
.sp;.nf
 tin_cmd_type :
      length          : length of the user input
      content         : user input
 
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.cp 50;
.oc _/1
Description:
 
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
 
(*------------------------------*) 
 
PROCEDURE
      i10edit;
 
BEGIN
initialize the work area FROM the editor;
REPEAT
    display the editor form that was passed;
    read in the form that was changed by the user;
    IF   the user has activated a releasekey that
        is relevant
    THEN
        BEGIN
        analyze the input commands
              in the prefix ofthe editor form
              (as long as no error is detected);
        execute the individual prefix commands
              sequentially
              (as long as no error is detected);
        execute the Function that is assigned tothe
              releasekey that was activated
              (If no error has been detected)
        END
    ELSE
        check whether the releasekey was valid
    (*ENDIF*) 
UNTIL
    the user has activated a releasekey that
    leads tothe exiting ofthe editor
    OR writes something tothe command line
(*ENDREPEAT*) 
END;
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
TYPE
 
      ed_cntr_type = RECORD
            screen_upd     : boolean;
            label_upd      : boolean;
            curr_edit_type : tin_editor_type;
            curr_wrap_mode : boolean;
      END;
 
 
 
(*------------------------------*) 
 
FUNCTION
      in1030 : tsp00_Int4;
 
BEGIN
(* linkcheck function *)
in1030 := 220920627;
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10edit (
            VAR eform    : tin_eform_buffer;
            VAR evars    : tin_eform_vars;
            VAR display  : tin_display_parms;
            VAR cmd      : tin_cmd_type;
            VAR relkey   : tin_ls_releasemode );
 
VAR
      code_type : tsp00_CodeType;
 
BEGIN
(* B.M. Rel 3.0.1I 15 Jun 1992 *)
&ifdef WINDOWS
win_init_i10 (display);
&endif
IF  chr (64) = bsp_c1
THEN
    code_type := csp_ebcdic
ELSE
    code_type := csp_ascii;
(*ENDIF*) 
i10editbyte ( eform, evars, display, cmd, relkey, code_type);
(* B.M. Rel 3.0.1I 15 Jun 1992 *)
&ifdef WINDOWS
win_reset_i10;
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10editbyte (
            VAR eform    : tin_eform_buffer;
            VAR evars    : tin_eform_vars;
            VAR display  : tin_display_parms;
            VAR cmd      : tin_cmd_type;
            VAR relkey   : tin_ls_releasemode;
            VAR code_type : tsp00_CodeType );
 
CONST
      not_list   = false;
      response   = true;
 
VAR
      edit             : tin_edit_work_area;
      leave_by_relkey  : boolean;
      leave_by_command : boolean;
      ln_overflow      : boolean;
      error            : boolean;
      l_key            : boolean;
      r_key            : boolean;
      spj_key          : boolean;
      active_keys      : tin_ls_key_set;
      kom_nr           : tsp00_Uint1;
      restore          : boolean;
      cut              : boolean;
      ready            : boolean;
      max_cols_opt     : tin_natural;
      ed_cntr          : ed_cntr_type;
      exit             : boolean;
      block            : tin_ed_winmark_type;
 
BEGIN
IF  NOT i01g^.is_batch
THEN
    BEGIN
    WITH ed_cntr DO
        BEGIN
        display.active_screen := 1;
        leave_by_command := false;
        leave_by_relkey  := false;
        ln_overflow    := false;
        screen_upd     := false;
        label_upd      := false;
        restore        := true;
&       ifdef WINDOWS
        curr_edit_type := no_prefix;
&       else
        curr_edit_type := i01g^.set_parms.editor;
&       endif
        curr_wrap_mode := display.wrap;
        i14setuplinecount (eform, evars);
        i10tetrans_eform (eform, evars, code_type);
        init_screen (display);
        edit.double_edit := false;
        init_edit (display, relkey, edit, evars, 1 );
        max_cols_opt := display.frame [ edit.current_eform] .max_cols;
        cut   := true;
        ready := false;
        get_lenover ( eform, evars, display, edit, cut, ready );
        IF  i20dbok
        THEN
            BEGIN
            i01g^.key_type.activated := i01g^.key_type.activated +
                  [ f_pick, f_put, f_insert, f_delete, f_left, f_right,
                  f_mark, f_top, f_bottom, f_cmd, f_exit, f_down, f_up,
                  f_cursor_bol, f_cursor_eol, f_print ];
&           if $OS in [ WIN32, OS2 ]
            i01g^.key_type.activated := i01g^.key_type.activated +
                  [ f_mouse_down, f_mouse_up, f_mouse_dbl];
&           endif
            i01g^.key_type.active_marked := i01g^.key_type.active_marked +
                  [ f_pick ];
            END;
        (*ENDIF*) 
        update_keys ( active_keys );
        l_key :=  ( [f4]  * active_keys =  [f4] );
        r_key :=  ( [f5]  * active_keys =  [f5] );
        spj_key :=   [f3]  * active_keys =  [f3] ;
        error := false;
&       ifndef WINDOWS
        IF  display.wrap  AND ( i01g^.set_parms.editor <> no_prefix )
        THEN
            BEGIN
            i11message ( red_cmd,
                  display.frame [ edit.current_eform] .sys_msg,
                  display.frame [ edit.current_eform] .is_error);
            display.wrap := false;
            END;
&       endif
&       ifdef WINDOWS
        (*ENDIF*) 
        in10_init_mark (block);
&       endif
        IF  NOT edit.error_found
        THEN
            BEGIN
            REPEAT
                BEGIN
                IF  screen_upd
                THEN
                    BEGIN
                    i51offwindow ( restore ) ;
                    init_screen (display);
                    init_edit (display, relkey, edit, evars, 1 );
                    END;
                (*ENDIF*) 
                IF  NOT ready
                THEN
                    BEGIN
                    cut := false;
                    get_lenover ( eform, evars, display, edit, cut, ready );
                    END;
                (*ENDIF*) 
                set_up_down_keys;
                set_left_right_spj_keys (display, edit, active_keys,
                      l_key, r_key, spj_key, label_upd );
                edit.screen_no := 1;
                edit.current_eform := 1;
                i15pickhelp (display);
                outscr_eform (eform, response, evars, display, edit,
                      cmd, relkey, not_list,
                      NOT display.split_screen, error, block);
                IF  NOT error
                THEN
                    inscreen_eform (eform, evars, display,
                          edit, cmd, relkey, error, block);
                (*ENDIF*) 
                IF  relkey = f_exit
                THEN
                    exit := true
                ELSE
                    BEGIN
                    exit := false;
                    IF  error
                    THEN
                        relkey := f_enter
                    ELSE
                        BEGIN
                        edit.csr_switch := true;
&                       ifndef WINDOWS
                        IF  (relkey IN [ f_enter, f_cmd, f9, f1, f2, f6,
                            f_up, f_down, f4, f5] )
                            AND (i01g^.set_parms.editor <> no_prefix)
                        THEN
                            BEGIN
                            analyze_eprefix (display, edit);
                            i11exeditcmds (eform, evars, display, edit);
                            END;
&                       endif
&                       if $OS in [ WIN32, OS2 ]
                        (*ENDIF*) 
                        IF  relkey in [f_mouse_up, f_mouse_down, f_mouse_dbl]
                        THEN
                            in10_exmouse (display, edit, relkey)
                        ELSE
&                           endif
                            IF  relkey in active_keys
                            THEN
                                i11exrelkeycmd (eform, evars, display,
                                      edit, cmd, relkey, block);
&                           ifdef WINDOWS
                            (*ENDIF*) 
                        (*ENDIF*) 
                        leave_by_relkey :=  (relkey = f_enter) AND
                              (display.csr_pos.screen_part =
                              cin_ls_workarea) AND
                              (cmd.length = 0) AND
                              (evars.elength > 0) AND
                              (edit.term_type = k_extended);
&                       else
                        leave_by_relkey :=  (relkey = f_enter) AND
                              (display.csr_pos.screen_part =
                              cin_ls_workarea) AND
                              (cmd.length = 0) AND
                              (evars.elength > 0) AND
                              (i01g^.set_parms.editor = no_prefix)
                              AND (edit.term_type = k_extended);
&                       endif
                        edit.e_cmd := true;
                        leave_by_command := false;
                        IF  (cmd.length > 0) AND (relkey = f_enter)
                        THEN
                            i13exlicmds (eform, evars,
                                  display, edit, cmd, relkey, kom_nr, not_list);
                        (*ENDIF*) 
                        scrn_control ( display, edit, max_cols_opt,
                              ready, ed_cntr );
&                       ifdef WINDOWS
                        curr_edit_type := no_prefix;
&                       else
                        curr_edit_type := i01g^.set_parms.editor;
&                       endif
                        curr_wrap_mode := display.wrap;
                        IF  NOT edit.e_cmd
                        THEN
                            leave_by_command := true;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    leave_by_relkey := leave_by_relkey OR
                          NOT (relkey in active_keys);
                    IF  leave_by_command OR leave_by_relkey
                    THEN
                        set_lenerror (evars, display, edit, ln_overflow );
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            UNTIL
                exit OR NOT ln_overflow
                AND ( leave_by_command OR leave_by_relkey );
            (*ENDREPEAT*) 
            END;
        (*ENDIF*) 
        display.frame [ edit.current_eform] .max_cols := max_cols_opt;
        WITH display.csr_pos DO
            BEGIN
            IF  screen_part = cin_ls_workarea
            THEN
                BEGIN
                sline := sline + display.frame [ screen_nr] .upper_margin - 1;
                IF  scol < edit.first_edit_scol
                THEN
                    scol := edit.first_edit_scol;
                (*ENDIF*) 
                scol := scol - edit.first_edit_scol +
                      display.frame [ screen_nr] .left_margin;
                END
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        i01g^.key_type.activated := i01g^.key_type.activated -
              [  f_pick, f_put, f_insert, f_delete,
              f_mark, f_top, f_bottom, f_cmd, f_exit,
              f_cursor_bol, f_cursor_eol ];
&       if $OS in [ WIN32, OS2 ]
        i01g^.key_type.activated := i01g^.key_type.activated -
              [f_mouse_down, f_mouse_up, f_mouse_dbl];
&       endif
        i01g^.key_type.active_marked := i01g^.key_type.active_marked -
              [ f_pick ];
        IF  NOT display.my_layout
        THEN
            restore_screen;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10sysedit (
            VAR eform    : tin_eform_buffer;
            VAR evars    : tin_eform_vars;
            VAR display  : tin_display_parms;
            VAR cmd      : tin_cmd_type;
            VAR ok       : boolean );
 
VAR
      edit : tin_edit_work_area;
      pos  : tsp00_Int2;
 
BEGIN
i14setuplinecount (eform, evars);
init_sysedit ( edit );
i13geget_editor ( cmd, pos, ok );
i13sesystem_editor ( eform, evars, display, edit, cmd, pos, ok );
END;
 
(*------------------------------*) 
 
PROCEDURE
      scrn_control (
            VAR display      : tin_display_parms;
            VAR edit         : tin_edit_work_area;
            VAR max_cols_opt : tin_natural;
            VAR ready        : boolean;
            VAR ed_cntr      : ed_cntr_type );
 
BEGIN
WITH ed_cntr DO
    BEGIN
    screen_upd := false;
    label_upd  := false;
&   ifdef WINDOWS
    IF  ( curr_edit_type <> no_prefix )
    THEN
        BEGIN
        label_upd := true;
        IF  ( max_cols_opt < i01g^.vt.desc.num_of_cols )
        THEN
            screen_upd := true;
        (*ENDIF*) 
        END;
&   else
    (*ENDIF*) 
    IF  ( curr_edit_type <> i01g^.set_parms.editor )
    THEN
        BEGIN
        label_upd := true;
        IF  ( max_cols_opt < i01g^.vt.desc.num_of_cols )
        THEN
            screen_upd := true;
        (*ENDIF*) 
        END;
&   endif
    (*ENDIF*) 
    IF  ( curr_wrap_mode <> display.wrap )
    THEN
        WITH display.frame [ edit.current_eform ] DO
            BEGIN
            IF  NOT display.wrap
            THEN
                max_cols := max_cols_opt
            ELSE
                BEGIN
                ready := false;
                IF  edit.ecols_on_screen < max_cols
                THEN
                    max_cols := edit.ecols_on_screen;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      set_lenerror (
            VAR evars   : tin_eform_vars;
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            VAR ln_overflow : boolean );
 
VAR
      msg_content      : tsp00_C10;
      mx_lnum          : tin_prefix_content;
 
BEGIN
msg_content    :=  bsp_c10;
WITH edit, display, frame [current_eform ] DO
    BEGIN
    IF  max_lines > 0
    THEN
        BEGIN
        ln_overflow := evars.lines > max_lines;
        IF  ln_overflow
        THEN
            BEGIN
            error_line   := max_lines + 1;
            msg_id       := line_overflow;
            error_type   := cmd_error;
            error_found  := true;
            i_to_c4 ( max_lines, mx_lnum );
            n_to_bl ( mx_lnum );
            s10mv (4,10,
                  @mx_lnum,1,
                  @msg_content,1,4 );
            i11content_message ( msg_id, 4, msg_content, sys_msg, is_error );
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      get_lenover (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            VAR cut     : boolean;
            VAR ready   : boolean );
 
VAR
      err_ln    : tin_natural;
 
BEGIN
WITH edit, display.frame [ edit.current_eform ] DO
    BEGIN
    IF  display.wrap
    THEN
        BEGIN
        IF  max_cols > ecols_on_screen
        THEN
            max_cols := ecols_on_screen;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  ( evars.lines > 0 )
        AND i14lolen_overflow ( eform, evars, err_ln, max_cols )
    THEN
        BEGIN
        IF  cut
        THEN
            BEGIN
            ready := i14clcut_line ( eform, evars, max_cols );
            error_type   := ocmd_error;
            (* display.wrap := false;  *)
            i11message ( li_trunc, sys_msg, is_error );
            END
        ELSE
            BEGIN
            ready        := false;
            error_found  := true;
            error_type   := cmd_error;
            error_line   := err_ln;
            (* display.wrap := false;  *)
            i11message ( wrap_overflow, sys_msg, is_error );
            END;
        (*ENDIF*) 
        END
    ELSE
        ready := true;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10doubleedit (
            VAR eform1  : tin_eform_buffer;
            VAR evars1  : tin_eform_vars;
            VAR eform2  : tin_eform_buffer;
            VAR evars2  : tin_eform_vars;
            VAR display : tin_display_parms;
            VAR cmd1    : tin_cmd_type;
            VAR cmd2    : tin_cmd_type;
            VAR relkey  : tin_ls_releasemode);
 
CONST
      not_list = false;
      response = true;
 
VAR
      edit1            : tin_edit_work_area;
      edit2            : tin_edit_work_area;
      leave_by_relkey  : boolean;
      leave_by_command : boolean;
      error            : boolean;
      l_key            : boolean;
      r_key            : boolean;
      spj_key          : boolean;
      active_keys      : tin_ls_key_set;
      kom_nr           : tsp00_Uint1;
      ln_overflow      : boolean;
      max_cols1_opt     : tin_natural;
      max_cols2_opt     : tin_natural;
      restore          : boolean;
      cut              : boolean;
      ready            : boolean;
      ready1           : boolean;
      ed_cntr          : ed_cntr_type;
      block            : tin_ed_winmark_type;
 
BEGIN
WITH ed_cntr DO
    BEGIN
    leave_by_command := false;
&   ifdef WINDOWS
    curr_edit_type := no_prefix;
&   else
    curr_edit_type := i01g^.set_parms.editor;
&   endif
    curr_wrap_mode := display.wrap;
    ln_overflow    := false;
    screen_upd     := false;
    label_upd      := false;
    restore        := true;
    i14setuplinecount (eform1, evars1);
    i14setuplinecount (eform2, evars2);
    init_screen (display);
    edit1.double_edit := true;
    edit2.double_edit := true;
    init_edit (display, relkey, edit1, evars1, 1 );
    init_edit (display, relkey, edit2, evars2, 2 );
    max_cols1_opt := display.frame [ edit1.current_eform] .max_cols;
    max_cols2_opt := display.frame [ edit2.current_eform] .max_cols;
    cut   := true;
    ready1 := false;
    ready  := false;
    edit1.current_eform := 1;
    edit2.current_eform := 2;
    get_lenover ( eform1, evars1, display, edit1, cut, ready1 );
    get_lenover ( eform2, evars2, display, edit2, cut, ready );
    ready := ready1 AND ready;
    IF  i20dbok
    THEN
        BEGIN
        i01g^.key_type.activated := i01g^.key_type.activated +
              [ f_pick, f_put, f_insert, f_delete, f_left, f_right,
              f_mark, f_top, f_bottom, f_cmd, f_exit, f_down, f_up,
              f_cursor_bol, f_cursor_eol ];
        i01g^.key_type.active_marked := i01g^.key_type.active_marked +
              [ f_pick ];
        END;
    (*ENDIF*) 
    update_keys ( active_keys );
    l_key :=   [f4]  * active_keys =  [f4] ;
    r_key :=   [f5]  * active_keys =  [f5] ;
    spj_key :=   [f3]  * active_keys =  [f3] ;
    error := false;
&   ifndef WINDOWS
    IF  display.wrap  AND ( i01g^.set_parms.editor <> no_prefix )
    THEN
        BEGIN
        i11message ( red_cmd, display.frame  [2] .sys_msg,
              display.frame [2] .is_error);
        display.frame[1].sys_msg  := display.frame[2].sys_msg;
        display.frame[1].is_error := display.frame[2].is_error;
        display.wrap := false;
        END;
&   endif
    (*ENDIF*) 
    IF  NOT edit1.error_found AND NOT edit2.error_found
    THEN
        BEGIN
        REPEAT
            BEGIN
            IF  screen_upd
            THEN
                BEGIN
                (* i51offwindow ( restore ) ;
                      init_screen (display);
                      init_edit ( display, relkey, edit1, evars1, 1 );
                      init_edit ( display, relkey, edit2, evars2, 2 ); *)
                END;
            (*ENDIF*) 
            IF  NOT ready
            THEN
                BEGIN
                cut := false;
                get_lenover ( eform1, evars1, display, edit1,
                      cut, ready1 );
                get_lenover ( eform2, evars2, display, edit2,
                      cut, ready );
                ready := ready1 AND ready;
                END;
            (*ENDIF*) 
            edit1.screen_no := 1;
            edit2.screen_no := 2;
            set_left_right_spj_keys (display, edit1, active_keys,
                  l_key, r_key, spj_key, label_upd );
            outscr_eform (eform1, response, evars1, display, edit1,
                  cmd1, relkey, not_list, false, error, block );
            outscr_eform (eform2, response, evars2, display, edit2,
                  cmd2, relkey, not_list, true, error, block );
            WITH  edit1 DO
                BEGIN
                csr_switch   := false;
                insert_mode  := false;
                target_found := false;
                error_found := false;
                msg_id      := ok_msg;
                END;
            (*ENDWITH*) 
            inscreen_eform (eform1, evars1, display,
                  edit1, cmd1, relkey, error, block );
            inscreen_eform (eform2, evars2, display,
                  edit2, cmd2, relkey, error, block);
            IF  error
            THEN
                relkey := f_enter
            ELSE
                BEGIN
                edit1.csr_switch := true;
                edit2.csr_switch := true;
                IF  relkey IN [ f_enter, f9, f1, f_up, f_down,
                    f4, f5, f_left, f_right ]
                THEN
                    BEGIN
                    analyze_eprefix (display, edit1);
                    analyze_eprefix (display, edit2);
                    i11exeditcmds (eform1, evars1, display, edit1);
                    i11exeditcmds (eform2, evars2, display, edit2);
                    END;
                (*ENDIF*) 
                IF  display.active_screen = 1
                THEN
                    i11exrelkeycmd (eform1, evars1, display,
                          edit1, cmd1, relkey, block);
                (*ENDIF*) 
                IF  display.active_screen = 2
                THEN
                    i11exrelkeycmd (eform2, evars2, display,
                          edit2, cmd2, relkey, block);
                (*ENDIF*) 
                edit1.e_cmd := true;
                edit2.e_cmd := true;
                leave_by_command := false;
                IF  (cmd1.length > 0) AND (relkey = f_enter)
                THEN
                    BEGIN
                    i13exlicmds (eform1, evars1,
                          display, edit1, cmd1, relkey, kom_nr, not_list);
                    i13doublelicmds ( display, edit2, kom_nr );
                    END;
                (*ENDIF*) 
                IF  (cmd2.length > 0) AND (relkey = f_enter)
                THEN
                    BEGIN
                    i13exlicmds (eform2, evars2,
                          display, edit2, cmd2, relkey, kom_nr, not_list);
                    i13doublelicmds ( display, edit1, kom_nr );
                    END;
                (*ENDIF*) 
                scrn_control ( display, edit1, max_cols1_opt,
                      ready1, ed_cntr );
                scrn_control ( display, edit2, max_cols2_opt,
                      ready, ed_cntr );
                ready := ready1 AND ready;
&               ifdef WINDOWS
                curr_edit_type := no_prefix;
&               else
                curr_edit_type := i01g^.set_parms.editor;
&               endif
                curr_wrap_mode := display.wrap;
                IF  (NOT edit1.e_cmd) AND (NOT (relkey in [ f7, f8,
                    f_up, f_down, f3, f4, f5, f_left, f_right] ))
                THEN
                    leave_by_command := true;
                (*ENDIF*) 
                IF  (NOT edit2.e_cmd) AND (NOT (relkey in [ f7, f8,
                    f_up, f_down, f3, f4, f5, f_left, f_right] ))
                THEN
                    leave_by_command := true;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
            leave_by_relkey := relkey in [  f_help, f7, f9, f1, f6, f2 ] ;
            IF  leave_by_command OR leave_by_relkey
            THEN
                BEGIN
                ln_overflow    := false;
                set_lenerror ( evars1, display, edit1, ln_overflow );
                IF  NOT ln_overflow
                THEN
                    set_lenerror ( evars2, display, edit2, ln_overflow );
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            NOT i01g^.vt.ok OR
            (NOT ln_overflow AND ( leave_by_command OR leave_by_relkey ));
        (*ENDREPEAT*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
WITH display.csr_pos DO
    BEGIN
    IF  screen_part = cin_ls_workarea
    THEN
        BEGIN
        sline := sline + display.frame [ screen_nr] .upper_margin - 1;
        IF  scol < edit1.first_edit_scol
        THEN
            scol := edit1.first_edit_scol;
        (*ENDIF*) 
        scol := scol - edit1.first_edit_scol +
              display.frame [ screen_nr] .left_margin;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  NOT display.my_layout
THEN
    restore_screen;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10list (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            VAR display : tin_display_parms;
            VAR cmd     : tin_cmd_type;
            VAR relkey  : tin_ls_releasemode;
            response    : boolean);
 
CONST
      list             = true;
 
VAR
      edit            : tin_edit_work_area;
      leave_by_relkey : boolean;
      error           : boolean;
      l_key           : boolean;
      r_key           : boolean;
      spj_key         : boolean;
      active_keys     : tin_ls_key_set;
      old_key_type    : tin_ls_key_type;
      kom_nr          : tsp00_Uint1;
      block           : tin_ed_winmark_type;
 
BEGIN
&ifdef WINDOWS
win_init_i10 (display);
&endif
error := false;
i14setuplinecount (eform, evars);
init_screen (display);
edit.double_edit := false;
init_edit (display, relkey, edit, evars, 1 );
old_key_type := i01g^.key_type;
leave_by_relkey := false;
IF  response
THEN
    BEGIN
    (* h.b. 02.03.1994: *)
    (* f_cmd herausgenommen *)
    i01g^.key_type.activated := i01g^.key_type.activated + [ f_exit];
    (* M.Rathmann 10.8.93: *)
    (* standard editor call: PRINT, UP, DOWN have been activated by caller*)
    (* other calls (activate only PF3, e.g.): no additional keys! *)
    (* i01g^.key_type.activated := i01g^.key_type.activated +
          [ f_up, f_down, f8 ] ; *)
    update_keys ( active_keys );
    l_key  :=   [f4]  * active_keys =  [f4] ;
    r_key  :=   [f5]  * active_keys =  [f5] ;
    spj_key  :=   [f3]  * active_keys =  [f3] ;
    END
ELSE
    i01g^.key_type.activated := [ ] ;
(*ENDIF*) 
IF  NOT edit.error_found
THEN
    BEGIN
    REPEAT
        edit.csr_set_by_user := false;
        edit.csr_switch      := false;
        IF  response
        THEN
            set_left_right_spj_keys (display, edit, active_keys,
                  l_key, r_key, spj_key, false );
        (*ENDIF*) 
        outscr_eform (eform, response, evars, display,
              edit, cmd, relkey, list, true, error, block);
        IF  ( response )
        THEN
            BEGIN
            inscreen_lform (display, cmd, relkey);
            display.csr_pos.screen_part := cin_ls_inputarea;
            display.csr_pos.sline := 1;
            display.csr_pos.scol := cin_ocmd_scol;
            IF  relkey IN [ f_enter, f8, f_up, f4, f5, f_left, f_right ]
            THEN
                i11exrelkeycmd (eform, evars,
                      display, edit, cmd, relkey, block);
            (*ENDIF*) 
            IF  relkey = f_down
            THEN
                scroll_forward (display, evars, edit);
            (*ENDIF*) 
            IF  (cmd.length > 0) AND (relkey = f_enter)
            THEN
                i13exlicmds (eform, evars,
                      display, edit, cmd, relkey, kom_nr, list);
            (*ENDIF*) 
            leave_by_relkey := NOT edit.e_cmd OR
                  NOT (relkey in active_keys);
            END;
        (*ENDIF*) 
    UNTIL
        leave_by_relkey OR NOT response OR NOT i01g^.vt.ok;
    (*ENDREPEAT*) 
    END;
(*ENDIF*) 
IF  NOT display.my_layout
THEN
    restore_screen;
(*ENDIF*) 
i01g^.key_type := old_key_type;
&ifdef WINDOWS
win_reset_i10;
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10outscreen (
            VAR sform   : tin_sform;
            VAR display : tin_display_parms;
            VAR scroll  : tin_display_range;
            VAR relkey  : tin_ls_releasemode;
            response    : boolean);
 
CONST
      functionmenu_length =  1;
      inputarea_length    =  1;
      msglines            =  1;
&     ifdef WINDOWS
      id_status_box       = 12000;
&     endif
 
VAR
      edit             : tin_edit_work_area;
      screenlines      : tin_natural;
      change_ln        : tin_natural;
      screenpos        : tin_ls_position;
      change_layout    : boolean;
&     ifdef WINDOWS
      trigger          : tin_ls_key_set;
&     endif
 
BEGIN
&ifdef WINDOWS
i56dlgremove ( id_status_box );
&endif
i50clear (cin_ls_basic_window);
display.frame  [1] .upper_margin := 1;
display.frame  [1] .left_margin  := 1;
edit.csr_set_by_user := false;
edit.csr_switch      := false;
change_ln            := 0;
WITH screenpos DO
    BEGIN
    screen_nr   := 1;
    screen_part := cin_ls_workarea;
    sline       := 1;
    scol        := 1;
    END;
(*ENDWITH*) 
i51size (cin_ls_workarea, screenlines, edit.cols_on_screen);
change_layout :=  NOT display.my_layout AND
      ( screenlines >  mxin_sform_lines );
IF  change_layout
THEN
    BEGIN
    change_ln := screenlines - mxin_sform_lines;
    edit.lines_on_screen := mxin_sform_lines;
    i51layout (functionmenu_length, inputarea_length +
          change_ln, msglines);
    i50clear ( cin_ls_basic_window );
    END
ELSE
    BEGIN
    edit.lines_on_screen := screenlines;
    i51layout (functionmenu_length, inputarea_length, msglines);
    END;
(*ENDIF*) 
WITH display.csr_pos DO
    BEGIN
    screen_part := cin_ls_basic_window;
    sline := 0;
    scol  := 0;
    END;
(*ENDWITH*) 
outscr_sform (sform, display, scroll, edit, relkey);
WITH display.csr_pos DO
    BEGIN
    screen_part := cin_ls_inputarea;
    sline := 1;
    scol  := cin_ocmd_scol;
    END;
(*ENDWITH*) 
IF  response
THEN
    ; (* inscreen_lform (display, cmd, relkey); *)
(*ENDIF*) 
IF  change_layout
THEN
    i51layout (functionmenu_length, inputarea_length, msglines);
&ifdef WINDOWS
(*ENDIF*) 
trigger := [ ];
i56dlgbox ( id_status_box, dg_modeless, cin_ls_sysline,
      trigger, true, 0, NIL, f_enter, f_clear );
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10reportoutscreen (
            VAR display    : tin_display_parms;
            VAR cmd        : tin_cmd_type;
            VAR relkey     : tin_ls_releasemode;
            screen_io      : boolean;
            set_cursor     : boolean );
 
VAR
      screen_changed : boolean;
      field_pos      : tin_ls_position;
      scr_len        : tin_natural;
      scr_wid        : tin_natural;
      blankline      : tin_screenline;
 
BEGIN
WITH display, display.frame [active_screen] DO
    BEGIN
    upper_margin := 1;
    left_margin := 1;
    IF  set_cursor
    THEN
        BEGIN
        i51size2 (active_screen, cin_ls_inputarea, scr_len, scr_wid);
        WITH csr_pos DO
            BEGIN
            screen_nr := display.active_screen;
            screen_part := cin_ls_inputarea;
            sline := 1;
            scol  := cin_ocmd_scol + cmd.length;
            IF  scol > scr_wid
            THEN
                scol := scr_wid;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    outscr_trailer (display, cmd, active_screen, active_screen, true );
    WITH field_pos DO
        BEGIN
        screen_part := cin_ls_basic_window;
        screen_nr := active_screen;
        sline := 0;
        scol := 0;
        END;
    (*ENDWITH*) 
    i10insertlabel (field_pos);
    END;
(*ENDWITH*) 
WITH i01g^.vt.opt DO
    BEGIN
    wait_for_input  := true;
    usage_mode      := vt_form;
    return_on_last  := false;
    return_on_first := false;
    returnkeys      := [  ] ;
    reject_keys     := [  ] ;
    (* bell := false; 22.06.93 hb *)
    END;
(*ENDWITH*) 
IF  screen_io
THEN
    WITH display DO
        BEGIN
        i57ioscreen (csr_pos, relkey, screen_changed);
        IF  relkey = f_local
        THEN
            relkey := f_enter;
        (*ENDIF*) 
        IF  split_screen
        THEN
            active_screen := csr_pos.screen_nr;
        (*ENDIF*) 
        SAPDB_PascalForcedFill (mxin_screenline, @blankline, 1, mxin_screenline, bsp_c1);
        frame  [active_screen] .sys_msg  := blankline;
        frame  [active_screen] .is_error := false;
        inscreen_lform (display, cmd, relkey);
        END;
    (*ENDWITH*) 
(*ENDIF*) 
i50clear (cin_ls_functionmenu);
i50clear (cin_ls_inputarea);
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10init (
            VAR display : tin_display_parms);
 
VAR
      blankline : tin_screenline;
      i         : tsp00_Int2;
 
BEGIN
SAPDB_PascalForcedFill (mxin_screenline, @blankline, 1, mxin_screenline, bsp_c1);
WITH display, display.screen_pos DO
    BEGIN
    FOR i := 1 TO mxin_screens DO
        WITH frame  [i]  DO
            BEGIN
            header.id_field     := bin_id_field;
            header.relno_field  := bsp_c8;
            header.mode_field   := bsp_c12;
            header.text_field   := bin_text_field;
            upper_margin  := 1;
            left_margin   := 1;
            sys_msg       := blankline;
            info_msg      := blankline;
            is_error      := false;
            active_screen := 1;
            split_screen  := false;
            bright_line   := 0;
            max_lines     := 0;
            max_cols      := mxin_eline;
            END;
        (*ENDWITH*) 
    (*ENDFOR*) 
    WITH csr_pos DO
        BEGIN
        screen_nr   := 1;
        screen_part := cin_ls_workarea;
        sline       := 1;
        scol        := 1;
        END;
    (*ENDWITH*) 
    WITH pick.pick_vars DO
        BEGIN
        size    := mxin_pickobject;
        elength := 0;
        lines   := 0;
        END;
    (*ENDWITH*) 
    line_pos  := 0;
    col_pos   := 0;
    lines     := 0;
    cols      := 0;
    changed   := false;
    my_layout := false;
    wrap      := false;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10info (
            mode     : tin_mode_field;
            VAR msg  : tin_screenline;
            response : boolean);
 
VAR
      rk             : tin_ls_releasemode;
      field_pos      : tin_ls_position;
      field_type     : tin_ls_fieldtype;
      csr_pos        : tin_ls_position;
      screen_changed : boolean;
      old_key_type   : tin_ls_key_type;
      scr_w          : tin_natural;
      length         : tin_natural;
 
BEGIN
old_key_type := i01g^.key_type;
IF  NOT response
THEN
    i01g^.key_type.activated := [ ]
ELSE
    i01g^.key_type.activated := old_key_type.activated + [ f_enter ];
(*ENDIF*) 
(* ===================================== *)
(* put Text in header mode field         *)
(* ===================================== *)
WITH field_pos DO
    BEGIN (* B.M. *)
    screen_part := cin_ls_header;
    sline       := 1;
    screen_nr   := 1;
    scol := mxin_id_field + mxin_rel_field + 2; (* i56modecol *)
    END;
(*ENDWITH*) 
csr_pos := field_pos;
WITH field_type DO
    BEGIN (* B.M. *)
    field_att  := cin_attr4;
    fieldmode  := [  ] ;
    END;
(*ENDWITH*) 
i50put3field (mode, mxin_mode_field, field_pos, field_type);
(* ================================= *)
(*     put function labels (B.M ]    *)
(* ================================= *)
i56putlabels (f_clear, false);
(* ================================= *)
(*            put sysmsg             *)
(* ================================= *)
field_type.field_att := cin_attr5;
WITH field_pos DO
    BEGIN
    screen_part := cin_ls_sysline;
    i51size (cin_ls_sysline, sline, scr_w);
    scol      := 1;
    screen_nr := 1;
    END;
(*ENDWITH*) 
length := s30klen ( msg, bsp_c1, mxin_screenline );
IF  scr_w > length
THEN
    SAPDB_PascalForcedFill (mxin_screenline, @msg, length+1,
          scr_w-length, bsp_c1 );
(*ENDIF*) 
i50put2field (msg, scr_w, field_pos, field_type);
(*
      i56errormessage ( 1, msg, length );
      *)
(* ================================ *)
(* overlay modefield and messages   *)
(* on screen and set cursor ahead   *)
(* of the mode field                *)
(* ================================ *)
WITH i01g^.vt.opt DO
    BEGIN
    IF  response
    THEN
        wait_for_input := true
    ELSE
        wait_for_input := false;
    (*ENDIF*) 
&   ifdef WINDOWS
    usage_mode := vt_form; (* h.b. 16.02.1994 *)
&   else
    IF  (i01g^.set_parms.editor = no_prefix)
    THEN
        BEGIN
        usage_mode      := vt_edit;
        return_on_last  := true;
        END
    ELSE
        BEGIN
        usage_mode      := vt_form;
        return_on_last  := false;
        END;
    (*ENDIF*) 
&   endif
    return_on_first := false;
    returnkeys      := [  ] ;
    reject_keys     := [  ] ;
    (* bell := false; 22.06.93 hb *)
    END;
(*ENDWITH*) 
WITH csr_pos DO (* B.M. *)
    scol := scol - 1;
(*ENDWITH*) 
REPEAT
    i57ioscreen (csr_pos, rk, screen_changed);
    IF  rk = f_local
    THEN
        rk := f_enter;
    (*ENDIF*) 
UNTIL
    NOT response OR NOT i01g^.vt.ok OR
    (rk in old_key_type.activated);
(*ENDREPEAT*) 
i01g^.key_type := old_key_type;
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10msgout (
            VAR msg  : tin_screenline );
 
VAR
      rk             : tin_ls_releasemode;
      field_pos      : tin_ls_position;
      field_type     : tin_ls_fieldtype;
      csr_pos        : tin_ls_position;
      screen_changed : boolean;
      scr_w          : tin_natural;
      length         : tin_natural;
 
BEGIN
WITH field_type DO
    BEGIN
    field_att  := cin_attr5;
    fieldmode  := [  ] ;
    END;
(*ENDWITH*) 
WITH field_pos DO
    BEGIN
    screen_part := cin_ls_sysline;
    i51size (cin_ls_sysline, sline, scr_w);
    scol      := 1;
    screen_nr := 1;
    END;
(*ENDWITH*) 
length := s30klen ( msg, bsp_c1, mxin_screenline );
IF  scr_w > length
THEN
    SAPDB_PascalForcedFill (mxin_screenline, @msg, length+1,
          scr_w-length, bsp_c1 );
(*ENDIF*) 
i50put2field (msg, scr_w, field_pos, field_type);
WITH i01g^.vt.opt DO
    BEGIN
    wait_for_input := false;
&   ifdef WINDOWS
    usage_mode := vt_edit;
&   else
    IF  (i01g^.set_parms.editor = no_prefix)
    THEN
        BEGIN
        usage_mode      := vt_edit;
        return_on_last  := true;
        END
    ELSE
        BEGIN
        usage_mode      := vt_form;
        return_on_last  := false;
        END;
    (*ENDIF*) 
&   endif
    return_on_first := false;
    returnkeys      := [  ] ;
    reject_keys     := [  ] ;
    END;
(*ENDWITH*) 
WITH csr_pos DO
    BEGIN
    screen_part := cin_ls_header;
    sline       := 1;
    screen_nr   := 1;
    scol := mxin_id_field + mxin_rel_field + 1;
    END;
(*ENDWITH*) 
i57ioscreen (csr_pos, rk, screen_changed);
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10execute (
            mode        : tin_mode_field;
            VAR csr_pos : tin_ls_position);
 
VAR
      rk             : tin_ls_releasemode;
      field_pos      : tin_ls_position;
      field_type     : tin_ls_fieldtype;
      screen_changed : boolean;
 
BEGIN
(* ===================================== *)
(* put Text in header mode field         *)
(* ===================================== *)
WITH field_pos DO
    BEGIN (* B.M. *)
    screen_part := cin_ls_header;
    sline       := 1;
    screen_nr   := 1;
    scol        := mxin_id_field + mxin_rel_field + 2; (* i56modecol *)
    END;
(*ENDWITH*) 
WITH field_type DO
    BEGIN (* B.M. *)
    field_att  := cin_attr4;
    fieldmode  := [  ] ;
    END;
(*ENDWITH*) 
i50put3field (mode, mxin_mode_field, field_pos, field_type);
WITH i01g^.vt.opt DO
    BEGIN (* B.M. *)
    wait_for_input  := false;
&   ifdef WINDOWS
    usage_mode := vt_edit;
&   else
    IF  (i01g^.set_parms.editor = no_prefix)
    THEN
        BEGIN
        usage_mode      := vt_edit;
        return_on_last  := true;
        END
    ELSE
        BEGIN
        usage_mode      := vt_form;
        return_on_last  := false;
        END;
    (*ENDIF*) 
&   endif
    return_on_first := false;
    returnkeys      := [  ] ;
    reject_keys     := [  ] ;
    (* bell := false; 22.06.93 hb *)
    END;
(*ENDWITH*) 
i57ioscreen (csr_pos, rk, screen_changed);
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10insertlabel (
            VAR field_pos : tin_ls_position);
 
VAR
      lab        : tsp00_VtLabel;
      field_type : tin_ls_fieldtype;
 
BEGIN
(* ===================================== *)
(* put INSERT label in upper frame       *)
(* ===================================== *)
lab := ' INSERT ';
WITH field_type DO
    BEGIN (* B.M. *)
    field_att  := cin_attr2;
    fieldmode  := [  ] ;
    END;
(*ENDWITH*) 
i50insertlabel (lab, field_type, field_pos);
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10sformclear (
            VAR sform : tin_sform);
 
VAR
      i           : tin_natural;
      blank_sline : tin_screenline;
 
BEGIN
(* ========================================= *)
(* init all s_form lines by a blankline,  *)
(* ========================================= *)
SAPDB_PascalForcedFill (mxin_screenline, @blank_sline, 1, mxin_screenline, bsp_c1);
FOR i := 1 TO mxin_sform_lines DO
    sform  [i]  := blank_sline;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      init_sysedit (
            VAR edit    : tin_edit_work_area );
 
BEGIN
WITH edit DO
    BEGIN
    error_found   := false;
    current_eform := 1;
    screen_no     := 1;
    msg_id        := ok_msg;
    error_line    := 1;
    error_type    := cmd_error;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      init_edit (
            VAR display : tin_display_parms;
            VAR relkey  : tin_ls_releasemode;
            VAR edit    : tin_edit_work_area;
            VAR evars   : tin_eform_vars;
            screen      : tsp00_Int2 );
 
VAR
      i     : tsp00_Int2;
      keys  : tin_ls_key_set;
      modes : tsp00_VtAttrib;
 
BEGIN
display.changed := false;
edit.error_found := false;
relkey := f_clear;
i50info (modes, keys);
IF  keys * [ f_cmd ] <> [  ]
THEN
    edit.term_type := k_extended
ELSE
    edit.term_type := k_standard;
(*ENDIF*) 
i51size (cin_ls_workarea, edit.lines_on_screen, edit.cols_on_screen);
IF  edit.lines_on_screen < 2
THEN
    edit.error_found := true;
(*ENDIF*) 
IF  edit.cols_on_screen < mxin_min_scr_cols
THEN
    edit.error_found := true;
&ifdef WINDOWS
(*ENDIF*) 
edit.first_edit_scol := 1;
edit.ecols_on_screen := edit.cols_on_screen;
&else
IF  i01g^.set_parms.editor <> prefix_left
THEN
    edit.first_edit_scol := 1
ELSE
    edit.first_edit_scol := cin_firsteditscol;
(*ENDIF*) 
(* ========================================== *)
(* pointer to upper margin of shown edit form *)
(* ========================================== *)
IF  i01g^.set_parms.editor = no_prefix
THEN
    edit.ecols_on_screen := edit.cols_on_screen
ELSE
    edit.ecols_on_screen := edit.cols_on_screen - mxin_prefix_content - 1;
(*ENDIF*) 
&endif
(* =========================================== *)
(* adjust upper margin of shown edit form part *)
(* =========================================== *)
WITH edit DO
    BEGIN
    (* =================================== *)
    (* buffer for analyzed prefix commands *)
    (* cmd  [i]  corresponds to eline  [i]  *)
    (* =================================== *)
    prefix.length := 0;
    FOR i := 1 TO mxin_prefix DO
        WITH prefix.line  [i]  DO
            BEGIN
            op := e_no_cmd;
            block_cmd := false;
            arg := 1;
            eline_nr := 0;
            content := cin_eprefix;
            END;
        (*ENDWITH*) 
    (*ENDFOR*) 
    (* ================== *)
    (* cursor positioning *)
    (* ================== *)
    current_eform   := 1;
    screen_no       := 1;
    csr_set_by_user := false;
    csr_switch      := false;
    cmd_line        := 0;
    (* ====================================== *)
    (* to place cursor on first insert line : *)
    (* ====================================== *)
    insert_mode  := false;
    insert_line  := 1;
    insert_scol  := 1;
    mark1        := false;
    mark2        := false;
    mark1_line   := 0;
    mark1_scol   := 0;
    mark2_line   := 0;
    mark2_scol   := 0;
    (* ========================== *)
    (* to remember f or p target: *)
    (* ========================== *)
    target_found := false;
    target_line  := 1 (* arbitrary *);
    target_kind  := ftarget (* arbitrary *);
    (* =============== *)
    (* error handling  *)
    (* =============== *)
    msg_id      := ok_msg;
    error_line  := 1 (* arbitrary *);
    error_type  := cmd_error (* arbitrary *);
    print_now   := false;
    print_prot  := false;
    e_cmd       := true;
    last_search_line       := 1;
    last_search_col        := 1;
    last_search_cmd.length := 0;
    END;
(*ENDWITH*) 
IF  (evars.elength < 0) OR (evars.elength > mxin_eform_buffer )
THEN
    edit.error_found := true;
(*ENDIF*) 
IF  edit.double_edit
THEN
    init_frame ( display, edit, evars, screen )
ELSE
    FOR i := 1 TO mxin_screens DO
        init_frame ( display, edit, evars, i );
    (*ENDFOR*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      init_frame (
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            VAR evars   : tin_eform_vars;
            screen      : tsp00_Int2 );
 
BEGIN
WITH display, display.csr_pos, frame [ screen ] DO
    BEGIN
    left_margin  := 1;
    IF  upper_margin > evars.lines
    THEN
        upper_margin := evars.lines;
    (*ENDIF*) 
    IF  evars.lines = 0
    THEN
        upper_margin := 1;
    (*ENDIF*) 
    IF  ( screen_part = cin_ls_workarea ) AND ( screen = active_screen )
    THEN
        BEGIN
        IF  (sline < upper_margin) OR
            (sline > upper_margin + edit.lines_on_screen - 1)
        THEN
            sline := upper_margin;
        (*ENDIF*) 
        IF  NOT edit.error_found
        THEN
            sline := sline - upper_margin + 1;
        (*ENDIF*) 
        scol := scol + edit.first_edit_scol - 1;
        IF  scol > edit.ecols_on_screen
        THEN
            BEGIN
            left_margin := scol - edit.ecols_on_screen + 1;
            scol := scol - left_margin + 1;
            END;
        (*ENDIF*) 
        IF  (left_margin + edit.ecols_on_screen) > (max_cols + 1)
        THEN
            BEGIN
            csr_pos.scol := csr_pos.scol + edit.ecols_on_screen -
                  max_cols - 1 + left_margin;
            left_margin := (max_cols + 1) - edit.ecols_on_screen;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      outscr_eform (
            VAR eform   : tin_eform_buffer;
            response    : boolean;
            VAR evars   : tin_eform_vars;
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            VAR cmd     : tin_cmd_type;
            VAR relkey  : tin_ls_releasemode;
            list_func   : boolean;
            outscreen   : boolean;
            error       : boolean;
            VAR block   : tin_ed_winmark_type );
 
VAR
      screen_changed : boolean;
      lab_mark       : tsp00_C4;
      scr_l          : tin_natural;
      scr_w          : tin_natural;
      field_pos      : tin_ls_position;
      hrange         : tin_display_range;
      scroll         : tin_display_range;
      blankline      : tin_screenline;
      header_len     : tin_natural;
      work_len       : tin_natural;
 
BEGIN
WITH display, edit, frame [ current_eform ] DO
    BEGIN
    IF  NOT error
    THEN
        BEGIN
        IF  screen_no = 1
        THEN
            i50clear (cin_ls_basic_window);
        (* ===================================== *)
        (* first recognized prefix command error *)
        (* will be centered on screen            *)
        (* ===================================== *)
        (*ENDIF*) 
        IF  ( current_eform = active_screen ) OR double_edit
        THEN
            IF  error_found
            THEN
                error_presentation (display, edit)
                      (* ================================== *)
                      (* if no prefix command was found,    *)
                      (* cursor will be set on command line *)
                      (* ================================== *)
            ELSE
                IF  ( current_eform = active_screen )
                THEN
                    IF  csr_switch
                    THEN
                        cursor_switch (display, edit)
                    ELSE
                        IF  csr_set_by_user
                        THEN
                            i10_set_cursor (eform, evars, display, edit);
                        (* ======================================== *)
                        (* else cursor was set by caller            *)
                        (* ======================================== *)
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        hrange.displ_begin := left_margin;
        hrange.displ_end   := left_margin + ecols_on_screen - 1;
        hrange.total_begin := 1;
        hrange.total_end   := max_cols;
        IF  ( current_eform = active_screen ) AND  split_screen
        THEN
            BEGIN
            i56putframe (true, true);
            i56hrange( screen_no, hrange);
            END
        ELSE
            IF  (screen_no = 1) OR NOT split_screen
            THEN
                BEGIN
                i56putframe (true, true);
                i56hrange( screen_no, hrange);
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        scroll.displ_begin := upper_margin;
        scroll.total_begin := 1;
        scroll.displ_end   := upper_margin + lines_on_screen - 1;
        scroll.total_end   := csp_maxint4;
        outscr_header (display, scroll, screen_no, current_eform );
        outscr_elines (eform, evars, display, edit, list_func);
        END;
    (*ENDIF*) 
    i51size (cin_ls_header, header_len, scr_w);
    i51size (cin_ls_workarea, work_len, scr_w);
    WITH field_pos DO
        BEGIN
        screen_part := cin_ls_basic_window;
        sline := header_len + work_len + 2;
        screen_nr := screen_no;
        scol := 1;
        END;
    (*ENDWITH*) 
    i51size (cin_ls_sysline, scr_l, scr_w);
    IF  ( (s30klen (sys_msg, bsp_c1, mxin_screenline)
        <= scr_w - 5)) AND mark1
    THEN
        BEGIN
        lab_mark := 'MARK';
        s10mv (4,mxin_screenline,
              @lab_mark,1,
              @sys_msg,scr_w - 3,4);
        END;
    (*ENDIF*) 
    outscr_trailer (display, cmd, screen_no, current_eform, response );
&   ifdef WINDOWS
    WITH field_pos DO
        BEGIN
        screen_part := cin_ls_basic_window;
        screen_nr := active_screen;
        sline := 0;
        scol := 0;
        END;
    (*ENDWITH*) 
&   endif
    i10insertlabel (field_pos);
    IF  outscreen
    THEN
        BEGIN
        WITH i01g^.vt.opt DO
            BEGIN (* B.M. *)
            IF  response
            THEN
                wait_for_input := true
            ELSE
                wait_for_input := false;
            (*ENDIF*) 
&           ifdef WINDOWS
            usage_mode := vt_edit;
&           else
            IF  (i01g^.set_parms.editor = no_prefix)
            THEN
                BEGIN
                usage_mode      := vt_edit;
                return_on_last  := true;
                END
            ELSE
                BEGIN
                usage_mode      := vt_form;
                return_on_last  := false;
                END;
            (*ENDIF*) 
&           endif
            return_on_first := false;
            returnkeys     := [ ] ;
            reject_keys     := [  ] ;
            (* bell := false; 22.06.93 hb *)
            END;
        (*ENDWITH*) 
&       ifdef WINDOWS
        in10_set_mark ( list_func,
              display.frame [edit.current_eform].upper_margin,
              display.frame [edit.current_eform].left_margin,
              block );
&       endif
        WITH display DO
            i57ioscreen (csr_pos, relkey, screen_changed);
        (*ENDWITH*) 
        error := NOT i01g^.vt.ok;
        IF  relkey = f_local
        THEN
            relkey := f_enter;
        (*ENDIF*) 
        IF  split_screen
        THEN
            active_screen := csr_pos.screen_nr;
        (* ======================================== *)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  outscreen
    THEN
        WITH display, edit DO
            (* =================== *)
            (* reset message lines *)
            (* =================== *)
            BEGIN
            csr_switch   := false;
            insert_mode  := false;
            target_found := false;
            error_found := false;
            msg_id      := ok_msg;
            SAPDB_PascalForcedFill (mxin_screenline, @blankline, 1, mxin_screenline, bsp_c1);
            frame  [1] .sys_msg  := blankline;
            frame  [1] .is_error := false;
            frame  [2] .sys_msg  := blankline;
            frame  [2] .is_error := false;
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      outscr_sform (
            VAR sform   : tin_sform;
            VAR display : tin_display_parms;
            VAR scroll  : tin_display_range;
            VAR edit    : tin_edit_work_area;
            VAR relkey  : tin_ls_releasemode);
 
VAR
      screen_changed : boolean;
      blank_line     : tin_screenline;
 
BEGIN
SAPDB_PascalForcedFill (mxin_screenline, @blank_line, 1, mxin_screenline, bsp_c1);
outscr_header (display, scroll, 1, 1 );
i56putframe (true, true);
;
outscr_slines (sform, edit);
(* outscr_trailer (display, cmd, 1, 1, response ); *)
WITH i01g^.vt.opt DO
    BEGIN (* B.M. *)
    put_label_and_msg ( display, 1, 1, true );
    wait_for_input  := true;
&   ifdef WINDOWS
    usage_mode := vt_edit;
&   else
    IF  (i01g^.set_parms.editor = no_prefix)
    THEN
        BEGIN
        usage_mode      := vt_edit;
        return_on_last  := true;
        END
    ELSE
        BEGIN
        usage_mode      := vt_form;
        return_on_last  := false;
        END;
    (*ENDIF*) 
&   endif
    return_on_first := false;
    returnkeys      := [  ] ;
    reject_keys     := [  ] ;
    (* bell := false; 22.06.93 hb *)
    END;
(*ENDWITH*) 
WITH display DO
    i57ioscreen (csr_pos, relkey, screen_changed);
(*ENDWITH*) 
IF  relkey = f_local
THEN
    relkey := f_enter;
(* ======================================== *)
(*ENDIF*) 
WITH edit DO
    (* ======================= *)
    (* reset control variables *)
    (* ======================= *)
    BEGIN
    csr_switch   := false;
    insert_mode  := false;
    target_found := false;
    error_found := false;
    msg_id      := ok_msg
    END;
(*ENDWITH*) 
WITH display DO
    (* =================== *)
    (* reset message lines *)
    (* =================== *)
    BEGIN
    frame  [1] .sys_msg  := blank_line;
    frame  [1] .is_error := false;
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      outscr_header (
            VAR display   : tin_display_parms;
            VAR scroll    : tin_display_range;
            current_eform : tsp00_Uint1;
            screen_no     : tsp00_Uint1);
 
CONST
      calm_mode = false;
 
VAR
      lab : tsp00_C8;
 
BEGIN
WITH display.frame [ current_eform ] DO
    BEGIN
    i56title (calm_mode, screen_no, header);
    (* =================================== *)
    (* put line numbers of first and last  *)
    (* shown edit line in screen top line  *)
    (* =================================== *)
    lab := bsp_c8;
    i56vrange (screen_no, lab, scroll);
    END;
(*ENDWITH*) 
END; (* outscr_header *)
 
(*------------------------------*) 
 
PROCEDURE
      outscr_elines (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            list_func   : boolean);
 
CONST
      x_text         = ' X-line(s)';
 
VAR
      eline_pos        : tin_ls_position;
      blankline        : tin_screenline;
      slno             : tin_natural;
      this             : tin_natural;
      this_line        : tin_eline;
      first_shown      : tin_natural;
      last_shown       : tin_natural;
      error_mode       : boolean;
      csr_set_mode     : boolean;
      error            : boolean;
      eline_fieldtype  : tin_ls_fieldtype;
      mark_fieldtype   : tin_ls_fieldtype;
      pcol             : tin_prefix_col;
      field10          : tsp00_C10;
      field_x_txt      : tsp00_C10;
      field80          : tin_screenline;
      dark_line        : tin_screenline;
      shown_ecols      : tin_natural;
      length           : tin_natural;
      i                : tin_natural;
      this_prefix      : tin_natural;
      width            : tin_natural;
      prenum           : tin_natural;
      prestr           : tin_prefix_content;
      dstr             : tin_prefix_content;
      is_dark          : boolean;
      dark_count       : tsp00_Int2;
      lower_dark_count : tin_natural;
      new_dark_count   : tsp00_Int2;
 
BEGIN
field_x_txt :=  x_text;
SAPDB_PascalForcedFill (mxin_screenline, @blankline, 1, mxin_screenline, bsp_c1);
SAPDB_PascalForcedFill (mxin_screenline, @dark_line, 1, mxin_screenline, '-');
s10mv (10,mxin_screenline,
      @field_x_txt,1,
      @dark_line,29,10 );
(* ================================================ *)
(* insert mode : cursor is set on first insert line *)
(* error mode : cursor is set on prefix with error  *)
(* ================================================ *)
error_mode := (edit.error_found AND (edit.error_type = cmd_error));
IF  error_mode
THEN
    edit.insert_mode := false;
(*ENDIF*) 
csr_set_mode := (error_mode OR edit.insert_mode) AND
      (display.active_screen = edit.current_eform);
(* ============================================================ *)
(* Wenn this ausgeblendete Zeile ist, dann muss mit der ersten  *)
(* folgenden Zeile begonnen werden, die nicht ausgeblendet ist. *)
(* ============================================================ *)
first_shown := 1;
dark_count := 0;
new_dark_count := 0;
slno := first_shown;
last_shown := edit.lines_on_screen;
lower_dark_count := 0;
&ifdef WINDOWS
this := display.frame [ edit.current_eform] .upper_margin;
&else
IF  i11isdark_ln ( edit.prefix,
    display.frame [edit.current_eform] .upper_margin, slno )
    AND (i01g^.set_parms.editor <> no_prefix)
THEN
    BEGIN
    this := edit.prefix.line [slno] .eline_nr;
    display.frame [ edit.current_eform] .upper_margin :=  this;
    END
ELSE
    this := display.frame [ edit.current_eform] .upper_margin;
(*ENDIF*) 
IF  (i01g^.set_parms.editor <> no_prefix)
THEN
    i11getdark_eline_count ( edit.prefix, 1, this, lower_dark_count );
&endif
(*ENDIF*) 
WHILE  ( slno <= last_shown) DO
    BEGIN
    WITH display.frame [ edit.current_eform] , edit, edit.prefix DO
        BEGIN
        prenum := display.frame [ edit.current_eform] .upper_margin +
              slno - 1;
        IF  prenum > lower_dark_count
        THEN
            prenum := prenum - lower_dark_count;
        (*ENDIF*) 
        this_prefix := 0;
        (* =========================== *)
        (* check if cursor must be set *)
        (* =========================== *)
        IF  csr_set_mode
        THEN
            BEGIN
            IF  (edit.insert_mode AND (edit.insert_line = this))
            THEN
                BEGIN
                display.csr_pos.screen_part := cin_ls_workarea;
                display.csr_pos.sline := slno;
                IF  (insert_scol >= left_margin) AND
                    (insert_scol < left_margin + ecols_on_screen)
                THEN
                    display.csr_pos.scol :=
                          insert_scol + first_edit_scol - left_margin
                ELSE
                    display.csr_pos.scol := edit.first_edit_scol;
                (*ENDIF*) 
                display.csr_pos.screen_nr := edit.screen_no;
                csr_set_mode := false
                END;
            (*ENDIF*) 
            IF  (error_mode AND (edit.error_line = this))
            THEN
                BEGIN
                display.csr_pos.screen_part := cin_ls_workarea;
                display.csr_pos.sline := slno;
&               ifdef WINDOWS
                display.csr_pos.scol := edit.ecols_on_screen;
&               else
                IF  i01g^.set_parms.editor = no_prefix
                THEN
                    display.csr_pos.scol := edit.ecols_on_screen
                ELSE
                    IF  i01g^.set_parms.editor = prefix_left
                    THEN
                        display.csr_pos.scol := 1
                    ELSE
                        display.csr_pos.scol := 1 +
                              edit.ecols_on_screen+1;
                    (*ENDIF*) 
                (*ENDIF*) 
&               endif
                display.csr_pos.screen_nr := edit.screen_no;
                csr_set_mode := false
                END
            (*ENDIF*) 
            END;
        (* ======================================= *)
        (* high intensity if anything is in prefix *)
        (* ======================================= *)
        (*ENDIF*) 
        WITH eline_fieldtype DO
            BEGIN (* B.M. *)
            field_att  := cin_attr1;
            IF  list_func
            THEN
                fieldmode  := [   ]
            ELSE
                fieldmode  := [ ls_input] ;
            (*ENDIF*) 
            IF  display.wrap AND ( slno < last_shown )
            THEN
                fieldmode  := fieldmode + [ ls_continued] ;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
&       ifndef WINDOWS
        IF  NOT list_func AND (i01g^.set_parms.editor <> no_prefix)
        THEN
            BEGIN
            FOR i := 1 TO length DO
                IF  ( line  [i] .eline_nr = this )
                THEN
                    BEGIN
                    this_prefix := i;
                    IF  ( line  [i] .op <> e_dark )
                    THEN
                        eline_fieldtype.field_att := cin_attr2;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDFOR*) 
            END;
&       endif
        (*ENDIF*) 
        IF  this = display.frame [ edit.current_eform] .bright_line
        THEN
            eline_fieldtype.field_att := cin_attr2;
        (* ====================== *)
        (* put edit prefix field  *)
        (* ====================== *)
        (*ENDIF*) 
        i_to_c4 (prenum, prestr);
&       ifndef WINDOWS
        IF  i01g^.set_parms.editor <> no_prefix
        THEN
            FOR pcol := 1 TO mxin_prefix_content DO
                IF  list_func
                THEN
                    field10 [ pcol ] := bsp_c1
                ELSE
                    IF  this_prefix <> 0
                    THEN
                        field10 [ pcol ] := line [ this_prefix] .
                              content [ pcol ]
                    ELSE
                        IF  this =
                            display.frame [ edit.current_eform] .
                            bright_line
                        THEN
                            field10 [ pcol ] := cin_bright_cmd_char
                        ELSE
                            IF  i01g^.set_parms.numeric_prefix
                            THEN
                                field10 [ pcol ] := prestr [ pcol ]
                            ELSE
                                field10 [ pcol ] := cin_eprefix_char;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDFOR*) 
&       endif
        (*ENDIF*) 
        i14geteline (eform, evars, this_line, this, width, error);
        is_dark := false;
        new_dark_count := 0;
&       ifndef WINDOWS
        IF  (i01g^.set_parms.editor <> no_prefix)
        THEN
            BEGIN
            i10_dark_lines ( this, is_dark, new_dark_count, edit );
            new_dark_count := new_dark_count - 1;
            END;
&       endif
        (*ENDIF*) 
        field80 := blankline;
        IF  is_dark
        THEN
            BEGIN
            i_to_c4 (new_dark_count + 1, dstr);
            n_to_bl ( dstr );
            s10mv (4,mxin_screenline,
                  @dstr,1,
                  @dark_line,25,4) ;
            shown_ecols := edit.ecols_on_screen;
            s10mv ( mxin_eline, mxin_screenline, @dark_line, display.
                  frame [ edit.current_eform] .left_margin,
                  @field80, 1, shown_ecols );
            END
        ELSE
            IF  (width >= display.frame [ edit.current_eform] .left_margin)
            THEN
                BEGIN
                IF  (width -
                    display.frame [ edit.current_eform] .left_margin
                    + 1 < edit.ecols_on_screen)
                THEN
                    shown_ecols := (width -
                          display.frame [ edit.current_eform] .
                          left_margin + 1)
                ELSE
                    shown_ecols := edit.ecols_on_screen;
                (*ENDIF*) 
                s10mv (mxin_eline, mxin_screenline, @this_line, display.
                      frame [ edit.current_eform] .left_margin,
                      @field80, 1, shown_ecols)
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        WITH eline_pos DO
            BEGIN
            screen_part := cin_ls_workarea;
            sline := slno;
            screen_nr := edit.screen_no;
            scol := 1;
            END;
        (*ENDWITH*) 
&       ifndef WINDOWS
        IF  i01g^.set_parms.editor = prefix_left
            (* prefix on left side *)
        THEN
            (* prefix *)
            i50put1field (field10, mxin_prefix_content,
                  eline_pos, eline_fieldtype)
                  (* ======================= *)
                  (* put line content field  *)
                  (* ======================= *)
        ELSE
            (* prefix on right side *)
            IF  i01g^.set_parms.editor = prefix_right
            THEN
                BEGIN
                eline_pos.scol := edit.ecols_on_screen + 2;
                i50put1field (field10, mxin_prefix_content,
                      eline_pos, eline_fieldtype);
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  i01g^.set_parms.editor = prefix_left
        THEN
            eline_pos.scol := cin_firsteditscol
        ELSE
            eline_pos.scol := 1;
        (*ENDIF*) 
&       else
        eline_pos.scol := 1;
&       endif
        IF   (this = edit.mark1_line) AND
            (vt_mixed in i01g^.vt.desc.attributes)
        THEN
            eline_fieldtype.fieldmode :=
                  eline_fieldtype.fieldmode + [ ls_mixed ] ;
        (*ENDIF*) 
        IF  is_dark
        THEN
            eline_fieldtype.fieldmode := [  ] ;
        (*ENDIF*) 
        i50put2field (field80, edit.ecols_on_screen,
              eline_pos, eline_fieldtype);
        IF  (this = edit.mark1_line) AND
            (vt_mixed in i01g^.vt.desc.attributes) AND
            (mark1_scol >= left_margin) AND
            (mark1_scol < left_margin + edit.ecols_on_screen)
        THEN
            BEGIN
            WITH eline_pos DO
                scol := scol + mark1_scol - left_margin;
            (*ENDWITH*) 
            mark_fieldtype := eline_fieldtype;
            mark_fieldtype.field_att := cin_attr4;
            i50putattribute (eline_pos, mark_fieldtype);
            END;
        (* ===================== *)
        (* next shown edit line  *)
        (* ===================== *)
        (*ENDIF*) 
        dark_count := dark_count + new_dark_count;
        this := this + 1 + new_dark_count;
        slno := slno + 1;
        (* ===================================================== *)
        (*  this : Zeile im eformbuffer                          *)
        (*  slno : Zeile im editorscreen                         *)
        (*  dark_count : Anzahl der ausgeblendeten Zeilen von    *)
        (*               frame [ ] .upper_margin bis this        *)
        (*  new_dark_count : Anzahl der ausgeblendeten Zeilen    *)
        (*               wenn this erste ausgeblendete Zeile ist *)
        (* ===================================================== *)
        END;
    (*ENDWITH*) 
    END;
(*ENDWHILE*) 
display.frame [ edit.current_eform] .bright_line := 0;
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10_dark_lines (
            this           : tin_natural;
            VAR is_dark    : boolean;
            VAR dark_count : tsp00_Int2;
            VAR edit       : tin_edit_work_area );
 
VAR
      lno      : tin_natural;
      this_lno : tin_natural;
 
BEGIN
WITH edit, edit.prefix DO
    BEGIN
    is_dark    := false;
    dark_count := 1;
    lno        := 1;
    WHILE ( lno <= length )  AND NOT is_dark DO
        BEGIN
        WITH line [ lno ] DO
            IF  ( op = e_dark ) AND ( eline_nr = this )
            THEN
                BEGIN (* this is dark line *)
                this_lno   := lno;
                is_dark    := true;
                dark_count := arg;
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
        lno := lno + 1;
        END;
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      outscr_slines (
            VAR sform   : tin_sform;
            VAR edit    : tin_edit_work_area);
 
VAR
      scol            : tin_natural;
      line            : tin_natural;
      sline_fieldtype : tin_ls_fieldtype;
      sline_pos       : tin_ls_position;
 
BEGIN
WITH sline_pos DO
    BEGIN
    screen_part := cin_ls_workarea;
    scol := 1;
    screen_nr := 1;
    END;
(*ENDWITH*) 
WITH sline_fieldtype DO
    BEGIN (* B.M. *)
    field_att  := cin_attr1;
    fieldmode  := [  ] ;
    END;
(*ENDWITH*) 
(* ======================= *)
(* put line content field  *)
(* ======================= *)
FOR line := 1 TO edit.lines_on_screen DO
    BEGIN
    sline_pos.sline := line;
    i50put5field (sform [ line] , edit.cols_on_screen,
          sline_pos, sline_fieldtype);
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      put_label_and_msg (
            VAR display    : tin_display_parms;
            current_eform  : tsp00_Uint1 ;
            screen_no      : tsp00_Uint1;
            response       : boolean );
 
VAR
      field_type : tin_ls_fieldtype;
      field_pos  : tin_ls_position;
      scr_l      : tin_natural;
      scr_w      : tin_natural;
      length     : tin_natural;
 
BEGIN
IF  response
THEN (* B.M. Rel 3.0.0C 3 Jun 1991 *)
    i56putlabels (f_clear, false)
ELSE
    i50clear (cin_ls_functionmenu );
(*ENDIF*) 
(* ======================= *)
(* put message text lines  *)
(* ======================= *)
WITH field_pos DO
    BEGIN
    screen_part := cin_ls_sysline;
    sline := 1;
    scol := 1;
    screen_nr := screen_no;
    END;
(*ENDWITH*) 
WITH field_type DO
    BEGIN (* B.M. *)
    field_att  := cin_attr5;
    fieldmode  := [  ] ;
    END;
(*ENDWITH*) 
i51size (cin_ls_sysline, scr_l, scr_w);
IF  scr_l > 1
THEN
    BEGIN
    (* WINDOWS : Hier wird eine 2. Zeile in den Bildschirmbereich
          sysline ausgegeben. Muss fuer WINDOWS ausgeklammert werden. *)
&   ifndef WINDOWS
    i50put2field (display.frame [ current_eform] .info_msg, scr_w,
          field_pos, field_type);
&   endif
    field_pos.sline := 2;
    END;
(*ENDIF*) 
WITH display.frame [current_eform] DO
    BEGIN
    length := s30klen (sys_msg, bsp_c1, mxin_screenline);
    IF  is_error
    THEN
        i56errormessage (screen_no, sys_msg, length)
    ELSE
        BEGIN
        IF  scr_w > length
        THEN
            SAPDB_PascalForcedFill (mxin_screenline, @sys_msg, length+1,
                  scr_w-length, bsp_c1 );
        (*ENDIF*) 
        i50put2field (sys_msg, scr_w, field_pos, field_type);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      outscr_trailer (
            VAR display   : tin_display_parms;
            VAR cmd       : tin_cmd_type;
            screen_no     : tsp00_Uint1;
            current_eform : tsp00_Uint1 ;
            response      : boolean ); (* B.M. Rel 3.0.0C 3 Jun 1991 *)
 
VAR
      field_type : tin_ls_fieldtype;
      field_pos  : tin_ls_position;
      field10    : tsp00_C10;
      field80    : tin_screenline;
      scr_w      : tin_natural;
      scr_l      : tin_natural;
      i          : tin_natural;
      scol       : tin_natural;
      with_input : boolean;
 
BEGIN
put_label_and_msg ( display, current_eform, screen_no, response );
IF  response
THEN
    BEGIN
    (* ================= *)
    (* put command line  *)
    (* ================= *)
    i51size (cin_ls_inputarea, scr_l, scr_w);
&   ifdef WINDOWS
    with_input := (f_cmd in i01g^.key_type.activated);
&   else
    with_input := ((scr_l <> 0) AND (scr_w <> 0));
&   endif
    IF  with_input
    THEN
        BEGIN
        field10 := '===>      ';
        WITH field_type DO
            BEGIN (* B.M. *)
            field_att  := cin_attr1;
            fieldmode  := [  ] ;
            END;
        (*ENDWITH*) 
        WITH field_pos DO
            BEGIN
            screen_part := cin_ls_inputarea;
            sline := 1;
            scol := 1;
            screen_nr := screen_no;
            END;
        (*ENDWITH*) 
        i50put1field (field10, 4, field_pos, field_type);
        IF  ( cmd.length > 0 )
        THEN
            FOR i := 1 TO cmd.length DO
                field80  [i]  := cmd.content  [i] ;
            (*ENDFOR*) 
        (*ENDIF*) 
        IF  ( cmd.length < mxin_screenline )
        THEN
            FOR i := cmd.length+1 TO mxin_screenline DO
                field80  [i]  := bsp_c1;
            (*ENDFOR*) 
        (* IF  current_eform <> display.active_screen THEN
              FOR i := 1  TO mxin_screenline DO
              field80  [i]  := bsp_c1; *)
        (*ENDIF*) 
        field_pos.scol := cin_ocmd_scol;
        field_type.fieldmode := [ ls_input] ;
        i50put2field (field80, scr_w - cin_ocmd_scol + 1,
              field_pos, field_type);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      inscreen_lform (
            VAR display : tin_display_parms;
            VAR cmd     : tin_cmd_type;
            VAR relkey  : tin_ls_releasemode);
 
BEGIN
(* ==================================== *)
(* read relkey  and cmd-line           *)
(* ==================================== *)
IF   relkey <> f_clear
THEN
    inscreen_commandline (cmd, display.active_screen);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      inscreen_eform (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            VAR cmd     : tin_cmd_type;
            VAR relkey  : tin_ls_releasemode;
            VAR error   : boolean;
            VAR block   : tin_ed_winmark_type );
 
BEGIN
(* ==================================== *)
(*       read screen and relkey         *)
(* ==================================== *)
error := false;
IF  relkey <> f_clear
THEN
    BEGIN
    edit.csr_set_by_user := true;
    (* ================================ *)
    (*      read complete edit form     *)
    (* ================================ *)
&   ifndef WINDOWS
    IF  i01g^.set_parms.editor <> no_prefix
    THEN
        inscreen_prefix (edit.prefix, display, edit);
&   endif
    (*ENDIF*) 
    inscreen_elines (eform, evars, display, edit, error);
    IF  error
    THEN
        IF  edit.double_edit
        THEN
            i11message ( eform_overflow,
                  display.frame [ edit.screen_no] .sys_msg,
                  display.frame [ edit.screen_no] .is_error)
        ELSE
            i11message ( eform_overflow,
                  display.frame [ display.active_screen] .sys_msg,
                  display.frame [ display.active_screen] .is_error);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  NOT ( (display.active_screen <> edit.current_eform)
        AND NOT edit.double_edit)
    THEN
        inscreen_commandline (cmd, edit.screen_no);
    (*ENDIF*) 
    i14setuplinecount (eform, evars);
&   ifdef WINDOWS
    in10_get_mark (display.frame [edit.current_eform].upper_margin,
          display.frame [edit.current_eform].left_margin,
          block);
&   endif
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      inscreen_prefix (
            VAR prefix  : tin_prefix_type;
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area);
 
VAR
      input_field      : tin_ls_input_field;
      field_found      : boolean;
      error            : boolean;
      first_window_pos : tin_ls_position;
      pcol             : tin_prefix_col;
      this             : tin_natural;
      edtscrn_lno      : tin_natural;
      window_width     : integer;
      window_changed   : boolean;
      this_prefix      : tin_prefix_content;
      prenum           : tin_prefix_content;
      dark_count       : tin_natural;
 
BEGIN
WITH first_window_pos DO
    BEGIN
    error := false;
    screen_part := cin_ls_workarea;
    screen_nr := edit.screen_no;
    sline := 1;
&   ifdef WINDOWS
    scol := edit.ecols_on_screen + 2;
&   else
    IF  i01g^.set_parms.editor = prefix_left
    THEN
        scol := 1
    ELSE
        scol := edit.ecols_on_screen + 2;
    (*ENDIF*) 
&   endif
    window_width := mxin_prefix_content;
    END;
(*ENDWITH*) 
i50getwindow (first_window_pos, 999, window_width, window_changed);
this := display.frame [ edit.current_eform] .upper_margin;
dark_count := 0;
i11getdark_eline_count ( edit.prefix, 1, this, dark_count );
IF  this > dark_count
THEN
    edtscrn_lno  := this - dark_count
ELSE
    edtscrn_lno := this;
(*ENDIF*) 
IF  window_changed
THEN
    BEGIN
    REPEAT
        (* ================================== *)
        (* copy read prefix on edit form line *)
        (* ================================== *)
        i50getfield (input_field, field_found);
        IF  field_found
        THEN
            BEGIN
            i_to_c4 ( edtscrn_lno, prenum);
            FOR pcol := 1 TO mxin_prefix_content DO
                IF  pcol <= input_field.len
                THEN
                    IF  (input_field.buf [ pcol ] = prenum [ pcol] ) AND
                        i01g^.set_parms.numeric_prefix
                    THEN
                        this_prefix [ pcol ] := cin_eprefix_char
                    ELSE
                        this_prefix [ pcol ] := input_field.buf [ pcol ]
                    (*ENDIF*) 
                ELSE
                    this_prefix [ pcol ] := cin_eprefix_char;
                (*ENDIF*) 
            (*ENDFOR*) 
            IF  this_prefix <> cin_bright_cmd
            THEN
                BEGIN
                put_prefix (prefix, this_prefix, this, edit.screen_no,
                      input_field.changed, error);
                IF  error
                THEN
                    edit.error_line := edtscrn_lno;
                (*ENDIF*) 
                dark_count := 0;
                get_dark_count ( prefix, this, dark_count );
                this := this + dark_count;
                END;
            (*ENDIF*) 
            this := this + 1;
            edtscrn_lno := edtscrn_lno + 1;
            END;
        (*ENDIF*) 
    UNTIL
        NOT field_found;
    (*ENDREPEAT*) 
    IF  error
    THEN
        BEGIN
        edit.error_type := cmd_error;
        edit.csr_switch := false;
        WITH display DO
            i11message ( prefix_overflow, frame [ active_screen] .sys_msg,
                  frame [ active_screen] .is_error );
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    i11sortprefix (prefix);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      get_dark_count (
            VAR prefix     : tin_prefix_type;
            this           : tin_natural;
            VAR dark_count : tin_natural );
 
VAR
      i : integer;
 
BEGIN
WITH prefix DO
    BEGIN
    FOR i := 1 TO length DO
        BEGIN
        IF  ( line [i] .op = e_dark ) AND
            ( line [i] .eline_nr = this )
        THEN
            BEGIN
            dark_count := dark_count + line [i] .arg - 1;
            END;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      inscreen_elines (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            VAR error   : boolean);
 
VAR
      input_field      : tin_ls_input_field;
      field_found      : boolean;
      width            : tin_natural;
      width_found      : boolean;
      first_window_pos : tin_ls_position;
      window_width     : integer;
      this             : tin_natural;
      this_line        : tin_eline;
      changed          : boolean;
      slno             : tin_natural;
 
BEGIN
error := false;
WITH first_window_pos DO
    BEGIN
    screen_part := cin_ls_workarea;
    sline := 1;
    screen_nr := edit.screen_no;
    scol := edit.first_edit_scol;
    window_width := edit.ecols_on_screen;
    END;
(*ENDWITH*) 
i50getwindow (first_window_pos, 999, window_width, changed);
display.changed := display.changed OR changed;
(* =================================== *)
(* read line content field from screen *)
(* an copy content on this eform line  *)
(* =================================== *)
IF  changed
THEN
    BEGIN
    IF  i11isdark_ln ( edit.prefix,
        display.frame [edit.current_eform] .upper_margin, slno )
    THEN
        this := edit.prefix.line [slno] .eline_nr +
              edit.prefix.line [slno] .arg
    ELSE
        this := display.frame [ edit.current_eform] .upper_margin;
    (*ENDIF*) 
    WITH display.frame [ edit.current_eform] , input_field DO
        REPEAT
            i50getfield (input_field, field_found);
            IF  field_found
            THEN
                BEGIN
                i14geteline (eform, evars, this_line, this, width,error);
                IF  width < mxin_eline
                THEN
                    SAPDB_PascalForcedFill (mxin_eline, @this_line, width + 1,
                          mxin_eline - width, bsp_c1);
                (*ENDIF*) 
                s10mv (mxin_screenline,mxin_eline,
                      @buf,1,
                      @this_line,left_margin,len);
                SAPDB_PascalForcedFill (mxin_eline, @this_line, left_margin + len,
                      edit.ecols_on_screen - len, bsp_c1);
                (* ============================ *)
                (* adjust new edit line width   *)
                (* ============================ *)
                width := mxin_eline;
                width_found := false;
                REPEAT
                    IF  ( this_line [ width ] <> bsp_c1 )
                    THEN
                        width_found := true
                    ELSE
                        width := width - 1
                    (*ENDIF*) 
                UNTIL
                    ( width_found OR ( width = 0) );
                (*ENDREPEAT*) 
                i14puteline (eform, evars, this_line,
                      this, width, error);
                this := this + 1;
                IF  i11isdark_ln ( edit.prefix, this + 1, slno )
                THEN
                    this := edit.prefix.line [slno] .eline_nr +
                          edit.prefix.line [slno] .arg;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            NOT field_found OR error;
        (*ENDREPEAT*) 
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      inscreen_commandline (
            VAR cmd   : tin_cmd_type;
            screen_no : tsp00_Uint1);
 
VAR
      scr_w, scr_l     : tin_natural;
      blk_only         : boolean;
      input_field      : tin_ls_input_field;
      field_found      : boolean;
      first_window_pos : tin_ls_position;
      window_changed   : boolean;
      i                : integer;
 
BEGIN
(* ========================================= *)
(* copy command line input on command buffer *)
(* ========================================= *)
i51size (cin_ls_inputarea, scr_l, scr_w);
IF  (scr_l = 0) AND (scr_w =0)
THEN
    cmd.length := 0
ELSE
    BEGIN
    WITH first_window_pos DO
        BEGIN
        screen_part := cin_ls_inputarea;
        screen_nr := screen_no;
        sline := 1;
        scol := 1;
        END;
    (*ENDWITH*) 
    i50getwindow (first_window_pos, 999, 999, window_changed);
    i50getfield (input_field, field_found);
    IF  field_found
    THEN
        WITH cmd DO
            BEGIN
            IF  (input_field.len <= mxin_screenline)
            THEN
                length := input_field.len
            ELSE
                length := 0;
            (*ENDIF*) 
            blk_only := true;
            IF  (length >  0)
                (*p1*)
            THEN
                BEGIN
                FOR i := 1 TO length
                      DO
                    BEGIN
                    cmd.content  [i]  := input_field.buf  [i] ;
                    IF  cmd.content  [i]  <> bsp_c1
                    THEN
                        blk_only := false;
                    (*ENDIF*) 
                    END;
                (*ENDFOR*) 
                IF  blk_only
                THEN
                    length := 0;
                (*ENDIF*) 
                END;
            (*p1*)
            (*  cmd.content  [i]  := input_field.buf  [i] ;  *)
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    ELSE
        cmd.length := 0;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      put_prefix (
            VAR prefix  : tin_prefix_type;
            this_prefix : tin_prefix_content;
            this        : tin_natural;
            screen_no   : tsp00_Uint1;
            changed     : boolean;
            VAR error   : boolean );
 
VAR
      found : boolean;
      i     : tin_natural;
 
BEGIN
i := 1;
found := false;
IF  prefix.length > 0
THEN
    REPEAT
        IF  prefix.line  [i] .eline_nr = this
        THEN
            BEGIN
            IF  changed
                (* IF  (screen_no = 1) OR (screen_no = 2) AND
                      double_edit OR (screen_no = 2) AND
                      (this_prefix <> cin_eprefix) AND NOT double_edit *)
            THEN
                prefix.line  [i] .content := this_prefix;
            (*ENDIF*) 
            found := true;
            END;
        (*ENDIF*) 
        i := i + 1;
    UNTIL
        found OR (i > prefix.length);
    (*ENDREPEAT*) 
(*ENDIF*) 
IF  NOT found AND (this_prefix <> cin_eprefix)
THEN
    BEGIN
    prefix.length := prefix.length + 1;
    IF  prefix.length <= mxin_prefix
    THEN
        BEGIN
        prefix.line [ prefix.length] .content := this_prefix;
        prefix.line [ prefix.length] .eline_nr := this;
        prefix.line [ prefix.length] .arg      := 1;
        END
    ELSE
        BEGIN
        prefix.length := prefix.length - 1;
        error := true;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      analyze_eprefix (
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area);
 
VAR
      this   : tin_natural;
      finish : boolean;
 
BEGIN
(* ===================================================== *)
(* inspect prefix from all edit lines beginning with top *)
(* ===================================================== *)
this := 1;
finish := false;
IF  edit.prefix.length > 0
THEN
    REPEAT
        WITH edit.prefix.line [ this ] DO
            BEGIN
            IF  content = cin_eprefix
            THEN
                BEGIN
                IF  op <> e_dark
                THEN
                    BEGIN
                    op := e_no_cmd;
                    END;
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                setup_prefix (content);
                IF  op = e_dark
                THEN
                    BEGIN
                    CASE content  [1]  OF
                        'S':
                            op := e_visible;
                        OTHERWISE:
                            edit.error_found := true;
                        END;
                    (*ENDCASE*) 
                    END
                ELSE
                    BEGIN
                    CASE content  [1]  OF
                        cin_eprefix_char :
                            op := e_no_cmd;
                        'I':
                            op := e_ins;
                        'A':
                            op := e_ins;
                        'D':
                            op := e_del;
                        '"':
                            op := e_dupl;
                        '>':
                            op := e_rshift;
                        '<':
                            op := e_lshift;
                        'C':
                            op := e_copy;
                        'M':
                            op := e_move;
                        'F':
                            op := e_ftarget;
                        'P':
                            op := e_ptarget;
                        '/':
                            op := e_center;
                        'X':
                            op := e_dark;
                        OTHERWISE:
                            BEGIN
                            IF  is_error_no (content)
                            THEN
                                op := e_no_cmd
                            ELSE
                                op := e_illegal_cmd
                            (*ENDIF*) 
                            END
                        END;
                    (*ENDCASE*) 
                    END;
                (*ENDIF*) 
                CASE op OF
                    e_no_cmd :
                        (* only blanks found in prefix *)
                        ;
                    e_illegal_cmd :
                        edit.error_found := true;
                    OTHERWISE:
                        BEGIN
                        (*  edit.csr_switch := false; *)
                        inspect_rest (edit, this)
                        END
                    END
                (*ENDCASE*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        IF  edit.error_found OR (this = edit.prefix.length)
        THEN
            finish := true
        ELSE
            (* =================== *)
            (* inspect next prefix *)
            (* =================== *)
            this  := this + 1
        (*ENDIF*) 
    UNTIL
        finish;
    (*ENDREPEAT*) 
(*ENDIF*) 
IF  edit.error_found
THEN
    BEGIN
    edit.error_line := edit.prefix.line [ this] .eline_nr;
    edit.error_type := cmd_error;
    edit.csr_switch := false;
    WITH display DO
        IF  edit.double_edit
        THEN
            i11message (unknown_ecmd,
                  frame [ edit.screen_no] .sys_msg,
                  frame [ edit.screen_no] .is_error)
        ELSE
            i11message (unknown_ecmd,
                  frame [ active_screen] .sys_msg,
                  frame [ active_screen] .is_error);
        (*ENDIF*) 
    (*ENDWITH*) 
    WITH edit.prefix.line [ this ] DO
        BEGIN
        IF  op <> e_dark
        THEN
            BEGIN
            op := e_no_cmd;
            block_cmd := false;
            arg := 1
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      setup_prefix (
            VAR prefix : tin_prefix_content);
 
VAR
      pcol       : tin_prefix_col;
      n_pcol     : 0..mxin_prefix_content;
      prefix_buf : tin_prefix_content;
 
BEGIN
prefix_buf := prefix;
prefix := cin_eprefix;
n_pcol := 0;
FOR pcol := 1 TO mxin_prefix_content DO
    IF  NOT ( prefix_buf [ pcol ] IN
        [  cin_eprefix_char, bsp_c1, cin_bright_cmd_char  ] )
    THEN
        BEGIN
        n_pcol := n_pcol + 1;
        CASE prefix_buf [ pcol ] OF
            'i' :
                prefix [ n_pcol ] := 'I';
            'a' :
                prefix [ n_pcol ] := 'A';
            'd' :
                prefix [ n_pcol ] := 'D';
            'c' :
                prefix [ n_pcol ] := 'C';
            'm' :
                prefix [ n_pcol ] := 'M';
            'f' :
                prefix [ n_pcol ] := 'F';
            'p' :
                prefix [ n_pcol ] := 'P';
            'x' :
                prefix [ n_pcol ] := 'X';
            's' :
                prefix [ n_pcol ] := 'S';
            OTHERWISE:
                prefix [ n_pcol ] := prefix_buf [ pcol ]
            END
        (*ENDCASE*) 
        END
    (*ENDIF*) 
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      inspect_rest (
            VAR edit : tin_edit_work_area;
            this     : tin_natural);
 
BEGIN
WITH edit.prefix.line [ this ] DO
    CASE op OF
        e_ftarget, e_ptarget, e_center :
            IF  ( (content  [2]  <> cin_eprefix_char)
                OR (content  [3]  <> cin_eprefix_char)
                OR (content  [4]  <> cin_eprefix_char) )
            THEN
                edit.error_found := true;
            (*ENDIF*) 
        e_ins :
            inspect_line_arg (edit, this);
        OTHERWISE (* is it a line or a block command *)
            BEGIN
            IF  ( content  [1]  <> cin_eprefix_char )
            THEN
                block_cmd := ( content  [2]  = content  [1]  );
            (*ENDIF*) 
            IF  block_cmd
            THEN
                inspect_block_arg (edit, this)
            ELSE
                inspect_line_arg (edit, this);
            (*ENDIF*) 
            END;
        END;
    (*ENDCASE*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      inspect_line_arg (
            VAR edit : tin_edit_work_area;
            this     : tin_natural);
 
VAR
      dark_arg : tin_natural;
 
BEGIN
WITH edit, edit.prefix.line [ this ] DO
    IF  ( ( content  [2]  = cin_eprefix_char ) AND
        ( content  [3]  = cin_eprefix_char )
        AND ( content  [4]  = cin_eprefix_char ) )
    THEN
        BEGIN
        IF  op <> e_dark
        THEN
            arg := 1;
        (*ENDIF*) 
        END
    ELSE
        CASE op OF
            e_ins, e_del, e_dupl, e_lshift,
            e_dark, e_rshift, e_copy, e_move:
                BEGIN
                get_arg ( edit, this );
                END;
            e_visible :
                BEGIN
                dark_arg := arg;
                IF  content  [2]  = '-'
                THEN
                    BEGIN
                    content  [2]  := content  [3] ;
                    content  [3]  := content  [4] ;
                    content  [4]  := cin_eprefix_char;
                    get_arg ( edit, this );
                    IF  arg > dark_arg
                    THEN
                        arg := 0
                    ELSE
                        BEGIN
                        op := e_dark;
                        arg := dark_arg - arg;
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    get_arg ( edit, this );
                    IF  arg > dark_arg
                    THEN
                        arg := 0
                    ELSE
                        BEGIN
                        eline_nr := eline_nr + arg;
                        op := e_dark;
                        arg := dark_arg - arg;
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            OTHERWISE (* e_copy, e_move *)
                error_found := true
            END
        (*ENDCASE*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      get_arg (
            VAR edit : tin_edit_work_area;
            this     : tin_natural);
 
BEGIN
WITH edit, edit.prefix.line [ this ] DO
    BEGIN
    IF  content  [2]  in [  '1'..'9'  ]
    THEN
        BEGIN
        arg := digit ( content  [2]  );
        IF  content  [3]  in [  '0'..'9'  ]
        THEN
            BEGIN
            arg := 10*arg + digit ( content  [3]  );
            IF  content  [4]  in [  '0'..'9'  ]
            THEN
                arg := 10*arg + digit ( content  [4]  )
            ELSE
                error_found := (content  [4] <>cin_eprefix_char)
            (*ENDIF*) 
            END
        ELSE
            error_found := (content  [3] <>cin_eprefix_char)
        (*ENDIF*) 
        END
    ELSE
        error_found := (content  [2] <>cin_eprefix_char)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      inspect_block_arg (
            VAR edit : tin_edit_work_area;
            this     : tin_natural);
 
VAR
      cont :     tin_prefix_content;
 
BEGIN
WITH edit, edit.prefix.line [ this ] DO
    CASE op OF
        e_lshift, e_rshift, e_dupl, e_copy :
            BEGIN
            IF  ( content  [3]  = cin_eprefix_char )
            THEN
                arg := 1
            ELSE
                BEGIN
                cont := content;
                content  [2]  := content  [3] ;
                content  [3]  := content  [4] ;
                content  [4]  := cin_eprefix_char;
                get_arg ( edit, this );
                content := cont;
                END;
            (*ENDIF*) 
            END;
        OTHERWISE (* e_del, e_dupl, e_copy, e_move *)
            error_found := (content  [3]  <> cin_eprefix_char)
        END
    (*ENDCASE*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      is_error_no (
            VAR prefix : tin_prefix_content) : boolean;
 
VAR
      i       : 0..mxin_prefix_content;
      numeric : boolean;
 
BEGIN
i := 0;
REPEAT
    i := i + 1;
    numeric := ( prefix  [i]  IN [ '0'..'9' ] );
UNTIL
    ( (i=mxin_prefix_content) OR NOT numeric );
(*ENDREPEAT*) 
is_error_no := numeric;
END;
 
(*------------------------------*) 
 
PROCEDURE
      error_presentation (
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area);
 
VAR
      back_scroll : tin_natural;
 
BEGIN
CASE edit.error_type OF
    relkey_error:
        (* ============================== *)
        (* cursor switch to command line  *)
        (* ============================== *)
        WITH display.csr_pos DO
            BEGIN
            screen_part := cin_ls_inputarea;
            sline := 1;
            scol := cin_ocmd_scol;
            screen_nr := edit.screen_no;
            END;
        (*ENDWITH*) 
    cmd_error:
        (* ===================================== *)
        (* center line with error on screen      *)
        (* ===================================== *)
        WITH display.frame [ edit.current_eform ] DO
            BEGIN
            upper_margin := edit.error_line;
            back_scroll := edit.lines_on_screen DIV 2;
            (* b) center error line by scroll back *)
            WHILE (back_scroll > 0) AND (upper_margin > 1) DO
                BEGIN
                upper_margin := upper_margin - 1;
                back_scroll := back_scroll - 1;
                END;
            (*ENDWHILE*) 
            END;
        (*ENDWITH*) 
    ocmd_error:
        WITH display.csr_pos DO
            BEGIN
            screen_part := cin_ls_inputarea;
            sline := 1;
            IF  scol > edit.cols_on_screen
            THEN
                scol := edit.cols_on_screen;
            (*ENDIF*) 
            screen_nr := edit.screen_no;
            END;
        (*ENDWITH*) 
    END
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      cursor_switch (
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area);
 
BEGIN
WITH display, edit, csr_pos DO
    BEGIN
    screen_part := cin_ls_inputarea;
    sline := 1;
    scol := cin_ocmd_scol;
    screen_nr := edit.screen_no;
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10_set_cursor (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area);
 
VAR
      this     : tin_natural;
      csr_line : tin_natural;
      i        : tin_natural;
 
BEGIN
WITH display, display.csr_pos, edit DO
    WITH frame [ active_screen ] DO
        BEGIN
        screen_nr := screen_no;
        (* ========================================== *)
        (* cursor is set on first shown empty line    *)
        (* or on command line, if no empty line found *)
        (* ========================================== *)
        IF  (mark1_line >= upper_margin) AND
            (mark1_line < upper_margin +
            lines_on_screen) AND
            (mark1_scol >= left_margin) AND
            (mark1_scol < left_margin + ecols_on_screen)
        THEN
            BEGIN
            screen_part := cin_ls_workarea;
            sline := mark1_line - upper_margin + 1;
            scol := mark1_scol + first_edit_scol - left_margin;
            END
        ELSE
            BEGIN
            this := upper_margin;
            csr_line := 0;
            FOR i := 1 TO lines_on_screen DO
                BEGIN
                IF  i14linelength (eform, evars, this) > 0
                THEN
                    csr_line := i;
                (*ENDIF*) 
                IF  ( i < lines_on_screen )
                THEN
                    this := this + 1;
                (*ENDIF*) 
                END;
            (*ENDFOR*) 
            IF  ( csr_line < lines_on_screen )
            THEN
                BEGIN
                screen_part := cin_ls_workarea;
                sline := csr_line + 1;
                scol := edit.first_edit_scol;
                END
            ELSE
                BEGIN
                (*  h.b. 21.12.1993 auf Wunsch
                      screen_part := cin_ls_inputarea;
                      sline := 1;
                      scol := edit.first_edit_scol;
                      *)
                screen_part := cin_ls_workarea;
                sline := 1;
                scol := edit.first_edit_scol;
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  mark1
        THEN
            BEGIN
            mark2_line := 0;
            mark2_scol := 0;
            END
        ELSE
            BEGIN
            mark1_line := 0;
            mark1_scol := 0;
            mark2_line := 0;
            mark2_scol := 0;
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      digit (
            c : char) : tin_natural;
 
BEGIN
digit := ( ord (c) - ord ('0') )
END;
 
(*------------------------------*) 
 
PROCEDURE
      n_to_bl (
            VAR c4 : tin_prefix_content);
 
VAR
      pos  : tsp00_Int2;
      succ : boolean;
 
BEGIN
succ := false;
pos := 1;
REPEAT
    IF  c4 [ pos ] = '0'
    THEN
        c4 [ pos ] := bsp_c1
    ELSE
        succ := true;
    (*ENDIF*) 
    pos := pos + 1;
UNTIL
    ( pos = 4 ) OR succ;
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i_to_c4 (
            i      : tin_natural;
            VAR c4 : tin_prefix_content);
 
VAR
      base : tin_natural;
      pos  : tsp00_Int2;
 
BEGIN
base := ord ('0');
pos := 4;
REPEAT
    c4 [ pos ] :=  chr (s20int4_to_int2 (base + (i MOD 10)));
    i := i DIV 10;
    pos := pos - 1;
UNTIL
    pos = 0;
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i_to_c6 (
            i      : tsp00_Int4;
            VAR c6 : tin_erg_no);
 
VAR
      base : tin_natural;
      pos  : tsp00_Int2;
 
BEGIN
base := ord ('0');
pos := 6;
REPEAT
    c6 [ pos ] :=  chr (s20int4_to_int2 (base + (i MOD 10)));
    i := i DIV 10;
    pos := pos - 1;
UNTIL
    pos = 0;
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      scroll_forward (
            VAR display : tin_display_parms;
            VAR evars   : tin_eform_vars;
            VAR edit    : tin_edit_work_area);
 
VAR
      scroll_amount : tin_natural;
      first_shown   : tin_natural;
      last_shown    : tin_natural;
      count         : tin_natural;
 
BEGIN
(* ==================== *)
(* adjust scroll amount *)
(* ==================== *)
first_shown := 1;
last_shown := edit.lines_on_screen;
scroll_amount := edit.lines_on_screen - 1;
WITH display, edit DO
    WITH frame [ active_screen ] DO
        (* =============================== *)
        (* adjust new upper margin (count) *)
        (* =============================== *)
        BEGIN
        count := 0;
        WHILE (count < scroll_amount) AND
              ( (upper_margin + lines_on_screen) <=
              evars.lines) DO
            BEGIN
            count := count + 1;
            upper_margin := upper_margin + 1;
            END;
        (*ENDWHILE*) 
        IF  (count < scroll_amount)
        THEN
            i11message (bottom_reached, sys_msg, is_error)
        ELSE
            IF  edit.msg_id in [ top_reached, bottom_reached ]
            THEN
                i11message (ok_msg, sys_msg, is_error);
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      update_keys (
            VAR active_keys : tin_ls_key_set );
 
VAR
      f    : tin_prog_function;
 
BEGIN
active_keys := i01g^.key_type.activated -
      [  f_help, f7, f9, f1, f6, f2, f_end, f_exit ] ;
FOR f := f1 TO f_down DO
    BEGIN
    IF  (  [f]  * active_keys <> [ ] ) AND
        (i01g^.key_type.key_labels  [f]  <> '        ')
    THEN
        active_keys := active_keys -  [f] ;
    (*ENDIF*) 
    END;
(*ENDFOR*) 
set_key_labels ( active_keys );
END;
 
(*------------------------------*) 
 
PROCEDURE
      set_key_labels (
            VAR active_keys : tin_ls_key_set );
 
VAR
      lab  : tin_ls_sk_label;
      j    : tsp00_Uint1;
      f    : tin_prog_function;
      msg  : tin_screenline;
      err  : boolean;
 
BEGIN
(* f_up und f_down durch f11 (PICK) und f12 (PUT) ersetzt *)
(* E.Stils 7.4.1993                                       *)
i11message (default_pf, msg, err);
j := 1;
FOR f := f3 TO f12 DO
    BEGIN
    IF  ( f IN [  f3, f4, f5, f8, f11, f12 ] )
    THEN
        BEGIN
        IF  ( f IN [  f3, f11, f12 ] )
        THEN
            BEGIN
            IF  i11keychange AND ( f in [ f3, f11, f12 ] )
            THEN
                BEGIN
                j := j + csp_lslabel;
                s10mv (mxin_screenline,csp_lslabel,
                      @msg,j,
                      @lab,1,csp_lslabel );
                j := j + csp_lslabel;
                END
            ELSE
                BEGIN
                s10mv (mxin_screenline,csp_lslabel,
                      @msg,j,
                      @lab,1,csp_lslabel );
                j := j + 2 * csp_lslabel;
                END;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            s10mv (mxin_screenline,csp_lslabel,
                  @msg,j,
                  @lab,1,csp_lslabel );
            j := j + csp_lslabel;
            END;
        (*ENDIF*) 
        IF  (  [f]  * active_keys <> [ ] )
        THEN
            i01g^.key_type.key_labels  [f]  := lab;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      set_up_down_keys;
 
BEGIN
WITH i01g^, i01g^.key_type DO
    BEGIN
    activated := activated + [ f11, f12 ];
    IF  (vt_down_key in vt.desc.returnkeys)
        AND (set_parms.editor <> no_prefix)
    THEN
        activated := activated - [ f11 ];
    (*ENDIF*) 
    IF  (vt_up_key in vt.desc.returnkeys)
        AND (set_parms.editor <> no_prefix)
    THEN
        activated := activated - [ f12 ];
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      set_left_right_spj_keys (
            VAR display     : tin_display_parms;
            VAR edit        : tin_edit_work_area;
            VAR active_keys : tin_ls_key_set;
            l_key           : boolean;
            r_key           : boolean;
            spj_key         : boolean;
            label_upd       : boolean);
 
BEGIN
WITH i01g^.key_type, display, frame [ active_screen ] DO
    IF  i20dbok
    THEN
        BEGIN
        activated := activated + [ f_left, f_right ];
&       ifndef WINDOWS
        IF  r_key
        THEN
            activated := activated + [f5] ;
        (*ENDIF*) 
        IF  l_key
        THEN
            activated := activated + [f4] ;
&       endif
        (*ENDIF*) 
        IF  (left_margin + edit.ecols_on_screen >= max_cols + 1)
        THEN
            BEGIN
            activated := activated - [ f_right] ;
&           ifndef WINDOWS
            IF  r_key
            THEN
                activated := activated -  [f5] ;
&           endif
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (left_margin = 1)
        THEN
            BEGIN
            activated := activated - [ f_left] ;
&           ifndef WINDOWS
            IF  l_key
            THEN
                activated := activated -  [f4] ;
&           endif
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  spj_key
        THEN
            activated := activated +  [f3] ;
        (*ENDIF*) 
        IF  label_upd
        THEN
            set_key_labels ( active_keys );
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      init_screen (
            VAR display : tin_display_parms);
 
CONST
      functionmenu_length  =  1;
      inputarea_length     =  1;
 
VAR
      window     : tin_screen_window;
      ok         : boolean;
      set_win    : boolean;
      with_frame : boolean;
      mx_lines   : tin_natural;
      mx_cols    : tin_natural;
 
BEGIN
(* i11initmsg;  *)
mx_lines   := i01g^.vt.desc.num_of_lines;
IF  display.split_screen
THEN
    i51split (2)
ELSE
    i51split (1);
(*ENDIF*) 
WITH display, display.screen_pos DO
    BEGIN
    mx_cols    := 0;
    set_win    := false;
    with_frame := false;
    IF  (line_pos > 0) AND (col_pos > 0)
    THEN
        BEGIN
        (* ====================================================== *)
        (* line_pos, col_pos, lines und cols werden entspr. der   *)
        (* window Position und Groesse gesetzt                    *)
        (* ( aus DIALOG Editoroptionen SIZE und POS ).            *)
        (* ====================================================== *)
        set_win    := true;
        with_frame := true;
        IF  (lines = 0) AND (cols = 0)
        THEN
            BEGIN
            lines := i01g^.vt.desc.num_of_lines;
            cols := i01g^.vt.desc.num_of_cols;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  ( frame [ active_screen] .max_cols < mxin_eline )
        AND NOT display.split_screen
    THEN
        BEGIN
        IF  ( frame [ active_screen] .max_cols > 0 )
        THEN
            BEGIN
            (* ======================================================= *)
            (* lines und cols werden entspr. der max. Zeilen- bzw.     *)
            (* Spaltenanzahl ( max_cols, max_lines ) gesetzt           *)
            (* ( aus DIALOG Editoroptionen EDITSIZE bzw. durch wrap ). *)
            (* ======================================================= *)
            (* =================================================== *)
            (* Hier muss auch fuer Prefix-Editoren max_cols        *)
            (* ( ohne mxin_prefix_content )                        *)
            (* vergroessert werden, da mit RED umgeschaltet        *)
            (* werden kann und im RED die minimale Window-Groesse  *)
            (* ohne Prefix-Zeichen nicht ausreicht. Hierbei wuerde *)
            (* max_cols innerhalb der Editorschleife veraendert.   *)
            (* ====================================================*)
            IF  ( frame [ active_screen] .max_cols < mxin_min_scr_cols )
            THEN
                frame [ active_screen] .max_cols := mxin_min_scr_cols;
            (*ENDIF*) 
            mx_cols := 4 + frame [ active_screen] .max_cols;
            (* 4 Zeichen fuer den frame *)
&           ifdef WINDOWS
            IF  i01g^.set_parms.editor <> no_prefix
            THEN
                mx_cols := mx_cols + 1 + mxin_prefix_content;
&           endif
            (*ENDIF*) 
            IF  set_win
            THEN
                BEGIN
                IF  ( mx_lines > 0 ) AND ( mx_lines < lines )
                THEN
                    lines := mx_lines;
                (*ENDIF*) 
                IF  ( mx_cols > 0 ) AND ( mx_cols < cols )
                THEN
                    cols  := mx_cols;
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                lines := mx_lines;
                cols  := mx_cols;
                set_win := true;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        frame [ active_screen] .max_cols := mxin_eline;
    (*ENDIF*) 
    IF  (lines < mxin_min_scr_lines)
    THEN
        lines := mxin_min_scr_lines;
    (*ENDIF*) 
    IF  (cols < mxin_min_scr_cols + 4)
    THEN
        cols := mxin_min_scr_cols + 4;
    (*ENDIF*) 
    IF  set_win
    THEN
        BEGIN
        IF  NOT with_frame
        THEN
            BEGIN
&           ifdef WINDOWS
            IF  ( frame [ active_screen] .max_cols
                < i01g^.vt.desc.num_of_cols - 1 )
            THEN
                with_frame := true;
&           else
            (*ENDIF*) 
            IF  ( frame [ active_screen] .max_cols
                < i01g^.vt.desc.num_of_cols - 1 ) AND
                (i01g^.set_parms.editor = no_prefix )
            THEN
                with_frame := true;
            (*ENDIF*) 
            IF   ( ( frame [ active_screen] .max_cols
                + 1 + mxin_prefix_content )
                < i01g^.vt.desc.num_of_cols - 1 ) AND
                (i01g^.set_parms.editor <> no_prefix )
            THEN
                with_frame := true;
&           endif
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        i51split (1);
        split_screen := false;
        WITH window.first_pos DO
            BEGIN
            screen_nr := 1;
            screen_part := cin_ls_whole_screen;
            IF  (line_pos = 0) OR  (col_pos = 0)
            THEN
                BEGIN
                scol  := 1;
                sline := 1;
                END
            ELSE
                BEGIN
                scol := col_pos;
                sline := line_pos;
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        window.lines := lines;
        window.cols := cols;
        i01g^.vt.wopt.with_frame :=  with_frame;
        WITH i01g^.vt.wopt.frame_ft DO
            BEGIN
            field_att  := cin_attr7;
            fieldmode  := [  ] ;
            END;
        (*ENDWITH*) 
        i01g^.vt.wopt.background_part := cin_ls_basic_window;
        WITH i01g^.vt.wopt.background_ft DO
            BEGIN
            field_att  := cin_attr1;
            fieldmode  := [  ] ;
            END;
        (*ENDWITH*) 
        i51onwindow (cin_ls_basic_window, window, ok);
        END;
    (*ENDIF*) 
    IF  NOT display.my_layout
    THEN
        WITH display DO
            IF  (s30klen (frame  [1] .info_msg, bsp_c1, mxin_screenline)
                = 0)     AND
                (s30klen (frame  [2] .info_msg, bsp_c1, mxin_screenline)
                = 0)
            THEN
                i51layout (functionmenu_length, inputarea_length, 1)
            ELSE
                i51layout (functionmenu_length, inputarea_length, 2);
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10tetrans_eform (
            VAR eform    : tin_eform_buffer;
            VAR evars    : tin_eform_vars;
            source_type  : tsp00_CodeType );
 
BEGIN
i10tltrans_elines ( eform, evars, source_type, i01g^.i20.code_type );
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10tltrans_elines (
            VAR eform    : tin_eform_buffer;
            VAR evars    : tin_eform_vars;
            source_type  : tsp00_CodeType;
            dest_type    : tsp00_CodeType );
 
VAR
      line_nr    : tin_natural;
      line       : tin_eline;
      length     : tin_natural;
      error      : boolean;
 
BEGIN
IF  (source_type <> dest_type)
    (* ma 5.11.96: and... *)
    AND (source_type < csp_unicode_swap)
    AND (dest_type < csp_unicode_swap)
THEN
    BEGIN
    error := false;
    line_nr := 1;
    WHILE ( line_nr <= evars.lines ) AND NOT error DO
        BEGIN
        i14geteline(eform,evars,line,line_nr,
              length,error);
        i32t1translate ( source_type, dest_type, line, 1, line, 1, length );
        i14puteline(eform,evars,line,line_nr,
              length,error);
        line_nr := line_nr + 1;
        END;
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      restore_screen;
 
VAR
      restore : boolean;
 
BEGIN
restore := true;
i51split (1);
i51offwindow ( restore ) ;
END;
 
(*------------------------------*) 
 
PROCEDURE
      i10mfset  (
            VAR msg_nos : tin_msgnos );
 
BEGIN
i03mfrange ( 17230, 17240, msg_nos );
i03mfrange ( 17203, 17206, msg_nos );
END;
 
&ifdef WINDOWS
(*------------------------------*) 
 
PROCEDURE
      in10_get_mark (
            firstline : tin_natural;
            firstcol  : tin_natural;
            VAR block : tin_ed_winmark_type );
 
BEGIN
WITH block, block.mark DO
    BEGIN
    i56getmark ( 1, cin_ls_workarea, mode, top,  left, bottom, right );
    IF  mode = vt_mark_block
    THEN
        BEGIN
        top    := firstline  + top -1; (* B.M. 06.10.92 *)
        bottom := firstline  + bottom - 1; (* B.M. 06.10.92 *)
        left   := left + firstcol -1; (* B.M. 06.10.92 *)
        right  := right + firstcol -1; (* B.M. 06.10.92 *)
        END;
    (*ENDIF*) 
    IF  mode = vt_mark_line
    THEN
        BEGIN
        top    := firstline  + top -1; (* B.M. 06.10.92 *)
        bottom := firstline  + bottom - 1; (* B.M. 06.10.92 *)
        left   := 1;
        right  := mxin_eline;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* in10_get_mark *)
 
(*------------------------------*) 
 
PROCEDURE
      in10_set_mark (
            list      : boolean;
            firstline : tin_natural;
            firstcol  : tin_natural;
            VAR block : tin_ed_winmark_type );
 
BEGIN
WITH block, block.mark DO
    BEGIN
    top    := top - firstline + 1;
    bottom := bottom - firstline + 1;
    left   := left - firstcol +1;
    right  := right - firstcol +1;
    IF  list
    THEN
        mode := vt_mark_off
    ELSE
        mode := vt_mark_block;
    (*ENDIF*) 
    i56setmark ( 1, cin_ls_workarea, mode,
          top,  left, bottom, right );
    END;
(*ENDWITH*) 
END; (* in10_set_mark *)
 
(*------------------------------*) 
 
PROCEDURE
      in10_init_mark (
            VAR block : tin_ed_winmark_type );
 
BEGIN
WITH block, block.mark DO
    BEGIN
    mode := vt_mark_block;
    top := 0;
    bottom := -1;
    left := 1;
    right := 0;
    END;
(*ENDWITH*) 
END; (* in10_init_mark *)
 
(* B.M. Rel 3.0.1I 15 Jun 1992 *)
(*------------------------------*) 
 
PROCEDURE
      win_init_i10 (
            VAR display : tin_display_parms );
 
BEGIN
i56standardbox (vt_edit,
      (display.csr_pos.screen_part = cin_ls_inputarea), true);
END;
 
(*------------------------------*) 
 
PROCEDURE
      win_reset_i10;
 
BEGIN
i56standardbox ( vt_edit, true, false );
END;
 
&endif
&if $OS in [ WIN32, OS2 ]
(*------------------------------*) 
 
PROCEDURE
      in10_exmouse (
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            VAR relkey  : tin_ls_releasemode);
 
BEGIN
WITH display, csr_pos, edit  DO
    BEGIN
    CASE relkey OF
        f_mouse_down, f_mouse_up :
            BEGIN
            WITH frame [active_screen ] DO
                BEGIN
                edit.csr_set_by_user := false;
                edit.csr_switch := false;
                csr_pos := i01g^.vt.parms.mouse_pos;
                END;
            (*ENDWITH*) 
            END;
        OTHERWISE : (* f_mouse_dbl *)
            ;
        END;
    (*ENDCASE*) 
    END; (* *)
(*ENDWITH*) 
END;
 
&endif
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
