.CM  SCRIPT , Version - 1.1 , last edited by holger
.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VIN05$
.tt 2 $$$
.TT 3 $$help$1996-03-18$
***********************************************************
.nf
 
.nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : help
=========
.sp
Purpose : Help function of the dialog components
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              i05init (
                    g_area     : tin_global_in_vars);
 
        PROCEDURE
              i05help (
                    hid        : tin_help_text_id;
                    component  : tsp00_C8;
                    release_id : tsp00_C8;
                    VAR ok     : boolean );
 
        PROCEDURE
              i05contexthelp (
                    mainhid    : tin_help_text_id;
                    contexthid : tin_help_text_id;
                    component  : tsp00_C8;
                    release_id : tsp00_C8;
                    VAR ok     : boolean );
 
        FUNCTION
              i05ifexample : boolean;
 
        PROCEDURE
              i05getexample (
                    VAR ebuf : tin_eform_buffer;
                    VAR evar : tin_eform_vars;
                    clear    : boolean;
                    VAR ok   : boolean);
 
        FUNCTION
              in0530 : tsp00_Int4;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              global_variable      : VIN01;
 
        VAR
              i01g : tin_global_in_vars;
 
      ------------------------------ 
 
        FROM
              messages : VIN03;
 
        PROCEDURE
              i03msg (
                    msg_no    : integer;
                    VAR parms : tin_msg_parms;
                    VAR msg   : tin_screenline;
                    VAR mt    : tin_msg_type ); (* kern 2.0 *)
 
      ------------------------------ 
 
        FROM
              standard_editor_functions: VIN14;
 
        PROCEDURE
              i14geteline (
                    VAR eform     : tin_eform_buffer;
                    VAR evars     : tin_eform_vars;
                    VAR line      : tin_eline;
                    line_nr       : tin_natural;
                    VAR length    : tin_natural;
                    VAR error     : boolean);
 
        PROCEDURE
              i14puteline (
                    VAR eform     : tin_eform_buffer;
                    VAR evars     : tin_eform_vars;
                    VAR line      : tin_screenline;
                    line_nr       : tin_natural;
                    length        : tin_natural;
                    VAR error     : boolean);
 
        PROCEDURE
              i14cleareform (
                    VAR evars     : tin_eform_vars);
 
      ------------------------------ 
 
        FROM
              SQLDB-command-interface : VIN20;
 
        PROCEDURE
              i20gparaminfo (
                    info_no   : tin_natural;
                    VAR pi    : tsp1_param_info;
                    VAR found : boolean);
 
        PROCEDURE
              i20chnginfo (
                    with_info : boolean);
 
        PROCEDURE
              i20findpart (
                    part_kind : tsp1_part_kind);
 
        PROCEDURE
              i20gcount (
                    VAR count : tsp00_Int4);
 
        FUNCTION
              i20gchar (
                    b_pos        : tsp00_Int4) : char;
 
        PROCEDURE
              i20gbval (
                    l_val       : tin_natural;
                    b_pos       : tsp00_Int4;
                    VAR val     : tin_screenline;
                    VAR is_null : boolean);
 
        PROCEDURE
              i20g1bval (
                    l_val       : tin_natural;
                    b_pos       : tsp00_Int4;
                    VAR val     : tsp00_C4;
                    VAR is_null : boolean);
 
        PROCEDURE
              i20g2bval (
                    l_val       : tin_natural;
                    b_pos       : tsp00_Int4;
                    VAR val     : tsp00_C2;
                    VAR is_null : boolean);
 
        PROCEDURE
              i20g3bval (
                    l_val       : tin_natural;
                    b_pos       : tsp00_Int4;
                    VAR val     : tin_double_eline;
                    VAR is_null : boolean);
 
        PROCEDURE
              i20mfetch (
                    in_unicode   : boolean;
                    m_type       : tsp1_cmd_mess_type;
                    count        : tin_natural;
                    dir          : tin_fetch_dir;
                    VAR res_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              i20pcmnd (
                    VAR s : tsp00_C30;
                    l_s   : tin_natural );
 
        PROCEDURE
              i20p2cmnd (
                    VAR s : tin_language_id;
                    l_s   : tin_natural );
 
        PROCEDURE
              i20p3cmnd (
                    VAR s : tin_help_text_id;
                    l_s   : tin_natural );
 
        PROCEDURE
              i20pccmnd (
                    c : char );
 
        PROCEDURE
              i20request (
                    VAR rq_status : tin_connect_status);
 
        PROCEDURE
              i20receive (
                    VAR rc_status  : tin_connect_status;
                    VAR sqlstate   : tsp00_SqlState;
                    VAR returncode : tsp00_Int2;
                    VAR errorpos   : tsp00_Int4);
 
        PROCEDURE
              i20rebuild_session (
                    VAR status : tin_connect_status );
 
        PROCEDURE
              i20reset (
                    m_type : tsp1_cmd_mess_type);
 
      ------------------------------ 
 
        FROM
              logical_screen : VIN50;
 
        PROCEDURE
              i50keymap;
 
        PROCEDURE
              i50clear (
                    part : tin_ls_part );
 
        PROCEDURE
              i50put1field (
                    VAR field  : tin_screenline;
                    length     : tin_natural;
                    field_pos  : tin_ls_position;
                    field_type : tin_ls_fieldtype );
 
      ------------------------------ 
 
        FROM
              logical_screen_layout : VIN51;
 
        PROCEDURE
              i51layout (
                    functionmenu_length : tin_natural;
                    inputarea_length    : tin_natural;
                    msglines            : tin_natural );
 
        PROCEDURE
              i51size (
                    screen_part    : tin_ls_part;
                    VAR partlength : tin_natural;
                    VAR partwidth  : tin_natural );
 
      ------------------------------ 
 
        FROM
              logical_screen_modules : VIN56;
 
        PROCEDURE
              i56title (
                    blinking_modefield : boolean;
                    screen_nr          : integer;
                    VAR title          : tsp00_OnlineHeader);
 
        PROCEDURE
              i56putframe (
                    with_name   :  boolean;
                    with_parms  :  boolean );
 
        PROCEDURE
              i56putlabels (
                    fct_cursorpos       : tin_ls_releasemode;
                    functionline_label  : boolean );
&       ifdef WINDOWS
 
        PROCEDURE
              i56standardbox (
                    mode      : tsp00_VtUsageMode ;
                    immediate : boolean;
                    enable    : boolean );
 
        PROCEDURE
              i56setmark (
                    screen_nr     : tsp00_Int2;
                    screenpart    : tin_ls_part;
                    mode          : tsp00_VtMark;
                    top, left     : tsp00_Int2;
                    bottom, right : tsp00_Int2 );
 
        PROCEDURE
              i56vrange (
                    screen_nr  : tsp00_Int2;
                    VAR lbl    : tsp00_C8;
                    VAR vrange : tin_display_range );
&       endif
 
      ------------------------------ 
 
        FROM
              logical_screen_IO : VIN57 ;
 
        PROCEDURE
              i57ioscreen (
                    VAR csr_pos        : tin_ls_position;
                    VAR rf             : tin_ls_releasemode;
                    VAR screen_changed : boolean );
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30eq (
                    VAR a,b : tin_help_text_id;
                    bi,cnt  : tsp00_Int4) : boolean;
 
        FUNCTION
              s30klen (
                    VAR str : tin_screenline;
                    val     : char;
                    cnt     : integer ) : integer;
 
        FUNCTION
              s30gad (
                    VAR b : char) : tsp00_MoveObjPtr;
 
      ------------------------------ 
 
        FROM
              GET-Conversions : VSP40;
 
        PROCEDURE
              s40gsint (
                    VAR buf  : tsp00_C4;
                    pos      : tsp00_Int4;
                    len      : integer;
                    VAR dest : tsp00_Int2;
                    VAR res  : tsp00_NumError );
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80 : VSP80;
 
        PROCEDURE
              s80uni_trans (
                    src_ptr         : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
&       ifdef WINDOWS
 
      ------------------------------ 
 
        FROM
              WinHelp Call : VEN66WC;
 
        PROCEDURE
              sqlwhelp (
                    term_ref      : tsp00_Int4;
                    VAR helpfile  : tsp00_C8;
                    VAR help_id   : tin_help_text_id;
                    VAR ok        : boolean );
&       endif
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              s40gsint;
 
              tsp00_MoveObj tsp00_C4
 
        PROCEDURE
              s30eq;
 
              tsp00_MoveObj tin_help_text_id
              tsp00_MoveObj tin_help_text_id
 
        FUNCTION
              s30gad;
 
              tsp00_MoveObj char
              tsp00_Addr    tsp00_MoveObjPtr
 
        PROCEDURE
              i14puteline;
 
              tin_eline tin_screenline
 
        PROCEDURE
              i50put1field;
 
              tsp00_MoveObj tin_screenline
 
        PROCEDURE
              i20pcmnd;
 
              tsp00_Buf tsp00_C30
 
        PROCEDURE
              i20p2cmnd;
 
              tsp00_C40  tin_language_id
 
        PROCEDURE
              i20p3cmnd;
 
              tsp00_C70  tin_help_text_id
 
        PROCEDURE
              i20gbval;
 
              tsp00_Buf tin_screenline
 
        PROCEDURE
              i20g1bval;
 
              tsp00_Buf tsp00_C4
 
        PROCEDURE
              i20g2bval;
 
              tsp00_Buf tsp00_C2
 
        PROCEDURE
              i20g3bval;
 
              tsp00_Buf tin_double_eline
 
        PROCEDURE
              i20mfetch;
 
              tsp00_Int4 tin_natural
 
        PROCEDURE
              s40gsint;
 
              tsp00_MoveObj tsp00_C4
 
        PROCEDURE
              s30klen;
 
              tsp00_MoveObj tin_screenline
 
        PROCEDURE
              m90buf;
 
              tsp00_Buf tin_eline
&             ifdef WINDOWS
 
        PROCEDURE
              sqlwhelp;
 
              tsp00_C12 tin_help_text_id
&             endif
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1985-03-25
.sp
.cp 3
.sp
.cp 3
Release :  6.1.2     Date : 1995-11-01
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
i05_HELP
--------
 
This procedure expects the following input parameters:
 
- A 10-character component name for the screen header line
  (id_field_type ).
 
- A 12-character helpid that specifies the entry point in the help
  tree (ti_help_text_id ).
 
This procedure returns a BOOLEAN parameter that has the value
true if no database access is possible.
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
.nf
Modifications:
=============
 
 9.4.87    : Query rc_timeout after 'request'.
 1.12.87   : Revision.  Now controlled via cursor placement.
 
 
General
=======
 
What does the HELP procedure do ?
---------------------------------
 
  + Outputs masks.
  + Provides a scrolling function.
  + Selects texts from the database.
  + Reads in user inputs.
  + Fills gaps in numbering in the help masks with empty lines.
  + Sets the return code to false if no database access is possible.
  + Issues messages and key assignments depending on the contents of
    the screen (menu/text/scrolling determined by the HELP_MODE field ).
 
What must the HELP provider do ?
--------------------------------
 
  + Provide a hierarchically structured series of masks.
  + Call the procedure i05help.
  + Identify its component by specifying the component name.
  + For each help line, indicate whether a menu ( 'M' or 'I' in
    SYSMSG.MODE_FIELD  ) or a text (default ) is involved.
  + For each menu line, indicate whether the current helpid is to be
    overwritten (with 'I' for 'instead' as mode.field ) or not ('m' ).
  + For each help page, indicate whether subsequent pages ( 'S' in
    SYSMSG.MODE_FIELD  ) are present.
 
What can the HELP user do ?
---------------------------
 
  + Select information by setting the cursor and pressing the INFO key.
  + Exit the help_procedure with the EXIT key.
  + Branch to the parent menu by pressing the MENU key.
  + Scroll in a help_mask.
 
Technical information
=====================
 
  Each component is assigned a two-digit number by which it is possible
  to enter its help tree.
 
                    DESIGN   - '01'
                    DIALOG   - '02'
                    EASY     - '03'
                    EDITOR   - '04'
                    FORM     - '05'
                    LOAD     - '06'
                    QUERY    - '07'
                    REPORT   - '08'
                    SQL      - '09'
                    UTILITY  - '10'
                    WORKBENCH- '11'
                    SHOW     - '12'
 
  The helpids of the dialog components begin with these numbers.
  In order to make the help information of other components accessible,
  the corresponding number must be specified in the menu and the menu
  line must be marked with the help mode 'I' (Instead ).
 
Mask layout
-----------
 
  The characters '#' and '@' in the HELPTEXT control where the user
  can place the cursor.  These characters MUST be followed by a
  TWO-OR-MORE DIGIT number, which is either appended to the
  helpid of the current mask or replaces it.
  If a substitution is desired, the HELP_MODE MUST be set to 'I'.
  The word following the flag ( #nn  ) becomes the input field
  ('#' causes high-intensity output ) and can, for this reason, be
  reached by the cursor.
 
     ***********************************************************
     * The flags (#nn or^nn ) do not appear on the screen!  *
     * The shifting that they cause is to be taken into        *
     * account when generating the masks.                      *
     ***********************************************************
 
  One line can contain several fields that can be flagged.
 
  A maximum of 18 lines can be displayed on the screen.
 
  Pattern :
  =======
 
  Text ... #01 Input field1  Text ... @02 Input field2
 
 
 
Program Interface
-----------------
 
  PROCEDURE i05help (
                   hid       : ti_help_text_id;
                   component : id_field_type;
                   VAR ok    : boolean );
 
Table structure
---------------
 
       TABLE SYSHELP
 
              LANGUAGE  CHAR   (3)
              HELP_ID   CHAR   (12)
              LINENO    FIXED  (5,0)
              HELP_MODE CHAR   (2)
              LINE      CHAR   (132) (+ 132 because of UNICODE)
 
 
Example of a help tree (call from DIALOG) :
-----------------------------------------
 
                     ----------------
              (i)    | #04 Editor   |
              (i)    | #09 SQL      |   '02    '  <-- Helpid
              (m)    | #03 DIALOG   |   (M),(I)   <-- Help_Mode
              (i)    | #11 Workbench|                 M for internal,
                     ----------------                 I for external helps
                      *    *    *
                    *      *      *
                  *        *        *
                *          *          *
          -----------    -----------     ------------
          | Editor  |    | SQL     |     | DIALOG   |
          | #01 ... |    | #01 ... |     | #01 ...  |
 '04    ' | #02 ... |    | #02 ... |     | #02 ...  | '0203  '
 (M)      -----------    | #03 ... |     ------------
                         -----------
                                           * *
                         * * *   '09    '  *   *
                       *   *   * (M)       *     *
                     *     *     *
                   *       *       *
                 *         *         *
            -------    ----------   --------
            | ... |    | ...    |   | ...  |
            |     |    | ...    |   |      |
            | ... |    | ...    |   | ...  |
            |     |    |        |   |      |
            -------    ----------   --------
           '0901  '    '0902  '     '0903  '
           ( )         ( )          (S)     <-- more than one page of text
 
  Example of a call :
 
 
    i05help ('02           ',   <-- helpid from DIALOG
              'DIALOG 2.0',      <-- component name for header line
               returncode );
.fo
.hi 0
Changes B.M. 19.02.93 :
If a pointer device (mouse) is available, a double click acts like the
help key. Thus, to each occurrence of f_help, f_mouse_dbl has been added.
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
 
Code    :
 
 
CONST
      c_with_info              = true;
      db_ok                    = 0;
      db_sys_error             = 1;
      db_not_found             = 100;
      db_wait_for_lock_release = 500;
      maxselectors             = 75;
      not_found                = 17971;
      pseudo_blank             = '^';
      more___                  = 17972;
      mark_placed              = 17974;
      example_picked           = 17975;
 
TYPE
 
      selector = RECORD
            line   : tsp00_Uint1;
            column : tsp00_Uint1;
            fend   : tsp00_Uint1;
            id     : tin_help_text_id;
            mode   : (additional, instead);
      END;
 
      selector_list = PACKED ARRAY [ 1..maxselectors ] OF selector;
 
      param_desc    = RECORD
            param_pos       : ARRAY [ 1 .. 3 ] OF integer;
            param_iolen     : ARRAY [ 1 .. 3 ] OF integer;
            param_totlen    : integer;
      END;
 
 
      help_global = RECORD
            selno           : integer;
            sel             : selector_list;
            ll              : integer;
            line            : tin_screenline;
            line_mode       : char;
            cols_on_screen  : tin_natural;
            lines_on_screen : tin_natural;
            lines_offset    : tin_natural;
            exit            : boolean;
            component       : tsp00_C8;
            release_id      : tsp00_C8;
            mode            : tsp00_C12;
            msg             : tin_screenline;
            msg_set         : boolean;
            level           : integer;
            start_hid       : tin_help_text_id;
            call_again      : boolean;
            example         : boolean;
            example_set     : boolean;
            example_hid     : tin_help_text_id;
            example_first   : tin_natural;
            example_last    : tin_natural;
            pdesc           : param_desc;
      END;
 
      (*===============================================================*)
      (* Mainprogram                                                   *)
      (*===============================================================*)
 
 
(*------------------------------*) 
 
FUNCTION
      in0530 : tsp00_Int4;
 
BEGIN
(* linkcheck function *)
in0530 := 219020707;
END;
 
(*------------------------------*) 
 
PROCEDURE
      i05init (
            g_area : tin_global_in_vars);
 
BEGIN
WITH g_area^.bookmark DO
    BEGIN
    bookmark_hid := '            ';
    bookmark_act := false;
    END;
(*ENDWITH*) 
WITH g_area^.example DO
    BEGIN
    example_set := false;
    example_hid := '            ';
    example_first := 0;
    example_last := 0;
    END;
(*ENDWITH*) 
END; (* i05init *)
 
(*------------------------------*) 
 
PROCEDURE
      i05contexthelp (
            mainhid    : tin_help_text_id;
            contexthid : tin_help_text_id;
            component  : tsp00_C8;
            release_id : tsp00_C8;
            VAR ok     : boolean );
 
BEGIN
do_help (mainhid, contexthid, component, release_id, ok);
END; (* i05contexthelp *)
 
(*------------------------------*) 
 
PROCEDURE
      i05help (
            hid        : tin_help_text_id;
            component  : tsp00_C8;
            release_id : tsp00_C8;
            VAR ok     : boolean );
 
BEGIN
do_help (hid, hid, component, release_id, ok);
END; (* i05help *)
 
(*------------------------------*) 
 
PROCEDURE
      do_help (
            start_hid  : tin_help_text_id;
            to_hid     : tin_help_text_id;
            component  : tsp00_C8;
            release_id : tsp00_C8;
            VAR ok     : boolean );
 
VAR
      hg                      : help_global;
      current_keys_and_labels : tin_ls_key_type;
      current_ls              : tin_ls_record;
      vt                      : tin_vt_record;
&     ifdef WINDOWS
      helpfile                : tsp00_C8;
&     endif
 
BEGIN
&ifdef WINDOWS
IF  i01g^.set_parms.language = cin_k_deu
THEN
    helpfile := 'SQLDBDEU'
ELSE
    helpfile := 'SQLDBENG';
(*ENDIF*) 
sqlwhelp (i01g^.vt.vt_ref, helpfile, to_hid, ok);
&else
vt := i01g^.vt;
current_keys_and_labels := i01g^.key_type;
current_ls := i01g^.ls;
hg.example := false;
hg.example_set := false;
hg.example_hid := '            ';
hg.example_first := 0;
hg.example_last := 0;
hg.component  := component;
hg.release_id := release_id;
hg.start_hid := start_hid;
to_hid := to_hid;
REPEAT
    init_help (hg);
    i50keymap;
    hg.call_again := false;
    exec_help (hg, 1, to_hid);
    IF  hg.call_again
    THEN
        to_hid := hg.start_hid;
    (*ENDIF*) 
UNTIL
    hg.call_again = false;
(*ENDREPEAT*) 
ok := i01g^.session [i01g^.dbno].connect_status = rc_ok;
i01g^.key_type := current_keys_and_labels;
i01g^.ls := current_ls;
i01g^.vt := vt;
&endif
END; (* i05help *)
 
(*------------------------------*) 
 
PROCEDURE
      init_help (
            VAR hg : help_global );
 
CONST
      header       = 17980;
      first_key    = 17981;
      no_cmd_lines = 0;
      msglines     = 1;
      keylines     = 1;
 
VAR
      f    : tin_prog_function;
      j    : integer;
      parm : tin_msg_parms;
      msg  : tin_screenline;
      ret  : tin_msg_type;
 
BEGIN
parm.length := 0;
(* Get keylabels*)
j := first_key;
FOR f := f1 TO f_down DO
    BEGIN
    IF  ( f IN [  f1, f4, f6, f7, f8, f9, f_help, f_up, f_down ] )
    THEN
        BEGIN
        i03msg (j, parm, msg, ret );
        j := j + 1;
        s10mv (mxin_screenline,csp_lslabel,
              @msg,1,
              @i01g^.key_type.key_labels [f],1,csp_lslabel );
        END
    ELSE
&       ifdef WINDOWS
        i01g^.key_type.key_labels [f] := bsp_c8;
    (*ENDIF*) 
&   endif
    END;
(*ENDFOR*) 
i01g^.vt.opt.wait_for_input := true;
i01g^.vt.opt.usage_mode      := vt_form;
i01g^.vt.opt.return_on_last  := false;
i01g^.vt.opt.return_on_first := false;
i01g^.vt.opt.returnkeys      := [  ] ;
i01g^.vt.opt.reject_keys     := [  ] ;
i01g^.vt.opt.bell := false;
hg.exit := false;
(* get headline*)
i03msg (header, parm, msg, ret);
s10mv (mxin_screenline,mxsp_c12,
      @msg,1,
      @hg.mode,1,mxsp_c12);
hg.msg_set := false;
hg.level := 0;
(* Get screensize *)
i51layout (keylines, no_cmd_lines, msglines);
i51size (cin_ls_workarea, hg.lines_on_screen, hg.cols_on_screen);
IF  hg.lines_on_screen > 18
THEN
    hg.lines_offset := 1
ELSE
    hg.lines_offset := 0;
(*ENDIF*) 
hg.lines_on_screen := 18;
&ifdef WINDOWS
i56setmark ( 1, cin_ls_workarea, vt_mark_off, 0, 0, 0, 0);
i56standardbox (vt_form, false, false);
&endif
END; (* init_help *)
 
(* ================================================================ *)
(*                                                                  *)
(* ================================================================ *)
(*------------------------------*) 
 
PROCEDURE
      exec_help (
            VAR hg       : help_global;
            first_line   : integer;
            hid          : tin_help_text_id );
 
VAR
      current_hid : tin_help_text_id;
      func        : tin_ls_releasemode;
      found       : boolean;
      cont        : boolean;
      cursor      : tin_ls_position;
 
BEGIN
hg.level := hg.level + 1;
current_hid := hid;
cont := true;
hg.example := false;
get_screen (hg, first_line, hid, found);
setpos (hg, cursor);
IF  found
THEN
    WHILE cont AND (NOT hg.exit) DO
        BEGIN
        func := f_undo;
        show_screen (hg, hid, cursor, func );
        CASE func OF
            f_help, f_mouse_dbl:
                BEGIN
                exec_help (hg, 1, hid);
                hid := current_hid;
                get_screen (hg, first_line, hid, found);
                END;
            f_up :
                BEGIN
                first_line := first_line - hg.lines_on_screen;
                get_screen (hg, first_line, hid, found);
                setpos (hg, cursor);
                END;
            f_down :
                BEGIN
                first_line := first_line + hg.lines_on_screen;
                get_screen (hg, first_line, hid, found);
                setpos (hg, cursor);
                END;
            f_vscroll:
                BEGIN
                IF  i01g^.vt.parms.scroll_dir < 0
                THEN
                    first_line := first_line - hg.lines_on_screen
                ELSE
                    first_line := first_line + hg.lines_on_screen;
                (*ENDIF*) 
                IF  first_line < 1
                THEN
                    first_line := 1;
                (*ENDIF*) 
                get_screen (hg, first_line, hid, found);
                setpos (hg, cursor);
                END;
            f_clear :
                BEGIN
                get_screen (hg, first_line, hid, found);
                END;
            f7, f_end :
                BEGIN
                cont := false;
                END;
            f9 :
                BEGIN
                hg.exit := true;
                END;
            f8 : (* Set Bookmark *)
                BEGIN
                WITH i01g^.bookmark DO
                    BEGIN
                    bookmark_hid := hid;
                    bookmark_act := true;
                    END;
                (*ENDWITH*) 
                set_msg (hg, mark_placed);
                END;
            f1 : (* Goto Bookmark *)
                BEGIN
                exec_help (hg, 1, i01g^.bookmark.bookmark_hid);
                hid := current_hid;
                get_screen (hg, first_line, hid, found);
                END;
            f6 : (* Back to Mainmenu *)
                BEGIN
                hg.exit := true;
                hg.call_again := true;
                END;
            f4 : (* Get Example *)
                BEGIN
                WITH i01g^.example DO
                    BEGIN
                    IF  hg.example
                    THEN
                        BEGIN
                        example_set := true;
                        example_hid := hg.example_hid;
                        example_first := hg.example_first;
                        example_last := hg.example_last;
                        set_msg (hg, example_picked);
                        END
                    ELSE
                        BEGIN
                        example_set := false;
                        example_hid := '            ';
                        example_first := 0;
                        example_last := 0;
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                END;
            OTHERWISE:
                BEGIN
                END;
            END;
        (*ENDCASE*) 
        END
    (*ENDWHILE*) 
ELSE
    set_msg (hg, not_found);
(*ENDIF*) 
hg.level := hg.level - 1;
END; (* exec_help *)
 
(*===================================================================*)
(*                                                                   *)
(*===================================================================*)
(*------------------------------*) 
 
PROCEDURE
      setpos (
            VAR hg : help_global;
            VAR cp : tin_ls_position );
 
BEGIN
(* set cursor on first inputfield or left upper corner*)
IF  hg.selno > 0
THEN
    BEGIN
    i05set_pos (cp, cin_ls_workarea,
          hg.sel [1] .line + hg.lines_offset,
          hg.sel [1] .column)
    END
ELSE
    i05set_pos (cp, cin_ls_workarea, 1, 1);
(*ENDIF*) 
END; (* setpos *)
 
(*===================================================================*)
(*                                                                   *)
(*===================================================================*)
(*------------------------------*) 
 
PROCEDURE
      show_screen (
            VAR hg         : help_global;
            VAR hid        : tin_help_text_id;
            VAR cursor_pos : tin_ls_position;
            VAR func       : tin_ls_releasemode );
 
VAR
      found   : boolean;
      altered : boolean;
      rk      : tin_ls_releasemode;
 
BEGIN
(* outscreen*)
IF  hg.msg_set
THEN
    BEGIN
    i05_put_field (hg.msg, 1, 80, 1, 1, 0,
          cin_attr5, [ ] ,cin_ls_sysline);
    hg.msg_set := false;
    END;
(*ENDIF*) 
i57ioscreen (cursor_pos, rk, altered);
(* concat selector and hid if function is help*)
IF  (rk = f_help) OR (rk = f_mouse_dbl)
THEN
    BEGIN
    create_new_hid (cursor_pos, hid, hg, found);
    IF  found
    THEN
        func := rk
    ELSE
        func := f_undo;
    (*ENDIF*) 
    END
ELSE
    func := rk;
(*ENDIF*) 
END; (* show_screen *)
 
(*===================================================================*)
(*                                                                   *)
(*===================================================================*)
(*------------------------------*) 
 
PROCEDURE
      create_new_hid (
            pos       : tin_ls_position;
            VAR hid   : tin_help_text_id;
            VAR hg    : help_global;
            VAR found : boolean );
 
VAR
      i : integer;
 
BEGIN
found := false;
WITH hg DO
    FOR i := 1 TO hg.selno DO
        BEGIN
        IF  (sel [i] .line = (pos.sline - lines_offset))
            AND  ( pos.scol in [ sel [i] .column .. sel [i] .fend ] )
        THEN
            BEGIN
            found := true;
            IF  hg.sel [i] .mode = additional
            THEN
                BEGIN
                hid [ i05len (hid) + 1 ] := hg.sel [i] .id  [1] ;
                hid [ i05len (hid) + 1 ] := hg.sel [i] .id  [2] ;
                END
            ELSE
                BEGIN
                hid := hg.sel [i] .id;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
(*ENDWITH*) 
END; (* create_new_hid *)
 
(*===================================================================*)
(*                                                                   *)
(*===================================================================*)
(*------------------------------*) 
 
PROCEDURE
      i05set_pos (
            VAR pos : tin_ls_position;
            area    : tin_ls_part;
            line    : tin_natural;
            col     : tin_natural );
 
BEGIN
WITH pos DO
    BEGIN
    scol := col;
    sline := line;
    screen_part := area;
    screen_nr := 1;
    END;
(*ENDWITH*) 
END; (* i05set_pos *)
 
(*===================================================================*)
(*                                                                   *)
(*===================================================================*)
(*------------------------------*) 
 
PROCEDURE
      get_screen (
            VAR hg     : help_global;
            first_line : integer;
            hid        : tin_help_text_id;
            VAR found  : boolean );
 
CONST
      no_cmd_lines = 0;
      msglines     = 1;
      keylines     = 1;
 
VAR
      rc              : tsp00_Int2;
      packet_pos      : tsp00_Int4;
      count           : tsp00_Int4;
      i               : integer;
      lineno          : integer;
      any_menu        : boolean;
      scroll_possible : boolean;
      is_menu         : boolean;
      is_example      : boolean;
&     ifdef WINDOWS
      lbl     : tsp00_C8;
      vrange  : tin_display_range;
&     endif
 
BEGIN
any_menu := false;
IF  NOT hg.exit
THEN
    BEGIN
    select_lines (hg, hid, first_line, count, rc);
    scroll_possible := false;
    IF  rc = db_ok
    THEN
        BEGIN
        hg.selno := 0;
        found := true;
        i50clear (cin_ls_basic_window);
        i51layout (keylines, no_cmd_lines, msglines);
        i05put_header (hg);
        i56putframe (true, true);
        i20findpart (sp1pk_data);
        packet_pos := 0;
        FOR i := 1 TO count DO
            BEGIN
            fetch_line (hg, packet_pos, scroll_possible, lineno,
                  is_menu, is_example);
            IF  is_menu
            THEN
                any_menu := true;
            (*ENDIF*) 
            IF  is_example
            THEN
                BEGIN
                IF  NOT hg.example
                THEN
                    BEGIN
                    hg.example := true;
                    hg.example_hid := hid;
                    hg.example_first := lineno;
                    hg.example_last := lineno;
                    END
                ELSE
                    hg.example_last := lineno;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            lineno := lineno MOD hg.lines_on_screen;
            IF  lineno = 0
            THEN
                lineno := hg.lines_on_screen;
            (*ENDIF*) 
            put_line (hg, lineno, is_menu, is_example);
            END;
        (*ENDFOR*) 
        set_function_keys (hg, hid, first_line, scroll_possible,
              any_menu, hg.level=1);
        END
    ELSE
        found := false;
    (*ENDIF*) 
&   ifdef WINDOWS
    WITH vrange DO
        BEGIN
        total_begin := 1;
        IF  scroll_possible
        THEN
            total_end := csp_maxint4
        ELSE
            total_end :=  first_line + hg.lines_on_screen - 1;
        (*ENDIF*) 
        displ_begin := first_line;
        displ_end   := first_line + hg.lines_on_screen - 1;
        END;
    (*ENDWITH*) 
    lbl := bsp_c8;
    i56vrange (1, lbl, vrange);
&   endif
    END;
(*ENDIF*) 
END; (* get_screen *)
 
(*===================================================================*)
(*                                                                   *)
(*===================================================================*)
(*------------------------------*) 
 
PROCEDURE
      set_function_keys (
            VAR hg      : help_global;
            hid         : tin_help_text_id;
            first_line  : integer;
            scroll_poss : boolean;
            is_menu     : boolean;
            first_level : boolean);
 
BEGIN
WITH i01g^.key_type DO
    BEGIN
    activated := [ f_up, f_down, f7, f_end, f_help, f_mouse_dbl,
          f9, f8, f1, f6, f4, f_vscroll] ;
    IF  first_line = 1
    THEN
        activated := activated - [ f_up] ;
    (*ENDIF*) 
    IF  NOT scroll_poss
    THEN
        activated := activated - [ f_down ] ;
    (*ENDIF*) 
    IF  NOT is_menu
    THEN
        activated := activated - [ f_help, f_mouse_dbl ] ;
    (*ENDIF*) 
    IF  NOT hg.example
    THEN
        activated := activated - [f4] ;
    (*ENDIF*) 
    IF  first_level
    THEN
        activated := activated -  [f7] ;
    (*ENDIF*) 
    IF  s30eq (hid, hg.start_hid, 1, 12)
    THEN
        activated := activated - [f6];
    (*ENDIF*) 
    IF  NOT i01g^.bookmark.bookmark_act
    THEN
        activated := activated -  [f1] ;
    (*ENDIF*) 
    IF  s30eq (hid, i01g^.bookmark.bookmark_hid, 1, 12)
    THEN
        activated := activated - [f8, f1];
    (*ENDIF*) 
    IF  f_down in activated
    THEN
        set_msg (hg, more___);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
i56putlabels (f_enter, false);
END; (* set_function_keys *)
 
(*===================================================================*)
(*                                                                   *)
(*===================================================================*)
(*------------------------------*) 
 
PROCEDURE
      put_line (
            VAR hg         : help_global;
            lineno         : integer;
            VAR is_menu    : boolean;
            VAR is_example : boolean);
 
VAR
      screen_offset : integer;
      p             : integer;
      absolute      : boolean;
 
BEGIN
WITH hg DO
    BEGIN
    ll := s30klen (line, bsp_c1, ll);
    IF  is_menu
    THEN
        BEGIN
        p := 1;
        screen_offset := 0;
        WHILE p <= ll DO
            BEGIN
            IF  line [p] in [ '@', '#' ]
            THEN
                BEGIN
                absolute := false;
                (**)
                IF  line [p + 1] in ['@','#']
                THEN
                    BEGIN
                    p := p + 1;
                    absolute := true;
                    END;
                (**)
                (*ENDIF*) 
                IF  screen_offset = 0
                THEN
                    BEGIN
                    IF  p > 2
                    THEN
                        BEGIN
                        i05_put_field (line, 1, p - 1, 1,
                              lineno, lines_offset,
                              cin_attr1, [ ] , cin_ls_workarea);
                        IF  absolute
                        THEN
                            screen_offset := p - 2
                        ELSE
                            screen_offset := p - 1;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END
                (* MR : for correct left and right justification put *)
                (* the attr byte of the markable field on a blank pos *)
                ELSE
                    IF  p > 2
                    THEN
                        IF  absolute
                        THEN
                            BEGIN
                            IF  line [ p - 2 ] = bsp_c1
                            THEN
                                screen_offset := screen_offset - 1;
                            (*ENDIF*) 
                            END
                        ELSE
                            BEGIN
                            IF  line [ p - 1 ] = bsp_c1
                            THEN
                                screen_offset := screen_offset - 1;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                selno := selno + 1;
                set_mark (hg, lineno, p, screen_offset);
                END;
            (*ENDIF*) 
            p := p + 1;
            END;
        (*ENDWHILE*) 
        END
    ELSE
        IF  is_example
        THEN
            i05_put_field (line, 1, ll, 1, lineno, lines_offset,
                  cin_attr5, [ ] , cin_ls_workarea)
        ELSE
            i05_put_field (line, 1, ll, 1, lineno, lines_offset,
                  cin_attr1, [ ] , cin_ls_workarea);
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* put_line *)
 
(*===================================================================*)
(*                                                                   *)
(*===================================================================*)
(*------------------------------*) 
 
PROCEDURE
      set_mark (
            VAR hg            : help_global;
            lineno            : integer;
            mark_pos          : integer;
            VAR screen_offset : integer );
 
VAR
      i,j      : integer;
      r_begin  : integer;
      f_len    : integer;
      if_len   : integer;
      if_begin : integer;
      p        : integer;
      lab_len  : integer;
      f_attr   : tin_ls_attribute_index;
 
BEGIN
WITH hg DO
    BEGIN
    sel [selno] .line := lineno;
    IF  ( line [ mark_pos + 1 ] in [ '0'..'9' ] )
        AND ( line [ mark_pos + 2 ] in [ '0'..'9' ] )
    THEN
        BEGIN
        p := mark_pos;
        i := 1;
        (**)
        WHILE ( line [ mark_pos + i ] in [ '0'..'9' ] ) DO
            BEGIN
            sel [selno].id [i] := line [mark_pos + i] ;
            p := p + 1;
            i := i + 1;
            END;
        (*ENDWHILE*) 
        FOR j := i TO mxsp_c12 DO
            sel [selno].id [j]  := bsp_c1;
        (*ENDFOR*) 
        (**)
        p := p + 1;
        (* Skip blanks *)
        WHILE (line [p]  = bsp_c1) AND (p <= ll) DO
            p := p + 1;
        (*ENDWHILE*) 
        if_begin := p;
        if_len := 0;
        (* Get next word*)
        WHILE ( NOT ( line [p] IN [ bsp_c1, '#', '@' ] ) )
              AND   (p <= ll) DO
            BEGIN
            p := p + 1;
            if_len := if_len + 1;
            END;
        (*ENDWHILE*) 
        lab_len := i05len (sel [selno].id) + 1;
        f_len := if_begin - mark_pos - lab_len;
        IF  f_len > 0
        THEN
            BEGIN
            (* Put leading blanks *)
            i05_put_field (line, mark_pos + lab_len,
                  f_len, screen_offset + 1,
                  lineno, lines_offset,
                  cin_attr1, [ ] , cin_ls_workarea);
            screen_offset := screen_offset + f_len + csp_attr_byte;
            END;
        (*ENDIF*) 
        IF  line [ mark_pos ] = '#'
        THEN
            f_attr := cin_attr2
        ELSE
            f_attr := cin_attr1;
        (*ENDIF*) 
        (* Put markable field*)
        sel [selno].column := screen_offset + csp_attr_byte;
        sel [selno].fend := sel [ selno].column + if_len - 1;
        i05_put_field (line, if_begin, if_len, screen_offset+1,
              lineno, lines_offset,
              f_attr, [ ls_input] , cin_ls_workarea);
        screen_offset := screen_offset + if_len + csp_attr_byte;
        IF  hg.line_mode in [ 'i', 'I' ]
        THEN
            sel [selno].mode := instead
        ELSE
            sel [selno].mode := additional;
        (*ENDIF*) 
        IF   ( NOT ( line  [p]  IN [ '#', '@' ] ) )
            AND   (p < ll)
        THEN
            BEGIN
            (* Get rest*)
            (* MR : for correct left and right justification use the *)
            (* attr byte of the normal field as first blank *)
            IF  line [p] = bsp_c1
            THEN
                p := p + 1;
            (*ENDIF*) 
            r_begin := p;
            f_len := 0;
            WHILE ( NOT ( line  [p]  IN [ '#', '@' ] ) )
                  AND   (p <= ll)
                  DO
                BEGIN
                p := p + 1;
                f_len := f_len + 1;
                END;
            (*ENDWHILE*) 
            (* Put rest*)
            i05_put_field (line, r_begin, f_len, screen_offset+1,
                  lineno, lines_offset,
                  cin_attr1, [ ] , cin_ls_workarea);
            screen_offset := screen_offset + f_len + csp_attr_byte;
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* set_mark *)
 
(*===================================================================*)
(*                                                                   *)
(*===================================================================*)
(*------------------------------*) 
 
PROCEDURE
      i05_put_field (
            VAR line   : tin_screenline;
            bpos       : integer;
            size       : integer;
            spos       : integer;
            lineno     : integer;
            lineoffset : integer;
            attr       : tin_ls_attribute_index;
            mode       : tin_ls_fieldmode;
            area       : integer );
 
VAR
      b : tin_screenline;
      p : tin_ls_position;
      t : tin_ls_fieldtype;
      i : integer;
 
BEGIN
p.screen_nr := 1;
p.screen_part := area;
p.scol := spos;
p.sline := lineno + lineoffset;
t.field_att  := attr;
t.fieldmode  := mode;
IF  mode = [ ls_input ]
THEN
    BEGIN
    FOR i := bpos TO bpos + size - 1 DO
        IF  line [i] = pseudo_blank
        THEN
            line [i] := bsp_c1;
        (*ENDIF*) 
    (*ENDFOR*) 
    END;
(*ENDIF*) 
s10mv (mxin_screenline,mxin_screenline,
      @line,bpos,
      @b,1,size );
i50put1field (b, size, p, t);
END; (* i05_put_field *)
 
(*===================================================================*)
(* Execution of DB commands. RECONNECT  if required.                 *)
(*===================================================================*)
(*------------------------------*) 
 
PROCEDURE
      in05_execute (
            VAR timeout : boolean;
            VAR ok      : boolean;
            VAR rc      : tsp00_Int2);
 
VAR
      rq_state  : tin_connect_status;
      rc_state  : tin_connect_status;
      errorpos  : tsp00_Int4;
      sqlstate  : tsp00_SqlState;
 
BEGIN
rc := db_ok;
timeout := false;
ok := true;
i20request (rq_state);
IF  rq_state <> rc_ok
THEN
    BEGIN
    IF  rq_state = rc_timeout
    THEN
        BEGIN
        i20rebuild_session (rc_state);
        i01g^.msg_tab.parsid := bin_parseid;
        timeout := true;
        IF  rc_state = rc_ok
        THEN
            ok := true
        ELSE
            BEGIN
            rc := db_sys_error;
            ok := false;
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        rc := db_sys_error;
        ok := false;
        END
    (*ENDIF*) 
    END
ELSE
    BEGIN
    i20receive (rc_state, sqlstate, rc, errorpos);
    IF  rc_state = rc_ok
    THEN
        timeout := (rc = db_wait_for_lock_release)
    ELSE
        BEGIN
        i20rebuild_session (rc_state);
        i01g^.msg_tab.parsid := bin_parseid;
        timeout := true;
        IF  rc_state = rc_ok
        THEN
            ok := true
        ELSE
            BEGIN
            rc := db_sys_error;
            ok := false;
            END;
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
END; (* in05_execute *)
 
(*===================================================================*)
(* Get length of helpid                                              *)
(*===================================================================*)
(*------------------------------*) 
 
FUNCTION
      i05len (
            h : tin_help_text_id ) : integer;
 
VAR
      i    : integer;
      intr : boolean;
 
BEGIN
intr := false;
i := mxsp_c12;
REPEAT
    IF  (h [i] = bsp_c1)
    THEN
        i := i - 1
    ELSE
        intr := true;
    (*ENDIF*) 
UNTIL
    (intr) OR (i = 0);
(*ENDREPEAT*) 
i05len := i;
END; (* i05len *)
 
(*===================================================================*)
(*                                                                   *)
(*===================================================================*)
(*------------------------------*) 
 
PROCEDURE
      fetch_line (
            VAR hg              : help_global;
            VAR packet_pos      : tsp00_Int4;
            VAR scroll_possible : boolean;
            VAR lineno          : integer;
            VAR is_menu         : boolean;
            VAR is_example      : boolean );
 
VAR
      rc      : tsp00_NumError;
      is_null : boolean;
      c       : tsp00_C2;
      lno     : tsp00_C4;
      l       : tsp00_Int2;
&     ifdef WINDOWS
      wline   : tin_screenline;
&     endif
 
BEGIN
i20g1bval (sizeof(lno), hg.pdesc.param_pos [1] + packet_pos,
      lno, is_null);
IF  NOT is_null
THEN
    BEGIN
    hg.ll := 132;
    s40gsint (lno, 1, 4, l, rc);
    lineno := l;
    IF  rc = num_ok
    THEN
        BEGIN
        in05_trans_line (hg.pdesc.param_iolen [2],
              hg.pdesc.param_pos [2] + packet_pos, hg.line);
        (******)
        (* windows help-line 3 characters to left *)
&       ifdef WINDOWS
        wline := hg.line;
        s10mv(mxin_screenline,mxin_screenline,
              @wline,3,
              @hg.line,1,mxin_screenline-3);
&       endif
        i20g2bval (sizeof (c), hg.pdesc.param_pos [ 3 ] + packet_pos,
              c, is_null);
        hg.line_mode := c [2];
        is_menu := false;
        is_example := false;
        IF  NOT is_null
        THEN
            BEGIN
            IF  c [1] in [ 'S', 's' ]
            THEN
                scroll_possible := true;
            (*ENDIF*) 
            IF  c [1] in [ 'R', 'r' ]
            THEN
                scroll_possible := false;
            (*ENDIF*) 
            IF  c [2] in [ 'M', 'm', 'I', 'i' ]
            THEN
                is_menu := true
            ELSE
                is_menu := false;
            (*ENDIF*) 
            IF  c [2] in [ 'E', 'e' ]
            THEN
                is_example := true
            ELSE
                is_example := false;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            is_menu := false;
            is_example := false;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    packet_pos := packet_pos + hg.pdesc.param_totlen;
    END;
(*ENDIF*) 
END; (* fetch_line *)
 
(*------------------------------*) 
 
PROCEDURE
      in05_trans_line (
            iolen    : tsp00_Int4;
            partpos  : tsp00_Int4;
            VAR line : tin_screenline);
 
VAR
      is_null   : boolean;
      trans_ret : tsp8_uni_error;
      errpos    : tsp00_Int4;
      res_len   : tsp00_Int4;
      uc_line   : tin_double_eline;
 
BEGIN
IF  i20gchar (partpos) = csp_unicode_def_byte
THEN
    BEGIN
    i20g3bval (iolen - 1, partpos, uc_line, is_null);
    res_len := sizeof (line);
    WITH i01g^.multibyte DO
        s80uni_trans (s30gad (uc_line [1]), iolen - 1, unicode_type,
              s30gad (line [1]), res_len, dblang_idx,
              [ ], trans_ret, errpos);
    (*ENDWITH*) 
    END
ELSE
    BEGIN
    IF  iolen - 1 > sizeof (line)
    THEN
        res_len := sizeof (line)
    ELSE
        res_len := iolen - 1;
    (*ENDIF*) 
    i20gbval (res_len, partpos, line, is_null);
    END;
(*ENDIF*) 
SAPDB_PascalForcedFill (sizeof (line),
      @line, res_len + 1, sizeof (line) - res_len, bsp_c1);
END; (* in05_trans_line *)
 
(*===================================================================*)
(*                                                                   *)
(*===================================================================*)
(*------------------------------*) 
 
PROCEDURE
      i05put_header (
            VAR hg : help_global  );
 
VAR
      header : tsp00_OnlineHeader;
 
BEGIN
WITH header DO
    BEGIN
    id_field := hg.component;
    relno_field := hg.release_id;
    mode_field := hg.mode;
    text_field := '                                        ';
    END;
(*ENDWITH*) 
i56title (false, 1, header);
END; (* i05put_header *)
 
(*===================================================================*)
(*===================================================================*)
(*------------------------------*) 
 
PROCEDURE
      select_lines (
            VAR hg     : help_global;
            hid        : tin_help_text_id;
            first_line : integer;
            VAR count  : tsp00_Int4;
            VAR rc     : tsp00_Int2);
 
VAR
      timeout    : boolean;
      ok         : boolean;
      resultname : tsp00_KnlIdentifier;
 
BEGIN
REPEAT
    i20reset (sp1m_dbs);
    p_cmnd ('select i05help_r (            ');
    p_cmnd ('lineno, line, help_mode) from ');
    p_cmnd ('localsysdba.help              ');
    p_cmnd (' where   language =           ');
    i20pccmnd ('''' );
    i20p2cmnd (i01g^.set_parms.language, 3 );
    i20pccmnd ('''' );
    p_cmnd (' and    help_id =             ');
    i20pccmnd ('''' );
    i20p3cmnd (hid, mxsp_c12 );
    i20pccmnd ('''' );
    p_cmnd ('  and   lineno between        ');
    p_int (first_line );
    p_cmnd (' and                          ');
    p_int (first_line + hg.lines_on_screen - 1);
    i20chnginfo (c_with_info);
    in05_execute (timeout, ok, rc);
UNTIL
    NOT timeout OR NOT ok;
(*ENDREPEAT*) 
IF  rc = db_ok
THEN
    in05_get_param (hg.pdesc, ok);
(*ENDIF*) 
resultname :=
      'I05HELP_R                                                       ';
IF  rc = db_ok
THEN
    REPEAT
        i20mfetch (false, sp1m_dbs, hg.lines_on_screen, mf_next, resultname);
        in05_execute (timeout, ok, rc);
    UNTIL
        NOT timeout OR NOT ok;
    (*ENDREPEAT*) 
(*ENDIF*) 
IF  rc = db_ok
THEN
    BEGIN
    i20gcount (count);
    IF  count = 0
    THEN
        rc := db_not_found;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END; (* select_lines *)
 
(*------------------------------*) 
 
PROCEDURE
      in05_get_param (
            VAR pdesc  : param_desc;
            VAR ok     : boolean);
 
VAR
      i       : integer;
      found   : boolean;
      pi      : tsp1_param_info;
 
BEGIN
WITH pdesc DO
    BEGIN
    ok  := true;
    param_totlen := 0;
    FOR i := 1 TO 3 DO
        param_pos [ i ] := 0;
    (*ENDFOR*) 
    i20findpart (sp1pk_shortinfo);
    IF  i01g^.sql_ptr^.curr_part_ptr <> NIL
    THEN
        FOR i := 1 TO 3 DO
            BEGIN
            i20gparaminfo (i, pi, found);
            IF  found
            THEN
                BEGIN
                param_pos   [ i ] := pi.sp1i_bufpos;
                param_iolen [ i ] := pi.sp1i_in_out_len;
                IF  param_totlen < (pi.sp1i_bufpos + pi.sp1i_in_out_len)
                THEN
                    param_totlen := pi.sp1i_bufpos + pi.sp1i_in_out_len - 1;
                (*ENDIF*) 
                END
            ELSE
                ok := false;
            (*ENDIF*) 
            END
        (*ENDFOR*) 
    ELSE
        ok := false;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* in05_get_pos *)
 
(*------------------------------*) 
 
FUNCTION
      i05ifexample : boolean;
 
VAR
      ret    : boolean;
 
BEGIN
ret := false;
WITH i01g^.example DO
    IF  example_set
    THEN
        ret := true;
    (*ENDIF*) 
(*ENDWITH*) 
i05ifexample := ret;
END; (* i05ifexample *)
 
(*------------------------------*) 
 
PROCEDURE
      i05getexample (
            VAR ebuf : tin_eform_buffer;
            VAR evar : tin_eform_vars;
            clear    : boolean;
            VAR ok   : boolean);
 
VAR
      ret        : boolean;
      error      : boolean;
      nextfetch  : boolean;
      firstfetch : boolean;
      count      : integer;
      i          : integer;
      lineno     : integer;
      ln         : integer;
      rc         : tsp00_Int2;
      packet_pos : tsp00_Int4;
      line       : tin_screenline;
      bline      : tin_screenline;
      length     : tin_natural;
      sl         : tin_natural;
      sc         : tin_natural;
      mode       : char;
      pdesc      : param_desc;
 
BEGIN
i51size (cin_ls_workarea, sl, sc);
ret := false;
WITH i01g^.example DO
    BEGIN
    IF  example_set
    THEN
        BEGIN
        IF  clear
        THEN
            BEGIN
            i14cleareform (evar);
            evar.size := mxin_eform_buffer;
            END;
        (*ENDIF*) 
        select_example_lines (example_hid, pdesc, count, rc);
        IF  rc = db_ok
        THEN
            BEGIN
            i20findpart (sp1pk_data);
            packet_pos := 0;
            nextfetch := true;
            firstfetch := true;
            i := 1;
            WHILE i <= count DO
                BEGIN
                IF  nextfetch
                THEN
                    fetch_example_line (packet_pos, lineno,
                          line, mode, pdesc);
                (*ENDIF*) 
                IF  firstfetch
                THEN
                    BEGIN
                    ln := lineno;
                    firstfetch := false;
                    END;
                (*ENDIF*) 
                IF  ln = lineno
                THEN
                    BEGIN
                    length := s30klen (line, bsp_c1, 132);
                    IF  length = 0
                    THEN
                        BEGIN
                        SAPDB_PascalForcedFill (mxin_screenline, @line, 1, sc, bsp_c1);
                        length := sc;
                        i14puteline (ebuf, evar, line,
                              evar.act_line + 1, length, error);
                        evar.act_line := evar.act_line + 1;
                        END
                    ELSE
                        BEGIN
                        i14puteline (ebuf, evar, line,
                              evar.act_line + 1, length, error);
                        END;
                    (*ENDIF*) 
                    nextfetch := true;
                    ln := ln + 1;
                    i := i + 1;
                    END
                ELSE
                    BEGIN
                    SAPDB_PascalForcedFill (mxin_screenline, @bline, 1, sc, bsp_c1);
                    length := sc;
                    nextfetch := false;
                    i14puteline (ebuf, evar, bline,
                          evar.act_line + 1, length, error);
                    evar.act_line := evar.act_line + 1;
                    ln := ln + 1;
                    END;
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  (rc = db_ok) AND NOT error
THEN
    BEGIN
    format_example_lines (ebuf, evar);
    ret := true;
    i01g^.example.example_set := false;
    END;
(*ENDIF*) 
ok := ret;
END;
 
(*------------------------------*) 
 
PROCEDURE
      format_example_lines (
            VAR ebuf : tin_eform_buffer;
            VAR evar : tin_eform_vars);
 
VAR
      lno       : tin_natural;
      llen      : tin_natural;
      p         : tin_natural;
      minblanks : tin_natural;
      line      : tin_eline;
      newline   : tin_eline;
      error     : boolean;
 
BEGIN
minblanks := mxin_eline;
FOR lno := 1 TO evar.lines DO
    BEGIN
    i14geteline (ebuf, evar, line, lno, llen, error);
    IF  llen > 0
    THEN
        BEGIN
        p := 1;
        WHILE (p < llen) AND (line [p] = bsp_c1) DO
            p := p + 1;
        (*ENDWHILE*) 
        IF  p < minblanks
        THEN
            minblanks := p;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDFOR*) 
IF  (minblanks - 1) > 0
THEN
    BEGIN
    FOR lno := 1 TO evar.lines DO
        BEGIN
        i14geteline (ebuf, evar, line, lno, llen, error);
        IF  llen > 0
        THEN
            BEGIN
            llen := llen - (minblanks - 1);
            s10mv (mxin_eline,mxin_eline,
                  @line,minblanks,
                  @newline,1,llen);
            i14puteline (ebuf, evar, newline, lno, llen, error);
            END
        ELSE
            BEGIN
            i14puteline (ebuf, evar, line, lno, llen, error);
            END;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    END;
(*ENDIF*) 
END; (* format_example_lines *)
 
(*------------------------------*) 
 
PROCEDURE
      select_example_lines (
            hid        : tin_help_text_id;
            VAR pdesc  : param_desc;
            VAR count  : integer;
            VAR rc     : tsp00_Int2);
 
VAR
      timeout    : boolean;
      ok         : boolean;
      resultname : tsp00_KnlIdentifier;
      lines      : tin_natural;
 
BEGIN
REPEAT
    i20reset (sp1m_dbs);
    p_cmnd    ('select i05help_r (            ');
    p_cmnd    ('lineno, line, help_mode) from ');
    p_cmnd    ('localsysdba.help              ');
    p_cmnd    (' where   language =           ');
    i20pccmnd ('''');
    i20p2cmnd (i01g^.set_parms.language, 3 );
    i20pccmnd ('''');
    p_cmnd    (' and    help_id =             ');
    i20pccmnd ('''');
    i20p3cmnd (hid, mxsp_c12 );
    i20pccmnd ('''');
    (**)
    p_cmnd    (' and help_mode like ''?E''      ');
    (**)
    (* all lines from hid
          p_cmnd    ('  and   lineno between        ');
          p_int     (first_line );
          p_cmnd    (' and                          ');
          p_int     (last_line );
          *)
    i20chnginfo (c_with_info);
    in05_execute (timeout, ok, rc);
UNTIL
    NOT timeout OR NOT ok;
(*ENDREPEAT*) 
IF  rc = db_ok
THEN
    in05_get_param (pdesc, ok);
(*ENDIF*) 
resultname :=
      'I05HELP_R                                                       ';
lines := csp_maxint2;
IF  rc = db_ok
THEN
    REPEAT
        i20mfetch (false, sp1m_dbs, lines, mf_next, resultname);
        in05_execute (timeout, ok, rc);
    UNTIL
        NOT timeout OR NOT ok;
    (*ENDREPEAT*) 
(*ENDIF*) 
IF  rc = db_ok
THEN
    i20gcount (count);
(*ENDIF*) 
IF  count = 0
THEN
    rc := db_not_found;
(*ENDIF*) 
END; (* select_example_lines *)
 
(*------------------------------*) 
 
PROCEDURE
      fetch_example_line (
            VAR packet_pos      : tsp00_Int4;
            VAR lineno          : integer;
            VAR line            : tin_screenline;
            VAR mode            : char;
            VAR pdesc           : param_desc);
 
VAR
      rc      : tsp00_NumError;
      is_null : boolean;
      lno     : tsp00_C4;
      l       : tsp00_Int2;
      c       : tsp00_C2;
      sl      : tin_natural;
      sc      : tin_natural;
 
BEGIN
i51size (cin_ls_workarea, sl, sc);
SAPDB_PascalForcedFill (mxin_screenline, @line, 1, sc, bsp_c1);
i20g1bval (sizeof(lno), pdesc.param_pos [1] + packet_pos, lno, is_null);
IF  NOT is_null
THEN
    BEGIN
    s40gsint (lno, 1, 4, l, rc);
    lineno := l;
    IF  rc = num_ok
    THEN
        BEGIN
        i20gbval (132, pdesc.param_pos [2] + packet_pos, line, is_null);
        i20g2bval (sizeof(c), pdesc.param_pos [3]+ packet_pos, c, is_null);
        mode := c [2] ;
        END;
    (*ENDIF*) 
    packet_pos := packet_pos + pdesc.param_totlen;
    END;
(*ENDIF*) 
END; (* fetch_example_line *)
 
(*===================================================================*)
(*===================================================================*)
(*------------------------------*) 
 
PROCEDURE
      p_int (
            n : integer );
 
VAR
      d : integer;
      i : integer;
 
BEGIN
d := 1000;
FOR i := 1 TO 4 DO
    BEGIN
    i20pccmnd (chr ((n DIV d ) + ord ('0' )));
    n := n MOD d;
    d := d DIV 10;
    END;
(*ENDFOR*) 
END; (* p_int *)
 
(*===================================================================*)
(*===================================================================*)
(*------------------------------*) 
 
PROCEDURE
      p_cmnd (
            s : tsp00_C30 );
 
VAR
      p : tsp00_C30;
 
BEGIN
p := s;
i20pcmnd (p, 30);
END; (* p_cmnd *)
 
(*===================================================================*)
(*===================================================================*)
(*------------------------------*) 
 
PROCEDURE
      set_msg (
            VAR hg : help_global;
            msgno  : integer );
 
VAR
      p : tin_msg_parms;
      r : tin_msg_type;
      c : tin_component_id;
 
BEGIN
p.length := 0;
c := cin_k_help;
i03msg (msgno, p, hg.msg, r);
hg.msg_set := true;
END; (* set_msg *)
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
