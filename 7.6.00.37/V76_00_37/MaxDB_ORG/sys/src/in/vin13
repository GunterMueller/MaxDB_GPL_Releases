.CM  SCRIPT , Version - 1.1 , last edited by E.Stils
.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VIN13$
.tt 2 $$$
.TT 3 $$dialog_editor_li_functions$$1999-02-17$
***********************************************************
.nf
 
 .nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : dialog_editor_li_functions
=========
.sp
Purpose : Execution of the command line
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              i13exlicmds (
                    VAR eform   : tin_eform_buffer;
                    VAR evars   : tin_eform_vars;
                    VAR display : tin_display_parms;
                    VAR edit    : tin_edit_work_area;
                    VAR cmd     : tin_cmd_type;
                    VAR relkey  : tin_ls_releasemode;
                    VAR kom_nr  : tsp00_Uint1;
                    list        : boolean);
 
        PROCEDURE
              i13doublelicmds (
                    VAR display : tin_display_parms;
                    VAR edit    : tin_edit_work_area;
                    VAR kom_nr  : tsp00_Uint1 );
 
        PROCEDURE
              i13printeform (
                    VAR eform   : tin_eform_buffer;
                    VAR evars   : tin_eform_vars;
                    VAR display : tin_display_parms;
                    VAR relkey  : tin_ls_releasemode;
                    VAR edit    : tin_edit_work_area;
                    close       : boolean);
 
        PROCEDURE
              i13eformprint (
                    VAR eform   : tin_eform_buffer;
                    VAR evars   : tin_eform_vars;
                    VAR header  : tsp00_C40;
                    close       : boolean;
                    VAR vpok    : boolean;
                    VAR errtext : tsp00_ErrText);
 
        PROCEDURE
              i13escex_search_cmd (
                    VAR eform   : tin_eform_buffer;
                    VAR evars   : tin_eform_vars;
                    VAR display : tin_display_parms;
                    VAR edit    : tin_edit_work_area;
                    VAR cmd     : tin_cmd_type;
                    VAR pos     : tsp00_Int2;
                    direction   : boolean;
                    key_cmd     : boolean);
 
        PROCEDURE
              i13sesystem_editor (
                    VAR eform    : tin_eform_buffer;
                    VAR evars    : tin_eform_vars;
                    VAR display  : tin_display_parms;
                    VAR edit     : tin_edit_work_area;
                    VAR cmd      : tin_cmd_type;
                    VAR pos      : tsp00_Int2;
                    VAR exec_ok  : boolean );
 
        PROCEDURE
              i13geget_editor (
                    VAR cmd : tin_cmd_type;
                    VAR pos : tsp00_Int2;
                    VAR ok  : boolean );
 
        PROCEDURE
              i13cschange_string (
                    VAR content      : tin_eline;
                    VAR width        : tin_natural;
                    VAR searchstring : tin_cmd_type;
                    VAR changestring : tin_cmd_type;
                    line_pos         : tsp00_Int2;
                    VAR max_cols     : tin_natural;
                    VAR error        : boolean);
 
        PROCEDURE
              i13ftsfind_this_string (
                    VAR content      : tin_eline;
                    VAR width        : tin_natural;
                    VAR searchstring : tin_cmd_type;
                    VAR line_pos     : tsp00_Int2;
                    direction        : boolean;
                    VAR string_found : boolean);
 
        PROCEDURE
              i13rfread_file (
                    VAR eform      :  tin_eform_buffer;
                    VAR evars      :  tin_eform_vars;
                    VAR display    :  tin_display_parms;
                    VAR edit       :  tin_edit_work_area;
                    VAR fname      :  tsp00_VFilename;
                    VAR line_no    :  integer;
                    VAR line_count :  integer;
                    VAR ignore_crs :  boolean );
 
        PROCEDURE
              i13etfeform_to_file (
                    VAR eform      : tin_eform_buffer;
                    VAR evars      : tin_eform_vars;
                    VAR display    : tin_display_parms;
                    VAR edit       : tin_edit_work_area;
                    VAR line_no    :  integer;
                    VAR line_count :  integer;
                    VAR fname      :  tsp00_VFilename;
                    VAR direction  :  tsp00_VFileOpCodes );
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              global_variable : vin01;
 
        VAR
              i01g   :  tin_global_in_vars;
 
      ------------------------------ 
 
        FROM
              messages : VIN03;
 
        PROCEDURE
              i03int2msg (
                    msg_nr    : integer;
                    int2parms : tsp00_Int2;
                    VAR msg   : tin_screenline;
                    VAR msgt  : tin_msg_type);
 
      ------------------------------ 
 
        FROM
              help     : VIN05;
 
        PROCEDURE
              i05help (
                    hid        : tin_help_text_id;
                    component  : tsp00_C8;
                    release_id : tsp00_C8;
                    VAR ok     : boolean);
 
      ------------------------------ 
 
        FROM
              dialog_editor_functions : VIN11;
 
        PROCEDURE
              i11getdark_eline_count (
                    VAR prefix     : tin_prefix_type;
                    start_this     : tin_natural;
                    this           : integer;
                    VAR dark_count : tin_natural );
 
        FUNCTION
              i11isdark_ln (
                    VAR prefix    : tin_prefix_type;
                    this_eline_no : tin_natural;
                    VAR this_lno  : tin_natural ) : boolean;
 
        FUNCTION
              i11lixbln_in_x_block (
                    VAR prefix    : tin_prefix_type;
                    this          : tin_natural;
                    VAR this_lno  : tin_natural;
                    VAR firstdark : tin_natural ) : boolean;
 
        PROCEDURE
              i11message (
                    msg_id       : tin_edit_msg;
                    VAR msg_text : tin_screenline;
                    VAR err_flag : boolean);
 
      ------------------------------ 
 
        FROM
              dialog_editor_rand_functions : VIN12;
 
        PROCEDURE
              i12pickrand (
                    VAR eform       : tin_eform_buffer;
                    VAR evars       : tin_eform_vars;
                    VAR display     : tin_display_parms;
                    VAR edit        : tin_edit_work_area;
                    VAR first_ins   : tin_natural;
                    VAR last_ins    : tin_natural;
                    VAR first_shift : tin_natural;
                    VAR last_shift  : tin_natural);
 
        PROCEDURE
              i12putrand (
                    VAR eform   : tin_eform_buffer;
                    VAR evars   : tin_eform_vars;
                    VAR display : tin_display_parms;
                    VAR edit    : tin_edit_work_area;
                    numb        : tin_natural);
 
      ------------------------------ 
 
        FROM
              standard_editor_functions : VIN14;
 
        PROCEDURE
              i14cleareform (
                    VAR evars     : tin_eform_vars);
 
        PROCEDURE
              i14sojsplitorjoin (
                    VAR eform      : tin_eform_buffer;
                    VAR evars      : tin_eform_vars;
                    line_no        : tin_natural;
                    scol           : tin_natural;
                    VAR only_split : boolean;
                    VAR only_join  : boolean;
                    max_cols       : tin_natural;
                    VAR error      : boolean);
 
        PROCEDURE
              i14inserteline (
                    VAR eform        : tin_eform_buffer;
                    VAR evars        : tin_eform_vars;
                    line_nr          : tin_natural;
                    line_count       : tin_natural;
                    VAR error        : boolean);
 
        PROCEDURE
              i14geteline (
                    VAR eform     : tin_eform_buffer;
                    VAR evars     : tin_eform_vars;
                    VAR line      : tin_eline;
                    line_nr       : tin_natural;
                    VAR length    : tin_natural;
                    VAR error     : boolean);
 
        PROCEDURE
              i14puteline (
                    VAR eform     : tin_eform_buffer;
                    VAR evars     : tin_eform_vars;
                    VAR line      : tin_eline;
                    line_nr       : tin_natural;
                    length        : tin_natural;
                    VAR error     : boolean);
 
        PROCEDURE
              i14setuplinecount (
                    VAR eform     : tin_eform_buffer;
                    VAR evars     : tin_eform_vars);
 
      ------------------------------ 
 
        FROM
              vp_output : VIN61;
 
        PROCEDURE
              i61close (
                    print       : boolean;
                    VAR errtext : tsp00_ErrText;
                    VAR ok      : boolean);
 
        PROCEDURE
              i61open (
                    VAR printer   : tsp00_PrtName;
                    VAR errtext   : tsp00_ErrText;
                    VAR vpok      : boolean ) ;
 
        PROCEDURE
              i61print (
                    VAR line    : tin_eline ;
                    length      : tsp00_Int2;
                    lfs         : tsp00_VpLinefeeds;
                    VAR errtext : tsp00_ErrText;
                    VAR vpok    : boolean ) ;
 
        FUNCTION
              i61status (
                    VAR printer : tsp00_PrtName) : tin_vp_status;
 
        PROCEDURE
              i61defaulttitle (
                    ktext : tsp00_C12 );
 
        PROCEDURE
              i61title (
                    VAR line : tsp00_PrtLine ;
                    linelen  : tin_natural;
                    linenum  : tin_natural;
                    linefeed : tsp00_VpLinefeeds;
                    linetyp  : tin_vp_titletyp);
 
      ------------------------------ 
 
        FROM
              command - line - history : VIN16;
 
        PROCEDURE
              i16getcmd (
                    VAR cmnd         : tin_cmd_type;
                    VAR ok           : boolean);
 
        PROCEDURE
              i16putcmd (
                    VAR cmnd         : tin_cmd_type);
 
      ------------------------------ 
 
        FROM
              Code-Translation: VIN32;
 
        PROCEDURE
              i32repltabs (
                    fcode       : tsp00_Uint1;
                    phys_buflen : integer;
                    VAR buf     : tsp00_Buf;
                    VAR buflen  : tsp00_Int4);
 
        FUNCTION
              i32machinecodetype : tsp00_Uint1;
 
      ------------------------------ 
 
        FROM
              logical_screen_layout : VIN51;
 
        PROCEDURE
              i51split (
                    screens : tin_natural);
 
        PROCEDURE
              i51size (
                    screen_part : tin_ls_part;
                    VAR length : tin_natural;
                    VAR width : tin_natural);
 
      ------------------------------ 
 
        FROM
              SQLEXEC : VIN71;
 
        PROCEDURE
              i71sqlexec (
                    VAR ex_command    : tsp00_ExecLine;
                    ex_mode           : tsp00_ExecMode;
                    VAR ex_return     : tsp00_ExecReturn;
                    VAR ex_errtext    : tsp00_ErrText;
                    VAR ex_progresult : tsp00_Int2;
                    hold              : boolean;
                    reset_tty         : boolean );
 
      ------------------------------ 
 
        FROM
              RTE_driver : VEN102;
 
        PROCEDURE
              sqlfopen (
                    VAR hostfile   : tsp00_VFilename;
                    direction      : tsp00_VFileOpCodes;
                    resource       : tsp00_VfResource;
                    VAR hostfileno : tsp00_Int4;
                    VAR format     : tsp00_VfFormat;
                    VAR rec_len    : tsp00_Int4;
                    poolptr        : tsp00_Int4;
                    buf_count      : tsp00_Int2;
                    VAR block      : tsp_vf_bufaddr;
                    VAR error      : tsp00_VfReturn;
                    VAR errtext    : tsp00_ErrText);
 
        PROCEDURE
              sqlfread (
                    VAR hostfileno  : tsp00_Int4;
                    block_p : tsp_vf_bufaddr;
                    VAR length  : tsp00_Int4;
                    VAR error   : tsp00_VfReturn;
                    VAR errtext : tsp00_ErrText);
 
        PROCEDURE
              sqlfwrite (
                    VAR hostfileno  : tsp00_Int4;
                    block_p : tsp_vf_bufaddr;
                    length      : tsp00_Int4;
                    VAR error   : tsp00_VfReturn;
                    VAR errtext : tsp00_ErrText);
 
        PROCEDURE
              sqlfclose (
                    VAR hostfileno : tsp00_Int4;
                    erase       : boolean;
                    poolptr     : tsp00_Int4;
                    buf_count   : tsp00_Int2;
                    block       : tsp_vf_bufaddr;
                    VAR error   : tsp00_VfReturn;
                    VAR errtext : tsp00_ErrText);
 
        PROCEDURE
              sqluid (
                    VAR uid : tsp00_TaskId);
 
        PROCEDURE
              sqlferase (
                    VAR hostfile   : tsp00_VFilename;
                    VAR error      : tsp00_VfReturn;
                    VAR errtext    : tsp00_ErrText);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-60   : VSP60;
 
        FUNCTION
              s60tocap (
                    c : char ) : char;
 
        FUNCTION
              s60toupper (
                    c : char ) : char;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedOverlappingMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        FUNCTION
              s20int4_to_int2 (
                    i : tsp00_Int4) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              RTE - Extension - 30 : VSP30;
 
        PROCEDURE
              s30lcm      (
                    VAR buf1     : tin_screenline;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tin_screenline;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
        PROCEDURE
              s30lcm1     (
                    VAR buf1     : tin_eline;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tin_screenline;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
        FUNCTION
              s30klen (
                    VAR str : tin_screenline;
                    val : char;
                    cnt : integer) : integer;
 
        FUNCTION
              s30gad (
                    VAR block : tsp00_Buf) : tsp_vf_bufaddr;
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              s30lcm;
 
              tsp00_MoveObj tin_screenline
              tsp00_MoveObj tin_screenline
 
        PROCEDURE
              s30lcm1;
 
              tsp00_MoveObj tin_eline
              tsp00_MoveObj tin_screenline
 
        PROCEDURE
              s30klen;
 
              tsp00_MoveObj tin_screenline
 
        FUNCTION
              s30gad;
 
              tsp00_MoveObj tsp00_Buf
              tsp00_Addr  tsp_vf_bufaddr
 
        PROCEDURE
              i61print;
 
              tsp00_PrtLine  tin_eline
 
        PROCEDURE
              sqlfopen;
 
              tsp00_VFilename    tsp00_VFilename
              tsp00_VFileOpCodes tsp00_VFileOpCodes
              tsp00_VfResource   tsp00_VfResource
              tsp00_Int4         tsp00_Int4
              tsp00_VfFormat     tsp00_VfFormat
              tsp00_Int4         tsp00_Int4
              tsp00_Int4         tsp00_Int4
              tsp00_Int2         tsp00_Int2
              tsp00_VfBufaddr    tsp_vf_bufaddr
              tsp00_VfReturn     tsp00_VfReturn
              tsp00_ErrText      tsp00_ErrText
 
        PROCEDURE
              sqlfread;
 
              tsp00_Int4       tsp00_Int4
              tsp00_VfBufaddr  tsp_vf_bufaddr
              tsp00_Int4       tsp00_Int4
              tsp00_VfReturn   tsp00_VfReturn
              tsp00_ErrText    tsp00_ErrText
 
        PROCEDURE
              sqlfwrite;
 
              tsp00_Int4      tsp00_Int4
              tsp00_VfBufaddr tsp_vf_bufaddr
              tsp00_Int4      tsp00_Int4
              tsp00_VfReturn  tsp00_VfReturn
              tsp00_ErrText   tsp00_ErrText
 
        PROCEDURE
              sqlfclose;
 
              tsp00_Int4      tsp00_Int4
              tsp00_Int4      tsp00_Int4
              tsp00_Int2      tsp00_Int2
              tsp00_VfBufaddr tsp_vf_bufaddr
              tsp00_VfReturn  tsp00_VfReturn
              tsp00_ErrText   tsp00_ErrText
 
        PROCEDURE
              sqluid;
 
              tsp00_TaskId  tsp00_TaskId
 
        PROCEDURE
              sqlferase;
 
              tsp00_VFilename tsp00_VFilename
              tsp00_VfReturn  tsp00_VfReturn
              tsp00_ErrText   tsp00_ErrText
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1985-02-21
.sp
.cp 3
.sp
.cp 3
Release :      Date : 1999-02-17
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.nf
        PROCEDURE
              i13exlicmds (VAR eform   : eform_type;
                          VAR display : ti_display_parms;
                          VAR edit    : ti_edit_work_area;
                          VAR cmd    : ti_cmd_type;
                          VAR relkey  : ti_ls_releasemode);
.sp;.fo
If anything has been written to the command line,
this procedure is called from i10edit and executes the commands.
If it cannot recognize a valid command, it relinquishes control to
the calling environment.  The following commands are interpreted
by the editor:
.sp
.nf
PUT     -   writes the editor form to external files.
GET     -   reads external files.
SWITCH  -   switches prefix areas.
TOP     -   scrolls to the beginning of the form.
BOTTOM  -   scrolls to the end of the form.
DOWN ( + ) -    scrolls forward in the form.
UP ( - )  -   scrolls back in the form.
LEFT    -   shifts the window to the left
RIGHT   -   shifts the window to the right
RESET   -   deletes the editor area
PRINT   -   prints the editor area
?       -   activates the HELP mechanism of the EDITORS
.fo
.sp 2
It is sufficient if the first three letters of a command are
correctly entered.
.sp 2;.nf
PROCEDURE
      i13_read_cmd (VAR display : ti_display_parms;
                  VAR edit    : ti_edit_work_area;
                  VAR cmd    : ti_cmd_type;
                  VAR relkey  : ti_ls_releasemode);
.sp;.fo
If the parameter display.exec_file is assigned when the editor is
called (not equal to blank), no input is expected from the screen;
instead, the file specified in exec_file is read from.  The editor
transfers to the command line every record that is read in and
executes the command.  After the last record, a changeover
is made to screen input.
.br
This mechanism for batch - type processing of command sequences is
used for testing the dialog components.
.sp 2;.nf
        PROCEDURE
              i13printeform (VAR eform : eform_type;
                          VAR display : ti_display_parms;
                          VAR edit : ti_edit_work_area);
.sp;.fo
The section of eform that has been written to
 (up to eform.length) is output
via a printer.
At the top of each page, the standard screen header
is output.
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
.nf
PROCEDURE
      ex_put_cmd (VAR eform : eform_type;
                  VAR display : ti_display_parms;
                  VAR edit    : ti_edit_work_area;
                  VAR cmd    : ti_cmd_type;
                  VAR pos   : int2);
.sp;
Function:  Writes the editor form to a file
.sp;.fo;.hi  + 3
a) The current contents of the editor form are written to the
specified target file.  The editor form remains unchanged on the screen;
the target file is closed.
.sp;.cp 3
b) The name of the target file is enclosed in single quotation signs
and, in all other respects, conforms to the conventions of the pertinent
operating system.
.sp;.cp 3
c) If the target file already exists and is open, the editor
supplies an appropriate system message and does not write anything
out.
.sp;.cp 3
d) If an unsigned integer n is specified as a <first> option, the
editor begins copying with the nth line of the form
 (form beginning = 1).
.sp;.cp 3
e) If an unsigned integer i is specified as an <amount> option,
the editor terminates the copying procedure, at the latest, after i
lines of the formula have been transferred.
.sp;.cp 3
f) If APPEND is specified, an existing file is not overwritten;
instead, writing is continued at the end.
.sp;.cp 3
g) If no file name is specified, the area of the editor form that is
displayed is written to the PICK buffer.  If an unsigned integer n is
specified as an option, n lines are written to the PICK buffer, beginning
with the first line displayed.
.hi 0
.sp 2
Ex_put_cmd reads the command line starting at position pos and, if the
file name and options are correct, executes the command; otherwise,
an appropriate error message is supplied.
.sp 2;.nf
PROCEDURE
      ex_pick_cmd (VAR eform : eform_type;
                  VAR display : ti_display_parms;
                  VAR edit    : ti_edit_work_area;
                  count  : eline_count);
.sp;.fo
Writes the lines specified in 'count' to the PICK buffer beginning
at the line display.upper_margin of the editor form.
.sp 2;.nf
PROCEDURE
      ex_get_cmd (VAR eform : eform_type;
                  VAR display : ti_display_parms;
                  VAR edit    : ti_edit_work_area;
                  VAR cmd    : ti_cmd_type;
                  VAR pos   : int2);
.sp;
Function: reads from a file.
.sp;.fo;.hi  + 3
a) The specified section of the source file is copied to the editor
form beginning at the target position.  The target position is the line
on which the cursor is located or, if the cursor is not located in the
input area, the first line that is displayed.
.sp;.cp 3
b) In the case of GET, unlike C and CC, no new lines are inserted;
instead, the old line contents are overwritten.
.sp;.cp 3
c) The name of the source file is enclosed in single quotation signs
and, in all other respects, conforms to the conventions of the pertinent
operating system.
.sp;.cp 3
d) If the file is not found or if this file is already
open at the current moment, the editor supplies an appropriate
system message and does not copy anything.
.sp;.cp 3
e) If no options are specified, the editor begins with the first
record of the source file.  The copy procedure is terminated as soon as
either the form is full or the end of the file is reached.
.sp;.cp 3
f) If an unsigned integer n is specified as a first option <first> , the
editor begins copying with the nth record of the source file.  If the
file has less than n records, the editor supplies an appropriate
system message and does not copy anything.
.sp;.cp 3
g) If an unsigned integer i is specified as a second option <amount> ,
the editor terminates the copy procedure, at the latest, after i
records have been transferred from the source file.
.sp;.cp 3
h) If no file name is specified, the contents of the PICK buffer
are copied to the editor form.
The target position is the line on which the cursor is located or,
if the cursor is not located in the input area, the first line
that is displayed.  It is inserted, not overwritten.
.hi 0
.sp 2
Ex_get_cmd reads the command line beginning at position pos and, if
the file name and options are correct, executes the command; otherwise,
an appropriate error message is sent.
.sp 2;.nf
PROCEDURE
      ex_pput_cmd (VAR eform : eform_type;
                  VAR display : ti_display_parms;
                  VAR edit    : ti_edit_work_area);
.sp;.fo
Inserts the contents of the PICK buffer in the editor form.
.sp 2;.nf
PROCEDURE
      read_fname (VAR display : ti_display_parms;
                  VAR cmd    : ti_cmd_type;
                  VAR edit    : ti_edit_work_area;
                  VAR pos     : int2;
                  VAR fname   : hostname);
.sp;.fo
Reads the command line beginning at the position pos and attempts to read
a file name.  If a name enclosed in quotation signs is recognized, it
is entered in fname; otherwise, an error message is sent and
edit.error_found is set to true.
.sp 2;.nf
PROCEDURE
      read_option (VAR display : ti_display_parms;
                  VAR cmd    : ti_cmd_type;
                  VAR edit    : ti_edit_work_area;
                  VAR numb    : integer;
                  VAR pos     : int2;
                  VAR numb_scanned  : boolean);
.sp;.fo
Beginning at the position pos in the command line, attempts to recognize
a valid option.
.br;.nf
Output parameters:
numb_scanned  true if option found; otherwise, false
numb          >= 0  option is a number with this value
               < 0  option is a character string
               - 1  means APPEND (currently the only possibility)
.sp 2
PROCEDURE
      i13rfread_file (VAR eform     :  eform_type;
                  VAR display   :  ti_display_parms;
                  VAR edit      :  ti_edit_work_area;
                  VAR fname     :  hostname;
                  VAR line_no   :  integer;
                  VAR line_count:  integer);
                  VAR ignore_crs:  integer);
.sp;.fo
Copies from a file to the editor form.
.sp;.nf
Input parameters:
fname         file name
line_no       first line in the file to be read
line_count    number of lines to be read
ignore_crs    first line in the editform is cursorpos/1 (false/true)
 
.sp2
PROCEDURE
      ex_top_cmd (VAR eform : eform_type;
                  VAR display : ti_display_parms;
                  VAR edit  : ti_edit_work_area;
                  VAR cmd  : ti_cmd_type);
.sp;.fo
Displays the top of the editor form (by changing 'display').
.sp 2;.nf
PROCEDURE
      ex_bottom_cmd (VAR eform : eform_type;
                  VAR display : ti_display_parms;
                  VAR edit  : ti_edit_work_area;
                  VAR cmd  : ti_cmd_type);
.sp;.fo
Displays the bottom of the editor form (by changing 'display').
.sp 2;.nf
PROCEDURE
      ex_up_cmd (VAR eform : eform_type;
                  VAR display : ti_display_parms;
                  VAR edit  : ti_edit_work_area;
                  VAR cmd  : ti_cmd_type;
                  VAR pos   : int2);
.sp;.fo
When there is no argument, UP or ' - ' has the same effect as the function
key PF7.
.sp
If an unsigned integer n is specified as an argument, the form on the
screen is shifted by n lines toward the top of the form, at most
until the first line of the form is the first line displayed.
.sp
Depending on the option specified, display.upper_margin is converted.
.sp 2;.nf
PROCEDURE
      ex_down_cmd (VAR eform : eform_type;
                  VAR display : ti_display_parms;
                  VAR edit  : ti_edit_work_area;
                  VAR cmd  : ti_cmd_type;
                  VAR pos   : int2);
.sp;.fo
When there is no argument, DOWN or '+' has the same effect as the function
key PF8.
.sp
If an unsigned integer n is specified as an argument, the form is
shifted on the screen by n lines toward the bottom of the form, at
most until the last line of the form is the last line displayed.
.sp
Depending on the option specified, display.upper_margin is converted.
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
 
(*------------------------------*) 
 
PROCEDURE
      i13exlicmds;
 
BEGIN
Read the first 3 letters ofthe command line;
IF   valid command is found
THEN
    attempt To execute it;
(*ENDIF*) 
IF   command is executed
THEN
    delete command line;
(*ENDIF*) 
END;
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
TYPE
      t_wrap_opt     = ( w_on, w_off, w_info );
 
 
(*------------------------------*) 
 
PROCEDURE
      in13_cmndtype (
            VAR cmd     : tin_cmd_type;
            VAR pos     : tsp00_Int2;
            VAR kom_nr  : tsp00_Uint1 );
 
CONST
      max_cmd_cnt  = 32;
 
VAR
      user_com     : tsp00_C8;
      compare_com  : tsp00_C8;
      user_com_num : tsp00_Uint1;
      user_com_len : integer;
      i            : integer;
 
BEGIN
WITH cmd DO
    BEGIN
    kom_nr := 0;
    IF  length > 0
    THEN
        BEGIN
        WHILE (content [ pos ] = ' ') AND (pos <= length) DO
            pos := pos + 1;
        (*ENDWHILE*) 
        CASE content [pos] OF
            '='  :
                BEGIN
                IF  content [ pos + 1 ] = '='
                THEN
                    BEGIN
                    pos := pos + 2;
                    kom_nr := 4;
                    END
                ELSE
                    BEGIN
                    pos := pos + 1;
                    kom_nr := 3;
                    END;
                (*ENDIF*) 
                END;
            '/' :
                BEGIN
                pos := pos + 1;
                kom_nr := 7;
                END;
            '-' :
                BEGIN
                IF  content [ pos + 1 ] = '/'
                THEN
                    BEGIN
                    pos := pos + 2;
                    kom_nr := 8;
                    END
                ELSE
                    BEGIN
                    pos := pos + 1;
                    kom_nr := 13;
                    END;
                (*ENDIF*) 
                END;
            '+' :
                BEGIN
                pos := pos + 1;
                kom_nr := 15;
                END;
            OTHERWISE:
                BEGIN
                user_com := '        ';
                user_com_len := 0;
                WHILE (content [ pos ] <> ' ') AND (pos <= length) DO
                    BEGIN
                    IF  user_com_len < mxsp_c8
                    THEN
                        BEGIN
                        user_com_len := user_com_len + 1;
                        user_com [ user_com_len ] := s60tocap (content [ pos]);
                        END;
                    (*ENDIF*) 
                    pos := pos + 1;
                    END;
                (*ENDWHILE*) 
                WHILE (content [ pos ] = ' ') AND (pos <= length) DO
                    pos := pos + 1;
                (*ENDWHILE*) 
                user_com_num := 0;
                compare_com := '        ';
                REPEAT
                    user_com_num := succ (user_com_num);
                    compare_com  [1]  := user_com  [1] ;
                    in13_cmd_label (user_com_num, compare_com);
                    FOR i := user_com_len + 1 TO mxsp_c8 DO
                        compare_com  [i]  := bsp_c1;
                    (*ENDFOR*) 
                UNTIL
                    (user_com = compare_com) OR (user_com_num = max_cmd_cnt);
                (*ENDREPEAT*) 
                IF  user_com = compare_com
                THEN
                    kom_nr := user_com_num
                ELSE
                    kom_nr := 0;
                (*ENDIF*) 
                IF  (user_com = compare_com) AND (user_com_num < max_cmd_cnt)
                THEN
                    BEGIN
                    REPEAT
                        user_com_num := succ (user_com_num);
                        compare_com  [1]  := user_com  [1] ;
                        in13_cmd_label (user_com_num, compare_com);
                        FOR i := user_com_len + 1 TO mxsp_c8 DO
                            compare_com  [i]  := bsp_c1;
                        (*ENDFOR*) 
                    UNTIL
                        (user_com = compare_com) OR (user_com_num = max_cmd_cnt);
                    (*ENDREPEAT*) 
                    IF  user_com = compare_com
                    THEN
                        kom_nr := 0;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            END;
        (*ENDCASE*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; (* in13_cmndtype *)
 
(*------------------------------*) 
 
PROCEDURE
      in13_cmd_label (
            possible_cmnd : tsp00_Uint1;
            VAR cmd_label : tsp00_C8);
 
BEGIN
CASE cmd_label  [1]  OF
    'B':
        CASE possible_cmnd OF
            11 :
                cmd_label := 'BOTTOM  ';
            32 :
                cmd_label := 'B       ';
            OTHERWISE:
                cmd_label := '        ';
            END;
        (*ENDCASE*) 
    'C':
        CASE possible_cmnd OF
            9  :
                cmd_label := 'CHANGE  ';
            6  :
                cmd_label := 'CLOSE   ';
            OTHERWISE:
                cmd_label := '        ';
            END;
        (*ENDCASE*) 
    'D':
        CASE possible_cmnd OF
            14 :
                cmd_label := 'DOWN    ';
            32 :
                cmd_label := 'D       ';
            OTHERWISE:
                cmd_label := '        ';
            END;
        (*ENDCASE*) 
    'G':
        CASE possible_cmnd OF
            2  :
                cmd_label := 'GET     ';
            32 :
                cmd_label := 'G       ';
            OTHERWISE:
                cmd_label := '        ';
            END;
        (*ENDCASE*) 
    'J':
        CASE possible_cmnd OF
            31 :
                cmd_label := 'JOIN    ';
            32 :
                cmd_label := 'J       ';
            OTHERWISE:
                cmd_label := '        ';
            END;
        (*ENDCASE*) 
    'L':
        CASE possible_cmnd OF
            16 :
                cmd_label := 'LEFT    ';
            32 :
                cmd_label := 'L       ';
            OTHERWISE:
                cmd_label := '        ';
            END;
        (*ENDCASE*) 
    'N':
        CASE possible_cmnd OF
            25 :
                cmd_label := 'NUMBER  ';
            32 :
                cmd_label := 'N       ';
            OTHERWISE:
                cmd_label := '        ';
            END;
        (*ENDCASE*) 
    'P':
        CASE possible_cmnd OF
            5  :
                cmd_label := 'PRINT   ';
            1  :
                cmd_label := 'PUT     ';
            OTHERWISE:
                cmd_label := '        ';
            END;
        (*ENDCASE*) 
    'R':
        CASE possible_cmnd OF
            29 :
                cmd_label := 'RAND    ';
            21 :
                cmd_label := 'RED     ';
            23 :
                cmd_label := 'REPLACE ';
            18 :
                cmd_label := 'RESET   ';
            17 :
                cmd_label := 'RIGHT   ';
            OTHERWISE:
                cmd_label := '        ';
            END;
        (*ENDCASE*) 
    'S':
        CASE possible_cmnd OF
            30 :
                cmd_label := 'SPLITT  ';
            19 :
                cmd_label := 'SWITCH  ';
            27 :
                cmd_label := 'SYSEDIT ';
            OTHERWISE:
                cmd_label := '        ';
            END;
        (*ENDCASE*) 
    'T':
        CASE possible_cmnd OF
            10 :
                cmd_label := 'TOP     ';
            32 :
                cmd_label := 'T       ';
            OTHERWISE:
                cmd_label := '        ';
            END;
        (*ENDCASE*) 
    'U':
        CASE possible_cmnd OF
            12 :
                cmd_label := 'UP      ';
            32 :
                cmd_label := 'U       ';
            OTHERWISE:
                cmd_label := '        ';
            END;
        (*ENDCASE*) 
    'V':
        CASE possible_cmnd OF
            24 :
                cmd_label := 'VED     ';
            28 :
                cmd_label := 'VI      ';
            OTHERWISE:
                cmd_label := '        ';
            END;
        (*ENDCASE*) 
    'W':
        CASE possible_cmnd OF
            26 :
                cmd_label := 'WRAP    ';
            32 :
                cmd_label := 'W       ';
            OTHERWISE:
                cmd_label := '        ';
            END;
        (*ENDCASE*) 
    'X':
        CASE possible_cmnd OF
            22 :
                cmd_label := 'XEDIT   ';
            32 :
                cmd_label := 'X       ';
            OTHERWISE:
                cmd_label := '        ';
            END;
        (*ENDCASE*) 
    OTHERWISE:
        cmd_label := bsp_c8;
    END;
(*ENDCASE*) 
END; (* in13_cmd_label *)
 
(*------------------------------*) 
 
PROCEDURE
      i13exlicmds (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            VAR cmd     : tin_cmd_type;
            VAR relkey  : tin_ls_releasemode;
            VAR kom_nr  : tsp00_Uint1;
            list        : boolean);
 
CONST
      edit_id    = '04          ';
      sforward   = true;
      sbackward  = false;
      print      = false;
      close      = true;
      exists_ved = false;
 
VAR
      ok           : boolean;
      error        : boolean;
      pos          : tsp00_Int2;
      inarea_width : tin_natural;
      is_spl       : boolean;
      wrap_opt     : t_wrap_opt;
      only_split   : boolean;
      only_join    : boolean;
 
BEGIN
pos := 1;
in13_cmndtype (cmd, pos, kom_nr);
IF  NOT ( kom_nr in [ 3, 4] )
THEN
    i16putcmd (cmd);
(*ENDIF*) 
IF  kom_nr = 0
THEN
    edit.e_cmd := false
ELSE
    BEGIN
&   ifdef WINDOWS
    IF  kom_nr in [10..17, 19, 21..22, 25, 26, 28..30]
    THEN
        kom_nr := 99;
&   endif
    (*ENDIF*) 
    IF  kom_nr in [ 28, 29 ]
    THEN
        kom_nr := 99;
    (*ENDIF*) 
    IF  list AND NOT ( kom_nr in [ 1, 3..8, 10..17] )
    THEN
        kom_nr := 99;
    (*ENDIF*) 
    IF  NOT ( kom_nr in [ 3, 4, 7, 8, 9] )
    THEN
        edit.last_search_cmd.length := 0;
    (*ENDIF*) 
    WITH display DO
        CASE kom_nr OF
            1 :
                ex_put_cmd (eform, evars, display, edit, cmd, pos);
            2 :
                ex_get_cmd (eform, evars, display, edit, cmd, pos);
            3 :
                BEGIN
                edit.error_found := true;
                edit.error_type := ocmd_error;
                i16getcmd (cmd, ok);
                IF  NOT ok
                THEN
                    cmd.length := 0;
                (*ENDIF*) 
                display.csr_pos.scol := cin_ocmd_scol + cmd.length;
                END;
            4 :
                BEGIN
                edit.csr_set_by_user := false;
                WITH csr_pos DO
                    BEGIN
                    screen_part := cin_ls_workarea;
                    i51size (cin_ls_workarea, sline, inarea_width);
                    (* last line *)
                    scol := cin_ocmd_scol;
                    END;
                (*ENDWITH*) 
                i16getcmd (cmd, ok);
                IF  NOT ok
                THEN
                    cmd.length := 0
                ELSE
                    i13exlicmds (eform, evars, display,
                          edit, cmd, relkey, kom_nr, list);
                (*ENDIF*) 
                END;
            5 :
                i13printeform (eform, evars,
                      display, relkey, edit, print);
            6 :
                i13printeform (eform, evars,
                      display, relkey, edit, close);
            7 :
                i13escex_search_cmd (eform, evars, display, edit,
                      cmd, pos, sforward, false);
            8 :
                i13escex_search_cmd (eform, evars, display, edit,
                      cmd, pos, sbackward, false);
            9, 23 :
                ex_change_cmd (eform, evars, display, edit, cmd, pos);
            10 :
                ex_top_cmd (display, edit);
            11 :
                ex_bottom_cmd (display, edit, evars);
            12, 13 :
                ex_up_cmd (display, edit, cmd, pos);
            14, 15 :
                ex_down_cmd (display, edit, cmd, pos);
            16 :
                frame [ edit.current_eform] .left_margin := 1;
            17 :
                BEGIN
                IF  NOT wrap
                THEN
                    frame [ edit.current_eform] .left_margin := (
                          frame [ edit.current_eform] .max_cols
                          + 1)
                          - edit.ecols_on_screen
                ELSE
                    i11message (wrap_on,
                          frame [ edit.current_eform] .sys_msg,
                          frame [ edit.current_eform] .is_error);
                (*ENDIF*) 
                END;
            18 :
                BEGIN
                i14cleareform (evars);
                frame [ edit.current_eform] .upper_margin := 1;
                frame [ edit.current_eform] .left_margin := 1;
                changed := true;
                edit.prefix.length := 0;
                edit.msg_id := ok_msg;
                edit.csr_set_by_user := false;
                display.csr_pos.scol := edit.first_edit_scol;
                display.csr_pos.sline := 1;
                display.csr_pos.screen_part := cin_ls_workarea;
                edit.mark1 := false;
                edit.mark1_line := 0;
                edit.mark1_line := 0;
                edit.mark2_scol := 0;
                edit.mark2_scol := 0;
                END;
            19 :
                IF  i01g^.set_parms.editor <> no_prefix
                THEN
                    IF  i01g^.set_parms.editor = prefix_left
                    THEN
                        BEGIN
                        i01g^.set_parms.editor := prefix_right;
                        i01g^.set_parms.change := true;
                        edit.first_edit_scol := cin_first_scol;
                        END
                    ELSE
                        BEGIN
                        i01g^.set_parms.editor := prefix_left;
                        i01g^.set_parms.change := true;
                        edit.first_edit_scol := cin_firsteditscol;
                        END
                    (*ENDIF*) 
                ELSE
                    edit.e_cmd := false;
                (*ENDIF*) 
            20 :
                BEGIN
                is_spl := split_screen;
                IF  is_spl
                THEN
                    i51split(1);
                (*ENDIF*) 
                i05help (edit_id, frame  [1] .header.id_field,
                      frame  [1] .header.relno_field, ok);
                IF  is_spl
                THEN
                    i51split(2);
                (*ENDIF*) 
                IF  NOT ok
                THEN
                    i11message (no_info,
                          frame [ edit.current_eform] .sys_msg,
                          frame [ edit.current_eform] .is_error);
                (*ENDIF*) 
                END;
            21 :
                IF  i01g^.set_parms.editor <> no_prefix
                THEN
                    BEGIN
                    i01g^.set_parms.editor := no_prefix;
                    i01g^.set_parms.change := true;
                    edit.first_edit_scol := cin_first_scol;
                    edit.ecols_on_screen := edit.ecols_on_screen + 5;
                    END;
                (*ENDIF*) 
            22 :
                IF  i01g^.set_parms.editor = no_prefix
                THEN
                    BEGIN
                    i01g^.set_parms.editor := prefix_left;
                    edit.first_edit_scol := cin_firsteditscol;
                    edit.ecols_on_screen := edit.ecols_on_screen - 5;
                    i01g^.set_parms.change := true;
                    wrap := false;
                    END;
                (*ENDIF*) 
            24 :
                IF  exists_ved
                THEN
                    BEGIN
                    i01g^.set_parms.editor := vax;
                    i01g^.set_parms.change := true;
                    END
                ELSE
                    edit.e_cmd := false;
                (*ENDIF*) 
            25 :
                BEGIN
                i01g^.set_parms.numeric_prefix :=
                      NOT i01g^.set_parms.numeric_prefix;
                i01g^.set_parms.change := true;
                END;
            27 :
                BEGIN
                i13geget_editor ( cmd, pos, ok );
                IF  ok
                THEN
                    i13sesystem_editor ( eform, evars, display, edit,
                          cmd, pos, ok )
                ELSE
                    i11message ( not_implemented,
                          frame [ edit.current_eform] .sys_msg,
                          frame [ edit.current_eform] .is_error);
                (*ENDIF*) 
                END;
            28 :
                BEGIN
                cmd.content [ pos ] := 'v';
                cmd.content [ pos + 1 ] := 'i';
                cmd.length  := cmd.length + 2;
                i13sesystem_editor ( eform, evars, display, edit,
                      cmd, pos, ok );
                cmd.length  := cmd.length - 2;
                END;
            29 :
                BEGIN
                cmd.content [ pos ] := 'e';
                cmd.length  := cmd.length + 1;
                i13sesystem_editor ( eform, evars, display, edit,
                      cmd, pos, ok );
                cmd.length  := cmd.length - 1;
                END;
            26 :
                BEGIN
                read_wrap_opt ( cmd, wrap_opt, pos );
                CASE wrap_opt OF
                    w_info :
                        BEGIN
                        IF  wrap
                        THEN
                            i11message (wrap_on,
                                  frame [ edit.current_eform] .sys_msg,
                                  frame [ edit.current_eform] .is_error)
                        ELSE
                            i11message (wrap_off,
                                  frame [ edit.current_eform] .sys_msg,
                                  frame [ edit.current_eform] .is_error);
                        (*ENDIF*) 
                        END;
                    w_off  :
                        BEGIN
                        wrap := false;
                        i11message (wrap_off,
                              frame [ edit.current_eform] .sys_msg,
                              frame [ edit.current_eform] .is_error);
                        END;
                    w_on   :
                        BEGIN
                        IF  i01g^.set_parms.editor <> no_prefix
                        THEN
                            i11message ( red_cmd,
                                  frame [ edit.current_eform] .sys_msg,
                                  frame [ edit.current_eform] .is_error)
                        ELSE
                            BEGIN
                            wrap := true;
                            frame [ edit.current_eform] .left_margin := 1;
                            i11message (wrap_on,
                                  frame [ edit.current_eform] .sys_msg,
                                  frame [ edit.current_eform] .is_error);
                            END;
                        (*ENDIF*) 
                        END;
                    END;
                (*ENDCASE*) 
                END;
            30 :
                BEGIN
                only_split := true;
                only_join  := false;
                i14sojsplitorjoin ( eform, evars, edit.mark2_line,
                      edit.mark2_scol, only_split, only_join,
                      frame [active_screen] .max_cols, error);
                END;
            31 :
                BEGIN
                only_split := false;
                only_join  := true;
                i14sojsplitorjoin ( eform, evars, edit.mark2_line,
                      edit.mark2_scol, only_split, only_join,
                      frame [active_screen] .max_cols, error);
                END;
            OTHERWISE:
                edit.e_cmd := false;
            END;
        (*ENDCASE*) 
    (*ENDWITH*) 
    END;
(*ENDIF*) 
IF  (NOT edit.error_found) AND (edit.e_cmd)
THEN
    BEGIN
    reset_ocmd_line (cmd);
    IF  NOT (kom_nr in [ 7, 8, 18])
    THEN
        BEGIN
        edit.csr_set_by_user := false;
        display.csr_pos.scol := cin_ocmd_scol;
        display.csr_pos.sline := 1;
        display.csr_pos.screen_part := cin_ls_inputarea;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i13doublelicmds (
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            VAR kom_nr  : tsp00_Uint1 );
 
BEGIN
WITH display DO
    CASE kom_nr OF
        19 :
            IF  ( i01g^.set_parms.editor = prefix_right )
                AND ( i01g^.set_parms.change = true )
            THEN
                BEGIN
                edit.first_edit_scol := cin_first_scol;
                END
            ELSE
                BEGIN
                IF  ( i01g^.set_parms.editor = prefix_left )
                    AND (  i01g^.set_parms.change = true )
                THEN
                    edit.first_edit_scol := cin_firsteditscol;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        21 :
            IF  ( i01g^.set_parms.editor = no_prefix )
                AND  ( i01g^.set_parms.change = true )
            THEN
                BEGIN
                edit.first_edit_scol := cin_first_scol;
                edit.ecols_on_screen := edit.ecols_on_screen + 5;
                END;
            (*ENDIF*) 
        22 :
            IF  ( i01g^.set_parms.editor = prefix_left )
                AND ( i01g^.set_parms.change = true )
            THEN
                BEGIN
                edit.first_edit_scol := cin_firsteditscol;
                edit.ecols_on_screen := edit.ecols_on_screen - 5;
                END;
            (*ENDIF*) 
        OTHERWISE:
        END;
    (*ENDCASE*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i13printeform (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            VAR display : tin_display_parms;
            VAR relkey  : tin_ls_releasemode;
            VAR edit    : tin_edit_work_area;
            close       : boolean);
 
VAR
      i              : integer;
      vpok           : boolean;
      errtext        : tsp00_ErrText;
      print_count    : tin_natural;
      this           : tin_natural;
      p_width        : tin_natural;
      content        : tin_eline;
      error          : boolean;
      helptxt        : tsp00_C12;
 
BEGIN
IF  NOT close
THEN
    BEGIN
    (* ======================= *)
    (*  print output defaults  *)
    (* ======================= *)
    IF  evars.lines > 0
    THEN
        BEGIN
        WITH i01g^.set_parms.printformat DO
            i61open (printerset [act_print].printer, errtext, vpok);
        (*ENDWITH*) 
        IF  vpok
        THEN
            BEGIN
            print_count := 0;
            this := 1;
            WITH display.frame[edit.current_eform] DO
                BEGIN
                helptxt := bsp_c12;
                FOR i := 1 TO 8 DO
                    helptxt[i] := header.id_field[i];
                (*ENDFOR*) 
                i61defaulttitle (helptxt);
                END;
            (*ENDWITH*) 
            WHILE ( vpok AND (print_count < evars.lines) ) DO
                BEGIN
                i14geteline (eform, evars,
                      content, this, p_width, error);
                IF  (p_width = 0) AND NOT error
                THEN
                    BEGIN
                    p_width := 1;
                    content [p_width] := bsp_c1;
                    END;
                (*ENDIF*) 
                i61print (content, p_width, vp_onelf, errtext, vpok);
                print_count := print_count + 1;
                this := this + 1;
                END;
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        IF  NOT vpok
        THEN
            BEGIN
            edit.error_found := true;
            edit.error_type := relkey_error;
            edit.print_now := true;
            WITH display DO
                i11message (printer_not_ok,
                      frame [ edit.current_eform] .sys_msg,
                      frame [ edit.current_eform] .is_error);
            (*ENDWITH*) 
            END
        ELSE
            WITH display DO
                IF  relkey = f8
                THEN
                    i11message (print_enqueued,
                          frame [ edit.current_eform] .sys_msg,
                          frame [ edit.current_eform] .is_error)
                ELSE
                    i11message (ok_change,
                          frame [ edit.current_eform] .sys_msg,
                          frame [ edit.current_eform] .is_error);
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        WITH display DO
            i11message (eform_empty, frame [ edit.current_eform] .sys_msg,
                  frame [ edit.current_eform] .is_error);
        (*ENDWITH*) 
        edit.print_now := true;
        END;
    (*ENDIF*) 
    END
ELSE
    WITH i01g^.set_parms.printformat DO
        BEGIN
        IF  i61status (printerset [act_print].printer) = vp_used
        THEN
            BEGIN
            i61close (true, errtext, vpok);
            IF  vpok
            THEN
                WITH display DO
                    i11message (print_out,
                          frame [ edit.current_eform] .sys_msg,
                          frame [ edit.current_eform] .is_error)
                (*ENDWITH*) 
            ELSE
                WITH display DO
                    i11message (printer_not_ok,
                          frame [ edit.current_eform] .sys_msg,
                          frame [ edit.current_eform] .is_error)
                (*ENDWITH*) 
            (*ENDIF*) 
            END
        ELSE
            WITH display DO
                i11message (no_print, frame [ edit.current_eform] .sys_msg,
                      frame [ edit.current_eform] .is_error);
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i13eformprint (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            VAR header  : tsp00_C40;
            close       : boolean;
            VAR vpok    : boolean;
            VAR errtext : tsp00_ErrText);
 
VAR
      print_count    : tin_natural;
      this           : tin_natural;
      p_width        : tin_natural;
      content        : tin_eline;
      error          : boolean;
 
BEGIN
(* ======================= *)
(*  print output defaults  *)
(* ======================= *)
IF  NOT close
THEN
    BEGIN
    i14setuplinecount (eform, evars);
    IF  evars.lines > 0
    THEN
        BEGIN
        WITH i01g^.set_parms.printformat DO
            i61open (printerset [act_print].printer, errtext, vpok);
        (*ENDWITH*) 
        IF  vpok
        THEN
            BEGIN
            print_count := 0;
            this := 1;
            define_header (header);
            WHILE ( vpok AND (print_count < evars.lines) ) DO
                BEGIN
                i14geteline (eform, evars,
                      content, this, p_width, error);
                IF  (p_width = 0) AND NOT error
                THEN
                    BEGIN
                    p_width := 1;
                    content [p_width] := bsp_c1;
                    END;
                (*ENDIF*) 
                i61print (content, p_width, vp_onelf, errtext, vpok);
                print_count := print_count + 1;
                this := this + 1;
                END;
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END
ELSE
    WITH i01g^.set_parms.printformat DO
        IF  i61status (printerset [act_print].printer) = vp_used
        THEN
            i61close (true, errtext, error);
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      define_header (
            VAR header  : tsp00_C40 );
 
CONST
      date_string = '$%D$                                    ';
      date_len    = 4;
      page_string = '$%P$                                    ';
      page_len    = 8;
 
VAR
      line       : tsp00_PrtLine;
      col, i     : tsp00_Int2;
      helpstr    : tsp00_C40;
 
BEGIN
SAPDB_PascalForcedFill ( mxin_prline, @line, 1, mxin_prline, bsp_c1 );
col := 1;
helpstr := date_string;
s10mv (40,mxin_prline,
      @helpstr,1,
      @line,col,date_len);
col := col + date_len;
s10mv (40,mxin_prline,
      @header,1,
      @line,col,40);
col := col + 40;
helpstr := page_string;
s10mv (40,mxin_prline,
      @helpstr,1,
      @line,col,page_len);
col := col + page_len;
i61title (line, col, 1, vp_onelf, vp_toptitle);
SAPDB_PascalForcedFill (mxin_prline, @line, 1, mxin_prline, '-');
i61title (line, mxin_prline, 2, vp_onelf, vp_toptitle);
i61title (line, mxin_prline, 1, vp_onelf, vp_bottitle);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ex_change_cmd (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            VAR cmd     : tin_cmd_type;
            VAR pos     : tsp00_Int2);
 
VAR
      searchstring   : tin_cmd_type;
      changestring   : tin_cmd_type;
      line_pos       : tsp00_Int2;
      string_found   : boolean;
      this           : tin_natural;
      error          : boolean;
      width          : tin_natural;
      line_count     : tin_natural;
      ch             : tin_natural;
      ch_count       : tin_natural;
      occ_count      : tsp00_Int2;
      old_occ_count  : tsp00_Int2;
      content        : tin_eline;
      msgt           : tin_msg_type;
 
BEGIN
string_found := false;
WITH display DO
    this := frame [ edit.current_eform] .upper_margin;
(*ENDWITH*) 
line_pos := 1;
line_count := 1;
ch_count := 1;
occ_count := 0;
old_occ_count := 0;
searchstring.length := 0;
changestring.length := 0;
WHILE (pos <= cmd.length) AND (cmd.content [ pos ] = ' ')  DO
    pos := pos + 1;
(*ENDWHILE*) 
IF  (cmd.content [ pos ] = '/') AND (pos < cmd.length)
THEN
    pos := pos + 1
ELSE
    edit.error_found := true;
(*ENDIF*) 
IF  NOT edit.error_found
THEN
    BEGIN
    read_string (cmd, searchstring, pos, false);
    IF  (cmd.content [ pos ] <> '/') OR (pos >= cmd.length)
    THEN
        edit.error_found := true
    ELSE
        BEGIN
        pos := pos + 1;
        read_string (cmd, changestring, pos, false);
        IF  (changestring.length = 0) AND
            (searchstring.length = 0)
        THEN
            edit.error_found := true
        ELSE
            IF  (cmd.content [ pos ] <> '/') OR (pos > cmd.length)
            THEN
                WHILE changestring.content [ changestring.length ] = ' '
                      DO
                    changestring.length := changestring.length - 1
                (*ENDWHILE*) 
            ELSE
                BEGIN
                WITH display DO
                    read_ch_options (cmd, pos, line_count, ch_count,
                          frame [ edit.current_eform] .max_cols );
                (*ENDWITH*) 
                IF  (line_count = 0) OR (ch_count = 0)
                THEN
                    edit.error_found := true;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  edit.error_found
THEN
    BEGIN
    edit.msg_id := no_change;
    edit.error_type := ocmd_error;
    display.csr_pos.scol := cin_ocmd_scol + cmd.length;
    WITH display DO
        i11message (edit.msg_id, frame [ edit.current_eform] .sys_msg,
              frame [ edit.current_eform] .is_error);
    (*ENDWITH*) 
    END
ELSE
    BEGIN
    line_count := display.frame [ edit.current_eform] .upper_margin +
          line_count - 1;
    IF  line_count > evars.lines
    THEN
        line_count := evars.lines;
    (*ENDIF*) 
    WITH display DO
        FOR this := frame [ edit.current_eform] .upper_margin TO
              line_count DO
            BEGIN
            ch := 1;
            i14geteline (eform, evars, content, this, width, error);
            IF  searchstring.length = 0
            THEN
                BEGIN
                i13cschange_string (content, width, searchstring,
                      changestring, line_pos,
                      frame [ edit.current_eform] .max_cols, error);
                IF  NOT error
                THEN
                    occ_count := occ_count + 1
                (*ENDIF*) 
                END
            ELSE
                WHILE  (line_pos + searchstring.length - 1 <=
                      width) AND (ch <= ch_count) DO
                    BEGIN
                    REPEAT
                        IF  line_pos + searchstring.length - 1 <=
                            width
                        THEN
                            i13ftsfind_this_string (content, width,
                                  searchstring,
                                  line_pos, true, string_found);
                        (*ENDIF*) 
                    UNTIL
                        (string_found) OR
                        (line_pos + searchstring.length - 1 > width);
                    (*ENDREPEAT*) 
                    IF  string_found
                    THEN
                        BEGIN
                        i13cschange_string (content, width, searchstring,
                              changestring, line_pos,
                              display.frame [ edit.current_eform] .max_cols,
                              error);
                        IF  NOT error
                        THEN
                            BEGIN
                            ch := ch + 1;
                            line_pos := line_pos
                                  + changestring.length;
                            occ_count := occ_count  + 1;
                            END
                        ELSE
                            line_pos :=
                                  frame [ edit.current_eform] .max_cols + 1;
                        (*ENDIF*) 
                        string_found := false;
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWHILE*) 
            (*ENDIF*) 
            i14puteline (eform, evars, content, this, width, error);
            IF  error
            THEN
                occ_count := old_occ_count
            ELSE
                old_occ_count := occ_count;
            (*ENDIF*) 
            line_pos := 1;
            END;
        (*ENDFOR*) 
    (*ENDWITH*) 
    IF  occ_count > 0
    THEN
        BEGIN
        edit.msg_id := ok_change;
        display.changed := true;
        WITH display DO
            i03int2msg ( 17212, occ_count,
                  frame [ edit.current_eform] .sys_msg, msgt);
        (*ENDWITH*) 
        END
    ELSE
        BEGIN
        edit.error_found := true;
        edit.msg_id := no_change;
        edit.error_type := ocmd_error;
        display.csr_pos.scol := cin_ocmd_scol + cmd.length;
        WITH display DO
            i11message (edit.msg_id, frame [ edit.current_eform] .sys_msg,
                  frame [ edit.current_eform] .is_error);
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i13cschange_string (
            VAR content      : tin_eline;
            VAR width        : tin_natural;
            VAR searchstring : tin_cmd_type;
            VAR changestring : tin_cmd_type;
            line_pos         : tsp00_Int2;
            VAR max_cols     : tin_natural;
            VAR error        : boolean);
 
VAR
      buflen : tin_natural;
 
BEGIN
error := false;
IF  width - searchstring.length + changestring.length > max_cols
THEN
    error := true
ELSE
    BEGIN
    buflen := width + 1;
    delspace (content, buflen, line_pos, searchstring.length);
    addspace (content, buflen, line_pos, changestring.length);
    width := buflen - 1;
    s10mv (mxin_eline,mxin_eline,
          @changestring.content,1,
          @content,line_pos,changestring.length);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i13escex_search_cmd (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            VAR cmd     : tin_cmd_type;
            VAR pos     : tsp00_Int2;
            direction   : boolean;
            key_cmd     : boolean);
 
VAR
      searchstring   : tin_cmd_type;
 
BEGIN
searchstring.length := 0;
IF  pos <= cmd.length
THEN
    BEGIN
    read_string (cmd, searchstring, pos, key_cmd );
    IF  cmd.content [ pos ] <> '/'
    THEN
        WHILE searchstring.content [ searchstring.length ] = ' ' DO
            searchstring.length := searchstring.length - 1;
        (*ENDWHILE*) 
    (*ENDIF*) 
    IF  searchstring.length > 0
    THEN
        find_string (eform, evars, display, edit,
              searchstring, key_cmd, direction);
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      read_wrap_opt (
            VAR cmd          : tin_cmd_type;
            VAR wrap_opt     : t_wrap_opt;
            VAR pos          : tsp00_Int2);
 
BEGIN
wrap_opt := w_info;
WHILE (pos <= cmd.length) AND
      (cmd.content [ pos ] = ' ') DO
    pos := pos + 1;
(*ENDWHILE*) 
IF  s60toupper ( cmd.content [ pos ] ) = 'O'
THEN
    BEGIN
    pos := pos + 1;
    IF  s60toupper ( cmd.content [ pos ] ) = 'N'
    THEN
        BEGIN
        pos := pos + 1;
        wrap_opt := w_on;
        END
    ELSE
        IF  ( s60toupper ( cmd.content [ pos ] ) = 'F' )
            AND ( s60toupper ( cmd.content [ pos+1 ] ) = 'F' )
        THEN
            BEGIN
            pos := pos + 2;
            wrap_opt := w_off;
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      read_string (
            VAR cmd          : tin_cmd_type;
            VAR searchstring : tin_cmd_type;
            VAR pos          : tsp00_Int2;
            key_cmd          : boolean );
 
BEGIN
WHILE ( pos <= cmd.length ) AND  ( cmd.content [ pos ] <> '/')
      OR ( ( pos <= cmd.length ) AND key_cmd ) DO
    BEGIN
    searchstring.length := searchstring.length + 1;
    searchstring.content [ searchstring.length ] :=  cmd.content [ pos] ;
    pos := pos + 1;
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      find_string (
            VAR eform         : tin_eform_buffer;
            VAR evars         : tin_eform_vars;
            VAR display       : tin_display_parms;
            VAR edit          : tin_edit_work_area;
            VAR searchstring  : tin_cmd_type;
            key_cmd           : boolean;
            direction         : boolean);
 
VAR
      this             : tin_natural;
      upper_m          : tin_natural;
      line_pos         : tsp00_Int2;
      string_found     : boolean;
      error            : boolean;
      second_search    : boolean;
      line_count       : tin_natural;
      search_count     : tsp00_Int2;
      res              : tsp00_LcompResult;
      screen_offset    : tin_natural;
      content          : tin_eline;
      width            : tin_natural;
 
BEGIN
string_found := false;
second_search := false;
screen_offset := 0;
line_count := 1;
line_pos   := 1;
search_count := 1;
res := l_less;
WITH display DO
    this := frame [ edit.current_eform] .upper_margin;
(*ENDWITH*) 
upper_m := this;
IF  searchstring.length = edit.last_search_cmd.length
THEN
    s30lcm ( searchstring.content, 1, searchstring.length,
          edit.last_search_cmd.content, 1, searchstring.length, res );
(*ENDIF*) 
IF  key_cmd  AND ( res <> l_equal )
THEN
    i16putcmd ( searchstring );
(*ENDIF*) 
IF  direction
THEN
    BEGIN
    IF  res = l_equal
    THEN
        BEGIN
        screen_offset := 1;
        IF  ( edit.last_search_line >= upper_m ) AND
            ( edit.last_search_line <= upper_m + edit.lines_on_screen )
        THEN
            BEGIN
            second_search := true;
            screen_offset := edit.last_search_line - upper_m;
            END
        ELSE
            screen_offset := 0;
        (*ENDIF*) 
        this     := edit.last_search_line;
        line_pos := edit.last_search_col + 1;
        END;
    (*ENDIF*) 
    WITH display DO
        IF  evars.lines > upper_m
        THEN
            line_count := evars.lines - upper_m + 1 - screen_offset;
        (*ENDIF*) 
    (*ENDWITH*) 
    END
ELSE
    BEGIN
    this := this + edit.lines_on_screen - 1;
    IF  evars.lines < this
    THEN
        this := evars.lines;
    (*ENDIF*) 
    WITH display DO
        line_pos :=
              frame [ edit.current_eform] .max_cols;
    (*ENDWITH*) 
    IF  res = l_equal
    THEN
        BEGIN
        screen_offset := 1;
        IF  ( edit.last_search_line >= upper_m ) AND
            ( edit.last_search_line <= upper_m + edit.lines_on_screen )
        THEN
            BEGIN
            second_search := true;
            screen_offset := edit.lines_on_screen + upper_m -
                  edit.last_search_line;
            END
        ELSE
            screen_offset := 0;
        (*ENDIF*) 
        this := edit.last_search_line;
        IF  edit.last_search_col >= searchstring.length
        THEN
            line_pos := edit.last_search_col - 1
        ELSE
            IF  this > 1
            THEN
                BEGIN
                this := this - 1;
                WITH display DO
                    line_pos :=
                          frame [ edit.current_eform] .max_cols;
                (*ENDWITH*) 
                END
            ELSE
                BEGIN
                this := 1;
                line_pos := 0;
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    WITH display DO
        line_count := upper_m + edit.lines_on_screen - 1 - screen_offset;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
IF  direction
THEN
    REPEAT
        i14geteline (eform, evars, content, this, width, error);
        IF  line_pos + searchstring.length - 1 <= width
        THEN
            i13ftsfind_this_string (content, width, searchstring,
                  line_pos, direction, string_found)
        ELSE
            BEGIN
            line_pos := 1;
            this     := this + 1;
            search_count := search_count + 1;
            END;
        (*ENDIF*) 
    UNTIL
        ( string_found ) OR ( search_count - 1  > line_count )
    (*ENDREPEAT*) 
ELSE
    REPEAT
        i14geteline (eform, evars, content, this, width, error);
        IF  ( width >= searchstring.length ) AND  ( line_pos >= 1 )
        THEN
            BEGIN
            IF  line_pos > ( width - searchstring.length )
            THEN
                line_pos := 1 + width - searchstring.length;
            (*ENDIF*) 
            REPEAT
                i13ftsfind_this_string (content, width, searchstring,
                      line_pos, direction, string_found);
            UNTIL
                ( string_found ) OR ( line_pos < 1 );
            (*ENDREPEAT*) 
            END;
        (*ENDIF*) 
        IF  NOT string_found
        THEN
            BEGIN
            IF  this > 1
            THEN
                BEGIN
                WITH display DO
                    line_pos :=
                          frame [ edit.current_eform] .max_cols;
                (*ENDWITH*) 
                this := this - 1;
                search_count := search_count + 1;
                END
            ELSE
                search_count := line_count + 2;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    UNTIL
        ( string_found ) OR ( search_count - 1  > line_count );
    (*ENDREPEAT*) 
(*ENDIF*) 
IF  string_found
THEN
    set_show_parms (display, edit, searchstring,
          this, line_pos);
(*ENDIF*) 
edit.last_search_cmd := searchstring;
edit.csr_set_by_user := false;
edit.csr_switch      := false;
IF  NOT string_found
THEN
    BEGIN
    (* IF  NOT second_search OR ( res = l_equal ) *)
    IF  NOT second_search
    THEN
        BEGIN
        edit.last_search_cmd.length := 0;
        edit.error_found := true;
        display.csr_pos.scol := cin_ocmd_scol + searchstring.length;
        END
    ELSE
        set_show_parms ( display, edit, edit.last_search_cmd,
              edit.last_search_line, edit.last_search_col );
    (*ENDIF*) 
    edit.msg_id     := no_target;
    edit.error_type := ocmd_error;
    WITH display DO
        i11message (edit.msg_id, frame [ edit.current_eform] .sys_msg,
              frame [ edit.current_eform] .is_error);
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i13ftsfind_this_string (
            VAR content      : tin_eline;
            VAR width        : tin_natural;
            VAR searchstring : tin_cmd_type;
            VAR line_pos     : tsp00_Int2;
            direction        : boolean;
            VAR string_found : boolean);
 
VAR
      res            : tsp00_LcompResult;
 
BEGIN
width := width;
s30lcm1 (content, line_pos, searchstring.length,
      searchstring.content, 1, searchstring.length,
      res);
IF  res = l_equal
THEN
    string_found := true
ELSE
    IF  direction
    THEN
        line_pos := line_pos + 1
    ELSE
        line_pos := line_pos - 1;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      set_show_parms (
            VAR display      : tin_display_parms;
            VAR edit         : tin_edit_work_area;
            VAR searchstring : tin_cmd_type;
            line             : tin_natural;
            pos              : tsp00_Int2);
 
BEGIN
WITH display DO
    WITH frame [ edit.current_eform ] DO
        BEGIN
        IF  line > edit.lines_on_screen DIV 2
        THEN
            BEGIN
            upper_margin := line - edit.lines_on_screen DIV 2 + 1;
            csr_pos.sline := edit.lines_on_screen DIV 2;
            END
        ELSE
            BEGIN
            upper_margin := 1;
            csr_pos.sline := line;
            END;
        (*ENDIF*) 
        left_margin := 1;
        IF  pos + searchstring.length - 1 > edit.ecols_on_screen
        THEN
            left_margin := pos + searchstring.length
                  - edit.ecols_on_screen;
        (*ENDIF*) 
        csr_pos.screen_part := cin_ls_workarea;
        csr_pos.scol := edit.first_edit_scol + pos - left_margin;
        edit.csr_set_by_user := false;
        edit.last_search_cmd := searchstring;
        edit.last_search_line := line;
        edit.last_search_col  := pos;
        bright_line := line;
        END;
    (*ENDWITH*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ex_put_cmd (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            VAR cmd     : tin_cmd_type;
            VAR pos     : tsp00_Int2);
 
VAR
      numb1_scanned   :  boolean;
      numb2_scanned   :  boolean;
      numb3_scanned   :  boolean;
      i               :  integer;
      line_no         :  integer;
      line_count      :  integer;
      append          :  integer;
      count          :  tin_natural;
      cmd_end         :  boolean;
      fname           :  tsp00_VFilename;
      direction       :  tsp00_VFileOpCodes;
 
BEGIN
cmd_end := true;
i := pos;
count := 0;
WHILE (i <= cmd.length) AND (cmd.content  [i]  = ' ')  DO
    i := i + 1;
(*ENDWHILE*) 
IF  i <= cmd.length
THEN
    BEGIN
    IF  cmd.content  [i]  in [ '0'..'9' ]
    THEN
        count := ord (cmd.content  [i] ) - ord ('0');
    (*ENDIF*) 
    IF  (cmd.content  [i]  in [ '0'..'9'] ) AND
        (cmd.content [ i + 1 ] in [ '0'..'9'] ) AND
        (i + 1 <= cmd.length)
    THEN
        BEGIN
        count := count * 10 + ord (cmd.content [ i + 1] ) - ord ('0');
        i := i + 1;
        END
    ELSE
        IF  (NOT (cmd.content [ i + 1 ] in [ '0'..'9', ' '] ))
            AND (i + 1 <= cmd.length)
        THEN
            count := 0;
        (*ENDIF*) 
    (*ENDIF*) 
    END
ELSE
    count := edit.lines_on_screen;
(*ENDIF*) 
IF  (i + 1 <= cmd.length)
THEN
    cmd_end := false;
(*ENDIF*) 
IF  ( count > 0 ) AND cmd_end
THEN
    ex_pick_cmd (eform, evars, display, edit, count)
ELSE
    BEGIN
    IF  ( count > 0 ) AND NOT cmd_end
    THEN
        BEGIN
        numb1_scanned := true;
        numb2_scanned := true;
        line_no := display.frame [ display.active_screen] .upper_margin;
        line_count := count;
        append     := 1;
        pos := i + 1;
        read_fname (display, cmd, edit, pos, fname);
        IF  (NOT edit.error_found)  AND (line_count <>  - 1)
        THEN
            (*========================*)
            (* try read third  option *)
            (*========================*)
            read_option (display, cmd, edit, append, pos, numb3_scanned);
        (*ENDIF*) 
        IF  numb3_scanned AND ( append <> -1 )
        THEN
            BEGIN
            (*==================*)
            (* incorrect option *)
            (*==================*)
            edit.error_found := true;
            edit.msg_id := option_error;
            edit.error_type := ocmd_error;
            display.csr_pos.scol := pos + cin_ocmd_scol - 1;
            WITH display DO
                i11message (edit.msg_id, frame [ edit.current_eform] .sys_msg,
                      frame [ edit.current_eform] .is_error);
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        read_fname (display, cmd, edit, pos, fname);
        numb1_scanned := false;
        numb2_scanned := false;
        numb3_scanned := false;
        line_no    := 1;
        line_count := 1;
        append     := 1;
        IF  NOT edit.error_found
        THEN
            BEGIN
            (*=======================*)
            (* try read first option *)
            (*=======================*)
            read_option (display, cmd, edit, line_no, pos, numb1_scanned);
            IF  (NOT edit.error_found) AND (numb1_scanned)
                AND (line_no <> - 1)
            THEN
                (*========================*)
                (* try read second option *)
                (*========================*)
                read_option (display, cmd, edit, line_count,
                      pos, numb2_scanned);
            (*ENDIF*) 
            IF  (NOT edit.error_found) AND (numb2_scanned)
                AND (line_count <>  - 1)
            THEN
                (*========================*)
                (* try read third  option *)
                (*========================*)
                read_option (display, cmd, edit, append, pos, numb3_scanned);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  NOT edit.error_found
    THEN
        BEGIN
        IF  (line_no = - 1) OR (line_count = - 1) OR (append = - 1)
        THEN
            direction := vappend
        ELSE
            direction := voverwrite;
        (*ENDIF*) 
        (*===========================*)
        (* set options if no options *)
        (*===========================*)
        IF  (numb1_scanned) AND (line_no = 0)
        THEN
            line_no := 1;
        (*ENDIF*) 
        IF  numb2_scanned
        THEN
            IF  line_count > evars.lines
            THEN
                line_count :=  evars.lines;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  (numb2_scanned) AND (line_count = - 1)
        THEN
            line_count :=  evars.lines;
        (*ENDIF*) 
        IF  (numb1_scanned) AND (NOT numb2_scanned)
        THEN
            line_count :=  evars.lines;
        (*ENDIF*) 
        IF  (NOT numb1_scanned) OR (line_no= - 1)
        THEN
            BEGIN
            line_no := 1;
            line_count :=  evars.lines;
            END;
        (*ENDIF*) 
        i13etfeform_to_file ( eform, evars, display, edit, line_no,
              line_count, fname, direction );
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END; (* ex_put_cmd *)
 
(*------------------------------*) 
 
PROCEDURE
      i13etfeform_to_file (
            VAR eform      : tin_eform_buffer;
            VAR evars      : tin_eform_vars;
            VAR display    : tin_display_parms;
            VAR edit       : tin_edit_work_area;
            VAR line_no    :  integer;
            VAR line_count :  integer;
            VAR fname      :  tsp00_VFilename;
            VAR direction  :  tsp00_VFileOpCodes );
 
VAR
      j               :  tin_natural;
      width           :  tin_natural;
      length          :  tin_natural;
      content         :  tin_eline;
      hostfileno      :  tsp00_Int4;
      len             :  tsp00_Int4;
      format          :  tsp00_VfFormat;
      outblockaddress :  tsp_vf_bufaddr;
      outbufaddress   :  tsp_vf_bufaddr;
      block           :  tsp00_Buf;
      geterror        :  boolean;
      error           :  tsp00_VfReturn;
      he              :  tsp00_ErrText;
 
BEGIN
(*=========================*)
(* try write eform on file *)
(*=========================*)
error :=  vf_ok;
len := 0;
format :=  vf_plaintext;
sqlfopen (fname, direction, vf_stack, hostfileno, format,
      len, i01g^.vf_pool_ptr, 0, outblockaddress, error, he);
IF  error = vf_notok
THEN
    (*===========================*)
    (* filename not VM - conform *)
    (*===========================*)
    BEGIN
    edit.error_found := true;
    edit.msg_id := file_error;
    edit.error_type := ocmd_error;
    display.csr_pos.scol := cin_ocmd_scol + 5;
    WITH display.frame [ edit.current_eform ] DO
        i13fmfile_message (edit.msg_id, sys_msg, he);
    (*ENDWITH*) 
    END
ELSE
    BEGIN
    (*=====================*)
    (* write eform on file *)
    (*=====================*)
    IF  evars.lines < line_count + line_no - 1
    THEN
        line_count :=  evars.lines - line_no + 1;
    (*ENDIF*) 
    IF  line_count < 1
    THEN
        BEGIN
        edit.msg_id :=  no_copy;
        WITH display.frame [ edit.current_eform ] DO
            i11message (edit.msg_id, sys_msg, is_error);
        (*ENDWITH*) 
        END
    ELSE
        REPEAT
            i14geteline (eform, evars, content,
                  line_no, width, geterror);
            FOR j :=  1 TO width DO
                block  [j]  :=  content  [j] ;
            (*ENDFOR*) 
            length :=  width;
            IF  length = 0
            THEN
                BEGIN
                length :=  1;
                block  [1]  :=  ' ';
                END;
            (*ENDIF*) 
            IF  error = vf_ok
            THEN
                BEGIN
                sqlfwrite (hostfileno, s30gad(block),
                      length, error, he);
                edit.msg_id := ok_copy;
                WITH display.frame [ edit.current_eform ] DO
                    i11message (edit.msg_id, sys_msg, is_error);
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            IF  error = vf_notok
            THEN
                BEGIN
                edit.error_found := true;
                edit.msg_id := file_error;
                edit.error_type := ocmd_error;
                WITH display.frame [ edit.current_eform ] DO
                    i13fmfile_message (edit.msg_id, sys_msg, he);
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            line_no :=  line_no + 1;
            line_count :=  line_count - 1;
        UNTIL
            line_count = 0;
        (*ENDREPEAT*) 
    (*ENDIF*) 
    outbufaddress := NIL;
    sqlfclose (hostfileno, false, i01g^.vf_pool_ptr, 0,
          outbufaddress, error, he);
    IF  error = vf_notok
    THEN
        BEGIN
        edit.error_found := true;
        edit.msg_id := file_error;
        edit.error_type := ocmd_error;
        WITH display.frame [ edit.current_eform ] DO
            i13fmfile_message (edit.msg_id, sys_msg, he);
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ex_pick_cmd (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            count      : tin_natural);
 
VAR
      first_ins   : tin_natural;
      last_ins    : tin_natural;
      first_shift : tin_natural;
      last_shift  : tin_natural;
 
BEGIN
first_ins := display.frame [ display.active_screen] .upper_margin;
last_ins := first_ins + count - 1;
first_shift := 1;
last_shift := 1;
i12pickrand (eform, evars, display, edit, first_ins,
      last_ins, first_shift, last_shift);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ex_pput_cmd (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area);
 
BEGIN
IF  edit.mark1_line = 0
THEN
    edit.mark1_line :=
          display.frame [ display.active_screen] .upper_margin;
(*ENDIF*) 
i12putrand (eform, evars, display, edit, 1);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ex_get_cmd (
            VAR eform   : tin_eform_buffer;
            VAR evars   : tin_eform_vars;
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            VAR cmd     : tin_cmd_type;
            VAR pos     : tsp00_Int2);
 
VAR
      i             : integer;
      fname         : tsp00_VFilename;
      line_no       : integer;
      line_count    : integer;
      numb1_scanned : boolean;
      numb2_scanned : boolean;
      ignore_crs    : boolean;
 
BEGIN
ignore_crs := false;
i := pos; (* pz 13.9 *)
line_no := 0;
line_count := 9999;
WHILE (i <= cmd.length) AND (cmd.content  [i]  =' ')  DO
    i := i + 1;
(*ENDWHILE*) 
IF  i > cmd.length
THEN
    ex_pput_cmd (eform, evars, display, edit)
ELSE
    BEGIN
    read_fname (display, cmd, edit, pos, fname);
    IF  NOT edit.error_found
    THEN
        BEGIN
        (*=======================*)
        (* try read first option *)
        (*=======================*)
        read_option (display, cmd, edit, line_no, pos, numb1_scanned);
        IF  (NOT edit.error_found) AND (numb1_scanned)
        THEN
            (*=======================*)
            (* try read second option *)
            (*=======================*)
            read_option (display, cmd, edit, line_count, pos, numb2_scanned);
        (*ENDIF*) 
        IF  NOT edit.error_found
        THEN
            BEGIN
            (*===========================*)
            (* set options if no options *)
            (*===========================*)
            IF  (numb1_scanned) AND (line_no=0)
            THEN
                line_no := 1;
            (*ENDIF*) 
            IF  NOT numb1_scanned
            THEN
                line_no := 1;
            (*========================*)
            (* try read file to eform *)
            (*========================*)
            (*ENDIF*) 
            i13rfread_file (eform, evars, display, edit,
                  fname, line_no, line_count, ignore_crs );
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      read_fname (
            VAR display : tin_display_parms;
            VAR cmd     : tin_cmd_type;
            VAR edit    : tin_edit_work_area;
            VAR pos     : tsp00_Int2;
            VAR fname   : tsp00_VFilename);
 
VAR
      i       : tin_natural;
      quote   : boolean;
      str_end : boolean;
      j       : integer;
 
BEGIN
WITH display DO
    BEGIN
    FOR j := 1 TO sizeof (fname) DO
        fname [j] := ' ';
    (*ENDFOR*) 
    (*=============*)
    (* skip blanks *)
    (*=============*)
    WHILE (pos <= cmd.length) AND (cmd.content [ pos ] = ' ')  DO
        pos := pos + 1;
    (*ENDWHILE*) 
    quote := cmd.content [ pos ] = '''';
    (*===============*)
    (* read filename *)
    (*===============*)
    i := 1;
    IF  quote
    THEN
        pos := pos + 1;
    (*ENDIF*) 
    str_end := false;
    WHILE (pos <= cmd.length) AND NOT str_end AND (i <= VFILENAME_MXSP00) DO
        BEGIN
        IF  quote
        THEN
            str_end := cmd.content [ pos ] = ''''
        ELSE
            str_end := cmd.content [ pos ] = ' ';
        (*ENDIF*) 
        IF  NOT str_end
        THEN
            fname  [i]  := cmd.content [ pos] ;
        (*ENDIF*) 
        pos := pos + 1;
        i := i + 1;
        END;
    (*ENDWHILE*) 
    IF  quote AND (cmd.content [ pos - 1 ] <> '''')
    THEN
        BEGIN
        (*==========================*)
        (* Missing ' after filename *)
        (*==========================*)
        edit.error_found := true;
        edit.msg_id := slash_missing;
        edit.error_type := ocmd_error;
        csr_pos.scol := pos + cin_ocmd_scol - 1;
        i11message (edit.msg_id, frame [ edit.current_eform] .sys_msg,
              frame [ edit.current_eform] .is_error);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      read_option (
            VAR display      : tin_display_parms;
            VAR cmd          : tin_cmd_type;
            VAR edit         : tin_edit_work_area;
            VAR numb         : integer;
            VAR pos          : tsp00_Int2;
            VAR numb_scanned : boolean);
 
VAR
      i    : integer;
      word : PACKED ARRAY [ 1..3 ] OF char;
 
BEGIN
i := 1;
numb_scanned := false;
(*=============*)
(* skip blanks *)
(*=============*)
WHILE (pos <= cmd.length) AND (cmd.content [ pos ] =' ')  DO
    pos := pos + 1;
(*ENDWHILE*) 
IF  (s60toupper (cmd.content [ pos] )='A')
    AND (numb=1) AND (pos <cmd.length - 1)
THEN
    BEGIN
    numb := 0;
    i := 1;
    WHILE (pos <= cmd.length) AND (cmd.content [ pos ] <> ' ') DO
        BEGIN
        IF  i <= 3
        THEN
            word  [i]  := s60toupper (cmd.content [ pos] );
        (*ENDIF*) 
        pos := pos + 1;
        i := i + 1;
        END;
    (*ENDWHILE*) 
    IF  word='APP'
    THEN
        BEGIN
        numb :=  - 1;
        numb_scanned := true;
        END
    ELSE
        pos := cmd.length + 1
    (*ENDIF*) 
    END
ELSE
    BEGIN
    numb := 0;
    WHILE (pos <=cmd.length) AND (cmd.content [ pos ]
          in   [ '0'..'9'] )
          AND (i <=4)
          DO
        BEGIN
        (*=============================*)
        (* convert option into integer *)
        (*=============================*)
        numb := numb*10 + ord (cmd.content [ pos] ) - ord ('0');
        pos := pos + 1;
        i := i + 1;
        numb_scanned := true;
        END;
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
IF  (cmd.content [ pos ] <> ' ') AND (pos <=cmd.length)
THEN
    BEGIN
    (*==================*)
    (* incorrect option *)
    (*==================*)
    edit.error_found := true;
    edit.msg_id := option_error;
    edit.error_type := ocmd_error;
    display.csr_pos.scol := pos + cin_ocmd_scol - 1;
    WITH display DO
        i11message (edit.msg_id, frame [ edit.current_eform] .sys_msg,
              frame [ edit.current_eform] .is_error);
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      read_ch_options (
            VAR cmd        : tin_cmd_type;
            VAR pos        : tsp00_Int2;
            VAR line_count : tin_natural;
            VAR ch_count   : tin_natural;
            max_cols       : tin_natural);
 
BEGIN
line_count := 1;
ch_count := 1;
IF  (pos < cmd.length) AND (cmd.content [ pos ] ='/')
THEN
    BEGIN
    pos := pos + 1;
    (*=============*)
    (* skip blanks *)
    (*=============*)
    WHILE (pos <= cmd.length) AND (cmd.content [ pos ] =' ')  DO
        pos := pos + 1;
    (*ENDWHILE*) 
    IF  (cmd.content [ pos ] = '*')
        AND (pos <= cmd.length)
    THEN
        BEGIN
        line_count := 9999;
        pos := pos + 1;
        END
    ELSE
        BEGIN
        IF  pos <= cmd.length
        THEN
            BEGIN
            line_count := 0;
            WHILE (pos <= cmd.length) AND (cmd.content [ pos ]
                  in   [ '0'..'9'] )
                  DO
                BEGIN
                (*=============================*)
                (* convert option into integer *)
                (*=============================*)
                IF  line_count * 10 +
                    ord (cmd.content [ pos] ) - ord ('0') <=
                    32767
                THEN
                    line_count := line_count * 10 +
                          ord (cmd.content [ pos] ) - ord ('0');
                (*ENDIF*) 
                pos := pos + 1;
                END;
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  line_count > 0
    THEN
        BEGIN
        WHILE (pos <= cmd.length) AND (cmd.content [ pos ] =' ')  DO
            pos := pos + 1;
        (*ENDWHILE*) 
        IF  (cmd.content [ pos ] = '*')
            AND (pos <= cmd.length)
        THEN
            ch_count := max_cols
        ELSE
            BEGIN
            IF  pos <= cmd.length
            THEN
                BEGIN
                ch_count := 0;
                WHILE (pos <= cmd.length) AND (cmd.content [ pos ]
                      in   [ '0'..'9'] )
                      DO
                    BEGIN
                    (*=============================*)
                    (* convert option into integer *)
                    (*=============================*)
                    IF  ch_count * 10 +
                        ord (cmd.content [ pos] ) - ord ('0') <=
                        32767
                    THEN
                        ch_count := ch_count * 10 +
                              ord (cmd.content [ pos] ) - ord ('0');
                    (*ENDIF*) 
                    pos := pos + 1;
                    END;
                (*ENDWHILE*) 
                IF  ch_count > max_cols
                THEN
                    ch_count := max_cols;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i13rfread_file (
            VAR eform      :  tin_eform_buffer;
            VAR evars      :  tin_eform_vars;
            VAR display    :  tin_display_parms;
            VAR edit       :  tin_edit_work_area;
            VAR fname      :  tsp00_VFilename;
            VAR line_no    :  integer;
            VAR line_count :  integer;
            VAR ignore_crs :  boolean );
 
VAR
      length          :  tsp00_Int4;
      format          :  tsp00_VfFormat;
      outblockaddress :  tsp_vf_bufaddr;
      outbufaddress   :  tsp_vf_bufaddr;
      hostfileno      :  tsp00_Int4;
      error           :  tsp00_VfReturn;
      buf             :  tsp00_Buf;
      direction       :  tsp00_VFileOpCodes;
      he              :  tsp00_ErrText;
      content         :  tin_eline;
      width           :  tin_natural;
      this            :  tin_natural;
      i, j            :  integer;
      splitcnt        :  integer;
      offset          :  integer;
      perror          :  boolean;
 
BEGIN
WITH display DO
    WITH frame [ edit.current_eform ] DO
        BEGIN
        length := 0;
        direction := vread;
        this := 1;
        error := vf_ok;
        format :=  vf_plaintext;
        sqlfopen (fname, direction, vf_stack, hostfileno, format,
              length, i01g^.vf_pool_ptr, 0, outblockaddress, error, he);
        IF  error=vf_notok
        THEN
            BEGIN
            (*=========================*)
            (* filename not VM - conform *)
            (*=========================*)
            edit.error_found := true;
            edit.msg_id := file_error;
            edit.error_type := ocmd_error;
            csr_pos.scol := cin_ocmd_scol + 5;
            i13fmfile_message (edit.msg_id, sys_msg, he);
            END
        ELSE
            BEGIN
            (*====================*)
            (* copy file to eform *)
            (*====================*)
            IF  csr_pos.screen_part = cin_ls_workarea
            THEN
                (*================================*)
                (* start copy where cursor stands *)
                (*================================*)
                this := upper_margin + csr_pos.sline - 1
            ELSE
                BEGIN
                (*==================================*)
                (* start copy at top of shown screen*)
                (*==================================*)
                this := upper_margin;
                END;
            (*ENDIF*) 
            IF  ignore_crs
            THEN
                this := 1;
            (*ENDIF*) 
            FOR i := 1 TO line_no DO
                BEGIN
                (*====================*)
                (* copy file to eform *)
                (*====================*)
                sqlfread (hostfileno, s30gad(buf), length, error, he);
                END;
            (*ENDFOR*) 
            IF  error <> vf_eof
            THEN
                BEGIN
                IF  line_count > 0
                THEN
                    BEGIN
                    REPEAT
                        i32repltabs (i32machinecodetype, mxsp_buf,
                              buf, length);
                        IF  length > max_cols
                        THEN
                            BEGIN
                            splitcnt := length DIV max_cols;
                            width := max_cols;
                            offset := 0;
                            FOR i := 1 TO splitcnt DO
                                BEGIN
                                offset := (i - 1) * width;
                                FOR j := 1 TO width DO
                                    content  [j]  := buf  [j + offset];
                                (*ENDFOR*) 
                                i14inserteline( eform, evars,
                                      this, 1, perror);
                                i14puteline (eform, evars, content,
                                      this, width, perror);
                                this := this + 1;
                                offset := i * width;
                                END;
                            (*ENDFOR*) 
                            IF  NOT perror
                            THEN
                                BEGIN
                                width := length MOD max_cols;
                                FOR j := 1 TO width DO
                                    content  [j]  := buf  [j + offset];
                                (*ENDFOR*) 
                                i14inserteline( eform, evars,
                                      this, 1, perror);
                                i14puteline (eform, evars, content,
                                      this, width, perror);
                                END;
                            (*ENDIF*) 
                            END
                        ELSE
                            BEGIN
                            FOR j := 1 TO length DO
                                content  [j]  := buf  [j] ;
                            (*ENDFOR*) 
                            width := length;
                            i14inserteline( eform, evars, this, 1, perror);
                            i14puteline (eform, evars, content,
                                  this, width, perror);
                            END;
                        (*ENDIF*) 
                        IF  perror
                        THEN
                            i11message (eform_overflow, sys_msg, is_error);
                        (*ENDIF*) 
                        this := this + 1;
                        line_count := line_count - 1;
                        sqlfread (hostfileno, s30gad(buf),
                              length, error, he);
                    UNTIL
                        (line_count = 0) OR (error = vf_eof) OR perror;
                    (*ENDREPEAT*) 
                    changed := true;
                    END
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                edit.msg_id := no_copy;
                i11message (edit.msg_id, sys_msg, is_error);
                END;
            (*ENDIF*) 
            outbufaddress := NIL;
            sqlfclose (hostfileno, false, i01g^.vf_pool_ptr, 0,
                  outbufaddress, error, he);
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i13fmfile_message (
            msg_id      : tin_edit_msg;
            VAR text    : tin_screenline;
            VAR errtext : tsp00_ErrText);
 
VAR
      pos    : tsp00_Int2;
      is_err : boolean;
 
BEGIN
i11message (msg_id, text, is_err);
pos := s30klen (text, ' ', mxin_screenline) + 2;
IF  pos <= i01g^.vt.desc.num_of_cols - 40 + 1
THEN
    s10mv (40,mxin_screenline,
          @errtext,1,
          @text,pos,40);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      reset_ocmd_line (
            VAR cmd : tin_cmd_type);
 
VAR
      i : integer;
 
BEGIN
FOR i :=  1 TO mxin_screenline DO
    cmd.content  [i]  := ' ';
(*ENDFOR*) 
cmd.length  := 0;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ex_top_cmd (
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area);
 
BEGIN
WITH display DO
    WITH frame [ edit.current_eform ] DO
        BEGIN
        upper_margin := 1;
        left_margin := 1;
        END;
    (*ENDWITH*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ex_bottom_cmd (
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            VAR evars   : tin_eform_vars);
 
VAR
      top_margin : integer;
 
BEGIN
WITH display , frame [ edit.current_eform ] DO
    BEGIN
    top_margin := evars.lines - edit.lines_on_screen + 1;
    IF  top_margin <= 0
    THEN
        top_margin := 1
    ELSE
        get_dark_bot_count ( edit, evars, top_margin );
    (*ENDIF*) 
    upper_margin := top_margin;
    left_margin := 1;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      get_dark_bot_count (
            VAR edit       : tin_edit_work_area;
            VAR evars      : tin_eform_vars;
            VAR top_margin : integer );
 
VAR
      this_lno   : tin_natural;
      first_dark : tin_natural;
      lno        : tin_natural;
      this       : tin_natural;
 
BEGIN
this := evars.lines;
lno := 1;
WHILE ( lno < edit.lines_on_screen ) AND ( this > 0 )  DO
    BEGIN
    IF  ( this > 0 ) AND
        i11lixbln_in_x_block ( edit.prefix, this,
        this_lno, first_dark )
    THEN
        this :=  first_dark - 1
    ELSE
        this := this - 1;
    (*ENDIF*) 
    lno := lno + 1;
    END;
(*ENDWHILE*) 
IF  ( this <= 0 )
THEN
    top_margin := 1
ELSE
    IF  ( this < top_margin )
    THEN
        top_margin := this;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ex_up_cmd (
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            VAR cmd     : tin_cmd_type;
            VAR pos     : tsp00_Int2);
 
VAR
      count        : integer;
      nxt_lno      : tin_natural;
      i            : integer;
      cnt          : tin_natural;
      width        : tin_natural;
      numb_scanned : boolean;
 
BEGIN
read_option (display, cmd, edit, count, pos, numb_scanned);
IF  NOT edit.error_found
THEN
    BEGIN
    IF  NOT numb_scanned
    THEN
        BEGIN
        i51size (cin_ls_workarea, cnt, width);
        count := cnt - 1;
        IF  count <= 0
        THEN
            count := 1;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    WITH  display DO
        WITH frame [ edit.current_eform ] DO
            BEGIN
            IF  upper_margin - count <= 1
            THEN
                BEGIN
                upper_margin := 1;
                i11message (top_reached, sys_msg, is_error)
                END
            ELSE
                BEGIN
                i := 1;
                WHILE ( i <= count ) AND ( upper_margin > 1 ) DO
                    BEGIN
                    IF  i11isdark_ln ( edit.prefix,
                        upper_margin, nxt_lno)
                    THEN
                        upper_margin := upper_margin -
                              edit.prefix.line [nxt_lno] .arg
                    ELSE
                        upper_margin := upper_margin - 1;
                    (*ENDIF*) 
                    i := i + 1;
                    END;
                (*ENDWHILE*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ex_down_cmd (
            VAR display : tin_display_parms;
            VAR edit    : tin_edit_work_area;
            VAR cmd     : tin_cmd_type;
            VAR pos     : tsp00_Int2);
 
VAR
      count        : integer;
      dark_count   : tin_natural;
      cnt          : tin_natural;
      width        : tin_natural;
      numb_scanned : boolean;
      this_lno     : tin_natural;
      first_dark   : tin_natural;
 
BEGIN
read_option (display, cmd, edit, count, pos, numb_scanned);
IF  NOT edit.error_found
THEN
    BEGIN
    IF  NOT numb_scanned
    THEN
        BEGIN
        i51size (cin_ls_workarea, cnt, width);
        IF  cnt < 1
        THEN
            count := 1
        ELSE
            count := cnt - 1;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    WITH display, frame [ edit.current_eform ] DO
        BEGIN
        IF  upper_margin + count > 10000
        THEN
            upper_margin := 10000
        ELSE
            BEGIN
            dark_count := 0;
            i11getdark_eline_count ( edit.prefix, upper_margin,
                  upper_margin + count, dark_count );
            upper_margin := upper_margin + count + dark_count;
            (* ist upper_margin in dark_block dann upper_margin  *)
            (* gleich erste folgende sichtbare Zeile             *)
            IF  i11lixbln_in_x_block ( edit.prefix,
                upper_margin, this_lno, first_dark )
            THEN
                IF  upper_margin <> first_dark
                THEN
                    BEGIN
                    upper_margin := first_dark
                          + edit.prefix.line [this_lno] .arg;
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      addspace (
            VAR buf       : tin_eline;
            VAR buflength : tin_natural;
            pos, plus     : integer);
 
BEGIN
IF  pos + plus >= buflength
THEN
    s10mv (mxin_eline,mxin_eline,
          @buf,pos,
          @buf,pos + plus,buflength - pos)
ELSE
    SAPDB_PascalForcedOverlappingMove  (mxin_eline, mxin_eline, @buf, pos, @buf, pos + plus,
          buflength - pos);
(*ENDIF*) 
buflength := buflength + plus
END;
 
(*------------------------------*) 
 
PROCEDURE
      delspace (
            VAR buf       : tin_eline;
            VAR buflength : tin_natural;
            pos, minus    : integer);
 
BEGIN
s10mv (mxin_eline,mxin_eline,
      @buf,pos + minus,
      @buf,pos,buflength - pos - minus);
buflength := buflength - minus;
END;
 
(*------------------------------*) 
 
PROCEDURE
      i13sesystem_editor (
            VAR eform    : tin_eform_buffer;
            VAR evars    : tin_eform_vars;
            VAR display  : tin_display_parms;
            VAR edit     : tin_edit_work_area;
            VAR cmd      : tin_cmd_type;
            VAR pos      : tsp00_Int2;
            VAR exec_ok  : boolean );
 
VAR
      ok             : boolean;
      line_no        : integer;
      line_count     : integer;
      vfilename      : tsp00_VFilename;
      direction      : tsp00_VFileOpCodes;
      vfile_name_len : tsp00_Int2;
      edit_name_len  : tsp00_Int2;
      ex_line        : tsp00_ExecLine;
      ex_mode        : tsp00_ExecMode;
      e_ret          : tsp00_ExecReturn;
      err_text       : tsp00_ErrText;
      progresult     : tsp00_Int2;
      last_pos       : tsp00_Int2;
      erase_file     : boolean;
      error          : tsp00_VfReturn;
      ignore_crs     : boolean;
 
BEGIN
ok         := true;
exec_ok    := false;
erase_file := false;
ignore_crs := true;
SAPDB_PascalForcedFill ( sizeof(ex_line), @ex_line, 1, sizeof(ex_line), bsp_c1 );
IF  cmd.length < pos
THEN
    BEGIN
    (* Fehler : kein Editor angegeben *)
    ok          := false;
    edit.msg_id := not_implemented;
    END
ELSE
    BEGIN
    WHILE ( cmd.content [ pos ] = ' ' ) AND ( cmd.length > pos )  DO
        pos := pos + 1;
    (*ENDWHILE*) 
    last_pos := pos;
    WHILE ( cmd.content [ pos ] <> ' ' ) AND ( cmd.length > pos )  DO
        pos := pos + 1;
    (*ENDWHILE*) 
    edit_name_len := pos - last_pos + 1;
    s10mv (mxin_screenline,EXEC_LINE_MXSP00,
          @cmd.content,last_pos,
          @ex_line,1,edit_name_len );
    IF  cmd.length <= pos
    THEN
        BEGIN
        (*=================================*)
        (* PUT eform to file               *)
        (*=================================*)
        erase_file    := true;
        direction     := voverwrite;
        line_no       := 1;
        line_count    := evars.lines;
        osedfilename  ( ex_mode, vfilename, vfile_name_len, ok );
        IF  ok
        THEN
            BEGIN
            i13etfeform_to_file ( eform, evars, display, edit, line_no,
                  line_count, vfilename, direction );
            ok := NOT edit.error_found;
            END
        ELSE
            BEGIN
            ok          := false;
            edit.msg_id := not_implemented;
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        ok          := false;
        edit.msg_id := not_implemented;
        END;
    (*ENDIF*) 
    (* SQLEXEC Systemeditor - Aufruf *)
    IF  ok
    THEN
        BEGIN
        WITH display, edit DO
            SAPDB_PascalForcedFill ( mxin_screenline,
                  @frame [active_screen] .sys_msg, 1,
                  mxin_screenline, bsp_c1 );
        (*ENDWITH*) 
        (*========================================*)
        (* Aufruf des Systemeditors durch sqlexec *)
        (*========================================*)
        (* h.b. vorubergehende Verbesserung bis VSP00 angebasst ist *)
        s10mv (VFILENAME_MXSP00,EXEC_LINE_MXSP00,
              @vfilename,1,
              @ex_line,edit_name_len + 2,vfile_name_len );
        e_ret := ex_ok;
        i71sqlexec ( ex_line, ex_mode, e_ret, err_text, progresult,
              false, true );
        (* IF  e_ret <> ex_ok
              THEN
              BEGIN
              ok          := false;
              edit.msg_id := not_implemented;
              END; *)
        (*=======================*)
        (*   GET file to eform   *)
        (*=======================*)
        exec_ok := true;
        i14cleareform (evars);
        line_no    := 1;
        line_count := 9999;
        i13rfread_file ( eform, evars, display, edit, vfilename,
              line_no, line_count, ignore_crs );
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  erase_file
THEN
    BEGIN
&   if $OS = VMS
    vfilename [ vfile_name_len + 1 ] := ';';
    vfilename [ vfile_name_len + 2 ] := '*';
&   endif
    sqlferase ( vfilename, error, err_text );
    IF  error = vf_notok
    THEN
        (*===========================*)
        (* file not found            *)
        (*===========================*)
        BEGIN
        edit.msg_id := file_error;
        ok          := false;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  NOT ok
THEN
    BEGIN
    edit.error_found     := true;
    edit.error_type      := ocmd_error;
    display.csr_pos.scol := pos + cin_ocmd_scol - 1;
    WITH display DO
        IF  edit.msg_id = file_error
        THEN
            i13fmfile_message (edit.msg_id,
                  frame [ edit.current_eform] .sys_msg, err_text)
        ELSE
            i11message (edit.msg_id,
                  frame [ edit.current_eform] .sys_msg,
                  frame [ edit.current_eform] .is_error);
        (*ENDIF*) 
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      osedfilename  (
            VAR ex_mode        : tsp00_ExecMode;
            VAR vfilename      : tsp00_VFilename;
            VAR vfile_name_len : tsp00_Int2;
            VAR file_exists    : boolean );
 
VAR
      uid         : tsp00_TaskId;
      pid_str     : tsp00_C10;
      pid_str_len : tsp00_Int2;
      file_name   : tsp00_C10;
      j           : integer;
 
BEGIN
file_exists := false;
&if $OS in [ UNIX, OS2, WIN32, MSDOS ]
file_exists    := true;
file_name      := 'ed.       ';
vfile_name_len := 3;
ex_mode        := sync_new_session;
&endif
&if $OS = VMS
file_exists    := true;
file_name      := 'esd_edt.  ';
vfile_name_len := 8;
ex_mode        := sync_new_session;
&endif
&if $OS=VMSP
file_exists    := true;
file_name      := 'EDIT P    ';
vfile_name_len := 6;
ex_mode        := sync_same_session;
&endif
IF  file_exists
THEN
    BEGIN
    sqluid (uid);
    i_to_c10 ( uid, pid_str_len, pid_str );
&   if $OS in [ OS2, WIN32, MSDOS ]
    IF  pid_str_len > 3
    THEN
        pid_str_len := 3;
&   endif
    (*ENDIF*) 
    FOR j := 1 TO sizeof (vfilename) DO
        vfilename [j] := ' ';
    (*ENDFOR*) 
    s10mv (10,VFILENAME_MXSP00,
          @file_name,1,
          @vfilename,1,vfile_name_len );
    s10mv (10,VFILENAME_MXSP00,
          @pid_str,11 - pid_str_len,
          @vfilename,vfile_name_len + 1,pid_str_len );
    vfile_name_len := vfile_name_len + pid_str_len;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i_to_c10(
            i       : tsp00_Int4;
            VAR len : tsp00_Int2;
            VAR c10 : tsp00_C10 );
 
VAR
      base : tin_natural;
      pos  : tsp00_Int2;
 
BEGIN
base := ord ('0');
pos := 10;
len := 10;
REPEAT
    IF  i = 0
    THEN
        len := len - 1;
    (*ENDIF*) 
    c10 [ pos ] :=  chr (s20int4_to_int2 (base + (i MOD 10)));
    i := i DIV 10;
    pos := pos - 1;
UNTIL
    pos = 0;
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      i13geget_editor (
            VAR cmd : tin_cmd_type;
            VAR pos : tsp00_Int2;
            VAR ok  : boolean );
 
VAR
      n_len  : integer;
 
BEGIN
(* editor aus den setparms  in cmd *)
ok := false;
&if $OS in [ UNIX, VMSP, OS2, WIN32, MSDOS, VMS ]
ok := true;
pos := 1;
SAPDB_PascalForcedFill ( mxin_screenline, @cmd.content, 1, mxin_screenline,
      bsp_c1 );
s10mv (mxin_screenline,mxsp_c40,
      @i01g^.set_parms.syseditor,1,
      @cmd.content,1,mxsp_c40 );
n_len := s30klen ( cmd.content, '0', mxin_screenline );
cmd.length := s30klen ( cmd.content, ' ', mxin_screenline );
IF  ( cmd.length = 0 ) OR ( n_len = 0 )
THEN
    ok := false;
&endif
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
