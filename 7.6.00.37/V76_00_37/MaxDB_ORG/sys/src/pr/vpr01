.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.tt 1 $SQL$Project Distributed Database System$VPR01$
.tt 2 $$$
.TT 3 $$SQL Runtime System$$2001-06-26$
.nf
 
 .nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : SQL_runtime_routinen
=========
.sp
Purpose : Runtime-Routinen von SQL-Kommandos in
          Anwendungsprogrammen
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        FUNCTION
              p01getaddr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        FUNCTION
              p01get1addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        FUNCTION
              p01get2addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        FUNCTION
              p01get3addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        FUNCTION
              p01get4addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        FUNCTION
              p01get5addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        FUNCTION
              p01get6addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        FUNCTION
              p01get7addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        FUNCTION
              p01get8addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        FUNCTION
              p01get9addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        FUNCTION
              p01getaaddr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        FUNCTION
              p01getbaddr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        FUNCTION
              p01getcaddr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        FUNCTION
              p01getdaddr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        FUNCTION
              p01geteaddr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        FUNCTION
              p01getfaddr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        PROCEDURE
              p01addr (VAR sqlca : sqlcatype;
                    VAR variab : tsp00_MoveObj;
                    VAR resaddr : tpr_vtypepointer);
 
        PROCEDURE
              p01check (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    connplen: tsp00_Int4);
 
        PROCEDURE
              p01sqlstatement (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry;
                    kae : sqlkaentry_ptr);
 
        PROCEDURE
              p01varpart_get (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry;
                    kae : sqlkaentry_ptr);
 
        PROCEDURE
              p01command (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry;
                    kae : sqlkaentry_ptr;
                    kano      : tsp00_Int2);
 
        PROCEDURE
              p01cancel  (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry;
                    kano : tsp00_Int2);
 
        PROCEDURE
              p01stop    (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype);
 
        PROCEDURE
              p01exit  (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype);
 
        PROCEDURE
              p01ma2bi  (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    ma_no   : tsp00_Int2;
                    ma_len  : tsp00_Int2;
                    VAR val   : tpr_macroline);
 
        PROCEDURE
              p01pparsidtrace (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    kae    : sqlkaentry_ptr;
                    VAR parsid : tpr_parsid;
                    inout : tpr00_TraceParseID_Enum);
 
        PROCEDURE
              p01formatparsid(VAR parsid : tpr_parsid;
                    VAR tastr80 : tsp00_C256; VAR tastr80l : tsp00_Int2);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Fetch-Optimierung   : VPR01B;
 
        FUNCTION
              pr01bNumberOfRows(VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype) : tsp00_Int4;
 
        PROCEDURE
              p01bdrop_parsid (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR parsid : tpr_parsid);
 
        PROCEDURE
              p01bbparsen  (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry;
                    VAR ka : sqlkaentry;
                    VAR cmdfetch : tsp00_Int2);
 
        FUNCTION
              p01bmfetch  (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry;
                    VAR ka : sqlkaentry;
                    VAR cmdfetch : tsp00_Int2;
                    sqcrowcount   : tsp00_Int4) : tsp00_Int2;
 
        FUNCTION
              p01bmfentryget(VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR selparsid: tpr_parsid) : tsp00_Int2;
 
        PROCEDURE
              p01baexecute  (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry;
                    VAR kae : sqlkaentry;
                    VAR ore : sqlorentry);
 
        PROCEDURE
              p01bgetmfetch  (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry;
                    VAR kae : sqlkaentry;
                    sqcrowcount   : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              SQL_runtime_routinen  : VPR01E;
 
        PROCEDURE
              p01xpagethostvariable (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry;
                    paind     : tsp00_Int2;
                    VAR len   : tsp00_Int4);
 
        PROCEDURE
              p01xcmdclose  (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry);
 
        PROCEDURE
              p01xprofinit (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry);
 
        PROCEDURE
              p01xhalt  (result : integer);
 
        PROCEDURE
              p01xvfclosetrace  (VAR sqlca : sqlcatype);
 
        PROCEDURE
              p01xtracefilecheck  (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype);
 
        PROCEDURE
              p01xtimetrace (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry);
 
        PROCEDURE
              p01xchangerror (VAR sqlca : sqlcatype);
 
      ------------------------------ 
 
        FROM
              Precompiler_Runtime_Routinen  : VPR08;
 
        PROCEDURE
              p08runtimeerror (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    error : tpr_runtime_errors);
 
        PROCEDURE
              p08relsess   (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry;
                    VAR kae : sqlkaentry);
 
        PROCEDURE
              p08puttracename (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR nam   : tsp00_Name;
                    naml      : tsp00_Int2;
                    trwrite   : boolean);
 
        PROCEDURE
              p08puttraceknlid (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR nam   : tsp00_KnlIdentifier;
                    naml      : tsp00_Int2;
                    trwrite   : boolean);
 
        PROCEDURE
              p08vfwritetrace (sqlrap : sqlrapointer);
 
        PROCEDURE
              p08allocat (length : tsp00_Int4;
                    VAR p : tpr_intaddr;
                    VAR ok : boolean);
 
      ------------------------------ 
 
        FROM
              C-Type-Checker-Module  : VPR102;
 
        PROCEDURE
              p04trint2(sqlrap : sqlrapointer; szStr : tsp00_Name; cbValue : tsp00_Int2);
 
        PROCEDURE
              p04trint4(sqlrap : sqlrapointer; szStr : tsp00_Name; cbValue : tsp00_Int4);
 
        PROCEDURE
              p04GetSFInfo (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    kae : sqlkaentry_ptr;
                    VAR   ore : sqlorentry);
 
        PROCEDURE
              pr01cResultNameGet(sqlrap : sqlrapointer;
                    VAR gae : sqlgaentry;
                    VAR sqlresn : tsp00_KnlIdentifier;
                    cbLen : integer);
 
        PROCEDURE
              pr01cUseNewParseInfo(VAR xaSQLDesc : tpr01_SQLDesc);
 
        FUNCTION
              pr01cFromOpenGetOr(VAR xaSQLDesc : tpr01_SQLDesc) : sqlorentry_ptr;
 
        PROCEDURE
              pr03mAllocatP (len : tsp00_Int4;
                    VAR sfpointer : tpr_intaddr;
                    nam :tsp00_Name);
 
        PROCEDURE
              pr03mFreeP (sfpointer : tpr_intaddr; nam :tsp00_Name);
 
        FUNCTION
              pr01cParse (VAR xaSQLDesc : tpr01_SQLDesc;
                    VAR cmdfetch: tsp00_Int2;
                    VAR datafound: boolean) : boolean;
 
        FUNCTION
              pr01cIsComType(VAR xaSQLDesc : tpr01_SQLDesc;
                    ComType : tpr00_ComTypeEnum) : boolean;
 
        PROCEDURE
              pr01cStmtNameSetState(StmtNameDesc : tsp00_Addr;
                    State : tpr01_SQLStateBinary);
 
        PROCEDURE
              pr01cEnd(VAR xaSQLDesc : tpr01_SQLDesc);
 
        PROCEDURE
              pr01cOpenCursor(VAR xaSQLDesc : tpr01_SQLDesc);
 
        PROCEDURE
              pr01cTraceStmtName(StmtNameDesc : tsp00_Addr;
                    VAR sqlca : sqlcatype);
 
        PROCEDURE
              p01xcheck (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype);
 
        PROCEDURE
              pr01cFindStatmentNameEntry(VAR sqlxa : sqlxatype;
                    VAR lsnname : tsp00_KnlIdentifier);
 
        PROCEDURE
              pr01StmtNameSnEntryInit(VAR sn : tpr_sqlsnentry);
 
        PROCEDURE
              p03sABAPStream (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry);
 
        PROCEDURE
              pr03AbapInfoPutPart(VAR sqlca : sqlcatype;
                    sqlrap : sqlrapointer;
                    VAR gae : sqlgaentry);
 
        PROCEDURE
              pr03CheckPointPutPart(VAR sqlca : sqlcatype;
                    VAR gae : sqlgaentry;
                    sqlrap : sqlrapointer);
 
        PROCEDURE
              p03raprofinit (VAR sqlca : sqlcatype;
                    proflen : tsp00_Int4);
 
        PROCEDURE
              p03csqlcaareainit (VAR sqlca : sqlcatype);
 
        PROCEDURE
              p03ccmdinit (
                    VAR xaSQLDesc : tpr01_SQLDesc;
                    VAR sqlca : sqlcatype;
                    VAR gae : sqlgaentry;
                    m_type   : tsp1_cmd_mess_type);
 
        PROCEDURE
              p03sqlrelease  (sqlrap : sqlrapointer;
                    sqlgap :  sqlgapointer;
                    VAR gae : sqlgaentry;
                    errmsg : sqlempointer);
 
        PROCEDURE
              p03connect  (
                    VAR sqlxa : sqlxatype;
                    sqlrap :sqlrapointer;
                    sqlgap   :  sqlgapointer;
                    VAR gae : sqlgaentry;
                    datetime : tsp00_Int2;
                    errmsg : sqlempointer);
 
        PROCEDURE
              p03cmdtrace (sqlrap : sqlrapointer;
                    VAR gae : sqlgaentry;
                    nlcnt : tsp00_Int2;
                    comkind : tsp00_Int2;
                    pSQLStatement : tpr05_StringPointer);
 
        PROCEDURE
              p03warningset (sqlemp : sqlempointer;
                    warnset : tsp00_C2);
 
        PROCEDURE
              p03cresultcountget (sqlrap :sqlrapointer;
                    VAR gae : sqlgaentry ;
                    VAR resultcount : tsp00_Int4);
 
        PROCEDURE
              p03sqlsnallocate (VAR sqlxa : sqlxatype;
                    VAR index : tsp00_Int4);
 
        PROCEDURE
              p03sninit (VAR sqlxa : sqlxatype);
 
        PROCEDURE
              p03cpparsid (sqlrap : sqlrapointer;
                    VAR gae  : sqlgaentry;
                    VAR parsid : tpr_parsid;
                    sqlemp : sqlempointer);
 
        PROCEDURE
              p03csqlemptosqlca (VAR sqlca : sqlcatype;
                    sqlemp : sqlempointer);
 
        PROCEDURE
              p03orfree (VAR sqlca : sqlcatype;
                    orptr : tpr_intaddr;
                    kind: tsp00_Int2);
 
        PROCEDURE
              pr03cRelease(ConDesc : tsp00_Addr);
 
        PROCEDURE
              p03DebugBreak;
 
        PROCEDURE
              p04init (VAR dbrow  : tpr_sqlrow);
 
        PROCEDURE
              p04sftoora (VAR dbrow : tpr_sqlrow;
                    VAR dbcol  : tpr_sqlcol;
                    sfpointer  : tpr_ptr_to_value;
                    VAR oralen : tsp00_Int4;
                    VAR oratyp : tsp00_Int2);
 
        PROCEDURE
              p04sftodb2 (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR vardb2: sqlvardb2type;
                    VAR dbrow : tpr_sqlrow;
                    sfpointer  : tpr_ptr_to_value;
                    init   : char);
 
        PROCEDURE
              p04sftosql (VAR varsql: sqlvartype;
                    VAR dbrow : tpr_sqlrow;
                    sfpointer  : tpr_ptr_to_value;
                    init   : char);
 
        FUNCTION
              p04pdecode (VAR buf: tsp00_MoveObj;
                    pos : tsp00_Int2;
                    VAR dbrow : tpr_sqlrow;
                    VAR dbcol  : tpr_sqlcol)
                    : tsp00_Int2;
 
        PROCEDURE
              p04input (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry;
                    VAR looprec : tpr_sqlloop);
 
        PROCEDURE
              p04output (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry;
                    VAR looprec : tpr_sqlloop);
 
        PROCEDURE
              p04din (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry;
                    VAR cue : sqlcuentry;
                    VAR looprec : tpr_sqlloop);
 
        PROCEDURE
              p04dout (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry;
                    VAR looprec : tpr_sqlloop);
 
        PROCEDURE
              p07version (VAR vers : tsp00_C40);
 
        PROCEDURE
              pr01sPrepareExecuteAtFetch(
                    VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR kae : sqlkaentry;
                    VAR cue : sqlcuentry);
 
        FUNCTION
              pr01sIsExecuteAtFetch(
                    VAR sqlxa : sqlxatype) : tsp00_Int2;
 
        PROCEDURE
              pr01sExecuteAtFetch(
                    VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    kano  : tsp00_Int2);
 
        FUNCTION
              pr01sExecuteAtFetchPossible(
                    VAR sqlxa : sqlxatype;
                    VAR kae : sqlkaentry ) : boolean;
 
        FUNCTION
              pr01sGetFunctionCode(sqlrap : sqlrapointer) : tsp00_Int2;
 
        PROCEDURE
              pr01sDisableExecuteAtFetch(sqlrap : sqlrapointer);
 
        PROCEDURE
              pr04LongOutputLvc (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry;
                    p01looprec : tpr_sqlloop);
 
        PROCEDURE
              pr01TraceRuntimeError (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    error : tpr_runtime_errors);
 
        PROCEDURE
              pr06ParseIdDropDirect(ConDesc : tsp00_Addr;
                    VAR parsid : tpr_parsid);
 
        PROCEDURE
              pr04LongInitLD (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype);
 
        PROCEDURE
              pr04LongLvcInitRec (VAR sqlca : sqlcatype;
                    VAR lvcrec: tpr_longvarcharrec);
&       ifdef TRACE
 
        PROCEDURE
              m90name (
                    layer : tsp00_ToolLayer;
                    nam   : tsp00_Name);
 
        PROCEDURE
              m90identifier (
                    layer : tsp00_ToolLayer;
                    nam   : tsp00_KnlIdentifier);
 
        PROCEDURE
              m90lname (
                    layer : tsp00_ToolLayer;
                    nam   : tsp00_Lname);
 
        PROCEDURE
              m90int2 (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : tsp00_Int2);
 
        PROCEDURE
              m90int4 (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : tsp00_Int4);
 
        PROCEDURE
              m90int (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : integer);
 
        PROCEDURE
              m90bool (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    bool: boolean);
 
        PROCEDURE
              m90buf  (layer : tsp00_ToolLayer;
                    VAR buf : tpr_sqlcol;
                    posanf : integer;
                    posend : integer);
 
        PROCEDURE
              m90buf1 (layer : tsp00_ToolLayer;
                    VAR buf :  tpr_valuerec;
                    pos_anf : integer;
                    pos_end : integer);
 
        PROCEDURE
              m90buf2 (layer : tsp00_ToolLayer;
                    VAR buf : tsp00_ErrText;
                    posanf : integer;
                    posend : integer);
 
        PROCEDURE
              m90buf3 (layer : tsp00_ToolLayer;
                    VAR buf : tsp00_KnlIdentifier;
                    posanf : integer;
                    posend : integer);
 
        PROCEDURE
              m90buf4 (layer : tsp00_ToolLayer;
                    VAR buf : tpr_parsid;
                    posanf : integer;
                    posend : integer);
 
        PROCEDURE
              m90buf5  (layer : tsp00_ToolLayer;
                    VAR buf : tsp00_MoveObj;
                    posanf : integer;
                    posend : integer);
 
        PROCEDURE
              m90hostname  (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    h :  tsp00_NodeId);
&       endif
 
      ------------------------------ 
 
        FROM
              SQLDB-Auftrags-Schnittstelle   : VPR03;
 
        PROCEDURE
              p03gparsid (sqlrap : sqlrapointer;
                    sqlemp : sqlempointer;
                    VAR parsid : tpr_parsid;
                    VAR SessionID : tpr00_SessionID);
 
        PROCEDURE
              p03gselparsid (sqlrap : sqlrapointer;
                    sqlemp : sqlempointer;
                    VAR parsid : tpr_parsid;
                    VAR SessionID : tpr00_SessionID);
 
        PROCEDURE
              p03modulnameput  (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR gae : sqlgaentry;
                    VAR kae : sqlkaentry);
 
        PROCEDURE
              p03cancel ( VAR sqlca : sqlcatype;
                    VAR gae : sqlgaentry);
 
        PROCEDURE
              p03reqrecpacket(
                    VAR sqlca   : sqlcatype;
                    VAR sqlxa   : sqlxatype;
                    VAR gae : sqlgaentry);
 
        PROCEDURE
              p03partptrinit  (sqlrap : sqlrapointer);
 
        PROCEDURE
              p03find_part  (sqlrap : sqlrapointer;
                    part_kind        : tsp1_part_kind;
                    VAR part_ptr     : tsp1_part_ptr);
 
        PROCEDURE
              p03psqllinecmd (VAR sqlca : sqlcatype;
                    VAR s  : tpr_sqlline;
                    anfpos : integer;
                    len    : integer;
                    lenmax : integer;
                    part_ptr : tsp1_part_ptr);
 
        PROCEDURE
              p03returncodeget (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype);
 
        PROCEDURE
              p03getparameteraddr (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR paix : integer;
                    VAR cmcnt : integer;
                    VAR vaaddr : tpr_vtypepointer;
                    VAR vaind  : integer;
                    VAR indaddr : tpr_vtypepointer;
                    VAR indind  : integer);
 
        PROCEDURE
              p03putsysprofbuf (sqlrap : sqlrapointer);
 
      ------------------------------ 
 
        FROM
              Runtime-Stringroutinen: VPR05;
 
        PROCEDURE
              p05inttochr12 (int : integer;
                    VAR chr12 : tsp00_C12);
 
        PROCEDURE
              p05nextsymbol (VAR buf : tsp00_MoveObj;
                    buflen  : tsp00_Int4;
                    posanf     : tsp00_Int4;
                    VAR sympos : tsp00_Int4;
                    VAR symlen : tsp00_Int4;
                    VAR symb   : tpr_symbol);
 
        PROCEDURE
              p05searchword  (VAR buf : tsp00_MoveObj;
                    lwb : integer;
                    upb : integer;
                    word : tsp00_Sname;
                    lw   : integer;
                    VAR pos : integer);
 
        FUNCTION
              p05eq (VAR a : tsp00_Sname;
                    VAR b  : tsp00_MoveObj;
                    b_pos  : tsp00_Int4;
                    length : tsp00_Int4) : boolean;
 
      ------------------------------ 
 
        FROM
              SQLDB-Program-Options  : VPR15;
 
        PROCEDURE
              p15noptionsget (VAR sclca : sqlcatype);
 
      ------------------------------ 
 
        FROM
              RTE_driver        : VEN102;
 
        PROCEDURE
              sqlabort;
 
        PROCEDURE
              sqlfinish (term : boolean);
 
        PROCEDURE
              sqldattime (VAR d : tsp00_C8;
                    VAR t : tsp00_C8);
 
        PROCEDURE
              sqlexec ( VAR ex_args       : tsp00_ExecLine;
                    ex_mode       : tsp00_ExecMode;
                    VAR retur         : tsp00_ExecReturn;
                    VAR err_text      : tsp00_ErrText;
                    VAR progresult    : tsp00_Int2);
 
        PROCEDURE
              sqlversion  (VAR vers : tsp00_C40);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill   : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;       
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;    
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;    
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30    : VSP30;
 
        FUNCTION
              s30eq (VAR a : tsp00_Sname;
                    VAR b : tsp00_MoveObj;
                    bi,cnt : tsp00_Int4) : boolean;
 
        FUNCTION
              s30klen (VAR str : tsp00_KnlIdentifier;
                    val : char; cnt : integer) : integer;
 
        FUNCTION
              s30len (VAR str : tsp00_ErrText;
                    val : char; cnt : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30len1 (VAR str : tpr_valuerec;
                    val : char; cnt : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30len2 (VAR str : tsp00_KnlIdentifier;
                    val : char; cnt : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30lnr (VAR str : tpr_valuerec;
                    val : char;
                    pos : tsp00_Int4;
                    cnt : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30gad (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
        FUNCTION
              s30gad2 (VAR b : char) : tpr_intaddr;
 
        FUNCTION
              s30gad3 (VAR b : tsp1_segment) : tsp1_segment_ptr;
 
      ------------------------------ 
 
        FROM
              GET-Conversions   : VSP40;
 
        PROCEDURE
              s40gbyte (VAR buf    : tpr_parsid;
                    pos    : tsp00_Int4;
                    len    : integer;
                    VAR dest   : tsp00_C256;
                    dpos   : tsp00_Int4;
                    dlen   : integer;
                    VAR truncated  : boolean);
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26finish_part (packet_ptr : tsp1_packet_ptr;
                    VAR finish_part      : tsp1_part);
 
        PROCEDURE
              s26new_part_init (packet_ptr : tsp1_packet_ptr;
                    VAR segm               : tsp1_segment;
                    VAR new_part_ptr       : tsp1_part_ptr);
 
        FUNCTION
              s26packet_len (packet_ptr : tsp1_packet_ptr):tsp00_Int4 ;
 
      ------------------------------ 
 
        FROM
              RTE-Extension-70    : VSP70;
 
        PROCEDURE
              s70execanalyze (VAR cmd : tsp00_MoveObj;
                    cmdl              : tsp00_Int2;
                    VAR ex_args       : tsp00_ExecLine;
                    VAR ex_mode       : tsp00_ExecMode;
                    VAR spec_complete : boolean);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              pr03mAllocatP;
 
              tpr_vtypepointer     tpr_intaddr
 
        PROCEDURE
              sqlexec;
 
              tsp00_ExecLine    tsp00_ExecLine
              tsp00_ExecMode    tsp00_ExecMode
              tsp00_ExecReturn  tsp00_ExecReturn
              tsp00_ErrText     tsp00_ErrText
              tsp00_Int2        tsp00_Int2
 
        PROCEDURE
              pr01StmtNameSnEntryInit;
 
              sqlsnentry tpr_sqlsnentry
 
        PROCEDURE
              sqlversion;
 
              tsp00_C40         tsp00_C40
 
        PROCEDURE
              m90hostname;
 
              tsp00_VFilename   tsp00_NodeId
 
        PROCEDURE
              m90buf;
 
              tsp00_Buf    tpr_sqlcol
 
        PROCEDURE
              m90buf1;
 
              tsp00_Buf     tpr_valuerec
 
        PROCEDURE
              m90buf2;
 
              tsp00_Buf           tsp00_ErrText
 
        PROCEDURE
              m90buf3;
 
              tsp00_Buf           tsp00_KnlIdentifier
 
        PROCEDURE
              m90buf4;
 
              tsp00_Buf           tpr_parsid
 
        PROCEDURE
              m90buf5;
 
              tsp00_Buf           tsp00_MoveObj
 
        PROCEDURE
              p08allocat;
 
              tsp00_ObjAddr  tpr_intaddr
 
        PROCEDURE
              sqldattime;
 
              tsp00_Date        tsp00_C8
              tsp00_Time        tsp00_C8
 
        PROCEDURE
              s70execanalyze;
 
              tsp00_Buf           tsp00_MoveObj
 
        PROCEDURE
              s30eq;
 
              tsp00_MoveObj   tsp00_Sname
              tsp00_MoveObj   tsp_varpart
 
        PROCEDURE
              s30len;
 
              tsp00_MoveObj   tsp00_ErrText
 
        FUNCTION
              s30len1;
 
              tsp00_MoveObj   tpr_valuerec
 
        FUNCTION
              s30len2;
 
              tsp00_Buf     tsp00_ErrText
              tsp00_MoveObj   tsp00_KnlIdentifier
 
        FUNCTION
              s30klen;
 
              tsp00_MoveObj       tsp00_KnlIdentifier
 
        FUNCTION
              s30lnr;
 
              tsp00_MoveObj   tpr_valuerec
 
        FUNCTION
              s30gad;
 
              tsp00_Addr          tpr_intaddr
 
        FUNCTION
              s30gad2;
 
              tsp00_MoveObj       char
              tsp00_Addr          tpr_intaddr
 
        FUNCTION
              s30gad3;
 
              tsp00_MoveObj       tsp1_segment
              tsp00_Addr          tsp1_segment_ptr
 
        PROCEDURE
              s40gbyte;
 
              tsp00_MoveObj   tpr_parsid
              tsp00_MoveObj   tsp00_C256
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1985-08-02
.sp
.cp 3
7
7
.sp
.cp 3
Release :  7.3    Date : 2001-06-26
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.sp 2
Hier werden die Datenstrukturen f?ur SQL_Kommandos und ihre
Arbeitsweise beschrieben.
.sp
Dieser Runtime-Modul basiert auf folgenden Datenstrukturen
siehe auch vpx00.deu:
.sp;.in +10
.un 8
SQLCA (Communication Area) enth?alt die R?uckmeldungen von
SQLDB an das Hostprogramm sowie die ben?otigten globalen
Strukturen SQLRA, SQLGA, SQLOA, SQLMA, SQLMF and SQLEM
die im Hostprogramm als Include Typen vereinbart werden.
Die SQLCA exisitiert pro Programm genau einmal. Getrennt kompilierte
Module m?ussen sie als externe Variable aus dem Hauptprogramm
importieren.
.sp
.un 8
SQLRA (Request Area) enth?alt das SQLDB-Auftragssegment
f?ur SQL-Kommandos.
Pro Programm existiert sie genau einmal. Getrennt kompilierte
Module importieren sie implizit, da sie Bestandteil der SQLCA
ist.
.sp
.un 8
SQLGA (Global Area) enth?alt die global zu haltenden Angaben
zum Betrieb der Auftragsschnittstelle.
Pro Programm existiert sie genau einmal. Getrennt kompilierte
Module importieren sie implizit, da sie Bestandteil der SQLCA
ist.
.sp
.un 8
SQLMA (Macro Area) enth?alt die f?ur die Macroparameter
in den SQL-Kommandos zu substituierenden Werte.
Pro Programm existiert sie genau einmal. Getrennt kompilierte
Module importieren sie implizit, da sie Bestandteil der SQLCA
.sp 3
.un 8
SQLXA (Extent Area) enth?alt die modulglobal ben?otigten
Variablen zum Betrieb der Laufzeitsystem-Prozeduren.
Sie existiert einmal pro getrennt ?ubersetztem Modul.
Die SQLXA wird modulspezifisch generiert und als
INCLUDE-File vor der eigentlichen Kompilation in den Modul eingef?ugt.
Sie enth?alt  SQLVA1, SQLVA2, SQLVA3, SQLPA, SQLKA, SQLFA, SQLAT,
SQLSD, SQLS1, SQLCU, SQLOR, SQLFN, and SQLSN,
ebenso f?ur dynamische Statements SQLPR, SQLDA und SQLST.
.sp
.un 8
SQLVA1,2,3 (Variable Area) enth?alt einen Eintrag f?ur jede
in diesem Modul deklarierte und gebrauchte
Variable zur Datenbank-Kommunikation.
Sie existiert pro getrennt ?ubersetztem Modul als lokale Modulvariable.
Die SQLVA1,2,3  werden modulspezifisch generiert und als Bestandteil der
SQLXA vor der eigentlichen Kompilation in den Modul eingef?ugt.
.sp
.un 8
SQLPA (Parameter Area) enth?alt einen Eintrag f?ur jeden
Parameter, der in einem im Programm stehenden SQL-Statement
verwendet wird. Gleiche Parameternamen in einem oder in
verschiedenen SQL-Angaben werden nicht auf denselben
SQLPA-Eintrag abgebildet. Indikatorparameter werden zusammen
mit den eigentlichen Parametern in einem Eintrag vermerkt.
Die SQLPA
existiert pro getrennt ?ubersetztem Modul als lokale Modulvariable.
Sie wird modulspezifisch generiert und als Bestandteil der
SQLXA vor der eigentlichen Kompilation in den Modul eingef?ugt.
.sp
.un 8
SQLKA (Kommando Area) enth?alt einen Eintrag f?ur jedes
in diesem Modul angegebene SQL-Statement. Die
SQLKA existiert pro getrennt ?ubersetztem Modul als lokale Modulvariable.
Sie wird modulspezifisch generiert und als Bestandteil der
SQLXA vor der eigentlichen Kompilation in den Modul eingef?ugt.
.sp 3
.un 8
SQLPR (Prepare Area) enth?alt einen Eintrag f?ur jedes
in diesem Modul angegebene SQL-Prepare-Statement
und SQL-Declare-Statement. Die
SQLPR existiert pro getrennt ?ubersetztem Modul als lokale Modulvariable.
Sie wird modulspezifisch generiert und als eigenst?andige Variable
erzeugt.
Der Pointer auf die Area wird in SQLXA-Area abgelegt.
Existiert kein Prepare_statement wird die Area auch nicht initialisiert.
.sp
.un 8
SQLDA (Descriptor Area) enth?alt einen Eintrag f?ur eine
Descriptorbeschreibung in diesem Modul.
SQLDA   existiert pro getrennt
?ubersetztem Modul einmal als lokale Modulvariablen.
Sie werden modulspezifisch generiert.
Existiert kein Describe-statement wird der
Type der SQLDA-Area auch nicht eingebunden.
.sp
.un 8
SQLST (Statement Area) enth?alt einen oder mehrere
String-Eintr?age f?ur jedes
in diesem Modul angegebene SQL-Prepare-Statement
oder SQL-Declare-Statement mit konstanten
String-statement Angabe. Die
SQLST existiert pro getrennt ?ubersetztem Modul als lokale Modulvariable.
Sie wird modulspezifisch generiert und als eigenst?andige Variable
erzeugt.
Der Pointer auf die Area wird in SQLXA-Area abgelegt.
Existiert kein Prepare_ oder Declare- Statement
wird die Area auch nicht initialisiert.
.sp 4;.in -10;.nf
.cp 12
             -----------------------
             |   Initialisierung   |
             -----------------------
.sp;.fo
Jede Macrovariable wird durch einen SQLMA-Entry beschrieben,
der den Macrostring und seine L?ange enth?alt.
Er wird bei jedem exec sql set &nnn gesetzt mit sqlmabind.
.sp
Jede Kommunikationsvariable wird durch
einen SQLVA1,2,3-Entry beschrieben, der die Adresse, den Typ, die
L?ange, die Anzahl der Nachkommastellen,
den Variablennamen und die L?ange des Namens
beschreibt.
.sp
Jede als Parameter verwendete Variable wird durch einen
SQLPA-Entry beschrieben, der die Variablennummer
und die Indikator-Variablennummer enth?alt.
Diese Nummern geben den Index der Variablen-
-Deklaration in der SQLVA1 an.
Jedes SQLPA-Entry hat au?zerdem Platz f?ur das SQLCOLINFO der
Hostvariablen, welches vom Laufzeitsystem eingetragen wird.
.sp
Die Sequence der Parameter in einem SQL-Statement wird hier durch ein
oder mehrere Eintr?age beschrieben. Es enth?alt den Areatyp die
Anzahl der Eintr?age in der entsprechenden SQL-Area, den
Index des ersten Eintrags und ob die Eintr?age aus einer
Structur sind oder einzel in SQL-Statement angegeben wurden.
.sp
Jedes Kommando wird durch einen SQLKA-Entry beschrieben.
Er enth?alt Angaben ?uber Kommandotyp,
Kommandostate und ob Macro vorhanden oder nicht.
Der pa_Index mit pa_Count der SQLPA-Area wird belegt
und initialisiert.
Bei 'execute' oder 'open' Kommandos wird noch der Index der
SQLPR-Area des zugeh?origen 'prepare' oder 'declare'
Statements angegeben sonst ist der Index = 0.
.sp;.cp 6
Jedes Prepare-Kommando und Declare-Kommando
wird durch einen SQLPR-Entry beschrieben.
Es enth?alt den Namen des Statements und
Angaben ob der Kommandostring ?uber Variable oder Konstanten
angegeben ist. SQLKAarea mit entsprechenden kaStcount,
 kaStindex Angaben
und zugeh?origer SQL-Area
werden initalisiert.
Stringconstante werden in SQLST-AREA und Variable werden in
SQLVA-Area abgelegt.
.sp
Jedes Execute-Kommando und Open-Kommando
wird durch einen SQLKA-Entry beschrieben.
Er enth?alt den Index des
zugeh?origen Prepare- oder Declare-Statements
in der SQLPR-Area.
Bei Parameterangaben den Index und Count der Eintr?age in der
SQLSA-Area.
.sp
Jedes Konstantenstatement bei Prepare- oder Declare-Kommandos wird
in die SQLST-Area abgelegt.
.sp 2
.cp 12
Vom Precompilelauf wird in jedem Modul eine
SQLSTART Procedure erzeugt.
.br
Sie erh?alt folgenden Aufbau :
.sp;.nf
begin
    sqlcheck (sqlca, sqlxa);   (siehe p01check)
    if sqlxa.xainit = cpr_is_true
    then begin
         initialisiere sql_area_adressen;
         initialisiere sqlva_area (variable);
         initialisiere sqlpa_area (parameter);
         initialisiere sqlsa_area (sequnce);
         initialisiere sqlka_area (kommando);
         initialisiere sqlxa_area (allgemeinesqlxa);
         initialisiere sqlpr_area (prepare);
         initialisiere sqlst_area (statement);
         initialisiere sqlfa_area (m-,fetch area );
         initialisiere sqlat_area (oracle dbserver at ..);
         initialisiere sqlcu_area (cursor area);
         initialisiere sqlfn_area (filename lineno area);
         initialisiere sqlsd_area (delectdirect fast area);
         initialisiere sqlsd1_area (delectdirect fast area);
         initialisiere sqloa_area (option from precompile run);
         initialisiere sqlxa_area (option from precompile run);
    end;
end;
.sp 4;.nf
.cp 8
             -----------------------
             |   Addressberechnung  |
             ------------------------
.sp;.fo
F?ur Sprachen, die keine eingebaute Adre?z-Funktion haben,
gibt es die Prozedur SQLADDR (p01getaddr), mit der die Adresse einer
Variablen bestimmt werden kann. Der Datenaustausch zwischen
Hostprogramm und Laufzeitsystem erfolgt nur ?uber diese
Adressen, nie ?uber die Variablennamen.
.sp 4;.nf
.cp 8
             --------------------
             |   Substitution   |
             --------------------
.sp;.fo
Durch den Befehl EXEC SQL SET &NNN = <macro> k?onnen
in jedem aus mehreren Modulen  bestehenden Anwendungsprogramm
bis zu 128 Substitutionen von
Macroparametern mit Konstanten der Art "authid.tablename"
vorgenommen werden.
Zur Verwaltung der Werte der
maximal 128 Parameter gibt es
eine SQLMA (SQL Macro Area), die aus einem Versionsz?ahler
und einer Liste von SQLMA-Entries besteht.
Die Macroparameter werden in der Form &1..&128 in den
Kommandos verwendet und durch die unter dem jeweiligen Index
in der SQLMA gespeicherten Werte vom Typ STRING30 ersetzt.
.sp
Der Befehl EXEC SQL SET &NNN = <macro> wird durch einen
SQLMABIND-Aufruf aufgel?ost. Die Prozedur SQLMABIND inkrementiert
den Versionsz?ahler und tr?agt den <value> vom Typ STRING30 in
den durch &NNN indizierten SQLMA-Entry ein. Ist <macro> eine
Hostvariable wird im ma_len der Index in die SQLVA1-area
eingetragen. Macronummer > 100 werden bei der Expansion nicht
in  Hochkomma (" ") gesetzt.
.sp
Alle Kommandos, die Macroparameter enthalten,
pr?ufen vor einer Ausf?uhrung den Versionsz?ahler. Hat er sich
ge?andert, dann mu?z das Kommando frisch substituiert und
erneut mit parse - execute ausgef?uhrt werden. Bleibt die
Versionsnummer konstant, kann auch bei Kommandos mit Macro-
parametern ein reiner Execute-Betrieb stattfinden.
.sp
Der Versionsz?ahler wird beim allerersten Aufruf von SQLSTART
von der LZU-lokalen Prozedur G_INIT initialisiert.
Wenn vor der Versions-Initialisierung in SQLSTART schon
SQLSETMA-Aufrufe erfolgten, haben diese die
nicht initialisierte Versionsnummer zwar hochgez?ahlt, aber der
Initialzustand 0 kann trotzdem gesetzt werden, da ja noch keine
Substitution erfolgen mu?zte. Die Prozedur SQLSETMA stellt sicher,
da?z die Versionsnummer immer ein g?ultiger Integer ist, indem
als Nachfolger von MAXLONGINT der Wert MINLONGINT genommen wird.
(Die Wahrscheinlichkeit, da?z in einem Hostprogrammlauf mehr als
4,3 Milliarden Macro-Substitutionen vorgenommen werden und dann auch noch
ausgerechnet ein Kommando aufgerufen wird, welches die gleiche
Versionsnummer hat, also w?ahrend der ganzen Substitutions-Schleife
nie ausgef?uhrt wurde, ist hinreichend gering, wenn der Anwendungs-
programmierer keine Fast-Endlosschleife eingebaut hat, aber wasser-
dicht ist die Methode nat?urlich nicht ]
.sp 4;.nf
.cp 6
             -------------------
             |   Ausf?uhrung    |
             -------------------
.sp;.fo
Ein im Programm stehendes SQL_Statement wird folgenderma?zen
aufgel?ost:
.sp
.nf
.cp 12
Kommando-Ausf?uhrung :
.sp
SQLSTART (sqlca, sqlxa);
                          (* proc wird im module eingebaut*)
 sqlxa.xakano := statement_number;
SQLBEGIN (sqlca, sqlxa);  (siehe p01begi)
WHILE sqlxa.xacmdinit = cpr_is_true DO
   BEGIN
      (siehe p01varpart_get)
      sqlxa.xaline := '...';   (* Kommando zuweisen *)
      sqlxa.xallen := ...;     (* L?ange des Kommandos angeben *)
      SQLLINE (sqlca, sqlxa);
      ....
      ....
      sqlxa.xaline := '...';    (* Kommando zuweisen *)
      sqlxa.xallen := ...;      (* L?ange des Kommandos angeben *)
      SQLLINE (sqlca, sqlxa);
      SQLEND  (sqlca, sqlxa);    (siehe p01end)
   END;
SQLWHENEVER  Behandlung;      (* siehe dort *)
.sp
.fo
Die Procedure SQLSTART ist eine Procedure die vom
Precompiler f?ur jeden Modul erzeugt und eingebunden wird.
Sie ruft intern SQLCHECK auf, diese Procedure liefert einen
Boolschenwert sqlxa.xainit zur?uck der angibt, ob die
Modulinitialisierung noch durchgef?uhrt werden mu?z.
Bei true wird die SQLSTARTprocedure veranlasst, die Initialisierung
durchzuf?uhren.
.sp
Die Procedure
SQLBEGIN entscheidet ?uber die Ausf?uhrungsart anhand der
Zustandsinformation in der SQLKA.
Wurde noch kein Tracefile er?offnet und wird nun gegraucht
wird dies jetzt noch veranla?zt.
SQLBEGIN und SQLEND
nehmen vom SQLDB_Datenbanksystem zum Programm
alle Transporte
und Konversionen von Parameterwerten
sowie den Warning- und Indikatorbetrieb vor.
.sp
Beim execute-Betrieb kann durch parallele Schema-?Anderungen
eine Wiederholung des Parsens erforderlich werden.
Anzahl der Wiederholungen ist durch mxpr_errorloop
festgelegt.
.sp
.sp 3
Eine Sonderform dynamisch ausgef?uhrter Kommandos sind
benannte Kommandos, die mit PREPARE und formalen Parametern
(z.B. Fragezeichen) geparst und mit EXECUTE <Kommandoname>
USING <Parameterfolge> ausgef?uhrt werden k?onnen.
.sp;.fo
Ein im Programm stehendes dynamisches
SQL_Statement wird folgenderma?zen
aufgel?ost:
.sp
.fo
.cp 12
Prepare- und Declare-Kommando-Ausf?uhrung :
.sp
SQLSTART (sqlca, sqlxa);
.sp
Der Kommandostring wird mit sqlstbind und sqlprbind
Routinen dem
Programm bekannt gemacht.
.sp 2
.cp 12
Execute_ und Open-Kommando-Ausf?uhrung :
.sp
Der execute Befehl wird mit sqlkabind dem Porgramm
bekannt gemacht.
.sp;.nf
 sqlxa.xakano := statement_number;
SQLBEGIN (sqlca, sqlxa);
WHILE sqlxa.xacmdinit = cpr_is_true DO
   BEGIN
      SQLEXECU  (sqlca, sqlxa);  (siehe p01execu )
      SQLEND    (sqlca, sqlxa);
   END;
SQLWHENEVER  Behandlung;      (* siehe dort *)
.sp
.sp 2
.fo
Bei dynamisch ausgef?uhrten SQL-Statements wird der Statementstring
intern bei SQLEXECU aufgebaut.
Solche
erst zur Laufzeit aus Textkonstanten und/oder beliebigen
Programmvariablen aufgebauten
SQL-Statements werden durch spezielle Precompiler-Anweisungen
kenntlich gemacht und ausgef?uhrt,
Kommt das Statement aus einer Programvariablen, so
wird der Kommando-Status jeweis neu gesetzt.
.sp 4;.nf
.cp 6
             ----------------------------
             |  SQLwhenever Behandlung  |
             ----------------------------
.sp;.fo
Nach jedem SQL-Statement wird diese Fehlerbehandung
eingebaut. Die unterschiedlichen Aktionen werden
ausgef?uhrt, wenn vom SQLDB-System entsprechende
SQLCA-fehlermeldungsvariable gesetzt wurden.
Der G?ultigkeitsbereich einer Wheneveranweisung wird
durch seine statische Position im Quellcode bestimmt,
nicht durch den Kontrollflu?z der   Ausf?uhrungsreihenfolge.
Wheneveranweisungen sind daher Modulspecifisch.
.sp 2
.cp 12
SQLWHENEVER-Input im Quellcode :
.sp
.nf
IF   (sqlca.sqlcode = 0) AND (sqlca.sqlwarn = 'W')
THEN    <!!! sqlaction>
ELSE
     IF   sqlca.sqlcode <> 0
     THEN
          IF   sqlca.sqlcode = 100
          THEN  <not found sqlaction>
          ELSE
               IF   sqlca.sqlcode > 0
               THEN  <exception sqlaction>
               ELSE  <error sqlaction>;
.sp 2
.cp 12
SQLWHENEVER-default-input im Quellcode :
.sp
IF   (sqlca.sqlcode = 0) AND (sqlca.sqlwarn = 'W')
THEN    continue  (* warning *)
ELSE
     IF   sqlca.sqlcode <> 0
     THEN
          IF   sqlca.sqlcode = 100
          THEN  continue  (* not found *)
          ELSE  continue  (* error, exception *)
.sp 4;.nf
.cp 6
             -------------------
             |   Trace-Options  |
             -------------------
.sp;.fo
Durch eine Precompiler-Option kann ein Tracing
f?ur alle SQL-Kommandos in diesem Modul
eingeschaltet werden. Dies wird bei
SQLBEGIN gepr?uft. Falls noch kein Tracefile er?offnet
wurde wird dies dort gemacht. Der Name des Tracefile muss
immer als Option angegeben werden.
Der Name der bei dem ?offnen des Tracefiles exsistiert
bleibt w?arend des gesammten Programmlaufs erhalten.
Vorrangig ist der Tracename der Programmoptions.
Danach der erste Modultracename f?ur den ein Trace
eingeschalltet werden soll.
Es sind folgende Trace-M?oglichkeiten denkbar : kein Trace,
Trace mit formalen Parametern (ohne Ein- Ausgabewerte)
und Longtrace mit aktuellen Parametern (mit Ein- Ausgabewerten).
Default ist kein Trace eingestellt.
.sp 4;.nf
    ******** Oracle Erweiterungen *********
.sp
.fo
Oracle belegt die sqlda ohne eine 'DESCRIBE' Anweisung.
Dazu ben?otigt SQLDB einige Erg?anzungen.
.br
Die Erweiterungen werden nur durchgef?uhrt, wenn das Kommando
beim "prepare" ?uber eine Hostvariable angegeben ist.
.sp
1. die Shortfieldinfos m?ussen f?ur einige Kommandos aufgehoben
werden. Sie werden in der SQLOR-Area abgelegt.
.sp
2. 'exec sql prepare' muss beim 'prepare' schon geparsed werden.
Dazu wird im Auftragspuffer
sp1c_prepare = true  mit dem "<statement> " an den Kern gesendet. Das Kommando
wird im Kern aufgehoben. Bei eventuellem Fehler der ein neues
Parsen verlangt (csp_use_new_pars_info = -9) wird beim "execute"
oder "open cursor" neu executet. Beim Error -9 ist der sp1p_buf
mit der neuen Shortfieldinfo,
und mit der neuen Parsid belegt. Das Bedeutet, da?z das
Kommando nochmals nach dem retten der neuen Informationen (pr01cUseNewParseInfo)
executet wird. (p01adbsaexecute).
.sp
3.Wird ein "describe" doch angegeben, werden die entsprechenden
Felder in der Oracle_sqlda belegt.
.sp 3
Neue SQLOR-AREA :
.sp
Wird f?ur zu jedem ka_entry zus?atzlich gebraucht und angelegt.
Er enth?alt den Pointer (orcolptr) auf die zugeh?orige Shortfieldinfo.
Bei einem erneuten executen wird diese Information in die SQLDA
gebracht.
.sp
.fo
Oropennew wird mit cpr_is_init belegt, beim "prepare" Kommando.
.sp 2
Erweiterungen in den Proceduren:
.sp 2
procedure p01begi:
.sp
Bei dynamischen Kommandos schon geparsed, wird die gerettete
Shortfiedinfo in die SQLDA gemoved, wenn es  describe, open cursor,
oder execute Kommando ist.
.sp
Das Kommando "open cursor"  wird, wenn der Trace eingeschaltet ist, nicht
neu geparset.
.sp 2
procedure p01end:
.sp
Beim "prepare command" wird das belegen der sqlda unterdr?uckt
(oraparse = false). Ebenso wird das Kommando nicht executet (in
p01prepare) ist die Abfrage.
.sp 2
procedure p01adbsexecute:
.sp
Bei Fehler csp_use_new_pars_info = -9 werden die Parsid und die
neuen Sfinfos gerettet und das Kommando wird nochmals abgesetzt
(p01inpadbsexecute).
.sp 2
procedure p01descr:
.sp
Bei einem Describe f?ur eine Ergebnismenge, kann nicht vom
Precompiler festgestellt werden, ob ein Open schon abgesetzt worden
ist.
Deshalb wird eine neue Syntax an den Kern gesendet.
.nf
    -----------------------
    |  DESCRIBE | parsid  |
    -----------------------
    |  part1    |  part2  |
 
und oropennew := cpr_is_describe gesetzt.
.fo
Die SQLDA wird dann mit den Angaben aus der Longinfo belegt.
.sp 2
procedure p10gethostvariable:
.sp
Newlines-charakter in der Hostvariablen werden in Blank
umgesetzt.
.sp 2
Procedure p01parseprepare:
.sp
Die Procedure wird beim Kommando "prepare" abgesetzt.
Sie parset nur, wenn das kommando ?uber eine Hostvariable kommt.
Das Kommando wird mit sp1c_prepare = true  an den
Kern gesendet.
F?ur die Sfinfos wird neuer Speicher angefordert, und die Adresse,
Parsid und xakano des Preparekommandos wird in die SQLOR-Area
der zugeh?origen
Kommandos eingetragen.
.sp 2
Procedure p01movesfinfo:
.sp
Die Sfinfo eines Kommandos aus der SQLOR-Area
wird in die SQLDA-geschrieben.
.sp 2
Procedure p01opencursor:
.sp
Da die Parsid beim Open-cursor schon bekannt ist aber
der Ergebnisname noch nicht, wird Open-cursor
Mit parsid + Ergebnismengennamen  in Part1 an den Kern
gesendet. Gleichzeitig werden beim Traceoutput die
Informationen in den Trace geschrieben.
.sp
Handelt es sich um ein Massen-declare-cursor (open 'ergname'),
wird die Parsid entsprechend auf ein Massenkommando umgesetzt.
.sp 2
Functio p01prepare:
.sp
Die Funktion ist true wenn es sich um ein "prepare" Kommando
handelte. Das heist es wird kein execute mehr durchgef?uhrt.
Handelt es sich um ein dynamisches Fetch Kommando, werden
die Sfinfos in die SQLDA-geschrieben.
.sp 2
Proecedure p01pparsidtrace:
.sp
Schreibt eine parsid in den Tracefile.
.nf
Inout 1 :: INPUT
      2 :: OUTPUT
      3 :: PARSID OLD
      4 :: PARSID NEW
      5 :: SQL STATEMENT : Module  Line
      6 :: EXECUTE SQL   : Module Line
      7 :: USE "EXECUTE IMMEDIATE ":
      8 :: FETCH STATEMENT :
      9 ::               : Module  Line
     10 :: PARSE AGAIN :
           IMPLICIT KOMMAD
     11 :: Version :p1, :p2
           SQL STATEMENT : Module  Line
     12 :: PARSID OF SELECT
     99 :: OTHERWISE
.fo
.sp 2
Proecedure p01_prname_get:
.sp
Fuer PREPARE :stmname wird der Statementname in einer Hostvariablen erwartet.
Dies ist der Fall wenn prStmtNameIndex != 0. Holt aus der in prStmtNameIndex angegebenen
Hostvariablen (vaarea) den Inhalt der Variablen und copiert ihn nach
sqlprp[kaprindex].prStmtName.
.sp 2
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
.sp 2
PROCEDURE  p01addr (SQLADDR):  (* oder sqlxaddr mit x=1..4   *)
.sp 2
Berechnet von einer Variablen, die Maschinen interne Addresse.
.sp 4
PROCEDURE  p01check  (SQLCHECK):
 oder PROCEDURE  SQLCCHEC  f?ur C-Sprache.:
 oder PROCEDURE  SQLPCHECK f?ur Pascal-Sprache.:
 oder PROCEDURE  SQLCBECK  f?ur Cobol-Sprache.:
.sp 2
 
Initialisiert die Sprache in sqlxa.xalang.
Checkt : ob f?ur das Programm initialisiert wurde.
         Bei nein werden durch die Procedure g_init
         die programmglobalen Variablen initialisiert.
.sp
Checkt : ob ?uber Programparameter ein connect
         durchgef?uhrt werden soll
         oder ob vom Programm oder implicit und
         stellt die entsprechenden Werte
         f?ur das sp?atere Connect bereit.
.sp
Checkt : ob f?ur den Module schon die allgemeinen Variablen
         initialisiert wurden.
         Bei nein werden die modulglobalen Variablen
         initialisiert.
.sp 4;.cp 6
PROCEDURE  p01ma2bi;
.sp 2
Die Maversion wird um eins erh?oht und
ma-entry %NNN initialisiert.
.sp 4
PROCEDURE  p01begi:
.sp 2
Initalisiert die actuelle Session und ruft p01beg auf.
.sp 4
PROCEDURE  p01beg:
.sp 2
Variable :
.br
cmdfetch := cpr_is_false kein fetch;  cpr_is_true fetch aus mf_buffer;
cpr_is_init mfetch absetzen;
.br
prepars := false, Kommando muss weiter bearbeitet werden;
true  Kommando ist vollst?andig bearbeitet, kein p01end aufruf mehr;
.br
preopen := false, inititalisiert;
true, open cursor oder execute wurde schon bei prepare geparsed;
.br
open_cuerrd3 := false, initalisiert;
true, bei fetch using descriptor, wenn zugeh?origes open
'row not found' brachte.
.sp
Initialisiert Kommando spezifische Informationen.
(Longspalten, kamode, actuelle Session, reconnect Information
und ob Optinen nach reconnect neu analysert werden sollen).
.sp
Untersucht ob Colinfos schon vorhanden und belegt sie (p01movesfinfo),
ob Kommando schon vollst?andig bearbeitet wurde (prepars = true).
Wenn prepars = false
initialisiert die Sqlca_area Return-felder.
Pr?uft ob Tracefile noch er?offnet werden mu?z und
f?uhrt es evevtuell durch.
Initialisiert SQLRA-Auftrag.
Belegt kastate.
Bei Traceausgabe wird kastate = cpr_state_parse gesetzt.
Pr?uft, ob ein execute ausgef?uhrt
werden kann. Bei ja, wird das Kommando mit Parsid und
Eingabeparametern aufgebaut und abgesetzt.
Bei sp1r_returncode = -1  (pars again)
wird kastate auf parse gesetzt. Da xacmdinit auf true sitzt,
wird der Auftrag nochmals aufgebaut und in sqlend bearbeitet.
Bei sp1r_returncode <> -1  werden Errors, Warnings und oder
Ausgabeparameter belegt und xacmdinit auf false gesetzt.
.sp 4
.cp 6
PROCEDURE  p01end:
.sp 2
Ist es das erste Kommando und kein 'connect' so wird
ein imlicites Connect abgesetzt.
Evtl. Macrosubsitutionen und Parameterexpansionen
werden durchgef?uhrt.
Setzt bei Macroangaben die kaversion = maversion.
Wird Trace verlangt wird das Kommando in
einen Tracefile geschrieben.
Kastate kann nur parse oder commmand sein.
.sp
Bei parse wird der Auftraggeparst. Nach korrektem Ablauf
wird die parseid, Shortfieldinfos belegt.
Ist parseid = 0 wird kastate auf cpr_state_command und xacmdinit auf
false gesetzt, dh. das Kommando ist vollst?andig
abgearbeitet.
Ist parsid [cpr_p_precom_index] = chr(p_use_adbs) wird kastate auf cpr_state_command gesetzt.
Da xacmdinit auf true sitzt, wird das Kommando nochmals
aufgebaut und abgesetzt.
In allen anderen F?allen wird
kastate auf
execute gesetzt.
Dann wird das Kommando mit Parseid und
Eingabeparametern aufgebaut und abgesetzt.
Bei return_code = -1
wird kastate auf parse gesetzt, s60maximal mxpr_errorloop.
Da xacmdinit auf true sitzt,
wird der Auftrag nochmals aufgebaut und in sqlend bearbeitet.
Bei return_code <> -1  werden Errors, Warnings und oder
Ausgabeparameter belegt und xacmdinit auf false gesetzt.
.sp
Bei cpr_state_command
wird der Auftrag mit dbs abgesetzt.
Vor dem Aufruf werden Eingabeparameter in part2.
Nach dem Aufruf werden errors, Warnings und oder
Ausgabeparameter belegt und xacmdinit auf false gesetzt.
.sp
Ist xacmdinit true, d.h. das Kommando soll nochmals aufgebaut
werden, dann wird sqlrap frisch initialisiert.
.sp 4
.cp 6
PROCEDURE p01adbsexecute:
.sp 2
Die Procedure erzeugt f?ur array-sql Kommandos mehrere Puffer,
die an den Kern gesendet werden, bevor der Anwender die Kontrolle
zur?uckerh?alt.
Die Repeat-Schleife wird solange durchlaufen, bis Fehler auftreten
oder das Kommando abgearbeitet ist. In der Procedure p04inputparamput
oder p04outputparamget wird der Schalter lpnext := cpr_is_false f?ur
Beendigung der Abarbeitung gesetzt.
.sp
In der localen  Variablen looprec (Parameter)
werden entsprechende Informationen
f?ur dieses eine Kommando abgespeichert, die bei der Belegung des
Auftragspuffers gebraucht werden. Die Procedure wird von p01begin
und p01end aufgerufen. Einige Statements sind dabei unterschiedlich
daf?ur wurde der Parameter proc_begin mitgegeben. Er zeigt an, ob
p01adbsexecute von p01begi (TRUE) aufgerufen wurde.
Ebenso wird noch die locale variable cmdfetch und cmdtype gebraucht,
und gegebenenfalls umgesetzt.
.sp 4
.cp 6
PROCEDURE  p01varpart_get:
.br oder SQLLINEC f?ur C-Sprache.
.sp 2
Setzt einen Teil eines Auftragsstring in die SQLRA-Area.
Evtl. Macrosubsitutionen und Parameterexpansionen
werden nach dem gesammten Aufbau in sqlend durchgef?uhrt.
.sp 4
.cp 6
PROCEDURE  p01descr:
.sp 2
Holt das zugeh?orige Statement aus der SQLPR-area (p01execute).
Kennzeichnet in dem zugeh?origen 'prepare' Kommando,
da?z beim 'fetch' evtl. die Ausgabe ?uber Descriptor SQLDA
erw?unscht ist.
Pr?uft, ob ein fetch mit 'using SQLDA' angegeben ist.
Bei ja, wird das zugeh?orige ka_statement gekennzeichnet
(kasa_count := -4) und 'describe im Kern aufgerufen,
andernfalls wird (kasa_count := -3) gekenzeichnet und
die Variablen Beschreibung ?uber die Parsinfo geholt.
(kasa_count := -5) alle ?ubrigen Komandos.
.br
Belegt das Kommando und parsed es und belegt die
sqlda_area.
.sp 4
.cp 6
PROCEDURE  p01execu:
.sp 2
Holt das zugeh?orige Statement aus der SQLPR-area (execute).
Bei Stringkonstanten wird SQLRA aus SQLST-area aufgebaut.
Bei Variabler wird SQLRA aus der Variablen aufgebaut.
Bei describe Angabe wird noch das ein fetch Kommando
entsprechend umgesetzt (fetch into :a .... ).
.sp 4
.cp 6
PROCEDURE  p01execute:
.sp 2
Holt das zugeh?orige Statement aus der SQLPR-area,
aus einer Hostvariablen oder aus der SQLST-Area.
Bei Stringkonstanten wird SQLRA aus SQLST-area aufgebaut.
Bei Variabler wird SQLRA aus der Variablen aufgebaut.
.sp 4
.cp 6
PROCEDURE  p01stop:
.sp 2
Wird aufgerufen, wenn bei der Wheneverbehandlung das  Programm
abgebrochen werden soll.
Schlie?zt alle Transactionen von den offenen Sessions ab
und stopt den programmlauf.
.sp 4
.cp 6
PROCEDURE  p01exit:
.sp 2
Wird aufgerufen, wenn vom Anwender im Programm 'exec sql stop'
angegeben wurde.
Schlie?zt das Anwenderprogramm mit sqlfinish ab, d.h. der Returncode
wird gesetzt und die Verbindugen zur Datenbank werden ordnugsgem?a?z
abgeschlossen.
.sp
Der Paramerter "FALSE" in 'sqlfinish' sagt,
die Kontrolle wird an  das Programm
zur?uckgegeben, d.h. der Returncode kann eventuell durch
die Behandlung der Sprache im Betriebsystem ?uberschrieben werden.
.sp
Der Paramerter "TRUE" in 'sqlfinish' sagt,
das Programm wird durch die SQLDB-LZU
abgebrochen und der Returncode kann nicht mehr ?uberschrieben werden.
.sp 4
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.CM -sss-
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
VAR
      p01looprec : tpr_sqlloop;
      p01lvcrec  : tpr_longvarcharrec;
 
 
(*------------------------------*) 
 
FUNCTION
      p01getaddr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
BEGIN
p01getaddr := s30gad (b);
END;
 
(*------------------------------*) 
 
FUNCTION
      p01get1addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
BEGIN
p01get1addr := s30gad (b);
END;
 
(*------------------------------*) 
 
FUNCTION
      p01get2addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
BEGIN
p01get2addr := s30gad (b);
END;
 
(*------------------------------*) 
 
FUNCTION
      p01get3addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
BEGIN
p01get3addr := s30gad (b);
END;
 
(*------------------------------*) 
 
FUNCTION
      p01get4addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
BEGIN
p01get4addr := s30gad (b);
END;
 
(*------------------------------*) 
 
FUNCTION
      p01get5addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
BEGIN
p01get5addr := s30gad (b);
END;
 
(*------------------------------*) 
 
FUNCTION
      p01get6addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
BEGIN
p01get6addr := s30gad (b);
END;
 
(*------------------------------*) 
 
FUNCTION
      p01get7addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
BEGIN
p01get7addr := s30gad (b);
END;
 
(*------------------------------*) 
 
FUNCTION
      p01get8addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
BEGIN
p01get8addr := s30gad (b);
END;
 
(*------------------------------*) 
 
FUNCTION
      p01get9addr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
BEGIN
p01get9addr := s30gad (b);
END;
 
(*------------------------------*) 
 
FUNCTION
      p01getaaddr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
BEGIN
p01getaaddr := s30gad (b);
END;
 
(*------------------------------*) 
 
FUNCTION
      p01getbaddr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
BEGIN
p01getbaddr := s30gad (b);
END;
 
(*------------------------------*) 
 
FUNCTION
      p01getcaddr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
BEGIN
p01getcaddr := s30gad (b);
END;
 
(*------------------------------*) 
 
FUNCTION
      p01getdaddr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
BEGIN
p01getdaddr := s30gad (b);
END;
 
(*------------------------------*) 
 
FUNCTION
      p01geteaddr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
BEGIN
p01geteaddr := s30gad (b);
END;
 
(*------------------------------*) 
 
FUNCTION
      p01getfaddr  (VAR b : tsp00_MoveObj) : tpr_intaddr;
 
BEGIN
p01getfaddr := s30gad (b);
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01addr (VAR sqlca : sqlcatype;
            VAR variab : tsp00_MoveObj;
            VAR resaddr  : tpr_vtypepointer);
 
BEGIN
WITH sqlca DO
    resaddr.intaddr := s30gad (variab);
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01check (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            connplen: tsp00_Int4);
 
BEGIN
p01xcheck (sqlca, sqlxa);
p03csqlcaareainit (sqlca);
p03raprofinit (sqlca, mxpr_sysprof_stmlen+2);
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01sqlstatement (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR gae : sqlgaentry;
            kae : sqlkaentry_ptr);
 
BEGIN
WHILE sqlxa.xacmdinit = cpr_is_true DO
    BEGIN
    p01varpart_get (sqlca, sqlxa, gae, kae);
    pr01cEnd(sqlxa.xaSQLDesc^);
    END;
(*ENDWHILE*) 
&ifdef TRACE
m90name(xx, 'END p01statement  ');
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01cmd_execute_immediate (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR gae : sqlgaentry;
            kae : sqlkaentry_ptr);
 
VAR
      err_w   : tpr_error_warnset;
      lsnname : tsp00_KnlIdentifier;
 
BEGIN
(*  execute immediate kommando *)
WITH sqlca, sqlrap^, rasqltap^, sqlgap^, sqlxa DO
    BEGIN
    (* execute immediate kom. *)
    IF   (kae^.kastate <> cpr_state_command)
    THEN
        p08runtimeerror (sqlca, sqlxa, cpr_invalid_commandstate)
    ELSE
        IF  ((kae^.kapacount = -5) AND
            (pr01cIsComType(sqlxa.xaSQLDesc^, cpr_com_crea_ind)))
        THEN
            (* describe create index *)
            (* dummy command *)
            xacmdinit := cpr_is_false
        ELSE
            BEGIN
            IF   sqlemp^.ereturncode = 0
            THEN
                BEGIN
                IF  pr01cIsComType(sqlxa.xaSQLDesc^, cpr_com_sql_conn) = false
                THEN
                    BEGIN
                    (* trace output in p03connect *)
                    p01cmd_trace (sqlca, sqlxa, kae, gae);
                    p01pparsidtrace(sqlca, sqlxa, kae,
                          kae^.kaParseInfo.ParseId, TraceParseIDSQLStmt_epr00);
                    END;
                (*ENDIF*) 
                kae^.kaparserrc := 0;
                IF  pr01cIsComType(sqlxa.xaSQLDesc^, cpr_com_sql_conn)
                THEN
                    BEGIN
                    p03connect(sqlxa, sqlrap, sqlgap, gae, sqldatetime, sqlemp);
                    p01pparsidtrace(sqlca, sqlxa, kae,
                          kae^.kaParseInfo.ParseId, TraceParseIDSQLStmt_epr00);
                    p01xprofinit (sqlca, sqlxa, gae);
                    END
                ELSE
                    BEGIN
                    sqlrap^.rasegptr^.sp1c_mess_type := sp1m_dbs;
                    p03modulnameput(sqlca, sqlxa, gae, kae^);
                    pr03AbapInfoPutPart(sqlca, sqlrap, gae);
                    p03reqrecpacket(sqlca, sqlxa, gae);
&                   if $RELVER = R62
&                   else
                    p03sABAPStream(sqlca, sqlxa, gae);
&                   endif
                    pr01cResultNameGet(sqlrap, gae, sqlca.sqlresn, sizeof(sqlca.sqlresn));
                    END;
                (*ENDIF*) 
                IF   (sqlemp^.ewarning [1] <> bsp_c1)
                    AND  (sqlemp^.ereturncode = 0)
                THEN
                    BEGIN
                    err_w.warn :=  gae.garecptr^.sp1_segm.sp1r_extern_warning;
                    kae^.kaparserrc := err_w.int2;
                    kae^.kaParseInfo.sp1rFunctionCode := pr01sGetFunctionCode(sqlrap);
&                   ifdef TRACE
                    m90int  (pc, 'adbs warnset', err_w.int2);
&                   endif
                    END;
                (*ENDIF*) 
                p03returncodeget (sqlca, sqlxa);
                IF  (sqlca.sqlcode <> 0)
                    AND pr01cIsComType(sqlxa.xaSQLDesc^, cpr_com_rollback_release)
                THEN
                    (* ignore errorcode on rollback release *)
                    BEGIN
                    p03csqlcaareainit(sqlca);
                    IF   (tatrout <> cpr_trace_off)
                    THEN
                        BEGIN
                        (*          1234567890123456789012345678901234567890123456789012345678901234*)
                        lsnname := 'INFO   : Ignore error on rollback work release.                 ';
                        p08puttraceknlid (sqlca, sqlxa, lsnname, sizeof(lsnname), true);
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                p01xtimetrace (sqlca, sqlxa, gae);
                xacmdinit := cpr_is_false;
                IF  pr01cIsComType(sqlxa.xaSQLDesc^, cpr_com_commit_release)
                    OR pr01cIsComType(sqlxa.xaSQLDesc^, cpr_com_rollback_release)
                THEN
                    BEGIN
                    p03sqlrelease (sqlrap, sqlgap, gae, sqlemp);
                    sqlrap^.raactsession := cpr_se_empty;
                    END;
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01cmd_trace (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            kae : sqlkaentry_ptr;
            VAR gae : sqlgaentry);
 
BEGIN
WITH sqlca, sqlrap^, rasqltap^, sqlxa  DO
    IF   tatrout <> cpr_trace_off
    THEN
        BEGIN
        IF  kae <> NIL
        THEN
            BEGIN
            IF  kae^.kapacount = -5
            THEN
                p03cmdtrace (sqlca.sqlrap, gae, 1, cpr_com_describe, NIL)
            ELSE
                IF  pr01cIsComType(sqlxa.xaSQLDesc^, cpr_com_sql_open)
                THEN
                    p03cmdtrace (sqlca.sqlrap, gae, 1, cpr_com_sql_open, NIL)
                ELSE
                    p03cmdtrace (sqlca.sqlrap, gae, 1, cpr_com_empty, NIL);
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            p03cmdtrace (sqlca.sqlrap, gae, 1, cpr_com_empty, NIL);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01initlooprec (VAR looprec : tpr_sqlloop);
 
BEGIN
WITH looprec  DO
    BEGIN
    lpcnt    := 0;
    lperrd3  := 0;
    lpindi   := 0;
    lpindo   := 0;
    lpfirsti := cpr_is_true;
    lpfirsto := cpr_is_true;
    lpnext   := cpr_is_false;
    lpfiller   := 0;
    lprescount := 0;
    lprecli    := 0;
    lpreclo    := 0;
    lperri   := cpr_p_ok;
    lperro   := cpr_p_ok;
    END;
(*ENDWITH*) 
&ifdef TRACE
m90name(xx, 'END p01initlooprec');
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01adbsexecute  (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR gae   : sqlgaentry;
            kae   : sqlkaentry_ptr;
            VAR ore   : sqlorentry;
            cue   : sqlcuentry_ptr;
            VAR cmdfetch : tsp00_Int2;
            VAR cmdtyp   : tsp1_cmd_mess_type;
            proc_begin   : boolean);
 
VAR
      err3    : integer;
      reterrd3    : integer;
      retcmdfetch : tsp00_Int2;
      retcmdtyp   : tsp1_cmd_mess_type;
      retlooprec  : tpr_sqlloop;
      rowWithSuccess : integer;
      cnt_new_pars_info : tsp00_Int2;
      nam  : tsp00_Name;
      part_ptr  : tsp1_part_ptr;
      datafound : boolean;
      lint : tsp00_Int4;
 
BEGIN
WITH sqlca, sqlxa, sqlgap^, sqlrap^, p01looprec, p01lvcrec  DO
    BEGIN
&   ifdef P04TRACE
    p04trint2(sqlrap, 'p01adbsexecute    ', cmdfetch);
&   endif
    IF  cue <> NIL
    THEN
        reterrd3 := cue^.cuerrd3;
    (*PID*)
    (*ENDIF*) 
    p01pparsidtrace (sqlca, sqlxa, kae,
          kae^.kaParseInfo.ParseId, TraceParseIDInput_epr00);
    IF  (raparse_again = FALSE)
    THEN
        BEGIN
        pr04LongInitLD (sqlca, sqlxa);
        rasqlldp.vtypep^.ldallsend := false;
        p01initlooprec ( p01looprec);
        pr04LongLvcInitRec (sqlca, p01lvcrec);
        END;
    (*ENDIF*) 
    err3  := 0;
    IF  (pr01cIsComType(sqlxa.xaSQLDesc^, cpr_com_sql_open))
        AND (cue <> NIL)
    THEN
        BEGIN
        cue^.cuerrd3 := 0;
        IF  NOT proc_begin
        THEN
            cue^.custate := cpr_is_true;
&       ifdef TRACE
        (*ENDIF*) 
        m90int  (pc, 'kacuindex   ', kae^.kacuindex);
        m90int  (pc, 'cuerrd3 o   ', cue.cuerrd3 );
        m90int  (pc, 'custate o   ', cue.custate );
&       endif
        END;
&   ifdef TRACE
    (*ENDIF*) 
    m90bool (pc, 'parsing_agai', raparse_again);
&   endif
    REPEAT
        BEGIN
        retcmdfetch := cmdfetch;
        retcmdtyp   := cmdtyp;
        retlooprec := p01looprec;
        END;
        IF  (((err3 <> 0)
            AND (kae^.kaParseInfo.ParseId [cpr_p_precom_index]
            = chr (csp1_p_mselect_found)))
            OR ( (err3 <> 0)
            AND (kae^.kaParseInfo.ParseId [cpr_p_precom_index]
            = chr (csp1_p_mass_command))))
        THEN
            (* 30.11.93 *)
            lperrd3 := err3;
&       ifdef P04TRACE
        (*ENDIF*) 
        p04trint2(sqlrap, 'p01adbsexecute 1  ', cmdfetch);
&       endif
        p01inpadbsexecute (sqlca, sqlxa, gae, kae, cue, cmdfetch, cmdtyp, p01looprec);
&       ifdef P04TRACE
        p04trint2(sqlrap, 'p01adbsexecute 2  ', cmdfetch);
&       endif
        (*BF 11.2.97*)
        IF  (sqlcode <> 0)
            AND (sqlerrd[3] <> 0)
        THEN
            BEGIN
            (* sqlerrd[3] ist <> 0 bei longspalten error *)
            err3 := sqlerrd[3];
            (*BF 11.2.97*)
            sqlerrd [3] := 0;
            END;
&       ifdef TRACE
        (*ENDIF*) 
        m90int  (pc, 'err3        ', err3     );
        m90int  (pc, 'lperri      ', ord(p01looprec.lperri));
        m90int  (pc, 'sqlerrd(3) 1', sqlerrd [3] );
&       endif
        cnt_new_pars_info := 0;
        WHILE (sqlemp^.ereturncode = csp_use_new_pars_info)
              AND (cnt_new_pars_info < 2) DO
            BEGIN
            (* PTS 1108103 *)
            pr01cUseNewParseInfo(sqlxa.xaSQLDesc^);
            cmdfetch := retcmdfetch;
&           ifdef P04TRACE
            p04trint2(sqlrap, 'retcmdfetch  1    ', cmdfetch);
&           endif
            cmdtyp   := retcmdtyp;
            IF  (((sqlemp^.eerrorpos <= 1) AND (cnt_new_pars_info=0) )
                OR  (
                ord (kae^.kaParseInfo.ParseId [cpr_p_precom_index]) in
                [csp1_p_mass_select_found,
                csp1_p_reuse_mass_select_found,
                csp1_p_select_for_update_found,
                csp1_p_reuse_update_sel_found,
                csp1_p_mselect_found,
                csp1_p_reuse_mselect_found,
                csp1_p_for_upd_mselect_found,
                csp1_p_reuse_upd_mselect_found]))
            THEN
                BEGIN
                (* mass selects insensitive for already processed input data*)
                p01looprec  := retlooprec;
                pr04LongInitLD (sqlca, sqlxa);
                p01inpadbsexecute (sqlca, sqlxa, gae, kae, cue, cmdfetch, cmdtyp,
                      p01looprec);
                END
            ELSE
                BEGIN
                (* mass insert/update/delete sensitive for successfully processed input data*)
                rowWithSuccess := sqlemp^.eerrorpos-1;
                IF  (rowWithSuccess <= 0)
                THEN
                    rowWithSuccess := 0;
                (*ENDIF*) 
                sqlerrd [3] := err3 + rowWithSuccess;
                err3 :=  sqlerrd [3];
                IF  (err3 <> 0)
                THEN
                    lperrd3 := err3;
                (*ENDIF*) 
                p01looprec.lpindi := sqlerrd [3];
                pr04LongInitLD (sqlca, sqlxa);
                p01inpadbsexecute (sqlca, sqlxa, gae, kae, cue, cmdfetch, cmdtyp, p01looprec);
                IF  (sqlemp^.ereturncode <> csp_use_new_pars_info)
                THEN
                    sqlerrd [3] := sqlerrd [3] + err3;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
&           ifdef P04TRACE
            p04trint2(sqlrap, 'p01adbsexecute 3  ', cmdfetch);
&           endif
&           ifdef TRACE
            m90int  (pc, 'cnt_new_p   ', cnt_new_pars_info);
            m90int  (pc, 'lperri      ', ord(p01looprec.lperri));
&           endif
            cnt_new_pars_info :=   cnt_new_pars_info + 1;
            END;
        (*ENDWHILE*) 
        (*****22.4.96 *******)
        IF  ((sqlcode <> 0)  AND (sqlcode <> 100))
        THEN
            err3 := err3 + sqlerrd [3];
        (**BF**)
        (*ENDIF*) 
        IF  sqlmfetch <> 0
        THEN
            BEGIN
            p01baexecute (sqlca, sqlxa, gae, kae^, ore);
            IF   cmdfetch = cpr_is_init
            THEN
                BEGIN
                (* PTS 1104385 *)
                lint := pr01bNumberOfRows(sqlca, sqlxa);
                p01bgetmfetch (sqlca, sqlxa, gae, kae^, lint);
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        raparse_again:=FALSE;
        IF   (sqlemp^.ereturncode = csp_old_fileversion)
            OR  (sqlemp^.ereturncode = cpr_file_or_table_droped)
        THEN
            BEGIN
            p01pparsidtrace (sqlca, sqlxa, kae,
                  kae^.kaParseInfo.ParseId, TraceParseIDAgain_epr00);
            IF  proc_begin
            THEN
                BEGIN
                cmdfetch := retcmdfetch;
                cmdtyp   := retcmdtyp;
                p01looprec  := retlooprec;
                p01bdrop_parsid (sqlca, sqlxa, kae^.kaParseInfo.ParseId);
                IF  (gae.gaKernelVersion < Version730_cpr00)
                    OR ((gae.gaKernelVersion >= Version740_cpr00) AND (gae.gaKernelVersion < Version742_cpr00))
                THEN
                    pr06ParseIdDropDirect(sqlxa.xaSQLDesc^.ConDesc, kae^.kaParseInfo.ParseId)
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                cmdfetch := retcmdfetch;
                cmdtyp   := retcmdtyp;
&               ifdef P04TRACE
                p04trint2(sqlrap, 'retcmdfetch   2   ', cmdfetch);
&               endif
                p01looprec  := retlooprec;
                p03returncodeget (sqlca, sqlxa);
                p01xtimetrace (sqlca, sqlxa, gae);
                (* ADIS 1000323    xastopcnt := xastopcnt + 1;*)
                END;
            (*ENDIF*) 
            kae^.kastate := cpr_state_parse;
            cmdtyp  := sp1m_parse;
            IF   xastopcnt >= mxpr_errorloop
            THEN
                xacmdinit := cpr_is_false
            ELSE
                BEGIN
                xacmdinit := cpr_is_true;
                p03ccmdinit(sqlxa.xaSQLDesc^, sqlca, gae, cmdtyp);
                END;
            (*ENDIF*) 
            raparse_again:=TRUE;
&           ifdef TRACE
            m90bool (pc, 'parsing_agai', raparse_again);
&           endif
            END
        ELSE
            BEGIN
            xastopcnt := 0;
&           ifdef TRACE
            m90int  (pc, 'lperri v    ', ord(p01looprec.lperri));
            m90int  (pc, 'sqlerrd(3) 2', sqlerrd [3] );
&           endif
            IF  (lperri <> cpr_inp_number_truncated)
                OR  (sqlemp^.ereturncode <> 0)
            THEN
                p03returncodeget (sqlca, sqlxa);
&           ifdef TRACE
            (*ENDIF*) 
            m90int  (pc, 'sqlcode     ', sqlcode );
            m90int  (pc, 'sqlerrd(3) 3', sqlerrd [3] );
&           endif
            IF  (gae.gareference <> 0)  (*BF*)
            THEN
                (* describe *)
                IF   kae^.kapacount < 0
                THEN
                    BEGIN
&                   ifdef TRACE
                    m90int  (pc, 'sqlda-area**', kapacount  );
                    m90int  (pc, 'kapacount** ', kapacount  );
                    p01_pr_sqlda (sqlca, sqlxa);
&                   endif
                    IF  sqlcxap^.xasqldap.sqldaptr <> NIL
                    THEN
                        p04dout (sqlca, sqlxa, gae, p01looprec);
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    IF  pr01cIsComType(sqlxa.xaSQLDesc^, cpr_com_sql_open) = false
                    THEN
                        p04output (sqlca, sqlxa, gae, p01looprec);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
&           ifdef TRACE
            (*ENDIF*) 
            m90int  (pc, 'err3  1     ', err3    );
            m90int  (pc, 'sqlerrd3    ', sqlerrd [3]);
&           endif
            pr04LongOutputLvc (sqlca, sqlxa, gae, p01looprec);
&           ifdef TRACE
            m90int  (pc, 'err3  2     ', err3    );
            m90int  (pc, 'sqlerrd3    ', sqlerrd [3]);
&           endif
            IF  ((sqlrap^.rakamode = cpr_kind_oracle) OR (sqlrap^.rakamode = cpr_kind_sapr3))
                (* PTS 1109835 *)
                AND (cue <> NIL)
                AND (kae^.kaParseInfo.ParseId[cpr_p_precom_index] <> chr(csp1_p_mass_command))
                (* ADIS 1001009 *)
                AND (kae^.kaParseInfo.ParseId[cpr_p_precom_index] <> chr(csp1_p_none))
                (* endof ADIS 1001009 *)
            THEN
                BEGIN
                IF  sqlcode = 0
                THEN
                    BEGIN
                    IF  (lpnext = cpr_is_false)
                    THEN
                        cue^.cuerrd3 := cue^.cuerrd3 + lperrd3;
                    (*ENDIF*) 
                    sqlerrd[3] := cue^.cuerrd3;
                    IF  (kae^.kaopendata = cpr_is_true)
                        AND (kae^.kaParseInfo.ParseId[cpr_p_precom_index] = chr(csp1_p_mfetch_found))
                    THEN
                        BEGIN
                        IF  (lpnext = cpr_is_true)
                        THEN
                            BEGIN
                            WITH kae^.kafae^, sqlmfp^,
                                 mfentry^ [famfindex] DO
                                BEGIN
                                mfLastrecno := cue^.cuerrd3 + lperrd3;
                                fafetch     := cpr_is_false;
                                END;
                            (*ENDWITH*) 
                            END
                        ELSE
                            WITH kae^.kafae^, sqlmfp^,
                                 mfentry^ [famfindex] DO
                                BEGIN
                                (* rest vom open muss noch *)
                                (* geholt werden *)
                                mfRecpos := mfActualPos;
                                mfLastrecno := cue^.cuerrd3;
                                p03find_part (sqlrap, sp1pk_data, part_ptr);
                                IF  (part_ptr <> NIL)
                                THEN
                                    BEGIN
                                    WITH  part_ptr^, sp1p_part_header  DO
                                        IF  (sp1pa_last_packet in sp1p_attributes)
                                        THEN
                                            mfAllRecordsRead := cpr_is_true
                                        (*ENDIF*) 
                                    (*ENDWITH*) 
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        END
                    (* ADIS 1106140   *)
                    ELSE
                        IF  (lpnext = cpr_is_false)
                        THEN
                            IF  ( (kae^.kafaindex > 0) AND
                                (kae^.kafae^.famfindex > 0))
                            THEN
                                BEGIN
                                WITH kae^.kafae^, sqlmfp^,
                                     mfentry^[famfindex] DO
                                    BEGIN
                                    mfRecpos := mfActualPos;
                                    mfLastrecno := cue^.cuerrd3;
                                    END;
                                (*ENDWITH*) 
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  pr01cIsComType(sqlxa.xaSQLDesc^, cpr_com_sql_open) = false
                    THEN
                        cue^.custate  := cpr_is_init
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  sqlcode = 100
                THEN
                    BEGIN
                    IF  ( rasegptr^.sp1r_function_code = csp1_mfetch_next_fc)
                    THEN
                        IF  kae^.kafae^.famfindex > 0
                        THEN
                            BEGIN
                            p03find_part (sqlrap, sp1pk_data, part_ptr);
                            IF  (part_ptr <> NIL)
                            THEN
                                BEGIN
                                WITH  part_ptr^, sp1p_part_header  DO
                                    IF  (sp1pa_last_packet in sp1p_attributes)
                                    THEN
                                        WITH sqlmfp^.mfentry^[kae^.kafae^.famfindex] DO
                                            mfAllRecordsRead := cpr_is_true
                                        (*ENDWITH*) 
                                    (*ENDIF*) 
                                (*ENDWITH*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    cue^.cuerrd3 := cue^.cuerrd3 + lperrd3;
                    sqlerrd[3] := cue^.cuerrd3;
                    IF  pr01cIsComType(sqlxa.xaSQLDesc^, cpr_com_sql_open)
                    THEN
                        BEGIN
                        IF  (ord (kae^.kaParseInfo.ParseId [cpr_p_precom_index]) in
                            [csp1_p_mass_select_found,
                            csp1_p_reuse_mass_select_found,
                            csp1_p_select_for_update_found,
                            csp1_p_reuse_update_sel_found,
                            csp1_p_mselect_found,
                            csp1_p_reuse_mselect_found,
                            csp1_p_for_upd_mselect_found,
                            csp1_p_reuse_upd_mselect_found])
                        THEN
                            BEGIN
                            (* open with row not found *)
                            cue^.cuerrd3 := -100;
                            sqlcode := 0;
                            sqlemp^.ereturncode := 0;
                            sqlerrml:= 0;
                            sqlerrmc [1] := chr(0);
                            END
                        (*ENDIF*) 
                        END
                    ELSE
                        (* BF 30.9.93 end *)
                        cue^.custate     := cpr_is_false;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  (gae.gareference <> 0)
                THEN
                    (*30.11.93*)
                    IF  (kae^.kaParseInfo.ParseId [cpr_p_precom_index]
                        = chr (csp1_p_mselect_found))
                        OR (rasegptr^.sp1r_function_code
                        = csp1_mselect_into_fc)
                        OR (kae^.kaParseInfo.ParseId [cpr_p_precom_index]
                        = chr (csp1_p_mass_command))
                    THEN
                        IF  (sqlcode <> 0)
                        THEN
                            err3 := err3 + sqlerrd [3]
                        ELSE
                            err3 :=  sqlerrd [3]
                        (*ENDIF*) 
                    ELSE
                        err3 := err3 + sqlerrd [3];
                    (*ENDIF*) 
                (*ENDIF*) 
                sqlerrd [3] := err3;
                END;
            (*ENDIF*) 
&           ifdef TRACE
            m90int  (pc, 'err3        ', err3);
            m90int  (pc, 'sqlerrd 3 5 ', sqlerrd [3]);
            m90int  (pc, 'lpnext      ', lpnext  );
            m90int  (pc, 'lpcnt       ', lpcnt   );
            m90int  (pc, 'lpmax       ', lpmax   );
            m90int  (pc, 'lpindo      ', lpindo  );
            m90int  (pc, 'sqldbmode   ', sqldbmode  );
            m90int  (pc, 'kaeParseInfo.ParseId[11]',
                  ord (kae^.kaParseInfo.ParseId [cpr_p_precom_index]) );
&           endif
            IF  (sqlcode = 0)
            THEN
                BEGIN
                IF  (lperri <> cpr_p_ok)
                THEN
                    p08runtimeerror (sqlca, sqlxa, lperri)
                ELSE
                    IF  (lvcerror <> cpr_p_ok)
                    THEN
                        p08runtimeerror (sqlca, sqlxa, lvcerror);
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  ((sqldbmode = cpr_kind_oracle)
                    OR (sqldbmode = cpr_kind_sapr3))
                THEN
                    IF  (kae^.kaParseInfo.ParseId [cpr_p_precom_index]
                        = chr (csp1_p_mfetch_found))
                    THEN
                        (******1.10.95 *)
                        IF  (p01looprec.lpnext = cpr_is_false)
                            AND (p01looprec.lpcnt > 1)
                            AND (p01looprec.lpindo < p01looprec.lpmax)
                        THEN
                            BEGIN
                            sqlemp^.ereturncode := 100;
                            sqlemp^.eerrorpos  := 0;
                            nam := 'ROW NOT FOUND     ';
                            s10mv (mxsp_name, mxsp_c70, @nam, 1,
                                  @sqlemp^.etext, 1, mxsp_name);
                            sqlemp^.etextlen := mxsp_name;
                            p03returncodeget (sqlca, sqlxa);
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            p01xtimetrace (sqlca, sqlxa, gae);
            p08relsess (sqlca, sqlxa, gae, kae^);
            xacmdinit := cpr_is_false;
            END;
        (*ENDIF*) 
    UNTIL
        (kae^.kastate = cpr_state_parse) OR
        (sqlcode <> 0) OR (p01looprec.lpnext = cpr_is_false);
    (*ENDREPEAT*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01inpadbsexecute  (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR gae    : sqlgaentry;
            kae    : sqlkaentry_ptr;
            cue    : sqlcuentry_ptr;
            VAR cmdfetch : tsp00_Int2;
            VAR cmdtyp   : tsp1_cmd_mess_type;
            VAR looprec : tpr_sqlloop);
 
VAR
      warn_ka : tsp_int_map_c2;
      rescnt  : tsp00_Int4;
      sp1p_attr  : tsp1_part_attr;
      temp : tsp00_Int2;
      lint : tsp00_Int4;
 
BEGIN
WITH sqlca, sqlxa, sqlgap^, sqlrap^ DO
    BEGIN
&   ifdef P04TRACE
    p04trint2(sqlrap, 'p01inpadbsexecute ', cmdfetch);
&   endif
    p03ccmdinit(sqlxa.xaSQLDesc^, sqlca, gae, cmdtyp);
    p03cpparsid (sqlrap, gae, kae^.kaParseInfo.ParseId, sqlemp);
    pr01cOpenCursor(sqlxa.xaSQLDesc^);
&   ifdef EXECUTEATFETCH
    IF  NOT pr01sExecuteAtFetchPossible(sqlxa, sqlkap^[xakano])
    THEN
        pr01sDisableExecuteAtFetch(sqlrap);
    (* describe *)
&   endif
    (*ENDIF*) 
    IF   (kae^.kaParseInfo.ParseId [cpr_p_precom_index] = chr(csp1_p_fetch_found))
        OR  (kae^.kaParseInfo.ParseId [cpr_p_precom_index] = chr(csp1_p_mfetch_found))
    THEN
        BEGIN
        IF  (kae^.kaopendata = cpr_is_true)
        THEN
            cmdfetch := cpr_is_true;
        (*ENDIF*) 
        END
    ELSE
        pr03CheckPointPutPart(sqlca, gae, sqlrap);
    (*ENDIF*) 
    IF  (gae.gareference <> 0)  (*BF*)
    THEN
        BEGIN
        IF   kae^.kapacount < 0
        THEN
            BEGIN
            IF  sqlcxap^.xasqldap.sqldaptr <> NIL
            THEN
                BEGIN
                p04din ( sqlca, sqlxa, gae, cue^, looprec);
                END
            (*ENDIF*) 
            END
        ELSE
            p04input (sqlca, sqlxa, gae, looprec);
        (*ENDIF*) 
        END;
    (* packet absetzen execute *)
&   ifdef P04TRACE
    (*ENDIF*) 
    p04trint2(sqlrap, 'cmdfetch          ', cmdfetch);
&   endif
    IF  (cmdfetch = cpr_is_true)
    THEN
        BEGIN
        cmdfetch := cpr_is_false;
        (* PTS 1104385 *)
        lint := pr01bNumberOfRows(sqlca, sqlxa);
        temp := p01bmfetch (sqlca, sqlxa, gae, kae^, cmdfetch, lint);
        END;
    (*ENDIF*) 
    IF   (cmdfetch <> cpr_is_true)
    THEN
        BEGIN
&       ifdef TRACE
        m90int2 (pc, 'rescnt 1vor ', rescnt );
&       endif
        WITH sqlrap^, rasqlldp.vtypep^ DO
            IF  (( NOT ldallsend))
                AND (sqlemp^.ereturncode = 0)
            THEN
                BEGIN
&               ifdef TRACE
                m90int2 (pc, 'rescnt 2vor ', rescnt );
&               endif
                p03reqrecpacket (sqlca, sqlxa, gae);
&               if $RELVER = R62
&               else
                p03sABAPStream(sqlca, sqlxa, gae);
&               endif
                IF  sqlemp^.ereturncode = csp_use_new_pars_info
                THEN
                    p03returncodeget (sqlca, sqlxa);
                (*ENDIF*) 
                pr01cResultNameGet(sqlca.sqlrap, gae, sqlca.sqlresn, sizeof(sqlca.sqlresn));
                (*** >  10.10.95 ****)
&               ifdef TRACE
                m90int2 (pc, 'rescnt  vor ', rescnt );
                m90int4 (pc, 'sqlerrd[3]  ', sqlerrd [3] );
                m90int  (pc, 'lperrd3i    ', looprec.lperrd3i );
&               endif
                p03cresultcountget (sqlrap, gae, sqlerrd[3]);
&               ifdef TRACE
                m90int4 (pc, 'sqlerrd[3]  ', sqlerrd [3] );
                m90int  (pc, 'lperrd3i    ', looprec.lperrd3i );
&               endif
                warn_ka.map_int := kae^.kaparserrc;
&               ifdef TRACE
                m90int4 (pc, 'sqlerrd[3]  ', sqlerrd [3] );
                m90int  (pc, 'exec warnset', warn_ka.map_int);
&               endif
                IF   (warn_ka.map_int <> 0)
                THEN
                    (* set warning from parsen *)
                    p03warningset (sqlemp, warn_ka.map_c2);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01varpart_get (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR gae : sqlgaentry;
            kae : sqlkaentry_ptr);
 
VAR
      i : integer;
      part_ptr : tsp1_part_ptr;
      ptr  : tsp1_packet_ptr;
 
BEGIN
WITH sqlca, sqlxa, sqlrap^, sqlgap^  DO
    BEGIN
    ptr := gae.gareqptr;
    s26new_part_init (ptr, rasegptr^, part_ptr);
    part_ptr^.sp1p_part_header.sp1p_part_kind :=  sp1pk_command;
    part_ptr^.sp1p_part_header.sp1p_buf_len   :=  0;
    rasegmpartptr [ord(sp1pk_command)+1] := part_ptr;
    WITH part_ptr^, sp1p_part_header  DO
        BEGIN
        FOR i := kae^.kaStindex TO kae^.kaStindex + kae^.kaStcount - 1 DO
            WITH sqlstp^ [i]  DO
                p03psqllinecmd (sqlca, stline, 1, stllen,
                      mxpr_sqlline, part_ptr);
            (*ENDWITH*) 
        (*ENDFOR*) 
        sp1p_buf_len  := sp1p_buf_len + 1;
        sp1p_buf [ sp1p_buf_len ] := bsp_c1;
        s26finish_part (ptr, part_ptr^);
&       ifdef TRACE
        m90int4 (pc, 'sp1p_buf_len', sp1p_buf_len);
        m90buf5 (pc, sp1p_buf, 1, sp1p_buf_len);
&       endif
        END;
    (*ENDWITH*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
m90name(xx, 'END p01varpart_get');
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01command  (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR gae : sqlgaentry;
            kae : sqlkaentry_ptr;
            kano      : tsp00_Int2);
 
VAR
      len  : integer;
      len4 : tsp00_Int4;
      ex_args  : tsp00_ExecLine;
      ex_mode  : tsp00_ExecMode;
      ex_return : tsp00_ExecReturn;
      err_text  : tsp00_ErrText;
      prog_result : tsp00_Int2;
      in4         : tsp00_Int4;
      nam         : tsp00_Name;
      spec_complete : boolean;
      parsid      : tpr_parsid;
      vptr      : tpr_vtypepointer;
      iptr      : tpr_vtypepointer;
      va1ind   : integer;
      indind   : integer;
      paix     : integer;
      cnt      : integer;
      part_ptr : tsp1_part_ptr;
 
BEGIN
WITH sqlca, sqlxa, sqlrap^, rasqltap^, sqlgap^  DO
    BEGIN
    ex_mode :=  sync_new_session;
    xakano := kano;
    WITH sqlprp^ [kae^.kaprindex] DO
        BEGIN
&       ifdef TRACE
        p01areaprint  (sqlca, sqlxa);
        m90int2 (pc, 'kapaindex   ', kae^.kapaindex);
&       endif
        p01xtracefilecheck (sqlca, sqlxa);
        p03ccmdinit(sqlxa.xaSQLDesc^, sqlca, gae, sp1m_dbs);
        IF  prarea = cpr_in_sqlva
        THEN
            p01xpagethostvariable (sqlca, sqlxa, gae, kae^.kapaindex, len4)
        ELSE
            p01varpart_get (sqlca, sqlxa, gae, kae);
        (*ENDIF*) 
        p03find_part (sqlrap, sp1pk_command, part_ptr);
        IF  part_ptr <> NIL
        THEN
            WITH  part_ptr^, sp1p_part_header  DO
                BEGIN
                len := sp1p_buf_len;
                p03cmdtrace (sqlca.sqlrap, gae, 1, cpr_com_command, NIL);
                spec_complete := true;
&               ifdef TRACE
                m90int2 (pc, 'len         ', len);
                m90buf5 (pc, sp1p_buf, 1, len);
&               endif
                s70execanalyze (sp1p_buf, len, ex_args,
                      ex_mode, spec_complete);
&               ifdef TRACE
                m90int2 (pc, 'ex_mode var ', ord(ex_mode) );
                m90buf5 (pc, sp1p_buf, 1, len);
&               endif
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        CASE prstate OF
            cpr_state_sync_exec :
                BEGIN
                nam     := 'SYNC              ';
                ex_mode :=  sync_new_session;
                END;
            cpr_state_newsync_exec :
                BEGIN
                nam     := 'NEWSYNC           ';
                ex_mode :=  sync_new_session;
                END;
            cpr_state_async_exec :
                BEGIN
                nam     := 'ASYNC             ';
                ex_mode :=  async;
                END;
            OTHERWISE:
            END;
        (*ENDCASE*) 
        IF  tatraceno <> 0
        THEN
            BEGIN
            p08puttracename (sqlca, sqlxa, nam, mxsp_name, true);
            p01pparsidtrace (sqlca, sqlxa, kae,
                  parsid, TraceParseIDBlank_epr00);
            IF  ranotrtimeoutp = cpr_is_false
            THEN
                sqldattime (tastartdate, tastarttime);
            (*ENDIF*) 
            END;
&       ifdef TRACE
        (*ENDIF*) 
        m90int2 (pc, 'ex_mode vsql', ord(ex_mode) );
&       endif
        sqlexec (ex_args, ex_mode, ex_return, err_text, prog_result);
        p01restrace (sqlca, sqlxa, prog_result);
&       ifdef TRACE
        m90int2 (pc, 'prog_result ', prog_result );
        m90int2 (pc, 'ex_mode nsql', ord(ex_mode) );
&       endif
        IF  tatraceno <> 0
        THEN
            IF  ranotrtimeoutp = cpr_is_false
            THEN
                sqldattime (taenddate, taendtime);
&           ifdef TRACE
            (*ENDIF*) 
        (*ENDIF*) 
        m90int2 (pc, 'ex_return   ', ord(ex_return) );
        m90int2 (pc, 'prog_result ', prog_result );
        m90buf2 (pc, err_text, 1, ERRTEXT_MXSP00 );
&       endif
        IF  prkaindex <> 0
        THEN
            BEGIN
            paix := prkaindex;
            p03getparameteraddr (sqlca, sqlxa, paix (* paindex *),
                  cnt, vptr, va1ind, iptr, indind );
            IF  vptr.intaddr = 0
            THEN
                p08runtimeerror (sqlca, sqlxa, cpr_missing_variable_addr)
            ELSE
                WITH  sqlv1p^[ va1ind], sqlv2p^ [va1indva2_sc] DO
                    (* put prog_result into hostvariable *)
                    CASE va2typ OF
                        cpr_vint2 :
                            s10mv (mxsp_c2, mxsp_c2, @prog_result, 1,
                                  @vptr.vtypep^, 1, mxsp_c2);
                        cpr_vint4 :
                            BEGIN
                            in4 := prog_result;
                            s10mv (mxsp_c4, mxsp_c4, @in4, 1,
                                  @vptr.vtypep^, 1, mxsp_c4);
                            END;
                        OTHERWISE:
                            p08runtimeerror (sqlca, sqlxa,
                                  cpr_incompatible_datatype);
                        END;
                    (*ENDCASE*) 
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  ex_return <> ex_ok
        THEN
            WITH sqlemp^ DO
                BEGIN
                ereturncode   := -11000 -ord (ex_return);
                eerrorpos     := 0;
                etextlen      := s30len (err_text, chr(0), ERRTEXT_MXSP00);
                s10mv (ERRTEXT_MXSP00, mxsp_c70, @err_text, 1,
                      @etext, 1, etextlen);
                p03returncodeget (sqlca, sqlxa);
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    p01xtimetrace (sqlca, sqlxa, gae);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01cancel  (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR gae : sqlgaentry;
            kano : tsp00_Int2);
 
VAR
      retsess  : tsp00_Int2;
      sess     : tsp00_Int2;
      in4      : tsp00_Int4;
      vptr     : tpr_vtypepointer;
      iptr     : tpr_vtypepointer;
      va1ind   : integer;
      indind   : integer;
      paix     : integer;
      cnt      : integer;
 
BEGIN
sqlxa.xakano := kano;
WITH sqlca, sqlxa, sqlkap^ [xakano], sqlrap^  DO
    BEGIN
    retsess :=  raactsession;
&   ifdef TRACE
    m90int2 (pc, 'sqlxakano   ', xakano );
&   endif
    IF  (kapacount = 1)
    THEN
        BEGIN
        (*p03csqlcaareainit (sqlca);*)
        IF  kapaindex = 0
        THEN
            BEGIN
            p01canctrace (sqlca, sqlxa, raactsession);
            p03cancel (sqlca, gae);
            END
        ELSE
            IF  kapaindex < 0
            THEN
                BEGIN
                retsess := raactsession;
                raactsession := - kapaindex;
                p01canctrace (sqlca, sqlxa, raactsession);
                p03cancel (sqlca, gae);
                raactsession := retsess;
                END
            ELSE
                IF  kapaindex > 0
                THEN
                    BEGIN
                    (* hostvariable *)
                    paix := kapaindex;
                    p03getparameteraddr (sqlca, sqlxa, paix (* paindex *),
                          cnt, vptr, va1ind,
                          iptr, indind );
                    IF  vptr.intaddr = 0
                    THEN
                        p08runtimeerror (sqlca, sqlxa,
                              cpr_missing_variable_addr)
                    ELSE
                        WITH  sqlv1p^[ va1ind], sqlv2p^ [va1indva2_sc] DO
                            (* put hostvariable into session *)
                            CASE va2typ OF
                                cpr_vint2, cpr_vuns2 :
                                    s10mv (mxsp_c2, mxsp_c2, @vptr.vtypep^, 1,
                                          @retsess, 1, mxsp_c2);
                                cpr_vint4, cpr_vuns4 :
                                    BEGIN
                                    s10mv (mxsp_c4, mxsp_c4,
                                          @vptr.vtypep^, 1,  @in4, 1, mxsp_c4);
                                    retsess := in4;
                                    END;
                                OTHERWISE:
                                    p08runtimeerror (sqlca, sqlxa,
                                          cpr_incompatible_datatype);
                                END;
                            (*ENDCASE*) 
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    IF  (retsess > 0) AND
                        (retsess < 9)
                    THEN
                        BEGIN
                        sess := raactsession;
                        raactsession := retsess;
                        p01canctrace (sqlca, sqlxa, raactsession);
                        p03cancel (sqlca, gae);
                        raactsession := sess;
                        END
                    ELSE
                        p08runtimeerror (sqlca, sqlxa,
                              cpr_db_session_not_allowed);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        p03returncodeget (sqlca, sqlxa);
        p01xtimetrace (sqlca, sqlxa, gae);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01canctrace (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            sess : tsp00_Int2);
 
VAR
      nam  : tsp00_Name;
      int  : integer;
      chr12  : tsp00_C12;
 
BEGIN
WITH sqlca, sqlrap^, rasqltap^  DO
    BEGIN
    IF  tatraceno <> 0
    THEN
        BEGIN
        p08puttracename (sqlca, sqlxa, nam, -1, true);
        SAPDB_PascalForcedFill (mxsp_c256, @tastr80, 1, mxsp_c256, bsp_c1);
        tastr80l := 0;
        nam := 'CANCEL SESSION :  ';
        p08puttracename (sqlca, sqlxa, nam, mxsp_name, false);
        int := sess;
        p05inttochr12 (int, chr12);
        s10mv (mxsp_c12, mxsp_c256, @chr12, 2,
              @tastr80, tastr80l+1, 5 );
        tastr80l := tastr80l + 5;
        p08vfwritetrace (sqlca.sqlrap);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01putversion (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            vaind     : tsp00_Int2;
            len : tsp00_Int4;
            VAR vers   : tsp00_C40;
            VAR error : tpr_runtime_errors;
            VAR ptr   : tpr_vtypepointer);
 
VAR
      in4 : tsp00_Int4;
      in2 : tsp00_Int2;
 
BEGIN
WITH sqlca, sqlxa, sqlrap^, sqlv1p^ [vaind] DO
    BEGIN
    WITH  sqlv2p^ [va1indva2_sc] DO
        BEGIN
        IF  va2size <> cpr_pointerlen
        THEN
            IF  len > va2size
            THEN
                BEGIN
                error := cpr_inp_string_truncated_oracle;
                len := va2size;
                END;
&           ifdef TRACE
            (*ENDIF*) 
        (*ENDIF*) 
        m90int4 (pc, 'len         ', len  );
        m90int2 (pc, 'va2typ      ', va2typ );
&       endif
        CASE va2typ OF
            cpr_vbuf, cpr_vchar :
                BEGIN
                s10mv (len, len, @vers, 1,
                      @ptr.vtypep^, 1, len);
                END;
            cpr_vstring4 :
                BEGIN
                in4 := len;
                s10mv (mxsp_c4, mxsp_c4, @in4, 1, @ptr.vtypep^, 1,
                      mxsp_c4);
                s10mv (len+5, len+5, @vers, 1,
                      @ptr.vtypep^, 5, len);
                END;
            cpr_vstring :
                BEGIN
                in2 := len;
                s10mv (mxsp_c2, mxsp_c2, @in2, 1, @ptr.vtypep^, 1,
                      mxsp_c2);
                s10mv (len+3, len+3, @vers, 1,
                      @ptr.vtypep^, 3, len);
                END;
            cpr_vcharc, cpr_vcharz  :
                BEGIN
                s10mv (len, len, @vers, 1,
                      @ptr.vtypep^, 1, len);
                ptr.vtypep^.buf[len+1] := chr(0);
                END;
            OTHERWISE:
                BEGIN
                error :=  cpr_unknown_datatype;
                END;
            END;
        (*ENDCASE*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01verstrace (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            art       : tsp00_Int2;
            VAR vers  : tsp00_C40);
 
VAR
      nam  : tsp00_Name;
 
BEGIN
WITH sqlca, sqlrap^, rasqltap^  DO
    BEGIN
    IF  tatraceno <> 0
    THEN
        BEGIN
        SAPDB_PascalForcedFill (mxsp_c256, @tastr80, 1, mxsp_c256, bsp_c1);
        IF  (art = 1)
        THEN
            nam := 'OUTPUT :  LZU  :  '
        ELSE
            nam := 'OUTPUT :  PCR  :  ';
        (*ENDIF*) 
        p08puttracename (sqlca, sqlxa, nam, mxsp_name, false);
        s10mv (mxsp_c40, mxsp_c256, @vers, 1,
              @tastr80, tastr80l+1, mxsp_c40);
        tastr80l := tastr80l + mxsp_c40;
        p08vfwritetrace (sqlca.sqlrap);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01restrace (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            prog_result : tsp00_Int2);
 
VAR
      nam  : tsp00_Name;
      int  : integer;
      chr12  : tsp00_C12;
 
BEGIN
WITH sqlca, sqlrap^, rasqltap^  DO
    BEGIN
    IF  tatraceno <> 0
    THEN
        BEGIN
        SAPDB_PascalForcedFill (mxsp_c256, @tastr80, 1, mxsp_c256, bsp_c1);
        nam := 'OUTPUT :       :  ';
        p08puttracename (sqlca, sqlxa, nam, mxsp_name, false);
        nam := 'RESULT      :     ';
        p08puttracename (sqlca, sqlxa, nam, 15, false);
        int := prog_result;
        p05inttochr12 (int, chr12);
        s10mv (mxsp_c12, mxsp_c256, @chr12, 2,
              @tastr80, tastr80l+1, 5 );
        tastr80l := tastr80l + 5;
        p08vfwritetrace (sqlca.sqlrap);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01stop    (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype);
 
VAR
      i : integer;
 
BEGIN
WITH sqlca, sqlgap^, sqlrap^, sqlxa DO
    FOR i := 1 TO mxpr_sqlga DO
        BEGIN
        IF   gaentry [i]^ .gareference <> 0
        THEN
            BEGIN
            raactsession := i;
            pr03cRelease(xaSQLDesc^.ConDesc);
            gaentry [i]^ .gareference := 0;
            END;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
(*ENDWITH*) 
IF  sqlca.sqlrap^.rasqlinit <> cpr_is_false
THEN
    sqlfinish (true);    (* 24.9.91 *)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01exit  (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype);
 
VAR
      nam : tsp00_Name;
 
BEGIN
WITH sqlca, sqlrap^, rasqltap^, sqlxa DO
    BEGIN
    IF  sqlrap^.rasqlinit <> cpr_is_end
    THEN
        IF   tatraceno <> 0
        THEN
            BEGIN
            p08puttracename (sqlca, sqlxa, nam, -1, true);
            nam  := 'EXEC      STOP    ';
            p08puttracename (sqlca, sqlxa, nam, mxsp_name, true);
            p01xvfclosetrace (sqlca);
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  sqlrap^.rasqlinit <> cpr_is_false
    THEN
        sqlfinish (false);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01ma2bi  (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            ma_no   : tsp00_Int2;
            ma_len   : tsp00_Int2;
            VAR val   : tpr_macroline);
 
VAR
      ma_val   : tpr_macroline;
      error    : tpr_runtime_errors;
      vptr      : tpr_vtypepointer;
      iptr      : tpr_vtypepointer;
      va1ind   : integer;
      indind   : integer;
      paix     : integer;
      cnt      : integer;
 
BEGIN
WITH sqlca, sqlxa, sqlmap^, maentry [ma_no ] DO
    BEGIN
    ma_val := val;
    IF   maversion >= csp_maxint4 - 2
    THEN
        maversion := cpr_minint4 + 1
    ELSE
        maversion := maversion + 1;
    (*ENDIF*) 
    malen  := ma_len;
    error  := cpr_p_ok;
    SAPDB_PascalForcedFill (mxpr_macroline, @maval, 1, mxpr_macroline, bsp_c1);
    IF   malen > 0
    THEN
        s10mv (mxpr_macroline, mxpr_macroline, @ma_val, 1,
              @maval, 1, malen)
    ELSE
        BEGIN
        paix := -ma_len;
        p03getparameteraddr (sqlca, sqlxa, paix (* paindex *),
              cnt, vptr, va1ind,
              iptr, indind );
        IF  vptr.intaddr = 0
        THEN
            (*  pointer *)
            error :=  cpr_missing_variable_addr;
        (*ENDIF*) 
        IF  error <> cpr_p_ok
        THEN
            p08runtimeerror (sqlca, sqlxa, error)
        ELSE
            WITH  sqlv1p^[ va1ind], sqlv2p^ [va1indva2_sc] DO
                BEGIN
                (* get value from parameter *)
                IF   va2typ = cpr_vcharc
                THEN
                    IF  va2size > 0
                    THEN
                        malen := s30len1 (vptr.vtypep^, chr(0), va2size)
                    ELSE
                        malen := s30len1 (vptr.vtypep^, chr(0), mxpr_macroline)
                    (*ENDIF*) 
                ELSE
                    malen := s30lnr (vptr.vtypep^, bsp_c1, 1, va2size);
                (*ENDIF*) 
                IF   malen > mxpr_macroline
                THEN
                    malen := mxpr_macroline;
                (*ENDIF*) 
                s10mv (mxpr_macroline, mxpr_macroline, @vptr.vtypep^, 1,
                      @maval, 1, malen);
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01oradescribe  (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR gae : sqlgaentry);
 
VAR
      nam : tsp00_Name;
      part_ptr : tsp1_part_ptr;
      ptr  : tsp1_packet_ptr;
 
BEGIN
WITH sqlca, sqlxa, sqlrap^, sqlkap^ [xakano] , sqlprp^ [kaprindex ],
     sqlgap^ DO
    BEGIN
    ptr := gae.gareqptr;
    s26new_part_init (ptr, rasegptr^, part_ptr);
    part_ptr^.sp1p_part_header.sp1p_part_kind :=  sp1pk_command;
    part_ptr^.sp1p_part_header.sp1p_buf_len   :=  0;
    rasegmpartptr [ord(sp1pk_command)+1] := part_ptr;
    WITH part_ptr^, sp1p_part_header  DO
        BEGIN
        (* oracle : describe select list for  ... kommando *)
        nam := 'FETCH             ';
        s10mv (mxsp_name, sp1p_buf_size, @nam, 1,
              @sp1p_buf, 1, mxsp_name);
        sp1p_buf_len := mxsp_c8;
        IF  (prstate = cpr_state_command)
            AND (kaParseInfo.ParseId = cpr_parsidnull)
        THEN
            BEGIN
            s10mv (sizeof(prStmtName), sp1p_buf_size, @prStmtName, 1,
                  @sp1p_buf, sp1p_buf_len+1, sizeof(prStmtName));
            sp1p_buf_len := sp1p_buf_len + sizeof(prStmtName);
            END;
        (*ENDIF*) 
        nam := ' USING DESCRIPTOR ';
        s10mv (mxsp_name, sp1p_buf_size, @nam, 1,
              @sp1p_buf, sp1p_buf_len+1, mxsp_name);
        sp1p_buf_len := sp1p_buf_len + 1 + mxsp_name;
        sp1p_buf [ sp1p_buf_len ] := bsp_c1;
        END;
    (*ENDWITH*) 
    s26finish_part (ptr, part_ptr^);
    END;
(*ENDWITH*) 
&ifdef TRACE
m90name(xx, 'END p01oradescribe');
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01dynmfetch (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            kae : sqlkaentry_ptr);
 
VAR
      part_ptr : tsp1_part_ptr;
 
BEGIN
IF  kae^.kapaindex < 0
THEN
    WITH  sqlxa.sqlpap^ [-kae^.kapaindex] DO
        BEGIN
        IF  pakindlo = sqlparlo
        THEN
            BEGIN
            IF  pava1index <> 0
            THEN
                WITH sqlxa.sqlv1p^ [pava1index], sqlxa.sqlv2p^ [va1indva2_sc] DO
                    BEGIN
                    IF  va2typ = cpr_vint2
                    THEN
                        sqlca.sqlcxap^.xasqldap.oradaptr^.sqlloop :=
                              va1addr_sc.vtypep^.i2 ;
                    (*ENDIF*) 
                    IF  va2typ = cpr_vint4
                    THEN
                        sqlca.sqlcxap^.xasqldap.oradaptr^.sqlloop :=
                              va1addr_sc.vtypep^.i4 ;
                    (*ENDIF*) 
                    END
                (*ENDWITH*) 
            ELSE
                sqlca.sqlcxap^.xasqldap.oradaptr^.sqlloop := paloopmin;
            (*ENDIF*) 
            END
        ELSE
            pr01TraceRuntimeError (sqlca, sqlxa, cpr_r_loop_init_wrong);
        (*ENDIF*) 
        p03find_part (sqlca.sqlrap, sp1pk_command, part_ptr);
        IF  part_ptr <> NIL
        THEN
            sqlca.sqlrap^.rasegptr^.sp1c_mass_cmd := true;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01colinitsfinfo (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            kae : sqlkaentry_ptr;
            VAR ore : sqlorentry);
 
VAR
      i    : integer;
      pos  : integer;
 
BEGIN
(* belege sqlda mit sfinfo aus orcolpointer *)
WITH sqlca, sqlrap^, sqlxa DO
    IF  sqlcxap^.xasqldap.sqldaptr <> NIL
    THEN
        BEGIN
        (* count *)
&       ifdef TRACE
        m90int2 (pc, 'xakano      ', xakano      );
        m90int4 (pc, 'orcolcntacc ', ore.orcolcntacc );
        m90int4 (pc, 'orcolcnt    ', ore.orcolcnt );
        m90int4 (pc, 'orcollen    ', ore.orcollen  );
        m90int4 (pc, 'ireclen     ', ore.orsqlrow.ireclen );
        m90int4 (pc, 'oreclen     ', ore.orsqlrow.oreclen );
        m90int4 (pc, 'orcolptr    ', ore.orcolptr.intaddr );
&       endif
        (* gesammt length *)
        CASE sqldbmode OF
            cpr_kind_db2 :
                WITH sqlcxap^.xasqldap.db2daptr^ DO
                    BEGIN
                    sqld :=  ore.orcolcntacc;
                    p01pparsidtrace (sqlca, sqlxa, kae,
                          kae^.kaParseInfo.ParseId, TraceParseIDOther_epr00);
                    END;
                (*ENDWITH*) 
            cpr_kind_oracle ,  cpr_kind_sapr3 :
                WITH sqlcxap^.xasqldap.oradaptr^ DO
                    BEGIN
                    ora_f := ore.orcolcntacc;
                    p01pparsidtrace (sqlca, sqlxa, kae,
                          kae^.kaParseInfo.ParseId, TraceParseIDOther_epr00);
                    END;
                (*ENDWITH*) 
            OTHERWISE:
                BEGIN
                (**   cpr_kind_internal  **)
                WITH sqlcxap^.xasqldap.sqldaptr^ DO
                    BEGIN
                    sqln :=  ore.orcolcntacc;
                    p01pparsidtrace (sqlca, sqlxa, kae,
                          kae^.kaParseInfo.ParseId, TraceParseIDOther_epr00);
                    END;
                (*ENDWITH*) 
                END;
            END;
        (*ENDCASE*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01resinitsfinfo (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            kae : sqlkaentry_ptr;
            VAR ore : sqlorentry;
            VAR prepars : boolean);
 
VAR
      i    : integer;
      pos  : integer;
 
BEGIN
(* belege sqlda mit sfinfo aus orcolpointer *)
WITH sqlca, sqlrap^, sqlxa DO
    IF  (sqlcxap^.xasqldap.sqldaptr <> NIL)
        AND (ore.orrescntacc > 0)
    THEN
        BEGIN
        (* count *)
&       ifdef TRACE
        m90int2 (pc, 'xakano  res ', xakano      );
&       endif
        (* gesammt length *)
        CASE sqldbmode OF
            cpr_kind_db2 :
                WITH sqlcxap^.xasqldap.db2daptr^ DO
                    BEGIN
                    sqld :=  ore.orrescntacc;
                    END;
                (*ENDWITH*) 
            cpr_kind_oracle ,  cpr_kind_sapr3 :
                WITH sqlcxap^.xasqldap.oradaptr^ DO
                    BEGIN
                    ora_f := ore.orrescntacc;
                    END;
                (*ENDWITH*) 
            OTHERWISE:
                BEGIN
                (**   cpr_kind_internal  **)
                WITH sqlcxap^.xasqldap.sqldaptr^ DO
                    BEGIN
                    sqln :=  ore.orrescntacc;
                    END;
                (*ENDWITH*) 
                END;
            END;
        (*ENDCASE*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01colmovesfinfo (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            kae : sqlkaentry_ptr;
            VAR ore : sqlorentry);
 
VAR
      i    : integer;
      pos  : integer;
 
BEGIN
(* belege sqlda mit sfinfo aus orcolpointer *)
WITH sqlca, sqlrap^, sqlxa DO
    IF  sqlcxap^.xasqldap.sqldaptr <> NIL
    THEN
        BEGIN
&       ifdef TRACE
        m90int2 (pc, 'xakano      ', xakano      );
        m90int4 (pc, 'orcolcntacc ', ore.orcolcntacc );
        m90int4 (pc, 'orcolcnt    ', ore.orcolcnt );
        m90int4 (pc, 'orcollen    ', ore.orcollen  );
        m90int4 (pc, 'ireclen     ', ore.orsqlrow.ireclen );
        m90int4 (pc, 'oreclen     ', ore.orsqlrow.oreclen );
        m90int4 (pc, 'orcolptr    ', ore.orcolptr.intaddr );
&       endif
        (* gesammt length *)
        CASE sqldbmode OF
            cpr_kind_db2 :
                WITH sqlcxap^.xasqldap.db2daptr^ DO
                    BEGIN
                    IF  ore.orcolcntacc <> sqld
                    THEN
                        BEGIN
                        IF  ore.orcolcntacc < sqld
                        THEN
                            pr01TraceRuntimeError (sqlca, sqlxa,
                                  cpr_too_many_hostvar)
                        ELSE
                            IF  ore.orcolcntacc > sqld
                            THEN
                                pr01TraceRuntimeError (sqlca, sqlxa,
                                      cpr_output_part_too_short);
                            (*ENDIF*) 
                        (*ENDIF*) 
                        p01pparsidtrace (sqlca, sqlxa, kae,
                              kae^.kaParseInfo.ParseId, TraceParseIDSQLStmt_epr00);
                        END;
                    (*ENDIF*) 
                    sqlrow := ore.orsqlrow;
                    pos := 1;
                    FOR i := 1  TO ore.orcolcntacc DO
                        WITH sqlvardb2 [i] DO
                            BEGIN
                            s10mv (ore.orcollen, ore.orcollen,
                                  @ore.orcolptr.sqlcolp^[1], pos,
                                  @sqlcoldb, 1,
                                  sizeof (sqlcoldb));
                            pos := pos + sizeof (sqlcoldb);
                            END;
                        (*ENDWITH*) 
                    (*ENDFOR*) 
                    END;
                (*ENDWITH*) 
            cpr_kind_oracle ,  cpr_kind_sapr3 :
                WITH sqlcxap^.xasqldap.oradaptr^ DO
                    BEGIN
                    IF  ore.orcolcntacc <> ora_f
                    THEN
                        BEGIN
                        IF  ore.orcolcntacc < ora_f
                        THEN
                            pr01TraceRuntimeError (sqlca, sqlxa,
                                  cpr_too_many_hostvar)
                        ELSE
                            IF  ore.orcolcntacc > ora_f
                            THEN
                                pr01TraceRuntimeError (sqlca, sqlxa,
                                      cpr_output_part_too_short);
                            (*ENDIF*) 
                        (*ENDIF*) 
                        p01pparsidtrace (sqlca, sqlxa, kae,
                              kae^.kaParseInfo.ParseId, TraceParseIDSQLStmt_epr00);
                        END;
                    (*ENDIF*) 
                    sqlrow := ore.orsqlrow;
                    sqlcoldb.intaddr := ore.orcolptr.intaddr;
                    END;
                (*ENDWITH*) 
            OTHERWISE:
                BEGIN
                (**   cpr_kind_internal  **)
                WITH sqlcxap^.xasqldap.sqldaptr^ DO
                    BEGIN
                    IF  ore.orcolcntacc <> sqln
                    THEN
                        BEGIN
                        IF  ore.orcolcntacc < sqln
                        THEN
                            pr01TraceRuntimeError (sqlca, sqlxa,
                                  cpr_too_many_hostvar)
                        ELSE
                            IF  ore.orcolcntacc > sqln
                            THEN
                                pr01TraceRuntimeError (sqlca, sqlxa,
                                      cpr_output_part_too_short);
                            (*ENDIF*) 
                        (*ENDIF*) 
                        p01pparsidtrace (sqlca, sqlxa, kae,
                              kae^.kaParseInfo.ParseId, TraceParseIDSQLStmt_epr00);
                        END;
                    (*ENDIF*) 
                    sqlrow := ore.orsqlrow;
                    pos := 1;
                    FOR i := 1  TO ore.orcolcntacc DO
                        WITH sqlvar [i] DO
                            BEGIN
                            s10mv (ore.orcollen, ore.orcollen,
                                  @ore.orcolptr.sqlcolp^[1], pos,
                                  @sqlcoldb, 1, sizeof (sqlcoldb));
                            pos := pos + sizeof (sqlcoldb);
                            END;
                        (*ENDWITH*) 
                    (*ENDFOR*) 
                    END;
                (*ENDWITH*) 
                END;
            END;
        (*ENDCASE*) 
        IF  kae^.kafaindex > 0
        THEN
            kae^.kafae^.fareclen := ore.orsqlrow.oreclen;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01resmovesfinfo (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            kae : sqlkaentry_ptr;
            VAR ore : sqlorentry;
            VAR prepars : boolean);
 
VAR
      i    : integer;
      pos  : integer;
      len  : integer;
      namel: integer;
 
BEGIN
(* belege sqlda mit sfinfo aus orcolpointer *)
WITH sqlca, sqlrap^, sqlxa DO
    IF  ore.orrescntacc = 0
    THEN
        prepars := false
    ELSE
        IF  sqlcxap^.xasqldap.sqldaptr <> NIL
        THEN
            BEGIN
&           ifdef TRACE
            m90int2 (pc, 'xakano      ', xakano      );
            m90int4 (pc, 'orrescntacc ', ore.orrescntacc );
            m90int4 (pc, 'orrescnt    ', ore.orrescnt );
            m90int4 (pc, 'orreslen    ', ore.orreslen  );
            m90int4 (pc, 'ireclen     ', ore.orsqlrow.ireclen );
            m90int4 (pc, 'oreclen     ', ore.orsqlrow.oreclen );
            m90int4 (pc, 'orresptr    ', ore.orresptr.intaddr );
&           endif
            (* gesammt length *)
            CASE sqldbmode OF
                cpr_kind_db2 :
                    WITH sqlcxap^.xasqldap.db2daptr^ DO
                        BEGIN
                        IF  ore.orrescntacc <> sqld
                        THEN
                            BEGIN
                            IF  ore.orrescntacc < sqld
                            THEN
                                pr01TraceRuntimeError (sqlca, sqlxa,
                                      cpr_too_many_hostvar)
                            ELSE
                                IF  ore.orrescntacc > sqld
                                THEN
                                    pr01TraceRuntimeError (sqlca, sqlxa,
                                          cpr_output_part_too_short);
                                (*ENDIF*) 
                            (*ENDIF*) 
                            p01pparsidtrace (sqlca, sqlxa, kae,
                                  kae^.kaParseInfo.ParseId, TraceParseIDSQLStmt_epr00);
                            END;
                        (*ENDIF*) 
                        sqlrow := ore.orressqlrow;
                        pos := 1;
                        FOR i := 1  TO ore.orrescntacc DO
                            WITH sqlvardb2 [i] DO
                                BEGIN
                                s10mv (ore.orreslen, ore.orreslen,
                                      @ore.orresptr.sqlcolp^[1], pos,
                                      @sqlcoldb, 1,
                                      sizeof (sqlcoldb));
                                pos := pos + sizeof (sqlcoldb);
                                END;
                            (*ENDWITH*) 
                        (*ENDFOR*) 
                        END;
                    (*ENDWITH*) 
                cpr_kind_oracle ,  cpr_kind_sapr3 :
                    WITH sqlcxap^.xasqldap.oradaptr^ DO
                        BEGIN
                        IF  ore.orrescntacc <> ora_f
                        THEN
                            BEGIN
                            IF  ore.orrescntacc < ora_f
                            THEN
                                pr01TraceRuntimeError (sqlca, sqlxa,
                                      cpr_too_many_hostvar)
                            ELSE
                                IF  ore.orrescntacc > ora_f
                                THEN
                                    pr01TraceRuntimeError (sqlca, sqlxa,
                                          cpr_output_part_too_short);
                                (*ENDIF*) 
                            (*ENDIF*) 
                            p01pparsidtrace (sqlca, sqlxa, kae,
                                  kae^.kaParseInfo.ParseId, TraceParseIDSQLStmt_epr00);
                            END;
                        (*ENDIF*) 
                        sqlrow := ore.orressqlrow;
                        sqlcoldb.intaddr := ore.orresptr.intaddr;
                        END;
                    (*ENDWITH*) 
                OTHERWISE:
                    BEGIN
                    (**   cpr_kind_internal  **)
                    WITH sqlcxap^.xasqldap.sqldaptr^ DO
                        BEGIN
                        IF  ore.orrescntacc <> sqln
                        THEN
                            BEGIN
                            IF  ore.orrescntacc < sqln
                            THEN
                                pr01TraceRuntimeError (sqlca, sqlxa,
                                      cpr_too_many_hostvar)
                            ELSE
                                IF  ore.orrescntacc > sqln
                                THEN
                                    pr01TraceRuntimeError (sqlca, sqlxa,
                                          cpr_output_part_too_short);
                                (*ENDIF*) 
                            (*ENDIF*) 
                            p01pparsidtrace (sqlca, sqlxa, kae,
                                  kae^.kaParseInfo.ParseId, TraceParseIDSQLStmt_epr00);
                            END;
                        (*ENDIF*) 
                        sqlrow := ore.orressqlrow;
                        pos := 1;
                        FOR i := 1  TO ore.orrescntacc DO
                            WITH sqlvar [i] DO
                                BEGIN
                                s10mv (ore.orreslen, ore.orreslen,
                                      @ore.orresptr.sqlcolp^[1], pos,
                                      @sqlcoldb, 1, sizeof (sqlcoldb));
                                pos := pos + sizeof (sqlcoldb);
                                END;
                            (*ENDWITH*) 
                        (*ENDFOR*) 
                        END;
                    (*ENDWITH*) 
                    END;
                END;
            (*ENDCASE*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01nammovesfinfo (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            kae : sqlkaentry_ptr;
            VAR ore : sqlorentry;
            getkatyp  : tpr00_ComTypeEnum);
 
VAR
      i    : integer;
      pos  : integer;
      len  : integer;
      namel: integer;
      nam  : tsp00_KnlIdentifier;
      ch12 : tsp00_C12;
      coldb: tpr_sqlcol;
      colcnt : tsp00_Int4;
      collen : tsp00_Int4;
      colptr : tpr_sqlcolpointer;
      sqlrow_col   : tpr_sqlrow;    (* reclen info's after parsen *)
      getresnames  : boolean;
 
BEGIN
(* belege sqlda mit sfinfo aus orcolpointer *)
WITH sqlca, sqlrap^, sqlxa DO
    BEGIN
    IF  (getkatyp = cpr_com_ora_descr_sel)
        OR  (getkatyp = cpr_com_sql_fetch)
        OR  (getkatyp = cpr_com_mfetch)   (*24.3.97*)
    THEN
        BEGIN
        getresnames := true;
        colcnt := ore.orrescntacc;
        colptr := ore.orresptr;
        collen := ore.orreslen;
        sqlrow_col := ore.orressqlrow;
        END
    ELSE
        BEGIN
        getresnames := false;
        colcnt := ore.orcolcntacc;
        colptr := ore.orcolptr;
        collen := ore.orcollen;
        sqlrow_col := ore.orsqlrow;
        END;
    (*ENDIF*) 
    IF  colcnt <> 0
    THEN
        IF  sqlcxap^.xasqldap.sqldaptr <> NIL
        THEN
            BEGIN
            (* count *)
&           ifdef TRACE
            m90int2 (pc, 'xakano  name', xakano      );
&           endif
            (* gesammt length *)
            CASE sqldbmode OF
                cpr_kind_db2 :
                    WITH sqlcxap^.xasqldap.db2daptr^ DO
                        BEGIN
                        (* sqlda belegen **)
                        pos := 1;
                        FOR i := 1  TO colcnt DO
                            BEGIN
                            s10mv (collen, collen,
                                  @colptr.sqlcolp^[1], pos,
                                  @coldb, 1, sizeof (coldb));
                            IF  (getkatyp <> cpr_com_sql_fetch)
                                (*24.3.97*)
                                AND (getkatyp <> cpr_com_mfetch)
                            THEN
                                p04sftodb2 (sqlca, sqlxa, sqlvardb2 [i],
                                      ore.orsqlrow, NIL, chr(0) );
                            (*ENDIF*) 
                            pos := pos + sizeof (tpr_sqlcol);
                            END;
                        (*ENDFOR*) 
                        sqlrow := sqlrow_col;
                        IF  (ore.orresnamacc <> 0)
                            AND (getresnames)
                        THEN
                            BEGIN
                            pos := 1;
                            i   := 1;
                            WHILE (pos <  ore.orresnamacc) DO
                                WITH sqlvardb2 [i] DO
                                    BEGIN
                                    len := ord ( ore.orresnamptr
                                          .vtypep^.buf[pos]);
                                    IF  len > mxsp_c30
                                    THEN
                                        sqlnamel := mxsp_c30
                                    ELSE
                                        sqlnamel := len;
                                    (*ENDIF*) 
                                    s10mv (ore.orresnamlen, ore.orresnamlen,
                                          @ore.orresnamptr.vtypep^.buf, pos+1,
                                          @sqlname, 1, sqlnamel);
                                    pos := pos + len + 1;
                                    i := i + 1;
                                    END;
                                (*ENDWITH*) 
                            (*ENDWHILE*) 
                            END
                        ELSE
                            FOR i := 1  TO colcnt DO
                                WITH sqlvardb2 [i] DO
                                    BEGIN
                                    sqlname :=
                                          'COLUMN                        ';
                                    p05inttochr12 (i, ch12);
                                    s10mv (mxsp_c12, mxsp_name, @ch12, 2,
                                          @sqlname, 7, 4);
                                    END
                                (*ENDWITH*) 
                            (*ENDFOR*) 
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                cpr_kind_oracle ,  cpr_kind_sapr3 :
                    WITH sqlcxap^.xasqldap.oradaptr^ DO
                        BEGIN
                        (* sqlda belegen **)
                        pos := 1;
                        sqlrow := sqlrow_col;
                        FOR i := 1  TO colcnt DO
                            BEGIN
                            s10mv (collen, collen,
                                  @colptr.sqlcolp^[1], pos,
                                  @coldb, 1, sizeof (coldb));
                            IF  (getkatyp <> cpr_com_sql_fetch)
                                (*24.3.97*)
                                AND (getkatyp <> cpr_com_mfetch)
                            THEN
                                p04sftoora (ore.orsqlrow, coldb,
                                      NIL, ora_l^[i], ora_t^[i]);
                            (*ENDIF*) 
                            pos := pos + sizeof (tpr_sqlcol);
                            END;
                        (*ENDFOR*) 
                        IF  ora_s <> NIL
                        THEN
                            BEGIN
&                           ifdef TRACE
                            m90int4 (pc, 'orresnamacc ', ore.orresnamacc );
&                           endif
                            IF  (ore.orresnamacc <> 0)
                                AND (getresnames)
                            THEN
                                BEGIN
                                pos := 1;
                                i   := 1;
                                WHILE (pos <  ore.orresnamacc) DO
                                    BEGIN
                                    len := ord ( ore.orresnamptr
                                          .vtypep^.buf[pos]);
                                    SAPDB_PascalForcedFill (ora_m^[i],
                                          @ora_s^[i].vtypep^.buf, 1,
                                          ora_m^[i], bsp_c1);
                                    IF  len > ora_m^[i]
                                    THEN
                                        ora_c^[i] := ora_m^[i]
                                    ELSE
                                        ora_c^[i] := len;
                                    (*ENDIF*) 
                                    s10mv (ore.orresnamlen, ore.orresnamlen,
                                          @ore.orresnamptr.vtypep^.buf, pos+1,
                                          @ora_s^[i].vtypep^.buf, 1,
                                          ora_c^[i]);
                                    (*    ora_s^[i].vtypep^.buf[ora_c^[i]]
                                          := chr(0);  *)
                                    pos := pos + len + 1;
                                    i := i + 1;
                                    END;
                                (*ENDWHILE*) 
                                END
                            ELSE
                                FOR i := 1  TO colcnt DO
                                    BEGIN
                                    nam :=
                                          'COLUMN                                                          ';
                                    p05inttochr12 (i, ch12);
                                    s10mv (mxsp_c12, sizeof (nam), @ch12, 2,
                                          @nam, 7, 4);
                                    len := 10;
                                    SAPDB_PascalForcedFill (ora_m^[i],
                                          @ora_s^[i].vtypep^.buf, 1,
                                          ora_m^[i], bsp_c1);
                                    IF  len > ora_m^[i]
                                    THEN
                                        ora_c^[i] := ora_m^[i]
                                    ELSE
                                        ora_c^[i] := len;
                                    (*ENDIF*) 
                                    s10mv (sizeof(nam), sizeof(nam),
                                          @nam, 1,
                                          @ora_s^[i].vtypep^.buf, 1,
                                          ora_c^[i]);
                                    END
                                (*ENDFOR*) 
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                OTHERWISE:
                    BEGIN
                    (**   cpr_kind_internal  **)
                    WITH sqlcxap^.xasqldap.sqldaptr^ DO
                        BEGIN
                        pos := 1;
                        sqlrow := sqlrow_col;
                        FOR i := 1  TO colcnt DO
                            WITH sqlvar [i] DO
                                BEGIN
                                s10mv (collen, collen,
                                      @colptr.sqlcolp^[1], pos,
                                      @sqlcoldb, 1, sizeof (tpr_sqlcol));
                                IF  (getkatyp <> cpr_com_sql_fetch)
                                    (*24.3.97*)
                                    AND (getkatyp <> cpr_com_mfetch)
                                THEN
                                    p04sftosql (sqlvar [i], ore.orsqlrow,
                                          NIL, chr(0) );
                                (*ENDIF*) 
                                pos := pos + sizeof (tpr_sqlcol);
                                END;
                            (*ENDWITH*) 
                        (*ENDFOR*) 
                        IF  (ore.orresnamacc <> 0)
                            AND (getresnames)
                        THEN
                            BEGIN
                            pos := 1;
                            i   := 1;
                            WHILE (pos <  ore.orresnamacc) DO
                                WITH sqlvar [i] DO
                                    BEGIN
                                    len := ord(ore.orresnamptr
                                          .vtypep^.buf[pos]);
                                    IF  len > sizeof(colname)
                                    THEN
                                        namel := sizeof(colname)
                                    ELSE
                                        namel := len;
                                    (*ENDIF*) 
                                    s10mv (ore.orresnamlen, ore.orresnamlen,
                                          @ore.orresnamptr.vtypep^.buf, pos+1,
                                          @colname, 1, namel);
                                    pos := pos + len + 1;
                                    i := i + 1;
                                    END;
                                (*ENDWITH*) 
                            (*ENDWHILE*) 
                            END
                        ELSE
                            FOR i := 1  TO colcnt DO
                                WITH sqlvar [i] DO
                                    BEGIN
                                    colname :=
                                          'COLUMN                                                          ';
                                    p05inttochr12 (i, ch12);
                                    s10mv (mxsp_c12, sizeof (colname), @ch12, 2,
                                          @colname, 7, 4);
                                    END
                                (*ENDWITH*) 
                            (*ENDFOR*) 
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                    END;
                END;
            (*ENDCASE*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      p01prepare (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR gae : sqlgaentry;
            kae : sqlkaentry_ptr;
            VAR pre : sqlprentry;
            VAR ore : sqlorentry;
            datafound:boolean)  : boolean;
 
VAR
      funct, prepars : boolean;
 
BEGIN
funct := false;
IF  NOT datafound
THEN
    WITH sqlca, sqlxa DO
        BEGIN
        IF  kae^.kapacount < 0
        THEN
            IF  (kae^.kastate = cpr_state_parse)
            THEN
                BEGIN
                (* fetch found, move sfinfos into sqlda_orada  *)
                IF   datafound
                THEN
                    BEGIN
                    p01resinitsfinfo (sqlca, sqlxa, kae, ore, prepars);
                    p01resmovesfinfo (sqlca, sqlxa, kae, ore, prepars);
                    END
                ELSE
                    BEGIN
                    p04GetSFInfo(sqlca, sqlxa, kae, ore);
                    p01colinitsfinfo(sqlca, sqlxa, kae, ore);
                    p01colmovesfinfo(sqlca, sqlxa, kae, ore);
                    END;
                (*ENDIF*) 
                IF  kae^.kapacount = -3
                THEN (***24.11.94 ****)
                    kae^.kapacount := -1;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
p01prepare := funct;
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01formatparsid(VAR parsid : tpr_parsid;
            VAR tastr80 : tsp00_C256; VAR tastr80l : tsp00_Int2);
 
VAR
      i       : integer;
      err     : boolean;
 
BEGIN
FOR i := 0 TO 3 DO
    BEGIN
    s40gbyte (parsid, (i*4)+1, 4, tastr80, tastr80l+1,
          mxpr_parsid+mxpr_parsid,err);
    tastr80l := tastr80l + 9;
    tastr80[tastr80l] := ' ';
    END;
(*ENDFOR*) 
(* remove last pending space *)
tastr80l := tastr80l-1;
END; { p01formatparsid }
 
(*------------------------------*) 
 
PROCEDURE
      p01pparsidtrace (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            kae    : sqlkaentry_ptr;
            VAR parsid : tpr_parsid;
            inout : tpr00_TraceParseID_Enum);
 
VAR
      knlid   : tsp00_KnlIdentifier;
      nam     : tsp00_Name;
      err     : boolean;
      lno     : integer;
      chr12   : tsp00_C12;
      i       : integer;
      found   : boolean;
      modlno  : integer;
 
BEGIN
modlno := 0;
WITH sqlca, sqlxa, sqlrap^, rasqltap^   DO
    IF   (tatrout <> cpr_trace_off)
    THEN
        IF  (inout = TraceParseIDSQLStmt_epr00)
            OR  (inout = TraceParseIDUseExecute_epr00)
            OR (ord (parsid [cpr_p_precom_index] ) <> csp1_p_command_executed)
            AND  (ord (parsid [cpr_p_precom_index] ) <>  csp1_p_use_adbs)
        THEN
            BEGIN
            (* ausgabe art = komando again  *)
            SAPDB_PascalForcedFill (mxsp_c256, @tastr80, 1, mxsp_c256, bsp_c1);
            CASE inout OF
                TraceParseIDInput_epr00 :
                    nam := 'PARSEID: INPUT :  ';
                TraceParseIDFromCache_epr00:
                    nam := 'PARSEID: OUTPUT:  ';
                TraceParseIDOutput_epr00 :
                    BEGIN
                    nam := 'PARSEID: OUTPUT:  ';
                    IF  sqloap^.oamaxsec <> 0
                    THEN
                        BEGIN
                        WITH rasqltap^  DO
                            tamaxsecoutp := cpr_is_true;
                        (*ENDWITH*) 
                        END;
                    (*ENDIF*) 
                    END;
                TraceParseIDChange_epr00 :
                    BEGIN
                    nam := 'CHANGE PARSEID :  ';
                    p08puttracename (sqlca, sqlxa, nam, -1, true);
                    p08puttracename (sqlca, sqlxa, nam, mxsp_name, true);
                    nam := 'PARSEID: OLD   :  ';
                    END;
                TraceParseIDNew_epr00 :
                    BEGIN
                    nam := 'PARSEID: NEW   :  ';
                    IF  sqloap^.oamaxsec <> 0
                    THEN
                        BEGIN
                        WITH rasqltap^ DO
                            tamaxsecoutp := cpr_is_true;
                        (*ENDWITH*) 
                        END;
                    (*ENDIF*) 
                    END;
                TraceParseIDSQLStmt_epr00 :
                    nam := 'SQL STATEMENT  :  ';
                TraceParseIDSQLStmtBlank_epr00 :
                    BEGIN
                    p08puttracename (sqlca, sqlxa, nam, -1, true);
                    nam := 'SQL STATEMENT  :  ';
                    END;
                TraceParseIDUseExecute_epr00 :
                    nam := 'USE "EXECUTE IMMED';
                TraceParseIDFetch_epr00 :
                    BEGIN
                    p08puttracename (sqlca, sqlxa, nam, -1, true);
                    nam := 'FETCH STATEMENT:  ';
                    END;
                TraceParseIDBlank_epr00 :
                    nam := '               :  ';
                TraceParseIDAgain_epr00 :
                    BEGIN
                    nam := 'PARSE AGAIN    :  ';
                    END;
                TraceParseIDDrop_epr00 :
                    BEGIN
                    p08puttracename (sqlca, sqlxa, nam, -1, true);
                    nam := 'PARSEID: DROP  :  ';
                    END;
                TraceParseIDVersion_epr00 :
                    BEGIN
                    p08puttracename (sqlca, sqlxa, nam, -1, true);
                    nam := 'version  :P_1, P_2';
                    p08puttracename (sqlca, sqlxa, nam, mxsp_name, true);
                    nam := 'SQL STATEMENT  :  ';
                    END;
                TraceParseIDSelect_epr00 :
                    nam := 'PARSEID: SELECT:  ';
                TraceParseIDSQLStmtMass_epr00 :
                    BEGIN
                    nam := 'MASS STATEMENT :  ';
                    p08puttracename (sqlca, sqlxa, nam, 18, true);
                    nam := 'SQL STATEMENT  :  ';
                    END
                OTHERWISE:
                    nam := 'PARSEID:       :  ';
                END;
            (*ENDCASE*) 
            p08puttracename (sqlca, sqlxa, nam, mxsp_name, false);
            IF  (inout =  TraceParseIDUseExecute_epr00)
            THEN
                BEGIN
                nam := 'IATE"  ****       ';
                p08puttracename (sqlca, sqlxa, nam, mxsp_name, true);
                END
            ELSE
                IF  (inout =  TraceParseIDSQLStmt_epr00)
                    OR (inout = TraceParseIDSQLStmtBlank_epr00)
                    OR (inout = TraceParseIDFetch_epr00)
                    OR (inout = TraceParseIDBlank_epr00)
                    OR (inout = TraceParseIDVersion_epr00)
                    OR (inout = TraceParseIDSQLStmtMass_epr00)
                THEN
                    BEGIN
                    IF  kae <> NIL
                    THEN
                        WITH  kae^ DO
                            BEGIN
                            modlno := kalineno;
                            lno    := kalineno;
                            IF  modlno < 0
                            THEN
                                BEGIN
                                nam := 'INCLUDE FILE:     ';
                                p08puttracename (sqlca, sqlxa, nam, 14, false);
                                i := 1;
                                found := false;
                                lno   := -kalineno;
                                REPEAT
                                    WITH sqlfnp^ [i] DO
                                        BEGIN
                                        IF  (fnkanomin <= xakano)
                                            AND (xakano <= fnkanomax)
                                        THEN
                                            BEGIN
                                            knlid := fnfilen;
                                            modlno:= fnincllno;
                                            found := true;
                                            END;
                                        (*ENDIF*) 
                                        i := i + 1;
                                        END;
                                    (*ENDWITH*) 
                                UNTIL
                                    (found);
                                (*ENDREPEAT*) 
                                p08puttraceknlid (sqlca, sqlxa, knlid,
                                      sizeof(knlid), false);
                                nam := ' AT LINE :        ';
                                p08puttracename (sqlca, sqlxa, nam, 11, false);
                                p05inttochr12 (lno, chr12);
                                s10mv (mxsp_c12, mxsp_c256, @chr12, 2,
                                      @tastr80, tastr80l+1, 5 );
                                tastr80l := tastr80l + 5;
                                p08puttracename (sqlca, sqlxa, nam, 0, true);
                                SAPDB_PascalForcedFill (mxsp_c256, @tastr80, 1, mxsp_c256, bsp_c1);
                                tastr80l := mxsp_name;
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    nam := 'FROM MODULE :     ';
                    p08puttracename (sqlca, sqlxa, nam, 14, false);
                    p08puttraceknlid (sqlca, sqlxa, xamodn,
                          sizeof(xamodn), false);
                    IF  modlno <> 0
                    THEN
                        BEGIN
                        nam := ' AT LINE :        ';
                        p08puttracename (sqlca, sqlxa, nam, 11, false);
                        p05inttochr12 (modlno, chr12);
                        s10mv (mxsp_c12, mxsp_c256, @chr12, 2,
                              @tastr80, tastr80l+1, 5 );
                        tastr80l := tastr80l + 5;
                        END;
                    (*ENDIF*) 
                    p08vfwritetrace (sqlca.sqlrap);
                    IF  @xaSQLDesc^ <> NIL
                    THEN
                        IF  xaSQLDesc^.StmtNameDesc <> NIL
                        THEN
                            pr01cTraceStmtName(xaSQLDesc^.StmtNameDesc, sqlca);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    p01formatparsid(parsid, tastr80, tastr80l);
                    IF  (inout = TraceParseIDFromCache_epr00)
                    THEN
                        BEGIN
                        nam := ' USE PARSE INFOS F';
                        p08puttracename (sqlca, sqlxa, nam, 18, false);
                        nam := 'ROM PI-CACHE      ';
                        p08puttracename (sqlca, sqlxa, nam, 12, false);
                        END;
                    (*ENDIF*) 
                    p08vfwritetrace (sqlca.sqlrap);
                    IF  inout = TraceParseIDNew_epr00
                    THEN
                        BEGIN
                        p08puttracename (sqlca, sqlxa, nam, -1, true);
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01resallocinfo (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            kae : sqlkaentry_ptr;
            VAR ore : sqlorentry);
 
VAR
      ok   : boolean;
      coldb  : tpr_sqlcol;
      i        : integer;
      iolen    : tsp00_Int2;
      pos      : integer;
      colp     : integer;
      part_ptr : tsp1_part_ptr;
      param_info : tsp1_param_info;
      coldbptr : tpr_sqlcolpointer;
      act_ptr  : tpr_vtypepointer;
      orptr    : tpr_sqlcolpointer; (* sqlcol-info pointer  *)
 
BEGIN
WITH sqlca, sqlxa, sqlrap^ DO
    BEGIN
    (* sfinfo der ergebnismenge retten nach orres.. *)
    ore.orrescntacc := 0;
    ore.oropennew := cpr_is_init;
    p03find_part (sqlrap, sp1pk_output_cols_no_parameter, part_ptr);
    IF  (part_ptr = NIL) AND (sqldbmode <> cpr_kind_internal)
    THEN
        p03find_part (sqlrap, sp1pk_shortinfo, part_ptr);
    (*ENDIF*) 
    IF  part_ptr <> NIL
    THEN
        WITH part_ptr^, sp1p_part_header, param_info, coldb  DO
            BEGIN
            IF  sp1p_buf_len > 0
            THEN
                (* belege  orrespointer, und inhalt mit sfinfo *)
                BEGIN
                ore.orrescntacc := sp1p_arg_count;
&               ifdef TRACE
                m90int2 (pc, 'sqlorp-index', xakano       );
                m90int2 (pc, 'mxpr_sqln   ', mxpr_sqln      );
                m90int4 (pc, 'orrescnt    ', ore.orrescnt     );
                m90int4 (pc, 'orrescntacc ', ore.orrescntacc  );
                m90int4 (pc, 'orreslen    ', ore.orreslen     );
                m90int4 (pc, 'orresptr    ', ore.orresptr.intaddr );
                m90buf5 (pc, sp1p_buf, 1, sp1p_buf_len);
&               endif
                IF  ore.orresptr.intaddr <> 0
                THEN
                    BEGIN
&                   ifdef TRACE
                    m90int2 (pc, 'sp1p_arg_cnt', sp1p_arg_count );
&                   endif
                    IF  ore.orrescnt  < sp1p_arg_count
                    THEN
                        BEGIN
&                       ifdef TRACE
                        m90int4 (pc, 'orrescnt fre', orrescnt );
                        m90int4 (pc, 'orresptr    ', orresptr.intaddr );
&                       endif
                        orptr.intaddr := ore.orresptr.intaddr;
                        pr03mFreeP(ore.orresptr.intaddr, 'orresptr          ');
                        ore.orresptr.intaddr := 0;
                        ore.orrescnt := 0;
                        ore.orreslen := 0;
                        ore.orressqlrow.ireclen := 0;
                        ore.orressqlrow.oreclen := 0;
                        (* doppelte orresptr auf NIL setzen *)
                        (* PTS 1107473 *)
                        p03orfree (sqlca, orptr.intaddr, 2);
&                       ifdef TRACE
                        m90int2 (pc, 'rescnt free ', ore.orrescnt  );
                        m90int4 (pc, 'orresptr    ', ore.orresptr.intaddr );
&                       endif
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  (ore.orresptr.intaddr = 0)
                THEN
                    BEGIN
                    ore.orrescnt := sp1p_arg_count;
                    ore.orreslen := sizeof (coldb) * ore.orrescnt;
&                   ifdef TRACE
                    m90int4 (pc, 'orrescnt    ', ore.orrescnt     );
                    m90int4 (pc, 'orreslen    ', ore.orreslen     );
                    m90int4 (pc, 'orresptr    ', ore.orresptr.intaddr );
&                   endif
                    pr03mAllocatP(ore.orreslen, act_ptr.intaddr, 'orresptr          ');
                    IF  act_ptr.vtypep = NIL
                    THEN
                        BEGIN
                        p01memoryerror (sqlca, sqlxa);
                        ore.orresptr.intaddr := 0;
                        ore.orrescntacc  := 0;
                        END
                    ELSE
                        ore.orresptr.intaddr := act_ptr.intaddr;
                    (*ENDIF*) 
                    END;
&               ifdef TRACE
                (*ENDIF*) 
                m90int4 (pc, 'orresptr    ', ore.orresptr.intaddr );
&               endif
                p04init (ore.orressqlrow);
                pos := 1;
                colp := 0;
                FOR i := 1 TO ore.orrescntacc DO
                    BEGIN
                    coldbptr.intaddr := ore.orresptr.intaddr + colp;
                    iolen := p04pdecode (sp1p_buf, pos, ore.orressqlrow,
                          coldbptr.sqlcolp^ [1]);
                    pos := pos + sizeof (param_info);
                    colp := colp + sizeof (coldb);
                    END;
                (*ENDFOR*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01memoryerror  (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype);
 
VAR
      parsid : tpr_parsid;
 
BEGIN
pr01TraceRuntimeError (sqlca, sqlxa,
      cpr_memory_allocation_faild);
p01pparsidtrace (sqlca, sqlxa, @sqlxa.sqlkap^[sqlxa.xakano],
      parsid, TraceParseIDSQLStmt_epr00);
p01xtimetrace (sqlca, sqlxa, sqlca.sqlgap^.gaentry[cpr_se_primary]^);
sqlabort;
END;
 
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      p01areaprint  (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype);
 
VAR
      i : integer;
 
BEGIN
WITH sqlca,  sqlxa, sqlkap^ [xakano] DO
    BEGIN
    m90int  (pc, 'xakano******', xakano);
    m90int  (pc, 'kapaindex   ', kapaindex );
    m90int  (pc, 'kapacount   ', kapacount );
    IF  (kapaindex > 0) AND (kapacount > 0)
    THEN
        FOR i := kapaindex TO kapaindex + kapacount - 1 DO
            WITH sqlpap^ [i] DO
                BEGIN
                m90int  (pc, 'partab i****', i );
                CASE pakindlo  OF
                    sqlparlo :
                        BEGIN
                        m90int  (pc, 'pakindlo    ', pakindlo  );
                        m90int2 (pc, 'pava1index  ', pava1index);
                        m90int2 (pc, 'paloopcnt   ', paloopcnt);
                        m90int2 (pc, 'paloopmin   ', paloopmin);
                        IF  pava1index > 0
                        THEN
                            p01va1print  (sqlca, sqlxa, pava1index);
                        (*ENDIF*) 
                        END;
                    sqlparst :
                        BEGIN
                        m90int  (pc, 'pakindst    ', pakindst  );
                        m90int2 (pc, 'pavarst     ', pavarst);
                        m90int2 (pc, 'paindst     ', paindst);
                        m90int2 (pc, 'paelcnt     ', paelcnt);
                        IF  pavarst > 0
                        THEN
                            p01va1print  (sqlca, sqlxa, pavarst);
                        (*ENDIF*) 
                        IF  paindst > 0
                        THEN
                            p01va1print  (sqlca, sqlxa, paindst);
                        (*ENDIF*) 
                        END;
                    sqlparel :
                        BEGIN
                        m90int  (pc, 'pakindel    ', pakindel  );
                        m90int2 (pc, 'pavarno     ', pavarno  );
                        m90int2 (pc, 'paindno     ', paindno);
                        m90int4 (pc, 'pasqlcolp   ', pasqlcolp.intaddr);
                        IF  pavarno > 0
                        THEN
                            p01va1print  (sqlca, sqlxa, pavarno);
                        (*ENDIF*) 
                        IF  paindno > 0
                        THEN
                            p01va1print  (sqlca, sqlxa, paindno);
                        (*ENDIF*) 
                        END;
                    OTHERWISE:
                        BEGIN
                        END;
                    END;
                (*ENDCASE*) 
                m90int  (pc, '------------', 0 );
                END;
            (*ENDWITH*) 
        (*ENDFOR*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01va1print  (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            vaix : integer);
 
VAR
      j : integer;
 
BEGIN
WITH  sqlca, sqlxa DO
    IF  vaix > 0
    THEN
        WITH sqlv1p^ [vaix] DO
            BEGIN
            m90int  (pc, 'va1tab i****', vaix );
            CASE va1indi_sc OF
                sqlvasc :
                    BEGIN
                    m90int  (pc, 'va1indi_sc  ', va1indi_sc );
                    m90int2 (pc, 'va1indva2_sc', va1indva2_sc);
                    m90int2 (pc, 'va1indva3_sc', va1indva3_sc);
                    m90int4 (pc, 'va1addr_sc  ', va1addr_sc.intaddr);
                    IF  sqlv3p <> NIL
                    THEN
                        m90lname (pc, sqlv3p^ [va1indva3_sc].va3name);
                    (*ENDIF*) 
                    p01va2print (sqlca, sqlxa, va1indva2_sc);
                    END;
                sqlvacm :
                    BEGIN
                    m90int  (pc, 'va1indi_cm  ', va1indi_cm );
                    m90int2 (pc, 'va1indva2_cm', va1indva2_cm);
                    m90int2 (pc, 'va1indva3_cm', va1indva3_cm);
                    m90int4 (pc, 'va1offs_cm  ', va1offs_cm  );
                    IF  sqlv3p <> NIL
                    THEN
                        m90lname (pc, sqlv3p^ [va1indva3_cm].va3name);
                    (*ENDIF*) 
                    p01va2print (sqlca, sqlxa, va1indva2_cm);
                    END;
                sqlvast :
                    BEGIN
                    m90int  (pc, 'va1indi_st  ', va1indi_st );
                    m90int2 (pc, 'va1cmpcnt_st', va1cmpcnt_st);
                    m90int4 (pc, 'va1size_st  ', va1size_st );
                    m90int4 (pc, 'va1ix_st    ', va1ix_st );
                    m90int4 (pc, 'va1addr_sc  ', va1addr_sc.intaddr);
                    FOR j := va1ix_st TO va1ix_st+va1cmpcnt_st-1 DO
                        p01va1print  (sqlca, sqlxa, j);
                    (*ENDFOR*) 
                    END;
                sqlvapt :
                    BEGIN
                    m90int  (pc, 'va1indi_pt  ', va1indi_pt );
                    m90int4 (pc, 'va1ix_pt    ', va1ix_pt );
                    p01va1print  (sqlca, sqlxa, va1ix_pt);
                    END;
                OTHERWISE:
                    BEGIN
                    END;
                END;
            (*ENDCASE*) 
            m90int  (pc, '------------', 0 );
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01va2print  (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            va2ix : integer);
 
BEGIN
WITH  sqlca, sqlxa DO
    IF  va2ix > 0
    THEN
        WITH sqlv2p^ [va2ix] DO
            BEGIN
            m90int  (pc, 'va2tab i****', va2ix );
            m90int2 (pc, 'va2typ      ', va2typ    );
            m90int2 (pc, 'va2digit    ', va2digit );
            m90int2 (pc, 'va2frac     ', va2frac  );
            m90int2 (pc, 'va2const    ', va2const );
            m90int4 (pc, 'va2size     ', va2size  );
            m90int  (pc, '------------', 0 );
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p01_pr_sqlda ( VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype);
 
VAR
      i : integer;
 
BEGIN
WITH sqlca,  sqlxa, sqlkap^ [xakano] DO
    IF  sqldbmode =  cpr_kind_internal
    THEN
        IF  sqlcxap^.xasqldap.sqldaptr <> NIL
        THEN
            WITH sqlcxap^.xasqldap.sqldaptr^ DO
                FOR i := 1 TO sqln DO
                    WITH sqlvar [i] DO
                        BEGIN
                        m90int  (pc, 'sqlvar**[i]*', i);
                        m90buf3  (pc, colname , 1, 80 );
                        END;
                    (*ENDWITH*) 
                (*ENDFOR*) 
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
&endif
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
