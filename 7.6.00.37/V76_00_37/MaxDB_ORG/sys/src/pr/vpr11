.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.tt 1 $SQL$Project Distributed Database System$VPR11$
.tt 2 $$$
.TT 3 $$Call_statement_procedures$2000-12-08$
***********************************************************
.nf
 
 .nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : Call_statement_proceduren
=========
.sp
Purpose : Call_statement_procedures for working
          with Call_interface.
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              p11connect (VAR sqcca : sqlcatype;
                    VAR gae : sqlgaentry);
 
        PROCEDURE
              p11statement (VAR sqcca : sqlcatype;
                    VAR gae : sqlgaentry);
 
        PROCEDURE
              p11parse  (VAR sqcca : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcda     : sqldavrec;
                    VAR sqcparsid : tpr_parsid;
                    again         : boolean);
 
        PROCEDURE
              p11execute (VAR sqcca : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcda     : sqldavrec;
                    VAR sqcparsid : tpr_parsid;
                    again         : boolean;
                    VAR arrayparsid : boolean;
                    sqcrowcount   : tsp00_Int4);
 
        PROCEDURE
              p11getxsqcerr (varno : tsp00_Int2;
                    vartyp        : tsp00_Int2;
                    VAR sqcda     : sqldavrec;
                    VAR sqcerr : tsp00_Int2);
 
        PROCEDURE
              p11trace  (VAR sqcca   : sqlcatype;
                    VAR nam : tsp00_Name );
 
        PROCEDURE
              p11pparsidtrace (VAR sqcca : sqlcatype;
                    VAR parsid : tpr_parsid;
                    inout : integer);
 
        PROCEDURE
              p11againtrace (VAR sqcca : sqlcatype;
                    art : integer;
                    again : boolean);
 
        PROCEDURE
              p11checkarraycommand   (VAR sqcca   : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcdbno   : tsp00_Int2;
                    VAR sqcstmlen : tsp00_Int4;
                    VAR sqcstmbuf : tsp00_MoveObj;
                    encodingType : tpr05_StringEncoding;
                    VAR sqcda     : sqldavrec;
                    VAR sqcparsid : tpr_parsid;
                    VAR arrayparsid : boolean);
 
        PROCEDURE
              p11shortfieldparameterput (VAR sqcca : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcda  : sqldavrec;
                    again      : boolean);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Precompiler_Runtime_Routinen  : VPR08;
 
        FUNCTION
              p08g1addr (VAR a: sqldatype): sqldapointer;
 
        FUNCTION
              p08g2addr (VAR a: sqldb2type): sqldb2pointer;
 
        FUNCTION
              p08g3addr (VAR a: sqloratype): sqlorapointer;
 
        PROCEDURE
              p08runtimeerror (VAR sqlca : sqlcatype;
                    VAR sqlcxa : sqlcxatype;
                    error : tpr_runtime_errors);
 
        PROCEDURE
              p08vfwritetrace (sqlrap : sqlrapointer);
 
      ------------------------------ 
 
        FROM
              Runtime-Stringroutinen  : VPR05;
 
        PROCEDURE
              p05nextsymbol (VAR buf : tsp00_MoveObj;
                    buflen  : tsp00_Int4;
                    posanf     : tsp00_Int4;
                    VAR sympos : tsp00_Int4;
                    VAR symlen : tsp00_Int4;
                    VAR symb   : tpr_symbol);
 
        PROCEDURE
              p05searchword  (VAR buf : tsp00_MoveObj;
                    lwb : integer;
                    upb : integer;
                    word : tsp00_Sname;
                    lw   : integer;
                    VAR pos : integer);
 
        FUNCTION
              p05eq (VAR a : tsp00_Sname;
                    VAR b  : tsp00_MoveObj;
                    b_pos  : tsp00_Int4;
                    length : tsp00_Int4) : boolean;
 
      ------------------------------ 
 
        FROM
              C-Type-Checker-Module  : VPR102;
 
        PROCEDURE
              pr12cBeforeParse  (VAR sqlca : sqlcatype;
                    ConDesc : tsp00_Addr;
                    VAR sqcda     : sqldavrec;
                    VAR cmdfetch : tsp00_Int2);
 
        PROCEDURE
              pr11cGetsqcstm (VAR sqcca : sqlcatype;
                    ConDesc : tsp00_Addr;
                    PacketEncoding : tpr05_StringEncoding;
                    cmdtyp : tsp1_cmd_mess_type;
                    sqcstmlen : tsp00_Int4;
                    VAR sqcstmbuf : tsp00_MoveObj;
                    encodingType : tpr05_StringEncoding;
                    VAR AnalyzeDesc   : tpr05_StmtAnalysisDesc);
 
        PROCEDURE
              pr11cFetchDescribe (VAR sqcca : sqlcatype;
                    ConDesc : tsp00_Addr;
                    PacketEncoding : tpr05_StringEncoding;
                    VAR sqcda     : sqldavrec;
                    VAR AnalyzeDesc   : tpr05_StmtAnalysisDesc);
 
        PROCEDURE
              pr03cPutResultName (ConDesc : tsp00_Addr;
                    VAR sqlresn : tsp00_KnlIdentifier;
                    errmsg : sqlempointer);
 
        PROCEDURE
              pr01cResultNameGet(sqlrap : sqlrapointer;
                    VAR gae : sqlgaentry;
                    VAR sqlresn : tsp00_KnlIdentifier;
                    cbLen : integer);
 
        PROCEDURE
              p04sqldin (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlcxatype;
                    VAR ga : sqlgaentry;
                    dapoint : sqldapointer;
                    VAR looprec : tpr_sqlloop);
 
        PROCEDURE
              p04sqldout (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlcxatype;
                    VAR ga : sqlgaentry;
                    dapoint : sqldapointer;
                    VAR looprec : tpr_sqlloop);
 
        FUNCTION
              p04sqldsfi (VAR sqlca : sqlcatype;
                    VAR sqlcxa  : sqlcxatype;
                    ore : sqlorpointer;
                    dapoint : sqldapointer;
                    fetchdesc   : boolean;
                    again       : boolean;
                    DescribeKind : tpr00_DescribeKindEnum)
                    : tsp00_Int2;
 
        PROCEDURE
              p04db2din (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlcxatype;
                    VAR ga : sqlgaentry;
                    cu : sqlcupointer;
                    da2point : sqldb2pointer);
 
        PROCEDURE
              p04db2dout (VAR sqlca : sqlcatype;
                    VAR ga : sqlgaentry;
                    da2point : sqldb2pointer);
 
        FUNCTION
              p04db2dsfi (VAR sqlca : sqlcatype;
                    VAR sqlcxa  : sqlcxatype;
                    ore : sqlorpointer;
                    da2point: sqldb2pointer;
                    fetchdesc   : boolean;
                    again       : boolean;
                    DescribeKind : tpr00_DescribeKindEnum)
                    : tsp00_Int2;
 
        PROCEDURE
              p04oradin (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlcxatype;
                    VAR ga : sqlgaentry;
                    cu : sqlcupointer;
                    orapoint : sqlorapointer;
                    VAR looprec : tpr_sqlloop);
 
        PROCEDURE
              p04oradout (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlcxatype;
                    VAR ga : sqlgaentry;
                    orapoint : sqlorapointer;
                    VAR looprec : tpr_sqlloop);
 
        FUNCTION
              p04oradsfi (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlcxatype;
                    ore : sqlorpointer;
                    daorapoint : sqlorapointer;
                    fetchdesc   : boolean;
                    DescribeKind : tpr00_DescribeKindEnum)
                    : tsp00_Int2;
 
        PROCEDURE
              p03ccmdinit (
                    VAR xaSQLDesc : tpr01_SQLDesc;
                    VAR sqlca : sqlcatype;
                    VAR gae : sqlgaentry;
                    m_type   : tsp1_cmd_mess_type);

        PROCEDURE
              p03sABAPStream (VAR sqlca : sqlcatype;
                    VAR sqlcxa : sqlcxatype;
                    VAR gae : sqlgaentry);
 
        PROCEDURE
              p03connect  (
                    VAR sqlcxa : sqlcxatype;
                    sqlrap :sqlrapointer;
                    sqlgap   :  sqlgapointer;
                    VAR ga : sqlgaentry;
                    datetime : tsp00_Int2;
                    errmsg : sqlempointer);
 
        PROCEDURE
              p03sqlrelease  (sqlrap : sqlrapointer;
                    sqlgap :  sqlgapointer;
                    VAR ga : sqlgaentry;
                    errmsg : sqlempointer);
 
        PROCEDURE
              p03cmdtrace (sqlrap : sqlrapointer;
                    VAR gae : sqlgaentry;
                    nlcnt : tsp00_Int2;
                    com_kind : tsp00_Int2;
                    pSQLStatement : tpr05_StringPointer);
 
        PROCEDURE
              p03cresultcountget (sqlrap :sqlrapointer;
                    VAR ga : sqlgaentry;
                    VAR resultcount : tsp00_Int4);
 
        PROCEDURE
              p03cpparsid (sqlrap : sqlrapointer;
                    VAR ga  : sqlgaentry;
                    VAR parsid : tpr_parsid;
                    sqlemp : sqlempointer);
 
        PROCEDURE
              pr04LongOutputLvc (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlcxatype;
                    VAR gae : sqlgaentry;
                    p01looprec : tpr_sqlloop);
 
        PROCEDURE
              pr04LongInitLD (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlcxatype);
 
        PROCEDURE
              pr04LongLvcInitRec (VAR sqlca : sqlcatype;
                    VAR lvcrec: tpr_longvarcharrec);
&       ifdef TRACE
 
        PROCEDURE
              m90int2 (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : tsp00_Int2);
 
        PROCEDURE
              m90int4 (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : tsp00_Int4);
 
        PROCEDURE
              m90int (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : integer);
 
        PROCEDURE
              m90buf  (layer : tsp00_ToolLayer;
                    VAR buf :  tsp_packet;
                    pos_anf : integer;
                    pos_end : integer);
&       endif
 
      ------------------------------ 
 
        FROM
              SQLDB-Auftrags-Schnittstelle : VPR03;
 
        PROCEDURE
              p03reqrecpacket (
                    VAR sqlca : sqlcatype;
                    VAR sqlcxa : sqlcxatype;
                    VAR ga : sqlgaentry);
 
        PROCEDURE
              p03find_part  (sqlrap : sqlrapointer;
                    part_kind        : tsp1_part_kind;
                    VAR part_ptr     : tsp1_part_ptr);
 
        PROCEDURE
              p03gparsid (sqlrap : sqlrapointer;
                    sqlemp : sqlempointer;
                    VAR parsid : tpr_parsid;
                    VAR SessionID : tpr00_SessionID);
 
        PROCEDURE
              p03returncodeget (VAR sqlca : sqlcatype;
                    VAR sqlcxa : sqlcxatype);
 
      ------------------------------ 
 
        FROM
              SQL_runtime_routinen  : VPR01;
 
        PROCEDURE
              p01formatparsid(VAR parsid : tpr_parsid;
                    VAR tastr80 : tsp00_C256; VAR tastr80l : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              SQL_runtime_routinen  : VPR01E;
 
        PROCEDURE
              p01xtimetrace (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlcxatype;
                    VAR gae : sqlgaentry);
 
      ------------------------------ 
 
        FROM
              Fetch-Optimierung   : VPR12;
 
        PROCEDURE
              p12baparsen  (VAR sqlca : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcda     : sqldavrec;
                    VAR cmdfetch : tsp00_Int2;
                    VAR reclen   : tsp00_Int4;
                    VAR parsid   : tpr_parsid);
 
        PROCEDURE
              p12bexecute  (VAR sqlca : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcda     : sqldavrec;
                    VAR cmdfetch : tsp00_Int2;
                    VAR fa_entry : sqlfaentry;
                    VAR parsid   : tpr_parsid;
                    sqcrowcount   : tsp00_Int4);
 
        PROCEDURE
              p12baexecute  (VAR sqlca : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR stmparsid   : tpr_parsid);
 
        PROCEDURE
              p12bgetmfetch  (VAR sqlca : sqlcatype;
                    VAR gae : sqlgaentry;
                    VAR sqcda     : sqldavrec;
                    VAR fa_entry : sqlfaentry;
                    sqcrowcount   : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill   : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              s10mv (
                    source_upb  : tsp00_Int4;       
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;    
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;    
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26finish_part (packet_ptr : tsp1_packet_ptr;
                    VAR finish_part      : tsp1_part);
 
        PROCEDURE
              s26new_part_init (packet_ptr : tsp1_packet_ptr;
                    VAR segm               : tsp1_segment;
                    VAR new_part_ptr       : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30    : VSP30;
 
        FUNCTION
              s30eq (VAR a : tsp00_Sname;
                    VAR b : tsp00_MoveObj;
                    bi,cnt : tsp00_Int4) : boolean;
 
        FUNCTION
              s30len2 (VAR str : tsp00_KnlIdentifier;
                    val : char; cnt : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              GET-Conversions   : VSP40;
 
        PROCEDURE
              s40gbyte (VAR buf    : tpr_parsid;
                    pos    : tsp00_Int4;
                    len    : integer;
                    VAR dest   : tsp00_C256;
                    dpos   : tsp00_Int4;
                    dlen   : integer;
                    VAR truncated  : boolean);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              m90buf;
 
              tsp00_Buf      tsp_packet
 
        FUNCTION
              p08g1addr;
 
              tsp00_MoveObj       sqldatype
              tpr_intaddr       sqldapointer
 
        FUNCTION
              p08g2addr;
 
              tsp00_MoveObj       sqldb2type
              tpr_intaddr       sqldb2pointer
 
        FUNCTION
              p08g3addr;
 
              tpr_intaddr       sqlorapointer
              tsp00_MoveObj    sqloratype
 
        PROCEDURE
              p08runtimeerror;
 
              sqlxatype   sqlcxatype
 
        PROCEDURE
              p01xtimetrace;
 
              sqlxatype   sqlcxatype
 
        PROCEDURE
              p04sqldin;
 
              sqlxatype   sqlcxatype
 
        PROCEDURE
              p04sqldout;
 
              sqlxatype   sqlcxatype
 
        PROCEDURE
              p04db2din;
 
              sqlxatype   sqlcxatype
 
        PROCEDURE
              p04db2dout;
 
              sqlxatype   sqlcxatype
 
        PROCEDURE
              p04oradin;
 
              sqlxatype   sqlcxatype
 
        PROCEDURE
              p04oradout;
 
              sqlxatype   sqlcxatype
 
        PROCEDURE
              p04sqldsfi;
 
              sqlxatype   sqlcxatype
 
        PROCEDURE
              p04oradsfi;
 
              sqlxatype   sqlcxatype
 
        PROCEDURE
              p04db2dsfi;
 
              sqlxatype   sqlcxatype
 
        PROCEDURE
              p03connect;
 
              sqlxatype         sqlcxatype
 
        PROCEDURE
              p03returncodeget;
 
              sqlxatype   sqlcxatype
 
        PROCEDURE
              p03reqrecpacket;
 
              sqlxatype   sqlcxatype

        PROCEDURE
              p03sABAPStream;
 
              sqlxatype   sqlcxatype
 
        PROCEDURE
              p03gparsid;
 
              tpr_parsid       tpr_parsid
 
        PROCEDURE
              s30eq;
 
              tsp00_MoveObj  tsp00_Sname
 
        FUNCTION
              s30len2;
 
              tsp00_MoveObj       tsp00_KnlIdentifier
 
        PROCEDURE
              s40gbyte;
 
              tsp00_MoveObj  tpr_parsid
              tsp00_MoveObj  tsp00_C256
 
        PROCEDURE
              pr04LongInitLD;
 
              sqlxatype         sqlcxatype
 
        PROCEDURE
              pr04LongOutputLvc;
 
              sqlxatype         sqlcxatype
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1988-03-25
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-12-08
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.sp 2
.cp 6
PROCEDURE  P81_GETSQCSTM:
.sp 2
If the trace output is activated or there is no dbs_execute instruction,
the command is written to the request buffer.
The buffer is initalized with the cmdtyp.
If the sqcstmlen is less than or equal to zero the length of the
command is calculated, i.e. it must be delimited by '!' exclamation
mark. Otherwise sqcstmlen is used.
Subsequently the command type is also calculated and also
moved to sqlcxa.xakono. Commands cpr_com_release, in the case of cpr_com_mfetch,
 cpr_com_mfetch_describe and cpr_com_fetch_describe are moved to xaprname after
the result set name.
.sp 4
.cp 6
PROCEDURE  P81_ANALYZE_CONNECT:
.sp 2
User name and password are moved to the current session for analysis
of the connect statements (p08_analyze_connect).
.sp 4
.cp 6
PROCEDURE  P81_CONNECT:
.sp 2
Executes the connect command.
Writes the command to the trace, if activated.
Sends it to the database, and analyzes the return code.
.sp 4
.cp 6
PROCEDURE  P81_STATEMENT:
.sp 2
Writes the command to the trace, if activated.
Sends it to the database, and analyzes the return code.
If a cpr_com_release command has been issued, the database session
is then terminated normally with p03sqlrelease.
.sp 4
.cp 6
PROCEDURE  P81_PARSE:
.sp 2
Writes the command to the trace, if activated, and if
it has not been repeated a second time.
Sends it to the database, and analyzes the return code.
Returns the parse ID and assigns the data infos to the SQCDA area.
If a cpr_com_mfetch or cpr_com_mfetch_describe command has been issued, a search
is performed for space in the SQLMF area and correspondingly initialized.
.sp 4
.cp 6
PROCEDURE  P81_DESCRIBE:
.sp 2
If a cpr_com_fetch_describe or cpr_com_mfetch_describe command has been issued,
the data infos are fetched by way of the command 'describe xaprname'
and written to the SQCDA area. Subsequently the command is
parsed with a converted fetch syntax.(p11parse).
.sp 4
.cp 6
PROCEDURE  P81_EXECUTE:
.sp 2
Writes the command to the trace, if activated, and if
it has not been repeated a second time.
Writes the parse ID to the trace, if activated.
From the SQCDA area assigns the input values to the request buffer.
For cmdfetch commands a check is run to determine whether a new buffer
has to be fetched, and if appropriate fetched from the database.
From the SQCDA area and the request buffer assigns the
output values of the command.
Analyzes the return code.
If a cpr_com_release command has been issued, the database session
is terminated normally with p03sqlrelease.
.sp 4
.cp 6
PROCEDURE  P81_FETCH_DESCRIBE:
.sp 2
For a describe-fetch, sets up the syntax for the
database. ' fetch xaprname into :a, :a, ....'.
.sp 4
.cp 6
PROCEDURE  P81_SHORTFIELD_PARAMETER_PUT:
.sp 2
Writes the short field infos (data infos) of the database to the
SQCDA area.
For all parameters
host indicator = 0, hostvartype = -1 and hostvaraddr = 0
is initialized.
The maximum extension of the sqlvar entries must be specified by the
user in sqlmax. sqln receives the number of all parameters in the
command, also in th event of a fault.
sqld contains the number of all output parameters in the command.
.sp 4
.cp 6
PROCEDURE  P81_SHORTFIELD_PARAMETER_PUT:
.sp 2
Writes the short field infos (data infos) of the database to the
SQCDA area.
For all parameters
host indicator = 0, hostvartype = -1 and hostvaraddr = 0
is initialized.
The maximum extension of the sqlvar entries must be specified by the
user in sqlmax. sqln receives the number of all parameters in the
command, also in th event of a fault.
sqld contains the number of all output parameters in the command.
.sp 4
.cp 6
PROCEDURE  P81_ISQCDA_PARAMETER_PUT:
.sp 2
On the basis of the short field infos (data infos) writes the
input values of a command to the request buffer.
(sqln <> sqld) signifies input parameters are specified.
.sp 4
.cp 6
PROCEDURE  P81_OSQCDA_PARAMETER_PUT:
.sp 2
On the basis of the short field infos (data infos) writes the
output values of a command from the request buffer to the host variables.
In addition,, if assigned by the database, the count (number
of lines that were processed) is brought to sqlerrd at position 3.
.sp 4
.cp 6
PROCEDURE  P81_GET_SQCERR:
.sp 2
In the case of a bind call, checks for overflow of the sqlvar entries
in the SQCDA area.
Checks the compatibility of the
parameters with the database values.
.sp 4
.cp 6
PROCEDURE  P81_AGAIN_TRACE:
.sp 2
If trace is activated, writes the start or repetitions entry
of the command to the trace output.
.sp 4
.cp 6
PROCEDURE  P81_PPARSID_TRACE:
.sp 2
If trace is activated, writes the parse ID to the
trace output.
.sp 4
.cp 6
PROCEDURE  P81_COMTYPE_TO_XAKANO:
.sp 2
Analyzes a command and stores the type in xakano.
Commands 'commit relase', rollback release' are assigned cpr_com_release as
the type.
Commands 'describe ...' are assigned cpr_com_describe as the type.
Commands 'ffetch   ...' are assigned cpr_com_mfetch as the type.
Commands 'describe fetch   ...' are assigned cpr_com_fetch_describe as the type.
Commands 'describe ffetch  ...' are assigned cpr_com_mfetch_describe as the type.
All others cpr_com_sql as the type.
.sp 4
***********************************************************
.sp 2
 
.cp 6
PROCEDURE  P81_GETSQCSTM:
.sp 2
Ist der Traceoutput eingeschaltet oder kein dbs_execute Befehl,
wird das Kommando in den Auftragspuffer geschrieben.
Es wird der Puffer initalisiert mit dem cmdtyp.
Ist die sqcstmlen kleiner gleich null wird die L?ange des
Kommandos berechnet, d.h. es muss mit '!' Ausrufezeichen abgeschlossen
sein. Sonst wird sqcstmlen genommen.
Anschlie?zend wird noch der kommandotype berechnet und nach
sqlcxa.xakono gebracht. Kommndos cpr_com_release, bei cpr_com_mfetch,
 cpr_com_mfetch_describe und cpr_com_fetch_describe wird noch der Ergbnissmengen-
namen nach xaprname gebracht.
.sp 4
.cp 6
PROCEDURE  P81_ANALYSE_CONNECT:
.sp 2
Username und Password werden in die aktuelle Session zur Analyse
des Connect-Statements gebracht (p08_analysiere_connect).
.sp 4
.cp 6
PROCEDURE  P81_CONNECT:
.sp 2
F?urht das Connect-Kommando aus.
Schreibt das Kommando in den Trace, wenn eingeschalltet.
Schickt es an die Datenbank, und analysiert den Returncode.
.sp 4
.cp 6
PROCEDURE  P81_STATEMENT:
.sp 2
Schreibt das Kommando in den Trace, wenn eingeschalltet.
Schickt es an die Datenbank, und analysiert den Returncode.
Wurde ein cpr_com_release Kommando abgesetzt, wird die Datenbanksession
mit p03sqlrelease noch ordnungsgem?a?z beendet.
.sp 4
.cp 6
PROCEDURE  P81_PARSE:
.sp 2
Schreibt das Kommando in den Trace, wenn eingeschalltet, und
es nicht ein zweitesmal wiederholt wurde.
Schickt es an die Datenbank, und analysiert den Returncode.
Gibt die Parsid zur?uck und belegt die Dateninfos in die SQCDA-Area.
Wurde ein cpr_com_mfetch oder cpr_com_mfetch_describe Kommando abgesetzt, wird
noch Platz gesucht in der SQLMF-Area und entsprechend initialisiert.
.sp 4
.cp 6
PROCEDURE  P81_DESCRIBE:
.sp 2
Wurde ein cpr_com_fetch_describe oder cpr_com_mfetch_describe Kommando abgesetzt,
werden die Dateninfos ?uber das Kommando 'describe xaprname' geholt
und in die SQCDA-Area geschrieben. Anschlie?zend wird das Kommando
mit einer umgesetzten fetch Syntax geparsed.(p11parse).
.sp 4
.cp 6
PROCEDURE  P81_EXECUTE:
.sp 2
Schreibt das Kommando in den Trace, wenn eingeschalltet, und
es nicht ein zweitesmal wiederholt wurde.
Schreibt die Parsid in den Trace, wenn eingeschalltet.
Belegt aus der SQCDA-Area die Input Werte in den Auftragsbuffer.
F?ur cmdfetch Kommandos wird gepr?uft, ob ein neuer Puffer
geholt weden muss, und eventuell aus der Datenbank geholt.
Belegt aus der SQCDA-Area und dem Auftragspuffer die
Output Werte des Kommandos.
Analysiert den Returncode.
Wurde ein cpr_com_release Kommando abgesetzt, wird die Datenbanksession
mit p03sqlrelease noch ordnungsgem?a?z beendet.
.sp 4
.cp 6
PROCEDURE  P81_FETCH_DESCRIBE:
.sp 2
Baut f?ur ein Describe-fetch die Syntax f?ur die
Datenbank auf. ' fetch xaprname into :a, :a, ....'.
.sp 4
.cp 6
PROCEDURE  P81_SHORTFIELD_PARAMETER_PUT:
.sp 2
Schreibt die Shortfieldinfos (Dateninfos) der Datenbank in die
SQCDA-Area.
F?ur alle Parameter wird
hostindicator = 0, hostvartype = -1 und hostvaraddr = 0
initialisiert.
In sqlmax muss vom Anwender die maximale Ausdehnung der sqlvar Eintr?age
angegeben sein. sqln erh?alt auch im Fehlerfall die Anzahl aller
Parameter in dem Kommando.
sqld erth?alt die Anzahl aller Output-Parameter in dem Kommando.
.sp 4
.cp 6
PROCEDURE  P81_SHORTFIELD_PARAMETER_PUT:
.sp 2
Schreibt die Shortfieldinfos (Dateninfos) der Datenbank in die
SQCDA-Area.
F?ur alle Parameter wird
hostindicator = 0, hostvartype = -1 und hostvaraddr = 0
initialisiert.
In sqlmax muss vom Anwender die maximale Ausdehnung der sqlvar Eintr?age
angegeben sein. sqln erh?alt auch im Fehlerfall die Anzahl aller
Parameter in dem Kommando.
sqld erth?alt die Anzahl aller Output-Parameter in dem Kommando.
.sp 4
.cp 6
PROCEDURE  P81_ISQCDA_PARAMETER_PUT:
.sp 2
Schreibt and Hand der Shortfieldinfos (Dateninfos) die Input Values
eines Kommandos in den Auftragspuffer.
(sqln <> sqld) bedeutet input Parameter sind angegeben..
.sp 4
.cp 6
PROCEDURE  P81_OSQCDA_PARAMETER_PUT:
.sp 2
Schreibt and Hand der Shortfieldinfos (Dateninfos) die Output Values
eines Kommandos vom  Auftragspuffer in die Hostvariablen.
Ausserdem wird, wenn von der Datenbank belegt, der Count (Anzahl
der Zeilen die bearbeitet wurden) nach sqlerrd an Position 3 gebracht..
.sp 4
.cp 6
PROCEDURE  P81_GET_SQCERR:
.sp 2
Scheckt bei einem Bindaufruf, ?uberlauf der sqlvar Eintr?age der SQCDA-Area.
Scheckt die Kompatibilit?at der
Parameter mit den Datenbankwerten.
.sp 4
.cp 6
PROCEDURE  P81_AGAIN_TRACE:
.sp 2
Schreibt, wenn Trace eingeschaltet, den Anfang oder Wiederholung
Angabe des Kommandos in den Traceoutput.
.sp 4
.cp 6
PROCEDURE  P81_PPARSID_TRACE:
.sp 2
Schreibt, wenn Trace eingeschaltet, die Parsid in den
Traceoutput.
.sp 4
.cp 6
PROCEDURE  P81_COMTYPE_TO_XAKANO:
.sp 2
Analysiert ein Kommando und legt den Type in xakano ab.
Kommandos 'commit relase', rollback release' erhalten cpr_com_release als
Type.
Kommandos 'describe ...' erhalten cpr_com_describe als Type.
Kommandos 'ffetch   ...' erhalten cpr_com_mfetch als Type.
Kommandos 'describe fetch   ...' erhalten cpr_com_fetch_describe als Type.
Kommandos 'describe ffetch  ...' erhalten cpr_com_mfetch_describe als Type.
Alle ?ubrigen cpr_com_sql als Type.
.sp 4
PROCEDURE p11checkarraycommand:
.sp 2
Die Procedure pr?uft, ob die Parsid f?ur ein Array-Kommando
schon existiert. Wenn nein wird das Array Kommando
analysiert und umgewandelt in ein Massenkommanso und nochmals
neu geparsed. Die neue Parsid wird an den anwender zur?uckgegeben.
Arrayparsid wird auf False gesetz, dies verhindert ein
nachmaliges ausgeben des Kommandos im Tracefile.
.sp 4
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
 
Code    :
 
 
(*------------------------------*) 
 
PROCEDURE
      p11connect (VAR sqcca : sqlcatype;
            VAR gae : sqlgaentry);
 
VAR
      dummyka : ^sqlkaentry;
 
BEGIN
WITH sqcca DO
    BEGIN
    sqlrap^.raparse_again := FALSE;
    p03connect (sqlcxap^, sqlrap, sqlgap, gae,
          sqldatetime, sqlemp);
    p03returncodeget(sqcca, sqlcxap^);
    p01xtimetrace(sqcca, sqlcxap^, gae);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p11statement (VAR sqcca : sqlcatype;
            VAR gae : sqlgaentry);
 
VAR
      dummyka : ^sqlkaentry;
 
BEGIN
WITH sqcca, sqlrap^  DO
    BEGIN
    raparse_again := FALSE;
    p03cmdtrace (sqcca.sqlrap, gae, 1, cpr_com_empty, NIL);
    p03reqrecpacket(sqcca, sqlcxap^, gae );
    p03cresultcountget (sqlrap, gae, sqlerrd[3]);
    pr01cResultNameGet(sqlrap, gae, sqcca.sqlresn, sizeof(sqcca.sqlresn));
    p03returncodeget(sqcca, sqlcxap^);
    p01xtimetrace(sqcca, sqlcxap^, gae);
    IF  (sqcca.sqlcode = 0) AND ((sqlcxap^.xakano = cpr_com_commit_release)
        OR (sqlcxap^.xakano = cpr_com_rollback_release))
    THEN
        p03sqlrelease (sqlrap, sqlgap, gae, sqlemp);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p11parse (VAR sqcca : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcda     : sqldavrec;
            VAR sqcparsid : tpr_parsid;
            again         : boolean);
 
VAR
      reclen   : tsp00_Int4;
      cmdfetch : tsp00_Int2;
      dummyka : ^sqlkaentry;
 
BEGIN
WITH sqcca, sqlcxap^, sqlgap^, sqlrap^ DO
    BEGIN
    IF   NOT again
    THEN
        p03cmdtrace (sqcca.sqlrap, gae, 1, cpr_com_empty, NIL);
    (*ENDIF*) 
    raparse_again := again;
    p11againtrace (sqcca, 1, again);
    pr12cBeforeParse(sqcca, xaSQLDesc^.ConDesc, sqcda, cmdfetch);
    p03reqrecpacket(sqcca, sqlcxap^, gae);
    IF  NOT again
    THEN
        BEGIN
        p03cresultcountget (sqlrap, gae, sqlerrd[3]);
        pr01cResultNameGet(sqcca.sqlrap, gae, sqcca.sqlresn, sizeof(sqcca.sqlresn));
        END;
    (*ENDIF*) 
    sqlerrd [3] := 0;
    p03gparsid (sqcca.sqlrap, sqcca.sqlemp, sqcparsid, gae.gaKnlSessionID);
    IF  (sqcparsid [cpr_p_precom_index] = chr(csp1_p_use_adbs))
    THEN
        p08runtimeerror (sqcca, sqlcxap^,
              cpr_use_call_stm)
    ELSE
        p03returncodeget(sqcca, sqlcxap^);
    (*ENDIF*) 
&   ifdef TRACE
    IF  (sqcca.sqlrap^.radbmode = cpr_kind_oracle)
    THEN
        m90int4 (pc, 'ora_n       ',sqcda.orada.ora_n );
&   endif
&   ifndef SQLODBC
    (*ENDIF*) 
    p11shortfieldparameterput (sqcca, gae, sqcda, again);
&   endif
    reclen := 0;
    p12baparsen  (sqcca, gae, sqcda, cmdfetch, reclen, sqcparsid);
    p11pparsidtrace (sqcca, sqcparsid, 2);
    p01xtimetrace (sqcca, sqlcxap^, gae);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p11execute (VAR sqcca : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcda     : sqldavrec;
            VAR sqcparsid : tpr_parsid;
            again         : boolean;
            VAR arrayparsid : boolean;
            sqcrowcount   : tsp00_Int4);
 
VAR
      looprec : tpr_sqlloop;
      lvcrec  : tpr_longvarcharrec;
      cmdtyp   : tsp1_cmd_mess_type;
      cmdfetch : tsp00_Int2;
      retsqlerrd3 : integer;
      fa_entry : sqlfaentry;
      nam  : tsp00_Name;
      dummyka : ^sqlkaentry;
 
BEGIN
WITH sqcca, sqlcxap^, sqlrap^, sqlgap^  DO
    IF  (sqcparsid [cpr_p_precom_index] <> chr(csp1_p_command_executed))
    THEN
        BEGIN
        IF  ( NOT again) AND (arrayparsid)
        THEN
            p03cmdtrace (sqcca.sqlrap, gae, 1, cpr_com_empty, NIL);
        (*ENDIF*) 
        p11againtrace (sqcca,  2, again);
        p11initlooprec ( looprec);
        pr04LongInitLD (sqcca, sqlcxap^);
        retsqlerrd3 := 0;
        IF  rasqlldp.intaddr <> 0
        THEN
            rasqlldp.vtypep^.ldallsend := false;
        (*ENDIF*) 
        REPEAT
            IF  rasqlldp.intaddr <> 0
            THEN
                WITH rasqlldp.vtypep^ DO
                    BEGIN
                    ldmaxi := 0;
                    ldmaxo := 0;
                    ldindpc := 0;
                    ldindsp := 0;
                    ldcolkind := cpr_is_false;
                    ldputvalsend := false;
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            cmdtyp := sp1m_execute;
            p03ccmdinit (xaSQLDesc^, sqcca, gae, cmdtyp);
            p03cpparsid (sqlrap, gae, sqcparsid, sqlemp);
            pr03cPutResultName(xaSQLDesc^.ConDesc, sqcca.sqlresn, sqlemp);
            p11pparsidtrace (sqcca, sqcparsid, 1);
            p11_isqcda_parameter_put (sqcca, gae, sqcda, looprec);
            (* sollte in mf-area sp?ater 25.2.94 *)
            p12bexecute (sqcca, gae, sqcda, cmdfetch,
                  fa_entry, sqcparsid, sqcrowcount);
            IF   cmdfetch <> cpr_is_true
            THEN
                BEGIN
                WITH sqlgap^, sqlrap^, rasqlldp.vtypep^ DO
                    IF  NOT ldallsend
                    THEN
                        BEGIN
                        p03reqrecpacket (sqcca, sqlcxap^, gae);
 (* http://pts:1080/webpts?wptsdetail=yes&ErrorType=1&ErrorID=1128557 *)
                        p03sABAPStream  (sqcca, sqlcxap^, gae);
                        IF  (sqlcode = 0) OR (sqlcode = 100)
                        THEN
                            BEGIN
                            p03cresultcountget (sqlrap, gae, sqlerrd[3]);
                            pr01cResultNameGet(sqlrap, gae, sqcca.sqlresn, sizeof(sqcca.sqlresn));
                            END;
                        (*ENDIF*) 
                        IF  sqlcode = 0
                        THEN
                            p03cresultcountget (sqlrap, gae, sqlerrd[3]);
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            p12baexecute (sqcca, gae, sqcparsid);
            IF   cmdfetch = cpr_is_init
            THEN
                p12bgetmfetch (sqcca, gae, sqcda, fa_entry, sqcrowcount);
            (*ENDIF*) 
            p03returncodeget (sqcca, sqlcxap^);
            p11_osqcda_parameter_put (sqcca, gae, sqcda, looprec);
            pr04LongLvcInitRec (sqcca, lvcrec);
            pr04LongOutputLvc (sqcca, sqlcxap^, gae, looprec);
            IF  (sqlcode = 0) AND (lvcrec.lvcerror <> cpr_p_ok)
            THEN
                p08runtimeerror (sqcca, sqlcxap^, lvcrec.lvcerror);
            (*ENDIF*) 
            IF  (radbmode = cpr_kind_oracle)
                OR (radbmode = cpr_kind_sapr3)
            THEN
                WITH looprec, sqcda.orada DO
                    BEGIN
                    (* nur oraclemode hat im call interface array cmd's *)
                    (* bei mass-cmd varpart ?uberlauf offset neu belegen *)
                    (* alle abgearbeitet wird sqlloop = 0, *)
                    (* sqlerrd[3]  wird akumuliert         *)
                    sqlloop := sqlloop + sqloffset  - (lpindi);
                    sqloffset := lpindi;
                    retsqlerrd3 := retsqlerrd3 + sqlerrd [3];
                    IF  sqlloop = 0
                    THEN
                        sqlerrd [3] := retsqlerrd3;
                    (*ENDIF*) 
                    IF  (sqcparsid [cpr_p_precom_index]
                        = chr (csp1_p_mfetch_found))
                    THEN
                        (******1.10.95 *)
                        IF  (looprec.lpnext = cpr_is_false)
                            AND (looprec.lpcnt > 1)
                            AND (looprec.lpindo < looprec.lpmax)
                        THEN
                            BEGIN
                            sqlemp^.ereturncode := 100;
                            sqlemp^.eerrorpos  := 0;
                            nam := 'ROW NOT FOUND     ';
                            s10mv (mxsp_name, mxsp_c70, @nam, 1,
                                  @sqlemp^.etext, 1, mxsp_name);
                            sqlemp^.etextlen := mxsp_name;
                            p03returncodeget (sqcca, sqlcxap^);
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
        UNTIL
            (looprec.lpnext = cpr_is_false);
        (*ENDREPEAT*) 
        p01xtimetrace (sqcca, sqlcxap^, gae);
        IF   sqlcode = 0
        THEN
            IF  (sqcparsid [cpr_p_precom_index] = chr(csp1_p_release_found))
            THEN
                p03sqlrelease (sqlrap, sqlgap, gae, sqlemp);
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p11shortfieldparameterput (VAR sqcca : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcda  : sqldavrec;
            again      : boolean);
 
VAR
      reclen   : tsp00_Int2;
      dapoint  : sqldapointer;
      da2point : sqldb2pointer;
      orapoint : sqlorapointer;
      fetchdesc : boolean;
 
BEGIN
WITH sqcca, sqlrap^, sqlcxap^  DO
    BEGIN
    IF   (xakano = cpr_com_fetch_describe)
        OR   (xakano = cpr_com_mfetch_describe)
    THEN
        BEGIN
        fetchdesc := true
        END
    ELSE
        fetchdesc := false;
    (*ENDIF*) 
&   ifdef TRACE
    m90int(pc,' radbmode   ',ord(radbmode));
&   endif
    IF   (sqlcode = 0)
    THEN
        CASE radbmode OF
            cpr_kind_internal :
                WITH  sqcda.sqldb DO
                    BEGIN
                    dapoint := p08g1addr (sqcda.sqldb);
                    reclen := p04sqldsfi(sqcca, sqlcxap^, NIL, dapoint, fetchdesc, again, Describe_Params_epr00);
                    END;
                (*ENDWITH*) 
            cpr_kind_db2 :
                WITH  sqcda.db2 DO
                    BEGIN
                    da2point := p08g2addr (sqcda.db2);
                    reclen := p04db2dsfi(sqcca, sqlcxap^, NIL, da2point, fetchdesc, again, Describe_Params_epr00);
                    END;
                (*ENDWITH*) 
            cpr_kind_oracle, cpr_kind_sapr3 :
                WITH  sqcda.orada DO
                    BEGIN
&                   ifdef TRACE
                    m90int4 (pc, 'ora_n       ', ora_n );
&                   endif
                    orapoint := p08g3addr (sqcda.orada);
                    reclen := p04oradsfi(sqcca, sqlcxap^, NIL, orapoint, fetchdesc, Describe_Params_epr00);
                    END;
                (*ENDWITH*) 
            OTHERWISE:
                BEGIN
                END;
            END;
        (*ENDCASE*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p11_isqcda_parameter_put (VAR sqcca : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcda : sqldavrec;
            VAR looprec : tpr_sqlloop);
 
VAR
      dapoint  : sqldapointer;
      da2point : sqldb2pointer;
      orapoint : sqlorapointer;
 
BEGIN
WITH sqcca, sqlcxap^, sqlrap^ DO
    IF  (gae.gareference <> 0)
    THEN
        IF  sqcca.sqlrap^.radbmode = cpr_kind_internal
        THEN
            BEGIN
            dapoint := p08g1addr (sqcda.sqldb);
            sqcca.sqlcxap^.xasqldap.sqldaptr := dapoint;
            p04sqldin (sqcca, sqcca.sqlcxap^, gae, dapoint, looprec );
            END
        ELSE
            IF  (sqcca.sqlrap^.radbmode = cpr_kind_oracle)
                OR (sqcca.sqlrap^.radbmode = cpr_kind_sapr3)
            THEN
                BEGIN
                orapoint := p08g3addr (sqcda.orada);
                sqcca.sqlcxap^.xasqldap.oradaptr := orapoint;
                p04oradin (sqcca, sqcca.sqlcxap^, gae, NIL, orapoint, looprec);
                END
            ELSE
                BEGIN
                da2point := p08g2addr (sqcda.db2);
                sqcca.sqlcxap^.xasqldap.db2daptr := da2point;
                p04db2din (sqcca, sqcca.sqlcxap^, gae, NIL, da2point);
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p11_osqcda_parameter_put (VAR sqcca : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcda : sqldavrec;
            VAR looprec : tpr_sqlloop);
 
VAR
      dapoint  : sqldapointer;
      da2point : sqldb2pointer;
      orapoint : sqlorapointer;
      part_ptr : tsp1_part_ptr;
 
BEGIN
WITH sqcca, sqlcxap^, sqlrap^ DO
    IF  (gae.gareference <> 0)
    THEN
        BEGIN
        p03find_part (sqcca.sqlrap, sp1pk_data, part_ptr);
        IF  part_ptr <> NIL
        THEN
            IF  sqcca.sqlrap^.radbmode = cpr_kind_internal
            THEN
                BEGIN
                dapoint := p08g1addr (sqcda.sqldb);
                p04sqldout (sqcca, sqcca.sqlcxap^, gae, dapoint, looprec);
                END
            ELSE
                IF  (sqcca.sqlrap^.radbmode = cpr_kind_oracle)
                    OR (sqcca.sqlrap^.radbmode = cpr_kind_sapr3)
                THEN
                    BEGIN
                    orapoint := p08g3addr (sqcda.orada);
                    p04oradout(sqcca, sqcca.sqlcxap^, gae, orapoint, looprec);
                    END
                ELSE
                    BEGIN
                    da2point := p08g2addr (sqcda.db2);
                    p04db2dout (sqcca, gae, da2point);
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p11getxsqcerr (varno : tsp00_Int2;
            vartyp        : tsp00_Int2;
            VAR sqcda     : sqldavrec;
            VAR sqcerr : tsp00_Int2);
 
BEGIN
WITH sqcda.sqldb DO
    BEGIN
    sqcerr := cpr_c_ok;
    IF   (varno < 1) OR (varno > sqlmax)
    THEN
        sqcerr := cpr_c_varnowrong
    ELSE
        WITH sqlvar [varno] DO
            BEGIN
            CASE vartyp OF
                cpr_vint2, cpr_vint4, cpr_vuns2, cpr_vuns4,
                cpr_vreal4, cpr_vreal8, cpr_vdecimal, cpr_vzoned :
                    BEGIN
                    IF   (coltype = ord(dfixed))
                        OR (coltype = ord(dfloat))
                        OR (coltype =  ord(dvfloat))
                        OR (coltype = ord(dcha))
                        OR (coltype = ord(dche))
                        OR (coltype = ord(dsmallint))
                        OR (coltype = ord(dinteger))
                    THEN
                        hostvartype := vartyp
                    ELSE
                        sqcerr := cpr_c_incompatible
                    (*ENDIF*) 
                    END;
                cpr_vchar, cpr_vcharc, cpr_vbuf,
                cpr_vansichar, cpr_vansicharc :
                    BEGIN
                    IF   (coltype = ord(dunknown))
                    THEN
                        sqcerr := cpr_c_incompatible
                    ELSE
                        hostvartype := vartyp
                    (*ENDIF*) 
                    END;
                OTHERWISE:
                    BEGIN
                    IF  ((coltype = ord(dfixed))
                        OR (coltype = ord(dfloat))
                        OR (coltype =  ord(dvfloat)))
                    THEN
                        sqcerr := cpr_c_incompatible
                    ELSE
                        hostvartype := vartyp
                    (*ENDIF*) 
                    END;
                END;
            (*ENDCASE*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p11againtrace (VAR sqcca : sqlcatype;
            art : integer;
            again : boolean);
 
VAR
      nam     : tsp00_Name;
 
BEGIN
WITH sqcca, sqlrap^, rasqltap^   DO
    IF   (tatrout <> cpr_trace_off)
    THEN
        BEGIN
        (* ausgabe art = komando again  *)
        CASE art OF
            1 :
                IF   again
                THEN
                    nam := 'PARSE  : AGAIN :  '
                ELSE
                    nam := 'PARSE  : CMD   :  ';
                (*ENDIF*) 
            2 :
                IF   again
                THEN
                    nam := 'EXECUTE: AGAIN :  '
                ELSE
                    nam := 'EXECUTE: CMD   :  ';
                (*ENDIF*) 
            3 :
                IF   again
                THEN
                    nam := 'DESCRIBE:AGAIN :  '
                ELSE
                    nam := 'DESCRIBE:CMD   :  ';
                (*ENDIF*) 
            4 :
                nam := 'PARSE ARRAY CMD:  ';
            5 :
                nam := 'PUTLONG: CMD   :  ';
            6 :
                nam := 'GETLONG: CMD   :  ';
            OTHERWISE:
                IF   again
                THEN
                    nam := '       : AGAIN :  '
                ELSE
                    nam := '       : CMD   :  ';
                (*ENDIF*) 
            END;
        (*ENDCASE*) 
        s10mv (mxsp_name, mxsp_c256, @nam, 1,
              @tastr80, 1, mxsp_name);
        tastr80l := mxsp_name;
        p08vfwritetrace (sqlrap);
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p11pparsidtrace (VAR sqcca : sqlcatype;
            VAR parsid : tpr_parsid;
            inout : integer);
 
VAR
      nam     : tsp00_Name;
      err     : boolean;
 
BEGIN
WITH sqcca,  sqlrap^, rasqltap^   DO
    IF   (tatrout <> cpr_trace_off)
    THEN
        BEGIN
        (* ausgabe art = komando again  *)
        CASE inout OF
            1 :
                nam := 'PARSEID: INPUT :  ';
            2 :
                nam := 'PARSEID: OUTPUT:  ';
            OTHERWISE:
                nam := 'PARSEID:       :  ';
            END;
        (*ENDCASE*) 
        s10mv (mxsp_name, mxsp_c256, @nam, 1,
              @tastr80, 1, mxsp_name);
        tastr80l := mxsp_name;
        p01formatparsid(parsid, tastr80, tastr80l);
        p08vfwritetrace (sqlrap);
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p11trace  (VAR sqcca   : sqlcatype;
            VAR nam : tsp00_Name );
 
BEGIN
WITH sqcca, sqlrap^, rasqltap^ DO
    IF   tatraceno <> 0
    THEN
        BEGIN
        tastr80  [1]  := bsp_c1;
        tastr80l  := 1;
        p08vfwritetrace (sqlrap);
        tastr80l  := mxsp_name;
        s10mv (mxsp_name, mxsp_c256, @nam, 1, @tastr80, 1, tastr80l);
        p08vfwritetrace (sqlrap);
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p11resultnget   (VAR sqcca : sqlcatype;
            VAR gae : sqlgaentry);
 
VAR
      part_ptr : tsp1_part_ptr;
      len  : integer;
 
BEGIN
WITH sqcca, sqlrap^, sqlgap^ DO
    BEGIN
    sqlresn := bsp_knl_identifier;
    IF  sqlcode = 0
    THEN
        BEGIN
        p03cresultcountget (sqlrap, gae, sqlerrd[3]);
        p03find_part (sqlrap, sp1pk_resulttablename, part_ptr);
        IF  part_ptr <> NIL
        THEN
            WITH  part_ptr^, sp1p_part_header  DO
                BEGIN
                IF  sp1p_buf_len > sizeof(sqlresn)
                THEN
                    len := sizeof(sqlresn)
                ELSE
                    len := sp1p_buf_len;
                (*ENDIF*) 
                s10mv (sp1p_buf_size, sizeof(sqlresn),
                      @sp1p_buf, 1, @sqlresn, 1, len);
                len := s30len2 (sqlresn, chr(0), sizeof(sqlresn));
                IF  len = 0
                THEN
                    sqlresn := bsp_knl_identifier;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p11initlooprec (VAR looprec : tpr_sqlloop);
 
BEGIN
WITH looprec  DO
    BEGIN
    lpcnt    := 0;
    lperrd3  := 0;
    lpindi   := 0;
    lpindo   := 0;
    lpfirsti := cpr_is_true;
    lpfirsto := cpr_is_true;
    lpnext   := cpr_is_false;
    lprecli  := 0;
    lpreclo  := 0;
    lperri   := cpr_p_ok;
    lperro   := cpr_p_ok;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p11checkarraycommand   (VAR sqcca   : sqlcatype;
            VAR gae : sqlgaentry;
            VAR sqcdbno   : tsp00_Int2;
            VAR sqcstmlen : tsp00_Int4;
            VAR sqcstmbuf : tsp00_MoveObj;
            encodingType : tpr05_StringEncoding;
            VAR sqcda     : sqldavrec;
            VAR sqcparsid : tpr_parsid;
            VAR arrayparsid : boolean);
 
VAR
      com_kind : integer;
      cmdtyp   : tsp1_cmd_mess_type;
      ergn     : tsp00_KnlIdentifier;
      decl_cmd : boolean;
      AnalyzeDesc : tpr05_StmtAnalysisDesc;
      dummyka : ^sqlkaentry;
 
BEGIN
com_kind := ord (sqcparsid [cpr_p_precom_index] );
IF  NOT (com_kind in [ csp1_p_mfetch_found,
    csp1_p_mass_command,
    csp1_p_mselect_found,
    csp1_p_reuse_mselect_found,
    csp1_p_for_upd_mselect_found,
    csp1_p_reuse_upd_mselect_found] )
THEN
    WITH sqcca, sqlrap^, sqlgap^ DO
        BEGIN
        (* kommando in array command umsetzen und neu parsen *)
        raactsession := sqcdbno;
        cmdtyp := sp1m_parse;
        pr11cGetsqcstm (sqcca, sqlcxap^.xaSQLDesc^.ConDesc, sqlcxap^.xaSQLDesc^.PacketEncoding,
              cmdtyp, sqcstmlen, sqcstmbuf, encodingType, AnalyzeDesc);
        WITH sqlcxap^ DO
            IF   (xakano = cpr_com_fetch_describe)
                OR  (xakano = cpr_com_mfetch_describe)
            THEN
                BEGIN
                pr11cFetchDescribe (sqcca, xaSQLDesc^.ConDesc,
                      sqlcxap^.xaSQLDesc^.PacketEncoding, sqcda, AnalyzeDesc)
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
        rasegptr^.sp1c_mass_cmd := true;
        (*  mass command *)
        p03cmdtrace (sqcca.sqlrap, gae, 1, cpr_com_empty, NIL);
        p11againtrace (sqcca, 4, true);
        p03reqrecpacket (sqcca, sqlcxap^, gae);
        p03returncodeget (sqcca, sqlcxap^);
        sqlerrd [3] := 0;
        p03gparsid (sqcca.sqlrap, sqcca.sqlemp, sqcparsid, gae.gaKnlSessionID);
        p11pparsidtrace (sqcca, sqcparsid, 2);
        arrayparsid := false;
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
