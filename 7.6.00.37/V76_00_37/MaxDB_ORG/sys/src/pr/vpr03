.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.tt 1 $SQL$Project Distributed Database System$VPR03$
.tt 2 $$$
.TT 3 $$SQLDB-Request-Interface$2001-03-15$
***********************************************************
.nf
 
 .nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
.nf
.sp
MODULE  : SQLDB-Auftrags-Schnittstelle
=========
.sp
Purpose : SQLDB request interface.
          Erstellen und versenden von Auftr?agen an die
          SQLDB-Maschine, empfangen und interpretieren
          der Auftrags-Ergebnisse
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              p03cancel (VAR sqlca : sqlcatype;
                    VAR gae    : sqlgaentry);
 
        PROCEDURE
              p03modulnameput  (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR ga : sqlgaentry;
                    VAR ka : sqlkaentry);
 
        PROCEDURE
              p03dropparsid  (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR ga    : sqlgaentry;
                    VAR parsid : tpr_parsid);
 
        PROCEDURE
              p03psqllinecmd (VAR sqlca : sqlcatype;
                    VAR s : tpr_sqlline;
                    anf : integer;
                    l_s : integer;
                    l_smax : integer;
                    part_ptr : tsp1_part_ptr);
 
        PROCEDURE
              p03reqrecpacket  (
                    VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR ga : sqlgaentry);
 
        PROCEDURE
              p03partptrinit  (sqlrap : sqlrapointer);
 
        PROCEDURE
              p03find_part  (sqlrap : sqlrapointer;
                    part_kind        : tsp1_part_kind;
                    VAR part_ptr     : tsp1_part_ptr);
 
        PROCEDURE
              p03gparsid (sqlrap : sqlrapointer;
                    sqlemp : sqlempointer;
                    VAR parsid : tpr_parsid;
                    VAR SessionID : tpr00_SessionID);
 
        PROCEDURE
              p03gselparsid (sqlrap : sqlrapointer;
                    sqlemp : sqlempointer;
                    VAR parsid : tpr_parsid;
                    VAR SessionID : tpr00_SessionID);
 
        PROCEDURE
              p03returncodeget (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype);
 
        PROCEDURE
              p03traceerror (sqlrap : sqlrapointer;
                    sqlemp : sqlempointer);
 
        PROCEDURE
              p03invaliderr (sqlrap : sqlrapointer;
                    art : tsp00_Int2;
                    inout : tsp00_Int2;
                    VAR buf   : tpr_buffer;
                    vatyp : tsp00_Int2;
                    valen : tsp00_Int4;
                    vafrac: tsp00_Int2);
 
        PROCEDURE
              p03encrypt (VAR clearname : tsp00_Name;
                    VAR crypt : tsp00_CryptName);
 
        PROCEDURE
              p03putsysprofbuf (sqlrap : sqlrapointer);
 
        PROCEDURE
              p03sysproferror  (VAR sqlca : sqlcatype;
                    VAR gae    : sqlgaentry);
 
        PROCEDURE
              p03p1cmd  (part_ptr : tsp1_part_ptr;
                    VAR s : tsp00_C24;
                    l_s : integer);
 
        PROCEDURE
              p03getparameteraddr (VAR sqlca : sqlcatype;
                    VAR sqlxa : sqlxatype;
                    VAR paix : integer;
                    VAR cmcnt : integer;
                    VAR vaaddr : tpr_vtypepointer;
                    VAR vaind  : integer;
                    VAR indaddr : tpr_vtypepointer;
                    VAR indind  : integer);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              C-Type-Checker-Module  : VPR102;
 
        PROCEDURE
              pr03PacketReqRec(ConDesc : tpr01_ConDesc;
                    sqlemp : sqlempointer);
 
        PROCEDURE
              p03sqlrelease  (sqlrap : sqlrapointer;
                    sqlgap :  sqlgapointer;
                    VAR ga : sqlgaentry;
                    errmsg : sqlempointer);
 
        PROCEDURE
              p03ccmdinit (
                    VAR xaSQLDesc : tpr01_SQLDesc;
                    VAR sqlca : sqlcatype;
                    VAR gae : sqlgaentry;
                    m_type   : tsp1_cmd_mess_type);
 
        PROCEDURE
              p03creqrecpacket (sqlrap : sqlrapointer;
                    VAR ga : sqlgaentry;
                    errmsg : sqlempointer);
 
        PROCEDURE
              p03clzuerror (VAR ga : sqlgaentry;
                    lzu_prog: integer;
                    errmsg  : sqlempointer);
 
        PROCEDURE
              p03csqlemptosqlca (VAR sqlca : sqlcatype;
                    sqlemp : sqlempointer);
 
        PROCEDURE
              p03warningset (sqlemp : sqlempointer;
                    warnset : tsp00_C2);
 
        PROCEDURE
              p03cseterror (sqlemp : sqlempointer;
                    error : tpr_runtime_errors);
 
        PROCEDURE
              p03cresultcountget (sqlrap :sqlrapointer;
                    VAR ga : sqlgaentry;
                    VAR resultcount : tsp00_Int4);
 
        PROCEDURE
              pr03PartInitCache  (sqlrap : sqlrapointer);
 
        FUNCTION
              pr03PartFind  (sqlrap : sqlrapointer;
                    part_kind        : tsp1_part_kind) : tsp1_part_ptr;
 
        PROCEDURE
              sqlacancel (reference  : tsp00_Int4);
 
        FUNCTION
              pr01cIsComType(VAR xaSQLDesc : tpr01_SQLDesc;
                    ComType : tpr00_ComTypeEnum) : boolean;
 
        PROCEDURE
              pr06ParseIdDropDirect(ConDesc : tsp00_Addr;
                    VAR parsid : tpr_parsid);
&       ifdef TRACE
 
        PROCEDURE
              m90int (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : integer);
 
        PROCEDURE
              m90int2(layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : tsp00_Int2);
 
        PROCEDURE
              m90int4 (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : tsp00_Int4);
 
        PROCEDURE
              m90hexint4 (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    int : tsp00_Int4);
 
        PROCEDURE
              m90hostname (layer : tsp00_ToolLayer;
                    nam : tsp00_Sname;
                    h : tsp00_NodeId);
 
        PROCEDURE
              m90addr (
                    layer    : tsp00_ToolLayer;
                    nam      : tsp00_Sname;
                    bufaddr  : tsp1_part_ptr);
 
        PROCEDURE
              m90buf (layer : tsp00_ToolLayer;
                    VAR buf : tsp1_packet_ptr;
                    von,bis : integer);
 
        PROCEDURE
              m90buf1 (layer : tsp00_ToolLayer;
                    VAR buf : tsp_packet;
                    von,bis : integer);
 
        PROCEDURE
              m90buf2 (layer : tsp00_ToolLayer;
                    VAR buf : char;
                    von,bis : integer);
 
        PROCEDURE
              m90buf3 (layer : tsp00_ToolLayer;
                    VAR buf : tsp00_TermId;
                    von,bis : integer);
 
        PROCEDURE
              m90buf4 (
                    layer   : tsp00_ToolLayer;
                    VAR buf : tsp4_xuser_record;
                    pos_anf : integer;
                    pos_end : integer);
 
        PROCEDURE
              m90buf5 (
                    layer   : tsp00_ToolLayer;
                    VAR buf : tsp00_C70;
                    pos_anf : integer;
                    pos_end : integer);
 
        PROCEDURE
              m90name (layer : tsp00_ToolLayer;
                    nam : tsp00_Name);
&       endif
 
      ------------------------------ 
 
        FROM
              Runtime-Stringroutinen  : VPR05;
 
        PROCEDURE
              p05inttochr12 (int : integer;
                    VAR chr12 : tsp00_C12);
 
      ------------------------------ 
 
        FROM
              Precompiler_Runtime_Routinen   : VPR08;
 
        PROCEDURE
              p08vfwritetrace (sqlrap : sqlrapointer);
 
      ------------------------------ 
 
        FROM
              Encrypting   : VSP02;
 
        PROCEDURE
              s02applencrypt (
                    pw_clear     : tsp00_Name;
                    VAR pw_crypt : tsp00_CryptName);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill   : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedOverlappingMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26finish_part (packet_ptr : tsp1_packet_ptr;
                    VAR finish_part      : tsp1_part);
 
        PROCEDURE
              s26new_part_init (packet_ptr : tsp1_packet_ptr;
                    VAR segm               : tsp1_segment;
                    VAR new_part_ptr       : tsp1_part_ptr);
 
        PROCEDURE
              s26nextpart (VAR part_ptr : tsp1_part_ptr);
 
        FUNCTION
              s26size_new_part (packet_ptr : tsp1_packet_ptr;
                    VAR segm : tsp1_segment) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              GET-Conversions   : VSP40;
 
        PROCEDURE
              s40gbyte (VAR buf    : tpr_buffer;
                    pos    : tsp00_Int4;
                    len    : integer;
                    VAR dest   : tsp00_C256;
                    dpos   : tsp00_Int4;
                    dlen   : integer;
                    VAR truncated  : boolean);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              sqlarelease;
 
              tsp00_Int4             tsp00_TaskId
 
        PROCEDURE
              sqldattime;
 
              tsp00_Date      tsp00_C8
              tsp00_Time      tsp00_C8
 
        PROCEDURE
              s02applencrypt;
 
              tsp00_CryptPw       tsp00_CryptName
 
        PROCEDURE
              s40gbyte;
 
              tsp00_MoveObj       tpr_buffer
              tsp00_MoveObj       tsp00_C256
&             ifdef TRACE
 
        PROCEDURE
              m90hostname;
 
              tsp00_VFilename  tsp00_NodeId
 
        PROCEDURE
              m90buf;
 
              tsp00_Buf tsp1_packet_ptr
 
        PROCEDURE
              m90addr;
 
              tsp00_BufAddr       tsp1_part_ptr
 
        PROCEDURE
              m90buf1;
 
              tsp00_Buf tsp_packet
 
        PROCEDURE
              m90buf2;
 
              tsp00_Buf char
 
        PROCEDURE
              m90buf3;
 
              tsp00_Buf tsp00_TermId
 
        PROCEDURE
              m90buf4;
 
              tsp00_Buf tsp4_xuser_record
 
        PROCEDURE
              m90buf5;
 
              tsp00_Buf tsp00_C70
&             endif
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1985-12-11
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2001-03-15
.sp
***********************************************************
.sp
.cp 20
.fo
.oc _/1
Specification:
.sp 2
The precompiler runtime environment implements its
database accesses via a request interface, which is described
in document ORDER INTERFACE.
.sp
The procedures of this module define the request interface
as an abstract data type.
.sp 2;.cp 10;.nf
Overview:
========
.sp;.cp 6
PROCEDURE  p03cancel:
.sp
Ruft f?ur die aktuelle Session die LZU-procedure sqlacancel auf.
Das Bedeutet der Server-Process im Kern
soll abgegrochen werde.
.sp 2;.cp 8
PROCEDURE  p03modulnameput:
.sp
Legt im Aufragspaket einen Part  sp1pk_modulename an, und
einen Part sp1pk_appl_parameter_description. Es sind Angaben
?uber die Definitionen der Hostvariblen zu den zugeh?oriben
Parametern im Kommando-Part.
.nf
  Description :   | 1B  |  1B  |  2B  |
                  |-----|------|------|
  Hostvariable    | Typ | frac | len  |
.fo
.sp 2;.cp 8
PROCEDURE  p03dropparsid:
.sp
Initalisiert ein Auftragspacket mit dem Kommando 'drop parsid',
mit der angegeben parsid.
Sendent den Auftrag an den Kern und setzt die parsid auf Null.
.sp 2;.cp 8
PROCEDURE  p03psqllinecmd:
.sp
Schreibt eine sqlline s, der L?ange l_s, an die Position anf,
in den angegeben Partteil des Auftragspacket und erh?oht die
buffer_len.
.sp 2;.cp 8
PROCEDURE  p03reqrecpacket:
.sp
Enth?alt ein Auftragspacket ein Kommando an den Kern, werden
noch vorhandene ?uberfl?ussige Zeichen aus dem Kommando entfernt.
Mit der Procedure p03creqrecpacket wird der
Auftrag an den Kern gesendet zur Verabeitung mit eventueller
Fehlerbehandung.
Ist ein Fehler aufgetreten wird er in die SQLCA-area gebracht.
.sp 2;.cp 8
PROCEDURE  p03gparsid:
.sp
Sieht nach ob in einem Auftrags-segment ein sp1pk_parsid Part
existiert. Bei ja wird die Parsid damit belegt, andernfall auf
Null gesetzt.
.sp 2;.cp 8
PROCEDURE  p03returncodeget:
.sp
Setzt in p03errorget Kommando- und Mode-spezifisch sqlcode, sqlwarning und
sqlerrd[3] richtig. Schreibt die Fehler in SQLCA und gibt die Information
eventuell in Trace.pct aus.
.sp 2;.cp 8
PROCEDURE  p03traceerror:
.sp
Screibt in den Trace.pct SQLCODE und WARNINGS.
.sp 2;.cp 8
PROCEDURE  p03invaliderr:
.sp
Screibt in den Trace.pct bei Art 1 Hostvariable, bei 2 Kernvariable
Informationen Datentyp, Length, Frac. Bei Input Variable wird
Die Hostvariable Hexadecimal maximal20 Bytelang ausgegeben,
bei Output Variable die Angabe der Variablen von Kern.
.sp 2;.cp 8
PROCEDURE  p03encrypt:
.sp
Verschl?usselt ein Password.
.sp 2;.cp 8
PROCEDURE  p03putsysprofbuf:
.sp
Rettet den Kommandostring f?ur Sysprofile Eintr?age in einem
Zwischen Puffer mit der Addr in sqlra.raprofstmp.
.sp 2;.cp 8
PROCEDURE  p03sysproferror:
.sp
Nach den Sysprofile-Auftr?agen wird der LZU- oder Kern-Error
in die SQLEM-area geschrieben.
.sp 2;.cp 8
PROCEDURE  p03p1cmd:
.sp
Schreibt einen String der L?ange l_s in den Part-buf und
erh?oht entsprechend die Buffer-len.
.sp 2;.cp 8
PROCEDURE  p03getparameteraddr:
.sp
Sucht ?uber den SQLPA-area Index paix  die Hostvariablen und
Indicator Adresse, den Index in die SQLVA1-area und die Anzahl der
Elemente.
.sp 2;.cp 8;.nf
.CM *-END-* specification -------------------------------
.sp 2.fo
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      user_already_connected  = -8002;
      sqlcode_rownotfound     =  100;
      maxcryptl               = 24;
 
 
(*------------------------------*) 
 
PROCEDURE
      p03cancel ( VAR sqlca : sqlcatype;
            VAR gae    : sqlgaentry);
 
VAR
      int : tsp00_Int2;
      chr12 : tsp00_C12;
      nam   : tsp00_Name;
 
BEGIN
WITH sqlca, sqlrap^, sqlemp^, sqlgap^ DO
    BEGIN
    elzu := sp1ce_crash;
    IF  gae.gareference <> 0
    THEN
        sqlacancel (gae.gareference);
    (*ENDIF*) 
    SAPDB_PascalForcedFill (mxsp_c70, @etext, 1, mxsp_c70, bsp_c1);
    nam := 'session number    ';
    SAPDB_PascalForcedMove (mxsp_c18, mxsp_c70, @nam, 1,
          @etext, 1, mxsp_c18 );
    int := raactsession;
    p05inttochr12 (int, chr12);
    SAPDB_PascalForcedMove (mxsp_c12, mxsp_c70, @chr12, 2,
          @etext, mxsp_c18-1, 5 );
    etextlen   := mxsp_c18 + 4;
    p03clzuerror (gae, cpr_lzu_cancel, sqlemp);
    IF  eprerr <> cpr_p_ok
    THEN
        p03cseterror (sqlemp, eprerr);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;  (* p03cancel *)
 
(*------------------------------*) 
 
PROCEDURE
      p03dropparsid  (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ga    : sqlgaentry;
            VAR parsid : tpr_parsid);
 
BEGIN
pr06ParseIdDropDirect (sqlxa.xaSQLDesc^.ConDesc, parsid);
END;
 
(*------------------------------*) 
 
PROCEDURE
      p03p1cmd  (part_ptr : tsp1_part_ptr;
            VAR s : tsp00_C24;
            l_s : integer);
 
BEGIN
WITH part_ptr^  DO
    BEGIN
    SAPDB_PascalForcedOverlappingMove (mxsp_c24, sp1p_buf_size,
          @s, 1, @sp1p_buf, sp1p_buf_len+1, l_s);
    sp1p_buf_len := sp1p_buf_len + l_s
    END
(*ENDWITH*) 
END;  (* p03p1cmd *)
 
(*------------------------------*) 
 
PROCEDURE
      p03psqllinecmd  (VAR sqlca : sqlcatype;
            VAR s : tpr_sqlline;
            anf : integer;
            l_s : integer;
            l_smax : integer;
            part_ptr : tsp1_part_ptr);
 
BEGIN
WITH sqlca, part_ptr^   DO
    IF   sp1p_buf_len + l_s > sp1p_buf_size
    THEN
        p03cseterror (sqlemp, cpr_request_area_overflow)
    ELSE
        BEGIN
        SAPDB_PascalForcedOverlappingMove (l_smax, sp1p_buf_size,
              @s, anf, @sp1p_buf, sp1p_buf_len+1, l_s);
        sp1p_buf_len := sp1p_buf_len + l_s
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p03modulnameput  (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ga : sqlgaentry;
            VAR ka : sqlkaentry);
 
VAR
      i : integer;
      pos : integer;
      len : tsp_int_map_c2;
      cnt    : integer;
      paind  : integer;
      vaind  : integer;
      indind : integer;
      vaaddr : tpr_vtypepointer;
      indaddr : tpr_vtypepointer;
      vaddr   : tpr_vtypepointer;
      iaddr   : tpr_vtypepointer;
      part_ptr : tsp1_part_ptr;
 
BEGIN
WITH sqlca, sqlrap^, sqlxa, sqlgap^  DO
    BEGIN
    IF  s26size_new_part(ga.gareqptr, rasegptr^) < sizeof(xamodn)
    THEN
        p03cseterror (sqlemp, cpr_request_area_overflow)
    ELSE
        BEGIN
        s26new_part_init (ga.gareqptr, rasegptr^, part_ptr);
        part_ptr^.sp1p_part_header.sp1p_part_kind :=  sp1pk_modulname;
        part_ptr^.sp1p_part_header.sp1p_buf_len   :=  0;
        rasegmpartptr [ord(sp1pk_modulname)+1] := part_ptr;
        WITH part_ptr^, sp1p_part_header  DO
            BEGIN
            (* ADIS 1001441 *)
            IF   sp1p_buf_len + sizeof(xamodn) > sp1p_buf_size
            THEN
                p03cseterror (sqlemp, cpr_request_area_overflow)
            ELSE
                BEGIN
                SAPDB_PascalForcedMove (sizeof(xamodn), sp1p_buf_size,
                      @xamodn, 1, @sp1p_buf, 1, sizeof(xamodn));
                sp1p_buf_len := sizeof(xamodn);
                END;
            (*ENDIF*) 
            s26finish_part (ga.gareqptr, part_ptr^);
            END;
        (*ENDWITH*) 
        IF  ka.kapaindex > 0
        THEN
            BEGIN
            IF  s26size_new_part(ga.gareqptr, rasegptr^) > 4
            THEN
            begin
            s26new_part_init (ga.gareqptr, rasegptr^, part_ptr);
            part_ptr^.sp1p_part_header.sp1p_part_kind
                  :=  sp1pk_appl_parameter_description;
            part_ptr^.sp1p_part_header.sp1p_buf_len   :=  0;
            rasegmpartptr [ord(sp1pk_appl_parameter_description)+1]
                  := part_ptr;
            WITH part_ptr^, sp1p_part_header  DO
                BEGIN
                (* shortfiled f?ur parse in varpart belegen *)
                pos := 1;
                paind  := ka.kapaindex;
                sp1p_arg_count := 0;
                WHILE (paind <= ka.kapaindex + ka.kapacount - 1) DO
                    BEGIN
                    p03getparameteraddr (sqlca, sqlxa, paind (* paindex *),
                          cnt, vaddr, vaind,
                          iaddr, indind );
&                   ifdef TRACE
                    m90int  (pc, 'paind       ', paind );
                    m90int  (pc, 'cnt         ', cnt   );
                    m90int  (pc, 'vaind       ', vaind   );
                    m90int  (pc, 'indind      ', indind  );
                    m90int  (pc, 'vaddr       ', vaddr.intaddr );
                    m90int  (pc, 'iaddr       ', iaddr.intaddr );
&                   endif
                    paind := paind + 1;
                    vaaddr  := vaddr;
                    indaddr := iaddr;
                    FOR i := 1 TO cnt DO
                        WITH  sqlv1p^ [vaind+i-1],
                             sqlv2p^ [va1indva2_sc] DO
                            IF  pos + 4 < sp1p_buf_size
                            THEN
                                BEGIN
                                sp1p_arg_count := sp1p_arg_count + 1;
                                sp1p_buf [pos  ] :=  chr (0);
                                sp1p_buf [pos+1] :=  chr (0);
                                sp1p_buf [pos+2] :=  chr (0);
                                sp1p_buf [pos+3] :=  chr (0);
                                CASE va2typ OF
                                    cpr_vint2, cpr_vuns2 :
                                        BEGIN
                                        sp1p_buf [pos]   := chr (ord(dsmallint));
                                        len.map_int := cpr_numblen_int2;
                                        END;
                                    cpr_vint4, cpr_vuns4 :
                                        BEGIN
                                        sp1p_buf [pos] := chr (ord(dinteger));
                                        len.map_int := cpr_numblen_int4;
                                        END;
                                    cpr_vreal4 :
                                        BEGIN
                                        sp1p_buf [pos] := chr (ord(dfloat));
                                        len.map_int := cpr_numblen_r4;
                                        END;
                                    cpr_vreal8 :
                                        BEGIN
                                        sp1p_buf [pos] := chr (ord(dfloat));
                                        len.map_int := cpr_numblen_r8;
                                        END;
                                    cpr_vdecimal,
                                    cpr_vzoned,
                                    cpr_vlzone,
                                    cpr_vlszon,
                                    cpr_vtszon:
                                        BEGIN
                                        sp1p_buf [pos] := chr (ord(dfixed));
                                        len.map_int    :=  va2digit;
                                        sp1p_buf [pos+1] :=  chr (va2frac);
                                        END;
                                    cpr_vchar,
                                    cpr_vcharc,
                                    cpr_vbuf,
                                    cpr_vstring,
                                    cpr_vstring1,
                                    cpr_vstringc:
                                        BEGIN
                                        sp1p_buf [pos] := chr (ord(dcha));
                                        IF  va2size > csp_maxint2
                                        THEN
                                            len.map_int := 0
                                        ELSE
                                            len.map_int :=  va2size;
                                        (*ENDIF*) 
                                        END;
                                    cpr_vbchar,
                                    cpr_vbyte,
                                    cpr_vdbyte,
                                    cpr_vdbchar,
                                    cpr_vdbcharc:
                                        BEGIN
                                        sp1p_buf [pos] := chr (ord(dchb));
                                        IF  va2size > csp_maxint2
                                        THEN
                                            len.map_int := 0
                                        ELSE
                                            len.map_int := va2size;
                                        (*ENDIF*) 
                                        END;
                                    OTHERWISE:
                                        BEGIN
                                        sp1p_buf [pos] := chr (ord(dunknown));
                                        len.map_int :=  0;
                                        END;
                                    END;
                                (*ENDCASE*) 
                                sp1p_buf [pos+2] :=  len.map_c2 [1];
                                sp1p_buf [pos+3] :=  len.map_c2 [2];
                                sp1p_buf_len := sp1p_buf_len + 4;
                                pos := pos + 4;
                                END;
                            (*ENDIF*) 
                        (*ENDWITH*) 
                    (*ENDFOR*) 
                    END;
                (*ENDWHILE*) 
                s26finish_part (ga.gareqptr, part_ptr^);
                END;
            (*ENDWITH*) 
            END;
            end;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;

(*------------------------------*) 
 
PROCEDURE
      p03reqrecpacket  (
            VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR ga : sqlgaentry);
 
VAR
      i        : integer;
      part_ptr : tsp1_part_ptr;
 
BEGIN
WITH sqlca, sqlrap^, sqlgap^, sqlemp^ DO
    BEGIN
&   ifdef TRACE
    m90int  (pc, 'ereturncode ', ereturncode);
&   endif
    IF  ((@sqlxa.xaSQLDesc^ <> NIL) AND (sqlxa.xaSQLDesc^.ConDesc <> NIL))
    THEN
        pr03PacketReqRec(sqlxa.xaSQLDesc^.ConDesc, sqlemp)
    ELSE
        BEGIN
        ga.gastatus := cpr_co_ok;
        IF  ga.gareqptr <> NIL
        THEN
            p03creqrecpacket (sqlrap, ga, sqlemp)
        ELSE
            p03cseterror (sqlemp, cpr_reflex_notok);
        (*ENDIF*) 
        p03csqlemptosqlca (sqlca, sqlemp);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;  (* p03sendpacket *)
 
&ifdef PR03PART
(*------------------------------*) 
 
PROCEDURE
      p03partptrinit  (sqlrap : sqlrapointer);
 
VAR
      i : integer;
      part_no : tsp00_Int2;
      part_ptr: tsp1_part_ptr;
      maxparts : integer;
 
BEGIN
WITH sqlrap^ DO
    BEGIN
    maxparts := sizeof(rasegmpartptr) DIV sizeof(rasegmpartptr[1]);
    FOR i := 1 TO maxparts DO
        rasegmpartptr [i] := NIL;
    (*ENDFOR*) 
    IF  rasegptr <> NIL
    THEN
        IF  rasegptr^.sp1s_no_of_parts <> 0
        THEN
            BEGIN
            part_ptr := @rasegptr^.sp1p_part;
            part_no := 1;
            REPEAT
                i := ord(part_ptr^.sp1p_part_kind) + 1;
                IF  ( i <= maxparts )
                THEN
                    rasegmpartptr [i] := part_ptr;
&               ifdef TRACE
                (*ENDIF*) 
                m90int2 (pc, 'sp1p_part_ki', ord(part_ptr^.sp1p_part_kind));
&               endif
                IF  part_no < rasegptr^.sp1s_no_of_parts
                THEN
                    BEGIN
                    part_no := part_no + 1;
                    s26nextpart (part_ptr)
                    END
                ELSE
                    part_ptr := NIL
                (*ENDIF*) 
            UNTIL
                (part_ptr = NIL)
            (*ENDREPEAT*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END; { p03partptrinit }
 
(*------------------------------*) 
 
PROCEDURE
      p03find_part  (sqlrap : sqlrapointer;
            part_kind        : tsp1_part_kind;
            VAR part_ptr     : tsp1_part_ptr);
 
VAR
      i : integer;
 
BEGIN
&ifdef TRACE
m90int2 (pc, 'sp1p_part_ki', ord(part_kind));
&endif
part_ptr := NIL;
WITH sqlrap^ DO
    IF  rasegptr <> NIL
    THEN
        BEGIN
        IF  rasegptr^.sp1s_no_of_parts <> 0
        THEN
            BEGIN
            i := ord(part_kind) + 1;
            part_ptr := rasegmpartptr [i];
&           ifdef TRACE
            IF  part_ptr <> NIL
            THEN
                m90int2 (pc, 'found part_k', ord(part_kind));
&           endif
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END; { p03find_part }
 
&else
(*------------------------------*) 
 
PROCEDURE
      p03partptrinit(sqlrap : sqlrapointer);
 
BEGIN
pr03PartInitCache(sqlrap);
END; { last }
 
(*------------------------------*) 
 
PROCEDURE
      p03find_part(sqlrap : sqlrapointer;
            part_kind        : tsp1_part_kind;
            VAR part_ptr     : tsp1_part_ptr);
 
BEGIN
part_ptr := pr03PartFind(sqlrap, part_kind);
END; { last }
 
&endif
(*------------------------------*) 
 
PROCEDURE
      p03sysproferror  (VAR sqlca : sqlcatype;
            VAR gae    : sqlgaentry);
 
BEGIN
WITH sqlca, sqlrap^, sqlemp^, sqlgap^, gae   DO
    BEGIN
    IF  elzu <> sp1ce_ok
    THEN
        BEGIN
        p03clzuerror (gae, cpr_lzu_sysprofile, sqlemp);
        IF  eprerr <> cpr_p_ok
        THEN
            p03cseterror (sqlemp, eprerr);
        (*ENDIF*) 
        END
    ELSE
        IF  ereturncode <> 0
        THEN
            BEGIN
            IF  ereturncode = -4004
            THEN
                p03cseterror (sqlemp, cpr_unknown_sysprofile)
            ELSE
                BEGIN
                p03cseterror  (sqlemp, cpr_errorno_from_sysprofile);
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p03gparsid  (sqlrap : sqlrapointer;
            sqlemp : sqlempointer;
            VAR parsid : tpr_parsid;
            VAR SessionID : tpr00_SessionID);
 
VAR
      part_ptr : tsp1_part_ptr;
 
BEGIN
IF  (sqlemp^.ereturncode = 0)
    OR (sqlemp^.ereturncode = csp_use_new_pars_info)
THEN
    WITH sqlrap^  DO
        BEGIN
        p03find_part (sqlrap, sp1pk_parsid, part_ptr);
        IF  part_ptr <> NIL
        THEN
            WITH  part_ptr^, sp1p_part_header  DO
                BEGIN
                SAPDB_PascalForcedFill(mxpr_parsid, @parsid, mxpr_knlparsid,
                      sizeof(SessionID.ClientSession), chr(0));
                SAPDB_PascalForcedMove (sp1p_buf_size, mxpr_parsid,
                      @sp1p_buf, 1, @parsid, 1, mxpr_knlparsid);
                IF  (parsid <> cpr_parsidnull)
                THEN
                    SAPDB_PascalForcedMove (mxsp_c4, mxpr_parsid, @SessionID.ClientSession, 1,
                          @parsid, mxpr_knlparsid+1, sizeof(SessionID.ClientSession));
                (*ENDIF*) 
                END
            (*ENDWITH*) 
        ELSE
            parsid := cpr_parsidnull;
        (*ENDIF*) 
        END
    (*ENDWITH*) 
ELSE
    (* ADIS 1001211 *)
    parsid := cpr_parsidnull;
(*ENDIF*) 
END;  (* p03gparsid *)
 
(*------------------------------*) 
 
PROCEDURE
      p03gselparsid  (sqlrap : sqlrapointer;
            sqlemp : sqlempointer;
            VAR parsid : tpr_parsid;
            VAR SessionID : tpr00_SessionID);
 
VAR
      part_ptr : tsp1_part_ptr;
 
BEGIN
WITH sqlrap^  DO
    BEGIN
    p03find_part (sqlrap, sp1pk_parsid_of_select, part_ptr);
    IF  part_ptr <> NIL
    THEN
        WITH  part_ptr^, sp1p_part_header  DO
            BEGIN
            SAPDB_PascalForcedFill(mxpr_parsid, @parsid, mxpr_knlparsid+1,
                  sizeof(SessionID.ClientSession), chr(0));
            SAPDB_PascalForcedMove (sp1p_buf_size, mxpr_parsid,
                  @sp1p_buf, 1, @parsid, 1, mxpr_knlparsid);
            IF  (parsid <> cpr_parsidnull)
            THEN
                SAPDB_PascalForcedMove (mxsp_c4, mxpr_parsid,
                      @SessionID.ClientSession, 1,
                      @parsid, mxpr_knlparsid+1, sizeof(SessionID.ClientSession));
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    ELSE
        parsid := cpr_parsidnull;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;  (* p03gparsid *)
 
(*------------------------------*) 
 
PROCEDURE
      p03returncodeget (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype);
 
BEGIN
WITH sqlca, sqlrap^, rasqltap^ DO
    BEGIN
    p03errorget (sqlca, sqlxa);
    p03csqlemptosqlca (sqlca, sqlemp);
    IF   (tatrout <> cpr_trace_off)
    THEN
        p03traceerror (sqlrap, sqlemp);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;  (* p03returncodeget *)
 
(*------------------------------*) 
 
PROCEDURE
      p03errorget (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype);
 
VAR
      error_ka : tpr_error_warnset;
      warn_ka : tsp_int_map_c2;
      kapaind  : integer;
&     ifdef TRACE
      warni4   : tsp00_Int4;
&     endif
 
BEGIN
WITH sqlca, sqlrap^, sqlgap^, rasqltap^, sqlemp^, sqlxa DO
    BEGIN
    error_ka.int2  := 0;
    IF  ( ralang <> cpr_la_call)
        AND (xakano <> 0)
    THEN
        BEGIN
        IF  (ereturncode = sqlcode_rownotfound)
            AND (pr01cIsComType(sqlxa.xaSQLDesc^, cpr_com_sql_open))
        THEN
            (* nur select befehle *)
            IF  (ord (sqlkap^ [xakano] .kaParseInfo.ParseId [cpr_p_precom_index]) in
                [csp1_p_mass_select_found,
                csp1_p_reuse_mass_select_found,
                csp1_p_select_for_update_found,
                csp1_p_reuse_update_sel_found,
                csp1_p_mselect_found,
                csp1_p_reuse_mselect_found,
                csp1_p_for_upd_mselect_found,
                csp1_p_reuse_upd_mselect_found])
            THEN
                BEGIN
                IF  (sqldbmode <>  cpr_kind_sapr3)
                    AND (sqldbmode <> cpr_kind_oracle)
                THEN
                    ereturncode := 0;  (* am 30.9.93 Horst *)
                (*ENDIF*) 
                eerrorpos    := 0;
                error_ka.int2:= 0;
                END
            ELSE
                sqlerrd [3] := 0
            (*ENDIF*) 
        ELSE
            BEGIN
            error_ka.int2:= sqlkap^ [xakano] .kaparserrc;
            END;
        (*ENDIF*) 
&       ifdef TRACE
        m90int2 (pc, 'kaparserrc  ', error_ka.int2);
        warni4 := error_ka.int2;
        m90hexint4 (pc, 'kaparserrc-h', warni4);
&       endif
        END;
    (*ENDIF*) 
    IF   (ereturncode = 100) AND (eerrorpos >= 1)
    THEN
        BEGIN
        eerrorpos := 0;
        sqlerrd [3] := 0;
        END
    ELSE
        IF   (ereturncode <> 100) AND (eerrorpos >= 1)
        THEN
            BEGIN
            IF  (ralang <> cpr_la_call)
                AND (xakano <> 0)
            THEN
                WITH sqlkap^ [xakano] DO
                    BEGIN
                    IF  kapaindex > 0
                    THEN
                        kapaind :=  kapaindex
                    ELSE
                        kapaind := -kapaindex;
                    (*ENDIF*) 
                    IF  kapaindex <> 0
                    THEN
                        IF  (sqlpap^ [kapaind] .pakindlo = sqlparlo)
                            AND (ramesstype <> ord (sp1m_parse))
                        THEN
                            (* array  commands *)
                            (* sqlerrd  = number of correct record *)
                            (* errorpos = number of last correct record *)
                            sqlerrd [6] := eerrorpos - 1
                        ELSE
                            sqlerrd [6] := 0;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
&       ifdef TRACE
        (*ENDIF*) 
    (*ENDIF*) 
    m90int2 (pc, 'ereturncode ', ereturncode);
    m90int2 (pc, 'error_ka.int', error_ka.int2);
    m90int2 (pc, 'sqlerrd (3) ', sqlerrd [3]);
    m90int2 (pc, 'eerrorpos   ', eerrorpos);
    m90int2 (pc, 'sqlcode     ', sqlcode  );
    warni4 := error_ka.int2;
    m90hexint4 (pc, 'error-code h', warni4);
&   endif
    warn_ka.map_int := error_ka.int2;
    IF   (error_ka.int2 <> 0) AND (ereturncode = 0)
    THEN
        p03warningset (sqlemp, warn_ka.map_c2);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p03traceerror (sqlrap : sqlrapointer;
            sqlemp : sqlempointer);
 
VAR
      len      : integer;
      nam      : tsp00_Name;
      chr12    : tsp00_C12;
      i        : integer;
      ch       : char;
      od       : integer;
 
BEGIN
WITH sqlrap^, rasqltap^, sqlemp^ DO
    IF   (tatrout <> cpr_trace_off)
    THEN
        BEGIN
        tastr80l := 1;
        IF   ereturncode <> 0
        THEN
            WITH rasqltap^ DO
                BEGIN
                SAPDB_PascalForcedFill (sizeof (tastr80) , @tastr80, 1, sizeof (tastr80), bsp_c1);
                nam := 'SQLCODE:          ';
                SAPDB_PascalForcedMove (mxsp_name, sizeof (tastr80), @nam, 1, @tastr80, 1, 9);
                tastr80l := 9;
                p05inttochr12 (ereturncode, chr12);
                SAPDB_PascalForcedMove (mxsp_c12, sizeof (tastr80), @chr12, 1,
                      @tastr80, tastr80l+1, mxsp_c12);
                tastr80l := tastr80l + mxsp_c12;
                len := etextlen;
                IF   len > mxsp_c80 - tastr80l
                THEN
                    i := mxsp_c80 - tastr80l
                ELSE
                    i := len;
                (*ENDIF*) 
                SAPDB_PascalForcedMove (mxsp_c70, sizeof (tastr80), @etext, 1,
                      @tastr80, tastr80l+1, i);
                tastr80l := tastr80l + i;
                p08vfwritetrace (sqlrap);
                END
            (*ENDWITH*) 
        ELSE
            IF   (ewarning [1] <> bsp_c1)
            THEN
                WITH rasqltap^ DO
                    BEGIN
                    SAPDB_PascalForcedFill (sizeof (tastr80), @tastr80, 1, sizeof(tastr80), bsp_c1);
                    nam := 'WARNING:          ';
                    SAPDB_PascalForcedMove (mxsp_name, sizeof (tastr80), @nam, 1, @tastr80, 1, 9);
                    tastr80l := 10;
                    ch  := '-';
                    od  := ord ('0');
                    FOR i := 0 TO 15 DO
                        BEGIN
                        IF  i = 10
                        THEN
                            od := ord ('A');
                        (*ENDIF*) 
                        IF  ewarning [i+1] = bsp_c1
                        THEN
                            tastr80 [tastr80l+i ] := ch
                        ELSE
                            tastr80 [tastr80l+i ] := chr(i + od);
                        (*ENDIF*) 
                        END;
                    (*ENDFOR*) 
                    tastr80 [tastr80l ] := cpr_warningchr;
                    tastr80l := tastr80l + 16;
                    p08vfwritetrace (sqlrap);
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;  (* p03traceerror *)
 
(*------------------------------*) 
 
PROCEDURE
      p03invaliderr (sqlrap : sqlrapointer;
            art : tsp00_Int2;
            inout : tsp00_Int2;
            VAR buf   : tpr_buffer;
            vatyp : tsp00_Int2;
            valen : tsp00_Int4;
            vafrac: tsp00_Int2);
 
VAR
      nam  : tsp00_Name;
      int  : integer;
      chr12  : tsp00_C12;
      len    : tsp00_Int2;
      ok     : boolean;
 
BEGIN
WITH sqlrap^, rasqltap^ DO
    IF   (tatrout <> cpr_trace_off)
    THEN
        BEGIN
        tastr80l := 1;
        SAPDB_PascalForcedFill (sizeof (tastr80), @tastr80, 1, sizeof (tastr80), bsp_c1);
        CASE art OF
            1 :
                nam := 'HOST-VARIABLE :   ';
            2 :
                nam := 'KERN-VARIABLE :   ';
            OTHERWISE:
                nam := '                  ';
            END;
        (*ENDCASE*) 
        SAPDB_PascalForcedMove (mxsp_name, sizeof (tastr80), @nam, 1, @tastr80, 1, mxsp_name);
        tastr80l := 17;
        nam := 'DATATYP =         ';
        SAPDB_PascalForcedMove (mxsp_name, sizeof (tastr80), @nam, 1, @tastr80, tastr80l, 10);
        tastr80l := tastr80l + 10;
        int := vatyp;
        p05inttochr12 (int, chr12);
        SAPDB_PascalForcedMove (mxsp_c12, sizeof (tastr80), @chr12, 1,
              @tastr80, tastr80l+1, mxsp_c12);
        tastr80l := tastr80l + 8;
        nam := 'LENGTH =          ';
        SAPDB_PascalForcedMove (mxsp_name, sizeof (tastr80), @nam, 1, @tastr80, tastr80l, 9);
        tastr80l := tastr80l + 9;
        int := valen;
        p05inttochr12 (int, chr12);
        SAPDB_PascalForcedMove (mxsp_c12, sizeof (tastr80), @chr12, 1,
              @tastr80, tastr80l+1, mxsp_c12);
        tastr80l := tastr80l + 8;
        IF  vafrac <> 0
        THEN
            BEGIN
            nam := 'FRAC =            ';
            SAPDB_PascalForcedMove (mxsp_name, sizeof (tastr80), @nam, 1, @tastr80, tastr80l, 7);
            tastr80l := tastr80l + 7;
            int := valen;
            p05inttochr12 (int, chr12);
            SAPDB_PascalForcedMove (mxsp_c12, sizeof (tastr80), @chr12, 1,
                  @tastr80, tastr80l+1, mxsp_c12);
            tastr80l := tastr80l + 8;
            END;
        (*ENDIF*) 
        p08vfwritetrace (sqlrap);
        IF  (art = inout)
        THEN
            BEGIN
            tastr80l := 1;
            SAPDB_PascalForcedFill (sizeof (tastr80), @tastr80, 1, sizeof (tastr80), bsp_c1);
            nam := 'HEX-VALUE     :   ';
            SAPDB_PascalForcedMove (mxsp_name, sizeof (tastr80), @nam, 1, @tastr80, 1, mxsp_name);
            tastr80l := 17;
            len := valen;
            IF  valen > 20
            THEN
                len := 20;
            (*ENDIF*) 
            s40gbyte (buf , 1, len, tastr80, tastr80l,
                  len + len, ok);
            tastr80l := tastr80l + len + len;
            p08vfwritetrace (sqlrap);
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p03encrypt (VAR clearname : tsp00_Name;
            VAR crypt : tsp00_CryptName);
 
BEGIN
s02applencrypt ( clearname, crypt );
END;
 
(*------------------------------*) 
 
PROCEDURE
      p03getparameteraddr (VAR sqlca : sqlcatype;
            VAR sqlxa : sqlxatype;
            VAR paix : integer;
            VAR cmcnt : integer;
            VAR vaaddr : tpr_vtypepointer;
            VAR vaind  : integer;
            VAR indaddr : tpr_vtypepointer;
            VAR indind  : integer);
 
VAR
      found : boolean;
      vatype   : tsp00_Int2;
 
BEGIN
WITH sqlxa DO
    BEGIN
    REPEAT
        WITH  sqlpap^ [paix]   DO
            BEGIN
            found := true;
            CASE pakindlo OF
                sqlparlo :
                    BEGIN
                    found := false;
                    paix := paix + 1;
                    END;
                sqlparst :
                    BEGIN
                    vaaddr.intaddr  := 0;
                    indaddr.intaddr := 0;
                    cmcnt  := paelcnt;
                    vaind  := pavarst;
                    indind := paindst;
&                   ifdef TRACE
                    m90int   (pc, 'pakindst    ', pakindst);
                    m90int2  (pc, 'pavarst     ', pavarst);
                    m90int2  (pc, 'paindst     ', paindst);
&                   endif
                    IF  pavarst > 0
                    THEN
                        WITH sqlv1p^ [pavarst] DO
                            IF  va1indi_st = sqlvast
                            THEN
                                BEGIN
                                vaind := va1ix_st;
                                vaaddr:= va1addr_st;
                                END
                            ELSE
                                IF  va1indi_st = sqlvapt
                                THEN
                                    BEGIN
                                    vaind := va1ix_pt;
                                    IF  va1addr_pt.intaddr <> 0
                                    THEN
                                        vaaddr.intaddr :=
                                              va1addr_pt.vtypep^.iaddr;
                                    (*ENDIF*) 
                                    END;
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    IF  paindst > 0
                    THEN
                        WITH sqlv1p^ [paindst] DO
                            IF  va1indi_st = sqlvast
                            THEN
                                BEGIN
                                indind := va1ix_st;
                                indaddr:= va1addr_st;
                                END
                            ELSE
                                IF  va1indi_st = sqlvapt
                                THEN
                                    BEGIN
                                    indind := va1ix_pt;
                                    IF  va1addr_pt.intaddr <> 0
                                    THEN
                                        indaddr.intaddr :=
                                              va1addr_pt.vtypep^.iaddr;
                                    (*ENDIF*) 
                                    END;
&                               ifdef TRACE
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    m90int   (pc, 'paix        ', paix    );
                    m90int   (pc, 'vaind       ', vaind   );
&                   endif
                    paix := paix + 1;
                    WITH  sqlpap^ [paix]   DO
                        BEGIN
&                       ifdef TRACE
                        m90int   (pc, 'paix        ', paix );
                        m90int   (pc, 'pakindel    ', pakindel);
                        m90int2  (pc, 'pavarno     ', pavarno);
                        m90int2  (pc, 'paindno     ', paindno);
&                       endif
                        IF  pavarno > 0
                        THEN
                            WITH sqlv1p^ [pavarno] DO
                                BEGIN
                                vaind := pavarno;
                                IF  va1indi_sc = sqlvasc
                                THEN
                                    BEGIN
                                    vaaddr := va1addr_sc;
                                    vatype:= sqlv2p^[va1indva2_sc].va2typ;
                                    END;
                                (*ENDIF*) 
                                IF  va1indi_sc = sqlvacm
                                THEN
                                    BEGIN
                                    vaaddr.intaddr := vaaddr.intaddr
                                          + va1offs_cm;
                                    vatype:= sqlv2p^[va1indva2_sc].va2typ;
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        IF  paindno > 0
                        THEN
                            WITH sqlv1p^ [paindno] DO
                                BEGIN
                                indind := paindno;
                                IF  va1indi_sc = sqlvasc
                                THEN
                                    indaddr := va1addr_sc;
                                (*ENDIF*) 
                                IF  va1indi_sc = sqlvacm
                                THEN
                                    indaddr.intaddr := indaddr.intaddr
                                          + va1offs_cm;
                                (*ENDIF*) 
                                END;
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                    END;
                sqlparel :
                    BEGIN
                    WITH sqlv1p^ [pavarno] DO
                        BEGIN
                        cmcnt  := 1;
                        vaind  := pavarno;
                        indind := paindno;
                        vaaddr := va1addr_sc;
                        vatype:= sqlv2p^[va1indva2_sc].va2typ;
                        IF  va1indi_st = sqlvast
                        THEN
                            BEGIN
                            cmcnt := va1cmpcnt_st;
                            vaind := va1ix_st;
                            vaaddr:= va1addr_st;
                            END;
                        (*ENDIF*) 
                        IF  va1indi_pt = sqlvapt
                        THEN
                            BEGIN
                            vaind := va1ix_pt;
                            IF  va1addr_pt.intaddr <> 0
                            THEN
                                vaaddr.intaddr := va1addr_pt.vtypep^.iaddr;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                    IF  paindno = 0
                    THEN
                        indaddr.intaddr := 0
                    ELSE
                        WITH sqlv1p^ [paindno] DO
                            BEGIN
                            indaddr := va1addr_sc;
                            IF  va1indi_st = sqlvast
                            THEN
                                BEGIN
                                indind := va1ix_st;
                                indaddr:= va1addr_st;
                                END;
                            (*ENDIF*) 
                            IF  va1indi_pt = sqlvapt
                            THEN
                                BEGIN
                                indind := va1ix_pt;
                                IF  va1addr_pt.intaddr <> 0
                                THEN
                                    indaddr.intaddr :=
                                          va1addr_pt.vtypep^.iaddr;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    END;
                OTHERWISE:
                    BEGIN
                    END;
                END;
            (*ENDCASE*) 
            END;
        (*ENDWITH*) 
    UNTIL
        (found);
    (*ENDREPEAT*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      p03putsysprofbuf (sqlrap : sqlrapointer);
 
VAR
      i : integer;
      len : tsp00_Int4;
      vptr     : tpr_vtypepointer;
      part_ptr : tsp1_part_ptr;
 
BEGIN
WITH sqlrap^ DO
    BEGIN
    p03find_part (sqlrap, sp1pk_command, part_ptr);
    IF  part_ptr <> NIL
    THEN
        WITH  part_ptr^, sp1p_part_header  DO
            BEGIN
            (*  raprofstmtp mit statement belegen *)
            IF  sp1p_buf_len > mxpr_sysprof_stmlen
            THEN
                len := mxpr_sysprof_stmlen
            ELSE
                len := sp1p_buf_len;
            (*ENDIF*) 
            vptr.intaddr := raprofstmtp;
            SAPDB_PascalForcedOverlappingMove (mxsp_c2, mxsp_c2, @len, 1,
                  @vptr.vtypep^, 1, mxsp_c2);
            SAPDB_PascalForcedOverlappingMove (sp1p_buf_size, mxpr_sysprof_stmlen+3,
                  @sp1p_buf, 1, @vptr.vtypep^, 3, len);
            i := len + 2;
            WHILE ((vptr.vtypep^.buf [i]  = bsp_c1) OR
                  (vptr.vtypep^.buf [i]  = cpr_nullchar) OR
                  (vptr.vtypep^.buf [i]  = cpr_pc_endsign))
                  AND (i > 1)   DO
                BEGIN
                vptr.vtypep^.buf [i]  := bsp_c1;
                i := i - 1;
                END;
            (*ENDWHILE*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
