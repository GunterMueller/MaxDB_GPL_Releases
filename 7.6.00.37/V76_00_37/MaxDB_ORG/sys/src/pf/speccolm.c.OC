/*
*****************************************************************************
** SQL Datenbanksysteme GmbH
**
** Autor        : Harun Eren 
**
** Program      : speccolm.c.OC
**
** Usage        : --
** Option       : --
**
** Purpose      : Auto Test DLL, Test von SQLSpecialColumns
**
** Date         : 30.10.96
** l.Žnderung   : 14:19pm 10-30-1996 (Harun)
****************************************************************************



    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end




*/
#include "winhead.h"

/* ---------------------------------------------------------------------- */
#define PROGNAME "speccolm"
#ifndef DEFAULTS
#define USERNAME "SUPERDBA"
#define PASSWORD "ADMIN"
#define DBNODE   "sqlprec:D"

#define ODBCUSER  "ODBC"
#define ODBCPASSW "ODBC"
#endif

#define ODBCUSER1  "ODBC1"
#define ODBCPASSW1 "ODBC1"
#define ODBCTABLE  "ODBCTEST"
#define ODBCSCRIPT "proc2inst"
#define DBPROC1	   "INSERT_TEST"
#define DBPROC2	   "SELECT_TEST"

#define ERROR_CHECK(hstmtx)  \
    if (rc != SQL_SUCCESS) {\
	   SQLError(henv, hdbc, hstmtx, sqlstate, &esq_sql_code, error_txt,\
		    len_error_txt, &used_error_txt);\
	   SPRINTF(buffer," sqlstate: %s"CRLF, sqlstate);\
           PRINTF(buffer);\
	   SPRINTF(buffer," esq_sql_code: %ld"CRLF, esq_sql_code);\
           PRINTF(buffer);\
           switch (rc) {\
		  case(1) :\ 
			  break;\
		  case(-1) :\ 
			  break;\
		  case(100) :\ 
			  break;\
		  default   :\ 
			  exit(16); \
			  break; } \
	}

 UCHAR sqlstate  [ 10 ];
 SDWORD esq_sql_code;
 UCHAR error_txt  [ 101 ] ;
 SWORD len_error_txt = 100;
 SWORD used_error_txt;
 UCHAR buffer[1024];
/* ----------------------------------------------------------------------- */
#define TESTNAME "SQLSpecialColumns"
#define TABLE1 "TABSPECCOL1"
#define TABLE2 "TABSPECCOL2"
#define TABLE3 "TABSPECCOL3"

#define STR_LEN			128+1
#define MAX_NAME_LEN		50
#define MAX_COL_NAME_LEN 	18

#define OUTPUTTXT "Driver does not support this function !"
	
#define NULL_VALUE "<NULL>"

/* ----------------------------------------------------------------------- */
RETCODE lstSpecialColInfo(HENV FAR henv, HDBC FAR hdbc, HSTMT FAR hstmt);
RETCODE lst_ColumnNames(HENV henv, HDBC hdbc, HSTMT hstmt, SWORD outcol);

/*
 ------------------------------------------------------------------------
| DoSpecilaColumns:
|             
|
| Returns:
|     Number of Errors or TEST_ABORTED
 ------------------------------------------------------------------------
*/
int MAIN(int argc, char **argv)
{
	RETCODE                 rc;
	SWORD                   sErr=0;
/* ------------------------------------------------------------------------- */
	HENV henv   = SQL_NULL_HENV;
	HENV FAR * phenv;
	HDBC hdbc   = SQL_NULL_HDBC;
	HDBC FAR * phdbc;
	HSTMT hstmt = SQL_NULL_HSTMT;
	HSTMT FAR * phstmt;
/* ------------------------------------------------------------------------- */
	UCHAR                   create[MAX_NAME_LEN+MAX_NAME_LEN+1];
	UCHAR                   drop[MAX_NAME_LEN+1];
	UCHAR                   tabname[MAX_NAME_LEN];

	UWORD			fColType;
	UCHAR			szTableQualifier[MAX_NAME_LEN],
				szTableOwner[MAX_NAME_LEN],
				szTableName[MAX_NAME_LEN];
	UWORD			fScope,
				fNullable;
	SWORD			cbTableQualifier, cbTableOwner, cbTableName;
			
	SWORD                   cAbort=0;
/* ---------------------------------------------------------------------har- */
 SPRINTF(buffer, " %s running.\n", PROGNAME);
 PRINTF(buffer);

 phenv = (HENV FAR *) &henv;
 phdbc = (HDBC FAR *) &hdbc;
 phstmt = (HSTMT FAR *) &hstmt;

 rc = SQLAllocEnv(phenv);
 SPRINTF(buffer," SQLAllocEnv retcode: %d"CRLF, rc);
 PRINTF(buffer);
 ERROR_CHECK(NULL);
	
 rc = SQLAllocConnect(henv, phdbc);
 SPRINTF(buffer," SQLAllocConnect retcode: %d"CRLF, rc);
 PRINTF(buffer);
 ERROR_CHECK(NULL);
	
 rc = SQLConnect(hdbc, DBNODE, SQL_NTS, ODBCUSER, SQL_NTS, 
 						ODBCPASSW, SQL_NTS );
 SPRINTF(buffer," SQLConnect retcode: %d"CRLF, rc);
 PRINTF(buffer);
 ERROR_CHECK(NULL);

 rc = SQLAllocStmt (hdbc, phstmt);
 SPRINTF(buffer," SQLAllocStmt retcode: %d"CRLF, rc);
 PRINTF(buffer);
 ERROR_CHECK(NULL);
/* ---------------------------------------------------------------------- */ 
	/* --- Create Table 1. ------------------------------------------- */
	STRCPY(tabname,TABLE1);
	STRCPY(create,"CREATE TABLE ");
	STRCAT(create,tabname);
	STRCAT(create," (\"MNR\" INTEGER, \"NAME\" CHAR(30))");
	SPRINTF(buffer," Create Stmt 1.= '%s'"CRLF,create);
	PRINTF(buffer);

	rc = SQLExecDirect(hstmt, create, SQL_NTS);
	SPRINTF(buffer," SQLExecDirect retcode: %d"CRLF, rc);
	PRINTF(buffer);
	ERROR_CHECK(NULL);

	/* --- Create Table 2. ------------------------------------------- */
	STRCPY(tabname,TABLE2);
	STRCPY(create,"CREATE TABLE ");
	STRCAT(create,tabname);
	STRCAT(create," (\"MNR\" INTEGER KEY, \"NAME\" CHAR(30))");
	SPRINTF(buffer," Create Stmt 2.= '%s'"CRLF,create);
	PRINTF(buffer);

	rc = SQLExecDirect(hstmt, create, SQL_NTS);
	SPRINTF(buffer," SQLExecDirect retcode: %d"CRLF, rc);
	PRINTF(buffer);
	ERROR_CHECK(NULL);

	/* --- Create Table 3. ------------------------------------------- */
	STRCPY(tabname,TABLE3);
	STRCPY(create,"CREATE TABLE ");
	STRCAT(create,tabname);
	STRCAT(create," (\"MNR\" INTEGER, \"NAME\" CHAR(30), PRIMARY KEY (NAME))");
	SPRINTF(buffer," Create Stmt 3.= '%s'"CRLF,create);
	PRINTF(buffer);

	rc = SQLExecDirect(hstmt, create, SQL_NTS);
	SPRINTF(buffer," SQLExecDirect retcode: %d"CRLF, rc);
	PRINTF(buffer);
	ERROR_CHECK(NULL);

	/* --- SQLSpecialColumns 1. ---------------------------------------- */
	SPRINTF(buffer,CRLF" 1.List SpecialColumns Table -> %s "CRLF,TABLE1);
	PRINTF(buffer);
	SPRINTF(buffer," 	fColType -> SQL_BEST_ROWID, fScope -> SQL_SCOPE_CURROW "CRLF);
	PRINTF(buffer);
	fColType = SQL_BEST_ROWID; 
	fScope = SQL_SCOPE_CURROW;
 	fNullable = SQL_NULLABLE;
	strcpy(szTableQualifier, "\0");
	strcpy(szTableOwner, ODBCUSER);
	strcpy(szTableName, TABLE1);
	cbTableQualifier = cbTableOwner = cbTableName = SQL_NTS;

	rc = SQLSpecialColumns(hstmt, fColType, szTableQualifier, SQL_NTS, 
				szTableOwner, SQL_NTS, szTableName, SQL_NTS, 
				fScope, fNullable);
	SPRINTF(buffer," SQLSpecialColumns retcode: %d"CRLF, rc);
	PRINTF(buffer);
	ERROR_CHECK(NULL);

	if (rc==SQL_SUCCESS) lstSpecialColInfo(henv, hdbc, hstmt);

	rc = SQLFreeStmt(hstmt, SQL_CLOSE);
	SPRINTF(buffer," SQLFreeStmt retcode: %d"CRLF, rc);
	PRINTF(buffer);
	ERROR_CHECK(NULL);

	/* --- SQLSpecialColumns 2. ---------------------------------------- */
	SPRINTF(buffer,CRLF" 2.List SpecialColumns Table -> %s "CRLF,TABLE2);
	PRINTF(buffer);
	SPRINTF(buffer," 	fColType -> SQL_BEST_ROWID, fScope -> SQL_SCOPE_CURROW "CRLF);
	PRINTF(buffer);
	fColType = SQL_BEST_ROWID; 
	fScope = SQL_SCOPE_CURROW;
 	fNullable = SQL_NULLABLE;
	strcpy(szTableQualifier, "\0");
	strcpy(szTableOwner, ODBCUSER);
	strcpy(szTableName, TABLE2);
	cbTableQualifier = cbTableOwner = cbTableName = SQL_NTS;

	rc = SQLSpecialColumns(hstmt, fColType, szTableQualifier, SQL_NTS, 
				szTableOwner, SQL_NTS, szTableName, SQL_NTS, 
				fScope, fNullable);
	SPRINTF(buffer," SQLSpecialColumns retcode: %d"CRLF, rc);
	PRINTF(buffer);
	ERROR_CHECK(NULL);

	if (rc==SQL_SUCCESS) lstSpecialColInfo(henv, hdbc, hstmt);

	rc = SQLFreeStmt(hstmt, SQL_CLOSE);
	SPRINTF(buffer," SQLFreeStmt retcode: %d"CRLF, rc);
	PRINTF(buffer);
	ERROR_CHECK(NULL);

	/* --- SQLSpecialColumns 3. ---------------------------------------- */
	SPRINTF(buffer,CRLF" 3.List SpecialColumns Table -> %s "CRLF,TABLE3);
	PRINTF(buffer);
	SPRINTF(buffer," 	fColType -> SQL_BEST_ROWID, fScope -> SQL_SCOPE_TRANSACTION "CRLF);
	PRINTF(buffer);
	fColType = SQL_BEST_ROWID; 
	fScope = SQL_SCOPE_TRANSACTION;
 	fNullable = SQL_NULLABLE;
	strcpy(szTableQualifier, "\0");
	strcpy(szTableOwner, ODBCUSER);
	strcpy(szTableName, TABLE3);
	cbTableQualifier = cbTableOwner = cbTableName = SQL_NTS;

	rc = SQLSpecialColumns(hstmt, fColType, szTableQualifier, SQL_NTS, 
				szTableOwner, SQL_NTS, szTableName, SQL_NTS, 
				fScope, fNullable);
	SPRINTF(buffer," SQLSpecialColumns retcode: %d"CRLF, rc);
	PRINTF(buffer);
	ERROR_CHECK(NULL);

	if (rc==SQL_SUCCESS) lstSpecialColInfo(henv, hdbc, hstmt);

	rc = SQLFreeStmt(hstmt, SQL_CLOSE);
	SPRINTF(buffer," SQLFreeStmt retcode: %d"CRLF, rc);
	PRINTF(buffer);
	ERROR_CHECK(NULL);

	/* --- SQLSpecialColumns 4. ---------------------------------------- */
	SPRINTF(buffer,CRLF" 4.List SpecialColumns Table -> %s "CRLF,TABLE3);
	PRINTF(buffer);
	SPRINTF(buffer," 	fColType -> SQL_BEST_ROWID, fScope -> SQL_SCOPE_SESSION "CRLF);
	PRINTF(buffer);
	fColType = SQL_BEST_ROWID; 
	fScope = SQL_SCOPE_SESSION;
 	fNullable = SQL_NULLABLE;
	strcpy(szTableQualifier, "\0");
	strcpy(szTableOwner, ODBCUSER);
	strcpy(szTableName, TABLE3);
	cbTableQualifier = cbTableOwner = cbTableName = SQL_NTS;

	rc = SQLSpecialColumns(hstmt, fColType, szTableQualifier, SQL_NTS, 
				szTableOwner, SQL_NTS, szTableName, SQL_NTS, 
				fScope, fNullable);
	SPRINTF(buffer," SQLSpecialColumns retcode: %d"CRLF, rc);
	PRINTF(buffer);
	ERROR_CHECK(NULL);

	if (rc==SQL_SUCCESS) lstSpecialColInfo(henv, hdbc, hstmt);

	rc = SQLFreeStmt(hstmt, SQL_CLOSE);
	SPRINTF(buffer," SQLFreeStmt retcode: %d"CRLF, rc);
	PRINTF(buffer);
	ERROR_CHECK(NULL);

	/* --- SQLSpecialColumns 5. ---------------------------------------- */
	SPRINTF(buffer,CRLF" 5.List SpecialColumns Table -> %s "CRLF,TABLE3);
	PRINTF(buffer);
	SPRINTF(buffer," 	fColType -> SQL_ROWVER, fScope -> SQL_SCOPE_CURROW "CRLF);
	PRINTF(buffer);
	fColType = SQL_ROWVER; 
	fScope = SQL_SCOPE_CURROW;
 	fNullable = SQL_NULLABLE;
	strcpy(szTableQualifier, "\0");
	strcpy(szTableOwner, ODBCUSER); 
	strcpy(szTableName, TABLE1);
	cbTableQualifier = cbTableOwner = cbTableName = SQL_NTS;

	rc = SQLSpecialColumns(hstmt, fColType, szTableQualifier, SQL_NTS, 
				szTableOwner, SQL_NTS, szTableName, SQL_NTS, 
				fScope, fNullable);
	SPRINTF(buffer," SQLSpecialColumns retcode: %d"CRLF, rc);
	PRINTF(buffer);
	ERROR_CHECK(NULL);

	if (rc==SQL_SUCCESS) lstSpecialColInfo(henv, hdbc, hstmt);

	rc = SQLFreeStmt(hstmt, SQL_CLOSE);
	SPRINTF(buffer," SQLFreeStmt retcode: %d"CRLF, rc);
	PRINTF(buffer);
	ERROR_CHECK(NULL);

	/* --- Drop Table 1. -------------------------------------------- */
	STRCPY(drop,"DROP TABLE ");
	STRCAT(drop,TABLE1);
	SPRINTF(buffer," Drop Stmt= '%s'"CRLF,drop);
	PRINTF(buffer);

	rc = SQLExecDirect(hstmt, drop, SQL_NTS);
	SPRINTF(buffer," SQLExecDirect retcode: %d"CRLF, rc);
	PRINTF(buffer);
	ERROR_CHECK(NULL);

	/* --- Drop Table 2. -------------------------------------------- */
	STRCPY(drop,"DROP TABLE ");
	STRCAT(drop,TABLE2);
	SPRINTF(buffer," Drop Stmt= '%s'"CRLF,drop);
	PRINTF(buffer);

	rc = SQLExecDirect(hstmt, drop, SQL_NTS);
	SPRINTF(buffer," SQLExecDirect retcode: %d"CRLF, rc);
	PRINTF(buffer);
	ERROR_CHECK(NULL);

	/* --- Drop Table 3. -------------------------------------------- */
	STRCPY(drop,"DROP TABLE ");
	STRCAT(drop,TABLE3);
	SPRINTF(buffer," Drop Stmt= '%s'"CRLF,drop);
	PRINTF(buffer);

	rc = SQLExecDirect(hstmt, drop, SQL_NTS);
	SPRINTF(buffer," SQLExecDirect retcode: %d"CRLF, rc);
	PRINTF(buffer);
	ERROR_CHECK(NULL);
	/* ----------------------------------------------------------------- */
  rc = SQLFreeStmt(hstmt, SQL_DROP);
  SPRINTF(buffer," SQLFreeStmt retcode: %d"CRLF, rc);
  PRINTF(buffer);
  ERROR_CHECK(NULL);
	
  rc = SQLDisconnect(hdbc);
  SPRINTF(buffer," SQLDisconnect retcode: %d"CRLF, rc);
  PRINTF(buffer);
  ERROR_CHECK(NULL);
	
  rc = SQLFreeConnect(hdbc);
  SPRINTF(buffer," SQLFreeConnect retcode: %d"CRLF, rc);
  PRINTF(buffer);
  ERROR_CHECK(NULL);
	
  rc = SQLFreeEnv(henv);
  SPRINTF(buffer," SQLFreeEnv retcode: %d"CRLF, rc);
  PRINTF(buffer);
  ERROR_CHECK(NULL);

  SPRINTF(buffer,""CRLF);
  PRINTF(buffer);
  SPRINTF(buffer," %s ending"CRLF, PROGNAME);
  PRINTF(buffer);

  return(0);

}
/* *********************************************************************** */
RETCODE lstSpecialColInfo(HENV FAR henv, HDBC hdbc, HSTMT FAR hstmt)
{
	RETCODE                 rc;
	SWORD                   sErr=0;
/* ----------------------------------------------------------------------- */
	/* Declare storage locations for result set data */
	UCHAR   szColumnName[STR_LEN], 
		szTypeName[STR_LEN];
	UCHAR   szScope[STR_LEN], 
		szPseudoColumn[STR_LEN],
		szScale[STR_LEN];
	SWORD   Scope, 
		DataType,
		Scale,
		PseudoColumn;
	SDWORD  Precision,
		Length;

	/* Declare storage locations for bytes available to return */
	SQLLEN cbScope, cbColumnName, cbDataType, cbTypeName, cbPrecision;
	SQLLEN cbLength, cbScale, cbPseudoColumn;

	SWORD  count=0;
/* ---------------------------------------------------------------------har- */
	/* Bind columns in result set to storage locations */
	SQLBindCol(hstmt, 1, SQL_C_SSHORT, &Scope, 0, &cbScope);
	SQLBindCol(hstmt, 2, SQL_C_CHAR, szColumnName, STR_LEN, &cbColumnName);
	SQLBindCol(hstmt, 3, SQL_C_SSHORT, &DataType, 0, &cbDataType);
	SQLBindCol(hstmt, 4, SQL_C_CHAR, szTypeName, STR_LEN, &cbTypeName);
	SQLBindCol(hstmt, 5, SQL_C_SLONG, &Precision, 0, &cbPrecision);
	SQLBindCol(hstmt, 6, SQL_C_SLONG, &Length, 0, &cbLength);
	SQLBindCol(hstmt, 7, SQL_C_SSHORT, &Scale, 0, &cbScale);
	SQLBindCol(hstmt, 8, SQL_C_SSHORT, &PseudoColumn, 0, &cbPseudoColumn);

	rc = lst_ColumnNames(henv, hdbc, hstmt, 8);

	while(TRUE) {
		count++;

		rc = SQLFetch(hstmt);
		/* ERROR_CHECK(hstmt); */

		if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO){
			/* Process fetched data */
			if (cbColumnName == SQL_NULL_DATA) STRCPY(szColumnName, NULL_VALUE);
			if (cbTypeName == SQL_NULL_DATA) STRCPY(szTypeName, NULL_VALUE);
			if (cbScale == SQL_NULL_DATA) STRCPY(szScale, NULL_VALUE);
						 else SPRINTF(szScale, "%d", Scale);

			/* Scope information */
			switch (Scope) {
				case SQL_SCOPE_CURROW		: STRCPY(szScope,"SQL_SCOPE_CUUROW"); break;
				case SQL_SCOPE_TRANSACTION	: STRCPY(szScope,"SQL_SCOPE_TRANSACTION"); break;
				case SQL_SCOPE_SESSION		: STRCPY(szScope,"SQL_SCOPE_SESSION"); break;
			}
			/* PseudoColumn information */
			switch (PseudoColumn) {
				case SQL_PC_UNKNOWN	: STRCPY(szPseudoColumn,"SQL_PC_UNKNOWN"); break;
				case SQL_PC_PSEUDO	: STRCPY(szPseudoColumn,"SQL_PC_PSEUDO"); break;
				case SQL_PC_NOT_PSEUDO	: STRCPY(szPseudoColumn,"SQL_PC_NOT_PSEUDO"); break;
			}
			SPRINTF(buffer,
			  " Column %d : '%s','%s','%d','%s','%d','%d','%s','%s'"CRLF,
			  count, szScope, szColumnName, DataType, szTypeName, 
			  Precision, Length,  szScale, szPseudoColumn);
			PRINTF(buffer);
		} else { break; }
	    }
	return TRUE;
}
/* ----------------------------------------------------------------------- */
RETCODE lst_ColumnNames(HENV henv, HDBC hdbc, HSTMT hstmt, SWORD outcol)
{
	RETCODE                 rc;
	SWORD                   sErr=0;
/* ----------------------------------------------------------------------- */
	UWORD			icol;
	UCHAR                   szColName[MAX_NAME_LEN];
	SWORD                   cbColNameMax;
	SWORD                   pcbColName;
	SWORD			pfSqlType;
	SQLULEN			pcbColDef;
	SWORD			pibScale;
	SWORD			pfNullable;
/* ----------------------------------------------------------------------- */
	STRCPY(buffer,"Columns->|");

	icol = 1; cbColNameMax = MAX_COL_NAME_LEN;
	while (icol <= outcol) {
		rc = SQLDescribeCol(hstmt, icol, szColName, cbColNameMax, 
					&pcbColName, &pfSqlType, &pcbColDef, 
					&pibScale, &pfNullable);
		STRCAT(buffer, szColName); STRCAT(buffer,"|");
		icol++;
	}
	STRCAT(buffer, CRLF);
	PRINTF(buffer);

return(rc);
}
/* ------------------------------------------------------------------------- */
