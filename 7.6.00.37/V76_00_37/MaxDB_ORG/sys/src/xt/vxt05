/* @lastChanged: "1999-09-02 12:00"
 
 * @filename:   vxt05
 * @purpose:    "XT_auxiliary_procedures"
 * @release:    7.2.0.0
 * @see:        "-.-"
 *
 * @Copyright (c) 1998-2005 SAP AG"
 */
 
.tt 1 $SAP$LiveCache$VXT05$
.tt 3 $$XT_auxiliary_procedures$1999-12-01$
 
.nf
 
 .nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1998-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
 
 
.fo
***********************************************************
 
Module  : XT_auxiliary_procedures
 
Define  :
 
        PROCEDURE
              x05blockno_to_line (VAR file_pos : tut_file_pos;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              x05charwriteln (VAR term : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    VAR buf         : tsp00_MoveObj;
                    buf_size        : tsp00_Int4;
                    lwb             : tsp00_Int4;
                    upb             : tsp00_Int4;
                    new_line_offset : integer;
                    VAR ln_len      : integer;
                    VAR ln          : tsp00_Line;
                    ln_attr         : char);
 
        PROCEDURE
              x05close_file (VAR f : tut_file);
 
        PROCEDURE
              x05date_time_to_line (
                    date_int   : tsp00_Int4;
                    time_int   : tsp00_Int4;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              x05direct_entry (VAR term : tut_terminal;
                    VAR f           : tut_file;
                    wanted_pagetype : tgg00_PageType;
                    wanted_pno      : tsp00_Int4;
                    wanted_pos      : tsp00_Int4;
                    VAR entry_ptr   : tsp00_MoveObjPtr;
                    entry_size      : tsp00_Int4;
                    VAR err         : tsp00_VfReturn);
 
        PROCEDURE
              x05display_msg (VAR term : tut_terminal;
                    msg                : tsp00_C20;
                    is_warning         : boolean;
                    immediate_display  : boolean);
 
        PROCEDURE
              x05find_lwb_upb_pno (VAR term : tut_terminal;
                    VAR f            : tut_file;
                    wanted_pagetype  : tgg00_PageType;
                    VAR last_checkpt : tsp00_Int4;
                    VAR err          : tsp00_VfReturn);
 
        PROCEDURE
              x05find_sequential_lwb (VAR term : tut_terminal;
                    VAR f           : tut_file;
                    wanted_pagetype : tgg00_PageType;
                    VAR err         : tsp00_VfReturn);
 
        PROCEDURE
              x05get_direct (VAR term : tut_terminal;
                    VAR f             : tut_file;
                    wanted_block      : tsp00_Int4;
                    wanted_page       : tsp00_Int2;
                    VAR err           : tsp00_VfReturn);
 
        PROCEDURE
              x05get_file_pos (VAR f : tut_file;
                    wanted_pno       : tsp00_Int4;
                    VAR file_pos     : tut_file_pos);
 
        PROCEDURE
              x05get_next (VAR term : tut_terminal;
                    VAR f           : tut_file;
                    VAR err         : tsp00_VfReturn);
 
        PROCEDURE
              x05getint4 (VAR term : tut_terminal;
                    n       : tsp00_Name;
                    VAR int : tsp00_Int4);
 
        PROCEDURE
              x05getversion_no (VAR version_no : tsp00_Sname);
 
        PROCEDURE
              x05handle_hexint (VAR term : tut_terminal;
                    adjust : boolean;
                    n      : tsp00_Name;
                    VAR ln : tsp00_Line);
 
        PROCEDURE
              x05header (VAR term : tut_terminal;
                    VAR protfile  : tut_vf_fileref;
                    VAR progname  : tsp00_C20;
                    VAR fn        : tsp00_VFilename);
 
        PROCEDURE
              x05helphexint (VAR term : tut_terminal;
                    VAR pfkey : tut_pfkey);
 
        PROCEDURE
              x05hexint (VAR term : tut_terminal;
                    VAR protfile  : tut_vf_fileref;
                    VAR pfkey     : tut_pfkey);
 
        PROCEDURE
              x05hextrim_to_line (VAR buf : tsp00_MoveObj;
                    buf_pos    : tsp00_Int4;
                    buf_len    : tsp00_Int4;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              x05hexwriteln (VAR term : tut_terminal;
                    VAR protfile      : tut_vf_fileref;
                    with_td_buf       : boolean;
                    scan              : tut_diag_scan;
                    VAR buf           : tsp00_MoveObj;
                    buf_size          : tsp00_Int4;
                    lwb               : tsp00_Int4;
                    upb               : tsp00_Int4;
                    new_line_offset   : integer;
                    VAR ln_len        : integer;
                    VAR ln            : tsp00_Line;
                    ln_attr           : char);
 
        PROCEDURE
              x05holdhexint (VAR term : tut_terminal;
                    VAR pfkey : tut_pfkey);
 
        PROCEDURE
              x05hostfile_err (VAR term : tut_terminal;
                    io_msg  : tsp00_C6;
                    errtext : tsp00_ErrText);
 
        PROCEDURE
              x05init_file (VAR f : tut_file;
                    VAR blankfilename : tsp00_VFilename);
 
        PROCEDURE
              x05int_from_name (VAR term : tut_terminal;
                    displ_warning : boolean;
                    int2_wanted   : boolean;
                    n             : tsp00_Name;
                    VAR int       : tsp00_Int4;
                    VAR ok        : boolean);
 
        PROCEDURE
              x05int_to_name (int : tsp00_Int4; VAR n : tsp00_Name);
 
        PROCEDURE
              x05inthex_to_line (int : tsp00_Int4;
                    trim       : boolean;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        FUNCTION
              x05is_greater_file_pos (VAR arg1 : tut_file_pos;
                    VAR arg2 : tut_file_pos) : boolean;
 
        FUNCTION
              x05ishex (VAR buf : tsp00_MoveObj;
                    buf_size    : tsp00_Int4;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4): boolean;
 
        PROCEDURE
              x05name_to_int4 (VAR term : tut_terminal;
                    displ_warning : boolean;
                    n             : tsp00_Name;
                    VAR int       : tsp00_Int4;
                    VAR ok        : boolean);
 
        PROCEDURE
              x05next_entry (VAR term : tut_terminal;
                    VAR f             : tut_file;
                    wanted_pagetype   : tgg00_PageType;
                    VAR entry_ptr     : tsp00_MoveObjPtr;
                    entry_size        : tsp00_Int4;
                    VAR err           : tsp00_VfReturn);
 
        PROCEDURE
              x05open_data_sql_file (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    VAR f        : tut_file;
                    sql_packet   : tsp00_Addr;
                    sql_ref      : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x05open_file (VAR term : tut_terminal;
                    VAR f            : tut_file;
                    skip_mask        : boolean;
                    edit_file        : boolean;
                    rewind_option    : boolean;
                    msg_fn           : tsp00_C20;
                    VAR pfkey        : tut_pfkey);
 
        PROCEDURE
              x05open_undo_file (VAR term : tut_terminal;
                    VAR input_file   : tut_file;
                    VAR undo_file    : tut_file;
                    page_header_size : tsp00_Int4;
                    write_open       : boolean;
                    VAR pfkey        : tut_pfkey);
 
        PROCEDURE
              x05packet (VAR term : tut_terminal;
                    VAR protfile  : tut_vf_fileref;
                    is_minbuf     : boolean;
                    maxbuflength  : tsp00_Int4;
                    nam           : tsp00_Sname;
                    packet_ptr    : tsp1_packet_ptr);
 
        PROCEDURE
              x05pageno_to_line (pno : tsp00_Int4;
                    trim       : boolean;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              x05print_msg (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    msg          : tsp00_C20);
 
        PROCEDURE
              x05read_block_no_from_to (VAR term : tut_terminal;
                    only_from    : boolean;
                    VAR from_pos : tut_file_pos;
                    VAR to_pos   : tut_file_pos;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x05read_entry_pos_from_to (VAR term : tut_terminal;
                    VAR f        : tut_file;
                    only_from    : boolean;
                    VAR from_pno : tsp00_Int4;
                    VAR from_pos : tsp00_Int4;
                    VAR to_pno   : tsp00_Int4;
                    VAR to_pos   : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x05readint4 (VAR term : tut_terminal;
                    init_int  : boolean;
                    is_int2   : boolean;
                    msg       : tsp00_C20;
                    VAR int   : tsp00_Int4;
                    VAR pfkey : tut_pfkey);
 
        PROCEDURE
              x05read2_int4 (VAR term : tut_terminal;
                    init1_int : boolean;
                    is_1_int2 : boolean;
                    msg1      : tsp00_C20;
                    VAR i1    : tsp00_Int4;
                    init2_int : boolean;
                    is_2_int2 : boolean;
                    msg2      : tsp00_C20;
                    VAR i2    : tsp00_Int4;
                    VAR pfkey : tut_pfkey);
 
        PROCEDURE
              x05reset_scan (VAR scan : tut_diag_scan);
 
        PROCEDURE
              x05scanned_msg (VAR term : tut_terminal;
                    block_no       : tsp00_Int4;
                    VAR msg_time   : tsp00_Int4;
                    VAR last_displ : tsp00_Int4);
 
        PROCEDURE
              x05version (VAR term : tut_terminal;
                    VAR protfile   : tut_vf_fileref);
 
        PROCEDURE
              x05write_direct (VAR term : tut_terminal;
                    VAR f   : tut_file;
                    VAR err : tsp00_VfReturn);
 
        PROCEDURE
              x05write_seq (VAR term : tut_terminal;
                    VAR f   : tut_file;
                    VAR err : tsp00_VfReturn);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17cmdsegm_head (VAR cmdsegm_head : tsp1_segment_header;
                    VAR ln1_len : integer;
                    VAR ln1     : tsp00_Line;
                    VAR ln2_len : integer;
                    VAR ln2     : tsp00_Line;
                    VAR ln3_len : integer;
                    VAR ln3     : tsp00_Line);
 
        PROCEDURE
              g17date_to_line (date : tsp00_Date;
                    VAR ln_len      : integer;
                    VAR ln          : tsp00_Line);
 
        PROCEDURE
              g17hexto_line (c : char;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17intdate_time (
                    int_date     : tsp00_Int4;
                    int_time     : tsp00_Int4;
                    VAR str_date : tsp00_Date;
                    VAR str_time : tsp00_Time);
 
        PROCEDURE
              g17intern_warning_item_to_line (
                    warning_item : tsp1_intern_warning;
                    VAR ln_len   : integer;
                    VAR ln       : tsp00_Line);
 
        PROCEDURE
              g17int4to_line (int : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_Line);
 
        PROCEDURE
              g17messtype_to_line (mess_type : tgg00_MessType;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17nameto_line (n : tsp00_Name;
                    VAR ln_len  : integer;
                    VAR ln      : tsp00_Line);
 
        PROCEDURE
              g17packet_head (nam   : tsp00_Sname;
                    VAR packet_head : tsp1_packet_header;
                    VAR ln_len      : integer;
                    VAR ln          : tsp00_Line);
 
        PROCEDURE
              g17paraminfo_to_line (VAR pi : tsp1_param_info;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17varparaminfo_to_line (
                    VAR pi     : tsp1_param_info;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17paramspec_to_line (data_type : tsp00_DataType;
                    length     : tsp00_Int2;
                    frac       : tsp00_Uint1;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17parsidinfo_to_line (info : char;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17parthead (VAR part_head : tsp1_part_header;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        FUNCTION
              g17printable_char (c : char) : boolean;
 
        PROCEDURE
              g17returnsegm_head (
                    VAR retsegm_head : tsp1_segment_header;
                    VAR ln1_len      : integer;
                    VAR ln1          : tsp00_Line;
                    VAR ln2_len      : integer;
                    VAR ln2          : tsp00_Line);
 
        PROCEDURE
              g17sname_to_line (n : tsp00_Sname;
                    VAR ln_len    : integer;
                    VAR ln        : tsp00_Line);
 
        PROCEDURE
              g17time_to_line (time : tsp00_Time;
                    VAR ln_len      : integer;
                    VAR ln          : tsp00_Line);
 
        PROCEDURE
              g17trimint4_to_line (int : tsp00_Int4;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17warning_item_to_line (warning_item : tsp00_Warnings;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              TA_RTE_functions : VTA05;
 
        PROCEDURE
              t05sqlexec (VAR term : tut_terminal;
                    VAR cmd_ln     : tsp00_Line;
                    VAR errtext    : tsp00_ErrText;
                    VAR retcode    : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              TA_terminal_IO : VTA09;
 
        PROCEDURE
              t09display (VAR t09 : tut_terminal;
                    display_on : boolean);
 
        PROCEDURE
              t09get1name (VAR t09 : tut_terminal;
                    msg         : tsp00_C20;
                    msg_attr    : char;
                    in_attr     : char;
                    in_len      : integer;
                    upper_case  : boolean;
                    VAR in_name : tsp00_Name;
                    VAR pfkey   : tut_pfkey);
 
        PROCEDURE
              t09get2name (VAR t09 : tut_terminal;
                    msg1,        msg2        : tsp00_C20;
                    msg1_attr,   msg2_attr   : char;
                    in1_attr,    in2_attr    : char;
                    in1_len,     in2_len     : integer;
                    upper_case1, upper_case2 : boolean;
                    VAR in1_name,in2_name    : tsp00_Name;
                    VAR pfkey                : tut_pfkey);
 
        PROCEDURE
              t09header (VAR t09 : tut_terminal;
                    left_msg  : tsp00_C20;
                    right_msg : tsp00_C20);
 
        PROCEDURE
              t09help (VAR t09 : tut_terminal;
                    msg        : tsp00_C20;
                    upper_case : boolean;
                    VAR ln     : tsp00_Line;
                    VAR pfkey  : tut_pfkey);
 
        PROCEDURE
              t09holding (VAR term : tut_terminal;
                    VAR pfkey      : tut_pfkey);
 
        PROCEDURE
              t09mask (VAR term   : tut_terminal;
                    count_names   : integer;
                    mask_size     : integer;
                    VAR mask_spec : tut_term_mask;
                    return_pfkey  : boolean;
                    VAR pfkey     : tut_pfkey);
 
        PROCEDURE
              t09mask_c256_n (VAR term : tut_terminal;
                    count_names   : integer;
                    mask_size     : integer;
                    VAR mask_spec : tut_term_mask;
                    return_pfkey  : boolean;
                    VAR pfkey     : tut_pfkey);
 
        PROCEDURE
              t09newscreen_page (VAR t09 : tut_terminal);
 
        FUNCTION
              t09prot_linesize (VAR term : tut_terminal): integer;
 
        PROCEDURE
              t09put (VAR t09 : tut_terminal;
                    VAR text  : tsp00_Line;
                    text_attr : char);
 
        PROCEDURE
              t09put30 (VAR term : tut_terminal;
                    ln30         : tsp00_C30;
                    text_attr    : char);
 
        PROCEDURE
              t09putmsg (VAR t09      : tut_terminal;
                    VAR msg           : tsp00_Line;
                    is_warning        : boolean;
                    immediate_display : boolean);
 
        PROCEDURE
              t09returncode_set (VAR t09 : tut_terminal;
                    retcode : integer);
 
        PROCEDURE
              t09setpf1 (VAR term : tut_terminal; pfkey_label : tsp00_C8);
 
      ------------------------------ 
 
        FROM
              TA_write_protfile : VTA12;
 
        PROCEDURE
              t12write_prot (VAR fileref : tut_vf_fileref;
                    VAR ln    : tsp00_Line;
                    length    : integer;
                    VAR error : integer);
 
      ------------------------------ 
 
        FROM
              TA_buf_display : VTA14;
 
        PROCEDURE
              t14bufdisplay (VAR term : tut_terminal;
                    VAR protfile      : tut_vf_fileref;
                    scan              : tut_diag_scan;
                    msg               : tsp00_C30;
                    VAR buf           : tsp00_MoveObj;
                    buf_size          : tsp00_Int4;
                    startpos          : tsp00_Int4;
                    endpos            : tsp00_Int4;
                    start_numbering   : tsp00_Int4;
                    VAR break_pos     : tsp00_Int4;
                    VAR pfkey         : tut_pfkey);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        FUNCTION
              s20buf_to_int4 (VAR source : tsp00_MoveObj;
                    source_pos    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26next_segment (VAR segm_ptr : tsp1_segment_ptr);
 
        PROCEDURE
              s26nextpart (VAR part_ptr : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              GETSTRING-Conversions : VSP42;
 
        PROCEDURE
              s42gchr (
                    VAR buf  : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    len      : integer;
                    frac     : integer;
                    origlen  : integer;
                    VAR dest : tsp00_Line;
                    dpos     : tsp00_Int4;
                    VAR dlen : integer;
                    VAR res  : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              Version : VSP101;
 
        PROCEDURE
              sp101_GetVersionStringP  (
                    VAR ComponentNameP    : tsp00_C9;
                    VAR VersionStringP    : tsp00_Version);
 
      ------------------------------ 
 
        FROM
              UT_auxiliary_procedures : VUT05;
 
        FUNCTION
              u05isyes (VAR n : tsp00_Name): boolean;
 
      ------------------------------ 
 
        FROM
              UT_repair : VUT07;
 
        PROCEDURE
              u07read_page (VAR term : tut_terminal;
                    VAR protfile     : tut_vf_fileref;
                    snd_packet       : tsp00_Addr;
                    VAR sql_ref      : tsp00_Int4;
                    dev_type         : tut_dev_type;
                    devno            : tsp00_Int2;
                    VAR devspace     : tsp00_VFilename;
                    pno              : tsp00_Int4;
                    VAR buf          : tsp00_MoveObj;
                    VAR buf_len      : tsp00_Int4;
                    VAR sql_retcode  : tsp00_Int2);
 
        PROCEDURE
              u07write_page (VAR term : tut_terminal;
                    VAR protfile      : tut_vf_fileref;
                    snd_packet        : tsp00_Addr;
                    VAR sql_ref       : tsp00_Int4;
                    dev_type          : tut_dev_type;
                    devno             : tsp00_Int2;
                    VAR devspace      : tsp00_VFilename;
                    dev_pno           : tsp00_Int4;
                    VAR buf           : tsp00_MoveObj;
                    buf_len           : tsp00_Int4;
                    VAR sql_retcode   : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              RTE_driver : VEN102;
 
        PROCEDURE
              sqlallocat ( length : tsp00_Int4;
                    VAR p         : tsp00_MoveObjPtr;
                    VAR ok        : boolean);
 
        PROCEDURE
              sqlclock (VAR sec  : tsp00_Int4;
                    VAR microsec : tsp00_Int4);
 
        PROCEDURE
              sqlfclosep (fhandle : tsp00_Int4;
                    option        : tsp05_RteCloseOption;
                    VAR err       : tsp05_RteFileError);
 
        PROCEDURE
              sqlfopenp (VAR fname : tsp00_VFilename;
                    datakind       : tsp05_RteDataKind;
                    filemode       : tsp05_RteFileMode;
                    buffering      : tsp05_RteBufferingKind;
                    VAR fhandle    : tsp00_Int4;
                    VAR err        : tsp05_RteFileError);
 
        PROCEDURE
              sqlfreadp (fhandle : tsp00_Int4;
                    VAR buf      : tsp00_MoveObj;
                    bufsize      : tsp00_Longint;
                    VAR outlen   : tsp00_Longint;
                    VAR err      : tsp05_RteFileError);
 
        PROCEDURE
              sqlfree (p : tsp00_MoveObjPtr);
 
        PROCEDURE
              sqlflongseekp (fhandle : tsp00_Int4;
                    recsize  : tsp00_Longint;
                    reccount : tsp00_Longint;
                    whence   : tsp05_RteSeekKind;
                    VAR err  : tsp05_RteFileError);
 
        PROCEDURE
              sqlfsaveopenp (
                    VAR fname      : tsp00_VFilename;
                    filemode       : tsp05_RteFileMode;
                    VAR buffersize : tsp00_Int4;
                    VAR fhandle    : tsp00_Int4;
                    VAR bufptr     : tsp00_MoveObjPtr;
                    VAR err        : tsp05_RteFileError);
 
        PROCEDURE
              sqlfwritep (fhandle : tsp00_Int4;
                    VAR buf : tsp00_MoveObj;
                    inlen   : tsp00_Longint;
                    VAR err : tsp05_RteFileError);
 
        PROCEDURE
              sqlos (VAR os : tsp00_Os);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              sqlallocat;
 
              tsp00_ObjAddr tsp00_MoveObjPtr
 
        PROCEDURE
              sqlfree;
 
              tsp00_BufAddr tsp00_MoveObjPtr
 
        PROCEDURE
              sqlfsaveopenp;
 
              tsp00_ObjAddr tsp00_MoveObjPtr;
 
        PROCEDURE
              s42gchr;
 
              tsp00_MoveObj   tsp00_Line
 
        PROCEDURE
              u07read_page;
 
              tsp1_packet_ptr tsp00_Addr
              tsp00_Page      tsp00_MoveObj
 
        PROCEDURE
              u07write_page;
 
              tsp1_packet_ptr tsp00_Addr
              tsp00_Page      tsp00_MoveObj
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : JuergenA
.sp
.cp 3
Created : 1986-01-17
.sp
.cp 3
.sp
.cp 3
Release :      Date : 1999-12-01
.sp
***********************************************************
.sp
.cp 8
.fo
.oc _/1
Specification:
.sp 2
Procedure X05DISPLAY_MSG
.sp
Switches screen output on and outputs a 20-character string in the
message line.
.sp 2;.cp 4
Procedure X05GET_MESS_TYPE
.sp
Returns the message type, the name of the message type and the
length of the name for the character passed as parameter.
.sp 2;.cp 4
Procedure X05GET2_MESS2_TYPE
.sp
Returns the message2 type, the name of the mesage2 type and the
length of the name for the character passed as parameter.
.sp 2;.cp 4
Procedure X05INT4_TO_LINE
.sp
Inserts an integer as a string of length INT_LEN in the LINE line
at the position LN_POS.
.sp 2;.cp 4
Procedure X05IS_HEX
.sp
Returns TRUE if there is an unprintable character in the buffer
in the range specified by POS and LEN.
.sp 2;.cp 5
Procedure X05PRINT_MSG
.sp
Switches screen output off, writes a 20-character string into the
protocol file and displays the same line highlighted on the screen.
.sp 2;.cp 8
Procedure X05READ_INT4
.sp
Reads in an integer from the screen, with INIT_INT indicating
whether the integer is not yet initialized.
IS_INT indicates whether range checks should be run for a
two-byte integer. The MSG appears highlighted on the screen.
.br
Number can also be entered in hex with an 'X' as prefix.
.sp 2;.cp 3
Procedure X05READ2_INT4
.sp
Two integers are read in the same way as with X05READ_INT4.
.sp 2;.cp 4
Procedure X05SEEK
.sp
Executes SQLFSEEK. If the procedure is not available, a sequential
search for the page is started with CURR_PNO indicating the page
last read.
.sp 2;.cp 4
Procedure X05TRIM_INT4_TO_LINE
.sp
Inserts an integer as a string of the length of the integer in the
line LINE and increments the line length LN_LEN accordingly.
.sp 2;.cp 3
Procedure XT05HEXNAME_TO_INT4
.sp
A hex value in N is converted to a four-byte integer.
.sp 2;.cp 4
Procedure XT05INT4_TO_NAME
.sp
A four-byte integer is assigned to N as a string without leading
zeros or blanks.
.sp 2;.cp 3
Procedure XT05NAME_TO_INT4
.sp
A number in N is converted to a four-byte integer.
.sp 2;.cp 4
Procedure XT05SEQUENTIAL_SEEK
.sp
Sequential positioning at the record before WANTED_PNO, with
CURR_PNO refers to the page last read.
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_component       = 'DIAGNOSE ';
      (* *)
      c_io_open         = 'OPEN  ';
      c_io_read         = 'READ  ';
      c_io_seek         = 'SEEK  ';
      c_io_write        = 'WRITE ';
      (* *)
      c_pfkey_explorer  = 'explorer';
      c_call_explorer   = 'EXEC explorer .   ';
      (* *)
      c_entry_pos_msg   = 'invalid entry pos                       ';
      c_pos_msg         = 'illegal seek position specified         ';
      c_alloc_msg       = 'allocation of io-block failed           ';
      c_pages_msg       = 'invalid pages per block                 ';
      c_undo_fn         = 'editbuf.tmp ';
      (* *)
      c_immediate_displ = true;
      c_return_pfkey    = true;
      c_upper_case      = true;
      c_warning         = true;
      c_with_zero       = true;
      (* *)
      c_msg                 =    1;
      c_in                  =    2;
      c_display_interval    =    5;
      c_pt2_pos             =    6;
      c_pt_pos              =    5;
      maxhexlength          =    8;
      maxint4length         =   10;
      retcode_io_error      = -903;
      maxint4string         = '2147483647';
      (* *)
      mx_min_vtrace_head    = 16;
      mx_min_logentry_head  = 12;
      (* *)
 
 
(*------------------------------*) 
 
PROCEDURE
      x05blockno_to_line (VAR file_pos : tut_file_pos;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
BEGIN
IF  file_pos.utfp_block_no <> cut_nil_block_no
THEN
    WITH file_pos DO
        BEGIN
        g17sname_to_line ('  [block    ', ln_len, ln);
        ln_len := ln_len + 1;
        g17trimint4_to_line (utfp_block_no, ln_len, ln);
        IF  utfp_pages_per_block > 1
        THEN
            BEGIN
            ln_len      := ln_len + 1;
            ln [ln_len] := '/';
            g17trimint4_to_line (utfp_page_no, ln_len, ln)
            END;
        (*ENDIF*) 
        ln_len      := ln_len + 1;
        ln [ln_len] := ']'
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05charwriteln (VAR term : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            VAR buf         : tsp00_MoveObj;
            buf_size        : tsp00_Int4;
            lwb             : tsp00_Int4;
            upb             : tsp00_Int4;
            new_line_offset : integer;
            VAR ln_len      : integer;
            VAR ln          : tsp00_Line;
            ln_attr         : char);
 
VAR
      len      : integer;
      linesize : integer;
      err      : integer;
      curr_pos : tsp00_Int4;
 
BEGIN
curr_pos := lwb;
linesize := t09prot_linesize (term);
WHILE curr_pos <= upb DO
    BEGIN
    IF  ln_len + 3 > linesize
    THEN
        BEGIN
        t12write_prot (protfile, ln, ln_len, err);
        t09put (term, ln, ln_attr);
        ln     := term.blankline;
        ln_len := new_line_offset;
        IF  ln_len + 3 > linesize
        THEN
            ln_len := 0
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  curr_pos = lwb
    THEN
        BEGIN
        ln_len      := ln_len + 1;
        ln [ln_len] := ''''
        END;
    (*ENDIF*) 
    len := upb - curr_pos + 1;
    IF  ln_len + len  > linesize
    THEN
        len := linesize - ln_len;
    (*ENDIF*) 
    SAPDB_PascalForcedMove (buf_size, sizeof (ln),
          @buf, curr_pos, @ln, ln_len+1, len);
    ln_len   := ln_len   + len;
    curr_pos := curr_pos + len;
    IF  (curr_pos > upb) AND (ln_len < linesize)
    THEN
        BEGIN
        ln_len      := ln_len + 1;
        ln [ln_len] := ''''
        END;
    (*ENDIF*) 
    t12write_prot (protfile, ln, ln_len, err);
    t09put (term, ln, ln_attr);
    ln     := term.blankline;
    ln_len := new_line_offset
    END
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05close_file (VAR f : tut_file);
 
VAR
      close_option : tsp05_RteCloseOption; (* PTS 1103859 JA 1999-09-02 *)
      close_err    : tsp05_RteFileError;
 
BEGIN
IF  f.utf_fhandle <> 0
THEN
    BEGIN
    (* PTS 1103859 JA 1999-09-02 *)
    IF  f.utf_rewind
    THEN
        close_option := sp5vf_close_rewind
    ELSE
        close_option := sp5vf_close_normal;
    (*ENDIF*) 
    sqlfclosep (f.utf_fhandle, close_option, close_err)
    END;
(*ENDIF*) 
WITH f DO
    BEGIN
    utf_sql_dev_type      := utdt_nil;
    utf_block             := NIL;
    utf_page              := NIL;
    utf_fhandle           := 0;
    utf_first_offset      := cut_nil_block_no;
    utf_block_size        := 0;
    utf_block_len         := 0;
    utf_page_len          := 0;
    utf_pos.utfp_block_no := cut_nil_block_no;
    utf_pos.utfp_page_no  := 0;
    utf_sql_retcode       := 0;
    utf_sql_ref           := 0;
    utf_sql_packet        := NIL;
    utf_sql_prot          := NIL;
    utf_rewind            := false; (* PTS 1103859 JA 1999-09-02 *)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05date_time_to_line (
            date_int   : tsp00_Int4;
            time_int   : tsp00_Int4;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
VAR
      date_str : tsp00_Date;
      time_str : tsp00_Time;
 
BEGIN
g17intdate_time (date_int, time_int, date_str, time_str);
ln [ln_len+1] := 'a';
ln [ln_len+2] := 't';
ln_len        := ln_len + 3;
g17date_to_line (date_str, ln_len, ln);
ln_len := ln_len + 1;
g17time_to_line (time_str, ln_len, ln)
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05direct_entry (VAR term : tut_terminal;
            VAR f           : tut_file;
            wanted_pagetype : tgg00_PageType;
            wanted_pno      : tsp00_Int4;
            wanted_pos      : tsp00_Int4;
            VAR entry_ptr   : tsp00_MoveObjPtr;
            entry_size      : tsp00_Int4;
            VAR err         : tsp00_VfReturn);
 
VAR
      entry_found     : boolean;
      curr_entry_pos  : tsp00_Int4;
      curr_entry_len  : tsp00_Int4;
      min_entry_size  : tsp00_Int4;
      page_capacity   : tsp00_Int4;
      offset          : tsp00_Int4;
      i2              : tsp00_IntMapC2;
      wanted_file_pos : tut_file_pos;
 
BEGIN
err := vf_ok;
IF  wanted_pno > f.utf_cycle_upb_pno
THEN
    err := vf_eof;
(*ENDIF*) 
IF  (wanted_pno <> f.utf_entry_pno) AND (err = vf_ok)
THEN
    BEGIN
    x05get_file_pos (f, wanted_pno, wanted_file_pos);
    x05get_direct (term, f,
          wanted_file_pos.utfp_block_no,
          wanted_file_pos.utfp_page_no, err)
    END;
(*ENDIF*) 
IF  err = vf_ok
THEN
    BEGIN
    IF  wanted_pagetype = ptVtrace_egg00
    THEN
        BEGIN
        offset         := c_pt_pos;
        min_entry_size := mx_min_vtrace_head;
        page_capacity  := sizeof (tsp00_Page) - offset
        END
    ELSE
        (* p_log *)
        BEGIN
        offset := PAGE_HEADER_MXGG00 + INT4_MXSP00 (* sizeof (tgg00_LogPos)*);
        min_entry_size := mx_min_logentry_head;
        IF  ord (f.utf_page^[c_pt2_pos]) = ord (pt2Log_egg00)
        THEN
            page_capacity := s20buf_to_int4(f.utf_page^, PAGE_HEADER_MXGG00+1)-1
        ELSE
            page_capacity := 0
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (f.utf_entry_pos <= wanted_pos) AND
        (f.utf_entry_pos > 0)
    THEN
        curr_entry_pos := f.utf_entry_pos
    ELSE
        curr_entry_pos := 1;
    (*ENDIF*) 
    entry_found := false;
    WHILE NOT entry_found AND (err = vf_ok)
          AND
          (curr_entry_pos + min_entry_size - 1 <= page_capacity) DO
        BEGIN
        IF  wanted_pagetype = ptVtrace_egg00
        THEN
            BEGIN
            i2.mapC2_sp00 [1]  := f.utf_page^[offset + curr_entry_pos  ];
            i2.mapC2_sp00 [2]  := f.utf_page^[offset + curr_entry_pos+1];
            curr_entry_len := i2.mapInt_sp00
            END
        ELSE
            (* log page *)
            curr_entry_len := s20buf_to_int4 (f.utf_page^,
                  offset + curr_entry_pos);
        (*ENDIF*) 
        IF  curr_entry_len < min_entry_size
        THEN
            err := vf_notok
        ELSE
            IF  curr_entry_pos = wanted_pos
            THEN
                entry_found := true
            ELSE
                curr_entry_pos := curr_entry_pos + curr_entry_len
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  NOT entry_found
    THEN
        BEGIN
        err := vf_notok;
        x05hostfile_err (term, c_io_read, c_entry_pos_msg)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  err = vf_ok
THEN
    BEGIN
    f.utf_entry_pos := curr_entry_pos;
    IF  entry_size = 0
    THEN
        entry_ptr := @f.utf_page^[offset + curr_entry_pos]
    ELSE
        BEGIN
        IF  offset + curr_entry_pos + curr_entry_len - 1
            > f.utf_page_size
        THEN
            curr_entry_len :=
                  f.utf_page_size - offset - curr_entry_pos + 1;
        (*ENDIF*) 
        IF  curr_entry_len > entry_size
        THEN
            curr_entry_len := entry_size;
        (*ENDIF*) 
        SAPDB_PascalForcedMove (f.utf_page_size, entry_size,
              @f.utf_page^, offset + curr_entry_pos,
              @entry_ptr^, 1, curr_entry_len)
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05display_msg (VAR term : tut_terminal;
            msg                : tsp00_C20;
            is_warning         : boolean;
            immediate_display  : boolean);
 
VAR
      ln : tsp00_Line;
 
BEGIN
ln := term.blankline;
SAPDB_PascalForcedMove (sizeof (msg), sizeof (ln), @msg, 1, @ln, 1, sizeof (msg));
IF  NOT term.is_batch
THEN
    BEGIN
    t09display (term, true);
    t09putmsg (term, ln, is_warning, immediate_display)
    END
ELSE
    t09putmsg (term, ln, is_warning, immediate_display)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05find_lwb_upb_pno (VAR term : tut_terminal;
            VAR f            : tut_file;
            wanted_pagetype  : tgg00_PageType;
            VAR last_checkpt : tsp00_Int4;
            VAR err          : tsp00_VfReturn);
 
VAR
      cycle_found  : boolean;
      end_found    : boolean;
      dummy_micsec : tsp00_Int4;
      first_pno    : tsp00_Int4;
      last_displ   : tsp00_Int4;
      msg_time     : tsp00_Int4;
      (* *)
&     ifdef JA
      ln     : tsp00_Line;
      ln_len : integer;
      pfkey  : tut_pfkey;
&     endif
 
BEGIN
err := vf_ok;
f.utf_cycle_lwb.utfp_pages_per_block := f.utf_pos.utfp_pages_per_block;
f.utf_cycle_lwb.utfp_block_no        := cut_nil_block_no;
f.utf_cycle_lwb.utfp_page_no         := 0;
f.utf_cycle_upb     := f.utf_cycle_lwb;
f.utf_first         := f.utf_cycle_lwb;
f.utf_last          := f.utf_cycle_lwb;
f.utf_last_pno      := cut_nil_entry_pno;
f.utf_cycle_lwb_pno := MAX_INT4_SP00;
f.utf_cycle_upb_pno := -1;
cycle_found         := false;
end_found           := false;
last_displ          := 0;
sqlclock (msg_time, dummy_micsec);
(* *)
x05get_direct (term, f, 0, 1, err);
(* *)
WHILE (err = vf_ok) AND NOT cycle_found AND NOT end_found DO
    BEGIN
    IF  (f.utf_pos.utfp_block_no MOD 10) = 0
    THEN
        x05scanned_msg (term, f.utf_pos.utfp_block_no,
              msg_time, last_displ);
    (*ENDIF*) 
    IF  (   (wanted_pagetype = ptVtrace_egg00)
        AND (f.utf_entry_pno > 0)
        AND (ord (f.utf_page^[c_pt_pos]) = ord (ptVtrace_egg00)))
        OR
        (   (wanted_pagetype = ptLog_egg00)
        AND (f.utf_entry_pno > -1)
        AND (ord (f.utf_page^[c_pt_pos]) = ord (ptLog_egg00))
        AND
        ((ord (f.utf_page^[c_pt2_pos]) = ord (pt2Log_egg00       )) OR
        ( ord (f.utf_page^[c_pt2_pos]) = ord (pt2Checkpt_egg00))))
    THEN
        BEGIN
        f.utf_last     := f.utf_pos;
        f.utf_last_pno := f.utf_entry_pno;
        IF  f.utf_first.utfp_block_no = cut_nil_block_no
        THEN
            BEGIN
            f.utf_first := f.utf_pos;
            first_pno   := f.utf_entry_pno
            END;
        (*ENDIF*) 
        IF  f.utf_entry_pno < f.utf_cycle_lwb_pno
        THEN
            BEGIN
            f.utf_cycle_lwb     := f.utf_pos;
            f.utf_cycle_lwb_pno := f.utf_entry_pno
            END;
        (*ENDIF*) 
        IF  f.utf_entry_pno > f.utf_cycle_upb_pno
        THEN
            BEGIN
            f.utf_cycle_upb     := f.utf_pos;
            f.utf_cycle_upb_pno := f.utf_entry_pno
            END
        ELSE
            cycle_found := true;
        (*ENDIF*) 
        IF  wanted_pagetype = ptLog_egg00
        THEN
            BEGIN
            IF  (ord(f.utf_page^[c_pt2_pos]) = ord(pt2Checkpt_egg00))
                AND
                (* PTS 1000297 JA 1997-11-25 *)
                ((last_checkpt < f.utf_entry_pno)
                OR
                (last_checkpt = NIL_PAGE_NO_GG00))
            THEN
                last_checkpt := f.utf_entry_pno
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    ELSE
        IF  f.utf_last_pno <> cut_nil_entry_pno
        THEN
            end_found := true;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  cycle_found
    THEN
        BEGIN
        f.utf_last_pno           := first_pno - 1;
        f.utf_last.utfp_page_no  := f.utf_first.utfp_pages_per_block;
        f.utf_last.utfp_block_no :=
              (f.utf_first.utfp_page_no + f.utf_cycle_upb_pno
              - f.utf_cycle_lwb_pno)
              DIV f.utf_first.utfp_pages_per_block
              + f.utf_first.utfp_block_no - 1
        END;
    (*ENDIF*) 
    x05get_next (term, f, err)
    END;
(*ENDWHILE*) 
IF  err = vf_eof
THEN
    err := vf_ok;
(*ENDIF*) 
IF  f.utf_last_pno = cut_nil_entry_pno
THEN
    BEGIN
    err := vf_eof;
    IF  wanted_pagetype = ptVtrace_egg00
    THEN
        x05display_msg (term, 'VTRACE NOT FOUND    ', c_warning,
              NOT c_immediate_displ)
    ELSE
        x05display_msg (term, 'LOGENTRIES NOT FOUND', c_warning,
              NOT c_immediate_displ)
    (*ENDIF*) 
    END
(*ENDIF*) 
;
&ifdef JA
ln := term.blankline;
ln_len := 0;
g17sname_to_line ('upb.bl=     ', ln_len, ln);
g17trimint4_to_line (f.utf_cycle_upb.utfp_block_no, ln_len, ln);
(**)
g17sname_to_line ('  upb.pg=   ', ln_len, ln);
g17trimint4_to_line (f.utf_cycle_upb.utfp_page_no, ln_len, ln);
(**)
g17sname_to_line ('  lwb.bl=   ', ln_len, ln);
g17trimint4_to_line (f.utf_cycle_lwb.utfp_block_no, ln_len, ln);
(**)
g17sname_to_line ('  lwb.pg=   ', ln_len, ln);
g17trimint4_to_line (f.utf_cycle_lwb.utfp_page_no, ln_len, ln);
(**)
g17sname_to_line ('  first.bl= ', ln_len, ln);
g17trimint4_to_line (f.utf_first.utfp_block_no, ln_len, ln);
(**)
g17sname_to_line ('  first.pg= ', ln_len, ln);
g17trimint4_to_line (f.utf_first.utfp_page_no, ln_len, ln);
(**)
g17sname_to_line ('  last.bl=  ', ln_len, ln);
g17trimint4_to_line (f.utf_last.utfp_block_no, ln_len, ln);
(**)
g17sname_to_line ('  last.pg=  ', ln_len, ln);
g17trimint4_to_line (f.utf_last.utfp_page_no, ln_len, ln);
(**)
g17sname_to_line ('  last_pno= ', ln_len, ln);
g17trimint4_to_line (f.utf_last_pno, ln_len, ln);
(**)
g17sname_to_line ('  lwb_pno=  ', ln_len, ln);
g17trimint4_to_line (f.utf_cycle_lwb_pno, ln_len, ln);
(**)
g17sname_to_line ('  upb_pno=  ', ln_len, ln);
g17trimint4_to_line (f.utf_cycle_upb_pno, ln_len, ln);
(**)
t09put (term, ln, cut_bright_protected);
t09holding (term, pfkey);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05find_sequential_lwb (VAR term : tut_terminal;
            VAR f           : tut_file;
            wanted_pagetype : tgg00_PageType;
            VAR err         : tsp00_VfReturn);
 
VAR
      lwb_found    : boolean;
      dummy_micsec : tsp00_Int4;
      first_pno    : tsp00_Int4;
      last_displ   : tsp00_Int4;
      msg_time     : tsp00_Int4;
&     ifdef JA
      (* *)
      ln     : tsp00_Line;
      ln_len : integer;
      pfkey  : tut_pfkey;
&     endif
 
BEGIN
err := vf_ok;
f.utf_cycle_lwb.utfp_pages_per_block := f.utf_pos.utfp_pages_per_block;
f.utf_cycle_upb     := f.utf_cycle_lwb;
f.utf_first         := f.utf_cycle_lwb;
f.utf_last          := f.utf_cycle_lwb;
last_displ          := 0;
sqlclock (msg_time, dummy_micsec);
(* *)
x05get_direct (term, f, 0, 1, err);
(* *)
(* avoid sequential search --  use log_restart_rec *)
lwb_found := (f.utf_sql_devno = 1); (* log contains restart rec *)
(* *)
WHILE (err = vf_ok) AND NOT lwb_found DO
    BEGIN
    IF  (f.utf_pos.utfp_block_no MOD 10) = 0
    THEN
        x05scanned_msg (term, f.utf_pos.utfp_block_no,
              msg_time, last_displ);
    (*ENDIF*) 
    IF  (   (wanted_pagetype = ptVtrace_egg00)
        AND (f.utf_entry_pno > 0)
        AND (ord (f.utf_page^[c_pt_pos]) = ord (ptVtrace_egg00)))
        OR
        (   (wanted_pagetype = ptLog_egg00)
        AND (f.utf_entry_pno > -1)
        AND (ord (f.utf_page^[c_pt_pos]) = ord (ptLog_egg00))
        AND
        ((ord (f.utf_page^[c_pt2_pos]) = ord (pt2Log_egg00       )) OR
        ( ord (f.utf_page^[c_pt2_pos]) = ord (pt2Checkpt_egg00))))
    THEN
        BEGIN
        lwb_found := true;
        (* *)
        f.utf_first         := f.utf_pos;
        first_pno           := f.utf_entry_pno;
        (* *)
        f.utf_cycle_lwb     := f.utf_pos;
        f.utf_cycle_lwb_pno := f.utf_entry_pno;
        (* *)
        f.utf_cycle_upb.utfp_block_no := MAX_INT4_SP00;
        f.utf_cycle_upb.utfp_page_no  := f.utf_pos.utfp_pages_per_block;
        f.utf_cycle_upb_pno           := MAX_INT4_SP00;
        (* *)
        f.utf_last     := f.utf_cycle_upb;
        f.utf_last_pno := f.utf_cycle_upb_pno;
        END
    ELSE
        x05get_next (term, f, err)
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
&ifdef JA
;
ln := term.blankline;
ln_len := 0;
g17sname_to_line ('upb.bl=     ', ln_len, ln);
g17trimint4_to_line (f.utf_cycle_upb.utfp_block_no, ln_len, ln);
(**)
g17sname_to_line ('  upb.pg=   ', ln_len, ln);
g17trimint4_to_line (f.utf_cycle_upb.utfp_page_no, ln_len, ln);
(**)
g17sname_to_line ('  lwb.bl=   ', ln_len, ln);
g17trimint4_to_line (f.utf_cycle_lwb.utfp_block_no, ln_len, ln);
(**)
g17sname_to_line ('  lwb.pg=   ', ln_len, ln);
g17trimint4_to_line (f.utf_cycle_lwb.utfp_page_no, ln_len, ln);
(**)
g17sname_to_line ('  first.bl= ', ln_len, ln);
g17trimint4_to_line (f.utf_first.utfp_block_no, ln_len, ln);
(**)
g17sname_to_line ('  first.pg= ', ln_len, ln);
g17trimint4_to_line (f.utf_first.utfp_page_no, ln_len, ln);
(**)
g17sname_to_line ('  last.bl=  ', ln_len, ln);
g17trimint4_to_line (f.utf_last.utfp_block_no, ln_len, ln);
(**)
g17sname_to_line ('  last.pg=  ', ln_len, ln);
g17trimint4_to_line (f.utf_last.utfp_page_no, ln_len, ln);
(**)
g17sname_to_line ('  last_pno= ', ln_len, ln);
g17trimint4_to_line (f.utf_last_pno, ln_len, ln);
(**)
g17sname_to_line ('  lwb_pno=  ', ln_len, ln);
g17trimint4_to_line (f.utf_cycle_lwb_pno, ln_len, ln);
(**)
g17sname_to_line ('  upb_pno=  ', ln_len, ln);
g17trimint4_to_line (f.utf_cycle_upb_pno, ln_len, ln);
(**)
t09put (term, ln, cut_bright_protected);
t09holding (term, pfkey);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05get_direct (VAR term : tut_terminal;
            VAR f             : tut_file;
            wanted_block      : tsp00_Int4;
            wanted_page       : tsp00_Int2;
            VAR err           : tsp00_VfReturn);
 
VAR
      io_call  : tsp00_C6;
      aux_len  : tsp00_Longint;
      read_err : tsp05_RteFileError;
 
BEGIN
read_err.sp5fe_result := vf_ok;
f.utf_sql_retcode     := 0;
io_call               := c_io_read;
IF  (wanted_block < 0) OR
    (wanted_page  < 0) OR
    (wanted_page  > f.utf_pos.utfp_pages_per_block)
THEN
    BEGIN
    read_err.sp5fe_result := vf_notok;
    read_err.sp5fe_text   := c_pos_msg
    END
ELSE
    IF  f.utf_pos.utfp_block_no <> wanted_block
    THEN
        BEGIN
        IF  (f.utf_sql_dev_type = utdt_magic_rec_file) OR
            (f.utf_sql_dev_type = utdt_binary_file   )
        THEN
            WITH f.utf_pos DO
                BEGIN
                io_call := c_io_seek;
                IF  (wanted_block <> utfp_block_no + 1)
                    OR
                    (utfp_block_no = cut_nil_block_no)
                THEN
                    BEGIN
                    IF  (wanted_block > utfp_block_no)
                        AND
                        (utfp_block_no <> cut_nil_block_no)
                    THEN
                        sqlflongseekp (f.utf_fhandle,
                              f.utf_block_size,
                              wanted_block - utfp_block_no - 1,
                              sp5vf_seek_cur, read_err)
                    ELSE
                        sqlflongseekp (f.utf_fhandle,
                              f.utf_block_size,
                              f.utf_first_offset + wanted_block,
                              sp5vf_seek_begin, read_err)
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  read_err.sp5fe_result = vf_ok
                THEN
                    BEGIN
                    io_call         := c_io_read;
                    utfp_block_no   := wanted_block;
                    f.utf_entry_pno := cut_nil_entry_pno;
                    f.utf_entry_pos := 0;
                    sqlfreadp (f.utf_fhandle, f.utf_block^,
                          f.utf_block_size, aux_len,
                          read_err);
                    f.utf_block_len := aux_len
                    END
                (*ENDIF*) 
                END
            (*ENDWITH*) 
        ELSE
            WITH f DO
                BEGIN
                io_call               := c_io_read;
                utf_pos.utfp_block_no := wanted_block;
                utf_entry_pno         := cut_nil_entry_pno;
                utf_entry_pos         := 0;
                u07read_page (term, utf_sql_prot^, utf_sql_packet,
                      utf_sql_ref, utf_sql_dev_type,
                      utf_sql_devno, utf_fn, utf_pos.utfp_block_no,
                      utf_block^, utf_block_len, utf_sql_retcode);
                IF  utf_sql_retcode <> 0
                THEN
                    read_err.sp5fe_result := vf_notok
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  read_err.sp5fe_result <> vf_ok
        THEN
            BEGIN
            f.utf_block_len        := 0;
            f.utf_page_len         := 0;
            f.utf_pos.utfp_page_no := 0;
            IF  read_err.sp5fe_result <> vf_eof
            THEN
                f.utf_pos.utfp_block_no := cut_nil_block_no
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  read_err.sp5fe_result = vf_ok
THEN
    BEGIN
    f.utf_pos.utfp_page_no := wanted_page;
    xt05get_page_handling (f, read_err)
    END;
(*ENDIF*) 
IF  (read_err.sp5fe_result <> vf_ok ) AND
    (read_err.sp5fe_result <> vf_eof) AND
    (f.utf_sql_retcode = 0) (* not sql error already displayed *)
THEN
    x05hostfile_err (term, io_call, read_err.sp5fe_text);
(*ENDIF*) 
err := read_err.sp5fe_result
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05get_file_pos (VAR f : tut_file;
            wanted_pno       : tsp00_Int4;
            VAR file_pos     : tut_file_pos);
 
VAR
      first_page_no             : tsp00_Int2;
      pages_per_block           : tsp00_Int2;
      pages_within_first_block  : tsp00_Int2;
      (* *)
      blocks_behind_first_block : tsp00_Int4;
      first_block_no            : tsp00_Int4;
      first_pno                 : tsp00_Int4;
      pages_behind_first_block  : tsp00_Int4;
 
BEGIN
file_pos               := f.utf_pos;
file_pos.utfp_block_no := cut_nil_block_no;
file_pos.utfp_page_no  := 0;
IF  (wanted_pno >= f.utf_cycle_lwb_pno) AND
    (wanted_pno <= f.utf_cycle_upb_pno)
THEN
    BEGIN
    IF  wanted_pno > f.utf_last_pno
    THEN
        BEGIN
        first_block_no := f.utf_first.utfp_block_no;
        first_page_no  := f.utf_first.utfp_page_no;
        first_pno      := f.utf_last_pno + 1
        END
    ELSE
        BEGIN
        first_block_no := f.utf_cycle_lwb.utfp_block_no;
        first_page_no  := f.utf_cycle_lwb.utfp_page_no;
        first_pno      := f.utf_cycle_lwb_pno
        END;
    (*ENDIF*) 
    pages_per_block := f.utf_pos.utfp_pages_per_block;
    (* *)
    pages_within_first_block := pages_per_block - first_page_no + 1;
    (* *)
    pages_behind_first_block :=
          wanted_pno - first_pno + 1 - pages_within_first_block;
    (* *)
    blocks_behind_first_block :=
          (pages_behind_first_block + pages_per_block -1)
          DIV pages_per_block;
    (* *)
    file_pos.utfp_block_no :=
          first_block_no + blocks_behind_first_block;
    (* *)
    file_pos.utfp_page_no :=
          pages_behind_first_block
          - pages_per_block * (blocks_behind_first_block - 1)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05get_next (VAR term : tut_terminal;
            VAR f           : tut_file;
            VAR err         : tsp00_VfReturn);
 
VAR
      aux_len  : tsp00_Longint;
      read_err : tsp05_RteFileError;
 
BEGIN
read_err.sp5fe_result := vf_ok;
f.utf_sql_retcode     := 0;
WITH f.utf_pos DO
    IF  (utfp_page_no >= 1)
        AND
        (utfp_page_no < utfp_pages_per_block)
    THEN
        BEGIN
        utfp_page_no    := utfp_page_no + 1;
        f.utf_entry_pno := cut_nil_entry_pno;
        f.utf_entry_pos := 0
        END
    ELSE
        BEGIN
        utfp_block_no   := utfp_block_no + 1;
        utfp_page_no    := 1;
        f.utf_entry_pno := cut_nil_entry_pno;
        f.utf_entry_pos := 0;
        IF  (f.utf_sql_dev_type = utdt_magic_rec_file) OR
            (f.utf_sql_dev_type = utdt_binary_file   )
        THEN
            BEGIN
            sqlfreadp (f.utf_fhandle, f.utf_block^, f.utf_block_size, aux_len, read_err);
            f.utf_block_len := aux_len;
            END
        ELSE
            WITH f DO
                BEGIN
                u07read_page (term, utf_sql_prot^, utf_sql_packet,
                      utf_sql_ref, utf_sql_dev_type,
                      utf_sql_devno, utf_fn, utf_pos.utfp_block_no,
                      utf_block^, utf_block_len, utf_sql_retcode);
                IF  utf_sql_retcode <> 0
                THEN
                    read_err.sp5fe_result := vf_notok
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  read_err.sp5fe_result <> vf_ok
        THEN
            BEGIN
            f.utf_block_len := 0;
            f.utf_page_len  := 0;
            utfp_page_no    := 0;
            IF  read_err.sp5fe_result <> vf_eof
            THEN
                f.utf_pos.utfp_block_no := cut_nil_block_no
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
IF  read_err.sp5fe_result = vf_ok
THEN
    xt05get_page_handling (f, read_err);
(*ENDIF*) 
IF  (read_err.sp5fe_result <> vf_ok ) AND
    (read_err.sp5fe_result <> vf_eof) AND
    (f.utf_sql_retcode = 0) (* not sql error already displayed *)
THEN
    x05hostfile_err (term, c_io_read, read_err.sp5fe_text);
(*ENDIF*) 
err := read_err.sp5fe_result
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05getint4 (VAR term : tut_terminal;
            n       : tsp00_Name;
            VAR int : tsp00_Int4);
 
VAR
      ok : boolean;
 
BEGIN
x05name_to_int4 (term, NOT c_warning, n, int, ok);
IF  NOT ok
THEN
    int := -1
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05getversion_no (VAR version_no : tsp00_Sname);
 
VAR
      skip_blanks : boolean;
      pos         : integer;
      i           : integer;
      comptxt     : tsp00_C9;
      vers        : tsp00_Version;
 
BEGIN
comptxt     := c_component;
sp101_GetVersionStringP (comptxt, vers);
version_no  := bsp_sname;
pos         := 1;
skip_blanks := false;
(* skip: SQL_DB, blanks, DIAGNOSE, blanks *)
FOR i := 1 TO 2 DO
    BEGIN
    WHILE (pos < sizeof (vers))
          AND
          (((vers [pos] =  ' ') AND     skip_blanks)
          OR
          ( (vers [pos] <> ' ') AND NOT skip_blanks)) DO
        pos := pos + 1;
    (*ENDWHILE*) 
    skip_blanks := NOT skip_blanks
    END;
(*ENDFOR*) 
pos := pos - 1;
i   := 1;
WHILE (i <= sizeof (version_no)) AND (pos+i < sizeof (vers))
      AND (vers [pos+i] <> ' ') DO
    BEGIN
    version_no [i] := vers [pos+i];
    i := i + 1
    END
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05handle_hexint (VAR term : tut_terminal;
            adjust : boolean;
            n      : tsp00_Name;
            VAR ln : tsp00_Line);
 
VAR
      ok         : boolean;
      curr_code  : tsp00_CodeType;
      c          : char;
      i          : integer;
      byte_count : integer;
      len        : integer;
      ln_len     : integer;
 
      hex : RECORD
            CASE integer OF
                1:
                    (c : tsp00_C4);
                2:
                    (int : tsp00_Int4)
                END;
            (*ENDCASE*) 
 
 
BEGIN
ln     := term.blankline;
ln_len := 0;
IF  (n [1] = 'x') OR (n [1] = 'X')
THEN
    xt05hexname_to_int4 (term, n, hex.int, ok)
ELSE
    x05name_to_int4 (term, c_warning, n, hex.int, ok);
(*ENDIF*) 
IF  ok
THEN
    BEGIN
    byte_count := 4;
    i := 1;
    WHILE (byte_count > 1) AND (hex.c [i] = chr(0)) DO
        BEGIN
        i := i + 1;
        byte_count := byte_count - 1
        END;
    (*ENDWHILE*) 
    g17sname_to_line ('int:        ', ln_len, ln);
    ln_len := ln_len + 1;
    IF  adjust
    THEN
        BEGIN
        g17int4to_line (hex.int, false, 11, ln_len+1, ln);
        ln_len := ln_len + 11
        END
    ELSE
        g17trimint4_to_line (hex.int, ln_len, ln);
    (*ENDIF*) 
    g17sname_to_line ('   hex:     ', ln_len, ln);
    ln_len := ln_len + 1;
    IF  adjust
    THEN
        len := 4
    ELSE
        len := byte_count;
    (*ENDIF*) 
    FOR i := 4 - len + 1 TO 4 DO
        g17hexto_line (hex.c [i], ln_len, ln);
    (*ENDFOR*) 
    g17sname_to_line ('   ascii: '' ', ln_len, ln);
    FOR i := 4 - byte_count + 1 TO 4 DO
        BEGIN
        c := hex.c [i];
        ln_len := ln_len + 1;
        IF  g17printable_char (c)
        THEN
            ln [ln_len] := c
        ELSE
            ln [ln_len] := '.';
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    ln_len      := ln_len + 1;
    ln [ln_len] := '''';
    IF  adjust
    THEN
        ln_len := ln_len + 4 - len
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05header (VAR term : tut_terminal;
            VAR protfile  : tut_vf_fileref;
            VAR progname  : tsp00_C20;
            VAR fn        : tsp00_VFilename);
 
VAR
      err    : integer;
      i      : integer;
      len    : integer;
      ln_len : integer;
      pos    : integer;
      ln     : tsp00_Line;
      msg    : tsp00_C20;
 
BEGIN
len := sizeof (fn);
WHILE (len > 1) AND (fn [len] = ' ') DO
    len := len - 1;
(*ENDWHILE*) 
ln  := term.blankline;
ln_len := 0;
g17sname_to_line ('Input File: ', ln_len, ln);
ln_len := ln_len + 1;
FOR i := 1 TO len DO
    ln [ln_len + i] := fn [i];
(*ENDFOR*) 
ln_len := ln_len + len;
t12write_prot (protfile, term.blankline, 1, err);
t12write_prot (protfile, ln, ln_len, err);
IF  len > sizeof (msg)
THEN
    len := sizeof (msg);
(*ENDIF*) 
msg := bsp_c20;
FOR i := 1 TO len DO
    BEGIN
    pos := sizeof (msg) - len + i;
    msg [pos] := fn [i]
    END;
(*ENDFOR*) 
IF  progname <> bsp_c20
THEN
    t09header (term, progname, msg)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05helphexint (VAR term : tut_terminal;
            VAR pfkey : tut_pfkey);
 
VAR
      i   : integer;
      n   : tsp00_Name;
      msg : tsp00_C20;
      ln  : tsp00_Line;
 
BEGIN
pfkey := pf_none;
msg   := 'ENTER: int OR "X"hex';
REPEAT
    t09help (term, msg, true, ln, pfkey);
    msg := bsp_c20;
    IF  ln = term.blankline
    THEN
        pfkey := pf_end;
    (*ENDIF*) 
    IF  pfkey = pf_none
    THEN
        BEGIN
        FOR i := 1 TO sizeof (n) DO
            n [i] := ln [i];
        (*ENDFOR*) 
        x05handle_hexint (term, false, n, ln);
        IF  ln <> term.blankline
        THEN
            t09putmsg (term, ln, NOT c_warning, NOT c_immediate_displ)
        (*ENDIF*) 
        END
    (*ENDIF*) 
UNTIL
    pfkey <> pf_none;
(*ENDREPEAT*) 
IF  pfkey = pf_end
THEN
    pfkey := pf_none;
(*ENDIF*) 
t09putmsg (term, term.blankline, NOT c_warning, NOT c_immediate_displ)
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05hexint (VAR term : tut_terminal;
            VAR protfile  : tut_vf_fileref;
            VAR pfkey     : tut_pfkey);
 
VAR
      err : integer;
      n   : tsp00_Name;
      ln  : tsp00_Line;
 
BEGIN
n := bsp_name;
t09newscreen_page (term);
REPEAT
    t09put (term, term.blankline, cut_protected);
    t09get1name (term, '  integer OR "X"hex:', cut_protected,
          cut_unprotected, sizeof (n), true, n, pfkey);
    IF  (pfkey = pf_none) AND (n <> bsp_name)
    THEN
        BEGIN
        x05handle_hexint (term, true, n, ln);
        IF  ln <> term.blankline
        THEN
            BEGIN
            t09put (term, ln, cut_bright_protected);
            t12write_prot (protfile, term.blankline, 1, err);
            t12write_prot (protfile, ln, sizeof (ln), err)
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
UNTIL
    (pfkey <> pf_none) OR (n = bsp_name);
(*ENDREPEAT*) 
IF  pfkey = pf_end
THEN
    pfkey := pf_none
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05hextrim_to_line (VAR buf : tsp00_MoveObj;
            buf_pos    : tsp00_Int4;
            buf_len    : tsp00_Int4;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
VAR
      pos : tsp00_Int4;
 
BEGIN
pos := 1;
WHILE (pos < buf_len) AND (buf [buf_pos - 1 + pos] = chr(0)) DO
    pos := pos + 1;
(*ENDWHILE*) 
WHILE (pos <= buf_len) AND (ln_len + 2 < sizeof (ln)) DO
    BEGIN
    g17hexto_line (buf [buf_pos - 1 + pos], ln_len, ln);
    pos := pos + 1
    END
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05hexwriteln (VAR term : tut_terminal;
            VAR protfile      : tut_vf_fileref;
            with_td_buf       : boolean;
            scan              : tut_diag_scan;
            VAR buf           : tsp00_MoveObj;
            buf_size          : tsp00_Int4;
            lwb               : tsp00_Int4;
            upb               : tsp00_Int4;
            new_line_offset   : integer;
            VAR ln_len        : integer;
            VAR ln            : tsp00_Line;
            ln_attr           : char);
 
VAR
      hex_only    : boolean;
      is_first    : boolean;
      dummy_pfkey : tut_pfkey;
      cnt         : integer;
      len         : integer;
      err         : integer;
      linesize    : integer;
      outbuf_pos  : integer;
      i           : tsp00_Int4;
      curr_pos    : tsp00_Int4;
      dummy_pos   : tsp00_Int4;
      moveobj_ptr : tsp00_MoveObjPtr;
      outbuf      : tsp00_Page;
 
BEGIN
linesize := t09prot_linesize (term);
IF  with_td_buf
THEN
    BEGIN
    IF  ln_len > 0
    THEN
        BEGIN
        t12write_prot (protfile, ln, ln_len, err);
        t09put (term, ln, ln_attr)
        END;
    (*ENDIF*) 
    t14bufdisplay (term, protfile, scan, bsp_c30,
          buf, buf_size, lwb, upb, lwb, dummy_pos, dummy_pfkey)
    END
ELSE
    BEGIN
    curr_pos := lwb;
    IF  lwb > upb
    THEN
        BEGIN
        t12write_prot (protfile, ln, ln_len, err);
        t09put (term, ln, ln_attr);
        END
    ELSE
        BEGIN
        is_first := true;
        cnt      := 0;
        WHILE (curr_pos <= upb) AND (curr_pos <= buf_size) DO
            BEGIN
            len := linesize - ln_len;
            (* space behind 8 characters (4 bytes) *)
            len := len - (len DIV 9);
            (* two characters for one hex byte *)
            len := len DIV 2;
            IF  len >= upb - curr_pos + 1
            THEN
                len := upb - curr_pos + 1
            ELSE
                IF  is_first
                THEN
                    len := 0
                ELSE
                    (* 4 byte packages only *)
                    len := (len DIV 4) * 4;
                (*ENDIF*) 
            (*ENDIF*) 
            is_first := false;
            IF  len <= 0
            THEN
                BEGIN
                t12write_prot (protfile, ln, ln_len, err);
                t09put (term, ln, cut_protected);
                ln     := term.blankline;
                ln_len := new_line_offset;
                IF  ln_len > linesize - 8
                THEN
                    ln_len := linesize - 8
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                FOR i := 1 TO len DO
                    BEGIN
                    IF  (i > 1) AND (cnt MOD 4 = 0)
                    THEN
                        ln_len := ln_len + 1;
                    (*ENDIF*) 
                    g17hexto_line (buf [curr_pos], ln_len, ln);
                    curr_pos := curr_pos + 1;
                    cnt      := cnt + 1
                    END;
                (*ENDFOR*) 
                IF  curr_pos <= upb
                THEN
                    BEGIN
                    t12write_prot (protfile, ln, ln_len, err);
                    t09put (term, ln, cut_protected);
                    ln     := term.blankline;
                    ln_len := new_line_offset;
                    IF  ln_len > linesize - 8
                    THEN
                        ln_len := linesize - 8
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    hex_only   := true;
    cnt        := 0;
    outbuf_pos := 1;
    IF  upb - lwb + 1 <= sizeof (outbuf)
    THEN
        FOR i := lwb TO upb DO
            BEGIN
            IF  buf [i] = ' '
            THEN
                outbuf [outbuf_pos] := ' '
            ELSE
                IF  g17printable_char (buf [i])
                THEN
                    BEGIN
                    outbuf [outbuf_pos] := buf [i];
                    cnt := cnt + 1;
                    IF  cnt > 2
                    THEN
                        hex_only := false
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    outbuf [outbuf_pos] := '.';
                    cnt := 0
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            outbuf_pos := outbuf_pos + 1
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    IF  hex_only
    THEN
        BEGIN
        t12write_prot (protfile, ln, ln_len, err);
        t09put (term, ln, ln_attr)
        END
    ELSE
        BEGIN
        IF  ln_len + 3 + upb - lwb + 1 > linesize
        THEN
            BEGIN
            t12write_prot (protfile, ln, ln_len, err);
            t09put (term, ln, ln_attr);
            ln     := term.blankline;
            ln_len := new_line_offset
            END
        ELSE
            ln_len := ln_len + 1;
        (*ENDIF*) 
        moveobj_ptr := @outbuf;
        x05charwriteln (term, protfile, moveobj_ptr^, sizeof (outbuf),
              1, upb - lwb + 1, new_line_offset, ln_len, ln, ln_attr);
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
ln_len := 0;
ln     := term.blankline
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05holdhexint (VAR term : tut_terminal;
            VAR pfkey : tut_pfkey);
 
BEGIN
t09setpf1 (term, cut_pfkey_hexint);
t09holding (term, pfkey);
t09setpf1 (term, cut_pfkey_none);
IF  pfkey = pf_help
THEN
    x05helphexint (term, pfkey)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05hostfile_err (VAR term : tut_terminal;
            io_msg  : tsp00_C6;
            errtext : tsp00_ErrText);
 
VAR
      err_msg : tsp00_C40;
      i       : integer;
      ln_len  : integer;
      ln      : tsp00_Line;
 
BEGIN
t09returncode_set (term, retcode_io_error);
ln := term.blankline;
err_msg := '*** ERROR -903: HOST FILE xxxxx ERROR,  ';
FOR i := 1 TO 5 DO
    err_msg [26+i] := io_msg [i];
(*ENDFOR*) 
ln_len := 38;
FOR i := 1 TO ln_len DO
    ln [i] := err_msg [i];
(*ENDFOR*) 
ln_len := ln_len + 1;
i := 1;
WHILE (i <= sizeof (errtext)) AND (ln_len < sizeof (ln)) DO
    BEGIN
    ln_len      := ln_len + 1;
    ln [ln_len] := errtext [i];
    i := i + 1
    END;
(*ENDWHILE*) 
t09putmsg (term, ln, c_warning, NOT c_immediate_displ)
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05init_file (VAR f : tut_file;
            VAR blankfilename : tsp00_VFilename);
 
BEGIN
WITH f DO
    BEGIN
    utf_first_offset  := cut_nil_block_no;
    utf_cycle_lwb_pno := cut_nil_entry_pno;
    utf_cycle_upb_pno := cut_nil_entry_pno;
    utf_last_pno      := cut_nil_entry_pno;
    utf_entry_pno     := cut_nil_entry_pno;
    utf_entry_pos     := 0;
    utf_page_size     := sizeof (tsp00_Page);
    utf_page_len      := 0;
    utf_block_size    := 0;
    utf_block_len     := 0;
    utf_block         := NIL;
    utf_page          := NIL;
    utf_fhandle       := 0;
    utf_fn            := blankfilename;
    utf_filler1       := 0;
    utf_rewind        := false;
    utf_sql_devno     := 0;
    utf_sql_dev_type  := utdt_nil;
    utf_sql_retcode   := 0;
    utf_sql_ref       := 0;
    utf_sql_packet    := NIL;
    utf_sql_prot      := NIL
    END;
(*ENDWITH*) 
WITH f.utf_pos DO
    BEGIN
    utfp_pages_per_block := 1;
    utfp_page_no         := 0;
    utfp_block_no        := cut_nil_block_no
    END;
(*ENDWITH*) 
WITH f DO
    BEGIN
    utf_cycle_lwb := utf_pos;
    utf_cycle_upb := utf_pos;
    utf_first     := utf_pos;
    utf_last      := utf_pos
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05int_from_name (VAR term : tut_terminal;
            displ_warning : boolean;
            int2_wanted   : boolean;
            n             : tsp00_Name;
            VAR int       : tsp00_Int4;
            VAR ok        : boolean);
 
BEGIN
IF  n [1] = 'X'
THEN
    xt05hexname_to_int4 (term, n, int, ok)
ELSE
    x05name_to_int4 (term, c_warning, n, int, ok);
(*ENDIF*) 
IF  ok
THEN
    BEGIN
    ok := NOT int2_wanted
          OR
          ((int >= - MAX_INT2_SP00) AND (int <= MAX_INT2_SP00));
    IF  NOT ok AND displ_warning
    THEN
        x05display_msg (term, 'Number too large    ', c_warning,
              NOT c_immediate_displ)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05int_to_name (int : tsp00_Int4; VAR n : tsp00_Name);
 
VAR
      len     : integer;
 
      univ_ln : RECORD
            CASE integer OF
                1:
                    (ln  : tsp00_Line );
                2:
                    (nam : tsp00_Name)
                END;
            (*ENDCASE*) 
 
 
BEGIN
univ_ln.nam := bsp_name;
len         := 0;
g17trimint4_to_line (int, len, univ_ln.ln);
n := univ_ln.nam
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05inthex_to_line (int : tsp00_Int4;
            trim       : boolean;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
VAR
      pos : integer;
 
      i4_c4 : RECORD
            CASE boolean OF
                true:
                    (i : tsp00_Int4);
                false:
                    (c : tsp00_C4)
                END;
            (*ENDCASE*) 
 
 
BEGIN
i4_c4.i := int;
pos := 1;
WHILE trim AND (pos < 4) AND (i4_c4.c [pos] = chr(0)) DO
    pos := pos + 1;
(*ENDWHILE*) 
WHILE pos <= 4 DO
    BEGIN
    g17hexto_line (i4_c4.c [pos], ln_len, ln);
    pos := pos + 1
    END
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      x05is_greater_file_pos (VAR arg1 : tut_file_pos;
            VAR arg2 : tut_file_pos) : boolean;
 
BEGIN
(* is_greater_file_pos := arg1 > arg2 *)
x05is_greater_file_pos :=
      (arg1.utfp_block_no > arg2.utfp_block_no)
      OR
      ((arg1.utfp_block_no = arg2.utfp_block_no) AND
      ( arg1.utfp_page_no  > arg2.utfp_page_no ))
END;
 
(*------------------------------*) 
 
FUNCTION
      x05ishex (VAR buf : tsp00_MoveObj;
            buf_size    : tsp00_Int4;
            pos         : tsp00_Int4;
            len         : tsp00_Int4): boolean;
 
VAR
      i         : tsp00_Int4;
      hex_found : boolean;
 
BEGIN
i := pos;
hex_found := false;
IF  pos + len - 1 > buf_size
THEN
    hex_found := true;
(*ENDIF*) 
WHILE NOT hex_found AND (i < pos + len) AND (i <= buf_size) DO
    IF  g17printable_char (buf [i])
    THEN
        i := i + 1
    ELSE
        hex_found := true;
    (*ENDIF*) 
(*ENDWHILE*) 
x05ishex := hex_found
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05name_to_int4 (VAR term : tut_terminal;
            displ_warning : boolean;
            n             : tsp00_Name;
            VAR int       : tsp00_Int4;
            VAR ok        : boolean);
 
VAR
      intstring : PACKED ARRAY [1..maxint4length] OF char;
      factor    : integer;
      intlength : integer;
      i, pos    : integer;
 
BEGIN
ok := true;
intlength := 0;
IF  n [1] = '-'
THEN
    pos := 2
ELSE
    pos := 1;
(*ENDIF*) 
WHILE (pos < sizeof (n)) AND
      (n [pos] >= '0') AND (n [pos] <= '9') DO
    BEGIN
    intlength := intlength + 1;
    pos := pos + 1
    END;
(*ENDWHILE*) 
IF  (intlength = 0) OR (n [pos] <> ' ')
THEN
    BEGIN
    ok := false;
    IF  displ_warning
    THEN
        x05display_msg (term, 'Invalid number      ', c_warning,
              NOT c_immediate_displ)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ok AND (intlength > maxint4length)
THEN
    BEGIN
    ok := false;
    IF  displ_warning
    THEN
        x05display_msg (term, 'Number too long     ', c_warning,
              NOT c_immediate_displ)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ok AND (intlength = maxint4length)
THEN
    BEGIN
    FOR i := 1 TO maxint4length DO
        intstring [i] := n [pos-maxint4length-1+i];
    (*ENDFOR*) 
    IF  
        intstring > maxint4string
    THEN
        BEGIN
        ok := false;
        IF  displ_warning
        THEN
            x05display_msg (term, 'Number too large    ', c_warning,
                  NOT c_immediate_displ)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ok
THEN
    BEGIN
    pos    := pos - 1;
    int    := 0;
    factor := 1;
    FOR i := 1 TO intlength DO
        BEGIN
        int := int + factor * (ord (n [pos]) - ord ('0'));
        pos := pos - 1;
        IF  i < intlength
        THEN
            factor := factor * 10
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    IF  n [1] = '-'
    THEN
        int := - int
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05next_entry (VAR term : tut_terminal;
            VAR f             : tut_file;
            wanted_pagetype   : tgg00_PageType;
            VAR entry_ptr     : tsp00_MoveObjPtr;
            entry_size        : tsp00_Int4;
            VAR err           : tsp00_VfReturn);
 
VAR
      entry_found : boolean;
      offset      : integer;
      entry_len   : integer;
 
BEGIN
err         := vf_ok;
entry_len   := 0;
entry_found := false;
IF  f.utf_pos.utfp_block_no = cut_nil_block_no
THEN
    x05get_next (term, f, err);
(*ENDIF*) 
WHILE (err = vf_ok) AND NOT entry_found DO
    BEGIN
    xt05next_entry_pos (f, wanted_pagetype, entry_len, entry_found);
    IF  NOT entry_found
    THEN
        BEGIN
        IF  (f.utf_entry_pno = f.utf_last_pno     ) AND
            (f.utf_entry_pno < f.utf_cycle_upb_pno)
        THEN
            x05get_direct (term, f,
                  f.utf_first.utfp_block_no,
                  f.utf_first.utfp_page_no, err)
        ELSE
            IF  f.utf_entry_pno < f.utf_cycle_upb_pno
            THEN
                x05get_next (term, f, err)
            ELSE
                err := vf_eof
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  err = vf_ok
THEN
    BEGIN
    IF  wanted_pagetype = ptVtrace_egg00
    THEN
        offset := c_pt_pos
    ELSE
        offset := PAGE_HEADER_MXGG00 + INT4_MXSP00 (* sizeof (tgg00_LogPos)*);
    (*ENDIF*) 
    IF  f.utf_entry_pos + entry_len - 1 > f.utf_page_size
    THEN
        entry_len := f.utf_page_size - f.utf_entry_pos + 1;
    (*ENDIF*) 
    IF  entry_size = 0
    THEN
        entry_ptr := @f.utf_page^[offset + f.utf_entry_pos]
    ELSE
        BEGIN
        IF  entry_len > entry_size
        THEN
            entry_len := entry_size;
        (*ENDIF*) 
        SAPDB_PascalForcedMove (f.utf_page_size, entry_size,
              @f.utf_page^, offset + f.utf_entry_pos,
              @entry_ptr^, 1, entry_len)
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05open_data_sql_file (VAR term : tut_terminal;
            VAR protfile : tut_vf_fileref;
            VAR f        : tut_file;
            sql_packet   : tsp00_Addr;
            sql_ref      : tsp00_Int4;
            VAR pfkey    : tut_pfkey);
 
VAR
      is_ok : boolean;
 
BEGIN
pfkey := pf_none;
f.utf_sql_dev_type := utdt_data_perm;
f.utf_sql_prot     := @protfile;
f.utf_sql_packet   := sql_packet;
f.utf_sql_ref      := sql_ref;
f.utf_first_offset := 0;
f.utf_pos.utfp_pages_per_block := 1;
f.utf_block_size   := f.utf_page_size * f.utf_pos.utfp_pages_per_block;
sqlallocat (f.utf_block_size, f.utf_block, is_ok);
IF  NOT is_ok
THEN
    BEGIN
    x05hostfile_err (term, c_io_open, c_alloc_msg);
    pfkey := pf_end
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05open_file (VAR term : tut_terminal;
            VAR f            : tut_file;
            skip_mask        : boolean;
            edit_file        : boolean;
            rewind_option    : boolean;
            msg_fn           : tsp00_C20;
            VAR pfkey        : tut_pfkey);
 
CONST
      x_pages_per_block = 1;
      x_rewind          = 2;
      c_msg = 1;
      c_in  = 2;
 
VAR
      is_ok          : boolean;
      bIsFileLocked  : boolean;
      os             : tsp00_Os;
      filemode       : tsp05_RteFileMode;
      count          : integer;
      i              : integer;
      x_fn           : integer;
      retcode        : tsp00_Int2;
      i4             : tsp00_Int4;
      aux_block_size : tsp00_Int4;
      errtext        : tsp00_ErrText;
      msg            : tut_c20_array;
      mask           : tut_term_mask;
      open_err       : tsp05_RteFileError;
      bin_open_err   : tsp05_RteFileError;
 
      exec_cmdline : RECORD
            CASE integer OF
                1:
                    (ln  : tsp00_Line);
                2:
                    (cmd : tsp00_Name)
                END;
            (*ENDCASE*) 
 
 
BEGIN
pfkey         := pf_none;
count         := 1;
is_ok         := false;
bIsFileLocked := false;
IF  edit_file
THEN
    filemode := sp5vf_readwrite
ELSE
    filemode := sp5vf_read;
(*ENDIF*) 
IF  f.utf_block <> NIL
THEN
    sqlfree (f.utf_block);
(*ENDIF*) 
WITH f DO
    BEGIN
    utf_sql_dev_type      := utdt_nil;
    utf_block             := NIL;
    utf_page              := NIL;
    utf_first_offset      := cut_nil_block_no;
    utf_block_size        := 0;
    utf_block_len         := 0;
    utf_page_len          := 0;
    utf_fhandle           := 0;
    utf_pos.utfp_block_no := cut_nil_block_no;
    utf_pos.utfp_page_no  := 0;
    utf_rewind            := false; (* PTS 1103859 JA 1999-09-02 *)
    END;
(*ENDWITH*) 
sqlos (os);
IF  os = os_win32
THEN
    t09setpf1 (term, c_pfkey_explorer);
(*ENDIF*) 
REPEAT
    IF  skip_mask
    THEN
        is_ok := true
    ELSE
        BEGIN
        t09newscreen_page (term);
        FOR i := 1 TO 20 DO
            WITH mask [i] DO
                BEGIN
                msg_in_attr [c_msg] := cut_protected;
                msg_in_attr [c_in ] := cut_bright_unprotected;
                upper_case := true;
                code_input := false;
                in_len     := sizeof (tsp00_Name);
                in_name    := bsp_name;
                in_c256    := term.blankfilename
                END;
            (*ENDWITH*) 
        (*ENDFOR*) 
        mask [x_pages_per_block].msg := '   PAGES PER BLOCK :';
        x05int_to_name (f.utf_pos.utfp_pages_per_block, mask[x_pages_per_block].in_name);
        IF  rewind_option
        THEN
            (* PTS 1103859 JA 1999-09-02 *)
            BEGIN
            x_fn := x_rewind + 1;
            mask [x_rewind].msg     := 'REWIND WHEN CLOSING?';
            mask [x_rewind].in_name := 'n                 ';
            END
        ELSE
            x_fn := x_pages_per_block + 1;
        (*ENDIF*) 
        (* *)
        mask [x_fn].msg        := msg_fn;
        mask [x_fn].upper_case := false;
        mask [x_fn].in_len     := sizeof (f.utf_fn);
        mask [x_fn].in_fn      := f.utf_fn;
        t09mask_c256_n (term, x_fn-1, x_fn, mask, NOT c_return_pfkey, pfkey);
        IF  pfkey = pf_none
        THEN
            BEGIN
            f.utf_fn := mask [x_fn].in_fn;
            x05name_to_int4 (term, c_warning, mask [x_pages_per_block].in_name, i4, is_ok);
            IF  is_ok
            THEN
                BEGIN
                IF  i4 < 1
                THEN
                    BEGIN
                    is_ok := false;
                    x05hostfile_err (term, c_io_open, c_pages_msg)
                    END
                ELSE
                    f.utf_pos.utfp_pages_per_block := i4;
                (*ENDIF*) 
                IF  rewind_option
                THEN
                    (* PTS 1103859 JA 1999-09-02 *)
                    f.utf_rewind := u05isyes (mask [x_rewind].in_name)
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        ELSE
            IF  pfkey = pf_help
            THEN
                BEGIN
                is_ok := false;
                pfkey := pf_none;
                IF  os = os_win32
                THEN
                    BEGIN
                    exec_cmdline.ln  := term.blankline;
                    exec_cmdline.cmd := c_call_explorer;
                    t05sqlexec (term, exec_cmdline.ln, errtext, retcode)
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  is_ok
    THEN
        BEGIN
        f.utf_block_size := f.utf_page_size * f.utf_pos.utfp_pages_per_block;
        aux_block_size   := f.utf_block_size;
        sqlfsaveopenp (f.utf_fn, filemode, aux_block_size, f.utf_fhandle, f.utf_block, open_err);
        IF  open_err.sp5fe_result <> vf_ok
        THEN
            BEGIN
            is_ok         := false;
            bIsFileLocked := (open_err.sp5fe_warning = sp5vfw_already_locked);
            END
        ELSE
            BEGIN
            IF  f.utf_block_size MOD PAGE_MXSP00 <> 0
            THEN
                is_ok := false
            ELSE
                BEGIN
                f.utf_sql_dev_type := utdt_magic_rec_file;
                f.utf_first_offset := 1; (* seek: skip magic record *)
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  NOT is_ok
        THEN
            BEGIN
            IF  f.utf_block <> NIL
            THEN
                sqlfree (f.utf_block);
            (*ENDIF*) 
            sqlfopenp (f.utf_fn, sp5vf_binary, filemode, sp5bk_unbuffered, f.utf_fhandle, bin_open_err);
            IF  bin_open_err.sp5fe_result <> vf_ok
            THEN
                BEGIN
                IF  open_err.sp5fe_result <> vf_ok
                THEN
                    x05hostfile_err (term, c_io_open, open_err.sp5fe_text)
                ELSE
                    x05hostfile_err (term, c_io_open, bin_open_err.sp5fe_text)
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                is_ok := true;
                sqlallocat (f.utf_block_size, f.utf_block, is_ok);
                IF  NOT is_ok
                THEN
                    x05hostfile_err (term, c_io_open, c_alloc_msg)
                ELSE
                    BEGIN
                    f.utf_sql_dev_type := utdt_binary_file;
                    IF  bIsFileLocked
                    THEN
                        f.utf_first_offset := 1 (* seek: skip magic record, because file is a volume *)
                    ELSE
                        f.utf_first_offset := 0
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    count := count + 1;
UNTIL
    (count > 3) OR is_ok OR (pfkey <> pf_none) OR skip_mask;
(*ENDREPEAT*) 
t09setpf1 (term, cut_pfkey_none);
IF  NOT is_ok
THEN
    pfkey := pf_end
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05open_undo_file (VAR term : tut_terminal;
            VAR input_file   : tut_file;
            VAR undo_file    : tut_file;
            page_header_size : tsp00_Int4;
            write_open       : boolean;
            VAR pfkey        : tut_pfkey);
 
VAR
      is_ok    : boolean;
      filemode : tsp05_RteFileMode;
      i        : integer;
      n        : tsp00_Sname;
      answer   : tsp00_Name;
      open_err : tsp05_RteFileError;
 
BEGIN
pfkey := pf_none;
n     := c_undo_fn;
undo_file.utf_fn := term.blankfilename;
FOR i := 1 TO sizeof (n) DO
    undo_file.utf_fn [i] := n [i];
(*ENDFOR*) 
IF  write_open
THEN
    filemode := sp5vf_append
ELSE
    filemode := sp5vf_read;
(*ENDIF*) 
sqlfopenp (undo_file.utf_fn, sp5vf_binary, filemode,
      sp5bk_unbuffered, undo_file.utf_fhandle, open_err);
IF  open_err.sp5fe_result <> vf_ok
THEN
    BEGIN
    is_ok := false;
    x05hostfile_err (term, c_io_open, open_err.sp5fe_text)
    END
ELSE
    BEGIN
    undo_file.utf_page_size :=
          page_header_size + input_file.utf_page_size;
    undo_file.utf_block_size := undo_file.utf_page_size;
    sqlallocat (undo_file.utf_block_size, undo_file.utf_block, is_ok);
    IF  NOT is_ok
    THEN
        x05hostfile_err (term, c_io_open, c_alloc_msg)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  NOT is_ok
THEN
    BEGIN
    IF  NOT write_open OR term.is_inputfile
    THEN
        pfkey := pf_none
    ELSE
        BEGIN
        answer := 'y                 ';
        t09put (term, term.blankline, cut_protected);
        t09put30 (term, 'open UNDO FILE failed !       ',
              cut_bright_protected);
        t09get1name (term, 'continue (y/n) ?    ', cut_bright_protected,
              cut_unprotected, 2, c_upper_case, answer, pfkey);
        IF  pfkey = pf_none
        THEN
            BEGIN
            IF  NOT u05isyes (answer)
            THEN
                pfkey := pf_end
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05packet (VAR term : tut_terminal;
            VAR protfile  : tut_vf_fileref;
            is_minbuf     : boolean;
            maxbuflength  : tsp00_Int4;
            nam           : tsp00_Sname;
            packet_ptr    : tsp1_packet_ptr);
 
VAR
      scan      : tut_diag_scan;
      dummy_err : integer;
      ln_len    : integer;
      segm_no   : integer;
      segm_ptr  : tsp1_segment_ptr;
      ln        : tsp00_Line;
 
BEGIN
g17packet_head (nam, packet_ptr^.sp1_header, ln_len, ln);
t12write_prot (protfile, ln, ln_len, dummy_err);
segm_ptr := @packet_ptr^.sp1_segm;
FOR segm_no := 1 TO packet_ptr^.sp1_header.sp1h_no_of_segm DO
    BEGIN
    IF  segm_no > 1
    THEN
        s26next_segment (segm_ptr);
    (*ENDIF*) 
    IF  is_minbuf
    THEN
        scan := [utds_minbuf]
    ELSE
        scan := [ ];
    (*ENDIF*) 
    xt05segment (term, protfile, scan, maxbuflength, segm_ptr^)
    END
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05pageno_to_line (pno : tsp00_Int4;
            trim       : boolean;
            VAR ln_len : integer;
            VAR ln     : tsp00_Line);
 
CONST
      c_align_pno_digits =       7;
      c_align_max_pno    = 9999999;
 
BEGIN
IF  pno = NIL_PAGE_NO_GG00
THEN
    BEGIN
    IF  NOT trim
    THEN
        ln_len := ln_len + c_align_pno_digits - 3;
    (*ENDIF*) 
    ln [ln_len+1] := 'n';
    ln [ln_len+2] := 'i';
    ln [ln_len+3] := 'l';
    ln_len := ln_len + 3
    END
ELSE
    BEGIN
    IF  trim OR (pno > c_align_max_pno)
    THEN
        g17trimint4_to_line (pno, ln_len, ln)
    ELSE
        BEGIN
        g17int4to_line (pno, NOT c_with_zero, c_align_pno_digits,
              ln_len + 1, ln);
        ln_len := ln_len + c_align_pno_digits
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05print_msg (VAR term : tut_terminal;
            VAR protfile     : tut_vf_fileref;
            msg              : tsp00_C20);
 
VAR
      ln  : tsp00_Line;
      err : integer;
 
BEGIN
ln := term.blankline;
SAPDB_PascalForcedMove (sizeof (msg), sizeof (ln), @msg, 1, @ln, 1, sizeof (msg));
t09put (term, ln, cut_bright_protected);
t12write_prot (protfile, ln, sizeof (msg), err)
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05read_block_no_from_to (VAR term : tut_terminal;
            only_from    : boolean;
            VAR from_pos : tut_file_pos;
            VAR to_pos   : tut_file_pos;
            VAR pfkey    : tut_pfkey);
 
CONST
      c_msg = 1;
      c_in  = 2;
 
VAR
      is_ok        : boolean;
      curr_ok      : boolean;
      count        : integer;
      i            : integer;
      mask_size    : integer;
      x_from_block : integer;
      x_from_page  : integer;
      x_to_block   : integer;
      x_to_page    : integer;
      i4           : tsp00_Int4;
      mask         : tut_term_mask;
 
BEGIN
pfkey := pf_none;
count := 1;
IF  from_pos.utfp_pages_per_block > 1
THEN
    BEGIN
    x_from_block := 1;
    x_from_page  := 2;
    x_to_block   := 3;
    x_to_page    := 4;
    mask_size    := 4
    END
ELSE
    BEGIN
    x_from_block := 1;
    x_from_page  := 1;
    x_to_block   := 2;
    x_to_page    := 2;
    mask_size    := 2
    END;
(*ENDIF*) 
IF  only_from
THEN
    mask_size := x_from_page;
(*ENDIF*) 
xt05check_block_no_from_to (from_pos, to_pos);
REPEAT
    t09newscreen_page (term);
    FOR i := 1 TO 20 DO
        WITH mask [i] DO
            BEGIN
            msg_in_attr [c_msg] := cut_protected;
            msg_in_attr [c_in ] := cut_bright_unprotected;
            upper_case := true;
            code_input := false;
            in_len     := sizeof (tsp00_Name);
            in_name    := bsp_name;
            in_c256    := term.blankfilename;
            msg        := bsp_c20
            END;
        (*ENDWITH*) 
    (*ENDFOR*) 
    ;
    (* pages_per_block = 1  --> msg [x_..._block] := '...PAGE NO' *)
    IF  only_from
    THEN
        BEGIN
        mask [x_from_block].msg := '            BLOCK NO';
        mask [x_from_page ].msg := '            BLOCK NO'
        END
    ELSE
        IF  from_pos.utfp_pages_per_block > 1
        THEN
            BEGIN
            mask [x_from_block].msg := '  FROM TAPE BLOCK NO';
            mask [x_from_page ].msg := '       FROM BLOCK NO';
            mask [x_to_block  ].msg := '  TO TAPE BLOCK NO  ';
            mask [x_to_page   ].msg := '       TO   BLOCK NO'
            END
        ELSE
            BEGIN
            mask [x_from_block].msg := '       FROM BLOCK NO';
            mask [x_to_block  ].msg := '         TO BLOCK NO'
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    x05int_to_name (from_pos.utfp_page_no, mask [x_from_page].in_name);
    x05int_to_name (from_pos.utfp_block_no,mask [x_from_block].in_name);
    IF  NOT only_from
    THEN
        BEGIN
        x05int_to_name (to_pos.utfp_page_no, mask [x_to_page].in_name);
        x05int_to_name (to_pos.utfp_block_no, mask [x_to_block].in_name)
        END;
    (*ENDIF*) 
    t09mask (term, mask_size, mask_size, mask,
          NOT c_return_pfkey, pfkey);
    is_ok := true;
    IF  pfkey = pf_none
    THEN
        BEGIN
        x05name_to_int4 (term, c_warning, mask [x_from_block].in_name,
              from_pos.utfp_block_no, curr_ok);
        IF  NOT curr_ok
        THEN
            is_ok := false
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  pfkey = pf_none
    THEN
        BEGIN
        x05name_to_int4 (term, c_warning, mask [x_from_page].in_name,
              i4, curr_ok);
        IF  curr_ok
        THEN
            from_pos.utfp_page_no := i4
        ELSE
            is_ok := false
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (pfkey = pf_none) AND NOT only_from
    THEN
        BEGIN
        x05name_to_int4 (term, c_warning, mask [x_to_block].in_name,
              to_pos.utfp_block_no, curr_ok);
        IF  NOT curr_ok
        THEN
            is_ok := false
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (pfkey = pf_none) AND NOT only_from
    THEN
        BEGIN
        x05name_to_int4 (term, c_warning, mask [x_to_page].in_name,
              i4, curr_ok);
        IF  curr_ok
        THEN
            to_pos.utfp_page_no := i4
        ELSE
            is_ok := false
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    count := count + 1
UNTIL
    (count > 3) OR is_ok OR (pfkey <> pf_none);
(*ENDREPEAT*) 
IF  NOT is_ok
THEN
    pfkey := pf_end;
(*ENDIF*) 
xt05check_block_no_from_to (from_pos, to_pos)
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05read_entry_pos_from_to (VAR term : tut_terminal;
            VAR f        : tut_file;
            only_from    : boolean;
            VAR from_pno : tsp00_Int4;
            VAR from_pos : tsp00_Int4;
            VAR to_pno   : tsp00_Int4;
            VAR to_pos   : tsp00_Int4;
            VAR pfkey    : tut_pfkey);
 
CONST
      c_msg      = 1;
      c_in       = 2;
      (* *)
      x_from_pno = 1;
      x_from_pos = 2;
      x_to_pno   = 3;
      x_to_pos   = 4;
 
VAR
      is_ok     : boolean;
      curr_ok   : boolean;
      count     : integer;
      i         : integer;
      mask_size : integer;
      mask      : tut_term_mask;
 
BEGIN
pfkey     := pf_none;
count     := 1;
is_ok     := false;
IF  only_from
THEN
    mask_size := x_from_pos
ELSE
    mask_size := x_to_pos;
(*ENDIF*) 
xt05check_entry_pos_from_to (f, from_pno, from_pos, to_pno, to_pos);
REPEAT
    t09newscreen_page (term);
    FOR i := 1 TO 20 DO
        WITH mask [i] DO
            BEGIN
            msg_in_attr [c_msg] := cut_protected;
            msg_in_attr [c_in ] := cut_bright_unprotected;
            upper_case := true;
            code_input := false;
            in_len     := sizeof (tsp00_Name);
            in_name    := bsp_name;
            in_c256    := term.blankfilename;
            msg        := bsp_c20
            END;
        (*ENDWITH*) 
    (*ENDFOR*) 
    IF  only_from
    THEN
        BEGIN
        mask [x_from_pno].msg := '           ENTRY PNO';
        mask [x_from_pos].msg := '           ENTRY POS'
        END
    ELSE
        BEGIN
        mask [x_from_pno].msg := '      FROM ENTRY PNO';
        mask [x_from_pos].msg := '      FROM ENTRY POS';
        mask [x_to_pno  ].msg := '      TO   ENTRY PNO';
        mask [x_to_pos  ].msg := '      TO   ENTRY POS'
        END;
    (*ENDIF*) 
    x05int_to_name (from_pno, mask [x_from_pno].in_name);
    x05int_to_name (from_pos, mask [x_from_pos].in_name);
    IF  NOT only_from
    THEN
        BEGIN
        x05int_to_name (to_pno, mask [x_to_pno].in_name);
        x05int_to_name (to_pos, mask [x_to_pos].in_name)
        END;
    (*ENDIF*) 
    t09mask (term, mask_size, mask_size, mask,
          NOT c_return_pfkey, pfkey);
    is_ok := true;
    IF  pfkey = pf_none
    THEN
        BEGIN
        x05name_to_int4 (term, c_warning, mask [x_from_pno].in_name,
              from_pno, curr_ok);
        IF  NOT curr_ok
        THEN
            is_ok := false
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  pfkey = pf_none
    THEN
        BEGIN
        x05name_to_int4 (term, c_warning, mask [x_from_pos].in_name,
              from_pos, curr_ok);
        IF  NOT curr_ok
        THEN
            is_ok := false
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (pfkey = pf_none) AND NOT only_from
    THEN
        BEGIN
        x05name_to_int4 (term, c_warning, mask [x_to_pno].in_name,
              to_pno, curr_ok);
        IF  NOT curr_ok
        THEN
            is_ok := false
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (pfkey = pf_none) AND NOT only_from
    THEN
        BEGIN
        x05name_to_int4 (term, c_warning, mask [x_to_pos].in_name,
              to_pos, curr_ok);
        IF  NOT curr_ok
        THEN
            is_ok := false
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    count := count + 1
UNTIL
    (count > 3) OR is_ok OR (pfkey <> pf_none);
(*ENDREPEAT*) 
IF  NOT is_ok
THEN
    pfkey := pf_end;
(*ENDIF*) 
xt05check_entry_pos_from_to (f, from_pno, from_pos, to_pno, to_pos)
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05readint4 (VAR term : tut_terminal;
            init_int  : boolean;
            is_int2   : boolean;
            msg       : tsp00_C20;
            VAR int   : tsp00_Int4;
            VAR pfkey : tut_pfkey);
 
VAR
      n  : tsp00_Name;
      ok : boolean;
 
BEGIN
ok := true;
n  := bsp_name;
IF  init_int
THEN
    int := 0
ELSE
    x05int_to_name (int, n);
(*ENDIF*) 
t09get1name (term, msg, cut_protected, cut_bright_unprotected,
      sizeof (n), true, n, pfkey);
IF  pfkey = pf_none
THEN
    BEGIN
    x05int_from_name (term, c_warning, is_int2, n, int, ok);
    IF  NOT ok
    THEN
        pfkey := pf_end
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05read2_int4 (VAR term : tut_terminal;
            init1_int : boolean;
            is_1_int2 : boolean;
            msg1      : tsp00_C20;
            VAR i1    : tsp00_Int4;
            init2_int : boolean;
            is_2_int2 : boolean;
            msg2      : tsp00_C20;
            VAR i2    : tsp00_Int4;
            VAR pfkey : tut_pfkey);
 
VAR
      n1 : tsp00_Name;
      n2 : tsp00_Name;
      ok : boolean;
 
BEGIN
ok := true;
n1 := bsp_name;
n2 := bsp_name;
IF  init1_int
THEN
    i1 := 0
ELSE
    x05int_to_name (i1, n1);
(*ENDIF*) 
IF  init2_int
THEN
    i2 := 0
ELSE
    x05int_to_name (i2, n2);
(*ENDIF*) 
t09get2name (term, msg1, msg2, cut_protected,
      cut_protected, cut_bright_unprotected, cut_bright_unprotected,
      sizeof (n1), sizeof (n2), true, true, n1, n2, pfkey);
IF  pfkey = pf_none
THEN
    x05int_from_name (term, c_warning, is_1_int2, n1, i1, ok);
(*ENDIF*) 
IF  ok AND (pfkey = pf_none)
THEN
    x05int_from_name (term, c_warning, is_2_int2, n2, i2, ok);
(*ENDIF*) 
IF  NOT ok AND (pfkey = pf_none)
THEN
    pfkey := pf_end
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05reset_scan (VAR scan : tut_diag_scan);
 
BEGIN
scan := scan - [
      utds_buffer_output,
      utds_page_header,
      utds_full_info,
      utds_bd_full_info,
      utds_node,
      utds_key,
      utds_key_first_last,
      utds_key_buf,
      utds_rec,
      utds_dump_label,
      utds_fdir,
      utds_logentry_header,
      utds_logentry_full_info,
      utds_logentry_buf]
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05scanned_msg (VAR term : tut_terminal;
            block_no       : tsp00_Int4;
            VAR msg_time   : tsp00_Int4;
            VAR last_displ : tsp00_Int4);
 
VAR
      ln_len       : integer;
      curr_time    : tsp00_Int4;
      dummy_micsec : tsp00_Int4;
      ln           : tsp00_Line;
 
BEGIN
sqlclock (curr_time, dummy_micsec);
IF  curr_time - msg_time >= c_display_interval
THEN
    BEGIN
    msg_time   := curr_time;
    last_displ := block_no;
    ln         := term.blankline;
    ln_len     := 0;
    g17trimint4_to_line (block_no, ln_len, ln);
    ln_len := ln_len + 1;
    g17sname_to_line ('blocks      ', ln_len, ln);
    t09display (term, true);
    t09putmsg  (term, ln, NOT c_warning, c_immediate_displ)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05version (VAR term : tut_terminal;
            VAR protfile   : tut_vf_fileref);
 
VAR
      dummy_err   : integer;
      vers        : tsp00_Version;
      ln          : tsp00_Line;
      comptxt     : tsp00_C9;
 
BEGIN
comptxt := c_component;
(* PTS 1104704 *)
sp101_GetVersionStringP (comptxt, vers);
ln   := term.blankline;
SAPDB_PascalForcedMove (sizeof (vers), sizeof (ln), @vers, 1, @ln, 1, sizeof (vers));
t09putmsg (term, ln, NOT c_warning, NOT c_immediate_displ);
t12write_prot (protfile, term.blankline, 1, dummy_err);
t12write_prot (protfile, ln, sizeof (vers), dummy_err)
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05write_direct (VAR term : tut_terminal;
            VAR f   : tut_file;
            VAR err : tsp00_VfReturn);
 
VAR
      write_err : tsp05_RteFileError;
      io_call   : tsp00_C6;
 
BEGIN
write_err.sp5fe_result := vf_ok;
f.utf_sql_retcode      := 0;
io_call                := c_io_write;
WITH f.utf_pos DO
    IF  (utfp_block_no < 0) OR
        (utfp_page_no  < 0) OR
        (utfp_page_no  > utfp_pages_per_block)
    THEN
        BEGIN
        write_err.sp5fe_result := vf_notok;
        write_err.sp5fe_text   := c_pos_msg
        END
    ELSE
        BEGIN
        IF  (f.utf_sql_dev_type = utdt_magic_rec_file) OR
            (f.utf_sql_dev_type = utdt_binary_file   )
        THEN
            BEGIN
            io_call := c_io_seek;
            sqlflongseekp (f.utf_fhandle,
                  f.utf_block_size,
                  f.utf_first_offset + utfp_block_no,
                  sp5vf_seek_begin, write_err);
            IF  write_err.sp5fe_result = vf_ok
            THEN
                BEGIN
                io_call := c_io_write;
                sqlfwritep (f.utf_fhandle, f.utf_block^,
                      f.utf_block_len, write_err)
                END
            (*ENDIF*) 
            END
        ELSE
            WITH f DO
                BEGIN
                u07write_page (term, utf_sql_prot^, utf_sql_packet,
                      utf_sql_ref, utf_sql_dev_type, utf_sql_devno,
                      utf_fn, utf_pos.utfp_block_no,
                      utf_block^, utf_block_len, utf_sql_retcode);
                IF  utf_sql_retcode <> 0
                THEN
                    write_err.sp5fe_result := vf_notok
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  write_err.sp5fe_result <> vf_ok
        THEN
            BEGIN
            f.utf_block_len := 0;
            f.utf_page_len  := 0;
            utfp_page_no    := 0;
            utfp_block_no   := cut_nil_block_no
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
IF  (write_err.sp5fe_result <> vf_ok) AND
    (f.utf_sql_retcode = 0) (* not sql error already displayed *)
THEN
    x05hostfile_err (term, io_call, write_err.sp5fe_text);
(*ENDIF*) 
err := write_err.sp5fe_result
END;
 
(*------------------------------*) 
 
PROCEDURE
      x05write_seq (VAR term : tut_terminal;
            VAR f   : tut_file;
            VAR err : tsp00_VfReturn);
 
VAR
      write_err : tsp05_RteFileError;
 
BEGIN
write_err.sp5fe_result := vf_ok;
sqlfwritep (f.utf_fhandle, f.utf_block^, f.utf_block_len, write_err);
IF  write_err.sp5fe_result <> vf_ok
THEN
    x05hostfile_err (term, c_io_write, write_err.sp5fe_text);
(*ENDIF*) 
err := write_err.sp5fe_result
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt05check_block_no_from_to (
            VAR from_pos : tut_file_pos;
            VAR to_pos   : tut_file_pos);
 
BEGIN
IF  from_pos.utfp_block_no < 0
THEN
    BEGIN
    from_pos.utfp_block_no := 0;
    from_pos.utfp_page_no  := 1
    END
ELSE
    IF  (from_pos.utfp_page_no < 1                            ) OR
        (from_pos.utfp_page_no > from_pos.utfp_pages_per_block)
    THEN
        from_pos.utfp_page_no := 1;
    (*ENDIF*) 
(*ENDIF*) 
IF  to_pos.utfp_block_no < from_pos.utfp_block_no
THEN
    to_pos := from_pos
ELSE
    IF  (to_pos.utfp_block_no = from_pos.utfp_block_no)
        AND
        ((to_pos.utfp_page_no < from_pos.utfp_page_no        ) OR
        ( to_pos.utfp_page_no > from_pos.utfp_pages_per_block))
    THEN
        to_pos := from_pos
    ELSE
        IF  (to_pos.utfp_page_no < 1                            ) OR
            (to_pos.utfp_page_no > from_pos.utfp_pages_per_block)
        THEN
            to_pos.utfp_page_no := 1
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt05check_entry_pos_from_to (VAR f : tut_file;
            VAR from_pno : tsp00_Int4;
            VAR from_pos : tsp00_Int4;
            VAR to_pno   : tsp00_Int4;
            VAR to_pos   : tsp00_Int4);
 
BEGIN
IF  from_pno < f.utf_cycle_lwb_pno
THEN
    from_pno := f.utf_cycle_lwb_pno
ELSE
    IF  from_pno > f.utf_cycle_upb_pno
    THEN
        from_pno := f.utf_cycle_upb_pno;
    (*ENDIF*) 
(*ENDIF*) 
IF  (from_pos < 1) OR (from_pos > sizeof (tsp00_Page))
THEN
    from_pos := 1;
(*ENDIF*) 
IF  to_pno < from_pno
THEN
    to_pno := from_pno
ELSE
    IF  to_pno > f.utf_cycle_upb_pno
    THEN
        to_pno := f.utf_cycle_upb_pno;
    (*ENDIF*) 
(*ENDIF*) 
IF  (to_pos < 1) OR (to_pos > sizeof (tsp00_Page))
THEN
    to_pos := 1;
(*ENDIF*) 
IF  (to_pno = from_pno) AND (to_pos < from_pos)
THEN
    to_pos := from_pos
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt05get_page_handling (VAR f : tut_file;
            VAR read_err : tsp05_RteFileError);
 
BEGIN
WITH f.utf_pos DO
    IF  f.utf_block_len < (utfp_page_no * f.utf_page_size)
    THEN
        read_err.sp5fe_result := vf_eof
    ELSE
        BEGIN
        IF  (f.utf_page_size = 0)
            AND
            (utfp_pages_per_block = 1)
        THEN
            f.utf_page_len := f.utf_block_len
        ELSE
            f.utf_page_len := f.utf_page_size;
        (*ENDIF*) 
        f.utf_page :=
              @f.utf_block^ [1 + (utfp_page_no - 1) * f.utf_page_size];
        f.utf_entry_pno := s20buf_to_int4 (f.utf_page^, 1);
        f.utf_entry_pos := 0
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt05hexname_to_int4 (VAR term : tut_terminal;
            n       : tsp00_Name;
            VAR int : tsp00_Int4;
            VAR ok  : boolean);
 
VAR
      factor      : integer;
      hexlength   : integer;
      digit       : integer;
      i, k, pos   : integer;
      len         : integer;
      invalid_hex : tsp00_Name;
 
      hex4      : RECORD
            CASE integer OF
                1:
                    (c : tsp00_C4);
                2:
                    (int : tsp00_Int4)
                END;
            (*ENDCASE*) 
 
 
      hex2      : RECORD
            CASE integer OF
                1:
                    (c : tsp00_C2);
                2:
                    (int : tsp00_Int2)
                END;
            (*ENDCASE*) 
 
 
BEGIN
ok        := true;
int       := 0;
hexlength := 0;
pos       := 2;
WHILE (pos < sizeof (n)) AND
      ((n [pos] >= '0') AND (n [pos] <= '9')) OR
      ((n [pos] >= 'A') AND (n [pos] <= 'F')) DO
    BEGIN
    hexlength := hexlength + 1;
    pos := pos + 1
    END;
(*ENDWHILE*) 
hex4.int := 1;
IF  hex4.c [4] = chr(1)
THEN
    invalid_hex := 'X80000000         '
ELSE
    IF  hex4.c [1] = chr(1)
    THEN
        invalid_hex := 'X00000080         '
    ELSE
        invalid_hex := 'X00008000         ';
    (*ENDIF*) 
(*ENDIF*) 
IF  (hexlength = 0) OR (n [pos] <> ' ') OR (n = invalid_hex)
THEN
    BEGIN
    ok := false;
    x05display_msg (term, 'Invalid HEX         ', c_warning,
          NOT c_immediate_displ)
    END;
(*ENDIF*) 
IF  ok AND (hexlength > maxhexlength)
THEN
    BEGIN
    ok := false;
    x05display_msg (term, 'HEX too long        ', c_warning,
          NOT c_immediate_displ)
    END;
(*ENDIF*) 
IF  ok
THEN
    BEGIN
    pos := pos - 1;
    hex4.int := 0;
    hex2.int := 0;
    IF  hexlength > 4
    THEN
        len := 4
    ELSE
        IF  hexlength > 2
        THEN
            len := 2
        ELSE
            len := 1;
        (*ENDIF*) 
    (*ENDIF*) 
    FOR i := len DOWNTO 1 DO
        BEGIN
        factor := 1;
        FOR k := 1 TO 2 DO
            BEGIN
            IF  pos < 2
            THEN
                digit := 0
            ELSE
                BEGIN
                IF  (n [pos] >= '0') AND (n [pos] <= '9')
                THEN
                    digit := ord (n [pos]) - ord ('0')
                ELSE
                    IF  (n [pos] >= 'A') AND (n [pos] <= 'F')
                    THEN
                        digit := ord (n [pos]) - ord ('A') + 10;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  len = 4
                THEN
                    hex4.c [i]:= chr(ord (hex4.c [i]) + factor * digit)
                ELSE
                    hex2.c [i]:= chr(ord (hex2.c [i]) + factor * digit);
                (*ENDIF*) 
                pos    := pos - 1;
                factor := factor * 16
                END
            (*ENDIF*) 
            END
        (*ENDFOR*) 
        END;
    (*ENDFOR*) 
    IF  len = 4
    THEN
        int := hex4.int
    ELSE
        IF  len = 2
        THEN
            int := hex2.int
        ELSE
            int := ord (hex2.c [1])
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt05next_entry_pos (VAR f : tut_file;
            wanted_pagetype     : tgg00_PageType;
            VAR entry_len       : tsp00_Int4;
            VAR entry_found     : boolean);
 
VAR
      curr_entry_pos : tsp00_Int4;
      old_entry_pos  : tsp00_Int4;
      min_entry_size : tsp00_Int4;
      page_capacity  : tsp00_Int4;
      offset         : tsp00_Int4;
      i2             : tsp00_IntMapC2;
 
BEGIN
entry_found   := false;
old_entry_pos := f.utf_entry_pos;
IF  f.utf_entry_pos <= 1
THEN
    curr_entry_pos := 1
ELSE
    curr_entry_pos := f.utf_entry_pos;
(*ENDIF*) 
IF  wanted_pagetype = ptVtrace_egg00
THEN
    BEGIN
    offset         := c_pt_pos;
    min_entry_size := mx_min_vtrace_head;
    page_capacity  := sizeof (tsp00_Page) - offset
    END
ELSE
    BEGIN
    offset := PAGE_HEADER_MXGG00 + INT4_MXSP00 (* sizeof (tgg00_LogPos)*);
    min_entry_size := mx_min_logentry_head;
    IF  ord (f.utf_page^[c_pt2_pos]) = ord (pt2Log_egg00)
    THEN
        BEGIN
        i2.mapC2_sp00 [1] := f.utf_page^[offset-1]; (* logpos *)
        i2.mapC2_sp00 [2] := f.utf_page^[offset  ];
        page_capacity := i2.mapInt_sp00 - 1
        END
    ELSE
        page_capacity := 0
    (*ENDIF*) 
    END;
(*ENDIF*) 
WHILE NOT entry_found
      AND
      (curr_entry_pos + min_entry_size - 1 <= page_capacity) DO
    BEGIN
    IF  wanted_pagetype = ptVtrace_egg00
    THEN
        BEGIN
        i2.mapC2_sp00 [1]  := f.utf_page^[offset + curr_entry_pos  ];
        i2.mapC2_sp00 [2]  := f.utf_page^[offset + curr_entry_pos+1];
        entry_len      := i2.mapInt_sp00
        END
    ELSE
        (* log page *)
        entry_len := s20buf_to_int4 (f.utf_page^, offset + curr_entry_pos);
    (*ENDIF*) 
    IF  (entry_len < min_entry_size) OR (entry_len > page_capacity)
    THEN
        curr_entry_pos := page_capacity + 1 (* no entry found *)
    ELSE
        IF  curr_entry_pos <> old_entry_pos
        THEN
            BEGIN
            entry_found     := true;
            f.utf_entry_pos := curr_entry_pos
            END
        ELSE
            curr_entry_pos := curr_entry_pos + entry_len
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt05packet_part (VAR term : tut_terminal;
            VAR protfile        : tut_vf_fileref;
            scan                : tut_diag_scan;
            maxbuflength        : tsp00_Int4;
            VAR packet_part     : tsp1_part);
 
VAR
      dummy_pfkey : tut_pfkey;
      dummy_err   : integer;
      dummy_pos   : integer;
      ln_len      : integer;
      upb         : tsp00_Int4;
      msg         : tsp00_C30;
      ln          : tsp00_Line;
      displ_buf   : boolean;
 
BEGIN
g17parthead (packet_part.sp1p_part_header, ln_len, ln);
t12write_prot (protfile, ln, ln_len, dummy_err);
msg := 'partbuf                       ';
IF  packet_part.sp1p_buf_len > maxbuflength
THEN
    upb := maxbuflength
ELSE
    upb := packet_part.sp1p_buf_len;
(*ENDIF*) 
IF  packet_part.sp1p_buf_len > 0
THEN
    BEGIN
    xt05special_part_buf (term, protfile, packet_part, displ_buf);
    IF  displ_buf
    THEN
        t14bufdisplay (term, protfile, scan, msg,
              packet_part.sp1p_buf, packet_part.sp1p_buf_size, 1, upb,
              1, dummy_pos, dummy_pfkey)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt05special_part_buf (VAR term : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            VAR packet_part : tsp1_part;
            VAR displ_buf   : boolean);
 
CONST
      c_messtype_pos  = 9;
      c_p_info_pos    = 11;
      c_packet_indent = 9;
 
VAR
      numb_err        : tsp00_NumError;
      err             : integer;
      ln_len, ln2_len : integer;
      len             : integer;
      pos             : integer;
      ln, ln2         : tsp00_Line;
      curr_i          : tsp00_Int2;
      pi_ptr          : ^tsp1_param_info;
      psl_ptr         : ^tsp1_param_spec_list;
      arg_size        : integer;
      ix              : integer;
 
      c1_mtype : RECORD
            CASE boolean OF
                true :
                    (c1    : char);
                false :
                    (mtype : tgg00_MessType);
                END;
            (*ENDCASE*) 
 
 
BEGIN
displ_buf := true;
WITH packet_part DO
    BEGIN
    CASE  sp1p_part_kind OF
        sp1pk_resultcount:
            BEGIN
            ln      := term.blankline;
            ln_len  := c_packet_indent;
            g17nameto_line ('result_count:     ', ln_len, ln);
            IF  sp1p_buf[1] = csp_undef_byte
            THEN
                BEGIN
                displ_buf := false;
                g17sname_to_line (' UNDEF      ', ln_len, ln);
                t12write_prot (protfile, ln, ln_len, err)
                END
            ELSE
                BEGIN
                s42gchr (sp1p_buf, 2, csp_resnum_deflen, 0,
                      csp_resnum_deflen, ln, ln_len+2, len, numb_err);
                IF  numb_err = num_ok
                THEN
                    BEGIN
                    displ_buf := false;
                    ln_len    := ln_len + 1 + len;
                    t12write_prot (protfile, ln, ln_len, err)
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        sp1pk_abap_info:
            BEGIN
            displ_buf := false;
            ln      := term.blankline;
            ln_len  := c_packet_indent;
            g17nameto_line ('name   :          ', ln_len, ln);
            len := ord(sp1p_buf[1]);
            FOR ix := 1 TO len DO
                ln [ln_len + ix + 1] := sp1p_buf [1 + ix];
            (*ENDFOR*) 
            ln_len := ln_len + len + 1;
            t12write_prot (protfile, ln, ln_len, err);
            ln      := term.blankline;
            ln_len  := c_packet_indent;
            g17nameto_line ('linenr :          ', ln_len, ln);
            pos := 2 + len;
            len := ord(sp1p_buf[pos]);
            FOR ix := 1 TO len DO
                ln [ln_len + ix + 1] := sp1p_buf [pos + ix];
            (*ENDFOR*) 
            ln_len := ln_len + len + 1;
            t12write_prot (protfile, ln, ln_len, err)
            END;
        sp1pk_shortinfo, sp1pk_output_cols_no_parameter,
        sp1pk_appl_parameter_description, sp1pk_vardata_shortinfo :
            BEGIN
            IF  (sp1p_part_kind = sp1pk_shortinfo) OR
                (sp1p_part_kind = sp1pk_output_cols_no_parameter) OR
                (sp1p_part_kind = sp1pk_vardata_shortinfo)
            THEN
                arg_size := sizeof (tsp1_param_info)
            ELSE (* part_kind = sp1pk_appl_parameter_description *)
                BEGIN
                psl_ptr  := @sp1p_buf [1];
                arg_size := sizeof (tsp1_param_spec)
                END;
            (*ENDIF*) 
            curr_i := 1;
            WHILE curr_i <= sp1p_arg_count DO
                BEGIN
                ln := term.blankline;
                g17int4to_line (curr_i,
                      NOT c_with_zero, 3, c_packet_indent, ln);
                ln [c_packet_indent+3] := '.';
                ln_len := c_packet_indent+5;
                IF  (sp1p_part_kind = sp1pk_shortinfo) OR
                    (sp1p_part_kind = sp1pk_output_cols_no_parameter)
                THEN
                    BEGIN
                    pi_ptr := @sp1p_buf [1 + (curr_i-1)*arg_size];
                    g17paraminfo_to_line (pi_ptr^, ln_len, ln)
                    END
                ELSE
                    IF  sp1p_part_kind = sp1pk_vardata_shortinfo
                    THEN
                        BEGIN
                        pi_ptr := @sp1p_buf [1 + (curr_i-1)*arg_size];
                        g17varparaminfo_to_line (pi_ptr^, ln_len, ln)
                        END
                    ELSE (* part_kind = sp1pk_appl_parameter_description *)
                        g17paramspec_to_line (psl_ptr^[curr_i].para_type,
                              psl_ptr^[curr_i].para_length,
                              ord (psl_ptr^[curr_i].para_frac), ln_len, ln);
                    (*ENDIF*) 
                (*ENDIF*) 
                t12write_prot (protfile, ln, ln_len, err);
                curr_i := succ (curr_i)
                END;
            (*ENDWHILE*) 
            displ_buf := false
            END;
        sp1pk_parsid, sp1pk_parsid_of_select:
            BEGIN
            ln     := term.blankline;
            ln_len := c_packet_indent;
            IF  ord (sp1p_buf [c_p_info_pos]) <> csp1_p_none
            THEN
                BEGIN
                g17parsidinfo_to_line (sp1p_buf [c_p_info_pos],
                      ln_len, ln);
                ln [ln_len+1] := ',';
                ln_len        := ln_len+2
                END;
            (*ENDIF*) 
            g17sname_to_line ('mess_type:  ', ln_len, ln);
            ln_len      := succ (ln_len);
            c1_mtype.c1 := sp1p_buf [c_messtype_pos];
            IF  (ord (c1_mtype.c1) >= ord (m_nil)) AND
                (ord (c1_mtype.c1) <= ord (m_autosave))
            THEN
                g17messtype_to_line (c1_mtype.mtype, ln_len, ln)
            ELSE
                g17hexto_line (c1_mtype.c1, ln_len, ln);
            (*ENDIF*) 
            t12write_prot (protfile, ln, ln_len, err)
            END;
        (* PTS 1111575 E.Z. *)
        OTHERWISE;
        END
    (*ENDCASE*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt05segment (VAR term : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            scan            : tut_diag_scan;
            maxbuflength    : tsp00_Int4;
            VAR segm        : tsp1_segment);
 
CONST
      c_packet_indent = 9;
 
VAR
      curr_warn : tsp00_Warnings;
      curriwarn : tsp1_intern_warning;
      dummy_err : integer;
      ln1_len   : integer;
      ln2_len   : integer;
      ln3_len   : integer;
      part_no   : integer;
      part_ptr  : tsp1_part_ptr;
      ln1       : tsp00_Line;
      ln2       : tsp00_Line;
      ln3       : tsp00_Line;
 
BEGIN
IF  segm.sp1s_segm_kind = sp1sk_cmd
THEN
    BEGIN
    g17cmdsegm_head (segm.sp1s_segm_header,
          ln1_len, ln1, ln2_len, ln2, ln3_len, ln3);
    t12write_prot (protfile, ln1, ln1_len, dummy_err);
    t12write_prot (protfile, ln2, ln2_len, dummy_err);
    IF  ln3_len > 0
    THEN
        t12write_prot (protfile, ln3, ln3_len, dummy_err)
    (*ENDIF*) 
    END
ELSE
    BEGIN
    g17returnsegm_head (segm.sp1s_segm_header,
          ln1_len, ln1, ln2_len, ln2);
    t12write_prot (protfile, ln1, ln1_len, dummy_err);
    IF  ln2_len > 0
    THEN
        t12write_prot (protfile, ln2, ln2_len, dummy_err);
    (*ENDIF*) 
    IF  segm.sp1r_extern_warning <> [ ]
    THEN
        BEGIN
        FOR curr_warn := warn0_exist
              TO warn15_user_defined_code DO
            IF  curr_warn in segm.sp1r_extern_warning
            THEN
                BEGIN
                ln1     := term.blankline;
                ln1_len := c_packet_indent;
                g17sname_to_line ('external    ', ln1_len, ln1);
                ln1_len := ln1_len + 1;
                g17warning_item_to_line (curr_warn, ln1_len, ln1);
                t12write_prot (protfile, ln1, ln1_len, dummy_err)
                END
            (*ENDIF*) 
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    IF  segm.sp1r_intern_warning <> [ ]
    THEN
        BEGIN
        curriwarn := sp1iw_warn0_resultset_closed;
        WHILE curriwarn <= sp1iw_warn15 DO
            BEGIN
            IF  curriwarn in segm.sp1r_intern_warning
            THEN
                BEGIN
                ln1     := term.blankline;
                ln1_len := c_packet_indent;
                g17nameto_line ('intern_warning:   ', ln1_len, ln1);
                g17intern_warning_item_to_line (curriwarn, ln1_len, ln1);
                t12write_prot (protfile, ln1, ln1_len, dummy_err)
                END;
            (*ENDIF*) 
            curriwarn := succ(curriwarn)
            END
        (*ENDWHILE*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
part_ptr := @segm.sp1p_part;
part_no := 1;
WHILE (part_no <= segm.sp1s_no_of_parts) AND
      (part_ptr <> NIL) DO
    BEGIN
    IF  part_no > 1
    THEN
        s26nextpart (part_ptr);
    (*ENDIF*) 
    IF  part_ptr <> NIL
    THEN
        xt05packet_part (term, protfile, scan, maxbuflength, part_ptr^);
    (*ENDIF*) 
    part_no := succ(part_no)
    END
(*ENDWHILE*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
