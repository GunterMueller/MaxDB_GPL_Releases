/* @lastChanged: "1999-10-28"
 
 * @filename:   vxt03
 * @purpose:    "XT_typebuf"
 * @release:    7.2.0.0
 * @see:        "-.-"
 *
 * @Copyright (c) 1999-2005 SAP AG"
 */
 
.tt 1 $SAP$LiveCache$VXT03$
.tt 3 $$XT_typebuf$2000-10-18$
 
.nf
 
 .nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
***********************************************************
 
Module  : XT_typebuf
 
Define  :
 
        PROCEDURE
              x03typedata (VAR term : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    VAR progname    : tsp00_C20;
                    sql_packet      : tsp00_Addr;
                    VAR sql_ref     : tsp00_Int4;
                    VAR pfkey       : tut_pfkey);
 
        PROCEDURE
              x03typebuf (VAR term : tut_terminal;
                    VAR protfile   : tut_vf_fileref;
                    VAR progname   : tsp00_C20;
                    VAR fn         : tsp00_VFilename;
                    edit_file      : boolean;
                    VAR pfkey      : tut_pfkey);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              pagestore : VBD10;
 
        PROCEDURE
              bd10GetPageHeader(
                    pPage            : tsp00_PageAddr;
                    VAR Version      : tsp00_Int4;
                    VAR DevNo        : tsp00_Int4;
                    VAR BlockNo      : tsp00_Int4;
                    VAR BaseNo       : tsp00_Int4;
                    VAR TotalCnt     : tsp00_Int4;
                    VAR ParentIndex  : tsp00_Int4;
                    VAR PageEntryNo  : tsp00_Int4;
                    VAR IsLeaf       : boolean;
                    VAR IsPerm       : boolean;
                    VAR IsDynamic    : boolean );
 
      ------------------------------ 
 
        FROM
              XT_logscan : VXT04;
 
        PROCEDURE
              x04logpage_display (VAR term : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    scan            : tut_diag_scan;
                    VAR file_pos    : tut_file_pos;
                    VAR buf         : tsp00_MoveObj;
                    buf_size        : tsp00_Int4;
                    one_entryoffset : tsp00_Int4;
                    VAR pfkey       : tut_pfkey);
 
        FUNCTION
              x04offset_is_valid (VAR buf : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    entryOffset  : tsp00_Int4) : boolean;
 
        FUNCTION
              x04search_iosequence (VAR page : tsp00_MoveObj;
                    iosequence : tsp00_Int4) : boolean;
 
        FUNCTION
              x04search_for_oid (VAR buf : tsp00_MoveObj;
                    buf_size         : tsp00_Int4;
                    VAR wanted_oid   : tgg00_OidSpace;
                    wanted_action_id : tsp00_Int4;
                    VAR entryOffset  : tsp00_Int4) : boolean;
 
        FUNCTION
              x04search_for_transno (VAR buf : tsp00_MoveObj;
                    buf_size           : tsp00_Int4;
                    VAR wanted_transno : tgg91_TransNo;
                    wanted_action_id   : tsp00_Int4;
                    VAR end_of_trans   : boolean;
                    VAR entryOffset    : tsp00_Int4) : boolean;
 
      ------------------------------ 
 
        FROM
              XT_auxiliary_procedures : VXT05;
 
        PROCEDURE
              x05blockno_to_line (VAR file_pos : tut_file_pos;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              x05close_file (VAR f : tut_file);
 
        PROCEDURE
              x05display_msg (VAR term : tut_terminal;
                    msg                : tsp00_C20;
                    is_warning         : boolean;
                    immediate_display  : boolean);
 
        PROCEDURE
              x05get_direct (VAR term : tut_terminal;
                    VAR f             : tut_file;
                    wanted_block      : tsp00_Int4;
                    wanted_page       : tsp00_Int2;
                    VAR err           : tsp00_VfReturn);
 
        PROCEDURE
              x05get_next (VAR term : tut_terminal;
                    VAR f           : tut_file;
                    VAR err         : tsp00_VfReturn);
 
        PROCEDURE
              x05header (VAR term : tut_terminal;
                    VAR protfile  : tut_vf_fileref;
                    VAR progname  : tsp00_C20;
                    VAR fn        : tsp00_VFilename);
 
        PROCEDURE
              x05helphexint (VAR term : tut_terminal;
                    VAR pfkey : tut_pfkey);
 
        PROCEDURE
              x05hexint (VAR term : tut_terminal;
                    VAR protfile  : tut_vf_fileref;
                    VAR pfkey     : tut_pfkey);
 
        PROCEDURE
              x05holdhexint (VAR term : tut_terminal;
                    VAR pfkey : tut_pfkey);
 
        PROCEDURE
              x05init_file (VAR f : tut_file;
                    VAR blankfilename : tsp00_VFilename);
 
        FUNCTION
              x05is_greater_file_pos (VAR arg1 : tut_file_pos;
                    VAR arg2 : tut_file_pos) : boolean;
 
        PROCEDURE
              x05open_file (VAR term : tut_terminal;
                    VAR f            : tut_file;
                    skip_mask        : boolean;
                    edit_file        : boolean;
                    rewind_option    : boolean;
                    msg_fn           : tsp00_C20;
                    VAR pfkey        : tut_pfkey);
 
        PROCEDURE
              x05open_data_sql_file (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    VAR f        : tut_file;
                    sql_packet   : tsp00_Addr;
                    sql_ref      : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x05open_undo_file (VAR term : tut_terminal;
                    VAR input_file   : tut_file;
                    VAR undo_file    : tut_file;
                    page_header_size : tsp00_Int4;
                    write_open       : boolean;
                    VAR pfkey        : tut_pfkey);
 
        PROCEDURE
              x05pageno_to_line (int : tsp00_Int4;
                    trim       : boolean;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              x05print_msg (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    msg          : tsp00_C20);
 
        PROCEDURE
              x05read_block_no_from_to (VAR term : tut_terminal;
                    only_from    : boolean;
                    VAR from_pos : tut_file_pos;
                    VAR to_pos   : tut_file_pos;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x05readint4 (VAR term : tut_terminal;
                    init_int  : boolean;
                    is_int2   : boolean;
                    msg       : tsp00_C20;
                    VAR int   : tsp00_Int4;
                    VAR pfkey : tut_pfkey);
 
        PROCEDURE
              x05read2_int4 (VAR term : tut_terminal;
                    init1_int : boolean;
                    is_1_int2 : boolean;
                    msg1      : tsp00_C20;
                    VAR i1    : tsp00_Int4;
                    init2_int : boolean;
                    is_2_int2 : boolean;
                    msg2      : tsp00_C20;
                    VAR i2    : tsp00_Int4;
                    VAR pfkey : tut_pfkey);
 
        PROCEDURE
              x05reset_scan (VAR scan : tut_diag_scan);
 
        PROCEDURE
              x05write_direct (VAR term : tut_terminal;
                    VAR f   : tut_file;
                    VAR err : tsp00_VfReturn);
 
        PROCEDURE
              x05write_seq (VAR term : tut_terminal;
                    VAR f   : tut_file;
                    VAR err : tsp00_VfReturn);
 
      ------------------------------ 
 
        FROM
              XT_page_display : VXT07;
 
        PROCEDURE
              x07fdirpage_display (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x07logundo_node_display (VAR term : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    scan            : tut_diag_scan;
                    VAR file_pos    : tut_file_pos;
                    trunc_buflength : tsp00_Int4;
                    VAR buf         : tsp00_MoveObj;
                    buf_size        : tsp00_Int4;
                    VAR pfkey       : tut_pfkey);
 
        PROCEDURE
              x07logredo_node_display (VAR term : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    scan            : tut_diag_scan;
                    VAR file_pos    : tut_file_pos;
                    trunc_buflength : tsp00_Int4;
                    VAR buf         : tsp00_MoveObj;
                    buf_size        : tsp00_Int4;
                    VAR pfkey       : tut_pfkey);
 
        PROCEDURE
              x07history_node_display (VAR term : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    scan            : tut_diag_scan;
                    VAR file_pos    : tut_file_pos;
                    trunc_buflength : tsp00_Int4;
                    VAR buf         : tsp00_MoveObj;
                    buf_size        : tsp00_Int4;
                    VAR pfkey       : tut_pfkey);
 
        PROCEDURE
              x07historydir_node_display (VAR term : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    scan            : tut_diag_scan;
                    VAR file_pos    : tut_file_pos;
                    trunc_buflength : tsp00_Int4;
                    VAR buf         : tsp00_MoveObj;
                    buf_size        : tsp00_Int4;
                    VAR pfkey       : tut_pfkey);
 
        PROCEDURE
              x07opentrans_node_display (VAR term : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    scan            : tut_diag_scan;
                    VAR file_pos    : tut_file_pos;
                    trunc_buflength : tsp00_Int4;
                    VAR buf         : tsp00_MoveObj;
                    buf_size        : tsp00_Int4;
                    VAR pfkey       : tut_pfkey);
 
        PROCEDURE
              x07convpage_display (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    VAR buf      : tsp00_MoveObj;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x07node_display (VAR term : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    scan            : tut_diag_scan;
                    VAR file_pos    : tut_file_pos;
                    trunc_buflength : tsp00_Int4;
                    VAR buf         : tsp00_MoveObj;
                    buf_size        : tsp00_Int4;
                    VAR pfkey       : tut_pfkey);
 
        PROCEDURE
              x07object_node_display (VAR term : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    scan            : tut_diag_scan;
                    VAR file_pos    : tut_file_pos;
                    trunc_buflength : tsp00_Int4;
                    VAR buf         : tsp00_MoveObj;
                    buf_size        : tsp00_Int4;
                    VAR pfkey       : tut_pfkey);
 
      ------------------------------ 
 
        FROM
              XT_dump_display : VXT08;
 
        PROCEDURE
              x08dumpdisplay (VAR term : tut_terminal;
                    VAR f        : tut_file;
                    VAR prot     : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    search_label : tsp00_Name;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey;
                    VAR found    : boolean);
 
        PROCEDURE
              x08hostinfo_display (VAR term : tut_terminal;
                    VAR prot     : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    page_name    : tsp00_Sname;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x08loginfo_display (VAR term : tut_terminal;
                    VAR prot     : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x08restart_display (VAR term : tut_terminal;
                    VAR prot     : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    page_name    : tsp00_Sname;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x08iomanpage_display (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        PROCEDURE
              gg06SetOid (VAR oid : tgg00_OidSpace;
                    pno           : tsp00_Int4;
                    pos           : tsp00_Int4;
                    FrameVers     : tsp00_Int4);
 
        PROCEDURE
              gg06TransBecomes (VAR TransNo : tgg91_TransNo; IntValue : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17nameto_line (n : tsp00_Name;
                    VAR ln_len  : integer;
                    VAR ln      : tsp00_Line);
 
        PROCEDURE
              g17messtype_to_line (mess_type : tgg00_MessType;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17mess2type_to_line (mess2_type : tgg00_MessType2;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17sname_to_line (n : tsp00_Sname;
                    VAR ln_len    : integer;
                    VAR ln        : tsp00_Line);
 
        PROCEDURE
              g17trimint4_to_line (int : tsp00_Int4;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              TA_terminal_IO : VTA09;
 
        PROCEDURE
              t09display (VAR t09 : tut_terminal;
                    display_on : boolean);
 
        PROCEDURE
              t09frame (VAR t09 : tut_terminal; on : boolean);
 
        PROCEDURE
              t09get1name (VAR t09 : tut_terminal;
                    msg         : tsp00_C20;
                    msg_attr    : char;
                    in_attr     : char;
                    in_len      : integer;
                    upper_case  : boolean;
                    VAR in_name : tsp00_Name;
                    VAR pfkey   : tut_pfkey);
 
        PROCEDURE
              t09holding (VAR t09 : tut_terminal;
                    VAR pfkey : tut_pfkey);
 
        FUNCTION
              t09is_empty_window (VAR term : tut_terminal): boolean;
 
        FUNCTION
              t09is_window_full (VAR term : tut_terminal;
                    wanted_lines: integer): boolean;
 
        PROCEDURE
              t09menu (VAR t09   : tut_terminal;
                    size         : integer;
                    msg_attr     : char;
                    VAR msg      : tut_c20_array;
                    VAR selected : integer;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              t09msgheader (VAR t09 : tut_terminal;
                    msg     : tsp00_C30;
                    is_perm : boolean);
 
        PROCEDURE
              t09newscreen_page (VAR t09 : tut_terminal);
 
        PROCEDURE
              t09pfkeys (VAR t09 : tut_terminal; on : boolean);
 
        PROCEDURE
              t09put (VAR t09 : tut_terminal;
                    VAR text  : tsp00_Line;
                    text_attr : char);
 
        PROCEDURE
              t09put60 (VAR term : tut_terminal;
                    ln60         : tsp00_C60;
                    text_attr    : char);
 
        PROCEDURE
              t09putmsg (VAR t09      : tut_terminal;
                    VAR msg           : tsp00_Line;
                    is_warning        : boolean;
                    immediate_display : boolean);
 
        PROCEDURE
              t09setpf1 (VAR term : tut_terminal; pfkey_label : tsp00_C8);
 
        FUNCTION
              t09window_cols (VAR t09 : tut_terminal): integer;
 
      ------------------------------ 
 
        FROM
              TA_write_protfile : VTA12;
 
        PROCEDURE
              t12write_prot (VAR fileref : tut_vf_fileref;
                    VAR ln    : tsp00_Line;
                    length    : integer;
                    VAR error : integer);
 
      ------------------------------ 
 
        FROM
              TA_buf_display : VTA14;
 
        PROCEDURE
              t14bufdisplay (VAR term : tut_terminal;
                    VAR protfile      : tut_vf_fileref;
                    scan              : tut_diag_scan;
                    msg               : tsp00_C30;
                    VAR buf           : tsp00_MoveObj;
                    buf_size          : tsp00_Int4;
                    startpos          : tsp00_Int4;
                    endpos            : tsp00_Int4;
                    start_numbering   : tsp00_Int4;
                    VAR break_pos     : tsp00_Int4;
                    VAR pfkey         : tut_pfkey);
 
        PROCEDURE
              t14editbuf (VAR term : tut_terminal;
                    VAR protfile   : tut_vf_fileref;
                    VAR buf        : tsp00_MoveObj;
                    buf_size       : tsp00_Int4;
                    buf_offset     : tsp00_Int4;
                    VAR file_pos   : tut_file_pos;
                    edit_scan      : tut_diag_scan;
                    VAR is_saved   : boolean;
                    VAR pfkey      : tut_pfkey);
 
        PROCEDURE
              t14record_edit (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    VAR node     : tsp00_MoveObj;
                    node_size    : tsp00_Int4;
                    VAR file_pos : tut_file_pos;
                    edit_scan    : tut_diag_scan;
                    VAR is_saved : boolean;
                    VAR pfkey    : tut_pfkey);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        FUNCTION
              s20buf_to_int4 (VAR source : tsp00_MoveObj;
                    sourec_pos    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              UT_repair : VUT07;
 
        PROCEDURE
              u07edit_restart_rec_loginfo (VAR term : tut_terminal;
                    VAR protfile   : tut_vf_fileref;
                    VAR f          : tut_file;
                    is_read_only   : boolean;
                    loginfo_wanted : boolean;
                    VAR pfkey      : tut_pfkey);
 
      ------------------------------ 
 
        FROM
              RTE_driver : VEN102;
 
        PROCEDURE
              sqlclock (VAR sec  : tsp00_Int4;
                    VAR microsec : tsp00_Int4);
 
        PROCEDURE
              sqldattime (VAR d : tsp00_Date;
                    VAR t       : tsp00_Time);
 
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              t09put;
 
              tsp00_C80 tsp00_Line
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : JuergenA
.sp
.cp 3
Created : 1983-06-01
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-10-18
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_default_dump_upb   = 10001;
      c_display_block_no   =  10;
      c_display_interval   =   5; (* seconds *)
      c_ptype_pos          =   5;
      c_ptype2_pos         =   c_ptype_pos+1;
      mx_maxbuf_displ_byte =   3;
      mx_maxbuf_prefix     =   4;
      eof_msg              = 'END OF FILE         ';
      data_perm_page_no    = 'PERM DATA PAGENO    ';
      data_static_page_no  = 'STATIC DATA PAGENO  ';
      displ_msg            = 'DISPLAY             ';
      displ_shadow_msg     = '-DISPLAY            ';
      dump_not_found_msg   = 'DUMP INFO NOT FOUND ';
      maxbuf_msg           = 'MAXBUF              ';
      maxbuf_shadow_msg    = '-MAXBUF             ';
      minbuf_msg           = 'MINBUF              ';
      minbuf_shadow_msg    = '-MINBUF             ';
      nodispl_msg          = 'NODISPLAY           ';
      nodispl_shadow_msg   = '-NODISPLAY          ';
      not_found_msg        = 'NOT FOUND           ';
      page_saved_msg       = 'PAGE SAVED          ';
      return_msg           = 'RETURN              ';
      scanning_msg         = 'SCANNING ...        ';
      (* *)
      c_edit_msgheader     = '         PAGE EDITOR          ';
      c_view_msgheader     = '   PAGE EDITOR (read only)    ';
      (* *)
      c_immediate_displ    = true;
      c_init               = true;
      c_int2               = true;
      c_loginfo_wanted     = true;
      c_on                 = true;
      c_only_from          = true;
      c_perm               = true;
      c_rewind_option      = true; (* PTS 1103859 JA 1999-09-02 *)
      c_read_only          = true;
      c_skip_mask          = true;
      c_trim               = true;
      c_upper              = true;
      c_warning            = true;
      c_write_open         = true;
 
TYPE
 
      display_info = RECORD
            di_default_trunc   : tsp00_Int4;
            di_trunc_buflength : tsp00_Int4;
            di_lwb             : tsp00_Int4;
            di_upb             : tsp00_Int4;
            di_scan            : tut_diag_scan;
            di_edit_file       : boolean;
            di_typebuf         : boolean
      END;
 
 
      t_undo_head = RECORD
            udh_block_no : tsp00_Int4;
            udh_page_no  : tsp00_Int4;
            udh_date     : tsp00_Date;
            udh_time     : tsp00_Time
      END;
 
      t_undo_head_addr = ^t_undo_head;
 
 
(*------------------------------*) 
 
PROCEDURE
      x03typedata (VAR term : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            VAR progname    : tsp00_C20;
            sql_packet      : tsp00_Addr;
            VAR sql_ref     : tsp00_Int4;
            VAR pfkey       : tut_pfkey);
 
VAR
      dummy_exit : boolean;
      f          : tut_file;
      undo_file  : tut_file;
      displ_info : display_info;
 
BEGIN
pfkey := pf_none;
t09frame     (term, c_on);
t09pfkeys    (term, c_on);
x05init_file (f, term.blankfilename);
x05init_file (undo_file, term.blankfilename);
WITH displ_info DO
    BEGIN
    di_typebuf       := false;
    di_lwb           := 1;
    di_upb           := sizeof (tsp00_Page);
    di_scan          := [utds_page_header, utds_display];
    di_edit_file     := false;
    di_default_trunc :=
          (((t09window_cols (term) - mx_maxbuf_prefix)
          DIV mx_maxbuf_displ_byte) DIV 10) * 10;
    di_trunc_buflength  := di_default_trunc
    END;
(*ENDWITH*) 
x05open_data_sql_file (term, protfile, f, sql_packet, sql_ref, pfkey);
IF  pfkey = pf_none
THEN
    BEGIN
    x05header (term, protfile, progname, f.utf_fn);
    xt03file_handling (term, protfile, f, undo_file, displ_info, dummy_exit, pfkey)
    END;
(*ENDIF*) 
sql_ref := f.utf_sql_ref;
x05close_file (f);
IF  pfkey <> pf_cancel
THEN
    pfkey := pf_none
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x03typebuf (VAR term : tut_terminal;
            VAR protfile   : tut_vf_fileref;
            VAR progname   : tsp00_C20;
            VAR fn         : tsp00_VFilename;
            edit_file      : boolean;
            VAR pfkey      : tut_pfkey);
 
CONST
      msg_fn = 'VOLUME/INPUTFILE:   ';
 
VAR
      is_exit    : boolean;
      f          : tut_file;
      undo_file  : tut_file;
      displ_info : display_info;
 
BEGIN
pfkey := pf_none;
t09frame     (term, c_on);
t09pfkeys    (term, c_on);
x05init_file (f, term.blankfilename);
x05init_file (undo_file, term.blankfilename);
f.utf_fn := fn;
WITH displ_info DO
    BEGIN
    di_typebuf       := true;
    di_lwb           := 1;
    di_upb           := sizeof (tsp00_Page);
    di_scan          := [utds_page_header, utds_display];
    di_edit_file     := edit_file;
    di_default_trunc :=
          (((t09window_cols (term) - mx_maxbuf_prefix)
          DIV mx_maxbuf_displ_byte) DIV 10) * 10;
    di_trunc_buflength  := di_default_trunc
    END;
(*ENDWITH*) 
is_exit := false;
REPEAT
    x05open_file (term, f, NOT c_skip_mask, edit_file,
          c_rewind_option, msg_fn, pfkey);
    IF  (pfkey = pf_none) AND edit_file
    THEN
        x05open_undo_file (term, f, undo_file,
              sizeof (t_undo_head), c_write_open, pfkey);
    (*ENDIF*) 
    IF  pfkey = pf_none
    THEN
        BEGIN
        x05header (term, protfile, progname, f.utf_fn);
        xt03file_handling (term, protfile, f, undo_file, displ_info, is_exit, pfkey);
        IF  pfkey = pf_end
        THEN
            pfkey := pf_none
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    x05close_file (f);
    IF  edit_file
    THEN
        x05close_file (undo_file)
    (*ENDIF*) 
UNTIL
    (pfkey <> pf_none) OR is_exit;
(*ENDREPEAT*) 
fn := f.utf_fn;
IF  pfkey <> pf_cancel
THEN
    pfkey := pf_none
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt03buf_info (VAR term : tut_terminal;
            VAR protfile : tut_vf_fileref;
            msg          : tsp00_Sname;
            VAR f        : tut_file);
 
VAR
      err    : integer;
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
ln     := term.blankline;
ln_len := 0;
g17sname_to_line (msg, ln_len, ln);
ln_len := ln_len + 1;
x05pageno_to_line  (s20buf_to_int4 (f.utf_page^, 1), c_trim, ln_len, ln);
x05blockno_to_line (f.utf_pos, ln_len, ln);
t09put             (term, ln, cut_bright_protected);
t12write_prot      (protfile, ln, ln_len, err)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt03direct_edit_displ (VAR term : tut_terminal;
            VAR protfile   : tut_vf_fileref;
            VAR f          : tut_file;
            VAR undo_file  : tut_file;
            VAR from_pos   : tut_file_pos;
            VAR to_pos     : tut_file_pos;
            VAR displ_info : display_info;
            msgText        : tsp00_C20;
            VAR pfkey      : tut_pfkey);
 
VAR
      io_err      : tsp00_VfReturn;
      is_saved    : boolean;
      edit_scan   : tut_diag_scan;
      msgheader   : tsp00_C30;
      aux_page    : tsp00_Page;
 
BEGIN
IF  displ_info.di_typebuf
THEN
    x05read_block_no_from_to (term, c_only_from, from_pos, to_pos, pfkey)
ELSE
    BEGIN
    x05readint4 (term, (from_pos.utfp_block_no = cut_nil_block_no),
          NOT c_int2, msgText, from_pos.utfp_block_no, pfkey);
    f.utf_pos.utfp_block_no := cut_nil_block_no;
    from_pos.utfp_page_no   := 1;
    to_pos                  := from_pos
    END;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    x05get_direct (term, f, from_pos.utfp_block_no,
          from_pos.utfp_page_no, io_err);
(*ENDIF*) 
IF  (pfkey = pf_none) AND (io_err = vf_ok)
THEN
    BEGIN
    IF  NOT term.is_batch
    THEN
        t09display (term, utds_display in displ_info.di_scan);
    (*ENDIF*) 
    t09newscreen_page (term);
    IF  NOT (utds_edit in displ_info.di_scan)
    THEN
        BEGIN
        xt03display_buffer (term, protfile, f, displ_info, pfkey);
        IF  pfkey = pf_none
        THEN
            x05holdhexint (term, pfkey)
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        is_saved := false;
        IF  displ_info.di_edit_file
        THEN
            msgheader := c_edit_msgheader
        ELSE
            msgheader := c_view_msgheader;
        (*ENDIF*) 
        SAPDB_PascalForcedMove (f.utf_page_size, sizeof (aux_page),
              @f.utf_page^, 1, @aux_page, 1, f.utf_page_len);
        t09msgheader (term, msgheader, c_perm);
        IF  (utds_node in displ_info.di_scan) AND
            (utds_rec  in displ_info.di_scan) AND
            (ord (f.utf_page^[c_ptype_pos]) = ord (ptData_egg00))
        THEN
            t14record_edit (term, protfile, f.utf_page^,
                  f.utf_page_len, f.utf_pos, [utds_rec], is_saved, pfkey)
        ELSE
            BEGIN
            IF  utds_page_header in displ_info.di_scan
            THEN
                edit_scan := [utds_page_header]
            ELSE
                edit_scan := [ ];
            (*ENDIF*) 
            t14editbuf (term, protfile, f.utf_page^, f.utf_page_len, 0, f.utf_pos, edit_scan,
                  is_saved, pfkey)
            END;
        (*ENDIF*) 
        IF  is_saved AND displ_info.di_edit_file
        THEN
            BEGIN
            IF  undo_file.utf_fhandle <> 0
            THEN
                xt03write_undo (term, f, undo_file, aux_page);
            (*ENDIF*) 
            x05write_direct (term, f, io_err);
            IF  io_err = vf_ok
            THEN
                x05display_msg (term, page_saved_msg,
                      NOT c_warning, NOT c_immediate_displ)
            (*ENDIF*) 
            END
        ELSE
            SAPDB_PascalForcedMove (sizeof (aux_page), f.utf_page_size,
                  @aux_page, 1, @f.utf_page^, 1, f.utf_page_len)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt03display_buffer (VAR term : tut_terminal;
            VAR protfile   : tut_vf_fileref;
            VAR f          : tut_file;
            VAR displ_info : display_info;
            VAR pfkey      : tut_pfkey);
 
CONST
      c_full_window = 1000;
 
VAR
      is_help        : boolean;
      is_valid_page  : boolean;
      dummy_bool     : boolean;
      displ_buffer   : boolean;
      displ_headline : boolean;
      wanted_lines   : integer;
      break_pos      : integer;
      buf_lwb        : integer;
      buf_upb        : integer;
      err            : integer;
      ln_len         : integer;
      info_page      : tkb3_info_ptr;
      page_name      : tsp00_Sname;
      ln             : tsp00_Line;
 
      univ_pt : RECORD
            CASE boolean OF
                true:
                    (c : tsp00_C2);
                false:
                    (pt : tgg00_PageType;
                    pt2 : tgg00_PageType2);
                END;
            (*ENDCASE*) 
 
 
BEGIN
pfkey          := pf_none;
page_name      := 'UNDEF       ';
wanted_lines   := 1;
univ_pt.pt     := ptNil_egg00;
univ_pt.pt2    := pt2Nil_egg00;
displ_headline := false;
is_valid_page  := false;
displ_buffer   :=
      (utds_buffer_output in displ_info.di_scan)
      AND (f.utf_page_len > 0);
IF  f.utf_page_len <> sizeof (tsp00_Page)
THEN
    BEGIN
    x05reset_scan (displ_info.di_scan);
    displ_info.di_scan := displ_info.di_scan + [utds_buffer_output]
    END
ELSE
    IF  utds_page_header in displ_info.di_scan
    THEN
        is_valid_page :=
              (ord (f.utf_page^[c_ptype_pos]) < ord (ptLastPageType_egg00));
    (*ENDIF*) 
(*ENDIF*) 
IF  is_valid_page
THEN
    BEGIN
    univ_pt.c [1] := f.utf_page^[c_ptype_pos  ];
    univ_pt.c [2] := f.utf_page^[c_ptype2_pos];
    CASE univ_pt.pt OF
        ptData_egg00:
            IF  univ_pt.pt2 = pt2Log_egg00
            THEN
                BEGIN
                IF  (utds_logentry_header    in displ_info.di_scan) OR
                    (utds_logentry_full_info in displ_info.di_scan) OR
                    (utds_logentry_buf       in displ_info.di_scan)
                THEN
                    wanted_lines := c_full_window
                ELSE
                    wanted_lines := 3
                (*ENDIF*) 
                END
            ELSE
                IF  univ_pt.pt2 = pt2Usm_egg00
                THEN
                    wanted_lines := 1
                ELSE
                    IF  univ_pt.pt2 = pt2Checkpt_egg00
                    THEN
                        BEGIN
                        IF  utds_bd_full_info in displ_info.di_scan
                        THEN
                            wanted_lines := c_full_window
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  utds_node in displ_info.di_scan
                        THEN
                            wanted_lines := c_full_window
                        ELSE
                            wanted_lines := 4;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        ptLog_egg00:
            BEGIN
            (* *)
            IF  (((utds_logentry_header    in displ_info.di_scan) OR
                (  utds_logentry_full_info in displ_info.di_scan) OR
                (  utds_logentry_buf       in displ_info.di_scan))
                AND (univ_pt.pt2 = pt2Log_egg00))
                OR
                (((univ_pt.pt2 = pt2Checkpt_egg00) OR
                (  univ_pt.pt2 = pt2LogInfo_egg00  ) OR
                (  univ_pt.pt2 = pt2Config_egg00    ))
                AND (utds_full_info in displ_info.di_scan))
            THEN
                wanted_lines := c_full_window
            (*ENDIF*) 
            END;
        ptSave_egg00:
            IF  (univ_pt.pt2 = pt2EndSaveInfo_egg00  ) OR
                (univ_pt.pt2 = pt2EndVolumeInfo_egg00) OR
                (univ_pt.pt2 = pt2VolumeLabelInfo_egg00) OR
                (univ_pt.pt2 = pt2VolumeFirstInfo_egg00 )
            THEN
                BEGIN
                IF  utds_full_info in displ_info.di_scan
                THEN
                    wanted_lines := c_full_window
                ELSE
                    wanted_lines := 9
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        ptConverter_egg00:
            BEGIN
            IF  utds_bd_full_info in displ_info.di_scan
            THEN
                wanted_lines := c_full_window
            (*ENDIF*) 
            END;
        OTHERWISE
            wanted_lines := 1
        END
    (*ENDCASE*) 
    END;
(*ENDIF*) 
IF  NOT t09is_empty_window (term)
    AND
    t09is_window_full (term, 1 + wanted_lines)
THEN
    BEGIN
    x05holdhexint (term, pfkey);
    IF  pfkey = pf_none
    THEN
        t09newscreen_page (term)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    xt03print_separator (term, protfile);
(*ENDIF*) 
IF  (pfkey = pf_none) AND is_valid_page
THEN
    CASE univ_pt.pt OF
        ptNil_egg00:
            BEGIN
            page_name      := 'NIL         ';
            displ_headline := true
            END;
        ptData_egg00:
            CASE univ_pt.pt2 OF
                pt2UndoLog_egg00:
                    BEGIN
                    page_name      := 'UNDO        ';
                    x07logundo_node_display (term, protfile, displ_info.di_scan,
                          f.utf_pos, displ_info.di_trunc_buflength,
                          f.utf_page^, f.utf_page_len, pfkey);
                    END;
                pt2RedoLog_egg00:
                    BEGIN
                    page_name      := 'REDO        ';
                    x07logredo_node_display (term, protfile, displ_info.di_scan,
                          f.utf_pos, displ_info.di_trunc_buflength,
                          f.utf_page^, f.utf_page_len, pfkey);
                    END;
                pt2History_egg00:
                    BEGIN
                    page_name      := 'HISTORY     ';
                    x07history_node_display (term, protfile, displ_info.di_scan,
                          f.utf_pos, displ_info.di_trunc_buflength,
                          f.utf_page^, f.utf_page_len, pfkey);
                    END;
                pt2HistoryDirectory_egg00:
                    BEGIN
                    page_name      := 'HISTDIR     ';
                    x07historydir_node_display (term, protfile, displ_info.di_scan,
                          f.utf_pos, displ_info.di_trunc_buflength,
                          f.utf_page^, f.utf_page_len, pfkey);
                    END;
                pt2OpenTrans_egg00:
                    BEGIN
                    page_name      := 'OPEN TRANS  ';
                    x07opentrans_node_display (term, protfile, displ_info.di_scan,
                          f.utf_pos, displ_info.di_trunc_buflength,
                          f.utf_page^, f.utf_page_len, pfkey);
                    END;
                pt2Usm_egg00:
                    BEGIN
                    (* ignore USM pages *)
                    page_name      := 'UNDEF       ';
                    displ_headline := true;
                    displ_buffer   := true
                    END;
                pt2Object_egg00,
                pt2VarObject_egg00,
                pt2ContObject_egg00:
                    x07object_node_display (term, protfile,
                          displ_info.di_scan, f.utf_pos,
                          displ_info.di_trunc_buflength,
                          f.utf_page^, f.utf_page_len, pfkey);
                pt2Checkpt_egg00:
                    BEGIN
                    page_name := 'RESTART REC ';
                    x08restart_display (term, protfile,
                          displ_info.di_scan, f.utf_pos, page_name,
                          f.utf_page^, f.utf_page_len, pfkey)
                    END;
                OTHERWISE
                    x07node_display (term, protfile, displ_info.di_scan,
                          f.utf_pos, displ_info.di_trunc_buflength,
                          f.utf_page^, f.utf_page_len, pfkey);
                END;
            (*ENDCASE*) 
        ptLog_egg00:
            x04logpage_display (term, protfile, displ_info.di_scan,
                  f.utf_pos, f.utf_page^, f.utf_page_len, 0, pfkey);
        ptLogInfo_egg00:
            x08loginfo_display (term, protfile, displ_info.di_scan,
                  f.utf_pos, f.utf_page^, f.utf_page_len, pfkey);
        ptDump_egg00:
            x08dumpdisplay (term, f, protfile, displ_info.di_scan,
                  f.utf_pos, bsp_name, f.utf_page^, f.utf_page_len,
                  pfkey, dummy_bool);
        ptConverter_egg00:
            x07convpage_display (term, protfile, displ_info.di_scan,
                  f.utf_pos, f.utf_page^, pfkey);
        ptIOManInfo_egg00:
            x08iomanpage_display (term, protfile, displ_info.di_scan,
                  f.utf_pos, f.utf_page^, f.utf_page_len, pfkey);
        ptSave_egg00:
            CASE univ_pt.pt2 OF
                pt2BitMap_egg00:
                    BEGIN
                    page_name      := 'BITMAP      ';
                    displ_headline := true;
                    displ_buffer   := true
                    END;
                pt2EndSaveInfo_egg00,
                pt2EndVolumeInfo_egg00,
                pt2VolumeFirstInfo_egg00,
                pt2VolumeLabelInfo_egg00:
                    BEGIN
                    info_page := @f.utf_block^;
                    xt03info_display (term, protfile, f.utf_pos,
                          info_page^.the_info);
                    IF  utds_full_info in displ_info.di_scan
                    THEN
                        x08hostinfo_display (term, protfile,
                              displ_info.di_scan,
                              f.utf_pos, 'HOSTFILE    ',
                              f.utf_page^, f.utf_page_len, pfkey)
                    (*ENDIF*) 
                    END;
                pt2Xparam_egg00:
                    BEGIN
                    page_name      := 'XPARAM      ';
                    displ_headline := true;
                    displ_buffer   := true
                    END;
                OTHERWISE
                    BEGIN
                    page_name      := 'SAVE        ';
                    displ_headline := true;
                    displ_buffer   := true
                    END
                END;
            (*ENDCASE*) 
        ptVtrace_egg00:
            BEGIN
            page_name      := 'VTRACE      ';
            displ_headline := true;
            displ_buffer   := true
            END;
        ptConverterBitMap_egg00:
            BEGIN
            page_name      := 'CONV BITMAP ';
            displ_headline := true;
            displ_buffer   := true
            END;
        ptFileDir_egg00:
            x07fdirpage_display (term, protfile, displ_info.di_scan,
                  f.utf_pos, f.utf_page^, f.utf_page_len, pfkey);
        OTHERWISE
            BEGIN
            page_name      := 'UNDEF       ';
            displ_headline := true;
            displ_buffer   := true
            END
        END;
    (*ENDCASE*) 
(*ENDIF*) 
IF  (pfkey = pf_none) AND displ_buffer
    AND
    NOT t09is_empty_window (term)
    AND
    ((utds_buffer_output in displ_info.di_scan) OR
    ( utds_full_info     in displ_info.di_scan))
THEN
    BEGIN
    x05holdhexint (term, pfkey);
    IF  pfkey = pf_none
    THEN
        t09newscreen_page (term)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (pfkey = pf_none)
    AND
    (NOT (utds_page_header in displ_info.di_scan) OR NOT is_valid_page)
THEN
    BEGIN
    ln     := term.blankline;
    ln_len := 0;
    g17sname_to_line ('PAGE        ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (f.utf_pos.utfp_block_no, ln_len, ln);
    IF  f.utf_pos.utfp_pages_per_block > 1
    THEN
        BEGIN
        ln_len      := ln_len + 1;
        ln [ln_len] := '/';
        g17trimint4_to_line (f.utf_pos.utfp_page_no, ln_len, ln)
        END;
    (*ENDIF*) 
    IF  f.utf_page_len < 1
    THEN
        BEGIN
        g17nameto_line (' *** page length: ', ln_len, ln);
        ln_len := ln_len + 1;
        g17trimint4_to_line (f.utf_page_len, ln_len, ln)
        END;
    (*ENDIF*) 
    t12write_prot (protfile, ln, ln_len, err);
    t09put (term, ln, cut_bright_protected)
    END;
(*ENDIF*) 
IF  (pfkey = pf_none) AND displ_headline
THEN
    xt03buf_info (term, protfile, page_name, f);
(*ENDIF*) 
IF  (pfkey = pf_none) AND displ_buffer
    AND
    ((utds_buffer_output in displ_info.di_scan) OR
    ( utds_full_info     in displ_info.di_scan))
THEN
    BEGIN
    WITH displ_info DO
        BEGIN
        buf_upb := di_upb;
        IF  buf_upb < 1
        THEN
            buf_upb := 1;
        (*ENDIF*) 
        IF  buf_upb > f.utf_page_len
        THEN
            buf_upb := f.utf_page_len;
        (*ENDIF*) 
        buf_lwb := di_lwb;
        IF  buf_upb < buf_lwb
        THEN
            buf_lwb := 1;
        (*ENDIF*) 
        IF  buf_upb - buf_lwb + 1 > di_trunc_buflength
        THEN
            buf_upb := buf_lwb + di_trunc_buflength - 1
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    t09setpf1 (term, cut_pfkey_hexint);
    REPEAT
        is_help := false;
        t14bufdisplay (term, protfile, displ_info.di_scan, bsp_c30,
              f.utf_page^, f.utf_page_len, buf_lwb, buf_upb, buf_lwb,
              break_pos, pfkey);
        IF  pfkey = pf_help
        THEN
            BEGIN
            is_help := true;
            x05helphexint (term, pfkey)
            END;
        (*ENDIF*) 
        buf_lwb := break_pos;
    UNTIL
        NOT is_help;
    (*ENDREPEAT*) 
    t09setpf1 (term, cut_pfkey_none);
    IF  pfkey = pf_end
    THEN
        pfkey := pf_none
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt03dump_handling (VAR term : tut_terminal;
            VAR protfile     : tut_vf_fileref;
            VAR f            : tut_file;
            VAR displ_info   : display_info;
            VAR search_label : tsp00_Name;
            VAR from_pos     : tut_file_pos;
            VAR to_pos       : tut_file_pos;
            VAR pfkey        : tut_pfkey);
 
VAR
      io_err       : tsp00_VfReturn;
      dummy_micsec : tsp00_Int4;
      msg_time     : tsp00_Int4;
      last_displ   : tsp00_Int4;
      curr_found   : boolean;
      found        : boolean;
 
BEGIN
(* read initial of label that will be searched *)
t09get1name (term, '    DUMP LABEL NAME:',
      cut_bright_protected, cut_unprotected,
      NAME_MXSP00, c_upper, search_label, pfkey);
(* read dump page at which search will start *)
IF  (from_pos.utfp_block_no = to_pos.utfp_block_no)
    AND
    (from_pos.utfp_page_no  = to_pos.utfp_page_no )
THEN
    to_pos.utfp_block_no := from_pos.utfp_block_no + c_default_dump_upb;
(*ENDIF*) 
x05read_block_no_from_to (term, NOT c_only_from, from_pos, to_pos, pfkey);
IF  pfkey = pf_none
THEN
    x05get_direct (term, f, from_pos.utfp_block_no,
          from_pos.utfp_page_no, io_err);
(*ENDIF*) 
IF  (pfkey = pf_none) AND (io_err = vf_ok)
THEN
    BEGIN
    t09newscreen_page (term);
    IF  NOT term.is_batch
    THEN
        t09display (term,
              utds_display in displ_info.di_scan);
    (*ENDIF*) 
    found      := false;
    curr_found := false;
    last_displ := 0;
    sqlclock (msg_time, dummy_micsec);
    x05display_msg (term, scanning_msg,
          NOT c_warning, c_immediate_displ);
    WHILE (io_err = vf_ok) AND (pfkey = pf_none)
          AND NOT term.is_reset_called
          AND (f.utf_page_len = sizeof (tsp00_Page))
          AND NOT x05is_greater_file_pos
          (f.utf_pos, to_pos) DO
        BEGIN
        IF  (ord(f.utf_page^[c_ptype_pos]) = ord(ptDump_egg00))
            OR
            (search_label = 'ALLOCATOR         ')
        THEN
            x08dumpdisplay (term, f, protfile, displ_info.di_scan,
                  f.utf_pos, search_label, f.utf_page^, f.utf_page_len,
                  pfkey, curr_found);
        (*ENDIF*) 
        IF  pfkey = pf_none
        THEN
            BEGIN
            IF  curr_found
            THEN
                BEGIN
                found      := true;
                curr_found := false;
                x05display_msg (term, scanning_msg, NOT c_warning, c_immediate_displ)
                END;
            (*ENDIF*) 
            x05get_next (term, f, io_err)
            END;
        (*ENDIF*) 
        WITH f.utf_pos DO
            IF  (io_err = vf_ok)
                AND
                (utfp_block_no - last_displ >= c_display_block_no)
                AND
                ((utfp_block_no MOD 10) = 0)
            THEN
                xt03scanned_msg (term, f.utf_pos, msg_time, last_displ)
            (*ENDIF*) 
        (*ENDWITH*) 
        END;
    (*ENDWHILE*) 
    IF  NOT term.is_inputfile
    THEN
        term.is_reset_called := false;
    (*ENDIF*) 
    IF  pfkey = pf_none
    THEN
        BEGIN
        xt03print_separator (term, protfile);
        IF  found
        THEN
            t09putmsg (term, term.blankline, NOT c_warning, c_immediate_displ)
        ELSE
            x05display_msg (term, dump_not_found_msg, c_warning, NOT c_immediate_displ);
        (*ENDIF*) 
        IF  NOT t09is_empty_window (term)
        THEN
            x05holdhexint (term, pfkey)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt03file_handling (VAR term : tut_terminal;
            VAR protfile   : tut_vf_fileref;
            VAR f          : tut_file;
            VAR undo_file  : tut_file;
            VAR displ_info : display_info;
            VAR is_exit    : boolean;
            VAR pfkey      : tut_pfkey);
 
CONST
      noscan_msg        = 'NOSCAN              ';
      noscan_shadow_msg = '-NOSCAN             ';
      (* column 1 *)
      x_all         =  1;
      x_from        =  2;
      x_direct      =  3;
      x_edit        =  4;
      x_dump        =  5;
      x_scan        =  7;
      x_noscan      =  8;
      x_displ       =  9;
      x_nodispl     = 10;
      (* column 2 *)
      x_minbuf      = 11;
      x_maxbuf      = 12;
      x_maxlen      = 13;
      x_lwb_upb     = 14;
      x_search      = 15;
      x_logsearch   = 16;
      x_hexint      = 17;
      x_loginfo     = 18;
      x_next_file   = 19;
      x_exit        = 20;
 
VAR
      io_err       : tsp00_VfReturn;
      selected     : integer;
      i4           : tsp00_Int4;
      search_label : tsp00_Name;
      from_pos     : tut_file_pos;
      to_pos       : tut_file_pos;
      msg          : tut_c20_array;
 
BEGIN
is_exit := false;
io_err  := vf_ok;
FOR selected := 1 TO x_exit DO
    msg [selected] := bsp_c20;
(*ENDFOR*) 
IF  displ_info.di_typebuf
THEN
    BEGIN
    msg [x_all   ]    := 'ALL                 ';
    msg [x_from  ]    := 'FROM/TO             ';
    msg [x_direct]    := 'GET BLOCK           ';
    msg [x_dump  ]    := 'SEARCH DUMP         ';
    msg [x_search]    := 'SEARCH PAGE         ';
    msg [x_next_file] := 'NEXT INPUTFILE      ';
    msg [x_logsearch] := 'SEARCH ON LOG VOLUME';
    IF  displ_info.di_edit_file
    THEN
        msg [x_edit] := 'EDIT BLOCK          '
    ELSE
        msg [x_edit] := '-EDIT BLOCK         ';
    (*ENDIF*) 
    END
ELSE
    BEGIN
    msg [x_all   ]    := 'GET DATA PERM       ';
    msg [x_from  ]    := 'GET DATA STATIC     ';
    msg [x_direct]    := '-GET BLOCK          ';
    msg [x_edit  ]    := 'GET LOG INFO        ';
    msg [x_dump  ]    := 'GET RESTART RECORD  ';
    msg [x_search]    := '-SEARCH PAGE        ';
    msg [x_next_file] := '-NEXT INPUTFILE     ';
    msg [x_logsearch] := '-SEARCH ON LOG VOLUM';
    END;
(*ENDIF*) 
msg [x_scan     ] := 'SCAN                ';
msg [x_maxlen   ] := 'BUFLENGTH           ';
msg [x_lwb_upb  ] := 'LOWER/UPPER BOUND   ';
msg [x_loginfo  ] := '-EDIT LOGINFO PAGE  ';
msg [x_hexint   ] := 'HEXINT              ';
msg [x_exit     ] := 'RETURN              ';
from_pos     := f.utf_pos;
to_pos       := f.utf_pos;
search_label := bsp_name;
IF  utds_minbuf in displ_info.di_scan
THEN
    BEGIN
    msg [x_minbuf] := minbuf_shadow_msg;
    msg [x_maxbuf] := maxbuf_msg
    END
ELSE
    BEGIN
    msg [x_minbuf] := minbuf_msg;
    msg [x_maxbuf] := maxbuf_shadow_msg
    END;
(*ENDIF*) 
IF  utds_display in displ_info.di_scan
THEN
    BEGIN
    msg [x_displ  ] := displ_shadow_msg;
    msg [x_nodispl] := nodispl_msg
    END
ELSE
    BEGIN
    msg [x_displ  ] := displ_msg;
    msg [x_nodispl] := nodispl_shadow_msg
    END;
(*ENDIF*) 
IF  displ_info.di_scan = [ ]
THEN
    msg [x_noscan] := noscan_shadow_msg
ELSE
    msg [x_noscan] := noscan_msg;
(*ENDIF*) 
REPEAT
    t09msgheader (term, '       SELECT FUNCTION        ', c_perm);
    t09menu      (term, x_exit, cut_protected, msg, selected, pfkey);
    t09msgheader (term, bsp_c30, c_perm);
    IF  pfkey = pf_none
    THEN
        BEGIN
        CASE selected OF
            x_all:
                IF  displ_info.di_typebuf
                THEN
                    BEGIN
                    x05get_direct (term, f, 0, 1, io_err);
                    IF  io_err = vf_ok
                    THEN
                        BEGIN
                        from_pos := f.utf_pos;
                        IF  NOT term.is_batch
                        THEN
                            t09display (term, utds_display in displ_info.di_scan);
                        (*ENDIF*) 
                        t09newscreen_page (term);
                        WHILE (io_err = vf_ok) AND (pfkey = pf_none)
                              AND NOT term.is_reset_called DO
                            BEGIN
                            xt03display_buffer (term, protfile, f, displ_info, pfkey);
                            IF  pfkey = pf_none
                            THEN
                                x05get_next (term, f, io_err)
                            (*ENDIF*) 
                            END;
                        (*ENDWHILE*) 
                        IF  NOT term.is_inputfile
                        THEN
                            term.is_reset_called := false;
                        (*ENDIF*) 
                        IF  pfkey = pf_none
                        THEN
                            BEGIN
                            xt03print_separator (term, protfile);
                            x05print_msg  (term, protfile, eof_msg);
                            x05holdhexint (term, pfkey)
                            END
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN (* get perm page *)
                    f.utf_sql_dev_type := utdt_data_perm;
                    xt03direct_edit_displ (term, protfile, f, undo_file,
                          from_pos, to_pos, displ_info, data_perm_page_no, pfkey);
                    END;
                (*ENDIF*) 
            x_from:
                IF  displ_info.di_typebuf
                THEN
                    BEGIN
                    x05read_block_no_from_to (term, NOT c_only_from, from_pos, to_pos, pfkey);
                    IF  pfkey = pf_none
                    THEN
                        x05get_direct (term, f, from_pos.utfp_block_no, from_pos.utfp_page_no, io_err);
                    (*ENDIF*) 
                    IF  (pfkey = pf_none) AND (io_err = vf_ok)
                    THEN
                        BEGIN
                        IF  NOT term.is_batch
                        THEN
                            t09display (term, utds_display in displ_info.di_scan);
                        (*ENDIF*) 
                        t09newscreen_page (term);
                        WHILE (io_err = vf_ok) AND (pfkey = pf_none)
                              AND NOT term.is_reset_called
                              AND NOT x05is_greater_file_pos (f.utf_pos, to_pos) DO
                            BEGIN
                            xt03display_buffer (term, protfile, f, displ_info, pfkey);
                            x05get_next (term, f, io_err)
                            END;
                        (*ENDWHILE*) 
                        IF  NOT term.is_inputfile
                        THEN
                            term.is_reset_called := false;
                        (*ENDIF*) 
                        IF  pfkey = pf_none
                        THEN
                            BEGIN
                            xt03print_separator (term, protfile);
                            IF  io_err = vf_eof
                            THEN
                                x05print_msg (term, protfile, eof_msg)
                            ELSE
                                x05print_msg (term, protfile, 'END OF SECTION      ');
                            (*ENDIF*) 
                            x05holdhexint (term, pfkey)
                            END
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    (* get static page *)
                    f.utf_sql_dev_type := utdt_data_static;
                    xt03direct_edit_displ (term, protfile, f, undo_file,
                          from_pos, to_pos, displ_info, data_static_page_no, pfkey);
                    END;
                (*ENDIF*) 
            x_direct: (* get block  *)
                IF  displ_info.di_typebuf
                THEN
                    xt03direct_edit_displ (term, protfile, f, undo_file,
                          from_pos, to_pos, displ_info, bsp_c20, pfkey);
                (*ENDIF*) 
            x_edit:
                BEGIN
                IF  displ_info.di_typebuf
                THEN
                    BEGIN
                    IF  displ_info.di_edit_file
                    THEN
                        BEGIN
                        displ_info.di_scan := displ_info.di_scan + [utds_edit];
                        xt03direct_edit_displ (term, protfile, f, undo_file,
                              from_pos, to_pos, displ_info, bsp_c20, pfkey);
                        displ_info.di_scan := displ_info.di_scan - [utds_edit]
                        END
                    ELSE
                        pfkey := pf_end
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN (* log info *)
                    u07edit_restart_rec_loginfo (term, protfile, f, c_read_only,
                          c_loginfo_wanted, pfkey)
                    END;
                (*ENDIF*) 
                END;
            x_search:
                IF  displ_info.di_typebuf
                THEN
                    xt03select_buf (term, protfile, f, from_pos, to_pos, displ_info, pfkey);
                (*ENDIF*) 
            x_logsearch:
                IF  displ_info.di_typebuf
                THEN
                    xt03search_on_log (term, protfile, f, from_pos, to_pos, displ_info, pfkey);
                (*ENDIF*) 
            x_dump:
                BEGIN
                IF  displ_info.di_typebuf
                THEN
                    xt03dump_handling (term, protfile, f, displ_info,
                          search_label, from_pos, to_pos, pfkey)
                ELSE (* restart record *)
                    u07edit_restart_rec_loginfo (term, protfile, f,
                          c_read_only, NOT c_loginfo_wanted, pfkey);
                (*ENDIF*) 
                END;
            x_scan:
                BEGIN
                xt03scan_menu (term, displ_info, pfkey);
                msg [x_noscan] := noscan_msg
                END;
            x_noscan:
                BEGIN
                x05display_msg (term, 'SCAN OFF            ', NOT c_warning, NOT c_immediate_displ);
                msg [x_noscan] := noscan_shadow_msg;
                x05reset_scan (displ_info.di_scan);
                displ_info.di_scan := displ_info.di_scan + [utds_buffer_output]
                END;
            x_displ:
                BEGIN
                x05display_msg (term, 'DISPLAY ON          ', NOT c_warning, NOT c_immediate_displ);
                msg [x_displ  ]    := displ_shadow_msg;
                msg [x_nodispl]    := nodispl_msg;
                displ_info.di_scan := displ_info.di_scan + [utds_display]
                END;
            x_nodispl:
                BEGIN
                x05display_msg (term, 'DISPLAY OFF         ', NOT c_warning, NOT c_immediate_displ);
                msg [x_displ  ]    := displ_msg;
                msg [x_nodispl]    := nodispl_shadow_msg;
                displ_info.di_scan := displ_info.di_scan - [utds_display]
                END;
            x_minbuf:
                BEGIN
                x05display_msg (term, 'MINBUF              ', NOT c_warning, NOT c_immediate_displ);
                msg [x_minbuf]     := minbuf_shadow_msg;
                msg [x_maxbuf]     := maxbuf_msg;
                displ_info.di_scan := displ_info.di_scan +[utds_minbuf]
                END;
            x_maxbuf:
                BEGIN
                x05display_msg (term, 'MAXBUF              ', NOT c_warning, NOT c_immediate_displ);
                msg [x_minbuf]     := minbuf_msg;
                msg [x_maxbuf]     := maxbuf_shadow_msg;
                displ_info.di_scan := displ_info.di_scan -[utds_minbuf]
                END;
            x_maxlen:
                BEGIN
                IF  displ_info.di_trunc_buflength = displ_info.di_default_trunc
                THEN
                    i4 := f.utf_page_size
                ELSE
                    i4 := displ_info.di_trunc_buflength;
                (*ENDIF*) 
                x05readint4 (term, NOT c_init, NOT c_int2, '   MAX BUFFERLENGTH:', i4, pfkey);
                IF  (i4 <= f.utf_page_size) AND
                    (i4 > 0) AND (pfkey = pf_none)
                THEN
                    displ_info.di_trunc_buflength := i4;
                (*ENDIF*) 
                END;
            x_lwb_upb:
                BEGIN
                x05read2_int4 (term, NOT c_init, NOT c_int2,
                      '        LOWER BOUND:', displ_info.di_lwb,
                      NOT c_init, NOT c_int2,
                      '        UPPER BOUND:', displ_info.di_upb, pfkey);
                WITH displ_info DO
                    BEGIN
                    IF  (di_lwb < 1) OR  (di_lwb > f.utf_page_size)
                    THEN
                        di_lwb := 1;
                    (*ENDIF*) 
                    IF  (di_upb < di_lwb) OR (di_upb > f.utf_page_size)
                    THEN
                        di_upb := f.utf_page_size
                    (*ENDIF*) 
                    END
                (*ENDWITH*) 
                END;
            x_hexint:
                x05hexint (term, protfile, pfkey);
            x_loginfo:
                BEGIN
                END;
            x_next_file:
                BEGIN
                IF  displ_info.di_typebuf
                THEN
                    pfkey := pf_end
                (*ENDIF*) 
                END;
            x_exit:
                BEGIN
                is_exit := true;
                pfkey   := pf_end
                END;
            OTHERWISE ;
            END;
        (*ENDCASE*) 
        IF  NOT term.is_batch
        THEN
            t09display (term, c_on);
        (*ENDIF*) 
        IF  (pfkey = pf_end) AND (selected <> x_next_file)
            AND (selected <> x_exit)
        THEN
            pfkey := pf_none
        (*ENDIF*) 
        END
    (*ENDIF*) 
UNTIL
    (pfkey = pf_cancel) OR (pfkey = pf_end);
(*ENDREPEAT*) 
IF  displ_info.di_lwb > displ_info.di_upb
THEN
    displ_info.di_lwb := displ_info.di_upb
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt03info_display (VAR term : tut_terminal;
            VAR protfile         : tut_vf_fileref;
            VAR file_pos         : tut_file_pos;
            VAR hostfile_info    : tkb3_info_stuff);
 
CONST
      c_margin = 10;
 
VAR
      date_kind : (start_date, end_date, version_date);
      err       : integer;
      ln_len    : integer;
      curr_date : tsp00_Date;
      curr_time : tsp00_Time;
      sn        : tsp00_Sname;
      n         : tsp00_Name;
      ln        : tsp00_Line;
 
BEGIN
WITH hostfile_info DO
    BEGIN
    ln     := term.blankline;
    ln_len := 0;
    g17sname_to_line ('HOSTFILE:   ', ln_len, ln);
    ln_len := c_margin;
    g17messtype_to_line (inf_mess_type, ln_len, ln);
    ln_len := ln_len + 1;
    g17mess2type_to_line (inf_mess2_type, ln_len, ln);
    ln_len := ln_len + 1;
    n      := bsp_name;
    CASE inf_pt2 OF
        pt2VolumeFirstInfo_egg00:
            n := '(first info)      ';
        pt2EndVolumeInfo_egg00:
            n := '(end of volume)   ';
        pt2EndSaveInfo_egg00:
            n := '(end of save)     ';
        pt2VolumeLabelInfo_egg00:
            n := '(label_info)      ';
        OTHERWISE
            BEGIN
            g17nameto_line ('(unknown info     ', ln_len, ln);
            ln_len := ln_len + 1;
            g17trimint4_to_line (ord (inf_pt2), ln_len, ln);
            ln_len := ln_len + 1;
            ln [ln_len] := ')'
            END
        END;
    (*ENDCASE*) 
    IF  n <> bsp_name
    THEN
        g17nameto_line (n, ln_len, ln);
    (*ENDIF*) 
    x05blockno_to_line (file_pos, ln_len, ln);
    t09put (term, ln, cut_protected);
    t12write_prot (protfile, ln, ln_len, err);
    ln     := term.blankline;
    ln_len := c_margin;
    g17nameto_line ('volume       :    ', ln_len, ln);
    ln_len := ln_len + 1;
    g17trimint4_to_line (inf_volume_no, ln_len, ln);
    IF  inf_max_volume_no = 1
    THEN
        g17sname_to_line ('  (1 volume)', ln_len, ln)
    ELSE
        IF  inf_max_volume_no <> 0
        THEN
            BEGIN
            ln_len := ln_len + 3;
            ln [ln_len] := '(';
            g17trimint4_to_line (inf_max_volume_no, ln_len, ln);
            g17sname_to_line (' volumes)   ', ln_len, ln)
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    t09put (term, ln, cut_protected);
    t12write_prot (protfile, ln, ln_len, err);
    IF  (inf_vol_page_cnt  > 0                  ) AND
        (inf_vol_page_cnt <> inf_page_count)
    THEN
        BEGIN
        ln     := term.blankline;
        ln_len := c_margin;
        g17nameto_line ('pages volume :    ', ln_len, ln);
        ln_len := ln_len + 1;
        g17trimint4_to_line (inf_vol_page_cnt, ln_len, ln);
        t09put (term, ln, cut_protected);
        t12write_prot (protfile, ln, ln_len, err)
        END;
    (*ENDIF*) 
    IF  inf_page_count > 0
    THEN
        BEGIN
        ln     := term.blankline;
        ln_len := c_margin;
        g17nameto_line ('pages total  :    ', ln_len, ln);
        ln_len := ln_len + 1;
        g17trimint4_to_line (inf_page_count, ln_len, ln);
        t09put (term, ln, cut_protected);
        t12write_prot (protfile, ln, ln_len, err)
        END;
    (*ENDIF*) 
    FOR date_kind := start_date TO version_date DO
        BEGIN
        CASE date_kind OF
            start_date:
                BEGIN
                n         := 'started      :    ';
                curr_date := inf_start_date;
                curr_time := inf_start_time
                END;
            end_date:
                BEGIN
                n         := 'completed    :    ';
                curr_date := inf_end_date;
                curr_time := inf_end_time
                END;
            version_date:
                BEGIN
                n         := 'saved version:    ';
                curr_date := inf_dbstamp1_date;
                curr_time := inf_dbstamp1_time
                END
            END;
        (*ENDCASE*) 
        IF  curr_date <> bsp_date
        THEN
            BEGIN
            ln     := term.blankline;
            ln_len := c_margin;
            g17nameto_line (n, ln_len, ln);
            ln_len := ln_len + 1;
            sn      := bsp_sname;
            sn [ 1] := curr_date [1];
            sn [ 2] := curr_date [2];
            sn [ 3] := curr_date [3];
            sn [ 4] := curr_date [4];
            sn [ 5] := '-';
            sn [ 6] := curr_date [5];
            sn [ 7] := curr_date [6];
            sn [ 8] := '-';
            sn [ 9] := curr_date [7];
            sn [10] := curr_date [8];
            g17sname_to_line (sn, ln_len, ln);
            ln_len := ln_len + 1;
            sn      := bsp_sname;
            sn [1]  := curr_time [3];
            sn [2]  := curr_time [4];
            sn [3]  := ':';
            sn [4]  := curr_time [5];
            sn [5]  := curr_time [6];
            sn [6]  := ':';
            sn [7]  := curr_time [7];
            sn [8]  := curr_time [8];
            g17sname_to_line (sn, ln_len, ln);
            IF  date_kind = version_date
            THEN
                BEGIN
                g17nameto_line ('  (version no:    ', ln_len, ln);
                ln_len := ln_len + 1;
                g17trimint4_to_line (inf_first_iosequence, ln_len, ln);
                ln_len      := ln_len + 1;
                ln [ln_len] := ')'
                END;
            (*ENDIF*) 
            t09put (term, ln, cut_protected);
            t12write_prot (protfile, ln, ln_len, err);
            END
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    ln     := term.blankline;
    ln_len := c_margin;
    g17nameto_line ('serverdb     :    ', ln_len, ln);
    SAPDB_PascalForcedMove (sizeof (inf_serverdb), sizeof (ln),
          @inf_serverdb, 1, @ln, ln_len+2,
          sizeof (inf_serverdb));
    ln_len  := ln_len + 1 + sizeof (inf_serverdb);
    t09put (term, ln, cut_protected);
    t12write_prot (protfile, ln, ln_len, err);
    IF  inf_servernode <> bsp_nodeid
    THEN
        BEGIN
        ln     := term.blankline;
        ln_len := c_margin;
        g17nameto_line ('servernode   :    ', ln_len, ln);
        SAPDB_PascalForcedMove (sizeof (inf_servernode), sizeof (ln),
              @inf_servernode, 1, @ln, ln_len+2,
              sizeof (inf_servernode));
        ln_len  := ln_len + 1 + sizeof (inf_servernode);
        t09put (term, ln, cut_protected);
        t12write_prot (protfile, ln, ln_len, err)
        END;
    (*ENDIF*) 
    IF  (inf_mess_type = m_save_parallel)
        OR
        (inf_mess_type = m_autosave)
    THEN
        BEGIN
        ln      := term.blankline;
        ln_len  := c_margin;
        g17nameto_line ('version      :    ', ln_len, ln);
        SAPDB_PascalForcedMove (sizeof (inf_curr_knlvers), sizeof (ln),
              @inf_curr_knlvers, 1, @ln, ln_len+2,
              sizeof (inf_curr_knlvers));
        ln_len  := ln_len + 1 + sizeof (inf_curr_knlvers);
        t09put (term, ln, cut_protected);
        t12write_prot (protfile, ln, ln_len, err);
        END;
    (*ENDIF*) 
    IF  (inf_mess2_type = mm_database)
        OR
        (inf_mess2_type = mm_pages)
    THEN
        BEGIN
        ln      := term.blankline;
        ln_len  := c_margin;
        g17nameto_line ('restartable  :    ', ln_len, ln);
        ln_len  := ln_len + 1;
        IF  inf_is_consistent
        THEN
            g17nameto_line ('without log       ', ln_len, ln)
        ELSE
            g17nameto_line ('only with log     ', ln_len, ln);
        (*ENDIF*) 
        t09put (term, ln, cut_protected);
        t12write_prot (protfile, ln, ln_len, err)
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      xt03is_searched_page (
            wanted_pagetype : tgg00_PageType;
            wanted_pt2      : tgg00_PageType2;
            wanted_pno      : tsp00_Int4;
            recoveryMode    : tgg00_RecoveryMode;
            page            : tsp00_MoveObjPtr) : boolean;
 
VAR
 
      pUnivPage : RECORD
            CASE integer OF
                1:
                    (pPage     : tsp00_MoveObjPtr);
                2:
                    (pHeader   : ^tgg00_PageHeader);
                3:
                    (pPageAddr : tsp00_PageAddr);
                END;
            (*ENDCASE*) 
 
      bIsLeaf      : boolean;
      bIsPerm      : boolean;
      bIsDynamic   : boolean;
      version      : tsp00_Int4;
      devNo        : tsp00_Int4;
      blockNo      : tsp00_Int4;
      baseNo       : tsp00_Int4;
      totalCnt     : tsp00_Int4;
      parentIndex  : tsp00_Int4;
      pageEntryNo  : tsp00_Int4;
 
BEGIN
IF  (page = NIL)
    OR
    (ord (page^[c_ptype_pos]) <> ord (wanted_pagetype))
THEN
    xt03is_searched_page := false
ELSE
    BEGIN
    pUnivPage.pPage := page;
    IF  (wanted_pt2 = pt2Nil_egg00) OR (wanted_pt2 = pUnivPage.pHeader^.pageType2_gg00)
    THEN
        BEGIN
        CASE wanted_pagetype OF
            ptLogInfo_egg00 :
                xt03is_searched_page := true;
            ptLog_egg00 :
                xt03is_searched_page := x04search_iosequence (page^, wanted_pno);
            ptConverter_egg00:
                BEGIN
&               ifdef SLOWCI
                xt03is_searched_page := false;
&               else
                bd10GetPageHeader( pUnivPage.pPageAddr, version, devNo, blockNo, baseNo, totalCnt,
                      parentIndex, pageEntryNo, bIsLeaf, bIsPerm, bIsDynamic );
                IF  (NOT bIsLeaf) OR (baseNo <> wanted_pno)
                THEN
                    xt03is_searched_page := false
                ELSE
                    BEGIN
                    CASE recoveryMode  OF
                        rmTemp_egg00:
                            xt03is_searched_page := bIsDynamic AND NOT bIsPerm;
                        rmStatic_egg00:
                            xt03is_searched_page := NOT bIsDynamic;
                        rmPerm_egg00:
                            xt03is_searched_page := bIsDynamic AND bIsPerm;
                        OTHERWISE:
                            xt03is_searched_page := false;
                        END;
                    (*ENDCASE*) 
                    END;
                (*ENDIF*) 
&               endif
                END;
            ptData_egg00 :
                BEGIN
                IF  wanted_pno <> pUnivPage.pHeader^.pageId_gg00
                THEN
                    BEGIN
                    IF  (wanted_pno = NIL_PAGE_NO_GG00) AND (wanted_pt2 = pt2Checkpt_egg00)
                    THEN
                        xt03is_searched_page := true
                    ELSE
                        xt03is_searched_page := false;
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    CASE recoveryMode  OF
                        rmTemp_egg00:
                            xt03is_searched_page :=
                                  (pmTemp_egg00 IN pUnivPage.pHeader^.pageMode_gg00);
                        rmStatic_egg00:
                            xt03is_searched_page :=
                                  (pUnivPage.pHeader^.pageType2_gg00 = pt2Object_egg00   )  OR
                                  (pUnivPage.pHeader^.pageType2_gg00 = pt2VarObject_egg00)
                        OTHERWISE:
                            xt03is_searched_page := true;
                        END;
                    (*ENDCASE*) 
                    END
                (*ENDIF*) 
                END;
            OTHERWISE:
                xt03is_searched_page :=
                      ((wanted_pno = pUnivPage.pHeader^.pageId_gg00) OR
                      (wanted_pno = NIL_PAGE_NO_GG00 ));
            END;
        (*ENDCASE*) 
        END
    ELSE
        xt03is_searched_page := false;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt03print_separator (VAR term : tut_terminal;
            VAR protfile : tut_vf_fileref);
 
VAR
      err : integer;
 
BEGIN
t12write_prot (protfile, term.blankline, 1, err);
t12write_prot (protfile, term.blankline, 1, err);
IF  NOT t09is_empty_window (term)
THEN
    t09put (term, term.blankline, cut_protected)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt03scan_menu (VAR term : tut_terminal;
            VAR displ_info    : display_info;
            VAR pfkey         : tut_pfkey);
 
VAR
      i : integer;
      n : tsp00_Name;
      s : ARRAY [1..16] OF tsp00_C60;
 
BEGIN
t09newscreen_page (term);
s[ 1]:= 'node:                                                       ';
s[ 2]:= '   F = node header                                          ';
s[ 3]:= '   K = key      S = key (short info: first/last key of node)';
s[ 4]:= '                M = key (minbuf/maxbuf)                     ';
s[ 5]:= '   R = record/object                                        ';
s[ 6]:= '                                                            ';
s[ 7]:= 'log:                                       dump:            ';
s[ 8]:= '   H = logentry (header only)                 D = dump label';
s[ 9]:= '   L = logentry                               F = full info ';
s[10]:= '   G = logentry (minbuf/maxbuf)                             ';
s[11]:= '                                                            ';
s[12]:= 'BD pages (converter, file directory):                       ';
s[13]:= '   B = BD full info                                         ';
s[14]:= '                                                            ';
s[15]:= 'other pages (restartrec, log info, hostfile info, etc.):    ';
s[16]:= '   F = full info                                            ';
FOR i := 1 TO 16 DO
    IF  (i = 1) OR (i = 7) OR (i = 12) OR (i = 15)
    THEN
        t09put60 (term, s [i], cut_bright_protected)
    ELSE
        t09put60 (term, s [i], cut_protected);
    (*ENDIF*) 
(*ENDFOR*) 
t09put (term, term.blankline, cut_protected);
n := bsp_name;
t09get1name (term, '        SELECT CHAR:', cut_bright_protected,
      cut_unprotected, sizeof (n), c_upper, n, pfkey);
IF  pfkey = pf_none
THEN
    WITH displ_info DO
        BEGIN
        x05reset_scan (di_scan);
        di_scan := di_scan + [utds_page_header];
        FOR i := 1 TO sizeof (n) DO
            CASE n [i] OF
                'B':
                    di_scan := di_scan + [utds_bd_full_info      ];
                'D':
                    di_scan := di_scan + [utds_dump_label        ];
                'F':
                    di_scan := di_scan + [utds_full_info         ];
                'G':
                    di_scan := di_scan + [utds_logentry_header
                          ,               utds_logentry_buf      ];
                'H':
                    di_scan := di_scan + [utds_logentry_header   ];
                'K':
                    di_scan := di_scan + [utds_node
                          ,               utds_key               ];
                'L':
                    di_scan := di_scan + [utds_logentry_header
                          ,               utds_logentry_full_info];
                'M':
                    di_scan := di_scan + [utds_node
                          ,               utds_key_buf           ];
                'R':
                    di_scan := di_scan + [utds_node
                          ,               utds_rec               ];
                'S':
                    di_scan := di_scan + [utds_node
                          ,               utds_key_first_last    ];
                OTHERWISE
                    pfkey := pf_none
                END
            (*ENDCASE*) 
        (*ENDFOR*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  pfkey <> pf_cancel
THEN
    pfkey := pf_none
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt03scanned_msg (VAR term : tut_terminal;
            VAR file_pos   : tut_file_pos;
            VAR msg_time   : tsp00_Int4;
            VAR last_displ : tsp00_Int4);
 
VAR
      ln_len       : integer;
      block_page   : tsp00_Int4;
      curr_time    : tsp00_Int4;
      dummy_micsec : tsp00_Int4;
      ln           : tsp00_Line;
 
BEGIN
sqlclock (curr_time, dummy_micsec);
IF  curr_time - msg_time >= c_display_interval
THEN
    BEGIN
    msg_time   := curr_time;
    last_displ := file_pos.utfp_block_no;
    block_page := last_displ * file_pos.utfp_pages_per_block;
    ln         := term.blankline;
    ln_len     := 0;
    g17trimint4_to_line (block_page, ln_len, ln);
    ln_len := ln_len + 1;
    g17sname_to_line ('pages       ', ln_len, ln);
    IF  file_pos.utfp_pages_per_block > 1
    THEN
        BEGIN
        ln_len := ln_len + 3;
        g17trimint4_to_line (file_pos.utfp_block_no, ln_len, ln);
        ln_len := ln_len + 1;
        g17sname_to_line ('blocks      ', ln_len, ln)
        END;
    (*ENDIF*) 
    t09putmsg (term, ln, NOT c_warning, c_immediate_displ)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt03search_on_log (VAR term : tut_terminal;
            VAR protfile       : tut_vf_fileref;
            VAR f              : tut_file;
            VAR from_pos       : tut_file_pos;
            VAR to_pos         : tut_file_pos;
            VAR displ_info     : display_info;
            VAR pfkey          : tut_pfkey);
 
CONST
      x_transaction_id =  1;
      x_oid            =  3;
      x_return         =  6;
 
VAR
      io_err              : tsp00_VfReturn;
      wanted_ptype        : tgg00_PageType;
      aux_scan            : tut_diag_scan;
      dummy_msec          : tsp00_Int4;
      last_displ          : tsp00_Int4;
      msg_time            : tsp00_Int4;
      selected            : integer;
      msg                 : tut_c20_array;
      entryOffset         : tsp00_Int4;
      end_of_trans_found  : boolean;
      found               : boolean;
      wanted_action_id    : tsp00_Int4;
      oid_pno             : tsp00_Int4;
      oid_offset          : tsp00_Int4;
      wanted_oid          : tgg00_OidSpace;
      wanted_int4_transno : tsp00_Int4;
      wanted_transno      : tgg91_TransNo;
 
BEGIN
found               := false;
pfkey               := pf_none;
wanted_int4_transno := 0;
wanted_action_id    := 0;
oid_pno             := 0;
oid_offset          := 0;
FOR selected := 1 TO x_return DO
    msg [selected] := bsp_c20;
(*ENDFOR*) 
msg [x_transaction_id] := 'TRANSACTION ID      ';
msg [x_oid           ] := 'OID                 ';
msg [x_return        ] := return_msg;
REPEAT
    wanted_ptype  := ptNil_egg00;
    t09msgheader (term, '     SEARCH ON LOG VOLUME     ', c_perm);
    t09menu (term, x_return, cut_protected, msg, selected, pfkey);
    t09msgheader (term, bsp_c30, c_perm);
    IF  (pfkey = pf_none) AND (selected <> x_return)
    THEN
        CASE selected OF
            x_transaction_id:
                BEGIN
                wanted_ptype := ptLog_egg00;
                x05readint4 (term, NOT c_init, NOT c_int2,
                      '     TRANSACTION ID:',
                      wanted_int4_transno, pfkey);
                gg06TransBecomes (wanted_transno, wanted_int4_transno);
                x05readint4 (term, NOT c_init, NOT c_int2,
                      '          ACTION ID:',
                      wanted_action_id, pfkey);
                END;
            x_oid:
                BEGIN
                wanted_ptype := ptLog_egg00;
                x05read2_int4 (term,
                      NOT c_init, NOT c_int2, '         OID.pageno:', oid_pno,
                      NOT c_init, NOT c_int2, '         OID.offset:', oid_offset,
                      pfkey);
                gg06SetOid (wanted_oid, oid_pno, oid_offset, 1);
                x05readint4 (term, NOT c_init, NOT c_int2,
                      '          ACTION ID:',
                      wanted_action_id, pfkey);
                END;
            OTHERWISE
                ;
            END;
        (*ENDCASE*) 
    (*ENDIF*) 
    IF  wanted_ptype <> ptNil_egg00
    THEN
        BEGIN
        IF  pfkey = pf_none
        THEN
            BEGIN
            IF  (from_pos.utfp_block_no = to_pos.utfp_block_no)
                AND
                (from_pos.utfp_page_no  = to_pos.utfp_page_no )
            THEN
                to_pos.utfp_block_no :=
                      from_pos.utfp_block_no + c_default_dump_upb;
            (*ENDIF*) 
            x05read_block_no_from_to (term, NOT c_only_from,
                  from_pos, to_pos, pfkey)
            END;
        (*ENDIF*) 
        IF  pfkey = pf_none
        THEN
            x05get_direct (term, f, from_pos.utfp_block_no,
                  from_pos.utfp_page_no, io_err);
        (*ENDIF*) 
        IF  (pfkey = pf_none) AND (io_err = vf_ok)
        THEN
            BEGIN
            entryOffset        := 0;
            found              := false;
            end_of_trans_found := false;
            last_displ  := 0;
            sqlclock (msg_time, dummy_msec);
            x05display_msg (term, scanning_msg,
                  NOT c_warning, c_immediate_displ);
            WHILE (io_err = vf_ok)
                  AND
                  (pfkey = pf_none)
                  AND
                  NOT term.is_reset_called
                  AND
                  NOT x05is_greater_file_pos (f.utf_pos, to_pos)
                  AND
                  NOT end_of_trans_found DO
                BEGIN
                (* analyze page *)
                IF  selected = x_transaction_id
                THEN
                    found := x04search_for_transno (f.utf_page^, f.utf_page_len,
                          wanted_transno, wanted_action_id,
                          end_of_trans_found, entryOffset)
                ELSE
                    found := x04search_for_oid (f.utf_page^, f.utf_page_len,
                          wanted_oid, wanted_action_id, entryOffset);
                (*ENDIF*) 
                IF  found
                THEN
                    BEGIN
                    from_pos := f.utf_pos;
                    aux_scan := displ_info.di_scan;
                    displ_info.di_scan := displ_info.di_scan
                          + [utds_page_header       ]
                          + [utds_full_info         ]
                          + [utds_logentry_full_info];
                    t09putmsg (term, term.blankline, NOT c_warning,
                          NOT c_immediate_displ);
                    IF  NOT term.is_batch
                    THEN
                        t09display (term, utds_display in displ_info.di_scan);
                    (*ENDIF*) 
                    t09newscreen_page (term);
                    x04logpage_display (term, protfile, displ_info.di_scan, f.utf_pos,
                          f.utf_page^, f.utf_page_len, entryOffset, pfkey);
                    IF  pfkey = pf_none
                    THEN
                        x05holdhexint (term, pfkey);
                    (*ENDIF*) 
                    displ_info.di_scan := aux_scan
                    END;
                (*ENDIF*) 
                IF  NOT x04offset_is_valid (f.utf_page^, f.utf_page_len, entryOffset)
                    AND
                    NOT x05is_greater_file_pos (f.utf_pos, to_pos)
                THEN
                    BEGIN
                    entryOffset := 0;
                    x05get_next (term, f, io_err);
                    IF  (io_err = vf_ok)
                        AND
                        (f.utf_pos.utfp_block_no - last_displ
                        >= c_display_block_no)
                        AND
                        ((f.utf_pos.utfp_block_no MOD 10) = 0)
                    THEN
                        xt03scanned_msg (term, f.utf_pos,
                              msg_time, last_displ)
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            IF  NOT found
            THEN
                x05display_msg (term, not_found_msg, c_warning,
                      NOT c_immediate_displ)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  NOT term.is_inputfile
        THEN
            term.is_reset_called := false;
        (*ENDIF*) 
        IF  pfkey = pf_end
        THEN
            pfkey := pf_none
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  NOT term.is_batch
    THEN
        t09display (term, c_on)
    (*ENDIF*) 
UNTIL
    (selected = x_return) OR (pfkey <> pf_none)
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt03select_buf (VAR term : tut_terminal;
            VAR protfile       : tut_vf_fileref;
            VAR f              : tut_file;
            VAR from_pos       : tut_file_pos;
            VAR to_pos         : tut_file_pos;
            VAR displ_info     : display_info;
            VAR pfkey          : tut_pfkey);
 
CONST
      x_data_perm        =  1;
      x_data_static      =  2;
      x_data_temp        =  3;
      x_converter_perm   =  5;
      x_converter_static =  6;
      x_converter_temp   =  7;
      x_restart          =  8;
      x_log              = 10;
      x_loginfo          = 11;
      x_return           = 14;
 
VAR
      io_err        : tsp00_VfReturn;
      wanted_ptype  : tgg00_PageType;
      wanted_ptype2 : tgg00_PageType2;
      aux_scan      : tut_diag_scan;
      recoveryMode  : tgg00_RecoveryMode;
      dummy_msec    : tsp00_Int4;
      last_displ    : tsp00_Int4;
      msg_time      : tsp00_Int4;
      wanted_pno    : tsp00_Int4;
      selected      : integer;
      pno_msg       : tsp00_C20;
      msg           : tut_c20_array;
 
BEGIN
pfkey      := pf_none;
wanted_pno := NIL_PAGE_NO_GG00;
FOR selected := 1 TO x_return DO
    msg [selected] := bsp_c20;
(*ENDFOR*) 
msg [x_data_perm   ] := 'DATA PERM           ';
msg [x_data_static ] := 'DATA STATIC         ';
msg [x_data_temp   ] := 'DATA TEMP           ';
(* *)
msg [x_converter_perm   ] := 'CONVERTER  PERM     ';
msg [x_converter_static ] := 'CONVERTER  STATIC   ';
msg [x_converter_temp   ] := 'CONVERTER  TEMP     ';
(* *)
msg [x_restart ] := 'RESTART RECORD      ';
(* *)
msg [x_loginfo ] := 'LOG INFO            ';
msg [x_log     ] := 'LOG                 ';
msg [x_return  ] := return_msg;
(* *)
REPEAT
    recoveryMode  := rmNone_egg00;
    wanted_ptype  := ptNil_egg00;
    wanted_ptype2 := pt2Nil_egg00;
    t09msgheader (term, '        SEARCH PAGE           ', c_perm);
    t09menu (term, x_return, cut_protected, msg, selected, pfkey);
    t09msgheader (term, bsp_c30, c_perm);
    IF  (pfkey = pf_none) AND (selected <> x_return)
    THEN
        CASE selected OF
            x_data_perm:
                BEGIN
                wanted_ptype := ptData_egg00;
                pno_msg      := '   PERM DATA PAGENO:';
                recoveryMode := rmPerm_egg00;
                END;
            x_data_static:
                BEGIN
                wanted_ptype := ptData_egg00;
                pno_msg      := ' STATIC DATA PAGENO:';
                recoveryMode := rmStatic_egg00;
                END;
            x_data_temp:
                BEGIN
                wanted_ptype := ptData_egg00;
                pno_msg      := '   TEMP DATA PAGENO:';
                recoveryMode := rmTemp_egg00;
                END;
            x_converter_perm:
                BEGIN
                wanted_ptype := ptConverter_egg00;
                pno_msg      := '        PERM BASENO:';
                recoveryMode := rmPerm_egg00;
                END;
            x_converter_static:
                BEGIN
                wanted_ptype := ptConverter_egg00;
                pno_msg      := '      STATIC BASENO:';
                recoveryMode := rmStatic_egg00;
                END;
            x_converter_temp:
                BEGIN
                wanted_ptype := ptConverter_egg00;
                pno_msg      := '        TEMP BASENO:';
                recoveryMode := rmTemp_egg00;
                END;
            x_restart:
                BEGIN
                wanted_ptype  := ptData_egg00;
                wanted_ptype2 := pt2Checkpt_egg00;
                END;
            x_loginfo:
                BEGIN
                wanted_ptype  := ptLogInfo_egg00;
                END;
            x_log:
                BEGIN
                wanted_ptype  := ptLog_egg00;
                pno_msg       := ' LOG IO SEQUENCE NO:'
                END;
            OTHERWISE
                ;
            END;
        (*ENDCASE*) 
    (*ENDIF*) 
    IF  wanted_ptype <> ptNil_egg00
    THEN
        BEGIN
        IF  (selected = x_loginfo) OR (selected = x_restart)
        THEN
            wanted_pno := NIL_PAGE_NO_GG00
        ELSE
            BEGIN
            IF  wanted_pno = NIL_PAGE_NO_GG00
            THEN
                wanted_pno := 0;
            (*ENDIF*) 
            x05readint4 (term, NOT c_init, NOT c_int2, pno_msg, wanted_pno, pfkey)
            END;
        (*ENDIF*) 
        IF  pfkey = pf_none
        THEN
            BEGIN
            IF  (from_pos.utfp_block_no = to_pos.utfp_block_no)
                AND
                (from_pos.utfp_page_no  = to_pos.utfp_page_no )
            THEN
                to_pos.utfp_block_no := from_pos.utfp_block_no + c_default_dump_upb;
            (*ENDIF*) 
            x05read_block_no_from_to (term, NOT c_only_from,
                  from_pos, to_pos, pfkey)
            END;
        (*ENDIF*) 
        IF  pfkey = pf_none
        THEN
            x05get_direct (term, f, from_pos.utfp_block_no,
                  from_pos.utfp_page_no, io_err);
        (*ENDIF*) 
        IF  (pfkey = pf_none) AND (io_err = vf_ok)
        THEN
            BEGIN
            last_displ := 0;
            sqlclock (msg_time, dummy_msec);
            x05display_msg (term, scanning_msg, NOT c_warning, c_immediate_displ);
            (* *)
            WHILE (io_err = vf_ok)
                  AND NOT term.is_reset_called
                  AND NOT xt03is_searched_page
                  ( wanted_ptype, wanted_ptype2, wanted_pno, recoveryMode, f.utf_page)
                  AND NOT x05is_greater_file_pos (f.utf_pos, to_pos) DO
                BEGIN
                x05get_next (term, f, io_err);
                IF  (io_err = vf_ok)
                    AND
                    (f.utf_pos.utfp_block_no - last_displ
                    >= c_display_block_no)
                    AND
                    ((f.utf_pos.utfp_block_no MOD 10) = 0)
                THEN
                    xt03scanned_msg (term, f.utf_pos,
                          msg_time, last_displ)
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            IF  (io_err = vf_ok) AND NOT term.is_reset_called
                AND
                xt03is_searched_page
                (   wanted_ptype, wanted_ptype2, wanted_pno, recoveryMode, f.utf_page)
            THEN
                BEGIN
                from_pos := f.utf_pos;
                aux_scan := displ_info.di_scan;
                displ_info.di_scan := displ_info.di_scan
                      + [utds_page_header]
                      + [utds_full_info  ];
                t09putmsg (term, term.blankline, NOT c_warning, NOT c_immediate_displ);
                IF  NOT term.is_batch
                THEN
                    t09display (term, utds_display in displ_info.di_scan);
                (*ENDIF*) 
                t09newscreen_page (term);
                xt03display_buffer (term, protfile, f, displ_info, pfkey);
                IF  pfkey = pf_none
                THEN
                    x05holdhexint (term, pfkey);
                (*ENDIF*) 
                displ_info.di_scan := aux_scan
                END
            ELSE
                x05display_msg (term, not_found_msg, c_warning, NOT c_immediate_displ)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  NOT term.is_inputfile
        THEN
            term.is_reset_called := false;
        (*ENDIF*) 
        IF  pfkey = pf_end
        THEN
            pfkey := pf_none
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  NOT term.is_batch
    THEN
        t09display (term, c_on)
    (*ENDIF*) 
UNTIL
    (selected = x_return) OR (pfkey <> pf_none)
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt03write_undo (VAR term : tut_terminal;
            VAR f         : tut_file;
            VAR undo_file : tut_file;
            VAR orig_page : tsp00_Page);
 
VAR
      io_err      : tsp00_VfReturn;
      dummy_pfkey : tut_pfkey;
      undo_head   : t_undo_head_addr;
 
BEGIN
undo_head               := @undo_file.utf_block^;
undo_head^.udh_block_no := f.utf_pos.utfp_block_no;
undo_head^.udh_page_no  := f.utf_pos.utfp_block_no;
undo_file.utf_block_len := sizeof (undo_head^) + sizeof (orig_page);
SAPDB_PascalForcedMove (sizeof (orig_page), undo_file.utf_block_size,
      @orig_page, 1,
      @undo_file.utf_block^, sizeof (undo_head^) + 1,
      sizeof (orig_page));
sqldattime (undo_head^.udh_date, undo_head^.udh_time);
(* *)
x05write_seq (term, undo_file, io_err);
(* *)
IF  io_err <> vf_ok
THEN
    t09holding (term, dummy_pfkey)
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
