* @lastChanged: "2000-03-15"
 
 * @filename:   vxt08
 * @purpose:    "XT_dump_display"
 * @release:    7.2.0.0
 * @see:        "-.-"
 *
 * @Copyright (c) 1999-2005 SAP AG"
*/
 
.tt 1 $SAP$LiveCache$VXT08$
.tt 3 $$XT_dump_display$2000-10-18$
 
.nf
 
 .nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
 
 
.fo
***********************************************************
 
Module  : XT_dump_display
 
Define  :
 
        PROCEDURE
              x08dumpdisplay (VAR term : tut_terminal;
                    VAR f        : tut_file;
                    VAR prot     : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    search_label : tsp00_Name;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey;
                    VAR found    : boolean);
 
        PROCEDURE
              x08fdir_rec_edit (VAR term : tut_terminal;
                    VAR prot   : tut_vf_fileref;
                    VAR buf    : tsp00_MoveObj;
                    buf_size   : tsp00_Int4;
                    buf_offset : tsp00_Int4;
                    is_edit    : boolean;
                    VAR pfkey  : tut_pfkey);
 
        PROCEDURE
              x08hostinfo_display (VAR term : tut_terminal;
                    VAR prot     : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    page_name    : tsp00_Sname;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x08edit_display_action (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    buf_offset   : tsp00_Int4;
                    VAR pfkey    : tut_pfkey;
                    entry_length : tsp00_Int4;
                    actiontype   : tsp00_Uint1;
                    forRedo      : boolean);
 
        PROCEDURE
              x08beforeimage_edit_display (VAR term : tut_terminal;
                    VAR prot   : tut_vf_fileref;
                    scan       : tut_diag_scan;
                    VAR buf    : tsp00_MoveObj;
                    buf_size   : tsp00_Int4;
                    buf_offset : tsp00_Int4;
                    VAR pfkey  : tut_pfkey);
 
        PROCEDURE
              x08node_edit_display (VAR term : tut_terminal;
                    VAR prot     : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x08logredo_edit_display (VAR term : tut_terminal;
                    VAR prot     : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x08logundo_edit_display (VAR term : tut_terminal;
                    VAR prot     : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x08history_edit_display (VAR term : tut_terminal;
                    VAR prot     : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x08historydir_edit_display (VAR term : tut_terminal;
                    VAR prot     : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x08opentrans_edit_display (VAR term : tut_terminal;
                    VAR prot     : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x08loginfo_display (VAR term : tut_terminal;
                    VAR prot     : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x08obj_edit (VAR term : tut_terminal;
                    VAR prot   : tut_vf_fileref;
                    VAR buf    : tsp00_MoveObj;
                    buf_size   : tsp00_Int4;
                    buf_offset : tsp00_Int4;
                    is_edit    : boolean;
                    VAR pfkey  : tut_pfkey);
 
        PROCEDURE
              x08object_node_edit_display (VAR term : tut_terminal;
                    VAR prot     : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x08rec_edit (VAR term : tut_terminal;
                    VAR prot   : tut_vf_fileref;
                    VAR buf    : tsp00_MoveObj;
                    buf_size   : tsp00_Int4;
                    buf_offset : tsp00_Int4;
                    is_edit    : boolean;
                    is_catalog : boolean;
                    page_type2 : tgg00_PageType2;
                    VAR pfkey  : tut_pfkey);
 
        PROCEDURE
              x08restart_display (VAR term : tut_terminal;
                    VAR prot     : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    page_name    : tsp00_Sname;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x08iomanpage_display (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    scan         : tut_diag_scan;
                    VAR file_pos : tut_file_pos;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              x08savept_display (VAR term : tut_terminal;
                    VAR prot  : tut_vf_fileref;
                    scan      : tut_diag_scan;
                    VAR buf   : tsp00_MoveObj;
                    buf_size  : tsp00_Int4;
                    VAR pfkey : tut_pfkey);
 
        PROCEDURE
              x08tree_index_rec_edit (VAR term : tut_terminal;
                    VAR prot   : tut_vf_fileref;
                    VAR buf    : tsp00_MoveObj;
                    buf_size   : tsp00_Int4;
                    buf_offset : tsp00_Int4;
                    is_edit    : boolean;
                    VAR pfkey  : tut_pfkey);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              XT_auxiliary_procedures : VXT05;
 
        PROCEDURE
              x05blockno_to_line (VAR file_pos : tut_file_pos;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              x05date_time_to_line (
                    date_int   : tsp00_Int4;
                    time_int   : tsp00_Int4;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              x05get_next (VAR term : tut_terminal;
                    VAR f           : tut_file;
                    VAR err         : tsp00_VfReturn);
 
        PROCEDURE
              x05helphexint (VAR term : tut_terminal;
                    VAR pfkey : tut_pfkey);
 
        PROCEDURE
              x05hextrim_to_line (VAR buf : tsp00_MoveObj;
                    buf_pos    : tsp00_Int4;
                    buf_len    : tsp00_Int4;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              x05holdhexint (VAR term : tut_terminal;
                    VAR pfkey : tut_pfkey);
 
        FUNCTION
              x05ishex (VAR buf : tsp00_MoveObj;
                    buf_size    : tsp00_Int4;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4): boolean;
 
        PROCEDURE
              x05pageno_to_line (pno : tsp00_Int4;
                    trim       : boolean;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              XT_heap_analysis : VXT12;
 
        FUNCTION
              x12FirstChunk (pRawChunk : tgg00_VoidPtr) : tgg00_VoidPtr;
 
        FUNCTION
              x12NextChunk (pCurrChunk : tgg00_VoidPtr) : tgg00_VoidPtr;
 
        PROCEDURE
              x12ChunkInfo (pCurrChunk : tgg00_VoidPtr;
                    VAR offset    : tsp00_Int4;
                    VAR chunkSize : tsp00_Int4;
                    VAR inUse     : boolean;
                    VAR ok        : boolean;
                    VAR prev      : tgg00_VoidPtr;
                    VAR next      : tgg00_VoidPtr;
                    VAR errorText : tsp00_C40);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        PROCEDURE
              gg06FileVersToLine (VAR FileVers : tgg91_FileVersion;
                    VAR LineLen : integer;
                    VAR Line    : tsp00_Line);
 
        FUNCTION
              gg06Int4Get (VAR buffer: tsp00_MoveObj;
                    pos : tsp00_Int4): tsp00_Int4;
 
        FUNCTION
              gg06Int4FromUint2 (Uint2 : tsp00_Uint2): tsp00_Int4;
 
        PROCEDURE
              gg06OidToLine (VAR oid : tgg00_OidSpace;
                    VAR LineLen      : integer;
                    VAR Line         : tsp00_Line);
 
        PROCEDURE
              gg06SessionToLine (VAR SessionNo : tgg91_SessionNo;
                    VAR LineLen : integer;
                    VAR Line    : tsp00_Line);
 
        PROCEDURE
              gg06TransToLine (VAR TransNo : tgg91_TransNo;
                    VAR LineLen : integer;
                    VAR Line    : tsp00_Line);
 
        PROCEDURE
              gg06LogActionToLine (ActionType : integer;
                    VAR LineLen : integer;
                    VAR Line    : tsp00_Line);
 
        PROCEDURE
              gg06DeviceStateToLine (devicestate : integer;
                    VAR length : integer;
                    VAR line   : tsp00_Line);
 
        PROCEDURE
              gg06FlushModeToLine (flushmode : integer;
                    VAR length : integer;
                    VAR line   : tsp00_Line);
 
        PROCEDURE
              gg06LogSavepointReasonToLine (Reason : integer;
                    VAR LineLen : integer;
                    VAR Line    : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17basis_err_to_line (b_err : tgg00_BasisError;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17bd_fdesc_to_line (bd_fdesc : tbd_fileinfo_desc_set;
                    is_edit_mode : boolean;
                    VAR ln_len   : integer;
                    VAR ln       : tsp00_Line);
 
        PROCEDURE
              g17bd_fstate_to_line (bd_fstate : tbd_file_state_set;
                    is_edit_mode : boolean;
                    VAR ln_len   : integer;
                    VAR ln       : tsp00_Line);
 
        PROCEDURE
              g17bd_use_set_to_line (bd_use : tgg00_BdUseSet;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17bd_data_io_state_to_line (io_state : tsp00_Uint1;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17bd_task_queue_state_to_line (task_state : tbd02_TaskQueueReason;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17counter_to_line (counter : tsp00_8ByteCounter;
                    VAR ln_len            : integer;
                    VAR ln                : tsp00_Line);
 
        PROCEDURE
              g17c4int_to_line (int : tsp00_C4;
                    VAR ln_len      : integer;
                    VAR ln          : tsp00_Line);
 
        PROCEDURE
              g17date_to_line (date : tsp00_Date;
                    VAR ln_len      : integer;
                    VAR ln          : tsp00_Line);
 
        PROCEDURE
              g17filename (nam      : tsp00_Sname;
                    VAR fn          : tgg00_Filename;
                    line_indent     : integer;
                    VAR first_ln    : tsp00_Line;
                    VAR second_ln   : tsp00_Line;
                    VAR third_ln    : tsp00_Line;
                    VAR is_third_ln : boolean);
 
        PROCEDURE
              g17filetype_to_line (filetype : tgg00_FiletypeSet;
                    is_edit_mode : boolean;
                    VAR ln_len   : integer;
                    VAR ln       : tsp00_Line);
 
        PROCEDURE
              g17efiletype_to_line (
                    efiletype    : tgg00_ExtendedFiletypeSet;
                    is_edit_mode : boolean;
                    VAR ln_len   : integer;
                    VAR ln       : tsp00_Line);
 
        PROCEDURE
              g17handling_set_to_line (handling : tgg00_HandlingSet;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17hexto_line (c : char;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17intdate_time (
                    int_date     : tsp00_Int4;
                    int_time     : tsp00_Int4;
                    VAR str_date : tsp00_Date;
                    VAR str_time : tsp00_Time);
 
        PROCEDURE
              g17int4to_line (int : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_Line);
 
        PROCEDURE
              g17lockmode_to_line (lock_mode : tgg00_LockReqMode;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17lockstate_to_line (lock_state : tgg00_LockReqState;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17messtype_to_line (mess_type : tgg00_MessType;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17mess2type_to_line (mess2_type : tgg00_MessType2;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17nameto_line (n : tsp00_Name;
                    VAR ln_len  : integer;
                    VAR ln      : tsp00_Line);
 
        PROCEDURE
              g17onestackentry (
                    VAR st             : tgg00_StackEntry;
                    entry_index        : integer;
                    VAR ln             : tsp00_Line (*ptocSynonym char**);
                    VAR is_second_ln   : boolean;
                    VAR second_ln      : tsp00_Line (*ptocSynonym char**));
 
        PROCEDURE
              g17page_ref_to_line (VAR page_ref : tgg91_PageRef;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17pagecheck_to_line (pagecheck : tgg00_PageCheckType;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17pagemode_to_line (pagemode : tgg00_PageMode;
                    is_edit_mode : boolean;
                    VAR ln_len   : integer;
                    VAR ln       : tsp00_Line);
 
        PROCEDURE
              g17pagetype_to_line (pagetype : tgg00_PageType;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17pagetype2_to_line (pagetype2 : tgg00_PageType2;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        FUNCTION
              g17printable_char (c : char) : boolean;
 
        PROCEDURE
              gg17SessionTransToLine (
                    VAR session      : tgg91_SessionNo;
                    VAR transid      : tgg91_TransNo;
                    VAR writetransid : tgg91_TransNo;
                    VAR subtrans     : tgg00_SubtransNo;
                    VAR ln_len       : integer;
                    VAR ln           : tsp00_Line);
 
        PROCEDURE
              g17siteto_line (site : tgg00_ServerdbNo;
                    VAR ln_len     : integer;
                    VAR ln         : tsp00_Line);
 
        PROCEDURE
              g17sname_to_line (n : tsp00_Sname;
                    VAR ln_len    : integer;
                    VAR ln        : tsp00_Line);
 
        PROCEDURE
              g17surrogate_to_line (VAR surrogate : tgg00_Surrogate;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17tfntype_to_line (tfn : tgg00_Tfn;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17ttfntemp_to_line (
                    ttfn       : tgg00_TfnTemp;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17time_to_line (time : tsp00_Time;
                    VAR ln_len      : integer;
                    VAR ln          : tsp00_Line);
 
        PROCEDURE
              g17trans_state_to_line (trans_state : tgg00_TransState;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17trimint4_to_line (int : tsp00_Int4;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines_2 : VGG172;
 
        PROCEDURE
              g172Char8AsUint8_to_line (
                    Char8      : tsp00_C8;
                    VAR ln_pos : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g172Char8AsInt8_to_line (
                    Char8      : tsp00_C8;
                    VAR ln_pos : integer;
                    VAR ln     : tsp00_Line (*ptocSynonym char**));
 
      ------------------------------ 
 
        FROM
              TA_terminal_IO : VTA09;
 
        FUNCTION
              t09is_empty_window (VAR term : tut_terminal): boolean;
 
        FUNCTION
              t09is_window_full (VAR term : tut_terminal;
                    wanted_lines: integer): boolean;
 
        PROCEDURE
              t09newscreen_page (VAR term : tut_terminal);
 
        FUNCTION
              t09prot_linesize (VAR term : tut_terminal): integer;
 
        PROCEDURE
              t09put (VAR term : tut_terminal;
                    VAR text   : tsp00_Line;
                    text_attr  : char);
 
        PROCEDURE
              t09putmsg (VAR term     : tut_terminal;
                    VAR msg           : tsp00_Line;
                    is_warning        : boolean;
                    immediate_display : boolean);
 
        PROCEDURE
              t09setpf1 (VAR term : tut_terminal; pfkey_label : tsp00_C8);
 
        FUNCTION
              t09window_lines (VAR term : tut_terminal): integer;
 
      ------------------------------ 
 
        FROM
              TA_write_protfile : VTA12;
 
        PROCEDURE
              t12write_prot (VAR fileref : tut_vf_fileref;
                    VAR ln    : tsp00_Line;
                    length    : integer;
                    VAR error : integer);
 
      ------------------------------ 
 
        FROM
              TA_buf_display : VTA14;
 
        PROCEDURE
              t14bufdimension (VAR term : tut_terminal;
                    scan                : tut_diag_scan;
                    VAR bytes_per_line  : integer;
                    VAR line_size       : integer;
                    VAR lines_per_buf   : integer);
 
        PROCEDURE
              t14bufdisplay (VAR term : tut_terminal;
                    VAR protfile      : tut_vf_fileref;
                    scan              : tut_diag_scan;
                    msg               : tsp00_C30;
                    VAR buf           : tsp00_MoveObj;
                    buf_size          : tsp00_Int4;
                    startpos          : tsp00_Int4;
                    endpos            : tsp00_Int4;
                    start_numbering   : tsp00_Int4;
                    VAR break_pos     : tsp00_Int4;
                    VAR pfkey         : tut_pfkey);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        FUNCTION
              s20buf_to_int4 (VAR str : tsp00_MoveObj; si : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              RTE_driver : VEN102;
 
        PROCEDURE
              sqlallocat (
                    length : tsp00_Int4;
                    VAR p  : tsp00_MoveObjPtr;
                    VAR ok : boolean);
 
        PROCEDURE
              sqlfree (
                    p : tsp00_MoveObjPtr);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              g17bd_data_io_state_to_line;
 
              tbd02_DataIOState tsp00_Uint1
 
        PROCEDURE
              t09put;
 
              tsp00_C80 tsp00_Line
 
        PROCEDURE
              sqlallocat;
 
              tsp00_ObjAddr tsp00_MoveObjPtr
 
        PROCEDURE
              sqlfree;
 
              tsp00_BufAddr tsp00_MoveObjPtr
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1987-09-29
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-10-18
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.sp 2
.nf
PROCEDURE X08RESTART_DISPLAY
.sp
Displays contents of restart record if the diagnose switch
'long dump info' is selected. Record components are displayed to-
gether with their selector-names.
.sp2
PROCEDURE X08LOCKLIST_DISPLAY
.sp
Displays contents of a dumped locklist if the diagnose switch
'long dump info' is selected. Record components are displayed to-
gether with their selector-names.
.sp2
PROCEDURE  X08DUMP_DISPLAY
.sp 1
Displays one single dump page. For possibilities:
a) scan_mode = s_header
        only header ('DUMP PAGE ......')is displayed
b) scan_mode = s_dump_labels:
        names of all dump records in this page are displayed
        (no contents)
c) scan_mode = s_long_dumpinfo:
        names and contents of all dump records in this page are
        displayed.
d) scan_mode = s_dump_search:
        only those records are displayed whose label match with some
        initial part a search string given by the user
.sp 2
PROCEDURE DUMP_HEADER
.sp 1
Displays header for restart,config or dump page retrieved from hostfile
Format:
"DUMP PAGE <page_no> .........................<hostfile_line_no>"
.sp 2
PROCEDURE DUMP_RECORD_BD
PROCEDURE DUMP_RECORD_KB
.sp 1
Display one single dump_record (name or contents) of the input
dump page. Every component is prefixed with its symbolic name.
Procedure is called by 'dump_display' as long as there are records
in the dump page not yet displayed.
.br;.cp 4
For outputting formatted data the following primitives are used:
.nf
        put_addr
        put_bool
        put_buffer
        put_char
        put_c4int
        put_header
        put_hex
        put_int
        put_kb3all
        put_kb3extr
        put_kb5info
        put_lockmode
        put_mess
        put_mess2
        put_name
        put_pno
        put_procid
        put_surro
        put_treeid
        put_uint2
.fo
The treatment of line-layout,screen-formatting,screen-holding and
data type conversion are hidden behind these procedures
.sp 2
PROCEDURE PUT_HEADER
.sp 1
Displays name (label) of a dump_record and its position in the
dump page;
First parameter of put_header specifies how much lines are ex-
pected for the record display and performs newscreen if necessary
.sp 2
PROCEDURE PUT_INT
.sp 1
Displays component_name + integer-contents;
output to terminal may be buffered if line is not filled yet;
performs screen-hold if screen is full
.sp 2
PROCEDURE PUT_INT_ARRAY
.sp 1
Displays array-name, followed by a compressed listing of its
integer-valued fields;
performs screen-hold if screen is full
.sp 2
PROCEDURE PUT_CHAR
.sp 1
displays component_name + string-contents
output to terminal may be buffered if line is not filled yet;
performs screen-hold if screen is full
.sp 2
PROCEDURE PUT_BUFFER
.sp 1
displays component_name + contents as an unstructured buffer
output to terminal may be buffered if line is not filled yet;
performs screen-hold if screen is full
.sp 2
PROCEDURE OUTPUT_LINE
.sp 2
Outputs one line to screen;
if screen is full a newscreen-operation is performed first
.sp 2
PROCEDURE CONDITIONAL_NEWSCREEN
.sp 1
if not all lines specified by 'line_limit' fit on screen
a hold is performed (for user acknowledge) and afterwards
a new screen provided
.sp 2
FUNCTION ORD2A
.sp 1
extracts int2-value from 2 bytes in buffer
.sp 2
PROCEDURE PUT_USMRECS
PROCEDURE PUT_USMFOLLOW
PROCEDURE PUT_CBLOCKS
PROCEDURE PUT_CBLFOLLW
PROCEDURE PUT_LRULIST
PROCEDURE PUT_LRUFOLLW
PROCEDURE PUT_B77UNDEF
PROCEDURE PUT_B77HASH
PROCEDURE PUT_B77HASHF
PROCEDURE PUT_B77LOCKL
PROCEDURE PUT_B77FOLLW
PROCEDURE PUT_K55CACHE
PROCEDURE PUT_K51TRANS
.sp
display each a dump-record of the type denoted by the last 8 letters of
the procedure-name
preconditions:
1. display_state.bufpos points to beginning of dump-record-entry
2.display_state.disp_line is empty (terminal-output flushed)
.sp
postconditions:
1. display_state.bufpos points to beginning of next dump_label (if
   existent) or to the end of the buffer (if the procedure
   decides that there are no more dump entries).
2.display_state.disp_line is empty (terminal-output flushed)
.sp 2
FUNCTION xt08equals_dumplabels
.sp
determines if a user-given search string matches an initial of
the dumplabel at the current position in the buffer
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      d_b12svpct         =  140;
      d_b12tdesc         =  142;
      d_b20regio         =  203;
      d_b20bufco         =  205;
      d_b20vars          =  207;
      d_b20hdlis         =  209;
      d_b20hdlfo         =  211;
      d_b20cbloc         =  213;
      d_b20cblfo         =  215;
      d_b20quele         =  217;
      d_b20qufol         =  219;
      d_b20all           =  237;
      d_b22undef         =  240;
      d_b22vars          =  241;
      d_b22hash_desc     =  242;
      d_b22hash_elem     =  243;
      d_b90obj_file_dir  =  250;
      d_b90obj_file_info =  251;
      d_b91vars          =  252;
      d_b91gc_state      =  253;
      d_b93cont_obj_file_dir = 254;
      d_b930HistDir      =  256;
      d_g01vars          = 1001;
      d_g01glob          = 1002;
      d_g01pid           = 1006;
      d_g01tabid         = 1007;
      d_g01vtrce         = 1008;
      d_g02tabs          = 1051;
      d_g02cset          = 1052;
      d_k38undef         = 1149;
      d_k38glob          = 1150;
      d_k38task          = 1151;
      d_k38tape          = 1152;
      d_k38devsp         = 1153;
      d_k38queue         = 1154;
      d_autoundef        = 1159;
      d_autoglob         = 1160;
      d_autotask         = 1161;
      d_autotape         = 1162;
      d_autodevsp        = 1163;
      d_autoqueue        = 1164;
      d_k51undef         = 1200;
      d_k51glob          = 1201;
      d_k51lock          = 1202;
      d_k51trans         = 1203;
      d_k51entry         = 1204;
      d_k51tabtr         = 1205;
      d_k51rowtr         = 1206;
      d_k51tab           = 1207;
      d_k51row           = 1208;
      d_k51rowid         = 1209;
      d_k51req           = 1210;
      d_k51hash          = 1211;
      d_k51hstab         = 1212;
      d_k51hsrow         = 1213;
      d_k51cnsis         = 1214;
      d_k51opent         = 1215;
      d_k51hopnt         = 1216;
      d_k51ocoll         = 1217;
      d_k51reqtr         = 1218;
      d_k51shrlckcntrl   = 1219; (* PTS 1128244 *)
      d_k51shrlock       = 1220; (* PTS 1128244 *)
      d_k57undef         = 1500;
      d_k57vars          = 1501;
      d_k90undef         = 1600;
      d_k90glob          = 1601;
      d_k90cache         = 1602;
      d_k90mdesc         = 1603;
      d_k90mbody         = 1605;
      d_k90parent        = 1606;
      d_k90serv          = 1608;
      d_a10cache         = 1801;
      d_a10error         = 1802;
      d_SQLTempFileColl  = 1810;
      d_allocator        = 1900;
      (* *)
      d_ConvManager      = 2001;
      d_ConvMapSection   = 2003;
      d_ConvMapEntry     = 2004;
      d_ConvIndex        = 2005;
      d_FBMManager       = 2010;
      d_FBMDataDevice    = 2011;
      d_PagerController  = 2020;
      d_FileDirectory    = 2030;
      (* *)
      (* copy of Data_FileType: *)
      d_FTUnknown        = 0;
      d_UndoFile         = 1;
      d_RedoFile         = 2;
      d_HistoryFile      = 3;
      d_HistoryDirectory = 4;
      d_OpenTransFile    = 5;
      d_TableFile        = 6;
      d_IndexFile        = 7;
      d_OmsFile          = 8;
      d_OmsFixedFile     = 9;
      d_OmsKeyFile       = 10;
      d_OmsKeyPartitionFile = 11;
      d_OmsVarFile       = 12;
      d_ShortColumnFile  = 14;
      (* *)
      mx_pos_displ       =   5;
      of_col_type        =   6;
      of_first_col       =  11;
      of_second_col      =  43;
      dump_page_header   = 'DUMP PAGE   ';
      a10cache_label     = 'A10CACHE          ';
      a10error_label     = 'A10ERROR          ';
      allocator_label    = 'ALLOCATOR         ';
      (* *)
      c_bool_indicator   = 'b';
      c_int_indicator    = 'i';
      c_mtype_indicator  = 'm';
      c_mtype2_indicator = 'n';
      c_set_indicator    = 's';
      (* *)
      c_immediate_displ  = true;
      c_pad_with_zero    = true;
      c_trim             = true;
      c_warning          = true;
      c_with_zero        = true;
      (* *)
      COMMIT_ENTRY_SIZE_WITH_TIMESTAMP = 32;
      c_trunc_key_length = 20;
 
TYPE
      t_term_addr = ^tut_terminal;
      t_prot_addr = ^tut_vf_fileref;
      t_any_set = (
            set_bd_fdesc,
            set_bd_fstate,
            set_bd_use,
            set_filetype,
            set_handling,
            set_lock_state,
            set_pagemode,
            set_trans_state,
            set_efiletype);
 
      display_state_type = RECORD  (* state information about display *)
            term       : t_term_addr;
            prot       : t_prot_addr;
            buf        : tsp00_MoveObjPtr;
            pfkey      : tut_pfkey;
            vt_attr    : char;
            scan       : tut_diag_scan; (* output handling            *)
            bufsize    : tsp00_Int4;
            bufoffset  : tsp00_Int4;
            bufpos     : tsp00_Int4;    (* current position in page   *)
            cur_column : integer;       (* current column; values 1,2 *)
            line_len   : integer;
            line_size  : integer;       (* max length of window line  *)
            file_pos   : tut_file_pos;  (* block/page no of input file*)
            disp_line  : tsp00_Line;    (* current display-line       *)
      END;
 
 
 
(*------------------------------*) 
 
PROCEDURE
      x08dumpdisplay (VAR term : tut_terminal;
            VAR f        : tut_file;
            VAR prot     : tut_vf_fileref;
            scan         : tut_diag_scan;
            VAR file_pos : tut_file_pos;
            search_label : tsp00_Name;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4;
            VAR pfkey    : tut_pfkey;
            VAR found    : boolean);
      (* *)
      (*search_label: initial of dump label to search for             *)
      (*found       : out-variable, indicating if dump-type was found *)
 
VAR
      is_hex   : boolean;
      dumptype : integer; (*index of dump record defining its contents*)
      d        : display_state_type;
 
BEGIN
d.cur_column := 1;           (* all parameters are copied *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := 0;
d.bufpos     := sizeof(tgg00_PageHeader) + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.scan       := scan;
d.file_pos   := file_pos;
d.line_size  := t09prot_linesize (term);
IF  utds_dump_label in scan
THEN
    xt08dump_header (d, dump_page_header, term.blankline, 0);
(* displays constant part of every Dump-Page *)
(*ENDIF*) 
IF  (utds_dump_label  in scan) OR
    (utds_full_info   in scan) OR
    (search_label <> bsp_name)
THEN
    BEGIN
    IF  (d.bufpos > 0) AND (d.bufpos + 7 <= d.bufsize)
    THEN
        is_hex := x05ishex (d.buf^, d.bufsize, d.bufpos, 8)
    ELSE
        is_hex := true;
    (*ENDIF*) 
    IF  search_label = allocator_label
    THEN
        BEGIN
        dumptype := d_allocator;
        xt08dump_allocator (d, f, dumptype)
        END
    ELSE
        WHILE (d.bufpos + sizeof (tsp00_C8) + 2 < d.bufsize)
              AND NOT is_hex
              AND (d.pfkey = pf_none) DO
            BEGIN
            dumptype := -1;
            IF  search_label = a10error_label
            THEN
                BEGIN
                dumptype     := d_a10error;
                search_label := a10cache_label;
                END;
            (*ENDIF*) 
            IF  (search_label <> bsp_name)
                AND
                xt08equals_dumplabels (d, search_label)
            THEN
                BEGIN
                t09putmsg (d.term^, d.term^.blankline,
                      NOT c_warning, NOT c_immediate_displ);
                found  := true;
                d.scan := d.scan + [utds_full_info];
                (* '+ full_info' to display contents in 'dump_record' *)
                END;
            (* extracts index of dumprecord from buffer *)
            (*ENDIF*) 
            IF  dumptype = -1
            THEN
                dumptype := xt08ord2a (d.buf^, d.bufpos + 8);
            (*ENDIF*) 
            IF  dumptype < 1000
            THEN
                xt08dump_bd_record (d, dumptype)
            ELSE
                IF  dumptype < 1050
                THEN
                    xt08dump_g01 (d, dumptype)
                ELSE
                    IF  dumptype < 1100
                    THEN
                        xt08dump_g02 (d, dumptype)
                    ELSE
                        IF  dumptype < 1500
                        THEN
                            xt08dump1_kb_record (d, dumptype)
                        ELSE
                            IF  dumptype < 1700
                            THEN
                                xt08dump2_kb_record (d, dumptype)
                            ELSE
                                IF  dumptype < 2000
                                THEN
                                    xt08dump_ak_record (d, f, dumptype)
                                ELSE
                                    xt08_DumpDataAccess( d, dumptype );
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            (* display one single record of dump information          *)
            (* One procedure together for BD and KB would be too      *)
            (* large for compiler!!                                   *)
            IF  (d.bufpos > 0) AND (d.bufpos + 7 <= d.bufsize)
            THEN
                is_hex := x05ishex (d.buf^, d.bufsize, d.bufpos, 8)
            ELSE
                is_hex := true;
            (*ENDIF*) 
            END
        (*ENDWHILE*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08fdir_rec_edit (VAR term : tut_terminal;
            VAR prot   : tut_vf_fileref;
            VAR buf    : tsp00_MoveObj;
            buf_size   : tsp00_Int4;
            buf_offset : tsp00_Int4;
            is_edit    : boolean;
            VAR pfkey  : tut_pfkey);
 
VAR
      is_ln3 : boolean;
      reclen : tsp00_IntMapC2;
      ln2    : tsp00_Line;
      ln3    : tsp00_Line;
      fn     : tgg00_Filename;
      d      : display_state_type;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := buf_offset;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.scan       := [utds_page_header, utds_full_info, utds_display];
d.line_size  := t09prot_linesize (term);
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
reclen.mapC2_sp00 [1] := buf [buf_offset+1];
reclen.mapC2_sp00 [2] := buf [buf_offset+2];
IF  d.bufsize - d.bufoffset < STD_FDIRENTRY_MXBD00
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('FDIR ENTRY TOO    ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (d.bufsize - d.bufoffset,
          d.line_len, d.disp_line);
    xt08output_line (d)
    END
ELSE
    BEGIN
    xt08put_int     (d, 'entry_len   ', 2);
    xt08put_int     (d, 'fn_length   ', 2);
    xt08skip_filler (d, 4);
    IF  is_edit
    THEN
        d.scan := d.scan + [utds_edit]; (* do not change: rec/key_len*)
    (*ENDIF*) 
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    xt08blank_line (d);
    SAPDB_PascalForcedMove (d.bufsize, sizeof (fn),
          @d.buf^, d.bufpos, @fn, 1, sizeof (fn));
    d.bufpos := d.bufpos + sizeof (fn);
    g17filename ('filename    ', fn, 0, d.disp_line, ln2, ln3, is_ln3);
    xt08output_line (d);
    d.disp_line := ln2;
    xt08output_line (d);
    IF  is_ln3
    THEN
        BEGIN
        d.disp_line := ln3;
        xt08output_line (d)
        END;
    (*ENDIF*) 
    xt08blank_line  (d);
    xt08put_any_set (d, 'fi_type     ', set_filetype);
    xt08put_any_set (d, 'fi_state    ', set_bd_fstate);
    xt08skip_filler (d,1);
    xt08put_any_set (d, 'fi_desc     ', set_bd_fdesc);
    xt08put_int     (d, 'fi_root     ', 4);
    xt08put_fvers   (d, 'fi_vers     '   );
    xt08put_int     (d, 'fi_col_cnt  ', 2);
    IF  reclen.mapInt_sp00 >= sizeof (tbd00_FDirEntry)
    THEN
        BEGIN
        xt08put_pageref (d, 'fi_user_ref '   );
        xt08put_int     (d, 'fi_var_col_c', 2)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08hostinfo_display (VAR term : tut_terminal;
            VAR prot     : tut_vf_fileref;
            scan         : tut_diag_scan;
            VAR file_pos : tut_file_pos;
            page_name    : tsp00_Sname;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4;
            VAR pfkey    : tut_pfkey);
 
CONST
      c_mess_pos = 7;
 
VAR
      d          : display_state_type;
      msg_ln_len : integer;
      msg_ln     : tsp00_Line;
 
      mess_type : RECORD
            CASE integer OF
                1:
                    (c : tsp00_C2);
                2:
                    (m : tgg00_MessType;
                    m2 : tgg00_MessType2)
                END;
            (*ENDCASE*) 
 
 
BEGIN
d.cur_column    := 1;       (* copy all parameters to parameter block *)
d.term          := @term;
d.prot          := @prot;
d.buf           := @buf;
d.bufsize       := buf_size;
d.bufoffset     := 0;
d.bufpos        := 1;
d.pfkey         := pfkey;
d.vt_attr       := cut_protected;
d.scan          := scan;
d.file_pos      := file_pos;
d.line_size     := t09prot_linesize (term);
mess_type.c [1] := buf [c_mess_pos  ];
mess_type.c [2] := buf [c_mess_pos+1];
msg_ln          := d.term^.blankline;
msg_ln_len      := 0;
g17messtype_to_line (mess_type.m, msg_ln_len, msg_ln);
IF  mess_type.m2 <> mm_nil
THEN
    BEGIN
    msg_ln_len := msg_ln_len + 1;
    g17mess2type_to_line (mess_type.m2, msg_ln_len, msg_ln)
    END;
(*ENDIF*) 
xt08dump_header (d, page_name, msg_ln, msg_ln_len);
(* display header *)
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08put_pagehead  (d, 'hostinfo'       );
    (* *)
    xt08put_mess      (d, 'h_mess_type '   );
    xt08put_mess2     (d, 'h_mess2_type'   );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (* beginning of trailer *)
    (*ENDIF*) 
    d.bufpos  := d.bufsize - PAGE_CHECK_TRAILER_MXGG00 + 1;
    xt08put_int       (d, 'checksum    ', 4);
    xt08put_pagehead  (d, 'hostinf2'       );
    (* *)
    xt08put_mess      (d, 't_mess_type '   );
    xt08put_mess2     (d, 't_mess2_type'   );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    d.bufpos := PAGE_HEADER_MXGG00
          + sizeof (tgg00_MessType)
          + sizeof (tgg00_MessType2) + 1;
    xt08put_hostinfo (d);
    xt08new_line     (d)
    END;
(*ENDIF*) 
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_Savepoint (VAR term : tut_terminal;
            VAR prot   : tut_vf_fileref;
            scan       : tut_diag_scan;
            VAR buf    : tsp00_MoveObj;
            buf_size   : tsp00_Int4;
            buf_offset : tsp00_Int4;
            VAR pfkey  : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            reason         : tsp00_Uint1;
            additionalInfo : tsp00_Uint1;
            filler2        : tsp00_Int2;
      END;
 
 
VAR
      d            : display_state_type;
      pAction      : ^t_action;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := buf_offset;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
pAction := @(buf[d.bufpos]);
IF  d.bufsize - d.bufoffset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (d.bufsize - d.bufoffset,
          d.line_len, d.disp_line);
    END
ELSE
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('Reason:           ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    gg06LogSavepointReasonToLine (pAction^.reason, d.line_len, d.disp_line);
    xt08output_line (d);
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_int     (d, 'Reason      ', 1);
        xt08put_int     (d, 'ExtraData   ', 1);
        xt08skip_filler (d, 2);
        IF  pAction^.additionalInfo <> 0
        THEN
            BEGIN
            xt08put_char     (d, 'ReleaseVers ', sizeof (tsp00_Version));
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_Commit (VAR term : tut_terminal;
            VAR prot   : tut_vf_fileref;
            scan       : tut_diag_scan;
            VAR buf    : tsp00_MoveObj;
            buf_size   : tsp00_Int4;
            buf_offset : tsp00_Int4;
            VAR pfkey  : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            commitDate : tsp00_Uint4;
            commitTime : tsp00_Uint4;
      END;
 
 
VAR
      d            : display_state_type;
      pAction      : ^t_action;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := buf_offset;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
pAction := @(buf[d.bufpos]);
IF  d.bufsize - d.bufoffset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('COMMITENTRY TOO   ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (d.bufsize - d.bufoffset,
          d.line_len, d.disp_line);
    END
ELSE
    IF  (d.bufsize - d.bufoffset <> 0)
    THEN
        BEGIN
        d.disp_line := d.term^.blankline;
        d.line_len  := 0;
        xt08put_int     (d, 'Date        ', 4);
        xt08put_int     (d, 'Time        ', 4);
        xt08new_line  (d); (* flush last line *)
        END;
    (*ENDIF*) 
(*ENDIF*) 
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_PartialRollback (VAR term : tut_terminal;
            VAR prot   : tut_vf_fileref;
            scan       : tut_diag_scan;
            VAR buf    : tsp00_MoveObj;
            buf_size   : tsp00_Int4;
            buf_offset : tsp00_Int4;
            VAR pfkey  : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            undostopsequence : tsp00_Int4;
            redostopsequence : tsp00_Int4;
      END;
 
 
VAR
      d            : display_state_type;
      pAction      : ^t_action;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := buf_offset;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
pAction := @(buf[d.bufpos]);
IF  d.bufsize - d.bufoffset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (d.bufsize - d.bufoffset,
          d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    (* *)
    xt08put_int     (d, 'UndoStopSeq ', 4);
    xt08put_int     (d, 'RedoStopSeq ', 4);
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_ObjectFile (VAR term : tut_terminal;
            VAR prot   : tut_vf_fileref;
            scan       : tut_diag_scan;
            VAR buf    : tsp00_MoveObj;
            buf_size   : tsp00_Int4;
            buf_offset : tsp00_Int4;
            VAR pfkey  : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            fileno                : tsp00_C8;
            rootPage              : tsp00_PageNo; (* for now only one *)
            bodyLength            : tsp00_Uint2;
            keyLength             : tsp00_Uint2;
            filetype              : tsp00_Uint1;
            filler1               : tsp00_Uint1;
            secFileNoListLength   : tsp00_Uint2;
            filler2               : tsp00_Int4;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := buf_offset;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
pAction := @(buf[d.bufpos]);
IF  d.bufsize - d.bufoffset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (d.bufsize - d.bufoffset,
          d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        d.disp_line := d.term^.blankline;
        d.line_len  := 0;
        (* *)
        xt08put_hex     (d, 'ObjFileNo   ', 8);
        xt08put_pno     (d, 'Root        '   );
        xt08put_uint2   (d, 'BodySize    '   );
        xt08put_uint2   (d, 'KeySize     '   );
        xt08put_hex     (d, 'FileType    ', 1);
        xt08skip_filler (d, 1);
        xt08put_uint2   (d, 'FileNoLstLg '   );
        xt08skip_filler (d, 2);
        END;
    (*ENDIF*) 
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_Object (VAR term : tut_terminal;
            VAR prot   : tut_vf_fileref;
            scan       : tut_diag_scan;
            VAR buf    : tsp00_MoveObj;
            buf_size   : tsp00_Int4;
            buf_offset : tsp00_Int4;
            VAR pfkey  : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            oid              : tgg00_OidSpace;
            fileno           : tsp00_C8;
            bodySize         : tsp00_Uint2;
            keySize          : tsp00_Uint2;
            objversion       : tgg91_PageRef;
            flags            : tsp00_Uint1;
            filler1          : tsp00_Uint1;
            filler2          : tsp00_Int4;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := buf_offset;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
pAction := @(buf[d.bufpos]);
IF  d.bufsize - d.bufoffset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (d.bufsize - d.bufoffset,
          d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        d.disp_line := d.term^.blankline;
        d.line_len  := 0;
        (* *)
        xt08put_oid     (d, 'Oid         '   );
        xt08put_hex     (d, 'ObjFileNo   ', 8);
        xt08put_uint2   (d, 'BodySize    '   );
        xt08put_uint2   (d, 'KeySize     '   );
        xt08put_pageref (d, 'PrevImageRef'   );
        xt08put_hex     (d, 'ActionFlags ', 1);   (* PTS 1127661 FF *)
        xt08skip_filler (d, 1);
        xt08skip_filler (d, 4);
        d.disp_line := d.term^.blankline;
        d.line_len  := 0;
        IF  utds_logentry_buf in scan
        THEN
            BEGIN
            IF  pAction^.keySize > 0
            THEN
                BEGIN
                d.disp_line := d.term^.blankline;
                d.line_len  := 0;
                xt08output_line (d);
                g17nameto_line ('OBJECT KEY:       ', d.line_len, d.disp_line);
                xt08output_line (d);
                xt08put_buffer (d, 'key         ', pAction^.keySize);
                END;
            (*ENDIF*) 
            IF  pAction^.bodySize > 0
            THEN
                BEGIN
                d.disp_line := d.term^.blankline;
                d.line_len  := 0;
                xt08output_line (d);
                g17nameto_line ('OBJECT BODY:      ', d.line_len, d.disp_line);
                xt08output_line (d);
                xt08put_buffer (d, 'body        ', pAction^.bodySize);
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_MultipleActions (VAR term : tut_terminal;
            VAR prot   : tut_vf_fileref;
            scan       : tut_diag_scan;
            VAR buf    : tsp00_MoveObj;
            buf_size   : tsp00_Int4;
            buf_offset : tsp00_Int4;
            VAR pfkey  : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            actionCount          : tsp00_Uint4;
            totalLengthOfActions : tsp00_Uint4;
      END;
 
 
      t_actionhead = RECORD
            length        : tsp00_Uint4;
            actionType    : tsp00_Uint1; (*Log_ActionType*)
            actionVersion : tsp00_Uint1;
            filler2       : tsp00_Uint2;
            redosequence  : tsp00_Uint4;
            undosequence  : tsp00_Uint4;
      END;
 
 
VAR
      d           : display_state_type;
      pAction     : ^t_action;
      pActionHead : ^t_actionhead;
      sumLength   : tsp00_Int4;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := buf_offset;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
pAction := @(buf[d.bufpos]);
IF  d.bufsize - d.bufoffset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (d.bufsize - d.bufoffset,
          d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    (* *)
    xt08put_int     (d, '# actions   ', 4);
    xt08put_int     (d, 'totLenOfAct ', 4);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    sumLength   := 0;
    WHILE  (d.bufsize - d.bufoffset >= sizeof(t_actionhead))
          AND
          (sumLength < pAction^.totalLengthOfActions)
          AND
          (sumLength < d.bufsize) DO
        BEGIN
        pActionHead := @(buf[d.bufpos]);
        d.disp_line := d.term^.blankline;
        d.line_len  := 0;
        sumLength   := sumLength + pActionHead^.length;
        xt08output_line (d);
        g17nameto_line ('INTERNAL ACTION:  ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 2;
        gg06LogActionToLine (pActionHead^.actionType, d.line_len, d.disp_line);
        d.disp_line[d.line_len] := '/';
        g17trimint4_to_line (pActionHead^.actionVersion, d.line_len, d.disp_line);
        xt08output_line (d);
        xt08put_int     (d, 'Act.Length  ', 4);
        xt08put_int     (d, 'Act.Type    ', 1);
        xt08put_int     (d, 'Act.Version ', 1);
        xt08skip_filler (d, 2);
        xt08put_int     (d, 'Act.redoSeq ', 4);
        xt08put_int     (d, 'Act.undoSeq ', 4);
        d.bufoffset := d.bufpos - 1;
        x08edit_display_action (term, prot, scan, buf, d.bufsize, d.bufoffset, pfkey,
              pActionHead^.length, pActionHead^.actionType, true);
        d.bufoffset := d.bufoffset + pActionHead^.length - sizeof(t_actionhead);
        d.bufpos    := d.bufoffset + 1;
        END;
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
FUNCTION
      xt08aligned (val : tsp00_Int4): tsp00_Int4;
 
CONST
      ALIGN = 8;
 
BEGIN
xt08aligned := ((val + ALIGN-1) DIV ALIGN) * ALIGN
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_UpdateRecord (VAR term : tut_terminal;
            VAR prot   : tut_vf_fileref;
            scan       : tut_diag_scan;
            VAR buf    : tsp00_MoveObj;
            buf_size   : tsp00_Int4;
            buf_offset : tsp00_Int4;
            VAR pfkey  : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            imagelen   : tsp00_Uint4;
            keylen     : tsp00_Uint2;
            newreclen  : tsp00_Uint2;
            colmaplen  : tsp00_Uint4;
            invdesclen : tsp00_Uint4;
            filename   : tgg00_Filename;
      END;
 
 
VAR
      d         : display_state_type;
      pAction   : ^t_action;
      fileid    : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    fileid.fileName_gg00 := pAction^.filename;
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  NOT (utds_logentry_full_info in scan)
    THEN
        BEGIN
        g17nameto_line ('tabid:            ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        xt08output_line (d);
        d.disp_line := d.term^.blankline;
        d.line_len  := 0;
        d.bufpos    := buf_offset + 1 + sizeof(t_action) + cgg_rec_key_offset;
        IF  pAction^.keylen-cgg_rec_key_offset > c_trunc_key_length
        THEN
            xt08put_hex (d, 'key (trunc) ', c_trunc_key_length)
        ELSE
            xt08put_hex (d, 'key         ', pAction^.keylen-cgg_rec_key_offset);
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        xt08put_int      (d, 'imagelen    ', 4);
        xt08put_uint2    (d, 'keylen      '   );
        xt08put_uint2    (d, 'newreclen   '   );
        xt08put_int      (d, 'colmaplen   ', 4);
        xt08put_int      (d, 'invdesclen  ', 4);
        xt08put_filename (d, 'filename    '   );
        xt08skip_filler  (d, cgg_rec_key_offset); (*tgg00_LKey header*)
        IF  d.bufpos + pAction^.keylen - cgg_rec_key_offset > buf_size
        THEN
            BEGIN
            d.disp_line := d.term^.blankline;
            d.line_len  := 0;
            g17nameto_line ('ENTRY IS CORRUPT  ', d.line_len, d.disp_line);
            xt08output_line (d);
            END
        ELSE
            IF  utds_logentry_buf in scan
            THEN
                xt08put_buffer  (d, 'KEY         ', pAction^.keylen-cgg_rec_key_offset)
            ELSE
                xt08put_hex (d, 'KEY         ', pAction^.keylen-cgg_rec_key_offset);
            (*ENDIF*) 
        (*ENDIF*) 
        IF  pAction^.colmaplen > 0
        THEN
            xt08edit_display_ColumnMap (term, prot, scan, buf, buf_size,
                  buf_offset + sizeof(t_action) + xt08aligned (pAction^.keylen),
                  pAction^.colmaplen, pfkey)
        ELSE
            xt08output_line (d);
        (*ENDIF*) 
        IF  pAction^.invdesclen > 0
        THEN
            xt08edit_display_InvDescMap (term, prot, scan, buf, buf_size,
                  buf_offset + pAction^.imagelen - pAction^.invdesclen,
                  pAction^.invdesclen, pfkey);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_InsDelRecord (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey;
            containsRecord : boolean);
 
TYPE
 
      t_action = RECORD
            imagelen    : tsp00_Uint4;
            keyOrRecLen : tsp00_Uint4;
            invdesclen  : tsp00_Uint4;
            filename    : tgg00_Filename;
      END;
 
 
VAR
      d            : display_state_type;
      pAction      : ^t_action;
      fileid       : tgg00_FileId;
      sname        : tsp00_Sname;
      pRecKey      : ^tgg00_Rec;
      recKeyLength : tsp00_Int4;
      recKeyOffset : tsp00_Int4;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction              := @(buf[d.bufpos]);
    fileid.fileName_gg00 := pAction^.filename;
    recKeyOffset         := buf_offset + xt08aligned(sizeof(t_action));
    pRecKey              := @(buf[recKeyOffset+1]);
    IF  containsRecord
        AND
        (utds_logentry_full_info in scan)
    THEN
        BEGIN
        sname        := 'rec         ';
        recKeyLength := pRecKey^.recLen_gg00;
        END
    ELSE
        BEGIN
        sname        := 'key         ';
        recKeyLength := pRecKey^.recKeyLen_gg00;
        recKeyOffset := recKeyOffset + cgg_rec_key_offset;
        END;
    (*ENDIF*) 
    IF  d.bufpos + recKeyLength > d.bufsize
    THEN
        recKeyLength := d.bufsize - d.bufpos;
    (*ENDIF*) 
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_int      (d, 'imagelen    ', 4);
        xt08put_int      (d, 'reclen      ', 4);
        xt08put_int      (d, 'invdesclen  ', 4);
        xt08put_filename (d, 'filename    '   );
        d.bufpos := recKeyOffset + 1;
        IF  utds_logentry_buf in scan
        THEN
            xt08put_buffer  (d, sname, recKeyLength)
        ELSE
            xt08put_hex (d, sname, recKeyLength);
        (*ENDIF*) 
        IF  pAction^.invdesclen > 0
        THEN
            xt08edit_display_InvDescMap (term, prot, scan, buf, buf_size,
                  buf_offset + pAction^.imagelen - pAction^.invdesclen + 1,
                  pAction^.invdesclen, pfkey);
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        g17nameto_line ('tabid:            ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        xt08output_line (d);
        d.disp_line := d.term^.blankline;
        d.line_len  := 0;
        d.bufpos    := recKeyOffset + 1;
        d.line_len  := d.line_len + 1;
        IF  recKeyLength > c_trunc_key_length
        THEN
            xt08put_hex (d, 'key (trunc) ', c_trunc_key_length)
        ELSE
            xt08put_hex (d, sname, recKeyLength);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_ModifyTable (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            imagelen     : tsp00_Uint4;
            invdesclen   : tsp00_Uint4;
            srcfilename  : tgg00_Filename;
            dstfilename  : tgg00_Filename;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
      fileid  : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_int      (d, 'imagelen    ', 4);
        xt08put_int      (d, 'invdesclen  ', 4);
        xt08put_filename (d, 'src filename'   );
        xt08put_filename (d, 'dst filename'   );
        IF  pAction^.invdesclen > 0
        THEN
            BEGIN
            xt08edit_display_InvDescMap (term, prot, scan, buf, buf_size,
                  buf_offset + sizeof(t_action) + 1,
                  pAction^.invdesclen, pfkey);
            xt08edit_display_InvDescMap (term, prot, scan, buf, buf_size,
                  buf_offset + sizeof(t_action) + pAction^.invdesclen + 1,
                  pAction^.imagelen - sizeof(t_action) - pAction^.invdesclen, pfkey);
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        fileid.fileName_gg00 := pAction^.srcfilename;
        g17nameto_line ('src tabid:        ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.dstfilename;
        g17nameto_line ('dst tabid:        ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_ChangeFileType (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            filename       : tgg00_Filename;
            oldfiletypeset : tgg00_FiletypeSet;
            newfiletypeset : tgg00_FiletypeSet;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
      fileid  : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_filename (d, 'filename    '   );
        xt08put_any_set  (d, 'old ftype   ', set_filetype);
        xt08put_any_set  (d, 'new ftype   ', set_filetype);
        END
    ELSE
        BEGIN
        fileid.fileName_gg00 := pAction^.filename;
        g17nameto_line ('tabid:            ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_CreateFile (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            filename    : tgg00_Filename;
            fileversion : tgg91_FileVersion;
            filetypeset : tgg00_FiletypeSet;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
      fileid  : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_filename (d, 'filename    '              );
        xt08put_any_set  (d, 'filetypeset ', set_filetype);
        xt08put_fvers    (d, 'fileversion '              );
        END
    ELSE
        BEGIN
        fileid.fileName_gg00 := pAction^.filename;
        g17nameto_line ('tabid:            ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_CreateIndex (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            tabfilename : tgg00_Filename;
            invfilename : tgg00_Filename;
            invdesclen  : tsp00_Uint2;
            primtfn     : tgg00_Tfn;
            primtfnno   : tsp00_Uint1;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
      fileid  : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_filename (d, 'tab filename'   );
        xt08put_filename (d, 'inv filename'   );
        xt08put_uint2    (d, 'invdesclen  '   );
        xt08put_tfntype  (d, 'prim tfn    '   );
        xt08put_int      (d, 'prim tfn no ', 1);
        IF  pAction^.invdesclen > 0
        THEN
            xt08edit_display_InvDescMap (term, prot, scan,
                  buf, buf_size, buf_offset + sizeof(t_action) + 1,
                  pAction^.invdesclen, pfkey);
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        g17nameto_line ('inv id:           ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.invfilename;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('tab id:           ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.tabfilename;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        g17nameto_line ('prim tfn:         ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17tfntype_to_line (pAction^.primtfn,  d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('prim tfn no:      ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17trimint4_to_line (pAction^.primtfnno, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_CreateTable (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            filename    : tgg00_Filename;
            fileversion : tgg91_FileVersion;
            filetypeset : tgg00_FiletypeSet;
            notreeindex : boolean;
            strcolcnt   : tsp00_Int2;
            varcolcnt   : tsp00_Int2;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
      fileid  : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_filename (d, 'filename    '              );
        xt08put_any_set  (d, 'filetypeset ', set_filetype);
        xt08put_fvers    (d, 'fileversion '              );
        xt08put_bool     (d, 'notreeindex '              );
        xt08put_int      (d, 'strcolcnt   ', 2           );
        xt08put_int      (d, 'varcolcnt   ', 2           );
        END
    ELSE
        BEGIN
        fileid.fileName_gg00 := pAction^.filename;
        g17nameto_line ('tabid:            ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_RenameFile (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            oldfilename    : tgg00_Filename;
            newfilename    : tgg00_Filename;
            newfileversion : tgg91_FileVersion;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
      fileid  : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_filename (d, 'old filename'              );
        xt08put_filename (d, 'new filename'              );
        xt08put_fvers    (d, 'new filevers'              );
        END
    ELSE
        BEGIN
        g17nameto_line ('old tabid:        ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.oldfilename;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('new tabid:        ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.newfilename;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('new file vers:    ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        gg06FileVersToLine (pAction^.newfileversion, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_SuccFileVersion (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            filename       : tgg00_Filename;
            newlongcnt     : tsp00_Int4;
            newfileversion : tgg91_FileVersion;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
      fileid  : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_filename (d, 'filename    '              );
        xt08put_fvers    (d, 'new filevers'              );
        xt08put_int      (d, 'new long cnt', 4           );
        END
    ELSE
        BEGIN
        g17nameto_line ('tabid:            ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.filename;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('new long cnt:     ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17trimint4_to_line (pAction^.newlongcnt, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('new file vers:    ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        gg06FileVersToLine (pAction^.newfileversion, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_UpdFileStatistic (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            filename  : tgg00_Filename;
            leafnodes : tsp00_Int4;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
      fileid  : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_filename (d, 'filename    '              );
        xt08put_int      (d, 'leaf nodes  ', 4           );
        END
    ELSE
        BEGIN
        g17nameto_line ('tabid:            ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.filename;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('leaf nodes        ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17trimint4_to_line (pAction^.leafnodes, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_CopyBlob (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            tableid            : tgg00_Surrogate;
            srcfilename        : tgg00_Filename;
            dstfilename        : tgg00_Filename;
            dstversion         : tsp00_Int4;
            copylength         : tsp00_Int4;
            srcoffset          : tsp00_Int4;
            dstoffset          : tsp00_Int4;
            newtruncateddstlen : tsp00_Int4;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
      fileid  : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_surro    (d, 'tableid     '   );
        xt08put_filename (d, 'srcfilename '   );
        xt08put_filename (d, 'dstfilename '   );
        xt08put_int      (d, 'dstversion  ', 4);
        xt08put_int      (d, 'copylength  ', 4);
        xt08put_int      (d, 'srcoffset   ', 4);
        xt08put_int      (d, 'dstoffset   ', 4);
        xt08put_int      (d, 'newtruncate ', 4);
        END
    ELSE
        BEGIN
        g17nameto_line ('src id:           ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.srcfilename;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('dst id:           ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.dstfilename;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_CopySameBlob (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            tableid         : tgg00_Surrogate;
            blobname        : tgg00_Filename;
            auxblobfilename : tgg00_Filename;
            newblobversion  : tsp00_Int4;
            copylength      : tsp00_Uint4;
            srcoffset       : tsp00_Uint4;
            dstoffset       : tsp00_Uint4;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
      fileid  : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_surro    (d, 'tableid     '   );
        xt08put_filename (d, 'blobname    '   );
        xt08put_filename (d, 'auxblobname '   );
        xt08put_int      (d, 'newblobvers ', 4);
        xt08put_int      (d, 'copylength  ', 4);
        xt08put_int      (d, 'srcoffset   ', 4);
        xt08put_int      (d, 'dstoffset   ', 4);
        END
    ELSE
        BEGIN
        g17nameto_line ('blob id:          ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.blobname;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('aux blob id:      ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.auxblobfilename;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('new blobvers:     ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17trimint4_to_line (pAction^.newblobversion, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_ExpandBlob (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            tableid         : tgg00_Surrogate;
            blobname        : tgg00_Filename;
            auxblobfilename : tgg00_Filename;
            newblobversion  : tsp00_Int4;
            copylength      : tsp00_Uint4;
            srcoffset       : tsp00_Uint4;
            dstoffset       : tsp00_Uint4;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
      fileid  : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_surro    (d, 'tableid     '   );
        xt08put_filename (d, 'blobname    '   );
        xt08put_filename (d, 'auxblobname '   );
        xt08put_int      (d, 'newblobvers ', 4);
        xt08put_int      (d, 'copylength  ', 4);
        xt08put_int      (d, 'srcoffset   ', 4);
        xt08put_int      (d, 'dstoffset   ', 4);
        END
    ELSE
        BEGIN
        g17nameto_line ('blob id:          ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.blobname;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('aux blob id:      ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.auxblobfilename;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('new blobvers:     ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17trimint4_to_line (pAction^.newblobversion, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_TruncateBlob (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            tableid         : tgg00_Surrogate;
            blobname        : tgg00_Filename;
            blobversion     : tsp00_Int4;
            newtruncbloblen : tsp00_Uint4;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
      fileid  : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_surro    (d, 'tableid     '   );
        xt08put_filename (d, 'blobname    '   );
        xt08put_int      (d, 'blobversion ', 4);
        xt08put_int      (d, 'newtrunclen ', 4);
        END
    ELSE
        BEGIN
        g17nameto_line ('blob id:          ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.blobname;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('blobversion:      ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17trimint4_to_line (pAction^.blobversion, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('new trunc len:    ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17trimint4_to_line (pAction^.newtruncbloblen, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_UpdateBlob (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            imagelength  : tsp00_Uint4;
            buflength    : tsp00_Uint4;
            insertoffset : tsp00_Uint4;
            blobname     : tgg00_Filename;
            tableid      : tgg00_Surrogate;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
      fileid  : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_int      (d, 'imagelength ', 4);
        xt08put_int      (d, 'buflength   ', 4);
        xt08put_int      (d, 'insertoffset', 4);
        xt08put_filename (d, 'blobname    '   );
        xt08skip_filler  (d,                 4);
        xt08put_surro    (d, 'tableid     '   );
        IF  utds_logentry_buf in scan
        THEN
            xt08put_buffer  (d, 'BLOB IMAGE  ', pAction^.buflength)
        ELSE
            xt08put_hex     (d, 'BLOB IMAGE  ', pAction^.buflength);
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        g17nameto_line ('blob id:          ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.blobname;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_ReorganizeFile (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            filename      : tgg00_Filename;
            lastkeylength : tsp00_Uint2;
            filler1       : tsp00_Int2;
            filler2       : tsp00_Int4;
      END;
 
 
VAR
      d         : display_state_type;
      pAction   : ^t_action;
      fileid    : tgg00_FileId;
      keylength : tsp00_Int4;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_filename (d, 'filename    ');
        xt08put_uint2    (d, 'lastkeylen  ');
        xt08skip_filler  (d, 6);
        keylength := pAction^.lastkeylength;
        IF  keylength > 0
        THEN
            BEGIN
            IF  utds_logentry_buf in scan
            THEN
                xt08put_buffer  (d, 'LAST KEY    ', keylength)
            ELSE
                xt08put_hex     (d, 'LAST KEY    ', keylength);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        g17nameto_line ('tab id:           ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.filename;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_ReloadFile (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            filename      : tgg00_Filename;
      END;
 
 
VAR
      d         : display_state_type;
      pAction   : ^t_action;
      fileid    : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_filename (d, 'filename    ');
        END
    ELSE
        BEGIN
        g17nameto_line ('tab id:           ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.filename;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_UnloadFile (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            filename      : tgg00_Filename;
            auxfilename   : tgg00_Filename;
      END;
 
 
VAR
      d         : display_state_type;
      pAction   : ^t_action;
      fileid    : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_filename (d, 'filename    ');
        xt08put_filename (d, 'auxfilename ');
        END
    ELSE
        BEGIN
        g17nameto_line ('tab id:           ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.filename;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('aux tab id:       ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.auxfilename;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_RefreshSequence (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_sequence = RECORD
            surrogate : tgg00_Surrogate;
            number    : tsp00_Number;
      END;
 
 
VAR
      d               : display_state_type;
      pNumsequence    : ^tsp00_Int4;
      numsequence     : tsp00_Int4;
      currentSequence : tsp00_Int4;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(tsp00_Int4)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pNumsequence := @(buf[d.bufpos]);
    numsequence  := pNumsequence^;
    d.disp_line  := d.term^.blankline;
    d.line_len   := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_int    (d, '# sequences ',  4);
        xt08skip_filler(d, 4);
        IF  buf_offset+(numsequence * sizeof(t_sequence))+1 < buf_size
        THEN
            BEGIN
            currentSequence := 1;
            WHILE currentSequence <= numsequence DO
                BEGIN
                xt08put_surro  (d, 'surrogate   '    );
                IF  utds_logentry_buf in scan
                THEN
                    xt08put_buffer  (d, 'NUM         ', sizeof(tsp00_Number))
                ELSE
                    xt08put_hex     (d, 'NUM         ', sizeof(tsp00_Number));
                (*ENDIF*) 
                currentSequence := currentSequence + 1;
                END
            (*ENDWHILE*) 
            END
        ELSE
            BEGIN
            g17nameto_line ('LOGENTRY CORRUPT  ', d.line_len, d.disp_line);
            xt08output_line (d);
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        g17nameto_line ('# sequences:      ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17trimint4_to_line (numsequence, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_RefreshSurrogate (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            surrogate : tgg00_Surrogate;
            syskey    : tgg00_Surrogate;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_surro  (d, 'surrogate   '    );
        xt08put_surro  (d, 'syskey      '    );
        END
    ELSE
        BEGIN
        g17nameto_line ('surrogate         ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17surrogate_to_line (pAction^.surrogate, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('syskey:           ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17surrogate_to_line (pAction^.syskey, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_CreateIndexFile (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            tabfilename : tgg00_Filename;
            invfilename : tgg00_Filename;
            indexid     : tsp00_Uint4;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
      fileid  : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_filename (d, 'tabfilename '   );
        xt08put_filename (d, 'invfilename '   );
        xt08put_int      (d, 'indexid     ', 4);
        END
    ELSE
        BEGIN
        g17nameto_line ('tab id:           ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.tabfilename;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('inv id:           ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.invfilename;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('indexid:          ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17trimint4_to_line (pAction^.indexid, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_MarkFileAsDeleted (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            filename    : tgg00_Filename;
            fileversion : tgg91_FileVersion;
            filestate   : tsp00_Uint4;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
      fileid  : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_filename (d, 'file no     '   );
        xt08put_fvers    (d, 'file version'   );
        xt08put_int      (d, 'file state  ', 4);
        END
    ELSE
        BEGIN
        g17nameto_line ('filename:         ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileName_gg00 := pAction^.filename;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('file version:     ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        gg06FileVersToLine (pAction^.fileversion, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('file state:       ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17trimint4_to_line (pAction^.filestate, d.line_len, d.disp_line);
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_UnqualifiedDelete (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            tableFileNo  : tgg00_Surrogate;
            dropFileNo   : tgg00_Surrogate;
            secFileCount : tsp00_Int2;
            filler       : tsp00_Int2;
            filler1      : tsp00_Int4;
      END;
 
 
VAR
      d       : display_state_type;
      ix      : integer;
      idx     : integer;
      pAction : ^t_action;
      pFileNo : ^tgg00_Surrogate;
      ptr     : ^tsp00_MoveObj;
      fileid  : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_surro (d, 'table fileNo'   );
        xt08put_surro (d, 'drop fileNo '   );
        xt08skip_filler (d, 8);
        FOR ix := 1 TO pAction^.secFileCount DO
            xt08put_surro (d, 'sec. fileNo '   );
        (*ENDFOR*) 
        END
    ELSE
        BEGIN
        g17nameto_line ('table file no     ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileTabId_gg00 := pAction^.tableFileNo;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('drop file no      ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        fileid.fileTabId_gg00 := pAction^.dropFileNo;
        g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        xt08output_line (d);
        ptr := @pAction^;
        idx := sizeof(pAction^) + 1;
        FOR ix := 1 TO pAction^.secFileCount DO
            BEGIN
            d.disp_line := d.term^.blankline;
            xt08new_line  (d); (* flush last line *)
            d.line_len  := 0;
            pFileNo := @ptr^[idx];
            fileid.fileTabId_gg00 := pFileNo^;
            g17nameto_line ('sec file no       ', d.line_len, d.disp_line);
            d.line_len  := d.line_len + 1;
            g17surrogate_to_line (fileid.fileTabId_gg00, d.line_len, d.disp_line);
            d.line_len  := d.line_len + 1;
            xt08output_line (d);
            idx := idx + sizeof(pAction^.dropFileNo);
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_action_ReassignSecondaryFile (VAR term : tut_terminal;
            VAR prot       : tut_vf_fileref;
            scan           : tut_diag_scan;
            VAR buf        : tsp00_MoveObj;
            buf_size       : tsp00_Int4;
            buf_offset     : tsp00_Int4;
            VAR pfkey      : tut_pfkey);
 
TYPE
 
      t_action = RECORD
            index   : tgg00_Surrogate;
            fromtab : tgg00_Surrogate;
            totab   : tgg00_Surrogate;
      END;
 
 
VAR
      d       : display_state_type;
      pAction : ^t_action;
      fileid  : tgg00_FileId;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
IF  buf_size - buf_offset < sizeof(t_action)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    pAction := @(buf[d.bufpos]);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    IF  utds_logentry_full_info in scan
    THEN
        BEGIN
        xt08put_surro (d, 'index       ');
        xt08put_surro (d, 'from tab    ');
        xt08put_surro (d, 'to tab      ');
        END
    ELSE
        BEGIN
        g17nameto_line ('index:            ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17surrogate_to_line (pAction^.index, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('from tab:         ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17surrogate_to_line (pAction^.fromtab, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17nameto_line ('to tab:           ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17surrogate_to_line (pAction^.totab, d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        xt08output_line (d);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_ColumnMap (VAR term : tut_terminal;
            VAR prot   : tut_vf_fileref;
            scan       : tut_diag_scan;
            VAR buf    : tsp00_MoveObj;
            buf_size   : tsp00_Int4;
            buf_offset : tsp00_Int4;
            colmaplen  : tsp00_Int4;
            VAR pfkey  : tut_pfkey);
 
TYPE
 
      t_head = RECORD
            imageLength     : tsp00_Int4;
            lengthAllValues : tsp00_Int4;
            imageEntries    : tsp00_Uint2;
            fixColCount     : tsp00_Uint2;
            varColCount     : tsp00_Uint2;
            varLongColCount : tsp00_Uint2;
      END;
 
      (* sequence: fixColumn, varColumn, varLongColumn *)
 
      t_columnEntry = RECORD
            offsetOrNumber : tsp00_Uint2;
            valueLength    : tsp00_Uint2;
      END;
 
 
VAR
      d              : display_state_type;
      pHead          : ^t_head;
      pColumnEntry   : ^t_columnEntry;
      currentEntryNo          : tsp00_Int4;
      currentEntryOffset      : tsp00_Int4;
      currentEntryValueOffset : tsp00_Int4;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
d.disp_line := d.term^.blankline;
d.line_len  := 0;
pHead := @(buf[buf_offset + 1]);
IF  (buf_size - buf_offset < colmaplen)
    AND
    (buf_offset + pHead^.imageLength < buf_size)
THEN
    BEGIN
    g17nameto_line ('COLUMN MAP TRUNCAT', d.line_len, d.disp_line);
    g17nameto_line ('ED                ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    IF  colmaplen < sizeof(t_head)
    THEN
        BEGIN
        g17nameto_line ('COLUMN MAP IS CORR', d.line_len, d.disp_line);
        g17nameto_line ('UPT / len =       ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17trimint4_to_line (colmaplen, d.line_len, d.disp_line);
        xt08output_line (d);
        END
    ELSE
        BEGIN
        g17nameto_line ('COLUMN MAP        ', d.line_len, d.disp_line);
        xt08output_line (d);
        d.disp_line := d.term^.blankline;
        d.line_len  := 0;
        xt08put_int     (d, 'imageLength ', 4);
        xt08put_int     (d, 'lengthAllVal', 4);
        xt08put_uint2   (d, 'imageEntries'   );
        xt08put_uint2   (d, 'fixColCount '   );
        xt08put_uint2   (d, 'varColCount '   );
        xt08put_uint2   (d, 'varLongColCo'   );
        IF  (pHead^.imageLength > 0)
            AND
            (pHead^.lengthAllValues > 0)
            AND
            (pHead^.imageEntries = pHead^.fixColCount + pHead^.varColCount + pHead^.varLongColCount)
        THEN
            BEGIN
            currentEntryNo          := 1;
            currentEntryOffset      := buf_offset + sizeof(t_head);
            currentEntryValueOffset := buf_offset + pHead^.imageLength - pHead^.lengthAllValues;
            pColumnEntry            := @(buf[currentEntryOffset+1]);
            WHILE (currentEntryNo            <= pHead^.imageEntries)
                  AND
                  (currentEntryOffset+1      <= buf_size - sizeof(t_columnEntry))
                  AND
                  (currentEntryValueOffset+1 <= buf_size - pColumnEntry^.valueLength)
                  DO
                BEGIN
                d.disp_line := d.term^.blankline;
                d.line_len  := 0;
                xt08put_uint2   (d, 'offsetOrNumb');
                xt08put_uint2   (d, 'valueLength ');
                d.disp_line := d.term^.blankline;
                d.line_len  := 0;
                d.bufpos    := currentEntryValueOffset + 1;
                IF  utds_logentry_buf in scan
                THEN
                    xt08put_buffer  (d, 'COLUMN      ', pColumnEntry^.valueLength)
                ELSE
                    xt08put_hex     (d, 'COLUMN      ', pColumnEntry^.valueLength);
                (*ENDIF*) 
                currentEntryValueOffset := currentEntryValueOffset + pColumnEntry^.valueLength;
                currentEntryOffset      := currentEntryOffset + sizeof(t_columnEntry);
                currentEntryNo          := currentEntryNo + 1;
                d.bufpos                := currentEntryOffset + 1;
                pColumnEntry            := @(buf[currentEntryOffset+1]);
                END;
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08edit_display_InvDescMap (VAR term : tut_terminal;
            VAR prot   : tut_vf_fileref;
            scan       : tut_diag_scan;
            VAR buf    : tsp00_MoveObj;
            buf_size   : tsp00_Int4;
            buf_offset : tsp00_Int4;
            invdesclen : tsp00_Int4;
            VAR pfkey  : tut_pfkey);
 
VAR
      d                  : display_state_type;
      pStackEntry        : ^tgg00_StackEntry;
      currentEntryNo     : tsp00_Int4;
      currentEntryOffset : tsp00_Int4;
      isSecondLine       : boolean;
      secondLine         : tsp00_Line;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufoffset  := 0;
d.bufsize    := buf_size;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
d.disp_line := d.term^.blankline;
d.line_len  := 0;
IF  (buf_offset > buf_size) OR (buf_offset < 0)
THEN
    BEGIN
    g17nameto_line ('INV DESC MAP TO LA', d.line_len, d.disp_line);
    g17nameto_line ('RGE               ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    IF  buf_size - buf_offset < invdesclen
    THEN
        BEGIN
        g17nameto_line ('INV DESC MAP TRUNC', d.line_len, d.disp_line);
        g17nameto_line ('ATED              ', d.line_len, d.disp_line);
        d.line_len  := d.line_len + 1;
        g17trimint4_to_line (buf_size - buf_offset, d.line_len, d.disp_line);
        xt08output_line (d);
        END
    ELSE
        BEGIN
        g17nameto_line ('INV DESC MAP      ', d.line_len, d.disp_line);
        xt08output_line (d);
        d.disp_line        := d.term^.blankline;
        d.line_len         := 0;
        currentEntryNo     := 1;
        IF  buf_offset MOD 4 <> 0  (* PTS 1128692 mb 2004-03-23 *)
        THEN
            currentEntryOffset := buf_offset + (4 - buf_offset MOD 4)
        ELSE
            currentEntryOffset := buf_offset;
        (*ENDIF*) 
        WHILE (currentEntryOffset + 1 <= buf_offset + invdesclen) AND
              (currentEntryOffset + 1 <= buf_size) DO
            BEGIN
            d.disp_line        := d.term^.blankline;
            d.line_len         := 0;
            d.bufpos           := currentEntryOffset + 1;
            pStackEntry        := @(buf[d.bufpos]);
            g17onestackentry (pStackEntry^, currentEntryNo, d.disp_line, isSecondLine, secondLine);
            xt08output_line  (d);
            IF  isSecondLine
            THEN
                BEGIN
                d.disp_line    := secondLine;
                d.line_len     := 0;
                xt08output_line(d);
                END;
            (*ENDIF*) 
            currentEntryOffset := currentEntryOffset + sizeof(tgg00_StackEntry);
            currentEntryNo     := currentEntryNo + 1;
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08edit_display_action (VAR term : tut_terminal;
            VAR protfile : tut_vf_fileref;
            scan         : tut_diag_scan;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4;
            buf_offset   : tsp00_Int4;
            VAR pfkey    : tut_pfkey;
            entry_length : tsp00_Int4;
            actiontype   : tsp00_Uint1;
            forRedo      : boolean);
 
CONST
      c_contains_record = true;
 
BEGIN
CASE actiontype OF
    0: (*Log_NoOp*)
        BEGIN
        (* nothing to do *)
        END;
    1: (*Log_Commit*)
        BEGIN
        IF  NOT forRedo
        THEN
            BEGIN
            (* unexpected *)
            END;
        (*ENDIF*) 
        IF  (utds_logentry_full_info in scan)
            AND
            (entry_length = COMMIT_ENTRY_SIZE_WITH_TIMESTAMP )
        THEN
            xt08edit_display_action_Commit (term, protfile, scan,
                  buf, buf_size, buf_offset, pfkey);
        (*ENDIF*) 
        END;
    2: (*Log_Rollback*)
        BEGIN
        IF  NOT forRedo
        THEN
            BEGIN
            (* unexpected *)
            END;
        (*ENDIF*) 
        END;
    3: (*Log_PartialRollback*)
        BEGIN
        IF  NOT forRedo
        THEN
            BEGIN
            (* unexpected *)
            END;
        (*ENDIF*) 
        xt08edit_display_action_PartialRollback (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
        END;
    4, (*Log_NewObject*)
    5, (*Log_InsertObject*)
    6, (*Log_UpdateObject*)
    7, (*Log_DeleteObject*)
    8: (*Log_LockObject*)
        xt08edit_display_action_Object (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
    9, (*Log_CreateObjectFile*)
    10:(*Log_DropObjectFile*)
        BEGIN
        IF  NOT forRedo
        THEN
            BEGIN
            (* unexpected *)
            END;
        (*ENDIF*) 
        xt08edit_display_action_ObjectFile (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
        END;
    11:(*Log_InsertRecord*)
        IF  forRedo
        THEN
            xt08edit_display_action_InsDelRecord (term, protfile, scan,
                  buf, buf_size, buf_offset, pfkey,
                  c_contains_record)
        ELSE
            xt08edit_display_action_InsDelRecord (term, protfile, scan,
                  buf, buf_size, buf_offset, pfkey,
                  NOT c_contains_record);
        (*ENDIF*) 
    12:(*Log_DeleteRecord*)
        IF  forRedo
        THEN
            xt08edit_display_action_InsDelRecord (term, protfile, scan,
                  buf, buf_size, buf_offset, pfkey,
                  NOT c_contains_record)
        ELSE
            xt08edit_display_action_InsDelRecord (term, protfile, scan,
                  buf, buf_size, buf_offset, pfkey,
                  c_contains_record);
        (*ENDIF*) 
    13:(*Log_UpdateRecord*)
        xt08edit_display_action_UpdateRecord (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
    14:(*Log_ModifyTable*)
        BEGIN
        IF  NOT forRedo
        THEN
            BEGIN
            (* unexpected *)
            END;
        (*ENDIF*) 
        xt08edit_display_action_ModifyTable (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
        END;
    15:(*Log_ChangeFileType*)
        xt08edit_display_action_ChangeFileType (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
    16:(*Log_CreateFile*)
        xt08edit_display_action_CreateFile (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
    17:(*Log_CreateIndex*)
        BEGIN
        IF  NOT forRedo
        THEN
            BEGIN
            (* unexpected *)
            END;
        (*ENDIF*) 
        xt08edit_display_action_CreateIndex (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
        END;
    18:(*Log_CreateTable*)
        BEGIN
        IF  NOT forRedo
        THEN
            BEGIN
            (* unexpected *)
            END;
        (*ENDIF*) 
        xt08edit_display_action_CreateTable (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
        END;
    19:(*Log_RenameFile*)
        xt08edit_display_action_RenameFile (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
    20:(*Log_SuccFileVersion*)
        xt08edit_display_action_SuccFileVersion (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
    21:(*Log_UpdFileStatistic*)
        xt08edit_display_action_UpdFileStatistic (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
    22:(*Log_CopyBlob*)
        xt08edit_display_action_CopyBlob (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
    23:(*Log_CopySameBlob*)
        xt08edit_display_action_CopySameBlob (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
    24:(*Log_ExpandBlob*)
        xt08edit_display_action_ExpandBlob (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
    25:(*Log_TruncateBlob*)
        xt08edit_display_action_TruncateBlob (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
    26:(*Log_UpdateBlob*)
        xt08edit_display_action_UpdateBlob (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
    27:(*Log_RefreshSequence*)
        BEGIN
        IF  NOT forRedo
        THEN
            BEGIN
            (* unexpected *)
            END;
        (*ENDIF*) 
        xt08edit_display_action_RefreshSequence (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
        END;
    28:(*Log_RefreshSurrogate*)
        BEGIN
        IF  NOT forRedo
        THEN
            BEGIN
            (* unexpected *)
            END;
        (*ENDIF*) 
        xt08edit_display_action_RefreshSurrogate (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
        END;
    29,(*Log_FinishOpenTrans*)
    30:(*Log_SavepointEntry*)
        BEGIN
        IF  NOT forRedo
        THEN
            BEGIN
            (* unexpected *)
            END;
        (*ENDIF*) 
        xt08edit_display_action_Savepoint (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
        END;
    31:(*Log_CAN_BE_USED*)
        BEGIN
        END;
    32:(*Log_ReorganizeFile*)
        xt08edit_display_action_ReorganizeFile (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
    33:(*Log_ReloadFile*)
        xt08edit_display_action_ReloadFile (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
    34:(*Log_UnloadFile*)
        xt08edit_display_action_UnloadFile (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
    36:(*Log_CreateIndexFile*)
        BEGIN
        IF  NOT forRedo
        THEN
            BEGIN
            (* unexpected *)
            END;
        (*ENDIF*) 
        xt08edit_display_action_CreateIndexFile (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
        END;
    37:(*Log_ReassignSecondaryFile*)
        BEGIN
        IF  NOT forRedo
        THEN
            BEGIN
            (* unexpected *)
            END;
        (*ENDIF*) 
        xt08edit_display_action_ReassignSecondaryFile (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
        END;
    38: (* Log_MarkFileAsDeleted *)
        BEGIN
        IF  NOT forRedo
        THEN
            BEGIN
            (* unexpected *)
            END;
        (*ENDIF*) 
        xt08edit_display_action_MarkFileAsDeleted (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
        END;
    40:(*Log_UnqualifiedDelete*)
        BEGIN
        IF  NOT forRedo
        THEN
            BEGIN
            (* unexpected *)
            END;
        (*ENDIF*) 
        xt08edit_display_action_UnqualifiedDelete (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
        END;
    41:(*Log_MultipleActions*)
        BEGIN
        IF  NOT forRedo
        THEN
            BEGIN
            (* unexpected *)
            END;
        (*ENDIF*) 
        xt08edit_display_action_MultipleActions (term, protfile, scan,
              buf, buf_size, buf_offset, pfkey);
        END;
    OTHERWISE
        BEGIN
        (* unknown entry *)
        END;
    END;
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08beforeimage_edit_display (VAR term : tut_terminal;
            VAR prot   : tut_vf_fileref;
            scan       : tut_diag_scan;
            VAR buf    : tsp00_MoveObj;
            buf_size   : tsp00_Int4;
            buf_offset : tsp00_Int4;
            VAR pfkey  : tut_pfkey);
 
TYPE
 
      t_beforeimage = RECORD
            actiontype       : tsp00_Uint1;
            state            : tsp00_Uint1;
            prevstate        : tsp00_Uint1;
            filler           : tsp00_Uint1;
            entrysequence    : tsp00_Int4;
            lastredosequence : tsp00_Int4;
            consistentviewno : tgg91_TransNo;
            prevupdtransno   : tgg91_TransNo;
            previmageref     : tgg91_PageRef;
            filler2          : tsp00_Int2;
      END;
 
 
CONST
      c_for_redo = true;
 
VAR
      d            : display_state_type;
      pBeforeImage : ^t_beforeimage;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := buf_offset;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.line_size  := t09prot_linesize (term);
d.scan       := d.scan + [utds_page_header, utds_full_info, utds_display, utds_edit];
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
pBeforeImage := @(buf[d.bufpos]);
IF  d.bufsize - d.bufoffset < sizeof(t_beforeimage)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17nameto_line ('LOGENTRY TOO      ', d.line_len, d.disp_line);
    g17nameto_line (' SHORT! len =     ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (d.bufsize - d.bufoffset,
          d.line_len, d.disp_line);
    xt08output_line (d);
    END
ELSE
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    d.line_len  := d.line_len + 1;
    d.disp_line [d.line_len] := '(';
    g17trimint4_to_line (pBeforeImage^.entrysequence, d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    d.disp_line [d.line_len] := ')';
    d.line_len  := d.line_len + 1;
    g17nameto_line ('actiontype:       ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    gg06LogActionToLine (pBeforeImage^.actiontype, d.line_len, d.disp_line);
    CASE pBeforeImage^.state OF
        0:
            BEGIN
            END;
        1:
            BEGIN
            d.line_len  := d.line_len + 1;
            g17nameto_line ('rollbacked        ', d.line_len, d.disp_line);
            END;
        2:
            BEGIN
            d.line_len  := d.line_len + 1;
            g17nameto_line ('deleted           ', d.line_len, d.disp_line);
            END;
        OTHERWISE
            BEGIN
            d.line_len  := d.line_len + 1;
            g17nameto_line ('***unknown state  ', d.line_len, d.disp_line);
            END;
        END;
    (*ENDCASE*) 
    d.vt_attr    := cut_bright_protected;
    xt08output_line (d);
    d.vt_attr    := cut_protected;
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    (* *)
    xt08put_int     (d, 'Action      ', 1);
    xt08put_int     (d, 'EntryState  ', 1);
    xt08put_int     (d, 'PrevObjState', 1);
    xt08skip_filler (d, 1);
    xt08put_int     (d, 'Sequence    ', 4);
    xt08put_int     (d, 'LastRedoSeq ', 4);
    xt08put_trans   (d, 'ConsistView '   );
    xt08put_trans   (d, 'PrevUpdTrans'   );
    xt08put_pageref (d, 'PrevImageRef'   );
    xt08skip_filler (d, 2);
    x08edit_display_action (term, prot, scan, buf, buf_size,
          d.bufoffset+sizeof(t_beforeimage), pfkey,
          -1, pBeforeImage^.actiontype, NOT c_for_redo);
    END;
(*ENDIF*) 
xt08new_line  (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08node_edit_display (VAR term : tut_terminal;
            VAR prot     : tut_vf_fileref;
            scan         : tut_diag_scan;
            VAR file_pos : tut_file_pos;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4;
            VAR pfkey    : tut_pfkey);
 
VAR
      node : tbd_nodeptr;
      d    : display_state_type;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := 0;
d.bufpos     := 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.scan       := scan;
d.file_pos   := file_pos;
d.line_size  := t09prot_linesize (term);
(* *)
IF  utds_full_info in scan
THEN
    BEGIN
    node := @buf;
    xt08put_pagehead  (d, 'nodepage'       );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    d.bufpos := d.bufsize - PAGE_CHECK_TRAILER_MXGG00 +1;
    xt08put_int       (d, 'nd_checksum ', 4);
    xt08put_pagehead  (d, 'nodepge2'       );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    d.bufpos := PAGE_HEADER_MXGG00 + 1;
    xt08put_int     (d, 'nd_bottom   ', 4);
    xt08put_int     (d, 'nd_rec_cnt  ', 4);
    xt08put_int     (d, 'nd_level    ', 2);
    xt08put_any_set (d, 'nd_filestate', set_bd_fstate);
    xt08put_bool    (d, 'nd_sorted   '   );
    xt08put_pno     (d, 'nd_root     '   );
    xt08put_pno     (d, 'nd_right    '   );
    xt08put_pno     (d, 'nd_left     '   );
    IF  node^.nd_pt2 = pt2String_egg00
    THEN
        xt08put_fileno  (d, 'parent fno  '   )
    ELSE
        BEGIN
        xt08put_pno     (d, 'nd_last     '   );
        xt08skip_filler (d, sizeof(node^.nd_filler2));
        END;
    (*ENDIF*) 
    xt08put_int     (d, 'nd_conv_vers', 4);
    xt08put_int     (d, 'nd_str_vers ', 4);
    xt08put_fvers   (d, 'nd_file_vers'   );
    xt08skip_filler (d, sizeof(node^.nd_history_info));
    xt08put_int     (d, 'ndPageVersio', 1);
    xt08put_int     (d, 'nd_inv_usage', 4);
    IF  node^.nd_pt2 = pt2String_egg00
    THEN
        xt08put_int     (d, 'nd_filesize ', 4)
    ELSE
        xt08put_int     (d, 'nd_leaf_cnt ', 4);
    (*ENDIF*) 
    xt08put_int     (d, 'nd_treeleavs', 4);
    xt08put_trans   (d, 'nd_trans_id '   );
    xt08skip_filler (d, sizeof(node^.nd_filler4));
    xt08put_pno     (d, 'ndInvRoot   '   ); (* PTS 1120695 UH 2003-10-27 *)
    xt08put_int     (d, 'nd_write_cnt', 4);
    xt08new_line  (d) (* flush last line *)
    END;
(*ENDIF*) 
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08logredo_edit_display (VAR term : tut_terminal;
            VAR prot     : tut_vf_fileref;
            scan         : tut_diag_scan;
            VAR file_pos : tut_file_pos;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4;
            VAR pfkey    : tut_pfkey);
 
VAR
      node : tbd_nodeptr;
      d    : display_state_type;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := 0;
d.bufpos     := 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.scan       := scan;
d.file_pos   := file_pos;
d.line_size  := t09prot_linesize (term);
(* *)
IF  utds_full_info in scan
THEN
    BEGIN
    node := @buf;
    xt08put_pagehead  (d, 'logredo '       );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    d.bufpos := d.bufsize - PAGE_CHECK_TRAILER_MXGG00 +1;
    xt08put_int       (d, 'nd_checksum ', 4);
    xt08put_pagehead  (d, 'nodepge2'       );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    d.bufpos := PAGE_HEADER_MXGG00 + 1;
    xt08put_int     (d, 'Bottom      ', 4);
    xt08skip_filler (d, sizeof(node^.nd_record_cnt));
    xt08skip_filler (d, sizeof(node^.nd_level));
    xt08skip_filler (d, sizeof(node^.nd_file_state));
    xt08skip_filler (d, sizeof(node^.nd_sorted));
    xt08put_pno     (d, 'RootPageNo  '   );
    xt08put_pno     (d, 'NextPageNo  '   );
    xt08put_pno     (d, 'PrevPageNo  '   );
    xt08put_pno     (d, 'LastPageNo  '   );
    xt08skip_filler (d, sizeof(node^.nd_filler2));
    xt08skip_filler (d, sizeof(node^.nd_conv_version));
    xt08put_int     (d, 'FrstEntrySeq', 4);
    xt08skip_filler (d, sizeof(node^.nd_file_version));
    xt08skip_filler (d, sizeof(node^.nd_history_info));
    xt08put_int     (d, 'ndPageVersio', 1);
    xt08put_int     (d, 'LastEntrySeq', 4);
    xt08skip_filler (d, sizeof(node^.ndLeafCount_bd00));
    xt08skip_filler (d, sizeof(node^.ndTreeLeaves_bd00));
    xt08put_trans   (d, 'TransNo     '   );
    xt08skip_filler (d, sizeof(node^.nd_filler4));
    xt08skip_filler (d, sizeof(node^.ndInvRoot_bd00)); (* PTS 1120695 UH 2003-10-27 *)
    xt08skip_filler (d, sizeof(node^.nd_write_cnt));
    xt08new_line  (d) (* flush last line *)
    END;
(*ENDIF*) 
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08logundo_edit_display (VAR term : tut_terminal;
            VAR prot     : tut_vf_fileref;
            scan         : tut_diag_scan;
            VAR file_pos : tut_file_pos;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4;
            VAR pfkey    : tut_pfkey);
 
VAR
      node : tbd_nodeptr;
      d    : display_state_type;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := 0;
d.bufpos     := 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.scan       := scan;
d.file_pos   := file_pos;
d.line_size  := t09prot_linesize (term);
(* *)
IF  utds_full_info in scan
THEN
    BEGIN
    node := @buf;
    xt08put_pagehead  (d, 'logundo '       );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    d.bufpos := d.bufsize - PAGE_CHECK_TRAILER_MXGG00 +1;
    xt08put_int       (d, 'nd_checksum ', 4);
    xt08put_pagehead  (d, 'nodepge2'       );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    d.bufpos := PAGE_HEADER_MXGG00 + 1;
    xt08put_int     (d, 'Bottom      ', 4);
    xt08skip_filler (d, sizeof(node^.nd_record_cnt));
    xt08skip_filler (d, sizeof(node^.nd_level));
    xt08skip_filler (d, sizeof(node^.nd_file_state));
    xt08skip_filler (d, sizeof(node^.nd_sorted));
    xt08put_pno     (d, 'RootPageNo  '   );
    xt08put_pno     (d, 'NextPageNo  '   );
    xt08put_pno     (d, 'PrevPageNo  '   );
    xt08put_pno     (d, 'LastPageNo  '   );
    xt08skip_filler (d, sizeof(node^.nd_filler2));
    xt08skip_filler (d, sizeof(node^.nd_conv_version));
    xt08skip_filler (d, sizeof(node^.nd_str_version));
    xt08skip_filler (d, sizeof(node^.nd_file_version));
    xt08skip_filler (d, sizeof(node^.nd_history_info));
    xt08put_int     (d, 'ndPageVersio', 1);
    xt08put_int     (d, 'LastEntrySeq', 4);
    xt08put_int     (d, 'PageCount   ', 4);
    xt08skip_filler (d, sizeof(node^.ndTreeLeaves_bd00));
    xt08put_trans   (d, 'TransNo     '   );
    xt08put_int     (d, 'LastGCoffset', 2);
    xt08put_int     (d, 'LastGCpno   ', 4);
    xt08skip_filler (d, sizeof(node^.nd_write_cnt));
    xt08new_line  (d) (* flush last line *)
    END;
(*ENDIF*) 
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08history_edit_display (VAR term : tut_terminal;
            VAR prot     : tut_vf_fileref;
            scan         : tut_diag_scan;
            VAR file_pos : tut_file_pos;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4;
            VAR pfkey    : tut_pfkey);
 
VAR
      node : tbd_nodeptr;
      d    : display_state_type;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := 0;
d.bufpos     := 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.scan       := scan;
d.file_pos   := file_pos;
d.line_size  := t09prot_linesize (term);
(* *)
IF  utds_full_info in scan
THEN
    BEGIN
    node := @buf;
    xt08put_pagehead  (d, 'history '       );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    d.bufpos := d.bufsize - PAGE_CHECK_TRAILER_MXGG00 +1;
    xt08put_int       (d, 'nd_checksum ', 4);
    xt08put_pagehead  (d, 'nodepge2'       );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    d.bufpos := PAGE_HEADER_MXGG00 + 1;
    xt08put_int     (d, 'Bottom      ', 4);
    xt08put_int     (d, 'Record Count', 4);
    xt08skip_filler (d, sizeof(node^.nd_level));
    xt08skip_filler (d, sizeof(node^.nd_file_state));
    xt08skip_filler (d, sizeof(node^.nd_sorted));
    xt08put_pno     (d, 'RootPageNo  '   );
    xt08put_pno     (d, 'NextPageNo  '   );
    xt08put_pno     (d, 'PrevPageNo  '   );
    xt08put_pno     (d, 'LastPageNo  '   );
    xt08skip_filler (d, sizeof(node^.nd_filler2));
    xt08skip_filler (d, sizeof(node^.nd_conv_version));
    xt08skip_filler (d, sizeof(node^.nd_str_version));
    xt08skip_filler (d, sizeof(node^.nd_file_version));
    xt08put_int     (d, 'FixRecordLen', 2);
    xt08skip_filler (d, sizeof(node^.ndInvUsageCnt_bd00));
    xt08skip_filler (d, sizeof(node^.ndLeafCount_bd00));
    xt08skip_filler (d, sizeof(node^.ndTreeLeaves_bd00));
    xt08skip_filler (d, sizeof(node^.nd_trans_id));
    xt08skip_filler (d, sizeof(node^.nd_filler4));
    xt08skip_filler (d, sizeof(node^.ndInvRoot_bd00)); (* PTS 1120695 UH 2003-10-27 *)
    xt08skip_filler (d, sizeof(node^.nd_write_cnt));
    xt08new_line  (d) (* flush last line *)
    END;
(*ENDIF*) 
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08historydir_edit_display (VAR term : tut_terminal;
            VAR prot     : tut_vf_fileref;
            scan         : tut_diag_scan;
            VAR file_pos : tut_file_pos;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4;
            VAR pfkey    : tut_pfkey);
 
VAR
      node : tbd_nodeptr;
      d    : display_state_type;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := 0;
d.bufpos     := 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.scan       := scan;
d.file_pos   := file_pos;
d.line_size  := t09prot_linesize (term);
(* *)
IF  utds_full_info in scan
THEN
    BEGIN
    node := @buf;
    xt08put_pagehead  (d, 'histdir '       );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    d.bufpos := d.bufsize - PAGE_CHECK_TRAILER_MXGG00 +1;
    xt08put_int       (d, 'nd_checksum ', 4);
    xt08put_pagehead  (d, 'nodepge2'       );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    d.bufpos := PAGE_HEADER_MXGG00 + 1;
    xt08put_int     (d, 'Bottom      ', 4);
    xt08put_int     (d, 'Record Count', 4);
    xt08skip_filler (d, sizeof(node^.nd_level));
    xt08skip_filler (d, sizeof(node^.nd_file_state));
    xt08skip_filler (d, sizeof(node^.nd_sorted));
    xt08put_pno     (d, 'RootPageNo  '   );
    xt08put_pno     (d, 'NextPageNo  '   );
    xt08put_pno     (d, 'PrevPageNo  '   );
    xt08put_pno     (d, 'LastPageNo  '   );
    xt08skip_filler (d, sizeof(node^.nd_filler2));
    xt08skip_filler (d, sizeof(node^.nd_conv_version));
    xt08skip_filler (d, sizeof(node^.nd_str_version));
    xt08skip_filler (d, sizeof(node^.nd_file_version));
    xt08put_int     (d, 'FixRecordLen', 2);
    xt08skip_filler (d, sizeof(node^.ndInvUsageCnt_bd00));
    xt08skip_filler (d, sizeof(node^.ndLeafCount_bd00));
    xt08skip_filler (d, sizeof(node^.ndTreeLeaves_bd00));
    xt08skip_filler (d, sizeof(node^.nd_trans_id));
    xt08skip_filler (d, sizeof(node^.nd_filler4));
    xt08skip_filler (d, sizeof(node^.ndInvRoot_bd00));  (* PTS 1120695 UH 2003-10-27 *)
    xt08skip_filler (d, sizeof(node^.nd_write_cnt));
    xt08new_line  (d) (* flush last line *)
    END;
(*ENDIF*) 
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08opentrans_edit_display (VAR term : tut_terminal;
            VAR prot     : tut_vf_fileref;
            scan         : tut_diag_scan;
            VAR file_pos : tut_file_pos;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4;
            VAR pfkey    : tut_pfkey);
 
VAR
      node : tbd_nodeptr;
      d    : display_state_type;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := 0;
d.bufpos     := 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.scan       := scan;
d.file_pos   := file_pos;
d.line_size  := t09prot_linesize (term);
(* *)
IF  utds_full_info in scan
THEN
    BEGIN
    node := @buf;
    xt08put_pagehead  (d, 'opntrans'       );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    d.bufpos := d.bufsize - PAGE_CHECK_TRAILER_MXGG00 +1;
    xt08put_int       (d, 'nd_checksum ', 4);
    xt08put_pagehead  (d, 'nodepge2'       );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    d.bufpos := PAGE_HEADER_MXGG00 + 1;
    xt08put_int     (d, 'Bottom      ', 4);
    xt08put_int     (d, 'Record Count', 4);
    xt08skip_filler (d, sizeof(node^.nd_level));
    xt08skip_filler (d, sizeof(node^.nd_file_state));
    xt08put_bool    (d, 'CreatBy Redo'   );
    xt08put_pno     (d, 'RootPageNo  '   );
    xt08put_pno     (d, 'NextPageNo  '   );
    xt08put_pno     (d, 'PrevPageNo  '   );
    xt08put_pno     (d, 'LastPageNo  '   );
    xt08skip_filler (d, sizeof(node^.nd_filler2));
    xt08skip_filler (d, sizeof(node^.nd_conv_version));
    xt08skip_filler (d, sizeof(node^.nd_str_version));
    xt08skip_filler (d, sizeof(node^.nd_file_version));
    xt08put_int     (d, 'FixRecordLen', 2);
    xt08put_int     (d, 'OldestEOTseq', 4);
    xt08skip_filler (d, sizeof(node^.ndLeafCount_bd00));
    xt08skip_filler (d, sizeof(node^.ndTreeLeaves_bd00));
    xt08skip_filler (d, sizeof(node^.nd_trans_id));
    xt08skip_filler (d, sizeof(node^.nd_filler4));
    xt08put_int     (d, 'SVPSequence ', 4);
    xt08skip_filler (d, sizeof(node^.nd_write_cnt));
    xt08new_line  (d) (* flush last line *)
    END;
(*ENDIF*) 
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08loginfo_display (VAR term : tut_terminal;
            VAR prot     : tut_vf_fileref;
            scan         : tut_diag_scan;
            VAR file_pos : tut_file_pos;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4;
            VAR pfkey    : tut_pfkey);
      (*parameters:                                                   *)
      (*term        : contains terminal data structures (e.g. buffers)*)
      (*buf         : buffer containing page                          *)
      (*pfkey       : out-variable showing which key was pressed      *)
 
TYPE
 
      t_page = RECORD
            id                  : tsp00_Int4;
            pagetype            : tsp00_Uint1;
            parityalg           : tsp00_Uint1;
            parityvalue         : tsp00_Int2;
            (* *)
            date                : tsp00_Int4;
            time                : tsp00_Int4;
            (* *)
            flushmode           : tsp00_Uint1;
            devicestate         : tsp00_Uint1;
            queuecount          : tsp00_Int2;
            cycleRelatedOffset  : tsp00_Int4;
            (* *)
            lastknown_seq       : tsp00_Int4;
            lastknown_off       : tsp00_Int4;
            (* *)
            oldestnotsaved_off  : tsp00_Int4;
            oldestnotsaved_seq  : tsp00_Int4;
            (* *)
            devspaceEnabled     : boolean;
            autoOverwrite       : boolean;
            filler2             : tsp00_Int2;
            logbackupcount      : tsp00_Int4;
            (* *)
            redountildate       : tsp00_Int4;
            redountiltime       : tsp00_Int4;
            (* *)
            clearlower_off      : tsp00_Int4;
            clearupper_off      : tsp00_Int4;
            (* *)
            seq_after_redountil : tsp00_Int4;
            oldest_known_ioseq  : tsp00_Int4;
            (* *)
            filler4             : tsp00_C64;
            filler5             : tsp00_C80;
            filler6             : tsp00_C20;
            filler7             : tsp00_Int4;
            dbversion           : tsp00_C40;
            (* *)
            dbident             : tsp00_C132;
      END;
 
 
VAR
      dummy_bad  : boolean;
      i          : integer;
      date       : tsp00_Date;
      time       : tsp00_Time;
      ln_len     : integer;
      ln         : tsp00_Line;
      d          : display_state_type;
      pPage      : ^t_page;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := 0;
d.bufpos     := 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.scan       := scan;
d.file_pos   := file_pos;
d.line_size  := t09prot_linesize (term);
(* *)
ln       := d.term^.blankline;
ln_len   := 0;
pPage    := @buf;
x05date_time_to_line (pPage^.date, pPage^.time, ln_len, ln);
ln_len  := ln_len + 1;
g17nameto_line ('MAX USED OFFSET   ', ln_len, ln);
ln_len  := ln_len + 1;
g17trimint4_to_line (pPage^.cycleRelatedOffset, ln_len, ln);
xt08dump_header (d, 'LOGINFO     ', ln, ln_len);
(*bad_logpage_check (d.term^, d.prot^, ptLogInfo_egg00, d.buf^, d.bufsize, dummy_bad);*)
IF  (utds_full_info in scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    xt08output_line (d);
    g17nameto_line ('FlushMode:        ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    gg06FlushModeToLine (pPage^.flushmode, d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17nameto_line ('DeviceState:      ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    gg06DeviceStateToLine (pPage^.devicestate, d.line_len, d.disp_line);
    xt08output_line (d);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    xt08output_line (d);
    (* *)
    xt08put_int     (d, 'id          ', 4);
    xt08put_pagetype(d, 'pagetype    '   );
    xt08skip_filler (d, 3);
    (* *)
    xt08put_date    (d, 'date        '   );
    xt08put_time    (d, 'time        '   );
    (* *)
    xt08put_int     (d, 'flushmode   ', 1);
    xt08put_int     (d, 'devicestate ', 1);
    xt08put_int     (d, 'queuecount  ', 2);
    xt08put_int     (d, 'cycleRelaOFF', 4);
    (* *)
    xt08put_int     (d, 'lastknownSEQ', 4);
    xt08put_int     (d, 'lastknownOFF', 4);
    (* *)
    xt08put_int     (d, 'oldNotSavOFF', 4);
    xt08put_int     (d, 'oldNotSavSEQ', 4);
    (* *)
    xt08put_bool    (d, 'devspaceEnab'   );
    xt08put_bool    (d, 'autoOverwrit'   );
    xt08skip_filler (d, 2);
    xt08put_int     (d, 'logBackupCnt', 4);
    (* *)
    xt08put_date    (d, 'redoUntilDat'   );
    xt08put_time    (d, 'redoUntilTim'   );
    (* *)
    xt08put_int     (d, 'clearLowOFF ', 4);
    xt08put_int     (d, 'clearUppOFF ', 4);
    (* *)
    xt08put_int     (d, 'seqAftRedoUn', 4);
    xt08put_int     (d, 'oldstKnwnIOS', 4);
    (* *)
    xt08skip_filler (d, 64);
    xt08skip_filler (d, 80);
    xt08skip_filler (d, 20);
    xt08skip_filler (d, 4);
    (* *)
    xt08put_char    (d, 'dbVersion   ', 40);
    xt08put_char    (d, 'dbident     ', 60);
    xt08skip_filler (d,                 sizeof (pPage^.dbident) - 60);
    (* *)
    xt08skip_filler (d, 256);
    xt08put_char    (d, 'master node ', 64);
    END;
(*ENDIF*) 
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08obj_edit (VAR term : tut_terminal;
            VAR prot   : tut_vf_fileref;
            VAR buf    : tsp00_MoveObj;
            buf_size   : tsp00_Int4;
            buf_offset : tsp00_Int4;
            is_edit    : boolean;
            VAR pfkey  : tut_pfkey);
 
VAR
      key_len  : tsp00_Int4;
      node_ptr : tbd_nodeptr;
      d        : display_state_type;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := buf_offset;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.scan       := [utds_page_header, utds_full_info, utds_display];
d.line_size  := t09prot_linesize (term);
IF  is_edit
THEN
    d.scan := d.scan + [utds_edit];
(*ENDIF*) 
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
xt08put_pageref (d, 'otrBeforeRef'   );
xt08put_int     (d, 'otrLockTrIdx', 2);
xt08put_trans   (d, 'otrLockTrans'   );
xt08put_trans   (d, 'otrUpdTrans '   );
xt08put_uint2   (d, 'ohdNextFree '   );
xt08put_int     (d, 'ohdState    ', 1);
xt08put_int     (d, 'ohdFrameVers', 1);
xt08new_line    (d); (* flush last line *)
d.scan      := d.scan - [utds_edit];
node_ptr    := @buf;
key_len     := gg06Int4FromUint2 (node_ptr^.nd_obj_key_len);
d.disp_line := d.term^.blankline;
d.line_len  := of_first_col;
g17nameto_line ('frame_len   :     ', d.line_len, d.disp_line);
d.line_len := d.line_len + 1;
g17trimint4_to_line (gg06Int4FromUint2 (node_ptr^.nd_obj_frame_len), d.line_len, d.disp_line);
d.line_len := of_second_col;
g17nameto_line ('key_len     :     ', d.line_len, d.disp_line);
d.line_len := d.line_len + 1;
g17trimint4_to_line (key_len, d.line_len, d.disp_line);
xt08output_line (d);
IF  key_len > 0
THEN
    BEGIN
    d.bufpos := buf_size - key_len + 1;
    xt08put_hex (d, 'key         ', key_len);
    xt08output_line (d)
    END;
(*ENDIF*) 
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08object_node_edit_display (VAR term : tut_terminal;
            VAR prot     : tut_vf_fileref;
            scan         : tut_diag_scan;
            VAR file_pos : tut_file_pos;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4;
            VAR pfkey    : tut_pfkey);
 
VAR
      node : tbd_nodeptr;
      d    : display_state_type;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := 0;
d.bufpos     := 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.scan       := scan;
d.file_pos   := file_pos;
d.line_size  := t09prot_linesize (term);
(* *)
IF  utds_full_info in scan
THEN
    BEGIN
    node := @buf;
    xt08put_pagehead  (d, 'objnode '       );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    d.bufpos := d.bufsize - PAGE_CHECK_TRAILER_MXGG00 +1;
    xt08put_int       (d, 'nd_checksum ', 4);
    xt08put_pagehead  (d, 'objnode2'       );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    d.bufpos := PAGE_HEADER_MXGG00 + 1;
    xt08put_uint2   (d, 'nd_MaxObjCnt'   );
    xt08put_uint2   (d, 'nd_OccObjCnt'   );
    xt08put_uint2   (d, 'nd_FeotObCnt'   );
    xt08put_uint2   (d, 'nd_FreeObCnt'   );
    xt08put_int     (d, 'nd_Level    ', 2);
    xt08put_any_set (d, 'nd_filestate', set_bd_fstate);
    xt08put_hex     (d, 'nd_filler5_1', 1);
    xt08put_pno     (d, 'nd_root     '   );
    xt08put_pno     (d, 'nd_right    '   );
    xt08put_pno     (d, 'nd_left     '   );
    xt08put_int     (d, 'nd_filler5_2', 2);
    xt08put_bool    (d, 'nd_freeChain'   );
    xt08put_hex     (d, 'nd_numkeyfil', 1);
    xt08put_hex     (d, 'ndLckReqSeqL', 4);
    xt08put_int     (d, 'nd_conv_vers', 4);
    xt08put_uint2   (d, 'nd_frame_len'   );
    xt08put_uint2   (d, 'nd_key_len  '   );
    xt08put_fvers   (d, 'nd_file_vers'   );
    xt08put_uint2   (d, 'nd_frst_free'   );
    xt08put_uint2   (d, 'nd_frst_obj '   );
    xt08put_uint2   (d, 'nd_filler5_4'   );
    xt08put_hex     (d, 'nd_ofileno_1', 4);
    xt08put_hex     (d, 'ndLckReqSeqH', 4);
    xt08put_pno     (d, 'nd_next_free'   );
    xt08put_pno     (d, 'nd_prev_free'   );
    xt08put_hex     (d, 'nd_ofileno_2', 4);
    xt08put_int     (d, 'nd_write_cnt', 4);
    xt08new_line  (d) (* flush last line *)
    END;
(*ENDIF*) 
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08rec_edit (VAR term : tut_terminal;
            VAR prot   : tut_vf_fileref;
            VAR buf    : tsp00_MoveObj;
            buf_size   : tsp00_Int4;
            buf_offset : tsp00_Int4;
            is_edit    : boolean;
            is_catalog : boolean;
            page_type2 : tgg00_PageType2;
            VAR pfkey  : tut_pfkey);
 
VAR
      is_subtree_root : boolean;
      key_len         : integer; (* PTS 1103605 JA 1999-08-12 *)
      d               : display_state_type;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := buf_offset;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.scan       := [utds_page_header, utds_full_info, utds_display];
d.line_size  := t09prot_linesize (term);
IF  is_edit
THEN
    d.scan := d.scan + [utds_edit];
(*ENDIF*) 
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
xt08put_int (d, 'recLen      ', 2);
key_len := xt08ord2a (d.buf^, d.bufpos); (* PTS 1103605 JA 1999-08-12 *)
xt08put_int (d, 'recKeyLen   ', 2);
IF  page_type2 = pt2Inv_egg00
THEN
    BEGIN
    is_subtree_root := (ord(d.buf^[d.bufpos]) = ord (ilkSubTree_egg00));
    xt08put_int (d, 'recInvLstKnd', 1);
    xt08put_int (d, 'recAlignment', 1);
    IF  is_subtree_root
    THEN
        (* PTS 1103605 JA 1999-08-12 *)
        BEGIN
        xt08skip_filler (d, sizeof (tsp00_Int2) + key_len); (* recNumPrimKeys + key *)
        xt08put_cint4   (d, 'SubTreeRoot ');
        xt08put_cint4   (d, 'NumPrimKeys ');
        xt08put_cint4   (d, 'NumLeaves   ')
        END
    ELSE
        xt08put_int (d, 'recNumPrKeys', 2);
    (*ENDIF*) 
    END
ELSE
    IF  (page_type2 = pt2InvSubtree_egg00) OR is_catalog
    THEN
        xt08put_hex (d, 'recVarColFil', 4)
    ELSE
        BEGIN
        xt08put_int (d, 'recVarcolOff', 2);
        xt08put_int (d, 'recVarcolCnt', 2)
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  is_catalog
THEN
    BEGIN
    xt08put_surro   (d, 'surrogate   ');
    xt08skip_filler (d, 1);
    xt08put_hex     (d, 'entrytype   ', 1)
    END;
(*ENDIF*) 
xt08new_line (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08restart_display (VAR term : tut_terminal;
            VAR prot     : tut_vf_fileref;
            scan         : tut_diag_scan;
            VAR file_pos : tut_file_pos;
            page_name    : tsp00_Sname;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4;
            VAR pfkey    : tut_pfkey);
      (*parameters:                                                   *)
      (*term        : contains terminal data structures (e.g. buffers)*)
      (*buf         : buffer containing page                          *)
      (*pfkey       : out-variable showing which key was pressed      *)
 
VAR
      dummy_bad  : boolean;
      msg_ln_len : integer;
      msg_ln     : tsp00_Line;
      d          : display_state_type;
      restartrec : tkb00_PagePtr;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := 0;
d.bufpos     := 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.scan       := scan;
d.file_pos   := file_pos;
d.line_size  := t09prot_linesize (term);
(* *)
msg_ln       := d.term^.blankline;
msg_ln_len   := 0;
restartrec   := @buf;
WITH restartrec^.rstLastSavept_kb00 DO
    BEGIN
    g17sname_to_line ('Savept:     ', msg_ln_len, msg_ln);
    msg_ln_len := msg_ln_len + 1;
    x05date_time_to_line (svpDate_kb00, svpTime_kb00, msg_ln_len, msg_ln);
    msg_ln_len := msg_ln_len + 1;
    g17trimint4_to_line (svpReason_kb00, msg_ln_len, msg_ln);
    END;
(*ENDWITH*) 
xt08dump_header (d, page_name, msg_ln, msg_ln_len);
IF  (utds_full_info in scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08put_pagehead  (d, 'restartr'       );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (* beginning of trailer *)
    (*ENDIF*) 
    d.bufpos  := d.bufsize - sizeof (tgg00_PageCheckTrailer) + 1;
    xt08put_int      (d, 'checksum    ', 4);
    xt08put_pagehead (d, 'restart2'       );
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    d.bufpos := sizeof (tgg00_LogPos) + sizeof (tsp00_Int4) + 1;
    xt08put_bool    (d, 'rstIsConsist'   );
    xt08put_int     (d, 'rstConfigPha', 1);
    xt08put_bool    (d, 'rstSetEndRdO'   );
    xt08put_bool    (d, 'rstLstSDOkay'   );
    xt08skip_filler (d, 4);
    xt08put_int     (d, 'rstConvVers ', 4);
    xt08put_int     (d, 'rstPrevConvV', 4);
    xt08put_int     (d, 'rstCurrBupVs', 4);
    xt08put_int     (d, 'rstPrevBupVs', 4);
    xt08skip_filler (d, 8);
    (* *)
    xt08restart_param (d)
    END;
(*ENDIF*) 
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08iomanpage_display (VAR term : tut_terminal;
            VAR protfile : tut_vf_fileref;
            scan         : tut_diag_scan;
            VAR file_pos : tut_file_pos;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4;
            VAR pfkey    : tut_pfkey);
 
TYPE
 
      t_ioman_page = RECORD
            ioman_Id_gg00       : tsp00_PageNo;
            ioman_Pt_gg00       : tgg00_PageType;
            ioman_CheckAlog     : tsp00_Uint1;
            ioman_Parity        : tsp00_Int2;
            ioman_PrevDevNo     : tsp00_Int4;
            ioman_NextDevNo     : tsp00_Int4;
            ioman_Capacity      : tsp00_Int4;
            ioman_BlockSize     : tsp00_Int4;
            ioman_BadCount      : tsp00_Int4;
            ioman_BadResetCount : tsp00_Int4;
            ioman_Filler1       : tsp00_Int4;
            ioman_Filler2       : tsp00_Int4;
            ioman_Filler3       : tsp00_Int4;
            ioman_Filler4       : tsp00_Int4;
            ioman_DbIdent       : tsp00_Line;
      END;
 
 
VAR
      msg_ln_len : integer;
      msg_ln     : tsp00_Line;
      d          : display_state_type;
      ppage      : ^t_ioman_page;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @protfile;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := 0;
d.bufpos     := 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.scan       := [utds_full_info];
d.file_pos   := file_pos;
d.line_size  := t09prot_linesize (term);
(* *)
msg_ln       := d.term^.blankline;
msg_ln_len   := 0;
ppage        := @buf;
xt08dump_header (d, 'IOMAN INFO  ', msg_ln, msg_ln_len);
xt08blank_line (d);
xt08put_int     (d, 'volumeId    ', 4);
xt08put_pagetype(d, 'pageType    '   );
d.bufpos := sizeof (tgg00_PageHeader) + 1;
xt08put_int     (d, 'prevVolumeId', 4);
xt08put_int     (d, 'nextVolumeId', 4);
xt08put_int     (d, 'capacity    ', 4);
xt08put_int     (d, 'blockSize   ', 4);
xt08put_int     (d, 'badBlockNo  ', 4);
xt08put_int     (d, 'badResetCnt ', 4);
xt08put_int     (d, 'rstVolumeId ', 4);
xt08put_int     (d, 'rstBlockNo  ', 4);
xt08skip_filler (d, 8);
xt08blank_line (d);
xt08put_char     (d, 'volumeGuid  ', 60);
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08tree_index_rec_edit (VAR term : tut_terminal;
            VAR prot   : tut_vf_fileref;
            VAR buf    : tsp00_MoveObj;
            buf_size   : tsp00_Int4;
            buf_offset : tsp00_Int4;
            is_edit    : boolean;
            VAR pfkey  : tut_pfkey);
 
VAR
      d : display_state_type;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := buf_offset;
d.bufpos     := buf_offset + 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.scan       := [utds_page_header, utds_full_info, utds_display];
d.line_size  := t09prot_linesize (term);
IF  is_edit
THEN
    d.scan := d.scan + [utds_edit];
(*ENDIF*) 
WITH d.file_pos DO
    BEGIN
    utfp_block_no        := cut_nil_block_no;
    utfp_page_no         := 0;
    utfp_pages_per_block := 1
    END;
(*ENDWITH*) 
xt08put_int   (d, 'recLen      ', 2);
xt08put_int   (d, 'recKeyLen   ', 2);
xt08put_c4int (d, 'recRoot     '   );
xt08new_line (d); (* flush last line *)
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      x08savept_display (VAR term : tut_terminal;
            VAR prot  : tut_vf_fileref;
            scan      : tut_diag_scan;
            VAR buf   : tsp00_MoveObj;
            buf_size  : tsp00_Int4;
            VAR pfkey : tut_pfkey);
 
VAR
      d : display_state_type;
 
BEGIN
d.cur_column := 1;          (* copy all parameters to parameter block *)
d.term       := @term;
d.prot       := @prot;
d.buf        := @buf;
d.bufsize    := buf_size;
d.bufoffset  := 0;
d.bufpos     := 1;
d.pfkey      := pfkey;
d.vt_attr    := cut_protected;
d.scan       := scan + [utds_full_info];
d.line_size  := t09prot_linesize (term);
(* *)
d.disp_line  := d.term^.blankline;
d.line_len   := 0;
xt08savept_param (d);
pfkey := d.pfkey
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08_k51glob (VAR d : display_state_type);
 
VAR
      glob : tkb05_Glob;
 
BEGIN
(* PTS 1105492 JA 2000-03-15 *)
xt08put_header (d, t09window_lines (d.term^) - 3);
xt08put_addr   (d, 'glRegionGlob'   );
xt08put_addr   (d, 'glPoolGlob  '   );
(* *)
xt08put_addr   (d, 'glStateGlob '   );
xt08put_addr   (d, 'glObjColGlob'   );
(* *)
xt08put_addr   (d, 'glTransList '   );
&ifdef BIT64
&else
xt08skip_filler(d, sizeof (tsp00_Addr));
&endif
(* *)
xt08put_bool   (d, 'glGenerated '   );
xt08skip_filler(d, 1);
xt08put_int    (d, 'glRegions   ', 2);
xt08put_int    (d, 'glRowRegions', 2);
xt08put_int    (d, 'glTabRegions', 2);
(* *)
xt08put_int    (d, 'glTrRegions ', 2);
xt08put_int    (d, 'glTrEntries ', 2);
xt08put_int    (d, 'glTrPerRgn  ', 2);
xt08put_int    (d, 'glTrHashEntr', 2);
(* *)
xt08skip_filler(d, 4);
xt08put_int    (d, 'glDeadlDetct', 4);
(* *)
xt08put_int    (d, 'glItems     ', 4);
xt08put_int    (d, 'glMaxRowsTab', 4);
(* *)
xt08put_int    (d, 'glItemsPerRg', 4);
xt08put_int    (d, 'glMaxPerRgn ', 4);
(* *)
xt08put_int    (d, 'glPoolSegms ', 4);
xt08put_int    (d, 'glPoolItems ', 4);
(* *)
xt08put_int    (d, 'glRowHshEntr', 4);
xt08put_int    (d, 'glTabHshEntr', 4);
(* *)
xt08put_trans  (d, 'glSelTrnsGen');                                  (* PTS 1108234 JA 2001-01-02 *)
xt08skip_filler(d, 2);                                               (* PTS 1108234 JA 2001-01-02 *)
(* *)
xt08skip_filler(d, sizeof (glob.glNilWantedLock_kb05 ));
xt08skip_filler(d, sizeof (glob.glNilOpenTrans_kb05  ));
xt08skip_filler(d, sizeof (glob.glNilReq_kb05        ));
xt08skip_filler(d, sizeof (glob.glNilRowLock_kb05    ));
xt08skip_filler(d, sizeof (glob.glNilRowTrans_kb05   ));
xt08skip_filler(d, sizeof (glob.glNilTabLock_kb05    ));
xt08skip_filler(d, sizeof (glob.glNilTabTrans_kb05   ));
xt08skip_filler(d, sizeof (glob.glNilTransEntry_kb05 ));
IF  d.cur_column = 2
THEN
    (* flush last line *)
    xt08out_col_line (d);
(*ENDIF*) 
;
(* ========================================== *)
(* *)
xt08put_addr   (d, 'poolSegmList'   );
xt08put_addr   (d, 'poolFrstFree'   );
(* *)
xt08put_int    (d, 'poolFreeSegm', 4);
xt08put_int    (d, 'poolMinFree ', 4);
(* *)
xt08skip_filler(d, 4);
xt08put_trans  (d, 'poolMinOpenT'   );
xt08put_trans  (d, 'poolMinCsist'   );
(* *)
xt08put_cnt    (d, 'poolSegmAmnt'   );
(* *)
xt08put_cnt    (d, 'poolItemAmnt'   );
(* *)
xt08put_cnt    (d, 'poolAmntPnts'   );
(* *)
xt08put_bool   (d, 'poolEmptyWng'   );
xt08skip_filler(d, 3);
xt08put_int    (d, 'poolOwnRgnId', 4);
xt08put_trans  (d, 'poolMinNVOpT'   );
xt08put_trans  (d, 'poolMinNVCsv'   );
xt08skip_filler(d, 4);                      (* record alignment *)
IF  d.cur_column = 2
THEN
    (* flush last line *)
    xt08out_col_line (d);
(*ENDIF*) 
;
(* ========================================== *)
(* *)
xt08put_int    (d, 'lglTimeClear', 4);
xt08put_int    (d, 'lglOwnRgnId ', 4);
(* *)
IF  d.cur_column = 2
THEN
    (* flush last line *)
    xt08out_col_line (d)
          ;
(* ========================================== *)
(* *)
(*ENDIF*) 
xt08put_addr   (d, 'oglCollList '   );
xt08put_addr   (d, 'oglReqList  '   );
(* *)
xt08put_int    (d, 'oglFirstFree', 2);
xt08put_int    (d, 'oglFreeCnt  ', 2);
xt08put_int    (d, 'oglReqCnt   ', 2);
xt08skip_filler(d, 2);
(* *)
xt08skip_filler(d, 4);
xt08put_int    (d, 'oglOwnRgnId ', 4);
(* *)
xt08put_cnt    (d, 'oglCollision'   );
IF  d.cur_column = 2
THEN
    (* flush last line *)
    xt08out_col_line (d)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08_k51lock (VAR d : display_state_type);
 
VAR
      aux_pos      : integer;
      curr_region  : integer;
      first_region : integer;
      header_pos   : integer;
      region_cnt   : integer;
 
BEGIN
(* PTS 1105492 JA 2000-03-15 *)
header_pos   := d.bufpos;
d.bufpos     := d.bufpos + 10;
first_region := xt08ord2a (d.buf^, d.bufpos);
d.bufpos     := d.bufpos + 2;
region_cnt   := xt08ord2a (d.buf^, d.bufpos);
d.bufpos     := d.bufpos + 2;
FOR curr_region := first_region TO first_region - 1 + region_cnt DO
    BEGIN
    aux_pos  := d.bufpos;
    d.bufpos := header_pos;
    xt08put_header (d, 6);
    d.bufpos    := aux_pos;
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17sname_to_line ('REGION GLOB ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (curr_region, d.line_len, d.disp_line);
    xt08output_line (d);
    xt08put_addr   (d, 'rglTransGlob'   );
    xt08put_addr   (d, 'rglSplyBlock'   );
    (* *)
    xt08put_addr   (d, 'rglRowHash  '   );
    xt08put_addr   (d, 'rglTabHash  '   );
    (* *)
    xt08put_addr   (d, 'rglFstCnsist'   );
    xt08put_addr   (d, 'rglFirstFree'   );
    (* *)
    xt08put_addr   (d, 'rglCancelCns'   );    (* PTS 1120151 FF 2003-01-29 *)
&   ifdef BIT64
&   else
    xt08skip_filler (d, sizeof (tsp00_Addr));
&   endif
    (* *)
    xt08put_addr   (d, 'rglExtFstSgm'   );
    xt08put_addr   (d, 'rglExtFstFre'   );
    (* *)
    xt08put_int    (d, 'rglOwnRegion', 2);
    xt08skip_filler(d, 2);
    xt08put_int    (d, 'rglFreeItems', 4);
    (* *)
    xt08put_int    (d, 'rglExtItems ', 4);
    xt08put_int    (d, 'rglExtFreeIt', 4);
    (* *)
    xt08put_int    (d, 'rglCnsistCnt', 4);
    xt08put_int    (d, 'rglCancelCnt', 4);   (* PTS 1120151 FF 2003-01-29 *)
    xt08put_cnt    (d, 'rglCollision'   ); (* PTS 1103799 JA 1999-08-30 *)
    xt08put_int    (d, 'rglOpenTrCnt', 4);
    (* *)
    xt08put_trans  (d, 'rglMinOpenTr'   );
    xt08put_trans  (d, 'rglMinCnsist'   );
    xt08put_trans  (d, 'rglMinNVOpTr'   );
    xt08put_trans  (d, 'rglMinNVCnsV'   );
    xt08skip_filler(d, 4);
    (* *)
    IF  d.cur_column = 2
    THEN
        (* flush last line *)
        xt08out_col_line (d)
    (*ENDIF*) 
    END
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08_k51rowid (VAR d : display_state_type);
 
BEGIN
xt08put_header (d, t09window_lines (d.term^)-3);
xt08put_addr   (d, 'ROWID       '   );
xt08put_int    (d, 'riItemKind  ', 1);
xt08put_bool   (d, 'riExtentItem'   );  (* PTS 1105492 JA 2000-03-15 *)
xt08put_int    (d, 'riChkOwnRgn ', 1);
xt08put_int    (d, 'riChkTrnsIdx', 1);
xt08put_procid (d, 'riChkTaskId '   );
xt08put_buffer (d, 'riRowId     ', sizeof (tkb05_RowId))
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08_k51trans (VAR d : display_state_type);
 
VAR
      aux_pos      : integer;
      curr_region  : integer;
      first_region : integer;
      header_pos   : integer;
      region_cnt   : integer;
 
BEGIN
(* PTS 1105492 JA 2000-03-15 *)
header_pos   := d.bufpos;
d.bufpos     := d.bufpos + 10;
first_region := xt08ord2a (d.buf^, d.bufpos);
d.bufpos     := d.bufpos + 2;
region_cnt   := xt08ord2a (d.buf^, d.bufpos);
d.bufpos     := d.bufpos + 2;
FOR curr_region := first_region TO first_region - 1 + region_cnt DO
    BEGIN
    aux_pos  := d.bufpos;
    d.bufpos := header_pos;
    xt08put_header (d, 7);
    d.bufpos    := aux_pos;
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17sname_to_line ('TRANS GLOB  ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (curr_region, d.line_len, d.disp_line);
    xt08output_line (d);
    (* *)
    xt08put_addr    (d, 'trFirst     '   );
    xt08put_addr    (d, 'trFirstFree '   );
    (* *)
    xt08put_addr    (d, 'trTransHash '   );
&   ifdef BIT64
&   else
    xt08skip_filler (d, sizeof (tsp00_Addr));
&   endif
    (* *)
    xt08put_int     (d, 'trFreeEntrie', 2);
    xt08put_int     (d, 'trConnctOnly', 2);
    xt08put_int     (d, 'trLckTrnsCnt', 2);
    xt08put_int     (d, 'trReqTrnsCnt', 2);
    (* *)
    xt08put_int     (d, 'trObjTrnsCnt', 2);
    xt08put_int     (d, 'trOwnRegion ', 2);
    xt08skip_filler (d, 4);
    (* *)
    xt08put_cnt     (d, 'trRowAmount '   ); (* PTS 1103799 JA 1999-08-30 *)
    xt08put_cnt     (d, 'trTabAmount '   ); (* PTS 1103799 JA 1999-08-30 *)
    xt08put_cnt     (d, 'trSqlReqTout'   ); (* PTS 1103799 JA 1999-08-30 *)
    xt08put_cnt     (d, 'trObjReqTout'   ); (* PTS 1103799 JA 1999-08-30 *)
    xt08put_cnt     (d, 'trDeadlocks '   ); (* PTS 1103799 JA 1999-08-30 *)
    xt08put_cnt     (d, 'trEscalation'   ); (* PTS 1103799 JA 1999-08-30 *)
    IF  d.cur_column = 2
    THEN
        (* flush last line *)
        xt08out_col_line (d)
    (*ENDIF*) 
    END
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08_k51trans_entry (VAR d : display_state_type);
 
VAR
      prev_log_cnt    : tsp00_Int2;
      i               : integer;
      logpno_list_pos : integer;
      logpos_list_pos : integer;
      dumplogtrans    : boolean;
 
BEGIN
(* PTS 1105492 JA 2000-03-15 *)
xt08put_header  (d, t09window_lines(d.term^)-3);
xt08put_addr    (d, 'TRANS ENTRY '   ); (* teOwnAddr *)
xt08put_addr    (d, 'teNextHash  '   );
(* *)
xt08put_addr    (d, 'tePrevHash  '   );
xt08put_addr    (d, 'teNextTrans '   );
(* *)
xt08put_addr    (d, 'tePrevTrans '   );
xt08put_addr    (d, 'teFirstTab  '   );
(* *)
xt08put_addr    (d, 'teTabRctUsed'   );
xt08put_addr    (d, 'teRowRctUsed'   );
(* *)
xt08put_addr    (d, 'teReqTab    '   );
xt08put_addr    (d, 'teReqRow    '   );
(* *)
xt08put_addr    (d, 'teCnsistView'   );
xt08put_addr    (d, 'teCancelAddr'   );
(* *)
xt08put_int     (d, 'teOwnIndex  ', 2);
xt08put_int     (d, 'teOwnRegion ', 2);
xt08put_sess_tr (d, 'teSessTrans '   );
(* *)
xt08put_c4int   (d, 'teUserId    '   );
xt08put_char    (d, 'teTermId    ',18);
xt08put_bool    (d, 'teTmoutEnabl'   );
xt08skip_filler (d, 1);
(* *)
xt08put_procid  (d, 'teTaskId    '   );
xt08put_kb5info (d, 'teInfo      '   );
xt08put_int     (d, 'teLockMode  ', 1);
xt08put_int     (d, 'teReqMode   ', 1);
xt08skip_filler (d, 1);
(* *)
xt08put_int     (d, 'teReqTimeout', 4);
xt08put_int     (d, 'teTmLstWrite', 4);
(* *)
xt08put_mess    (d, 'teState     '   );
xt08put_int     (d, 'teObjLockMod', 1);
xt08skip_filler (d, 6);
(* *)
xt08put_date    (d, 'teStartDate '   );
xt08put_time    (d, 'teStartTime '   );
(* *)
xt08put_int     (d, 'teCollLock  ', 2);
xt08put_int     (d, 'teObjReq    ', 2);
xt08put_int     (d, 'teObjTimeout', 4);
(* *)
xt08put_bool    (d, 'teWaiting   '   );
xt08put_int     (d, 'teOmsLockMod', 1);
xt08skip_filler (d, 6);
(* *)
xt08put_int     (d, 'tlogAuxFnNo ', 4);
xt08put_int     (d, 'tlogTmpFunct', 4);
(* *)
xt08put_int     (d, 'tlogTmpCnt  ', 4);
xt08put_pno     (d, 'tlogTmpRoot '   );
(* *)
dumplogtrans := s20buf_to_int4 (d.buf^, d.bufpos) <> 0; (* for 64 bytes ptr too *)
xt08put_addr    (d, 'tlogTransPtr');
xt08skip_filler (d, sizeof (tsp00_Addr));
(* *)
xt08put_int8    (d, 'teTransStart' );
xt08put_addr    (d, 'teLocalFileD');
(* *)
xt08put_addr    (d, 'teShrLockLst');
xt08put_addr    (d, 'teExtTransMo');
xt08skip_filler (d, sizeof (tsp00_Addr));
(* Log_Transaction* *)
(* *)
IF  dumplogtrans
THEN
    BEGIN
    xt08put_trans   (d, 'LOG.TransNo '   );
    xt08put_int     (d, 'LOG.State   ', 1);
    xt08skip_filler (d, 1);
    (* *)
    xt08put_int     (d, 'LOG.UndoSeq ', 4); (* unit4 *)
    xt08put_int     (d, 'LOG.RedoSeq ', 4); (* unit4 *)
    (* *)
    xt08put_int     (d, 'LOG.LstCpySq', 4); (* unit4 *)
    xt08put_int     (d, 'LOG.UndoRoot', 4);
    (* *)
    xt08put_int     (d, 'LOG.UndoLast', 4);
    xt08put_int     (d, 'LOG.RedoRoot', 4);
    (* *)
    xt08put_int     (d, 'LOG.RedoLast', 4);
    xt08put_int     (d, 'LOG.EOTseq  ', 4); (* unit4 *)
    (* *)
    xt08put_int     (d, 'LOG.QueueID ', 2); (* unit2 *)
    xt08put_bool    (d, 'LOG.EntrCmpl'   ); (* unit2 *)
    xt08skip_filler (d, 1);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08blank_line (VAR d : display_state_type);
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08new_line (d);
    d.disp_line := d.term^.blankline;
    IF  d.pfkey = pf_none
    THEN
        xt08output_line (d)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08col_size_to_line (VAR d : display_state_type;
            size : integer);
 
BEGIN
IF  (size > 0) AND (size <= 9) AND (utds_edit in d.scan)
THEN
    g17int4to_line (size, c_pad_with_zero, 1,
          of_col_type + 2 + 2*(d.cur_column-1), d.disp_line)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08conditional_newscreen (VAR d : display_state_type;
            wanted_lines : integer);
 
BEGIN
IF  (d.pfkey = pf_none)
    AND
    NOT t09is_empty_window (d.term^)
    AND
    t09is_window_full (d.term^, wanted_lines)
THEN
    (* not enough space on screen *)
    BEGIN
    x05holdhexint (d.term^, d.pfkey);
    IF  d.pfkey = pf_none
    THEN
        t09newscreen_page (d.term^)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08dump_allocator (VAR d : display_state_type;
            VAR f    : tut_file;
            dumptype : integer);
 
TYPE
 
      TChunkInfo = RECORD
            ci_offset    : tsp00_Int4;
            ci_size      : tsp00_Int4;
            ci_prev      : tgg00_VoidPtr;
            ci_next      : tgg00_VoidPtr;
            ci_inUse     : boolean;
            ci_errorText : tsp00_C40;
      END;
 
 
      TChunkHeader = RECORD
            ch_label : tsp00_C4;
            ch_size  : tsp00_Int4;
            ch_next  : tsp00_Addr;
&           ifndef BIT64
            ch_fill  : tsp00_Int4;
&           endif
      END;
 
 
CONST
      c_msg_no_memory   = 'NOT ENOUGH MEMORY   ';
      c_unexpected_eof  = 'UNEXPECTED EOF      ';
 
VAR
      ok           : boolean;
      err          : tsp00_VfReturn;
      chunkCnt     : integer;
      pos          : integer;
      len          : integer;
      size         : integer;
      nextChunk    : tsp00_Addr;
      pBuf         : tsp00_MoveObjPtr;
      pAuxBuf      : tsp00_MoveObjPtr;
      pChunk       : tgg00_VoidPtr;
      pChunkHeader : ^TChunkHeader;
      chunkSize    : tsp00_Int4;
      inUse        : boolean;
      errorText    : tsp00_C40;
      chunkInfo    : TChunkInfo;
      lbl          : tsp00_C18;
 
BEGIN
CASE dumptype OF
    d_allocator :
        BEGIN
        (* dump of a allocator raw chunk *)
        chunkCnt := 0;
        pBuf     := d.buf;
        lbl      := allocator_label;
        d.buf    := @lbl;
        d.bufpos := 1;
        xt08put_header (d, t09window_lines(d.term^) - 3);
        size := 10 * 1024 * 1024;
        sqlallocat (size, pBuf, ok);
        IF  ok
        THEN
            BEGIN
            SAPDB_PascalForcedMove (f.utf_block_len, size,
                  @f.utf_block^, 1, @pBuf^, 1, f.utf_block_len);
            pos      := f.utf_block_len + 1;
            chunkCnt := chunkCnt + 1;
            REPEAT
                x05get_next (d.term^, f, err);
                IF  err = vf_ok
                THEN
                    BEGIN
                    IF  pos + f.utf_block_len - 1 > size
                    THEN
                        BEGIN
                        sqlallocat (size + 10 * 1024 * 1024, pAuxBuf, ok);
                        IF  pBuf <> NIL
                        THEN
                            BEGIN
                            SAPDB_PascalForcedMove (size, size + 10 * 1024 * 1024,
                                  @pBuf^, 1, @pAuxBuf^, 1, pos - 1);
                            sqlfree(pBuf);
                            pBuf := pAuxBuf;
                            size := size + 10 * 1024 * 1024;
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  ok
                    THEN
                        SAPDB_PascalForcedMove (f.utf_block_len, size,
                              @f.utf_block^, 1, @pBuf^, pos, f.utf_block_len);
                    (*ENDIF*) 
                    pos := pos + f.utf_block_len;
                    END;
                (*ENDIF*) 
            UNTIL
                (err <> vf_ok) OR NOT ok;
            (*ENDREPEAT*) 
            sqlfree(pBuf);
            END;
        (*ENDIF*) 
        IF  NOT ok
        THEN
            xt08put_error (d, c_msg_no_memory)
        ELSE
            BEGIN
            (* the heap chunk is completely copied now *)
            pChunk := x12FirstChunk (@pBuf^);
            REPEAT
                xt08new_line (d);
                x12ChunkInfo (pChunk, chunkInfo.ci_offset,
                      chunkInfo.ci_size, chunkInfo.ci_inUse, ok,
                      chunkInfo.ci_prev, chunkInfo.ci_next, chunkInfo.ci_errorText);
                d.buf    := @chunkInfo;
                d.bufpos := 1;
                xt08put_int  (d, 'offset      ', 4);
                xt08put_int  (d, 'chunk size  ', 4);
                IF  chunkInfo.ci_inUse
                THEN (* don't display free list pointers *)
                    d.pfkey := pf_end;
                (*ENDIF*) 
                xt08put_addr (d, 'prev free   ');
                xt08put_addr (d, 'next free   ');
                d.pfkey := pf_none;
                xt08put_bool (d, 'chunk in use');
                IF  NOT ok
                THEN
                    xt08put_char (d, 'ERROR       ', 40)
                ELSE
                    IF  chunkInfo.ci_inUse
                    THEN
                        BEGIN
                        d.buf    := @pChunk^;
                        d.bufpos := 1;
                        xt08put_buffer (d, 'info        ', chunkInfo.ci_size);
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                pChunk := x12NextChunk (pChunk);
            UNTIL
                pChunk = NIL;
            (*ENDREPEAT*) 
            END;
        (*ENDIF*) 
        END;
    OTHERWISE
        d.bufpos := d.bufsize; (* no more dump recs *)
    END;
(*ENDCASE*) 
xt08new_line (d);
(* flushing line buffer with last item *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08dump_ak_record (VAR d : display_state_type;
            VAR f    : tut_file;
            dumptype : integer);
 
TYPE
 
      TChunkHeader = RECORD
            ch_label : tsp00_C4;
            ch_size  : tsp00_Int4;
            ch_next  : tsp00_Addr;
&           ifndef BIT64
            ch_fill  : tsp00_Int4;
&           endif
      END;
 
 
CONST
      c_msg_no_memory   = 'NOT ENOUGH MEMORY   ';
      c_unexpected_eof  = 'UNEXPECTED EOF      ';
 
VAR
      ok           : boolean;
      err          : tsp00_VfReturn;
      chunkCnt     : integer;
      pos          : integer;
      len          : integer;
      nextChunk    : tsp00_Addr;
      pBuf         : tsp00_MoveObjPtr;
      pChunkHeader : ^TChunkHeader;
 
BEGIN
CASE dumptype OF
    d_a10cache, d_a10error :
        BEGIN
        (* dump of ak cache *)
        chunkCnt := 0;
        pBuf     := d.buf;
        xt08put_header (d, t09window_lines(d.term^) - 3);
        REPEAT
            chunkCnt := chunkCnt + 1;
            d.buf    := pBuf;
            x05get_next (d.term^, f, err);
            IF  err <> vf_ok
            THEN
                BEGIN
                xt08put_error (d, c_unexpected_eof);
                nextChunk := NIL;
                END
            ELSE
                BEGIN
                pChunkHeader := @d.buf^[1];
                d.bufpos := 1;
                IF  dumptype <> d_a10error
                THEN
                    BEGIN
                    xt08put_char (d, 'chunk label ', sizeof (tsp00_C4));
                    xt08put_int  (d, 'chunk size  ', 4);
                    xt08put_addr (d, 'next chunk  ');
                    xt08blank_line (d);
                    END;
                (*ENDIF*) 
                len       := pChunkHeader^.ch_size * sizeof(tsp00_Buf);
                nextChunk := pChunkHeader^.ch_next;
                sqlallocat (len, d.buf, ok);
                IF  ok
                THEN
                    BEGIN
                    SAPDB_PascalForcedMove (f.utf_block_len, len,
                          @f.utf_block^, 1, @d.buf^, 1, f.utf_block_len);
                    pos := f.utf_block_len + 1;
                    WHILE pos < len DO
                        BEGIN
                        x05get_next (d.term^, f, err);
                        IF  err <> vf_ok
                        THEN
                            BEGIN
                            xt08put_error (d, c_unexpected_eof);
                            nextChunk := NIL;
                            len       := 0;
                            END
                        ELSE
                            SAPDB_PascalForcedMove (f.utf_block_len, len,
                                  @f.utf_block^, 1, @d.buf^, pos, f.utf_block_len);
                        (*ENDIF*) 
                        pos := pos + f.utf_block_len;
                        END;
                    (*ENDWHILE*) 
                    d.bufsize := len;
                    IF  chunkCnt = 1
                    THEN
                        d.bufpos  := sizeof(TChunkHeader) + 2 * sizeof(tak_globalCacheReference) + 1
                    ELSE
                        d.bufpos  := sizeof(TChunkHeader) + 1;
                    (*ENDIF*) 
                    WHILE d.bufpos < len DO
                        BEGIN
                        IF  dumptype = d_a10error
                        THEN
                            xt08CheckAkCacheBlock(d)
                        ELSE
                            xt08DumpAkCacheBlock(d);
                        (*ENDIF*) 
                        END;
                    (*ENDWHILE*) 
                    sqlfree (d.buf);
                    END
                ELSE
                    BEGIN
                    xt08put_error (d, c_msg_no_memory);
                    nextChunk := NIL;
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            nextChunk = NIL;
        (*ENDREPEAT*) 
        d.bufpos := d.bufsize
        END;
    d_SQLTempFileColl:
        xt08DumpSQLTempFileColl(d);
    OTHERWISE
        d.bufpos := d.bufsize; (* no more dump recs *)
    END;
(*ENDCASE*) 
xt08new_line (d);
(* flushing line buffer with last item *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08CheckAkCacheBlock(VAR d : display_state_type);
 
VAR
      error   : boolean;
      pos     : tsp00_Int4;
      pHeader : ^tak_cache_dir_entry;
 
BEGIN
pos     := d.bufpos;
pHeader := @d.buf^[pos];
error := pHeader^.cd_check <> cak_cache_chunk_flag;
IF  NOT error
THEN
    IF  NOT (dno_meaning in pHeader^.cd_state)
    THEN
        BEGIN
        IF  (pHeader^.cd_syskey.skeylen < 12) OR
            (pHeader^.cd_syskey.skeylen > sizeof(pHeader^.cd_syskey) - 8)
        THEN
            error := true;
        (*ENDIF*) 
        IF  pHeader^.cd_balance > right_weighted
        THEN
            error := true;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        IF  pHeader^.cd_bl_less.cdir_ptr <> NIL
        THEN
            error := true;
        (*ENDIF*) 
        IF  pHeader^.cd_bl_fix_prev.cdir_ptr <> NIL
        THEN
            error := true;
        (*ENDIF*) 
        IF  pHeader^.cd_bl_lru_prev.cdir_ptr <> NIL
        THEN
            error := true;
        (*ENDIF*) 
        IF  pHeader^.cd_bl_lru_next.cdir_ptr <> NIL
        THEN
            error := true;
        (*ENDIF*) 
        IF  (pHeader^.cd_mem_type < dyn_free) OR (pHeader^.cd_mem_type > dyn_syntax_tree)
        THEN
            error := true;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  error
THEN
    BEGIN
    xt08DumpAkCacheBlock(d);
    END
ELSE
    d.bufpos := pos + pHeader^.cd_syslen;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08DumpAkCacheBlock(VAR d : display_state_type);
 
VAR
      pos     : tsp00_Int4;
      pHeader : ^tak_cache_dir_entry;
 
BEGIN
pos     := d.bufpos;
pHeader := @d.buf^[pos];
IF  (dno_meaning in pHeader^.cd_state)
THEN
    xt08conditional_newscreen (d, 4)
ELSE
    xt08conditional_newscreen (d, 20);
(*ENDIF*) 
xt08put_int (d, 'cd_pos      ', 4);
xt08put_int (d, 'cd_check    ', 2);
xt08put_int (d, 'cd_refCount ', 2);
IF  NOT (dno_meaning in pHeader^.cd_state)
THEN
    BEGIN
    xt08put_addr (d, 'cd_less     ');
    xt08put_addr (d, 'cd_greater  ');
    xt08put_addr (d, 'cd_fix_prev ');
    xt08put_addr (d, 'cd_fix_next ');
    xt08put_addr (d, 'cd_lru_prev ');
    xt08put_addr (d, 'cd_lru_next ');
    xt08put_int  (d, 'cd_cmd_no   ', 4);
    xt08put_int  (d, 'cd_create_cm', 4);
    xt08put_int  (d, 'cd_state    ', 1);
    xt08put_int  (d, 'cd_balance  ', 1);
    xt08put_int  (d, 'cd_buf_no   ', 2);
    xt08put_int  (d, 'cd_syslen   ', 4);
    IF  dreference in pHeader^.cd_state
    THEN
        BEGIN
        xt08put_addr (d, 'cd_globhndle');
        xt08put_addr (d, 'cd_globsysp ');
        END
    ELSE
        BEGIN
        xt08put_int  (d, 'cd_reclen   ', 2);
        xt08put_int  (d, 'cd_keylen   ', 2);
        d.bufpos := d.bufpos + 4;
        xt08put_buffer (d, 'cd_syskey   ', pHeader^.cd_syskey.skeylen);
        xt08put_buffer (d, 'info        ', pHeader^.cd_syslen
              - (sizeof(pHeader^) - sizeof(pHeader^.cd_sysinfo))
              - pHeader^.cd_syskey.skeylen - 8);
        END;
    (*ENDIF*) 
    END
ELSE
    BEGIN
    (* PTS 1111500 E.Z. *)
    xt08put_addr (d, 'cd_less     ');
    IF  pHeader^.cd_mem_type = dyn_free
    THEN
        xt08put_addr (d, 'cd_next_free')
    ELSE
        d.bufpos := d.bufpos +
              sizeof(pHeader^.cd_next_free);
    (*ENDIF*) 
    xt08put_addr (d, 'cd_fix_prev ');
    xt08put_addr (d, 'cd_fix_next ');
    xt08put_addr (d, 'cd_lru_prev ');
    xt08put_addr (d, 'cd_lru_next ');
    d.bufpos := d.bufpos +
          sizeof(pHeader^.cd_free_fill) +
          sizeof(pHeader^.cd_block_len) +
          sizeof(pHeader^.cd_bl_state);
    xt08put_block_type(d, 'cd_mem_type ');
    xt08put_int       (d, 'cd_bl_buf_no', 2);
    xt08put_int       (d, 'cd_syslen   ', 4);
    END;
(*ENDIF*) 
xt08blank_line (d);
d.bufpos := pos + pHeader^.cd_syslen;
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08DumpSQLTempFileColl(VAR d : display_state_type);
 
VAR
      EntryCount    : tsp00_Int2;
      CurrentEntry  : tsp00_Int4;
 
BEGIN
xt08put_header (d, t09window_lines(d.term^) - 3);
xt08new_line (d);
EntryCount   := xt08ord2a( d.buf^, d.bufpos);
d.bufpos     := d.bufpos + 2;
CurrentEntry := 1;
WHILE CurrentEntry <= EntryCount DO
    BEGIN
    xt08blank_line   (d);
    xt08put_ttfnTemp (d, 'file type   ');
    xt08skip_filler  (d, 1);
    xt08put_int      (d, 'level       ', 2);
    d.line_len := d.line_len + 8;
    xt08put_int      (d, 'sublevel    ', 4);
    xt08put_int      (d, 'index       ', 4);
    xt08skip_filler  (d, 4);
    xt08put_fileno   (d, 'instance fn '   );
    xt08new_line (d);
    CurrentEntry := succ( CurrentEntry );
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08dump_bd_record (VAR d : display_state_type;
            dumptype : integer);
 
VAR
      i           : integer;
      count       : integer;
      Header      : tsp00_Sname;
 
BEGIN
CASE dumptype OF
    d_b12svpct:
        BEGIN
        xt08put_header (d, t09window_lines(d.term^) - 3);
        xt08put_procid (d, 'coordinator '   );
        xt08put_bool   (d, 'svp_active  '   );
        xt08put_bool   (d, 'prepare DW  '   );
        xt08put_int    (d, 'FlushOrder  ', 1);
        xt08put_bool   (d, 'DW disabled '   )
        END;
    d_b12tdesc:
        BEGIN
        xt08put_header (d, t09window_lines(d.term^) - 3);
        count := s20buf_to_int4 (d.buf^, d.bufpos);
        xt08put_int    (d, 'num_data_wri', 4);
        xt08put_int    (d, 'suspend_cnt ', 4);
        xt08put_int    (d, 'last_data_io', 4);
        xt08put_int    (d, 'start_io_cnt', 4);
        xt08put_int    (d, 'cur_read_cnt', 4);
        xt08new_line   (d);
        xt08new_line   (d);
        FOR i := 1 TO count DO
            BEGIN
            xt08put_int     (d, 'dtd_index   ', 4);
            xt08put_procid  (d, 'dtd_pid     ');
            xt08put_bool    (d, 'dtd_active  ');
            xt08put_bool    (d, 'dtd_check_fb');
            xt08put_addr    (d, 'dtd_cache_pt');
            xt08new_line    (d)
            END
        (*ENDFOR*) 
        END;
    d_b20bufco:
        BEGIN
        (*++++ bufcount ++++++++*)
        xt08put_header (d, 2);
        xt08put_int    (d, 'buffer_count', 4)
        END;
    d_b20regio:
        BEGIN
        (*++++ no of datacache regions ++++++++*)
        xt08put_header (d, 2);
        xt08put_int    (d, 'datacache no', 4)
        END;
    (* *)
    d_b20hdlis:
        xt08put_hdlist (d, true);
    (* *)
    d_b20hdlfo:
        xt08put_hdlist (d, false);
    (* *)
    d_b20cbloc, d_b20cblfo :
        xt08put_cblocks (d);
    (* *)
    d_b20quele, d_b20qufol :
        xt08put_b20_queue_elems (d);
    (* *)
    d_b20vars:
        BEGIN
        (*++++b20vars++++++++*)
        xt08put_header (d, t09window_lines(d.term^) - 3);
        xt08put_int  (d, 'SegmentId   ', 4);
        xt08put_int  (d, 'SegmentSize ', 4);
        xt08put_addr (d, 'First CB    '   );
        xt08put_addr (d, 'Last CB     '   );
        xt08put_addr (d, 'First LRU   '   );
        xt08put_addr (d, 'Last LRU    '   );
        xt08new_line (d);
        xt08put_addr (d, 'LRU Mid     '   );
        xt08put_addr (d, 'IO Mid      '   );
        xt08put_addr (d, 'FreeList    '   );
        xt08put_addr (d, 'FrameLessCBs'   );
        xt08new_line (d);
        xt08put_int  (d, 'FreeCnt     ', 4);
        xt08put_int  (d, 'FrameLessCnt', 4);
        xt08put_int  (d, 'HeadListSize', 4);
        xt08put_int  (d, 'SVP Elems   ', 4);
        xt08put_int  (d, 'clustSVPElem', 4);
        xt08put_int  (d, 'IO Elems    ', 4);
        xt08put_int  (d, 'clustIOElems', 4);
        xt08put_int  (d, 'SVP Sync Cnt', 4);
        xt08put_int  (d, 'Old Occupant', 4);
        xt08put_int  (d, 'IOAreaSize  ', 4);
        xt08put_int  (d, 'RecAreaSize ', 4);
        xt08put_int  (d, 'IOAreaFlsBy ', 4);
        xt08put_int  (d, 'RecAreaFlsBy', 4);
        xt08new_line (d);
        xt08put_int  (d, 'UndoPageCnt ', 4);
        xt08put_int  (d, 'OmsDataCnt  ', 4);
        xt08put_int  (d, 'SqlDataCnt  ', 4);
        xt08new_line (d);
        xt08put_addr (d, 'IO QHead1   '   );
        xt08put_addr (d, 'IO Qhead2   '   );
        xt08put_addr (d, 'IO QTail1   '   );
        xt08put_addr (d, 'IO QTail2   '   );
        xt08put_addr (d, 'IO CLQHead1 '   );
        xt08put_addr (d, 'IO CLQhead2 '   );
        xt08put_addr (d, 'IO CLQTail1 '   );
        xt08put_addr (d, 'IO CLQTail2 '   );
        xt08put_addr (d, 'Overflow Que'   );
        xt08put_addr (d, 'SVP-End Queu'   );
        xt08put_addr (d, 'Queue Head  '   );
        xt08put_addr (d, 'Queue Free  '   );
        xt08new_line (d);
        xt08put_bool (d, 'Buf Active  '   );
        xt08put_bool (d, 'SVP Active  '   );
        xt08put_bool (d, 'Prevent Sync'   );
        xt08put_bool (d, 'IO Switch   '   );
        xt08put_bool (d, 'MemProtect  '   );
        xt08put_bool (d, 'PreventIO   '   );
        END;
    d_b20all:
        BEGIN
        (*++++ b20all ++++++++*)
        xt08put_header (d, t09window_lines(d.term^) - 3);
        xt08put_int    (d, 'NextShrinkSe', 4);
        xt08put_int    (d, 'TotalIOCnt  ', 4);
        END;
&   ifdef NOTUSED
    d_b22undef:
        xt08put_header (d, 1);
    d_b22vars:
        BEGIN
        (*++++ bd22Glob ++++++++*)
        xt08put_header (d, t09window_lines(d.term^) - 3);
        xt08put_int    (d, 'bd22hmSize  ', 4);
        xt08put_int    (d, 'bd22hmUsed  ', 4);
        (* bd22hmHashes *)
        d.bufpos := d.bufpos + MAX_OBJ_FILE_NO_GG92 * 4;
        (* bd22hmHashIsUsable *)
        d.bufpos := d.bufpos + (MAX_OBJ_FILE_NO_GG92 DIV 8) + 1;
        (* *)
        xt08put_int    (d, 'bd22hmObject', 4);
        xt08put_int    (d, 'bd22hmFreeHa', 4);
        (* *)
        xt08put_int    (d, 'Tot Free Ele', 4);
        END;
    d_b22hash_desc:
        BEGIN
        (*++++ tbd22_HashDesc ++++++++*)
        xt08put_header (d, t09window_lines(d.term^) - 3);
        (* *)
        xt08put_int    (d, 'bd22hdArrayS', 4);
        xt08put_int    (d, 'bd22hdElemCo', 4);
        (* *)
        xt08put_int    (d, 'bd22hdArray ', 4);
        END;
    d_b22hash_elem:
        BEGIN
        (*++++ tbd22_HashElem ++++++++*)
        xt08put_header (d, t09window_lines(d.term^) - 3);
        (* *)
        xt08put_int    (d, 'ElementPtr  ', 4);
        xt08put_int    (d, 'ClassId     ', 4);
        xt08put_int    (d, 'HashIndex   ', 4);
        (* *)
        xt08put_oid    (d, 'OID         '   );
        (* *)
        xt08put_int    (d, 'bd22heIdent ', 4);
        xt08put_int    (d, 'bd22heNext  ', 4);
        END;
&   endif
    d_b91vars:
        BEGIN
        xt08put_header (d, t09window_lines(d.term^) - 3);
        (* *)
        xt08put_int    (d, 'NumGarbColl ', 4);
        xt08put_int    (d, 'NumUsed     ', 4);
        xt08put_int    (d, 'NumReqToRelP', 4);
        xt08put_procid (d, 'StopGC TId  ');
        xt08put_bool   (d, 'StopAllGC   ');
        xt08put_bool   (d, 'SPV Activ   ');
        xt08put_bool   (d, 'PrepTruncate');
        IF  d.cur_column = 2
        THEN
            (* flush last line *)
            xt08out_col_line (d)
                  (* *)
        (*ENDIF*) 
        END;
    d_b91gc_state:
        IF  utds_full_info in d.scan (* JA 2000-03-15 *)
        THEN
            BEGIN
            xt08put_header (d, t09window_lines(d.term^) - 3);
            count := s20buf_to_int4 (d.buf^, d.bufpos);
            d.bufpos := d.bufpos + 4 ;
            Header := 'Task        ';
            FOR i := 1 TO count DO
                BEGIN
                xt08conditional_newscreen (d, 3);
                d.disp_line := d.term^.blankline;
                SAPDB_PascalForcedMove (sizeof (Header), sizeof (d.disp_line),
                      @Header, 1, @d.disp_line, 1, sizeof (Header));
                g17int4to_line (i, c_pad_with_zero, 4, 6, d.disp_line);
                d.disp_line [15] := ':';
                xt08output_line (d);
                xt08put_procid (d, 'cgcTaskId   ');
                xt08put_bool   (d, 'cgcActive   ');
                IF  d.cur_column = 2
                THEN
                    (* flush last line *)
                    xt08out_col_line (d)
                (*ENDIF*) 
                END
            (*ENDFOR*) 
            END
        ELSE
            d.bufpos := d.bufsize; (* no more dump recs *)
        (*ENDIF*) 
    d_b930HistDir:
        IF  utds_full_info in d.scan (* JA 2000-03-15 *)
        THEN
            xt08put_GCHistoryDir (d)
        ELSE
            d.bufpos := d.bufsize; (* no more dump recs *)
        (*ENDIF*) 
    OTHERWISE
        d.bufpos := d.bufsize; (* no more dump recs *)
    END;
(*ENDCASE*) 
xt08new_line (d);
(* flushing line buffer with last item *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08dump_g01 (VAR d : display_state_type;
            dumptype      : integer);
 
VAR
      aux_scan : tut_diag_scan;
 
BEGIN
aux_scan := d.scan;
d.scan   := d.scan + [utds_minbuf];
CASE dumptype OF
    d_g01vars:
        BEGIN
        xt08put_header (d, t09window_lines(d.term^) - 3);
        (* *)
        xt08put_int    (d, 'ctype       ', 1); (* g01code *)
        xt08put_int    (d, 'char_default', 1);
        xt08put_int    (d, 'date_time   ', 1);
        xt08put_int    (d, 'kernel_swap ', 1);
        (* *)
        xt08put_int    (d, 'commit_delay', 2);
        xt08put_site   (d, 'local_site  '   );
        xt08put_site   (d, 'max_site    '   );
        xt08skip_filler(d, 1);
        xt08put_bool   (d, 'stand_alone '   );
        xt08put_bool   (d, 'sysaccount  '   );
        xt08put_bool   (d, 'diagparse_on'   );
        xt08put_bool   (d, 'updstat     '   );
        (* *)
        xt08put_int    (d, 'timeout.Cmd ', 4); (* g01timeout *)
        xt08put_int    (d, 'timeout.Req ', 4);
        (* *)
        xt08skip_filler(d, 1);
        END;
    d_g01glob:
        BEGIN
        xt08put_header (d, t09window_lines(d.term^) - 3);
        xt08put_int    (d, 'timezone    ', 4);
        xt08put_int    (d, 'vf_bufpool  ', 4);
        (* *)
        xt08put_surro  (d, 'sysuser_id  ');
        (* *)
        xt08put_hex    (d, 'rescnt_undef', sizeof(tsp00_ResNum));
        xt08put_bool   (d, 'cache_check ');
        (* *)
        xt08put_hex    (d, 'rescnt_1    ', sizeof(tsp00_ResNum));
        xt08put_bool   (d, 'sysmsg_exist');
        (* *)
        xt08put_hex    (d, 'rescnt_0    ', sizeof(tsp00_ResNum));
        xt08put_bool   (d, 'is_for_sapr3');
        (* *)
        xt08put_char   (d, 'sysuser_name', sizeof (tsp00_KnlIdentifier));
        (* *)
        xt08put_bool   (d, 'tree_check  ');
        xt08new_line   (d);
        xt08put_bool   (d, 'bd_lockcheck');
        xt08put_bool   (d, 'bd_subtree  ');
        xt08new_line   (d);
        xt08put_int    (d, 'InstanceType', 1);
        xt08put_bool   (d, 'TransProcEna');
        xt08put_hex    (d, 'undef_buf   ', 1);
        xt08skip_filler(d, 2);
        (* *)
        xt08put_addr   (d, 'undef_addr  ')
        END;
    d_g01pid:
        BEGIN
        xt08put_header (d, t09window_lines(d.term^) - 3);
        xt08put_procid (d, 'TraceWriter ');
        END;
    d_g01tabid:
        BEGIN
        xt08put_header (d, t09window_lines(d.term^) - 3);
        xt08put_treeid (d, 'SYS1 CATALOG');
        xt08put_treeid (d, 'SYS2 CATALOG');
        (*                                    SAVELOG INFO removed: JA 2000-03-30 *)
        xt08put_treeid (d, 'SYSDIAGPARSE');
        xt08put_treeid (d, 'SYS MSG     ');
        xt08put_treeid (d, 'OBJ HASH    '); (* PTS 1103799 1999-08-30 *)
        xt08put_treeid (d, 'SYSCMD_ANALY');
        xt08put_treeid (d, 'SYSDATA_ANAL');
        END;
    d_g01vtrce:
        BEGIN
        xt08put_header  (d, t09window_lines(d.term^) - 3);
        xt08put_bool    (d, 'vtrAk       ');
        xt08put_bool    (d, 'vtrAkDelete ');
        xt08put_bool    (d, 'vtrAkInsert ');
        xt08put_bool    (d, 'vtrAkPacket ');
        xt08put_bool    (d, 'vtrAkSelect ');
        xt08put_bool    (d, 'vtrAkShortPa');
        xt08put_bool    (d, 'vtrAkUpdate ');
        xt08put_bool    (d, 'vtrAll      ');
        (* *)
        xt08put_bool    (d, 'vtrAny      ');
        xt08put_bool    (d, 'vtrBdIndex  ');
        xt08put_bool    (d, 'vtrBdPrim   ');
        xt08put_bool    (d, 'vtrBdString ');
        xt08put_bool    (d, 'vtrConsole  ');
        xt08put_bool    (d, 'vtrIoTrace  ');
        xt08put_bool    (d, 'vtrKbLock   ');
        xt08put_bool    (d, 'vtrStrategy ');
        (* *)
        xt08put_bool    (d, 'vtrTime     ');
        xt08put_bool    (d, 'vtrGateway  ');
        xt08put_bool    (d, 'vtrBdObject '); (* PTS 1103799 1999-08-30 *)
        xt08put_bool    (d, 'vtrOmsNew   ');
        xt08put_bool    (d, 'vtrOmsGet   ');
        xt08put_bool    (d, 'vtrOmsUpd   ');
        xt08put_bool    (d, 'vtrOmsFree  ');
        xt08skip_filler (d, 1);
        (* *)
        xt08put_bool    (d, 'vtrCheck    ');
        xt08put_bool    (d, 'vtrRetcodeCh');
        xt08put_int     (d, 'vtrStopRetco', 2);
        xt08put_session (d, 'vtrSession  ');
        END;
    (* PTS 1113051 E.Z. *)
    OTHERWISE
        d.bufpos := d.bufsize; (* no more dump recs *)
    END;
(*ENDCASE*) 
(* flushing line buffer with last item *)
xt08new_line (d);
d.scan := aux_scan
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08dump_g02 (VAR d : display_state_type;
            dumptype      : integer);
 
VAR
      aux_scan : tut_diag_scan;
 
BEGIN
aux_scan := d.scan;
d.scan   := d.scan + [utds_minbuf];
CASE dumptype OF
    d_g02tabs:
        BEGIN
        xt08put_header  (d, t09window_lines(d.term^) - 3);
        xt08put_codetab (d, 'to EBCDIC   ');
        xt08put_codetab (d, 'to ASCII    ');
        xt08put_codetab (d, 'up EBCDIC   ');
        xt08put_codetab (d, 'up ASCII    ');
        xt08put_codetab (d, 'to up EBCDIC');
        xt08put_codetab (d, 'to up ASCII ');
        xt08put_codetab (d, 'low EBCDIC  ');
        xt08put_codetab (d, 'low ASCII   ')
        END;
    d_g02cset:
        BEGIN
        xt08put_header  (d, t09window_lines(d.term^) - 3);
        xt08put_int     (d, 'cset_index  ', 2);
        xt08put_char    (d, 'cset_name   ', NAME_MXSP00);
        xt08put_int     (d, 'cset_messcod', 1);
        xt08put_int     (d, 'cset_code   ', 1);
        xt08put_codetab (d, 'charset     '   );
        xt08put_codetab (d, 'inv_charset '   )
        END;
    OTHERWISE
        d.bufpos := d.bufsize; (* no more dump recs *)
    END;
(*ENDCASE*) 
(* flushing line buffer with last item *)
xt08new_line (d);
d.scan := aux_scan
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08dump_header (VAR d : display_state_type;
            pagename   : tsp00_Sname;
            VAR msg_ln : tsp00_Line;
            msg_ln_len : integer);
 
CONST
      c_blockno_space = 20;
 
VAR
      err : integer;
      len : integer;
 
BEGIN
d.pfkey     := pf_none;
d.disp_line := d.term^.blankline;  (* initialize with blanks *)
d.line_len  := 0;
SAPDB_PascalForcedMove (sizeof (pagename), sizeof (d.disp_line),
      @pagename, 1, @d.disp_line, d.line_len+1, sizeof (pagename));
d.line_len := d.line_len + sizeof (pagename) + 1;
x05pageno_to_line (s20buf_to_int4 (d.buf^,1), c_trim, d.line_len, d.disp_line);
d.line_len := d.line_len + 3;
IF  msg_ln_len > 0
THEN
    BEGIN
    IF  d.line_len + msg_ln_len + c_blockno_space > sizeof (d.disp_line)
    THEN
        len := sizeof (d.disp_line) - d.line_len - c_blockno_space
    ELSE
        len := msg_ln_len;
    (*ENDIF*) 
    SAPDB_PascalForcedMove (sizeof (msg_ln), sizeof (d.disp_line), @msg_ln, 1,
          @d.disp_line, d.line_len+1, len);
    d.line_len := d.line_len + len
    END;
(* attaches hosfile-line-number to upper right side of screen *)
(*ENDIF*) 
x05blockno_to_line (d.file_pos, d.line_len, d.disp_line);
IF  NOT t09is_empty_window (d.term^)
THEN
    BEGIN
    IF  utds_full_info in d.scan
    THEN
        xt08conditional_newscreen (d, 3)
    ELSE
        xt08conditional_newscreen (d, 1)
    (*ENDIF*) 
    END;
(* perform formfeed + hold if not enough space on screen *)
(*ENDIF*) 
IF  d.pfkey = pf_none
THEN
    BEGIN
    (* write to protocol and display at terminal: *)
    t12write_prot (d.prot^, d.disp_line, d.line_len, err);
    t09put        (d.term^, d.disp_line, cut_bright_protected)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08dump1_kb_record (VAR d : display_state_type;
            dumptype : integer);
 
VAR
      i         : integer;
      blocksize : tsp00_Int2;
      n         : tsp00_Sname;
 
BEGIN
CASE dumptype OF
    d_k38undef, d_autoundef:
        xt08put_header (d, 1); (* no entries *)
    d_k38glob, d_autoglob:
        BEGIN
        xt08put_header  (d, t09window_lines(d.term^) - 3);
        xt08put_int     (d, 'pages_transf', 4);
        xt08put_int     (d, 'into_count  ', 4);
        (* *)
        xt08put_int     (d, 'out_count   ', 4);
        xt08put_int     (d, 'queue_into  ', 4);
        (* *)
        xt08put_int     (d, 'queue_out   ', 4);
        xt08put_int     (d, 'blocksize   ', 2);
        xt08put_int     (d, 'max_tasks   ', 2);
        (* *)
        xt08put_int     (d, 'num_devsp   ', 2);
        xt08put_int     (d, 'devsp_ready ', 2);
        xt08put_int     (d, 'num_tapes   ', 2);
        xt08put_int     (d, 'tapes_ready ', 2);
        (* *)
        xt08put_int     (d, 'tapes_start ', 2);
        xt08put_int     (d, 'conttape    ', 2);
        xt08put_int     (d, 'task_conttap', 2);
        xt08put_int     (d, 'queue_size  ', 2);
        (* *)
        xt08put_int     (d, 'q_first_free', 2);
        xt08put_int     (d, 'q_first_read', 2);
        xt08put_int     (d, 'q_last_read ', 2);
        xt08put_int     (d, 'read_waits  ', 2);
        (* *)
        xt08put_int     (d, 'write_waits ', 2);
        xt08put_kb3all  (d, 'system_state'   );
        xt08put_bool    (d, 'is_auto_load'   );
        xt08put_bool    (d, 'is_cold     '   );
        xt08put_mess    (d, 'msgtype     '   );
        xt08put_mess2   (d, 'msg2type    '   );
        xt08put_int     (d, 'vtr_directio', 1);
        (* *)
        xt08put_datestr (d, 'until   date'   );
        xt08put_timestr (d, 'until   time'   );
        (* *)
        xt08put_int     (d, 'until io_seq', 4);
        xt08put_int     (d, 'region_nr   ', 4);
        (* *)
        xt08put_int     (d, 'wait_pid    ', 4);
        xt08put_bool    (d, 'try_again   '   );
        xt08put_bool    (d, 'check_save  '   );
        xt08put_bool    (d, 'write_bm_pag'   );
        xt08put_bool    (d, 'write conv  '   );
        (* *)
        xt08put_int     (d, 'file_version', 4);
        xt08put_int     (d, 'q_locked    ', 2);
        xt08put_bool    (d, 'is_remote   '   );
        xt08put_bool    (d, 'perform_redo'   );
        (* *)
        (* *)
        xt08put_int     (d, 'last_lpno_wa', 4);
        xt08put_int     (d, 'eof_wait_pid', 4);
        (* *)
        xt08put_char    (d, 'media_name  ', sizeof (tgg00_MediaName));
        (* *)
        xt08put_char    (d, 'tape_label  ', sizeof (tsp00_C14)); (* UH 2004-09-27 *)
        xt08put_bool    (d, 'no_rel_log  '   );
        xt08skip_filler (d, 1);
        (* *)
        xt08put_int     (d, 'Coord.TaskId', 4); (* PTS 1134753 UH 2005-04-07 *)
        xt08skip_filler (d, 4);                 (* PTS 1134753 UH 2005-04-07 *)
        (* *)
        xt08put_char    (d, 'utilcmd_id  ', sizeof (tsp00_C12));
        xt08put_int     (d, 'utilcmd_lino', 4); (* PTS 1108625 UH 11-12-2000 *)
        (* *)
        IF  d.cur_column = 2
        THEN
            xt08new_line (d);
        (*ENDIF*) 
        d.bufpos := d.bufpos + 128 ; (* +++ check volumes +++ *)
        d.bufpos := d.bufpos + (32 * 4); (* trt_into_queue *)
        (* REMOTE IO *)
        FOR i := 1 TO MAX_TAPES_GG00 DO
            BEGIN
            IF  s20buf_to_int4 (d.buf^, d.bufpos + 8) <> cgg_nil_pid
            THEN
                BEGIN
                xt08put_int     (d, 'buffer size ', 4);
                xt08put_int     (d, 'buffer lengt', 4);
                xt08put_int     (d, 'pid waiting ', 4);
                d.bufpos := d.bufpos + 4;
                xt08put_addr8   (d, 'buffer ptr  '   )
                END
            ELSE
                d.bufpos := d.bufpos + 24;
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
        THEN
            BEGIN
            xt08conditional_newscreen (d, 11);
            d.disp_line := d.term^.blankline;
            d.line_len  := 0;
            d.vt_attr   := cut_bright_protected;
            g17sname_to_line ('STA_INFO    ', d.line_len, d.disp_line);
            xt08output_line (d);
            d.vt_attr := cut_protected
            END;
        (*ENDIF*) 
        xt08put_int       (d, 'pno         ', 4);
        xt08put_pagetype  (d, 'page_type   '   );
        xt08put_pagetype2 (d, 'page_type2  '   );
        xt08put_checktype (d, 'checktype   '   );
        d.bufpos := d.bufpos + 1;
        xt08put_mess      (d, 'mess_type   '   );
        xt08put_mess2     (d, 'mess2_type  '   );
        xt08put_hostinfo  (d);
        xt08put_addr8     (d, 'sta_task    '   );
        xt08put_addr8     (d, 'sta_tape    '   );
        xt08put_addr8     (d, 'sta_devsp   '   );
        xt08put_addr8     (d, 'sta_restartr'   );
        xt08put_addr8     (d, 'sta_queue   '   );
        xt08put_addr8     (d, 'sta_to_cance'   );
        xt08put_addr8     (d, 'sta_backup  '   );
        xt08put_addr8     (d, 'sta_vol_idx '   );
        END;
    d_k38task, d_autotask:
        BEGIN
        xt08put_header (d,                 4);
        xt08put_int    (d, 'task_index  ', 2);
        (**)
        xt08put_procid (d, 'task_pid    '   );
        d.bufpos := d.bufpos + 2;
        xt08put_int    (d, 'tape_index  ', 2);
        xt08put_int    (d, 'state       ', 1);
        xt08put_int    (d, 'task_kind   ', 1);
        d.bufpos := d.bufpos + 6
        END;
    d_k38tape, d_autotape:
        BEGIN
        xt08put_header (d,                 6);
        xt08put_int    (d, 'tape_index  ', 2);
        (**)
        xt08put_bool   (d, 'is_open     '   );
        xt08put_bool   (d, 'is_full     '   );
        xt08put_int    (d, 'volume_no   ', 2);
        xt08put_int    (d, 'fno         ', 4);
        (**)
        xt08put_int    (d, 'max_pages   ', 4);
        xt08put_int    (d, 'cnt_pages   ', 4);
        (**)
        xt08put_int    (d, 'xp_size     ', 4);
        xt08put_int    (d, 'xp_read     ', 4);
        (**)
        xt08put_int    (d, 'xp_pages    ', 4);
        xt08put_int    (d, 'tpd_type    ', 1);
        xt08put_bool   (d, 'check_destru'   );
        xt08put_int    (d, 'mirror_index', 2);
        (**)
        xt08put_int    (d, 'total_pages ', 4);
        xt08put_err    (d, 'tpd_err     '   );
        xt08put_bool   (d, 'is_replaced '   );
        xt08put_bool   (d, 'is_clustered'   );
        (**)
        xt08put_char   (d, 'tpd_name    ',64); (* original=256*)
        xt08put_char   (d, 'tpd_errtext ',40);
        END;
    d_k38devsp, d_autodevsp:
        BEGIN
        xt08put_header (d,                 5);
        xt08put_int    (d, 'devsp_index ', 2);
        xt08put_bool   (d, 'is_open     '   );
        d.bufpos := d.bufpos + 1;
        xt08put_int    (d, 'volume no   ', 2);
        xt08put_int    (d, 'fno         ', 4);
        END;
    d_k38queue, d_autoqueue:
        BEGIN
        xt08put_header (d, t09window_lines(d.term^) - 3);
        xt08put_int    (d, 'queue_index ', 2);
        xt08put_int    (d, 'sre_state   ', 1);
        xt08put_bool   (d, 'is_clustered'   );
        xt08put_int    (d, 'pages/block ', 2);
        xt08put_int    (d, 'sre_next    ', 2);
        xt08put_int    (d, 'sre_prev    ', 2);
        xt08put_int    (d, 'task_no_into', 2);
        xt08skip_filler(d, 6);
        xt08put_addr8  (d, 'sre_block   '   );
        IF  d.cur_column = 2
        THEN
            xt08new_line  (d);
        (*ENDIF*) 
        blocksize := s20buf_to_int4 (d.buf^, d.bufpos);
        d.bufpos := d.bufpos + 4;
        END;
    d_k51undef:
        xt08put_header (d, 1); (* no entries *)
    d_k51glob:
        xt08_k51glob (d);
    d_k51lock:
        xt08_k51lock (d);
    d_k51trans:
        xt08_k51trans (d);
    d_k51entry:
        xt08_k51trans_entry (d);
    d_k51tabtr:
        BEGIN
        xt08put_header   (d, t09window_lines(d.term^) - 3);
        xt08put_addr     (d, 'TAB TRANS   '   );
        xt08put_int      (d, 'ttItemKind  ', 1);
        xt08put_bool     (d, 'ttExtentItem'   );  (* PTS 1105492 JA 2000-03-15 *)
        xt08put_int      (d, 'ttChkOwnRgn ', 1);
        xt08put_int      (d, 'ttChkTrnsIdx', 1);
        xt08put_procid   (d, 'ttChkTaskId '   );
        (* *)
        xt08put_surro    (d, 'ttTabId     '   );  (* PTS 1105492 JA 2000-03-15 *)
        (* *)
        xt08put_addr     (d, 'ttTab       '   );
        xt08put_addr     (d, 'ttFirstRow  '   );
        (* *)
        xt08put_addr     (d, 'ttConsistRow'   );
        xt08put_addr     (d, 'ttNextTab   '   );
        (* *)
        xt08put_lockmode (d, 'ttLockMode  '   );
        xt08put_any_set  (d, 'ttLockState ', set_lock_state);
        xt08put_lockmode (d, 'ttReqMode   '   );
        xt08put_any_set  (d, 'ttReqState  ', set_lock_state);
        xt08put_bool     (d, 'ttKeySort   '   );  (* PTS 1107056 JA 2001-03-01 *)
        xt08skip_filler  (d, 1);
        xt08put_int      (d, 'ttTabRegion ', 2);
        (* *)
        xt08put_int      (d, 'ttTabHash   ', 4);
        xt08put_int      (d, 'ttRowShare  ', 4);
        (* *)
        xt08put_int      (d, 'ttRowOptmCnt', 4);
        xt08put_int      (d, 'ttRowExclLck', 4);
        END;
    d_k51rowtr:
        BEGIN
        xt08put_header   (d, t09window_lines(d.term^) - 3);
        xt08put_addr     (d, 'ROW TRANS   '   );
        xt08put_int      (d, 'rtItemKind  ', 1);
        xt08put_bool     (d, 'rtExtentItem'   );   (* PTS 1105492 JA 2000-03-15 *)
        xt08put_int      (d, 'rtChkOwnRgn ', 1);
        xt08put_int      (d, 'rtChkTrnsIdx', 1);
        xt08put_procid   (d, 'rtChkTaskId '   );
        (* *)
        xt08put_addr     (d, 'rtRowLock   '   );
        xt08put_addr     (d, 'rtNextRow   '   );
        (* *)
        xt08put_addr     (d, 'rtPrevRow   '   );
&       ifdef BIT64
&       else
        xt08skip_filler  (d, sizeof (tsp00_Addr)); (* PTS 1105492 JA 2000-03-15 *)
&       endif
        (* *)
        xt08put_hex      (d, 'rtShortKey  ',10);
        xt08put_int      (d, 'rtKeyLen    ', 2);
        xt08put_lockmode (d, 'rtLockMode  '   );
        xt08put_any_set  (d, 'rtLockState ', set_lock_state);
        xt08put_lockmode (d, 'rtReqMode   '   );
        xt08put_any_set  (d, 'rtReqState  ', set_lock_state);
        (* *)
        xt08put_int      (d, 'rtRowRegion ', 2);
        xt08skip_filler  (d, 2);
        xt08put_int      (d, 'rtRowHash   ', 4);
        (* *)
        xt08put_int      (d, 'rtRowOptVers', 4);
        xt08put_int      (d, 'rtTabOptVers', 4)
        END;
    d_k51tab:
        BEGIN
        xt08put_header  (d, t09window_lines(d.term^) - 3);
        xt08put_addr    (d, 'TAB LOCK    '   );
        xt08put_int     (d, 'tlItemKind  ', 1);
        xt08put_bool    (d, 'tlExtentItem'   );   (* PTS 1105492 JA 2000-03-15 *)
        xt08put_int     (d, 'tlChkOwnRgn ', 1);
        xt08put_int     (d, 'tlChkTrnsIdx', 1);
        xt08put_procid  (d, 'tlChkTaskId '   );
        (* *)
        xt08put_surro   (d, 'tlTabId     '   );   (* PTS 1105492 JA 2000-03-15 *)
        (* *)
        xt08put_addr    (d, 'tlNextHshTab'   );
        xt08put_addr    (d, 'tlFrstReqTab'   );
        (* *)
        xt08put_addr    (d, 'tlFrstReqRow'   );
&       ifdef BIT64
&       else
        xt08skip_filler (d, sizeof (tsp00_Addr)); (* PTS 1105492 JA 2000-03-15 *)
&       endif
        (* *)
        xt08put_bool    (d, 'tlIsSysExcl '   );
        xt08skip_filler (d, 1);
        xt08put_int     (d, 'tlExclTrIdx ', 2);
        xt08put_int     (d, 'tlShare1Trns', 2);
        xt08put_int     (d, 'tlShare2Trsn', 2);
        (* *)
        xt08put_int     (d, 'tlSysShareL ', 4);   (* PTS 1105492 JA 2000-03-15 *)
        xt08put_int     (d, 'tlTabShareL ', 4);   (* PTS 1105492 JA 2000-03-15 *)
        (* *)
        xt08put_int     (d, 'tlTabOptVers', 4);
        xt08put_int     (d, 'tlRowShareL ', 4);
        (* *)
        xt08put_int     (d, 'tlRowOptCnt ', 4);
        xt08put_int     (d, 'tlRowExclLck', 4)
        END;
    d_k51row:
        BEGIN
        xt08put_header  (d, t09window_lines(d.term^) - 3);
        xt08put_addr    (d, 'ROW LOCK    '   );
        xt08put_int     (d, 'rlItemKind  ', 1);
        xt08put_bool    (d, 'rlExtentItem'   );   (* PTS 1105492 JA 2000-03-15 *)
        xt08put_int     (d, 'rlChkOwnRgn ', 1);
        xt08put_int     (d, 'rlChkTrnsIdx', 1);
        xt08put_procid  (d, 'rlChkTaskId '   );
        (* *)
        xt08put_surro   (d, 'rlTabId     '   );   (* PTS 1105492 JA 2000-03-15 *)
        (* *)
        xt08put_addr    (d, 'rlNextHshRow'   );
        xt08put_addr    (d, 'rlRowIdItem '   );
        (* *)
        xt08put_addr    (d, 'rlFrstReqRow'   );
&       ifdef BIT64
&       else
        xt08skip_filler (d, sizeof (tsp00_Addr)); (* PTS 1105492 JA 2000-03-15 *)
&       endif
        (* *)
        xt08put_hex     (d, 'rlShortKey  ',10);
        xt08put_int     (d, 'rlKeyLen    ', 2);
        xt08put_int     (d, 'rlExclTrIdx ', 2);
        xt08put_any_set (d, 'rlLockState ', set_lock_state); (* PTS 1115302 UH 2002-05-02 *)
        xt08skip_filler (d, 1);                               (* PTS 1115302 UH 2002-05-02 *)
        (* *)
        xt08put_int     (d, 'rlRowShareL ', 4);
        xt08put_int     (d, 'rlRowOptCnt ', 4);
        (* *)
        xt08put_int     (d, 'rlRowOptVers', 4);
        xt08put_int     (d, 'rlShare1Trns', 2);
        xt08put_int     (d, 'rlShare2Trns', 2)
        END;
    d_k51rowid:
        xt08_k51rowid (d);
    d_k51req:
        BEGIN
        xt08put_header   (d, t09window_lines(d.term^) - 3);
        xt08put_addr     (d, 'REQUEST     '   );
        xt08put_int      (d, 'rqItemKind  ', 1);
        xt08put_bool     (d, 'rqExtentItem'   );   (* PTS 1105492 JA 2000-03-15 *)
        xt08put_int      (d, 'rqChkOwnRgn ', 1);
        xt08put_int      (d, 'rqChkTrnsIdx', 1);
        xt08put_procid   (d, 'rqChkTaskId '   );
        (* *)
        xt08put_addr     (d, 'rqNextReq   '   );
        xt08put_addr     (d, 'rqPrevReq   '   );
        (* *)
        xt08put_addr     (d, 'rqLastReq   '   );
&       ifdef BIT64
&       else
        xt08skip_filler  (d, sizeof (tsp00_Addr)); (* PTS 1105492 JA 2000-03-15 *)
&       endif
        (* *)
        xt08put_int      (d, 'rqTransIndex', 2);
        xt08put_bool     (d, 'rqEotWanted '   );
        xt08put_lockmode (d, 'rqReqMode   '   );
        xt08put_lockmode (d, 'rqLockMode  '   );
        xt08put_int      (d, 'rqTrLockMode', 1);
        xt08skip_filler  (d, 2);
        (* *)
        xt08put_int      (d, 'rqRowShareL ', 4);
        xt08put_int      (d, 'rqRowExclLck', 4)
        END;
    d_k51hash, d_k51hstab, d_k51hsrow:
        xt08put_hashlist (d);
    d_k51cnsis:
        BEGIN
        xt08put_header  (d, t09window_lines(d.term^) - 3);
        xt08put_addr    (d, 'CONSIST TRNS'   );
        xt08put_int     (d, 'cstItemKind ', 1);
        xt08put_bool    (d, 'cstExtntItem'   );  (* PTS 1105492 JA 2000-03-15 *)
        xt08put_int     (d, 'cstChkOwnRgn', 1);
        xt08put_int     (d, 'cstChkTrsIdx', 1);
        xt08put_procid  (d, 'cstChkTaskId'   );
        (* *)
        xt08put_surro   (d, 'cstView/hex '   );  (* PTS 1105492 JA 2000-03-15 *)
        d.bufpos := d.bufpos - sizeof (tgg00_Surrogate);
        xt08put_site    (d, 'cstViewNo.i2'   );  (* PTS 1105492 JA 2000-03-15 *)
        xt08put_trans   (d, 'cstViewNo.Id'   );  (* PTS 1105492 JA 2000-03-15 *)
        (* *)
        xt08put_addr    (d, 'cstNextHash '   );
        xt08put_addr    (d, 'cstNextCsist'   );
        (* *)
        xt08put_addr    (d, 'cstPrevCsist'   );
        xt08put_addr    (d, 'cstFstOpenTr'   );
        (* *)
        xt08put_int     (d, 'cstStartDate', 4);  (* PTS 1120151 FF 2003-01-29 *)
        xt08put_int     (d, 'cstStartTime', 4);
        xt08put_int     (d, 'cstTimeout  ', 4);  (* PTS 1105492 JA 2000-03-15 *)
        xt08put_bool    (d, 'cstCancelled'   );  (* PTS 1120151 FF 2003-01-29 *)
        xt08put_bool    (d, 'cstInWork   '   );  (* PTS 1120151 FF 2003-01-29 *)
        (* xt08skip_filler (d, 2);                  PTS 1120151 FF 2003-01-29 *)
        xt08put_trans   (d, 'cstCreatorTr'   );  (* PTS 1125503 FF 2003-12-03 *)
        (* *)
        xt08put_trans   (d, 'cstMinOpenTr'   );
        xt08put_int     (d, 'cstCurrTrIdx', 2);
        xt08put_int     (d, 'cstStartClkS', 4);
        xt08put_bool    (d, 'cstOmsVers  ');
        END;
    d_k51opent:
        BEGIN
        (* PTS 1105492 JA 2000-03-15 *)
        xt08put_header  (d, t09window_lines(d.term^) - 3);
        xt08put_addr    (d, 'OPEN TRANS  '   );
        xt08put_int     (d, 'openItemKind', 1);
        xt08put_bool    (d, 'openExtItem '   );
        xt08put_int     (d, 'openChkOwnRg', 1);
        xt08put_int     (d, 'openChkTrIdx', 1);
        xt08put_procid  (d, 'openChkTask '   );
        (* *)
        xt08put_addr    (d, 'openNext    '   );
        xt08put_addr    (d, 'openHashTr1 '   );
        (* *)
        xt08put_addr    (d, 'openHashTr2 '   );
        xt08put_addr    (d, 'openHashTr3 '   );
        (* *)
        xt08put_trans   (d, 'openTransId1'   );
        xt08put_trans   (d, 'openTransId2'   );
        xt08put_trans   (d, 'openTransId3'   );
        xt08put_int     (d, 'openHashRgn1', 2);
        xt08put_int     (d, 'openHashRgn2', 2);
        xt08put_int     (d, 'openHashRgn3', 2);
        (* *)
        xt08put_int     (d, 'openCount   ', 4);
        xt08skip_filler (d, 4)
        END;
    d_k51hopnt:
        BEGIN
        xt08put_header  (d, t09window_lines(d.term^) - 3);
        xt08put_addr    (d, 'HASH OPEN TR'   );
        xt08put_int     (d, 'hshItemKind ', 1);
        xt08put_bool    (d, 'hshExtntItem'   );   (* PTS 1105492 JA 2000-03-15 *)
        xt08put_int     (d, 'hshChkOwnRgn', 1);
        xt08put_int     (d, 'hshChkTrIdx ', 1);
        xt08put_procid  (d, 'hshChkTaskId'   );
        (* *)
        xt08put_surro   (d, 'hshTrans/hex'   );   (* PTS 1105492 JA 2000-03-15 *)
        d.bufpos := d.bufpos - sizeof (tgg00_Surrogate);
        xt08put_site    (d, 'hshTrans.i2 '   );   (* PTS 1105492 JA 2000-03-15 *)
        xt08put_trans   (d, 'hshTrans.Id '   );   (* PTS 1105492 JA 2000-03-15 *)
        (* *)
        xt08put_addr    (d, 'hshNextHash '   );
&       ifdef BIT64
&       else
        xt08skip_filler (d, sizeof (tsp00_Addr)); (* PTS 1105492 JA 2000-03-15 *)
&       endif
        (* *)
        xt08put_int     (d, 'hshUsedCnt  ', 4);
        xt08put_int     (d, 'hshHashValue', 4);
        xt08put_int     (d, 'hshNVUsedCnt', 4)
        END;
    d_k51ocoll:
        BEGIN
        (* PTS 1105492 JA 2000-03-15 *)
        xt08put_header  (d, t09window_lines(d.term^) - 3);
        xt08put_int     (d, 'objcOwnIndex', 2);
        xt08put_int     (d, 'objcFirstReq', 2);
        xt08put_int     (d, 'objcNextColl', 2);
        xt08put_int     (d, 'objcPrevColl', 2);
        (* *)
        xt08put_trans   (d, 'objcLckTrans'   );
        xt08put_int     (d, 'objcLckTrIdx', 2);
        (* *)
        xt08put_oid     (d, 'objcOid     '   );
        (* *)
        xt08put_int     (d, 'objcFileNo  ', 4);
        xt08skip_filler (d, 4)
        END;
    d_k51reqtr:
        BEGIN
        (* PTS 1105492 JA 2000-03-15 *)
        xt08put_header  (d, t09window_lines(d.term^) - 3);
        (* *)
        xt08put_trans   (d, 'objrReqTrans'   );
        xt08put_int     (d, 'objrOwnIdx  ', 2);
        (* *)
        xt08put_int     (d, 'objrColEntry', 2);
        xt08put_int     (d, 'objrNextReq ', 2);
        xt08put_procid  (d, 'objrWaitTask'   )
        END;
    d_k51shrlckcntrl:
        BEGIN
        (* PTS 1128244 FF 2004-05-17 *)
        xt08put_header  (d, t09window_lines(d.term^) - 3);
        xt08put_addr   (d, 'NxtShrLkCtrl'   );
        xt08put_addr   (d, 'ShareLock   '   );
        xt08put_oid    (d, 'Oid         '   );
        xt08put_int    (d, 'CollisionIdx', 2);
        xt08put_int    (d, 'ExclTrIdx   ', 2);
        xt08put_trans  (d, 'ExclTransNo '   );
        xt08put_int    (d, 'InUseWLCnt  ', 2);
        xt08put_bool   (d, 'ReleaseLocks'   );
        xt08skip_filler(d,  1);
        xt08put_int    (d, 'OwnIndex    ', 2);
        xt08put_int    (d, 'ObjFileId   ', 4);
        xt08skip_filler(d,  4);
        END;
    d_k51shrlock:
        BEGIN
        (* PTS 1128244 FF 2004-05-17 *)
        xt08put_header  (d, t09window_lines(d.term^) - 3);
        xt08put_addr   (d, 'NxtShrLock  '   );
        xt08put_trans  (d, 'ShareTransNo'   );
        xt08put_int    (d, 'ShareTrIdx  ', 2);
        xt08put_bool   (d, 'LockRollback'   );
        xt08skip_filler(d,  1);
        xt08skip_filler(d,  2);
        xt08skip_filler(d,  2);
        xt08put_int    (d, 'OwnIndex    ', 2);
        END;
    OTHERWISE
        d.bufpos := d.bufsize; (* no more dump recs *)
    END;
(*ENDCASE*) 
xt08new_line (d);
(* flushing line buffer with last item *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08dump2_kb_record (VAR d : display_state_type;
            dumptype : integer);
 
VAR
      i : integer;
 
BEGIN
CASE dumptype OF
    d_k57undef:
        xt08put_header (d, 1); (* no entry *)
    d_k57vars:
        BEGIN
        xt08put_header (d, 3);
        xt08put_bool   (d, 'surrog_upd  '   );
        xt08put_bool   (d, 'surrog_loggi'   );
        xt08skip_filler(d, 2);
        xt08put_int    (d, 'lru_timestmp', 4);
        (* *)
        xt08put_cnt    (d, 'seq_hit     '   ); (* PTS 1103799 JA 1999-08-30 *)
        xt08put_cnt    (d, 'seq_miss    '   ); (* PTS 1103799 JA 1999-08-30 *)
        (* *)
        xt08put_addr   (d, 'seq         '   );
        xt08put_addr   (d, 'seq_free    '   );
        xt08put_addr   (d, 'seq_log     '   );
        FOR i := 0 TO 97 DO
            BEGIN
            xt08put_addr   (d, 'sqh_first   '   );
            xt08put_addr   (d, 'sqh_last    '   );
            END;
        (*ENDFOR*) 
        END;
    d_k90undef:
        xt08put_header (d, 1); (* no entry *)
    d_k90glob:
        BEGIN
        (* PTS 1104043 JA 1999-10-08 *)
        xt08put_header (d,                11);
        xt08put_addr   (d, 'glParentList'   );
        xt08put_addr   (d, 'glServerList'   );
        (* *)
        xt08put_addr   (d, 'glFirstSvJob'   );
        xt08put_addr   (d, 'glLastSvJob '   );
        (* *)
        xt08put_addr   (d, 'glParentFree'   );
        xt08put_addr   (d, 'glParentHash'   );
        (* *)
        xt08put_int    (d, 'glParentMax ', 4);
        xt08put_int    (d, 'glTimeClear ', 4);
        (* *)
        xt08put_int    (d, 'glSvBusyCnt ', 2);    (* PTS 1105291 JA 2000-01-07 *)
        xt08put_int    (d, 'glSvReserved', 2);    (* PTS 1105291 JA 2000-01-07 *)
        xt08put_int    (d, 'glSvFrstIdle', 2);
        xt08put_int    (d, 'glSvStatCnt ', 2);
        (* *)
        xt08put_cnt    (d, 'glSvCallCnt '   );    (* PTS 1103799 JA 1999-08-30 *)
        (* *)
        xt08put_procid (d, 'glDropTask  '   );    (* PTS 1105291 JA 2000-01-07 *)
        xt08put_int    (d, 'glDropReqCnt', 4);    (* PTS 1105291 JA 2000-01-07 *)
        END;
    d_k90cache:
        BEGIN
        (* PTS 1104043 JA 1999-10-08 *)
        xt08put_header (d,                 4);
        xt08put_addr   (d, 'mcMdescList '   );
        xt08put_addr   (d, 'mcMdescFree '   );
        (* *)
        xt08put_addr   (d, 'mcMbodyList '   );
        xt08put_addr   (d, 'mcMbodyFree '   );
        (* *)
        xt08put_int    (d, 'mcMdescMax  ', 4);
        xt08put_int    (d, 'mcMdescCnt  ', 4);
        (* *)
        xt08put_int    (d, 'mcMbodyCnt  ', 4);
        xt08skip_filler(d, 4);
        END;
    d_k90mdesc:
        BEGIN
        (* PTS 1104043 JA 1999-10-08 *)
        xt08put_header (d,                 9);
        xt08put_int    (d, 'index       ', 2);
        xt08put_addr   (d, 'addr        '   );
        (*-----*)
        xt08put_addr   (d, 'mdMessBody  '   );
        xt08put_addr   (d, 'mdNext      '   );
        (* *)
        xt08put_int    (d, 'mdTrnsferLen', 4); (* PTS 1000395 UH *)
        xt08put_procid (d, 'mdParentTask'   ); (* PTS 1000395 UH *)
        (* *)
        xt08put_int    (d, 'mdCommState ', 1);
        xt08skip_filler(d, 7);
        (* *)
        xt08put_remote_mhead (d);
        xt08skip_filler(d, 128); (* skip short_messbuf *)
        END;
    d_k90mbody:
        BEGIN
        (* PTS 1104043 JA 1999-10-08 *)
        xt08put_header (d,                 7);
        xt08put_int    (d, 'index       ', 2);
        xt08put_addr   (d, 'addr        '   );
        (*-----*)
        xt08put_addr   (d, 'mbyBuf      '   );
        xt08put_addr   (d, 'mbyNext     '   );
        (* *)
        xt08put_int    (d, 'mbyBufLen   ', 4);
        xt08put_int    (d, 'mbyBufSsize ', 4)
        END;
    d_k90parent:
        BEGIN
        (* PTS 1104043 JA 1999-10-08 *)
        xt08put_header (d, 6);
        xt08put_int    (d, 'index       ', 2);
        xt08put_addr   (d, 'addr        '   );
        (*-----*)
        xt08put_addr   (d, 'prMdescFirst'   );
        xt08put_addr   (d, 'prNext      '   );
        (* *)
        xt08put_procid (d, 'prTaskId    '   );
        xt08put_bool   (d, 'prRcvWaiting'   );
        xt08put_int    (d, 'prRcvTimeout', 1);
        xt08put_int    (d, 'prHashIndex ', 2);
        (*-----*)
        xt08put_addr   (d, 'hash        '   )
        END;
    d_k90serv :
        BEGIN
        (* PTS 1104043 JA 1999-10-08 *)
        xt08put_header (d,                 5);
        xt08put_int    (d, 'index       ', 2);
        xt08put_addr   (d, 'addr        '   );
        (*-----*)
        xt08put_addr   (d, 'svMdesc     '   );
&       ifdef BIT64
&       else
        xt08skip_filler(d, sizeof (tsp00_Addr));
&       endif
        xt08put_procid (d, 'svTaskId    '   );
        xt08put_int    (d, 'svNextIdle  ', 2);
        xt08put_bool   (d, 'svRemovable '   );
        xt08skip_filler(d, 1);
        (* *)
        xt08put_int    (d, 'svTimeout   ', 4);
        xt08skip_filler(d, 4)
        END;
    OTHERWISE
        d.bufpos := d.bufsize; (*no more dump recs*)
    END;
(*ENDCASE*) 
xt08new_line (d);
(* flushing line buffer with last item *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08_DumpDataAccess(
            VAR d    : display_state_type;
            dumptype : integer);
 
VAR
      is_ln3        : boolean;
      bIsPerm       : boolean;
      bIsDynamic    : boolean;
      i             : tsp00_Int2;
      EntryCount    : tsp00_Int2;
      partitionCnt  : tsp00_Int4;
      CurrentEntry  : tsp00_Int4;
      FDirEntryType : tsp00_Int4;
      indexCount    : tsp00_IntMapC2;
      ln2           : tsp00_Line;
      ln3           : tsp00_Line;
      fn            : tgg00_Filename;
 
BEGIN
CASE dumptype OF
    d_ConvManager :
        BEGIN
        xt08put_header (d, t09window_lines(d.term^) - 3);
        xt08skip_filler(d, 2); (* skip internal counter *)
        xt08put_int    (d, 'ConvVersion ', 4);
        xt08put_int    (d, 'RootDevNo   ', 4);
        xt08put_int    (d, 'RootBlockNo ', 4);
        xt08put_int    (d, 'PermUsed    ', 4);
        xt08put_int    (d, 'TempUsed    ', 4);
        xt08put_int    (d, 'DB Pages    ', 4);
        xt08put_int    (d, 'SnapShotPage', 4);
        xt08put_int    (d, 'BkUpDataPage', 4);
        xt08put_int    (d, 'BkUpStatConv', 4);
        xt08put_int    (d, 'BkUpDynConv ', 4);
        xt08put_int    (d, 'PermConvPage', 4);
        xt08put_int    (d, 'TempConvPage', 4);
        xt08put_int    (d, 'BlockingSize', 4);
        xt08put_bool   (d, 'ConvIsActive'   );
        xt08put_bool   (d, 'SP IsActive '   );
        xt08put_bool   (d, 'SD IsActive '   );
        xt08put_bool   (d, 'RD IsActive '   );
        xt08put_bool   (d, 'RP IsActive '   );
        xt08put_bool   (d, 'CV IsActive '   );
        END;
    d_ConvMapSection:
        BEGIN
        xt08put_header (d, t09window_lines(d.term^) - 3);
        EntryCount   := xt08ord2a( d.buf^, d.bufpos);
        d.bufpos     := d.bufpos + 2;
        CurrentEntry := 1;
        WHILE CurrentEntry <= EntryCount DO
            BEGIN
            xt08conditional_newscreen (d, 13);
            bIsDynamic := ord (d.buf^[d.bufpos])   = 1;
            bIsPerm    := ord (d.buf^[d.bufpos+1]) = 1;
            d.bufpos   := d.bufpos + 4;
            IF  NOT bIsPerm
            THEN
                xt08put_int (d, 'Temp Section', 4)
            ELSE
                IF  bIsDynamic
                THEN
                    xt08put_int (d, 'Perm Section', 4)
                ELSE
                    xt08put_int (d, 'Stat Section', 4);
                (*ENDIF*) 
            (*ENDIF*) 
            xt08put_int (d, 'RegionId    ', 4);
            xt08put_int (d, 'HeadUnused  ', 4);
            xt08put_int (d, 'HeadPartUsed', 4);
            xt08put_int (d, 'HeadFullUsed', 4);
            xt08put_int (d, 'UsedDataPage', 4);
            xt08put_int (d, 'MaxUsedEntry', 4);
            IF  NOT bIsPerm
            THEN
                xt08skip_filler(d, 12)
            ELSE
                BEGIN
                xt08put_bool   (d, 'SVP IsActive'   );
                xt08put_bool   (d, 'Last SD Succ'   );
                xt08put_int    (d, 'Pending I/O ', 2);
                xt08put_int    (d, 'UpdPages    ', 4);
                xt08put_int    (d, 'PendingUpd  ', 4);
                END;
            (*ENDIF*) 
            xt08new_line   (d);
            CurrentEntry := succ( CurrentEntry );
            IF  CurrentEntry <= EntryCount
            THEN
                BEGIN
                d.disp_line := d.term^.blankline;
                xt08output_line (d)
                END
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        END;
    d_ConvMapEntry:
        BEGIN
        xt08put_header (d, t09window_lines(d.term^) - 3);
        EntryCount   := xt08ord2a( d.buf^, d.bufpos);
        d.bufpos     := d.bufpos + 2;
        CurrentEntry := 1;
        WHILE CurrentEntry <= EntryCount DO
            BEGIN
            xt08conditional_newscreen (d, 13);
            xt08put_int    (d, 'EntryNo     ', 4);
            xt08put_int    (d, 'SectionNo   ', 4);
            xt08put_int    (d, 'BaseNo      ', 4);
            xt08put_int    (d, 'ReservedCnt ', 4);
            xt08put_int    (d, 'FreeCnt     ', 4);
            xt08put_int    (d, 'UsedCnt     ', 4);
            xt08put_int    (d, 'PrevEntry   ', 4);
            xt08put_int    (d, 'NextEntry   ', 4);
            xt08put_bool   (d, 'IsIOPending '   );
            xt08put_bool   (d, 'IsChanged   '   );
            xt08skip_filler(d, 2);
            xt08new_line   (d);
            CurrentEntry := succ( CurrentEntry );
            IF  CurrentEntry <= EntryCount
            THEN
                BEGIN
                d.disp_line := d.term^.blankline;
                xt08output_line (d)
                END
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        END;
    d_ConvIndex:
        BEGIN
        xt08put_header (d, t09window_lines(d.term^) - 3);
        EntryCount   := xt08ord2a( d.buf^, d.bufpos);
        d.bufpos     := d.bufpos + 2;
        CurrentEntry := 1;
        WHILE CurrentEntry <= EntryCount DO
            BEGIN
            xt08conditional_newscreen (d, 13);
            xt08put_int    (d, 'IndexNo     ', 4);
            xt08new_line   (d);
            xt08put_int    (d, 'DevNo       ', 4);
            xt08put_int    (d, 'BlockNo     ', 4);
            xt08put_int    (d, 'Previous    ', 2);
            xt08put_int    (d, 'Next        ', 2);
            xt08put_int    (d, 'myFreeEntry ', 2);
            xt08put_int    (d, 'pageFreeEntr', 2);
            xt08put_int    (d, 'usedEntries ', 2);
            xt08put_convChainType (d, 'ChainType   ');
            xt08skip_filler (d, 1);
            xt08new_line   (d);
            CurrentEntry := succ( CurrentEntry );
            IF  CurrentEntry <= EntryCount
            THEN
                BEGIN
                d.disp_line := d.term^.blankline;
                xt08output_line (d)
                END
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        END;
    d_FBMManager :
        BEGIN
        xt08put_header (d, t09window_lines(d.term^) - 3);
        xt08skip_filler(d, 2); (* skip internal counter *)
        xt08put_bool   (d, 'IsActive    '   );
        xt08put_bool   (d, 'Trigger SVP '   );
        xt08skip_filler(d, 2); (* skip filler *)
        xt08put_int    (d, 'MaxDevSpaces', 4);
        xt08put_int    (d, 'DevSpaceUsed', 4);
        xt08put_int    (d, 'LastDevNumbr', 4);
        xt08put_int    (d, 'All Blocks  ', 4);
        xt08put_int    (d, 'Occ + BackUp', 4);
        xt08put_int    (d, 'FreeAfterSVP', 4);
        xt08put_int    (d, 'Backup+FSVP ', 4);
        xt08put_int    (d, 'Free        ', 4);
        xt08put_int    (d, 'SearchFreeOn', 4);
        END;
    d_FBMDataDevice :
        BEGIN
        xt08put_header (d, t09window_lines(d.term^) - 3);
        EntryCount   := xt08ord2a( d.buf^, d.bufpos);
        d.bufpos     := d.bufpos + 2;
        CurrentEntry := 1;
        WHILE CurrentEntry <= EntryCount DO
            BEGIN
            xt08conditional_newscreen (d, 13);
            xt08put_int    (d, 'DevNo       ', 4);
            xt08new_line   (d);
            xt08put_int    (d, 'All Blocks  ', 4);
            xt08put_int    (d, '# All Used  ', 4);
            xt08put_int    (d, '# BackUp    ', 4);
            xt08put_int    (d, '# Clu BackUp', 4);
            xt08put_int    (d, '# FreeSVP   ', 4);
            xt08put_int    (d, '# BackU+FSVP', 4);
            xt08put_int    (d, '# Add Blocks', 4);
            xt08put_int    (d, '# Sections  ', 4);
            xt08put_int    (d, 'Backup Blck ', 4);
            xt08put_int    (d, 'FreeBlckSear', 4);
            xt08put_int    (d, 'LastUsedBlck', 4);
            xt08put_int    (d, 'FstFreeBlck ', 4);
            xt08put_bool   (d, 'IsToDrop    '   );
            xt08skip_filler(d, 3); (* skip filler *)
            xt08put_int    (d, 'maxUncluster', 4);
            xt08put_int    (d, 'minClustered', 4);
            xt08put_int    (d, 'lstUncluterd', 4);
            xt08put_int    (d, 'numUsdUnclus', 4);
            xt08put_int    (d, 'numUsdCluste', 4);
            xt08put_int    (d, 'numRsrvClstr', 4);
            xt08new_line   (d);
            CurrentEntry := succ( CurrentEntry );
            IF  CurrentEntry <= EntryCount
            THEN
                BEGIN
                d.disp_line := d.term^.blankline;
                xt08output_line (d)
                END
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        END;
    d_PagerController:
        BEGIN
        xt08put_header (d, t09window_lines(d.term^) - 3);
        xt08skip_filler(d, 2); (* skip internal counter *)
        xt08put_int    (d, 'NumPagerWrtr', 4);
        xt08put_int    (d, 'RegPagerWrtr', 4);
        xt08put_int    (d, 'SuspPagerWrt', 4);
        xt08put_int    (d, 'FlushOrder  ', 4);
        xt08put_bool   (d, 'SVP Active  '   );
        xt08put_bool   (d, 'Flush Active'   );
        xt08put_bool   (d, 'PrepPagerWrt'   );
        xt08put_bool   (d, 'DisablePager'   );
        END;
    d_FileDirectory:
        BEGIN
        xt08put_header (d, t09window_lines(d.term^) - 3);
        EntryCount   := xt08ord2a( d.buf^, d.bufpos);
        d.bufpos     := d.bufpos + 2;
        CurrentEntry := 1;
        WHILE CurrentEntry <= EntryCount DO
            BEGIN
            xt08put_fileno (d, 'FileNo      '   );
            xt08put_pno    (d, 'RootPNo     '   );
            xt08put_pno    (d, 'FDirPNo     '   );
            xt08put_uint8  (d, 'EntryCount  '   );
            xt08put_int    (d, 'LeafPCount  ', 4);
            xt08put_int    (d, 'IndexPCount ', 4);
            xt08put_int    (d, 'FileState   ', 1);
            FDirEntryType := ord (d.buf^[ d.bufpos ]);
            xt08put_fdir_type (d, 'FDirEntryTyp'  );
            xt08skip_filler(d, 1); (* skip fileAttr *)
            xt08skip_filler(d, 5); (* skip filler *)
            xt08put_bool   (d, 'Permanent   '   );
            xt08put_bool   (d, 'NeedsUpdate '   );
            xt08skip_filler(d, 2); (* skip filler *)
            xt08put_int    (d, 'LeafPDelta  ', 4);
            xt08put_int    (d, 'IndexPDelta ', 4);
            xt08put_int    (d, 'EntryCDelta ', 4);
            xt08put_uint8  (d, 'cacheHits   '   );
            xt08put_uint8  (d, 'cacheMisses '   );
            CASE FDirEntryType OF
                d_TableFile:
                    BEGIN
                    xt08put_uint2   (d, 'blobColCount');
                    xt08put_fvers   (d, 'fileVersion ');
                    xt08put_any_set (d, 'filetypeset ', set_filetype);
                    xt08put_int     (d, 'tabAttr     ', 1);
                    indexCount.mapC2_sp00 [1] := d.buf^[ d.bufpos ];
                    indexCount.mapC2_sp00 [2] := d.buf^[ d.bufpos+1 ];
                    xt08put_int     (d, 'IndexCount  ', 2);
                    xt08put_int8    (d, 'LobPCount   '   );
                    xt08put_int     (d, 'LobPDelta   ',4 );
                    xt08skip_filler (d, 4); (* skip filler *)
                    xt08put_fileno  (d, 'SColFileNo  '   );
                    FOR i := 1 TO indexCount.mapInt_sp00 DO
                        xt08put_fileno (d, 'IndexFileNo ');
                    (*ENDFOR*) 
                    END;
                d_IndexFile:
                    BEGIN
                    xt08put_fileno (d, 'TableFileNo '   );
                    xt08put_int    (d, 'IndexId     ', 2);
                    xt08put_any_set(d, 'filetypeset ', set_filetype);
                    xt08put_int    (d, 'indexAttr   ', 1);
                    xt08put_int    (d, 'usageCount  ', 4);
                    END;
                d_ShortColumnFile:
                    BEGIN
                    xt08put_fileno (d, 'TableFileId ');
                    END;
                d_OmsFile,
                d_OmsFixedFile,
                d_OmsKeyFile,
                d_OmsVarFile:
                    BEGIN
                    xt08put_uint2  (d, 'ChainCount  ');
                    xt08put_uint2  (d, 'ObjBodySize ');
                    xt08put_uint2  (d, 'ObjPerPageCt');
                    partitionCnt := xt08ord2a (d.buf^, d.bufpos);
                    xt08put_uint2  (d, 'PartitionCnt');
                    xt08put_uint8  (d, 'MaxPageNoSeq');
                    CASE FDirEntryType OF
                        d_OmsVarFile:
                            BEGIN
                            FOR i := 1 TO partitionCnt DO
                                xt08put_pno    (d, 'ContRootPNo '   );
                            (*ENDFOR*) 
                            END;
                        d_OmsKeyFile:
                            BEGIN
                            FOR i := 1 TO partitionCnt DO
                                xt08put_fileno (d, 'KeyPartFlNo ');
                            (*ENDFOR*) 
                            END;
                        OTHERWISE
                            (* *)
                        END;
                    (*ENDCASE*) 
                    END;
                d_OmsKeyPartitionFile:
                    BEGIN
                    xt08put_fileno (d, 'ParentFileNo'   );
                    xt08put_int    (d, 'PartitionNo ', 2);
                    xt08skip_filler(d, 6); (* skip filler *)
                    END;
                OTHERWISE
                    (* *)
                END;
            (*ENDCASE*) 
            xt08new_line   (d);
            CurrentEntry := succ( CurrentEntry );
            IF  CurrentEntry <= EntryCount
            THEN
                BEGIN
                d.disp_line := d.term^.blankline;
                xt08output_line (d)
                END
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        END;
    OTHERWISE
        d.bufpos := d.bufsize; (* no more dump recs *)
    END;
(*ENDCASE*) 
xt08new_line (d);
END;
 
(*------------------------------*) 
 
FUNCTION
      xt08equals_dumplabels (VAR d : display_state_type;
            VAR search_label       : tsp00_Name) : boolean;
 
VAR
      is_eq : boolean;
      i     : integer;
 
BEGIN
i     := 1;
is_eq := (search_label [1] = d.buf^[d.bufpos]);
WHILE (i <= sizeof (tsp00_C8)) AND is_eq DO
    IF  search_label [i] = d.buf^[d.bufpos+i-1]
    THEN
        i := i + 1
    ELSE
        is_eq := false;
    (*ENDIF*) 
(*ENDWHILE*) 
IF  NOT is_eq
THEN
    is_eq := (search_label [i] = ' ');
(*ENDIF*) 
xt08equals_dumplabels := is_eq
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08init_left_output_col (VAR d : display_state_type;
            msg : tsp00_Sname);
 
BEGIN
IF  d.cur_column = 2
THEN
    xt08new_line (d);
(*ENDIF*) 
d.disp_line := d.term^.blankline;
d.line_len  := of_first_col; (* Tabulator for left col *)
g17int4to_line (d.bufpos - d.bufoffset,
      c_pad_with_zero, mx_pos_displ, 1,d.disp_line);
(* move name of dump record component to display*)
SAPDB_PascalForcedMove (sizeof (msg), sizeof (d.disp_line),
      @msg, 1, @d.disp_line, d.line_len + 1, sizeof (msg));
(* *)
d.line_len               := d.line_len + sizeof (msg) + 1;
d.disp_line [d.line_len] := ':';
d.line_len               := d.line_len + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08init_output_col (VAR d : display_state_type;
            msg : tsp00_Sname);
 
BEGIN
IF  d.cur_column = 1  (* left column *)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := of_first_col; (* Tabulator for left col *)
    g17int4to_line (d.bufpos - d.bufoffset,
          c_pad_with_zero, mx_pos_displ, 1, d.disp_line)
    END
ELSE
    d.line_len := of_second_col; (* right column *)
(*ENDIF*) 
(* move name of dump record component to display *)
SAPDB_PascalForcedMove (sizeof (msg), sizeof (d.disp_line),
      @msg, 1, @d.disp_line, d.line_len + 1, sizeof (msg));
(* *)
d.line_len               := d.line_len + sizeof (msg) + 1;
d.disp_line [d.line_len] := ':';
d.line_len               := d.line_len + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08new_line (VAR d : display_state_type);
 
BEGIN
IF  (d.cur_column = 2)
    AND (utds_full_info in d.scan)
    AND (d.pfkey = pf_none)
THEN
    xt08out_col_line (d) (* flush last line *)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      xt08ord2a (VAR buf : tsp00_MoveObj; bufpos : integer) : tsp00_Int2;
 
VAR
      i2 : tsp00_IntMapC2;
 
BEGIN
i2.mapC2_sp00 [1] := buf [bufpos  ];  (* extract rec type *)
i2.mapC2_sp00 [2] := buf [bufpos+1];
xt08ord2a := i2.mapInt_sp00 (* return rec type as output parameter *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08out_col_line (VAR d : display_state_type);
 
VAR
      aux_attr   : char;
      indicator1 : char;
      indicator2 : char;
 
BEGIN
aux_attr := d.vt_attr;
IF  utds_edit in d.scan
THEN
    BEGIN
    indicator1 := d.disp_line [of_col_type+1];
    indicator2 := d.disp_line [of_col_type+3];
    (* *)
    IF  (indicator1 = c_bool_indicator  ) OR
        (indicator1 = c_int_indicator   ) OR
        (indicator1 = c_mtype_indicator ) OR
        (indicator1 = c_mtype2_indicator) OR
        (indicator1 = c_set_indicator   )
        OR
        (((indicator2 = c_bool_indicator  ) OR
        (  indicator2 = c_int_indicator   ) OR
        (  indicator2 = c_mtype_indicator ) OR
        (  indicator2 = c_mtype2_indicator))
        AND (d.disp_line [of_col_type+2] <> ' '))
    THEN
        BEGIN
        IF  d.vt_attr = cut_protected
        THEN
            d.vt_attr := cut_unprotected
        ELSE
            d.vt_attr := cut_bright_unprotected
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
xt08output_line (d);
d.vt_attr := aux_attr
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08output_line (VAR d : display_state_type);
 
VAR
      err    : integer;
      ln_len : integer;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08conditional_newscreen (d, 1);
    (* perform formfeed + hold if not enough space on screen *)
    IF  d.pfkey = pf_none
    THEN
        BEGIN
        (* write to protocol and display at terminal: *)
        ln_len := d.line_size;
        WHILE (ln_len > 1) AND (d.disp_line [ln_len] = ' ') DO
            ln_len := ln_len - 1;
        (*ENDWHILE*) 
        t12write_prot (d.prot^, d.disp_line, ln_len, err);
        IF  (ln_len > 1)
            OR
            (d.disp_line [1] <> ' ')
            OR
            NOT t09is_empty_window (d.term^)
        THEN
            t09put (d.term^, d.disp_line, d.vt_attr);
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
d.cur_column := 1; (* reset to left column *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_addr (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      is_nil    : boolean;
      try_again : boolean;
      i         : integer;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    REPEAT
        try_again := false;
        xt08init_output_col (d, msg);
        i      := 1;
        is_nil := true;
        WHILE (i <= sizeof (tsp00_BufAddr)) AND is_nil DO
            IF  d.buf^[d.bufpos+i-1] = chr (0)
            THEN
                i := i + 1
            ELSE
                is_nil := false;
            (*ENDIF*) 
        (*ENDWHILE*) 
        IF  is_nil
        THEN
            g17sname_to_line ('nil         ', d.line_len, d.disp_line)
        ELSE
            FOR i := 1 TO sizeof (tsp00_BufAddr) DO
                g17hexto_line (d.buf^[d.bufpos+i-1],
                      d.line_len, d.disp_line);
            (*ENDFOR*) 
        (*ENDIF*) 
        IF  (d.cur_column = 2) AND (d.line_len > d.line_size)
        THEN
            BEGIN
            try_again := true;
            SAPDB_PascalForcedFill (sizeof (d.disp_line), @d.disp_line, of_second_col+1,
                  d.line_len - of_second_col, ' ')
            END;
        (*ENDIF*) 
        xt08write_output_col (d)
    UNTIL
        NOT try_again;
    (*ENDREPEAT*) 
(*ENDIF*) 
d.bufpos := d.bufpos + sizeof (tsp00_Addr)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_addr8 (VAR d : display_state_type;
            msg : tsp00_Sname);
 
BEGIN
xt08put_addr (d, msg);
IF  sizeof (tsp00_Addr) = 4
THEN
    d.bufpos := d.bufpos + 4
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_any_set (VAR d : display_state_type;
            msg              : tsp00_Sname;
            any_set_type     : t_any_set);
 
VAR
      set_size : integer;
 
      any_set : RECORD
            CASE integer OF
                1:
                    (c : tsp00_C2);
                2:
                    (bd_fdesc     : tbd_fileinfo_desc_set);
                3:
                    (bd_fstate    : tbd_file_state_set   );
                4:
                    (pagemode     : tgg00_PageMode         );
                5:
                    (bd_use       : tgg00_BdUseSet       );
                6:
                    (filetype     : tgg00_FiletypeSet     );
                7:
                    (handling     : tgg00_HandlingSet     );
                8:
                    (lock_state   : tgg00_LockReqState   );
                9:
                    (trans_state  : tgg00_TransState      );
                10:
                    (efiletype    : tgg00_ExtendedFiletypeSet );
                END;
            (*ENDCASE*) 
 
 
BEGIN
CASE any_set_type OF
    set_bd_fdesc:
        set_size := sizeof (any_set.bd_fdesc   );
    set_bd_fstate:
        set_size := sizeof (any_set.bd_fstate  );
    set_pagemode:
        set_size := sizeof (any_set.pagemode   );
    set_bd_use:
        set_size := sizeof (any_set.bd_use     );
    set_filetype:
        set_size := sizeof (any_set.filetype   );
    set_handling:
        set_size := sizeof (any_set.handling   );
    set_lock_state:
        set_size := sizeof (any_set.lock_state );
    set_trans_state:
        set_size := sizeof (any_set.trans_state);
    set_efiletype:
        set_size := sizeof (any_set.efiletype   );
    END;
(*ENDCASE*) 
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
    AND
    (d.bufpos + set_size - 1 <= d.bufsize)
THEN
    BEGIN
    xt08init_left_output_col (d, msg);
    IF  utds_edit in d.scan
    THEN
        BEGIN
        xt08col_size_to_line (d, set_size);
        IF  (any_set_type = set_bd_fdesc    ) OR
            (any_set_type = set_bd_fstate   ) OR
            (any_set_type = set_filetype    ) OR
            (any_set_type = set_efiletype   )
        THEN
            d.disp_line [of_col_type + 1 + 2*(d.cur_column-1)] :=
                  c_set_indicator
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    d.line_len    := d.line_len - 1;
    any_set.c [1] := d.buf^[d.bufpos];
    IF  set_size = 2
    THEN
        any_set.c [2] := d.buf^[d.bufpos+1];
    (*ENDIF*) 
    CASE any_set_type OF
        set_bd_fdesc:
            g17bd_fdesc_to_line (any_set.bd_fdesc,
                  utds_edit in d.scan, d.line_len, d.disp_line);
        set_bd_fstate:
            g17bd_fstate_to_line (any_set.bd_fstate,
                  utds_edit in d.scan, d.line_len, d.disp_line);
        set_pagemode:
            g17pagemode_to_line (any_set.pagemode,
                  utds_edit in d.scan, d.line_len, d.disp_line);
        set_bd_use:
            g17bd_use_set_to_line (any_set.bd_use, d.line_len,
                  d.disp_line);
        set_filetype:
            g17filetype_to_line (any_set.filetype,
                  utds_edit in d.scan, d.line_len, d.disp_line);
        set_efiletype:
            g17efiletype_to_line (any_set.efiletype,
                  utds_edit in d.scan, d.line_len, d.disp_line);
        set_handling:
            g17handling_set_to_line (any_set.handling, d.line_len,
                  d.disp_line);
        set_lock_state:
            g17lockstate_to_line (any_set.lock_state, d.line_len,
                  d.disp_line);
        set_trans_state:
            g17trans_state_to_line (any_set.trans_state, d.line_len,
                  d.disp_line);
        END;
    (*ENDCASE*) 
    IF  d.pfkey = pf_none
    THEN
        xt08out_col_line (d);
    (*ENDIF*) 
    d.cur_column := 1
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + set_size
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_bd_data_io_state (VAR d : display_state_type;
            msg : tsp00_Sname);
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    g17bd_data_io_state_to_line (ord (d.buf^[d.bufpos] ), d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_fdir_type (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      FDirEntryType : tsp00_Uint1;
 
BEGIN
FDirEntryType := ord (d.buf^[ d.bufpos ]);
d.bufpos      := d.bufpos + 1;
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    CASE FDirEntryType OF
        d_TableFile:
            g17sname_to_line ('Table       ', d.line_len, d.disp_line);
        d_IndexFile:
            g17sname_to_line ('Index       ', d.line_len, d.disp_line);
        d_ShortColumnFile:
            g17sname_to_line ('ShortColumn ', d.line_len, d.disp_line);
        d_OmsFile:
            g17sname_to_line ('Oms         ', d.line_len, d.disp_line);
        d_OmsFixedFile:
            g17sname_to_line ('OmsFixed    ', d.line_len, d.disp_line);
        d_OmsKeyFile:
            g17sname_to_line ('OmsKey      ', d.line_len, d.disp_line);
        d_OmsKeyPartitionFile:
            g17sname_to_line ('OmsKeyPartit', d.line_len, d.disp_line);
        d_OmsVarFile:
            g17sname_to_line ('OmsVar      ', d.line_len, d.disp_line);
        OTHERWISE
            g17sname_to_line ('free block  ', d.line_len, d.disp_line);
        END;
    (*ENDCASE*) 
    xt08write_output_col (d);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_task_queue_state (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
 
      univ_state : RECORD
            CASE integer OF
                1:
                    (c : tsp00_C2);
                2:
                    (l : tbd02_TaskQueueReason);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    univ_state.c [1] := d.buf^[d.bufpos];
    g17bd_task_queue_state_to_line (univ_state.l, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_recMode (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
 
      univRecMode : RECORD
            CASE integer OF
                1:
                    (c1 : tsp00_C2);
                2:
                    (e1 : tgg00_RecoveryMode);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    univRecMode.c1[1] := d.buf^[d.bufpos];
    CASE univRecMode.e1  OF
        rmNone_egg00 :
            g17sname_to_line ('none        ', d.line_len, d.disp_line);
        rmTemp_egg00 :
            g17sname_to_line ('temp        ', d.line_len, d.disp_line);
        rmPerm_egg00 :
            g17sname_to_line ('perm        ', d.line_len, d.disp_line);
        rmStatic_egg00 :
            g17sname_to_line ('static      ', d.line_len, d.disp_line);
        OTHERWISE
            BEGIN
            g17sname_to_line ('***         ', d.line_len, d.disp_line);
            g17trimint4_to_line (ord (d.buf^[d.bufpos]), d.line_len, d.disp_line)
            END
        END;
    (*ENDCASE*) 
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_changedState (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
 
      univChangedState : RECORD
            CASE integer OF
                1:
                    (c1 : tsp00_C2);
                2:
                    (e1 : tbd02_ChangedState);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    univChangedState.c1[1] := d.buf^[d.bufpos];
    CASE univChangedState.e1  OF
        cstNone_ebd02 :
            g17sname_to_line ('none        ', d.line_len, d.disp_line);
        cstChanged_ebd02 :
            g17sname_to_line ('changed     ', d.line_len, d.disp_line);
        cstSvpRelevant_ebd02 :
            g17sname_to_line ('svp relevant', d.line_len, d.disp_line);
        OTHERWISE
            BEGIN
            g17sname_to_line ('***         ', d.line_len, d.disp_line);
            g17trimint4_to_line (ord (d.buf^[d.bufpos]), d.line_len, d.disp_line)
            END
        END;
    (*ENDCASE*) 
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_tfntype (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
 
      univ_tfn : RECORD
            CASE integer OF
                1:
                    (c : tsp00_C2);
                2:
                    (l : tgg00_Tfn);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    univ_tfn.c [1] := d.buf^[d.bufpos];
    g17tfntype_to_line (univ_tfn.l, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_ttfnTemp (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
 
      univ_tfn : RECORD
            CASE integer OF
                1:
                    (c : tsp00_C2);
                2:
                    (l : tgg00_TfnTemp);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    univ_tfn.c [1] := d.buf^[d.bufpos];
    g17ttfntemp_to_line (univ_tfn.l, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_block_type (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      pMemType : ^tak_mem_type;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    pMemType := @d.buf^[d.bufpos];
    CASE pMemType^ OF
        dyn_free :
            g17sname_to_line ('dyn_free    ', d.line_len, d.disp_line);
        dyn_normal :
            g17sname_to_line ('dyn_normal  ', d.line_len, d.disp_line);
        dyn_packet :
            g17sname_to_line ('dyn_packet  ', d.line_len, d.disp_line);
        dyn_mess_block :
            g17sname_to_line ('dyn_mblock  ', d.line_len, d.disp_line);
        dyn_mess_block_part :
            g17sname_to_line ('dyn_mblock_p', d.line_len, d.disp_line);
        dyn_syntax_tree :
            g17sname_to_line ('dyn_syntax  ', d.line_len, d.disp_line);
        OTHERWISE
            BEGIN
            g17sname_to_line ('***         ', d.line_len, d.disp_line);
            g17trimint4_to_line (ord (d.buf^[d.bufpos]), d.line_len,
                  d.disp_line)
            END
        END;
    (*ENDCASE*) 
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_convChainType (VAR d : display_state_type;
            msg : tsp00_Sname);
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    IF  utds_edit in d.scan
    THEN
        BEGIN
        d.disp_line [of_col_type + 1 + 2*(d.cur_column-1)] :=
              c_bool_indicator;
        xt08col_size_to_line (d, sizeof (boolean))
        END;
    (* move value of boolean variable to display: *)
    (*ENDIF*) 
    CASE (d.buf^[d.bufpos]) OF
        'i':
            g17sname_to_line ('invalid     ', d.line_len, d.disp_line);
        'r':
            g17sname_to_line ('rootEntry   ', d.line_len, d.disp_line);
        'p':
            g17sname_to_line ('partially   ', d.line_len, d.disp_line);
        'f':
            g17sname_to_line ('full        ', d.line_len, d.disp_line);
        OTHERWISE
            BEGIN
            (* error case : neither 0 nor 1 *)
            g17sname_to_line ('***         ', d.line_len, d.disp_line);
            g17trimint4_to_line (ord (d.buf^[d.bufpos]), d.line_len,
                  d.disp_line)
            END
        END;
    (*ENDCASE*) 
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_bool (VAR d : display_state_type;
            msg : tsp00_Sname);
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    IF  utds_edit in d.scan
    THEN
        BEGIN
        d.disp_line [of_col_type + 1 + 2*(d.cur_column-1)] :=
              c_bool_indicator;
        xt08col_size_to_line (d, sizeof (boolean))
        END;
    (* move value of boolean variable to display: *)
    (*ENDIF*) 
    CASE ord (d.buf^[d.bufpos]) OF
        0:
            g17sname_to_line ('false       ', d.line_len, d.disp_line);
        1:
            g17sname_to_line ('true        ', d.line_len, d.disp_line);
        OTHERWISE
            BEGIN
            (* error case : neither 0 nor 1 *)
            g17sname_to_line ('***         ', d.line_len, d.disp_line);
            g17trimint4_to_line (ord (d.buf^[d.bufpos]), d.line_len,
                  d.disp_line)
            END
        END;
    (*ENDCASE*) 
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_buffer (VAR d : display_state_type;
            msg             : tsp00_Sname;
            bufferlength    : integer);
 
VAR
      is_help         : boolean;
      dummy_size      : integer;
      lines_tdbuf     : integer;
      i               : integer;
      char_per_tdline : integer;
      lines_per_tdbuf : integer;
      start_pos       : tsp00_Int4; (* index to buf *)
      stop_pos        : tsp00_Int4; (* index to buf *)
      break_pos       : tsp00_Int4; (* index to buf *)
      buf_msg         : tsp00_C30;
 
BEGIN
IF  NOT (utds_full_info in d.scan) OR (d.pfkey <> pf_none)
THEN
    (* only add up lengths to find beginning of next dump rec *)
    d.bufpos := d.bufpos + bufferlength
ELSE
    BEGIN
    (* flush current line *)
    xt08new_line (d);
    IF  d.pfkey = pf_none
    THEN
        BEGIN
        t14bufdimension (d.term^, d.scan, char_per_tdline,
              dummy_size, lines_per_tdbuf);
        lines_tdbuf := 1 + ((bufferlength + char_per_tdline - 1)
              DIV char_per_tdline) * lines_per_tdbuf;
        xt08conditional_newscreen (d, lines_tdbuf)
        END;
    (*ENDIF*) 
    IF  d.pfkey = pf_none
    THEN
        BEGIN
        buf_msg := bsp_c30;
        FOR i := 1 TO sizeof (msg) DO
            buf_msg [i] := msg [i];
        (*ENDFOR*) 
        IF  bufferlength <> 0
        THEN
            BEGIN
            start_pos := d.bufpos;
            stop_pos  := d.bufpos - 1 + bufferlength;
            t09setpf1 (d.term^, cut_pfkey_hexint);
            REPEAT
                is_help := false;
                t14bufdisplay (d.term^, d.prot^, d.scan, buf_msg,
                      d.buf^, d.bufsize, start_pos, stop_pos,
                      start_pos - d.bufpos + 1, break_pos, d.pfkey);
                IF  d.pfkey = pf_help
                THEN
                    BEGIN
                    start_pos := break_pos;
                    buf_msg   := bsp_c30;
                    is_help   := true;
                    x05helphexint (d.term^, d.pfkey)
                    END;
                (*ENDIF*) 
            UNTIL
                NOT is_help OR (d.pfkey <> pf_none);
            (*ENDREPEAT*) 
            t09setpf1 (d.term^, cut_pfkey_none);
            d.cur_column := 1
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    d.bufpos := d.bufpos + bufferlength (* adjust bufpos-pointer *)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_GCHistoryDir (VAR d : display_state_type);
 
VAR
      NumHistFiles     : tsp00_Int4;
      HistFileNo       : tsp00_Int4;
      CurrActivGCIndex : tsp00_Int4;
      historyAvailable : boolean;
 
BEGIN
xt08put_header (d, t09window_lines(d.term^) - 3);
(* NumHistFiles := s20buf_to_int4 (d.buf^, d.bufpos);  FF 2003-05-21 PTS 1122220 *)
xt08put_int (d, 'NumHistFiles', 4);   (* JA 2000-03-15 *)
xt08put_int (d, 'MaxHistFiles', 4);
historyAvailable := (d.buf^[d.bufpos] <> chr(ord(false)));
d.bufpos := d.bufpos + 1;
NumHistFiles := s20buf_to_int4 (d.buf^, d.bufpos); (* FF 2003-05-21 PTS 1122220 *)
xt08put_int(d, 'PageEntryCnt', 4);                      (* FF 2003-05-21 PTS 1122220 *)
IF  d.cur_column = 2
THEN
    (* flush last line *)
    xt08out_col_line (d);             (* JA 2000-03-15 *)
(*ENDIF*) 
FOR HistFileNo := 1 TO NumHistFiles DO
    BEGIN
    xt08conditional_newscreen (d, 4);
    d.disp_line := d.term^.blankline;
    xt08output_line (d);
    IF  historyAvailable
    THEN
        BEGIN
        xt08put_int     (d, 'root        ', 4);
        xt08put_int     (d, 'last        ', 4);
        xt08put_trans   (d, 'oldestTrans '   );
        xt08put_trans   (d, 'youngestTrns'   );
        xt08put_int     (d, 'lpagecount  ', 4);
        xt08put_bool    (d, 'inProcess   '   );
        xt08skip_filler (d, 3);
        END;
    (*ENDIF*) 
    CurrActivGCIndex := xt08ord2a (d.buf^, d.bufpos);
    d.bufpos := d.bufpos + 2 ;  (* GCIndex *)
    xt08init_output_col (d, 'Activ GC:   ');
    IF  (CurrActivGCIndex = -1)
    THEN
        g17sname_to_line ('none        ', d.line_len, d.disp_line)
    ELSE
        g17trimint4_to_line (CurrActivGCIndex, d.line_len, d.disp_line);
    (*ENDIF*) 
    xt08write_output_col (d);
    xt08put_bool    (d, 'Cut History ');
    xt08write_output_col (d);
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_cblocks (VAR d : display_state_type);
 
VAR
      last_follow_page : boolean;
      entries_in_page  : integer;
      i                : integer;
      rec_length       : integer;
 
BEGIN
rec_length := sizeof (tsp00_BufAddr)
      +       sizeof (tsp00_Int4)
      +       sizeof (tsp00_BufAddr)
      +     4*sizeof (tsp00_Int4)
      +     8*sizeof (tsp00_BufAddr)
      +     4*sizeof (tsp00_Int2)
      +     4*sizeof (tsp00_Uint1);
xt08put_header (d, 13);
entries_in_page  := xt08ord2a (d.buf^, d.bufpos);
last_follow_page := d.buf^[d.bufpos + 2] = chr (ord (true));
d.bufpos := d.bufpos + 3;
IF  NOT (utds_full_info in d.scan) OR (d.pfkey <> pf_none)
THEN
    IF  last_follow_page
    THEN
        d.bufpos := d.bufpos + rec_length * entries_in_page
    ELSE
        d.bufpos := d.bufsize
    (*ENDIF*) 
ELSE
    BEGIN
    i := 1;
    WHILE i <= entries_in_page DO
        BEGIN
        xt08conditional_newscreen (d, 13);
        xt08put_addr     (d, 'pCblock     '   );
        xt08put_addr     (d, 'pFrame      '   );
        xt08put_int      (d, 'occupant    ', 4);
        xt08put_recMode  (d, 'recMode     '   );
        xt08put_int      (d, 'oldOccupant ', 4);
        xt08put_recMode  (d, 'oldRecMode  '   );
        xt08put_int      (d, 'pFrame^.Id  ', 4);
        xt08put_int      (d, 'pFrame^.Root', 4);
        xt08put_int      (d, 'lastOwner   ', 4);
        xt08put_int      (d, 'accessCnt   ', 4);
        xt08put_int      (d, 'collisionCnt', 4);
        xt08put_int      (d, 'updateCnt   ', 4);
        xt08put_int      (d, 'usageCnt    ', 2);
        xt08put_bd_data_io_state (d, 'state       ');
        xt08put_changedState     (d, 'changedState');
        xt08put_tfntype  (d, 'fileTfn     '   );
        xt08put_int      (d, 'syncSVPCount', 2);
        xt08put_bool     (d, 'isSrcOfACopy'   );
        xt08put_int      (d, 'copyNo      ', 1);
        xt08put_bool     (d, 'ioArea      '   );
        xt08put_bool     (d, 'isClustered '   );
        xt08put_bool     (d, 'rechainArea '   );
        xt08put_addr     (d, 'pNextLRU    '   );
        xt08put_addr     (d, 'pPrevLRU    '   );
        xt08put_addr     (d, 'pLockReqHead'   );
        xt08put_addr     (d, 'pLockReqTail'   );
        xt08put_addr     (d, 'pOccupant   '   );
        xt08put_addr     (d, 'pOldOccupant'   );
        xt08put_addr     (d, 'pNextIO     '   );
        xt08put_addr     (d, 'pPrevIO     '   );
        xt08put_addr     (d, 'pNextFixed  '   );
        xt08put_addr     (d, 'pNextVar    '   );
        (* *)
        xt08new_line     (d);
        i := i+1;
        IF  i <= entries_in_page
        THEN
            BEGIN
            d.disp_line := d.term^.blankline;
            xt08output_line (d)
            END
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  NOT last_follow_page
    THEN
        d.bufpos := d.bufsize
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_char (VAR d : display_state_type;
            msg           : tsp00_Sname;
            stringlength  : integer);
 
VAR
      longstring : boolean; (* indicates that string spans two columns*)
      i          : integer;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    IF  d.cur_column = 1  (* left column *)
    THEN
        BEGIN
        longstring :=
              of_first_col + sizeof (msg) + 2 + stringlength
              >= of_second_col;
        d.disp_line := d.term^.blankline;
        d.line_len  := of_first_col; (* Tabulator for left col *)
        g17int4to_line (d.bufpos - d.bufoffset,
              c_pad_with_zero, mx_pos_displ, 1, d.disp_line)
        END
    ELSE (* cur_column = 2 *)
        BEGIN
        longstring :=
              of_second_col + sizeof(msg) + 2 + stringlength
              > d.line_size;
        IF  NOT longstring
        THEN
            d.line_len := of_second_col (* right column *)
        ELSE
            BEGIN
            (* flush current line *)
            xt08out_col_line (d);
            d.disp_line := d.term^.blankline;
            d.line_len  := of_first_col; (* Tabulator left col *)
            g17int4to_line (d.bufpos - d.bufoffset,
                  c_pad_with_zero, mx_pos_displ, 1, d.disp_line)
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    (* move msg of dump record component to display *)
    SAPDB_PascalForcedMove (sizeof (msg), sizeof (d.disp_line), @msg, 1,
          @d.disp_line, d.line_len + 1, sizeof (msg));
    d.line_len := d.line_len + sizeof (msg) + 1;
    d.disp_line [d.line_len] := ':';
    d.line_len := d.line_len + 2;
    FOR i := 0 TO stringlength-1 DO
        IF  g17printable_char (d.buf^[d.bufpos+i])
        THEN
            d.disp_line [d.line_len+i] := d.buf^[d.bufpos+i]
        ELSE
            d.disp_line [d.line_len+i] := '.';
        (*ENDIF*) 
    (*ENDFOR*) 
    IF  longstring OR (d.cur_column = 2)
    THEN
        BEGIN
        xt08out_col_line (d);
        d.cur_column := 1
        END
    ELSE
        d.cur_column := 2
    (*ENDIF*) 
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + stringlength
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_checktype (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
 
      page_type : RECORD
            CASE integer OF
                1:
                    (c : tsp00_C2);
                2:
                    (p : tgg00_PageCheckType);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    IF  utds_edit in d.scan
    THEN
        xt08col_size_to_line (d, sizeof (tgg00_PageCheckType));
    (*ENDIF*) 
    page_type.c [1] := d.buf^[d.bufpos];
    g17pagecheck_to_line (page_type.p, d.line_len, d.disp_line);
    xt08write_output_col (d);
    d.bufpos := d.bufpos + 1
    END
ELSE
    d.bufpos := d.bufpos + 1
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_cint4 (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      try_again : boolean;
      intval    : tsp00_Int4;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    REPEAT
        try_again := false;
        xt08init_output_col (d, msg);
        IF  utds_edit in d.scan
        THEN
            xt08col_size_to_line (d, sizeof (tsp00_Int4));
        (*ENDIF*) 
        intval := gg06Int4Get (d.buf^, d.bufpos);
        g17trimint4_to_line (intval, d.line_len, d.disp_line);
        IF  (d.cur_column = 2) AND (d.line_len > d.line_size)
        THEN
            BEGIN
            try_again := true;
            SAPDB_PascalForcedFill (sizeof (d.disp_line), @d.disp_line, of_second_col+1,
                  d.line_len - of_second_col, ' ')
            END;
        (*ENDIF*) 
        xt08write_output_col (d)
    UNTIL
        NOT try_again;
    (*ENDREPEAT*) 
(*ENDIF*) 
d.bufpos := d.bufpos + 4
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_cnt (VAR d : display_state_type;
            msg          : tsp00_Sname);
 
VAR
      counter : tsp00_8ByteCounter;
 
BEGIN
(* PTS 1103799 JA 1999-08-30 *)
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
    AND
    (d.bufpos + sizeof (counter) - 1 <= d.bufsize)
THEN
    BEGIN
    SAPDB_PascalForcedMove (d.bufsize, sizeof (counter),
          @d.buf^, d.bufpos, @counter, 1, sizeof (counter));
    xt08init_output_col (d, msg);
    IF  utds_edit in d.scan
    THEN
        xt08col_size_to_line (d, sizeof (counter));
    (*ENDIF*) 
    g17counter_to_line (counter, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + sizeof (counter)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_uint8 (VAR d : display_state_type;
            msg            : tsp00_Sname);
 
TYPE
 
      uint8 = RECORD
            CASE integer OF
                1:
                    (ch : tsp00_C8);
                2:
                    (align : tsp00_Longint);
                END;
            (*ENDCASE*) 
 
 
VAR
      value : uint8;
 
BEGIN
(* PTS 1103799 JA 1999-08-30 *)
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
    AND
    (d.bufpos + sizeof (value) - 1 <= d.bufsize)
THEN
    BEGIN
    SAPDB_PascalForcedMove (d.bufsize, sizeof (value),
          @d.buf^, d.bufpos, @value, 1, sizeof (value));
    xt08init_output_col (d, msg);
    IF  utds_edit in d.scan
    THEN
        xt08col_size_to_line (d, sizeof (value));
    (*ENDIF*) 
    g172Char8AsInt8_to_line (value.ch, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + sizeof (value)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_int8 (VAR d : display_state_type;
            msg           : tsp00_Sname);
 
TYPE
 
      int8 = RECORD
            CASE integer OF
                1:
                    (ch : tsp00_C8);
                2:
                    (align : tsp00_Longint);
                END;
            (*ENDCASE*) 
 
 
VAR
      value : int8;
 
BEGIN
(* PTS 1103799 JA 1999-08-30 *)
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
    AND
    (d.bufpos + sizeof (value) - 1 <= d.bufsize)
THEN
    BEGIN
    SAPDB_PascalForcedMove (d.bufsize, sizeof (value),
          @d.buf^, d.bufpos, @value, 1, sizeof (value));
    xt08init_output_col (d, msg);
    IF  utds_edit in d.scan
    THEN
        xt08col_size_to_line (d, sizeof (value));
    (*ENDIF*) 
    g172Char8AsInt8_to_line (value.ch, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + sizeof (value)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_fileno (VAR d : display_state_type;
            msg          : tsp00_Sname);
 
BEGIN
xt08put_hex (d, msg, 8);
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_codetab (VAR d : display_state_type;
            msg : tsp00_Sname);
 
CONST
      c_indent            =  4;
      c_space             =  3;
      c_lines_per_tab     = 32;
      c_chr_per_block     = 16;
      c_columns_per_line  =  8;
 
VAR
      col       : integer;
      code_col1 : integer;
      i         : integer;
      dummy_err : integer;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    (* flush current line *)
    xt08new_line (d);
    xt08conditional_newscreen (d, 1 + c_chr_per_block);
    t12write_prot (d.prot^, d.term^.blankline, 1, dummy_err);
    (* formfeed if rest of output too long *)
    d.disp_line := d.term^.blankline;
    (* move name of dump record component to display *)
    SAPDB_PascalForcedMove (sizeof (msg), sizeof (d.disp_line), @msg, 1,
          @d.disp_line, c_indent + 1, sizeof (msg));
    (* flush header line, giving name of code table *)
    xt08output_line (d);
    code_col1 := 0;
    FOR i := 1 TO c_lines_per_tab DO
        BEGIN
        d.disp_line := d.term^.blankline;
        d.line_len  := c_indent;
        IF  i = c_chr_per_block + 1
        THEN
            BEGIN
            code_col1 := c_columns_per_line * c_chr_per_block;
            xt08conditional_newscreen (d, c_chr_per_block);
            t12write_prot (d.prot^, d.term^.blankline, 1, dummy_err);
            END;
        (*ENDIF*) 
        FOR col := 0 TO c_columns_per_line - 1 DO
            IF  code_col1 + col * c_chr_per_block < CTABLE_MXSP00
            THEN
                BEGIN
                g17hexto_line (chr(code_col1 + col * c_chr_per_block),
                      d.line_len, d.disp_line);
                d.line_len := d.line_len + 1;
                g17hexto_line (d.buf^
                      [d.bufpos + code_col1 + col * c_chr_per_block],
                      d.line_len, d.disp_line);
                d.line_len := d.line_len + c_space
                END;
            (*ENDIF*) 
        (*ENDFOR*) 
        code_col1 := code_col1 + 1;
        xt08output_line (d);
        END;
    (*ENDFOR*) 
    d.cur_column := 1
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + CTABLE_MXSP00
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_c4int (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      c4 : tsp00_C4;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    IF  utds_edit in d.scan
    THEN
        xt08col_size_to_line (d, sizeof (c4));
    (*ENDIF*) 
    c4 [1] := d.buf^[d.bufpos  ];
    c4 [2] := d.buf^[d.bufpos+1];
    c4 [3] := d.buf^[d.bufpos+2];
    c4 [4] := d.buf^[d.bufpos+3];
    g17c4int_to_line (c4, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 4
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_err (VAR d: display_state_type;
            msg : tsp00_Sname);
 
VAR
      err : tsp00_IntMapC2;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    IF  utds_edit in d.scan
    THEN
        xt08col_size_to_line (d, sizeof (tgg00_BasisError));
    (*ENDIF*) 
    err.mapC2_sp00 [1] := d.buf^[d.bufpos  ];
    err.mapC2_sp00 [2] := d.buf^[d.bufpos+1];
    g17basis_err_to_line (err.mapInt_sp00, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + sizeof (tgg00_BasisError)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_date (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      date       : tsp00_Date;
      dummy_time : tsp00_Date;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    g17intdate_time (s20buf_to_int4 (d.buf^, d.bufpos), 0, date, dummy_time);
    g17date_to_line (date, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 4
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_datestr (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      i    : integer;
      date : tsp00_Date;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    FOR i := 1 TO sizeof (tsp00_Date) DO
        date [i] := d.buf^[d.bufpos - 1 + i];
    (*ENDFOR*) 
    xt08init_output_col (d, msg);
    IF  date <> bsp_date
    THEN
        g17date_to_line (date, d.line_len, d.disp_line);
    (*ENDIF*) 
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + sizeof (tsp00_Date)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_error(VAR d: display_state_type;
            msg : tsp00_C20);
 
VAR
      pC20 : ^tsp00_C20;
 
BEGIN
xt08init_left_output_col(d, 'ERROR :     ');
pC20  := @d.disp_line[d.line_len + 1];
pC20^ := msg;
d.line_len := d.line_len + sizeof(msg);
xt08output_line (d);
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_filename (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      is_ln3 : boolean;
      ln2    : tsp00_Line;
      ln3    : tsp00_Line;
      fn     : tgg00_Filename;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    IF  d.cur_column = 2
    THEN
        xt08new_line (d);
    (*ENDIF*) 
    xt08blank_line (d);
    SAPDB_PascalForcedMove (d.bufsize, sizeof (fn),
          @d.buf^, d.bufpos, @fn, 1, sizeof (fn));
    g17filename (msg, fn, 0, d.disp_line, ln2, ln3, is_ln3);
    xt08output_line (d);
    d.disp_line := ln2;
    xt08output_line (d);
    IF  is_ln3
    THEN
        BEGIN
        d.disp_line := ln3;
        xt08output_line (d)
        END;
    (*ENDIF*) 
    xt08blank_line (d);
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + sizeof (fn)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_fvers (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      vers : tgg91_FileVersion;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
    AND
    (d.bufpos + sizeof (vers) - 1 <= d.bufsize)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    IF  utds_edit in d.scan
    THEN
        xt08col_size_to_line (d, sizeof (vers));
    (*ENDIF*) 
    vers.ci2_gg00 [1] := d.buf^[d.bufpos  ];
    vers.ci2_gg00 [2] := d.buf^[d.bufpos+1];
    gg06FileVersToLine (vers, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + sizeof (vers)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_b20_queue_elems (VAR d : display_state_type);
 
VAR
      last_follow_page : boolean;
      entries_in_page  : integer;
      i                : integer;
      rec_length       : integer;
 
BEGIN
rec_length := sizeof (tsp00_BufAddr)
      + sizeof (tsp00_BufAddr)
      + sizeof (tsp00_BufAddr)
      + sizeof (tsp00_Int4)
      + sizeof (tsp00_Int4);
xt08put_header (d, 13);
entries_in_page  := xt08ord2a (d.buf^, d.bufpos);
last_follow_page := d.buf^[d.bufpos + 2] = chr (ord (true));
d.bufpos         := d.bufpos + 3;
IF  NOT (utds_full_info in d.scan) OR (d.pfkey <> pf_none)
THEN
    IF  last_follow_page
    THEN
        d.bufpos := d.bufpos + rec_length * entries_in_page
    ELSE
        d.bufpos := d.bufsize
    (*ENDIF*) 
ELSE
    BEGIN
    i := 1;
    WHILE i <= entries_in_page DO
        BEGIN
        xt08conditional_newscreen (d, 4);
        xt08put_addr             (d, 'QueueItem   ');
        xt08new_line             (d);
        xt08put_addr             (d, 'FixedNext   ');
        xt08put_addr             (d, 'VarNext     ');
        xt08put_procid           (d, 'TaskId      ');
        xt08put_task_queue_state (d, 'Reason      ');
        (* skip 4-byte filler *)
        d.bufpos := d.bufpos + 3;
        xt08new_line (d);
        i := i+1;
        IF  i <= entries_in_page
        THEN
            BEGIN
            d.disp_line := d.term^.blankline;
            xt08output_line (d)
            END
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  NOT last_follow_page
    THEN
        d.bufpos := d.bufsize
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_hashlist (VAR d : display_state_type);
 
CONST
      c_index_digits         =  7;
      c_items_per_dump_entry = 20;
 
VAR
      entrylength : integer; (* length of output for one array element*)
      i           : integer;
      k           : integer;
      index_no    : tsp00_Int4;
      region_no   : integer;     (* PTS 1105492 JA 2000-03-15 *)
 
BEGIN
xt08put_header (d, t09window_lines(d.term^) - 3);
IF  NOT (utds_full_info in d.scan) OR (d.pfkey <> pf_none)
THEN
    (* only add up lengths to find beginning of next dump rec *)
    d.bufpos := d.bufpos + sizeof (tkb05_RegionNo) + c_items_per_dump_entry *
          (sizeof (tsp00_Int4) + sizeof (tsp00_Addr))
ELSE
    BEGIN
    (* flush current line *)
    xt08new_line (d);
    (**)
    region_no   := xt08ord2a (d.buf^, d.bufpos);                     (* PTS 1105492 JA 2000-03-15 *)
    d.bufpos    := d.bufpos + sizeof (tkb05_RegionNo);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17sname_to_line ('REGION      ', d.line_len, d.disp_line);
    d.line_len  := d.line_len + 1;
    g17trimint4_to_line (region_no, d.line_len, d.disp_line);
    xt08output_line (d);
    (**)
    (* '1234567: FFFFFFFF' frame of output: *)
    entrylength := c_index_digits + 2 + 2 * sizeof (tsp00_Addr);
    (* formfeed if rest of output too long *)
    xt08conditional_newscreen (d, 5);
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    FOR i := 1 TO c_items_per_dump_entry DO
        BEGIN
        index_no := s20buf_to_int4 (d.buf^, d.bufpos);
        d.bufpos := d.bufpos + sizeof (tsp00_Int4);
        IF  index_no <= 0
        THEN
            d.bufpos := d.bufpos + sizeof (tsp00_Addr)
        ELSE
            BEGIN
            g17int4to_line (index_no, NOT c_with_zero, c_index_digits, d.line_len+1, d.disp_line);
            d.line_len               := d.line_len + c_index_digits + 1;
            d.disp_line [d.line_len] := ':';
            d.line_len               := d.line_len + 1;
            FOR k := 1 TO sizeof (tsp00_Addr) DO
                BEGIN
                g17hexto_line (d.buf^[d.bufpos], d.line_len, d.disp_line);
                d.bufpos := d.bufpos + 1
                END;
            (*ENDFOR*) 
            IF  d.line_len + 1 + entrylength >= d.line_size
            THEN
                BEGIN
                xt08output_line (d);
                d.disp_line := d.term^.blankline;
                d.line_len  := 0
                END
            ELSE
                d.line_len := d.line_len + 1
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    IF  d.line_len > 0
    THEN
        (* flush last line *)
        xt08output_line (d);
    (*ENDIF*) 
    d.cur_column := 1
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_hdlist (VAR d : display_state_type;
            first_page : boolean);
 
VAR
      last_follow_page : boolean;
      entries_in_page  : integer; (* number of recs in this page *)
      i                : integer;
      index            : integer;
      offset           : integer;
      hd_elem_len      : integer;
      arr_el_header    : tsp00_Sname;   (* string-variable for header *)
 
BEGIN
hd_elem_len := sizeof (tsp00_Int4)     (* array index    *)
      +        sizeof (tsp00_BufAddr)  (* he_cb          *)
      +        sizeof (tsp00_Int4);    (* he_old_occ_cnt *)
hd_elem_len := hd_elem_len + sizeof (tsp00_BufAddr); (* he_free_pno *)
IF  sizeof (tsp00_Addr) = 8
THEN
    hd_elem_len := hd_elem_len + sizeof (tsp00_Int4); (* he_filler *)
(*ENDIF*) 
xt08put_header (d, 4);
IF  first_page
THEN
    offset := 8
ELSE
    offset := 0;
(*ENDIF*) 
entries_in_page  := xt08ord2a (d.buf^, d.bufpos + offset);
last_follow_page := (d.buf^[d.bufpos + 2 + offset] = chr (ord (true)));
IF  NOT (utds_full_info in d.scan) OR (d.pfkey <> pf_none)
THEN
    BEGIN
    IF  last_follow_page
    THEN
        d.bufpos:= d.bufpos + 3 + hd_elem_len * entries_in_page + offset
    ELSE
        d.bufpos := d.bufsize
    (*ENDIF*) 
    END
ELSE
    BEGIN
    IF  first_page
    THEN
        BEGIN
        xt08put_int (d, 'hd_list_size', 4);
        xt08put_int (d, 'elems used  ', 4);
        d.disp_line := d.term^.blankline;
        xt08output_line (d)
        END;
    (*ENDIF*) 
    d.bufpos      := d.bufpos + 3;
    arr_el_header := 'hdlist      ';
    i := 1;
    WHILE (i <= entries_in_page) AND (d.pfkey = pf_none) DO
        BEGIN
        xt08conditional_newscreen (d, 3);
        d.disp_line := d.term^.blankline;
        SAPDB_PascalForcedMove (sizeof (arr_el_header), sizeof (d.disp_line),
              @arr_el_header, 1, @d.disp_line, 1, sizeof (arr_el_header));
        index    := s20buf_to_int4 (d.buf^, d.bufpos);
        d.bufpos := d.bufpos + 4;
        (* attach index to array-name *)
        g17int4to_line (index, c_pad_with_zero, 7, 9, d.disp_line);
        d.disp_line [16] := ':';
        xt08output_line (d);
        xt08put_addr (d, 'cb          '   );
        xt08put_int  (d, 'old_occ_cnt ', 4);
        IF  (sizeof (tsp00_Addr) = 8)
        THEN
            d.bufpos := d.bufpos + 4;
        (*ENDIF*) 
        xt08new_line (d);
        d.disp_line := d.term^.blankline;
        xt08output_line (d);
        i := i + 1
        END;
    (*ENDWHILE*) 
    IF  NOT last_follow_page
    THEN
        d.bufpos := d.bufsize
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_header (VAR d : display_state_type;
            line_limit      : integer);
 
CONST
      label_size = 8;
 
VAR
      err : integer;
 
BEGIN
IF  ((utds_dump_label in d.scan) OR
    ( utds_full_info  in d.scan))
    AND
    (d.pfkey = pf_none)
THEN
    BEGIN
    t12write_prot (d.prot^, d.term^.blankline, 1, err);
    d.disp_line := d.term^.blankline; (* clear line *)
    d.line_len  := label_size;
    SAPDB_PascalForcedMove (d.bufsize, sizeof (d.disp_line),
          @d.buf^, d.bufpos,
          @d.disp_line, 1, d.line_len);
    (* give position of dump record in buffer *)
    g17sname_to_line (' [block     ', d.line_len, d.disp_line);
    d.line_len := d.line_len + 1;
    g17trimint4_to_line (d.file_pos.utfp_block_no,
          d.line_len, d.disp_line);
    IF  d.file_pos.utfp_pages_per_block > 1
    THEN
        BEGIN
        d.line_len := d.line_len + 1;
        d.disp_line [d.line_len] := '/';
        g17trimint4_to_line (d.file_pos.utfp_page_no,
              d.line_len, d.disp_line)
        END;
    (*ENDIF*) 
    g17sname_to_line (', pos       ', d.line_len, d.disp_line);
    d.line_len := d.line_len + 1;
    g17trimint4_to_line (d.bufpos, d.line_len, d.disp_line);
    d.line_len := d.line_len + 1;
    d.disp_line [d.line_len] := ']';
    (*formfeeds depends on whether whole dump record or only*)
    (*its header is displayed                               *)
    IF  utds_full_info in d.scan
    THEN
        xt08conditional_newscreen (d, line_limit+1)
    ELSE
        xt08conditional_newscreen (d, 1);
    (*ENDIF*) 
    IF  d.pfkey = pf_none
    THEN
        BEGIN
        t12write_prot (d.prot^, d.disp_line, d.line_len, err);
        IF  utds_full_info in d.scan
        THEN
            t09put (d.term^, d.disp_line, cut_bright_protected)
        ELSE
            t09put (d.term^, d.disp_line, cut_protected);
        (*ENDIF*) 
        d.cur_column := 1
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + label_size + 2
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_hex (VAR d : display_state_type;
            msg          : tsp00_Sname;
            hexlength    : integer);
 
VAR
      new_line_wanted : boolean;
      cnt             : integer;
      rest_hexlen     : integer;
 
BEGIN
IF  NOT (utds_full_info in d.scan) OR (d.pfkey <> pf_none)
THEN
    (* only adds up lengths to find beginning of next dump rec *)
    d.bufpos := d.bufpos + hexlength
ELSE
    BEGIN
    (* spaces within hex output => (hexlength-1) DIV 4 *)
    IF  (d.cur_column = 2)
        AND
        (of_second_col + sizeof (msg) + 2
        + 2 * hexlength + (hexlength-1) DIV 4 > d.line_size)
    THEN
        xt08out_col_line (d);
    (*ENDIF*) 
    IF  d.cur_column = 1  (* left column *)
    THEN
        BEGIN
        d.disp_line := d.term^.blankline;
        d.line_len  := of_first_col; (* Tabulator for left col *)
        g17int4to_line (d.bufpos - d.bufoffset,
              c_pad_with_zero, mx_pos_displ, 1, d.disp_line);
        END
    ELSE
        d.line_len := of_second_col; (* right column *)
    (*ENDIF*) 
    (* move name of dump record component to display*)
    SAPDB_PascalForcedMove (sizeof (msg), sizeof (d.disp_line),
          @msg, 1, @d.disp_line, d.line_len+1, sizeof (msg));
    d.line_len := d.line_len + sizeof (msg) + 1;
    d.disp_line [d.line_len] := ':';
    d.line_len := d.line_len + 1;
    IF  d.bufpos - 1 + hexlength > d.bufsize
    THEN
        (* high bound checking error *)
        rest_hexlen := d.bufsize - d.bufpos + 1
    ELSE
        rest_hexlen := hexlength;
    (*ENDIF*) 
    WHILE (d.pfkey = pf_none) AND (rest_hexlen > 0) DO
        BEGIN
        cnt := 0;
        new_line_wanted := false;
        REPEAT
            g17hexto_line (d.buf^[d.bufpos], d.line_len, d.disp_line);
            d.bufpos    := d.bufpos + 1;
            rest_hexlen := rest_hexlen - 1;
            cnt         := cnt + 1;
            IF  (cnt >= 4) AND (rest_hexlen > 0)
            THEN
                BEGIN
                cnt        := 0;
                d.line_len := d.line_len + 1;
                IF  rest_hexlen < 4
                THEN
                    new_line_wanted :=
                          (d.line_len + 2 * rest_hexlen > d.line_size)
                ELSE
                    new_line_wanted := (d.line_len + 8 > d.line_size)
                (*ENDIF*) 
                END
            (*ENDIF*) 
        UNTIL
            new_line_wanted OR (rest_hexlen <= 0);
        (*ENDREPEAT*) 
        IF  rest_hexlen > 0
        THEN
            BEGIN
            xt08out_col_line (d);
            d.cur_column := 2;
            d.disp_line  := d.term^.blankline;
            d.line_len   := of_first_col + sizeof (msg) + 2
            END
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  d.pfkey = pf_none
    THEN
        xt08write_output_col (d)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_hostinfo (VAR d : display_state_type);
 
BEGIN
xt08put_int     (d, 'volume_no   ', 2);
xt08put_int     (d, 'swap_check  ', 4);
xt08put_int     (d, 'file_version', 4);
xt08put_int     (d, 'blocksize   ', 2);
xt08put_int     (d, 'max_volume  ', 2);
xt08put_int     (d, 'page_count  ', 4);
xt08put_int     (d, 'bd_page_cnt ', 4);
xt08put_int     (d, 'vol_page_cnt', 4);
xt08put_int     (d, 'used_tapes  ', 4);
xt08put_char    (d, 'curr_knlvers',40);
xt08put_char    (d, 'knlvers     ',40);
xt08put_char    (d, 'serverdb    ',18);
xt08put_char    (d, 'servernode  ',64);
xt08put_bool    (d, 'is_consisten'   );
xt08put_bool    (d, 'is_clustered'   );
xt08put_int     (d, 'first_lpno  ', 4);
xt08put_int     (d, 'last_lpno   ', 4);
xt08put_datestr (d, 'start_date  '   );
xt08put_timestr (d, 'start_time  '   );
xt08put_datestr (d, 'end_date    '   );
xt08put_timestr (d, 'end_time    '   );
xt08put_datestr (d, 'dbstamp1_dat'   );
xt08put_timestr (d, 'dbstamp1_tim'   );
xt08put_datestr (d, 'dbstamp2_dat'   );
xt08put_timestr (d, 'dbstamp2_tim'   );
xt08put_char    (d, 'kern label  ',14);      (* PTS 1130971 mb 2004-08-22 *)
xt08skip_filler (d, 2);                      (* PTS 1105071 UH 17-01-2000 *)
xt08put_char    (d, 'db_ident    ', 60);
xt08skip_filler (d, sizeof(tsp00_Line) -60); (* PTS 1105071 UH 17-01-2000 *)
xt08put_int     (d, 'max_used_dat', 4);      (* PTS 1105071 UH 17-01-2000 *)
xt08put_int     (d, 'cnv_page_cnt', 4);
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_int (VAR d : display_state_type;
            msg          : tsp00_Sname;
            intlength    : integer);
 
VAR
      intval : tsp00_Int4; (* contains value of integer in buffer *)
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
    AND
    (d.bufpos + intlength - 1 <= d.bufsize)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    CASE intlength OF
        1:
            intval := ord       (d.buf^ [d.bufpos]);
        2:
            intval := xt08ord2a (d.buf^, d.bufpos);
        4:
            intval := s20buf_to_int4   (d.buf^, d.bufpos);
        END;
    (*ENDCASE*) 
    IF  utds_edit in d.scan
    THEN
        BEGIN
        d.disp_line [of_col_type + 1 + 2*(d.cur_column-1)] :=
              c_int_indicator;
        xt08col_size_to_line (d, intlength)
        END;
    (*ENDIF*) 
    IF  intval = NIL_PAGE_NO_GG00
    THEN
        g17sname_to_line ('nil_pno     ', d.line_len, d.disp_line)
    ELSE
        IF  intval = -1
        THEN
            g17sname_to_line ('nil         ', d.line_len, d.disp_line)
        ELSE
            (* display as an integer *)
            g17trimint4_to_line (intval, d.line_len, d.disp_line);
        (*ENDIF*) 
    (*ENDIF*) 
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + intlength
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_kb3all (VAR d : display_state_type;
            msg : tsp00_Sname);
 
TYPE
      kb3_all_states = (
            sy_allocated,        (* dynpool and dyndata are allocated *)
            sy_bup_working,      (* label-I/O without reset glob data *)
            sy_configured,       (* config pages are copied to BD     *)
            sy_error,            (* an error is occurred              *)
            sy_initialized,      (* global data are initialized       *)
            sy_knockoffwork,     (* starting end phase                *)
            sy_restoreconfig,    (* restore config pages from tape    *)
            sy_filler7);
      kb3_system_state = PACKED SET OF kb3_all_states;
 
VAR
 
      all_states : RECORD
            CASE integer OF
                1:
                    (c : tsp00_C2);
                2:
                    (s : kb3_system_state);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_left_output_col (d, msg);
    all_states.c [1] := d.buf^[d.bufpos];
    IF  all_states.s = [ ]
    THEN
        g17sname_to_line ('empty       ', d.line_len, d.disp_line)
    ELSE
        BEGIN
        d.line_len := d.line_len - 1;
        IF  sy_allocated in all_states.s
        THEN
            g17sname_to_line (' alloc      ', d.line_len, d.disp_line);
        (*ENDIF*) 
        IF  sy_bup_working in all_states.s
        THEN
            g17sname_to_line (' bup        ', d.line_len, d.disp_line);
        (*ENDIF*) 
        IF  sy_configured in all_states.s
        THEN
            g17sname_to_line (' conf       ', d.line_len, d.disp_line);
        (*ENDIF*) 
        IF  sy_error in all_states.s
        THEN
            g17sname_to_line (' error      ', d.line_len, d.disp_line);
        (*ENDIF*) 
        IF  sy_initialized in all_states.s
        THEN
            g17sname_to_line (' init       ', d.line_len, d.disp_line);
        (*ENDIF*) 
        IF  sy_knockoffwork in all_states.s
        THEN
            g17sname_to_line (' knockoff   ', d.line_len, d.disp_line);
        (*ENDIF*) 
        IF  sy_restoreconfig in all_states.s
        THEN
            g17sname_to_line (' reconf     ', d.line_len, d.disp_line);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  d.pfkey = pf_none
    THEN
        xt08output_line (d);
    (*ENDIF*) 
    d.cur_column := 1
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_kb5info (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
 
      te_info : RECORD
            CASE integer OF
                1:
                    (c : tsp00_C2);
                2:
                    (s : tkb05_TransInfo);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_left_output_col (d, msg);
    te_info.c [1] := d.buf^[d.bufpos  ];
    te_info.c [2] := d.buf^[d.bufpos+1];
    IF  te_info.s = [ ]
    THEN
        g17sname_to_line ('empty       ', d.line_len, d.disp_line)
    ELSE
        BEGIN
        d.line_len := d.line_len - 1;
        IF  tiAuxPermExists_ekb05 in te_info.s
        THEN
            g17sname_to_line (' auxp       ', d.line_len, d.disp_line);
        (*ENDIF*) 
        IF  tiAuxTempExists_ekb05 in te_info.s
        THEN
            g17sname_to_line (' auxt       ', d.line_len, d.disp_line);
        (*ENDIF*) 
        IF  tiCollision_ekb05 in te_info.s
        THEN
            g17sname_to_line (' coll       ', d.line_len, d.disp_line);
        (*ENDIF*) 
        IF  tiExclusiveUser_ekb05 in te_info.s
        THEN
            g17sname_to_line (' user       ', d.line_len, d.disp_line);
        (*ENDIF*) 
        IF  tiUserTask_ekb05 in te_info.s
        THEN
            g17sname_to_line (' user       ', d.line_len, d.disp_line);
        (*ENDIF*) 
        IF  tiPriority_ekb05 in te_info.s
        THEN
            g17sname_to_line (' prio       ', d.line_len, d.disp_line);
        (*ENDIF*) 
        IF  tiCancelled_ekb05 in te_info.s
        THEN
            g17sname_to_line (' cancel     ', d.line_len, d.disp_line);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  d.pfkey = pf_none
    THEN
        xt08output_line (d);
    (*ENDIF*) 
    d.cur_column := 1
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_lockmode (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
 
      lock_mode : RECORD
            CASE integer OF
                1:
                    (c : tsp00_C2);
                2:
                    (m : tgg00_LockReqMode);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    lock_mode.c [1] := d.buf^[d.bufpos];
    g17lockmode_to_line (lock_mode.m, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_mess (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
 
      mess_type : RECORD
            CASE integer OF
                1:
                    (c : tsp00_C2);
                2:
                    (t : tgg00_MessType)
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    IF  utds_edit in d.scan
    THEN
        BEGIN
        d.disp_line [of_col_type + 1 + 2*(d.cur_column-1)] :=
              c_mtype_indicator;
        xt08col_size_to_line (d, sizeof (mess_type.t))
        END;
    (*ENDIF*) 
    mess_type.c [1] := d.buf^[d.bufpos];
    g17messtype_to_line (mess_type.t, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_mess2 (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
 
      mess2_type : RECORD
            CASE integer OF
                1:
                    (c : tsp00_C2);
                2:
                    (t : tgg00_MessType2)
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    IF  utds_edit in d.scan
    THEN
        BEGIN
        d.disp_line [of_col_type + 1 + 2*(d.cur_column-1)] :=
              c_mtype2_indicator;
        xt08col_size_to_line (d, sizeof (mess2_type.t))
        END;
    (*ENDIF*) 
    mess2_type.c [1] := d.buf^[d.bufpos];
    g17mess2type_to_line (mess2_type.t, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 1
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_oid (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      i   : integer;
      oid : tgg00_OidSpace;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
    AND
    (d.bufpos + sizeof (oid) - 1 <= d.bufsize)
THEN
    BEGIN
    xt08new_line (d);
    d.disp_line := d.term^.blankline; (* clear line *)
    d.line_len  := 1;
    xt08init_output_col (d, msg);
    FOR i := 1 TO sizeof (oid) DO
        oid.oidC8_gg00[i] := d.buf^ [d.bufpos+i-1];
    (*ENDFOR*) 
    gg06OidToLine (oid, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + sizeof (oid)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_pageref (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      i        : integer;
      page_ref : tgg91_PageRef;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
    AND
    (d.bufpos + sizeof (page_ref) - 1 <= d.bufsize)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    IF  utds_edit in d.scan
    THEN
        xt08col_size_to_line (d, sizeof (page_ref));
    (*ENDIF*) 
    FOR i := 1 TO sizeof (page_ref) DO
        page_ref.ci6_gg00 [i] := d.buf^ [d.bufpos+i-1];
    (*ENDFOR*) 
    g17page_ref_to_line (page_ref, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + sizeof (tgg91_PageRef)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_pagehead (VAR d : display_state_type;
            msg : tsp00_C8);
 
VAR
 
      nam : RECORD
            CASE integer OF
                1:
                    (n      : tsp00_Sname);
                2:
                    (main_n : tsp00_C8;
                    sub_n   : tsp00_C4)
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    nam.n      := bsp_sname;
    nam.main_n := msg;
    (* *)
    nam.sub_n := '.pno';
    xt08put_int (d, nam.n, 4);
    (* *)
    nam.sub_n := '.pt ';
    xt08put_pagetype (d, nam.n);
    (* *)
    nam.sub_n := '.pt2';
    xt08put_pagetype2 (d, nam.n);
    (* *)
    nam.sub_n := '.chk';
    xt08put_checktype (d, nam.n);
    (* *)
    nam.sub_n := '.mde';
    xt08put_any_set (d, nam.n, set_pagemode)
    END
ELSE
    d.bufpos := d.bufpos + sizeof (tgg00_PageHeader)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_pagetype (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
 
      page_type : RECORD
            CASE integer OF
                1:
                    (c : tsp00_C2);
                2:
                    (p : tgg00_PageType);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    IF  ord (d.buf^[d.bufpos]) >= ord (ptLastPageType_egg00)
    THEN
        xt08put_int (d, msg, 1)
    ELSE
        BEGIN
        xt08init_output_col (d, msg);
        IF  utds_edit in d.scan
        THEN
            xt08col_size_to_line (d, sizeof (tgg00_PageType));
        (*ENDIF*) 
        page_type.c [1] := d.buf^[d.bufpos];
        g17pagetype_to_line (page_type.p, d.line_len, d.disp_line);
        xt08write_output_col (d);
        d.bufpos := d.bufpos + 1
        END
    (*ENDIF*) 
    END
ELSE
    d.bufpos := d.bufpos + 1
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_pagetype2 (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
 
      page_type : RECORD
            CASE integer OF
                1:
                    (c : tsp00_C2);
                2:
                    (p : tgg00_PageType2);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    IF  ord (d.buf^[d.bufpos]) > ord (pt2OpenTrans_egg00)
    THEN
        xt08put_int (d, msg, 1)
    ELSE
        BEGIN
        xt08init_output_col (d, msg);
        IF  utds_edit in d.scan
        THEN
            xt08col_size_to_line (d, sizeof (tgg00_PageType2));
        (*ENDIF*) 
        page_type.c [1] := d.buf^[d.bufpos];
        g17pagetype2_to_line (page_type.p, d.line_len, d.disp_line);
        xt08write_output_col (d);
        d.bufpos := d.bufpos + 1
        END
    (*ENDIF*) 
    END
ELSE
    d.bufpos := d.bufpos + 1
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_pno (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      try_again : boolean;
      intval    : tsp00_Int4;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    REPEAT
        try_again := false;
        xt08init_output_col (d, msg);
        IF  utds_edit in d.scan
        THEN
            xt08col_size_to_line (d, sizeof (tsp00_Int4));
        (*ENDIF*) 
        intval := s20buf_to_int4 (d.buf^, d.bufpos);
        IF  intval = NIL_PAGE_NO_GG00
        THEN
            g17sname_to_line ('nil_pno     ', d.line_len, d.disp_line)
        ELSE
            BEGIN
            g17trimint4_to_line (intval, d.line_len, d.disp_line);
            IF  (intval < -1) OR (intval > 9)
            THEN
                BEGIN
                d.line_len := d.line_len + 1;
                d.disp_line [d.line_len] := '/';
                x05hextrim_to_line (d.buf^, d.bufpos, 4, d.line_len,
                      d.disp_line)
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (d.cur_column = 2) AND (d.line_len > d.line_size)
        THEN
            BEGIN
            try_again := true;
            SAPDB_PascalForcedFill (sizeof (d.disp_line), @d.disp_line, of_second_col+1,
                  d.line_len - of_second_col, ' ')
            END;
        (*ENDIF*) 
        xt08write_output_col (d)
    UNTIL
        NOT try_again;
    (*ENDREPEAT*) 
(*ENDIF*) 
d.bufpos := d.bufpos + 4
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_procid (VAR d : display_state_type;
            msg : tsp00_Sname);
 
BEGIN
IF  NOT (utds_full_info in d.scan) OR (d.pfkey <> pf_none)
THEN
    d.bufpos := d.bufpos + 4
ELSE
    xt08put_int (d, msg, 4)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_remote_mhead (VAR d : display_state_type);
 
BEGIN
IF  d.cur_column = 2
THEN
    xt08new_line (d);
(* --- kb9mh_trans --- *)
(*ENDIF*) 
xt08put_sess_tr (d, 'tcdSessTrans'   );
xt08put_int     (d, 'tcdChild    ', 4);
(* *)
xt08put_trans   (d, 'tcdConsView '   );
xt08skip_filler (d, 2);
(* *)
xt08put_any_set (d, 'tsdState    ', set_trans_state);
xt08put_err     (d, 'tcdError    '   );
xt08put_int     (d, 'tcdWarning  ', 2);
xt08put_int     (d, 'tcdObjReqTmo', 2);
(* *)
xt08put_int     (d, 'tcdTempLimit', 4);
xt08put_int     (d, 'tcdTempCount', 4);
(* *)
xt08put_cnt     (d, 'tcdIoCount  '   );
IF  d.cur_column = 2
THEN
    xt08new_line (d);
(* --- kb9mh_mblock --- *)
(*ENDIF*) 
xt08put_int     (d, 'mb_qual_len ', 4);
xt08put_int     (d, 'mb_data_len ', 4);
xt08skip_filler (d, 8);
(* *)
xt08put_site    (d, 'mb_src_site '   );
xt08put_bool    (d, 'mb_reply    '   );
xt08put_int     (d, 'mb_replicted', 1);
xt08put_mess    (d, 'mb_type     '   );
xt08put_mess2   (d, 'mb_type2    '   );
xt08put_int     (d, 'mb_struct   ', 1);
xt08skip_filler (d, 1)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_session (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      session : tgg91_SessionNo;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    IF  utds_edit in d.scan
    THEN
        xt08col_size_to_line (d, sizeof (session));
    (*ENDIF*) 
    SAPDB_PascalForcedMove (d.bufsize, sizeof (session),
          @d.buf^, d.bufpos, @session, 1, sizeof (session));
    gg06SessionToLine (session, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + sizeof (session)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_site (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      site : tgg00_ServerdbNo;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    IF  utds_edit in d.scan
    THEN
        xt08col_size_to_line (d, sizeof (site));
    (*ENDIF*) 
    site [1] := d.buf^[d.bufpos  ];
    site [2] := d.buf^[d.bufpos+1];
    g17siteto_line (site, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 2
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_surro (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      i         : integer;
      surrogate : tgg00_Surrogate;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_left_output_col (d, msg);
    IF  d.pfkey = pf_none
    THEN
        BEGIN
        FOR i := 1 TO sizeof (tgg00_Surrogate)  DO
            surrogate [i] := d.buf^[d.bufpos + i - 1];
        (*ENDFOR*) 
        g17surrogate_to_line (surrogate, d.line_len, d.disp_line);
        xt08output_line (d)
        END;
    (*ENDIF*) 
    d.cur_column := 1
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + sizeof (tgg00_Surrogate)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_time (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      time       : tsp00_Time;
      dummy_date : tsp00_Date;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    g17intdate_time (0, s20buf_to_int4 (d.buf^, d.bufpos), dummy_date, time);
    g17time_to_line (time, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + 4
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_timestr (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      i    : integer;
      time : tsp00_Time;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    FOR i := 1 TO sizeof (tsp00_Time) DO
        time [i] := d.buf^[d.bufpos - 1 + i];
    (*ENDFOR*) 
    xt08init_output_col (d, msg);
    IF  time <> bsp_time
    THEN
        g17time_to_line (time, d.line_len, d.disp_line);
    (*ENDIF*) 
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + sizeof (tsp00_Time)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_trans (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      trans : tgg91_TransNo;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    IF  utds_edit in d.scan
    THEN
        xt08col_size_to_line (d, sizeof (trans));
    (*ENDIF*) 
    SAPDB_PascalForcedMove (d.bufsize, sizeof (trans),
          @d.buf^, d.bufpos, @trans, 1, sizeof (trans));
    gg06TransToLine (trans, d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + sizeof (trans)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_sess_tr (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      try_again  : boolean;
      session    : tgg91_SessionNo;
      writetrans : tgg91_TransNo;
      trans      : tgg91_TransNo;
      subtrans   : tgg00_SubtransNo;
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
THEN
    BEGIN
    SAPDB_PascalForcedMove (d.bufsize, sizeof (session),
          @d.buf^, d.bufpos, @session, 1, sizeof (session));
    d.bufpos := d.bufpos + sizeof (session);
    (**)
    SAPDB_PascalForcedMove (d.bufsize, sizeof (trans),
          @d.buf^, d.bufpos, @trans, 1, sizeof (trans));
    d.bufpos := d.bufpos + sizeof (trans);
    (**)
    SAPDB_PascalForcedMove (d.bufsize, sizeof (writetrans),
          @d.buf^, d.bufpos, @trans, 1, sizeof (writetrans));
    d.bufpos := d.bufpos + sizeof (writetrans);
    (**)
    SAPDB_PascalForcedMove (d.bufsize, sizeof (subtrans),
          @d.buf^, d.bufpos, @subtrans, 1, sizeof (subtrans));
    d.bufpos := d.bufpos + sizeof (subtrans);
    REPEAT
        try_again := false;
        xt08init_output_col (d, msg);
        gg17SessionTransToLine (session, trans, writetrans, subtrans, d.line_len, d.disp_line);
        IF  (d.cur_column = 2) AND (d.line_len > d.line_size)
        THEN
            BEGIN
            try_again := true;
            SAPDB_PascalForcedFill (sizeof (d.disp_line), @d.disp_line, of_second_col+1,
                  d.line_len - of_second_col, ' ')
            END;
        (*ENDIF*) 
        xt08write_output_col (d)
    UNTIL
        NOT try_again
    (*ENDREPEAT*) 
    END
ELSE
    d.bufpos := d.bufpos + sizeof (session) + sizeof (trans) + sizeof (subtrans)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_treeid (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
      is_ln3      : boolean;
      aux_vt_attr : char;
      ln2         : tsp00_Line;
      ln3         : tsp00_Line;
      fn          : tgg00_Filename;
 
BEGIN
xt08new_line (d);
xt08conditional_newscreen (d, 10);
IF  NOT t09is_empty_window (d.term^) AND (msg <> bsp_sname)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    xt08output_line (d)
    END;
(*ENDIF*) 
IF  (utds_full_info in d.scan)
    AND (d.pfkey = pf_none)
    AND (msg <> bsp_sname)
THEN
    BEGIN
    d.disp_line := d.term^.blankline;
    d.line_len  := 0;
    g17sname_to_line (msg, d.line_len, d.disp_line);
    aux_vt_attr := d.vt_attr;
    d.vt_attr   := cut_bright_protected;
    xt08output_line (d);
    d.vt_attr := aux_vt_attr
    END;
(*ENDIF*) 
xt08put_hex     (d, 'fileRootChck', 4);
xt08put_int     (d, 'fileLeafNode', 4);
xt08put_pageref (d, 'fileUserRef '   );
xt08put_fvers   (d, 'fileVersion '   );
xt08put_pno     (d, 'fileRoot    '   );
IF  d.cur_column = 2
THEN
    xt08new_line  (d);
(*ENDIF*) 
xt08put_any_set (d, 'fileHandling', set_handling);
xt08put_any_set (d, 'fileBdUse   ', set_bd_use  );
xt08put_any_set (d, 'fileType    ', set_filetype);
SAPDB_PascalForcedMove (d.bufsize, sizeof (fn), @d.buf^, d.bufpos, @fn, 1, sizeof (fn));
d.bufpos := d.bufpos + sizeof (fn);
g17filename ('fileName    ', fn, 0, d.disp_line, ln2, ln3, is_ln3);
xt08output_line (d);
d.disp_line := ln2;
xt08output_line (d);
IF  is_ln3
THEN
    BEGIN
    d.disp_line := ln3;
    xt08output_line (d)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08put_uint2 (VAR d : display_state_type;
            msg : tsp00_Sname);
 
VAR
 
      univ_uint : RECORD
            CASE integer OF
                1:
                    (c2 : tsp00_C2);
                2:
                    (u2 : tsp00_Uint2)
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (utds_full_info in d.scan) AND (d.pfkey = pf_none)
    AND
    (d.bufpos + sizeof (tsp00_Uint2) - 1 <= d.bufsize)
THEN
    BEGIN
    xt08init_output_col (d, msg);
    univ_uint.c2 [1] := d.buf^ [d.bufpos  ];
    univ_uint.c2 [2] := d.buf^ [d.bufpos+1];
    IF  utds_edit in d.scan
    THEN
        BEGIN
        d.disp_line [of_col_type + 1 + 2*(d.cur_column-1)] := c_int_indicator;
        xt08col_size_to_line (d, sizeof (tsp00_Uint2))
        END;
    (*ENDIF*) 
    g17trimint4_to_line (gg06Int4FromUint2 (univ_uint.u2), d.line_len, d.disp_line);
    xt08write_output_col (d)
    END;
(*ENDIF*) 
d.bufpos := d.bufpos + sizeof (tsp00_Uint2)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08restart_param (VAR d : display_state_type);
 
BEGIN
xt08new_line (d);
(* *)
(* ----- config ----- *)
xt08put_int      (d, 'crSnapShotBA', 4);
xt08put_int      (d, 'crConvRootBA', 4);
xt08put_int      (d, 'crFdirRoot  ', 4);
xt08put_int      (d, 'crLngDirRoot', 4);
xt08put_int      (d, 'crMaxDynPno ', 4);
xt08put_int      (d, 'crMaxStatPno', 4);
xt08put_bool     (d, 'crRecovIncom'   );
xt08put_int      (d, 'crVolBitCnt ', 1);
xt08put_int      (d, 'ClstrBlkCnt ', 2);
xt08put_int      (d, 'FDirEntrCnt ', 4);
xt08put_int      (d, 'ClusterSpace', 4);
xt08skip_filler  (d, 4);
xt08put_char     (d, 'crReleaseVrs', sizeof (tsp00_Version));
xt08skip_filler  (d, 72);
xt08new_line     (d);
(* *)
(* ----- last_savept ----- *)
xt08savept_param (d);
xt08skip_filler  (d, 64);
(* *)
(* ----- last_surrogate ----- *)
xt08put_session  (d, 'srgSession  '   );
xt08skip_filler  (d, 4);
xt08put_surro    (d, 'srgSurrogate'   );
xt08put_surro    (d, 'srgSyskey   '   );
xt08put_trans    (d, 'srgTrans    '   );
xt08skip_filler  (d,  2);
(* ------ *)
xt08skip_filler  (d, 72);
xt08new_line     (d);
(* *)
xt08skip_filler  (d, 140); (* PTS 1000333 UH *)
xt08put_int      (d, 'rstTotLogSiz', 4); (* PTS 1107544 UH 2000-08-21 *)
(* ------ backup ------ *)
(* *)
xt08put_int      (d, 'rstDatBupCnt', 4); (* PTS 1000333 UH *)
xt08put_int      (d, 'rstLastDataB', 4); (* PTS 1000333 UH *)
(* *)
xt08put_char     (d, 'rstReleaseVe', sizeof (tsp00_Version));
xt08put_char     (d, 'rstDbIdent  ', 60);
xt08skip_filler  (d,                 sizeof (tsp00_Line) - 60);
xt08new_line     (d); (* flush last line *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08savept_param (VAR d : display_state_type);
 
BEGIN
xt08put_int     (d, 'svpId       ', 4);
xt08put_int     (d, 'svpReason   ', 1);
xt08skip_filler (d,                 1);
xt08put_uint2   (d, 'svpOpenTrans'   );
(* *)
xt08put_int     (d, 'svpIOseqNo  ', 4); (* unit4 - Log_IOSequenceNo *)
xt08put_int     (d, 'svpStrtDevOf', 4); (* unit4 - Log_RawDeviceOffset *)
(* *)
xt08put_uint2   (d, 'svpStrtEntOf'   );
xt08put_int     (d, 'svpStrtEntTp', 1);
xt08skip_filler (d,                 5);
(* *)
xt08put_int     (d, 'svpOpnTrnsRo',  4);
xt08put_int     (d, 'svpHistoryRo',  4);
(* *)
xt08put_date    (d, 'svpDate     '   );
xt08put_time    (d, 'svpTime     '   );
(* *)
xt08put_date    (d, 'svpEntryDate'   );
xt08put_time    (d, 'svpEntryTime'   );
(* *)
xt08skip_filler (d,                56);
(* *)
xt08new_line    (d                   )
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08skip_filler (VAR d : display_state_type;
            filler_len       : tsp00_Int4);
 
BEGIN
IF  (utds_edit in d.scan) AND (d.cur_column = 2)
THEN
    xt08new_line (d);
(*ENDIF*) 
d.bufpos := d.bufpos + filler_len
END;
 
(*------------------------------*) 
 
PROCEDURE
      xt08write_output_col (VAR d : display_state_type);
 
BEGIN
IF  (d.cur_column = 1) AND (d.line_len < of_second_col)
THEN
    (* do not yet output, wait for second *)
    d.cur_column := 2
ELSE
    (* line is full: do output *)
    BEGIN
    xt08out_col_line (d);
    d.cur_column := 1
    END
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
