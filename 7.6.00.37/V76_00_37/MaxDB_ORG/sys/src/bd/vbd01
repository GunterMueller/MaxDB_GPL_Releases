.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.tt 1 $SQL$Project Distributed Database System$VBD01$
.tt 2 $$$$
.tt 3 $JuergenP$filesysteminterface_1$$$$$2000-11-10$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
Module  : filesysteminterface_1
=========
.sp
Purpose : base layer operations :
            - routines for system administration
            - general file operations
            - I/O routines for the restart/logging area
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        VAR
              b01downfilesystem : boolean;
              b01blankfilename  : tsp00_VFilename;
              b01zerokey        : tsp00_Key;
              b01fullkey        : tsp00_Key;
 
        PROCEDURE
              b01bcreate_bytestr (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              b01change_filetype (VAR t : tgg00_TransContext;
                    VAR file_id  : tgg00_FileId;
                    new_filetype : tgg00_FiletypeSet);
 
        PROCEDURE
              b01check_table (VAR t : tgg00_TransContext;
                    VAR file_id          : tgg00_FileId;
                    long_col_cnt         : tsp00_Int2;
                    new_long_col_cnt     : tsp00_Int2;
                    bWithExtendedCheck   : boolean;
                    check_long_existence : boolean;
                    bQuiet               : boolean;
                    bUpdateLeaves        : boolean);
 
        FUNCTION
              b01connect_allowed : boolean;
 
        PROCEDURE
              b01create_filesystem (VAR t : tgg00_TransContext);
 
        FUNCTION
              b01db_full( taskId : tsp00_TaskId ) : boolean;
 
        PROCEDURE
              b01dbspace_statistic (VAR t : tgg00_TransContext;
                    VAR info : tgg00_DbSpaceInfo);
 
        PROCEDURE
              b01destroy_file (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              b01empty_file (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              b01end_read_only (VAR t : tgg00_TransContext);
 
        PROCEDURE
              bd01CreatePermTableFile (
                    VAR trans    : tgg00_TransContext;
                    VAR fileId   : tgg00_FileId;
                    eFiletypeSet : tgg00_ExtendedFiletypeSet(*ptocConst*);
                    blobCount    : tsp00_Int2);
 
        PROCEDURE
              bd01CreateShortColumnFile (
                    VAR trans          : tgg00_TransContext;
                    VAR shortColId     : tgg00_FileId;
                    VAR tableSurrogate : tgg00_Surrogate);
 
        PROCEDURE
              b01filestate (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        FUNCTION
              b01get_bad_index_cnt : tsp00_Int4;
 
        PROCEDURE
              b01get_data_cache_workload (
                    VAR trans                  : tgg00_TransContext;
                    VAR DataCacheSize          : tsp00_Int4;
                    VAR OmsHistoryPageCnt      : tsp00_Int4;
                    VAR OmsDataPageCnt         : tsp00_Int4;
                    VAR OmsUnloadedVersPageCnt : tsp00_Int4;
                    VAR SqlDataPageCnt         : tsp00_Int4);
 
        PROCEDURE
              b01move_filecontent (VAR t : tgg00_TransContext;
                    VAR sourceFileId : tgg00_FileId;
                    VAR destFileId : tgg00_FileId);
 
        PROCEDURE
              b01next_fdir_entry (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        FUNCTION
              b01no_of_data_devs : tsp00_Int4;
 
        FUNCTION
              b01no_of_log_devs : tsp00_Int4;
 
        PROCEDURE
              b01pdestroy_perm_file (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              bd01DropLobFile (
                    VAR trans    : tgg00_TransContext;
                    VAR fileId   : tgg00_FileId;
                    parentFileNo : tgg00_Surrogate);
 
        PROCEDURE
              b01prefix_destroy_files (VAR t : tgg00_TransContext;
                    VAR prefix_fn : tgg00_Filename;
                    prefix_len    : integer);
 
        PROCEDURE
              b01pverify_participant (
                    VAR t              : tgg00_TransContext;
                    VAR file_id        : tgg00_FileId;
                    is_cold            : boolean;
                    bWithExtendedCheck : boolean);
 
        PROCEDURE
              bd01RenameFile (
                    VAR t          : tgg00_TransContext;
                    VAR parent_Id  : tgg00_Surrogate      (*ptocSynonym const tgg00_Surrogate&*);
                    VAR srcFileId  : tgg00_FileId;
                    VAR destFileId : tgg00_FileId);
 
        PROCEDURE
              b01reset_monitor (part : tgg00_MonitorPart);
 
        PROCEDURE
              b01restart_filesystem (VAR t : tgg00_TransContext;
                    IncrementConvVersion : boolean);
 
        PROCEDURE
              b01set_fileversion (VAR t : tgg00_TransContext;
                    VAR file_id     : tgg00_FileId;
                    new_fileversion : tgg91_FileVersion;
                    new_long_cnt    : tsp00_Int2);
 
        PROCEDURE
              b01treeleafnodes (VAR t     : tgg00_TransContext;
                    VAR file_id           : tgg00_FileId;
                    m_type                : tgg00_MessType;
                    VAR old_treeleafnodes : tsp00_Int4);
 
        PROCEDURE
              b01setto_zero_full_and_null;
 
        PROCEDURE
              b01sfile_statistic (
                    VAR t              : tgg00_TransContext;
                    VAR file_id        : tgg00_FileId;
                    with_shortcol_file : boolean;
                    VAR info           : tgg00_SampleInfo);
 
        PROCEDURE
              b01show_monitor (
                    TaskId   : tsp00_TaskId;
                    VAR info : tgg00_ReferenceInfo);
 
        PROCEDURE
              b01shutdown_filesystem (VAR t : tgg00_TransContext);
 
        PROCEDURE
              b01tcreate_file (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              b01tinit_temp_cache (VAR t : tgg00_TransContext;
                    is_control_session : boolean);
 
        PROCEDURE
              b01trelease_temp_cache (VAR t : tgg00_TransContext);
 
        PROCEDURE
              b01treset_file (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              b01verify_database (
                    VAR t                 : tgg00_TransContext;
                    bWithUpdate           : boolean;
                    bWithIndexes          : boolean;
                    bWithExtendedCheck    : boolean;
                    bWithDeleteUnreferencedBlobs : boolean;
                    VAR NumPermPages      : tsp00_Int4;
                    VAR NumReleasedBlocks : tsp00_Int4;
                    VAR bad_index_cnt     : tsp00_Int4;
                    VAR total_bad_cnt     : tsp00_Int4);
 
        PROCEDURE
              b01vstate_fileversion (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              bd01DataCacheSize (
                    VAR TotalPages : tsp00_Int4;
                    VAR UnMapPages : tsp00_Int4);
 
        FUNCTION
              bd01ConverterSize : tsp00_Int4;
 
        PROCEDURE
              bd01SetToBad (
                    VAR trans  : tgg00_TransContext;
                    VAR fileId : tgg00_FileId);
 
        PROCEDURE
              bd01SetToNilCurrent( VAR Current : tbd_current_tree );
 
        FUNCTION
              bd01UsableServerForParallelExecution : integer;
 
        PROCEDURE
              bd01CalculateClusterStatistics(
                    VAR trans        : tgg00_TransContext;
                    VAR fileId       : tgg00_FileId;
                    VAR leafCount    : tsp00_Int4;
                    VAR clusterCount : tsp00_Int4 );
 
        PROCEDURE
              bd01CalculateRecordsAndLeaves(
                    VAR Trans           : tgg00_TransContext;
                    VAR FileId          : tgg00_FileId;
                    VAR NumberOfLeaves  : tsp00_Int4;
                    VAR NumberOfRecords : tsp00_Int4 );
 
        PROCEDURE
              bd01GetLeafPageAndRecordCount(
                    VAR trans         : tgg00_TransContext;
                    VAR fileId        : tgg00_FileId;
                    countRecords      : boolean;
                    VAR leafPageCount : tsp00_Int4;
                    VAR recordCount   : tsp00_Int4);
 
        PROCEDURE
              bd01SampleRecordsAndLeaves(
                    VAR Trans            : tgg00_TransContext;
                    VAR FileId           : tgg00_FileId;
                    NumberOfSampleLeaves : tsp00_Int4;
                    VAR NumberOfLeaves   : tsp00_Int4;
                    VAR NumberOfRecords  : tsp00_Int4 );
 
        PROCEDURE
              bd01ExtractForeignKey(
                    VAR MessBlock : tgg00_MessBlock;
                    VAR AuxFileId : tgg00_FileId);
 
        PROCEDURE
              bd01MultiColumnStatistic(
                    VAR MessBlock        : tgg00_MessBlock;
                    VAR AuxFileId        : tgg00_FileId;
                    bCalculate           : boolean;
                    NumberOfSampleLeaves : tsp00_Int4;
                    VAR NumberOfLeaves   : tsp00_Int4;
                    VAR NumberOfRecords  : tsp00_Int4;
                    VAR DistinctValues   : tgg00_ColumnDistinctValues);
 
        PROCEDURE
              bd01MigrateDataBase(
                    TaskId      : tsp00_TaskId;
                    VAR TrError : tgg00_BasisError);
 
        PROCEDURE
              bd01ExtractTable (
                    VAR trans        : tgg00_TransContext;
                    root             : tsp00_PageNo;
                    VAR hostFileName : tsp00_VFilename);
              (*ptocExport hbd01_2.h*)
 
        FUNCTION
              b01devsize (dev_type : tsp2_dev_type;
                    devno : tsp00_Int4) : tsp00_Int4;
 
        PROCEDURE
              b01get_devname (dev_type : tsp2_dev_type;
                    devno       : tsp00_Int4;
                    VAR devname : tsp2_devname);
 
        PROCEDURE
              b01next_bad_dev (
                    VAR dev_type   : tsp2_dev_type;
                    VAR devno      : tsp00_Int4;
                    VAR devname    : tsp2_devname;
                    VAR really_bad : boolean);
 
        PROCEDURE
              b01next_dev_info (
                    VAR dev_no          : tsp00_Int4;
                    VAR dev_type        : tsp2_dev_type;
                    VAR dev_name        : tsp2_devname;
                    VAR dev_size        : tsp00_Int4;
                    VAR dev_used_blocks : tsp00_Int4;
                    VAR dev_online      : boolean;
                    VAR dev_state       : tsp00_C18);
              (*ptocExport hbd01_1.h*)
 
        VAR
              b01nilcurrent : tbd_current_tree;
              b01niltree_id : tgg00_FileId;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              filesysteminterface_2 : VBD02;
 
        PROCEDURE
              b02eval_page_count (VAR t : tgg00_TransContext;
                    VAR file_id      : tgg00_FileId;
                    VAR startkey     : tgg00_Lkey;
                    VAR stopkey      : tgg00_Lkey;
                    count_records    : boolean;
                    VAR page_count   : tsp00_Int4;
                    VAR all_page_cnt : tsp00_Int4;
                    VAR record_cnt   : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_3 : VBD03;
 
        PROCEDURE
              b03calculate_page_count (VAR t : tgg00_TransContext;
                    VAR file_id      : tgg00_FileId;
                    VAR startkey     : tgg00_Lkey;
                    VAR stopkey      : tgg00_Lkey;
                    count_records    : boolean;
                    VAR page_count   : tsp00_Int4;
                    VAR min_page_cnt : tsp00_Int4;
                    VAR record_cnt   : tsp00_Int4);
 
        PROCEDURE
              bd03ReleaseInvTree (VAR Trans  : tgg00_TransContext;
                    VAR FiledId              : tgg00_FileId);
 
        PROCEDURE
              bd03VerifyInvTree (
                    VAR Trans          : tgg00_TransContext;
                    VAR FiledId        : tgg00_FileId;
                    IsCold             : boolean;
                    bWithExtendedCheck : boolean;
                    VAR NumPages       : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_5 : VBD05;
 
        PROCEDURE
              bd05DropLob (
                    VAR trans    : tgg00_TransContext;
                    VAR fileId   : tgg00_FileId;
                    parentFileNo : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              error_text_handling : VBD06;
 
        PROCEDURE
              b06init_errtxt;
 
        PROCEDURE
              b06write_filename_and_root (VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              pagestore : VBD10;
 
        FUNCTION
              bd10IsConnectAllowed : boolean;
 
        FUNCTION
              bd10IsDbFull( TaskId : tsp00_TaskId ) : boolean;
 
        FUNCTION
              bd10ConverterSize : tsp00_Int4;
 
        PROCEDURE
              b10create_converter (
                    TaskId      : tsp00_TaskId;
                    NumAllPages : tsp00_Int4);
 
        FUNCTION
              bd10GetConverterVersion : tsp00_Int4;
 
        PROCEDURE
              bd10dbspace_statistic (VAR t : tgg00_TransContext;
                    VAR info : tgg00_DbSpaceInfo);
 
        PROCEDURE
              bd10EndColdVerify (
                    TaskId                : tsp00_TaskId;
                    VAR NumPermPages      : tsp00_Int4;
                    VAR NumReleasedBlocks : tsp00_Int4);
 
        PROCEDURE
              bd10EndFailedColdVerify (TaskId : tsp00_TaskId);
 
        PROCEDURE
              bd10FlushConverterSerial (VAR Trans : tgg00_TransContext;
                    VAR ConverterVersion           : tsp00_Int4;
                    VAR MaxStaticPageNo            : tsp00_PageNo;
                    VAR MaxDynamicPageNo           : tsp00_PageNo;
                    VAR PackedConvRootBlockAddress : tsp00_Int4);
 
        PROCEDURE
              bd10BeginColdVerify (VAR Trans : tgg00_TransContext);
 
        PROCEDURE
              b10rc_restart_converter (
                    TaskId                 : tsp00_TaskId;
                    VAR TrError            : tgg00_BasisError;
                    ConverterVersion       : tsp00_Int4;
                    NumAllPages            : tsp00_Int4;
                    IncrementConvVersion   : boolean;
                    LastSaveDataSuccessful : boolean;
                    VAR RestartParam       : tkb00_ConfigRestartParam);
 
        PROCEDURE
              bd10ShutdownConverter (TaskId : tsp00_TaskId);
 
      ------------------------------ 
 
        FROM
              free_block_management : VBD11;
 
        FUNCTION
              b11_blocks_used (dev_no : tsp00_Int2) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Trace : VBD120;
 
        PROCEDURE
              b120InsertTrace (VAR t   : tgg00_TransContext;
                    trace_layer  : tgg00_Debug;
                    trace_object : tgg00_VtraceType;
                    body_len     : tsp00_Int2;
                    trace_body   : tgg11_VtraceBodyPtr);
 
      ------------------------------ 
 
        FROM
              nodehandling : VBD13;
 
        PROCEDURE
              bd13FreeNewRoot(
                    VAR current : tbd_current_tree );
 
        PROCEDURE
              b13free_node (
                    VAR Nptrs   : tbd_node_ptrs;
                    VAR Current : tbd_current_tree);
 
      ------------------------------ 
 
        FROM
              filedirectory : VBD17;
 
        PROCEDURE
              b17repl_fdir (VAR fn : tgg00_Filename;
                    VAR fi      : tbd_fileinfo;
                    shared_file : boolean;
                    VAR t       : tgg00_TransContext);
 
        PROCEDURE
              b17del_fdir (VAR fn   : tgg00_Filename;
                    shared_file     : boolean;
                    VAR t           : tgg00_TransContext);
 
        PROCEDURE
              b17next_del_fdir (VAR prefix : tgg00_Filename;
                    prefix_len      : integer;
                    VAR fn          : tgg00_Filename;
                    VAR fi          : tbd_fileinfo;
                    VAR t           : tgg00_TransContext);
 
        PROCEDURE
              b17state_fdir (VAR fn : tgg00_Filename;
                    VAR fi      : tbd_fileinfo;
                    shared_file : boolean;
                    VAR t       : tgg00_TransContext);
 
        PROCEDURE
              b17reset_read_only (VAR t : tgg00_TransContext);
 
        PROCEDURE
              bd17AddBlobToFDir (
                    VAR trans : tgg00_TransContext;
                    VAR fn    : tgg00_Filename;
                    VAR fi    : tbd_fileinfo);
 
        PROCEDURE
              bd17CreateBlobFDir (VAR t : tgg00_TransContext);
 
        PROCEDURE
              bd17GetNextBlob (
                    VAR trans    : tgg00_TransContext;
                    VAR filename : tgg00_Filename;
                    VAR fileInfo : tbd_fileinfo);
 
        PROCEDURE
              bd17RestartBlobFdir (
                    VAR t          : tgg00_TransContext;
                    blob_fdir_root : tsp00_PageNo);
 
        PROCEDURE
              bd17RenameFile(
                    VAR trans      : tgg00_TransContext;
                    VAR srcFileId  : tgg00_FileId;
                    VAR destFileId : tgg00_FileId;
                    VAR parent_Id  : tgg00_Surrogate);
 
        PROCEDURE
              bd17VerifyBlobFdir (
                    VAR trans          : tgg00_TransContext;
                    bIsCold            : boolean;
                    bWithExtendedCheck : boolean);
 
      ------------------------------ 
 
        FROM
              systembufferinterface : VBD20;
 
        PROCEDURE
              bd20InitDataCache (
                    TaskId          : tsp00_TaskId;
                    VAR TrError     : tgg00_BasisError;
                    TotalFreeFrames : tsp00_Int4;
                    TotalDataPages  : tsp00_Int4);
 
        PROCEDURE
              bd20GetCacheSize( VAR TotalPages : tsp00_Int4 );
 
        PROCEDURE
              bd20GetWorkloadCounter (
                    VAR DataCacheSize          : tsp00_Int4;
                    VAR OmsHistoryPageCnt      : tsp00_Int4;
                    VAR OmsDataPageCnt         : tsp00_Int4;
                    VAR OmsUnloadedVersPageCnt : tsp00_Int4;
                    VAR SqlDataPageCnt         : tsp00_Int4);
 
        PROCEDURE
              bd20FlushDataCache (VAR t : tgg00_TransContext);
 
        PROCEDURE
              bd20ShutdownDataCache ( TaskId : tsp00_TaskId );
 
        FUNCTION
              bd20GetDestinationConverterVersion (
                    TaskId  : tsp00_TaskId;
                    pCBlock : tbd_nodeptr) : tgg00_ConverterVersion;
 
      ------------------------------ 
 
        FROM
              task_temp_data_cache : VBD21;
 
        PROCEDURE
              b21init_temp_cache (pid  : tsp00_TaskId;
                    allocate_monitor   : boolean;
                    is_control_session : boolean;
                    VAR temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR e              : tgg00_BasisError);
 
        PROCEDURE
              b21temp_cache_release (pid : tsp00_TaskId;
                    temp_cache_ptr : tgg00_TempDataCachePtr);
 
        PROCEDURE
              b21m_init_monitor_rec;
 
      ------------------------------ 
 
        FROM
              treehandling : VBD30;
 
        PROCEDURE
              bd30CheckDatabase (
                    VAR t                        : tgg00_TransContext;
                    VAR bad_index_cnt            : tsp00_Int4;
                    VAR total_bad_cnt            : tsp00_Int4;
                    VAR verify_error             : tgg00_BasisError;
                    bWithUpdate                  : boolean;
                    bWithExtendedCheck           : boolean;
                    bWithIndexes                 : boolean;
                    bWithDeleteUnreferencedBlobs : boolean;
                    max_server                   : integer);
 
        PROCEDURE
              b30fdir_to_treeid (VAR fi : tbd_fileinfo;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              b30new_tree (VAR fi : tbd_fileinfo;
                    VAR current   : tbd_current_tree);
 
        PROCEDURE
              bd30BadFile (
                    VAR trans  : tgg00_TransContext;
                    VAR fileId : tgg00_FileId);
 
        PROCEDURE
              bd30BuildCurrent (
                    VAR trans   : tgg00_TransContext;
                    VAR fileId  : tgg00_FileId;
                    VAR current : tbd_current_tree);
 
        PROCEDURE
              bd30CheckTree (
                    VAR trans           : tgg00_TransContext;
                    VAR fileId          : tgg00_FileId;
                    VAR treeStatistic   : tbd00_TreeStatistic;
                    LongColCnt          : tsp00_Int2;
                    NewLongColCnt       : tsp00_Int2;
                    bWithExtendedCheck  : boolean;
                    bCheckLongExistence : boolean;
                    bQuiet              : boolean;
                    bUpdateLeaves       : boolean);
 
        PROCEDURE
              bd30DropTree (
                    VAR current     : tbd_current_tree;
                    longColumnCount : integer;
                    bOnlyEmpty      : boolean);
 
        PROCEDURE
              bd30GetTree (
                    VAR trans            : tgg00_TransContext;
                    VAR fileId           : tgg00_FileId;
                    VAR current          : tbd_current_tree;
                    messType             : tgg00_MessType;
                    bLockTreeExcl        : boolean;
                    bSynchronizeExclLock : boolean);
 
        PROCEDURE
              bd30ReleaseTree (
                    VAR current : tbd_current_tree);
 
        PROCEDURE
              bd30SetFileVersion (
                    VAR current    : tbd_current_tree;
                    newfileVersion : tgg91_FileVersion);
 
        PROCEDURE
              bd30VerifyTree (
                    VAR trans          : tgg00_TransContext;
                    VAR fileId         : tgg00_FileId;
                    VAR treeStatistic  : tbd00_TreeStatistic;
                    bUpdateConverter   : boolean;
                    bWithExtendedCheck : boolean);
 
        PROCEDURE
              bd30InitFileIdForBlobFileIds;
 
        PROCEDURE
              bd30AddBlobIdFoundInFiledirectory  (VAR trans : tgg00_TransContext;
                    BlobId : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              indexhandling : VBD50;
 
        PROCEDURE
              bd50ExtractForeignKey (
                    VAR m           : tgg00_MessBlock;
                    VAR current     : tbd_current_tree;
                    VAR tempCurrent : tbd_current_tree);
 
        PROCEDURE
              bd50ExtractTable (
                    VAR current      : tbd_current_tree;
                    VAR hostFileName : tsp00_VFilename);
 
        PROCEDURE
              bd50MoveFileContent (
                    VAR sourceCurrent : tbd_current_tree;
                    VAR destCurrent   : tbd_current_tree;
                    VAR subRoot       : tsp00_PageNo);
 
      ------------------------------ 
 
        FROM
              bytestring_handling : VBD60;
 
        PROCEDURE
              bd60NewLob( VAR current : tbd_current_tree );
 
        PROCEDURE
              bd60VerifyLob(
                    VAR trans        : tgg00_TransContext;
                    VAR fileId       : tgg00_FileId;
                    bUpdateConverter : boolean;
                    VAR numPages     : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              filestatistic : VBD72;
 
        PROCEDURE
              bd72SampleMultiColumnStatistic(
                    VAR MessBlock        : tgg00_MessBlock;
                    VAR Current          : tbd_current_tree;
                    VAR TempCurrent      : tbd_current_tree;
                    NumberOfSampleLeaves : tsp00_Int4;
                    VAR NumberOfLeaves   : tsp00_Int4;
                    VAR NumberOfRecords  : tsp00_Int4;
                    VAR DistinctValues   : tgg00_ColumnDistinctValues);
 
      ------------------------------ 
 
        FROM
              ref_statistic :   VBD73;
 
        PROCEDURE
              b73init_ref_statistic (part : tgg00_MonitorPart);
 
        PROCEDURE
              b73show_ref_statistic (
                    TaskId   : tsp00_TaskId;
                    VAR info : tgg00_ReferenceInfo);
 
      ------------------------------ 
 
        FROM
              service_routines_for_oms : VBD92;
 
        PROCEDURE
              bd92VerifyObjFile ( VAR current : tbd_current_tree;
                    bConverterUpdate : boolean);
 
      ------------------------------ 
 
        FROM
              FileDir_Wrapper : VBD998;
 
        PROCEDURE
              bd998CreateTempFile(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
        FUNCTION
              bd998IsTempFile(
                    VAR trans  : tgg00_TransContext;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
        FUNCTION
              bd998GetBadIndexCount : tsp00_Int4;
 
        PROCEDURE
              bd998SetPageAndRecordCount (
                    VAR trans      : tgg00_TransContext;
                    VAR surrogate  : tgg00_Surrogate;
                    leafPageCount  : tsp00_Int4;
                    indexPageCount : tsp00_Int4;
                    entryCount     : tsp00_Int4);
 
        PROCEDURE
              bd998GetPageAndRecordCount (
                    VAR trans          : tgg00_TransContext;
                    VAR surrogate      : tgg00_Surrogate;
                    VAR leafPageCount  : tsp00_Int4;
                    VAR indexPageCount : tsp00_Int4;
                    VAR entryCount     : tsp00_Int4);
 
        PROCEDURE
              bd998AddTableToFdir(
                    VAR trans        : tgg00_TransContext;
                    VAR surrogate    : tgg00_Surrogate;
                    converterVersion : tgg00_ConverterVersion;
                    rootPage         : tsp00_PageNo;
                    blobColCount     : tsp00_Int2;
                    VAR fileTypeSet  : tgg00_FiletypeSet;
                    VAR fileVersion  : tgg91_FileVersion);
 
        PROCEDURE
              bd998SetRecordsPacked(
                    VAR trans     : tgg00_TransContext;
                    VAR tableSurr : tgg00_Surrogate;
                    recordsPacked : boolean);
 
        PROCEDURE
              bd998SetPagesClustered(
                    VAR trans      : tgg00_TransContext;
                    VAR tableSurr  : tgg00_Surrogate;
                    pagesClustered : boolean);
 
        PROCEDURE
              bd998AddShortColumnFile (
                    VAR trans          : tgg00_TransContext;
                    converterVersion   : tgg00_ConverterVersion;
                    VAR shortColId     : tgg00_FileId;
                    VAR tableSurrogate : tgg00_Surrogate);
 
        PROCEDURE
              bd998DelDirectFDirEntry(
                    VAR transContext  : tgg00_TransContext;
                    VAR fileSurrogate : tgg00_Surrogate;
                    VAR fileinfo      : tbd_fileinfo);
 
        PROCEDURE
              bd998GcGetFDirEntryFileinfo (
                    VAR transContext: tgg00_TransContext;
                    VAR filename    : tgg00_Filename;
                    VAR fileinfo    : tbd_fileinfo;
                    shared_file     : boolean);
 
        PROCEDURE
              bd998CreateFDir( TaskId : tsp00_TaskId );
 
        PROCEDURE
              bd998RestartFDir(
                    VAR trans               : tgg00_TransContext;
                    FirDirRoot              : tsp00_PageNo;
                    ConverterVersion        : tsp00_Int4;
                    RestartConverterVersion : tsp00_Int4;
                    cleanupFileDirPages     : boolean);
 
        PROCEDURE
              bd998ShutdownFDir( TaskId : tsp00_TaskId );
 
        PROCEDURE
              bd998FlushFDir( TaskId : tsp00_TaskId );
 
        PROCEDURE
              bd998VerifyFdir (
                    VAR trans  : tgg00_TransContext;
                    withUpdate : boolean);
 
      ------------------------------ 
 
        FROM
              BD_Wrapper : VBD999;
 
        PROCEDURE
              bd999AttachAllDataVolumes(
                    TaskId      : tsp00_TaskId;
                    VAR TrError : tgg00_BasisError);
 
        PROCEDURE
              bd999AttachAllLogVolumes(
                    TaskId      : tsp00_TaskId;
                    VAR TrError : tgg00_BasisError);
 
        PROCEDURE
              bd999CreateAllLogVolumes(
                    TaskId        : tsp00_TaskId;
                    VAR TrError   : tgg00_BasisError);
 
        PROCEDURE
              bd999CreateAllDataVolumes(
                    TaskId        : tsp00_TaskId;
                    VAR TrError   : tgg00_BasisError);
 
        PROCEDURE
              bd999DetachAllVolumes( TaskId : tsp00_TaskId );
 
        FUNCTION
              bd999DataDevSpaceSize( DevNo : tsp00_Int2 ) : tsp00_Int4;
 
        FUNCTION
              bd999LogDevSpaceSize( DevNo : tsp00_Int2) : tsp00_Int4;
 
        FUNCTION
              bd999FramesAvailable : tsp00_Int4;
 
        PROCEDURE
              bd999GetDataVolumeName(
                    DevNo        : tsp00_Int2;
                    VAR  DevName : tsp00_VFilename);
 
        PROCEDURE
              bd999GetLogVolumeName(
                    DevNo        : tsp00_Int2;
                    VAR  DevName : tsp00_VFilename);
 
        PROCEDURE
              bd999GetMirrLogVolumeName(
                    DevNo        : tsp00_Int2;
                    VAR  DevName : tsp00_VFilename );
 
        PROCEDURE
              bd999MigrateDataBase(
                    TaskId      : tsp00_TaskId;
                    VAR TrError : tgg00_BasisError);
 
        FUNCTION
              bd999IsDataVolumeConfigured( DevNo : tsp00_Int2) : boolean;
 
        FUNCTION
              bd999MaxConfigurableDataVolumes : tsp00_Int4;
 
        FUNCTION
              bd999NoOfDataDevices : tsp00_Int4;
 
        FUNCTION
              bd999NoOfLogDevices : tsp00_Int4;
 
        FUNCTION
              bd999TotalDataPages : tsp00_Int4;
 
        PROCEDURE
              bd999EnableDataWriter;
 
        PROCEDURE
              bd999CalculateColumnStatistic(
                    VAR Trans           : tgg00_TransContext;
                    VAR Current         : tbd_current_tree;
                    VAR TempCurrent     : tbd_current_tree;
                    ColumnCount         : tsp00_Int2;
                    columnFirstPosition : tsp00_Int2;
                    columnLastPosition  : tsp00_Int2;
                    pColumnDescription  : tgg00_StackListPtr;
                    VAR NumberOfLeaves  : tsp00_Int4;
                    VAR NumberOfRecords : tsp00_Int4;
                    VAR DistinctValues  : tgg00_ColumnDistinctValues );
 
        PROCEDURE
              bd999CalculateCluster(
                    VAR trans            : tgg00_TransContext;
                    VAR current          : tbd_current_tree;
                    VAR numberOfLeaves   : tsp00_Int4;
                    VAR numberOfClusters : tsp00_Int4 );
 
        PROCEDURE
              bd999CalculateRecordsAndLeaves(
                    VAR Trans           : tgg00_TransContext;
                    VAR Current         : tbd_current_tree;
                    VAR NumberOfLeaves  : tsp00_Int4;
                    VAR NumberOfRecords : tsp00_Int4 );
 
        PROCEDURE
              bd999SampleRecordsAndLeaves(
                    VAR Trans            : tgg00_TransContext;
                    VAR Current          : tbd_current_tree;
                    NumberOfSampleLeaves : tsp00_Int4;
                    VAR NumberOfLeaves   : tsp00_Int4;
                    VAR NumberOfRecords  : tsp00_Int4 );
 
        PROCEDURE
              bd999CalculateTableStatistic(
                    VAR Trans             : tgg00_TransContext;
                    VAR Current           : tbd_current_tree;
                    VAR ShortCurrent      : tbd_current_tree;
                    bShortColumnFileExist : boolean;
                    NumberOfLongColumns   : tsp00_Int4;
                    VAR TableStatistic    : tgg00_TableStatInfo);
 
        FUNCTION
              bd999LogIsMirrored : boolean;
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103CatalogCacheInvalidateTable (
                    TaskId       : tsp00_TaskId;
                    VAR  TableId : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              KB_Logging : VKB560;
 
        PROCEDURE
              kb560CreateHistoryManager (VAR Trans : tgg00_TransContext);
 
        PROCEDURE
              kb560DropHistoryManager;
 
        FUNCTION
              kb560VerifyOpenTransAndHistory (VAR Trans : tgg00_TransContext;
                    isCold : boolean) : boolean;
 
      ------------------------------ 
 
        FROM
              KB_restart_record : VKB57;
 
        VAR
              k57restartrec : tkb00_PagePtr;
 
        PROCEDURE
              k57init_restartrec_handling (VAR t : tgg00_TransContext);
 
        PROCEDURE
              k57save_restartrecord (TaskId : tsp00_TaskId);
 
        FUNCTION
              kb57GetLongFdir : tsp00_PageNo;
 
        FUNCTION
              kb57GetFdirRoot : tsp00_PageNo;
 
      ------------------------------ 
 
        FROM
              KB_ServerTasks : VKB900;
 
        FUNCTION
              kb900AvailableServerTasks : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01vtrace     : tgg00_VtraceState;
 
        PROCEDURE
              g01abort (
                    msg_no     : tsp00_Int4;
                    msg_label  : tsp00_C8;
                    msg_text   : tsp00_C24;
                    bad_value  : tsp00_Int4);
 
        PROCEDURE
              g01opmsg (msg_prio : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C24;
                    msg_value : tsp00_Int4);
 
        PROCEDURE
              g01optextmsg (msg_prio : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C40);
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        FUNCTION
              g04inv_tfn (tfn : tgg00_Tfn) : boolean;
 
        PROCEDURE
              g04short_col_tree_build (
                    VAR table_surrogate : tgg00_Surrogate (*ptocConst*);
                    VAR short_col_tree  : tgg00_FileId;
                    VAR b_err           : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : vgg06;
 
        PROCEDURE
              gg06SetNilRef (VAR PageRef : tgg91_PageRef);
 
      ------------------------------ 
 
        FROM
              KernelAdministration_Interface : VGG999;
 
        FUNCTION
              gg999CheckDataCompatibility(VAR checkVersion : tsp00_Version) : boolean;
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vtracestack;
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01basis_error (debug : tgg00_Debug;
                    nam   : tsp00_Sname;
                    b_err : tgg00_BasisError);
 
        PROCEDURE
              t01bool (debug : tgg00_Debug;
                    nam      : tsp00_Sname;
                    curr_bool: boolean);
 
        PROCEDURE
              t01vffn (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname;
                    fn    : tsp00_VFilename);
 
        PROCEDURE
              t01filename (debug : tgg00_Debug;
                    fn : tgg00_Filename);
 
        PROCEDURE
              t01filetype (debug : tgg00_Debug;
                    nam : tsp00_Sname;
                    s   : tgg00_FiletypeSet);
 
        PROCEDURE
              ta01FileVers (debug : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR FileVers  : tgg91_FileVersion);
 
        PROCEDURE
              t01int4 (debug : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int4     : tsp00_Int4);
 
        PROCEDURE
              t01messtype (debug : tgg00_Debug;
                    nam          : tsp00_Sname;
                    mess_type    : tgg00_MessType);
 
        PROCEDURE
              t01name (debug : tgg00_Debug;
                    nam  : tsp00_Name);
 
        PROCEDURE
              t01p2int4 (debug : tgg00_Debug;
                    nam_1 : tsp00_Sname;
                    int_1 : tsp00_Int4;
                    nam_2 : tsp00_Sname;
                    int_2 : tsp00_Int4);
 
        PROCEDURE
              t01treeid (debug : tgg00_Debug;
                    nam        : tsp00_Sname;
                    VAR treeid : tgg00_FileId);
&       endif
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        FUNCTION
              bd20GetDestinationConverterVersion;
 
              tbd02_pDataCBlock tbd_nodeptr
 
        PROCEDURE
              bd999CalculateColumnStatistic;
 
              tgg00_StEntryAddr tgg00_StackListPtr
 
        PROCEDURE
              bd999GetDataVolumeName;
 
              tsp00_VFilename tsp2_devname
 
        PROCEDURE
              bd999GetLogVolumeName;
 
              tsp00_VFilename tsp2_devname
 
        PROCEDURE
              bd999GetMirrLogVolumeName;
 
              tsp00_VFilename tsp2_devname
&             ifdef TRACE
&             endif
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : JuergenP
.sp
.cp 3
Created : 1979-09-05
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-11-10
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.sp 2;.cp 4
.oc _/1;1._Base_Layer_Files
.sp 4;.cp 6
The base layer makes available operations for file management and
processing.
.br
A file must be explicitly created before it can be processed and
normally exists until it is explicitly deleted.  Every (existing)
file has an unambiguous name, a 'filename', and consists of a
sequenced set of entries.  The entries are (Pascal) strings of
variable length and each contains an unambiguous key as a
substring.
.sp 2;.cp 10
   a) Key :
.sp 2;.nf
        1       n bytes
      ------------------------------
      | kl |    keyvalue           |   (kl) = n
      ------------------------------
.sp 3;.cp 4
.fo
File entries are arranged according to their key values,
from lowest to highest.
The binary codes of the individual characters form the
alphabet, the keys form words via this alphabet and the
words are arranged in alphabetical order.
.br
The type of file (fileType_gg00) that is created can either
be temporary or permanent (perm, temp).  At each system
startup, all temporary files that are still in existence are
implicitly deleted and all permanent files are retained.
In addition, the user alone is responsible for the
unambiguousness of the file name for temporary files.
The internal handling of temporary files differs in some
respects from the handling of permanent files, in order to
reduce access time -- at the expense of data protection.
.br
With regard to processing possibilities, a distinction is
made between primary files and inversions of primary files.
.sp
The procedure parameter procid supplies the system-internal
identification  of the process that calls the procedure.
It is required for synchronizing operations on
B* trees.
.sp 4;.cp 6
.oc _/1;2._General_File_Management_Routines
.sp 3
bd01CreatePermFile (t,fn,ft,stringcol_cnt,
.br
                 act_tree_id,e)
.sp
Generates a new, empty file with the name fn and file
type ft.  The unambiguousness of the file name is
constantly verified.
.br
The parameter with_stringcol indicates whether the table
assigned to this file contains columns of the 'LONG' type.
If this column type is present (stringcol_cnt > 0),
the number of such columns is supplied to 'stringcol_cnt'. Furthermore
(in the latter case) the offset to skip the fixed part of each record
(relative to the end of the record key) is supplied
to 'varcol_cnt_off'.
.br
In act_tree_id, the caller is supplied with the tree
identification for the file.
.br;.cp 5
One of the following messages, among others, is sent to e:
   - e_ok
   - b_duplicate_filename
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b01tcreate_file (t,file_id,e)
.sp
Generates a new, temporary file with the file identification 'file_id'
supplies the relevant file parameters to file_id.
The unambiguousness of the file name is constantly verified.
.br;.cp 5
One of the following messages, among others, is sent to e:
   - e_ok
   - b_duplicate_filename
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b01open_file (t,fn,act_tree_id,e)
.sp
Opens file with the name fn for further processing.
The relevant file information is supplied to act_tree_id.
.br;.cp 6
One of the following messages is sent to e:
   - e_ok
   - b_file_not_found
   - b_file_unloaded
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b01bcreate_bytestr (t,fn,e)
.sp
Generates a new, empty byte-string file with the name fn.
The unambiguousness of the file name is constantly verified.
.br;.cp 5
One of the following messages, among others, is sent to e:
   - e_ok
   - b_duplicate_filename
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b01vstate_fileversion (t,fn,e)
.sp
Checks whether the version number for the file fn in the file
directory matches the version number that was supplied by the
calling procedure via trans_no t.
.br;.cp 6
One of the following messages, among others, is sent to e:
   - e_ok
   - b_old_fileversion
   - b_file_not_found
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b01set_fileversion (t, file_id, new_fileversion, new_long_cnt)
.sp
A new version number is entered in the file directory for the
file fn.
.br;.cp 5
One of the following messages, among others, is sent to e:
   - e_ok
   - b_file_not_found
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b01treeleafnodes (t, file_id, m_fetch/m_update, old_treeleafnodes)
.sp
Case m_fetch a number of tree leaf nodes is fetched from the root node
page of the primary tree file_id into old_treeleafnodes.
Case m_update a new number of tree leaf nodes is entered from
file_id.treeleafnodes in the root node page of the primary tree file_id.
.br;.cp 5
One of the following messages, among others, is sent to e:
   - e_ok
   - b_file_not_found
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b01end_read_only (t,e)
.sp
An entry is made in the file directory cancelling
the read-only restriction for all files that were, up until
this point, read-only.
.br;.cp 5
One of the following error messages, among others, is sent to e:
   - e_ok
   - b_file_not_found
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
 b01destroy_file (t,fn,e)
.sp
If the file with the name fn is present, it is deleted, i.e.
all file records are destroyed and the name of the file is
not retained.
.br;.cp 5
One of the following messages, among others, is sent to e:
   - e_ok
   - b_file_not_found
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b01empty_file (t,file_id,e)
.sp
The temporary file with the identifier 'file_id' is emptied;
i.e. all file records are destroyed.  However, the file directory
for this file is retained along with the root of the associated
tree.
.br;.cp 5
One of the following messages, among others, is sent to e:
   - e_ok
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b01treset_file (t,file_id,e)
.sp
If the temporary file with the identifier 'file_id' exists
then this file is emptied;
i.e. all file records are destroyed.
However, the file directory
for this file is retained along with the root of the associated
tree.
.br
Otherwise a new temporary file is created.
.br;.cp 5
One of the following messages, among others, is sent to e:
   - e_ok
   - b_shutdown
   - b_disk_not_accessible
.sp 3;.cp 6
b01prefix_destroy_files (t,prefix_fn,prefix_len,e)
.sp
All files that contain the prefix prefix_fn of the length
prefix_len in their file name are deleted, i.e. all file records
are destroyed and the file names are not retained.
.br;.cp 5
One of the following messages, among others, is sent to e:
   - e_ok
   - b_file_not_found
   - b_shutdown
   - b_disk_not_accessible
.sp 2;.cp 6
b01filestate (t,fn,ft,e)
.sp
Checks whether a file with the name fn exists.  If yes, the
file type defined for this file is shown in ft.  One of the
purposes of this routine is to check the unambiguousness
of a file name that is to be assigned to a temporary file.
.br;.cp 7
One of the following messages, among others, is sent to e:
   - e_ok
   - b_file_read_only
   - b_bad_file
   - b_file_unloaded
   - b_file_not_found
   - b_shutdown
   - b_disk_not_accessible
.sp 2;.cp 6
bd01invfile_state (t,fn,ft,e)
.sp
Checks whether a file with the name fn exists.  If yes, the
file type defined for this file is shown in ft.  One of the
purposes of this routine is to check the unambiguousness
of a file name that is to be assigned to a temporary file.
.br;.cp 6
One of the following messages, among others, is sent to e:
   - e_ok
   - b_bad_invfile
   - b_file_unloaded
   - b_file_not_found
   - b_shutdown
   - b_disk_not_accessible
.sp 2;.cp 6
bd01RenameFile (t,old,new,e)
.sp
If there is a file with the name "old" and no file with the name
"new", "old" is renamed "new".  For temporary files, external
measures must be taken to ensure that no file with the name "new"
already exists.
.br;.cp 6
One of the following messages, among others, is sent to e:
   - e_ok
   - b_file_not_found
   - b_duplicate_filename
   - b_shutdown
   - b_disk_not_accessible
.sp 2;.cp 6
b01sfile_statistic (t,fn,info,e)
.sp
Generates statistics on static memory utilization by the
file fn.  The result is sent to the buffer "info".
.br;.cp 6
One of the following messages, among others, is sent to e:
   - e_ok
   - b_file_unloaded
   - b_file_not_found
   - b_shutdown
   - b_disk_not_accessible
.sp 4;.cp 12
.oc _/1;3._System_Management
.sp 3
The following is an introduction to the routines for creating,
explicitly shutting down and restarting the base-layer
file management system.
.sp 3;.cp 4
b01create_filesystem (t)
.sp
This routine must be called during system generation.
It formats the secondary storage and initializes all data
structures used by the file management system (in the main memory
and secondary storage) in such a way that there are not yet any
files in existence and a maximum of free storage space is
available.  The prerequisite is that the number of free storage
management pages chosen is appropriately high.  The trans_no of
the calling transaction is sent to t; a description of the system
configuration must be entered in conf_desc.
.br;.cp 5
One of the following messages, among others, is sent to e:
   - e_ok
   - b_no_more_space
   - b_sysbuf_storage_exceeded
   - b_disk_not_accessible
.sp 3;.cp 4
b01shutdown_filesystem (t,log_active,e)
.sp
This routine brings about the normal shutdown of the file
management system.  Until the system is restarted, all base-layer
calls result in the acknowledgement 'b_shutdown' in parameter e.
.br;.cp 3
One of the following messages, among others, is sent to e:
   - e_ok
   - b_disk_not_accessible
.sp 3;.cp 4
b01restart_filesystem (t,fn,conf_desc,conf_pageptr,e)
.sp
This routine must be called to restart the system following a
normal shutdown or following a system failure due to an
irrecoverable error.  At this time, all temporary files that
are still present are implicitly deleted whereas permanent files
are retained unchanged. The name of the
file from which the configuration description must be read must
be entered in fn.  This description is sent to conf_desc.
.br;.cp 5
One of the following messages, among others, is sent to e:
   - e_ok
   - b_init_missing
   - b_sysbuf_storage_exceeded
   - b_disk_not_accessible
.sp 3;.cp 6
b01verify_database (t,bWithUpdate,NumPermPages,repair_trees,bad_file)
.sp
When this routine is called, the pages of all permanent files in
the previously deleted free storage manager that are present
in the database are labelled as used.  In this way, pages that were
labelled as used but did not belong to a file (did not belong to a
tree) are labelled as unused.
.br
The number of pages that are labelled as used following the "verify"
routine is indicated in the parameter "NumPermPages".
If, when traversing a tree, a structural error is discovered,
an attempt is made to reconstruct the correct structure.
The number of successful repair attempts is sent to "repair_trees".
.br;.cp 6
One of the following messages, among others, is sent to e:
.br
   - e_ok
   - b_shutdown
   - b_invalid_index_structure
   - b_invalid_leaves_structure
   - b_disk_not_accessible
.sp 4;.cp 12
.oc _/1;4._I/O-Routines
.sp 3
Using the following procedures, it is possible to read
from or write to individual pages in the restart and
logging areas.
.sp 2;.cp 9
 
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
A global variable 'database_state' indicates by means of
'e_ok' that the file system has been generated and is
not shut down; otherwise it contains the message 'b_shutdown'.
The existence of a file can generally be detected by accessing
the file directory.  In addition, the 'add' and 'repl' operations
are used to determine whether enough space is still available
in the secondary storage.
.sp
When a new file is being created, a tree root is requested and an
entry identifying the file is included in the file directory.
.sp
Entries in a file are stored in the leaves of a B* tree.
File routines are thus referred back to the appropriate
tree routine.  Before each tree routine is called, the operation
b30adjust_tree identifies which tree is being processed;
this means that, later on, certain information does not always
have to be carried along as a parameter.
.sp
When a checkpoint is set, only the system buffer (as necessary)
is written to the secondary storage.
.sp
If a file routine sends the message b_disk_not_accessible
to e, the physical integrity of the file system is no
longer secure!
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_only_empty             = true;
      (* *)
      MSG_STOP_CHECK_OKAY      = 'Check data finished successfully        ';
      MSG_STOP_CHECK_WITH_ERR  = 'Check data finished unsuccessfully      ';
 
TYPE
 
      tbd01_mapTypeIntoChar = RECORD
            CASE integer OF
                1:
                    (typeAsSet : tgg00_FiletypeSet);
                2:
                    (typeAsChar : tsp00_C1);
                END;
            (*ENDCASE*) 
 
 
 
(*------------------------------*) 
 
PROCEDURE
      b01bcreate_bytestr (VAR t : tgg00_TransContext;
            VAR file_id : tgg00_FileId);
 
VAR
      fi         : tbd_fileinfo;
      current    : tbd_current_tree;
      fn_trace   : tgg11_BdFilenameTrace;
      root_trace : tgg11_BdRootTrace;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    fn_trace.bdfTrType_gg11 := bdtrFilename_egg11;
    fn_trace.bdfFn_gg11     := file_id.fileName_gg00;
    b120InsertTrace (t, bd, b01b_create, sizeof (fn_trace), @fn_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd create by');
t01treeid (bi, 'treeid req  ', file_id);
&endif
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown
ELSE
    BEGIN
    t.trError_gg00 := e_ok;
    WITH fi DO
        BEGIN
        fi_type    := [ftsByteStr_egg00, ftsConcurrent_egg00];
        fi_state   := [];
        fi_fill1   := false;
        fi_descr   := [];
        fi_root    := NIL_PAGE_NO_GG00;
        fi_vers    := file_id.fileVersion_gg00;
        fi_col_cnt := 0;
        gg06SetNilRef (fi_user_ref)
        END;
    (*ENDWITH*) 
    b30fdir_to_treeid (fi, file_id);
    bd30BuildCurrent (t, file_id, current);
    IF  t.trError_gg00 = e_ok
    THEN
        bd60NewLob (current);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        fi.fi_root := current.curr_tree_id.fileRoot_gg00;
        bd17AddBlobToFDir (t, file_id.fileName_gg00, fi)
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_duplicate_filename
    THEN
        BEGIN
        t.trError_gg00 := e_ok;
        bd13FreeNewRoot (current);
        IF  t.trError_gg00 = e_ok
        THEN
            t.trError_gg00 := e_duplicate_filename
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        file_id := current.curr_tree_id
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrRoot_gg11   := file_id.fileRoot_gg00;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b01b_create, sizeof (root_trace), @root_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01treeid      (bi, 'new treeid  ', file_id);
t01basis_error (bi, 'create byt e', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01change_filetype (VAR t : tgg00_TransContext;
            VAR file_id  : tgg00_FileId;
            new_filetype : tgg00_FiletypeSet);
 
VAR
      fi : tbd_fileinfo;
 
BEGIN
&ifdef TRACE
t01name     (bi, '====> change filet');
t01treeid   (bi, 'treeid      ', file_id);
t01filetype (bi, 'new filetype', new_filetype);
&endif
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown
ELSE
    BEGIN
    t.trError_gg00 := e_ok;
    b17state_fdir (file_id.fileName_gg00, fi, ftsShared_egg00 IN file_id.fileType_gg00, t);
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        b30fdir_to_treeid (fi, file_id);
        fi.fi_type := new_filetype;
        b17repl_fdir (file_id.fileName_gg00, fi, ftsShared_egg00 IN file_id.fileType_gg00, t)
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        file_id.fileType_gg00 := new_filetype
    (*ENDIF*) 
    END;
(*ENDIF*) 
&ifdef TRACE
t01basis_error (bi, 'change ft e ', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01check_table (VAR t : tgg00_TransContext;
            VAR file_id          : tgg00_FileId;
            long_col_cnt         : tsp00_Int2;
            new_long_col_cnt     : tsp00_Int2;
            bWithExtendedCheck   : boolean;
            check_long_existence : boolean;
            bQuiet               : boolean;
            bUpdateLeaves        : boolean);
 
VAR
      aux_err       : tgg00_BasisError;
      treeStatistic : tbd00_TreeStatistic;
      shcol_file_id : tgg00_FileId;
 
BEGIN
&ifdef TRACE
t01name   (bi, '====> check table ');
t01treeid (bi, 'treeid      ', file_id);
t01int4   (bi, 'long_col_cnt', long_col_cnt);
t01int4   (bi, 'new_long_col', new_long_col_cnt);
t01bool   (bi, 'long_exist  ', check_long_existence);
&endif
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown
ELSE
    t.trError_gg00 := e_ok;
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    WITH t DO
        BEGIN
        file_id.fileRoot_gg00 := NIL_PAGE_NO_GG00;
        bd30CheckTree (t, file_id, treeStatistic, long_col_cnt,
              new_long_col_cnt, bWithExtendedCheck, check_long_existence,
              bQuiet, bUpdateLeaves );
        IF  check_long_existence AND (t.trError_gg00 = e_ok)
        THEN
            WITH treeStatistic DO
                BEGIN
                (* *)
                (* table is protected against concurrent access *)
                (* *)
                bd998SetPageAndRecordCount (t, file_id.fileTabId_gg00,
                      ts_LeafPages_bd00, ts_IndexPages_bd00, ts_RecordCount_bd00);
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  (long_col_cnt > 0                     ) AND
            (long_col_cnt > new_long_col_cnt      ) AND
            (trError_gg00 <> e_disk_not_accessible) AND
            (trError_gg00 <> e_shutdown           ) AND
            (trError_gg00 <> e_cancelled          )
        THEN
            BEGIN
            aux_err       := trError_gg00;
            trError_gg00  := e_ok;
            shcol_file_id := file_id;
            g04short_col_tree_build (file_id.fileTabId_gg00, shcol_file_id, trError_gg00);
            IF  trError_gg00 = e_ok
            THEN
                bd30CheckTree (t, shcol_file_id, treeStatistic, 0, 0, bWithExtendedCheck,
                      NOT check_long_existence, bQuiet, bUpdateLeaves );
            (*ENDIF*) 
            IF  check_long_existence AND (t.trError_gg00 = e_ok)
            THEN
                WITH treeStatistic DO
                    BEGIN
                    (* *)
                    (* table is protected against concurrent access *)
                    (* *)
                    bd998SetPageAndRecordCount (t, shcol_file_id.fileTabId_gg00,
                          ts_LeafPages_bd00, ts_IndexPages_bd00, ts_RecordCount_bd00);
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            IF  trError_gg00 = e_ok
            THEN
                trError_gg00 := aux_err
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
&ifdef TRACE
(*ENDIF*) 
t01basis_error (bi, 'check tab e ', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
FUNCTION
      b01connect_allowed : boolean;
 
BEGIN
b01connect_allowed := bd10IsConnectAllowed;
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01create_filesystem (VAR t : tgg00_TransContext);
 
BEGIN
&ifdef TRACE
t01name (bi, '====> bd init     ');
&endif
t.trError_gg00    := e_ok;
b01downfilesystem := false;
b06init_errtxt;
(* *)
bd999CreateAllLogVolumes( t.trTaskId_gg00, t.trError_gg00 );
IF  t.trError_gg00 = e_ok
THEN
    bd999CreateAllDataVolumes( t.trTaskId_gg00, t.trError_gg00 );
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    b10create_converter (t.trTaskId_gg00, bd999TotalDataPages);
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    bd20InitDataCache (t.trTaskId_gg00, t.trError_gg00, bd999FramesAvailable, bd999TotalDataPages);
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    bd17CreateBlobFDir (t);
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    bd998CreateFDir(t.trTaskId_gg00);
(*ENDIF*) 
IF  t.trError_gg00 <> e_ok
THEN
    bd999DetachAllVolumes (t.trTaskId_gg00);
&ifdef TRACE
(*ENDIF*) 
t01basis_error (bi, 'init error  ', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
FUNCTION
      b01db_full( taskId : tsp00_TaskId ) : boolean;
 
BEGIN
b01db_full := bd10IsDbFull( taskId );
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01dbspace_statistic (VAR t : tgg00_TransContext;
            VAR info : tgg00_DbSpaceInfo);
 
BEGIN
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown;
(*ENDIF*) 
BEGIN
t.trError_gg00 := e_ok;
bd10dbspace_statistic (t, info)
END;
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01destroy_file (VAR t : tgg00_TransContext;
            VAR file_id : tgg00_FileId);
 
VAR
      fn_trace   : tgg11_BdFilenameTrace;
      root_trace : tgg11_BdRootTrace;
      filetype   : tbd01_mapTypeIntoChar;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    fn_trace.bdfTrType_gg11 := bdtrFilename_egg11;
    fn_trace.bdfFn_gg11     := file_id.fileName_gg00;
    b120InsertTrace (t, bd, b01destroy, sizeof (fn_trace), @fn_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd drop temp');
t01treeid (bi, 'fileId      ', file_id);
&endif
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown
ELSE
    IF  bd998IsTempFile (t, file_id)
    THEN
        bd01destroy_file (t, file_id, root_trace.bdrRoot_gg11, cgg_zero_id)
    ELSE
        BEGIN
        t.trError_gg00     := e_invalid_filetype;
        filetype.typeAsSet := file_id.fileType_gg00;
        g01opmsg (sp3p_console, sp3m_error, csp3_b01_1_invalid_filetype,
              csp3_n_btree, 'NOT ftsTemp IN filetype ', ord(filetype.typeAsChar[1]));
        b06write_filename_and_root (file_id);
        vtracestack;
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b01destroy, sizeof (root_trace), @root_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01basis_error (bi, 'destroy err ', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
FUNCTION
      b01devsize (dev_type : tsp2_dev_type;
            devno : tsp00_Int4) : tsp00_Int4;
 
VAR
      devsize : tsp00_Int4;
 
BEGIN
&ifdef TRACE
t01name (bi, '====> bd devsize  ');
t01int4 (bi, 'dev_type    ', ord (dev_type));
t01int4 (bi, 'devno       ', devno);
&endif
CASE dev_type OF
    sp2dt_data:
        devsize := bd999DataDevSpaceSize( devno );
    sp2dt_log:
        devsize :=  bd999LogDevSpaceSize( devno );
    OTHERWISE
        devsize :=  0;
    END;
(*ENDCASE*) 
b01devsize := devsize;
&ifdef TRACE
t01int4 (bi, 'devsize     ', devsize);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01empty_file (VAR t : tgg00_TransContext;
            VAR file_id : tgg00_FileId);
 
VAR
      fi         : tbd_fileinfo;
      current    : tbd_current_tree;
      fn_trace   : tgg11_BdFilenameTrace;
      root_trace : tgg11_BdRootTrace;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    fn_trace.bdfTrType_gg11 := bdtrFilename_egg11;
    fn_trace.bdfFn_gg11     := file_id.fileName_gg00;
    b120InsertTrace (t, bd, b01empty, sizeof (fn_trace), @fn_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name (bi, '====> bd empty f  ');
t01int4 (bi, 'root        ', file_id.fileRoot_gg00);
&endif
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown
ELSE
    BEGIN
    t.trError_gg00 := e_ok;
    b17state_fdir (file_id.fileName_gg00, fi, ftsShared_egg00 IN file_id.fileType_gg00, t);
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        b30fdir_to_treeid (fi, file_id);
        bd30GetTree (t, file_id, current, m_drop,
              LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
        IF  t.trError_gg00 = e_ok
        THEN
            bd30DropTree (current, 0, c_only_empty);
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  t.trError_gg00 = e_ok
        THEN
            file_id := current.curr_tree_id
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrRoot_gg11   := file_id.fileRoot_gg00;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b01empty, sizeof (root_trace), @root_trace)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01end_read_only (VAR t : tgg00_TransContext);
 
BEGIN
&ifdef TRACE
t01name (bi, '====> bd end ronly');
&endif
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown
ELSE
    BEGIN
    t.trError_gg00 := e_ok;
    b17reset_read_only (t)
    END;
(*ENDIF*) 
&ifdef TRACE
t01basis_error (bi, 'end readonly', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      bd01CreatePermTableFile (
            VAR trans    : tgg00_TransContext;
            VAR fileId   : tgg00_FileId;
            eFiletypeSet : tgg00_ExtendedFiletypeSet(*ptocConst*);
            blobCount    : tsp00_Int2);
 
CONST
      c_pagesClustered = true;
      c_recordsPacked  = true;
 
VAR
      converterVersion : tgg00_ConverterVersion;
      fileInfo         : tbd_fileinfo;
      current          : tbd_current_tree;
      fnTrace          : tgg11_BdFilenameTrace;
      rootTrace        : tgg11_BdRootTrace;
 
BEGIN
&ifdef TRACE
t01name   (bi, '===> bd create tab');
t01treeid (bi, 'fileId      ', fileId);
t01int4   (bi, 'blob count  ', blobCount);
&endif
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    fnTrace.bdfTrType_gg11 := bdtrFilename_egg11;
    fnTrace.bdfFn_gg11     := fileId.fileName_gg00;
    b120InsertTrace (trans, bd, b01create, sizeof (fnTrace), @fnTrace)
    END;
(*ENDIF*) 
IF  b01downfilesystem
THEN
    trans.trError_gg00 := e_shutdown
ELSE
    WITH trans, fileInfo DO
        BEGIN
        trError_gg00       := e_ok;
        fi_type            := fileId.fileType_gg00;
        fi_type            := fi_type + [ftsConcurrent_egg00];
        fi_state           := [];
        fi_descr           := [];
        fi_root            := NIL_PAGE_NO_GG00;
        fi_vers            := fileId.fileVersion_gg00;
        fi_var_col_cnt_pos := cgg_nil_varcol_cnt_off;
        fi_col_cnt         := blobCount;
        gg06SetNilRef (fi_user_ref);
        (* *)
        fileId.fileLeafNodes_gg00 := 1;
        (* *)
        b30fdir_to_treeid (fileInfo, fileId);
        bd30BuildCurrent (trans, fileId, current);
        (* *)
        b30new_tree (fileInfo, current);
        IF  trError_gg00 = e_ok
        THEN
            WITH fileId DO
                BEGIN
                fileRoot_gg00 := current.curr_tree_id.fileRoot_gg00;
                bd30GetTree (trans, fileId, current, m_create_table,
                      LOCK_TREE_EXCL_BD00, SYNC_TREE_LOCK_BD00);
                IF  trError_gg00 = e_ok
                THEN
                    BEGIN
                    converterVersion := bd20GetDestinationConverterVersion(
                          trTaskId_gg00, current.currRootNptrs_bd00.np_cbptr);
                    bd998AddTableToFdir (trans, fileId.fileTabId_gg00, converterVersion,
                          fileRoot_gg00, blobCount, fileType_gg00, fileVersion_gg00);
                    IF  trError_gg00 = e_ok
                    THEN
                        BEGIN
                        bd998SetPageAndRecordCount (trans, fileId.fileTabId_gg00, 1, 0, 0);
                        IF  eftsClustered_egg00 in eFiletypeSet
                        THEN
                            bd998SetPagesClustered (trans,
                                  fileId.fileTabId_gg00, c_pagesClustered);
                        (*ENDIF*) 
                        IF  eftsRecordsPacked_egg00 in eFiletypeSet
                        THEN
                            bd998SetRecordsPacked (trans,
                                  fileId.fileTabId_gg00, c_recordsPacked);
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  trError_gg00 = e_duplicate_filename
                        THEN
                            BEGIN
                            trError_gg00 := e_ok;
                            b13free_node (current.currRootNptrs_bd00, current);
                            trError_gg00 := e_duplicate_filename
                            END
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                bd30ReleaseTree (current);
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    rootTrace.bdrTrType_gg11 := bdtrRoot_egg11;
    rootTrace.bdrRoot_gg11   := fileId.fileRoot_gg00;
    rootTrace.bdrError_gg11  := trans.trError_gg00;
    b120InsertTrace (trans, bd, b01create, sizeof (rootTrace), @rootTrace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01treeid      (bi, 'new fileId  ', fileId);
t01basis_error (bi, 'create err  ', trans.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      bd01CreateShortColumnFile (
            VAR trans          : tgg00_TransContext;
            VAR shortColId     : tgg00_FileId;
            VAR tableSurrogate : tgg00_Surrogate);
 
VAR
      converterVersion : tgg00_ConverterVersion;
      fileInfo         : tbd_fileinfo;
      current          : tbd_current_tree;
      fnTrace          : tgg11_BdFilenameTrace;
      rootTrace        : tgg11_BdRootTrace;
 
BEGIN
&ifdef TRACE
t01name   (bi, '===> bd create shc');
t01treeid (bi, 'shortColId  ', shortColId);
&endif
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    fnTrace.bdfTrType_gg11 := bdtrFilename_egg11;
    fnTrace.bdfFn_gg11     := shortColId.fileName_gg00;
    b120InsertTrace (trans, bd, b01create, sizeof (fnTrace), @fnTrace)
    END;
(*ENDIF*) 
IF  b01downfilesystem
THEN
    trans.trError_gg00 := e_shutdown
ELSE
    WITH trans, fileInfo DO
        BEGIN
        trError_gg00 := e_ok;
        fi_type      := shortColId.fileType_gg00;
        IF  ftsPerm_egg00 IN fi_type
        THEN
            fi_type := fi_type + [ftsConcurrent_egg00];
        (*ENDIF*) 
        fi_state           := [];
        fi_descr           := [];
        fi_root            := NIL_PAGE_NO_GG00;
        fi_vers            := shortColId.fileVersion_gg00;
        fi_var_col_cnt_pos := cgg_nil_varcol_cnt_off;
        fi_col_cnt         := 0;
        gg06SetNilRef (fi_user_ref);
        (* *)
        b30fdir_to_treeid (fileInfo, shortColId);
        bd30BuildCurrent (trans, shortColId, current);
        (* *)
        b30new_tree (fileInfo, current);
        IF  trError_gg00 = e_ok
        THEN
            WITH shortColId DO
                BEGIN
                shortColId.fileRoot_gg00 := current.curr_tree_id.fileRoot_gg00;
                bd30GetTree (trans, shortColId, current, m_create_table,
                      LOCK_TREE_EXCL_BD00, SYNC_TREE_LOCK_BD00);
                IF  trError_gg00 = e_ok
                THEN
                    BEGIN
                    converterVersion := bd20GetDestinationConverterVersion(
                          trTaskId_gg00, current.currRootNptrs_bd00.np_cbptr );
                    bd998AddShortColumnFile (trans, converterVersion, shortColId, tableSurrogate);
                    IF  trError_gg00 = e_ok
                    THEN
                        bd998SetPageAndRecordCount (trans, shortColId.fileTabId_gg00, 1, 0, 0)
                    ELSE
                        IF  trError_gg00 = e_duplicate_filename
                        THEN
                            BEGIN
                            trError_gg00 := e_ok;
                            b13free_node (current.currRootNptrs_bd00, current);
                            trError_gg00 := e_duplicate_filename
                            END
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                bd30ReleaseTree (current);
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    rootTrace.bdrTrType_gg11 := bdtrRoot_egg11;
    rootTrace.bdrRoot_gg11   := shortColId.fileRoot_gg00;
    rootTrace.bdrError_gg11  := trans.trError_gg00;
    b120InsertTrace (trans, bd, b01create, sizeof (rootTrace), @rootTrace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01treeid      (bi, 'newSColId   ', shortColId);
t01basis_error (bi, 'create err  ', trans.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01filestate (VAR t : tgg00_TransContext;
            VAR file_id : tgg00_FileId);
 
VAR
      fi : tbd_fileinfo;
 
BEGIN
&ifdef TRACE
t01name   (bi, '====> bd state fil');
t01treeid (bi, 'treeid bef  ', file_id);
&endif
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown
ELSE
    BEGIN
    t.trError_gg00 := e_ok;
    b17state_fdir (file_id.fileName_gg00, fi, ftsShared_egg00 IN file_id.fileType_gg00, t);
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        IF  ((f_read_only IN fi.fi_state) AND (NOT (hsNoLog_egg00 in file_id.fileHandling_gg00)))
        THEN
            t.trError_gg00 := e_file_read_only
        ELSE
            BEGIN
            IF  f_bad IN fi.fi_state
            THEN
                BEGIN
                t.trError_gg00         := e_bad_file;
                file_id.fileType_gg00 := fi.fi_type
                END
            ELSE
                IF  f_not_accessible IN fi.fi_state
                THEN
                    t.trError_gg00 := e_file_not_accessible
                (*ENDIF*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (t.trError_gg00 = e_ok) OR (t.trError_gg00 = e_file_read_only)
    THEN
        b30fdir_to_treeid (fi, file_id)
    (*ENDIF*) 
    END;
(*ENDIF*) 
&ifdef TRACE
t01treeid      (bi, 'treeid after', file_id);
t01basis_error (bi, 'state err   ', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
FUNCTION
      b01get_bad_index_cnt : tsp00_Int4;
 
BEGIN
b01get_bad_index_cnt := bd998GetBadIndexCount;
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01get_data_cache_workload (
            VAR trans                  : tgg00_TransContext;
            VAR DataCacheSize          : tsp00_Int4;
            VAR OmsHistoryPageCnt      : tsp00_Int4;
            VAR OmsDataPageCnt         : tsp00_Int4;
            VAR OmsUnloadedVersPageCnt : tsp00_Int4;
            VAR SqlDataPageCnt         : tsp00_Int4);
 
BEGIN
&ifdef TRACE
t01name (bi, '===> bd cache stat');
&endif
IF  b01downfilesystem
THEN
    trans.trError_gg00 := e_shutdown
ELSE
    bd20GetWorkloadCounter (DataCacheSize, OmsHistoryPageCnt,
          OmsDataPageCnt, OmsUnloadedVersPageCnt, SqlDataPageCnt);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01get_devname (
            dev_type    : tsp2_dev_type;
            devno       : tsp00_Int4;
            VAR devname : tsp2_devname);
 
BEGIN
&ifdef TRACE
t01name (bi, '====> bd get devna');
t01int4 (bi, 'dev_type    ', ord (dev_type));
t01int4 (bi, 'devno       ', devno);
&endif
CASE dev_type OF
    sp2dt_data:
        bd999GetDataVolumeName( devno, devname );
    sp2dt_log:
        bd999GetLogVolumeName( devno, devname );
    sp2dt_mirr_log:
        bd999GetMirrLogVolumeName( devno, devname );
    OTHERWISE
        devname := b01blankfilename
    END;
(*ENDCASE*) 
&ifdef TRACE
t01vffn (bi, 'devname     ', devname);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01move_filecontent (VAR t : tgg00_TransContext;
            VAR sourceFileId : tgg00_FileId;
            VAR destFileId   : tgg00_FileId);
 
VAR
      fi             : tbd_fileinfo;
      sourceCurrent  : tbd_current_tree;
      destCurrent    : tbd_current_tree;
      leafPageCount  : tsp00_Int4;
      indexPageCount : tsp00_Int4;
      recordCount    : tsp00_Int4;
 
BEGIN
&ifdef TRACE
t01name   (bi, '====> bd move file');
t01treeid (bi, 'source file ', sourceFileId);
t01treeid (bi, 'target file ', destFileId);
&endif
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown
ELSE
    BEGIN
    t.trError_gg00 := e_ok;
    b17state_fdir (destFileId.fileName_gg00, fi,
          ftsShared_egg00 IN destFileId.fileType_gg00, t);
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        IF  destFileId.fileRoot_gg00 = NIL_PAGE_NO_GG00
        THEN
            b30fdir_to_treeid (fi, destFileId);
        (*ENDIF*) 
        IF  sourceFileId.fileRoot_gg00 = NIL_PAGE_NO_GG00
        THEN
            BEGIN
            b17state_fdir (sourceFileId.fileName_gg00, fi,
                  ftsShared_egg00 IN sourceFileId.fileType_gg00, t);
            IF  t.trError_gg00 = e_ok
            THEN
                b30fdir_to_treeid (fi, sourceFileId)
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        bd30GetTree (t, destFileId, destCurrent, m_drop,
              LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
        IF  t.trError_gg00 = e_ok (* empty destination file *)
        THEN
            bd30DropTree (destCurrent, 0, c_only_empty);
        (*ENDIF*) 
        IF  t.trError_gg00 = e_ok
        THEN
            BEGIN
            bd30GetTree (t, sourceFileId, sourceCurrent, m_drop,
                  LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
            IF  t.trError_gg00 = e_ok (* move source to destination *)
            THEN
                BEGIN
                bd50MoveFileContent (sourceCurrent, destCurrent, sourceFileId.fileRoot_gg00);
                IF  t.trError_gg00 = e_ok
                THEN
                    BEGIN
                    bd998GetPageAndRecordCount (t, sourceFileId.fileTabId_gg00,
                          leafPageCount, indexPageCount, recordCount);
                    IF  t.trError_gg00 = e_ok
                    THEN
                        bd998SetPageAndRecordCount (t, destFileId.fileTabId_gg00,
                              leafPageCount, indexPageCount, recordCount);
                    (*ENDIF*) 
                    IF  t.trError_gg00 = e_ok
                    THEN
                        bd998SetPageAndRecordCount (t, sourceFileId.fileTabId_gg00, 1, 0, 0)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            bd30ReleaseTree (sourceCurrent)
            END;
        (*ENDIF*) 
        bd30ReleaseTree (destCurrent)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
&ifdef TRACE
t01basis_error (bi, 'mv file err ', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01next_bad_dev (
            VAR dev_type   : tsp2_dev_type;
            VAR devno      : tsp00_Int4;
            VAR devname    : tsp2_devname;
            VAR really_bad : boolean);
 
BEGIN
&ifdef TRACE
t01name (bi, '====> bd next_badd');
&endif
really_bad  := true;
devname     := b01blankfilename;
dev_type    := sp2dt_trace;
devno       := 1;
&ifdef TRACE
t01int4  (bi, 'dev_type    ', ord (dev_type));
t01vffn  (bi, 'devname     ', devname);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01next_dev_info (
            VAR dev_no          : tsp00_Int4;
            VAR dev_type        : tsp2_dev_type;
            VAR dev_name        : tsp2_devname;
            VAR dev_size        : tsp00_Int4;
            VAR dev_used_blocks : tsp00_Int4;
            VAR dev_online      : boolean;
            VAR dev_state       : tsp00_C18);
 
VAR
      found : boolean;
 
BEGIN
&ifdef TRACE
t01name (bi, '====> bd next_dinf');
&endif
dev_name        := b01blankfilename;
dev_size        := 0;
dev_used_blocks := 0;
IF  dev_no < 0
THEN
    BEGIN
    dev_no   := 1;
    dev_type := sp2dt_data
    END
ELSE
    dev_no := dev_no + 1;
(*ENDIF*) 
found := false;
WHILE (NOT found) AND (dev_type <> sp2dt_trace) DO
    CASE dev_type OF
        sp2dt_data :
            BEGIN
            WHILE (dev_no <= bd999MaxConfigurableDataVolumes) AND (NOT bd999IsDataVolumeConfigured(dev_no)) DO
                dev_no := dev_no +1;
            (*ENDWHILE*) 
            IF  dev_no <= bd999MaxConfigurableDataVolumes
            THEN
                BEGIN
                bd999GetDataVolumeName (dev_no, dev_name);
                dev_size        := bd999DataDevSpaceSize (dev_no);
                dev_used_blocks := b11_blocks_used (dev_no);
                dev_state       := 'NotMirrored       ';
                dev_online      := true;
                found           := true
                END
            ELSE
                BEGIN
                dev_no   := 1;
                dev_type := sp2dt_log;
                found    := false
                END
            (*ENDIF*) 
            END;
        sp2dt_log :
            IF  dev_no <= bd999NoOfLogDevices
            THEN
                BEGIN
                bd999GetLogVolumeName (dev_no, dev_name);
                dev_size := bd999LogDevSpaceSize (dev_no);
                IF  bd999LogIsMirrored
                THEN
                    dev_state    := 'AllMirrored       '
                ELSE
                    dev_state    := 'NotMirrored       ';
                (*ENDIF*) 
                dev_online   := true;
                found        := true
                END
            ELSE
                BEGIN
                dev_no   := 1;
                IF  bd999LogIsMirrored
                THEN
                    dev_type := sp2dt_mirr_log
                ELSE
                    dev_type := sp2dt_trace;
                (*ENDIF*) 
                found    := false
                END;
            (*ENDIF*) 
        sp2dt_mirr_log :
            IF  dev_no <= bd999NoOfLogDevices
            THEN
                BEGIN
                bd999GetMirrLogVolumeName (dev_no, dev_name);
                dev_size     := bd999LogDevSpaceSize (dev_no);
                dev_state    := 'AllMirrored       ';
                dev_online   := true;
                found        := true
                END
            ELSE
                BEGIN
                dev_no   := 1;
                dev_type := sp2dt_trace;
                found    := false
                END;
            (*ENDIF*) 
        OTHERWISE
            dev_type := sp2dt_trace;
        END;
    (*ENDCASE*) 
(*ENDWHILE*) 
IF  NOT found
THEN
    dev_no := -1;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01next_fdir_entry (VAR t : tgg00_TransContext;
            VAR file_id : tgg00_FileId);
 
VAR
      found : boolean;
      fi    : tbd_fileinfo;
 
BEGIN
&ifdef TRACE
t01name     (bi, '====> bd next fdir');
t01filename (bi, file_id.fileName_gg00);
&endif
found := false;
REPEAT
    IF  b01downfilesystem
    THEN
        t.trError_gg00 := e_shutdown
    ELSE
        BEGIN
        t.trError_gg00 := e_ok;
        bd17GetNextBlob (t, file_id.fileName_gg00, fi);
        IF  t.trError_gg00 = e_ok
        THEN
            BEGIN
            found := true;
            b30fdir_to_treeid (fi, file_id);
            END
        ELSE
            IF  (t.trError_gg00       = e_file_not_found) AND
                (file_id.fileTfn_gg00 = tfnColumn_egg00 )
            THEN
                BEGIN
                file_id.fileName_gg00 := cgg_zero_fn;
                file_id.fileTfn_gg00  := tfnTemp_egg00;
                t.trError_gg00        := e_ok;
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
UNTIL
    (t.trError_gg00 <> e_ok) OR found;
(*ENDREPEAT*) 
IF  t.trError_gg00 = e_file_not_found
THEN
    t.trError_gg00 := e_no_next_record;
&ifdef TRACE
(*ENDIF*) 
t01treeid      (bi, 'next treeid ', file_id);
t01basis_error (bi, 'next fdir er',t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
FUNCTION
      b01no_of_data_devs : tsp00_Int4;
 
VAR
      no_of_devs : tsp00_Int4;
 
BEGIN
&ifdef TRACE
t01name (bi, '====> bd no data d');
&endif
no_of_devs         := bd999NoOfDataDevices;
b01no_of_data_devs := no_of_devs;
&ifdef TRACE
t01int4 (bi, 'no data devs', no_of_devs);
&endif
END;
 
(*------------------------------*) 
 
FUNCTION
      b01no_of_log_devs : tsp00_Int4;
 
VAR
      no_of_devs : tsp00_Int4;
 
BEGIN
&ifdef TRACE
t01name (bi, '====> bd no log de');
&endif
no_of_devs := bd999NoOfLogDevices;
b01no_of_log_devs := no_of_devs;
&ifdef TRACE
t01int4 (bi, 'no log devs ', no_of_devs);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01pdestroy_perm_file (VAR t : tgg00_TransContext;
            VAR file_id : tgg00_FileId);
 
VAR
      fn_trace   : tgg11_BdFilenameTrace;
      root_trace : tgg11_BdRootTrace;
      filetype   : tbd01_mapTypeIntoChar;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    fn_trace.bdfTrType_gg11 := bdtrFilename_egg11;
    fn_trace.bdfFn_gg11     := file_id.fileName_gg00;
    b120InsertTrace (t, bd, b01destroy, sizeof (fn_trace), @fn_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd drop perm');
t01treeid (bi, 'fileId      ', file_id);
&endif
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown
ELSE
    IF  (ftsPerm_egg00 in file_id.fileType_gg00   ) OR
        (ftsByteStr_egg00 in file_id.fileType_gg00)
    THEN
        bd01destroy_file (t, file_id, root_trace.bdrRoot_gg11, cgg_zero_id)
    ELSE
        BEGIN
        t.trError_gg00     := e_invalid_filetype;
        filetype.typeAsSet := file_id.fileType_gg00;
        g01opmsg (sp3p_console, sp3m_error, csp3_b01_3_invalid_filetype,
              csp3_n_btree, 'ftsTemp IN filetype     ', ord(filetype.typeAsChar[1]));
        b06write_filename_and_root (file_id);
        vtracestack;
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    IF  t.trError_gg00 = e_file_not_found
    THEN
        root_trace.bdrRoot_gg11 := NIL_PAGE_NO_GG00;
    (*ENDIF*) 
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b01destroy, sizeof (root_trace), @root_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01basis_error (bi, 'drop perm er', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      bd01DropLobFile (
            VAR trans    : tgg00_TransContext;
            VAR fileId   : tgg00_FileId;
            parentFileNo : tgg00_Surrogate);
 
VAR
      fn_trace   : tgg11_BdFilenameTrace;
      root_trace : tgg11_BdRootTrace;
      filetype   : tbd01_mapTypeIntoChar;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    fn_trace.bdfTrType_gg11 := bdtrFilename_egg11;
    fn_trace.bdfFn_gg11     := fileId.fileName_gg00;
    b120InsertTrace (trans, bd, b01destroy, sizeof (fn_trace), @fn_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd drop lob ');
t01treeid (bi, 'fileId      ', fileId);
&endif
IF  b01downfilesystem
THEN
    trans.trError_gg00 := e_shutdown
ELSE
    IF  (ftsPerm_egg00 in fileId.fileType_gg00   ) OR
        (ftsByteStr_egg00 in fileId.fileType_gg00)
    THEN
        bd01destroy_file (trans, fileId, root_trace.bdrRoot_gg11, parentFileNo)
    ELSE
        BEGIN
        trans.trError_gg00 := e_invalid_filetype;
        filetype.typeAsSet := fileId.fileType_gg00;
        g01opmsg (sp3p_console, sp3m_error, csp3_b01_3_invalid_filetype,
              csp3_n_btree, 'ftsTemp IN filetype     ', ord(filetype.typeAsChar[1]));
        b06write_filename_and_root (fileId);
        vtracestack;
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    IF  trans.trError_gg00 = e_file_not_found
    THEN
        root_trace.bdrRoot_gg11 := NIL_PAGE_NO_GG00;
    (*ENDIF*) 
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrError_gg11  := trans.trError_gg00;
    b120InsertTrace (trans, bd, b01destroy, sizeof (root_trace), @root_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01basis_error (bi, 'drop lob err', trans.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01prefix_destroy_files (
            VAR t         : tgg00_TransContext;
            VAR prefix_fn : tgg00_Filename;
            prefix_len    : integer);
 
VAR
      bFirst         : boolean;
      bSharedFile    : boolean;
      i              : integer;
      fi             : tbd_fileinfo;
      prefixFileName : tgg00_Filename;
      fileId         : tgg00_FileId;
      current        : tbd_current_tree;
      fn_trace       : tgg11_BdFilenameTrace;
      root_trace     : tgg11_BdRootTrace;
 
BEGIN
&ifdef TRACE
t01name     (bi, '==ski bd prefix de');
IF  (prefix_fn[1] <> chr (ord (tfnAux_egg00)))
    AND (prefix_fn[1] <> chr (ord (tfnTempAux_egg00)))
THEN
    g01abort (csp3_bd_msg, csp3_n_size_check,
          'PRFIX DSTRY ONLY FOR AUX', 0);
&endif
&ifdef TRACE
(*ENDIF*) 
t01name     (bi, '====> bd prefix de');
t01filename (bi, prefix_fn);
t01int4     (bi, 'prefix len  ', prefix_len);
&endif
bSharedFile := true;
bFirst      := true;
WITH t DO
    REPEAT
        IF  b01downfilesystem
        THEN
            trError_gg00 := e_shutdown
        ELSE
            BEGIN
            trError_gg00 := e_ok;
            IF  bFirst
            THEN
                BEGIN
                bFirst         := false;
                prefixFileName := prefix_fn;
                (* *)
                FOR i := prefix_len + 1 TO FN_MXGG00 DO
                    prefixFileName[ i ] := chr(0);
                (*ENDFOR*) 
                fileId               := b01niltree_id;
                fileId.fileName_gg00 := prefixFileName;
                (* *)
                b17state_fdir(prefix_fn, fi, bSharedFile, t);
                IF  trError_gg00 = e_ok
                THEN
                    b17del_fdir (prefix_fn, bSharedFile, t);
                (*ENDIF*) 
                IF  trError_gg00 = e_file_not_found
                THEN
                    b17next_del_fdir (prefixFileName, prefix_len, fileId.fileName_gg00,
                          fi, t)
                (*ENDIF*) 
                END
            ELSE
                b17next_del_fdir (prefixFileName, prefix_len, fileId.fileName_gg00,
                      fi, t);
            (*ENDIF*) 
            IF  (trError_gg00 = e_ok)
                AND
                (g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00)
            THEN
                BEGIN
                fn_trace.bdfTrType_gg11 := bdtrFilename_egg11;
                fn_trace.bdfFn_gg11     := fileId.fileName_gg00;
                b120InsertTrace (t, bd, b01p_destroy, sizeof (fn_trace), @fn_trace)
                END;
            (*ENDIF*) 
            IF  (trError_gg00 = e_ok) AND (fi.fi_root <> NIL_PAGE_NO_GG00)
            THEN
                BEGIN
                b30fdir_to_treeid (fi, fileId);
                IF  (g04inv_tfn (fileId.fileTfn_gg00)) (* PTS 1126494 2003-12-16 *)
                    OR
                    ((fileId.fileTfn_gg00 = tfnAux_egg00) AND g04inv_tfn (fileId.fileOldTfn_gg00))
                THEN
                    bd03ReleaseInvTree (t, fileId)
                ELSE
                    IF  ftsByteStr_egg00 IN fi.fi_type
                    THEN
                        bd05DropLob (t, fileId, cgg_zero_id)
                    ELSE
                        BEGIN
&                       ifdef TRACE
                        t01int4 (bi, 'scol count  ', fi.fi_col_cnt);
&                       endif
                        fileId.fileBdUse_gg00 := fileId.fileBdUse_gg00 + [bd_release_acc];
                        bd30GetTree (t, fileId, current, m_drop,
                              LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
                        IF  trError_gg00 = e_ok
                        THEN
                            BEGIN
                            IF  (fi.fi_col_cnt > 0) AND (fileId.fileAuxCnt_gg00 < 0)
                            THEN
                                (* is set when executing m_change, mm_key *)
                                bd30DropTree (current, 0, NOT c_only_empty)
                            ELSE
                                bd30DropTree (current, fi.fi_col_cnt, NOT c_only_empty);
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        bd30ReleaseTree (current);
                        fileId.fileBdUse_gg00 := fileId.fileBdUse_gg00 - [bd_release_acc];
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  trError_gg00 = e_bad_datapage
                THEN
                    trError_gg00 := e_ok;
                (*ENDIF*) 
                IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
                THEN
                    BEGIN
                    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
                    root_trace.bdrRoot_gg11   := fileId.fileRoot_gg00;
                    root_trace.bdrError_gg11  := trError_gg00;
                    b120InsertTrace (t, bd, b01p_destroy, sizeof (root_trace), @root_trace)
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  bSharedFile AND (trError_gg00 = e_file_not_found)
        THEN
            BEGIN
            trError_gg00 := e_ok;
            bSharedFile  := false;
            bFirst       := true;
            END;
        (*ENDIF*) 
    UNTIL
        (trError_gg00 <> e_ok);
    (*ENDREPEAT*) 
(*ENDWITH*) 
IF  t.trError_gg00 = e_file_not_found
THEN
    t.trError_gg00 := e_ok;
&ifdef TRACE
(*ENDIF*) 
t01basis_error (bi, 'prefix destr', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01pverify_participant (
            VAR t              : tgg00_TransContext;
            VAR file_id        : tgg00_FileId;
            is_cold            : boolean;
            bWithExtendedCheck : boolean);
 
VAR
      NumPages         : tsp00_Int4;
      oldTreeStatistic : tbd00_TreeStatistic;
      treeStatistic    : tbd00_TreeStatistic;
      fi               : tbd_fileinfo;
      current          : tbd_current_tree;
      VerifyTrace      : tgg11_BdVerifyTrace;
 
BEGIN
&ifdef TRACE
t01bool   (bi, 'verify cold ', is_cold);
t01bool   (bi, 'extended    ', bWithExtendedCheck);
t01treeid (bi, 'treeid      ', file_id);
&endif
NumPages := 0;
WITH t DO
    BEGIN
    IF  (g04inv_tfn (file_id.fileTfn_gg00)) (* PTS 1126494 2003-12-16 *)
        OR
        ((file_id.fileTfn_gg00 = tfnAux_egg00) AND g04inv_tfn (file_id.fileOldTfn_gg00))
    THEN
        bd03VerifyInvTree (t, file_id, is_cold, bWithExtendedCheck, NumPages)
    ELSE
        BEGIN
        IF  b01downfilesystem
        THEN
            trError_gg00 := e_shutdown
        ELSE
            BEGIN
            trError_gg00 := e_ok;
            IF  (file_id.fileTfn_gg00 <> tfnColumn_egg00)
                AND (file_id.fileTfn_gg00 <> tfnAux_egg00)
                AND (file_id.fileTfn_gg00 <> tfnTempAux_egg00)
            THEN
                bd998GcGetFDirEntryFileinfo (t, file_id.fileName_gg00, fi,
                      ftsShared_egg00 IN file_id.fileType_gg00)
            ELSE
                b17state_fdir (file_id.fileName_gg00, fi,
                      ftsShared_egg00 IN file_id.fileType_gg00, t);
            (*ENDIF*) 
            IF  trError_gg00 <> e_ok
            THEN
                BEGIN
                IF  trError_gg00 = e_file_not_found
                THEN
                    trError_gg00 := e_ok
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  file_id.fileTfn_gg00 <> tfnObj_egg00
                THEN
                    b30fdir_to_treeid (fi, file_id);
                (*ENDIF*) 
                IF  (ftsByteStr_egg00 IN fi.fi_type)
                    AND (file_id.fileTfn_gg00 <> tfnObj_egg00)
                THEN
                    BEGIN
                    bd60VerifyLob (t, file_id, is_cold, NumPages);
                    IF  trError_gg00 = e_ok
                    THEN
                        (* PTS 1133300 UH 2005-01-11 *)
                        bd30AddBlobIdFoundInFiledirectory (t, file_id.fileTabId_gg00);
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    IF  file_id.fileTfn_gg00 = tfnObj_egg00
                    THEN
                        BEGIN
                        bd30BuildCurrent (t, file_id, current);
                        bd92VerifyObjFile (current, is_cold)
                        END
                    ELSE
                        IF  file_id.fileTfn_gg00 <> tfnContObj_egg00
                        THEN
                            BEGIN
                            (* nothing needs to be done for object continuation files  *)
                            (* since they get already checked when the verify routine  *)
                            (* is called for the corresponding primary file of type    *)
                            (* tfnObj_egg00                                            *)
                            bd30VerifyTree (t, file_id, treeStatistic, is_cold, bWithExtendedCheck);
                            IF  (trError_gg00 = e_ok) AND is_cold
                            THEN
                                BEGIN  (* table is protected against concurrent access *)
                                WITH oldTreeStatistic DO
                                    bd998GetPageAndRecordCount (t, file_id.fileTabId_gg00,
                                          ts_LeafPages_bd00, ts_IndexPages_bd00, ts_RecordCount_bd00);
                                (*ENDWITH*) 
                                (* *)
                                IF  (oldTreeStatistic.ts_LeafPages_bd00   <> treeStatistic.ts_LeafPages_bd00  ) OR
                                    (oldTreeStatistic.ts_IndexPages_bd00  <> treeStatistic.ts_IndexPages_bd00 ) OR
                                    (oldTreeStatistic.ts_RecordCount_bd00 <> treeStatistic.ts_RecordCount_bd00)
                                THEN
                                    WITH treeStatistic DO
                                        bd998SetPageAndRecordCount (t, file_id.fileTabId_gg00,
                                              ts_LeafPages_bd00, ts_IndexPages_bd00, ts_RecordCount_bd00);
                                    (*ENDWITH*) 
                                (*ENDIF*) 
                                IF  trError_gg00 = e_file_not_found (* file could be marked as deleted *)
                                THEN
                                    trError_gg00 := e_ok;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            NumPages := treeStatistic.ts_LeafPages_bd00;
                            END
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (trError_gg00 <> e_ok) OR (g01vtrace.vtrAll_gg00)
    THEN
        BEGIN
        VerifyTrace.bdvRootTrace_gg11.bdrTrType_gg11 := bdtrVerify_egg11;
        VerifyTrace.bdvRootTrace_gg11.bdrError_gg11  := trError_gg00;
        VerifyTrace.bdvRootTrace_gg11.bdrRoot_gg11   := file_id.fileRoot_gg00;
        VerifyTrace.bdvNumPages_gg11                 := NumPages;
        VerifyTrace.bdvFn_gg11                       := file_id.fileName_gg00;
        b120InsertTrace (t, bd, b01verify, sizeof (VerifyTrace), @VerifyTrace)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      bd01RenameFile (
            VAR t          : tgg00_TransContext;
            VAR parent_Id  : tgg00_Surrogate;
            VAR srcFileId  : tgg00_FileId;
            VAR destFileId : tgg00_FileId);
 
VAR
      renameTrace  : tgg11_BdRenameTrace;
      rootTrace    : tgg11_BdRootTrace;
 
BEGIN
(* only for blobs and temporary files *)
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    renameTrace.bdrnTrType_gg11 := bdtrRename_egg11;
    renameTrace.bdrnOldFn_gg11  := srcFileId.fileName_gg00;
    renameTrace.bdrnNewFn_gg11  := destFileId.fileName_gg00;
    b120InsertTrace (t, bd, b01rename, sizeof (renameTrace), @renameTrace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd rename fi');
t01treeid (bi, 'src fileId  ', srcFileId);
t01treeid (bi, 'dest fileId ', destFileId);
&endif
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown
ELSE
    BEGIN
    t.trError_gg00 := e_ok;
    IF  srcFileId.fileName_gg00 <> destFileId.fileName_gg00
    THEN
        bd17RenameFile(t, srcFileId, destFileId, parent_Id);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    rootTrace.bdrTrType_gg11 := bdtrRoot_egg11;
    rootTrace.bdrRoot_gg11   := destFileId.fileRoot_gg00;
    rootTrace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b01rename, sizeof (rootTrace), @rootTrace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01treeid      (bi, 'new fileId  ', destFileId);
t01basis_error (bi, 'rename err  ', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01reset_monitor (part : tgg00_MonitorPart);
 
BEGIN
&ifdef TRACE
t01name (bi, '====> bd reset mon');
&endif
b73init_ref_statistic (part);
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01restart_filesystem (VAR t : tgg00_TransContext;
            IncrementConvVersion : boolean);
 
BEGIN
&ifdef TRACE
t01name (bi, '====> bd restart  ');
&endif
t.trError_gg00     := e_ok;
b01downfilesystem  := false;
b06init_errtxt;
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    bd999AttachAllDataVolumes (t.trTaskId_gg00, t.trError_gg00);
    IF  t.trError_gg00 = e_ok
    THEN
        bd999AttachAllLogVolumes (t.trTaskId_gg00, t.trError_gg00);
    (*ENDIF*) 
    IF  t.trError_gg00 <> e_ok
    THEN
        BEGIN
        bd999DetachAllVolumes (t.trTaskId_gg00);
        b01downfilesystem := true
        END
    (*ENDIF*) 
    END
ELSE
    BEGIN
    b01downfilesystem := true
    END;
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    k57init_restartrec_handling (t);
    IF  t.trError_gg00 = e_ok
    THEN
        b10rc_restart_converter(t.trTaskId_gg00, t.trError_gg00,
              k57restartrec^.rstConverterVersion_kb00,
              bd999TotalDataPages,
              IncrementConvVersion,
              k57restartrec^.rstLastSaveDataSuccessful_kb00,
              k57restartrec^.rstConfigParam_kb00);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        bd20InitDataCache (t.trTaskId_gg00, t.trError_gg00,
              bd999FramesAvailable, bd999TotalDataPages);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        bd17RestartBlobFdir (t, kb57GetLongFdir);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        bd998RestartFDir(
              t,
              kb57GetFdirRoot,
              bd10GetConverterVersion,
              k57restartrec^.rstConverterVersion_kb00,
              IncrementConvVersion);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        IF  NOT gg999CheckDataCompatibility(k57restartrec^.rstReleaseVersion_kb00)
        THEN
            t.trError_gg00 := e_software_too_old;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  t.trError_gg00 <> e_ok
    THEN
        BEGIN
        bd999DetachAllVolumes (t.trTaskId_gg00);
        b01downfilesystem := true
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    IF  t.trError_gg00 = e_ok (* PTS 1111179 TS 2001-07-30 *)
    THEN
        BEGIN
        bd999EnableDataWriter;
        END;
    (* PTS 1114877 UH 2002-03-18 *)
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        kb560CreateHistoryManager (t);
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 <> e_ok
    THEN
        BEGIN
        bd999DetachAllVolumes (t.trTaskId_gg00);
        b01downfilesystem := true
        END
    (*ENDIF*) 
    END;
&ifdef TRACE
(*ENDIF*) 
t01basis_error (bi, 'restart err ', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01set_fileversion (VAR t : tgg00_TransContext;
            VAR file_id     : tgg00_FileId;
            new_fileversion : tgg91_FileVersion;
            new_long_cnt    : tsp00_Int2);
 
CONST
      c_dummy_new_long_cnt = -1;
 
VAR
      fi      : tbd_fileinfo;
      current : tbd_current_tree;
 
BEGIN
&ifdef TRACE
t01name      (bi, '====> set filevers');
t01treeid    (bi, 'treeid      ', file_id);
ta01FileVers (bi, 'new filevers', new_fileversion);
t01int4      (bi, 'new long cnt', new_long_cnt);
&endif
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown
ELSE
    BEGIN
    t.trError_gg00 := e_ok;
    b17state_fdir (file_id.fileName_gg00, fi, ftsShared_egg00 in file_id.fileType_gg00,t);
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        b30fdir_to_treeid (fi, file_id);
        bd30GetTree (t, file_id, current, m_set,
              LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
        IF  t.trError_gg00 = e_ok
        THEN
            bd30SetFileVersion (current, new_fileversion);
        (*ENDIF*) 
        bd30ReleaseTree (current)
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        WITH fi DO
            BEGIN
            fi_vers := new_fileversion;
            IF  new_long_cnt <> c_dummy_new_long_cnt
            THEN
                fi.fi_col_cnt := new_long_cnt;
            (*ENDIF*) 
            b17repl_fdir (file_id.fileName_gg00, fi,
                  ftsShared_egg00 IN file_id.fileType_gg00, t)
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
&ifdef TRACE
t01basis_error (bi, 'set filev e ', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01treeleafnodes (VAR t     : tgg00_TransContext;
            VAR file_id           : tgg00_FileId;
            m_type                : tgg00_MessType;
            VAR old_treeleafnodes : tsp00_Int4);
 
VAR
      fi        : tbd_fileinfo;
      auxFileId : tgg00_FileId;
      current   : tbd_current_tree;
 
BEGIN
&ifdef TRACE
t01name     (bi, '====> treeleafnode');
t01treeid   (bi, 'treeid      ', file_id);
t01messtype (bi, 'fetch/update', m_type);
&endif
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown
ELSE
    WITH t DO
        BEGIN
        trError_gg00 := e_ok;
        auxFileId    := file_id;
        CASE m_type OF
            m_fetch:
                BEGIN
                b17state_fdir (auxFileId.fileName_gg00, fi, ftsShared_egg00 IN file_id.fileType_gg00, t);
                IF  trError_gg00 = e_ok
                THEN
                    BEGIN
                    b30fdir_to_treeid (fi, auxFileId);
                    auxFileId.fileLeafNodes_gg00 := cgg_nil_leafnodes;
                    bd30GetTree (t, auxFileId, current, m_fetch,
                          NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
                    IF  trError_gg00 = e_ok
                    THEN
                        old_treeleafnodes := current.currRootNptrs_bd00.np_ptr^.ndTreeLeaves_bd00;
                    (*ENDIF*) 
                    bd30ReleaseTree (current);
                    END;
                (*ENDIF*) 
                END;
            m_update:
                BEGIN
                b17state_fdir (auxFileId.fileName_gg00, fi, ftsShared_egg00 IN file_id.fileType_gg00, t);
                IF  trError_gg00 = e_ok
                THEN
                    BEGIN
                    b30fdir_to_treeid (fi, auxFileId);
                    auxFileId.fileLeafNodes_gg00 := cgg_nil_leafnodes;
                    bd30GetTree (t, auxFileId, current, m_update,
                          LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
                    IF  trError_gg00 = e_ok
                    THEN
                        BEGIN
                        a103CatalogCacheInvalidateTable (t.trTaskId_gg00, file_id.fileTabId_gg00);
                        current.currRootNptrs_bd00.np_ptr^.ndTreeLeaves_bd00 :=
                              file_id.fileLeafNodes_gg00; (* newLeafNodes *)
                        current.currRootUpdated_bd00 := true
                        END;
                    (*ENDIF*) 
                    bd30ReleaseTree (current);
                    END
                (*ENDIF*) 
                END;
            OTHERWISE:
                BEGIN
                g01opmsg (sp3p_console, sp3m_error, csp3_b01_1_illegal_mess_type,
                      csp3_n_btree, 'illegal mess type       ', ord (m_type));
                trError_gg00 := e_not_implemented
                END
            END
        (*ENDCASE*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
&ifdef TRACE
t01basis_error (bi, 'set treel e ', t.trError_gg00);
t01int4        (bi, 'old leafnode', old_treeleafnodes);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01setto_zero_full_and_null;
 
VAR
      i : integer;
 
BEGIN
b21m_init_monitor_rec;
b01downfilesystem := true;
FOR i := 1 TO sizeof (tsp00_Key) DO
    b01zerokey [i] := chr (0);
(*ENDFOR*) 
FOR i := 1 TO sizeof (tsp00_Key) DO
    b01fullkey [i] := chr (255);
(*ENDFOR*) 
FOR i := 1 TO sizeof (tsp00_VFilename) DO
    b01blankfilename [i] := ' ';
(*ENDFOR*) 
WITH b01niltree_id DO
    BEGIN
    fileRootCheck_gg00        := ROOT_CHECK_GG00;
    fileLeafNodes_gg00        := cgg_nil_leafnodes;
    fileHandling_gg00         := [hsWithoutLock_egg00];
    fileBdUse_gg00            := [];
    fileRoot_gg00             := NIL_PAGE_NO_GG00;
    fileVersion_gg00.ci2_gg00 := cgg_dummy_file_version;
    fileType_gg00             := []; (* M.Ki. *)
    fileName_gg00             := cgg_zero_fn;
    gg06SetNilRef (fileUserRef_gg00);
    END;
(*ENDWITH*) 
WITH b01nilcurrent DO
    BEGIN
    curr_lvl_1_pno                := NIL_PAGE_NO_GG00;
    currLeftBound_bd00            := NIL_PAGE_NO_GG00;
    currRightBound_bd00           := NIL_PAGE_NO_GG00;
    curr_tree_id                  := b01niltree_id;
    currRootPageLockMode_bd00     := plmLock_ebd00;
    currIndexPageLockMode_bd00    := plmLock_ebd00;
    currUnlockAllowed_bd00        := false;
    curr_action                   := m_nil;
    currFreeQueue_bd00.fqTop_bd00 := 1;
    currNumLeaves_bd00            := 1;
    currRootNptrs_bd00.np_ptr     := NIL;
    currRootNptrs_bd00.np_cbptr   := NIL;
    currIndexNptrs_bd00.np_ptr    := NIL;
    currIndexNptrs_bd00.np_cbptr  := NIL;
    currRootUpdated_bd00          := false;
    currIndexUpdated_bd00         := false;
    currCounter_bd00              := 0;
    currLeafPageCountDelta_bd00   := 0;
    currIndexPageCountDelta_bd00  := 0;
    currExtendedFileTypeSet_bd00  := [];
    END;
(*ENDWITH*) 
b06init_errtxt;
bd30InitFileIdForBlobFileIds; (* PTS 1133300 UH 2005-01-11 *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01sfile_statistic (
            VAR t              : tgg00_TransContext;
            VAR file_id        : tgg00_FileId;
            with_shortcol_file : boolean;
            VAR info           : tgg00_SampleInfo);
 
VAR
      bShortColFileUsed : boolean;
      fi                : tbd_fileinfo;
      scol_file_id      : tgg00_FileId;
      current           : tbd_current_tree;
      scol_current      : tbd_current_tree;
      tableStat         : tgg00_TableStatInfo;
 
BEGIN
&ifdef TRACE
t01name (bi, '====> bd statistic');
t01treeid (bi, 'treeid      ', file_id);
&endif
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown
ELSE
    WITH t DO
        BEGIN
        trError_gg00          := e_ok;
        bShortColFileUsed     := false;
        file_id.fileRoot_gg00 := NIL_PAGE_NO_GG00;
        b17state_fdir (file_id.fileName_gg00, fi, ftsShared_egg00 IN file_id.fileType_gg00, t);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            b30fdir_to_treeid (fi, file_id);
            bd30GetTree (t, file_id, current, m_column,
                  NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00)
            END;
        (*ENDIF*) 
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            IF  (fi.fi_col_cnt > 0) AND with_shortcol_file
            THEN
                BEGIN
                bShortColFileUsed := true;
                scol_file_id      := current.curr_tree_id;
                g04short_col_tree_build (current.curr_tree_id.fileTabId_gg00,
                      scol_file_id, trError_gg00);
                bd30GetTree (t, scol_file_id, scol_current, m_column,
                      NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
                END;
            (*ENDIF*) 
            IF  trError_gg00 = e_ok
            THEN
                bd999CalculateTableStatistic (t, current, scol_current, with_shortcol_file,
                      fi.fi_col_cnt, tableStat);
            (*ENDIF*) 
            IF  bShortColFileUsed
            THEN
                bd30ReleaseTree (scol_current)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  trError_gg00 = e_ok
        THEN
            file_id := current.curr_tree_id;
        (*ENDIF*) 
        IF  trError_gg00 = e_ok
        THEN
            WITH info DO (* temporary solution as long as tgg00_SampleInfo is given *)
                BEGIN
                sam_tree_id         := file_id;
                leafnodes           := tableStat.TabStatLeafnodes_gg00;
                sec_key_cnt         := 0;
                prim_key_cnt        := 0;
                avg_prim_per_list   := 0;
                records             := tableStat.TabStatRecords_gg00;
                all_stringcol_pages := tableStat.TabStatAllStringColPages_gg00;
                nodes               := tableStat.TabStatNodes_gg00;
                null_value_cnt      := 0;
                min_sec_key_len     := 0;
                max_sec_key_len     := 0;
                avg_sec_key_len     := 0;
                treecov             := tableStat.TabStatTreeCov_gg00;
                rootcov             := tableStat.TabStatRootCov_gg00;
                indexcov            := tableStat.TabStatIndexCov_gg00;
                min_indexcov        := tableStat.TabStatMinIndexCov_gg00;
                max_indexcov        := tableStat.TabStatMaxIndexCov_gg00;
                leafcov             := tableStat.TabStatLeafCov_gg00;
                min_leafcov         := tableStat.TabStatMinLeafCov_gg00;
                max_leafcov         := tableStat.TabStatMaxLeafCov_gg00;
                rec_per_page        := tableStat.TabStatRecsPerPage_gg00;
                ave_rec_length      := tableStat.TabStatAveRecLength_gg00;
                min_rec_length      := tableStat.TabStatMinRecLength_gg00;
                max_rec_length      := tableStat.TabStatMaxRecLength_gg00;
                ave_key_length      := tableStat.TabStatAveKeyLength_gg00;
                indexnodes          := tableStat.TabStatIndexNodes_gg00;
                ave_sep_length      := tableStat.TabStatAveSepLength_gg00;
                min_key_length      := tableStat.TabStatMinKeyLength_gg00;
                max_key_length      := tableStat.TabStatMaxKeyLength_gg00;
                min_sep_length      := tableStat.TabStatMinSepLength_gg00;
                max_sep_length      := tableStat.TabStatMaxSepLength_gg00;
                min_rec_per_page    := tableStat.TabStatMinRecsPerPage_gg00;
                max_rec_per_page    := tableStat.TabStatMaxRecsPerPage_gg00;
                rootsegm            := current.curr_tree_id.fileRoot_gg00;
                smplFileType_gg00   := current.curr_tree_id.fileType_gg00;
                pcs_dummy           := false;
                hight               := tableStat.TabStatRootLevel_gg00;
                defined_stringcols  := tableStat.TabStatDefinedStringCols_gg00;
                min_len_stringcol   := tableStat.TabStatMinLenStringCol_gg00;
                max_len_stringcol   := tableStat.TabStatMaxLenStringCol_gg00;
                ave_len_stringcol   := tableStat.TabStatAveLenStringCol_gg00;
                min_stringcol_pages := tableStat.TabStatMinStringColPages_gg00;
                max_stringcol_pages := tableStat.TabStatMaxStringColPages_gg00;
                ave_stringcol_pages := tableStat.TabStatAveStringColPages_gg00;
                sam_clustercount    := tableStat.TabStatClusterCount_gg00;
                invsel_1            := 0;
                invsel_5            := 0;
                invsel_10           := 0;
                invsel_25           := 0;
                invsel_notsel       := 0;
                min_prim_per_list   := 0;
                max_prim_per_list   := 0;
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
&ifdef TRACE
t01basis_error (bi, 'statistic er', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01show_monitor (
            TaskId   : tsp00_TaskId;
            VAR info : tgg00_ReferenceInfo);
 
BEGIN
&ifdef TRACE
t01name (bi, '====> bd show mon ');
&endif
b73show_ref_statistic (TaskId, info);
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01shutdown_filesystem (VAR t : tgg00_TransContext);
 
BEGIN
&ifdef TRACE
t01name (bi, '====> bd shutdown ');
&endif
t.trError_gg00 := e_ok;
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown
ELSE
    BEGIN
    b01downfilesystem := true;
    bd20ShutdownDataCache (t.trTaskId_gg00);
    bd10ShutdownConverter (t.trTaskId_gg00);
    bd998ShutdownFDir (t.trTaskId_gg00);
    kb560DropHistoryManager; (* PTS 1122361 UH 2003-05-27 *)
    bd999DetachAllVolumes (t.trTaskId_gg00)
    END;
(*ENDIF*) 
&ifdef TRACE
t01basis_error (bi, 'shutdown err', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01tcreate_file (VAR t : tgg00_TransContext;
            VAR file_id : tgg00_FileId);
 
BEGIN
&ifdef TRACE
t01name   (bi, '====> bd tcreate f');
t01treeid (bi, 'treeid req  ', file_id);
&endif
bd998CreateTempFile (t, file_id);
&ifdef TRACE
t01treeid      (bi, 'new treeid  ', file_id);
t01basis_error (bi, 'tcreate err ', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01tinit_temp_cache (VAR t : tgg00_TransContext;
            is_control_session : boolean);
 
CONST
      c_alloc_monitor = true;
 
BEGIN
&ifdef TRACE
t01name (bi, '====> bd tinit tc ');
t01bool (bi, 'is control s', is_control_session);
&endif
t.trError_gg00 := e_ok;
IF  is_control_session OR bd10IsConnectAllowed
THEN
    b21init_temp_cache (t.trTaskId_gg00,
          c_alloc_monitor, is_control_session,
          t.trBdTcachePtr_gg00, t.trError_gg00)
ELSE
    t.trError_gg00 := e_no_more_temp_space;
(*ENDIF*) 
IF  (t.trError_gg00 <> e_ok) AND (t.trError_gg00 <> e_no_more_temp_space)
THEN
    t.trBdTcachePtr_gg00 := NIL;
&ifdef TRACE
(*ENDIF*) 
t01basis_error (bi, 'tinit tc err', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01trelease_temp_cache (VAR t : tgg00_TransContext);
 
BEGIN
&ifdef TRACE
t01name (bi, '====> bd trele tc ');
&endif
b21temp_cache_release (t.trTaskId_gg00, t.trBdTcachePtr_gg00);
t.trBdTcachePtr_gg00 := NIL;
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01treset_file (VAR t : tgg00_TransContext;
            VAR file_id : tgg00_FileId);
 
VAR
      fi         : tbd_fileinfo;
      current    : tbd_current_tree;
      fn_trace   : tgg11_BdFilenameTrace;
      root_trace : tgg11_BdRootTrace;
      filetype   : tbd01_mapTypeIntoChar;
 
BEGIN
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    fn_trace.bdfTrType_gg11 := bdtrFilename_egg11;
    fn_trace.bdfFn_gg11     := file_id.fileName_gg00;
    b120InsertTrace (t, bd, b01t_reset, sizeof (fn_trace), @fn_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01name   (bi, '====> bd treset f ');
t01treeid (bi, 'treeid req  ', file_id);
&endif
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown
ELSE
    BEGIN
    IF  NOT (ftsTemp_egg00 IN file_id.fileType_gg00)
    THEN
        BEGIN
        t.trError_gg00     := e_invalid_filetype;
        filetype.typeAsSet := file_id.fileType_gg00;
        g01opmsg (sp3p_console, sp3m_error, csp3_b01_4_invalid_filetype,
              csp3_n_btree, 'NOT ftsTemp IN fileType ', ord(filetype.typeAsChar[1]));
        b06write_filename_and_root (file_id);
        vtracestack
        END
    ELSE
        BEGIN
        t.trError_gg00 := e_ok;
        b17state_fdir (file_id.fileName_gg00, fi, ftsShared_egg00 IN file_id.fileType_gg00, t);
        IF  t.trError_gg00 = e_ok
        THEN
            BEGIN
            b30fdir_to_treeid (fi, file_id);
            bd30GetTree (t, file_id, current, m_drop,
                  LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
            IF  t.trError_gg00 = e_ok
            THEN
                bd30DropTree (current, 0, c_only_empty);
            (*ENDIF*) 
            bd30ReleaseTree (current)
            END
        ELSE
            IF  t.trError_gg00 = e_file_not_found
            THEN
                BEGIN
                t.trError_gg00 := e_ok;
                bd998CreateTempFile (t, file_id);
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrBdPrim_gg00
THEN
    BEGIN
    root_trace.bdrTrType_gg11 := bdtrRoot_egg11;
    root_trace.bdrRoot_gg11   := file_id.fileRoot_gg00;
    root_trace.bdrError_gg11  := t.trError_gg00;
    b120InsertTrace (t, bd, b01t_reset, sizeof (root_trace), @root_trace)
    END;
&ifdef TRACE
(*ENDIF*) 
t01treeid      (bi, 'new treeid  ', file_id);
t01basis_error (bi, 'treset error', t.trError_gg00);
&endif
END;
 
(* PTS 1107952 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      b01verify_database (
            VAR t                 : tgg00_TransContext;
            bWithUpdate           : boolean;
            bWithIndexes          : boolean;
            bWithExtendedCheck    : boolean;
            bWithDeleteUnreferencedBlobs : boolean;
            VAR NumPermPages      : tsp00_Int4;
            VAR NumReleasedBlocks : tsp00_Int4;
            VAR bad_index_cnt     : tsp00_Int4;
            VAR total_bad_cnt     : tsp00_Int4);
 
VAR
      verify_error                : tgg00_BasisError;
      MaxServer                   : integer;
      ConverterVersion            : tsp00_Int4;
      MaxStaticPageNo             : tsp00_PageNo;
      MaxDynamicPageNo            : tsp00_PageNo;
      PackedConvRootBlockAddress  : tsp00_Int4;
      OpenTransOrHistoryFilesOkay : boolean;
 
BEGIN
&ifdef TRACE
t01name (bi, '====> bd verify   ');
&endif
verify_error      := e_ok;
bad_index_cnt     := 0;
NumPermPages      := 0;
NumReleasedBlocks := 0;
total_bad_cnt     := 0;
WITH t DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        BEGIN
        trError_gg00 := e_ok;
        IF  bWithUpdate
        THEN
            bd10BeginColdVerify (t);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        bd998VerifyFdir (t, bWithUpdate);
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        bd17VerifyBlobFdir (t, bWithUpdate, bWithExtendedCheck);
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        OpenTransOrHistoryFilesOkay :=
              kb560VerifyOpenTransAndHistory (t, bWithUpdate);
        IF  trError_gg00 <> e_ok
        THEN
            BEGIN
            verify_error := trError_gg00;
            trError_gg00 := e_ok;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  trError_gg00 = e_ok
    THEN
        BEGIN
        MaxServer := b01no_of_data_devs+1;
        bd30CheckDatabase (t, bad_index_cnt, total_bad_cnt, verify_error,
              bWithUpdate, bWithExtendedCheck, bWithIndexes,
              bWithDeleteUnreferencedBlobs, (* PTS 1133300 UH 2005-01-11 *)
              MaxServer)
        END;
    (*ENDIF*) 
    IF  (total_bad_cnt > 0)
        OR
        NOT OpenTransOrHistoryFilesOkay
    THEN
        BEGIN
        IF  verify_error = e_ok
        THEN
            trError_gg00 := e_file_not_accessible
        ELSE
            trError_gg00 := verify_error;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  trError_gg00 = e_file_not_found
    THEN
        BEGIN
        trError_gg00 := e_ok;
        IF  bWithUpdate
        THEN
            BEGIN
            bd20FlushDataCache (t);
            IF  trError_gg00 = e_ok
            THEN
                bd998FlushFDir (t.trTaskId_gg00);
            (*ENDIF*) 
            IF  trError_gg00 = e_ok
            THEN
                bd10EndColdVerify (t.trTaskId_gg00, NumPermPages, NumReleasedBlocks);
            (*ENDIF*) 
            IF  t.trError_gg00 = e_ok
            THEN
                bd10FlushConverterSerial (t, ConverterVersion ,MaxStaticPageNo,
                      MaxDynamicPageNo, PackedConvRootBlockAddress);
            (*ENDIF*) 
            IF  t.trError_gg00 = e_ok
            THEN
                WITH k57restartrec^, rstConfigParam_kb00 DO
                    BEGIN
                    rstConverterVersion_kb00 := ConverterVersion;
                    crMaxDynamicPno_kb00     := MaxDynamicPageNo;
                    crMaxStaticPno_kb00      := MaxStaticPageNo;
                    crConvRootBlockAddr_kb00 := PackedConvRootBlockAddress;
                    k57save_restartrecord (t.trTaskId_gg00);
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        g01optextmsg (sp3p_knldiag, sp3m_info, csp3_bd_msg,
              csp3_n_check, MSG_STOP_CHECK_OKAY)
        END
    ELSE
        BEGIN
        IF  bWithUpdate
        THEN
            bd10EndFailedColdVerify(t.trTaskId_gg00);
        (*ENDIF*) 
        g01optextmsg (sp3p_knldiag, sp3m_error, csp3_bd_msg,
              csp3_n_check, MSG_STOP_CHECK_WITH_ERR);
        END;
    (*ENDIF*) 
&   ifdef TRACE
    IF  bWithUpdate
    THEN
        BEGIN
        t01p2int4 (bi, 'bad_index_cn', bad_index_cnt
              ,        'total_bad_cn', total_bad_cnt)
        END;
    (*ENDIF*) 
    t01basis_error (bi, 'verify error',trError_gg00);
&   endif
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      b01vstate_fileversion (VAR t : tgg00_TransContext;
            VAR file_id : tgg00_FileId);
 
VAR
      fi : tbd_fileinfo;
 
BEGIN
&ifdef TRACE
t01name   (bi, '====> state filev ');
t01treeid (bi, 'treeid      ', file_id);
&endif
IF  b01downfilesystem
THEN
    t.trError_gg00 := e_shutdown
ELSE
    BEGIN
    t.trError_gg00 := e_ok;
    b17state_fdir (file_id.fileName_gg00, fi, ftsShared_egg00 in file_id.fileType_gg00, t);
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        b30fdir_to_treeid (fi, file_id);
        IF  fi.fi_vers <> file_id.fileVersion_gg00
        THEN
            BEGIN
            file_id.fileVersion_gg00 := fi.fi_vers;
            t.trError_gg00 := e_old_fileversion
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
&ifdef TRACE
ta01FileVers   (bi, 'fdir fvers  ', fi.fi_vers);
t01basis_error (bi, 'state fv  e ', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      bd01DataCacheSize (
            VAR TotalPages : tsp00_Int4;
            VAR UnMapPages : tsp00_Int4);
 
BEGIN
UnMapPages := 0;
bd20GetCacheSize( TotalPages );
END;
 
(*------------------------------*) 
 
FUNCTION
      bd01ConverterSize : tsp00_Int4;
 
BEGIN
bd01ConverterSize := bd10ConverterSize;
END;
 
(*------------------------------*) 
 
PROCEDURE
      bd01SetToBad (
            VAR trans  : tgg00_TransContext;
            VAR fileId : tgg00_FileId);
 
BEGIN
&ifdef TRACE
t01name   (bi, '====> set to bad  ');
t01treeid (bi, 'fileId      ', fileId);
&endif
bd30BadFile (trans, fileId);
END;
 
(*------------------------------*) 
 
PROCEDURE
      bd01SetToNilCurrent( VAR Current : tbd_current_tree );
 
BEGIN
Current := b01nilcurrent;
END;
 
(*------------------------------*) 
 
FUNCTION
      bd01UsableServerForParallelExecution : integer;
 
VAR
      ReadAheadServer : integer;
      ServerAvailable : integer;
 
BEGIN
ServerAvailable := kb900AvailableServerTasks;
ReadAheadServer := b01no_of_data_devs;
IF  (ReadAheadServer > (ServerAvailable DIV 2))
THEN
    ReadAheadServer := (ServerAvailable DIV 2);
(*ENDIF*) 
IF  ReadAheadServer < 2
THEN
    ReadAheadServer := 2;
(*ENDIF*) 
bd01UsableServerForParallelExecution := ReadAheadServer
END;
 
(*------------------------------*) 
 
PROCEDURE
      bd01CalculateClusterStatistics(
            VAR trans        : tgg00_TransContext;
            VAR fileId       : tgg00_FileId;
            VAR leafCount    : tsp00_Int4;
            VAR clusterCount : tsp00_Int4 );
 
VAR
      current : tbd_current_tree;
 
BEGIN
bd30GetTree (trans, fileId, current, m_select,
      NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
IF  trans.trError_gg00 = e_ok
THEN
    bd999CalculateCluster (trans, current, leafCount, clusterCount);
(*ENDIF*) 
bd30ReleaseTree (current);
END;
 
(*------------------------------*) 
 
PROCEDURE
      bd01CalculateRecordsAndLeaves(
            VAR Trans           : tgg00_TransContext;
            VAR FileId          : tgg00_FileId;
            VAR NumberOfLeaves  : tsp00_Int4;
            VAR NumberOfRecords : tsp00_Int4 );
 
VAR
      indexPageCount : tsp00_Int4;
      Current        : tbd_current_tree;
 
BEGIN
&ifdef TRACE
t01name   (bi, '====> bd calc rec ');
t01treeid (bi, 'FileId      ', FileId);
&endif
WITH Trans DO
    BEGIN
    Trans.trError_gg00 := e_ok;
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        BEGIN
        (* PTS 1132071 M.Ki. *)
        indexPageCount := 0;
        bd998GetPageAndRecordCount (Trans, FileId.fileTabId_gg00,
              NumberOfLeaves, indexPageCount, NumberOfRecords);
        IF  NumberOfLeaves = 0
        THEN
            BEGIN
            bd30GetTree (Trans, FileId, Current, m_select,
                  NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
            IF  trError_gg00 = e_ok
            THEN
                bd999CalculateRecordsAndLeaves (Trans, Current,
                      NumberOfLeaves, NumberOfRecords);
            (*ENDIF*) 
            bd30ReleaseTree (Current);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
IF  Trans.trError_gg00 = e_ok
THEN
    BEGIN
    t01int4 (bi, 'record count', NumberOfRecords);
    t01int4 (bi, 'leaf count  ', NumberOfLeaves);
    END;
(*ENDIF*) 
t01basis_error (bi, 'calc rec err', Trans.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      bd01SampleRecordsAndLeaves(
            VAR Trans            : tgg00_TransContext;
            VAR FileId           : tgg00_FileId;
            NumberOfSampleLeaves : tsp00_Int4;
            VAR NumberOfLeaves   : tsp00_Int4;
            VAR NumberOfRecords  : tsp00_Int4 );
 
VAR
      indexPageCount : tsp00_Int4;
      Current        : tbd_current_tree;
 
BEGIN
&ifdef TRACE
t01name   (bi, '====> bd esti rec ');
t01treeid (bi, 'FileId      ', FileId);
t01int4   (bi, 'sample leave', NumberOfSampleLeaves);
&endif
WITH Trans DO
    BEGIN
    Trans.trError_gg00 := e_ok;
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        BEGIN
        (* PTS 1132071 M.Ki. *)
        indexPageCount := 0;
        bd998GetPageAndRecordCount (Trans, FileId.fileTabId_gg00,
              NumberOfLeaves, indexPageCount, NumberOfRecords);
        IF  NumberOfLeaves = 0
        THEN
            BEGIN
            bd30GetTree (Trans, FileId, Current, m_select,
                  NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
            IF  trError_gg00 = e_ok
            THEN
                bd999SampleRecordsAndLeaves (Trans, Current,
                      NumberOfSampleLeaves, NumberOfLeaves, NumberOfRecords);
            (*ENDIF*) 
            bd30ReleaseTree (Current);
            END;
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
IF  Trans.trError_gg00 = e_ok
THEN
    BEGIN
    t01int4 (bi, 'record count', NumberOfRecords);
    t01int4 (bi, 'leaf count  ', NumberOfLeaves);
    END;
(*ENDIF*) 
t01basis_error (bi, 'esti rec err', Trans.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      bd01GetLeafPageAndRecordCount(
            VAR trans         : tgg00_TransContext;
            VAR fileId        : tgg00_FileId;
            countRecords      : boolean;
            VAR leafPageCount : tsp00_Int4;
            VAR recordCount   : tsp00_Int4);
 
VAR
      dummyPageCount : tsp00_Int4;
      indexPageCount : tsp00_Int4;
      startKey       : tgg00_Lkey;
      stopKey        : tgg00_Lkey;
 
BEGIN
trans.trError_gg00 := e_ok;
indexPageCount     := 0;
bd998GetPageAndRecordCount (trans, fileId.fileTabId_gg00,
      leafPageCount, indexPageCount, recordCount);
IF  leafPageCount = 0
THEN
    BEGIN
    (* file directory entry counters are not yet initialised *)
    (* use sampling to get values                            *)
    startKey.keyLen_gg00 := 0;
    stopKey.keyLen_gg00  := PERM_KEY_MXSP00;
    stopKey.keyVal_gg00  := b01fullkey;
    IF  g04inv_tfn (fileId.fileTfn_gg00)
    THEN
        b03calculate_page_count  (trans, fileId,
              startKey, stopKey, countRecords, leafPageCount,
              dummyPageCount, recordCount)
    ELSE
        b02eval_page_count (trans, fileId,
              startKey, stopKey, countRecords, leafPageCount,
              dummyPageCount, recordCount)
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      bd01ExtractForeignKey(
            VAR MessBlock : tgg00_MessBlock;
            VAR AuxFileId : tgg00_FileId);
 
VAR
      current     : tbd_current_tree;
      tempCurrent : tbd_current_tree;
 
BEGIN
&ifdef TRACE
t01name   (bi, '====> bd extract  ');
t01treeid (bi, 'FileId      ', MessBlock.mb_qual^.mtree);
t01treeid (bi, 'AuxFileId   ', AuxFileId);
&endif
WITH MessBlock, mb_trns^ DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        BEGIN
        trError_gg00 := e_ok;
        AuxFileId.fileBdUse_gg00 := AuxFileId.fileBdUse_gg00 + [bd_write_acc];
        bd30GetTree (mb_trns^, AuxFileId, tempCurrent, m_nil,
              LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            bd30GetTree (mb_trns^, mb_qual^.mtree, current, m_select,
                  NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
            IF  trError_gg00 = e_ok
            THEN
                bd50ExtractForeignKey (MessBlock, current, tempCurrent);
            (*ENDIF*) 
            bd30ReleaseTree (current)
            END;
        (*ENDIF*) 
        bd30ReleaseTree (tempCurrent);
        AuxFileId.fileBdUse_gg00 := AuxFileId.fileBdUse_gg00 - [bd_write_acc];
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
t01basis_error (bi, 'extract err ', MessBlock.mb_trns^.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      bd01MultiColumnStatistic(
            VAR MessBlock        : tgg00_MessBlock;
            VAR AuxFileId        : tgg00_FileId;
            bCalculate           : boolean;
            NumberOfSampleLeaves : tsp00_Int4;
            VAR NumberOfLeaves   : tsp00_Int4;
            VAR NumberOfRecords  : tsp00_Int4;
            VAR DistinctValues   : tgg00_ColumnDistinctValues);
 
VAR
      AuxError    : tgg00_BasisError;
      Current     : tbd_current_tree;
      TempCurrent : tbd_current_tree;
 
BEGIN
&ifdef TRACE
t01name   (bi, '====> bd statistic');
t01treeid (bi, 'FileId      ', MessBlock.mb_qual^.mtree);
t01treeid (bi, 'AuxFileId   ', AuxFileId);
&endif
WITH MessBlock, mb_trns^ DO
    BEGIN
    IF  b01downfilesystem
    THEN
        trError_gg00 := e_shutdown
    ELSE
        BEGIN
        trError_gg00 := e_ok;
        bd30GetTree (mb_trns^, MessBlock.mb_qual^.mtree, Current, m_select,
              NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
        IF  trError_gg00 = e_ok
        THEN
            BEGIN
            AuxFileId.fileBdUse_gg00 := AuxFileId.fileBdUse_gg00 + [bd_write_acc];
            IF  trError_gg00 = e_ok
            THEN
                BEGIN
                IF  bCalculate
                THEN
                    WITH MessBlock.mb_qual^ DO
                        BEGIN
                        bd30BuildCurrent (mb_trns^, AuxFileId, TempCurrent);
                        bd999CalculateColumnStatistic (mb_trns^, Current, TempCurrent,
                              mcol_cnt, mcol_pos, (mcol_pos + mcol_cnt -1), MessBlock.mb_st,
                              NumberOfLeaves, NumberOfRecords, DistinctValues);
                        END
                    (*ENDWITH*) 
                ELSE
                    BEGIN
                    bd30GetTree (mb_trns^, AuxFileId, TempCurrent, m_nil,
                          LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
                    AuxFileId.fileRoot_gg00 := TempCurrent.curr_tree_id.fileRoot_gg00;
                    bd72SampleMultiColumnStatistic (MessBlock, Current,
                          TempCurrent, NumberOfSampleLeaves,
                          NumberOfLeaves, NumberOfRecords, DistinctValues);
                    bd30ReleaseTree (TempCurrent);
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            AuxFileId.fileBdUse_gg00 := AuxFileId.fileBdUse_gg00 - [bd_write_acc];
            END;
        (*ENDIF*) 
        bd30ReleaseTree (Current)
        END;
    (*ENDIF*) 
    IF  AuxFileId.fileRoot_gg00 <> NIL_PAGE_NO_GG00
    THEN
        BEGIN
        AuxError     := trError_gg00;
        trError_gg00 := e_ok;
        bd30GetTree (mb_trns^, AuxFileId, TempCurrent, m_drop,
              LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
        IF  trError_gg00 = e_ok
        THEN
            bd30DropTree (TempCurrent, 0,  c_only_empty);
        (*ENDIF*) 
        bd30ReleaseTree (TempCurrent);
        IF  trError_gg00 = e_ok
        THEN
            trError_gg00 := AuxError
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
t01basis_error (bi, 'col stat err', MessBlock.mb_trns^.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      bd01MigrateDataBase(
            TaskId      : tsp00_TaskId;
            VAR TrError : tgg00_BasisError);
 
BEGIN
bd999MigrateDataBase( TaskId, TrError );
END;
 
(*------------------------------*) 
 
PROCEDURE
      bd01ExtractTable (
            VAR trans        : tgg00_TransContext;
            root             : tsp00_PageNo;
            VAR hostFileName : tsp00_VFilename);
 
VAR
      fileId  : tgg00_FileId;
      current : tbd_current_tree;
 
BEGIN
&ifdef TRACE
t01name (bi, '===> extract table');
t01int4 (bi, 'fileRoot    ', root);
&endif
fileId               := b01niltree_id;
fileId.fileRoot_gg00 := root;
fileId.fileType_gg00 := [ ftsPerm_egg00 ];
fileId.fileTfn_gg00  := tfnTable_egg00;
IF  b01downfilesystem
THEN
    trans.trError_gg00 := e_shutdown
ELSE
    WITH trans DO
        BEGIN
        trError_gg00 := e_ok;
        bd30GetTree (trans, fileId, current, m_select,
              NOT LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
        IF  trError_gg00 = e_ok
        THEN
            bd50ExtractTable (current, hostFileName);
        (*ENDIF*) 
        bd30ReleaseTree (current);
        IF  (trError_gg00 = e_old_fileversion) OR
            (trError_gg00 = e_file_not_found )
        THEN
            trError_gg00 := e_invalid_root;
        (*ENDIF*) 
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      bd01destroy_file (
            VAR t             : tgg00_TransContext;
            VAR file_id       : tgg00_FileId;
            VAR trace_root    : tsp00_PageNo;
            parentFileNo      : tgg00_Surrogate);
 
VAR
      fi      : tbd_fileinfo;
      current : tbd_current_tree;
 
BEGIN
t.trError_gg00 := e_ok;
IF  (file_id.fileTfn_gg00 = tfnColumn_egg00   ) OR
    (file_id.fileTfn_gg00 = tfnAux_egg00      ) OR
    (ftsByteStr_egg00 in file_id.fileType_gg00)
THEN
    BEGIN
    b17state_fdir(file_id.fileName_gg00, fi,
          ftsShared_egg00 in file_id.fileType_gg00, t);
    IF  t.trError_gg00 = e_ok
    THEN
        b17del_fdir (file_id.fileName_gg00,
              ftsShared_egg00 in file_id.fileType_gg00, t);
    (*ENDIF*) 
    END
ELSE
    bd998DelDirectFDirEntry (t, file_id.fileTabId_gg00, fi);
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok) AND (fi.fi_root <> NIL_PAGE_NO_GG00)
THEN
    BEGIN
    b30fdir_to_treeid (fi, file_id);
    trace_root := file_id.fileRoot_gg00;
    IF  (g04inv_tfn (file_id.fileTfn_gg00)) (* PTS 1126494 2003-12-16 *)
        OR
        ((file_id.fileTfn_gg00 = tfnAux_egg00) AND g04inv_tfn (file_id.fileOldTfn_gg00))
    THEN
        bd03ReleaseInvTree (t, file_id)
    ELSE
        IF  ftsByteStr_egg00 IN fi.fi_type
        THEN
            bd05DropLob (t, file_id, parentFileNo)
        ELSE
            BEGIN
&           ifdef TRACE
            t01int4 (bi, 'scol count  ', fi.fi_col_cnt);
&           endif
            file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 + [bd_release_acc];
            bd30GetTree (t, file_id, current, m_drop,
                  LOCK_TREE_EXCL_BD00, NOT SYNC_TREE_LOCK_BD00);
            IF  t.trError_gg00 = e_ok
            THEN
                bd30DropTree (current, fi.fi_col_cnt, NOT c_only_empty);
            (*ENDIF*) 
            bd30ReleaseTree (current);
            file_id.fileBdUse_gg00 := file_id.fileBdUse_gg00 - [bd_release_acc];
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  t.trError_gg00 = e_bad_datapage
    THEN
        t.trError_gg00 := e_ok;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        file_id.fileRoot_gg00 := NIL_PAGE_NO_GG00;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
