/* @lastChanged: "1998-02-18 12:00"
 
 * @filename:   vta320
 * @purpose:    "TA_driver_procedures"
 * @release:    7.1.0.0
 * @see:        "-.-"
 *
 * @Copyright (c) 1998-2005 SAP AG"
 */
 
.tt 1 $SAP$LiveCache$VTA320$
.tt 3 $$TA_driver_procedures$$2000-11-24$
 
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1998-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
***********************************************************
 
Module  : TA_driver_procedures
 
Define  :
 
        PROCEDURE
              t320sequential_program (
                    VAR upg           : tta_user_proc_globals;
                    VAR ut_term       : tut_terminal;
                    is_util_cmd       : boolean;
                    VAR util_cmd_line : tsp00_Line);
 
        PROCEDURE
              t320readterminal (
                    VAR upg       : tta_user_proc_globals;
                    VAR lineinfo  : tsp00_DataLine;
                    VAR last_line : boolean);
 
        PROCEDURE
              t320dbcall (
                    VAR upg        : tta_user_proc_globals;
                    snd_packet     : tsp1_packet_ptr;
                    VAR rcv_packet : tsp1_packet_ptr;
                    VAR returncode : tsp00_Int2;
                    VAR parseid    : tsp00_C12;
                    rescount       : tsp00_Int2);
 
        PROCEDURE
              t320drop_parseid (
                    VAR upg     : tta_user_proc_globals;
                    snd_packet  : tsp1_packet_ptr;
                    VAR parseid : tsp00_C12);
 
        PROCEDURE
              t320errmsg (
                    VAR upg      : tta_user_proc_globals;
                    VAR ret_segm : tsp1_segment);
 
        PROCEDURE
              t320string_to_line (
                    comment         : tsp00_C40;
                    VAR commentline : tsp00_Line);
 
        PROCEDURE
              t320finish_part (
                    VAR upg    : tta_user_proc_globals;
                    packet_ptr : tsp1_packet_ptr;
                    VAR part   : tsp1_part);
 
        PROCEDURE
              t320unicode2ascii (
                    VAR upg     : tta_user_proc_globals;
                    buf_size    : tsp00_Int4;
                    buf_ptr     : tsp00_MoveObjPtr;
                    VAR buf_len : tsp00_Int4);
 
        PROCEDURE
              t320buildbuffer (
                    VAR line1    : tsp00_DataLine;
                    VAR cmd_segm : tsp1_segment);
 
        PROCEDURE
              t320resultcount_part (
                    VAR upg    : tta_user_proc_globals;
                    snd_packet : tsp1_packet_ptr;
                    VAR snd_segm : tsp1_segment;
                    result       : tsp00_Int2);
 
        PROCEDURE
              t320getcommand (
                    VAR in_line : tsp00_DataLine;
                    VAR vstring : tsp00_Sname);
 
        PROCEDURE
              t320GetVal (
                    VAR upg       : tta_user_proc_globals;
                    snd_packet    : tsp1_packet_ptr;
                    VAR long_desc : tsp00_LongDescriptor;
                    VAR pData     : tsp1_part_ptr);
 
        PROCEDURE
              t320display_enter_command (
                    VAR upg    : tta_user_proc_globals;
                    returncode : tsp00_Int2);
 
        PROCEDURE
              t320prot (
                    VAR upg : tta_user_proc_globals;
                    len : integer);
              (* PTS 1106167 E.Z. *)
 
        PROCEDURE
              t320parseid_part (
                    VAR upg      : tta_user_proc_globals;
                    snd_packet   : tsp1_packet_ptr;
                    VAR snd_segm : tsp1_segment;
                    VAR parsid   : tsp00_C12);
 
        PROCEDURE
              t320dbs_send (
                    VAR upg        : tta_user_proc_globals;
                    snd_packet     : tsp1_packet_ptr;
                    VAR rcv_packet : tsp1_packet_ptr;
                    VAR returncode : tsp00_Int2);
 
        PROCEDURE
              t320_to_upper (
                    VAR line : tsp00_Line;
                    length : integer);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              RTE_driver : VEN102;
 
        PROCEDURE
              sqlaconnect (
                    uid             : tsp00_TaskId;
                    VAR servernode  : tsp00_NodeId;
                    VAR serverdb    : tsp00_DbName;
                    service         : tsp00_Service;
                    packet_cnt      : tsp00_Int4;
                    VAR reference   : tsp00_Int4;
                    VAR packet_size : tsp00_Int4;
                    VAR packet_list : tsp1_packet_list;
                    VAR errtext     : tsp00_ErrText;
                    VAR returncode  : tsp1_comm_error);
 
        PROCEDURE
              sqlallocat (
                    length : tsp00_Int4;
                    VAR p  : tsp00_MoveObjPtr;
                    VAR ok : boolean);
 
        PROCEDURE
              sqlarelease (reference : tsp00_Int4);
 
        PROCEDURE
              sqlarequest (
                    reference        : tsp00_Int4;
                    sql_packet       : tsp1_packet_ptr;
                    length           : tsp00_Int4;
                    VAR errtext      : tsp00_ErrText;
                    VAR returncode   : tsp1_comm_error);
 
        PROCEDURE
              sqlareceive (
                    reference          : tsp00_Int4;
                    VAR res_packet     : tsp1_packet_ptr;
                    VAR res_packet_len : tsp00_Int4;
                    VAR errtext        : tsp00_ErrText;
                    VAR returncode     : tsp1_comm_error);
 
        PROCEDURE
              sqldattime (
                    VAR d       : tsp00_Date;
                    VAR t       : tsp00_Time);
 
        PROCEDURE
              sqlfree (
                    p : tsp00_MoveObjPtr);
 
        PROCEDURE
              sqlgetenv
                    (VAR envname   : tsp00_VFilename;
                    VAR envvalue   : tsp00_VFilename;
                    VAR envfound   : boolean);
 
        PROCEDURE
              sqlsleep (duration : tsp00_Int2);
 
        PROCEDURE
              sqlexec (
                    VAR command       : tsp00_ExecLine;
                    mode              : tsp00_ExecMode;
                    VAR error         : tsp00_ExecReturn;
                    VAR err_text      : tsp00_ErrText;
                    VAR commandresult : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Encrypting : VSP02;
 
        PROCEDURE
              s02applencrypt (
                    pw_clear     : tsp00_Name;
                    VAR pw_crypt : tsp00_CryptPw);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedOverlappingMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20int4_to_buf (
                    val      : tsp00_Int4;
                    VAR dest : tsp00_MoveObj;
                    di       : tsp00_Int4);
 
        FUNCTION
              s20buf_to_int4 (
                    VAR source    : tsp00_MoveObj;
                    source_pos    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26init_cmd_packet (
                    packet_ptr               : tsp1_packet_ptr;
                    VAR first_segm_ptr       : tsp1_segment_ptr);
 
        PROCEDURE
              s26first_segment_init (
                    packet_ptr                  : tsp1_packet_ptr;
                    segm_kind                   : tsp1_segment_kind;
                    VAR first_segm_ptr          : tsp1_segment_ptr);
 
        PROCEDURE
              s26new_segment_init (
                    packet_ptr                : tsp1_packet_ptr;
                    segm_kind                 : tsp1_segment_kind;
                    VAR new_segm_ptr          : tsp1_segment_ptr;
                    VAR first_part_ptr        : tsp1_part_ptr);
 
        PROCEDURE
              s26new_part_init (
                    packet_ptr             : tsp1_packet_ptr;
                    VAR cmd_segm           : tsp1_segment;
                    VAR new_part_ptr       : tsp1_part_ptr);
 
        PROCEDURE
              s26finish_part (
                    packet_ptr           : tsp1_packet_ptr;
                    VAR finish_part      : tsp1_part);
 
        PROCEDURE
              s26find_part (
                    VAR return_segm : tsp1_segment;
                    part_kind    : tsp1_part_kind;
                    VAR part_ptr : tsp1_part_ptr);
 
        PROCEDURE
              s26nextpart (VAR part_ptr : tsp1_part_ptr);
 
        FUNCTION
              s26partptr (VAR part : tsp1_part) : tsp1_part_ptr;
 
        FUNCTION
              s26segmptr (VAR segm : tsp1_segment) : tsp1_segment_ptr;
 
        PROCEDURE
              s26next_segment (VAR segm_ptr : tsp1_segment_ptr);
 
        FUNCTION
              s26packet_len (packet_ptr : tsp1_packet_ptr) : tsp00_Int4;
 
        FUNCTION
              s26partlen (VAR part : tsp1_part) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30lnr (
                    VAR str : tsp00_VFilename;
                    val : char;
                    start : tsp00_Int4;
                    cnt : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30lnr1 (
                    VAR str : tsp00_MoveObj;
                    val   : char;
                    start : tsp00_Int4;
                    cnt   : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              GET-Conversions : VSP40;
 
        PROCEDURE
              s40g4int (
                    VAR buf  : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    VAR dest : tsp00_Int4;
                    VAR res  : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              PUT-Conversions : VSP41;
 
        PROCEDURE
              s41pbyte (
                    VAR buf     : tsp00_MoveObj;
                    pos         : tsp00_Int4;
                    VAR len     : integer;
                    VAR source  : tsp00_Line;
                    spos        : tsp00_Int4;
                    slen        : integer;
                    VAR invalid : boolean);
 
        PROCEDURE
              s41psint (
                    VAR buf : tsp00_MoveObj;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int2;
                    VAR res : tsp00_NumError);
 
        PROCEDURE
              s41p4int (
                    VAR buf : tsp00_MoveObj;
                    pos     : tsp00_Int4;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              PUTSTRING-Conversions : VSP43;
 
        PROCEDURE
              s43pstr (
                    VAR buf    : tsp00_MoveObj;
                    pos        : tsp00_Int4;
                    len        : integer;
                    frac       : integer;
                    VAR source : tsp00_NumStr;
                    spos       : tsp00_Int4;
                    slen       : integer;
                    VAR res    : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80: VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
        PROCEDURE
              s80uni_error (
                    uni_rc  : tsp8_uni_error;
                    VAR msg : tsp00_C40);
 
      ------------------------------ 
 
        FROM
              Version : VSP100;
 
        PROCEDURE
              sp100_GetSenderIDVersionP  (
                    VAR SenderIDP    : tsp00_C5);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              TA_test_procedures : VTA02;
 
        FUNCTION
              t02buflength_max : tsp00_Int4;
 
        PROCEDURE
              t02c64 (
                    debug   : tut_debug;
                    VAR msg : tsp00_C64);
 
        PROCEDURE
              t02int4 (
                    debug    : tut_debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        FUNCTION
              t02is_minbuf : boolean;
 
        PROCEDURE
              t02name (
                    debug    : tut_debug;
                    nam      : tsp00_Name);
 
        PROCEDURE
              t02sname (
                    debug     : tut_debug;
                    nam       : tsp00_Sname);
 
        PROCEDURE
              t02moveobj (
                    debug        : tut_debug;
                    VAR moveobj  : tsp00_MoveObj;
                    moveobj_size : tsp00_Int4;
                    startpos     : tsp00_Int4;
                    endpos       : tsp00_Int4);
 
        PROCEDURE
              t02str30 (
                    debug     : tut_debug;
                    str30     : tsp00_C30);
 
        FUNCTION
              t02trace (debug : tut_debug) : boolean;
 
        PROCEDURE
              t02vffn (
                    debug : tut_debug;
                    nam : tsp00_Sname;
                    fn  : tsp00_VFilename);
&       endif
 
      ------------------------------ 
 
        FROM
              TA_terminal_IO : VTA09;
 
        PROCEDURE
              t09clear_screen_string
                    (VAR term : tut_terminal);
 
        PROCEDURE
              t09frame (VAR term : tut_terminal; on : boolean);
 
        PROCEDURE
              t09get (
                    VAR term   : tut_terminal;
                    VAR text   : tsp00_Line;
                    VAR pfkey  : tut_pfkey);
 
        PROCEDURE
              t09get1name (
                    VAR term    : tut_terminal;
                    msg         : tsp00_C20;
                    msg_attr    : char;
                    in_attr     : char;
                    in_len      : integer;
                    upper_case  : boolean;
                    VAR in_name : tsp00_Name;
                    VAR pfkey   : tut_pfkey);
 
        PROCEDURE
              t09header (
                    VAR t09   : tut_terminal;
                    left_msg  : tsp00_C20;
                    right_msg : tsp00_C20);
 
        PROCEDURE
              t09holding (
                    VAR term       : tut_terminal;
                    VAR pf_key     : tut_pfkey);
 
        PROCEDURE
              t09msgheader (
                    VAR t09 : tut_terminal;
                    msg     : tsp00_C30;
                    is_perm : boolean);
 
        PROCEDURE
              t09newscreen_page (VAR term : tut_terminal);
 
        PROCEDURE
              t09pfkeys (VAR term : tut_terminal; on : boolean);
 
        PROCEDURE
              t09put (
                    VAR term   : tut_terminal;
                    VAR text   : tsp00_Line;
                    text_attr  : char);
 
        PROCEDURE
              t09put20 (
                    VAR term     : tut_terminal;
                    text         : tsp00_C20;
                    text_attr    : char);
 
        PROCEDURE
              t09putmsg (
                    VAR t09           : tut_terminal;
                    VAR msg           : tsp00_Line;
                    is_warning        : boolean;
                    immediate_display : boolean);
 
        PROCEDURE
              t09readscreen_string (
                    VAR term  : tut_terminal;
                    VAR pfkey : tut_pfkey);
 
        FUNCTION
              t09retcode (VAR term : tut_terminal) : integer;
 
        PROCEDURE
              t09returncode_set (
                    VAR term : tut_terminal;
                    retcode : integer);
 
        PROCEDURE
              t09string_get_screen (
                    VAR term      : tut_terminal;
                    VAR text      : tsp00_Line;
                    VAR last_line : boolean);
 
      ------------------------------ 
 
        FROM
              TA_write_protfile : vta12;
 
        PROCEDURE
              t12write_prot (
                    VAR fileref    : tut_vf_fileref;
                    VAR ln         : tsp00_Line;
                    length         : integer;
                    VAR error      : integer);
 
      ------------------------------ 
 
        FROM
              TA_file_read : vta13;
 
        PROCEDURE
              t13close_file (VAR t09 : tut_terminal);
 
      ------------------------------ 
 
        FROM
              TA_driver_procedures : VTA321;
 
        PROCEDURE
              t321_GetError (
                    VAR upg : tta_user_proc_globals;
                    pError : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              TA_retrieval_output : VTA340;
 
        PROCEDURE
              t340gethandler (
                    VAR upg      : tta_user_proc_globals;
                    snd_packet   : tsp1_packet_ptr;
                    VAR ret_segm : tsp1_segment);
 
        PROCEDURE
              t340get1handler (
                    VAR upg      : tta_user_proc_globals;
                    VAR ret_segm : tsp1_segment);
 
        PROCEDURE
              t340fetchhandler (
                    VAR upg      : tta_user_proc_globals;
                    VAR ret_segm : tsp1_segment;
                    VAR org_segm : tsp1_segment;
                    sql_packet   : tsp1_packet_ptr;
                    VAR parseid  : tsp00_C12);
 
        PROCEDURE
              t340mfetchhandler (
                    VAR upg      : tta_user_proc_globals;
                    VAR ret_segm : tsp1_segment);
 
        PROCEDURE
              t340printresultcount (
                    VAR upg      : tta_user_proc_globals;
                    VAR ret_segm : tsp1_segment);
 
        PROCEDURE
              t340showresults (
                    VAR upg      : tta_user_proc_globals;
                    VAR ret_segm : tsp1_segment;
                    snd_packet   : tsp1_packet_ptr;
                    VAR parseid  : tsp00_C12);
 
        FUNCTION
              t340segmptr (VAR segm : tsp00_Buf8K) : tsp1_segment_ptr;
 
      ------------------------------ 
 
        FROM
              TA_driver_testroutines : VTA370;
 
        PROCEDURE
              t370tests (
                    VAR upg        : tta_user_proc_globals;
                    VAR first      : tsp00_Sname;
                    VAR second     : tsp00_Sname;
                    command        : tsp1_packet_ptr;
                    VAR rcv_packet : tsp1_packet_ptr;
                    VAR returncode : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17int4to_line (
                    int       : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_Line);
 
        PROCEDURE
              g17sname_to_line (
                    n             : tsp00_Sname;
                    VAR ln_len    : integer;
                    VAR ln        : tsp00_Line);
 
        PROCEDURE
              g17sp1partkind_to_line (
                    part_kind  : tsp1_part_kind;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17paraminfo_to_line (
                    VAR pi     : tsp1_param_info;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17varparaminfo_to_line (
                    VAR pi     : tsp1_param_info;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              UT_auxiliary_procedures : VUT05;
 
        PROCEDURE
              u05getserverdb (
                    snd_packet     : tsp1_packet_ptr;
                    VAR serverdb   : tsp00_DbName;
                    VAR servernode : tsp00_NodeId);
 
        PROCEDURE
              u05request_errmsg (
                    VAR term     : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    VAR errtext  : tsp00_ErrText;
                    retcode      : tsp1_comm_error);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              XT_auxiliary_procedures : VXT05;
 
        PROCEDURE
              x05packet (
                    VAR term      : tut_terminal;
                    VAR protfile  : tut_vf_fileref;
                    is_minbuf     : boolean;
                    maxbuflength  : tsp00_Int4;
                    nam           : tsp00_Sname;
                    packet_ptr    : tsp1_packet_ptr);
&       endif
 
      ------------------------------ 
 
        FROM
              TA_dbmcli_sequential : VTA33;
 
        PROCEDURE
              t33sub_sequential_program (
                    VAR upg         : tta_user_proc_globals;
                    VAR session_ptr : tsp00_MoveObjPtr );
 
      ------------------------------ 
 
        FROM
              database_manager_api : VCN14;
 
        FUNCTION
              cn14connectDBMUsr_fixedSizeParameters(
                    servernode      : tsp00_NodeId;
                    dbname          : tsp00_DbName;
                    dbroot          : tsp00_VFilename;
                    user            : tsp00_C64;
                    VAR sessionOut  : tsp00_MoveObjPtr;
                    VAR errtext     : tsp00_ErrText) : tsp00_Int4;
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              sqlallocat;
 
              tsp00_ObjAddr tsp00_MoveObjPtr
 
        PROCEDURE
              sqlfree;
 
              tsp00_BufAddr  tsp00_MoveObjPtr
 
        FUNCTION
              t340segmptr;
 
              tsp1_segment tsp00_Buf8K
 
        PROCEDURE
              s30lnr;
 
              tsp00_MoveObj tsp00_VFilename
 
        PROCEDURE
              s41pbyte;
 
              tsp00_MoveObj tsp00_Line
 
        PROCEDURE
              s43pstr;
 
              tsp00_MoveObj tsp00_NumStr
 
        PROCEDURE
              t09put;
 
              tsp00_C80 tsp00_Line
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  :
.sp
.cp 3
Created : 1988-10-27
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-11-24
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.sp 4
Schnittstelle_zum_Terminalbenutzer
.br
----------------------------------
.sp
VTA31 stellt dem Benutzer ein Dialogsystem zur Verf?ugung:
 - COMMAND-INTERFACE
.sp;.cp 4
Die Kommandos werden nach einer Eingabeaufforderung als
Kommandostring, der sich ?uber mehrere Zeilen erstrecken kann, mit einem
Abschlu?zzeichen ('!') eingegeben.
.br;Durch Eingabe von VDNEXIT! kann der Dialog abgebrochen werden.
.sp;.cp 18
COMMAND-INTERFACE
.br
-----------------
.sp
1. Testkommandos
.br;.pb '@'
----------------
.sp;.of 25
VDNEXIT^! Dialogende
.sp;.of 25
UTILITY^! Aufruf des Utility-Drivers
.sp;.of 25
DATA^! Eingabe mit Com-Buffer:
.in +25
Die Daten werden angefordert und m?ussen in einer der folgenden Formen
angegeben werden :
   C n 'x'
   N n x
   N n,m x
.br
Dabei gibt der erste Buchstabe an, ob das Datum zu einem
Character- oder einem Numberfeld geh?ort.
.br
Das n steht f?ur einen Integerwert, der die Gesamtl?ange des Feldes,
m f?ur einen Integerwert, der die Anzahl von Nachkommastellen
angibt.
.br
Das x steht f?ur den einzugebenden Characterstring bzw f?ur die Zahl.
.br
Mehrere dieser Folgen k?onnen in einer Zeile stehen.
.br
Die Eingabe von Daten wird durch eine Leerzeile beendet.
.in;.sp;.of 25
NODATA^! Eingabe ohne Com-Buffer (Default nach Restart)
.sp;.of 25
PARSING^! nur Parsen der Kommandos
.sp;.of 25
EXECUTING^! nur Kommandoausf?uhrung ohne Parsen
.sp;.of 25
PARS_EXECUTE^! normale Kommando Abarbeitung (Default nach Restart)
.sp;.of 25
PARS_THEN_EX^! Abarbeitung eines Kommandos in zwei getrennten
Schritten (1. Parsen, 2. Execution).
Funktioniert nicht bei LIST-Kommandos!
.sp;.of 25
ERRORMSG^LONG^! Bei Fehlermeldungen zus?atzliche Ausgabe des
Kommandoteils, in dem der Fehler entdeckt wurde.
.sp;.of 25
ERRORMSG^! Normale Fehlerausgabe (Default nach Restart)
.sp;.of 25
TERMINAL^ASCII^! Die Auftragsschnittstelle wird mit ASCII-Code
betrieben.
.sp;.of 25
PROT^COMMON^! Die wichtigsten Protokollinformationen des Prozesses
werden zusaetzlich ins Driverprotokoll MULI PROT A eingetragen
(Nur bei Multiuser-Driver).
.sp;.of 25
PROT^SINGLE^! (Default) Eintrag nur im privaten Protokoll des
Driver-Prozesses.
.sp;.of 25
SWITCH^! Setzen des Trace- und Testoutputs im Driver und im Kern
.sp;.of 25
TSWITCH^! Setzen des Trace- und Testoutputs nur im Driver
.sp;.of 25
SWITCHLIMIT^! Setzen des begrenzten Trace- und Testoutputs im Driver und
im Kern
.sp;.of 25
TSWITCHLIMIT^! Setzen des begrenzten Trace- und Testoutputs nur im Driver
.sp;.of 25
MINBUF^! Komprimierter TD_BUF-Output im Driver und im Kern
(Default nach Restart nur im Kern)
.sp;.of 25
TMINBUF^! Komprimierter TD_BUF-Output nur im Driver
.sp;.of 25
MAXBUF^! Normaler TD_BUF-Output im Driver und Kern
.sp;.of 25
TMAXBUF^! Normaler TD_BUF-Output nur im Driver (Default nach Restart)
.sp;.of 25
BUFLIMIT^! Begrenzung des TD_BUF-Outputs im Driver und Kern (Default
nach Restart: maxbufferlength)
.sp;.of 25
TBUFLIMIT^! Begrenzung des TD_BUF-Outputs nur im Driver (Default
nach Restart: maxbufferlength)
.sp;.of 25
TIME^! Anschalten der Zeitmessung und -ausgabe
.sp;.of 25
NOTIME^! Abschalten der Zeitmessung und -ausgabe
.sp;.of 25
SUM^! Beginn der Aufsummierung der gemessenen Zeiten (nur sinnvoll
nach Angabe von TIME^!
.sp;.of 25
ENDSUM^! Beendigung der Aufsummierung und Ausgabe der Zeit.
Zeitausgabe erfolgt in Millisekunden der virtuellen CPU-Zeit(virt:).
In einigen F?allen wird auch die reale CPU-Zeit (total:)
angegeben.
.sp;.of 25
CMS^<cms command>@! Ausf?uhrung eines CMS-Commands
.sp;.of 25
UNIX^<unix command>@! Ausf?uhrung eines UNIX-Commands
.sp 2;.cp 18
2. Spezielle Kommandos des Command-Interfaces
.br
---------------------------------------------
.sp;.of 17
FILE^filename^! Kommandos werden aus der angegebenen Datei
filename.VDNMAC.* gelesen
.in;.sp;.of 17
VDNEXIT^! Dialogende
.sp 2;.cp 17
3. VDN-Kommandos
.br
----------------
.sp
Alle ?ubrigen Kommandos werden als VDN-Kommandos interpretiert.
.sp 2;.cp 6;.oc _/1
4. Starten des Sytems
.sp
Bei jedem Systemlauf wird das Protokoll VDN.PROT.A erzeugt, da?z
defaultm?a?zig alle Kommandos und Ausgaben enth?alt.
Durch SWITCH bzw. SWITCHLIMIT kann die Protokollumfang
erweitert oder vermindert werden.
.sp 2;.cp 9
Eingabem?oglichkeiten beim Starten des Systems:
.sp;.of 3
a) Dr?ucken der Entertaste
.br;.in 3;Das virtuelle Terminal wird gestartet und in die erste
Zeile des Protokolls wird "PROTOKOLL" eingetragen.
.in;.sp;.cp 3;.of 3
b) Eingabe der Protokoll-?Uberschrift
.br;.in 3;Das virtuelle Terminal wird gestartet, und die erste
Zeile des Protokolls erh?alt die Uberschrift.
.in;.sp;.cp 5;.of 3
c) Eingabe 'TEST fn' (ohne Ausrufezeichen)
.br;.in 3;Das virtuelle Terminal wird zur Ausgabe ohne Holding
gestartet. Die Eingaben werden der Datei fn.VDNTEST.* entnommen.
In der ersten Zeile des Protokolls steht der Dateiname fn.
.in;.sp;.cp 5;.of 3
d) Eingabe 'DEBUG'
.br;.in 3;Start des Systems zum Debuggen, wenn zwischen dem
VDN-IO Debugger-IO erfolgt. D.H.
anstelle des virtuellen Terminals wird
PASCAL-IO benutzt (kein Seitenaufbau). IN der ersten Zeile des Protokolls
steht "DEBUG". Alle Ein-/Ausgaben k?onnen auch im Consol-Protokoll
erscheinen.
.sp;.cp 5;.of 3
e) Eingabe 'DEBUG fn'
.br;.in 3;Start des Systems, damit ein Consol-Protokoll (z.B. von den
Nachtl?aufen) erstellt werden kann. Das Anschalten des Consol-Proto-
kolls mu?z schon vorher von Hand oder durch ein Exec geschehen sein.
 
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.oc _/1
1_?Uberblick
.sp 1
Einzelne Eingabezeilen werden zu einem commandbuffer zusammengesetzt.
Dies geschieht solange, bis das Zeichen f?ur Kommandoende
als letztes Zeichen einer Zeile erkannt wird oder der Benutzer den
Dialog abbricht.
Der/die erste(n) String(s) der Eingabe wird/werden mit der Liste
der oben aufgef?uhrten Test- bzw. speziellen Kommandos verglichen
und entsprechend bearbeitet bzw. als VDN-Kommando weitergereicht.
.sp 2
.oc _/1;2_Prozeduren
.sp
T31STRING_TO_LINE
.sp
Eine 50 Character lange Kommentarzeile wird in eine Line eingetragen.
.sp 2
T31_NOTOK
.sp
Eine Meldung wird ausgegeben, da?z das Schicken eines Befehls oder das
Empfangen eines Ergebnisses nicht funktioniert hat.
.sp 2
T31ERRMSG
.sp
Mit Hilfe von get_errmsg wird der zu der erhaltenen Fehlernummer
geh?orende Text ermittelt und ausgegeben.
.sp 2
GET_ERRORMSG
.sp
Aus einem File wird der zu der angegebenen Fehlernummer geh?orende Text
gesucht.
.sp 2
T31_RET_ERRORS
.sp
Es wird die Fehlernummer und der dazu geh?orende Text ausgegeben.
.sp 2
DISPLAY_ENTER_COMMAND
.sp
Ein neues Kommando wird angefordert.
.sp 2
GETCOMMAND
.sp
Der erste bzw. zweite String des Kommandos wird in den Parameter
vstring ?ubertragen.
.sp 2
BUILDBUFFER
.sp
Die ?ubergebene Zeile mit einem Teil des Kommandos wird an den schon
zusammengesetzten Teil angef?ugt, wobei ?uberz?ahlige Leerzeichen
entfernt und Teilstrings zusammengesetzt werden.
.sp 2
READINPUT
.sp
Das gesamte Kommando wird gelesen und mit Hilfe von buildbuffer
zusammengesetzt. Die ersten zwei Strings des Kommandos werden f?ur
die Unterscheidung, ob ein Test-, Utility- oder ein normales
VDN-Kommando vorliegt, bestimmt.
.sp 2
T31SEQUENTIAL_PROGRAM
.sp
Nach einigen Initialisierungen wird in einer Schleife, die bei
'VDNEXIT !' endet, ein Kommando angefordert, mit Hilfe von
readinput gelesen, gem?a?z der zwei angelieferten Strings entschieden,
um welchen Typ von Kommando es sich handelt und eine entsprechende
Prozedur aufgerufen.
.sp 2
COMMAND_INTERFACE
.sp
.br
Liegt ein Logon-Befehl vor, wird das Passwort gelesen.
.br
Mit Hilfe der Prozedur t320dbcall wird die Ausf?uhrung des Befehls
veranla?zt.
.br
Wurde ein Fehler gemeldet, wird dieser ausgegeben.
.br
Ansonsten wird je nach Befehl eine Prozedur aufgerufen, die eine
?ubersichtliche Ausgabe der Ergebnisse erzeugt.
.br
Bei einem Logon- bzw. Logoff-Befehl wird der Header der Terminal-
ausgabe ver?andert.
.sp 2
READ_PASSWORD
.sp
Bei Logon_Befehlen wird das zu dem betreffenden Benutzer geh?orende
Passwort eingelesen.
.sp 2
READ_FORMAT
.sp
Es wird eingelesen, von welchem Feldtyp (Number, Character) welcher
L?ange das folgende Datum ist.
.sp 2
READ_INT
.sp
Es wird eine ggf. negative, ganze Zahl gelesen.
.sp 2
SKIPBL
.sp
Blank-Zeichen werden ?ubersprungen.
.sp 2
DAT_CASE
.sp
Ein Datum wird gem?a?z der vorangestellten Formatangabe gelesen und
in den Datenpuffer eingetragen.
.sp 2
GET_DATA_INPUT
.sp
Aus allen Folgezeilen bis zu einer Leerzeile werden die Daten mit
Hilfe von dat_case gelesen und in den Datenpuffer ?ubertragen.
.sp 2
DBS_SEND
.sp
Der VDN-Auftrag wird mit seinen Daten an das VDN-System gesandt
und das Ergebnis empfangen. Gegebenenfalls wird mit t32notok bzw.
t320errmsg eine Fehlermeldung ausgegeben.
.sp 2
ONLY_PARSING_CMD
.sp
Nach einer ?Uberpr?ufung, ob ein weiterer Parseidentifier Platz in
der zugeh?origen Liste findet, wird der Auftrag an das VDN-System
gesandt und der Identifier in die Liste eingef?ugt.
.sp 2
CMD_PARSE_THEN_EXECUTE
.sp
Der eventuell vorhandene Datenteil wird zwischengespeichert, der
Parse-Befehl und dann der Execute-Befehl mit den Daten ausgef?uhrt.
.sp 2
T31DBCALL
.sp
Es wird gegebenenfalls die Eingabe von Daten verlangt und dann, je
nachdem, ob nur geparst oder ausgef?uhrt oder beides gemacht
werden soll dbs_send, only_parsing_cmd oder cmd_pars_then_execute
aufgerufen.
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_maxonebytelength= 250;
      buffer_overflow   = 210;
      c_with_zero       = true;
      comment_symbol    = '*';
      comment1_symbol   = '/';
      parameter_symbol  = ':';
      enter_cmd_msg     = 'Enter command:                          ';
      enter_data_msg    = 'Enter data:         ';
      enter_pw_msg      = 'Enter password:     ';
      error_prefix      = '***ERROR    ';
      sqlstate_prefix   = '*SQLSTATE   ';
      in_idno_pars_msg  = 'Parsing idnr :                          ';
      out_idno_pars_msg = 'parsing idnr :                          ';
      resname_msg       = 'Result name  :                          ';
      tablename_msg     = 'tablename    :                          ';
      msg_execute       = '           execute            ';
      msg_not_connected = 'USER: not connected ';
      msg_wrong_format  = 'wrong data format,nothing sent to SQL-DB';
      msg_wrong_cnt     = 'wrong number for array command          ';
      msg30_enter_cmd   = '         enter command        ';
      msg30_leave1      = 'If you want to leave CI, restr';
      msg30_leave2      = 'ike the EXIT or END key       ';
      n_adbs            = 'ADBS        ';
      n_alter           = 'ALTER       ';
      n_analyze         = 'ANALYZE     ';
      n_ascii           = 'ASCII       ';
      n_autocommit      = 'AUTOCOMMIT  ';
      n_bigcmd          = 'BIGCMD      ';
      n_break           = 'BREAK       ';
      n_catalog         = 'CATALOG     ';
      n_check           = 'CHECK       ';
      n_cms             = 'CMS         ';
      n_column          = 'COLUMN      ';
      n_commit          = 'COMMIT      ';
      n_count           = 'COUNT       ';
      n_create          = 'CREATE      ';
      n_dbmcli          = 'DBMCLI      ';
      n_dbprocedure     = 'DBPROCEDURE ';
      n_debug           = 'DEBUG       ';
      n_delete          = 'DELETE      ';
      n_drop            = 'DROP        ';
      n_errormsg        = 'ERRORMSG    ';
      n_fileinfo        = 'FILEINFO    ';
      n_exit            = 'VDNEXIT     ';
      n_fetch           = 'FETCH       ';
      n_fetch1          = 'FETCH1      ';
      n_fetchall        = 'FETCHALL    '; (* = FETCH, wenn alles mit *)
      (*                                 MFETCH getestet werden soll *)
      n_force           = 'FORCE       ';
      n_fread           = 'FREAD       ';
      n_fwrite          = 'FWRITE      ';
      n_identi          = 'IDENTIFIED  ';
      n_index           = 'INDEX       ';
      n_insert          = 'INSERT      ';
      n_installation    = 'INSTALLATION';
      n_internal        = 'INTERNAL    ';
      n_lineinfo        = 'LINEINFO    ';
      n_long            = 'LONG        ';
      n_longdemand      = 'LONGDEMAND  ';
      n_kernel          = 'KERNEL      ';
      n_mdeclare        = 'MDECLARE    ';
      n_mdelete         = 'MDELETE     ';
      n_mfetch          = 'MFETCH      ';
      n_minsert         = 'MINSERT     ';
      n_mlock           = 'MLOCK       ';
      n_moduleinfo      = 'MODULEINFO  ';
      n_mselect         = 'MSELECT     ';
      n_mupdate         = 'MUPDATE     ';
      n_none            = 'NONE        ';
      n_off             = 'OFF         ';
      n_on              = 'ON          ';
      n_open            = 'OPEN        ';
      n_parse           = 'PARSE       ';
      n_password        = 'PASSWORD    ';
      n_pdescribe       = 'PDESCRIBE   ';
      n_producer        = 'PRODUCER    ';
      n_prot            = 'PROT        ';
      n_references      = 'REFERENCES  ';
      n_release         = 'RELEASE     ';
      n_rename          = 'RENAME      ';
      n_rest            = 'REST        ';
      n_restore         = 'RESTORE     ';
      n_rfetch          = 'RFETCH      ';
      n_rollback        = 'ROLLBACK    ';
      n_save            = 'SAVE        ';
      n_scrollfeature   = 'SCROLLFEAT  ';
      n_selfetch        = 'SELFETCH    ';
      n_senderid        = 'SENDERID    ';
      n_set             = 'SET         ';
      n_sleep           = 'SLEEP       ';
      n_store           = 'STORE       ';
      n_synonym         = 'SYNONYM     ';
      n_table           = 'TABLE       ';
      n_term            = 'TERMINAL    ';
      n_unicode         = 'UNICODE     ';
      n_unique          = 'UNIQUE      ';
      n_unix            = 'UNIX        ';
      n_update          = 'UPDATE      ';
      n_usage           = 'USAGE       ';
      n_use             = 'USE         ';
      n_user            = 'USER        ';
      n_useutil         = 'USEUTIL     ';
      n_view            = 'VIEW        ';
      n_vtrace          = 'VTRACE      ';
      n_work            = 'WORK        ';
      nohelp_msg        = 'no help information available           ';
      overflow_cmd_msg  = 'input rejected,maxcommandlength exceeded';
      pars_arr_over     = 'parsing array overflow                  ';
      parsidlength      = 12;
      c_p_info_pos      = 11;
      session_end_msg   = 'SESSION END                             ';
      string_delimiter  = '''';
      double_quote      = '"';
      command_delimiter = '!';
      c_dblang          = 'DBLANG            ';
      c_max_session     = 8;
 
TYPE
 
      ta320_session_entry = RECORD
            reference         : tsp00_Int4;
            is_connected      : boolean;
            is_variab_input   : boolean;
            snd_packet        : tsp1_packet_ptr;
            rcv_packet        : tsp1_packet_ptr;
      END;
 
      ta320_session_arr = ARRAY [1..c_max_session] OF ta320_session_entry;
 
      ta320_session_stack = RECORD
            top  : integer;
            arr  : ta320_session_arr;
      END;
 
 
VAR
      session_stack     : ta320_session_stack;
 
 
(*------------------------------*) 
 
PROCEDURE
      ta320push_session (
            reference       : tsp00_Int4;
            is_connected    : boolean;
            is_variab_input : boolean;
            snd_packet      : tsp1_packet_ptr;
            rcv_packet      : tsp1_packet_ptr;
            VAR ok          : boolean);
 
BEGIN
ok := true;
WITH session_stack DO
    IF  top >= c_max_session
    THEN
        ok := false
    ELSE
        BEGIN
        top := succ(top);
        arr [top].reference       := reference;
        arr [top].is_connected    := is_connected;
        arr [top].is_variab_input := is_variab_input;
        arr [top].snd_packet      := snd_packet;
        arr [top].rcv_packet      := rcv_packet;
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320pop_session (
            VAR reference       : tsp00_Int4;
            VAR is_connected    : boolean;
            VAR is_variab_input : boolean;
            VAR snd_packet      : tsp1_packet_ptr;
            VAR rcv_packet      : tsp1_packet_ptr;
            VAR ok              : boolean);
 
BEGIN
ok := true;
WITH session_stack DO
    IF  top <= 0
    THEN
        ok := false
    ELSE
        BEGIN
        is_connected    := arr [top].is_connected;
        is_variab_input := arr [top].is_variab_input;
        reference       := arr [top].reference;
        snd_packet      := arr [top].snd_packet;
        rcv_packet      := arr [top].rcv_packet;
        top := pred(top);
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320get_senderid (VAR upg : tta_user_proc_globals);
 
CONST
      c_application  = 'XCI';
 
BEGIN
sp100_GetSenderIDVersionP(upg.appl_version);
upg.application  := c_application
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320get_time (VAR realtime : tsp00_Int4);
 
VAR
      d : tsp00_Date;
      t : tsp00_Time;
 
BEGIN
sqldattime (d, t);
realtime:=
      (ord(t[ 3 ]) - ord('0')) * 36000 +
      (ord(t[ 4 ]) - ord('0')) *  3600 +
      (ord(t[ 5 ]) - ord('0')) *   600 +
      (ord(t[ 6 ]) - ord('0')) *    60 +
      (ord(t[ 7 ]) - ord('0')) *    10 +
      (ord(t[ 8 ]) - ord('0'))
END;
 
(*------------------------------*) 
 
PROCEDURE
      t320string_to_line (
            comment              : tsp00_C40;
            VAR commentline      : tsp00_Line);
 
VAR
      i : integer;
 
BEGIN
FOR i := 1 TO 40 DO
    commentline [ i ] := comment [ i ] ;
(*ENDFOR*) 
FOR i := 41 TO LINE_MXSP00 DO
    commentline [ i ] := ' '
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t320errmsg (
            VAR upg      : tta_user_proc_globals;
            VAR ret_segm : tsp1_segment);
 
CONST
      mx_msg_output = 74;
      mx_retcode    =  6;
 
VAR
      put_out        : boolean;
      found          : boolean;
      pos            : integer;
      len            : integer;
      ln_len         : integer;
      old_buf_len    : tsp00_Int4;
      msg            : tsp00_C20;
      ln             : tsp00_Line;
      errortext_part : tsp1_part_ptr;
      new_parsinfo   : tsp00_C30;
 
BEGIN
put_out := true;
ln      := upg.term^.blankline;
ln_len  := 0;
t09returncode_set (upg.term^, ret_segm.sp1r_returncode);
IF  upg.sqlmode = sqlm_ansi
THEN
    BEGIN
    g17sname_to_line (sqlstate_prefix, ln_len, ln);
    IF  ret_segm.sp1r_sqlstate = '00000'
    THEN
        put_out := false
    ELSE
        BEGIN
        SAPDB_PascalForcedMove (sizeof (tsp00_SqlState), sizeof (ln),
              @ret_segm.sp1r_sqlstate, 1, @ln, 11, sizeof (tsp00_SqlState));
        ln_len := 16
        END
    (*ENDIF*) 
    END
ELSE
    BEGIN
    g17sname_to_line (error_prefix, ln_len, ln);
    g17int4to_line (ret_segm.sp1r_returncode,
          NOT c_with_zero, mx_retcode, ln_len+2, ln);
    ln_len := ln_len + 1 + mx_retcode + 1
    END;
(*ENDIF*) 
IF  put_out
THEN
    BEGIN
    IF  ret_segm.sp1r_returncode <> 0
    THEN
        BEGIN
        t340printresultcount (upg, ret_segm);
        s26find_part (ret_segm, sp1pk_errortext, errortext_part);
        IF  errortext_part <> NIL
        THEN
            WITH errortext_part^ DO
                BEGIN
                old_buf_len := sp1p_buf_len;
                IF  upg.term_simulation = tasim_unicode
                THEN (* Convert the errormsg to ascii. *)
                    t320unicode2ascii (upg,
                          sp1p_buf_size, @sp1p_buf, sp1p_buf_len);
                (*ENDIF*) 
                IF  (ret_segm.sp1r_returncode = -5015) AND
                    (s30lnr1 (sp1p_buf, bsp_c1, 1, sp1p_buf_len) > 70)
                THEN      (* The list of missing keywords is *)
                    BEGIN (* too long, so we better cut it.  *)
                    found := false;
                    pos   := 62;
                    WHILE (pos > 0) AND (NOT found) DO
                        IF  (sp1p_buf[ pos ] = ':') OR
                            (sp1p_buf[ pos ] = ',')
                        THEN
                            found := true
                        ELSE
                            pos := pred (pos);
                        (*ENDIF*) 
                    (*ENDWHILE*) 
                    IF  found
                    THEN
                        BEGIN
&                       ifdef trace
                        t02int4 (debug_ta, '...filled at', pos);
&                       endif
                        sp1p_buf[ pos ] := ' ';
                        SAPDB_PascalForcedFill (sp1p_buf_size, @sp1p_buf,
                              pos+1, 3, '.');
                        IF  pos+4 <= sp1p_buf_len
                        THEN
                            SAPDB_PascalForcedFill (sp1p_buf_size, @sp1p_buf,
                                  pos+4, sp1p_buf_len-pos-3, bsp_c1)
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  sp1p_buf_len > mxsp_c20
                THEN
                    SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (msg),
                          @sp1p_buf, 1, @msg, 1, sizeof (msg));
                (*ENDIF*) 
                len := mx_msg_output - ln_len;
                IF  len > errortext_part^.sp1p_buf_len
                THEN
                    len := errortext_part^.sp1p_buf_len;
                (*ENDIF*) 
                SAPDB_PascalForcedMove (errortext_part^.sp1p_buf_size, sizeof (ln),
                      @errortext_part^.sp1p_buf, 1, @ln, ln_len + 1, len);
                sp1p_buf_len := old_buf_len;
                END
            (*ENDWITH*) 
        ELSE
            IF  ret_segm.sp1r_returncode = -9
            THEN
                BEGIN
                new_parsinfo := 'USE NEW PARSINFO              ';
                SAPDB_PascalForcedMove (sizeof (new_parsinfo), sizeof (ln),
                      @new_parsinfo, 1, @ln, ln_len + 1, 16)
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  ret_segm.sp1r_errorpos < 0
        THEN
            g17int4to_line (ret_segm.sp1r_errorpos,
                  c_with_zero, 5, mx_msg_output + 1, ln)
        ELSE
            IF  ret_segm.sp1r_errorpos > 0
            THEN
                IF  (upg.bigcmd_offset > 0) AND
                    (ret_segm.sp1r_errorpos > upg.bigcmd_offset)
                THEN
                    g17int4to_line (
                          ret_segm.sp1r_errorpos - upg.bigcmd_offset,
                          c_with_zero, 4, mx_msg_output + 2, ln)
                ELSE
                    g17int4to_line (ret_segm.sp1r_errorpos,
                          c_with_zero, 4, mx_msg_output + 2, ln);
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    t09putmsg (upg.term^, ln, true, false);
    upg.prot.ln := upg.term^.blankline;
    t320prot (upg, 1);
    upg.prot.ln := ln;
    t320prot (upg, sizeof (upg.prot.ln));
    s26find_part (ret_segm, sp1pk_message_list, errortext_part);
    IF  errortext_part <> NIL
    THEN
        BEGIN
        upg.prot.ln := upg.term^.blankline;
        t320prot (upg, 1);
        t321_GetError (upg, errortext_part);
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320error_pos_display (
            VAR upg      : tta_user_proc_globals;
            VAR cmd_segm : tsp1_segment;
            err_pos      : tsp00_Int4);
 
CONST
      ln_offset = 6;
      ln_prefix = ' ';
 
VAR
      ln_pos     : integer;
      err_ln_pos : integer;
      i          : integer;
      lbuflen    : integer;
      ln         : tsp00_Line;
 
BEGIN
IF  (err_pos > 0) AND (err_pos <= BUF8K_MXSP00 - sizeof (tsp1_segment_header)
    - sizeof(tsp1_part_header))
THEN
    BEGIN
    lbuflen := cmd_segm.sp1p_buf_len;
    IF  (lbuflen > BUF8K_MXSP00)
    THEN
        lbuflen := BUF8K_MXSP00;
    (*ENDIF*) 
    IF  upg.term_simulation = tasim_unicode
    THEN
        t320unicode2ascii (upg, cmd_segm.sp1p_buf_size,
              @cmd_segm.sp1p_buf, lbuflen);
    (*ENDIF*) 
    ln := upg.term^.blankline;
    FOR i := 1 TO ln_offset-1 DO
        ln[ i ] := ln_prefix;
    (*ENDFOR*) 
    ln_pos := ln_offset + 1;
    IF  err_pos > 20
    THEN
        i := 20 + ln_offset
    ELSE
        i := err_pos - 1 + ln_offset;
    (*ENDIF*) 
    WHILE (ln_pos <= i) AND (err_pos+ln_pos-i-1 <= lbuflen) DO
        BEGIN
        ln[ ln_pos ] := cmd_segm.sp1p_buf[ err_pos+ln_pos-i-1 ];
        ln_pos       := succ (ln_pos);
        END;
    (*ENDWHILE*) 
    WHILE ln_pos <= i DO
        BEGIN
        ln[ ln_pos ] := ln_prefix;
        ln_pos       := succ (ln_pos);
        END;
    (*ENDWHILE*) 
    err_ln_pos := ln_pos;
    i          := err_pos;
    WHILE (ln_pos <= 50+ln_offset) AND (i <= lbuflen) DO
        BEGIN
        ln[ ln_pos ] := cmd_segm.sp1p_buf[ i ];
        i            := succ (i);
        ln_pos       := succ (ln_pos)
        END;
    (*ENDWHILE*) 
    t09put (upg.term^, ln, cut_protected);
    upg.prot.ln := ln;
    t320prot (upg, 77);
    ln := upg.term^.blankline;
    ln[ err_ln_pos ] := '$';
    FOR i := 1 TO ln_offset-1 DO
        ln[ i ] := ln_prefix;
    (*ENDFOR*) 
    t09put (upg.term^, ln, cut_bright_protected);
    upg.prot.ln := ln;
    t320prot (upg, 77)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t320display_enter_command (
            VAR upg    : tta_user_proc_globals;
            returncode : tsp00_Int2);
 
BEGIN
IF  returncode = 0
THEN
    t09newscreen_page (upg.term^);
(*ENDIF*) 
t09msgheader (upg.term^, msg30_enter_cmd, true);
upg.prot.ln := upg.term^.blankline;
t320prot (upg, 1);
t320string_to_line (enter_cmd_msg, upg.prot.ln);
t320prot (upg, 15)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t320getstring (
            VAR lineinfo         : tsp00_DataLine;
            VAR stringinfo       : tsp00_String;
            VAR ok               : boolean);
 
VAR
      found         : boolean;
      end_of_string : boolean;
      character     : char;
      currpos       : tsp00_LinePositions;
 
BEGIN
ok    := true;
found := false;
end_of_string     := false;
stringinfo.length := 0;
WITH lineinfo DO
    BEGIN
    IF  pos > 0
    THEN
        IF  pos > length
        THEN
            BEGIN
            ok := false;
&           ifdef TRACE
            t02str30 (debug_always, 'getstring:input already passed');
&           endif
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  ok
THEN
    WITH stringinfo DO
        BEGIN
        currpos := lineinfo.pos;
        REPEAT
            currpos   := succ (currpos);
            character := lineinfo.text  [ currpos ] ;
            IF  NOT (character in [ 'a'..'i', 'j'..'r', 's'..'z',
                'A'..'I', 'J'..'R', 'S'..'Z', '_', '0'..'9',
                comment_symbol, comment1_symbol, parameter_symbol])
            THEN
                end_of_string := found
            ELSE
                BEGIN
                found  := true;
                length := succ (length);
                text [ length ] := character
                END;
            (*ENDIF*) 
            IF  currpos >= lineinfo.length
            THEN
                IF  found
                THEN
                    end_of_string := true
                ELSE
                    ok := false
                (*ENDIF*) 
            (*ENDIF*) 
        UNTIL
            end_of_string OR NOT ok;
        (*ENDREPEAT*) 
        IF  ok
        THEN
            IF  end_of_string
            THEN
                lineinfo.pos := currpos
            ELSE
                lineinfo.pos := pred (currpos)
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t320getcommand (
            VAR in_line : tsp00_DataLine;
            VAR vstring : tsp00_Sname);
 
VAR
      ok : boolean;
      i  : integer;
      s  : tsp00_String;
 
BEGIN
vstring := bsp_sname;
WHILE (in_line.pos < in_line.length) AND
      (in_line.text[ in_line.pos+1 ] = ' ') DO
    in_line.pos := succ (in_line.pos);
(*ENDWHILE*) 
IF  in_line.pos < in_line.length
THEN
    BEGIN
    t320getstring (in_line, s, ok);
    i := 1;
    WHILE ((i <= s.length) AND (i <= SNAME_MXSP00)) DO
        BEGIN
        IF  s.text[ i ] in [ 'a'..'i', 'j'..'r', 's'..'z' ]
        THEN
            vstring[ i ] := chr(ord(s.text[ i ]) - ord('a') + ord('A'))
        ELSE
            vstring[ i ] := s.text[ i ];
        (*ENDIF*) 
        i := succ(i)
        END
    (*ENDWHILE*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t320buildbuffer (
            VAR line1    : tsp00_DataLine;
            VAR cmd_segm : tsp1_segment);
 
VAR
      i : integer;
 
BEGIN
WITH cmd_segm DO
    BEGIN
    i := 1;
    IF  (sp1p_buf_len > 1) AND (line1.text[ 1 ] = string_delimiter)
    THEN
        BEGIN
        IF  sp1p_buf[ sp1p_buf_len-1 ] = string_delimiter
        THEN
            BEGIN
            sp1p_buf_len := sp1p_buf_len-2;
            i            := 2
            END
        (*ENDIF*) 
        END
    ELSE
        WHILE (i <= line1.length) AND (line1.text[ i ] = ' ') DO
            i := succ (i);
        (*ENDWHILE*) 
    (*ENDIF*) 
    WHILE i <= line1.length DO
        BEGIN
        sp1p_buf_len             := succ (sp1p_buf_len);
        sp1p_buf[ sp1p_buf_len ] := line1.text[ i ];
        i                        := succ (i)
        END;
    (*ENDWHILE*) 
    IF  (sp1p_buf_len < sp1p_buf_size) AND (sp1p_buf_len > 0)
    THEN
        BEGIN
        sp1p_buf_len             := succ (sp1p_buf_len);
        sp1p_buf[ sp1p_buf_len ] := bsp_c1
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(* PTS 1121518 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      t320readterminal (
            VAR upg       : tta_user_proc_globals;
            VAR lineinfo  : tsp00_DataLine;
            VAR last_line : boolean);
 
BEGIN
lineinfo.text   := upg.term^.blankline;
lineinfo.pos    := 0;
lineinfo.length := 1;
WITH lineinfo DO
    BEGIN
    t09string_get_screen (upg.term^, text, last_line);
    length := LINE_MXSP00;
    WHILE (length > 1) AND (text[ length ] = ' ') DO
        length := pred (length);
    (*ENDWHILE*) 
    IF  (length = 1) AND (text[ 1 ] = ' ')
    THEN
        length := 0;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t320_to_upper (
            VAR line : tsp00_Line;
            length : integer);
 
VAR
      ap_string : boolean;
      as_string : boolean;
      i         : integer;
 
BEGIN
ap_string       := false;
as_string       := false;
FOR i := 1 TO length DO
    BEGIN
    IF  NOT as_string
    THEN
        IF  line [ i ] = string_delimiter
        THEN
            ap_string := NOT ap_string;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  NOT ap_string
    THEN
        IF  line [ i ] = double_quote
        THEN
            as_string := NOT as_string;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  (line [ i ] in [ 'a'..'i', 'j'..'r', 's'..'z' ])
        AND (NOT ap_string) AND (NOT as_string)
    THEN
        line [ i ] := chr(ord(line [ i ]) + ord('A') - ord('a'))
    (*ENDIF*) 
    END;
(*ENDFOR*) 
END;
 
(* PTS END 1121518 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ta320readinput (
            VAR upg           : tta_user_proc_globals;
            producer          : tsp1_producer;
            VAR third_string  : tsp00_Sname;
            snd_packet        : tsp1_packet_ptr;
            VAR cmd_segm      : tsp1_segment_ptr;
            VAR cmd_part      : tsp1_part_ptr);
 
VAR
      in_line    : tsp00_DataLine;
      h_line     : tsp00_DataLine;
      inend      : boolean;
      line_count : integer;
      pos        : tsp00_Int4;
      ok         : boolean;
      currlng    : tsp00_Int4;
      c40        : tsp00_C40;
 
BEGIN
s26init_cmd_packet (snd_packet, cmd_segm);
upg.curr_segm := cmd_segm;
cmd_segm^.sp1c_producer := producer;
s26new_part_init (snd_packet, cmd_segm^, cmd_part);
cmd_part^.sp1p_part_kind := sp1pk_command;
IF  (upg.bigcmd_offset > 0) AND
    (cmd_part^.sp1p_buf_size > upg.bigcmd_offset) AND
    (upg.longdesccnt = 0)
THEN
    WITH cmd_part^ DO
        BEGIN
        SAPDB_PascalForcedFill (sp1p_buf_size, @sp1p_buf, 1, upg.bigcmd_offset, bsp_c1);
        sp1p_buf_len := upg.bigcmd_offset;
        END;
    (*ENDWITH*) 
(*ENDIF*) 
upg.pfkey := pf_none;
REPEAT
    line_count       := 0;
    ok               := true;
    upg.prepare      := false;
    upg.first_token  := bsp_sname;
    upg.second_token := bsp_sname;
    third_string     := bsp_sname;
    t09readscreen_string (upg.term^, upg.pfkey);
    IF  NOT (upg.pfkey in [ pf_cancel, pf_end, pf_help ])
    THEN
        BEGIN
        t09putmsg (upg.term^, upg.term^.blankline, false, false);
        REPEAT
            line_count := succ (line_count);
            REPEAT
                t320readterminal (upg, in_line, inend);
                upg.prot.ln := in_line.text;
                (* PTS 1121518 E.Z. *)
                t320_to_upper (upg.prot.ln, in_line.length);
                t320prot (upg, in_line.length);
            UNTIL
                (in_line.length > 0) OR inend OR NOT upg.term^.io_ok;
            (*ENDREPEAT*) 
            IF  inend
            THEN
                BEGIN (* eliminate trailing blanks and the endsign(!) *)
                WHILE (in_line.length > 1) AND
                      (in_line.text[ in_line.length ] = ' ') DO
                    in_line.length := pred (in_line.length);
                (*ENDWHILE*) 
                IF  in_line.text[ in_line.length ] = command_delimiter
                THEN
                    in_line.length := pred (in_line.length);
                (*ENDIF*) 
                WHILE (in_line.length > 1) AND
                      (in_line.text[ in_line.length ] = ' ') DO
                    in_line.length := pred (in_line.length)
                (*ENDWHILE*) 
                END;
            (*ENDIF*) 
            IF  in_line.length > 0
            THEN
                BEGIN
                IF  line_count = 1
                THEN
                    BEGIN
                    pos := in_line.pos;
                    t320getcommand (in_line, upg.first_token);
&                   ifdef trace
                    t02sname (debug_ta, 'first_token ');
                    t02sname (debug_ta, upg.first_token);
&                   endif
                    IF  upg.first_token = n_parse
                    THEN
                        BEGIN
                        upg.prepare := true;
                        upg.first_token := '(           ';
                        pos := pos + 5
                        END;
                    (*ENDIF*) 
                    WHILE upg.first_token[ 1 ] = '(' DO
                        BEGIN
                        pos         := succ(pos);
                        in_line.pos := pos;
                        t320getcommand (in_line, upg.first_token);
&                       ifdef trace
                        t02sname (debug_ta, 'first_token ');
                        t02sname (debug_ta, upg.first_token);
&                       endif
                        END;
                    (*ENDWHILE*) 
                    upg.second_token := bsp_sname;
                    third_string     := bsp_sname;
                    t320getcommand (in_line, upg.second_token);
&                   ifdef trace
                    t02sname (debug_ta, 'second_token');
                    t02sname (debug_ta, upg.second_token);
&                   endif
                    IF  (upg.more_segments > 0)      AND
                        (upg.is_connected)           AND
                        (upg.first_token <> n_sleep)
                    THEN
                        BEGIN
                        c40 := 'SELECT ''abc''||''def''INTO :a FROM DUAL    ';
                        SAPDB_PascalForcedMove (sizeof(c40), sizeof(tsp00_Line),
                              @c40, 1, @h_line.text, 1, sizeof(c40));
                        h_line.pos    := 38;
                        h_line.length := 38;
                        t320buildbuffer (h_line, cmd_segm^);
                        t320finish_part (upg, snd_packet, cmd_part^);
                        cmd_segm^.sp1c_with_info := true;
                        s26new_segment_init (snd_packet, sp1sk_cmd, cmd_segm, cmd_part);
                        upg.curr_segm := cmd_segm;
                        cmd_segm^.sp1c_producer := producer;
                        s26new_part_init (snd_packet, cmd_segm^, cmd_part);
                        cmd_part^.sp1p_part_kind := sp1pk_command;
                        END;
&                   ifdef PARS
                    (*ENDIF*) 
                    upg.more_segments := 0;
                    IF  (
                        upg.shared_sql_drop AND
                        (
                        (upg.first_token = cta_n_declare )   OR
                        (upg.first_token = n_mdeclare )      OR
                        (upg.first_token = n_delete )        OR
                        (upg.first_token = n_mdelete )       OR
                        (upg.first_token = n_insert )        OR
                        (upg.first_token = n_minsert )       OR
                        (upg.first_token = cta_n_select  )   OR
                        (upg.first_token = n_mselect  )      OR
                        (upg.first_token = n_update )        OR
                        (upg.first_token = n_mupdate )
                        )
                        )
                        OR
                        (upg.shared_drop_trans AND
                        (upg.first_token = n_rollback))
                    THEN
                        BEGIN
                        c40 := 'DIAGNOSE SHARE PARSE DROP               ';
                        SAPDB_PascalForcedMove (sizeof(c40), sizeof(tsp00_Line),
                              @c40, 1, @h_line.text, 1, sizeof(c40));
                        h_line.pos    := 25;
                        h_line.length := 25;
                        t320buildbuffer (h_line, cmd_segm^);
                        t320finish_part (upg, snd_packet, cmd_part^);
                        cmd_segm^.sp1c_with_info := true;
                        cmd_segm^.sp1c_sqlmode   := sp1sm_internal;
                        s26new_segment_init (snd_packet, sp1sk_cmd, cmd_segm, cmd_part);
                        upg.curr_segm := cmd_segm;
                        cmd_segm^.sp1c_producer := producer;
                        s26new_part_init (snd_packet, cmd_segm^, cmd_part);
                        cmd_part^.sp1p_part_kind := sp1pk_command;
                        IF  (upg.shared_drop_trans AND
                            (upg.first_token = n_rollback))
                        THEN
                            upg.shared_drop_trans := false
                        ELSE
                            upg.shared_sql_drop := false;
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  (upg.first_token = n_commit)
                        THEN
                            upg.shared_drop_trans := false;
&                       endif
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  upg.second_token = bsp_sname
                THEN
                    BEGIN
                    t320getcommand (in_line, upg.second_token);
&                   ifdef trace
                    t02sname (debug_ta, 'second_token');
                    t02sname (debug_ta, upg.second_token);
&                   endif
                    END;
                (*ENDIF*) 
                IF  (third_string = bsp_sname)
                    AND
                    ((upg.first_token  = cta_n_connect) OR
                    ( upg.second_token = n_work       ) OR
                    ( upg.second_token = cta_n_config ) OR
                    ( upg.first_token = n_dbmcli ) OR
                    ((upg.first_token  = n_alter) AND
                    ( upg.second_token = n_password)))
                THEN
                    BEGIN
                    t320getcommand (in_line, third_string);
&                   ifdef trace
                    t02sname (debug_ta, 'third_string');
                    t02sname (debug_ta, third_string);
&                   endif
                    END
                ELSE
                    IF  (third_string = bsp_sname) AND
                        (upg.first_token  = n_create) AND
                        (upg.second_token = n_table)
                    THEN
                        REPEAT
                            t320getcommand (in_line, third_string);
&                           ifdef trace
                            t02sname (debug_ta, 'third_string');
                            t02sname (debug_ta, third_string);
&                           endif
                        UNTIL
                            (third_string = bsp_sname) OR (third_string = n_references);
                        (*ENDREPEAT*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                currlng := cmd_part^.sp1p_buf_size - cmd_part^.sp1p_buf_len;
                IF  (in_line.length > currlng)
                    OR
                    ((in_line.length = currlng) AND NOT inend)
                THEN
                    BEGIN
                    ok := false;
                    t09put (upg.term^, upg.term^.blankline, cut_protected);
                    t320string_to_line (overflow_cmd_msg, upg.prot.ln);
                    t09putmsg (upg.term^, upg.prot.ln, true, false);
                    t09put (upg.term^, upg.prot.ln, cut_protected);
                    t320prot (upg, 50)
                    END
                ELSE
                    IF  (upg.first_token <> cta_n_putval) AND
                        (upg.first_token <> cta_n_getval)
                    THEN
                        t320buildbuffer (in_line, cmd_segm^)
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            (*ENDIF*) 
        UNTIL
            inend OR NOT ok OR NOT upg.term^.io_ok;
        (*ENDREPEAT*) 
        cmd_part^.sp1p_buf_len := pred (cmd_part^.sp1p_buf_len);
        IF  cmd_part^.sp1p_buf_len <= 0
        THEN
            cmd_part^.sp1p_buf_len := 1;
        (*ENDIF*) 
        t09clear_screen_string (upg.term^)
        END;
    (*ENDIF*) 
    IF  upg.pfkey = pf_help
    THEN
        BEGIN
        ok := false;
        t09clear_screen_string (upg.term^);
        upg.pfkey := pf_none;
        t320string_to_line (nohelp_msg, upg.prot.ln);
        t09putmsg (upg.term^, upg.prot.ln, false, false);
        t320prot (upg, 40)
        END;
    (*ENDIF*) 
    IF  NOT ok
    THEN
        BEGIN
        upg.prot.ln := upg.term^.blankline;
        t320prot (upg, 1);
        t320string_to_line (enter_cmd_msg, upg.prot.ln);
        t09put (upg.term^, upg.term^.blankline, cut_protected);
        t09put (upg.term^, upg.prot.ln, cut_protected);
        t320prot (upg, 15)
        END
    (*ENDIF*) 
UNTIL
    (ok OR NOT upg.term^.io_ok);
(*ENDREPEAT*) 
IF  upg.file_info
THEN
    ta320fileinfo_print (upg);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320last_logoff (
            VAR upg        : tta_user_proc_globals;
            snd_packet     : tsp1_packet_ptr;
            VAR rcv_packet : tsp1_packet_ptr;
            VAR returncode : tsp00_Int2);
 
VAR
      last_pfkey   : tut_pfkey;
      last_retcode : integer;
      s24          : tsp00_C24;
      cmd_segm     : tsp1_segment_ptr;
      cmd_part     : tsp1_part_ptr;
 
BEGIN
IF  t09retcode (upg.term^) <> cut_sql_req_failed
THEN
    BEGIN
    last_pfkey   := upg.pfkey;
    last_retcode := t09retcode (upg.term^);
    upg.pfkey    := pf_none;
    IF  last_pfkey = pf_cancel
    THEN
        s24 := 'ROLLBACK RELEASE        '
    ELSE
        s24 := 'COMMIT WORK RELEASE     ';
    (*ENDIF*) 
    s26init_cmd_packet (snd_packet, cmd_segm);
    upg.curr_segm := cmd_segm;
    s26new_part_init (snd_packet, cmd_segm^, cmd_part);
    WITH cmd_part^ DO
        BEGIN
        sp1p_part_kind := sp1pk_command;
        sp1p_buf_len   := 19;
        SAPDB_PascalForcedMove (sizeof (s24), sp1p_buf_size,
              @s24, 1, @sp1p_buf, 1, sp1p_buf_len)
        END;
    (*ENDWITH*) 
    t320finish_part (upg, snd_packet, cmd_part^);
    t320dbs_send (upg,
          snd_packet, rcv_packet, returncode);
    IF  upg.pfkey <> pf_cancel
    THEN
        upg.pfkey := last_pfkey;
    (*ENDIF*) 
    IF  returncode = 0
    THEN
        t09returncode_set (upg.term^, last_retcode)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320set_prot (
            VAR upg : tta_user_proc_globals;
            VAR cmd : tsp00_Sname);
 
BEGIN
IF  cmd = n_off
THEN
    BEGIN
    IF  upg.prot.refer.utvf_handle > 0
    THEN
        BEGIN
        upg.prot.refsafe           := upg.prot.refer;
        upg.prot.refer.utvf_handle := 0;
        END
    (*ENDIF*) 
    END
ELSE
    IF  cmd = n_on
    THEN
        BEGIN
        IF  upg.prot.refsafe.utvf_handle > 0
        THEN
            BEGIN
            upg.prot.refer               := upg.prot.refsafe;
            upg.prot.refsafe.utvf_handle := 0;
            END
        (*ENDIF*) 
        END
    ELSE
        IF  cmd = 'COMMON      '
        THEN
            upg.prot.common := true
        ELSE
            IF  cmd = 'SINGLE      '
            THEN
                upg.prot.common := false
            ELSE
                IF  cmd = 'SESSION     '
                THEN
                    upg.prot.session := true
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320set_cmdoffset (
            VAR upg : tta_user_proc_globals;
            VAR cmd : tsp00_Sname);
 
CONST
      c_maxint_txt = 'MAXINT      ';
 
VAR
      ok       : boolean;
      hint     : integer;
      lineinfo : tsp00_DataLine;
 
BEGIN
upg.bigcmd_offset := 0;
IF  cmd = c_maxint_txt
THEN
    upg.bigcmd_offset := MAX_INT2_SP00
ELSE
    BEGIN
    WITH lineinfo DO
        BEGIN
        text [ 1 ] := bsp_c1;
        SAPDB_PascalForcedMove (sizeof (cmd), sizeof (text), @cmd, 1, @text, 2, sizeof (cmd));
        pos    := 1;
        length := sizeof (cmd) + 1;
        END;
    (*ENDWITH*) 
    ta320getint (upg, lineinfo, hint, ok);
    IF  ok AND (hint > 0)
    THEN
        upg.bigcmd_offset := hint;
    (*ENDIF*) 
    END;
(*ENDIF*) 
&ifdef trace
t02int4 (debug_ta, 'bigcmd offse', upg.bigcmd_offset);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320sleep (
            VAR upg : tta_user_proc_globals;
            VAR cmd : tsp00_Sname);
 
VAR
      ok       : boolean;
      hint     : integer;
      lineinfo : tsp00_DataLine;
 
BEGIN
WITH lineinfo DO
    BEGIN
    text [ 1 ] := bsp_c1;
    SAPDB_PascalForcedMove (sizeof (cmd), sizeof (text), @cmd, 1, @text, 2, sizeof (cmd));
    pos    := 1;
    length := sizeof (cmd) + 1;
    END;
(*ENDWITH*) 
ta320getint (upg, lineinfo, hint, ok);
IF  ok AND (hint > 0)
THEN
    sqlsleep (hint);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320debug (VAR upg : tta_user_proc_globals);
 
CONST
      c_x_cons    = '#x_cons             ';
      c_set_debug = ' DebugBreak set     ';
      c_clr_debug = ' DebugBreak clear   ';
 
VAR
      pos           : integer;
      s20           : tsp00_C20;
      command       : tsp00_ExecLine;
      error         : tsp00_ExecReturn;
      msg           : tsp00_C40;
      commandresult : tsp00_Int2;
 
BEGIN
commandresult := 0;
pos := 1;
SAPDB_PascalForcedFill (sizeof (command), @command, 1, sizeof(command), bsp_c1);
IF  upg.second_token = n_off
THEN
    BEGIN
    s20 := c_x_cons;
    SAPDB_PascalForcedMove (mxsp_c20, sizeof (command), @s20, 1, @command, pos, mxsp_c20);
    pos := pos + mxsp_c20;
    SAPDB_PascalForcedMove (sizeof(upg.serverdb), sizeof (command), @upg.serverdb, 1,
          @command, pos, sizeof(upg.serverdb));
    pos := pos + sizeof(upg.serverdb);
    s20 := c_clr_debug;
    SAPDB_PascalForcedMove (mxsp_c20, sizeof (command), @s20, 1, @command, pos, mxsp_c20);
    pos := pos + mxsp_c20;
    END
ELSE
    BEGIN
    s20 := c_x_cons;
    SAPDB_PascalForcedMove (mxsp_c20, sizeof (command), @s20, 1, @command, pos, mxsp_c20);
    pos := pos + mxsp_c20;
    SAPDB_PascalForcedMove (sizeof(upg.serverdb), sizeof (command), @upg.serverdb, 1,
          @command, pos, sizeof(upg.serverdb));
    pos := pos + sizeof(upg.serverdb);
    s20 := c_set_debug;
    SAPDB_PascalForcedMove (mxsp_c20, sizeof (command), @s20, 1, @command, pos, mxsp_c20);
    pos := pos + mxsp_c20;
    SAPDB_PascalForcedMove (sizeof(upg.second_token), sizeof (command),
          @upg.second_token, 1, @command, pos, sizeof(upg.second_token));
    END;
(*ENDIF*) 
sqlexec (command, sync_new_session, error, msg, commandresult);
IF  (error <> ex_ok) OR (commandresult <> 0)
THEN
    ta320put_msg (upg, msg);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320set_senderid (
            VAR upg      : tta_user_proc_globals;
            VAR senderid : tsp00_Sname);
 
CONST
      c_standard      = 'STANDARD    ';
 
BEGIN
IF  senderid = c_standard
THEN
    ta320get_senderid (upg)
ELSE
    SAPDB_PascalForcedMove (SNAME_MXSP00, mxsp_c3, @senderid, 1, @upg.application, 1, mxsp_c3);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320set_selfetch (
            VAR upg    : tta_user_proc_globals;
            VAR option : tsp00_Sname);
 
BEGIN
IF  option = n_on
THEN
    upg.command_options := upg.command_options - [ sp1co_selfetch_off ]
ELSE
    upg.command_options := upg.command_options + [ sp1co_selfetch_off ];
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320set_scrollfeature (
            VAR upg    : tta_user_proc_globals;
            VAR option : tsp00_Sname);
 
BEGIN
IF  option = n_on
THEN
    upg.check_scrollopt := true
ELSE
    upg.check_scrollopt := false;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320set_autocommit (
            VAR upg    : tta_user_proc_globals;
            VAR option : tsp00_Sname);
 
BEGIN
IF  option = n_on
THEN
    upg.autocommit := true
ELSE
    upg.autocommit := false;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320set_moduleinfo (
            VAR upg : tta_user_proc_globals;
            VAR cmd : tsp00_Sname);
 
VAR
      ok       : boolean;
      hint     : integer;
      lineinfo : tsp00_DataLine;
 
BEGIN
WITH lineinfo DO
    BEGIN
    text [ 1 ] := bsp_c1;
    SAPDB_PascalForcedMove (sizeof (cmd), sizeof (text), @cmd, 1, @text, 2, sizeof (cmd));
    pos    := 1;
    length := sizeof (cmd) + 1;
    END;
(*ENDWITH*) 
ta320getint (upg, lineinfo, hint, ok);
IF  ok AND (hint > 0)
THEN
    upg.with_module_part := hint
ELSE
    upg.with_module_part := 0;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320set_lineinfo (
            VAR upg    : tta_user_proc_globals;
            VAR option : tsp00_Sname);
 
BEGIN
IF  option = n_on
THEN
    upg.with_abap_part := true
ELSE
    upg.with_abap_part := false;
(*ENDIF*) 
END;
 
(* PTS 1122546 D.T. *)
(*------------------------------*) 
 
PROCEDURE
      ta320set_longdemand (
            VAR upg    : tta_user_proc_globals;
            VAR option : tsp00_Sname);
 
BEGIN
IF  option = n_off
THEN
    BEGIN
    upg.longdem_cnt    := 0;
    upg.longdem_atonce := true;
    upg.longdem_length := -1;
    upg.longdem_pos    := 0;
    END
ELSE
    BEGIN
    upg.longdem_cnt    := 2;
    upg.longdem_atonce := true;
    upg.longdem_length := 4;
    upg.longdem_pos    := -5;
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320set_simulation (
            VAR upg        : tta_user_proc_globals;
            VAR simulation : tsp00_Sname);
 
VAR
      msg         : tsp00_C40;
 
BEGIN
msg := bsp_c40;
IF  upg.reference > 0
THEN
    msg := 'TERMINAL command only, if not connected.'
ELSE
    IF  simulation = n_ascii
    THEN
        upg.term_simulation := tasim_ascii
    ELSE
        IF  simulation = n_none
        THEN
            upg.term_simulation := tasim_none
        ELSE
            IF  simulation = n_unicode
            THEN
                upg.term_simulation := tasim_unicode
            ELSE
                msg := 'unknown terminal emulation.             ';
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
IF  msg <> bsp_c40
THEN (* Something went wrong. *)
    ta320put_msg (upg, msg)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320set_producer (
            VAR upg      : tta_user_proc_globals;
            VAR producer : tsp1_producer);
 
VAR
      msg         : tsp00_C40;
 
BEGIN
msg := bsp_c40;
IF  upg.first_token = n_installation
THEN
    IF  upg.second_token = n_on
    THEN
        producer := sp1pr_installation
    ELSE
        IF  upg.second_token = n_off
        THEN
            producer := sp1pr_user_cmd
        ELSE
            msg := 'After INSTALLATION expected: ON or OFF  '
        (*ENDIF*) 
    (*ENDIF*) 
ELSE
    IF  upg.first_token = n_producer
    THEN
        IF  upg.second_token = n_user
        THEN
            producer := sp1pr_user_cmd
        ELSE
            IF  upg.second_token = n_internal
            THEN
                producer := sp1pr_internal_cmd
            ELSE
                IF  upg.second_token = n_kernel
                THEN
                    producer := sp1pr_kernel
                ELSE
                    IF  upg.second_token = n_installation
                    THEN
                        producer := sp1pr_installation
                    ELSE
                        msg := 'Invalid producer found                  ';
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
IF  msg <> bsp_c40
THEN (* Something went wrong. *)
    ta320put_msg (upg, msg)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320put_msg (
            VAR upg : tta_user_proc_globals;
            VAR msg : tsp00_C40);
 
BEGIN
SAPDB_PascalForcedMove (sizeof (msg), sizeof (upg.prot.ln),
      @msg, 1, @upg.prot.ln, 1, 40);
SAPDB_PascalForcedFill (sizeof (upg.prot.ln), @upg.prot.ln, 41, 40, ' ');
t09put (upg.term^, upg.prot.ln, cut_protected);
t320prot (upg, 40);
upg.pfkey := pf_none
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320set_serverdb (
            VAR upg    : tta_user_proc_globals;
            snd_packet : tsp1_packet_ptr;
            useutil    : boolean);
 
VAR
      i : integer;
 
BEGIN
WITH upg.curr_segm^ DO
    IF  sp1p_buf[ sp1p_buf_len ] = command_delimiter
    THEN
        sp1p_buf_len := pred (sp1p_buf_len);
    (*ENDIF*) 
(*ENDWITH*) 
u05getserverdb (snd_packet, upg.utilserverdb, upg.utilservernode);
IF  NOT useutil
THEN
    BEGIN
    upg.serverdb   := upg.utilserverdb;
    upg.servernode := upg.utilservernode;
    i := 1;
    WHILE (i <= DBNAME_MXSP00) AND (i <= 16) DO
        BEGIN
        upg.left_header[ i+4 ] := upg.serverdb[ i ];
        i := i + 1
        END;
    (*ENDWHILE*) 
    t09header    (upg.term^, upg.left_header, upg.right_header);
    t09msgheader (upg.term^, msg30_enter_cmd, true)
    END;
&ifdef trace
(*ENDIF*) 
t02name (debug_ta, upg.serverdb);
t02name (debug_ta, upg.utilserverdb);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      t320sequential_program (
            VAR upg           : tta_user_proc_globals;
            VAR ut_term       : tut_terminal;
            is_util_cmd       : boolean;
            VAR util_cmd_line : tsp00_Line);
 
CONST
      c_write_time = true;
 
VAR
      call_spec_cmd       : boolean;
      m_is_data_inp       : boolean;
      producer            : tsp1_producer;
      i,j                 : integer;
      third_string        : tsp00_Sname;
      c30                 : tsp00_C30;
      ln                  : tsp00_Line;
      connect_packet      : tsp1_packet_ptr;
      snd_packet          : tsp1_packet_ptr;
      rcv_packet          : tsp1_packet_ptr;
      returncode          : tsp00_Int2;
      cmd_segm            : tsp1_segment_ptr;
      cmd_part            : tsp1_part_ptr;
      connect_buf         : PACKED ARRAY [1..1024] OF char;
      session_ptr         : tsp00_MoveObjPtr;
      dbmapi_retcode      : tsp00_Int4;
      cstr_utilserverdb   : tsp00_DbName;
      cstr_utilservernode : tsp00_NodeId;
      cstr_dbroot         : tsp00_VFilename;
      cstr_user           : tsp00_C64;
 
BEGIN
session_stack.top := 0;
returncode        := 0;
upg.term          := @ut_term;
upg.pfkey         := pf_none;
upg.bigcmd_offset := 0;
upg.more_segments := 0;
upg.curr_segm     := NIL;
upg.is_data_input := false;
upg.execution     := tek_parsing_executing;
upg.p_count       := 0;
upg.time          := false;
upg.rtime         := false;
upg.info          := false;
upg.prot.session  := false;
upg.utilserverdb  := upg.serverdb;
upg.utilservernode:= upg.servernode;
ta320get_senderid (upg);
upg.appl_param_infos:= false;
upg.mass_cmd        := false;
upg.longdesccnt     := 0;
upg.shared_sql_drop := false;
upg.shared_drop_trans:= false;
snd_packet        := NIL;
rcv_packet        := NIL;
connect_packet    := @connect_buf;
ta320get_senderid (upg);
connect_packet^.sp1_header.sp1h_varpart_size := sizeof (connect_buf);
ta320packet_init (upg, connect_packet, cmd_segm, cmd_part);
i := 1;
WHILE (i <= DBNAME_MXSP00) AND (i <= 16) DO
    BEGIN
    upg.left_header[ i+4 ] := upg.serverdb[ i ];
    i := succ(i)
    END;
(*ENDWHILE*) 
upg.right_header := msg_not_connected;
upg.msg_header   := bsp_c30;
(* PTS 1105196 E.Z. *)
upg.dbprocCall := false;
FOR i := 1 TO cta_max_parsing DO
    BEGIN
    upg.execute_input [ i ].cnt_input_fields := 0;
    upg.execute_output[ i ].cnt_input_fields := 0;
    END;
(*ENDFOR*) 
t09frame  (upg.term^, true);
t09pfkeys (upg.term^, true);
producer := sp1pr_user_cmd;
t09header (upg.term^, upg.left_header, upg.right_header);
t320display_enter_command (upg, returncode);
ta320readinput (upg, producer,
      third_string, connect_packet,
      cmd_segm, cmd_part);
IF  (upg.pfkey = pf_end) OR upg.cancel
THEN
    upg.pfkey := pf_cancel;
(*ENDIF*) 
t09msgheader (upg.term^, bsp_c30, true);
WHILE (upg.first_token <> n_exit) AND (upg.pfkey <> pf_cancel) AND
      ((upg.term^.retcode <> cut_sql_req_failed) OR NOT upg.to_break
      OR NOT upg.term^.is_inputfile) AND upg.term^.io_ok DO
    BEGIN
    upg.prot.no_prot := false;
    WHILE ((upg.first_token = n_bigcmd  )     OR
          ( upg.first_token = n_break   )     OR
          ( upg.first_token = n_debug   )     OR
          ( upg.first_token = n_errormsg)     OR
          ( upg.first_token = n_fileinfo)     OR
          ( upg.first_token = n_installation) OR
          ( upg.first_token = n_autocommit)   OR
          ( upg.first_token = n_lineinfo)     OR
          ( upg.first_token = n_scrollfeature)OR
          ( upg.first_token = n_longdemand)   OR
          ( upg.first_token = n_moduleinfo)   OR
          ( upg.first_token = n_producer)     OR
          ( upg.first_token = n_prot    )     OR
          ( upg.first_token = n_selfetch)     OR
          ( upg.first_token = n_senderid)     OR
          ( upg.first_token = n_sleep   )     OR
          ( upg.first_token = n_term    )     OR
          ( upg.first_token = n_use     )     OR
          ( upg.first_token = n_useutil ))   AND
          ( upg.first_token <> n_exit)       AND
          ( upg.pfkey <> pf_cancel)  DO
        BEGIN
        IF  upg.first_token = n_errormsg
        THEN
            upg.long_errmsg := upg.second_token = n_long
        ELSE
            IF  upg.first_token = n_fileinfo
            THEN
                upg.file_info := upg.second_token = n_on
            ELSE
                IF  (upg.first_token = n_installation) OR
                    (upg.first_token = n_producer)
                THEN
                    ta320set_producer (upg, producer)
                ELSE
                    IF  upg.first_token = n_term
                    THEN
                        ta320set_simulation (upg, upg.second_token)
                    ELSE
                        IF  upg.first_token = n_selfetch
                        THEN
                            ta320set_selfetch (upg, upg.second_token)
                        ELSE
                            IF  upg.first_token = n_senderid
                            THEN
                                ta320set_senderid (upg, upg.second_token)
                            ELSE
                                IF  upg.first_token = n_scrollfeature
                                THEN
                                    ta320set_scrollfeature (upg, upg.second_token)
                                ELSE
                                    IF  upg.first_token = n_autocommit
                                    THEN
                                        ta320set_autocommit (upg, upg.second_token)
                                    ELSE
                                        IF  upg.first_token = n_moduleinfo
                                        THEN
                                            ta320set_moduleinfo (upg, upg.second_token)
                                        ELSE
                                        IF  upg.first_token = n_lineinfo
                                        THEN
                                            ta320set_lineinfo (upg, upg.second_token)
                                        ELSE
                                            IF  upg.first_token = n_longdemand
                                            THEN
                                                ta320set_longdemand (upg, upg.second_token)
                                            ELSE
                                                IF  upg.first_token = n_bigcmd
                                                THEN
                                                    ta320set_cmdoffset (upg, upg.second_token)
                                                ELSE
                                                    IF  upg.first_token = n_sleep
                                                    THEN
                                                     ta320sleep (upg, upg.second_token)
                                                    ELSE
                                                     IF  upg.first_token = n_debug
                                                     THEN
                                                      ta320debug (upg)
                                                     ELSE
                                                      IF  upg.first_token = n_prot
                                                      THEN
                                                       ta320set_prot (upg, upg.second_token)
                                                      ELSE
                                                       IF  (upg.first_token = n_use) OR
                                                        (upg.first_token = n_useutil)
                                                       THEN
                                                        IF  snd_packet <> NIL
                                                        THEN
                                                         ta320set_serverdb (upg,
                                                            snd_packet,
                                                            upg.first_token = n_useutil)
                                                        ELSE
                                                         ta320set_serverdb (upg,
                                                            connect_packet,
                                                            upg.first_token = n_useutil)
                                                        (*ENDIF*) 
                                                       ELSE
                                                        IF  upg.first_token = n_break
                                                        THEN
                                                         upg.to_break := upg.second_token=n_on;
                                                        (*ENDIF*) 
                                                       (*ENDIF*) 
                                                      (*ENDIF*) 
                                                     (*ENDIF*) 
                                                    (*ENDIF*) 
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  snd_packet <> NIL
        THEN
            ta320readinput (upg, producer,
                  third_string, snd_packet,
                  cmd_segm, cmd_part)
        ELSE
            ta320readinput (upg, producer,
                  third_string, connect_packet,
                  cmd_segm, cmd_part)
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  (upg.first_token <> n_exit) AND
        NOT (upg.pfkey in [pf_cancel, pf_end])
    THEN
        BEGIN
        IF  (upg.first_token <> cta_n_connect) AND
            (upg.first_token <> cta_n_file)    AND
            (upg.first_token <> cta_n_getval)  AND
            (upg.first_token <> cta_n_putval)
        THEN
            IF  snd_packet <> NIL
            THEN
                t320finish_part (upg, snd_packet,     cmd_part^)
            ELSE
                t320finish_part (upg, connect_packet, cmd_part^);
            (*ENDIF*) 
        (*ENDIF*) 
        IF  upg.first_token <> cta_n_getval
        THEN
            IF  upg.first_token = cta_n_putval
            THEN
                BEGIN
                m_is_data_inp     := upg.is_data_input;
                upg.is_data_input := false;
                ta320do_putval (upg,
                      snd_packet, rcv_packet, returncode);
                upg.is_data_input := m_is_data_inp
                END
            ELSE
                BEGIN
                call_spec_cmd := false;
                CASE upg.first_token[1] OF
                    (* necessary for Achim's compiler *)
                    'B', 'C', 'D', 'E', 'F':
                        IF  (upg.first_token = cta_n_buflimit       ) OR
                            (upg.first_token =     n_cms            ) OR
                            (upg.first_token =     n_count          ) OR
                            (upg.first_token = cta_n_data_input     ) OR
                            (upg.first_token = cta_n_endsum         ) OR
                            (upg.first_token = cta_n_executing      ) OR
                            (* PTS 1111575 E.Z. *)
                            (upg.first_token = cta_n_file           )
                        THEN
                            call_spec_cmd := true;
                        (*ENDIF*) 
                    'L', 'M', 'N':
                        IF  ((upg.first_token = cta_n_load           )
                            AND
                            (upg.second_token <> 'STATISTICS  '))     OR
                            (upg.first_token = cta_n_masscmd        ) OR
                            (upg.first_token = cta_n_maxbuf         ) OR
                            (upg.first_token = cta_n_minbuf         ) OR
                            (upg.first_token = cta_n_no_data_input  ) OR
                            (upg.first_token = cta_n_no_masscmd     ) OR
                            (upg.first_token = cta_n_no_parameter   ) OR
                            (upg.first_token = cta_n_noreal         ) OR
                            (upg.first_token = cta_n_notime         )
                        THEN
                            call_spec_cmd := true;
                        (*ENDIF*) 
                    'P','R','S':
                        IF  (upg.first_token = cta_n_parameter      ) OR
                            (upg.first_token = cta_n_pars_execute   ) OR
                            (upg.first_token = cta_n_pars_then_ex   ) OR
                            (upg.first_token = cta_n_parsing        ) OR
                            (upg.first_token = cta_n_real           ) OR
                            (upg.first_token = cta_n_sum            ) OR
                            (upg.first_token = cta_n_switch         ) OR
                            (upg.first_token = cta_n_switch_limited ) OR
                            (upg.first_token = cta_n_syntax         )
                        THEN
                            call_spec_cmd := true;
                        (*ENDIF*) 
                    'T','U':
                        IF  (upg.first_token = cta_n_tbuflimit      ) OR
                            (upg.first_token = cta_n_time           ) OR
                            (upg.first_token = cta_n_tmaxbuf        ) OR
                            (upg.first_token = cta_n_tminbuf        ) OR
                            (upg.first_token = cta_n_tswitch        ) OR
                            (upg.first_token = cta_n_tswitch_limited) OR
                            (upg.first_token =     n_unix           ) OR
                            (upg.first_token = 'UTILSTATE   '       )
                        THEN
                            call_spec_cmd := true;
                        (*ENDIF*) 
                    OTHERWISE;
                    END;
                (*ENDCASE*) 
                IF  call_spec_cmd
                THEN
                    IF  snd_packet <> NIL
                    THEN
                        (* PTS 1106167 E.Z. *)
                        t370tests (upg, upg.first_token,
                              upg.second_token, snd_packet, rcv_packet, returncode)
                    ELSE
                        t370tests (upg, upg.first_token,
                              upg.second_token,
                              connect_packet, rcv_packet, returncode)
                    (*ENDIF*) 
                ELSE
                    IF  (upg.first_token[ 1 ] <> comment_symbol)
                        AND
                        ((upg.first_token[ 1 ] <> comment1_symbol) OR
                        ( upg.first_token[ 2 ] <> comment_symbol))
                    THEN
                        BEGIN
                        t09returncode_set (upg.term^, 0);
                        IF  (upg.first_token = n_dbmcli)
                        THEN
                            BEGIN
                            t09pfkeys (upg.term^, false);
                            (* convert pascal strings to C strings *)
                            i := 1;
                            WHILE ( upg.second_token[i] <> csp_ascii_blank ) AND
                                  ( i < mxsp_c64 ) DO
                                BEGIN
                                cstr_user[i] := upg.second_token[i];
                                i := succ(i);
                                END;
                            (*ENDWHILE*) 
                            cstr_user[i] := ',';
                            j := succ(i);
                            i := 1;
                            WHILE ( third_string[i] <> csp_ascii_blank ) AND
                                  ( j < mxsp_c64 ) AND ( i < SNAME_MXSP00 ) DO
                                BEGIN
                                cstr_user[j] := third_string[i];
                                i := succ(i);
                                j := succ(j);
                                END;
                            (*ENDWHILE*) 
                            cstr_user[j] := '\00';
                            i := 1;
                            WHILE ( upg.utilserverdb[i] <> csp_ascii_blank ) AND
                                  ( i < DBNAME_MXSP00 ) DO
                                BEGIN
                                cstr_utilserverdb[i] :=
                                      upg.utilserverdb[i];
                                i := succ(i);
                                END;
                            (*ENDWHILE*) 
                            cstr_utilserverdb[i] := '\00';
                            i := 1;
                            WHILE ( upg.utilservernode[i] <> csp_ascii_blank ) AND
                                  ( i < NODEID_MXSP00 ) DO
                                BEGIN
                                cstr_utilservernode[i] :=
                                      upg.utilservernode[i];
                                i := succ(i);
                                END;
                            (*ENDWHILE*) 
                            cstr_utilservernode[i] := '\00';
                            cstr_dbroot[1] := '\00';
                            dbmapi_retcode :=
                                  cn14connectDBMUsr_fixedSizeParameters(cstr_utilservernode,
                                  cstr_utilserverdb, cstr_dbroot,
                                  cstr_user, session_ptr, upg.prot.errt);
                            IF  dbmapi_retcode = 0
                            THEN
                                t33sub_sequential_program(upg, session_ptr)
                            ELSE
                                BEGIN
                                (* error handling *)
                                t320string_to_line(upg.prot.errt,
                                      upg.prot.ln);
                                t09putmsg(upg.term^, upg.prot.ln,
                                      true, true);
                                i := 1;
                                WHILE (upg.prot.errt[i] <> '\00') AND
                                      (sizeof(upg.prot.errt) >= i) DO
                                    i := succ(i);
                                (*ENDWHILE*) 
                                t320prot(upg, i-1);
                                IF  upg.is_batch
                                THEN
                                    BEGIN
                                    upg.first_token := n_exit;
                                    third_string := n_exit;
                                    SAPDB_PascalForcedMove(sizeof(tsp00_Sname),
                                          sizeof(upg.prot.ln), @third_string, 1 ,
                                          @upg.prot.ln, 1, sizeof(tsp00_Sname));
                                    t320prot(upg, sizeof(tsp00_Sname));
                                    upg.pfkey := pf_cancel;
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            IF  is_util_cmd
                            THEN
                                upg.pfkey := pf_cancel;
                            (*ENDIF*) 
                            IF  (NOT upg.to_break) AND (upg.pfkey = pf_cancel)
                            THEN
                                BEGIN
                                upg.pfkey := pf_none;
                                t13close_file (upg.term^)
                                END;
                            (*ENDIF*) 
                            IF  upg.pfkey <> pf_cancel
                            THEN
                                BEGIN
                                i := 1;
                                WHILE (i <= DBNAME_MXSP00) AND (i <= 16) DO
                                    BEGIN
                                    upg.left_header[i+4] := upg.serverdb[i];
                                    i := succ (i)
                                    END;
                                (*ENDWHILE*) 
                                t09pfkeys (upg.term^, true);
                                t09frame  (upg.term^, true);
                                t09header (upg.term^, upg.left_header,
                                      upg.right_header)
                                END
                            (*ENDIF*) 
                            END
                        ELSE
                            ta320command_interface (upg, third_string,
                                  connect_packet, snd_packet, cmd_segm,
                                  cmd_part, rcv_packet, returncode);
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  upg.cancel
    THEN
        upg.pfkey := pf_cancel;
    (*ENDIF*) 
    IF  upg.pfkey = pf_end
    THEN
        upg.pfkey := pf_none;
    (*ENDIF*) 
    IF  (upg.pfkey = pf_none) AND
        ((upg.term^.retcode <> cut_sql_req_failed) OR NOT upg.to_break
        OR NOT upg.term^.is_inputfile)
    THEN
        BEGIN
        t320display_enter_command (upg, returncode);
        IF  snd_packet <> NIL
        THEN
            ta320readinput (upg, producer,
                  third_string, snd_packet,
                  cmd_segm, cmd_part)
        ELSE
            ta320readinput (upg, producer,
                  third_string, connect_packet,
                  cmd_segm, cmd_part)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  ((upg.pfkey = pf_cancel) OR (upg.pfkey = pf_end))
        AND NOT upg.term^.is_batch
        AND (upg.first_token <> n_exit   )
        AND (upg.reference > 0)
    THEN
        BEGIN
        upg.pfkey := pf_none;
        ln        := upg.term^.blankline;
        c30       := msg30_leave1;
        SAPDB_PascalForcedMove (sizeof(c30), sizeof(ln), @c30, 1, @ln, 1, mxsp_c30);
        c30 := msg30_leave2;
        SAPDB_PascalForcedMove (sizeof(c30), sizeof(ln), @c30, 1,
              @ln, mxsp_c30 + 1, mxsp_c30);
        t09putmsg (upg.term^, ln, false, false);
        IF  snd_packet <> NIL
        THEN
            ta320readinput (upg, producer,
                  third_string, snd_packet,
                  cmd_segm, cmd_part)
        ELSE
            ta320readinput (upg, producer,
                  third_string, connect_packet,
                  cmd_segm, cmd_part)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  upg.pfkey = pf_end
    THEN
        upg.pfkey := pf_cancel;
    (*ENDIF*) 
    t09msgheader (upg.term^, bsp_c30, true)
    END;
(*ENDWHILE*) 
IF  (upg.first_token <> n_exit) AND
    (upg.reference > 0)
THEN
    ta320last_logoff (upg,
          snd_packet, rcv_packet, returncode);
(*ENDIF*) 
IF  NOT is_util_cmd
THEN
    BEGIN
    t320string_to_line (session_end_msg, upg.prot.ln);
    IF  upg.pfkey <> pf_cancel
    THEN
        t09putmsg (upg.term^, upg.prot.ln, false, true);
    (*ENDIF*) 
    t320prot (upg, 15)
    END;
(*ENDIF*) 
END;
 
(*================================================================*)
(*==========                                            ==========*)
(*========== ab hier gehoert alles zu command_interface ==========*)
(*==========                                            ==========*)
(*================================================================*)
(*------------------------------*) 
 
PROCEDURE
      ta320getint (
            VAR upg          : tta_user_proc_globals;
            VAR lineinfo     : tsp00_DataLine;
            VAR integervalue : integer;
            VAR ok           : boolean);
 
CONST
      maxintl = 5;
 
VAR
      vvalue    : boolean;
      found,neg : boolean;
      c         : char;
      i,currpos : integer;
      intlength : tsp00_LinePositions;
      fac       : integer;
 
BEGIN
ok           := true;
neg          := false;
vvalue       := false;
integervalue := 0;
found        := false;
intlength    := 0;
WITH lineinfo DO
    BEGIN
    IF  pos > 0
    THEN
        IF  pos > length
        THEN
            BEGIN
            ok := false;
&           ifdef TRACE
            t02str30 (debug_always, 'getint : input already passed ');
&           endif
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  ok
    THEN
        BEGIN
        currpos := pos;
        REPEAT
            currpos := succ (currpos);
            c       := text [ currpos ];
            IF  c = bsp_c1
            THEN
                BEGIN
                IF  vvalue
                THEN
                    found := true
                (*ENDIF*) 
                END
            ELSE
                IF  c = '+'
                THEN
                    BEGIN
                    IF  vvalue
                    THEN
                        ok := false
                    (*ENDIF*) 
                    END
                ELSE
                    IF  c = '-'
                    THEN
                        BEGIN
                        IF  vvalue
                        THEN
                            ok := false
                        ELSE
                            neg := true
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  currpos > length
                        THEN
                            BEGIN
                            IF  vvalue
                            THEN
                                found := true
                            ELSE
                                ok := false
                            (*ENDIF*) 
                            END
                        ELSE
                            IF  c in upg.digiset
                            THEN
                                BEGIN
                                vvalue    := true;
                                intlength := succ (intlength);
                                IF  intlength > maxintl
                                THEN
                                    ok := false
                                (*ENDIF*) 
                                END
                            ELSE
                                ok := false
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        UNTIL
            (found OR NOT ok);
        (*ENDREPEAT*) 
        IF  NOT ok
        THEN
            BEGIN
&           ifdef TRACE
            t02str30 (debug_always, 'getint : invalid input        ');
&           endif
            END
        ELSE
            BEGIN
            pos := pred (currpos);
            integervalue := 0;
            fac := 1;
            FOR i:= intlength DOWNTO 1 DO
                BEGIN
                currpos := pred (currpos);
                integervalue := integervalue + fac *
                      (ord(text[ currpos ]) - ord('0'));
                IF  i > 1
                THEN
                    fac := fac * 10
                (*ENDIF*) 
                END;
            (*ENDFOR*) 
            IF  neg
            THEN
                integervalue := integervalue * (-1)
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320read_int (
            VAR upg : tta_user_proc_globals;
            VAR int : integer);
 
VAR
      int_line : tsp00_DataLine;
      ok       : boolean;
 
BEGIN
upg.pfkey := pf_none;
REPEAT
    t09put20 (upg.term^, 'Anzahl eingeben :   ', cut_protected);
    WITH int_line DO
        BEGIN
        t09get (upg.term^, text, upg.pfkey);
        IF  upg.pfkey = pf_none
        THEN
            BEGIN
            pos := 0;
            WHILE (pos+1 < LINE_MXSP00) AND (text [ pos+1 ] = ' ') DO
                pos := succ (pos);
            (*ENDWHILE*) 
            length := LINE_MXSP00;
            WHILE (length > 1) AND (text [ length ] = ' ') DO
                length := pred (length);
            (*ENDWHILE*) 
            IF  length >= pos
            THEN
                ta320getint (upg, int_line, int, ok)
            ELSE
                ok := false;
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    IF  NOT ok AND (upg.pfkey = pf_none)
    THEN
        t09put20 (upg.term^, 'fehlerhafte Eingabe!', cut_bright_protected)
    (*ENDIF*) 
UNTIL
    ok OR (upg.pfkey <> pf_none);
(*ENDREPEAT*) 
IF  upg.pfkey = pf_none
THEN
    BEGIN
    t09put (upg.term^, int_line.text, cut_protected);
    upg.prot.ln := int_line.text;
    t320prot (upg, int_line.length)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ta320token_in_cmd (
            VAR upg      : tta_user_proc_globals;
            VAR cmd_part : tsp1_part;
            keyword      : tsp00_C6;
            pos          : tsp00_Int4;
            length       : tsp00_Int4) : boolean;
 
VAR
      found     : boolean;
      i         : tsp00_Int4;
      char_size : tsp00_Int4;
 
BEGIN
IF  upg.code_type in [ csp_unicode, csp_unicode_swap ]
THEN
    char_size := 2
ELSE
    char_size := 1;
(*ENDIF*) 
IF  upg.code_type = csp_unicode
THEN
    pos := succ (pos);
(*ENDIF*) 
WITH cmd_part DO
    BEGIN
    found := false;
    WHILE NOT found AND (pos+length*char_size <= sp1p_buf_len) DO
        BEGIN
        IF  sp1p_buf[ pos ] = ' '
        THEN
            BEGIN
            i     := 1;
            found := true;
            WHILE found AND (i <= length) DO
                BEGIN
                found := sp1p_buf[ pos+i*char_size ] = keyword[ i ];
                i     := succ (i)
                END
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        pos := pos + char_size
        END
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
ta320token_in_cmd := found
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320command_interface (
            VAR upg        : tta_user_proc_globals;
            VAR third      : tsp00_Sname;
            connect_packet : tsp1_packet_ptr;
            VAR snd_packet : tsp1_packet_ptr;
            VAR cmd_segm   : tsp1_segment_ptr;
            VAR cmd_part   : tsp1_part_ptr;
            VAR rcv_packet : tsp1_packet_ptr;
            VAR returncode : tsp00_Int2);
 
CONST
      n_add        = 'ADD         ';
      n_language   = 'LANGUAGE    ';
      n_parseid    = 'PARSEID     ';
      n_priv       = 'PRIV        ';
      n_privileges = 'PRIVILEGES  ';
      n_set        = 'SET         ';
      n_store      = 'STORE       ';
      n_user       = 'USER        ';
 
VAR
      sql_return       : tsp1_comm_error;
      key_found        : boolean;
      i                : integer;
      idnr             : integer;
      j                : integer;
      pos              : integer;
      dist             : integer;
      org_segment_len  : tsp00_Int4;
      snd_packet_size  : tsp00_Int4;
      aux_len          : tsp00_Int4;
      d                : tsp00_Date;
      t                : tsp00_Time;
      nam              : tsp00_Name;
      crypt            : tsp00_CryptPw;
      c8               : tsp00_C8;
      parseid          : tsp00_C12;
      err_string       : tsp00_ErrText;
      ln               : tsp00_Line;
      dli              : tsp00_DataLine;
      ex_in            : tta_ex_in;
      field_info       : tsp1_param_info;
      part2            : tsp1_part_ptr;
      data_part        : tsp1_part_ptr;
      feature_part     : tsp1_part_ptr;
      packet_list      : tsp1_packet_list;
      org_segment      : tsp1_segment_ptr;
      org_segment_buf  : tsp00_Buf8K;
      empty_parsid     : tsp00_C12;
      with_parsid      : boolean;
      with_resultcount : boolean;
      with_argcount    : boolean;
      ident_io_len     : integer;
      (* h.b. CR 1000072 *)
      is_first_part    : boolean;
      stack_rc         : boolean;
&     ifdef PARS
      m_ex_kind        : tta_execution_kind;
&     endif
      features         : tsp1_features;
      feature_cnt      : integer;
      curr_feature     : tsp1_feature;
 
BEGIN
returncode    := 0;
is_first_part := false;
IF  upg.first_token = cta_n_connect
THEN
    BEGIN
    IF  (upg.reference <> 0) AND (snd_packet <> NIL)
    THEN
        BEGIN
&       ifdef trace
        t02name (debug_ta, '*** CONN: ref<>0 !');
        aux_len := sizeof (cmd_segm^.sp1s_segm_header) +
              sizeof (cmd_part^.sp1p_part_header) +
              cmd_part^.sp1p_buf_len;
        SAPDB_PascalForcedMove (snd_packet^.sp1_header.sp1h_varpart_size,
              connect_packet^.sp1_header.sp1h_varpart_size,
              @snd_packet^.sp1_varpart, 1,
              @connect_packet^.sp1_varpart, 1, aux_len);
&       endif
        ta320push_session (upg.reference, upg.is_connected, upg.variable_input,
              snd_packet, rcv_packet, stack_rc);
        END;
    (*ENDIF*) 
    upg.reference := 0
    END;
(*ENDIF*) 
IF  upg.reference = 0
THEN
    BEGIN
&   ifdef trace
    t02name (debug_ta, 'calling sqlaconnec');
    t02name (debug_ta, 'locname (=db)     ');
    t02name (debug_ta, upg.serverdb);
    t02name (debug_ta, 'node_id (c64)     ');
    t02c64 (debug_ta, upg.servernode);
&   endif
    err_string := bsp_c40;
    sqlaconnect (upg.procid, upg.servernode, upg.serverdb,
          sql_user, 1, upg.reference, snd_packet_size, packet_list,
          err_string, sql_return);
&   ifdef trace
    t02int4 (debug_ta, 'ref (after) ', upg.reference);
&   endif
    IF  sql_return = sp1ce_ok
    THEN
        BEGIN
        aux_len := sizeof (cmd_segm^.sp1s_segm_header) +
              sizeof (cmd_part^.sp1p_part_header) +
              cmd_part^.sp1p_buf_len;
        snd_packet := packet_list [1];
&       ifdef trace
        t02int4 (debug_ta, 'packet size ', snd_packet_size);
&       endif
        snd_packet^.sp1_header := connect_packet^.sp1_header;
        snd_packet^.sp1_header.sp1h_varpart_size :=  snd_packet_size -
              sizeof (snd_packet^.sp1_header);
        SAPDB_PascalForcedMove (connect_packet^.sp1_header.sp1h_varpart_size,
              snd_packet^.sp1_header.sp1h_varpart_size,
              @connect_packet^.sp1_varpart, 1,
              @snd_packet^.sp1_varpart, 1, aux_len);
&       ifdef trace
        t02name   (debug_ta, 'connect packet -->');
        IF  t02trace (debug_ta)
        THEN
            x05packet (upg.term^, upg.prot.refer, t02is_minbuf,
                  t02buflength_max, 'snd_packet  ', snd_packet);
&       endif
        (*cmd_segm := @snd_packet^.sp1_segm;*)
        (*ENDIF*) 
        cmd_segm := s26segmptr(snd_packet^.sp1_segm);
        cmd_part := @cmd_segm^.sp1p_part;
        END
    ELSE
        BEGIN
        u05request_errmsg (upg.term^, upg.prot.refer, err_string, sql_return);
        upg.reference := 0;
        returncode    := cut_sql_req_failed;
        ta320pop_session (upg.reference, upg.is_connected, upg.variable_input,
              snd_packet, rcv_packet, stack_rc);
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  returncode = 0
THEN
    BEGIN
    org_segment := t340segmptr (org_segment_buf);
    key_found   := false;
    cmd_segm^.sp1c_mass_cmd := upg.mass_cmd;
    IF  upg.prepare
    THEN
        dist := 6
    ELSE
        dist := 0;
    (*ENDIF*) 
    IF  ((upg.first_token = n_commit) OR (upg.first_token = n_rollback))
        AND (((upg.second_token = n_work) AND (third = n_release)) OR
        (upg.second_token = n_release))
    THEN
        BEGIN
        FOR i := 5 DOWNTO 1 DO
            upg.open_cols[ i ].free := true;
        (*ENDFOR*) 
        upg.second_token := n_release
        END;
    (*ENDIF*) 
    IF  upg.first_token = n_fetch1
    THEN
        ta320blank_out (upg, cmd_part^, 6)
    ELSE
        IF  (upg.first_token = n_fetchall) AND
            (upg.second_token <> 'FIRST       ') AND
            (upg.second_token <> 'LAST        ') AND
            (upg.second_token <> 'POS         ')
        THEN
            IF  n_fetchall = cta_n_fetch
            THEN
                BEGIN
                upg.first_token := cta_n_fetch;
                cmd_segm^.sp1c_mass_cmd := true;
                t320resultcount_part (upg, snd_packet,
                      cmd_segm^, 100)
                END
            ELSE
                BEGIN
                WITH cmd_part^ DO
                    BEGIN
                    sp1p_buf[ 1 ]:= 'F';
                    sp1p_buf[ 2 ]:= 'E';
                    sp1p_buf[ 3 ]:= 'T';
                    sp1p_buf[ 4 ]:= 'C';
                    sp1p_buf[ 5 ]:= 'H';
                    sp1p_buf[ 6 ]:= ' ';
                    sp1p_buf[ 7 ]:= ' ';
                    sp1p_buf[ 8 ]:= ' '
                    END;
                (*ENDWITH*) 
                cmd_segm^.sp1c_mass_cmd := true;
                t320resultcount_part (upg, snd_packet,
                      cmd_segm^, 100)
                END
            (*ENDIF*) 
        ELSE
            BEGIN
            IF  ((upg.first_token = n_mfetch )  AND
                (upg.second_token <> n_rest)) OR
                (upg.first_token = n_rfetch ) OR
                (upg.first_token = n_mdelete) OR
                (upg.first_token = n_minsert) OR
                (upg.first_token = n_mlock) OR
                (upg.first_token = n_mselect) OR
                (upg.first_token = n_mdeclare) OR
                (upg.first_token = n_mupdate)
            THEN
                BEGIN
                IF  upg.first_token <> n_rfetch
                THEN
                    ta320blank_out (upg, cmd_part^, 1+dist);
                (*ENDIF*) 
                cmd_segm^.sp1c_mass_cmd := true;
                IF  (upg.execution <> tek_only_parsing) AND
                    (upg.execution <> tek_only_syntax)
                THEN (* here we start over with a fresh cmd_segm. *)
                    BEGIN
                    with_parsid := ((upg.first_token <> n_mfetch)) AND
                          (upg.first_token <> n_rfetch) AND
                          (upg.execution <> tek_pars_then_execute);
                    with_resultcount := (upg.execution <> tek_pars_then_execute);
&                   ifdef PARS
                    IF  (upg.execution = tek_parsing_executing)
                        AND
                        (upg.first_token = n_mfetch)
                    THEN
                        with_resultcount := false;
&                   endif
                    (*ENDIF*) 
                    with_argcount := (upg.first_token <> n_rfetch) AND
                          (upg.first_token <> n_mfetch) AND
                          (upg.execution <> tek_pars_then_execute);
                    IF  with_parsid
                    THEN
                        BEGIN
                        IF  (upg.more_segments > 0) AND (upg.is_connected)
                        THEN
                            BEGIN
                            upg.curr_segm^.sp1s_segm_len    :=
                                  sizeof (tsp1_segment_header);
                            upg.curr_segm^.sp1s_no_of_parts := 0;
                            cmd_segm := upg.curr_segm;
                            END
                        ELSE
                            s26first_segment_init (snd_packet,
                                  sp1sk_cmd, cmd_segm);
                        (*ENDIF*) 
                        upg.curr_segm := cmd_segm;
                        cmd_segm^.sp1c_mess_type := sp1m_execute;
                        t320parseid_part (upg, snd_packet,
                              cmd_segm^, empty_parsid)
                        END;
                    (*ENDIF*) 
                    IF  with_resultcount
                    THEN
                        BEGIN
                        ta320read_int (upg, pos);
                        t320resultcount_part (upg, snd_packet,
                              cmd_segm^, pos);
                        is_first_part := (pos = csp_maxint2);
                        END;
                    (*ENDIF*) 
                    IF  with_argcount
                    THEN
                        BEGIN
                        ta320read_int (upg, pos);
                        IF  pos <> 0
                        THEN
                            BEGIN
                            s26new_part_init (snd_packet, cmd_segm^, data_part);
                            WITH data_part^ DO
                                BEGIN
                                IF  upg.variable_input
                                THEN
                                    sp1p_part_kind := sp1pk_vardata
                                ELSE
                                    sp1p_part_kind := sp1pk_data;
                                (*ENDIF*) 
                                IF  pos < 0
                                THEN
                                    sp1p_arg_count  := -pos
                                ELSE
                                    BEGIN
                                    sp1p_arg_count  := pos;
                                    sp1p_attributes := [sp1pa_last_packet]
                                    END;
                                (*ENDIF*) 
                                IF  is_first_part
                                THEN
                                    sp1p_attributes := sp1p_attributes +
                                          [sp1pa_first_packet];
                                (*ENDIF*) 
                                END
                            (*ENDWITH*) 
                            END
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            ELSE
                IF  upg.first_token = cta_n_connect
                THEN
                    BEGIN
                    ta320read_password (upg, snd_packet,
                          cmd_segm^, cmd_part^, third);
                    ta320write_features (upg, snd_packet, cmd_segm);
                    END
                ELSE
                    IF  (upg.first_token = n_set) AND
                        (upg.second_token = n_language)
                    THEN
                        BEGIN
                        ex_in.cnt_input_fields := 1;
                        ta320set_infield (ex_in.input_params[ 1 ],
                              sp1ot_mandatory, sp1io_input,
                              dcha, 0, 3, 4, 1);
                        ta320get_data_input (upg, ex_in, snd_packet)
                        END
                    ELSE
                        IF  (((upg.first_token = n_create) AND
                            (upg.second_token = n_user))
                            OR
                            ((upg.first_token = n_alter ) AND
                            (upg.second_token = n_password)))
                            AND
                            upg.is_data_input
                        THEN
                            BEGIN
                            ex_in.cnt_input_fields := 1;
                            ta320set_infield (ex_in.input_params[ 1 ],
                                  sp1ot_mandatory, sp1io_input,
                                  dcha, NAME_MXSP00, 0, NAME_MXSP00+1, 1);
                            IF  (third = bsp_sname) AND (upg.first_token = n_alter)
                            THEN
                                BEGIN
                                ex_in.cnt_input_fields := 2;
                                ta320set_infield (ex_in.input_params[ 2 ],
                                      sp1ot_mandatory, sp1io_input,
                                      dcha, NAME_MXSP00, 0, NAME_MXSP00+1, 26)
                                END;
                            (*ENDIF*) 
                            ta320get_data_input (upg, ex_in, snd_packet)
                            END
                        ELSE
                            IF  (upg.first_token  =  n_usage) AND
                                (upg.second_token <> n_off) AND
                                (upg.execution = tek_parsing_executing)
                            THEN
                                BEGIN
                                ex_in.cnt_input_fields := 1;
                                ta320set_infield (ex_in.input_params[ 1 ],
                                      sp1ot_mandatory, sp1io_input,
                                      dcha, mxsp_c8, 0, mxsp_c8+1, 1);
                                IF  upg.second_token = n_on
                                THEN (* usage on *)
                                    j := 4
                                ELSE
                                    IF  upg.second_token = n_add
                                    THEN (* usage add *)
                                        j := 3;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                FOR i := 2 TO j DO
                                    BEGIN
                                    ident_io_len := 1 +
                                          sizeof (tsp00_KnlIdentifier);
                                    ex_in.cnt_input_fields := i;
                                    ta320set_infield (ex_in.input_params[ i ],
                                          sp1ot_mandatory, sp1io_input, dcha,
                                          sizeof (tsp00_KnlIdentifier), 0,
                                          ident_io_len, 10+(i-2)*ident_io_len);
                                    END;
                                (*ENDFOR*) 
                                ta320get_data_input (upg, ex_in,
                                      snd_packet)
                                END
                            ELSE
                                IF  ((upg.first_token = n_drop) AND
                                    (upg.second_token = n_parseid))
                                    OR
                                    (upg.first_token = n_pdescribe)
                                THEN
                                    BEGIN
                                    IF  upg.first_token = n_pdescribe
                                    THEN
                                        WITH cmd_segm^ DO
                                            BEGIN
                                            sp1p_buf[ 1 ] := 'D';
                                            sp1p_buf[ 2 ] := 'E';
                                            sp1p_buf[ 3 ] := 'S';
                                            sp1p_buf[ 4 ] := 'C';
                                            sp1p_buf[ 5 ] := 'R';
                                            sp1p_buf[ 6 ] := 'I';
                                            sp1p_buf[ 7 ] := 'B';
                                            sp1p_buf[ 8 ] := 'E';
                                            (* PTS 1103485 E.Z. *)
                                            sp1p_buf[ 9 ] := ' ';
                                            sp1p_buf_len  := 9;
                                            IF  upg.term_simulation = tasim_unicode
                                            THEN
                                                (* Convert command to Unicode *)
                                                sp1p_buf_len := ta320ascii2unicode (upg,
                                                      @sp1p_buf[ 1 ],
                                                      sp1p_buf_len, sp1p_buf_size);
                                            (*ENDIF*) 
                                            END;
                                        (*ENDWITH*) 
                                    (*ENDIF*) 
                                    t09put20 (upg.term^, 'enter idnr:         ',
                                          cut_bright_protected);
                                    t09get (upg.term^, ln, upg.pfkey);
                                    i:= 1;
                                    ta320read_number (i, ln, idnr);
                                    dli.text   := upg.term^.blankline;
                                    dli.pos    := 0;
                                    dli.length := 1;
                                    t320string_to_line (in_idno_pars_msg,
                                          dli.text);
                                    dli.pos:= 19;
                                    g17int4to_line (idnr,
                                          NOT c_with_zero, 3, dli.pos,
                                          dli.text);
                                    dli.pos:= dli.pos + 3;
                                    dli.length:= dli.length + 3;
                                    t09put (upg.term^, dli.text,
                                          cut_protected);
                                    upg.prot.ln := dli.text;
                                    t320prot (upg, dli.pos);
                                    t320parseid_part (upg, snd_packet,
                                          cmd_segm^, upg.parsing[ idnr ])
                                    END
                                ELSE
                                    IF  (upg.first_token = n_delete ) OR
                                        (upg.first_token = n_mdelete) OR
                                        (upg.first_token = n_update ) OR
                                        (upg.first_token = n_mupdate)
                                    THEN
                                        (* PTS 1121518 E.Z. *)
                                        key_found := ta320token_in_cmd (
                                              upg, cmd_part^, 'KEY   ', 1, 4) OR
                                              ta320token_in_cmd (
                                              upg, cmd_part^, 'key   ', 1, 4) OR
                                              ta320token_in_cmd (
                                              upg, cmd_part^, 'Key   ', 1, 4);
                                    (*ENDIF*) 
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  (
        (
        (upg.first_token = cta_n_fetch   )   OR
        ((upg.first_token = n_mfetch ) AND
        ( upg.second_token <> n_rest))       OR
        (upg.first_token = n_rfetch  )       OR
        (upg.first_token = n_fetch1  )       OR
        (upg.first_token = n_fetchall)       OR
        (upg.first_token = cta_n_select  )   OR
        (upg.first_token = cta_n_declare )   OR
        (upg.first_token = cta_n_show    )   OR
        (upg.first_token = 'EXPLAIN     ')   OR
        (upg.first_token = 'DBPROC      ')   OR
        ((upg.first_token       = n_set) AND
        ( upg.second_token[ 1 ] = parameter_symbol))
        )
        (*
              AND
              (upg.execution <> tek_only_parsing)
              *)
        AND
        (upg.execution <> tek_only_executing)
        )
        OR
        (* PTS 1112770 E.Z. *)
        (upg.first_token = 'CALL        ')
        OR
        ((upg.second_token = n_column) AND
        ((upg.first_token = n_open  ) OR
        (upg.first_token = n_fread  ) OR
        (upg.first_token = n_fwrite ) OR
        (upg.first_token = 'COPY        ') OR
        (upg.first_token = 'READ        ') OR
        (upg.first_token = 'SEARCH      ') OR
        (upg.first_token = 'LENGTH      ')))
    THEN
        upg.info:= true;
    (*ENDIF*) 
    IF  
        (
        (upg.first_token = n_alter)        AND
        (
        ( upg.second_token = n_table) OR
        ( upg.second_token = n_index))
        ) OR
        (
        (upg.first_token  = n_rename)      AND
        (upg.second_token = n_table)
        ) OR
        (
        (upg.first_token = n_create)       AND
        (
        ( upg.second_token = n_index)   OR
        ( upg.second_token = n_synonym) OR
        ( upg.second_token = n_unique))
        ) OR
        (
        (upg.first_token  = n_create)      AND
        (upg.second_token = n_table)       AND
        (third            = n_references)
        ) OR
        (
        (upg.first_token = n_drop)         AND
        (upg.second_token = n_index)
        )
    THEN
        BEGIN
        upg.shared_sql_drop   := true;
        upg.shared_drop_trans := true;
        END;
    (*ENDIF*) 
    upg.inlength := 0;
    IF  (upg.first_token = n_priv) OR (upg.first_token = n_privileges)
    THEN
        BEGIN
        sqldattime (d, t);
        nam := bsp_name;
        pos := 0;
        FOR i := 1 TO TIME_MXSP00 DO
            BEGIN
            nam[ i ] := t[ i ];
            pos      := pos + ord(t[ i ]) - ord('0')
            END;
        (*ENDFOR*) 
&       ifdef TRACE
        t02name (debug_ta, nam);
&       endif
        s02applencrypt (nam, crypt);
        s26new_part_init (snd_packet, cmd_segm^, part2);
        WITH part2^ DO
            BEGIN
            sp1p_buf[ 1 ] := chr(pos);
            FOR i := 1 TO CRYPTPW_MXSP00 DO
                sp1p_buf[ i+1 ] := crypt[ i ];
            (*ENDFOR*) 
            sp1p_buf_len := CRYPTPW_MXSP00 + 1
            END;
        (*ENDWITH*) 
        t320finish_part (upg, snd_packet, part2^)
        END;
    (*ENDIF*) 
    IF  upg.first_token = n_store
    THEN
        BEGIN
        (* describe one dbproc parameter *)
        s26new_part_init (snd_packet, cmd_segm^, part2);
        WITH part2^ DO
            BEGIN
            SAPDB_PascalForcedFill (sp1p_buf_size, @sp1p_buf, 1,
                  NAME_MXSP00, bsp_c1);
            c8 := 'PARAM1  ';
            SAPDB_PascalForcedMove (sizeof (c8), sp1p_buf_size,
                  @c8, 1, @sp1p_buf, 1, sizeof (c8));
            ta320set_infield (field_info,
                  sp1ot_mandatory, sp1io_input,
                  dcha, 10, 0, 11, 1);
            SAPDB_PascalForcedMove (sizeof (field_info), sp1p_buf_size,
                  @field_info, 1, @sp1p_buf, NAME_MXSP00 + 1, sizeof (field_info));
            sp1p_buf_len := NAME_MXSP00 + sizeof(field_info)
            END;
        (*ENDWITH*) 
        t320finish_part (upg, snd_packet, part2^);
        END;
    (*ENDIF*) 
    IF  upg.pfkey = pf_none
    THEN
        BEGIN
        IF  (upg.execution <> tek_only_executing) AND
            (cmd_segm^.sp1p_part_kind = sp1pk_command)
        THEN (* the original cmd string may be overwritten by an parsid. *)
            BEGIN
            IF  (upg.bigcmd_offset > 0) AND
                (cmd_part^.sp1p_buf_size > upg.bigcmd_offset)
            THEN
                BEGIN
                SAPDB_PascalForcedMove (s26packet_len (snd_packet), sizeof (org_segment_buf),
                      @cmd_segm^, 1, @org_segment^, 1,
                      sizeof(tsp1_segment_header) + sizeof(tsp1_part_header));
                SAPDB_PascalForcedMove (s26packet_len (snd_packet), sizeof (org_segment_buf),
                      @cmd_segm^,
                      sizeof(tsp1_segment_header) + sizeof(tsp1_part_header) +
                      upg.bigcmd_offset + 1, @org_segment^,
                      sizeof(tsp1_segment_header) + sizeof(tsp1_part_header) + 1,
                      cmd_segm^.sp1s_segm_len -
                      sizeof(tsp1_segment_header) + sizeof(tsp1_part_header) -
                      upg.bigcmd_offset);
                org_segment^.sp1p_buf_len :=
                      cmd_segm^.sp1p_buf_len - upg.bigcmd_offset;
                org_segment^.sp1p_buf_size := sizeof(org_segment_buf);
                org_segment^.sp1s_segm_len:=
                      cmd_segm^.sp1s_segm_len - upg.bigcmd_offset;
                END
            ELSE
                BEGIN
                IF  cmd_segm^.sp1s_segm_len > sizeof (org_segment_buf)
                THEN
                    org_segment_len := sizeof (org_segment_buf)
                ELSE
                    org_segment_len := cmd_segm^.sp1s_segm_len;
                (*ENDIF*) 
                SAPDB_PascalForcedMove (s26packet_len (snd_packet), sizeof (org_segment_buf),
                      @cmd_segm^, 1, @org_segment^, 1, org_segment_len)
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        t09msgheader (upg.term^, msg_execute, false);
&       ifdef PARS
        m_ex_kind := upg.execution;
        IF  (upg.execution = tek_parsing_executing)
            AND
            (
            (upg.first_token = cta_n_select) OR
            (upg.first_token = cta_n_declare) OR
            (upg.first_token = n_insert) OR
            (upg.first_token = n_update) OR
            (upg.first_token = n_delete) OR
            (upg.first_token = n_fetch) OR
            (upg.first_token = n_fetch1) OR
            (upg.first_token = n_mfetch)
            )
        THEN
            upg.execution := tek_pars_then_execute;
&       endif
        (*ENDIF*) 
        t320dbcall (upg,
              snd_packet, rcv_packet, returncode, parseid, -1);
        IF  (returncode <> cut_sql_req_failed) AND
            (((returncode <> 0) AND (upg.pfkey = pf_none))
            OR (upg.sqlmode = sqlm_ansi))
        THEN
            IF  (upg.bigcmd_offset > 0) AND
                (cmd_part^.sp1p_buf_size > upg.bigcmd_offset) AND
                (upg.curr_ret_segm^.sp1r_errorpos > upg.bigcmd_offset)
            THEN
                ta320error_print (upg,
                      org_segment^, upg.curr_ret_segm^,
                      upg.curr_ret_segm^.sp1r_errorpos - upg.bigcmd_offset)
            ELSE
                ta320error_print (upg,
                      org_segment^, upg.curr_ret_segm^,
                      upg.curr_ret_segm^.sp1r_errorpos)
            (*ENDIF*) 
        ELSE
            IF  returncode = 0
            THEN
                ta320warning_print (upg, upg.curr_ret_segm^)
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (* PTS 1111575 E.Z. *)
&   ifdef trace
    (*ENDIF*) 
    t02int4 (debug_ta, 'upg.executio', ord(upg.execution));
&   endif
    IF  (returncode = 0) AND (NOT upg.stop) AND (upg.pfkey = pf_none) AND
        NOT (upg.execution in [ tek_only_parsing,
        tek_only_syntax ])
    THEN
        ta320results_print (upg, upg.curr_ret_segm^,
              org_segment^, snd_packet, key_found, parseid)
    ELSE
        upg.info:= false;
    (*ENDIF*) 
    IF  (NOT upg.stop) AND (upg.pfkey = pf_none)
        AND
        (upg.execution = tek_pars_then_execute) AND
        (ord (parseid[ c_p_info_pos ]) <> csp1_p_command_executed)
        AND
        ((upg.second_token <> n_release) OR
        ((upg.first_token <> n_commit) AND (upg.first_token <> n_rollback)))
    THEN
        t320drop_parseid (upg, snd_packet, parseid);
    (*ENDIF*) 
    IF  ((returncode <> 0) OR (upg.first_token = n_vtrace)) AND
        NOT upg.is_connected
    THEN
        BEGIN
&       ifdef trace
        t02int4 (debug_ta, 'ref (sqlrel)', upg.reference);
&       endif
        sqlarelease (upg.reference);
        snd_packet    := NIL;
        upg.reference := 0;
        ta320pop_session (upg.reference, upg.is_connected, upg.variable_input,
              snd_packet, rcv_packet, stack_rc);
        END
    ELSE
        IF  (returncode <> 0)
            AND
            (returncode <> -9000) (* compare vak93 *)
            AND
            (returncode <> -5015) (* compare vak93 *)
            AND
            (upg.first_token = n_commit)
        THEN
            BEGIN
&           ifdef trace
            t02int4 (debug_ta, 'ref (sqlrel)', upg.reference);
&           endif
            sqlarelease (upg.reference);
            snd_packet       := NIL;
            upg.reference    := 0;
            upg.is_connected := false;
            ta320pop_session (upg.reference, upg.is_connected, upg.variable_input,
                  snd_packet, rcv_packet, stack_rc);
            upg.code_type := csp_ascii;
            upg.right_header := msg_not_connected;
            t09header (upg.term^, upg.left_header, upg.right_header)
            END
        ELSE
            IF  (returncode = 0) AND (NOT upg.stop) AND (upg.pfkey = pf_none)
            THEN
                IF  upg.first_token = cta_n_connect
                THEN
                    BEGIN
                    upg.is_connected:= true;
                    FOR i:=1 TO SNAME_MXSP00 DO
                        upg.right_header[ i + 6 ]:= upg.second_token[ i ];
                    (*ENDFOR*) 
                    upg.right_header[ 19 ]:= ' ';
                    upg.right_header[ 20 ]:= ' ';
                    t09header (upg.term^, upg.left_header, upg.right_header);
                    upg.code_type := rcv_packet^.sp1_header.sp1h_mess_code;
                    s26find_part (rcv_packet^.sp1_segm , sp1pk_feature, feature_part);
                    IF  feature_part <> NIL
                    THEN
                        BEGIN
                        feature_cnt := feature_part^.sp1p_arg_count;
                        IF  feature_cnt * sizeof(tsp1_one_feature) > sizeof (features)
                        THEN
                            feature_cnt := sizeof(features) DIV sizeof(tsp1_one_feature);
                        (*ENDIF*) 
                        SAPDB_PascalForcedMove (feature_part^.sp1p_buf_size, sizeof(tsp1_features),
                              @feature_part^.sp1p_buf, 1,
                              @features, 1, feature_cnt * sizeof(tsp1_one_feature));
                        curr_feature := sp1f_nil_feature;
                        WHILE (curr_feature < sp1f_last_feature) AND
                              (ord(curr_feature) <= feature_cnt) DO
                            BEGIN
                            CASE features[curr_feature].of_feature OF
                                sp1f_variable_input :
                                    IF  features[curr_feature].of_value = 1
                                    THEN
                                        upg.variable_input := true;
                                    (*ENDIF*) 
                                sp1f_ascii_in_and_output:
                                    IF  features[curr_feature].of_value = 1
                                    THEN
                                        upg.ascii_in_output := true;
                                    (*ENDIF*) 
                                OTHERWISE
                                    BEGIN
                                    END;
                                END;
                            (*ENDCASE*) 
                            curr_feature := succ(curr_feature)
                            END;
                        (*ENDWHILE*) 
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    IF  ((upg.second_token = n_work) AND (third = n_release)) OR
                        (upg.second_token = n_release)
                    THEN
                        BEGIN
&                       ifdef trace
                        t02int4 (debug_ta, 'ref (sqlrel)', upg.reference);
&                       endif
                        sqlarelease (upg.reference);
                        snd_packet    := NIL;
                        upg.reference := 0;
                        upg.is_connected := false;
                        upg.variable_input := false;
                        ta320pop_session (upg.reference, upg.is_connected, upg.variable_input,
                              snd_packet, rcv_packet, stack_rc);
                        upg.code_type := csp_ascii;
                        upg.right_header := msg_not_connected;
                        t09header (upg.term^, upg.left_header, upg.right_header)
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
&ifdef PARS
(*ENDIF*) 
upg.execution := m_ex_kind;
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320tablename (
            VAR upg      : tta_user_proc_globals;
            VAR ret_segm : tsp1_segment);
 
VAR
      tablename_part : tsp1_part_ptr;
      ln             : tsp00_Line;
      i              : tsp00_Int4;
 
BEGIN
s26find_part (ret_segm, sp1pk_tablename, tablename_part);
IF  tablename_part <> NIL
THEN
    BEGIN
    upg.pfkey := pf_none;
    t320string_to_line (tablename_msg, ln);
    i := tablename_part^.sp1p_buf_len;
    IF  upg.term_simulation = tasim_unicode
    THEN (* Convert the tablename to ascii. *)
        WITH tablename_part^ DO
            t320unicode2ascii (upg, sp1p_buf_size, @sp1p_buf, i);
        (*ENDWITH*) 
    (*ENDIF*) 
    SAPDB_PascalForcedMove (tablename_part^.sp1p_buf_size, sizeof (ln),
          @tablename_part^.sp1p_buf, 1, @ln, 16,
          tablename_part^.sp1p_buf_len);
    t09put (upg.term^, ln, cut_protected);
    t12write_prot (upg.prot.refer, ln,
          16+tablename_part^.sp1p_buf_len, i);
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320error_print (
            VAR upg      : tta_user_proc_globals;
            VAR cmd_segm : tsp1_segment;
            VAR ret_segm : tsp1_segment;
            err_pos      : tsp00_Int4);
 
VAR
      errortext_part : tsp1_part_ptr;
 
BEGIN
ta320warning_print (upg, upg.curr_ret_segm^);
t320errmsg (upg, ret_segm);
IF  (ret_segm.sp1r_returncode <> 0) AND
    (upg.pfkey = pf_none)           AND
    upg.long_errmsg                 AND
    (upg.execution in [ tek_only_parsing, tek_parsing_executing ])
THEN
    BEGIN
    s26find_part (ret_segm, sp1pk_errortext, errortext_part);
    IF  errortext_part <> NIL
    THEN
        ta320error_pos_display (upg, cmd_segm, err_pos)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ta320env_found (
            env_name      : tsp00_Identifier;
            VAR env_value : tsp00_VFilename) : boolean;
 
VAR
      env_found : boolean;
      aux       : tsp00_VFilename;
 
BEGIN
&ifdef trace
t02name (debug_ta, env_name);
&endif
SAPDB_PascalForcedFill (sizeof (aux), @aux, 1, sizeof (aux), bsp_c1);
SAPDB_PascalForcedMove (sizeof (env_name), sizeof (aux),
      @env_name, 1, @aux, 1, sizeof (env_name));
sqlgetenv (aux, env_value, env_found);
ta320env_found := env_found
&     ifdef trace
      ;
t02int4 (debug_ta, 'found       ', ord (env_found));
t02vffn (debug_ta, 'env_value   ', env_value)
&     endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320fileinfo_print (VAR upg : tta_user_proc_globals);
 
CONST
      c_mx_lineno = 10;
 
VAR
      len : integer;
      i   : integer;
      ln  : tsp00_Line;
 
BEGIN
WITH upg, term^ DO
    IF  (curr_inputfile > 0)
    THEN
        BEGIN
        ln  := upg.term^.blankline;
        len := s30lnr (inputfn[curr_inputfile],
              bsp_c1, 1, sizeof(inputfn[curr_inputfile]));
        IF  len > (sizeof(ln) - c_mx_lineno - 1)
        THEN
            len := (sizeof(ln) - c_mx_lineno - 1);
        (*ENDIF*) 
        FOR i := 1 TO len DO
            ln[i] := inputfn[curr_inputfile][i];
        (*ENDFOR*) 
        g17int4to_line (inputfilpos[curr_inputfile],
              NOT c_with_zero, c_mx_lineno, len + 2, ln);
        t09putmsg (upg.term^, ln, true, true);
        upg.prot.ln := ln;
        t320prot (upg, sizeof (upg.prot.ln));
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320warning_print (
            VAR upg      : tta_user_proc_globals;
            VAR ret_segm : tsp1_segment);
 
VAR
      ln  : tsp00_Line;
      s40 : tsp00_C40;
      i   : integer;
 
BEGIN
IF  warn15_user_defined_code in ret_segm.sp1r_extern_warning
THEN
    BEGIN
    ln  := upg.term^.blankline;
    IF  (upg.first_token = cta_n_select)  OR
        (upg.first_token = cta_n_declare) OR
        (upg.first_token = n_mselect)     OR
        (upg.first_token = n_mdeclare)    OR
        (upg.first_token = 'EXPLAIN     ')
    THEN
        s40 := '*** QUERYREWRITE ROLLBACK               '
    ELSE
        s40 := '*** USER DEFINED RETURN CODE            ';
    (*ENDIF*) 
    FOR i := 1 TO mxsp_c40 DO
        ln[ i ] := s40[ i ];
    (*ENDFOR*) 
    t09putmsg (upg.term^, ln, true, true);
    upg.prot.ln := upg.term^.blankline;
    t320prot (upg, 1);
    upg.prot.ln := ln;
    t320prot (upg,  sizeof (upg.prot.ln))
    END;
(*ENDIF*) 
IF  warn10_views_substituted in ret_segm.sp1r_extern_warning
THEN
    BEGIN
    ln  := upg.term^.blankline;
    s40 := '*** VIEWS SUBSTITUTED BY FROMSELECTS    ';
    FOR i := 1 TO mxsp_c40 DO
        ln[ i ] := s40[ i ];
    (*ENDFOR*) 
    t09putmsg (upg.term^, ln, true, true);
    upg.prot.ln := upg.term^.blankline;
    t320prot (upg, 1);
    upg.prot.ln := ln;
    t320prot (upg,  sizeof (upg.prot.ln))
    END;
(*ENDIF*) 
IF  warn9_stmt_optimized in ret_segm.sp1r_extern_warning
THEN
    BEGIN
    ln  := upg.term^.blankline;
    s40 := '*** SQLSTATEMENT HAS BEEN OPTIMIZED     ';
    FOR i := 1 TO mxsp_c40 DO
        ln[ i ] := s40[ i ];
    (*ENDFOR*) 
    t09putmsg (upg.term^, ln, true, true);
    upg.prot.ln := upg.term^.blankline;
    t320prot (upg, 1);
    upg.prot.ln := ln;
    t320prot (upg,  sizeof (upg.prot.ln))
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320results_print (
            VAR upg      : tta_user_proc_globals;
            VAR ret_segm : tsp1_segment;
            VAR org_segm : tsp1_segment;
            snd_packet   : tsp1_packet_ptr;
            key_found    : boolean;
            VAR parseid  : tsp00_C12);
 
VAR
      data_ptr : tsp1_part_ptr;
      ln       : tsp00_Line;
 
BEGIN
IF  (upg.first_token     = n_set)            AND
    (upg.second_token[1] = parameter_symbol) AND
    (upg.execution       <> tek_only_executing)
THEN
    BEGIN
    t340get1handler (upg, ret_segm);
    upg.info:= false
    END
ELSE
    IF  (upg.first_token = cta_n_fetch) AND
        (upg.execution <> tek_only_executing)
    THEN
        IF  upg.second_token = cta_n_show
        THEN
            t340showresults (upg, ret_segm, snd_packet,
                  parseid)
        ELSE
            BEGIN
            IF  upg.execution <> tek_pars_then_execute
            THEN
                upg.inlength := 0;
            (*ENDIF*) 
            IF  ret_segm.sp1r_function_code in [
                csp1_fetch_first_fc, csp1_fetch_last_fc,
                csp1_fetch_pos_fc,   csp1_fetch_same_fc,
                csp1_fetch_relative_fc ]
            THEN
                t340get1handler (upg, ret_segm)
            ELSE
                t340fetchhandler (upg, ret_segm,
                      org_segm, snd_packet, parseid);
            (*ENDIF*) 
            upg.info := false
            END
        (*ENDIF*) 
    ELSE
        IF  (upg.first_token = n_fetch1) AND
            (upg.execution <> tek_only_executing)
        THEN
            BEGIN
            t340get1handler (upg, ret_segm);
            upg.info:= false
            END
        ELSE
            IF  (upg.execution <> tek_only_executing) AND
                (ret_segm.sp1r_function_code in [ csp1_mfetch_first_fc,
                csp1_mfetch_last_fc, csp1_mfetch_next_fc,
                csp1_mfetch_prev_fc, csp1_mfetch_pos_fc,
                csp1_mfetch_same_fc, csp1_mselect_into_fc ])
            THEN
                BEGIN
                IF  (upg.first_token = n_fetchall) AND
                    (upg.execution <> tek_pars_then_execute)
                THEN
                    upg.inlength := 0;
                (*ENDIF*) 
                t340mfetchhandler (upg, ret_segm);
                upg.info:= false
                END
            ELSE
                BEGIN
                IF  (upg.first_token = cta_n_select)   OR
                    (upg.first_token = cta_n_declare)  OR
                    (upg.first_token = n_check)        OR
                    (upg.first_token = n_force)        OR
                    (upg.first_token = 'DBPROC      ')
                THEN
                    IF  ( upg.first_token  = 'DBPROC      ')  OR
                        ((upg.first_token  = n_check) AND
                        ( upg.second_token = 'DATABASE    ')) OR
                        ((upg.first_token  = n_force) AND
                        ( upg.second_token = 'CHECKPOINT  ')) OR
                        (ret_segm.sp1r_function_code in [
                        csp1_select_direct_fc, csp1_select_next_fc,
                        csp1_select_prev_fc,   csp1_select_first_fc,
                        csp1_select_last_fc,   csp1_select_into_fc ])
                    THEN
                        BEGIN
                        s26find_part (ret_segm, sp1pk_data, data_ptr);
                        IF  (upg.execution <> tek_only_executing)
                            AND
                            (data_ptr <> NIL)
                        THEN
                            IF  data_ptr^.sp1p_buf_len > 0
                            THEN
                                t340gethandler (upg, snd_packet, ret_segm);
                            (*ENDIF*) 
                        (*ENDIF*) 
                        upg.info:= false
                        END
                    ELSE
                        BEGIN
                        (* PTS 1105196 E.Z. *)
                        IF  (upg.execution <> tek_pars_then_execute) AND
                            (upg.execution <> tek_only_executing)
                        THEN
                            upg.inlength := 0;
                        (*ENDIF*) 
                        t340printresultcount (upg, ret_segm);
                        s26find_part (ret_segm, sp1pk_data, data_ptr);
                        (* PTS 1105196 E.Z. *)
                        IF  data_ptr <> NIL
                        THEN
                            t340mfetchhandler (upg, ret_segm);
                        (*ENDIF*) 
                        upg.info := false
                        END
                    (*ENDIF*) 
                ELSE
                    IF  (upg.first_token = n_mdeclare)
                        OR
                        ((upg.first_token = n_minsert) AND
                        (ret_segm.sp1r_function_code in
                        [ csp1_insert_fc, csp1_minsert_fc ]))
                        OR
                        (ret_segm.sp1r_function_code = csp1_mselect_fc)
                        OR
                        ((ret_segm.sp1r_function_code in [
                        csp1_update_fc, csp1_mupdate_fc,
                        csp1_delete_fc, csp1_mdelete_fc,
                        csp1_mlock_objects_fc ])
                        AND NOT key_found)
                    THEN
                        t340printresultcount (upg, ret_segm)
                    ELSE
                        IF  (ret_segm.sp1r_function_code in [
                            csp1_explain_fc ])  AND
                            (upg.second_token <> cta_n_fetch) AND
                            (upg.first_token  <> n_check)
                        THEN
                            IF  upg.second_token = '%ERSION     '
                            THEN
                                BEGIN
                                upg.prot.ln := upg.term^.blankline;
                                t320prot (upg, 1);
                                t09newscreen_page (upg.term^);
                                ln := upg.term^.blankline;
                                SAPDB_PascalForcedMove (ret_segm.sp1p_buf_size,
                                      sizeof (ln), @ret_segm.sp1p_buf,
                                      ret_segm.sp1p_buf_len+1,
                                      @ln, 1, 40);
                                t09put (upg.term^, ln, cut_protected);
                                upg.prot.ln := ln;
                                t320prot (upg, 40);
                                t09holding (upg.term^, upg.pfkey)
                                END
                            ELSE
                                BEGIN
                                t340showresults (upg,
                                      ret_segm, snd_packet,
                                      parseid);
                                upg.info:= false
                                END
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320read_password (
            VAR upg      : tta_user_proc_globals;
            snd_packet   : tsp1_packet_ptr;
            VAR cmd_segm : tsp1_segment;
            VAR cmd_part : tsp1_part;
            VAR token3   : tsp00_Sname);
 
VAR
      is_sql_mode   : boolean;
      found         : boolean;
      i             : integer;
      pos           : integer;
      token_cnt     : integer;
      len_incl_user : integer;
      len_incl_pw   : integer;
      len_until_pw  : integer;
      password      : tsp00_Name;
      token         : tsp00_Name;
      pw_crypt      : tsp00_CryptPw;
      uni_pw_len    : tsp00_Int4;
      li            : tsp00_Line;
      data_part     : tsp1_part_ptr;
      s24           : tsp00_C24;
      dblang        : tsp00_Identifier;
      env_name      : tsp00_VFilename;
      env_value     : tsp00_VFilename;
      env_found     : boolean;
 
BEGIN
&ifdef trace
t02name   (debug_ta, 'connect packet 1->');
IF  t02trace (debug_ta)
THEN
    x05packet (upg.term^, upg.prot.refer, t02is_minbuf,
          t02buflength_max, 'snd_packet  ', snd_packet);
&endif
(*ENDIF*) 
upg.pfkey := pf_none;
found     := false;
password  := bsp_name;
WITH cmd_part DO
    FOR i:= 1 TO sp1p_buf_len DO
        IF  sp1p_buf[ i ] = ':'
        THEN
            found := true;
        (*ENDIF*) 
    (*ENDFOR*) 
(*ENDWITH*) 
IF  found
THEN
    BEGIN
    t09put (upg.term^, upg.term^.blankline, cut_protected);
    t09get1name (upg.term^, enter_pw_msg, cut_protected, cut_invisible,
          NAME_MXSP00, false, password, upg.pfkey);
    IF  upg.pfkey = pf_none
    THEN
        li := upg.term^.blankline;
    (*ENDIF*) 
    END;
(*ENDIF*) 
WITH cmd_part DO
    BEGIN
    pos         := 1;
    is_sql_mode := false;
    upg.sqlmode := sqlm_internal;
    WHILE pos < sp1p_buf_len DO
        BEGIN
        token := bsp_name;
        WHILE (pos <= sp1p_buf_len) AND (sp1p_buf[ pos ] = ' ') DO
            pos := succ (pos);
        (*ENDWHILE*) 
        i := 1;
        WHILE (pos <= sp1p_buf_len) AND (sp1p_buf[ pos ] <> ' ') DO
            BEGIN
            IF  i <= NAME_MXSP00
            THEN
                BEGIN
                token[ i ] := sp1p_buf[ pos ];
                i          := succ (i)
                END;
            (*ENDIF*) 
            pos := succ (pos)
            END;
        (*ENDWHILE*) 
        IF  i <= NAME_MXSP00
        THEN
            BEGIN
            (* PTS 1121518 E.Z. *)
            FOR i := 1 TO NAME_MXSP00 DO
                IF  token[ i ] in [ 'a'..'i', 'j'..'r', 's'..'z' ]
                THEN
                    token[ i ] := chr(ord(token[ i ]) - ord('a') + ord('A'));
                (*ENDIF*) 
            (*ENDFOR*) 
            IF  token = 'SQLMODE           '
            THEN
                is_sql_mode := true
            ELSE
                IF  is_sql_mode
                THEN
                    IF  token = 'SQL-DB            '
                    THEN
                        upg.sqlmode := sqlm_internal
                    ELSE
                        IF  token = 'ANSI              '
                        THEN
                            upg.sqlmode := sqlm_ansi
                        ELSE
                            IF  token = 'ORACLE            '
                            THEN
                                upg.sqlmode := sqlm_oracle
                            ELSE
                                IF  token = 'DB2               '
                                THEN
                                    upg.sqlmode := sqlm_db2;
                                (* PTS 1121518 E.Z. *)
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  token3 = n_identi
    THEN
        token_cnt := 5
    ELSE
        token_cnt := 3;
    (*ENDIF*) 
    IF  sp1p_buf[ sp1p_buf_len ] = command_delimiter
    THEN
        sp1p_buf_len := pred (sp1p_buf_len);
    (*ENDIF*) 
    len_incl_pw := 1;
    (* skip 'CONNECT' ... *)
    FOR i := 1 TO token_cnt DO
        BEGIN
        WHILE (len_incl_pw <= sp1p_buf_len) AND
              (sp1p_buf[ len_incl_pw ] = ' ') DO
            len_incl_pw := succ (len_incl_pw);
        (*ENDWHILE*) 
        IF  i = token_cnt
        THEN
            len_until_pw := pred (len_incl_pw);
        (*ENDIF*) 
        WHILE (len_incl_pw <= sp1p_buf_len) AND
              (sp1p_buf[ len_incl_pw ] <> ' ') DO
            len_incl_pw := succ (len_incl_pw);
        (*ENDWHILE*) 
        IF  i = 2
        THEN
            len_incl_user := pred (len_incl_pw);
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    len_incl_pw := pred (len_incl_pw);
    i := 1;
    WHILE (len_until_pw + i <= len_incl_pw) AND
          (i <= NAME_MXSP00) DO
        BEGIN
        IF  NOT found
        THEN
            (* PTS 1121518 E.Z. *)
            IF  sp1p_buf[ len_until_pw+i ] in [ 'a'..'i', 'j'..'r', 's'..'z' ]
            THEN
                password[ i ] := chr(ord(sp1p_buf[ len_until_pw+i ]) - ord('a') + ord('A'))
            ELSE
                password[ i ] := sp1p_buf[ len_until_pw+i ];
            (*ENDIF*) 
        (*ENDIF*) 
        sp1p_buf[ len_until_pw+i ] := ' ';
        i := i + 1
        END;
    (*ENDWHILE*) 
    ta320remove_double_quotes (password);
    IF  i <= 2
    THEN
        BEGIN
        FOR i := sp1p_buf_len DOWNTO len_incl_pw + 1 DO
            sp1p_buf[ i+2 ] := sp1p_buf[ i ];
        (*ENDFOR*) 
        sp1p_buf[ len_incl_pw+1 ] := ' ';
        sp1p_buf[ len_incl_pw+2 ] := ' ';
        sp1p_buf_len              := sp1p_buf_len + 2
        END;
    (*ENDIF*) 
    IF  token3 <> n_identi
    THEN
        BEGIN
        s24 := ' IDENTIFIED BY          ';
        SAPDB_PascalForcedMove (sizeof (s24), sp1p_buf_size,
              @s24, 1, @sp1p_buf, len_incl_user + 1, 18);
        len_until_pw := len_incl_user + 15;
        sp1p_buf_len := len_until_pw  + 3
        END;
    (*ENDIF*) 
    sp1p_buf[ len_until_pw+1 ] := ':';
    sp1p_buf[ len_until_pw+2 ] := 'X';
    CASE  upg.term_simulation OF
        tasim_unicode: (* Convert the password to Unicode *)
            uni_pw_len := ta320ascii2unicode (upg, @password,
                  sizeof (password) DIV 2, sizeof (password));
        OTHERWISE;
        END;
    (*ENDCASE*) 
    (*
          IF  upg.term_simulation = tasim_unicode
          THEN
          BEGIN ( * We connect with Unicode as Characterset. * )
          s24 := ' CHARACTER SET UCS_2    ';
          SAPDB_PascalForcedMove (sizeof (s24), sp1p_buf_size,
          @s24, 1, @sp1p_buf, sp1p_buf_len+1, 22);
          sp1p_buf_len := sp1p_buf_len + 22
          END
          ELSE
          BEGIN ( * If DBLANG is set, connect with the given Characterset. * )
          dblang := c_dblang;
          SAPDB_PascalForcedFill (sizeof (env_name), @env_name, 1, sizeof (env_name), bsp_c1);
          SAPDB_PascalForcedMove (sizeof (dblang), sizeof (env_name),
          dblang, 1, env_name, 1, sizeof (dblang));
          sqlgetenv (env_name, env_value, env_found);
          IF  env_found AND (env_value <> upg.term^.blankfilename)
          THEN
          BEGIN
          s24 := ' CHARACTER SET          ';
          SAPDB_PascalForcedMove (sizeof (s24), sp1p_buf_size,
          s24, 1, sp1p_buf, sp1p_buf_len+1, 15);
          sp1p_buf_len := sp1p_buf_len + 15;
          SAPDB_PascalForcedMove  (sizeof (env_value), sp1p_buf_size,
          env_value, 1, sp1p_buf, sp1p_buf_len+1, sizeof (env_value));
          sp1p_buf_len := sp1p_buf_len + s30lnr1 (sp1p_buf,
          bsp_c1, sp1p_buf_len+1, sizeof (env_value))
          END
          END
          *)
    END;
(*ENDWITH*) 
&ifdef trace
t02name   (debug_ta, 'connect packet 2->');
IF  t02trace (debug_ta)
THEN
    x05packet (upg.term^, upg.prot.refer, t02is_minbuf,
          t02buflength_max, 'snd_packet  ', snd_packet);
&endif
(*ENDIF*) 
t320finish_part (upg, snd_packet, cmd_part);
s02applencrypt (password, pw_crypt);
s26new_part_init (snd_packet, cmd_segm, data_part);
WITH data_part^ DO
    BEGIN
    sp1p_buf_len  := 1 + CRYPTPW_MXSP00;
    sp1p_buf[ 1 ] := csp_defined_byte;
    SAPDB_PascalForcedMove (sizeof(pw_crypt), sp1p_buf_size,
          @pw_crypt, 1, @sp1p_buf, 2, CRYPTPW_MXSP00);
    sp1p_buf[ sp1p_buf_len+1 ] := bsp_c1;
    SAPDB_PascalForcedMove (sizeof (upg.termid), sp1p_buf_size, @upg.termid, 1,
          @sp1p_buf, sp1p_buf_len+2, TERMID_MXSP00);
    sp1p_buf_len := sp1p_buf_len + 1 + TERMID_MXSP00
    END;
(*ENDWITH*) 
t320finish_part (upg, snd_packet, data_part^);
&ifdef trace
t02name   (debug_ta, 'connect packet 3->');
IF  t02trace (debug_ta)
THEN
    x05packet (upg.term^, upg.prot.refer, t02is_minbuf,
          t02buflength_max, 'snd_packet  ', snd_packet);
&endif
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320read_format (
            VAR upg  : tta_user_proc_globals;
            VAR lpos : integer;
            VAR ln   : tsp00_Line;
            VAR typ  : char;
            VAR len1 : integer;
            VAR len2 : integer);
 
VAR
      l : tsp00_Line;
 
BEGIN
WHILE ((ln[ lpos ] = ' ') AND (lpos < LINE_MXSP00)) DO
    lpos := succ(lpos);
(*ENDWHILE*) 
IF  lpos < LINE_MXSP00
THEN
    typ := ln[ lpos ]
ELSE
    typ := ' ';
(*ENDIF*) 
lpos := succ(lpos);
CASE typ OF
    'B', 'b' :
        BEGIN
        typ  := 'B';
        len2 := 0;
        ta320read_number (lpos,ln,len1)
        END;
    'C', 'c' :
        BEGIN
        typ  := 'C';
        len2 := 0;
        ta320read_number (lpos,ln,len1)
        END;
    'D', 'd' :
        BEGIN
        typ  := 'D';
        len1 := 0;
        len2 := 0
        END;
    'E', 'e' :
        BEGIN
        typ  := 'E';
        len2 := 0;
        ta320read_number (lpos,ln,len1)
        END;
    'F', 'f' :
        BEGIN
        typ  := 'F';
        len2 := 0;
        ta320read_number (lpos,ln,len1)
        END;
    'I', 'i' :
        BEGIN
        typ  := 'I';
        len2 := 0;
        ta320read_number (lpos,ln,len1)
        END;
    'L', 'l' :
        BEGIN
        typ := 'L';
        ta320read_number (lpos,ln,len1);
        IF  ln [ lpos ] = ','
        THEN
            BEGIN
            lpos := succ(lpos);
            ta320read_number (lpos,ln,len2)
            END
        ELSE
            len2 := 1 (*vm_alldata*)
        (*ENDIF*) 
        END;
    'M', 'm' :
        BEGIN
        typ  := 'M';
        len1 := 0;
        len2 := 0
        END;
    'N', 'n' :
        BEGIN
        typ := 'N';
        ta320read_number (lpos,ln,len1);
        IF  ln [ lpos ] = ','
        THEN
            BEGIN
            lpos := succ(lpos);
            ta320read_number (lpos,ln,len2)
            END
        ELSE
            len2 := 0
        (*ENDIF*) 
        END;
    'P', 'p' : (* password -> to be crypted *)
        BEGIN
        typ  := 'P';
        len1 := NAME_MXSP00;
        len2 := 0
        END;
    'S', 's' :
        BEGIN
        typ  := 'S';
        len2 := 0;
        ta320read_number (lpos,ln,len1)
        END;
    'T', 't' :
        BEGIN
        typ  := 'T';
        len1 := 0;
        len2 := 0
        END;
    'V', 'v' :
        BEGIN
        typ  := 'V';
        len2 := 0;
        ta320read_number (lpos,ln,len1)
        END;
    OTHERWISE
        BEGIN
        typ:= ' ';
        t320string_to_line (msg_wrong_format, l);
        t09put (upg.term^, l, cut_protected);
        upg.prot.ln := l;
        t320prot (upg, 40)
        END
    END
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320read_number (
            VAR lpos  : integer;
            VAR ln  : tsp00_Line;
            VAR int : integer);
 
VAR
      vz    : boolean;
      ready : boolean;
 
BEGIN
int   := 0;
vz    := true;
ready := false;
WHILE (lpos <= LINE_MXSP00) AND NOT ready DO
    IF  ln [ lpos ] <> ' '
    THEN
        ready := true
    ELSE
        lpos := succ (lpos);
    (*ENDIF*) 
(*ENDWHILE*) 
IF  lpos <= LINE_MXSP00
THEN
    IF  ln[ lpos ] = '('
    THEN
        lpos := succ (lpos);
    (*ENDIF*) 
(*ENDIF*) 
IF  lpos < LINE_MXSP00
THEN
    BEGIN
    IF  ln[ lpos ] = '-'
    THEN
        BEGIN
        vz   := false;
        lpos := succ (lpos)
        END
    ELSE
        IF  ln[ lpos ] = '+'
        THEN
            lpos := succ (lpos);
        (*ENDIF*) 
    (*ENDIF*) 
    ready := false;
    WHILE (lpos <= LINE_MXSP00) AND NOT ready DO
        IF  (ln[ lpos ] >= '0') AND (ln[ lpos ] <= '9')
        THEN
            BEGIN
            int  := int*10 + ord (ln[ lpos ]) - ord ('0');
            lpos := succ (lpos)
            END
        ELSE
            ready := true;
        (*ENDIF*) 
    (*ENDWHILE*) 
    IF  NOT vz
    THEN
        int := -int
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320skipbl (
            VAR cd : tsp00_Line;
            VAR i : integer);
 
BEGIN
WHILE ((i < LINE_MXSP00) AND (cd[ i ] = ' ')) DO
    i:= i+1
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320dat_case (
            VAR upg          : tta_user_proc_globals;
            snd_packet       : tsp1_packet_ptr;
            VAR lpos         : integer;
            VAR ln           : tsp00_Line;
            VAR ex_in        : tta_ex_in;
            input_field      : integer;
            masscmd          : boolean;
            VAR data_part    : tsp1_part;
            data_offset      : tsp00_Int4;
            VAR long_offset  : tsp00_Int4);
 
CONST
      lsState_offset = 25;
      valmode_offset = 27;
      valind_offset  = 28;
      valpos_offset  = 32;
      vallen_offset  = 36;
 
VAR
      ok          : boolean;
      default     : boolean;
      is_null     : boolean;
      ldState     : tsp00_LdState;
      curr_len    : integer;
      len1        : integer;
      len2        : integer;
      si          : integer;
      nl          : integer;
      i           : integer;
      j           : integer;
      diff        : integer;
      old_lpos    : integer;
      typ         : char;
      delimiter   : char;
      i2c2        : tsp_int_map_c2;
      p           : tsp00_MoveObjPtr;
      num         : tsp00_NumStr;
      res         : tsp00_NumError;
      invalid     : boolean;
      undef_len   : boolean;
      pw_clear    : tsp00_Name;
      pw_crypt    : tsp00_CryptPw;
      new_pos     : tsp00_Int4;
      val_pos     : tsp00_Int4;
      curr_offset : tsp00_Int4;
      ic2         : tsp00_IntMapC2;
&     ifdef TRACE
      s30         : tsp00_C30;
&     endif
 
BEGIN
ta320read_format (upg, lpos, ln, typ, len1, len2);
WITH data_part, ex_in.input_params[ input_field ] DO
    BEGIN
    default := false;
    is_null := false;
    curr_len := 0;
    IF  upg.variable_input
    THEN
        BEGIN
        undef_len := false;
        IF  data_part.sp1p_part_kind = sp1pk_longdata
        THEN
            new_pos :=  (input_field-1) * (LONG_DESC_MXSP00 + 1) + 1
        ELSE
            new_pos := sp1p_buf_len + 1
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        undef_len := sp1i_bufpos < 0;
        IF  undef_len
        THEN
            new_pos := sp1p_buf_len + 1
        ELSE
            new_pos := sp1i_bufpos + data_offset;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    CASE typ OF
        'B' :
            BEGIN
            REPEAT
                lpos := succ(lpos)
            UNTIL
                ((lpos = LINE_MXSP00) OR (ln[ lpos ] <> ' '));
            (*ENDREPEAT*) 
            nl := lpos;
            REPEAT
                nl := succ(nl)
            UNTIL
                ((lpos = LINE_MXSP00) OR (ln[ nl ] = ' '));
            (*ENDREPEAT*) 
            nl := nl-lpos;
            IF  nl MOD 2 = 1
            THEN
                nl := nl - 1;
            (*ENDIF*) 
            si := len1;
            IF  upg.variable_input
            THEN
                BEGIN
                curr_len := nl DIV 2;
                IF  curr_len > c_maxonebytelength
                THEN
                    val_pos := new_pos + 3
                ELSE
                    val_pos := succ(new_pos);
                (*ENDIF*) 
                END
            ELSE
                val_pos := succ(new_pos);
            (*ENDIF*) 
            s41pbyte (sp1p_buf, val_pos, si, ln, lpos, nl, invalid);
            IF  invalid OR (nl <= 0)
            THEN
                BEGIN
                sp1p_buf[ new_pos ]:= csp_undef_byte;
                curr_len := 0;
                is_null := true
                END
            ELSE
                IF  sp1i_data_type in [ dcha, dvarchara ]
                THEN
                    sp1p_buf[ new_pos ]:= ' '
                ELSE
                    sp1p_buf[ new_pos ]:= csp_defined_byte;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  NOT upg.variable_input
            THEN
                BEGIN
                IF  undef_len
                THEN
                    FOR j := si + 1 TO len1 DO
                        sp1p_buf[ new_pos + j ] := csp_defined_byte
                    (*ENDFOR*) 
                ELSE
                    FOR j := si + 1 TO sp1i_in_out_len-1 DO
                        sp1p_buf[ new_pos + j ] := sp1p_buf[ new_pos ];
                    (*ENDFOR*) 
                (*ENDIF*) 
                IF  undef_len
                THEN
                    sp1p_buf_len := sp1p_buf_len + len1 + 1
                ELSE
                    IF  new_pos > sp1p_buf_len
                    THEN
                        IF  sp1i_length > 0
                        THEN
                            BEGIN
                            curr_len := sp1i_in_out_len - 1;
                            sp1p_buf_len := new_pos + sp1i_in_out_len - 1
                            END
                        ELSE
                            sp1p_buf_len := new_pos + len1;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (* das hier stimmt fuer variablen Input noch nicht *)
            (*ENDIF*) 
            IF  (upg.term_simulation = tasim_unicode)   AND
                NOT (sp1i_data_type in [ dchb, dunicode, dvarcharuni,
                dstrb, dstruni, dlongb, dlonguni, dboolean ]) AND
                (NOT (sp1i_data_type in [ dcha, dvarchara, dstra, dlonga, ddate, dtime, dtimestamp ])
                OR NOT upg.ascii_in_output) AND
                NOT undef_len AND (sp1i_length > 0)
            THEN
                curr_len := ta320ascii2unicode (upg,
                      @sp1p_buf[ val_pos ],
                      curr_len, sp1p_buf_size);
            (*ENDIF*) 
            IF  upg.variable_input
            THEN
                sp1p_buf_len := val_pos + curr_len - 1;
            (*ENDIF*) 
            lpos := lpos + nl
            END;
        'C', 'P', 'E' :
            BEGIN
            REPEAT
                lpos := succ (lpos)
            UNTIL
                (ln[ lpos ] = string_delimiter) OR
                (ln[ lpos ] = double_quote)     OR
                (lpos = LINE_MXSP00);
            (*ENDREPEAT*) 
            IF  (lpos < LINE_MXSP00) AND (len1 > 0)
            THEN
                BEGIN
                delimiter := ln[ lpos ];
                lpos      := succ(lpos);
                IF  upg.variable_input
                THEN
                    BEGIN
                    old_lpos := lpos;
                    WHILE ln[ lpos ] <> delimiter DO
                        lpos := succ(lpos);
                    (*ENDWHILE*) 
                    curr_len := lpos - old_lpos;
                    lpos := old_lpos;
                    IF  typ = 'E'
                    THEN
                        curr_len := len1;
                    (*ENDIF*) 
                    IF  (sp1i_data_type in [dunicode, dvarcharuni]) OR
                        ((upg.term_simulation = tasim_unicode) AND
                        (NOT (sp1i_data_type in [ dcha, dvarchara, dstra, dlonga, ddate, dtime, dtimestamp ])
                        OR NOT upg.ascii_in_output) AND
                        (delimiter = string_delimiter))
                    THEN
                        curr_len := curr_len * 2;
                    (*ENDIF*) 
                    IF  curr_len > c_maxonebytelength
                    THEN
                        val_pos := new_pos + 2
                    ELSE
                        val_pos := new_pos;
                    (*ENDIF*) 
                    END
                ELSE
                    val_pos := new_pos;
                (*ENDIF*) 
                i         := 0;
                IF  sp1i_data_type in [dunicode, dvarcharuni]
                THEN
                    BEGIN
                    sp1p_buf[ val_pos ] := csp_unicode_def_byte;
                    WHILE ln[ lpos ] <> delimiter DO
                        BEGIN
                        IF  (snd_packet^.sp1_header.sp1h_mess_swap = sw_normal)
                            (* PTS 1111575 E.Z. *)
                        THEN
                            BEGIN
                            i := succ(i);
                            sp1p_buf[ val_pos + i ] := csp_unicode_mark;
                            i := succ(i);
                            sp1p_buf[ val_pos + i ] := ln[ lpos ];
                            END
                        ELSE
                            BEGIN
                            i := succ(i);
                            sp1p_buf[ val_pos + i ] := ln[ lpos ];
                            i := succ(i);
                            sp1p_buf[ val_pos + i ] := csp_unicode_mark;
                            END;
                        (*ENDIF*) 
                        lpos := succ (lpos)
                        END;
                    (*ENDWHILE*) 
                    lpos := succ (lpos);
                    IF  NOT upg.variable_input
                    THEN
                        BEGIN
                        j := i + 1;
                        IF  undef_len
                        THEN
                            IF  (snd_packet^.sp1_header.sp1h_mess_swap = sw_normal)
                                (* PTS 1111575 E.Z. *)
                            THEN
                                WHILE j < len1 DO
                                    BEGIN
                                    sp1p_buf[ val_pos + j     ] := csp_unicode_mark;
                                    sp1p_buf[ val_pos + j + 1 ] := bsp_c1;
                                    j := j + 2
                                    END
                                (*ENDWHILE*) 
                            ELSE
                                WHILE j < len1 DO
                                    BEGIN
                                    sp1p_buf[ val_pos + j     ] := bsp_c1;
                                    sp1p_buf[ val_pos + j + 1 ] := csp_unicode_mark;
                                    j := j + 2
                                    END
                                (*ENDWHILE*) 
                            (*ENDIF*) 
                        ELSE
                            IF  (snd_packet^.sp1_header.sp1h_mess_swap = sw_normal)
                                (* PTS 1111575 E.Z. *)
                            THEN
                                WHILE j < sp1i_in_out_len - 1 DO
                                    BEGIN
                                    sp1p_buf[ val_pos + j     ] := csp_unicode_mark;
                                    sp1p_buf[ val_pos + j + 1 ] := bsp_c1;
                                    j := j + 2
                                    END
                                (*ENDWHILE*) 
                            ELSE
                                WHILE j < sp1i_in_out_len - 1 DO
                                    BEGIN
                                    sp1p_buf[ val_pos + j     ] := bsp_c1;
                                    sp1p_buf[ val_pos + j + 1 ] := csp_unicode_mark;
                                    j := j + 2
                                    END
                                (*ENDWHILE*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    IF  (upg.term_simulation = tasim_unicode) AND
                        (NOT (sp1i_data_type in [ dcha, dvarchara, dstra, dlonga, ddate, dtime, dtimestamp ])
                        OR NOT upg.ascii_in_output) AND
                        (delimiter = string_delimiter)
                    THEN
                        sp1p_buf[ val_pos ] := csp_unicode_def_byte
                    ELSE
                        sp1p_buf[ val_pos ] := bsp_c1;
                    (*ENDIF*) 
                    WHILE ln[ lpos ] <> delimiter DO
                        BEGIN
                        i := succ(i);
                        sp1p_buf[ val_pos + i ] := ln[ lpos ];
                        lpos := succ (lpos)
                        END;
                    (*ENDWHILE*) 
                    lpos := succ (lpos);
                    IF  upg.variable_input
                    THEN
                        BEGIN
                        IF  typ = 'P'
                        THEN
                            BEGIN
                            FOR j := i + 1 TO len1 DO
                                sp1p_buf[ val_pos + j ] := ' ';
                            (*ENDFOR*) 
                            IF  sp1i_length > 0
                            THEN
                                BEGIN
                                i := sp1i_length;
                                curr_len := sp1i_length
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  (upg.term_simulation = tasim_unicode) AND
                            (NOT (sp1i_data_type in [ dcha, dvarchara, dstra, dlonga, ddate, dtime, dtimestamp ])
                            OR NOT upg.ascii_in_output) AND
                            (delimiter = string_delimiter)
                        THEN
                            i := ta320ascii2unicode (upg,
                                  @sp1p_buf[ val_pos+1 ], i, sp1p_buf_size)
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  undef_len
                        THEN
                            BEGIN
                            FOR j := i + 1 TO len1 DO
                                sp1p_buf[ val_pos + j ] := ' ';
                            (*ENDFOR*) 
                            IF  (upg.term_simulation = tasim_unicode) AND
                                (NOT (sp1i_data_type in [ dcha, dvarchara, dstra, dlonga, ddate, dtime, dtimestamp ])
                                OR NOT upg.ascii_in_output) AND
                                (delimiter = string_delimiter)
                            THEN
                                len1 := ta320ascii2unicode (upg,
                                      @sp1p_buf[ val_pos+1 ], len1, sp1p_buf_size)
                            (*ENDIF*) 
                            END
                        ELSE
                            BEGIN
                            IF  typ = 'E'
                            THEN
                                BEGIN
                                FOR j := 2 TO sp1i_length DIV i DO
                                    SAPDB_PascalForcedOverlappingMove (sp1p_buf_size, sp1p_buf_size,
                                          @sp1p_buf, val_pos+1,
                                          @sp1p_buf, val_pos+(j-1) * i + 1, i);
                                (*ENDFOR*) 
                                i := (sp1i_length DIV i) * i
                                END;
                            (*ENDIF*) 
                            FOR j := i + 1 TO sp1i_in_out_len-1 DO
                                sp1p_buf[ val_pos + j ] := ' ';
                            (*ENDFOR*) 
                            IF  (upg.term_simulation = tasim_unicode) AND
                                (NOT (sp1i_data_type in [ dcha, dvarchara, dstra, dlonga, ddate, dtime, dtimestamp ])
                                OR NOT upg.ascii_in_output) AND
                                (delimiter = string_delimiter)
                            THEN (* for byte values use double_quotes *)
                                BEGIN
                                IF  sp1i_length > 0
                                THEN
                                    len1 := sp1i_length;
                                (*ENDIF*) 
                                len1 := ta320ascii2unicode (upg,
                                      @sp1p_buf[ val_pos+1 ], len1, sp1p_buf_size)
                                END
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  typ = 'P'
                THEN   (* crypt password *)
                    BEGIN
                    pw_clear := bsp_name;
                    IF  upg.variable_input
                    THEN
                        SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (pw_clear),
                              @sp1p_buf, val_pos + 1, @pw_clear, 1, curr_len)
                    ELSE
                        SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (pw_clear),
                              @sp1p_buf, val_pos + 1, @pw_clear, 1, NAME_MXSP00);
                    (*ENDIF*) 
                    s02applencrypt (pw_clear, pw_crypt);
                    SAPDB_PascalForcedMove (sizeof (pw_crypt), sp1p_buf_size,
                          @pw_crypt, 1, @sp1p_buf, val_pos + 1, CRYPTPW_MXSP00);
                    len1         := CRYPTPW_MXSP00;
                    curr_len     := CRYPTPW_MXSP00;
                    sp1p_buf_len := val_pos + len1
                    END
                ELSE
                    IF  upg.variable_input
                    THEN
                        BEGIN
                        IF  typ = 'E'
                        THEN
                            FOR j := 2 TO curr_len DIV i DO
                                SAPDB_PascalForcedOverlappingMove (sp1p_buf_size, sp1p_buf_size,
                                      @sp1p_buf, val_pos+1,
                                      @sp1p_buf, val_pos+(j-1) * i + 1, i);
                            (*ENDFOR*) 
                        (*ENDIF*) 
                        sp1p_buf_len := val_pos + curr_len
                        END
                    ELSE
                        IF  undef_len
                        THEN
                            sp1p_buf_len := sp1p_buf_len + len1 + 1
                        ELSE
                            IF  new_pos > sp1p_buf_len
                            THEN
                                IF  sp1i_length > 0
                                THEN
                                    sp1p_buf_len := new_pos + sp1i_in_out_len - 1
                                ELSE
                                    sp1p_buf_len := new_pos + len1
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                IF  upg.variable_input
                THEN
                    BEGIN
                    is_null := true;
                    sp1p_buf_len := succ(sp1p_buf_len);
                    curr_len := 0;
                    END
                ELSE
                    BEGIN
                    sp1p_buf[ new_pos ] := csp_undef_byte;
                    IF  undef_len
                    THEN
                        i := len1
                    ELSE
                        i := sp1i_in_out_len-1;
                    (*ENDIF*) 
                    FOR j := 1 TO i DO
                        sp1p_buf[ new_pos+j ] := csp_defined_byte;
                    (*ENDFOR*) 
                    IF  undef_len
                    THEN
                        sp1p_buf_len := sp1p_buf_len + len1 + 1
                    ELSE
                        IF  new_pos > sp1p_buf_len
                        THEN
                            sp1p_buf_len := new_pos + i
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        'D' :
            BEGIN
            (* DEFAULT *)
            IF  upg.variable_input
            THEN
                BEGIN
                default := true;
                curr_len := 0;
                sp1p_buf_len := succ(sp1p_buf_len)
                END
            ELSE
                BEGIN
                sp1p_buf[ new_pos ] := csp_default_byte;
                IF  new_pos > sp1p_buf_len
                THEN
                    sp1p_buf_len := new_pos + sp1i_in_out_len - 1
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        'F' :
            BEGIN
            REPEAT
                lpos:= succ (lpos)
            UNTIL
                (ln[ lpos ] <> ' ') OR (lpos = LINE_MXSP00);
            (*ENDREPEAT*) 
            nl:= lpos;
            REPEAT
                num[ nl-lpos+1 ]:= ln[ nl ];
                nl:= succ (nl)
            UNTIL
                (ln[ nl ] = ' ') OR (nl = LINE_MXSP00);
            (*ENDREPEAT*) 
            s43pstr (sp1p_buf, new_pos+1,
                  len1, csp_float_frac, num, 1, nl-lpos, res);
            len2:= (len1+1) DIV 2 + 1;
            curr_len := len2;
            IF  upg.variable_input
            THEN
                BEGIN
                IF  res <> num_ok
                THEN
                    BEGIN
                    is_null := true;
                    curr_len := 0;
                    END
                ELSE
                    WHILE sp1p_buf[new_pos+curr_len] = chr(0) DO
                        curr_len := pred(curr_len);
                    (*ENDWHILE*) 
                (*ENDIF*) 
                sp1p_buf_len := new_pos + curr_len
                END
            ELSE
                BEGIN
                IF  res <> num_ok
                THEN
                    sp1p_buf[ new_pos ] := csp_undef_byte
                ELSE
                    sp1p_buf[ new_pos ] := csp_defined_byte;
                (*ENDIF*) 
                IF  new_pos > sp1p_buf_len
                THEN
                    sp1p_buf_len := new_pos + sp1i_in_out_len - 1;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            lpos:= nl
            END;
        'I' :
            BEGIN
            ic2.mapInt_sp00 := len1;
            sp1p_buf[ sp1p_buf_len + 1 ] := ic2.mapC2_sp00[ 1 ];
            sp1p_buf[ sp1p_buf_len + 2 ] := ic2.mapC2_sp00[ 2 ];
            sp1p_buf_len := sp1p_buf_len + 2
            END;
        'L' :
            BEGIN
            REPEAT
                lpos := succ (lpos)
            UNTIL
                (ln[ lpos ] = string_delimiter) OR
                (ln[ lpos ] = double_quote)     OR
                (lpos = LINE_MXSP00);
            (*ENDREPEAT*) 
            IF  ((lpos < LINE_MXSP00) AND (len1 > 0))
                OR
                ((lpos = LINE_MXSP00) AND (len1 = 0))
            THEN
                BEGIN
                delimiter := ln[ lpos ];
                lpos      := succ (lpos);
                curr_len  := LONG_DESC_MXSP00;
                IF  upg.variable_input
                THEN
                    sp1p_buf[ new_pos ] := chr(LONG_DESC_MXSP00)
                ELSE
                    sp1p_buf[ new_pos ] := csp_defined_byte;
                (*ENDIF*) 
                IF  sp1p_part_kind <> sp1pk_longdata
                THEN
                    SAPDB_PascalForcedFill (sp1p_buf_size, @sp1p_buf, new_pos + 1,
                          LONG_DESC_MXSP00, csp_defined_byte);
                (*ENDIF*) 
                sp1p_buf[ new_pos + 1 + valmode_offset ] := chr (len2);
                IF  (sp1p_part_kind = sp1pk_longdata) AND (input_field > 1)
                THEN
                    long_offset := long_offset + LONG_DESC_MXSP00 + 1;
                (*ENDIF*) 
                curr_offset := data_offset + long_offset;
                IF  upg.dbprocCall
                THEN
                    BEGIN
                    ldState := [ld_stream];
                    IF  (upg.term_simulation = tasim_unicode) AND
                        (NOT (sp1i_data_type in [ dstra, dlonga ]) OR NOT upg.ascii_in_output) AND
                        (sp1i_data_type <> dstruni)
                    THEN
                        ldState := ldState + [ld_use_toascii];
                    (*ENDIF*) 
                    SAPDB_PascalForcedMove (1, sp1p_buf_size, @ldState, 1,
                          @sp1p_buf, new_pos + 1 + lsState_offset, 1);
                    sp1p_buf[new_pos + 1 + valmode_offset] := chr(ord(vm_last_putval));
                    IF  (sp1i_data_type = dstruni) OR
                        ((upg.term_simulation = tasim_unicode) AND
                        (NOT (sp1i_data_type in [ dstra, dlonga ]) OR NOT upg.ascii_in_output))
                    THEN
                        len1 := 2 * len1;
                    (*ENDIF*) 
                    sqlallocat (len1, p, ok);
                    upg.dbprocLongData.dbp_count := upg.dbprocLongData.dbp_count + 1;
                    upg.dbprocLongData.dbp_length[ upg.dbprocLongData.dbp_count] := len1;
                    upg.dbprocLongData.dbp_pos   [ upg.dbprocLongData.dbp_count] := 1;
                    upg.dbprocLongData.dbp_addr  [ upg.dbprocLongData.dbp_count] := p;
                    i2c2.map_int := upg.dbprocLongData.dbp_count;
                    sp1p_buf[new_pos + valind_offset + 1] := i2c2.map_c2[1];
                    sp1p_buf[new_pos + valind_offset + 2] := i2c2.map_c2[2];
                    (*s20int4_to_buf (upg.dbprocLongData.dbp_count, sp1p_buf,
                          new_pos + 1 + 32);*)
                    (* PTS 1108066 E.Z. *)
                    IF  ok
                    THEN
                        BEGIN
                        SAPDB_PascalForcedFill (len1, @p^,
                              1, len1, csp_defined_byte);
                        END;
                    (*ENDIF*) 
                    i := 0;
                    IF  (upg.swap = sw_normal)                 AND
                        ((sp1i_data_type = dstruni) OR
                        (upg.term_simulation = tasim_unicode)  AND
                        (NOT (sp1i_data_type in [ dstra, dlonga ]) OR NOT upg.ascii_in_output))
                    THEN
                        diff := 1
                    ELSE
                        diff := 0;
                    (*ENDIF*) 
&                   ifdef trace
                    t02int4 (debug_ta, 'delimiter   ', ord (delimiter));
&                   endif
                    WHILE ln[ lpos ] <> delimiter DO
                        BEGIN
                        p^[ i + diff + 1] := ln[ lpos ];
                        IF  (sp1i_data_type = dstruni) OR
                            ((upg.term_simulation = tasim_unicode) AND
                            (NOT (sp1i_data_type in [ dstra, dlonga ]) OR NOT upg.ascii_in_output))
                        THEN
                            i := i+2
                        ELSE
                            i := i+1;
                        (*ENDIF*) 
                        lpos := succ (lpos)
                        END;
                    (*ENDWHILE*) 
                    j := len1 DIV i;
                    FOR si := 1 TO j-1 DO
                        SAPDB_PascalForcedOverlappingMove (i, len1,
                              @p^, 1,
                              @p^, (i*si) + 1, i);
                    (*ENDFOR*) 
                    SAPDB_PascalForcedOverlappingMove (i, len1,
                          @p^, 1,
                          @p^, (j*i) + 1, len1 - (j*i));
                    len1 := 0;
                    IF  upg.variable_input
                    THEN
                        sp1p_buf_len := sp1p_buf_len + 1 + LONG_DESC_MXSP00
                    ELSE
                        sp1p_buf_len := curr_offset - 1
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    IF  (len2 >= ord (vm_data_trunc)) OR
                        (len2 <= ord (vm_lastdata))
                    THEN
                        BEGIN
                        IF  sp1i_data_type = dstruni
                        THEN
                            BEGIN
                            len1 := 2 * len1;
                            (* PTS 1108066 E.Z. *)
                            SAPDB_PascalForcedFill (sp1p_buf_size, @sp1p_buf,
                                  curr_offset, len1, csp_defined_byte);
                            END;
                        (*ENDIF*) 
                        i := 0;
                        IF  (upg.swap = sw_normal) AND
                            (sp1i_data_type = dstruni)
                        THEN
                            diff := 1
                        ELSE
                            diff := 0;
                        (*ENDIF*) 
&                       ifdef trace
                        t02int4 (debug_ta, 'delimiter   ', ord (delimiter));
&                       endif
                        WHILE ln[ lpos ] <> delimiter DO
                            BEGIN
                            sp1p_buf[ curr_offset+diff+i ] := ln[ lpos ];
                            IF  sp1i_data_type = dstruni
                            THEN
                                i    := i+2
                            ELSE
                                i    := i+1;
                            (*ENDIF*) 
                            lpos := succ (lpos)
                            END;
                        (*ENDWHILE*) 
                        j := len1 DIV i;
                        FOR si := 1 TO j-1 DO
                            SAPDB_PascalForcedOverlappingMove (sp1p_buf_size, sp1p_buf_size,
                                  @sp1p_buf, curr_offset,
                                  @sp1p_buf, curr_offset + (i*si), i);
                        (*ENDFOR*) 
                        SAPDB_PascalForcedOverlappingMove (sp1p_buf_size, sp1p_buf_size,
                              @sp1p_buf, curr_offset,
                              @sp1p_buf, curr_offset + (j*i), len1 - (j*i));
                        IF  (upg.term_simulation = tasim_unicode) AND
                            (NOT (sp1i_data_type in [ dstra, dlonga ]) OR NOT upg.ascii_in_output) AND
                            (delimiter = string_delimiter)        AND
                            (sp1i_data_type <> dstruni)           AND
                            (sp1i_data_type <> dstrb)
                        THEN (* for byte values use double_quotes; for   *)
                            (*  real unicode columns all is done already *)
                            len1 := ta320ascii2unicode (upg,
                                  @sp1p_buf[ curr_offset ], len1,
                                  sp1p_buf_size - curr_offset+1);
                        (*ENDIF*) 
                        IF  upg.variable_input
                        THEN
                            sp1p_buf_len := sp1p_buf_len + 1 + LONG_DESC_MXSP00
                        ELSE
                            sp1p_buf_len := curr_offset + len1 - 1;
                        (*ENDIF*) 
                        long_offset  := long_offset + len1
                        END
                    ELSE
                        BEGIN
                        WHILE ln[ lpos ] <> delimiter DO
                            lpos := succ (lpos);
                        (*ENDWHILE*) 
                        IF  upg.variable_input
                        THEN
                            sp1p_buf_len := sp1p_buf_len + 1 + LONG_DESC_MXSP00
                        ELSE
                            sp1p_buf_len := curr_offset - 1
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  NOT upg.dbprocCall
                THEN
                    BEGIN
                    s20int4_to_buf (curr_offset, sp1p_buf,
                          new_pos + 1 + valpos_offset);
                    s20int4_to_buf (len1, sp1p_buf,
                          new_pos + 1 + vallen_offset);
                    END;
                (*ENDIF*) 
                lpos := succ(lpos);
                IF  (NOT upg.is_data_input) AND
                    ((input_field > 1) OR masscmd)
                THEN
                    BEGIN (* putval *)
                    SAPDB_PascalForcedOverlappingMove (sp1p_buf_size, sp1p_buf_size,
                          @sp1p_buf, new_pos, @sp1p_buf,
                          curr_offset-LONG_DESC_MXSP00-1, LONG_DESC_MXSP00+1);
                    SAPDB_PascalForcedFill (sp1p_buf_size, @sp1p_buf,
                          new_pos, LONG_DESC_MXSP00+1, '-');
                    new_pos := curr_offset-LONG_DESC_MXSP00-1
                    END
                (*ENDIF*) 
                END
            ELSE
                IF  upg.variable_input
                THEN
                    BEGIN
                    is_null := true;
                    curr_len := 0;
                    sp1p_buf_len := new_pos + curr_len
                    END
                ELSE
                    BEGIN
                    sp1p_buf[ new_pos ] := csp_undef_byte;
                    i := sp1i_in_out_len - 1;
                    FOR j := 1 TO i DO
                        sp1p_buf[ new_pos+j ] := csp_defined_byte;
                    (*ENDFOR*) 
                    IF  new_pos > sp1p_buf_len
                    THEN
                        sp1p_buf_len := new_pos + i
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        'N' :
            BEGIN
            si := 1;
            REPEAT
                lpos := succ(lpos)
            UNTIL
                (ln[ lpos ] <> ' ');
            (*ENDREPEAT*) 
&           ifdef TRACE
            s30:= '                              ';
&           endif
            WHILE ((ln[ lpos ] <> ' ') AND (si <= 40)) DO
                BEGIN
&               ifdef TRACE
                IF  ( si <= 20 )
                THEN
                    s30[ si ] := ln[ lpos ];
&               endif
                (*ENDIF*) 
                num[ si ] := ln[ lpos ];
                lpos      := succ (lpos);
                si        := succ (si)
                END;
            (*ENDWHILE*) 
&           ifdef TRACE
            t02str30 (debug_ta, s30);
&           endif
            s43pstr (sp1p_buf, new_pos+1, len1, len2, num, 1, si-1, res);
            IF  upg.variable_input
            THEN
                BEGIN
                IF  res <> num_ok
                THEN
                    BEGIN
                    is_null := true;
                    curr_len := 0;
                    END
                ELSE
                    BEGIN
                    curr_len := ((len1 + 1) DIV 2) + 1;
                    WHILE sp1p_buf[new_pos+curr_len] = chr(0) DO
                        curr_len := pred(curr_len);
                    (*ENDWHILE*) 
                    sp1p_buf_len := new_pos + curr_len
                    END
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  res <> num_ok
                THEN
                    sp1p_buf[ new_pos ] := csp_undef_byte
                ELSE
                    sp1p_buf[ new_pos ] := csp_defined_byte;
                (*ENDIF*) 
                IF  new_pos > sp1p_buf_len
                THEN
                    sp1p_buf_len := new_pos + ((len1 + 1) DIV 2) + 1;
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        'S' :
            BEGIN
            (* searchpattern of LONG-Column statements         *)
            (* are given with different length, specified as   *)
            (* character. They are changed into CHAR(254) BYTE *)
            len1 := 254;
            REPEAT
                lpos := succ(lpos)
            UNTIL
                ((ln[ lpos ] = string_delimiter) OR (lpos = LINE_MXSP00));
            (*ENDREPEAT*) 
            IF  (lpos < LINE_MXSP00) AND (len1 > 0)
            THEN
                BEGIN
                lpos := succ (lpos);
                sp1p_buf[ new_pos ] := csp_defined_byte;
                i := 0;
                WHILE ln[ lpos ] <> string_delimiter DO
                    BEGIN
                    i := succ(i);
                    sp1p_buf[ new_pos + i ] := ln[ lpos ];
                    lpos := succ(lpos)
                    END;
                (*ENDWHILE*) 
                lpos := succ(lpos);
                FOR j := i + 1 TO len1 DO
                    sp1p_buf[ new_pos + j ] := csp_defined_byte;
                (*ENDFOR*) 
                IF  undef_len
                THEN
                    sp1p_buf_len := sp1p_buf_len + len1 + 1
                ELSE
                    IF  new_pos > sp1p_buf_len
                    THEN
                        sp1p_buf_len := new_pos+sp1i_in_out_len-1
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        'V' :
            BEGIN
            IF  len1 > 255
            THEN
                len1 := len1 MOD 256;
            (*ENDIF*) 
            sp1p_buf_len             := succ (sp1p_buf_len);
            sp1p_buf[ sp1p_buf_len ] := chr (len1)
            END;
        OTHERWISE
            BEGIN
            sp1p_buf[ 3 ] := '!';
            sp1p_buf_len  := 3;
            lpos          := LINE_MXSP00;
            ln            := upg.term^.blankline
            END
        END;
    (*ENDCASE*) 
    IF  upg.variable_input
    THEN
        IF  is_null
        THEN
            sp1p_buf[new_pos] := chr(csp1_fi_null_value)
        ELSE
            IF  default
            THEN
                sp1p_buf[new_pos] := chr(csp1_fi_default_value)
            ELSE
                IF  curr_len > c_maxonebytelength
                THEN
                    BEGIN
                    sp1p_buf[new_pos  ] := chr(csp1_fi_2byte_length);
                    sp1p_buf[new_pos+1] := chr(curr_len DIV 256);
                    sp1p_buf[new_pos+2] := chr(curr_len MOD 256);
                    END
                ELSE
                    sp1p_buf[new_pos] := chr(curr_len);
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320get_appl_param (
            VAR upg    : tta_user_proc_globals;
            snd_packet : tsp1_packet_ptr);
 
VAR
      len1        : integer;
      len2        : integer;
      typ         : char;
      com_data    : tsp00_Line;
      i           : integer;
      param_no    : integer;
      param_part  : tsp1_part_ptr;
      params      : tsp1_param_spec_list;
 
BEGIN
(* IF  upg.curr_segm^.sp1c_mess_type = sp1m_putval
      THEN
      s26find_part (upg.curr_segm^, sp1pk_longdata, param_part)
      ELSE
      *)
s26find_part (upg.curr_segm^, sp1pk_appl_parameter_description,
      param_part);
t09put (upg.term^, upg.term^.blankline, cut_protected);
t09put20 (upg.term^, enter_data_msg, cut_bright_protected);
t09get (upg.term^, com_data, upg.pfkey);
t09put (upg.term^, upg.term^.blankline, cut_protected);
upg.prot.ln := upg.term^.blankline;
t320prot (upg, 1);
param_no    := 0;
WHILE com_data <> upg.term^.blankline DO
    BEGIN
    IF  param_part = NIL
    THEN
        s26new_part_init (snd_packet, upg.curr_segm^, param_part);
    (*ENDIF*) 
    t09put (upg.term^, com_data, cut_protected);
    upg.prot.ln := com_data;
    t320prot (upg, 132);
    i := 1;
    ta320skipbl (com_data, i);
    WHILE i < LINE_MXSP00 DO
        BEGIN
        param_no := succ(param_no);
&       ifdef TRACE
        t02int4 (debug_ta, 'param_no    ', param_no);
&       endif
        ta320read_format (upg, i, com_data, typ, len1, len2);
        WITH params[ param_no ] DO
            CASE typ OF
                'B' :
                    BEGIN
                    para_type := dchb;
                    para_frac := chr(0);
                    para_length := len1
                    END;
                'C' :
                    BEGIN
                    para_type := dcha;
                    para_frac := chr(0);
                    para_length := len1
                    END;
                'D' :
                    BEGIN
                    para_type := ddate;
                    para_frac := chr(0);
                    para_length := DATE_MXSP00
                    END;
                'L' :
                    BEGIN
                    para_type := dlonga;
                    para_frac := chr(0);
                    para_length := 8
                    END;
                'M' :
                    BEGIN
                    para_type := dtimestamp;
                    para_frac := chr(0);
                    para_length := TIMESTAMP_MXSP00
                    END;
                'N' :
                    BEGIN
                    para_type := dfixed;
                    para_frac := chr(len2);
                    para_length := len1
                    END;
                'T' :
                    BEGIN
                    para_type := dtime;
                    para_frac := chr(0);
                    para_length := TIME_MXSP00
                    END;
                OTHERWISE
                    BEGIN
                    para_type := dcha;
                    para_frac := chr(0);
                    para_length := len1
                    END;
                END;
            (*ENDCASE*) 
        (*ENDWITH*) 
        ta320skipbl (com_data, i);
        END;
    (*ENDWHILE*) 
    IF  com_data <> upg.term^.blankline
    THEN
        t09get (upg.term^, com_data, upg.pfkey)
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  param_part <> NIL
THEN
    BEGIN
    SAPDB_PascalForcedMove (sizeof(params), param_part^.sp1p_buf_size,
          @params, 1, @param_part^.sp1p_buf, 1, param_no * sizeof(tsp1_param_spec));
    param_part^.sp1p_part_kind := sp1pk_appl_parameter_description;
    param_part^.sp1p_arg_count := param_no;
    param_part^.sp1p_buf_len   := param_no * sizeof(tsp1_param_spec);
    t320finish_part (upg, snd_packet, param_part^)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320get_data_input (
            VAR upg    : tta_user_proc_globals;
            VAR ex_in  : tta_ex_in;
            snd_packet : tsp1_packet_ptr);
 
VAR
      masscmd     : boolean;
      com_data    : tsp00_Line;
      i           : integer;
      param_no    : integer;
      data_part   : tsp1_part_ptr;
      data_offset : tsp00_Int4;
      fix_buf_len : tsp00_Int4;
      long_offset : tsp00_Int4;
 
BEGIN
IF  upg.curr_segm^.sp1c_mess_type = sp1m_putval
THEN
    s26find_part (upg.curr_segm^, sp1pk_longdata, data_part)
ELSE
    IF  upg.variable_input
    THEN
        s26find_part (upg.curr_segm^, sp1pk_vardata, data_part)
    ELSE
        s26find_part (upg.curr_segm^, sp1pk_data, data_part);
    (*ENDIF*) 
(*ENDIF*) 
IF  upg.variable_input
THEN
    BEGIN
    fix_buf_len := 0;
    FOR i := 1 TO ex_in.cnt_input_fields DO
        WITH ex_in.input_params[ i ] DO
            fix_buf_len := fix_buf_len + sp1i_in_out_len;
        (*ENDWITH*) 
    (*ENDFOR*) 
    END
ELSE
    IF  data_part = NIL
    THEN
        fix_buf_len := ta320fix_buf_len (ex_in)
    ELSE
        IF  data_part^.sp1p_buf_len = 0
        THEN
            fix_buf_len := ta320fix_buf_len (ex_in)
        ELSE
            fix_buf_len := data_part^.sp1p_buf_len;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
t09put (upg.term^, upg.term^.blankline, cut_protected);
t09put20 (upg.term^, enter_data_msg, cut_bright_protected);
t09get (upg.term^, com_data, upg.pfkey);
t09put (upg.term^, upg.term^.blankline, cut_protected);
upg.prot.ln := upg.term^.blankline;
t320prot (upg, 1);
param_no    := 0;
masscmd     := false;
IF  upg.variable_input
THEN
    IF  data_part = NIL
    THEN
        data_offset := 2
    ELSE
        IF  data_part^.sp1p_part_kind = sp1pk_longdata
        THEN
            data_offset := 0
        ELSE
            data_offset := 2
        (*ENDIF*) 
    (*ENDIF*) 
ELSE
    data_offset := 0;
(*ENDIF*) 
long_offset := fix_buf_len + 1;
WHILE com_data <> upg.term^.blankline DO
    BEGIN
    IF  data_part = NIL
    THEN
        BEGIN
        upg.dbprocLongData.dbp_count := 0;
        s26new_part_init (snd_packet, upg.curr_segm^, data_part);
        IF  upg.variable_input
        THEN
            data_part^.sp1p_part_kind := sp1pk_vardata;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    t09put (upg.term^, com_data, cut_protected);
    upg.prot.ln := com_data;
    t320prot (upg, 132);
    i := 1;
    ta320skipbl (com_data, i);
    IF  upg.variable_input AND (param_no = 0)
    THEN
        WITH data_part^DO
            BEGIN
            sp1p_buf[sp1p_buf_len+1] := chr(ex_in.cnt_input_fields DIV 256);
            sp1p_buf[sp1p_buf_len+2] := chr(ex_in.cnt_input_fields MOD 256);
            sp1p_buf_len := sp1p_buf_len + 2
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    WHILE i < LINE_MXSP00 DO
        BEGIN
        param_no := succ(param_no);
&       ifdef TRACE
        t02int4 (debug_ta, 'param_no    ', param_no);
&       endif
        ta320dat_case (upg, snd_packet, i, com_data, ex_in, param_no,
              masscmd, data_part^, data_offset, long_offset);
        ta320skipbl (com_data, i);
        IF  param_no = ex_in.cnt_input_fields
        THEN
            BEGIN (* minsert etc. *)
            IF  upg.variable_input AND
                (long_offset > fix_buf_len + 1)
            THEN
                data_part^.sp1p_buf_len := data_offset + long_offset - 1;
            (*ENDIF*) 
            masscmd     := true;
            param_no    := 0;
            IF  upg.variable_input
            THEN
                data_offset := data_part^.sp1p_buf_len + 2
            ELSE
                data_offset := data_part^.sp1p_buf_len;
            (*ENDIF*) 
            long_offset := fix_buf_len + 1
            END
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  com_data <> upg.term^.blankline
    THEN
        t09get (upg.term^, com_data, upg.pfkey)
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  data_part <> NIL
THEN
    t320finish_part (upg, snd_packet, data_part^)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ta320fix_buf_len (VAR ex_in : tta_ex_in) : tsp00_Int4;
 
VAR
      fix_buf_len : tsp00_Int4;
      curr_param  : tsp00_Int4;
 
BEGIN
fix_buf_len := 0;
FOR curr_param := 1 TO ex_in.cnt_input_fields DO
    WITH ex_in.input_params[ curr_param ] DO
        IF  fix_buf_len < sp1i_bufpos + sp1i_in_out_len - 1
        THEN
            fix_buf_len := sp1i_bufpos + sp1i_in_out_len - 1;
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDFOR*) 
ta320fix_buf_len := fix_buf_len
END;
 
(* PTS 1111575 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      t320dbs_send (
            VAR upg        : tta_user_proc_globals;
            snd_packet     : tsp1_packet_ptr;
            VAR rcv_packet : tsp1_packet_ptr;
            VAR returncode : tsp00_Int2);
 
VAR
      sql_retcode : tsp1_comm_error;
      err_string  : tsp00_ErrText;
      num_err     : tsp00_NumError;
      rcv_length  : tsp00_Int4;
      new_time    : tsp00_Int4;
      li          : tsp00_DataLine;
      i           : integer;
      ix          : integer;
      jx          : integer;
      virt        : tsp00_C8;
      snd_length  : tsp00_Int4;
      debug       : tut_debug;
      abap_part   : tsp1_part_ptr;
      pAbapRead   : tsp1_part_ptr;
      fnlen       : integer;
      fnrow       : integer;
      fnrowlen    : integer;
      fnrowpos    : integer;
      fnrowtxt    : tsp00_C12;
 
LABEL
      999;
 
BEGIN
snd_packet^.sp1_segm.sp1c_commit_immediately := upg.autocommit;
IF  (upg.is_connected) AND
    (upg.first_token <> cta_n_connect) AND
    (upg.with_module_part > 0)
THEN
    BEGIN
    s26new_part_init (snd_packet, upg.curr_segm^, abap_part);
    WITH upg, term^ DO
        BEGIN
        abap_part^.sp1p_part_kind := sp1pk_modulname;
        abap_part^.sp1p_buf [1]  := chr(ord('0') + with_module_part);
        abap_part^.sp1p_buf_len := 1;
        t320finish_part (upg, snd_packet, abap_part^);
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
IF  (upg.term^.curr_inputfile > 0) AND
    (upg.is_connected) AND
    (upg.first_token <> cta_n_connect) AND
    (upg.with_abap_part)
THEN
    BEGIN
    s26new_part_init (snd_packet, upg.curr_segm^, abap_part);
    WITH upg, term^ DO
        BEGIN
        abap_part^.sp1p_part_kind := sp1pk_abap_info;
        fnrow    := inputfilpos[curr_inputfile];
        IF  fnrow > 0
        THEN
            BEGIN
            fnrowpos := sizeof(fnrowtxt);
            fnrowlen := 0;
            REPEAT
                fnrowtxt [fnrowpos]
                      := chr (ord ('0') + (fnrow MOD 10));
                fnrow        := fnrow DIV 10;
                fnrowpos     := pred(fnrowpos);
                fnrowlen     := succ(fnrowlen);
            UNTIL
                fnrow = 0;
            (*ENDREPEAT*) 
            END
        ELSE
            BEGIN
            fnrow        := 0;
            fnrowtxt [1] := '0';
            fnrowpos     := 1;
            fnrowlen     := 1;
            END;
        (*ENDIF*) 
        fnlen := s30lnr (inputfn[curr_inputfile], bsp_c1,
              1, sizeof(inputfn[curr_inputfile]));
        IF  2 + fnlen + fnrowlen > abap_part^.sp1p_buf_size
        THEN
            fnlen := abap_part^.sp1p_buf_size - 2 - fnrowlen;
        (*ENDIF*) 
        IF  (upg.term_simulation = tasim_unicode)
        THEN
            IF  2 + 2*fnlen + 2*fnrowlen > abap_part^.sp1p_buf_size
            THEN
                fnlen := (abap_part^.sp1p_buf_size - 2 - 2*fnrowlen) DIV 2;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  fnlen > 0
        THEN
            BEGIN
            SAPDB_PascalForcedMove (sizeof (inputfn[curr_inputfile]), abap_part^.sp1p_buf_size,
                  @inputfn[curr_inputfile], 1, @abap_part^.sp1p_buf, 2, fnlen);
            abap_part^.sp1p_buf [1] := chr(fnlen);
            SAPDB_PascalForcedMove (sizeof (fnrowtxt), abap_part^.sp1p_buf_size,
                  @fnrowtxt, fnrowpos + 1,
                  @abap_part^.sp1p_buf, 3 + fnlen, fnrowlen);
            abap_part^.sp1p_buf [fnlen + 2] := chr(fnrowlen);
            abap_part^.sp1p_buf_len := 2 + fnlen + fnrowlen;
            t320finish_part (upg, snd_packet, abap_part^);
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
IF  (upg.is_connected) AND
    (upg.first_token <> cta_n_connect) AND
    (upg.longdem_length >= 0)                    (* PTS 1122546 D.T. *)
THEN
    BEGIN
    s26new_part_init (snd_packet, upg.curr_segm^, abap_part);
    WITH upg, term^ DO
        BEGIN
        abap_part^.sp1p_part_kind := sp1pk_long_demand;
        abap_part^.sp1p_arg_count := upg.longdem_cnt;
        abap_part^.sp1p_buf_len := upg.longdem_cnt * 16;
        FOR i:=1 TO upg.longdem_cnt DO
            BEGIN
            abap_part^.sp1p_buf [16*(i-1)+1] := csp_defined_byte;
            abap_part^.sp1p_buf [16*(i-1)+2] := chr(ord(upg.longdem_atonce));
            abap_part^.sp1p_buf [16*(i-1)+3] := csp_defined_byte;
            s41p4int (abap_part^.sp1p_buf,  16*(i-1)+4, upg.longdem_pos, num_err);
            abap_part^.sp1p_buf [16*(i-1)+10] := csp_defined_byte;
            s41p4int (abap_part^.sp1p_buf, 16*(i-1)+11, upg.longdem_length, num_err);
            END;
        (*ENDFOR*) 
        t320finish_part (upg, snd_packet, abap_part^);
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
IF  NOT upg.check_scrollopt
THEN
    upg.curr_segm^.sp1c_command_options := upg.command_options -
          [sp1co_scrollable_cursor_on]
ELSE
    upg.curr_segm^.sp1c_command_options := upg.command_options;
(*ENDIF*) 
IF  NOT (sp1co_scrollable_cursor_on in upg.command_options)
    AND
    (upg.curr_segm^.sp1c_mess_type = sp1m_parse)
THEN
    upg.curr_segm^.sp1c_with_info        := false
ELSE
    upg.curr_segm^.sp1c_with_info        := upg.info;
(*ENDIF*) 
snd_packet^.sp1_header.sp1h_mess_code    := upg.code_type;
snd_packet^.sp1_header.sp1h_application  := upg.application;
snd_packet^.sp1_header.sp1h_appl_version := upg.appl_version;
upg.pfkey  := pf_none;
snd_length := s26packet_len (snd_packet);
snd_packet^.sp1_header.sp1h_varpart_len := snd_length -
      sizeof (snd_packet^.sp1_header);
CASE  upg.term_simulation OF
    tasim_unicode:
        IF  upg.swap = sw_normal
        THEN
            snd_packet^.sp1_header.sp1h_mess_code := csp_unicode
        ELSE
            snd_packet^.sp1_header.sp1h_mess_code := csp_unicode_swap;
        (*ENDIF*) 
    OTHERWISE:;
    END;
(*ENDCASE*) 
&ifdef TRACE
t02int4   (debug_ta, 'REQUEST: ref', upg.reference);
IF  t02trace (debug_ta)
THEN
    x05packet (upg.term^, upg.prot.refer, t02is_minbuf, t02buflength_max,
          'REQUEST     ', snd_packet);
&endif
(*ENDIF*) 
IF  upg.rtime
THEN
    ta320get_time (upg.roldtime);
(*ENDIF*) 
999 :
      sqlarequest (upg.reference, snd_packet, snd_length,
      err_string, sql_retcode);
&ifdef TRACE
t02int4 (debug_ta, 'REQUEST-rc  ', ord (sql_retcode));
&endif
IF  sql_retcode <> sp1ce_ok
THEN
    BEGIN
    u05request_errmsg (upg.term^, upg.prot.refer, err_string, sql_retcode);
    returncode := cut_sql_req_failed
    END
ELSE
    BEGIN
    rcv_length:= 0;
    sqlareceive (upg.reference, rcv_packet, rcv_length,
          err_string, sql_retcode);
&   ifdef TRACE
    t02int4 (debug_ta, 'ref (sqlrec)', upg.reference);
    t02int4 (debug_ta, 'RECEIVE-rc  ', ord (sql_retcode));
&   endif
    IF  sql_retcode <> sp1ce_ok
    THEN
        BEGIN
        u05request_errmsg (upg.term^, upg.prot.refer, err_string, sql_retcode);
        returncode := cut_sql_req_failed
        END
    ELSE
        BEGIN
        IF  ((upg.more_segments = 0) OR (NOT upg.is_connected))
&           ifdef PARS
            AND (rcv_packet^.sp1_header.sp1h_no_of_segm = 1)
&           endif
            (* PTS 1111575 E.Z. *)
        THEN
            upg.curr_ret_segm := s26segmptr(rcv_packet^.sp1_segm)
        ELSE
            BEGIN
            upg.curr_ret_segm := s26segmptr(rcv_packet^.sp1_segm);
            IF  (upg.curr_ret_segm^.sp1r_function_code <> csp1_connect_fc)
            THEN
                s26next_segment (upg.curr_ret_segm);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        returncode := upg.curr_ret_segm^.sp1r_returncode;
        ta320check_retsegm (upg, upg.curr_ret_segm^, debug);
        s26find_part (upg.curr_ret_segm^, sp1pk_abap_istream, pAbapRead);
        IF  pAbapRead <> NIL
        THEN
            BEGIN
            IF  ta320ReadStream (upg, snd_packet, pAbapRead)
            THEN
                BEGIN
                snd_length := s26packet_len (snd_packet);
                goto 999;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        FOR ix := 1 TO upg.dbprocLongData.dbp_count DO
            BEGIN
            FOR jx := 1 TO upg.dbprocLongData.dbp_length[ix] DO
                upg.dbprocLongData.dbp_addr[ix]^[jx] := 'X';
            (*ENDFOR*) 
            sqlfree (upg.dbprocLongData.dbp_addr[ix]);
            END;
        (*ENDFOR*) 
        upg.dbprocLongData.dbp_count := 0;
        upg.stop   := false;
        IF  upg.rtime
        THEN
            BEGIN
            ta320get_time (new_time);
            new_time  := new_time - upg.roldtime;
            virt      := 'real  : ';
            li.text   := upg.term^.blankline;
            li.pos    := 0;
            li.length := 1;
            FOR i:= 1 TO 8 DO
                li.text[ i ]:= virt[ i ];
            (*ENDFOR*) 
            li.pos    := 9;
            li.length := 10;
            g17int4to_line (new_time, NOT c_with_zero, 8, li.pos, li.text);
            li.pos    := li.pos + 8;
            li.length := li.length + 8;
            t09putmsg (upg.term^, li.text, false, false);
            t09holding (upg.term^, upg.pfkey);
            upg.prot.ln := li.text;
            t320prot (upg, 19)
            END;
&       ifdef TRACE
        (*ENDIF*) 
        IF  t02trace (debug_ta)
        THEN
            x05packet (upg.term^, upg.prot.refer, t02is_minbuf,
                  t02buflength_max, 'RETURN      ', rcv_packet);
&       endif
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ta320ReadStream (
            VAR upg    : tta_user_proc_globals;
            snd_packet : tsp1_packet_ptr;
            pAbapRead  : tsp1_part_ptr) : boolean;
 
VAR
      idx      : tsp00_Int4;
      moveLen  : integer;
      cmd_segm : tsp1_segment_ptr;
      pData    : tsp1_part_ptr;
 
BEGIN
&ifdef trace
t02str30 (debug_ta, 'ta320ReadStream               ');
&endif
idx := s20buf_to_int4 (pAbapRead^.sp1p_buf, 1);
IF  (idx >= 1) AND (idx <= upg.dbprocLongData.dbp_count)
THEN
    BEGIN
    ta320ReadStream := true;
    IF  pAbapRead^.sp1p_arg_count = -2
    THEN
        upg.dbprocLongData.dbp_pos[idx] := 1;
    (*ENDIF*) 
    s26init_cmd_packet (snd_packet, cmd_segm);
    upg.curr_segm := cmd_segm;
    s26new_part_init (snd_packet, cmd_segm^, pData);
    pData^.sp1p_part_kind := sp1pk_data;
    moveLen := upg.dbprocLongData.dbp_length[idx] -
          upg.dbprocLongData.dbp_pos[idx] + 1;
    IF  moveLen > 0
    THEN
        BEGIN
        IF  moveLen > pData^.sp1p_buf_size
        THEN
            moveLen := pData^.sp1p_buf_size;
        (*ENDIF*) 
        SAPDB_PascalForcedMove (upg.dbprocLongData.dbp_length[idx], pData^.sp1p_buf_size,
              @upg.dbprocLongData.dbp_addr[idx]^, upg.dbprocLongData.dbp_pos[idx],
              @pData^.sp1p_buf, 1, moveLen);
        pData^.sp1p_buf_len := moveLen;
        upg.dbprocLongData.dbp_pos [idx] := upg.dbprocLongData.dbp_pos [idx] + moveLen;
&       ifdef trave
        t02moveobj (debug_ta, pData^.sp1p_buf, pData^.sp1p_buf_size, 1, moveLen);
&       endif
        END;
    (*ENDIF*) 
    IF  upg.dbprocLongData.dbp_pos[idx] > upg.dbprocLongData.dbp_length[idx]
    THEN
        pData^.sp1p_attributes := pData^.sp1p_attributes + [sp1pa_last_packet];
    (*ENDIF*) 
    s26finish_part (snd_packet, pData^);
    END
ELSE
    BEGIN
&   ifdef trave
    t02int4 (debug_always, 'bad stream  ', idx);
&   endif
    ta320ReadStream := false;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t320GetVal (
            VAR upg       : tta_user_proc_globals;
            snd_packet    : tsp1_packet_ptr;
            VAR long_desc : tsp00_LongDescriptor;
            VAR pData     : tsp1_part_ptr);
 
VAR
      rc         : tsp00_Int2;
      cmd_segm   : tsp1_segment_ptr;
      rcv_packet : tsp1_packet_ptr;
 
BEGIN
pData := NIL;
&ifdef trace
t02str30 (debug_ta, 't320GetVal                    ');
&endif
s26init_cmd_packet (snd_packet, cmd_segm);
upg.curr_segm            := cmd_segm;
cmd_segm^.sp1c_mess_type := sp1m_getval;
s26new_part_init (snd_packet, cmd_segm^, pData);
pData^.sp1p_part_kind := sp1pk_longdata;
pData^.sp1p_buf[1] := chr(0);
SAPDB_PascalForcedMove (sizeof(long_desc), pData^.sp1p_buf_size,
      @long_desc, 1, @pData^.sp1p_buf, 2, sizeof(long_desc));
pData^.sp1p_buf_len := 1 + sizeof(long_desc);
s26finish_part (snd_packet, pData^);
t320dbs_send (upg, snd_packet, rcv_packet, rc);
IF  rc = 0
THEN
    BEGIN
    s26find_part (upg.curr_ret_segm^, sp1pk_longdata, pData);
    IF  pData <> NIL
    THEN
        BEGIN
&       ifdef trace
        t02moveobj (debug_ta, pData^.sp1p_buf, pData^.sp1p_buf_size, 1, pData^.sp1p_buf_len);
&       endif
        SAPDB_PascalForcedMove (pData^.sp1p_buf_size, sizeof(long_desc),
              @pData^.sp1p_buf, 2, @long_desc, 1, sizeof(long_desc));
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320check_retsegm (
            VAR upg      : tta_user_proc_globals;
            VAR ret_segm : tsp1_segment;
            VAR debug    : tut_debug);
 
VAR
      kind_exist : ARRAY [ tsp1_part_kind ] OF boolean;
      segm_len   : tsp00_Int4;
      curr_index : tsp00_Int2;
      curr_part  : tsp1_part_ptr;
      kind       : tsp1_part_kind;
      ok         : boolean;
 
BEGIN
WITH ret_segm DO
    BEGIN
    debug := debug_ta;
    IF  (sp1r_function_code = csp1_nil_fc) AND
        (sp1r_returncode  <> -8000)        AND (*e_shutdown*)
        (sp1r_returncode  <> -8001)        AND (*e_user_not_connected*)
        (sp1r_returncode  <> -3005)        AND (*e_invalid_command*)
        (sp1r_returncode  <> -8044)        AND (*e_not_translatable*)
        (sp1r_returncode  <> -8045)        AND (*e_not_trans_to_uni*)
        (sp1r_returncode  <> -8046)        AND (*e_not_trans_from_uni*)
        (((sp1r_returncode <> -3008) AND       (*e_invalid_keyword*)
        (  sp1r_returncode <> -5015))   OR     (*e_wanted_keyword*)
        (sp1r_errorpos >
        10 + upg.bigcmd_offset))            AND
        (upg.first_token <> n_analyze)      AND
        (upg.first_token <> n_usage)        AND
        ((upg.first_token <> n_save)    OR
        (upg.second_token <> n_catalog))    AND
        ((upg.first_token <> n_restore) OR
        (upg.second_token <> n_catalog))    AND
        ((upg.first_token <> n_store)   OR
        (upg.second_token <> n_dbprocedure))
    THEN
        ta320invalid_segm (upg, debug,
              'NO FUNCTION_CODE FOUND        ', 0, sp1pk_nil);
    (*ENDIF*) 
    IF  debug = debug_ta
    THEN
        IF  NOT (
            ((sp1r_function_code >= csp1_nil_fc)      AND
            ( sp1r_function_code <= csp1_max_special_fc))
            OR
            ((sp1r_function_code >= csp1_min_masscmd_fc) AND
            ( sp1r_function_code <= csp1_max_masscmd_fc))
            )
        THEN
            ta320invalid_segm (upg, debug,
                  'UNKNOWN FUNCTION_CODE FOUND : ',
                  sp1r_function_code, sp1pk_nil);
        (*ENDIF*) 
    (*ENDIF*) 
    segm_len := sizeof (sp1s_segm_header);
    IF  (debug = debug_ta) AND (sp1s_no_of_parts > 0)
    THEN
        BEGIN
        FOR kind := sp1pk_nil TO sp1pk_last_part_kind DO
            kind_exist[ kind ] := false;
        (*ENDFOR*) 
        curr_index := 1;
        curr_part  := s26partptr (sp1p_part);
        WHILE (debug = debug_ta) AND
              (curr_index <= sp1s_no_of_parts) DO
            BEGIN
            IF  kind_exist[ curr_part^.sp1p_part_kind ]
            THEN
                ta320invalid_segm (upg, debug,
                      'DUPLICATE PART IN RETURN SEGM:',
                      0, curr_part^.sp1p_part_kind);
            (*ENDIF*) 
            kind_exist[ curr_part^.sp1p_part_kind ] := true;
            IF  (debug = debug_ta) AND (curr_part^.sp1p_buf_len = 0)
            THEN
                BEGIN
                CASE curr_part^.sp1p_part_kind OF
                    sp1pk_resulttablename:
                        ok := true;
                    sp1pk_shortinfo, sp1pk_vardata_shortinfo:
                        ok := curr_part^.sp1p_arg_count = 0;
                    sp1pk_data:
                        ok := (curr_part^.sp1p_arg_count = 0) AND
                              (sp1r_function_code>csp1_masscmd_fc_offset);
                    OTHERWISE
                        ok := false
                    END;
                (*ENDCASE*) 
                IF  NOT ok
                THEN
                    ta320invalid_segm (upg, debug,
                          'EMPTY PART BUF IN RETURN SEGM:',
                          0, curr_part^.sp1p_part_kind)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            segm_len   := segm_len + s26partlen (curr_part^);
            curr_index := succ (curr_index);
            IF  curr_index <= sp1s_no_of_parts
            THEN
                s26nextpart (curr_part)
            (*ENDIF*) 
            END
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    IF  (debug = debug_ta) AND (segm_len <> sp1s_segm_len)
    THEN
        ta320invalid_segm (upg, debug,
              'INVALID RETURN SEGM LENGTH :  ', segm_len, sp1pk_nil);
    (*ENDIF*) 
    IF  (debug = debug_ta) AND (sp1r_returncode = 0) AND
        (upg.execution in [ tek_only_parsing, tek_pars_then_execute ]) AND
        (upg.curr_segm^.sp1c_mess_type = sp1m_parse)
    THEN
        BEGIN
        s26find_part (ret_segm, sp1pk_parsid, curr_part);
        IF  curr_part = NIL
        THEN
            ta320invalid_segm (upg, debug,
                  'MISSING RETURN PART        :  ', 0, sp1pk_parsid)
        ELSE
            BEGIN
            IF  NOT upg.variable_input
            THEN
                BEGIN
                s26find_part (ret_segm, sp1pk_shortinfo, curr_part);
                IF  curr_part = NIL
                THEN
                    ta320invalid_segm (upg, debug,
                          'MISSING RETURN PART        :  ', 0,
                          sp1pk_shortinfo)
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                s26find_part (ret_segm, sp1pk_vardata_shortinfo, curr_part);
                IF  curr_part = NIL
                THEN
                    ta320invalid_segm (upg, debug,
                          'MISSING RETURN PART        :  ', 0,
                          sp1pk_vardata_shortinfo)
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  upg.prot.session
THEN
    BEGIN
    s26find_part (ret_segm, sp1pk_session_info_returned, curr_part);
    IF  curr_part <> NIL
    THEN
        ta320session_info_prot (upg, curr_part^)
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320invalid_segm (
            VAR upg       : tta_user_proc_globals;
            VAR debug     : tut_debug;
            err_text      : tsp00_C30;
            err_number    : tsp00_Int4;
            err_part_kind : tsp1_part_kind);
 
VAR
      li     : tsp00_DataLine;
      ln_len : integer;
 
BEGIN
SAPDB_PascalForcedMove (sizeof (err_text), sizeof (upg.prot.ln),
      @err_text, 1, @li.text, 1, 30);
ln_len := 30;
IF  err_number <> 0
THEN
    BEGIN
    li.pos := 31;
    g17int4to_line (err_number, NOT c_with_zero, 5, li.pos, li.text);
    ln_len := 35
    END;
(*ENDIF*) 
IF  err_part_kind <> sp1pk_nil
THEN
    g17sp1partkind_to_line (err_part_kind, ln_len, li.text);
(*ENDIF*) 
upg.prot.ln := li.text;
t320prot (upg, ln_len);
debug := debug_always
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320session_info_prot (
            VAR upg       : tta_user_proc_globals;
            VAR curr_part : tsp1_part);
 
CONST
      date_format_len_pos  = 6;
      date_format_pos      = 7;
      date_lang_pos        = 158;
      language_pos         = 164;
      format_coded_len_pos = 107;
      format_coded_pos     = 108;
      numeric_chars_pos    = 171;
 
VAR
      ln_len    : integer;
      length    : integer;
      char_size : integer;
 
BEGIN
IF  upg.term_simulation = tasim_unicode
THEN
    char_size := 2
ELSE
    char_size := 1;
(*ENDIF*) 
(* *)
ln_len := 0;
g17sname_to_line ('DATE_FORMAT:', ln_len, upg.prot.ln);
length := ord (curr_part.sp1p_buf[ date_format_len_pos ]);
SAPDB_PascalForcedMove (curr_part.sp1p_buf_len, sizeof (upg.prot.ln),
      @curr_part.sp1p_buf, date_format_pos,
      @upg.prot.ln, ln_len+1, length);
IF  upg.term_simulation = tasim_unicode
THEN (* Convert the errormsg to ascii. *)
    t320unicode2ascii (upg,
          length, @upg.prot.ln[ ln_len+1 ], length);
(*ENDIF*) 
t320prot (upg, ln_len+length);
;
length := 3 * char_size;
ln_len := 0;
g17sname_to_line ('DATE_LANG  :', ln_len, upg.prot.ln);
SAPDB_PascalForcedMove (curr_part.sp1p_buf_len, sizeof (upg.prot.ln),
      @curr_part.sp1p_buf, date_lang_pos,
      @upg.prot.ln, ln_len+1, length);
IF  upg.term_simulation = tasim_unicode
THEN (* Convert the errormsg to ascii. *)
    t320unicode2ascii (upg,
          length, @upg.prot.ln[ ln_len+1 ], length);
(*ENDIF*) 
t320prot (upg, ln_len+length);
;
length := 3 * char_size;
ln_len := 0;
g17sname_to_line ('LANGUAGE   :', ln_len, upg.prot.ln);
SAPDB_PascalForcedMove (curr_part.sp1p_buf_len, sizeof (upg.prot.ln),
      @curr_part.sp1p_buf, language_pos, @upg.prot.ln, ln_len+1, length);
IF  upg.term_simulation = tasim_unicode
THEN (* Convert the errormsg to ascii. *)
    t320unicode2ascii (upg,
          length, @upg.prot.ln[ ln_len+1 ], length);
(*ENDIF*) 
t320prot (upg, ln_len+length);
;
length := 2 * char_size;
ln_len := 0;
g17sname_to_line ('NUM_CHARS  :', ln_len, upg.prot.ln);
SAPDB_PascalForcedMove (curr_part.sp1p_buf_len, sizeof (upg.prot.ln),
      @curr_part.sp1p_buf, numeric_chars_pos, @upg.prot.ln, ln_len+1, length);
IF  upg.term_simulation = tasim_unicode
THEN (* Convert the errormsg to ascii. *)
    t320unicode2ascii (upg,
          length, @upg.prot.ln[ ln_len+1 ], length);
(*ENDIF*) 
t320prot (upg, ln_len+length);
;
&ifdef trace
length := ord (curr_part.sp1p_buf[ format_coded_len_pos ]);
t02moveobj (debug_always,
      curr_part.sp1p_buf, curr_part.sp1p_buf_len,
      format_coded_pos, format_coded_pos+length-1);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320only_parsing_cmd (
            VAR upg        : tta_user_proc_globals;
            snd_packet     : tsp1_packet_ptr;
            VAR rcv_packet : tsp1_packet_ptr;
            VAR returncode : tsp00_Int2;
            send_mess_type : tsp1_cmd_mess_type);
 
VAR
      i              : integer;
      outline        : tsp00_DataLine;
      shortinfos     : tta_fields;
      parsid_part    : tsp1_part_ptr;
      shortinfo_part : tsp1_part_ptr;
 
BEGIN
upg.pfkey := pf_none;
IF  upg.p_count + 1 > cta_max_parsing
THEN
    BEGIN
    outline.text:= upg.term^.blankline;
    t320string_to_line (pars_arr_over, outline.text);
    t09put (upg.term^, outline.text, cut_protected);
    upg.prot.ln := outline.text;
    t320prot (upg, 40);
    returncode := buffer_overflow
    END
ELSE
    BEGIN
    IF  upg.appl_param_infos
    THEN
        ta320get_appl_param (upg, snd_packet);
    (*ENDIF*) 
    upg.curr_segm^.sp1c_mess_type := send_mess_type;
    t320dbs_send (upg,
          snd_packet, rcv_packet, returncode);
    IF  (returncode = 0) AND (upg.pfkey = pf_none)
    THEN
        BEGIN
        s26find_part (upg.curr_ret_segm^, sp1pk_parsid, parsid_part);
        IF  parsid_part <> NIL
        THEN
            BEGIN
            SAPDB_PascalForcedMove (parsid_part^.sp1p_buf_size,
                  sizeof (upg.parsing[ upg.p_count+1 ]),
                  @parsid_part^.sp1p_buf, 1,
                  @upg.parsing[ upg.p_count+1 ], 1,
                  parsidlength);
            IF  NOT (ord (upg.parsing[ upg.p_count+1 ][ parsidlength - 1 ])
                in [ csp1_p_command_executed, csp1_p_use_adbs ])
            THEN
                BEGIN
                upg.p_count := succ (upg.p_count);
                (* PTS 1105196 E.Z. *)
                upg.dbprocCall := upg.curr_ret_segm^.sp1r_function_code = csp1_pl_sql_execute_fc;
                upg.execute_input [ upg.p_count ].cnt_input_fields := 0;
                upg.execute_output[ upg.p_count ].cnt_input_fields := 0;
                IF  NOT upg.variable_input
                THEN
                    s26find_part (upg.curr_ret_segm^,
                          sp1pk_shortinfo, shortinfo_part)
                ELSE
                    s26find_part (upg.curr_ret_segm^,
                          sp1pk_vardata_shortinfo, shortinfo_part);
                (*ENDIF*) 
                IF  shortinfo_part <> NIL
                THEN
                    BEGIN
                    WITH shortinfo_part^, shortinfos DO
                        BEGIN
                        cnt_res_fields := sp1p_arg_count;
                        IF  cnt_res_fields > 0
                        THEN
                            SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (res_fieldparam),
                                  @sp1p_buf, 1, @res_fieldparam, 1, sp1p_buf_len)
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                    WITH shortinfos, upg.execute_input[ upg.p_count ] DO
                        BEGIN
                        cnt_input_fields := 0;
                        FOR i := 1 TO cnt_res_fields DO
                            IF  (
                                ((res_fieldparam[ i ].sp1i_bufpos  > 0) AND NOT upg.variable_input) OR
                                ((res_fieldparam[ i ].sp1i_param_no  > 0) AND upg.variable_input)
                                ) AND
                                (
                                (res_fieldparam[ i ].sp1i_io_type=sp1io_input)
                                OR
                                (res_fieldparam[ i ].sp1i_io_type=sp1io_inout)
                                )
                            THEN
                                BEGIN
                                cnt_input_fields := succ (cnt_input_fields);
                                input_params[ cnt_input_fields ] :=
                                      res_fieldparam[ i ]
                                END;
&                           ifdef TRACE
                            (*ENDIF*) 
                        (*ENDFOR*) 
                        ta320shortinfo_trace (upg, 'input_params',
                              cnt_input_fields, input_params);
&                       endif
                        END;
                    (*ENDWITH*) 
                    WITH shortinfos, upg.execute_output[ upg.p_count ] DO
                        BEGIN
                        cnt_input_fields := 0;
                        FOR i := 1 TO cnt_res_fields DO
                            IF  (res_fieldparam[ i ].sp1i_bufpos  > 0) AND
                                (res_fieldparam[ i ].sp1i_io_type=sp1io_output) AND
                                (cnt_input_fields < cta_max_input_fields)
                            THEN
                                BEGIN
                                cnt_input_fields := succ (cnt_input_fields);
                                input_params[ cnt_input_fields ] :=
                                      res_fieldparam[ i ]
                                END;
&                           ifdef TRACE
                            (*ENDIF*) 
                        (*ENDFOR*) 
                        ta320shortinfo_trace (upg, 'outputparams',
                              cnt_input_fields, input_params);
&                       endif
                        END
                    (*ENDWITH*) 
                    END;
                (*ENDIF*) 
                IF  upg.execute_output[ upg.p_count ].cnt_input_fields = 0
                THEN
                    BEGIN
                    s26find_part (upg.curr_ret_segm^,
                          sp1pk_output_cols_no_parameter, shortinfo_part);
                    IF  shortinfo_part <> NIL
                    THEN
                        BEGIN
                        WITH shortinfo_part^, shortinfos DO
                            BEGIN
                            cnt_res_fields := sp1p_arg_count;
                            IF  cnt_res_fields > 0
                            THEN
                                SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (res_fieldparam),
                                      @sp1p_buf, 1, @res_fieldparam, 1, sp1p_buf_len)
                            (*ENDIF*) 
                            END;
                        (*ENDWITH*) 
                        WITH shortinfos, upg.execute_output[ upg.p_count ] DO
                            BEGIN
                            cnt_input_fields := 0;
                            FOR i := 1 TO cnt_res_fields DO
                                IF  (res_fieldparam[ i ].sp1i_bufpos  > 0) AND
                                    (res_fieldparam[ i ].sp1i_io_type=sp1io_output) AND
                                    (cnt_input_fields < cta_max_input_fields)
                                THEN
                                    BEGIN
                                    cnt_input_fields := succ (cnt_input_fields);
                                    input_params[ cnt_input_fields ] :=
                                          res_fieldparam[ i ]
                                    END;
&                               ifdef TRACE
                                (*ENDIF*) 
                            (*ENDFOR*) 
                            ta320shortinfo_trace (upg, 'outputparams',
                                  cnt_input_fields, input_params);
&                           endif
                            END
                        (*ENDWITH*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                outline.text   := upg.term^.blankline;
                outline.pos    := 0;
                outline.length := 1;
                t320string_to_line (out_idno_pars_msg, outline.text);
                outline.pos    := 20;
                g17int4to_line (upg.p_count, NOT c_with_zero, 3,
                      outline.pos, outline.text);
                outline.pos:= outline.pos + 3;
                outline.length:= outline.length + 3;
                t09put (upg.term^, outline.text, cut_protected);
                upg.prot.ln := outline.text;
                t320prot (upg, outline.pos);
                (* PTS 1111575 E.Z. *)
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320cmd_pars_then_execute (
            VAR upg        : tta_user_proc_globals;
            snd_packet     : tsp1_packet_ptr;
            VAR rcv_packet : tsp1_packet_ptr;
            VAR returncode : tsp00_Int2;
            column_ptr1    : integer;
            column_ptr2    : integer;
            VAR parseid    : tsp00_C12;
            rescount       : tsp00_Int2);
 
CONST
      e_use_adbs = -5;
 
VAR
      with_drop          : boolean;
      only_pars          : boolean;
      is_mfetch          : boolean;
      i                  : integer;
      subtract_cnt       : integer;
      masscmd_cnt        : tsp00_Int4;
      ex_in              : tta_ex_in;
      rcv_parsid_part    : tsp1_part_ptr;
      rcv_shortinfo_part : tsp1_part_ptr;
      snd_segm           : tsp1_segment_ptr;
      snd_data_part      : tsp1_part_ptr;
      snd_rescnt_part    : tsp1_part_ptr;
      infparams_count    : tsp00_Int2;
      res                : tsp00_NumError;
      dataportions       : integer;
      in_line            : tsp00_DataLine;
      cmd_part           : tsp1_part_ptr;
      c40                : tsp00_C40;
      (* h.b. CR 1000072 *)
      is_first_part      : boolean;
      is_last_part       : boolean;
      columnnames_part : tsp1_part_ptr;
      curr_pos         : tsp00_Int2;
      curr_ident       : tsp00_Int2;
      curr_length      : tsp00_Int4;
      curr_segm_index  : tsp00_Int2;
 
BEGIN
&ifdef TRACE
t02str30 (debug_ta, 'ta320cmd_pars_then_execute    ');
&endif
upg.pfkey := pf_none;
with_drop := (upg.second_token <> n_release) OR
      ((upg.first_token <> n_commit) AND (upg.first_token <> n_rollback));
dataportions  := 1;
is_first_part :=  false;
is_last_part  :=  false;
masscmd_cnt   := rescount;
IF  (upg.first_token = n_mfetch ) OR
    (upg.first_token = n_rfetch ) OR
    (upg.first_token = n_mdelete) OR
    (upg.first_token = n_minsert) OR
    (upg.first_token = n_mlock) OR
    (upg.first_token = n_mselect) OR
    (upg.first_token = n_mdeclare) OR
    (upg.first_token = n_mupdate)
THEN
    BEGIN
    ta320read_int (upg, masscmd_cnt);
    is_first_part := (masscmd_cnt = csp_maxint2);
    IF  (upg.first_token <> n_mfetch ) AND
        (upg.first_token <> n_rfetch )
    THEN
        BEGIN
        ta320read_int (upg, dataportions);
        IF  dataportions < 0
        THEN
            dataportions  := -dataportions
        ELSE
            is_last_part := true
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  upg.appl_param_infos
THEN
    ta320get_appl_param (upg, snd_packet);
(*ENDIF*) 
upg.curr_segm^.sp1c_mess_type := sp1m_parse;
curr_segm_index := upg.curr_segm^.sp1s_own_index;
t320dbs_send (upg,
      snd_packet, rcv_packet, returncode);
IF  (returncode = 0) AND NOT upg.stop AND (upg.pfkey= pf_none)
THEN
    BEGIN
    ta320tablename (upg, upg.curr_ret_segm^);
    ta320warning_print (upg, upg.curr_ret_segm^);
    IF  (upg.curr_ret_segm^.sp1r_function_code = csp1_delete_fc) AND
        (warn0_exist     in upg.curr_ret_segm^.sp1r_extern_warning) AND
        (warn4_nullwhere in upg.curr_ret_segm^.sp1r_extern_warning)
    THEN
        BEGIN
        upg.shared_sql_drop   := true;
        upg.shared_drop_trans := true;
        END;
    (*ENDIF*) 
    upg.dbprocCall := upg.curr_ret_segm^.sp1r_function_code = csp1_pl_sql_execute_fc;
    upg.infparams.cnt_res_fields := 0;
    ex_in.cnt_input_fields       := 0;
    IF  NOT upg.variable_input
    THEN
        s26find_part (upg.curr_ret_segm^,
              sp1pk_shortinfo, rcv_shortinfo_part)
    ELSE
        s26find_part (upg.curr_ret_segm^,
              sp1pk_vardata_shortinfo, rcv_shortinfo_part);
    (*ENDIF*) 
    IF  rcv_shortinfo_part <> NIL
    THEN
        WITH rcv_shortinfo_part^, upg.infparams DO
            BEGIN
            cnt_res_fields := sp1p_arg_count;
            SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (res_fieldparam),
                  @sp1p_buf, 1, @res_fieldparam, 1, sp1p_buf_len)
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    WITH upg.infparams, ex_in DO
        FOR i := 1 TO cnt_res_fields DO
            IF  
                (
                (res_fieldparam[ i ].sp1i_io_type=sp1io_input)
                OR
                (res_fieldparam[ i ].sp1i_io_type=sp1io_inout)
                )
                AND
                (res_fieldparam[ i ].sp1i_bufpos > 0)
            THEN
                BEGIN
                cnt_input_fields                 := succ (cnt_input_fields);
                input_params[ cnt_input_fields ] := res_fieldparam[ i ]
                END;
            (*ENDIF*) 
        (*ENDFOR*) 
    (*ENDWITH*) 
    IF  (returncode = 0) AND (upg.pfkey = pf_none) AND
        (upg.infparams.cnt_res_fields > 0)
    THEN
        WITH upg.infparams DO
            BEGIN
            infparams_count := cnt_res_fields;
            cnt_res_fields  := 0;
            subtract_cnt    := 0;
            s26find_part (upg.curr_ret_segm^,
                  sp1pk_columnnames, columnnames_part);
            FOR i := 1 TO infparams_count DO
                IF  res_fieldparam[ i ].sp1i_io_type = sp1io_output
                THEN
                    BEGIN
                    cnt_res_fields                   := succ (cnt_res_fields);
                    res_fieldparam[ cnt_res_fields ] := res_fieldparam[ i ];
                    SAPDB_PascalForcedFill (sizeof (res_fieldname [ cnt_res_fields ]),
                          @res_fieldname[cnt_res_fields], 1,
                          sizeof (res_fieldname[cnt_res_fields]), bsp_c1);
&                   ifdef LONGREC
                    IF  res_fieldparam[ i ].sp1i_length = 24079
                    THEN
                        subtract_cnt := 1;
&                   endif
&                   ifdef MAXCOLS
                    (*IF  (res_fieldparam[ i ].sp1i_length = 13) AND
                          (res_fieldparam[ i ].sp1i_data_type in
                          [ dcha,
                          dche,
                          dchb,
                          dunicode,
                          dvarchara,
                          dvarchare,
                          dvarcharb,
                          dvarcharuni ])
                          *)
                    (*ENDIF*) 
                    IF  res_fieldparam[ i ].sp1i_data_type = dboolean
                    THEN
                        subtract_cnt := 490;
&                   endif
                    (*ENDIF*) 
                    IF  columnnames_part = NIL
                    THEN
                        IF  cnt_res_fields-subtract_cnt < 10
                        THEN
                            res_fieldname[ cnt_res_fields ][ 1 ]:=
                                  chr (cnt_res_fields-subtract_cnt + ord ('0'))
                        ELSE
                            BEGIN
                            res_fieldname[ cnt_res_fields ][ 1 ] :=
                                  chr ((cnt_res_fields-subtract_cnt) DIV 10 + ord ('0'));
                            res_fieldname[ cnt_res_fields ][ 2 ] :=
                                  chr ((cnt_res_fields-subtract_cnt) MOD 10 + ord ('0'))
                            END
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDFOR*) 
            IF  columnnames_part <> NIL
            THEN
                WITH columnnames_part^, upg.infparams DO
                    BEGIN
&                   ifdef TRACE
                    t02int4 (debug_ta, 'columnnames#', sp1p_arg_count);
&                   endif
                    curr_pos := 1;
                    FOR curr_ident := 1 TO sp1p_arg_count DO
                        BEGIN
                        curr_length := ord (sp1p_buf[ curr_pos ]);
                        curr_pos    := succ (curr_pos);
                        SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (tsp00_KnlIdentifier),
                              @sp1p_buf, curr_pos,
                              @res_fieldname[ curr_ident ], 1, curr_length);
                        SAPDB_PascalForcedFill (sizeof (res_fieldname[ curr_ident ]),
                              @res_fieldname[ curr_ident ], curr_length+1,
                              sizeof (tsp00_KnlIdentifier) - curr_length, ' ');
                        curr_pos := curr_pos + curr_length;
                        IF  upg.term_simulation = tasim_unicode
                        THEN
                            t320unicode2ascii (upg,
                                  sizeof (res_fieldname[ curr_ident ]),
                                  @res_fieldname[ curr_ident ], curr_length);
                        (*ENDIF*) 
                        END
                    (*ENDFOR*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            upg.inlength := sizeof (upg.infparams)
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    s26find_part (upg.curr_ret_segm^, sp1pk_parsid, rcv_parsid_part);
    IF  rcv_parsid_part <> NIL
    THEN
        WITH rcv_parsid_part^ DO
            SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (parseid),
                  @sp1p_buf, 1, @parseid, 1, parsidlength);
        (*ENDWITH*) 
    (*ENDIF*) 
    is_mfetch := (ord (parseid[ parsidlength-1 ]) = csp1_p_mfetch_found) OR
          (upg.curr_ret_segm^.sp1r_function_code = csp1_mselect_into_fc);
    s26first_segment_init (snd_packet, sp1sk_cmd, snd_segm);
    upg.curr_segm := snd_segm;
    IF  (upg.more_segments > 0) AND (upg.is_connected)
    THEN
        BEGIN
        s26new_part_init (snd_packet, snd_segm^, cmd_part);
        cmd_part^.sp1p_part_kind := sp1pk_command;
        c40 := 'SELECT ''abc''||''def''INTO :a FROM DUAL    ';
        SAPDB_PascalForcedMove (sizeof(c40), sizeof(tsp00_Line),
              @c40, 1, @in_line.text, 1, sizeof(c40));
        in_line.pos    := 38;
        in_line.length := 38;
        t320buildbuffer (in_line, snd_segm^);
        t320finish_part (upg, snd_packet, cmd_part^);
        snd_segm^.sp1c_with_info := true;
        s26new_segment_init (snd_packet, sp1sk_cmd, snd_segm, cmd_part);
        upg.curr_segm := snd_segm;
        END;
    (*ENDIF*) 
    t320parseid_part (upg, snd_packet, snd_segm^, parseid);
    only_pars := ord (parseid[ parsidlength-1 ]) in
          [ csp1_p_command_executed, csp1_p_use_adbs ];
    IF  only_pars AND (ord (parseid[ parsidlength-1 ]) = csp1_p_use_adbs)
    THEN
        BEGIN
        snd_segm^.sp1r_returncode := e_use_adbs;
        snd_segm^.sp1r_errorpos   := -1
        END;
    (*ENDIF*) 
    IF  upg.is_data_input AND (ex_in.cnt_input_fields > 0)
    THEN
        ta320get_data_input (upg, ex_in, snd_packet);
    (*ENDIF*) 
    IF  upg.variable_input
    THEN
        s26find_part (snd_segm^, sp1pk_vardata, snd_data_part)
    ELSE
        s26find_part (snd_segm^, sp1pk_data, snd_data_part);
    (*ENDIF*) 
    IF   (snd_data_part <> NIL)
    THEN
        BEGIN
        snd_data_part^.sp1p_arg_count := dataportions;
        IF  is_first_part
        THEN
            snd_data_part^.sp1p_attributes :=
                  snd_data_part^.sp1p_attributes + [sp1pa_first_packet];
        (*ENDIF*) 
        IF  is_last_part
        THEN
            snd_data_part^.sp1p_attributes :=
                  snd_data_part^.sp1p_attributes + [sp1pa_last_packet];
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  is_mfetch
    THEN
        t320resultcount_part (upg, snd_packet,
              snd_segm^, masscmd_cnt);
    (*ENDIF*) 
    IF   (snd_data_part <> NIL) AND (column_ptr1 <> 0)
    THEN
        WITH snd_data_part^ DO
            SAPDB_PascalForcedMove (sizeof (upg.open_cols[ 1 ].descr), sp1p_buf_size,
                  @upg.open_cols[ column_ptr1 ].descr, 1, @sp1p_buf, 2, 8);
        (*ENDWITH*) 
    (*ENDIF*) 
    IF   (snd_data_part <> NIL) AND (column_ptr2 <> 0)
    THEN
        WITH snd_data_part^ DO
            SAPDB_PascalForcedMove (sizeof(upg.open_cols[ 1 ].descr), sp1p_buf_size,
                  @upg.open_cols[ column_ptr2 ].descr, 1, @sp1p_buf, 11, 8);
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  NOT only_pars
    THEN
        BEGIN
        snd_segm^.sp1c_mess_type := sp1m_execute;
        t320dbs_send (upg, snd_packet, rcv_packet, returncode)
        END;
    (*ENDIF*) 
    END
ELSE
    parseid[ c_p_info_pos ] := chr(ord(csp1_p_command_executed))
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t320drop_parseid (
            VAR upg     : tta_user_proc_globals;
            snd_packet  : tsp1_packet_ptr;
            VAR parseid : tsp00_C12);
 
VAR
      rcv_packet  : tsp1_packet_ptr;
      returncode  : tsp00_Int2;
      cmd_segm    : tsp1_segment_ptr;
      cmd_part    : tsp1_part_ptr;
      m_info      : boolean;
      c8          : tsp00_C8;
      in_line     : tsp00_DataLine;
      c40         : tsp00_C40;
 
BEGIN
ta320packet_init (upg, snd_packet, cmd_segm, cmd_part);
upg.curr_segm := cmd_segm;
cmd_part^.sp1p_part_kind := sp1pk_command;
IF  (upg.more_segments > 0) AND (upg.is_connected)
THEN
    BEGIN
    c40 := 'SELECT ''abc''||''def''INTO :a FROM DUAL    ';
    SAPDB_PascalForcedMove (sizeof(c40), sizeof(tsp00_Line),
          @c40, 1, @in_line.text, 1, sizeof(c40));
    in_line.pos    := 38;
    in_line.length := 38;
    t320buildbuffer (in_line, cmd_segm^);
    t320finish_part (upg, snd_packet, cmd_part^);
    cmd_segm^.sp1c_with_info := true;
    s26new_segment_init (snd_packet, sp1sk_cmd, cmd_segm, cmd_part);
    upg.curr_segm := cmd_segm;
    s26new_part_init (snd_packet, cmd_segm^, cmd_part);
    cmd_part^.sp1p_part_kind := sp1pk_command;
    END;
(*ENDIF*) 
WITH cmd_part^ DO
    BEGIN
    c8 := 'DROP    ';
    SAPDB_PascalForcedMove (sizeof (c8), sp1p_buf_size, @c8, 1, @sp1p_buf, 1, 5);
    c8 := 'PARSEID ';
    SAPDB_PascalForcedMove (sizeof (c8), sp1p_buf_size, @c8, 1, @sp1p_buf, 6, 7);
    sp1p_buf_len := 12
    END;
(*ENDWITH*) 
t320finish_part (upg, snd_packet, cmd_part^);
t320parseid_part (upg, snd_packet,
      cmd_segm^, parseid);
m_info   := upg.info;
upg.info := false;
t320dbs_send (upg, snd_packet, rcv_packet, returncode);
upg.info := m_info
END;
 
(*------------------------------*) 
 
PROCEDURE
      t320dbcall (
            VAR upg        : tta_user_proc_globals;
            snd_packet     : tsp1_packet_ptr;
            VAR rcv_packet : tsp1_packet_ptr;
            VAR returncode : tsp00_Int2;
            VAR parseid    : tsp00_C12;
            rescount       : tsp00_Int2);
 
VAR
      delimiter    : char;
      idno         : integer;
      i            : integer;
      j            : integer;
      ptr1         : integer;
      ptr2         : integer;
      colid        : tsp00_Sname;
      ptr_name     : tsp00_Name;
      ptr_name2    : tsp00_Name;
      resname      : tsp00_KnlIdentifier;
      li           : tsp00_Line;
      dli          : tsp00_DataLine;
      ex_in        : tta_ex_in;
      snd_segm     : tsp1_segment_ptr;
      parsid_part  : tsp1_part_ptr;
      data_part    : tsp1_part_ptr;
      ignore_it    : boolean;
      long_dtype   : tsp00_DataType;
 
BEGIN
&ifdef trace
t02str30 (debug_ta, 't320dbcall                    ');
&endif
ignore_it := false;
ptr1      := 0;
ptr2      := 0;
ex_in.act_cnt_fields   := 1;
ex_in.cnt_input_fields := 1;
IF  upg.prepare AND
    (upg.execution in [ tek_only_syntax, tek_pars_then_execute,
    tek_only_parsing ])
THEN
    ta320prepare (upg, upg.curr_segm^);
(*ENDIF*) 
IF  upg.is_data_input
THEN
    IF  (upg.second_token = n_column) AND (upg.first_token <> n_open)
        AND (upg.first_token <> n_fread)
        AND (upg.first_token <> n_fwrite)
    THEN
        BEGIN
        IF  upg.execution <> tek_only_parsing
        THEN
            BEGIN
            ptr_name  := bsp_name;
            ptr_name2 := bsp_name;
            t09get1name (upg.term^, 'ENTER SRC COL ID :  ', cut_protected,
                  cut_unprotected, NAME_MXSP00, false, ptr_name, upg.pfkey);
            upg.prot.ln := upg.term^.blankline;
            colid := 'SRC COL ID: ';
            FOR i := 1 TO 12 DO
                upg.prot.ln [ i ] := colid [ i ];
            (*ENDFOR*) 
            FOR i := 1 TO 18 DO
                upg.prot.ln [ i + 12 ] := ptr_name [ i ];
            (*ENDFOR*) 
            IF  upg.first_token = 'COPY        '
            THEN
                BEGIN
                t09get1name (upg.term^, 'ENTER DST COL ID :  ', cut_protected,
                      cut_unprotected, NAME_MXSP00, false,
                      ptr_name2, upg.pfkey);
                colid := 'DST COL ID: ';
                FOR i := 1 TO 12 DO
                    upg.prot.ln [ i + 30 ] := colid [ i ];
                (*ENDFOR*) 
                FOR i := 1 TO 18 DO
                    upg.prot.ln [ i + 42 ] := ptr_name2 [ i ];
                (*ENDFOR*) 
                END;
            (*ENDIF*) 
            t320prot (upg, 55);
&           ifdef TRACE
            t02name (debug_ta, ptr_name);
            t02name (debug_ta, ptr_name2);
&           endif
            IF  NOT (upg.pfkey in [ pf_end, pf_cancel ])
            THEN
                BEGIN
                ptr1 := ord (ptr_name [ 1 ]) - ord ('0');
&               ifdef TRACE
                t02int4 (debug_ta, 'col_index   ', ptr1);
&               endif
                IF  (ptr1 > 5) OR (ptr1 < 1)
                THEN
                    BEGIN
                    t09put20 (upg.term^, 'ILLEGAL COLUMN ID   ',
                          cut_bright_protected);
                    long_dtype := dstrb
                    END
                ELSE
                    long_dtype := upg.open_cols[ ptr1 ].
                          shortinfo.sp1i_data_type;
                (*ENDIF*) 
                IF  upg.execution <> tek_pars_then_execute
                THEN
                    BEGIN
                    ta320fill_ex_in (upg, ex_in, long_dtype);
                    ta320get_data_input (upg, ex_in, snd_packet);
                    IF  upg.variable_input
                    THEN
                        BEGIN
                        s26find_part (upg.curr_segm^, sp1pk_vardata, data_part);
                        IF  (data_part <> NIL) AND (ptr1 <= 5) AND (ptr1 >= 1)
                        THEN
                            SAPDB_PascalForcedMove (sizeof (upg.open_cols[ 1 ].descr),
                                  data_part^.sp1p_buf_size,
                                  @upg.open_cols[ ptr1 ].descr, 1,
                                  @data_part^.sp1p_buf, 4, 8)
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        s26find_part (upg.curr_segm^, sp1pk_data, data_part);
                        IF  (data_part <> NIL) AND (ptr1 <= 5) AND (ptr1 >= 1)
                        THEN
                            SAPDB_PascalForcedMove (sizeof (upg.open_cols[ 1 ].descr),
                                  data_part^.sp1p_buf_size,
                                  @upg.open_cols[ ptr1 ].descr, 1,
                                  @data_part^.sp1p_buf, 2, 8)
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  upg.first_token = 'COPY        '
                THEN
                    BEGIN
                    ptr2 := ord (ptr_name2 [ 1 ]) - ord ('0');
&                   ifdef TRACE
                    t02int4 (debug_ta, 'col_index   ', ptr2);
&                   endif
                    IF  (ptr2 > 5) OR (ptr2 < 1)
                    THEN
                        t09put20 (upg.term^, 'ILLEGAL COLUMN ID   ',
                              cut_bright_protected);
                    (*ENDIF*) 
                    IF  upg.execution <> tek_pars_then_execute
                    THEN
                        IF  (data_part <> NIL) AND (ptr2 <= 5) AND (ptr2 >= 1)
                        THEN
                            SAPDB_PascalForcedMove (sizeof(upg.open_cols[ 1 ].descr),
                                  data_part^.sp1p_buf_size,
                                  @upg.open_cols[ ptr2 ].descr, 1,
                                  @data_part^.sp1p_buf, 11, 8)
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    ELSE
        IF  (upg.first_token = n_fwrite) AND (upg.second_token = n_column)
        THEN
            BEGIN
            IF  (upg.execution <> tek_pars_then_execute) AND
                (upg.execution <> tek_only_parsing)
            THEN
                BEGIN
                ta320fill_ex_in (upg, ex_in, dstrb);
                ta320get_data_input (upg, ex_in, snd_packet)
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
CASE upg.execution OF
    tek_only_parsing :
        BEGIN
        ta320only_parsing_cmd (upg,
              snd_packet, rcv_packet, returncode, sp1m_parse);
        IF  (returncode = 0) AND NOT upg.stop AND (upg.pfkey= pf_none)
        THEN
            ta320tablename (upg, upg.curr_ret_segm^)
        (*ENDIF*) 
        END;
    tek_only_executing :
        BEGIN
        t09put20 (upg.term^, 'enter idno:         ', cut_bright_protected);
        t09get (upg.term^, li, upg.pfkey);
        i:= 1;
        ta320read_number (i, li, idno);
        j := 0;
        ta320skipbl (li, i);
        IF  (i < LINE_MXSP00) AND (li [ i ] = ',')
        THEN
            BEGIN (* result name specified *)
            resname := bsp_knl_identifier;
            j       := 1;
            i       := i + 1;
            ta320skipbl (li, i);
            IF  li[ i ] = string_delimiter
            THEN
                BEGIN
                i := i + 1;
                delimiter := string_delimiter
                END
            ELSE
                delimiter := ' ';
            (*ENDIF*) 
            WHILE i <= LINE_MXSP00 DO
                BEGIN
                IF  li[ i ] = delimiter
                THEN
                    i := LINE_MXSP00
                ELSE
                    IF  j <= sizeof(resname)
                    THEN
                        BEGIN
                        resname[ j ] := li[ i ];
                        j := j + 1
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                i := i + 1
                END;
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        dli.text   := upg.term^.blankline;
        dli.pos    := 0;
        dli.length := 1;
        t320string_to_line (in_idno_pars_msg, dli.text);
        dli.pos:= 19;
        g17int4to_line (idno, NOT c_with_zero, 3, dli.pos, dli.text);
        dli.pos:= dli.pos + 3;
        dli.length:= dli.length + 3;
        t09put (upg.term^, dli.text, cut_protected);
        upg.prot.ln := dli.text;
        t320prot (upg, dli.pos);
        IF  j > 0
        THEN
            BEGIN
            dli.text   := upg.term^.blankline;
            dli.pos    := 0;
            dli.length := 1;
            t320string_to_line (resname_msg, dli.text);
            dli.pos:= 19;
            FOR i := 1 TO NAME_MXSP00 DO
                BEGIN
                dli.text[ dli.pos ] := resname[ i ];
                dli.pos := dli.pos + 1
                END;
            (*ENDFOR*) 
            t09put (upg.term^, dli.text, cut_protected);
            upg.prot.ln := dli.text;
            t320prot (upg, dli.pos)
            END;
        (*ENDIF*) 
        IF  (idno < 1) OR (idno > cta_max_parsing)
        THEN
            ignore_it := true
        ELSE
            BEGIN
            s26find_part (upg.curr_segm^,
                  sp1pk_parsid, parsid_part);
            IF  parsid_part <> NIL
            THEN
                WITH parsid_part^ DO
                    SAPDB_PascalForcedMove (sizeof (upg.parsing[ idno ]), sp1p_buf_size,
                          @upg.parsing[ idno ], 1, @sp1p_buf, 1,
                          parsidlength);
                (*ENDWITH*) 
            (*ENDIF*) 
            IF  NOT (((upg.first_token = n_mfetch ) AND
                (upg.second_token <> n_rest)) OR
                (upg.first_token = n_rfetch))
            THEN
                IF  ((upg.first_token = n_minsert) OR
                    (upg.first_token = n_mupdate) OR
                    (upg.first_token = n_mdelete) OR
                    (upg.first_token = n_mselect) OR
                    (upg.first_token = n_mdeclare))
                THEN
                    BEGIN
                    upg.curr_segm^.sp1c_mess_type := sp1m_execute;
                    IF  upg.variable_input
                    THEN
                        s26find_part (upg.curr_segm^, sp1pk_vardata, data_part)
                    ELSE
                        s26find_part (upg.curr_segm^,
                              sp1pk_data, data_part);
                    (*ENDIF*) 
                    IF  (data_part <> NIL) AND (parsid_part <> NIL)
                    THEN
                        IF  (data_part^.sp1p_arg_count = 1) AND
                            (sp1pa_last_packet in
                            data_part^.sp1p_attributes)
                        THEN
                            ta320reset_parseid (parsid_part^)
                        ELSE
                            IF  (((upg.first_token = n_minsert ) OR
                                (  upg.first_token = n_mupdate ) OR
                                (  upg.first_token = n_mdelete )) AND
                                (parsid_part^.sp1p_buf[ parsidlength-1 ]
                                = chr(csp1_p_none)))
                                OR
                                (((upg.first_token = n_mdeclare) OR
                                (  upg.first_token = n_mselect )) AND
                                ((parsid_part^.sp1p_buf[ parsidlength-1 ] =
                                chr (csp1_p_mass_select_found)) OR
                                (parsid_part^.sp1p_buf[ parsidlength-1 ] =
                                chr (csp1_p_select_for_update_found)) OR
                                (parsid_part^.sp1p_buf[ parsidlength-1 ] =
                                chr (csp1_p_reuse_mass_select_found)) OR
                                (parsid_part^.sp1p_buf[ parsidlength-1 ] =
                                chr (csp1_p_reuse_update_sel_found))))
                            THEN
                                BEGIN
                                t320string_to_line (msg_wrong_cnt, li);
                                t09put (upg.term^, li, cut_protected);
                                upg.prot.ln := li;
                                t320prot (upg, 40);
                                FOR i := 1 TO parsidlength DO
                                    parsid_part^.sp1p_buf[ i ] := chr (0)
                                (*ENDFOR*) 
                                END
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    IF  parsid_part = NIL
                    THEN
                        BEGIN
                        IF  (upg.more_segments > 0) AND (upg.is_connected)
                        THEN
                            BEGIN
                            upg.curr_segm^.sp1s_segm_len    := sizeof (tsp1_segment_header);
                            upg.curr_segm^.sp1s_no_of_parts := 0;
                            snd_segm := upg.curr_segm;
                            END
                        ELSE
                            s26first_segment_init (snd_packet,
                                  sp1sk_cmd, snd_segm);
                        (*ENDIF*) 
                        upg.curr_segm := snd_segm;
                        snd_segm^.sp1c_mess_type := sp1m_execute;
                        t320parseid_part (upg, snd_packet,
                              snd_segm^, upg.parsing[ idno ])
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            IF  upg.is_data_input AND
                (upg.execute_input[ idno ].cnt_input_fields > 0)
            THEN
                ta320get_data_input (upg, upg.execute_input[ idno ],
                      snd_packet);
            (*ENDIF*) 
            IF  j > 0
            THEN
                ta320resname_part (upg, snd_packet,
                      upg.curr_segm^, resname);
            (*ENDIF*) 
            t320dbs_send (upg,
                  snd_packet, rcv_packet, returncode);
            IF  (returncode = -9) (* h.b *)
            THEN
                BEGIN
                s26find_part (upg.curr_ret_segm^, sp1pk_parsid, parsid_part);
                IF  parsid_part <> NIL
                THEN
                    SAPDB_PascalForcedMove (parsid_part^.sp1p_buf_size,
                          sizeof (upg.parsing[ idno ]),
                          @parsid_part^.sp1p_buf, 1,
                          @upg.parsing[ idno ], 1,
                          parsidlength);
                (*ENDIF*) 
                END;
            (* PTS 1105196 E.Z. *)
&           ifdef TRACE
            (*ENDIF*) 
            t02int4 (debug_ta, 'ex cnt outco', upg.execute_output[ idno ].cnt_input_fields);
&           endif
            IF  (upg.execute_output[ idno ].cnt_input_fields > 0)
            THEN
                WITH upg.infparams DO
                    BEGIN
                    cnt_res_fields := upg.execute_output[ idno ].cnt_input_fields;
                    FOR i := 1 TO upg.execute_output[ idno ].cnt_input_fields DO
                        BEGIN
                        res_fieldparam [i] := upg.execute_output[ idno ].input_params [i];
                        SAPDB_PascalForcedFill (sizeof (res_fieldname [ i ]),
                              @res_fieldname[i], 1,
                              sizeof (res_fieldname[i]), bsp_c1);
                        IF  cnt_res_fields < 10
                        THEN
                            res_fieldname[ i ][ 1 ]:=
                                  chr (i + ord ('0'))
                        ELSE
                            BEGIN
                            res_fieldname[ i ][ 1 ] :=
                                  chr ((i) DIV 10 + ord ('0'));
                            res_fieldname[ i ][ 2 ] :=
                                  chr ((i) MOD 10 + ord ('0'))
                            END
                        (*ENDIF*) 
                        END;
                    (*ENDFOR*) 
                    upg.inlength := sizeof (upg.infparams);
&                   ifdef TRACE
                    t02int4 (debug_ta, 'upg.inlength', upg.inlength);
&                   endif
                    END
                (*ENDWITH*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    tek_pars_then_execute:
        ta320cmd_pars_then_execute (upg,
              snd_packet, rcv_packet, returncode, ptr1, ptr2,
              parseid, rescount);
    tek_only_syntax :
        BEGIN
        upg.curr_segm^.sp1c_mess_type := sp1m_syntax;
        t320dbs_send (upg,
              snd_packet, rcv_packet, returncode)
        END;
    (* PTS 1111575 E.Z. *)
    tek_parsing_executing :
        BEGIN
        upg.curr_segm^.sp1c_mess_type := sp1m_dbs;
        IF  (upg.first_token = n_open) AND upg.is_data_input
        THEN
            BEGIN
            FOR i := 1 TO cta_max_input_fields DO
                WITH ex_in.input_params[ i ] DO
                    BEGIN
                    sp1i_data_type := dstrb;
                    sp1i_bufpos    := -1;
                    sp1i_length    := 0
                    END;
                (*ENDWITH*) 
            (*ENDFOR*) 
            ta320get_data_input (upg, ex_in, snd_packet)
            END;
        (*ENDIF*) 
        t320dbs_send (upg,
              snd_packet, rcv_packet, returncode);
        IF  (returncode = 0) AND NOT upg.stop AND (upg.pfkey= pf_none)
        THEN
            ta320tablename (upg, upg.curr_ret_segm^)
        (*ENDIF*) 
        END;
    tek_dbsload :
        BEGIN
        upg.curr_segm^.sp1c_mess_type := sp1m_load;
        t320dbs_send (upg,
              snd_packet, rcv_packet, returncode);
        upg.execution := tek_parsing_executing
        END
    END;
(*ENDCASE*) 
IF  ignore_it
THEN
    returncode := cut_sql_req_failed
ELSE
    IF  (upg.execution = tek_only_executing) AND (returncode = 0)
    THEN
        ta320find_longdata (upg, upg.curr_ret_segm^)
    ELSE
        upg.longdesccnt := 0
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320prepare (
            VAR upg      : tta_user_proc_globals;
            VAR cmd_segm : tsp1_segment);
 
VAR
      pos, ix     : tsp00_Int4;
      char_width  : tsp00_Int4;
      swap_offset : tsp00_Int4;
 
BEGIN
CASE  upg.code_type OF
    csp_unicode:
        BEGIN
        char_width  := 2;
        swap_offset := 0
        END;
    csp_unicode_swap:
        BEGIN
        char_width  := 2;
        swap_offset := 1
        END;
    OTHERWISE
        BEGIN
        char_width  := 1;
        swap_offset := 0
        END
    END;
(*ENDCASE*) 
WITH cmd_segm DO
    BEGIN
    pos := char_width - swap_offset;
    WHILE (pos < sp1p_buf_len) AND (sp1p_buf[ pos ] = bsp_c1) DO
        pos := pos + char_width;
    (*ENDWHILE*) 
    FOR ix := 1 TO 5*char_width DO
        sp1p_buf[ pos+ ix - 1 ] := csp_unicode_mark;
    (*ENDFOR*) 
    FOR ix := 1 TO 5 DO
        sp1p_buf[ pos + (ix - 1) * char_width ] := bsp_c1;
    (*ENDFOR*) 
    sp1c_prepare := true
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320reset_parseid (VAR parsid_part : tsp1_part);
 
BEGIN
WITH  parsid_part DO
    CASE ord(sp1p_buf[ parsidlength-1 ]) OF
        csp1_p_mass_command :
            sp1p_buf[ parsidlength-1 ] := chr (csp1_p_none);
        csp1_p_mselect_found :
            sp1p_buf[ parsidlength-1 ] := chr (csp1_p_mass_select_found);
        csp1_p_for_upd_mselect_found :
            sp1p_buf[ parsidlength-1 ] := chr(csp1_p_select_for_update_found);
        csp1_p_reuse_mselect_found :
            sp1p_buf[ parsidlength-1 ] := chr(csp1_p_reuse_mass_select_found);
        csp1_p_reuse_upd_mselect_found :
            sp1p_buf[ parsidlength-1 ] := chr(csp1_p_reuse_update_sel_found);
        OTHERWISE
            BEGIN
            END
        END;
    (*ENDCASE*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320fill_ex_in (
            VAR upg    : tta_user_proc_globals;
            VAR ex_in  : tta_ex_in;
            long_dtype : tsp00_DataType);
 
VAR
      in_out_len : tsp00_Int4;
 
BEGIN
IF  (upg.first_token = 'READ        ') OR
    (upg.first_token = 'WRITE       ') OR
    (upg.first_token = 'CLOSE       ') OR
    (upg.first_token = 'EXPAND      ') OR
    (upg.first_token = 'SEARCH      ') OR
    (upg.first_token = 'TRUNC       ') OR
    (upg.first_token = 'COPY        ') OR
    (upg.first_token = 'LENGTH      ')
THEN
    BEGIN
    ex_in.cnt_input_fields := 1;
    ta320set_infield (ex_in.input_params[ 1 ],
          sp1ot_optional, sp1io_input, dchb,
          8, 0, 9, 1)
    END;
(*ENDIF*) 
IF  upg.first_token = 'LENGTH      '
THEN
    ex_in.cnt_input_fields := 1;
(*ENDIF*) 
IF  (upg.first_token = 'READ        ') OR
    (upg.first_token = 'WRITE       ') OR
    (upg.first_token = 'SEARCH      ') OR
    (upg.first_token = 'TRUNC       ') OR
    (upg.first_token = 'EXPAND      ')
THEN
    ta320set_infield (ex_in.input_params[ 2 ],
          sp1ot_optional, sp1io_input, dfixed,
          10, 0, 7, 10);
(*ENDIF*) 
IF  upg.first_token = 'TRUNC       '
THEN
    ex_in.cnt_input_fields := 2;
(*ENDIF*) 
IF  (upg.first_token = 'READ        ') OR
    (upg.first_token = 'WRITE       ')
THEN
    BEGIN
    ta320set_infield (ex_in.input_params[ 3 ],
          sp1ot_optional, sp1io_input, dfixed,
          5, 0, 5, 17);
    IF  upg.first_token = 'READ        '
    THEN
        ex_in.cnt_input_fields := 3;
    (*ENDIF*) 
    IF  upg.first_token = 'WRITE       '
    THEN
        BEGIN
        ex_in.cnt_input_fields := 4;
        ta320set_infield (ex_in.input_params[ 4 ],
              sp1ot_optional, sp1io_input, long_dtype,
              0, 0, 0, 22)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  upg.first_token = 'SEARCH      '
THEN
    BEGIN
    ta320set_infield (ex_in.input_params[ 3 ],
          sp1ot_optional, sp1io_input, dfixed,
          10, 0, 7, 17);
    ta320set_infield (ex_in.input_params[ 4 ],
          sp1ot_optional, sp1io_input, dchb,
          254, 0, 255, 24);
    ex_in.cnt_input_fields := 4
    END;
(*ENDIF*) 
IF  upg.first_token = 'EXPAND      '
THEN
    BEGIN
    IF  upg.term_simulation = tasim_unicode
    THEN
        in_out_len := 3
    ELSE
        in_out_len := 2;
    (*ENDIF*) 
    ta320set_infield (ex_in.input_params[ 3 ],
          sp1ot_optional, sp1io_input, dchb,
          1, 0, in_out_len, 17);
    ex_in.cnt_input_fields := 3
    END;
(*ENDIF*) 
IF  upg.first_token = 'COPY        '
THEN
    BEGIN
    ta320set_infield (ex_in.input_params[ 2 ],
          sp1ot_optional, sp1io_input, dchb,
          8, 0, 9, 10);
    ta320set_infield (ex_in.input_params[ 3 ],
          sp1ot_optional, sp1io_input, dfixed,
          10, 0, 7, 19);
    ta320set_infield (ex_in.input_params[ 4 ],
          sp1ot_optional, sp1io_input, dfixed,
          10, 0, 7, 26);
    ta320set_infield (ex_in.input_params[ 5 ],
          sp1ot_optional, sp1io_input, dfixed,
          10, 0, 7, 33);
    ex_in.cnt_input_fields := 5
    END;
(*ENDIF*) 
IF  upg.first_token = 'FWRITE      '
THEN
    BEGIN
    ta320set_infield (ex_in.input_params[ 1 ],
          sp1ot_optional, sp1io_input, dfixed,
          5, 0, 5, 1);
    ta320set_infield (ex_in.input_params[ 2 ],
          sp1ot_optional, sp1io_input, long_dtype,
          0, 0, 0, 6);
    ex_in.cnt_input_fields := 2
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320do_putval (
            VAR upg        : tta_user_proc_globals;
            snd_packet     : tsp1_packet_ptr;
            VAR rcv_packet : tsp1_packet_ptr;
            VAR returncode : tsp00_Int2);
 
VAR
      oldlong   : boolean;
      varinput  : boolean;
      i         : integer;
      idno      : integer;
      offset    : integer;
      li        : tsp00_Line;
      dli       : tsp00_DataLine;
      ex_in     : tta_ex_in;
      snd_segm  : tsp1_segment_ptr;
      data_part : tsp1_part_ptr;
 
BEGIN
varinput := upg.variable_input;
upg.variable_input := false;
t09put20 (upg.term^, 'enter idno:         ', cut_bright_protected);
t09get (upg.term^, li, upg.pfkey);
i := 1;
ta320read_number (i, li, idno);
dli.text   := upg.term^.blankline;
dli.pos    := 0;
dli.length := 1;
t320string_to_line (in_idno_pars_msg, dli.text);
dli.pos:= 19;
g17int4to_line (idno, NOT c_with_zero, 3, dli.pos, dli.text);
dli.pos:= dli.pos + 3;
dli.length:= dli.length + 3;
t09put (upg.term^, dli.text, cut_protected);
upg.prot.ln := dli.text;
t320prot (upg, dli.pos);
oldlong := false;
ex_in.cnt_input_fields := 0;
&ifdef trace
ta320shortinfo_trace (upg, 'shortinfos  ',
      upg.execute_input[idno].cnt_input_fields,
      upg.execute_input[idno].input_params);
&endif
WITH upg.execute_input[idno] DO
    FOR i := 1 TO cnt_input_fields DO
        WITH input_params[i] DO
            IF  (sp1i_io_type = sp1io_input) AND
                (sp1i_data_type in [ dstra, dstrb, dstruni ])
            THEN
                BEGIN
                oldlong := true;
                ex_in.cnt_input_fields := succ(ex_in.cnt_input_fields);
                ex_in.input_params[ex_in.cnt_input_fields] := input_params[i];
                IF  upg.variable_input
                THEN
                    ex_in.input_params[ex_in.cnt_input_fields].sp1i_param_no := ex_in.cnt_input_fields
                ELSE
                    ex_in.input_params[ex_in.cnt_input_fields].sp1i_bufpos :=
                          1 + (ex_in.cnt_input_fields-1) * (LONG_DESC_MXSP00+1)
                (*ENDIF*) 
                END
            ELSE
                IF  (sp1i_io_type = sp1io_input) AND
                    (sp1i_data_type in [ dlonga, dlongb, dlonguni ])
                THEN
                    BEGIN
                    ex_in.cnt_input_fields := succ(ex_in.cnt_input_fields);
                    ex_in.input_params[ex_in.cnt_input_fields] := input_params[i];
                    IF  upg.variable_input
                    THEN
                        ex_in.input_params[ex_in.cnt_input_fields].sp1i_param_no := ex_in.cnt_input_fields
                    ELSE
                        ex_in.input_params[ex_in.cnt_input_fields].sp1i_bufpos :=
                              1 + (ex_in.cnt_input_fields-1) * (LONG_DESC_BLOCK_MXSP00+1)
                    (*ENDIF*) 
                    END;
&               ifdef trace
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDFOR*) 
(*ENDWITH*) 
ta320shortinfo_trace (upg, 'ex_in.params',
      ex_in.cnt_input_fields, ex_in.input_params);
&endif
IF  oldlong
THEN
    FOR i := 1 TO ex_in.cnt_input_fields DO
        ex_in.input_params[i].sp1i_in_out_len := 2 +
              ex_in.cnt_input_fields * (LONG_DESC_MXSP00 + 1) + 1
    (*ENDFOR*) 
ELSE
    FOR i := 1 TO ex_in.cnt_input_fields DO
        ex_in.input_params[i].sp1i_in_out_len := 2 +
              ex_in.cnt_input_fields * (LONG_DESC_BLOCK_MXSP00 + 1) + 1;
    (*ENDFOR*) 
(*ENDIF*) 
IF  (upg.more_segments > 0) AND (upg.is_connected)
THEN
    BEGIN
    upg.curr_segm^.sp1s_segm_len    :=
          sizeof (tsp1_segment_header);
    upg.curr_segm^.sp1s_no_of_parts := 0;
    snd_segm := upg.curr_segm;
    END
ELSE
    s26first_segment_init (snd_packet, sp1sk_cmd, snd_segm);
(*ENDIF*) 
upg.curr_segm := snd_segm;
snd_segm^.sp1c_mess_type := sp1m_putval;
s26new_part_init (snd_packet, snd_segm^, data_part);
WITH data_part^ DO
    IF  upg.longdesccnt > 0
    THEN
        BEGIN
        sp1p_part_kind := sp1pk_longdata;
        (*
              if upg.variable_input then begin
              offset := 2;
              sp1p_buf[1] := chr(upg.longdesccnt div 256);
              sp1p_buf[2] := chr(upg.longdesccnt mod 256);
              end
              else
              *)
        offset := 0;
        sp1p_buf_len   := offset + upg.longdesccnt * (LONG_DESC_MXSP00 + 1);
        sp1p_arg_count := upg.longdesccnt;
        SAPDB_PascalForcedMove (sizeof (upg.longdescs), sp1p_buf_size,
              @upg.longdescs, 1, @sp1p_buf, offset + 1,
              sp1p_buf_len - offset )
        END
    ELSE
        BEGIN (* the beginning of the old snd_part contains a longdesc! *)
        (*       this will not be true starting with 7.4.4.1            *)
        sp1p_part_kind := sp1pk_longdata;
        sp1p_buf_len   := sizeof (tsp00_LongDescriptor) + 1;
        sp1p_arg_count := 1
        END;
    (*ENDIF*) 
(*ENDWITH*) 
ta320get_data_input (upg, ex_in, snd_packet);
t320dbs_send (upg,
      snd_packet, rcv_packet, returncode);
IF  returncode = 0
THEN
    ta320find_longdata (upg, upg.curr_ret_segm^)
ELSE
    BEGIN
    upg.longdesccnt := 0;
    IF  (returncode <> cut_sql_req_failed) AND (upg.pfkey = pf_none)
    THEN
        t320errmsg (upg, upg.curr_ret_segm^)
    (*ENDIF*) 
    END;
(*ENDIF*) 
upg.variable_input := varinput;
END;
 
(*------------------------------*) 
 
PROCEDURE
      t320prot (
            VAR upg : tta_user_proc_globals;
            len : integer);
 
VAR
      aux_err : integer;
 
BEGIN
IF  NOT upg.prot.no_prot
THEN
    BEGIN
    t12write_prot (upg.prot.refer, upg.prot.ln, len, aux_err);
    upg.prot.err := aux_err
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320remove_double_quotes (VAR n : tsp00_Name);
 
VAR
      found : boolean;
      i     : integer;
      aux_n : tsp00_Name;
 
BEGIN
IF  n [1] = double_quote
THEN
    BEGIN
    aux_n := bsp_name;
    i     := 1;
    found := false;
    WHILE NOT found AND (i < sizeof (n)) DO
        IF  n[ i+1 ] = double_quote
        THEN
            found := true
        ELSE
            BEGIN
            aux_n[ i ] := n[ i+1 ];
            i          := succ (i)
            END;
        (*ENDIF*) 
    (*ENDWHILE*) 
    IF  found
    THEN
        n := aux_n
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320packet_init (
            VAR upg            : tta_user_proc_globals;
            VAR snd_packet_ptr : tsp1_packet_ptr;
            VAR first_segm_ptr : tsp1_segment_ptr;
            VAR first_part_ptr : tsp1_part_ptr);
 
BEGIN
s26init_cmd_packet (snd_packet_ptr, first_segm_ptr);
upg.curr_segm := first_segm_ptr;
WITH snd_packet_ptr^.sp1_header, upg DO
    BEGIN
    sp1h_appl_version := appl_version;
    sp1h_application  := application;
    sp1h_mess_code    := code_type
    END;
(*ENDWITH*) 
s26new_part_init (snd_packet_ptr, first_segm_ptr^, first_part_ptr);
first_part_ptr^.sp1p_part_kind := sp1pk_command
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320set_infield (
            VAR infield : tsp1_param_info;
            mode       : tsp1_param_opt_type;
            io_type    : tsp1_param_io_type;
            data_type  : tsp00_DataType;
            length     : tsp00_Int2;
            frac       : tsp00_Uint1;
            in_out_len : tsp00_Int2;
            bufpos     : tsp00_Int4);
 
BEGIN
WITH infield DO
    BEGIN
    sp1i_mode       := [ mode ];
    sp1i_io_type    := io_type;
    sp1i_data_type  := data_type;
    sp1i_length     := length;
    sp1i_frac       := frac;
    sp1i_in_out_len := in_out_len;
    sp1i_bufpos     := bufpos
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      t320parseid_part (
            VAR upg      : tta_user_proc_globals;
            snd_packet   : tsp1_packet_ptr;
            VAR snd_segm : tsp1_segment;
            VAR parsid   : tsp00_C12);
 
VAR
      parsid_part : tsp1_part_ptr;
 
BEGIN
s26new_part_init (snd_packet, snd_segm, parsid_part);
WITH parsid_part^ DO
    BEGIN
    sp1p_part_kind := sp1pk_parsid;
    sp1p_buf_len   := parsidlength;
    SAPDB_PascalForcedMove (sizeof (parsid), sp1p_buf_size,
          @parsid, 1, @sp1p_buf, 1, sp1p_buf_len)
    END;
(*ENDWITH*) 
t320finish_part (upg, snd_packet, parsid_part^)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320resname_part (
            VAR upg    : tta_user_proc_globals;
            snd_packet : tsp1_packet_ptr;
            VAR snd_segm : tsp1_segment;
            VAR resname  : tsp00_KnlIdentifier);
 
VAR
      resname_part : tsp1_part_ptr;
 
BEGIN
s26new_part_init (snd_packet, snd_segm, resname_part);
WITH resname_part^ DO
    BEGIN
    sp1p_part_kind := sp1pk_resulttablename;
    IF  resname <> bsp_knl_identifier
    THEN
        BEGIN
        sp1p_buf_len   := sizeof(resname);
        SAPDB_PascalForcedMove (sizeof (resname), sp1p_buf_size,
              @resname, 1, @sp1p_buf, 1, sp1p_buf_len)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
t320finish_part (upg, snd_packet, resname_part^)
END;
 
(*------------------------------*) 
 
PROCEDURE
      t320resultcount_part (
            VAR upg    : tta_user_proc_globals;
            snd_packet : tsp1_packet_ptr;
            VAR snd_segm : tsp1_segment;
            result       : tsp00_Int2);
 
VAR
      rescnt_part : tsp1_part_ptr;
      num_err     : tsp00_NumError;
 
BEGIN
s26new_part_init (snd_packet, snd_segm, rescnt_part);
WITH rescnt_part^ DO
    BEGIN
    sp1p_part_kind := sp1pk_resultcount;
    sp1p_buf_len   := sizeof (tsp00_ResNum);
    IF  result = MAX_INT2_SP00
    THEN
        sp1p_buf[ 1 ] := csp_undef_byte
    ELSE
        BEGIN
        sp1p_buf[ 1 ] := csp_defined_byte;
        s41psint (sp1p_buf, 2, csp_resnum_deflen, 0, result, num_err)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
t320finish_part (upg, snd_packet, rescnt_part^)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320find_longdata (
            VAR upg      : tta_user_proc_globals;
            VAR ret_segm : tsp1_segment);
 
VAR
      longdata_part    : tsp1_part_ptr;
 
BEGIN
s26find_part (ret_segm, sp1pk_longdata, longdata_part);
IF  longdata_part <> NIL
THEN
    IF  longdata_part^.sp1p_buf_len = 0
    THEN
        upg.longdesccnt := 0
    ELSE
        BEGIN
        upg.longdesccnt := longdata_part^.sp1p_arg_count;
        SAPDB_PascalForcedMove (longdata_part^.sp1p_buf_size, sizeof (upg.longdescs),
              @longdata_part^.sp1p_buf, 1, @upg.longdescs, 1, longdata_part^.sp1p_buf_len)
        END;
    (*ENDIF*) 
&ifdef trace
(*ENDIF*) 
IF  longdata_part <> NIL
THEN
    t02int4 (debug_ta, 'longdata/len', longdata_part^.sp1p_buf_len)
ELSE
    t02int4 (debug_ta, 'longdata NIL', 0);
(*ENDIF*) 
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      t320finish_part (
            VAR upg    : tta_user_proc_globals;
            packet_ptr : tsp1_packet_ptr;
            VAR part   : tsp1_part);
 
BEGIN
IF  (upg.term_simulation = tasim_unicode) AND
    (part.sp1p_part_kind in [ sp1pk_command, sp1pk_resulttablename ])
THEN
    BEGIN
    IF  part.sp1p_part_kind = sp1pk_resulttablename
    THEN
        part.sp1p_buf_len := part.sp1p_buf_len DIV 2;
&   ifdef trace
    (*ENDIF*) 
    t02name   (debug_ta, 'connect packet 2a>');
    IF  t02trace (debug_ta)
    THEN
        x05packet (upg.term^, upg.prot.refer, t02is_minbuf,
              t02buflength_max, 'snd_packet  ', packet_ptr);
&   endif
    (*ENDIF*) 
    part.sp1p_buf_len := ta320ascii2unicode (upg,
          @part.sp1p_buf, part.sp1p_buf_len, part.sp1p_buf_size);
&   ifdef trace
    t02name   (debug_ta, 'connect packet 2b>');
    IF  t02trace (debug_ta)
    THEN
        x05packet (upg.term^, upg.prot.refer, t02is_minbuf,
              t02buflength_max, 'snd_packet  ', packet_ptr);
&   endif
    (*ENDIF*) 
    END;
(*ENDIF*) 
s26finish_part (packet_ptr, part)
END;
 
(*------------------------------*) 
 
FUNCTION
      ta320ascii2unicode (
            VAR upg   : tta_user_proc_globals;
            buf_ptr   : tsp00_MoveObjPtr;
            ascii_len : tsp00_Int4;
            buf_size  : tsp00_Int4) : tsp00_Int4;
 
VAR
      unicode_len : tsp00_Int4;
      error       : tsp8_uni_error;
      err_char_no : tsp00_Int4;
      msg         : tsp00_C40;
 
BEGIN
(* The problem is, that for ascii to unicode translation the   *)
(* buffers mustn't start at the same place. But it is okay, if *)
(* both buffers end at the same place (src moved to the right).*)
(* Forbidden: I-src_buf-|         | Ok: I         |-src_buf-|  *)
(*            I-destination_buf---|     |---destination_buf-|  *)
SAPDB_PascalForcedOverlappingMove (buf_size, buf_size,
      buf_ptr, 1, buf_ptr, 1+ascii_len, ascii_len);
unicode_len := buf_size;
s80uni_trans (@(buf_ptr^[ 1+ascii_len ]), ascii_len,   upg.extern_enc,
      @(buf_ptr^[ 1 ]),           unicode_len, csp_unicode,
      [ ], error, err_char_no);
IF  (upg.swap <> sw_normal) AND (error = uni_ok)
THEN
    BEGIN
&   ifdef TRACE
    t02int4 (debug_ta, 'FULL SWAP   ', upg.extern_enc);
&   endif
    s80uni_trans (@(buf_ptr^[ 1 ]), unicode_len, csp_unicode,
          @(buf_ptr^[ 1 ]), unicode_len, csp_unicode_swap,
          [ ], error, err_char_no);
    END;
(*ENDIF*) 
IF  error <> uni_ok
THEN
    BEGIN
    s80uni_error (error, msg);
    ta320put_msg (upg, msg)
    END;
(*ENDIF*) 
ta320ascii2unicode := unicode_len
END;
 
(*------------------------------*) 
 
PROCEDURE
      t320unicode2ascii (
            VAR upg     : tta_user_proc_globals;
            buf_size    : tsp00_Int4;
            buf_ptr     : tsp00_MoveObjPtr;
            VAR buf_len : tsp00_Int4);
 
VAR
      error       : tsp8_uni_error;
      err_char_no : tsp00_Int4;
      msg         : tsp00_C40;
      m_len       : tsp00_Int4;
 
BEGIN
&ifdef trace
t02int4 (debug_ta, 'extern_enc  ', upg.extern_enc);
t02moveobj (debug_ta, buf_ptr^, buf_size, 1, buf_len);
&endif
IF  upg.swap <> sw_normal
THEN
    BEGIN
    s80uni_trans (buf_ptr, buf_len, csp_unicode_swap,
          buf_ptr, buf_len, csp_unicode,
          [ ], error, err_char_no);
    IF  error <> uni_ok
    THEN
        BEGIN
        s80uni_error (error, msg);
        ta320put_msg (upg, msg);
        SAPDB_PascalForcedFill (buf_size, @buf_ptr^, 1, buf_len, '*')
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
m_len := buf_len;
s80uni_trans (buf_ptr, buf_len, csp_unicode,
      buf_ptr, buf_len, upg.extern_enc,
      [ ], error, err_char_no);
&ifdef trace
t02int4 (debug_ta, 'err_char_no ', err_char_no);
IF  buf_len > 0
THEN
    t02moveobj (debug_ta, buf_ptr^, buf_size, 1, buf_len);
&endif
(*ENDIF*) 
IF  error = uni_ok
THEN
    SAPDB_PascalForcedFill (buf_size, @buf_ptr^, buf_len+1, m_len-buf_len, bsp_c1)
ELSE
    BEGIN
    s80uni_error (error, msg);
    ta320put_msg (upg, msg);
    SAPDB_PascalForcedFill (buf_size, @buf_ptr^, 1, buf_len, '*')
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320write_features (
            VAR upg           : tta_user_proc_globals;
            snd_packet        : tsp1_packet_ptr;
            VAR cmd_segm      : tsp1_segment_ptr);
 
VAR
      feature_part     : tsp1_part_ptr;
      features         : tsp1_features;
      curr_feature     : tsp1_feature;
 
BEGIN
s26new_part_init (snd_packet, cmd_segm^, feature_part);
WITH feature_part^ DO
    BEGIN
    sp1p_part_kind := sp1pk_feature;
    FOR curr_feature := sp1f_nil_feature TO sp1f_last_feature DO
        BEGIN
        features[curr_feature].of_feature := curr_feature;
        CASE curr_feature OF
            sp1f_nil_feature, sp1f_last_feature,
            sp1f_space_option :
                features[curr_feature].of_value   := 0;
            sp1f_check_scrollableoption:
                IF  upg.check_scrollopt
                THEN
                    features[curr_feature].of_value   := 1
                ELSE
                    features[curr_feature].of_value   := 0;
                (*ENDIF*) 
            sp1f_ascii_in_and_output:
                features[curr_feature].of_value   := 1;
            OTHERWISE
                features[curr_feature].of_value   := 1;
            END;
        (*ENDCASE*) 
        END;
    (*ENDFOR*) 
    sp1p_arg_count := ord(sp1f_last_feature);
    sp1p_buf_len   := sp1p_arg_count * sizeof (tsp1_one_feature);
    SAPDB_PascalForcedMove (sizeof(features), sp1p_buf_size,
          @features, 1, @sp1p_buf, 1, sp1p_buf_len);
    END;
(*ENDWITH*) 
t320finish_part (upg, snd_packet, feature_part^);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ta320blank_out (
            VAR upg      : tta_user_proc_globals;
            VAR cmd_part : tsp1_part;
            blank_pos    : integer);
 
BEGIN
CASE  upg.code_type OF
    csp_unicode:
        blank_pos := 2 * blank_pos;
    csp_unicode_swap:
        blank_pos := 2 * blank_pos - 1;
    OTHERWISE;
    END;
(*ENDCASE*) 
IF  (upg.bigcmd_offset > 0) AND
    (cmd_part.sp1p_buf_size > upg.bigcmd_offset)
THEN
    blank_pos := blank_pos +  upg.bigcmd_offset;
(*ENDIF*) 
cmd_part.sp1p_buf[ blank_pos ] := ' '
END;
 
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      ta320shortinfo_trace (
            VAR upg        : tta_user_proc_globals;
            title          : tsp00_Sname;
            param_count    : tsp00_Int2;
            VAR paraminfos : tta_input_params);
 
VAR
      curr_param : tsp00_Int2;
      ln_len     : integer;
      ln         : tsp00_Line;
 
BEGIN
t02int4 (debug_ta, title, param_count);
FOR curr_param := 1 TO param_count DO
    BEGIN
    ln      := upg.term^.blankline;
    g17int4to_line (curr_param, NOT c_with_zero, 3, 1, ln);
    ln[ 4 ] := '.';
    ln_len  := 6;
    IF  upg.variable_input AND (paraminfos [curr_param].sp1i_io_type = sp1io_input)
    THEN
        g17varparaminfo_to_line (paraminfos[ curr_param ], ln_len, ln)
    ELSE
        g17paraminfo_to_line (paraminfos[ curr_param ], ln_len, ln)
    (*ENDIF*) 
    END
(*ENDFOR*) 
END;
 
&endif
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
