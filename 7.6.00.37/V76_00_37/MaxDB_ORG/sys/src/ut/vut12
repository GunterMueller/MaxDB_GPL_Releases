/* @lastChanged: "1999-01-20 12:00"
 
 * @filename:   vut12
 * @purpose:    "UT_diag_scheme_3"
 * @release:    7.2.0.0
 * @see:        "-.-"
 *
 * @Copyright (c) 1999-2005 SAP AG"
 */
 
.tt 1 $SAP$LiveCache$VUT12$
.tt 3 $$UT_diag_scheme_3$2000-10-05$
 
.nf
 
 .nf

.nf

    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo


.fo

 
.fo
***********************************************************
 
Module  : UT_diag_scheme_3
 
Define  :
 
        PROCEDURE
              u12domainreference (VAR term : tut_terminal;
                    VAR s        : tak_systembuffer;
                    protect_mode : char;
                    VAR modified : boolean;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              u12sdbnamerec (VAR term : tut_terminal;
                    VAR s        : tak_systembuffer;
                    protect_mode : char;
                    VAR modified : boolean;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              u12serverdbrec (VAR term : tut_terminal;
                    VAR s        : tak_systembuffer;
                    protect_mode : char;
                    VAR modified : boolean;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              u12sysuserrec (VAR term : tut_terminal;
                    VAR s        : tak_systembuffer;
                    protect_mode : char;
                    VAR modified : boolean;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              u12usagerec (VAR term : tut_terminal;
                    VAR s        : tak_systembuffer;
                    protect_mode : char;
                    VAR modified : boolean;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              u12usertabrec (VAR term : tut_terminal;
                    VAR s        : tak_systembuffer;
                    protect_mode : char;
                    VAR modified : boolean;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              u12userrec (VAR term : tut_terminal;
                    VAR s        : tak_systembuffer;
                    protect_mode : char;
                    VAR modified : boolean;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              u12ureference (VAR term : tut_terminal;
                    VAR s        : tak_systembuffer;
                    protect_mode : char;
                    VAR modified : boolean;
                    VAR pfkey    : tut_pfkey);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              UT_diag_scheme_2 : VUT11;
 
        PROCEDURE
              u11hexname_in_out (VAR name : tsp00_Name;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11c64in_out (VAR out : tsp00_C64;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR modified : boolean);
 
        PROCEDURE
              u11filename_in_out (VAR fn : tgg00_Filename;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11maskerror (VAR term : tut_terminal;
                    VAR ok        : tut_ok_array;
                    VAR mask      : tut_term_mask;
                    mask_size     : integer;
                    VAR pfkey     : tut_pfkey);
 
        PROCEDURE
              u11setin_out (VAR c2 : tsp00_C2;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11newpage (VAR term : tut_terminal;
                    msgheader : tsp00_C20);
 
        PROCEDURE
              u11hexpw (VAR pw : tsp00_CryptPw;
                    VAR out : tsp00_C256);
 
        PROCEDURE
              u11boolean_in_out (VAR in_out_bool : boolean;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11int1in_out (VAR int1 : tsp00_Uint1;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11int2in_out (VAR int2 : tsp00_Int2;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11int4in_out (VAR int4 : tsp00_Int4;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11c6in_out (VAR c6 : tsp00_C6;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11surrogate_in_out (VAR surrogate : tgg00_Surrogate;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11namein_out (VAR out : tsp00_Name;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR modified : boolean);
 
        PROCEDURE
              u11c8surrogate_in_out (VAR out : tgg00_Surrogate;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11c2inout (VAR c2 : tsp00_C2;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11tabkind_in_out (VAR kind : tgg00_TableKind;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
        PROCEDURE
              u11utkind_in_out (VAR kind : tak_usertab_descriptor;
                    VAR mask     : tut_term_mask;
                    mask_index   : integer;
                    VAR ok       : boolean;
                    VAR modified : boolean);
 
      ------------------------------ 
 
        FROM
              TA_terminal_IO : VTA09;
 
        PROCEDURE
              t09putmsg (VAR term     : tut_terminal;
                    VAR msg           : tsp00_Line;
                    is_warning        : boolean;
                    immediate_display : boolean);
 
        PROCEDURE
              t09mask (VAR t09    : tut_terminal;
                    count_names   : integer;
                    mask_size     : integer;
                    VAR mask_spec : tut_term_mask;
                    return_pf_key : boolean;
                    VAR pfkey     : tut_pfkey);
 
        PROCEDURE
              t09newscreen_page (VAR t09 : tut_terminal);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              u11c64in_out;
 
              tsp00_C64 tsp00_NodeId
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ThomasA
.sp
.cp 3
Created : 1986-01-17
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-10-05
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      msg20_domainrefrec    = '  DOMAIN REF RECORD ';
      msg20_sysuserrec      = ' SYSTEM USER RECORD ';
      msg20_userrec         = '     USER RECORD    ';
      msg20_userrefrec      = '   USERREF RECORD   ';
      msg20_usertabrec      = '   USERTAB RECORD   ';
      msg20_serverdbrec     = '   SERVERDB RECORD  ';
      msg20_serverdbnamerec = 'SERVERDBNAME RECORD ';
 
 
(*------------------------------*) 
 
PROCEDURE
      u12domainreference (VAR term : tut_terminal;
            VAR s        : tak_systembuffer;
            protect_mode : char;
            VAR modified : boolean;
            VAR pfkey    : tut_pfkey);
 
CONST
      max_domref_mask = 7;
 
VAR
      is_input    : boolean;
      i           : integer;
      ok          : tut_ok_array;
      mask        : tut_term_mask;
 
BEGIN
u11newpage (term, msg20_domainrefrec);
is_input := false;
REPEAT
    IF  NOT is_input
    THEN
        FOR i := 1 TO max_domref_mask DO
            BEGIN
            mask[ i ].upper_case       := true;
            mask[ i ].msg_in_attr[ 1 ] := cut_protected;
            mask[ i ].msg_in_attr[ 2 ] := protect_mode;
            mask[ i ].in_name          := bsp_name;
            mask[ i ].code_input       := false;
            ok  [ i ] := true;
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    mask[ 1 ].msg     := 'RECORD LENGTH  (HEX)';
    u11int2in_out (s.b_sl, mask, 1, ok[ 1 ], modified);
    mask[ 2 ].msg     := 'DOMAINNAME(1..8)    ';
    u11c8surrogate_in_out (s.syskey.sauthid,
          mask, 2, ok[ 2 ], modified);
    mask[ 3 ].msg     := 'DOMAINNAME(9..18)   ';
    u11namein_out (s.syskey.stablen, mask, 3, modified);
    mask[ 4 ].msg  := 'ENTRY TYPE     (HEX)';
    u11c2inout (s.syskey.sentrytyp,
          mask, 4, ok[ 4 ], modified);
    mask[ 5 ].msg  := 'LINKAGE        (HEX)';
    u11c2inout (s.syskey.slinkage, mask, 5, ok[ 5 ], modified);
    mask[ 6 ].msg  := 'DSEGMENTID     (HEX)';
    u11c2inout (s.sdomainref.dsegmentid, mask, 6,
          ok[ 6 ], modified);
    mask[ 7 ].msg  := 'DSURROGATE     (HEX)';
    u11surrogate_in_out (s.sdomainref.dsurrogate, mask, 7,
          ok[ 7 ], modified);
    IF  NOT is_input
    THEN
        BEGIN
        t09newscreen_page(term);
        t09mask (term,
              max_domref_mask, max_domref_mask, mask, true, pfkey);
        t09putmsg (term, term.blankline, false, false);
        is_input := true
        END
    ELSE
        BEGIN
        u11maskerror (term, ok, mask, max_domref_mask, pfkey);
        is_input := false
        END;
    (*ENDIF*) 
UNTIL
    ((pfkey <> pf_none) AND (NOT is_input)) OR
    (protect_mode = cut_protected);
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u12sysuserrec (VAR term : tut_terminal;
            VAR s        : tak_systembuffer;
            protect_mode : char;
            VAR modified : boolean;
            VAR pfkey    : tut_pfkey);
 
CONST
      max_sysuser_mask = 8;
 
VAR
      is_input    : boolean;
      i           : integer;
      ok          : tut_ok_array;
      mask        : tut_term_mask;
 
BEGIN
u11newpage (term, msg20_sysuserrec);
is_input := false;
REPEAT
    IF  NOT is_input
    THEN
        FOR i := 1 TO max_sysuser_mask DO
            BEGIN
            mask[ i ].upper_case       := true;
            mask[ i ].msg_in_attr[ 1 ] := cut_protected;
            mask[ i ].msg_in_attr[ 2 ] := protect_mode;
            mask[ i ].in_name          := bsp_name;
            mask[ i ].code_input       := false;
            ok  [ i ] := true;
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    mask[ 1 ].msg     := 'RECORD LENGTH  (HEX)';
    u11int2in_out (s.b_sl, mask, 1,
          ok[ 1 ], modified);
    mask[ 2 ].msg     := 'SYSSURROGATE   (HEX)';
    u11surrogate_in_out (s.syskey.sauthid,
          mask, 2, ok[ 2 ], modified);
    mask[ 3 ].msg  := 'ENTRY TYPE     (HEX)';
    u11c2inout (s.syskey.sentrytyp, mask, 3, ok[ 3 ], modified);
    mask[ 4 ].msg  := 'LINKAGE        (HEX)';
    u11c2inout (s.syskey.slinkage, mask, 4, ok[ 4 ], modified);
    mask[ 5 ].msg  := 'SYSSEGMENTID   (HEX)';
    u11c2inout (s.ssysdba.syssegmentid, mask, 5,
          ok[ 5 ], modified);
    mask[ 6 ].msg := 'SYSVERSION          ';
    u11int1in_out (s.ssysdba.sysversion, mask, 6,
          ok[ 6 ], modified);
    mask[ 7 ].msg := 'SYSACTIVATED        ';
    u11boolean_in_out (s.ssysdba.sysactivated, mask, 7,
          ok[ 7 ], modified);
    mask[ 8 ].msg  := 'SYSAUTHID      (HEX)';
    u11surrogate_in_out (s.ssysdba.sysauthid, mask, 8,
          ok[ 8 ], modified);
    IF  NOT is_input
    THEN
        BEGIN
        t09newscreen_page(term);
        t09mask (term, max_sysuser_mask,
              max_sysuser_mask, mask, true, pfkey);
        t09putmsg (term, term.blankline, false, false);
        is_input := true
        END
    ELSE
        BEGIN
        u11maskerror (term, ok, mask, max_sysuser_mask, pfkey);
        is_input := false
        END;
    (*ENDIF*) 
UNTIL
    ((pfkey <> pf_none) AND (NOT is_input)) OR
    (protect_mode = cut_protected);
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u12ureference (VAR term : tut_terminal;
            VAR s        : tak_systembuffer;
            protect_mode : char;
            VAR modified : boolean;
            VAR pfkey    : tut_pfkey);
 
CONST
      max_uref_mask = 8;
 
VAR
      is_input    : boolean;
      i           : integer;
      ok          : tut_ok_array;
      mask        : tut_term_mask;
 
BEGIN
u11newpage (term, msg20_userrefrec);
is_input := false;
REPEAT
    IF  NOT is_input
    THEN
        FOR i := 1 TO max_uref_mask DO
            BEGIN
            mask[ i ].upper_case       := true;
            mask[ i ].msg_in_attr[ 1 ] := cut_protected;
            mask[ i ].msg_in_attr[ 2 ] := protect_mode;
            mask[ i ].in_name          := bsp_name;
            mask[ i ].code_input       := false;
            ok  [ i ] := true;
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    mask[ 1 ].msg     := 'RECORD LENGTH  (HEX)';
    u11int2in_out (s.b_sl, mask, 1,
          ok[ 1 ], modified);
    mask[ 2 ].msg     := 'USERNAME(1..8)      ';
    u11c8surrogate_in_out (s.syskey.sauthid,
          mask, 2, ok[ 2 ], modified);
    mask[ 3 ].msg     := 'USERNAME(9..18)     ';
    u11namein_out (s.syskey.stablen, mask, 3, modified);
    mask[ 4 ].msg  := 'ENTRY TYPE     (HEX)';
    u11c2inout (s.syskey.sentrytyp, mask, 4, ok[ 4 ], modified);
    mask[ 5 ].msg  := 'LINKAGE        (HEX)';
    u11c2inout (s.syskey.slinkage, mask, 5, ok[ 5 ], modified);
    mask[ 6 ].msg  := 'RU_SEGMENTID   (HEX)';
    u11c2inout (s.suserref.ru_segmentid, mask, 6,
          ok[ 6 ], modified);
    mask[ 7 ].msg  := 'RU_USER_ID     (HEX)';
    u11surrogate_in_out (s.suserref.ru_user_id, mask, 7,
          ok[ 7 ], modified);
    mask[ 8 ].msg := 'RU_FILLER      (HEX)';
    u11int2in_out (s.suserref.ru_filler, mask, 8,
          ok[ 8 ], modified);
    IF  NOT is_input
    THEN
        BEGIN
        t09newscreen_page(term);
        t09mask (term,
              max_uref_mask, max_uref_mask, mask, true, pfkey);
        t09putmsg (term, term.blankline, false, false);
        is_input := true
        END
    ELSE
        BEGIN
        u11maskerror (term, ok, mask, max_uref_mask, pfkey);
        is_input := false
        END;
    (*ENDIF*) 
UNTIL
    ((pfkey <> pf_none) AND (NOT is_input)) OR
    (protect_mode = cut_protected);
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u12userrec (VAR term : tut_terminal;
            VAR s        : tak_systembuffer;
            protect_mode : char;
            VAR modified : boolean;
            VAR pfkey    : tut_pfkey);
 
CONST
      max_userrec_mask = 11;
 
VAR
      ok          : tut_ok_array;
      mask_call   : boolean;
      i           : integer;
      index       : integer;
      mask_cnt    : integer;
      name_cnt    : integer;
      mask        : tut_term_mask;
 
      utyp_map_c2 : RECORD
            CASE boolean OF
                true :
                    (ut : tak_userrectype);
                false :
                    (c2 : tsp00_C2);
                END;
            (*ENDCASE*) 
 
 
      ukind_map_int1 : RECORD
            CASE boolean OF
                true :
                    (uk : tak_usertyp);
                false :
                    (int : tsp00_Uint1);
                END;
            (*ENDCASE*) 
 
 
BEGIN
u11newpage (term, msg20_userrec);
term.use_pfkeys := true;
mask_call := true;
index     := 0;
REPEAT
    IF  mask_call
    THEN
        BEGIN
        FOR i := 1 TO max_userrec_mask DO
            BEGIN
            ok  [ i ]                  := true;
            mask[ i ].upper_case       := true;
            mask[ i ].msg_in_attr[ 1 ] := cut_protected;
            mask[ i ].msg_in_attr[ 2 ] := protect_mode;
            mask[ i ].in_name          := bsp_name;
            mask[ i ].code_input       := false;
            END;
        (*ENDFOR*) 
        mask[ 13 ].in_c256 := term.blankfilename;
        END;
    (*ENDIF*) 
    IF  index = 0
    THEN
        BEGIN
        mask[ 1 ].msg  := 'RECORD LENGTH  (HEX)';
        u11int2in_out (s.b_sl,
              mask, 1, ok[ 1 ], modified);
        mask[ 2 ].msg  := 'USERSURROGATE  (HEX)';
        u11surrogate_in_out (s.syskey.sauthid,
              mask, 2, ok[ 2 ], modified);
        mask[ 3 ].msg  := 'ENTRY TYPE     (HEX)';
        u11c2inout (s.syskey.sentrytyp,
              mask, 3, ok[ 3 ], modified);
        mask[ 4 ].msg  := 'LINKAGE        (HEX)';
        u11c2inout (s.syskey.slinkage,
              mask, 4, ok[ 4 ], modified);
        mask[ 5 ].msg  := 'USERSEGMENTID  (HEX)';
        u11c2inout (s.suser.usersegmentid,
              mask, 5, ok[ 5 ], modified);
        mask[ 6 ].msg  := 'USERNAME            ';
        u11c64in_out (s.suser.username, mask, 6, modified);
        mask[ 7 ].msg  := 'URECORDTYPE         ';
        utyp_map_c2.ut := s.suser.urecordtyp;
        utyp_map_c2.c2[ 2 ] := chr(0);
        u11setin_out (utyp_map_c2.c2,
              mask, 7, ok[ 7 ], modified);
        s.suser.urecordtyp := utyp_map_c2.ut;
        mask[ 8 ].msg  := 'USERKIND            ';
        ukind_map_int1.uk := s.suser.userkind;
        u11int1in_out (ukind_map_int1.int,
              mask, 8, ok[ 8 ], modified);
        s.suser.userkind := ukind_map_int1.uk;
        mask[ 9 ].msg  := 'USERSYSUSER         ';
        u11boolean_in_out (s.suser.usersysdba,
              mask, 9, ok[ 9 ], modified);
        mask[ 10 ].msg := 'USEREXCLUSIVE       ';
        u11boolean_in_out (s.suser.uexclusive,
              mask, 10, ok[ 10 ], modified);
        mask[ 11 ].msg := 'USERREPLICATION     ';
        u11boolean_in_out (s.suser.ureplication,
              mask, 11, ok[ 11 ], modified);
        mask_cnt := 11;
        name_cnt := 11
        END
    ELSE
        BEGIN
        mask[ 1 ].msg := 'USERFILLER3    (HEX)';
        u11int2in_out (s.suser.userfiller3,
              mask, 1, ok[ 1 ], modified);
        mask[ 2 ].msg  := 'USERGROUP_ID   (HEX)';
        u11surrogate_in_out (s.suser.usergroup_id,
              mask, 2, ok[ 2 ], modified);
        mask[ 3 ].msg := 'USEROWNER_ID   (HEX)';
        u11surrogate_in_out (s.suser.userowner_id,
              mask, 3, ok[ 3 ], modified);
        mask[ 4 ].msg := 'SCHEMAID       (HEX)';
        u11int4in_out (s.suser.uparams[ schemaid ],
              mask, 4, ok[ 4 ], modified);
        mask[ 5 ].msg := 'UNUSED2        (HEX)';
        u11int4in_out (s.suser.uparams[ up_unused2 ],
              mask, 5, ok[ 5 ], modified);
        mask[ 6 ].msg := 'MAXTIMEOUT     (HEX)';
        u11int4in_out (s.suser.uparams[ maxtimeout ],
              mask, 6, ok[ 6 ], modified);
        mask[ 7 ].msg := 'COSTWARNING    (HEX)';
        u11int4in_out (s.suser.uparams[ costwarning ],
              mask, 7, ok[ 7 ], modified);
        mask[ 8 ].msg := 'COSTLIMIT      (HEX)';
        u11int4in_out (s.suser.uparams[ costlimit ],
              mask, 8, ok[ 8 ], modified);
        mask[ 9 ].msg := 'PERM_REF       (HEX)';
        u11c6in_out (s.suser.uperm_ref.ci6_gg00,
              mask, 9, ok[ 9 ], modified);
        mask[ 10 ].msg := 'PASSWORD       (HEX)';
        u11hexpw (s.suser.userpassw, mask[ 10 ].in_c256);
        mask_cnt := 10;
        name_cnt := 10
        END;
    (*ENDIF*) 
    IF  mask_call
    THEN
        BEGIN
        t09newscreen_page(term);
        t09mask (term, name_cnt, mask_cnt, mask, true, pfkey);
        t09putmsg (term, term.blankline, false, false);
        CASE pfkey OF
            pf_up, pf_down, pf_end, pf_run :
                mask_call := false;
            pf_cancel :
                modified := false;
            OTHERWISE;
            END;
        (*ENDCASE*) 
        END
    ELSE
        BEGIN
        u11maskerror (term, ok, mask, max_userrec_mask, pfkey);
        IF  ok[ 1 ]
        THEN
            CASE pfkey OF
                pf_up :
                    BEGIN
                    index := 0;
                    pfkey := pf_none
                    END;
                pf_down :
                    BEGIN
                    index := 1;
                    pfkey := pf_none
                    END;
                OTHERWISE ;
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        mask_call := true
        END;
    (*ENDIF*) 
UNTIL
    (pfkey <> pf_none) AND (mask_call);
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u12usagerec (VAR term : tut_terminal;
            VAR s        : tak_systembuffer;
            protect_mode : char;
            VAR modified : boolean;
            VAR pfkey    : tut_pfkey);
 
CONST
      max_usage_mask = 11;
 
VAR
      dummy           : boolean;
      index_modified  : boolean;
      is_input        : boolean;
      mask_cnt        : integer;
      i               : integer;
      index           : tsp00_Int2;
      ok              : tut_ok_array;
      mask            : tut_term_mask;
 
BEGIN
dummy     := true;
is_input  := false;
FOR i := 1 TO max_usage_mask DO
    BEGIN
    mask[ i ].upper_case       := true;
    mask[ i ].msg_in_attr[ 1 ] := cut_protected;
    mask[ i ].msg_in_attr[ 2 ] := protect_mode;
    mask[ i ].code_input       := false;
    END;
(*ENDFOR*) 
term.use_pfkeys := true;
index                := 0;
u11newpage (term, msg20_usertabrec);
REPEAT
    t09newscreen_page(term);
    IF  NOT is_input
    THEN
        FOR i := 1 TO max_usage_mask DO
            BEGIN
            ok[ i ] := true;
            mask[ i ].in_name := bsp_name
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    IF  index = 0
    THEN
        BEGIN
        mask[ 1 ].msg  := 'RECORD LENGTH  (HEX)';
        mask[ 1 ].msg_in_attr[ 2 ] := protect_mode;
        u11int2in_out (s.b_sl,
              mask, 1, ok[ 1 ], modified);
        mask[ 2 ].msg  := 'USAGESURROGATE      ';
        u11surrogate_in_out (s.syskey.sauthid,
              mask, 2, ok[ 2 ], modified);
        mask[ 3 ].msg  := 'ENTRY TYPE     (HEX)';
        u11c2inout (s.syskey.sentrytyp,
              mask, 3, ok[ 3 ], modified);
        mask[ 4 ].msg  := 'LINKAGE        (HEX)';
        u11c2inout (s.syskey.slinkage,
              mask, 4, ok[ 4 ], modified);
        mask[ 5 ].msg  := 'USAGESEGMENTID      ';
        u11c2inout (s.susage.usagesegmentid,
              mask, 5, ok[ 5 ], modified);
        mask[ 6 ].msg  := 'USAGEFILLER    (HEX)';
        u11int2in_out (s.susage.usagefiller,
              mask, 6, ok[ 6 ], modified);
        mask[ 7 ].msg  := 'USAGECOUNT     (HEX)';
        u11int2in_out (s.susage.usagecount,
              mask, 7, ok[ 7 ], modified);
        mask[ 8 ].msg  := 'USAGENEXT_EXIST     ';
        u11boolean_in_out (s.susage.usagenext_exist,
              mask, 8, ok[ 8 ], modified);
        mask[ 9 ].msg  := 'UAGEFULL            ';
        u11boolean_in_out (s.susage.usagefull,
              mask, 9, ok[ 9 ], modified);
        mask_cnt := max_usage_mask;
        END
    ELSE
        BEGIN
        mask_cnt       := 5;
        index_modified := false;
        mask[ 1 ].msg  := 'ENTRY INDEX    (HEX)';
        mask[ 1 ].msg_in_attr[ 2 ] := cut_unprotected;
        u11int2in_out (index,
              mask, 1, dummy, index_modified);
        IF  NOT index_modified
        THEN
            BEGIN
            mask[ 2 ].msg  := 'USA_TABLEID    (HEX)';
            u11surrogate_in_out (
                  s.susage.usagedef[ index ].usa_tableid,
                  mask, 2, ok[ 2 ], modified);
            mask[ 3 ].msg  := 'USA_FILLER     (HEX)';
            u11int2in_out (s.susage.usagedef[ index ].usa_filler,
                  mask, 3, ok[ 3 ], modified);
            mask[ 4 ].msg  := 'USA_TABLEKIND       ';
            u11tabkind_in_out (s.susage.usagedef[ index ].usa_tablekind,
                  mask, 4, ok[ 4 ], modified);
            mask[ 5 ].msg  := 'USA_EMPTY           ';
            u11boolean_in_out (s.susage.usagedef[ index ].usa_empty,
                  mask, 5, ok[ 5 ], modified);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  NOT is_input
    THEN
        BEGIN
        t09newscreen_page(term);
        t09mask (term, mask_cnt, mask_cnt, mask, true, pfkey);
        t09putmsg (term, term.blankline, false, false);
        CASE pfkey OF
            pf_up, pf_down, pf_end, pf_run :
                is_input := true;
            pf_cancel :
                modified := false;
            OTHERWISE;
            END;
        (*ENDCASE*) 
        END
    ELSE
        BEGIN
        u11maskerror (term, ok, mask, max_usage_mask, pfkey);
        IF  ok[ 1 ]
        THEN
            CASE pfkey OF
                pf_up :
                    BEGIN
                    index := index - 1;
                    pfkey := pf_none
                    END;
                pf_down :
                    BEGIN
                    index := index + 1;
                    pfkey := pf_none
                    END;
                pf_run :
                    pfkey := pf_none;
                OTHERWISE ;
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        is_input := false
        END;
    (*ENDIF*) 
    IF  index < 0
    THEN
        index := 0
    ELSE
        IF  index >  s.susage.usagecount
        THEN
            index := 0;
        (*ENDIF*) 
    (*ENDIF*) 
UNTIL
    (pfkey <> pf_none) AND NOT is_input;
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u12usertabrec (VAR term : tut_terminal;
            VAR s        : tak_systembuffer;
            protect_mode : char;
            VAR modified : boolean;
            VAR pfkey    : tut_pfkey);
 
CONST
      max_usertab_mask = 9;
 
VAR
      dummy           : boolean;
      index_modified  : boolean;
      is_input        : boolean;
      mask_cnt        : integer;
      i               : integer;
      index           : tsp00_Int2;
      ok              : tut_ok_array;
      mask            : tut_term_mask;
 
BEGIN
dummy     := true;
is_input  := false;
FOR i := 1 TO 10 DO
    BEGIN
    mask[ i ].upper_case       := true;
    mask[ i ].msg_in_attr[ 1 ] := cut_protected;
    mask[ i ].msg_in_attr[ 2 ] := protect_mode;
    mask[ i ].code_input       := false;
    END;
(*ENDFOR*) 
term.use_pfkeys := true;
index                := 0;
u11newpage (term, msg20_usertabrec);
REPEAT
    t09newscreen_page(term);
    IF  NOT is_input
    THEN
        FOR i := 1 TO 10 DO
            BEGIN
            ok[ i ] := true;
            mask[ i ].in_name := bsp_name
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    IF  index = 0
    THEN
        BEGIN
        mask[ 1 ].msg  := 'RECORD LENGTH  (HEX)';
        mask[ 1 ].msg_in_attr[ 2 ] := protect_mode;
        u11int2in_out (s.b_sl,
              mask, 1, ok[ 1 ], modified);
        mask[ 2 ].msg  := 'USERTABSURROGATE    ';
        u11surrogate_in_out (s.syskey.sauthid,
              mask, 2, ok[ 2 ], modified);
        mask[ 3 ].msg  := 'ENTRY TYPE     (HEX)';
        u11c2inout (s.syskey.sentrytyp,
              mask, 3, ok[ 3 ], modified);
        mask[ 4 ].msg  := 'LINKAGE        (HEX)';
        u11c2inout (s.syskey.slinkage,
              mask, 4, ok[ 4 ], modified);
        mask[ 5 ].msg  := 'USERTABSEGMENTID    ';
        u11c2inout (s.susertab.usertabsegmentid,
              mask, 5, ok[ 5 ], modified);
        mask[ 6 ].msg  := 'USERTABFILLER  (HEX)';
        u11int2in_out (s.susertab.usertabfiller,
              mask, 6, ok[ 6 ], modified);
        mask[ 7 ].msg  := 'USERTABNEXTEXIST    ';
        u11boolean_in_out (s.susertab.usertabnext_exist,
              mask, 7, ok[ 7 ], modified);
        mask[ 8 ].msg  := 'USERTABFULL         ';
        u11boolean_in_out (s.susertab.usertabfull,
              mask, 8, ok[ 8 ], modified);
        mask[ 9 ].msg  := 'USERTABCOUNT   (HEX)';
        u11int2in_out (s.susertab.usertabcount,
              mask, 9, ok[ 9 ], modified);
        mask_cnt := max_usertab_mask;
        END
    ELSE
        BEGIN
        mask_cnt       := 5;
        index_modified := false;
        mask[ 1 ].msg  := 'ENTRY INDEX    (HEX)';
        mask[ 1 ].msg_in_attr[ 2 ] := cut_unprotected;
        u11int2in_out (index,
              mask, 1, dummy, index_modified);
        IF  NOT index_modified
        THEN
            BEGIN
            mask[ 2 ].msg  := 'UT_SURROGATE   (HEX)';
            u11surrogate_in_out (
                  s.susertab.usertabdef[ index ].ut_surrogate,
                  mask, 2, ok[ 2 ], modified);
            mask[ 3 ].msg  := 'UT_EMPTY            ';
            u11boolean_in_out (s.susertab.usertabdef[ index ].ut_empty,
                  mask, 3, ok[ 3 ], modified);
            mask[ 4 ].msg  := 'UT_KIND             ';
            u11utkind_in_out (s.susertab.usertabdef[ index ].ut_kind,
                  mask, 4, ok[ 4 ], modified);
            mask[ 5 ].msg  := 'UT_FILLER      (HEX)';
            u11int2in_out (s.susertab.usertabdef[ index ].ut_filler,
                  mask, 5, ok[ 5 ], modified)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  NOT is_input
    THEN
        BEGIN
        t09newscreen_page(term);
        t09mask (term, mask_cnt, mask_cnt, mask, true, pfkey);
        t09putmsg (term, term.blankline, false, false);
        CASE pfkey OF
            pf_up, pf_down, pf_end, pf_run :
                is_input := true;
            pf_cancel :
                modified := false;
            OTHERWISE;
            END;
        (*ENDCASE*) 
        END
    ELSE
        BEGIN
        u11maskerror (term, ok, mask, max_usertab_mask, pfkey);
        IF  ok[ 1 ]
        THEN
            CASE pfkey OF
                pf_up :
                    BEGIN
                    index := index - 1;
                    pfkey := pf_none
                    END;
                pf_down :
                    BEGIN
                    index := index + 1;
                    pfkey := pf_none
                    END;
                pf_run :
                    pfkey := pf_none;
                OTHERWISE ;
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        is_input := false
        END;
    (*ENDIF*) 
    IF  index < 0
    THEN
        index := 0
    ELSE
        IF  index >  s.susertab.usertabcount
        THEN
            index := 0;
        (*ENDIF*) 
    (*ENDIF*) 
UNTIL
    (pfkey <> pf_none) AND NOT is_input;
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u12sdbnamerec (VAR term : tut_terminal;
            VAR s        : tak_systembuffer;
            protect_mode : char;
            VAR modified : boolean;
            VAR pfkey    : tut_pfkey);
 
CONST
      max_locname_mask = 13;
      name_cnt         =  7;
 
VAR
      is_input    : boolean;
      i           : integer;
      j           : integer;
      k           : integer;
      len         : integer;
      c12         : tsp00_C12;
      ok          : tut_ok_array;
      aux_fn      : tgg00_Filename;
      mask        : tut_term_mask;
 
BEGIN
u11newpage (term, msg20_serverdbnamerec);
is_input := false;
REPEAT
    IF  NOT is_input
    THEN
        FOR i := 1 TO max_locname_mask DO
            BEGIN
            mask[ i ].upper_case       := true;
            mask[ i ].msg_in_attr[ 1 ] := cut_protected;
            mask[ i ].msg_in_attr[ 2 ] := protect_mode;
            mask[ i ].in_name          := bsp_name;
            mask[ i ].in_c256          := term.blankfilename;
            mask[ i ].code_input       := false;
            ok  [ i ] := true;
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    mask[ 1 ].msg     := 'RECORD LENGTH  (HEX)';
    u11int2in_out (s.b_sl, mask, 1,
          ok[ 1 ], modified);
    mask[ 2 ].msg     := 'SURROGATE      (HEX)';
    u11surrogate_in_out (s.syskey.sauthid,
          mask, 2, ok[ 2 ], modified);
    mask[ 3 ].msg  := 'ENTRY TYPE     (HEX)';
    u11c2inout (s.syskey.sentrytyp,
          mask, 3, ok[ 3 ], modified);
    mask[ 4 ].msg  := 'LINKAGE        (HEX)';
    u11c2inout (s.syskey.slinkage, mask, 4, ok[ 4 ], modified);
    mask[ 5 ].msg     := 'SERVERDB            ';
    u11namein_out (s.syskey.stablen, mask, 5, modified);
    mask[ 6 ].msg  := 'SNSEGMENTID    (HEX)';
    u11c2inout (s.sserverdbname.snsegmentid, mask, 6,
          ok[ 6 ], modified);
    mask[ 7 ].msg  := 'SNSITE         (HEX)';
    u11c2inout (s.sserverdbname.snsite, mask, 7,
          ok[ 7 ], modified);
    mask[ 8 ].msg  := 'SNNODEID            ';
    u11c64in_out (s.sserverdbname.snnodeid, mask, 8, modified);
    mask[ 9 ].msg  := 'SERVERDB       (HEX)';
    u11hexname_in_out (s.syskey.stablen,
          mask, 9, ok[ 9 ], modified);
    FOR i := 1 TO 4 DO
        WITH s.sserverdbname DO
            BEGIN
            mask[ name_cnt+i+2 ].msg  := 'SNNODEID       (HEX)';
            ut12int_str ((i-1) * FN_MXGG00 + 1, len, c12);
            k := 11;
            FOR j := mxsp_c12 DOWNTO len DO
                BEGIN
                mask[ name_cnt+i+2 ].msg[ k ] := c12[ j ];
                k := k - 1
                END;
            (*ENDFOR*) 
            mask[ name_cnt+i+2 ].msg[ 12 ] := '-';
            ut12int_str (i * FN_MXGG00, len, c12);
            k := 14;
            FOR j := mxsp_c12 DOWNTO len DO
                BEGIN
                mask[ name_cnt+i+2 ].msg[ k ] := c12[ j ];
                k := k - 1
                END;
            (*ENDFOR*) 
            SAPDB_PascalForcedMove (sizeof (snnodeid), sizeof (aux_fn),
                  @snnodeid, (i-1) * FN_MXGG00 + 1,  @aux_fn, 1, FN_MXGG00);
            u11filename_in_out (aux_fn, mask, name_cnt+i+2,
                  ok[ name_cnt+i+2 ], modified);
            SAPDB_PascalForcedMove (sizeof (aux_fn), sizeof (snnodeid),
                  @aux_fn, 1, @snnodeid, (i-1) * FN_MXGG00 + 1, FN_MXGG00)
            END;
        (*ENDWITH*) 
    (*ENDFOR*) 
    IF  NOT is_input
    THEN
        BEGIN
        t09newscreen_page(term);
        t09mask (term,
              name_cnt, max_locname_mask, mask, true, pfkey);
        t09putmsg (term, term.blankline, false, false);
        is_input := true
        END
    ELSE
        BEGIN
        u11maskerror (term, ok, mask, max_locname_mask, pfkey);
        is_input := false
        END;
    (*ENDIF*) 
UNTIL
    ((pfkey <> pf_none) AND (NOT is_input)) OR
    (protect_mode = cut_protected);
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u12serverdbrec (VAR term : tut_terminal;
            VAR s        : tak_systembuffer;
            protect_mode : char;
            VAR modified : boolean;
            VAR pfkey    : tut_pfkey);
 
CONST
      max_locname_mask = 14;
      name_cnt         =  8;
 
VAR
      is_input    : boolean;
      i           : integer;
      j           : integer;
      k           : integer;
      len         : integer;
      c12         : tsp00_C12;
      ok          : tut_ok_array;
      aux_fn      : tgg00_Filename;
      mask        : tut_term_mask;
 
BEGIN
u11newpage (term, msg20_serverdbrec);
is_input := false;
REPEAT
    IF  NOT is_input
    THEN
        FOR i := 1 TO max_locname_mask DO
            BEGIN
            mask[ i ].upper_case       := true;
            mask[ i ].msg_in_attr[ 1 ] := cut_protected;
            mask[ i ].msg_in_attr[ 2 ] := protect_mode;
            mask[ i ].in_name          := bsp_name;
            mask[ i ].in_c256          := term.blankfilename;
            mask[ i ].code_input       := false;
            ok  [ i ] := true;
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    mask[ 1 ].msg     := 'RECORD LENGTH  (HEX)';
    u11int2in_out (s.b_sl, mask, 1,
          ok[ 1 ], modified);
    mask[ 2 ].msg     := 'SURROGATE      (HEX)';
    u11surrogate_in_out (s.syskey.sauthid,
          mask, 2, ok[ 2 ], modified);
    mask[ 3 ].msg  := 'ENTRY TYPE     (HEX)';
    u11c2inout (s.syskey.sentrytyp,
          mask, 3, ok[ 3 ], modified);
    mask[ 4 ].msg  := 'LINKAGE        (HEX)';
    u11c2inout (s.syskey.slinkage, mask, 4, ok[ 4 ], modified);
    mask[ 5 ].msg  := 'SITESEGMENTID  (HEX)';
    u11c2inout (s.sserverdb.sitesegmentid, mask, 5,
          ok[ 5 ], modified);
    mask[ 6 ].msg  := 'SITEMAP_NO     (HEX)';
    u11c2inout (s.sserverdb.sitemap_no, mask, 6,
          ok[ 6 ], modified);
    mask[ 7 ].msg     := 'SITESERVERDBNAME    ';
    u11namein_out (s.sserverdb.siteserverdbname, mask, 7, modified);
    mask[ 8 ].msg  := 'SITEFILLER1    (HEX)';
    u11boolean_in_out (s.sserverdb.sitefiller1, mask, 8,
          ok[ 8 ], modified);
    mask[ 9 ].msg  := 'SITEID              ';
    u11c64in_out (s.sserverdb.siteid, mask, 9, modified);
    mask[ 10 ].msg  := 'SITESERVERDB   (HEX)';
    u11hexname_in_out (s.sserverdb.siteserverdbname,
          mask, 10, ok[ 10 ], modified);
    FOR i := 1 TO 4 DO
        WITH s.sserverdb DO
            BEGIN
            mask[ name_cnt+i+2 ].msg  := 'NODEID         (HEX)';
            ut12int_str ((i-1) * FN_MXGG00 + 1, len, c12);
            k := 11;
            FOR j := mxsp_c12 DOWNTO len DO
                BEGIN
                mask[ name_cnt+i+2 ].msg[ k ] := c12[ j ];
                k := k - 1
                END;
            (*ENDFOR*) 
            mask[ name_cnt+i+2 ].msg[ 12 ] := '-';
            ut12int_str (i * FN_MXGG00, len, c12);
            k := 14;
            FOR j := mxsp_c12 DOWNTO len DO
                BEGIN
                mask[ name_cnt+i+2 ].msg[ k ] := c12[ j ];
                k := k - 1
                END;
            (*ENDFOR*) 
            SAPDB_PascalForcedMove (sizeof (siteid), sizeof (aux_fn),
                  @siteid, (i-1) * FN_MXGG00+1, @aux_fn, 1, sizeof(aux_fn));
            u11filename_in_out (aux_fn, mask, name_cnt+i+2,
                  ok[ name_cnt+i+2 ], modified);
            SAPDB_PascalForcedMove (sizeof (aux_fn), sizeof (siteid),
                  @aux_fn, 1, @siteid, (i-1) * FN_MXGG00+1,sizeof(aux_fn))
            END;
        (*ENDWITH*) 
    (*ENDFOR*) 
    IF  NOT is_input
    THEN
        BEGIN
        t09newscreen_page(term);
        t09mask (term,
              name_cnt, max_locname_mask, mask, true, pfkey);
        t09putmsg (term, term.blankline, false, false);
        is_input := true
        END
    ELSE
        BEGIN
        u11maskerror (term, ok, mask, max_locname_mask, pfkey);
        is_input := false
        END;
    (*ENDIF*) 
UNTIL
    ((pfkey <> pf_none) AND (NOT is_input)) OR
    (protect_mode = cut_protected);
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut12int_str (i       : integer;
            VAR len : integer;
            VAR str : tsp00_C12);
 
BEGIN
len := mxsp_c12;
WHILE i > 0 DO
    BEGIN
    str[ len ] := chr (ord('0') + i MOD 10);
    i   := i DIV 10;
    len := len - 1;
    END;
(*ENDWHILE*) 
len := len + 1
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
