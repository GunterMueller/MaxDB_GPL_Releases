/* @lastChanged: "1999-10-28"
 
 * @filename:   vut05
 * @purpose:    "UT_auxiliary_procedures"
 * @release:    7.2.0.0
 * @see:        "-.-"
 *
 * @Copyright (c) 1998-2005 SAP AG"
 */
 
.tt 1 $SAP$LiveCache$VUT05$
.tt 3 $$UT_auxiliary_procedures$2000-08-23$
 
.nf
 
 .nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 1998-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
 
 
.fo
***********************************************************
 
Module  : UT_auxiliary_procedures
 
Define  :
 
        PROCEDURE
              u05c20to_packet (n : tsp00_C20;
                    snd_packet   : tsp1_packet_ptr);
 
        PROCEDURE
              u05c256to_packet (VAR n : tsp00_C256;
                    snd_packet       : tsp1_packet_ptr);
 
        PROCEDURE
              u05cmdwrite_prot (VAR protfile : tut_vf_fileref;
                    VAR blankline : tsp00_Line;
                    write_time    : boolean;
                    snd_packet    : tsp1_packet_ptr);
 
        PROCEDURE
              u05connect_mask (VAR term : tut_terminal;
                    is_batch       : boolean;
                    VAR username   : tsp00_KnlIdentifier;
                    VAR password   : tsp00_Name;
                    VAR serverdb   : tsp00_DbName;
                    VAR servernode : tsp00_NodeId;
                    VAR pfkey      : tut_pfkey);
 
        PROCEDURE
              u05diagextract (VAR term : tut_terminal;
                    snd_packet         : tsp1_packet_ptr;
                    VAR pfkey          : tut_pfkey);
 
        PROCEDURE
              u05diagnose (VAR term    : tut_terminal;
                    snd_packet         : tsp1_packet_ptr;
                    VAR is_blockoutput : boolean;
                    VAR menu_finished  : boolean;
                    VAR pfkey          : tut_pfkey);
 
        PROCEDURE
              u05encrypt (pw_clear : tsp00_Name;
                    VAR pw_crypt   : tsp00_CryptPw);
 
        PROCEDURE
              u05errmsg (VAR term : tut_terminal;
                    VAR protfile  : tut_vf_fileref;
                    errcode       : tsp00_Int2);
 
        PROCEDURE
              u05fetch_show (VAR term : tut_terminal;
                    VAR protfile      : tut_vf_fileref;
                    snd_packet        : tsp1_packet_ptr;
                    VAR sql_ref       : tsp00_Int4;
                    header_msg        : tsp00_C30;
                    VAR pfkey         : tut_pfkey;
                    VAR rcv_packet    : tsp1_packet_ptr;
                    VAR sql_retcode   : tsp00_Int2);
 
        PROCEDURE
              u05get_block_addr (
                    VAR term            : tut_terminal;
                    VAR protfile        : tut_vf_fileref;
                    rcv_packet          : tsp1_packet_ptr;
                    VAR pfkey           : tut_pfkey);
 
        PROCEDURE
              u05getcommand (VAR term  : tut_terminal;
                    VAR protfile       : tut_vf_fileref;
                    snd_packet         : tsp1_packet_ptr;
                    write_time         : boolean;
                    VAR ln             : tsp00_Line;
                    VAR is_continue_ln : boolean;
                    VAR pfkey          : tut_pfkey);
 
        PROCEDURE
              u05getserverdb (snd_packet : tsp1_packet_ptr;
                    VAR serverdb   : tsp00_DbName;
                    VAR servernode : tsp00_NodeId);
 
        PROCEDURE
              u05gettoken (snd_packet : tsp1_packet_ptr;
                    VAR tok1 : tsp00_Name;
                    VAR tok2 : tsp00_Name;
                    VAR tok3 : tsp00_Name;
                    VAR tok4 : tsp00_Name;
                    VAR tok5 : tsp00_Name;
                    VAR tok6 : tsp00_Name);
 
        PROCEDURE
              u05get2token (VAR ln : tsp00_Line;
                    VAR tok1 : tsp00_Name;
                    VAR tok2 : tsp00_Name);
 
        PROCEDURE
              u05header (VAR term : tut_terminal;
                    progname      : tsp00_C8;
                    serverdb      : tsp00_DbName;
                    VAR username  : tsp00_KnlIdentifier);
 
        PROCEDURE
              u05illegal_input_errmsg (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    write_prot   : boolean;
                    msg          : tsp00_C20);
 
        PROCEDURE
              u05int_to_packet (int : tsp00_Int4;
                    snd_packet      : tsp1_packet_ptr);
 
        PROCEDURE
              u05intformat (n          : tsp00_Name;
                    max_length         : integer;
                    max_int            : tsp00_Int4;
                    VAR formatted_name : tsp00_Name;
                    VAR ok             : boolean);
 
        FUNCTION
              u05isdevname_upper_case : boolean;
 
        FUNCTION
              u05isuser_upper_case : boolean;
 
        FUNCTION
              u05isyes (VAR n : tsp00_Name): boolean;
 
        FUNCTION
              u05len (n : tsp00_Name): integer;
 
        FUNCTION
              u05len20 (c : tsp00_C20): integer;
 
        PROCEDURE
              u05msgheader (VAR term : tut_terminal; msg : tsp00_C20);
 
        PROCEDURE
              u05nameto_packet (n : tsp00_Name;
                    snd_packet    : tsp1_packet_ptr);
 
        PROCEDURE
              u05packet_init (snd_packet : tsp1_packet_ptr);
 
        PROCEDURE
              u05param_errmsg (VAR term : tut_terminal;
                    VAR protfile        : tut_vf_fileref;
                    rcv_packet          : tsp1_packet_ptr);
 
        PROCEDURE
              u05request_errmsg (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    VAR errtext  : tsp00_ErrText;
                    comm_error   : tsp1_comm_error);
 
        PROCEDURE
              u05sqlexec_errmsg (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    VAR errtext  : tsp00_ErrText;
                    retcode      : tsp00_Int2);
 
        PROCEDURE
              u05str20_to_line (comment : tsp00_C20;
                    VAR commentline     : tsp00_Line);
 
        PROCEDURE
              u05switch (VAR term   : tut_terminal;
                    VAR protfile    : tut_vf_fileref;
                    snd_packet      : tsp1_packet_ptr;
                    VAR sql_ref     : tsp00_Int4;
                    switch_cmd      : tsp00_C20;
                    VAR pfkey       : tut_pfkey;
                    VAR sql_retcode : tsp00_Int2);
 
        PROCEDURE
              u05username_to_packet (VAR n : tsp00_KnlIdentifier;
                    snd_packet : tsp1_packet_ptr);
 
        PROCEDURE
              u05usewrite_prot (VAR protfile : tut_vf_fileref;
                    VAR blankln    : tsp00_Line;
                    VAR serverdb   : tsp00_DbName;
                    VAR servernode : tsp00_NodeId);
 
        PROCEDURE
              u05vfnto_packet (VAR n : tsp00_VFilename;
                    snd_packet       : tsp1_packet_ptr);
 
        PROCEDURE
              u05write_prot (VAR term : tut_terminal;
                    VAR protfile : tut_vf_fileref;
                    n            : tsp00_Name;
                    int          : tsp00_Int4);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              UT_utility_driver : VUT02;
 
        PROCEDURE
              u02send (VAR term      : tut_terminal;
                    VAR protfile     : tut_vf_fileref;
                    snd_packet       : tsp1_packet_ptr;
                    VAR sql_ref      : tsp00_Int4;
                    msg_wanted       : integer;
                    req_only         : boolean;
                    VAR rcv_packet   : tsp1_packet_ptr;
                    VAR sql_retcode  : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              UT_errormsg : VUT03;
 
        PROCEDURE
              u03application (VAR appl_vers : tsp00_C5;
                    VAR application : tsp00_C3);
 
        PROCEDURE
              u03geterrormsg (errcode : tsp00_Int2; VAR ln : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17hexto_line (c : char;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17nameto_line (n : tsp00_Name;
                    VAR ln_len  : integer;
                    VAR ln      : tsp00_Line);
 
        FUNCTION
              g17printable_char (c : char) : boolean;
 
        PROCEDURE
              g17trimint4_to_line (int : tsp00_Int4;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              TA_terminal_IO : VTA09;
 
        FUNCTION
              t09columns_window (VAR term : tut_terminal): integer;
 
        PROCEDURE
              t09frame (VAR term : tut_terminal; on : boolean);
 
        PROCEDURE
              t09get (VAR term : tut_terminal;
                    VAR text   : tsp00_Line;
                    VAR pfkey  : tut_pfkey);
 
 
        PROCEDURE
              t09get1name (VAR term : tut_terminal;
                    msg             : tsp00_C20;
                    msg_attr        : char;
                    in_attr         : char;
                    in_len          : integer;
                    upper_case      : boolean;
                    VAR in_name     : tsp00_Name;
                    VAR pfkey       : tut_pfkey);
 
 
        PROCEDURE
              t09header (VAR term : tut_terminal;
                    left_msg      : tsp00_C20;
                    right_msg     : tsp00_C20);
 
        PROCEDURE
              t09holding (VAR term : tut_terminal;
                    VAR pfkey      : tut_pfkey);
 
        PROCEDURE
              t09mask (VAR term   : tut_terminal;
                    count_names   : integer;
                    mask_size     : integer;
                    VAR mask_spec : tut_term_mask;
                    return_pfkey  : boolean;
                    VAR pfkey     : tut_pfkey);
 
        PROCEDURE
              t09mask_c256_n (VAR term : tut_terminal;
                    count_names   : integer;
                    mask_size     : integer;
                    VAR mask_spec : tut_term_mask;
                    return_pfkey  : boolean;
                    VAR pfkey     : tut_pfkey);
 
        PROCEDURE
              t09menu (VAR term  : tut_terminal;
                    size         : integer;
                    msg_attr     : char;
                    VAR msg      : tut_c20_array;
                    VAR selected : integer;
                    VAR pfkey    : tut_pfkey);
 
        PROCEDURE
              t09newscreen_page (VAR term : tut_terminal);
 
        PROCEDURE
              t09msgheader (VAR term : tut_terminal;
                    msg     : tsp00_C30;
                    is_perm : boolean);
 
        PROCEDURE
              t09put (VAR term : tut_terminal;
                    VAR text   : tsp00_Line;
                    text_attr  : char);
 
        PROCEDURE
              t09put20 (VAR term : tut_terminal;
                    ln20         : tsp00_C20;
                    text_attr    : char);
 
        PROCEDURE
              t09put60 (VAR term : tut_terminal;
                    ln60         : tsp00_C60;
                    text_attr    : char);
 
        PROCEDURE
              t09putmsg (VAR term     : tut_terminal;
                    VAR msg           : tsp00_Line;
                    is_warning        : boolean;
                    immediate_display : boolean);
 
        PROCEDURE
              t09returncode_set (VAR term : tut_terminal;
                    retcode : integer);
 
        PROCEDURE
              t09right_left_holding (VAR term : tut_terminal;
                    turn_right     : boolean;
                    turn_left      : boolean;
                    VAR is_running : boolean;
                    VAR pfkey      : tut_pfkey);
 
        PROCEDURE
              t09setpf1 (VAR term : tut_terminal; pfkey_label : tsp00_C8);
 
        PROCEDURE
              t09uppercase_line (VAR ln : tsp00_Line;
                    lwb : integer;
                    upb : integer);
 
        FUNCTION
              t09window_lines (VAR term : tut_terminal): integer;
 
      ------------------------------ 
 
        FROM
              TA_write_protfile : VTA12;
 
        PROCEDURE
              t12write_prot (VAR fileref : tut_vf_fileref;
                    VAR ln    : tsp00_Line;
                    length    : integer;
                    VAR error : integer);
 
      ------------------------------ 
 
        FROM
              TA_buf_display : VTA14;
 
        PROCEDURE
              t14int4from_line (VAR term : tut_terminal;
                    VAR ln  : tsp00_Line;
                    ln_pos  : integer;
                    ln_len  : integer;
                    VAR int : tsp00_Int4;
                    VAR ok  : boolean);
 
      ------------------------------ 
 
        FROM
              Encrypting : VSP02;
 
        PROCEDURE
              s02applencrypt (pw_clear : tsp00_Name;
                    VAR pw_crypt : tsp00_CryptPw);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26find_part (VAR segm : tsp1_segment;
                    part_kind        : tsp1_part_kind;
                    VAR part_ptr     : tsp1_part_ptr);
 
        PROCEDURE
              s26finish_part (packet_ptr : tsp1_packet_ptr;
                    VAR finish_part      : tsp1_part);
 
        PROCEDURE
              s26init_cmd_packet (packet_ptr : tsp1_packet_ptr;
                    VAR first_segm_ptr       : tsp1_segment_ptr);
 
        PROCEDURE
              s26new_part_init (packet_ptr : tsp1_packet_ptr;
                    VAR segm               : tsp1_segment;
                    VAR new_part_ptr       : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30lnr (VAR str : tsp00_MoveObj;
                    val       : char;
                    start     : tsp00_Int4;
                    cnt       : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30lnr1 (VAR str : tsp00_Line;
                    val        : char;
                    start      : tsp00_Int4;
                    cnt        : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              GETSTRING-Conversions : VSP42;
 
        PROCEDURE
              s42gstr (VAR buf : tsp00_MoveObj;
                    pos        : tsp00_Int4;
                    len        : integer;
                    frac       : integer;
                    origlen    : integer;
                    VAR dest   : tsp00_Line;
                    dpos       : tsp00_Int4;
                    VAR dlen   : integer;
                    VAR res    : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE_driver : VEN102;
 
        PROCEDURE
              sqldattime (VAR d : tsp00_Date;
                    VAR t       : tsp00_Time);
 
        PROCEDURE
              sqlclock (VAR sec  : tsp00_Int4;
                    VAR microsec : tsp00_Int4);
 
        PROCEDURE
              sqlos (VAR os : tsp00_Os);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              t09put;
 
              tsp00_C80 tsp00_Line
 
        FUNCTION
              s30lnr1;
 
              tsp00_MoveObj tsp00_Line
 
        PROCEDURE
              s42gstr;
 
              tsp00_MoveObj   tsp00_Line
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : JuergenA
.sp
.cp 3
Created : 1984-03-26
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-08-23
.sp
***********************************************************
.sp
.cp 11
.fo
.oc _/1
Specification:
.sp 2
Procedure U05ACCOUNT_CMD
.sp
Creates a SQL_PACKET with PART2_LENGTH = 0.
The command in PART1 is formed with the aid of a menu as follows:
.sp;.cp 3;.nf
ACCOUNTING | GET | !
           | ON  |
           | OFF |
.fo;
.sp 2;.cp 4
Procedure U05AUDIT_CMD
.sp
Creates a SQL_PACKET with PART2_LENGTH = 0 and the following PART1:
.sp;.nf
AUDIT TABLE /authname./tablename TO 'hostfilename' !
.fo
.sp 2;.cp 3
Procedure U05C20_TO_PACKET
.sp
Adds a 20-byte string without trailing blanks to the PART1 of a
SQL_PACKET.
.sp 2;.cp 3
Procedure U05C256_TO_PACKET
.sp
Adds a 64-byte string enclosed in quotes without trailing blanks
to the PART1 of a SQL_PACKET.
.sp 2;.cp 3
Procedure U05CHRPARAM_TO_PACKET
.sp
Adds a single character parameter contained in the mask
to the PART1 of a SQL_PACKET.
.sp 2;.cp 10
Procedure U05COLD_INCOPY_CMD
.sp
Creates a SQL_PACKET with PART2_LENGTH = 0 and the following PART1:
.sp;.nf;.cp 6
RESTORE | |DATA | /DIRECT/ FROM 'hostfn' !
        | |PAGES|
        |
        | LOG /DIRECT/ 'sysdev' FROM 'hostfn'
                          /UNTIL 'yyyy-mm-dd' 'hh:mm:ss'/ !
        |
        | LOG 'sysdevname' FROM 'devname' TO 'devname' !
.fo
.sp 2;.cp 23
Procedure U05DIAG_EXTRACT
.sp
Creates a SQL_PACKET with PART2_LENGTH = 0.
The command in PART1 is formed with the aid of a menu as follows:
.sp;.nf;.cp 5
DIAGNOSE 'sysdevname' TO 'hostfilename
 
    | CONFIG !
    | DEVSPACE FROM pno TO pno !
    | PAGES FROM data_pno TO data_pno !
    | RESTART !
    | LOG FROM log_pno TO log_pno !
    | LOG ALL !
    | LOG LAST no_of_last_logpages !
    | COLUMN <hex tabid > !
    | INDEX index_authname.index_name index_number /M/ !
    | INDEX <hex tabid> index_number /M/ !
    | TABLE table_authname.table_name !
    | TABLE <hex tabid> !
    | TABLE root !
.fo;
.sp 2;.cp 4
Procedure U05DIAGNOSE
.sp
The procedure selects the following DIAGNOSE functions:
.sp;.hi 14
VTRACE enables or disables vtrace writing
FLUSH~VTRACE flushes vtrace onto disk
DUMP creates a dump hostfile
.sp 2;.cp 3
Procedure U05ENCRYPT
.sp
This procedure encodes a password and inserts the result into PART2.
.sp 2;.cp 6
Procedure U05ERRMSG
.sp
With the aid of U03GET_ERRMSG, the text belonging to the error
number is determined, displayed in the terminal's message
line along with the internal error number and written into the protocol
file.
.sp 2;.cp 3
Procedure U05FETCH_SHOW
.sp
Creates the output for SHOW on the screen and writes it into the
protocol file.
.sp 2;.cp 4
Procedure U05GETSERVERDB
.sp
The procedure scans the USE command and returns the SERVERDB and
the SERVERNODE.
.sp 2;.cp 4
Procedure U05GET_TOKEN
.sp
Determines the first four tokens in a line that are limited by
spaces.
.sp 2;.cp 4
Procedure U05GET6_TOKEN
.sp
Determines the first six tokens in a line that are limited by
spaces.
.sp 2;.cp 4
Procedure U05HEADER
.sp
A new screen header is created with the username and the name of the
serverdb.
.sp 2;.cp 5
Procedure U05ILLEGAL_INPUT_ERRMSG
.sp
The MSG_ILLEGAL_INPUT message stating the field (from the MSG
parameter) is displayed in the terminal's message line and written
into the protocol file.
.sp 2;.cp 4
Procedure U05INT_FROM_NAME
.sp
The five-character string number with leading zeros contained in
the name N is converted into the integer INT.
.sp 2;.cp 4
Procedure U05INTFORMAT
.sp
This procedure converts the digits in the name N into a formatted
string number with leading zeros of length MAX_LENGTH (5 or 10).
The result is then available in FORMATTED NAME. If the number does
not consist only of digits with trailing blanks or if it is larger
than MAXINTEGER or MAXLONGINT, OK is set to false.
.sp 2;.cp 3
Procedure U05INTPARAM_TO_PACKET
.sp
Adds an integer parameter contained in the mask
to the PART1 of a SQL_PACKET. The integere parameter consists of
5 or 10 digits.
.sp 2;.cp 4
Function U05IS_DEVNAME_UPPER_CASE
.sp
Returns true if the underlying operation system requires an upper case
devspace name.
.sp 2;.cp 4
Function U05IS_YES
.sp
IS_YES yields true, if the parameter N contains the characters
'y', 'Y', 'YE' or'YES' with pendant spaces.
.sp 2;.cp 3
Function U05LEN20
.sp
Yields the length of a 20-byte string.
.sp 2;.cp 4
Procedure U05LOGON_MASK
.sp
.sp 2;.cp 4
Procedure U05MSG_HEADER
.sp
Assigns a 20-byte string to the header line and displays the header.
.sp 2;.cp 4
Procedure U05N_TO_PACKET
.sp
Adds a name without trailing blanks to the PART1 of a SQL_PACKET.
.sp 2;.cp 4
Procedure U05OUTCOPY_CMD
.sp
Creates a command with PART2_LENGTH = 0 for a restarted serverdb.
The command in PART1 is generated as follows with the aid of the
CMD parameter and a RESTORE menu (serverdb, log or pages):
.sp;.cp 4;.nf
SAVE | |DATA | /DIRECT/ TO 'hostfn' /COUNT n/ /CLEAR LOG/ !
     | |PAGES|
     |
     | LOG /DIRECT/ /SEGMENT/ TO 'hostfn' /COUNT n/ !
.fo
.sp 2;.cp 4
Procedure U05PARAM_ERRMSG
.sp
With the aid of U03GET_ERRMSG, the text belonging to the error
number is determined and is parameterized with the
error description contained in the SQL_PACKET.
The error message is displayed in the terminal's message line
along with the internal error number and written into the protocol file.
.sp 2;.cp 4
Procedure U05REQUEST_ERRMSG
.sp
An error message for send or receive errors is displayed in the
terminal's message line and written into the protocol file.
.sp 2;.cp 4
Procedure U05SAVE_COLD_CMD
.sp
Creates a SQL_PACKET with PART2_LENGTH = 0 and the following
Part1 structure:
.sp;.cp 4;.nf
    ||DATA | COLD /DIRECT/ 'sysdev' TO 'hostfn' /COUNT n/ /CLEAR LOG/!
    ||PAGES|
SAVE|
    | LOG COLD /DIRECT/ 'sysdev' /'logdev'/ TO 'h' /COUNT n/ !
.fo
.sp 2;.cp 4
Procedure U05SET_CMD
.sp
Creates a SQL_PACKET with PART2_LENGTH = 0.
The command in PART1 is formed as follows with the aid of a menu:
.sp;.cp 6;.nf
SET | LOCK BUFFER = buf_count | !
    | NOLOG OFF               |
    | WRITE | OFF    |        |
            | ON     |
            | REJECT |
.fo;
.sp 2;.cp 4
Procedure U05SHOW_STAT_CMD
.sp
Creates a SQL_PACKET with PART2_LENGTH = 0.
The command in PART1 is formed as follows with the aid of a menu:
.sp;.cp 10;.nf
SHOW | USER CONNECTED !
     |
     | STATISTICS | CONFIG !
                  | SERVERDB !
                  | DEVSPACE 'dev' !
                  | LOG !
                  | STATE !
                  | LOCK /| CONFIG |/ !
                          | USER   |
                          | TABLE  |
.fo;
.sp 2;.cp 3
Procedure U05STR20_TO_LINE
.sp
A 20-byte string is inserted at the beginning of a line
and the rest of the line is filled with blanks.
.sp 2;.cp 7
Procedure U05SWITCH
.sp
The procedure selects the following SWITCH functions:
SWITCH, SWITCHLIMIT, BUFLIMIT, MINBUF and MAXBUF.
These functions can only be executed with a SLOW kernel.
.sp 2;.cp 4
Procedure U05TABLENAME_CMD
.sp
Once the author name and the table name specified by
MSG have been entered, PART1 of the request is expanded by a space
and an identifier. If a author name has been given, the identifier
consists of the author name followed by a dot and the table name;
other wise, it contains only the table name.
.sp
The procedure creates a request with
PART2_LENGTH = 0 and PART~1: "<cmd>~/authname./tablename!".
.sp 2;.cp 4
Procedure U05TRANSFERRED_MSG
.sp
The number of transferred pages specified by PAGE_COUNT is displayed
in the terminal's message line.
.sp 2;.cp 4
.sp 2;.cp 4
Procedure U05W_CMD_PROT_WRITE
.sp
PART1 of a SQL_PACKET is written into the protocol. If WITH_PART2
is true, the protocol is extended to include PART2 as well.
Output is truncated when LINELENGTH is reached.
.sp 2;.cp 4
Procedure U05W_MASK_PROT_WRITE
.sp
In the same way as the mask is formed, the messages and parameters
contained in MASK_SPEC are written into the protocol file.
.sp 2;.cp 5
Procedure UT05DIAG_DUMP
.sp
Creates a SQL_PACKET with PART2_LENGTH = 0 and the following PART1:
.sp;.nf
DIAGNOSE DATA TO 'hostfilename' !
.fo
.sp 2;.cp 4
Procedure UT05DIAG_VTRACE
.sp
Creates a SQL_PACKET with PART2_LENGTH = 0. PART1 is formed
with the aid of a mask and contains the DIAGNOSE VTRACE command
to enable or disable the VTRACE functions.
If the mask remains unchanged by the user the following default
command is produced:
.sp;.nf
DIAGNOSE VTRACE DEFAULT ON !
.fo
.sp 2;.cp 4
Function UT05IS_SERVERDB_UPPER_CASE
.sp
Returns true if the underlying operation system requires an upper case
serverdb name.
.sp 2;.cp 3
Function UT05LEN
.sp
Yields the length of a name.
.sp 2;.cp 3
Function UT05LEN64
.sp
Yields the length of a 64-byte string.
.sp 2;.cp 4
Procedure UT05NAME_MSG_HEADER
.sp
Assigns an 18-byte name to the header line and displays the header.
.sp 2;.cp 4
.CM *-END-* specification -------------------------------
.fo;
.sp 2
***********************************************************
.sp
.cp 9
.fo
.oc _/1
Description:
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 20
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      comment_sign1          =  '/';
      comment_sign2          =  '*';
      c_at_sign              =  '@';
      c_double_quote         =  '"';
      c_dollar               =  '$';
      c_hash                 =  '#';
      c_msg                  =    1;
      c_in                   =    2;
      display_msg            =     1;
      first_loc              = '0                 ';
      int2_length            =     5;
      int4_length            =    10;
      mx_yes_no              =     2;
      retcode_row_not_found  =   100;
      string_delimiter       = '''';
      suppress_not_found_msg =     2;
      unix_cmd_sign          =   '!';
      (* *)
      c_immediate_displ      = true;
      c_on                   = true;
      c_perm                 = true;
      c_req_only             = true;
      c_return_pfkey         = true;
      c_upper_case           = true;
      c_warning              = true;
      c_write_prot           = true;
      (*
      N A M E *)
      utn_catalog      = 'CATALOG           ';
      utn_clear        = 'CLEAR             ';
      utn_column       = 'COLUMN            ';
      utn_connect      = 'CONNECT           ';
      utn_data         = 'DATA              ';
      utn_diagnose     = 'DIAGNOSE          ';
      utn_exec         = 'EXEC              ';
      utn_exit         = 'EXIT              ';
      utn_extract      = 'EXTRACT           ';
      utn_fdir1        = 'FIRST             ';
      utn_fdir2        = 'SECOND            ';
      utn_for          = 'FOR               ';
      utn_get_block    = 'GET BLOCK ADDRESS ';
      utn_index        = 'INDEX             ';
      utn_perm         = 'PERMANENT         ';
      utn_off          = 'OFF               ';
      utn_on           = 'ON                ';
      utn_page         = 'PAGE              ';
      utn_repair       = 'REPAIR            ';
      utn_run          = 'RUN               ';
      utn_serverdb     = 'SERVERDB          ';
      utn_session      = 'SESSION           ';
      utn_switch       = 'SWITCH            ';
      utn_table        = 'TABLE             ';
      utn_temp         = 'TEMP              ';
      utn_to           = 'TO                ';
      utn_static       = 'STATIC            ';
      utn_unix         = 'UNIX              ';
      utn_use          = 'USE               ';
      utn_vtrace       = 'VTRACE            ';
      no_answer        = 'n                 ';
      utn_flush        = 'FLUSH             ';
      (*
      D U M P L A B E L *)
      dpl_filedirectory     = 'FILEDIRECTORY       ';
      dpl_configuration     = 'CONFIGURATION       ';
      dpl_converter         = 'CONVERTER           ';
      dpl_converter_cache   = 'CONVERTERCACHE      ';
      dpl_data_cache        = 'DATACACHE           ';
      dpl_data_writer       = 'PAGERWRITER         ';
      dpl_fbm               = 'FBM                 ';
      dpl_headmaster        = 'HEADMASTER          ';
      dpl_kb_locklist       = 'KBLOCKLIST          ';
      dpl_netserver         = 'SERVER              ';
      dpl_restartrec        = 'RESTARTRECORD       ';
      dpl_garbagecollection = 'GARBAGECOLLECTION   ';
      (*
      C O M M A N D *)
      cmd_fetch_show       = 'FETCH SHOW INTO :X  ';
      (*
      M E S S A G E *)
      msg_buf_len             = 'BUFFER LENGTH       ';
      msg_blockAddr           = 'GET BLOCK ADDRESS   ';
      msg_data_perm           = 'DATA PERM           ';
      msg_data_static         = 'DATA STATIC         ';
      msg_data_temp           = 'DATA TEMP           ';
      msg_diag_switch         = 'DIAGNOSE SWITCH     ';
      msg_dump_full           = 'FULL DUMP           ';
      msg_dump_partial        = 'PARTIAL DUMP        ';
      msg_hostfn              = 'HOST FILE NAME      ';
      msg_illegal_input       = 'Illegal input:      ';
      msg_perm_page_no        = 'DATA PERM PAGENO    ';
      msg_static_page_no      = 'DATA STATIC PAGENO  ';
      msg_temp_page_no        = 'DATA TEMP PAGENO    ';
      msg_return              = 'RETURN              ';
      msg_vtr_check           = 'CHECK               ';
      msg_vtr_default         = 'DEFAULT             ';
      msg_vtr_delete          = 'DELETE              ';
      msg_vtr_index           = 'INDEX               ';
      msg_vtr_insert          = 'INSERT              ';
      msg_vtr_lock            = 'LOCK                ';
      msg_vtr_long            = 'LONG                ';
      msg_vtr_object          = 'OBJECT              ';
      msg_vtr_OmsFree         = 'FREEPAGE            ';
      msg_vtr_OmsGet          = 'GET                 ';
      msg_vtr_OmsNew          = 'ADD                 ';
      msg_vtr_OmsUpd          = 'ALTER               ';
      msg_vtr_optimize        = 'OPTIMIZE            ';
      msg_vtr_order           = 'ORDER               ';
      msg_vtr_order_st        = 'ORDER STANDARD      ';
      msg_vtr_pages           = 'PAGES               ';
      msg_vtr_select          = 'SELECT              ';
      msg_vtr_table           = 'TABLE               ';
      msg_vtr_time            = 'TIME                ';
      msg_vtr_update          = 'UPDATE              ';
      msg_sql_vtrace_on       = 'SQL VTRACE ON       ';
      msg_oms_vtrace_on       = 'OMS VTRACE ON       ';
      msg_vtrace_off          = '    VTRACE OFF      ';
      msg_vtrace_clear        = 'VTRACE CLEAR        ';
      msg_vtrace_flush        = 'VTRACE FLUSH        ';
      msg_vtrace_session      = 'VTRACE FOR SESSION  ';
      (*
      M E S S A G E  30 *)
      msg30_diag_extract      = '    Diagnose Extract Pages    ';
      msg30_diag_vtrace       = '       Diagnose Vtrace        ';
 
 
(*------------------------------*) 
 
PROCEDURE
      u05c20to_packet (n : tsp00_C20;
            snd_packet   : tsp1_packet_ptr);
 
VAR
      len : integer;
 
BEGIN
len := u05len20 (n);
IF  len > 0
THEN
    WITH snd_packet^.sp1_segm DO
        BEGIN
        IF  sp1p_buf_len > 0
        THEN
            ut05char_to_packet (' ', snd_packet);
        (*ENDIF*) 
        SAPDB_PascalForcedMove (sizeof (n), sp1p_buf_size, @n, 1,
              @sp1p_buf, sp1p_buf_len + 1,len);
        sp1p_buf_len := sp1p_buf_len + len
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05c256to_packet (VAR n : tsp00_C256;
            snd_packet       : tsp1_packet_ptr);
 
VAR
      len : integer;
 
BEGIN
len := ut05len256 (n);
IF  len > 0
THEN
    WITH snd_packet^.sp1_segm DO
        BEGIN
        ut05char_to_packet (' ',              snd_packet);
        ut05char_to_packet (string_delimiter, snd_packet);
        SAPDB_PascalForcedMove (sizeof (n), sp1p_buf_size, @n, 1,
              @sp1p_buf, sp1p_buf_len + 1,
              len);
        sp1p_buf_len := sp1p_buf_len + len;
        ut05char_to_packet (string_delimiter, snd_packet)
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05cmdwrite_prot (VAR protfile : tut_vf_fileref;
            VAR blankline : tsp00_Line;
            write_time    : boolean;
            snd_packet    : tsp1_packet_ptr);
 
VAR
      ln     : tsp00_Line;
      i      : integer;
      length : integer;
      err    : integer;
 
BEGIN
ln := blankline;
WITH snd_packet^.sp1_segm DO
    BEGIN
    length := sp1p_buf_len;
    IF  length > LINE_MXSP00
    THEN
        length := LINE_MXSP00;
    (*ENDIF*) 
    FOR i := 1 TO length DO
        ln [i] := sp1p_buf [i]
    (*ENDFOR*) 
    END;
(*ENDWITH*) 
t12write_prot (protfile, blankline, 1, err);
IF  write_time
THEN
    ut05write_time (protfile, blankline);
(*ENDIF*) 
t12write_prot (protfile, ln, length, err);
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05connect_mask (VAR term : tut_terminal;
            is_batch       : boolean;
            VAR username   : tsp00_KnlIdentifier;
            VAR password   : tsp00_Name;
            VAR serverdb   : tsp00_DbName;
            VAR servernode : tsp00_NodeId;
            VAR pfkey      : tut_pfkey);
 
CONST
      x_user  =  1;
      x_pw    =  2;
      x_db    =  3;
      x_node  =  4;
 
VAR
      i    : integer;
      mask : tut_term_mask;
 
BEGIN
pfkey := pf_none;
t09newscreen_page (term);
t09put   (term, term.blankline,         cut_protected);
t09put20 (term, 'KERNEL/DIAGNOSE     ', cut_bright_protected); (* PTS 1104396 JA 1999-10-28 *)
t09put   (term, term.blankline,         cut_protected);
t09put   (term, term.blankline,         cut_protected);
FOR i := 1 TO x_node DO
    WITH mask [i] DO
        BEGIN
        msg_in_attr [c_msg] := cut_protected;
        msg_in_attr [c_in ] := cut_unprotected;
        upper_case          := true;
        code_input          := false;
        in_len              := sizeof (tsp00_Name);
        in_c256              := term.blankfilename
        END;
    (*ENDWITH*) 
(*ENDFOR*) 
IF  NOT is_batch
THEN
    BEGIN
    mask [x_user ].msg        := '      Username   ==>';
    mask [x_user ].in_ident   := username;
    mask [x_user ].upper_case := u05isuser_upper_case;
    mask [x_user ].in_len     := sizeof (username);
    mask [x_pw   ].msg        := '      Password   ==>';
    mask [x_pw   ].upper_case := mask[x_user].upper_case;
    mask [x_pw   ].in_len     := sizeof (password);
    mask [x_pw   ].msg_in_attr [c_in] := cut_invisible;
    mask [x_db   ].msg        := '      Serverdb   ==>';
    mask [x_db   ].in_db      := serverdb;
    mask [x_db   ].upper_case := ut05is_serverdb_upper (serverdb);
    mask [x_db   ].in_len     := sizeof (serverdb);
    mask [x_node ].msg        := '      Servernode ==>';
    mask [x_node ].in_node    := servernode;
    mask [x_node ].upper_case := ut05is_servernode_upper (servernode);
    mask [x_node ].in_len     := sizeof (tsp00_NodeId);
    t09mask (term, 0, x_node, mask, NOT c_return_pfkey, pfkey);
    IF  pfkey = pf_none
    THEN
        BEGIN
        username   := mask [x_user].in_ident;
        password   := mask [x_pw  ].in_name;
        serverdb   := mask [x_db  ].in_db;
        servernode := mask [x_node].in_node
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
t09putmsg (term, term.blankline, NOT c_warning, is_batch)
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05diagextract (VAR term : tut_terminal;
            snd_packet         : tsp1_packet_ptr;
            VAR pfkey          : tut_pfkey);
 
CONST
      x_tree         =  1;
      x_index        =  3;
      x_column_root  =  5;
      x_fdir1        =  6;
      x_fdir2        =  7;
      x_return       = 10;
      (* *)
      c_from         =  1;
      c_number       =  1;
 
VAR
      dev_upper_case : boolean;
      i              : integer;
      selected       : integer;
      count_names    : integer;
      hostfn         : integer;
      msg            : tut_c20_array;
      mask           : tut_term_mask;
 
BEGIN
pfkey := pf_none;
FOR i := 1 TO x_return DO
    msg [i] := bsp_c20;
(*ENDFOR*) 
msg [x_tree        ] := 'TREE                ';
msg [x_index       ] := 'INDEX               ';
msg [x_column_root ] := 'BLOB                ';
msg [x_fdir1       ] := 'PERM FDIR           ';
msg [x_fdir2       ] := 'BLOB FDIR           ';
msg [x_return      ] := msg_return;
t09msgheader (term, msg30_diag_extract, c_perm);
t09menu      (term, x_return, cut_protected, msg, selected, pfkey);
IF  (selected = x_return) AND (pfkey = pf_none)
THEN
    pfkey := pf_end;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    t09newscreen_page (term);
    u05msgheader      (term, msg [selected]);
    dev_upper_case := u05isdevname_upper_case;
    FOR i := 1 TO 20 DO
        WITH mask [i] DO
            BEGIN
            msg_in_attr [c_msg] := cut_protected;
            msg_in_attr [c_in ] := cut_bright_unprotected;
            upper_case := true;
            code_input := false;
            in_len     := sizeof (tsp00_Name);
            in_c256    := term.blankfilename
            END;
        (*ENDWITH*) 
    (*ENDFOR*) 
    CASE selected OF
        x_tree, x_column_root, x_index:
            BEGIN
            count_names       := c_number;
            hostfn            := count_names + 1;
            mask [c_from].msg := 'ROOT                '
            END;
       x_fdir1, x_fdir2:
            BEGIN
            count_names := c_number;
            hostfn      := count_names;
            END;
        OTHERWISE:
            ;
        END;
    (*ENDCASE*) 
    mask [hostfn].msg        := msg_hostfn;
    mask [hostfn].upper_case := false;
    mask [hostfn].in_len     := sizeof (tsp00_VFilename);
    t09mask (term, count_names, hostfn, mask, NOT c_return_pfkey, pfkey)
    END;
(*ENDIF*) 
IF  pfkey = pf_none
THEN
    BEGIN
    u05packet_init   (snd_packet);
    u05nameto_packet (utn_diagnose,           snd_packet);
    u05nameto_packet (utn_to,                 snd_packet);
    u05c256to_packet (mask [hostfn].in_c256, snd_packet);
    CASE selected OF
        x_tree:
            BEGIN
            u05nameto_packet (utn_table, snd_packet);
            u05nameto_packet (mask [c_number].in_name, snd_packet)
            END;
        x_column_root:
            BEGIN
            u05nameto_packet (utn_column, snd_packet);
            u05nameto_packet (mask [c_number].in_name, snd_packet)
            END;
        x_index:
            BEGIN
            u05nameto_packet (utn_index, snd_packet);
            u05nameto_packet (mask [c_number].in_name, snd_packet)
            END;
        x_fdir1:
            BEGIN
            u05nameto_packet (utn_fdir1, snd_packet);
            END;
        x_fdir2:
            BEGIN
            u05nameto_packet (utn_fdir2, snd_packet);
            END;
        OTHERWISE
            pfkey := pfkey
        END;
    (*ENDCASE*) 
    END;
(*ENDIF*) 
s26finish_part (snd_packet, snd_packet^.sp1_segm.sp1p_part)
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05diagnose (VAR term    : tut_terminal;
            snd_packet         : tsp1_packet_ptr;
            VAR is_blockoutput : boolean;
            VAR menu_finished  : boolean;
            VAR pfkey          : tut_pfkey);
 
CONST
      x_vtrace_on     =  1;
      x_vtrace_oms_on =  2;
      x_vtrace_off    =  3;
      x_vtrace_clear  =  5;
      x_flush         =  6;
      x_session       =  7;
      x_dump_full     =  8;
      x_dump_partial  =  9;
      (* *)
      x_blockAddr     = 11;
      x_return        = 14;
 
VAR
      selected : integer;
      ln       : tsp00_Line;
      msg      : tut_c20_array;
 
BEGIN
pfkey          := pf_none;
is_blockoutput := false;
menu_finished  := false;
FOR selected := 1 TO x_return DO
    msg [selected] := bsp_c20;
(*ENDFOR*) 
msg [x_vtrace_on    ] := msg_sql_vtrace_on;
msg [x_vtrace_oms_on] := msg_oms_vtrace_on;
msg [x_vtrace_off   ] := msg_vtrace_off;
msg [x_vtrace_clear ] := msg_vtrace_clear;
msg [x_flush        ] := msg_vtrace_flush;
msg [x_session      ] := msg_vtrace_session;
msg [x_dump_full    ] := msg_dump_full;
msg [x_dump_partial ] := msg_dump_partial;
msg [x_blockAddr    ] := msg_blockAddr;
msg [x_return       ] := msg_return;
ut05name_msg_header (term, utn_diagnose);
t09menu (term, x_return, cut_protected, msg, selected, pfkey);
IF  (selected = x_return) AND (pfkey = pf_none)
THEN
    pfkey := pf_end;
(*ENDIF*) 
menu_finished := ((pfkey = pf_end) OR (pfkey = pf_cancel));
IF  pfkey = pf_none
THEN
    BEGIN
    CASE selected OF
        x_vtrace_on:
            ut05diag_vtrace (term, snd_packet, pfkey);
        x_vtrace_oms_on:
            ut05diag_oms_vtrace (term, snd_packet, pfkey);
        x_vtrace_off:
            BEGIN
            u05packet_init   (snd_packet);
            u05nameto_packet (utn_diagnose,     snd_packet);
            u05nameto_packet (utn_vtrace,       snd_packet);
            u05c20to_packet  (msg_vtr_check,    snd_packet);
            u05c20to_packet  (msg_vtr_default,  snd_packet);
            u05c20to_packet  (msg_vtr_delete,   snd_packet);
            u05c20to_packet  (msg_vtr_index,    snd_packet);
            u05c20to_packet  (msg_vtr_insert,   snd_packet);
            u05c20to_packet  (msg_vtr_lock,     snd_packet);
            u05c20to_packet  (msg_vtr_long,     snd_packet);
            u05c20to_packet  (msg_vtr_object,   snd_packet);
            u05c20to_packet  (msg_vtr_optimize, snd_packet);
            u05c20to_packet  (msg_vtr_order,    snd_packet);
            u05c20to_packet  (msg_vtr_order_st, snd_packet);
            u05c20to_packet  (msg_vtr_pages,    snd_packet);
            u05c20to_packet  (msg_vtr_select,   snd_packet);
            u05c20to_packet  (msg_vtr_table,    snd_packet);
            u05c20to_packet  (msg_vtr_time,     snd_packet);
            u05c20to_packet  (msg_vtr_update,   snd_packet);
            u05nameto_packet (utn_off,          snd_packet)
            END;
        x_vtrace_clear:
            BEGIN
            u05packet_init   (snd_packet);
            u05nameto_packet (utn_diagnose, snd_packet);
            u05nameto_packet (utn_vtrace,   snd_packet);
            u05nameto_packet (utn_clear,    snd_packet);
            END;
        x_flush:
            BEGIN
            u05packet_init (snd_packet);
            snd_packet^.sp1_segm.sp1c_mess_type := sp1m_dbs;
            u05nameto_packet (utn_diagnose, snd_packet);
            u05nameto_packet (utn_vtrace,   snd_packet);
            u05nameto_packet (utn_flush,    snd_packet)
            END;
        x_session:
            ut05diag_session_vtrace (term, snd_packet, pfkey);
        x_dump_full:
            ut05diag_full_dump (term, snd_packet, pfkey);
        x_dump_partial:
            ut05diag_partial_dump (term, snd_packet, pfkey);
        x_blockAddr:
            BEGIN
            is_blockoutput := true;
            ut05get_block_menue( term, snd_packet, pfkey);
            END;
        END;
    (*ENDCASE*) 
    IF  (selected = x_vtrace_off) OR (selected = x_flush) OR (selected = x_vtrace_clear)
    THEN
        BEGIN
        ln := term.blankline;
        SAPDB_PascalForcedMove (sizeof (msg [selected]), sizeof (ln),
              @msg [selected], 1, @ln, 1, sizeof (msg [selected]));
        t09putmsg (term, ln, NOT c_warning, NOT c_immediate_displ)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
s26finish_part (snd_packet, snd_packet^.sp1_segm.sp1p_part)
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05encrypt (pw_clear : tsp00_Name;
            VAR pw_crypt   : tsp00_CryptPw);
 
BEGIN
s02applencrypt (pw_clear, pw_crypt)
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05errmsg (VAR term : tut_terminal;
            VAR protfile  : tut_vf_fileref;
            errcode       : tsp00_Int2);
 
VAR
      ln  : tsp00_Line;
      err : integer;
 
BEGIN
u03geterrormsg (errcode,  ln);
t09putmsg      (term,     ln, c_warning, NOT c_immediate_displ);
t12write_prot  (protfile, ln, 77, err)
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05fetch_show (VAR term : tut_terminal;
            VAR protfile      : tut_vf_fileref;
            snd_packet        : tsp1_packet_ptr;
            VAR sql_ref       : tsp00_Int4;
            header_msg        : tsp00_C30;
            VAR pfkey         : tut_pfkey;
            VAR rcv_packet    : tsp1_packet_ptr;
            VAR sql_retcode   : tsp00_Int2);
 
CONST
      fixed_prefix      = 30;
      max_shift_bytes   = 30;
      max_show_lines    = 20;
      one_sec           = 1000000;
      timelimit_1byte   = 100000; (* 0.1  sec *)
      timelimit_2bytes  = 500000; (* 0.5  sec *)
      timelimit_3bytes  = 750000; (* 0.75 sec *)
      c_description     = 'DESCRIPTION       ';
      c_lock_info       = 'LOCK INFO         ';
      c_value           = 'VALUE             ';
 
VAR
      is_running    : boolean;
      skip_header   : boolean;
      turn_left     : boolean;
      turn_right    : boolean;
      with_info     : boolean;
      c             : char;
      col_len       : integer;
      curr_col      : integer;
      curr_part_pos : integer;
      curr_show     : integer;
      displayed_len : integer;
      err           : integer;
      header_space  : integer;
      len           : integer;
      line_count    : integer;
      max_rolls     : integer;
      max_show_len  : integer;
      pos           : integer;
      prefix_len    : integer;
      roll_count    : integer;
      shift_bytes   : integer;
      window_cols   : integer;
      show_len      : tsp00_Int4;
      start_micsec  : tsp00_Int4;
      start_sec     : tsp00_Int4;
      stop_micsec   : tsp00_Int4;
      stop_sec      : tsp00_Int4;
      curr_part_ptr : tsp1_part_ptr;
      col_name      : ARRAY [1..2] OF tsp00_Name;
      out_ln        : tsp00_Line;
      show_ln       : ARRAY [0..max_show_lines] OF tsp00_Key;
 
BEGIN
pfkey         := pf_none;
turn_left     := false;
turn_right    := false;
with_info     := true;
displayed_len := 0;
header_space  := 0;
line_count    := 0;
max_show_len  := 0;
show_len      := 0;
window_cols   := t09columns_window (term);
IF  window_cols > LINE_MXSP00
THEN
    window_cols := LINE_MXSP00;
(*ENDIF*) 
t09newscreen_page (term);
t09msgheader      (term, header_msg, c_perm);
SAPDB_PascalForcedFill (sizeof (show_ln [0]), @show_ln [0], 1,
      sizeof (show_ln [0]), ' ');
FOR curr_show := 1 TO max_show_lines DO
    show_ln [curr_show] := show_ln [0];
(*ENDFOR*) 
FOR curr_col := 1 TO 2 DO
    col_name [curr_col] := bsp_name;
(*ENDFOR*) 
REPEAT
    IF  show_len - displayed_len <= 0
    THEN
        BEGIN
        u05packet_init  (snd_packet);
        snd_packet^.sp1_segm.sp1c_mess_type := sp1m_dbs;
        snd_packet^.sp1_segm.sp1c_with_info := with_info;
        u05c20to_packet (cmd_fetch_show, snd_packet);
        s26finish_part (snd_packet, snd_packet^.sp1_segm.sp1p_part);
        u02send (term, protfile, snd_packet, sql_ref,
              suppress_not_found_msg, NOT c_req_only,
              rcv_packet, sql_retcode);
        END;
    (*ENDIF*) 
    IF  with_info AND (sql_retcode = 0)
    THEN
        BEGIN
        s26find_part (rcv_packet^.sp1_segm,
              sp1pk_columnnames, curr_part_ptr);
        WITH curr_part_ptr^ DO
            BEGIN
            (* first show contains column info *)
            with_info := false;
            IF  sp1p_arg_count = 2
            THEN
                BEGIN
                curr_part_pos := 1;
                FOR curr_col := 1 TO 2 DO
                    BEGIN
                    col_len := ord (sp1p_buf [curr_part_pos]);
                    IF  col_len > NAME_MXSP00
                    THEN
                        len := NAME_MXSP00
                    ELSE
                        len := col_len;
                    (*ENDIF*) 
                    SAPDB_PascalForcedMove (sp1p_buf_size,
                          sizeof (col_name [curr_col]),
                          @sp1p_buf, curr_part_pos + 1,
                          @col_name [curr_col], 1, len);
                    curr_part_pos := curr_part_pos + col_len + 1;
                    END;
                (*ENDFOR*) 
                skip_header := (col_name [1] = c_description)
                      AND      (col_name [2] = c_value      )
                END
            ELSE
                IF  sp1p_arg_count = 1
                THEN
                    BEGIN
                    col_len := ord (sp1p_buf [1]);
                    IF  col_len > NAME_MXSP00
                    THEN
                        len := NAME_MXSP00
                    ELSE
                        len := col_len;
                    (*ENDIF*) 
                    SAPDB_PascalForcedMove (sp1p_buf_size,
                          sizeof (col_name [1]),
                          @sp1p_buf, 2,
                          @col_name [1], 1, len);
                    skip_header := (col_name [1] = c_lock_info)
                    END
                ELSE
                    skip_header := false;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  NOT skip_header
            THEN
                BEGIN
                header_space  := 1;
                pos           := 1;
                curr_part_pos := 1;
                FOR curr_col := 1 TO sp1p_arg_count DO
                    BEGIN
                    col_len := ord (sp1p_buf [curr_part_pos]);
                    IF  pos + col_len - 1 <= sizeof (show_ln [0])
                    THEN
                        BEGIN
                        IF  col_len > NAME_MXSP00
                        THEN
                            len := NAME_MXSP00
                        ELSE
                            len := col_len;
                        (*ENDIF*) 
                        SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (show_ln [0]),
                              @sp1p_buf, curr_part_pos + 1,
                              @show_ln [0], pos, len);
                        pos := pos + col_len + 1
                        END;
                    (*ENDIF*) 
                    curr_part_pos := curr_part_pos + col_len + 1;
                    END;
                (*ENDFOR*) 
                out_ln := term.blankline;
                IF  pos - 2 > sizeof (out_ln)
                THEN
                    len := sizeof (out_ln)
                ELSE
                    len := pos - 2;
                (*ENDIF*) 
                SAPDB_PascalForcedMove (sizeof (show_ln [0]), sizeof (out_ln),
                      @show_ln [0], 1, @out_ln, 1, len);
                t12write_prot (protfile, out_ln, len, err);
                IF  term.is_display AND NOT term.is_virt_term
                THEN
                    BEGIN
                    out_ln := term.blankline;
                    IF  pos - 2 > window_cols
                    THEN
                        len := window_cols
                    ELSE
                        len := pos - 2;
                    (*ENDIF*) 
                    SAPDB_PascalForcedMove (sizeof (show_ln [0]), sizeof (out_ln),
                          @show_ln [0], 1,
                          @out_ln, 1, len);
                    t09put (term, out_ln, cut_bright_protected)
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    IF  (show_len - displayed_len <= 0) AND (sql_retcode = 0)
    THEN
        BEGIN
        s26find_part (rcv_packet^.sp1_segm, sp1pk_data, curr_part_ptr);
        (* skip first defined byte *)
        WITH curr_part_ptr^ DO
            show_len := s30lnr (sp1p_buf, ' ', 2, sp1p_buf_len - 1);
        (*ENDWITH*) 
        displayed_len := 0
        END;
    (*ENDIF*) 
    IF  sql_retcode = 0
    THEN
        BEGIN
        IF  show_len - displayed_len > sizeof (show_ln [0])
        THEN
            len := sizeof (show_ln [0])
        ELSE
            len := show_len - displayed_len;
        (*ENDIF*) 
        IF  show_len > max_show_len
        THEN
            max_show_len := show_len;
        (*ENDIF*) 
        IF  max_show_len > KEY_MXSP00
        THEN
            max_show_len := KEY_MXSP00;
        (*ENDIF*) 
        line_count := line_count + 1;
        FOR pos := 1 TO len DO
            BEGIN
            c := curr_part_ptr^.sp1p_buf
                  [1 + displayed_len + pos];
            IF  g17printable_char (c)
            THEN
                show_ln [line_count, pos] := c
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        displayed_len := displayed_len + len;
        err := 0;
        pos := 1;
        WHILE (pos <= len) AND (err = 0) DO
            BEGIN
            out_ln := term.blankline;
            IF  len - pos + 1 > LINE_MXSP00
            THEN
                col_len := LINE_MXSP00
            ELSE
                col_len := len - pos + 1;
            (*ENDIF*) 
            SAPDB_PascalForcedMove (sizeof (show_ln [line_count]), sizeof (out_ln),
                  @show_ln [line_count], pos,
                  @out_ln, 1, col_len);
            t12write_prot (protfile, out_ln, col_len, err);
            pos := pos + col_len
            END;
        (*ENDWHILE*) 
        IF  term.is_display AND NOT term.is_virt_term
        THEN
            BEGIN
            pos := 1;
            WHILE pos <= len DO
                BEGIN
                out_ln := term.blankline;
                IF  len - pos + 1 > window_cols
                THEN
                    col_len := window_cols
                ELSE
                    col_len := len - pos + 1;
                (*ENDIF*) 
                SAPDB_PascalForcedMove (sizeof (show_ln [line_count]), sizeof (out_ln),
                      @show_ln [line_count], pos,
                      @out_ln, 1, col_len);
                t09put (term, out_ln, cut_protected);
                pos := pos + col_len
                END
            (*ENDWHILE*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  term.is_display AND term.is_virt_term
        AND
        (((sql_retcode = retcode_row_not_found) AND
        (line_count > 0))
        OR
        ((sql_retcode = 0)
        AND ((header_space + line_count >= t09window_lines (term)) OR
        (    line_count >= max_show_lines))))
    THEN
        BEGIN
        IF  max_show_len > window_cols
        THEN
            sqlclock (start_sec, start_micsec);
        (*ENDIF*) 
        FOR curr_show := 1 - header_space TO line_count DO
            BEGIN
            out_ln := term.blankline;
            SAPDB_PascalForcedMove (sizeof (show_ln [curr_show]), sizeof (out_ln),
                  @show_ln [curr_show], 1,
                  @out_ln, 1, window_cols);
            IF  curr_show = 0
            THEN
                t09put (term, out_ln, cut_bright_protected)
            ELSE
                t09put (term, out_ln, cut_protected)
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        IF  max_show_len > window_cols
        THEN
            BEGIN
            IF  line_count + header_space < t09window_lines (term)
            THEN
                t09putmsg (term, term.blankline, NOT c_warning,
                      c_immediate_displ);
            (*ENDIF*) 
            sqlclock (stop_sec, stop_micsec);
            IF  stop_sec - start_sec > 1
            THEN
                start_micsec := one_sec
            ELSE
                IF  start_sec + 1 = stop_sec
                THEN
                    start_micsec := stop_micsec + one_sec - start_micsec
                ELSE
                    start_micsec := stop_micsec - start_micsec;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  start_micsec <= 0
            THEN
                shift_bytes := 2
            ELSE
                IF  start_micsec <= timelimit_1byte
                THEN
                    shift_bytes := 1
                ELSE
                    IF  start_micsec <= timelimit_2bytes
                    THEN
                        shift_bytes := 2
                    ELSE
                        IF  start_micsec <= timelimit_3bytes
                        THEN
                            shift_bytes := 3
                        ELSE
                            shift_bytes := max_shift_bytes;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            max_rolls := max_shift_bytes DIV shift_bytes
            END;
        (*ENDIF*) 
        IF  max_show_len <= window_cols
        THEN
            t09holding (term, pfkey)
        ELSE
            BEGIN
            turn_right := true;
            turn_left  := false;
            (* holding after first truncated screen *)
            t09right_left_holding (term, turn_right, turn_left,
                  is_running, pfkey);
            (* is_running => display following screen, skip rolling *)
            is_running := false;
            turn_right := false;
            turn_left  := false;
            pos        := 1;
            roll_count := 0;
            WHILE (pfkey = pf_left) OR (pfkey = pf_right) OR
                  is_running DO
                BEGIN
                IF  (roll_count > max_rolls) AND NOT is_running
                THEN
                    BEGIN
                    roll_count := 0;
                    (* holding after rolling *)
                    t09right_left_holding (term, turn_right, turn_left,
                          is_running, pfkey);
                    (* is_running => roll to right margin *)
                    turn_right := false;
                    turn_left  := false
                    END;
                (*ENDIF*) 
                t09newscreen_page (term);
                FOR curr_show := 1 - header_space TO line_count DO
                    BEGIN
                    out_ln := term.blankline;
                    IF  pos > 1
                    THEN
                        BEGIN
                        SAPDB_PascalForcedMove (sizeof (show_ln [curr_show]),
                              sizeof (out_ln),
                              @show_ln [curr_show], 1,
                              @out_ln, 1, fixed_prefix);
                        out_ln [fixed_prefix  ] := ' ';
                        out_ln [fixed_prefix+1] := csp_vertical_bar;
                        out_ln [fixed_prefix+2] := ' ';
                        prefix_len := fixed_prefix + 2
                        END
                    ELSE
                        prefix_len := 0;
                    (*ENDIF*) 
                    SAPDB_PascalForcedMove (sizeof (show_ln [curr_show]),
                          sizeof (out_ln),
                          @show_ln [curr_show], pos + prefix_len,
                          @out_ln, prefix_len + 1,
                          window_cols - prefix_len);
                    IF  curr_show = 0
                    THEN
                        t09put (term, out_ln, cut_bright_protected)
                    ELSE
                        t09put (term, out_ln, cut_protected)
                    (*ENDIF*) 
                    END;
                (*ENDFOR*) 
                roll_count := roll_count + 1;
                IF  is_running AND
                    (pos >= max_show_len - window_cols + 1)
                THEN
                    (* right rolling finished *)
                    is_running := false;
                (*ENDIF*) 
                IF  (roll_count <= max_rolls) OR is_running
                THEN
                    BEGIN
                    turn_right := true;
                    turn_left  := true;
                    IF  (pfkey = pf_right) OR is_running
                    THEN
                        BEGIN
                        pos := pos + shift_bytes;
                        IF  pos >= max_show_len - window_cols + 1
                        THEN
                            BEGIN
                            pos := max_show_len - window_cols + 1;
                            roll_count := max_rolls;
                            turn_right := false;
                            turn_left  := true
                            END
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  pfkey = pf_left
                        THEN
                            BEGIN
                            pos := pos - shift_bytes;
                            IF  pos <= 1
                            THEN
                                BEGIN
                                pos := 1;
                                roll_count := max_rolls;
                                turn_right := true;
                                turn_left  := false;
                                END
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDWHILE*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (sql_retcode = 0) AND (pfkey = pf_none)
        AND ((header_space + line_count >= t09window_lines (term)) OR
        (    line_count >= max_show_lines))
    THEN
        BEGIN
        t09newscreen_page (term);
        max_show_len := 0;
        line_count   := 0;
        SAPDB_PascalForcedFill (sizeof (show_ln [1]), @show_ln [1], 1,
              sizeof (show_ln [1]), ' ');
        FOR curr_show := 2 TO max_show_lines DO
            show_ln [curr_show] := show_ln [1]
        (*ENDFOR*) 
        END
    (*ENDIF*) 
UNTIL
    (sql_retcode <> 0) OR (pfkey <> pf_none);
(*ENDREPEAT*) 
IF  sql_retcode <> cut_sql_req_failed
THEN
    t09returncode_set (term, sql_retcode);
(*ENDIF*) 
IF  sql_retcode = retcode_row_not_found
THEN
    BEGIN
    IF  with_info
    THEN
        (* first fetch returns row not found *)
        u05errmsg (term, protfile, sql_retcode)
    ELSE
        t09returncode_set (term, 0);
    (*ENDIF*) 
    sql_retcode := 0
    END;
(*ENDIF*) 
IF  pfkey <> pf_cancel
THEN
    pfkey := pf_none
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05getcommand (VAR term  : tut_terminal;
            VAR protfile       : tut_vf_fileref;
            snd_packet         : tsp1_packet_ptr;
            write_time         : boolean;
            VAR ln             : tsp00_Line;
            VAR is_continue_ln : boolean;
            VAR pfkey          : tut_pfkey);
 
VAR
      get_next  : boolean;
      is_first  : boolean;
      displ_ln  : boolean;
      ln_len    : integer;
      dummy_err : integer;
      tok1      : tsp00_Name;
      tok2      : tsp00_Name;
      curr_ln   : tsp00_Line;
      prot_ln   : tsp00_Line;
 
BEGIN
pfkey    := pf_none;
curr_ln  := ln;
get_next := true;
is_first := true;
u05packet_init (snd_packet);
snd_packet^.sp1_segm.sp1c_producer := sp1pr_user_cmd;
WHILE (pfkey = pf_none) AND get_next
      AND
      (snd_packet^.sp1_segm.sp1p_buf_len + 1 + sizeof (curr_ln)
      <= snd_packet^.sp1_segm.sp1p_buf_size) DO
    BEGIN
    ln_len := s30lnr1 (curr_ln, ' ', 1, LINE_MXSP00);
    IF  ln_len = 0
    THEN
        BEGIN
        t12write_prot (protfile, term.blankline, 1, dummy_err);
        get_next       := false;
        is_continue_ln := false
        END
    ELSE
        IF  (curr_ln [1] = comment_sign1) AND
            (curr_ln [2] = comment_sign2)
        THEN
            BEGIN
            t12write_prot (protfile, curr_ln, ln_len, dummy_err);
            is_continue_ln := true;
            IF  is_first
            THEN
                BEGIN
                t09get (term, curr_ln, pfkey);
                ln := curr_ln
                END
            ELSE
                get_next := false
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            displ_ln := true;
            prot_ln  := curr_ln; (* lower case *)
            t09uppercase_line (curr_ln, 1, ln_len);
            IF  snd_packet^.sp1_segm.sp1p_buf_len = 0
            THEN
                (* first line *)
                BEGIN
                u05get2token (curr_ln, tok1, tok2);
                IF  ut05isexec (tok1)
                THEN
                    BEGIN
                    get_next := false;
                    curr_ln  := ln (* lower case *)
                    END
                ELSE
                    IF  (tok1 = utn_connect)
                        OR
                        ((tok1 = utn_exit) AND (tok2 = bsp_name))
                        OR
                        ((tok1 = utn_diagnose) AND
                        (                      (tok2 = bsp_name   ) OR
                        (                       tok2 = utn_catalog) OR
                        (                       tok2 = utn_extract) OR
                        (                       tok2 = utn_repair ) OR
                        (                       tok2 = utn_switch )))
                    THEN
                        BEGIN
                        get_next := false;
                        displ_ln := false
                        END
                    ELSE
                        IF  tok1 <> utn_run
                        THEN
                            prot_ln := curr_ln (* upper case *)
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                prot_ln := curr_ln; (* upper case *)
            (*ENDIF*) 
            IF  displ_ln
            THEN
                BEGIN
                IF  is_first
                THEN
                    BEGIN
                    t12write_prot (protfile, term.blankline, 1,
                          dummy_err);
                    IF  write_time
                    THEN
                        ut05write_time (protfile, term.blankline)
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                t12write_prot (protfile, prot_ln, ln_len, dummy_err)
                END;
            (*ENDIF*) 
            WITH snd_packet^.sp1_segm DO
                BEGIN
                IF  sp1p_buf_len > 0
                THEN
                    ut05char_to_packet (' ', snd_packet);
                (*ENDIF*) 
                SAPDB_PascalForcedMove (sizeof (curr_ln), sp1p_buf_size, @curr_ln, 1,
                      @sp1p_buf, sp1p_buf_len + 1,
                      ln_len);
                sp1p_buf_len := sp1p_buf_len + ln_len
                END;
            (*ENDWITH*) 
            IF  is_continue_ln AND get_next
            THEN
                t09get (term, curr_ln, pfkey)
            ELSE
                get_next := false
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    is_first := false;
    END;
(*ENDWHILE*) 
s26finish_part (snd_packet, snd_packet^.sp1_segm.sp1p_part)
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05getserverdb (snd_packet : tsp1_packet_ptr;
            VAR serverdb   : tsp00_DbName;
            VAR servernode : tsp00_NodeId);
 
VAR
      is_delimiter : boolean;
      count        : integer;
      i            : integer;
      pos          : integer;
      token        : tsp00_Name;
 
BEGIN
pos      := 1;
serverdb := bsp_dbname;
WITH snd_packet^.sp1_segm DO
    BEGIN
    (* skip blanks *)
    WHILE (pos <= sp1p_buf_len) AND (sp1p_buf [pos] = ' ') DO
        pos := pos + 1;
    (*ENDWHILE*) 
    (* skip keyword *)
    WHILE (pos <= sp1p_buf_len) AND (sp1p_buf [pos] <> ' ') DO
        pos := pos + 1;
    (*ENDWHILE*) 
    count        := 0;
    is_delimiter := false;
    REPEAT
        (* skip blanks *)
        WHILE (pos <= sp1p_buf_len) AND (sp1p_buf [pos] = ' ') DO
            pos := pos + 1;
        (*ENDWHILE*) 
        IF  (pos <= sp1p_buf_len) AND
            (sp1p_buf [pos] = string_delimiter)
        THEN
            BEGIN
            pos          := pos + 1;
            is_delimiter := true
            END;
        (*ENDIF*) 
        i := 1;
        token    := bsp_name;
        serverdb := bsp_dbname;
        WHILE (i   <= DBNAME_MXSP00                ) AND
              (pos <  sp1p_buf_len               ) AND
              (sp1p_buf [pos] <> ' '             ) AND
              (sp1p_buf [pos] <> string_delimiter) DO
            BEGIN
            IF  i <= NAME_MXSP00
            THEN
                token [i] := sp1p_buf [pos];
            (*ENDIF*) 
            serverdb [i] := sp1p_buf [pos];
            pos := pos + 1;
            i   := i   + 1
            END;
        (*ENDWHILE*) 
        IF  is_delimiter                        AND
            (pos <= sp1p_buf_len              ) AND
            (sp1p_buf [pos] = string_delimiter)
        THEN
            pos := pos + 1;
        (*ENDIF*) 
        count := count + 1
    UNTIL
        is_delimiter OR (token <> utn_serverdb) OR (count >= 2);
    (*ENDREPEAT*) 
    (* skip blanks *)
    WHILE  (pos <= sp1p_buf_len) AND (sp1p_buf [pos] = ' ') DO
        pos := pos + 1;
    (*ENDWHILE*) 
    IF  pos <= sp1p_buf_len
    THEN
        BEGIN
        servernode := bsp_nodeid;
        (* skip token 'ON' *)
        IF  (pos <= sp1p_buf_len) AND (sp1p_buf [pos] = 'O')
        THEN
            pos := pos + 1;
        (*ENDIF*) 
        IF  (pos <= sp1p_buf_len) AND (sp1p_buf [pos] = 'N')
        THEN
            pos := pos + 1;
        (* skip blanks *)
        (*ENDIF*) 
        WHILE  (pos <= sp1p_buf_len) AND (sp1p_buf [pos] = ' ') DO
            pos := pos + 1;
        (*ENDWHILE*) 
        i := 1;
        IF  (pos <= sp1p_buf_len) AND
            (sp1p_buf [pos] = string_delimiter)
        THEN
            pos := pos + 1;
        (*ENDIF*) 
        WHILE  (pos <= sp1p_buf_len)
              AND (i <= NODEID_MXSP00)
              AND (sp1p_buf [pos] <> ' ')
              AND (sp1p_buf [pos] <> string_delimiter) DO
            BEGIN
            servernode [i] := sp1p_buf [pos];
            pos := pos + 1;
            i   := i + 1
            END
        (*ENDWHILE*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05gettoken (snd_packet : tsp1_packet_ptr;
            VAR tok1 : tsp00_Name;
            VAR tok2 : tsp00_Name;
            VAR tok3 : tsp00_Name;
            VAR tok4 : tsp00_Name;
            VAR tok5 : tsp00_Name;
            VAR tok6 : tsp00_Name);
 
VAR
      is_str1    : boolean;
      is_str2    : boolean;
      i          : integer;
      curr_token : integer;
      pos        : integer;
      endpos     : integer;
      n          : ARRAY [1..6] OF tsp00_Name;
 
BEGIN
pos := 1;
FOR curr_token := 1 TO 6 DO
    WITH snd_packet^.sp1_segm DO
        BEGIN
        n [curr_token] := bsp_name;
        WHILE (pos <= sp1p_buf_len) AND (sp1p_buf [pos] = ' ') DO
            pos := pos + 1;
        (*ENDWHILE*) 
        endpos  := pos;
        is_str1 := false;
        is_str2 := false;
        i       := 1;
        WHILE (endpos <= sp1p_buf_len) AND
              ((sp1p_buf [endpos] <> ' ') OR is_str1 OR is_str2) DO
            BEGIN
            IF  sp1p_buf [endpos] = string_delimiter
            THEN
                is_str1 := NOT is_str1
            ELSE
                IF  (sp1p_buf [endpos] = c_double_quote)
                    AND NOT is_str1
                THEN
                    is_str2 := NOT is_str2;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  (i <= sizeof (n [curr_token]))
                AND
                (is_str1 OR
                (sp1p_buf [endpos] <> c_double_quote))
            THEN
                BEGIN
                n [curr_token] [i] := sp1p_buf [endpos];
                i := i + 1
                END;
            (*ENDIF*) 
            endpos := endpos + 1
            END;
        (*ENDWHILE*) 
        pos := endpos
        END;
    (*ENDWITH*) 
(*ENDFOR*) 
tok1 := n [1];
tok2 := n [2];
tok3 := n [3];
tok4 := n [4];
tok5 := n [5];
tok6 := n [6]
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05get2token (VAR ln : tsp00_Line;
            VAR tok1 : tsp00_Name;
            VAR tok2 : tsp00_Name);
 
VAR
      is_str1    : boolean;
      is_str2    : boolean;
      i          : integer;
      curr_token : integer;
      pos        : integer;
      endpos     : integer;
      n          : ARRAY [1..2] OF tsp00_Name;
 
BEGIN
pos := 1;
FOR curr_token := 1 TO 2 DO
    BEGIN
    n [curr_token] := bsp_name;
    WHILE (pos < LINE_MXSP00) AND (ln [pos] = ' ') DO
        pos := pos + 1;
    (*ENDWHILE*) 
    endpos  := pos;
    is_str1 := false;
    is_str2 := false;
    i       := 1;
    WHILE (endpos < LINE_MXSP00)
          AND
          ((ln [endpos] <> ' ') OR is_str1 OR is_str2) DO
        BEGIN
        IF  ln [endpos] = string_delimiter
        THEN
            is_str1 := NOT is_str1
        ELSE
            IF  (ln [endpos] = c_double_quote) AND NOT is_str1
            THEN
                is_str2 := NOT is_str2;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  (i <= NAME_MXSP00)
            AND
            (is_str1 OR (ln [endpos] <> c_double_quote))
        THEN
            BEGIN
            n [curr_token] [i] := ln [endpos];
            i := i + 1
            END;
        (*ENDIF*) 
        endpos := endpos + 1
        END;
    (*ENDWHILE*) 
    pos := endpos
    END;
(*ENDFOR*) 
tok1 := n [1];
tok2 := n [2]
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05header (VAR term : tut_terminal;
            progname      : tsp00_C8;
            serverdb      : tsp00_DbName;
            VAR username  : tsp00_KnlIdentifier);
 
VAR
      i         : integer;
      len       : integer;
      n         : tsp00_Sname;
      left_msg  : tsp00_C20;
      right_msg : tsp00_C20;
 
BEGIN
left_msg := bsp_c20;
FOR i := 1 TO 8 DO
    left_msg [i] := progname [i];
(*ENDFOR*) 
len := u05len20 (left_msg);
FOR i := 1 TO 20 - len - 2 DO
    left_msg [len+2+i] := serverdb [i];
(*ENDFOR*) 
right_msg := bsp_c20;
len := sizeof (username);
WHILE (username [len] = ' ') AND (len > 1) DO
    len := len - 1;
(*ENDWHILE*) 
IF  len <= 20 - 1 - 5
THEN
    BEGIN
    n := 'USER:       ';
    FOR i := 1 TO 5 DO
        right_msg [20 - len - 1 - 5 + i] := n [i]
    (*ENDFOR*) 
    END;
(*ENDIF*) 
IF  len > 20
THEN
    len := 20;
(*ENDIF*) 
FOR i := 1 TO len DO
    right_msg [20 - len + i] := username [i];
(*ENDFOR*) 
t09frame  (term, c_on);
t09header (term, left_msg, right_msg)
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05illegal_input_errmsg (VAR term : tut_terminal;
            VAR protfile : tut_vf_fileref;
            write_prot   : boolean;
            msg          : tsp00_C20);
 
VAR
      ln  : tsp00_Line;
      err : integer;
      i   : integer;
 
BEGIN
u05str20_to_line (msg_illegal_input, ln);
FOR i := 1 TO 20 DO
    ln [20+i] := msg [i];
(*ENDFOR*) 
t09putmsg (term, ln, c_warning, NOT c_immediate_displ);
IF  write_prot
THEN
    t12write_prot (protfile, ln, 40, err)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05int_to_packet (int : tsp00_Int4;
            snd_packet      : tsp1_packet_ptr);
 
VAR
      len     : integer;
 
      univ_ln : RECORD
            CASE integer OF
                1:
                    (ln : tsp00_Line );
                2:
                    (n  : tsp00_Name)
                END;
            (*ENDCASE*) 
 
 
BEGIN
univ_ln.n := bsp_name;
len       := 0;
g17trimint4_to_line (int, len, univ_ln.ln);
IF  len > 0
THEN
    WITH snd_packet^.sp1_segm DO
        BEGIN
        IF  sp1p_buf_len > 0
        THEN
            ut05char_to_packet (' ', snd_packet);
        (*ENDIF*) 
        SAPDB_PascalForcedMove (sizeof (univ_ln.n), sp1p_buf_size,
              @univ_ln.n, 1,
              @sp1p_buf, sp1p_buf_len + 1, len);
        sp1p_buf_len := sp1p_buf_len + len
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05intformat (n          : tsp00_Name;
            max_length         : integer;
            max_int            : tsp00_Int4;
            VAR formatted_name : tsp00_Name;
            VAR ok             : boolean);
 
VAR
      rem    : tsp00_Int4;
      first  : integer;
      last   : integer;
      length : integer;
      i      : integer;
      max_n  : tsp00_Name;
 
BEGIN
ok := true;
formatted_name := bsp_name;
first := 1;
WHILE (first < NAME_MXSP00) AND (n [first] = ' ') DO
    first := first + 1;
(*ENDWHILE*) 
last := NAME_MXSP00;
WHILE (last > 1) AND (n [last] = ' ') DO
    last := last - 1;
(*ENDWHILE*) 
length := last - first + 1;
IF  (last < first) OR (length > max_length)
THEN
    ok := false
ELSE
    BEGIN
    i := first;
    WHILE ok AND (i <= last) DO
        BEGIN
        IF  (n [i] < '0') OR (n [i] > '9')
        THEN
            ok := false;
        (*ENDIF*) 
        i := i + 1
        END
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
IF  ok
THEN
    BEGIN
    FOR i := 1 TO max_length - length DO
        formatted_name [i] := '0';
    (*ENDFOR*) 
    FOR i := 1 TO length DO
        formatted_name [max_length-length+i] := n [first+i-1];
    (*ENDFOR*) 
    max_n := bsp_name;
    IF  length = max_length
    THEN
        BEGIN
        rem := max_int;
        FOR i := max_length DOWNTO 1 DO
            BEGIN
            max_n [i] := chr ((rem MOD 10) + ord ('0'));
            rem       := rem DIV 10
            END;
        (*ENDFOR*) 
        IF  formatted_name > max_n
        THEN
            ok := false
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      u05isdevname_upper_case : boolean;
 
BEGIN
u05isdevname_upper_case := false
END;
 
(*------------------------------*) 
 
FUNCTION
      ut05isexec (VAR token : tsp00_Name): boolean;
 
VAR
      os : tsp00_Os;
 
BEGIN
sqlos (os);
ut05isexec :=
      ((token = utn_exec)
      OR
      ((os = os_unix) AND
      ((token = utn_unix) OR (token [1] = unix_cmd_sign))))
END;
 
(*------------------------------*) 
 
FUNCTION
      u05isuser_upper_case : boolean;
 
BEGIN
u05isuser_upper_case := true
END;
 
(*------------------------------*) 
 
FUNCTION
      u05isyes (VAR n : tsp00_Name): boolean;
 
BEGIN
IF  (n = 'y                 ') OR (n = 'YE                ') OR
    (n = 'Y                 ') OR (n = 'YES               ')
THEN
    u05isyes := true
ELSE
    u05isyes := false
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      u05len (n : tsp00_Name): integer;
 
VAR
      i : integer;
 
BEGIN
IF  n = bsp_name
THEN
    i := 0
ELSE
    BEGIN
    i := NAME_MXSP00;
    WHILE (i > 1) AND (n [i] = ' ') DO
        i := i - 1
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
u05len := i
END;
 
(*------------------------------*) 
 
FUNCTION
      u05len20 (c : tsp00_C20): integer;
 
VAR
      i : integer;
 
BEGIN
IF  c = bsp_c20
THEN
    i := 0
ELSE
    BEGIN
    i := mxsp_c20;
    WHILE (i > 1) AND (c [i] = ' ') DO
        i := i - 1
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
u05len20 := i
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05msgheader (VAR term : tut_terminal; msg : tsp00_C20);
 
VAR
      len    : integer;
      offset : integer;
      i      : integer;
      str30  : tsp00_C30;
 
BEGIN
len    := u05len20 (msg);
offset := 5 + (20 - len) DIV 2;
str30  := bsp_c30;
FOR i := 1 TO len DO
    str30 [offset + i] := msg [i];
(*ENDFOR*) 
t09msgheader (term, str30, c_perm)
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05nameto_packet (n : tsp00_Name;
            snd_packet    : tsp1_packet_ptr);
 
VAR
      len : integer;
 
BEGIN
len := u05len (n);
IF  len > 0
THEN
    WITH snd_packet^.sp1_segm DO
        BEGIN
        IF  sp1p_buf_len > 0
        THEN
            ut05char_to_packet (' ', snd_packet);
        (*ENDIF*) 
        SAPDB_PascalForcedMove (sizeof (n), sp1p_buf_size, @n, 1,
              @sp1p_buf, sp1p_buf_len + 1,
              len);
        sp1p_buf_len := sp1p_buf_len + len
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05packet_init (snd_packet : tsp1_packet_ptr);
 
VAR
      first_segm_ptr : tsp1_segment_ptr;
      first_part_ptr : tsp1_part_ptr;
 
BEGIN
s26init_cmd_packet (snd_packet, first_segm_ptr);
s26new_part_init (snd_packet, first_segm_ptr^, first_part_ptr);
WITH snd_packet^.sp1_header DO
    u03application (sp1h_appl_version, sp1h_application);
(*ENDWITH*) 
WITH first_segm_ptr^ DO
    BEGIN
    sp1c_mess_type := sp1m_utility;
    sp1c_producer  := sp1pr_internal_cmd
    END;
(*ENDWITH*) 
WITH first_part_ptr^ DO
    sp1p_part_kind := sp1pk_command
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05param_errmsg (VAR term : tut_terminal;
            VAR protfile        : tut_vf_fileref;
            rcv_packet          : tsp1_packet_ptr);
 
VAR
      err    : integer;
      ln_len : integer;
      pos    : integer;
      ln     : tsp00_Line;
 
BEGIN
WITH rcv_packet^.sp1_segm DO
    BEGIN
    u03geterrormsg (sp1r_returncode, ln);
    ln_len := sizeof (ln);
    WHILE (ln_len > 1) AND (ln [ln_len] = ' ') DO
        ln_len := ln_len - 1;
    (*ENDWHILE*) 
    IF  sp1s_segm_len - sizeof (sp1s_segm_header)
        - sizeof (sp1p_part_header) > 0
    THEN
        BEGIN
        pos := 1;
        WHILE (pos < sp1p_buf_len) AND (sp1p_buf [pos] <> ',') DO
            pos := pos + 1;
        (*ENDWHILE*) 
        pos := pos + 1; (* skip ',' *)
        IF  (pos < sp1p_buf_len) AND (ln_len < sizeof (ln))
        THEN
            BEGIN
            ln [ln_len+1] := ':';
            ln_len := ln_len + 2;
            WHILE (pos <= sp1p_buf_len) AND (ln_len < sizeof (ln)) DO
                BEGIN
                ln [ln_len+1] := sp1p_buf [pos];
                pos    := pos    + 1;
                ln_len := ln_len + 1
                END
            (*ENDWHILE*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
t09putmsg (term, ln, c_warning, NOT c_immediate_displ);
t12write_prot (protfile, ln, ln_len, err)
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05request_errmsg (VAR term : tut_terminal;
            VAR protfile : tut_vf_fileref;
            VAR errtext  : tsp00_ErrText;
            comm_error   : tsp1_comm_error);
 
VAR
      err         : integer;
      i           : integer;
      ln_len      : integer;
      return_code : integer;
      ln          : tsp00_Line;
 
BEGIN
CASE comm_error OF
    sp1ce_ok:
        return_code := 0;
    sp1ce_notok:
        return_code := -8888;
    sp1ce_tasklimit:
        return_code := -8026;
    sp1ce_timeout:
        return_code :=   700;
    sp1ce_crash:
        return_code := -8888;
    sp1ce_start_required:
        return_code := -8888;
    sp1ce_shutdown:
        return_code := -8888;
    OTHERWISE
        return_code := -8888
    END;
(*ENDCASE*) 
IF  return_code <> 0
THEN
    BEGIN
    t09returncode_set (term, return_code);
    u03geterrormsg    (return_code, ln);
    IF  errtext <> bsp_c40
    THEN
        BEGIN
        ln_len := LINE_MXSP00;
        WHILE (ln_len > 1) AND (ln [ln_len] = ' ') DO
            ln_len := ln_len - 1;
        (*ENDWHILE*) 
        ln_len        := ln_len + 2;
        ln [ln_len-1] := ',';
        i := 1;
        WHILE (i <= ERRTEXT_MXSP00) AND (ln_len < LINE_MXSP00) DO
            BEGIN
            ln_len      := ln_len + 1;
            ln [ln_len] := errtext [i];
            i           := i + 1
            END
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    t09putmsg         (term, ln, c_warning, NOT c_immediate_displ);
    t12write_prot     (protfile, ln, 77, err)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05get_block_addr (
            VAR term            : tut_terminal;
            VAR protfile        : tut_vf_fileref;
            rcv_packet          : tsp1_packet_ptr;
            VAR pfkey           : tut_pfkey);
 
VAR
      ln_len          : integer;
      len             : integer;
      dest_len        : integer;
      currColumn      : integer;
      columnCount     : integer;
      i               : integer;
      curr_descr_pos  : integer;
      curr_param_pos  : integer;
      curr_value_pos  : integer;
      ln              : tsp00_Line;
      err             : tsp00_NumError;
      colname_ptr     : tsp1_part_ptr;
      param_info_ptr  : tsp1_part_ptr;
      datapart_ptr    : tsp1_part_ptr;
      curr_param_info : tsp1_param_info;
 
BEGIN
s26find_part (rcv_packet^.sp1_segm, sp1pk_columnnames, colname_ptr);
s26find_part (rcv_packet^.sp1_segm, sp1pk_shortinfo,   param_info_ptr);
s26find_part (rcv_packet^.sp1_segm, sp1pk_data,        datapart_ptr);
(* *)
dest_len       := 1;
currColumn     := 1;
columnCount    := colname_ptr^.sp1p_arg_count;
curr_descr_pos := 1;
curr_param_pos := 1;
curr_value_pos := 1;
WHILE (pfkey = pf_none) AND (currColumn <= columnCount) DO
    BEGIN
    ln     := term.blankline;
    ln_len := 1;
    WITH colname_ptr^ DO
        BEGIN
        len := ord (sp1p_buf [curr_descr_pos]);
        SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (ln),
              @sp1p_buf, curr_descr_pos + 1, @ln, ln_len, len);
        curr_descr_pos := curr_descr_pos + 1 + len;
        ln_len         := ln_len + len;
        ln[ ln_len ]   := ':';
        ln_len         := ln_len + 1;
        END;
    (*ENDWITH*) 
    WITH param_info_ptr^ DO
        SAPDB_PascalForcedMove (sp1p_buf_size, sizeof (curr_param_info),
              @sp1p_buf, curr_param_pos, @curr_param_info, 1, sizeof (curr_param_info));
    (*ENDWITH*) 
    curr_param_pos := curr_param_pos + sizeof (curr_param_info);
    WITH curr_param_info DO
        s42gstr (datapart_ptr^.sp1p_buf,
              sp1i_bufpos + 1, sp1i_bufpos -1 + sp1i_in_out_len,
              sp1i_frac, sp1i_length, ln, ln_len+1, dest_len, err);
    (*ENDWITH*) 
    (* *)
    IF  err = num_ok
    THEN
        BEGIN
        t09put (term, term.blankline, cut_protected);
        t09put (term, ln, cut_bright_protected);
        (* *)
        t12write_prot (protfile, term.blankline, 1, i);
        t12write_prot (protfile, ln, ln_len + dest_len, i);
        (* *)
        IF  pfkey <> pf_cancel
        THEN
            pfkey := pf_none;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    currColumn := currColumn + 1;
    END;
(*ENDWHILE*) 
IF  (pfkey = pf_none) AND (err = num_ok)
THEN
    t09holding (term, pfkey);
(*ENDIF*) 
IF  pfkey in [pf_end, pf_help]
THEN
    pfkey := pf_none;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05sqlexec_errmsg (VAR term : tut_terminal;
            VAR protfile : tut_vf_fileref;
            VAR errtext  : tsp00_ErrText;
            retcode      : tsp00_Int2);
 
VAR
      i      : integer;
      offset : integer;
      rem    : tsp00_Int4;
      number : tsp00_C10;
      n      : tsp00_Sname;
      ln     : tsp00_Line;
 
BEGIN
ln := term.blankline;
IF  retcode <> 0
THEN
    BEGIN
    ln [1] := '*';
    ln [2] := '*';
    ln [3] := '*';
    offset  := 4
    END
ELSE
    offset := 0;
(*ENDIF*) 
n := 'RETURN CODE ';
FOR i := 1 TO 11 DO
    ln [offset+i] := n [i];
(*ENDFOR*) 
offset := offset + 12;
IF  retcode = 0
THEN
    BEGIN
    ln [offset+1] := '0';
    offset := offset + 1
    END
ELSE
    BEGIN
    IF  retcode < 0
    THEN
        BEGIN
        ln [offset+1] := '-';
        offset := offset + 1;
        rem    := - retcode
        END
    ELSE
        rem := retcode;
    (*ENDIF*) 
    i := 10;
    WHILE (i >= 1) AND (rem > 0) DO
        BEGIN
        number [i] := chr((rem MOD 10) + ord('0'));
        rem := rem DIV 10;
        i   := i - 1
        END;
    (*ENDWHILE*) 
    rem := i;
    FOR i := rem + 1 TO 10 DO
        ln [offset + i - rem] := number [i];
    (*ENDFOR*) 
    offset := offset + 10 - rem
    END;
(*ENDIF*) 
IF  (retcode <> 0) AND (errtext <> bsp_c40)
THEN
    BEGIN
    offset      := offset + 1;
    ln [offset] := ':';
    offset      := offset + 1;
    FOR i := 1 TO 40 DO
        ln [offset+i] := errtext [i]
    (*ENDFOR*) 
    END;
(*ENDIF*) 
t09returncode_set (term, retcode);
t09putmsg (term, ln, (retcode <> 0), NOT c_immediate_displ);
IF  retcode <> 0
THEN
    t12write_prot (protfile, ln, 77, i)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05str20_to_line (comment : tsp00_C20;
            VAR commentline     : tsp00_Line);
 
VAR
      i : integer;
 
BEGIN
FOR i := 1 TO 20 DO
    commentline [i]  := comment [i] ;
(*ENDFOR*) 
FOR i := 21 TO LINE_MXSP00 DO
    commentline [i]  := ' '
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05switch (VAR term   : tut_terminal;
            VAR protfile    : tut_vf_fileref;
            snd_packet      : tsp1_packet_ptr;
            VAR sql_ref     : tsp00_Int4;
            switch_cmd      : tsp00_C20;
            VAR pfkey       : tut_pfkey;
            VAR sql_retcode : tsp00_Int2);
 
CONST
      x_switch        =   1;
      x_switchlimit   =   3;
      x_buflimit      =   5;
      x_minbuf        =   6;
      x_maxbuf        =   8;
      x_return        =  10;
      (**)
      x_trace         =   1;
      x_debug         =   2;
      x_topic_debug   =   3;
      x_start_name    =   4;
      x_start_cnt     =   5;
      x_stop_name     =   6;
      trace_test_size =  20;
      trace_name_size =  16;
 
VAR
      is_ok      : boolean;
      is_help    : boolean;
      i          : integer;
      count      : integer;
      err        : integer;
      ln_len     : integer;
      mask_size  : integer;
      selected   : integer;
      int4_param : tsp00_Int4;
      rcv_packet : tsp1_packet_ptr;
      int_name   : tsp00_Name;
      n          : tsp00_Name;
      ln         : tsp00_Line;
      msg        : tut_c20_array;
      mask       : tut_term_mask;
 
BEGIN
sql_retcode := 0;
FOR selected := 1 TO x_return DO
    msg [selected] := bsp_c20;
(*ENDFOR*) 
msg [x_switch     ] := 'SWITCH              ';
msg [x_switchlimit] := 'SWITCHLIMIT         ';
msg [x_buflimit   ] := 'BUFLIMIT            ';
msg [x_minbuf     ] := 'MINBUF              ';
msg [x_maxbuf     ] := 'MAXBUF              ';
msg [x_return     ] := msg_return;
REPEAT
    pfkey := pf_none;
    u05packet_init (snd_packet);
    u05msgheader (term, msg_diag_switch);
    IF  switch_cmd = bsp_c20
    THEN
        t09menu (term, x_return, cut_protected, msg, selected, pfkey)
    ELSE
        BEGIN
        selected := 0;
        i        := 1;
        WHILE (selected = 0) AND (i < x_return) DO
            IF  msg [i] = switch_cmd
            THEN
                selected := i
            ELSE
                i := i + 1;
            (*ENDIF*) 
        (*ENDWHILE*) 
        IF  selected = 0
        THEN
            selected := x_return
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  pfkey = pf_end
    THEN
        selected := x_return
    ELSE
        IF  pfkey <> pf_none
        THEN
            selected := 0
        ELSE
            IF  selected = x_return
            THEN
                pfkey := pf_end;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  selected in [x_switch, x_switchlimit]
    THEN
        BEGIN
        IF  selected = x_switch
        THEN
            BEGIN
            snd_packet^.sp1_segm.sp1c_mess_type := sp1m_switch;
            mask_size := x_topic_debug
            END
        ELSE
            BEGIN
            snd_packet^.sp1_segm.sp1c_mess_type := sp1m_switchlimit;
            mask_size := x_stop_name
            END;
        (*ENDIF*) 
        FOR i := 1 TO mask_size DO
            WITH mask [i] DO
                BEGIN
                msg_in_attr [c_msg] := cut_protected;
                msg_in_attr [c_in ] := cut_bright_unprotected;
                upper_case := true;
                code_input := false;
                in_len     := NAME_MXSP00;
                in_name    := bsp_name
                END;
            (*ENDWITH*) 
        (*ENDFOR*) 
        mask [x_trace     ].msg        := 'TRACE LAYERS        ';
        mask [x_debug     ].msg        := 'DEBUGGING           ';
        mask [x_topic_debug ].msg      := 'TOPIC               ';
        mask [x_start_name].msg        := 'START TRACE         ';
        mask [x_start_name].in_name    := 'XX99  xxxxxxxxxx  ';
        mask [x_start_name].in_len     := 16;
        mask [x_start_name].upper_case := false;
        mask [x_start_cnt ].msg        := 'COUNT START TRACE   ';
        mask [x_start_cnt ].in_name    := '1                 ';
        mask [x_start_cnt ].in_len     := int2_length;
        mask [x_stop_name ].msg        := 'STOP  TRACE / TDSTOP';
        mask [x_stop_name ].in_name    := mask [3].in_name;
        mask [x_stop_name ].in_len     := 16;
        mask [x_stop_name ].upper_case := false;
        count   := 0;
        is_ok   := false;
        is_help := false;
        u05msgheader (term, msg [selected]);
        t09setpf1 (term, cut_pfkey_help);
        REPEAT
            IF  NOT is_help
            THEN
                BEGIN
                count := count + 1;
                t09newscreen_page (term)
                END;
            (*ENDIF*) 
            t09mask (term, mask_size, mask_size, mask,
                  NOT c_return_pfkey, pfkey);
            is_help := false;
            IF  (pfkey = pf_help)
                OR
                ((pfkey = pf_none) AND
                ((mask[x_trace].in_name [1] = '?') OR
                ( mask[x_debug].in_name [1] = '?')))
            THEN
                BEGIN
                ut05help_switch (term);
                is_help         := true;
                pfkey           := pf_none;
                mask[x_trace].in_name := bsp_name;
                mask[x_debug].in_name := bsp_name
                END
            ELSE
                IF  (pfkey = pf_none) AND (selected = x_switchlimit)
                THEN
                    BEGIN
                    u05intformat (mask [x_start_cnt].in_name, int2_length,
                          MAX_INT2_SP00, int_name, is_ok);
                    IF  is_ok
                    THEN
                        BEGIN
                        mask [x_start_cnt].in_name := int_name;
                        ln := term.blankline;
                        FOR i := 1 TO int2_length DO
                            ln [i] := int_name [i];
                        (*ENDFOR*) 
                        t14int4from_line (term, ln, 1, int2_length,
                              int4_param, is_ok)
                        END;
                    (*ENDIF*) 
                    IF  NOT is_ok
                    THEN
                        BEGIN
                        u05illegal_input_errmsg (term, protfile,
                              NOT c_write_prot, mask [x_start_cnt].msg);
                        mask [x_start_cnt].msg_in_attr [c_msg] :=
                              cut_bright_protected
                        END
                    (*ENDIF*) 
                    END
                ELSE
                    is_ok := true
                (*ENDIF*) 
            (*ENDIF*) 
        UNTIL
            (pfkey <> pf_none) OR is_ok OR (count > 3);
        (*ENDREPEAT*) 
        t09setpf1 (term, cut_pfkey_none);
        IF  NOT is_ok AND (pfkey = pf_none)
        THEN
            pfkey := pf_end;
        (*ENDIF*) 
        IF  pfkey = pf_none
        THEN
            BEGIN
            IF  switch_cmd = bsp_c20
            THEN
                BEGIN
                ln := term.blankline;
                SAPDB_PascalForcedMove (sizeof (msg [selected]), sizeof (ln),
                      @msg [selected], 1, @ln, 1,
                      sizeof (msg [selected]));
                t12write_prot (protfile, term.blankline, 1, err);
                t12write_prot (protfile, ln, mxsp_c20, err)
                END;
            (*ENDIF*) 
            FOR i := 1 TO mask_size DO
                BEGIN
                ln     := term.blankline;
                ln_len := 0;
                g17nameto_line (mask [i].in_name, ln_len, ln);
                t12write_prot (protfile, ln, mxsp_c20, err)
                END;
            (*ENDFOR*) 
            FOR count := 1 TO x_topic_debug DO
                WITH snd_packet^.sp1_segm DO
                    BEGIN
                    SAPDB_PascalForcedMove (sizeof (mask [count].in_name),
                          sp1p_buf_size,
                          @mask [count].in_name, 1,
                          @sp1p_buf, sp1p_buf_len + 1,
                          sizeof (mask [count].in_name));
                    FOR i := NAME_MXSP00 + 1 TO trace_test_size DO
                        sp1p_buf [sp1p_buf_len+i] := ' ';
                    (*ENDFOR*) 
                    sp1p_buf_len := sp1p_buf_len + trace_test_size
                    END;
                (*ENDWITH*) 
            (*ENDFOR*) 
            IF  selected = x_switchlimit
            THEN
                WITH snd_packet^.sp1_segm DO
                    BEGIN
                    SAPDB_PascalForcedMove (sizeof (mask [x_start_name].in_name), sp1p_buf_size,
                          @mask [x_start_name].in_name, 1,
                          @sp1p_buf, sp1p_buf_len + 1,
                          trace_name_size);
                    sp1p_buf_len := sp1p_buf_len + trace_name_size;
                    SAPDB_PascalForcedMove (sizeof (mask [x_stop_name].in_name), sp1p_buf_size,
                          @mask [x_stop_name].in_name, 1,
                          @sp1p_buf, sp1p_buf_len + 1,
                          trace_name_size);
                    sp1p_buf_len := sp1p_buf_len + trace_name_size;
                    sp1p_buf [sp1p_buf_len+1] :=
                          chr (int4_param DIV 256);
                    sp1p_buf [sp1p_buf_len+2] :=
                          chr (int4_param MOD 256);
                    sp1p_buf_len := sp1p_buf_len + 2
                    END
                (*ENDWITH*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  selected = x_buflimit
    THEN
        BEGIN
        snd_packet^.sp1_segm.sp1c_mess_type := sp1m_buflength;
        n     := '60                ';
        count := 0;
        is_ok := false;
        REPEAT
            count := count + 1;
            t09newscreen_page (term);
            u05msgheader (term, msg [selected]);
            t09get1name  (term, msg_buf_len, cut_protected,
                  cut_bright_unprotected, int2_length,
                  c_upper_case, n, pfkey);
            IF  pfkey = pf_none
            THEN
                BEGIN
                u05intformat (n, int2_length, MAX_INT2_SP00,
                      int_name, is_ok);
                IF  is_ok
                THEN
                    BEGIN
                    n  := int_name;
                    ln := term.blankline;
                    FOR i := 1 TO int2_length DO
                        ln [i] := int_name [i];
                    (*ENDFOR*) 
                    t14int4from_line (term, ln, 1, int2_length,
                          int4_param, is_ok)
                    END;
                (*ENDIF*) 
                IF  is_ok
                THEN
                    is_ok := ((int4_param <= sizeof(tsp00_MoveObj))
                          AND (int4_param >= 1));
                (*ENDIF*) 
                IF  NOT is_ok
                THEN
                    u05illegal_input_errmsg (term, protfile,
                          NOT c_write_prot, msg_buf_len)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            (pfkey <> pf_none) OR is_ok OR (count > 3);
        (*ENDREPEAT*) 
        IF  NOT is_ok AND (pfkey = pf_none)
        THEN
            pfkey := pf_end;
        (*ENDIF*) 
        IF  pfkey = pf_none
        THEN
            BEGIN
            IF  switch_cmd = bsp_c20
            THEN
                BEGIN
                ln := term.blankline;
                SAPDB_PascalForcedMove (sizeof (msg [selected]), sizeof (ln),
                      @msg [selected], 1, @ln, 1, sizeof (msg[selected]));
                t12write_prot (protfile, term.blankline, 1, err);
                t12write_prot (protfile, ln, mxsp_c20, err)
                END;
            (*ENDIF*) 
            ln     := term.blankline;
            ln_len := 0;
            g17nameto_line (n, ln_len, ln);
            t12write_prot (protfile, ln, mxsp_c20, err);
            ut05char_to_packet (chr (int4_param DIV 256), snd_packet);
            ut05char_to_packet (chr (int4_param MOD 256), snd_packet)
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (selected = x_minbuf) OR (selected = x_maxbuf)
    THEN
        BEGIN
        ln := term.blankline;
        SAPDB_PascalForcedMove (sizeof (msg [selected]), sizeof (ln),
              @msg [selected], 1,
              @ln, 1, sizeof (msg [selected]));
        t09putmsg (term, ln, NOT c_warning, NOT c_immediate_displ);
        IF  switch_cmd = bsp_c20
        THEN
            BEGIN
            t12write_prot (protfile, term.blankline, 1, err);
            t12write_prot (protfile, ln, mxsp_c20, err)
            END;
        (*ENDIF*) 
        IF  selected = x_minbuf
        THEN
            snd_packet^.sp1_segm.sp1c_mess_type := sp1m_minbuf
        ELSE
            snd_packet^.sp1_segm.sp1c_mess_type := sp1m_maxbuf
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  pfkey = pf_none
    THEN
        BEGIN
        s26finish_part (snd_packet, snd_packet^.sp1_segm.sp1p_part);
        u02send (term, protfile, snd_packet, sql_ref,
              display_msg, NOT c_req_only, rcv_packet, sql_retcode)
        END
    (*ENDIF*) 
UNTIL
    (selected = x_return)
    OR (pfkey = pf_cancel)
    OR (sql_retcode <> 0)
    OR (switch_cmd  <> bsp_c20)
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05username_to_packet (VAR n : tsp00_KnlIdentifier;
            snd_packet : tsp1_packet_ptr);
 
VAR
      is_special : boolean;
      i          : integer;
      len        : integer;
 
BEGIN
len := sizeof (n);
WHILE (n [len] = ' ') AND (len > 1) DO
    len := len - 1;
(*ENDWHILE*) 
IF  len > 0
THEN
    BEGIN
    is_special := NOT (n [1] in ['A'..'I', 'J'..'R', 'S' ..'Z',
          c_at_sign, c_dollar, c_hash]);
    i := 2;
    WHILE NOT is_special AND (i <= len) DO
        IF  NOT (n [i] in ['A'..'I', 'J'..'R', 'S' ..'Z', '0'..'9',
            c_at_sign, c_dollar, c_hash])
        THEN
            is_special := true
        ELSE
            i := i + 1;
        (*ENDIF*) 
    (*ENDWHILE*) 
    WITH snd_packet^.sp1_segm DO
        BEGIN
        IF  sp1p_buf_len > 0
        THEN
            ut05char_to_packet (' ', snd_packet);
        (*ENDIF*) 
        IF  is_special
        THEN
            ut05char_to_packet (c_double_quote, snd_packet);
        (*ENDIF*) 
        SAPDB_PascalForcedMove (sizeof (n), sp1p_buf_size, @n, 1,
              @sp1p_buf, sp1p_buf_len + 1, len);
        sp1p_buf_len := sp1p_buf_len + len;
        IF  is_special
        THEN
            ut05char_to_packet (c_double_quote, snd_packet)
        (*ENDIF*) 
        END
    (*ENDWITH*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05usewrite_prot (VAR protfile : tut_vf_fileref;
            VAR blankln    : tsp00_Line;
            VAR serverdb   : tsp00_DbName;
            VAR servernode : tsp00_NodeId);
 
VAR
      ln_len    : integer;
      dummy_err : integer;
      ln        : tsp00_Line;
 
BEGIN
ln     := blankln;
ln_len := 0;
g17nameto_line (utn_use, ln_len, ln);
ln_len := ln_len + 1;
g17nameto_line (utn_serverdb, ln_len, ln);
ln_len      := ln_len + 2;
ln [ln_len] := string_delimiter;
SAPDB_PascalForcedMove (sizeof (serverdb), sizeof (ln), @serverdb, 1,
      @ln, ln_len+1, sizeof (serverdb));
ln_len      := s30lnr1 (ln, ' ', 1, ln_len + sizeof (serverdb)) + 1;
ln [ln_len] := string_delimiter;
IF  servernode <> bsp_nodeid
THEN
    BEGIN
    ln_len := ln_len + 1;
    g17nameto_line (utn_on, ln_len, ln);
    ln_len      := ln_len + 2;
    ln [ln_len] := string_delimiter;
    SAPDB_PascalForcedMove (sizeof (servernode), sizeof (ln),
          @servernode, 1, @ln, ln_len+1,
          sizeof (servernode));
    ln_len := s30lnr1 (ln, ' ', 1, ln_len + sizeof (servernode)) + 1;
    ln [ln_len] := string_delimiter
    END;
(*ENDIF*) 
t12write_prot (protfile, blankln, 1, dummy_err);
t12write_prot (protfile, ln, ln_len, dummy_err)
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05vfnto_packet (VAR n : tsp00_VFilename;
            snd_packet       : tsp1_packet_ptr);
 
VAR
      len : integer;
 
BEGIN
len := sizeof(tsp00_VFilename);
WHILE (len > 1) AND (n [len] = ' ') DO
    len := len - 1;
(*ENDWHILE*) 
IF  (len = 1) AND (n [len] = ' ')
THEN
    len := 0;
(*ENDIF*) 
IF  len > 0
THEN
    WITH snd_packet^.sp1_segm DO
        BEGIN
        ut05char_to_packet (' ',              snd_packet);
        ut05char_to_packet (string_delimiter, snd_packet);
        SAPDB_PascalForcedMove (sizeof (n), sp1p_buf_size, @n, 1,
              @sp1p_buf, sp1p_buf_len + 1,
              len);
        sp1p_buf_len := sp1p_buf_len + len;
        ut05char_to_packet (string_delimiter, snd_packet)
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      u05write_prot (VAR term : tut_terminal;
            VAR protfile : tut_vf_fileref;
            n            : tsp00_Name;
            int          : tsp00_Int4);
 
VAR
      err    : integer;
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
ln     := term.blankline;
ln_len := 0;
g17nameto_line ('+++               ', ln_len, ln);
ln_len := ln_len + 1;
g17nameto_line (n, ln_len, ln);
ln_len := ln_len + 1;
g17trimint4_to_line (int, ln_len, ln);
t12write_prot (protfile, ln, ln_len, err)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut05char_to_packet (c : char;
            VAR snd_packet  : tsp1_packet_ptr);
 
BEGIN
WITH snd_packet^.sp1_segm DO
    BEGIN
    sp1p_buf_len            := sp1p_buf_len + 1;
    sp1p_buf [sp1p_buf_len] := c
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut05diag_block_address(
            VAR term   : tut_terminal;
            msg        : tsp00_C20;
            obj_name   : tsp00_Name;
            snd_packet : tsp1_packet_ptr;
            VAR pfkey  : tut_pfkey;
            VAR is_ok  : boolean);
 
VAR
      pageNo : tsp00_Name;
 
BEGIN
pfkey  := pf_none;
pageNo := first_loc;
t09newscreen_page (term);
ut05name_msg_header (term, utn_get_block);
t09get1name (term, msg, cut_bright_protected,
      cut_unprotected, int4_length, c_upper_case, pageNo, pfkey);
IF  pfkey = pf_none
THEN
    BEGIN
    is_ok := true;
    u05packet_init   (snd_packet);
    u05nameto_packet (utn_diagnose,  snd_packet);
    u05nameto_packet (utn_get_block, snd_packet);
    u05nameto_packet (utn_for,       snd_packet);
    u05nameto_packet (obj_name,      snd_packet);
    u05nameto_packet (utn_page,      snd_packet);
    u05nameto_packet (pageNo,        snd_packet);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut05diag_full_dump (VAR term : tut_terminal;
            snd_packet : tsp1_packet_ptr;
            VAR pfkey  : tut_pfkey);
 
CONST
      x_hostfn = 1;
 
VAR
      mask : tut_term_mask;
 
BEGIN
pfkey := pf_none;
u05packet_init    (snd_packet);
u05nameto_packet  (utn_diagnose, snd_packet);
u05nameto_packet  (utn_data,     snd_packet);
u05nameto_packet  (utn_to,       snd_packet);
t09newscreen_page (term);
u05msgheader      (term, msg_dump_full);
mask [x_hostfn].msg_in_attr [c_msg] := cut_protected;
mask [x_hostfn].msg_in_attr [c_in ] := cut_bright_unprotected;
mask [x_hostfn].upper_case          := false;
mask [x_hostfn].code_input          := false;
mask [x_hostfn].in_len              := DEVNAME_MXSP00;
mask [x_hostfn].in_name             := bsp_name;
mask [x_hostfn].in_c256             := term.blankfilename;
mask [x_hostfn].msg                 := msg_hostfn;
t09mask (term, 0, x_hostfn, mask, NOT c_return_pfkey, pfkey);
IF  pfkey = pf_none
THEN
    u05c256to_packet (mask [x_hostfn].in_c256, snd_packet)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut05diag_oms_vtrace (VAR term : tut_terminal;
            snd_packet : tsp1_packet_ptr;
            VAR pfkey  : tut_pfkey);
 
CONST
      x_object         =  1;
      x_space1         =  3;
      x_space2         =  5;
      x_space3         =  7;
      (**)
      x_OmsNew         =  2;
      x_OmsUpd         =  4;
      x_OmsFree        =  6;
      x_OmsGet         =  8;
      (* *)
      mask_size        = x_OmsGet;
 
VAR
      is_ok      : boolean;
      i          : integer;
      count      : integer;
      dummy_prot : tut_vf_fileref;
      mask       : tut_term_mask;
 
BEGIN
pfkey := pf_none;
FOR i := 1 TO mask_size DO
    WITH mask [i] DO
        BEGIN
        msg        := bsp_c20;
        in_name    := 'N                 ';
        in_len     := mx_yes_no;
        upper_case := true;
        code_input := false;
        msg_in_attr [c_msg] := cut_protected;
        msg_in_attr [c_in ] := cut_unprotected
        END;
    (*ENDWITH*) 
(*ENDFOR*) 
mask [x_object ].msg := msg_vtr_object;
mask [x_OmsNew ].msg := msg_vtr_OmsNew;
mask [x_OmsUpd ].msg := msg_vtr_OmsUpd;
mask [x_OmsFree].msg := msg_vtr_OmsFree;
mask [x_OmsGet ].msg := msg_vtr_OmsGet;
(* *)
mask [x_object ].in_name := 'Y                 ';
mask [x_space1 ].in_name := bsp_name;
mask [x_space2 ].in_name := bsp_name;
mask [x_space3 ].in_name := bsp_name;
(* *)
mask [x_space1 ].msg_in_attr [c_in ] := cut_protected;
mask [x_space2 ].msg_in_attr [c_in ] := cut_protected;
mask [x_space3 ].msg_in_attr [c_in ] := cut_protected;
count := 0;
REPEAT
    count := count + 1;
    t09newscreen_page (term);
    t09msgheader      (term, msg30_diag_vtrace, c_perm);
    t09mask           (term, mask_size, mask_size, mask, NOT c_return_pfkey, pfkey);
    is_ok := false;
    i     := 1;
    WHILE NOT is_ok AND (i <= mask_size) DO
        IF  mask[i].in_name[1] = 'Y'
        THEN
            is_ok := true
        ELSE
            i := i + 1;
        (*ENDIF*) 
    (*ENDWHILE*) 
    IF  NOT is_ok
    THEN
        u05illegal_input_errmsg (term, dummy_prot, NOT c_write_prot,
              'NO VTRACE SELECTED  ')
    (*ENDIF*) 
UNTIL
    (pfkey <> pf_none) OR is_ok OR (count >= 3);
(*ENDREPEAT*) 
IF  pfkey = pf_none
THEN
    BEGIN
    u05packet_init   (snd_packet);
    u05nameto_packet (utn_diagnose, snd_packet);
    u05nameto_packet (utn_vtrace,   snd_packet);
    FOR i := 1 TO mask_size DO
        IF  mask [i].in_name <> bsp_name
        THEN
            BEGIN
            IF  u05isyes (mask [i].in_name)
            THEN
                u05c20to_packet (mask [i].msg, snd_packet)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDFOR*) 
    u05nameto_packet (utn_on, snd_packet)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut05diag_partial_dump (VAR term : tut_terminal;
            snd_packet : tsp1_packet_ptr;
            VAR pfkey  : tut_pfkey);
 
CONST
      x_msg_contained =  1;
      x_space         =  2;
 
VAR
      is_ok      : boolean;
      i          : integer;
      count      : integer;
      mask_size  : integer;
      dummy_prot : tut_vf_fileref;
      mask       : tut_term_mask;
 
BEGIN
pfkey := pf_none;
FOR i := 1 TO 20 DO
    WITH mask [i] DO
        BEGIN
        msg                 := bsp_c20;
        in_c256             := term.blankfilename;
        in_len              := mx_yes_no;
        upper_case          := true;
        code_input          := false;
        msg_in_attr [c_msg] := cut_protected;
        msg_in_attr [c_in ] := cut_unprotected
        END;
    (*ENDWITH*) 
(*ENDFOR*) 
(* *)
mask [x_msg_contained].msg                 := 'contained in DUMP   ';
mask [x_msg_contained].msg_in_attr [c_msg] := cut_bright_protected;
mask [x_msg_contained].msg_in_attr [c_in ] := cut_protected;
mask [x_space        ].msg_in_attr [c_in ] := cut_protected;
mask_size := x_space + 1;
(* *)
mask [mask_size].msg := dpl_filedirectory;
mask_size            := mask_size + 1;
mask [mask_size].msg := dpl_configuration;
mask_size            := mask_size + 1;
mask [mask_size].msg := dpl_converter;
mask_size            := mask_size + 1;
mask [mask_size].msg := dpl_converter_cache;
mask_size            := mask_size + 1;
mask [mask_size].msg := dpl_data_cache;
mask_size            := mask_size + 1;
mask [mask_size].msg := dpl_data_writer;
mask_size            := mask_size + 1;
mask [mask_size].msg := dpl_fbm;
mask_size            := mask_size + 1;
mask [mask_size].msg := dpl_headmaster;
mask_size            := mask_size + 1;
mask [mask_size].msg := dpl_kb_locklist;
mask_size            := mask_size + 1;
mask [mask_size].msg := dpl_netserver;
mask_size            := mask_size + 1;
mask [mask_size].msg := dpl_restartrec;
mask_size            := mask_size + 1;
mask [mask_size].msg := dpl_garbagecollection;
mask_size            := mask_size + 1;
(* *)
mask [mask_size].msg_in_attr [c_in ] := cut_bright_unprotected;
mask [mask_size].code_input          := false;
mask [mask_size].upper_case          := false;
mask [mask_size].in_len              := sizeof (tsp00_VFilename);
mask [mask_size].msg                 := msg_hostfn;
(* *)
FOR i := x_space + 1 TO mask_size - 1 DO
    mask [i].in_name := no_answer;
(*ENDFOR*) 
count := 0;
REPEAT
    count := count + 1;
    t09newscreen_page (term);
    u05msgheader      (term, msg_dump_partial);
    t09mask_c256_n     (term, mask_size - 1, mask_size, mask,
          NOT c_return_pfkey, pfkey);
    is_ok := false;
    i     := x_space + 1;
    WHILE NOT is_ok AND (i < mask_size) DO
        IF  u05isyes (mask [i].in_name)
        THEN
            is_ok := true
        ELSE
            i := i + 1;
        (*ENDIF*) 
    (*ENDWHILE*) 
    IF  (NOT is_ok) AND (pfkey = pf_none)
    THEN
        u05illegal_input_errmsg (term, dummy_prot, NOT c_write_prot,
              'NO ITEM SELECTED    ')
    (*ENDIF*) 
UNTIL
    (pfkey <> pf_none) OR is_ok OR (count >= 3);
(*ENDREPEAT*) 
IF  pfkey = pf_none
THEN
    BEGIN
    u05packet_init    (snd_packet);
    u05nameto_packet  (utn_diagnose,            snd_packet);
    u05nameto_packet  (utn_data,                snd_packet);
    u05nameto_packet  (utn_to,                  snd_packet);
    u05c256to_packet   (mask [mask_size].in_c256, snd_packet);
    FOR i := x_space + 1 TO mask_size - 1 DO
        IF  u05isyes (mask [i].in_name)
        THEN
            u05c20to_packet (mask [i].msg, snd_packet)
        (*ENDIF*) 
    (*ENDFOR*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut05diag_session_vtrace (VAR term : tut_terminal;
            snd_packet : tsp1_packet_ptr;
            VAR pfkey  : tut_pfkey);
 
CONST
      c_all = '*                 ';
 
VAR
      is_ok     : boolean;
      count     : integer;
      ln_len    : integer;
      len       : integer;
      hex_n     : tsp00_Name;
      ln        : tsp00_Line;
      n         : tsp00_Name;
      msg       : tsp00_C20;
 
BEGIN
pfkey := pf_none;
t09newscreen_page (term);
u05msgheader      (term, msg_vtrace_session);
n     := c_all;
msg   := 'SESSION NO          ';
count := 0;
REPEAT
    is_ok   := true;
    count   := count + 1;
    u05packet_init   (snd_packet);
    u05nameto_packet (utn_diagnose, snd_packet);
    u05nameto_packet (utn_vtrace,   snd_packet);
    u05nameto_packet (utn_session,  snd_packet);
    t09get1name (term, msg , cut_protected, cut_bright_unprotected,
          int4_length, c_upper_case, n, pfkey);
    IF  pfkey = pf_none
    THEN
        BEGIN
        IF  n = c_all
        THEN
            u05nameto_packet (c_all, snd_packet)
        ELSE
            BEGIN
            ut05name_to_hex (term, n, msg, 4, hex_n, is_ok);
            IF  is_ok
            THEN
                u05nameto_packet (hex_n, snd_packet)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    (*ENDIF*) 
UNTIL
    (pfkey <> pf_none) OR (count >= 3) OR is_ok;
(*ENDREPEAT*) 
IF  is_ok AND (pfkey = pf_none)
THEN
    BEGIN
    ln     := term.blankline;
    ln_len := 0;
    g17nameto_line ('SELECTED:         ', ln_len, ln);
    ln_len := ln_len + 1;
    len := sizeof (msg);
    WHILE (len > 1) AND (msg[len] = ' ') DO
        len := len - 1;
    (*ENDWHILE*) 
    SAPDB_PascalForcedMove (sizeof (msg), sizeof (ln),
          @msg, 1, @ln, ln_len+1, len);
    ln_len := ln_len + len + 1;
    g17nameto_line (n, ln_len, ln);
    t09putmsg (term, ln, NOT c_warning, NOT c_immediate_displ)
    END;
(*ENDIF*) 
IF  (pfkey = pf_none) AND NOT is_ok
THEN
    pfkey := pf_end
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut05diag_vtrace (VAR term : tut_terminal;
            snd_packet : tsp1_packet_ptr;
            VAR pfkey  : tut_pfkey);
 
CONST
      x_default        =  1;
      x_space1         =  2;
      x_space2         =  3;
      x_space3         =  4;
      (* *)
      x_msg_in_default =  5;
      x_index          =  7;
      x_lock           =  9;
      x_orderst        = 11;
      x_pages          = 13;
      x_str            = 15;
      x_tab            = 17;
      x_check          = 19;
      (* *)
      x_msg_additional =  6;
      x_del            =  8;
      x_ins            = 10;
      x_optim          = 12;
      x_order          = 14;
      x_sel            = 16;
      x_time           = 18;
      x_upd            = 20;
      (* *)
      mask_size        = x_upd;
 
VAR
      is_ok      : boolean;
      i          : integer;
      count      : integer;
      dummy_prot : tut_vf_fileref;
      mask       : tut_term_mask;
 
BEGIN
pfkey := pf_none;
FOR i := 1 TO mask_size DO
    WITH mask [i] DO
        BEGIN
        msg        := bsp_c20;
        in_name    := no_answer;
        in_len     := mx_yes_no;
        upper_case := true;
        code_input := false;
        msg_in_attr [c_msg] := cut_protected;
        msg_in_attr [c_in ] := cut_unprotected
        END;
    (*ENDWITH*) 
(*ENDFOR*) 
mask [x_default].msg     := msg_vtr_default;
mask [x_default].in_name := 'Y                 ';
(* *)
mask [x_msg_in_default].msg := 'contained in DEFAULT';
mask [x_index         ].msg := msg_vtr_index;
mask [x_lock          ].msg := msg_vtr_lock;
mask [x_orderst       ].msg := msg_vtr_order_st;
mask [x_pages         ].msg := msg_vtr_pages;
mask [x_str           ].msg := msg_vtr_long;
mask [x_tab           ].msg := msg_vtr_table;
mask [x_check         ].msg := msg_vtr_check;
(* *)
mask [x_msg_additional].msg := 'additional VTRACE   ';
mask [x_del           ].msg := msg_vtr_delete;
mask [x_ins           ].msg := msg_vtr_insert;
mask [x_optim         ].msg := msg_vtr_optimize;
mask [x_order         ].msg := msg_vtr_order;
mask [x_sel           ].msg := msg_vtr_select;
mask [x_time          ].msg := msg_vtr_time;
mask [x_upd           ].msg := msg_vtr_update;
(* *)
mask [x_space1        ].in_name := bsp_name;
mask [x_space2        ].in_name := bsp_name;
mask [x_space3        ].in_name := bsp_name;
mask [x_msg_in_default].in_name := bsp_name;
mask [x_msg_additional].in_name := bsp_name;
(* *)
mask [x_default].msg_in_attr [c_msg] := cut_bright_protected;
mask [x_default].msg_in_attr [c_in ] := cut_bright_unprotected;
mask [x_space1 ].msg_in_attr [c_in ] := cut_protected;
mask [x_space2 ].msg_in_attr [c_in ] := cut_protected;
mask [x_space3 ].msg_in_attr [c_in ] := cut_protected;
(* *)
mask [x_msg_in_default].msg_in_attr [c_msg] := cut_bright_protected;
mask [x_msg_in_default].msg_in_attr [c_in ] := cut_protected;
mask [x_msg_additional].msg_in_attr [c_msg] := cut_bright_protected;
mask [x_msg_additional].msg_in_attr [c_in ] := cut_protected;
(* *)
count := 0;
REPEAT
    count := count + 1;
    t09newscreen_page (term);
    t09msgheader      (term, msg30_diag_vtrace, c_perm);
    t09mask           (term, mask_size, mask_size, mask,
          NOT c_return_pfkey, pfkey);
    is_ok := false;
    i     := 1;
    WHILE NOT is_ok AND (i <= mask_size) DO
        IF  mask[i].in_name[1] = 'Y'
        THEN
            is_ok := true
        ELSE
            i := i + 1;
        (*ENDIF*) 
    (*ENDWHILE*) 
    IF  NOT is_ok
    THEN
        u05illegal_input_errmsg (term, dummy_prot, NOT c_write_prot,
              'NO VTRACE SELECTED  ')
    (*ENDIF*) 
UNTIL
    (pfkey <> pf_none) OR is_ok OR (count >= 3);
(*ENDREPEAT*) 
IF  pfkey = pf_none
THEN
    BEGIN
    u05packet_init   (snd_packet);
    u05nameto_packet (utn_diagnose, snd_packet);
    u05nameto_packet (utn_vtrace,   snd_packet);
    FOR i := x_default TO mask_size DO
        IF  mask [i].in_name <> bsp_name
        THEN
            BEGIN
            IF  u05isyes (mask [i].in_name)
            THEN
                u05c20to_packet (mask [i].msg, snd_packet)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDFOR*) 
    u05nameto_packet (utn_on, snd_packet)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut05help_switch (VAR term : tut_terminal);
 
VAR
      i : integer;
      s : ARRAY [1..17] OF tsp00_C60;
 
BEGIN
s[ 1]:='AK debugging       | BD debugging      | KB debugging       ';
s[ 2]:='-------------------+-------------------+--------------------';
s[ 3]:='AK  ak; not AI, AJ | BD  bd; not BI    | KB  kb; not KE     ';
s[ 4]:='AC  ak_cache       | BB  bd_buf        | KD  kb_dist        ';
s[ 5]:='AI  ak_isolev      | BY  bd_byte       | KF  kb_funct       ';
s[ 6]:='AJ  ak_join        | BX  bd_index      | KL  kb_lock        ';
s[ 7]:='AS  ak_sem         | BV  bd_inv        | KE  kb_lockentry   ';
s[ 8]:='AT  ak_strat       | BO  bd_io         | KV  kb_save        ';
s[ 9]:='AY  ak_syn         | BQ  bd_ioqueue    | KN  kb_dist        ';
s[10]:='                   | BM  bd_keym       | KQ  kb_qual        ';
s[11]:='FH  fs_ak          | BL  bd_lock       | KS  kb_sel         ';
s[12]:='TP  test_ak        | BF  bd_oflw       |                    ';
s[13]:='                   | BP  bd_psm        |                    ';
s[14]:='                   | BT  bd_tbuf       | FL  fs_kb          ';
s[15]:='TB test_bd         | BI  <bd interface>| TK  test_kb        ';
s[16]:='stored procedures: PR, PI sproc, PC sproc_call, PS sproc_sql';
s[17]:='other functions  : GG, ST st_stack, UC unicode              ';
(* *)
t09newscreen_page (term);
FOR i := 1 TO 17 DO
    t09put60 (term, s [i], cut_protected)
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut05hexbyte_to_name (c : char;
            pos   : integer;
            VAR n : tsp00_Name);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
ln_len := 0;
g17hexto_line (c, ln_len, ln);
n [pos  ] := ln [1];
n [pos+1] := ln [2]
END;
 
(*------------------------------*) 
 

 
(*------------------------------*) 
 
FUNCTION
      ut05is_serverdb_upper (VAR init_db : tsp00_DbName): boolean;
 
VAR
      os       : tsp00_Os;
      is_upper : boolean;
      i        : integer;
 
BEGIN
sqlos (os);
is_upper := (os = os_vms);
IF  is_upper
THEN
    BEGIN
    i := 1;
    WHILE (i <= DBNAME_MXSP00) AND is_upper DO
        IF  init_db [i] in ['a'..'i', 'j'..'r',  's'..'z']
        THEN
            is_upper := false
        ELSE
            i := i + 1
        (*ENDIF*) 
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
ut05is_serverdb_upper := is_upper
END;
 
(*------------------------------*) 
 
FUNCTION
      ut05is_servernode_upper (VAR init_node : tsp00_NodeId): boolean;
 
VAR
      os       : tsp00_Os;
      is_upper : boolean;
      i        : integer;
 
BEGIN
sqlos (os);
is_upper := (os = os_vms);
IF  is_upper
THEN
    BEGIN
    i := 1;
    WHILE (i <= NODEID_MXSP00) AND is_upper DO
        IF  init_node [i] in ['a'..'i', 'j'..'r',  's'..'z']
        THEN
            is_upper := false
        ELSE
            i := i + 1
        (*ENDIF*) 
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
ut05is_servernode_upper := is_upper
END;
 
(*------------------------------*) 
 
FUNCTION
      ut05len256 (VAR c : tsp00_C256): integer;
 
VAR
      i : integer;
 
BEGIN
i := mxsp_c256;
WHILE (i >= 1) AND (c [i] = ' ') DO
    i := i - 1;
(*ENDWHILE*) 
ut05len256 := i
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut05name_msg_header (VAR term : tut_terminal; n : tsp00_Name);
 
VAR
      i   : integer;
      msg : tsp00_C20;
 
BEGIN
msg := bsp_c20;
FOR i := 1 TO NAME_MXSP00 DO
    msg [i] := n [i];
(*ENDFOR*) 
u05msgheader (term, msg)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut05name_to_hex (VAR term : tut_terminal;
            n         : tsp00_Name;
            msg       : tsp00_C20;
            hex_bytes : integer;
            VAR hex_n : tsp00_Name;
            VAR is_ok : boolean);
 
VAR
      i          : integer;
      pos        : integer;
      fac        : tsp00_Int4;
      int        : tsp00_Int4;
      max_int    : tsp00_Int4;
      int_n      : tsp00_Name;
      dummy_prot : tut_vf_fileref;
 
BEGIN
is_ok := true;
int   := 0;
IF  hex_bytes = 2
THEN
    max_int := MAX_INT2_SP00
ELSE
    max_int := MAX_INT4_SP00;
(*ENDIF*) 
u05intformat (n, int4_length, max_int, int_n, is_ok);
IF  NOT is_ok
THEN
    u05illegal_input_errmsg (term, dummy_prot, NOT c_write_prot, msg)
ELSE
    BEGIN
    fac := 1;
    FOR i := int4_length DOWNTO 1 DO
        BEGIN
        int := int + fac * (ord (int_n [i]) - ord('0'));
        IF  i > 1
        THEN
            fac := fac * 10
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    hex_n       := bsp_name;
    hex_n [1]   := 'X';
    hex_n [2]   := string_delimiter;
    pos         := 2 + 2 * hex_bytes + 1;
    hex_n [pos] := string_delimiter;
    FOR i := hex_bytes DOWNTO 1 DO
        BEGIN
        pos := pos - 2;
        ut05hexbyte_to_name (chr (int MOD 256), pos, hex_n);
        int := int DIV 256
        END
    (*ENDFOR*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 

 
(*------------------------------*) 
 
PROCEDURE
      ut05write_time (VAR protfile : tut_vf_fileref;
            VAR blankline : tsp00_Line);
 
VAR
      ln     : tsp00_Line;
      ln_len : integer;
      err    : integer;
      dat    : tsp00_Date;
      tim    : tsp00_Time;
 
BEGIN
ln     := blankline;
ln_len := 0;
sqldattime (dat, tim);
ln [ln_len+ 1] := tim[3]; (* hour *)
ln [ln_len+ 2] := tim[4];
ln [ln_len+ 3] := ':';
ln [ln_len+ 4] := tim[5]; (* min *)
ln [ln_len+ 5] := tim[6];
ln [ln_len+ 6] := ':';
ln [ln_len+ 7] := tim[7]; (* sec *)
ln [ln_len+ 8] := tim[8];
ln_len := ln_len + 8;
t12write_prot (protfile, ln, ln_len, err)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ut05get_block_menue (
            VAR term    : tut_terminal;
            snd_packet  : tsp1_packet_ptr;
            VAR pfkey   : tut_pfkey);
 
CONST
      x_perm_block    =  1;
      x_static_block  =  2;
      x_temp_block    =  3;
      x_return        =  6;
 
VAR
      is_ok    : boolean;
      selected : integer;
      msg      : tut_c20_array;
 
BEGIN
is_ok := false;
FOR selected := 1 TO x_return DO
    msg [selected] := bsp_c20;
(*ENDFOR*) 
msg [x_perm_block  ] := msg_data_perm;
msg [x_static_block] := msg_data_static;
msg [x_temp_block  ] := msg_data_temp;
msg [x_return      ] := msg_return;
(* *)
REPEAT
    ut05name_msg_header (term, utn_get_block);
    t09menu (term, x_return, cut_protected, msg, selected, pfkey);
    IF  (selected = x_return) AND (pfkey = pf_none)
    THEN
        pfkey := pf_end;
    (*ENDIF*) 
    IF  pfkey = pf_none
    THEN
        BEGIN
        CASE selected OF
            x_perm_block:
                ut05diag_block_address( term, msg_perm_page_no, utn_perm, snd_packet, pfkey, is_ok);
            x_static_block:
                ut05diag_block_address( term, msg_static_page_no, utn_static, snd_packet, pfkey, is_ok);
            x_temp_block:
                ut05diag_block_address( term, msg_temp_page_no, utn_temp, snd_packet, pfkey, is_ok);
            END;
        (*ENDCASE*) 
        pfkey := pf_none;
        END;
    (*ENDIF*) 
UNTIL
    (pfkey <> pf_none) OR is_ok;
(*ENDREPEAT*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
