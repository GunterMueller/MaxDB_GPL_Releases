<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE Tests SYSTEM "TestCases.dtd">
<Tests>
<Test Exclude="(;;oracle)" Number="1" Responsible="Daub, Jan Michael" TestType="positive">
<Comment>dbproc 'fill_table' creates a table with dates of the next x weeks,
	uses two NESTED WHILE LOOPS and calls

dbproc 'add_day' adding the matching daynames for the dates in the table

</Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create table meetings (nr int unique, daya char(10), dat date, descr char (40))
</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>
CREATE DBPROC ADD_DAY AS  
	var dat_act timestamp;
	day_name char (10);
  	counter int;
    	select now() from sysdba.dual;
           fetch into :dat_act;

	if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
	set counter = 1;
	
	while counter &lt;= 7 do begin
           select dayname(:dat_act) from sysdba.dual;
              fetch into :day_name;
	   UPDATE user.MEETINGS SET DAYA= :day_name
	   WHERE MEETINGS.NR IN (SELECT MEETINGS.NR FROM user.MEETINGS 
	   WHERE DAYNAME (MEETINGS.DAT) = :day_name); 
  	   counter = counter +1;
  	   select adddate(:dat_act,1) from sysdba.dual;
  	      fetch into :dat_act;
	   if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
  	end;
	
	if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
CREATE DBPROC FILL_TABLE (in num_week smallint) AS  
	VAR O_NR INT; 
	A_NR INT; 
	B_NR INT; 
	O_DAT timestamp;  
	SET O_NR = 1; 
	SET A_NR = 1; 
	set b_nr = 1;
	SELECT NOW() FROM SYSDBA.DUAL; 
	   FETCH INTO :O_DAT;  
	if num_week &gt; 52 then
		stop (01,'plans for a period longer than one year are not supported');
	WHILE A_NR &lt;= num_week DO BEGIN 
		WHILE B_NR &lt;= 7 DO BEGIN 
		   	INSERT INTO user.MEETINGS (NR, DAT) VALUES (:O_NR, substr(:O_DAT,1,10));  
			IF $RC &lt;&gt; 0 THEN          
				STOP ($RC, $ERRMSG); 
			SET B_NR = B_NR +1; 
			SET O_NR = O_NR +1; 
			select adddate(:o_dat, 1) from sysdba.dual;
			   fetch into :o_dat;
			if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
		END; 
		SET B_NR = 1; 
		SET A_NR = A_NR + 1; 
		if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
	END;
if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG); 
call add_day;
if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call fill_table (53)
</CallString>
<Error>
<ErrorCode>1</ErrorCode>
<ErrorMessage>[1]: plans for a period longer than one year are not supported</ErrorMessage>
</Error>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call fill_table(22)</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>  
select count(*) from meetings where daya = 'Tuesday'
</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>EXPRESSION1</ColumnName>
<ColumnType>INT</ColumnType>
</ColumnDefinition>
<Row>
<Value>22</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>
select sum(nr) from meetings
</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>EXPRESSION1</ColumnName>
<ColumnType>FLOAT</ColumnType>
</ColumnDefinition>
<Row>
<Value>11935.00000000000000000000000000000000000000</Value>
</Row>
</ResultSet>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString> 
 drop table meetings</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>DROP DBPROC ADD_DAY</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>DROP DBPROC FILL_TABLE</CallString>
</Statement>
</CleanUp>
</Test>
<Test Exclude="(;;oracle)" Number="2" Responsible="Daub, Jan Michael" TestType="positive">
<Comment>dbproc 'fill_table' creates a table with dates of the next x weeks,
	uses two nested while loops and calls

dbproc 'add_day' using a SIMPLE_CASE_STATEMENT to determine the number of a day of a week and calls

dbproc 'sub_add_day' which writes the matching daynames in the table</Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>

create table meetings (nr int unique, daya char(10), dat date, descr char (40))

</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>
  create dbproc sub_add_day (in day_name char (10)) as 
  	UPDATE user.MEETINGS SET DAYA= :day_name
		WHERE MEETINGS.NR IN (SELECT MEETINGS.NR FROM user.MEETINGS 
		WHERE DAYNAME (MEETINGS.DAT) = :day_name); 
		if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
  </CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
CREATE DBPROC ADD_DAY AS  
	var dat_act timestamp;
	counter int;
	day_nr int;
	select now() from sysdba.dual;
            fetch into :dat_act;
	set counter = 1;
	while counter &lt;= 7 do begin
        	select dayofweek(:dat_act) from sysdba.dual;
        	    fetch into :day_nr;
		case day_nr
                    when 1 then call sub_add_day ('Monday');
                    when 2 then call sub_add_day ('Tuesday');
                    when 3 then call sub_add_day ('Wednesday');
                    when 4 then call sub_add_day ('Thursday');
                    when 5 then call sub_add_day ('Friday');
                    when 6 then call sub_add_day ('Saturday');
                    when 7 then call sub_add_day ('Sunday');
                    else stop (-007, 'day not found');
                end;
  		if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
		counter = counter +1;
	  	select adddate(:dat_act,1) from sysdba.dual;
  	            fetch into :dat_act;
		if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
  	end;

  
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>

CREATE DBPROC FILL_TABLE (in num_week smallint) AS  
	VAR O_NR INT; 
	A_NR INT; 
	B_NR INT; 
	O_DAT timestamp;  
	SET O_NR = 1; 
	SET A_NR = 1; 
	set b_nr = 1;
	SELECT NOW() FROM SYSDBA.DUAL; 
	    FETCH INTO :O_DAT;  
	if num_week &gt; 52 then
		stop (01,'plans for a period longer than one year are not supported');
	WHILE A_NR &lt;= num_week DO BEGIN 
		WHILE B_NR &lt;= 7 DO BEGIN 
			INSERT INTO user.MEETINGS (NR, DAT) VALUES (:O_NR, substr(:O_DAT,1,10));  
			IF $RC &lt;&gt; 0 THEN          
				STOP ($RC, $ERRMSG); 
			SET B_NR = B_NR +1; 
			SET O_NR = O_NR +1; 
			select adddate(:o_dat, 1) from sysdba.dual;
			    fetch into :o_dat;
		END; 
		SET B_NR = 1; 
		SET A_NR = A_NR + 1; 
		if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
	END; 
call add_day;
if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="true">
<CallString>

call fill_table (53)

</CallString>
<Error>
<ErrorCode>1</ErrorCode>
<ErrorMessage>[1]: plans for a period longer than one year are not supported</ErrorMessage>
</Error>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call fill_table(22)
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>

select sum(nr) from meetings

</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>EXPRESSION1</ColumnName>
<ColumnType>FLOAT</ColumnType>
</ColumnDefinition>
<Row>
<Value>11935.00000000000000000000000000000000000000</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>select count(*) from meetings where daya = 'Saturday'</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>EXPRESSION1</ColumnName>
<ColumnType>INT</ColumnType>
</ColumnDefinition>
<Row>
<Value>22</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>delete from meetings 



























	where daya in ('Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday')
         </CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call fill_table(52)</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>select count(*) from meetings where nr &gt; 300</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>EXPRESSION1</ColumnName>
<ColumnType>INT</ColumnType>
</ColumnDefinition>
<Row>
<Value>64</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="true" ignore="false" verify="true">
<CallString>call fill_table(2)</CallString>
<Error>
<ErrorCode>250</ErrorCode>
<ErrorMessage>[250]: Duplicate secondary key:NR,MEETINGS,PROCTEST</ErrorMessage>
</Error>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>
 
 drop table meetings
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
DROP DBPROC ADD_DAY
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
DROP DBPROC FILL_TABLE
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString> 
drop dbproc sub_add_day

</CallString>
</Statement>
</CleanUp>
</Test>
<Test Exclude="(;;oracle)" Number="3" Responsible="Daub, Jan Michael" TestType="positive">
<Comment>dbproc_names with 
 	- special_identifiers in double_quotes
	- language_specific_character like ä, ö
	- digits
	- underscores
	- extended_letters</Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>create table testlog (logmsg char (100))</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc "table" (out  output smallint) as
var cur_dat date;
cur_dat = date;
create table temp.tab1 (col1 date);
    if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
insert into temp.tab1 values (:cur_dat);
    if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
select count(*) from temp.tab1;
fetch into :output;
    if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
drop table temp.tab1;
insert into USER.testlog values ('proc table executed successfully');
    if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);

</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc "4-5-*+6?}" (out  output smallint) as
var cur_dat date;
cur_dat = date;
create table temp.tab1 (col1 date);
    if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
insert into temp.tab1 values (:cur_dat);
    if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
select count(*) from temp.tab1;
fetch into :output;
    if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
drop table temp.tab1;
insert into USER.testlog values ('proc 4-5-*+6?} executed successfully');
    if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc äöü_ (out  output smallint) as
var cur_dat date;
cur_dat = date;
create table temp.tab1 (col1 date);
    if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
insert into temp.tab1 values (:cur_dat);
    if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
select count(*) from temp.tab1;
fetch into :output;
    if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
drop table temp.tab1;
insert into USER.testlog values ('proc aeoeue_ executed successfully');
    if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc @proc1 (out  output smallint) as
var cur_dat date;
cur_dat = date;
create table temp.tab1 (col1 date);
    if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
insert into temp.tab1 values (:cur_dat);
    if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
select count(*) from temp.tab1;
fetch into :output;
    if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
drop table temp.tab1;
insert into USER.testlog values ('proc @proc1 executed successfully');
    if $RC &lt;&gt; 0 THEN STOP ($RC,$ERRMSG);
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call "table" (?)
</CallString>
<Parameter DataType="SMALLINT" InValue="" OutValue="1" ParamType="OUT"/>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call "4-5-*+6?}"(?)
</CallString>
<Parameter DataType="SMALLINT" InValue="" OutValue="1" ParamType="OUT"/>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call äöü_(?)
</CallString>
<Parameter DataType="SMALLINT" InValue="" OutValue="1" ParamType="OUT"/>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call USER.@proc1(?)
</CallString>
<Parameter DataType="" InValue="" OutValue="1" ParamType="OUT"/>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>select * from testlog</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>LOGMSG</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>'proc table executed successfully'</Value>
</Row>
<Row>
<Value>'proc 4-5-*+6?} executed successfully'</Value>
</Row>
<Row>
<Value>'proc aeoeue_ executed successfully'</Value>
</Row>
<Row>
<Value>'proc @proc1 executed successfully'</Value>
</Row>
</ResultSet>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc "table"
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString> 
drop dbproc "4-5-*+6?}"
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc äöü_
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc USER.@proc1</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop table testlog</CallString>
</Statement>
</CleanUp>
</Test>
<Test Exclude="(;;oracle)" Number="4" Responsible="Daub, Jan Michael" TestType="positive">
<Comment>searched_case_statement within a procedure
--&gt; dbproc prio_cases</Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create table meetings (nr int unique, dat date, prio1 smallint, prio2 smallint, prio3 smallint, prio char (10), descr char (40))
</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc insert_meeting (in dat date, in prio1 smallint, in prio2 smallint, in prio3 smallint, in descr char(40)) as 
var l_nr int;
nr int;
nr = 0;
l_nr = 0;
select nr from user.meetings;
   WHILE $RC = 0 DO BEGIN
      FETCH INTO :nr;
      if  ($RC &lt;&gt; 100) and (nr &gt; l_nr) then  l_nr = nr;
      if  $RC = 100 then break;
   end;
nr = nr + 1;
insert into user.meetings (nr, dat, prio1, prio2, prio3, descr) values (:nr, :dat, :prio1, :prio2, :prio3, :descr);
 if $RC = 250 THEN STOP ($RC, 'problem in generating numbers');
  if $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG);
  </CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc prio_cases as
var p1 int;
p2 int;
p3 int; 
p4 int;
prio_descr char (10);
select prio1, prio2, prio3 from user.meetings;
   while $RC &lt;&gt; 100 DO BEGIN
        fetch into :p1,:p2,:p3;
        p4 = p1 + p2 + p3;
        if $RC = 100 THEN BREAK;
        if $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG);
        case
            when p4 &lt;= 6 then prio_descr = 'high';
            when p4 &gt; 6 and p4 &lt;= 10 then set prio_descr = 'middle';
            when p4 &gt; 10 and p4 &lt;= 27 then set prio_descr = 'low';
            else set prio_descr = '-- none --';
        end case;
        update user.meetings set prio = :prio_descr where prio1 = :p1 and prio2 = :p2 and prio3 = :p3; 
    end;
    if $RC &lt;&gt; 0 and $RC &lt;&gt; 100 THEN STOP ($RC, 'setting priorities failed');
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
 call insert_meeting('2002-02-02',1,3,5,'interview')
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
 call insert_meeting('2002-04-12',2,1,4,'sports')
 </CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
 call insert_meeting('2002-03-30',3,3,2,'breakfast at ...')
 </CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
 call insert_meeting('2002-06-25',5,4,5,'learning hour')
 </CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
 call insert_meeting('2002-12-05',1,1,1,'camp')
 </CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
 call insert_meeting('2002-06-07',3,4,5,'new project')
 </CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
 call insert_meeting('2002-03-08',6,3,5,'meeting with Smith')
 </CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
 call insert_meeting('2002-09-08',9,13,5,'meeting with Mandy')
  </CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
 call insert_meeting('2002-09-08',19,11,0,'walking')


</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call prio_cases
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>
select * from meetings
</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>NR</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DAT</ColumnName>
<ColumnType>DATE</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO1</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO2</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO3</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DESCR</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>1</Value>
<Value>'2002-02-02'</Value>
<Value>1</Value>
<Value>3</Value>
<Value>5</Value>
<Value>'middle'</Value>
<Value>'interview'</Value>
</Row>
<Row>
<Value>2</Value>
<Value>'2002-04-12'</Value>
<Value>2</Value>
<Value>1</Value>
<Value>4</Value>
<Value>'middle'</Value>
<Value>'sports'</Value>
</Row>
<Row>
<Value>3</Value>
<Value>'2002-03-30'</Value>
<Value>3</Value>
<Value>3</Value>
<Value>2</Value>
<Value>'middle'</Value>
<Value>'breakfast at ...'</Value>
</Row>
<Row>
<Value>4</Value>
<Value>'2002-06-25'</Value>
<Value>5</Value>
<Value>4</Value>
<Value>5</Value>
<Value>'low'</Value>
<Value>'learning hour'</Value>
</Row>
<Row>
<Value>5</Value>
<Value>'2002-12-05'</Value>
<Value>1</Value>
<Value>1</Value>
<Value>1</Value>
<Value>'high'</Value>
<Value>'camp'</Value>
</Row>
<Row>
<Value>6</Value>
<Value>'2002-06-07'</Value>
<Value>3</Value>
<Value>4</Value>
<Value>5</Value>
<Value>'low'</Value>
<Value>'new project'</Value>
</Row>
<Row>
<Value>7</Value>
<Value>'2002-03-08'</Value>
<Value>6</Value>
<Value>3</Value>
<Value>5</Value>
<Value>'low'</Value>
<Value>'meeting with Smith'</Value>
</Row>
<Row>
<Value>8</Value>
<Value>'2002-09-08'</Value>
<Value>9</Value>
<Value>13</Value>
<Value>5</Value>
<Value>'low'</Value>
<Value>'meeting with Mandy'</Value>
</Row>
<Row>
<Value>9</Value>
<Value>'2002-09-08'</Value>
<Value>19</Value>
<Value>11</Value>
<Value>0</Value>
<Value>'-- none --'</Value>
<Value>'walking'</Value>
</Row>
</ResultSet>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc prio_cases
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc insert_meeting
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop table meetings

</CallString>
</Statement>
</CleanUp>
</Test>
<Test Exclude="(;;oracle)" Number="5" Responsible="Daub, Jan Michael" TestType="positive">
<Comment>&lt;searched_case_statement&gt;

testing that the first matching condition is determined, 
the task executed and the case_statement ended
(it means that it does not follow up more than one - the first - 
matching condition)
</Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>

create table meetings (nr int unique, dat date, prio1 smallint, prio2 smallint, prio3 smallint, prio char (15), descr char (40))

</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>

create dbproc insert_meeting (in dat date, in prio1 smallint, in prio2 smallint, in prio3 smallint, in descr char(40)) as 
var l_nr int;
nr int;
nr = 0;
l_nr = 0;
select nr from user.meetings;
   WHILE $RC = 0 DO BEGIN
      FETCH INTO :nr;
      if  ($RC &lt;&gt; 100) and (nr &gt; l_nr) then  l_nr = nr;
      if  $RC = 100 then break;
   end;
nr = nr + 1;
insert into user.meetings (nr, dat, prio1, prio2, prio3, descr) values (:nr, :dat, :prio1, :prio2, :prio3, :descr);
 if $RC = 250 THEN STOP ($RC, 'problem in generating numbers');
  if $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG);
  
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc prio_cases as
var p1 int;
p2 int;
p3 int; 
p4 int;
descr char (15);
select prio1, prio2, prio3 from user.meetings;
   while $RC &lt;&gt; 100 DO BEGIN
        fetch into :p1,:p2,:p3;
        p4 = p1 + p2 + p3;
        if $RC = 100 THEN BREAK;
        if $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG);
       case
                when p1 &lt;= 2 then descr = '[1] p1 &lt;= 2';
                when p2 &lt;= 3 then set descr = '[2] p2 &lt;= 3';
                when p2 = 4 then set descr = '[3] p2 = 4';
                when p1 = 1 and p2 = 1 and p3 = 1 then set descr = '[4] special 1';
                else set descr = '[5] -- none --';
            end case;
            update user.meetings set prio = :descr where prio1 = :p1 and prio2 = :p2 and prio3 = :p3; 
        end;
    if $RC &lt;&gt; 0 and $RC &lt;&gt; 100 THEN STOP ($RC, 'setting priorities failed');


</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>

 call insert_meeting('2002-02-02',1,3,5,'interview')

</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>

 call insert_meeting('2002-04-12',2,1,4,'sports')
 
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>

 call insert_meeting('2002-03-30',3,3,2,'breakfast at ...')
 
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>

 call insert_meeting('2002-06-25',5,4,5,'learning hour')
 
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>

 call insert_meeting('2002-12-05',1,1,1,'camp')
 
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>

 call insert_meeting('2002-06-07',3,4,5,'new project')
 
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>

 call insert_meeting('2002-03-08',6,3,5,'meeting with Smith')
 
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>

 call insert_meeting('2002-09-08',9,13,5,'meeting with Mandy')
  
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>

 call insert_meeting('2002-09-08',19,11,0,'walking')



</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>

call prio_cases

</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>

select * from meetings

</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>NR</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DAT</ColumnName>
<ColumnType>DATE</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO1</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO2</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO3</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DESCR</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>1</Value>
<Value>'2002-02-02'</Value>
<Value>1</Value>
<Value>3</Value>
<Value>5</Value>
<Value>'[1] p1 &lt;= 2'</Value>
<Value>'interview'</Value>
</Row>
<Row>
<Value>2</Value>
<Value>'2002-04-12'</Value>
<Value>2</Value>
<Value>1</Value>
<Value>4</Value>
<Value>'[1] p1 &lt;= 2'</Value>
<Value>'sports'</Value>
</Row>
<Row>
<Value>3</Value>
<Value>'2002-03-30'</Value>
<Value>3</Value>
<Value>3</Value>
<Value>2</Value>
<Value>'[2] p2 &lt;= 3'</Value>
<Value>'breakfast at ...'</Value>
</Row>
<Row>
<Value>4</Value>
<Value>'2002-06-25'</Value>
<Value>5</Value>
<Value>4</Value>
<Value>5</Value>
<Value>'[3] p2 = 4'</Value>
<Value>'learning hour'</Value>
</Row>
<Row>
<Value>5</Value>
<Value>'2002-12-05'</Value>
<Value>1</Value>
<Value>1</Value>
<Value>1</Value>
<Value>'[1] p1 &lt;= 2'</Value>
<Value>'camp'</Value>
</Row>
<Row>
<Value>6</Value>
<Value>'2002-06-07'</Value>
<Value>3</Value>
<Value>4</Value>
<Value>5</Value>
<Value>'[3] p2 = 4'</Value>
<Value>'new project'</Value>
</Row>
<Row>
<Value>7</Value>
<Value>'2002-03-08'</Value>
<Value>6</Value>
<Value>3</Value>
<Value>5</Value>
<Value>'[2] p2 &lt;= 3'</Value>
<Value>'meeting with Smith'</Value>
</Row>
<Row>
<Value>8</Value>
<Value>'2002-09-08'</Value>
<Value>9</Value>
<Value>13</Value>
<Value>5</Value>
<Value>'[5] -- none --'</Value>
<Value>'meeting with Mandy'</Value>
</Row>
<Row>
<Value>9</Value>
<Value>'2002-09-08'</Value>
<Value>19</Value>
<Value>11</Value>
<Value>0</Value>
<Value>'[5] -- none --'</Value>
<Value>'walking'</Value>
</Row>
</ResultSet>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>

drop dbproc prio_cases

</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>

drop dbproc insert_meeting

</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>

drop table meetings


</CallString>
</Statement>
</CleanUp>
</Test>
<Test Exclude="(;;oracle)" Number="6" Responsible="Daub, Jan Michael" TestType="positive">
<Comment>defining a procedure which delivers a resultset;
dbproc 'people_from' creates a resultset with addresses of all the people living in city X

</Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>
        create table addressbook (lastname char(30),
                                                              forname char(20),
                                                              street char(40),
                                                              h_nr smallint,
                                                              city char (50))
                                                              
                                                              </CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
                                                              
insert into addressbook values ('Wieler', 'Christian', 'Hardenberggasse', 23, 'Honigberg')
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
insert into addressbook values ('Mindbach', 'Reinhold', 'Bucheneckstrasse', 45, 'Waldhausen')
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
insert into addressbook values ('Grenz', 'Waldemar', 'Zaunstrasse', 10, 'Waldhausen')
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
insert into addressbook values ('Baum', 'Edelgard', 'Sandiger Weg', 16, 'Honigberg')
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
insert into addressbook values ('Winn', 'Viola', 'Kompakt Allee', 2, 'Wungenstadt')
</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>
CREATE DBPROC people_from (IN city char(40))
        RETURNS CURSOR AS
       var counted smallint;
        $CURSOR = 'people_city';
        select count(*) from (select * from user.addressbook where city = :city);
            fetch into :counted;
        if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
        case 
            when counted = 0 then stop (-30303, 'could not find any entry');
            when counted &gt; 0 then DECLARE :$CURSOR CURSOR FOR
                        SELECT * FROM user.addressbook WHERE city = :city for reuse;
          
        end case;
        

</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call people_from ('Honigberg')
</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>LASTNAME</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>FORNAME</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>STREET</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>H_NR</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>CITY</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>'Wieler'</Value>
<Value>'Christian'</Value>
<Value>'Hardenberggasse'</Value>
<Value>23</Value>
<Value>'Honigberg'</Value>
</Row>
<Row>
<Value>'Baum'</Value>
<Value>'Edelgard'</Value>
<Value>'Sandiger Weg'</Value>
<Value>16</Value>
<Value>'Honigberg'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call people_from ('London')

</CallString>
<Error>
<ErrorCode>-30303</ErrorCode>
<ErrorMessage>[-30303]: could not find any entry</ErrorMessage>
</Error>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc people_from
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop table addressbook
</CallString>
</Statement>
</CleanUp>
</Test>
<Test Exclude="(;;oracle)" Number="7" Responsible="Daub, Jan Michael" TestType="positive">
<Comment>- creating a table containing columns of type Boolean, Char (40), Varchar (40), Date, 
  Time, Fixed (5,1), Float (16), Integer, numeric (7), real, Smallint, Timestamp;

- creating a db-procedure with the same type of columns which inserts values in the table;
- creating some db-procedure with functions getting data from the first table and put results in a temporarily one;</Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>
CREATE TABLE AIRPORT
(
	TODAY               Boolean,
	NAME               Char (40) ,
	LOCATION               Varchar (40) unique,
	STAND               Date,
	STAND_T               Time,
	AREA      Fixed (5,1),
	EMPLOYEES               Float (16),
	PASSENGERS               Integer,
	CARGO               numeric (7),
	FLIGHTS               real,
	PER_DAY               Smallint,
	ARRIVAL             Timestamp,
            DEPARTURE               Timestamp
)
</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC AIRPORT_ADD (IN TODAY BOOLEAN,                             
	IN NAME CHAR (40),                         
	IN LOCATION VARCHAR(40),                         
	IN STAND DATE,                         
	IN STAND_T TIME,                         
	IN AREA FIXED(5,1),                         
	IN EMPLOYEES FLOAT,                         
	IN PASSENGERS INT,                         
	IN CARGO NUMERIC(7),                          
	IN FLIGHTS REAL,                         
	IN PER_DAY SMALLINT,                         
	IN ARRIVAL TIMESTAMP,                         
	IN DEPARTURE TIMESTAMP)                         
AS                         
	INSERT INTO USER.AIRPORT VALUES (:TODAY, :NAME, :LOCATION, :STAND, 
						:STAND_T, :AREA, :EMPLOYEES, :PASSENGERS, 
						:CARGO, :FLIGHTS, :PER_DAY, :ARRIVAL, :DEPARTURE);
	IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG);</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call airport_add (TRUE,   'Frankfurt Airport',  'Frankfurt',  '2002-08-12',  
			'06:05:00',  15.6,  62000,  49369429,  1589428,  458731,  1253,  
				'2002-09-23 10:10:07.000000',  '2002-09-23 12:10:07.0700')  
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call airport_add (FALSE,  'Munich Airport',     'Munich',    '2002-08-14',  
			'07:00:01',  10 ,   25000 , 25023379,  703956,   319009,  874,   
				'2002-09-24 02:37:53.003000',  '2002-09-24 05:55:00.000000')  
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>call airport_add (FALSE,  'Munich Airport',     'Munich',    '2002-08-14',  
			'07:00:01',  10 ,   25000 , 25023379,  703956,   319009,  874,   
				'2002-09-24 02:37:53.003000',  '2002-09-24 05:55:00.000000')  </CallString>
<Error>
<ErrorCode>250</ErrorCode>
<ErrorMessage>[250]: Duplicate secondary key:LOCATION,AIRPORT,PROCTEST</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
CREATE DBPROC CH_BOOLEAN (IN LOCATION CHAR (40), 
				OUT B CHAR, OUT B1 INT) 
AS       	SELECT CHR(TODAY) FROM USER.AIRPORT WHERE LOCATION = :LOCATION;      
		FETCH INTO :B;      
		IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG);       

		SELECT NUM(TODAY) FROM USER.AIRPORT WHERE LOCATION = :LOCATION;      
		FETCH INTO :B1;      
		IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG);
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call ch_boolean ('Frankfurt', ?, ?)
</CallString>
<Parameter DataType="CHAR" InValue="" OutValue="T" ParamType="OUT"/>
<Parameter DataType="INT" InValue="" OutValue="1" ParamType="OUT"/>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call ch_boolean ('Munich', ?, ?)
</CallString>
<Parameter DataType="CHAR" InValue="" OutValue="F" ParamType="OUT"/>
<Parameter DataType="INT" InValue="" OutValue="0" ParamType="OUT"/>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
CREATE DBPROC DELAY (IN LOCATION CHAR(40), 
			IN DELAY TIME)  
	AS 		
			UPDATE USER.AIRPORT 
			SET ARRIVAL = (SELECT ADDTIME(ARRIVAL, :DELAY) 
				FROM USER.AIRPORT WHERE LOCATION = :LOCATION ),    
                            DEPARTURE = (SELECT ADDTIME(DEPARTURE, :DELAY) 
				FROM USER.AIRPORT WHERE LOCATION = :LOCATION ) 
			WHERE  LOCATION = :LOCATION;
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call delay ('Frankfurt', '01:25:00')
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
CREATE DBPROC TEST_REST AS      
  VAR RES1 INT;      
    RES2 INT;      
      res3 char(40);
        CREATE TABLE TEMP.VERIFY1 (F INT, S INT);      
	CREATE TABLE TEMP.VERIFY2 (PD INT, AV INT);      
	CREATE TABLE TEMP.VERIFY3 (NAME CHAR(40), PS INT);      
	
	IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG);      
	SELECT TRUNC(FLIGHTS,-2), SIGN(AREA) FROM USER.AIRPORT;      
	  WHILE $RC &lt;&gt; 100 DO BEGIN
 	    FETCH INTO :RES1, :RES2;              
            IF $RC = 100 THEN BREAK;  
	    INSERT INTO TEMP.VERIFY1 VALUES (:RES1, :RES2);     
          END;                          
    
        SELECT  SUM(PER_DAY), AVG(CARGO) FROM USER.AIRPORT ;           
	  WHILE $RC &lt;&gt; 100 DO BEGIN
	    FETCH INTO :RES1, :RES2;              
	    IF $RC = 100 THEN BREAK;  
	    INSERT INTO TEMP.VERIFY2 VALUES (:RES1, :RES2);  
	  end;

	SELECT name, INDEX(NAME, 'Air') FROM USER.AIRPORT; 
	  WHILE $RC &lt;&gt; 100 DO BEGIN
	    FETCH INTO :RES3, :RES1;              
	    IF $RC = 100 THEN BREAK;  
	    INSERT INTO TEMP.VERIFY3 VALUES (:RES3, :RES1);  
	end;
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call test_rest
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString> 
select * from temp.verify1
</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>F</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>S</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<Row>
<Value>458700</Value>
<Value>1</Value>
</Row>
<Row>
<Value>319000</Value>
<Value>1</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
select * from temp.verify2
</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>PD</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>AV</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<Row>
<Value>2127</Value>
<Value>1146692</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
select * from temp.verify3
</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>NAME</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PS</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<Row>
<Value>'Frankfurt Airport'</Value>
<Value>11</Value>
</Row>
<Row>
<Value>'Munich Airport'</Value>
<Value>8</Value>
</Row>
</ResultSet>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc airport_add
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc ch_boolean
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc delay
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc test_rest
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop table airport

</CallString>
</Statement>
</CleanUp>
</Test>
<Test Exclude="" Number="8" Responsible="Daub, Jan Michael" TestType="positive">
<Comment>two dbprocs calling one another till a given number is reached by the counter

each writes a line in the logtab and adds one to the counter </Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create table logtab (counter int, in_sert char (40))          
</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>
         create dbproc lo_2 (in n int, in c int) as 
            stop ($RC, $ERRMSG);
            </CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc lo_1 (in numb int, in counter int)
    as    
            if counter &lt;= numb then begin
                insert into user.logtab values (:counter, 'was inserted by lo_1');
                if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
                counter = counter + 1;
                call lo_2 (:numb, :counter);
                if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
            end;
            
            </CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
            drop dbproc lo_2
            </CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc lo_2 (in numb int, in counter int)
    as 
            if counter &lt;= numb then begin
                insert into user.logtab values (:counter, 'was inserted by lo_2');
                if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
                counter = counter + 1;
                call lo_1 (:numb, :counter);
                if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
            end;
            
            </CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
  call lo_1 (20, 1)
  </CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>
select * from logtab
  </CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>COUNTER</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>IN_SERT</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>1</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>2</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>3</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>4</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>5</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>6</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>7</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>8</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>9</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>10</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>11</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>12</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>13</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>14</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>15</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>16</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>17</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>18</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>19</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>20</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop table logtab
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create table logtab (counter int, in_sert char (40))          
  </CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
     call lo_1 (70, 51)
     </CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>
select * from logtab
     </CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>COUNTER</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>IN_SERT</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>51</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>52</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>53</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>54</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>55</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>56</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>57</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>58</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>59</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>60</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>61</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>62</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>63</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>64</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>65</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>66</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>67</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>68</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>69</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>70</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop table logtab
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create table logtab (counter int, in_sert char (40))          
  </CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call lo_1 (1000000020, 1000000001)
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>
select * from logtab
</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>COUNTER</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>IN_SERT</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>1000000001</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>1000000002</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>1000000003</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>1000000004</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>1000000005</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>1000000006</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>1000000007</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>1000000008</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>1000000009</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>1000000010</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>1000000011</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>1000000012</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>1000000013</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>1000000014</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>1000000015</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>1000000016</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>1000000017</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>1000000018</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
<Row>
<Value>1000000019</Value>
<Value>'was inserted by lo_1'</Value>
</Row>
<Row>
<Value>1000000020</Value>
<Value>'was inserted by lo_2'</Value>
</Row>
</ResultSet>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop table logtab
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc lo_1
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc lo_2</CallString>
</Statement>
</CleanUp>
</Test>
<Test Exclude="" Number="9" Responsible="Daub, Jan Michael" TestType="positive">
<Comment>two dbprocs calling one another till a given number is reached by the counter,
they are initially called by a third one within a while_loop,
	the given parameter determines who many loops are done  

* has been deactivated due to incompatibility with DBPROC_TRIGGER.xml if it (nr. 9!) runs first</Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create table logtab (counter int, in_sert char (40))
</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc lo_2 (in n int, in c int) as 
            stop ($RC, $ERRMSG);
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc lo_1 (in numb int, in counter int)
    as    
            if counter &lt;= numb then begin
                insert into user.logtab values (:counter, 'was inserted by lo_1');
                if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
                counter = counter + 1;
		call lo_2 (:numb, :counter);
                if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
            end;
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc lo_2
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc lo_2 (in numb int, in counter int)
    as 
            if counter &lt;= numb then begin
                insert into user.logtab values (:counter, 'was inserted by lo_2');
                if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
                counter = counter + 1;
                call lo_1 (:numb, :counter);
                if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
            end;
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc cal (in b int, out numb int)
    as 
	    var a int; 
	    numb = 0;
	    a = 1;
	        while a &lt;= b do begin
        	    call lo_1 (10, 1);
         	    	if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
            	    a = a+1;
	            select count(*) from user.logtab;
		        fetch into :numb;
		end;
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="true">
<CallString>
    call cal(5000, ?)
</CallString>
<Parameter DataType="INT" InValue="" OutValue="50000" ParamType="OUT"/>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop table logtab</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>

create table logtab (counter int, in_sert char (40))</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="true">
<CallString>
    call cal(10000, ?)
</CallString>
<Parameter DataType="INT" InValue="" OutValue="100000" ParamType="OUT"/>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop table logtab</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>

create table logtab (counter int, in_sert char (40))</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="true">
<CallString>
    call cal(30000, ?)
</CallString>
<Parameter DataType="INT" InValue="" OutValue="300000" ParamType="OUT"/>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop table logtab
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc cal
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc lo_1
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc lo_2
</CallString>
</Statement>
</CleanUp>
</Test>
<Test ErrorType="semantic" Exclude="" Number="10" Responsible="Daub, Jan Michael" TestType="negative">
<Comment>verifying that incorrect [owner.]identifiers are not accepted for dbprocs</Comment>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc table (out cur_dat date) as
cur_dat = date;

</CallString>
<Error>
<ErrorCode>-7006</ErrorCode>
<ErrorMessage>[-7006] (at 16): Reserved identifier not allowed:TABLE</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc temp.proc1 (out cur_dat date) as
cur_dat = date;

</CallString>
<Error>
<ErrorCode>-5001</ErrorCode>
<ErrorMessage>[-5001] (at 21): Missing privilege:OWNER</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc *proc (out cur_dat date) as
cur_dat = date;

</CallString>
<Error>
<ErrorCode>-5006</ErrorCode>
<ErrorMessage>[-5006] (at 16): Missing identifier</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc 12 (out cur_dat date) as
cur_dat = date;

</CallString>
<Error>
<ErrorCode>-5006</ErrorCode>
<ErrorMessage>[-5006] (at 16): Missing identifier</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc benno.proc2 (out cur_dat date) as
cur_dat = date;</CallString>
<Error>
<ErrorCode>-5001</ErrorCode>
<ErrorMessage>[-5001] (at 22): Missing privilege:OWNER</ErrorMessage>
</Error>
<Error>
<ErrorCode>-4024</ErrorCode>
<ErrorMessage>[-4024] (at 22): Unknown name</ErrorMessage>
</Error>
<Error>
<ErrorCode>-4030</ErrorCode>
<ErrorMessage>[-4030] (at 22): Unknown schema</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>
select count(*) from dbprocedures where dbprocname in ('TABLE', 'proc1', '*proc', '12', 'proc2') </CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>EXPRESSION1</ColumnName>
<ColumnType>INT</ColumnType>
</ColumnDefinition>
<Row>
<Value>0</Value>
</Row>
</ResultSet>
</Statement>
</Run>
</Test>
<Test ErrorType="syntax" Exclude="(7.3.32.*;;)(;;oracle)" Number="11" Responsible="Daub, Jan Michael" TestType="negative">
<Comment>dbproc with invalid 
* create_table_temp_statements *

- duplicate column name
- too complicated trigger
- invalid numeric constant in check_constraint
- invalid numeric constant as default
- default does not fulfil check_constraint
- unique definition on a column in a temp_table 
- invalid not_null
- primary key too long (char(1024)-column)
- long column as primary key
- invalid length for numeric-column

(7.3.32 is excluded because page size is 32 kByte instead of 8 kByte, so that the expected error does not occur)</Comment>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc1 (out  cur_dat date) as
begin
    cur_dat = date;
    create table temp.tab1 (col1 int, col1 int);
end;
</CallString>
<Error>
<ErrorCode>-6001</ErrorCode>
<ErrorMessage>[-6001] (at 109): Duplicate column name:COL1</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc2 (out  cur_dat date) as
begin
    cur_dat = date;
    create table temp.tab2 (COL1 CHAR(6), COL2 CHAR(6), COL3 CHAR(6), COL4 CHAR(6), COL5 CHAR(6),
COL6 CHAR(6), COL7 CHAR(6), COL8 CHAR(6), COL9 CHAR(6), COL10 CHAR(6),
COL11 CHAR(6), COL12 CHAR(6), COL13 CHAR(6), COL14 CHAR(6), COL15 CHAR(6),
COL16 CHAR(6), COL17 CHAR(6), COL18 CHAR(6), COL19 CHAR(6), COL20 CHAR(6),
COL21 CHAR(6), COL22 CHAR(6), COL23 CHAR(6), COL24 CHAR(6), COL25 CHAR(6),
COL26 CHAR(6), COL27 CHAR(6), COL28 CHAR(6), COL29 CHAR(6), COL30 CHAR(6),
COL31 CHAR(6), COL32 CHAR(6), COL33 CHAR(6), COL34 CHAR(6), COL35 CHAR(6),
COL36 CHAR(6), COL37 CHAR(6), COL38 CHAR(6), COL39 CHAR(6), COL40 CHAR(6),
COL41 CHAR(6), COL42 CHAR(6), COL43 CHAR(6), COL44 CHAR(6), COL45 CHAR(6),
COL46 CHAR(6), COL47 CHAR(6), COL48 CHAR(6), COL49 CHAR(6), COL50 CHAR(6),
COL51 CHAR(6), COL52 CHAR(6), COL53 CHAR(6), COL54 CHAR(6), COL55 CHAR(6),
COL56 CHAR(6), COL57 CHAR(6), COL58 CHAR(6), COL59 CHAR(6), COL60 CHAR(6),
COL61 CHAR(6), COL62 CHAR(6), COL63 CHAR(6), COL64 CHAR(6), COL65 CHAR(6),
COL66 CHAR(6), COL67 CHAR(6), COL68 CHAR(6), COL69 CHAR(6), COL70 CHAR(6),
COL71 CHAR(6), COL72 CHAR(6), COL73 CHAR(6), COL74 CHAR(6), COL75 CHAR(6),
COL76 CHAR(6), COL77 CHAR(6), COL78 CHAR(6), COL79 CHAR(6), COL80 CHAR(6),
COL81 CHAR(6), COL82 CHAR(6), COL83 CHAR(6), COL84 CHAR(6), COL85 CHAR(6),
COL86 CHAR(6), COL87 CHAR(6), COL88 CHAR(6), COL89 CHAR(6), COL90 CHAR(6),
COL91 CHAR(6), COL92 CHAR(6), COL93 CHAR(6), COL94 CHAR(6), COL95 CHAR(6),
COL96 CHAR(6), COL97 CHAR(6), COL98 CHAR(6), COL99 CHAR(6), COL100 CHAR(6),
COL101 CHAR(6), COL102 CHAR(6), COL103 CHAR(6), COL104 CHAR(6), COL105 CHAR(6),
COL106 CHAR(6), COL107 CHAR(6), COL108 CHAR(6), COL109 CHAR(6), COL110 CHAR(6),
COL111 CHAR(6), COL112 CHAR(6), COL113 CHAR(6), COL114 CHAR(6), COL115 CHAR(6),
COL116 CHAR(6), COL117 CHAR(6), COL118 CHAR(6), COL119 CHAR(6), COL120 CHAR(6),
COL121 CHAR(6), COL122 CHAR(6), COL123 CHAR(6), COL124 CHAR(6), COL125 CHAR(6),
COL126 CHAR(6), COL127 CHAR(6), COL128 CHAR(6), COL129 CHAR(6), COL130 CHAR(6),
COL131 CHAR(6), COL132 CHAR(6), COL133 CHAR(6), COL134 CHAR(6), COL135 CHAR(6),
COL136 CHAR(6), COL137 CHAR(6), COL138 CHAR(6), COL139 CHAR(6), COL140 CHAR(6),
COL141 CHAR(6), COL142 CHAR(6), COL143 CHAR(6), COL144 CHAR(6), COL145 CHAR(6),
COL146 CHAR(6), COL147 CHAR(6), COL148 CHAR(6), COL149 CHAR(6), COL150 CHAR(6),
COL151 CHAR(6), COL152 CHAR(6), COL153 CHAR(6), COL154 CHAR(6), COL155 CHAR(6),
COL156 CHAR(6), COL157 CHAR(6), COL158 CHAR(6), COL159 CHAR(6), COL160 CHAR(6),
COL161 CHAR(6), COL162 CHAR(6), COL163 CHAR(6), COL164 CHAR(6), COL165 CHAR(6),
COL166 CHAR(6), COL167 CHAR(6), COL168 CHAR(6), COL169 CHAR(6), COL170 CHAR(6),
COL171 CHAR(6), COL172 CHAR(6), COL173 CHAR(6), COL174 CHAR(6), COL175 CHAR(6),
COL176 CHAR(6), COL177 CHAR(6), COL178 CHAR(6), COL179 CHAR(6), COL180 CHAR(6),
COL181 CHAR(6), COL182 CHAR(6), COL183 CHAR(6), COL184 CHAR(6), COL185 CHAR(6),
COL186 CHAR(6), COL187 CHAR(6), COL188 CHAR(6), COL189 CHAR(6), COL190 CHAR(6),
COL191 CHAR(6), COL192 CHAR(6), COL193 CHAR(6), COL194 CHAR(6), COL195 CHAR(6),
COL196 CHAR(6), COL197 CHAR(6), COL198 CHAR(6), COL199 CHAR(6), COL200 CHAR(6),
COL201 CHAR(6), COL202 CHAR(6), COL203 CHAR(6), COL204 CHAR(6), COL205 CHAR(6),
COL206 CHAR(6), COL207 CHAR(6), COL208 CHAR(6), COL209 CHAR(6), COL210 CHAR(6),
COL211 CHAR(6), COL212 CHAR(6), COL213 CHAR(6), COL214 CHAR(6), COL215 CHAR(6),
COL216 CHAR(6), COL217 CHAR(6), COL218 CHAR(6), COL219 CHAR(6), COL220 CHAR(6),
COL221 CHAR(6), COL222 CHAR(6), COL223 CHAR(6), COL224 CHAR(6), COL225 CHAR(6),
COL226 CHAR(6), COL227 CHAR(6), COL228 CHAR(6), COL229 CHAR(6), COL230 CHAR(6),
COL231 CHAR(6), COL232 CHAR(6), COL233 CHAR(6), COL234 CHAR(6), COL235 CHAR(6),
COL236 CHAR(6), COL237 CHAR(6), COL238 CHAR(6), COL239 CHAR(6), COL240 CHAR(6),
COL241 CHAR(6), COL242 CHAR(6), COL243 CHAR(6), COL244 CHAR(6), COL245 CHAR(6),
COL246 CHAR(6), COL247 CHAR(6), COL248 CHAR(6), COL249 CHAR(6), COL250 CHAR(6),
COL251 CHAR(6), COL252 CHAR(6), COL253 CHAR(6), COL254 CHAR(6), COL255 CHAR(6),
COL256 CHAR(6), COL257 CHAR(6), COL258 CHAR(6), COL259 CHAR(6), COL260 CHAR(6),
COL261 CHAR(6), COL262 CHAR(6), COL263 CHAR(6), COL264 CHAR(6), COL265 CHAR(6),
COL266 CHAR(6), COL267 CHAR(6), COL268 CHAR(6), COL269 CHAR(6), COL270 CHAR(6),
COL271 CHAR(6), COL272 CHAR(6), COL273 CHAR(6), COL274 CHAR(6), COL275 CHAR(6),
COL276 CHAR(6), COL277 CHAR(6), COL278 CHAR(6), COL279 CHAR(6), COL280 CHAR(6),
COL281 CHAR(6), COL282 CHAR(6), COL283 CHAR(6), COL284 CHAR(6), COL285 CHAR(6),
COL286 CHAR(6), COL287 CHAR(6), COL288 CHAR(6), COL289 CHAR(6), COL290 CHAR(6),
COL291 CHAR(6), COL292 CHAR(6), COL293 CHAR(6), COL294 CHAR(6), COL295 CHAR(6),
COL296 CHAR(6), COL297 CHAR(6), COL298 CHAR(6), COL299 CHAR(6), COL300 CHAR(6),
COL301 CHAR(6), COL302 CHAR(6), COL303 CHAR(6), COL304 CHAR(6), COL305 CHAR(6),
COL306 CHAR(6), COL307 CHAR(6), COL308 CHAR(6), COL309 CHAR(6), COL310 CHAR(6),
COL311 CHAR(6), COL312 CHAR(6), COL313 CHAR(6), COL314 CHAR(6), COL315 CHAR(6),
COL316 CHAR(6), COL317 CHAR(6), COL318 CHAR(6), COL319 CHAR(6), COL320 CHAR(6),
COL321 CHAR(6), COL322 CHAR(6), COL323 CHAR(6), COL324 CHAR(6), COL325 CHAR(6),
COL326 CHAR(6), COL327 CHAR(6), COL328 CHAR(6), COL329 CHAR(6), COL330 CHAR(6),
COL331 CHAR(6), COL332 CHAR(6), COL333 CHAR(6), COL334 CHAR(6), COL335 CHAR(6),
COL336 CHAR(6), COL337 CHAR(6), COL338 CHAR(6), COL339 CHAR(6), COL340 CHAR(6),
COL341 CHAR(6), COL342 CHAR(6), COL343 CHAR(6), COL344 CHAR(6), COL345 CHAR(6),
COL346 CHAR(6), COL347 CHAR(6), COL348 CHAR(6), COL349 CHAR(6), COL350 CHAR(6),
COL351 CHAR(6), COL352 CHAR(6), COL353 CHAR(6), COL354 CHAR(6), COL355 CHAR(6),
COL356 CHAR(6), COL357 CHAR(6), COL358 CHAR(6), COL359 CHAR(6), COL360 CHAR(6),
COL361 CHAR(6), COL362 CHAR(6), COL363 CHAR(6), COL364 CHAR(6), COL365 CHAR(6),
COL366 CHAR(6), COL367 CHAR(6), COL368 CHAR(6), COL369 CHAR(6), COL370 CHAR(6),
COL371 CHAR(6), COL372 CHAR(6), COL373 CHAR(6), COL374 CHAR(6), COL375 CHAR(6),
COL376 CHAR(6), COL377 CHAR(6), COL378 CHAR(6), COL379 CHAR(6), COL380 CHAR(6),
COL381 CHAR(6), COL382 CHAR(6), COL383 CHAR(6), COL384 CHAR(6), COL385 CHAR(6),
COL386 CHAR(6), COL387 CHAR(6), COL388 CHAR(6), COL389 CHAR(6), COL390 CHAR(6),
COL391 CHAR(6), COL392 CHAR(6), COL393 CHAR(6), COL394 CHAR(6), COL395 CHAR(6),
COL396 CHAR(6), COL397 CHAR(6), COL398 CHAR(6), COL399 CHAR(6), COL400 CHAR(6),
COL401 CHAR(6), COL402 CHAR(6), COL403 CHAR(6), COL404 CHAR(6), COL405 CHAR(6),
COL406 CHAR(6), COL407 CHAR(6), COL408 CHAR(6), COL409 CHAR(6), COL410 CHAR(6),
COL411 CHAR(6), COL412 CHAR(6), COL413 CHAR(6), COL414 CHAR(6), COL415 CHAR(6),
COL416 CHAR(6), COL417 CHAR(6), COL418 CHAR(6), COL419 CHAR(6), COL420 CHAR(6),
COL421 CHAR(6), COL422 CHAR(6), COL423 CHAR(6), COL424 CHAR(6), COL425 CHAR(6),
COL426 CHAR(6), COL427 CHAR(6), COL428 CHAR(6), COL429 CHAR(6), COL430 CHAR(6),
COL431 CHAR(6), COL432 CHAR(6), COL433 CHAR(6), COL434 CHAR(6), COL435 CHAR(6),
COL436 CHAR(6), COL437 CHAR(6), COL438 CHAR(6), COL439 CHAR(6), COL440 CHAR(6),
COL441 CHAR(6), COL442 CHAR(6), COL443 CHAR(6), COL444 CHAR(6), COL445 CHAR(6),
COL446 CHAR(6), COL447 CHAR(6), COL448 CHAR(6), COL449 CHAR(6), COL450 CHAR(6),
COL451 CHAR(6), COL452 CHAR(6), COL453 CHAR(6), COL454 CHAR(6), COL455 CHAR(6),
COL456 CHAR(6), COL457 CHAR(6), COL458 CHAR(6), COL459 CHAR(6), COL460 CHAR(6),
COL461 CHAR(6), COL462 CHAR(6), COL463 CHAR(6), COL464 CHAR(6), COL465 CHAR(6),
COL466 CHAR(6), COL467 CHAR(6), COL468 CHAR(6), COL469 CHAR(6), COL470 CHAR(6),
COL471 CHAR(6), COL472 CHAR(6), COL473 CHAR(6), COL474 CHAR(6), COL475 CHAR(6),
COL476 CHAR(6), COL477 CHAR(6), COL478 CHAR(6), COL479 CHAR(6), COL480 CHAR(6),
COL481 CHAR(6), COL482 CHAR(6), COL483 CHAR(6), COL484 CHAR(6), COL485 CHAR(6),
COL486 CHAR(6), COL487 CHAR(6), COL488 CHAR(6), COL489 CHAR(6), COL490 CHAR(6),
COL491 CHAR(6), COL492 CHAR(6), COL493 CHAR(6), COL494 CHAR(6), COL495 CHAR(6),
COL496 CHAR(6), COL497 CHAR(6), COL498 CHAR(6), COL499 CHAR(6), COL500 CHAR(6),
COL501 CHAR(6), COL502 CHAR(6), COL503 CHAR(6), COL504 CHAR(6), COL505 CHAR(6),
COL506 CHAR(6), COL507 CHAR(6), COL508 CHAR(6), COL509 CHAR(6), COL510 CHAR(6),
COL511 CHAR(6), COL512 CHAR(6), COL513 CHAR(6), COL514 CHAR(6), COL515 CHAR(6),
COL516 CHAR(6), COL517 CHAR(6), COL518 CHAR(6), COL519 CHAR(6), COL520 CHAR(6),
COL521 CHAR(6), COL522 CHAR(6), COL523 CHAR(6), COL524 CHAR(6), COL525 CHAR(6),
COL526 CHAR(6), COL527 CHAR(6), COL528 CHAR(6), COL529 CHAR(6), COL530 CHAR(6),
COL531 CHAR(6), COL532 CHAR(6), COL533 CHAR(6), COL534 CHAR(6), COL535 CHAR(6),
COL536 CHAR(6), COL537 CHAR(6), COL538 CHAR(6), COL539 CHAR(6), COL540 CHAR(6),
COL541 CHAR(6), COL542 CHAR(6), COL543 CHAR(6), COL544 CHAR(6), COL545 CHAR(6),
COL546 CHAR(6), COL547 CHAR(6), COL548 CHAR(6), COL549 CHAR(6), COL550 CHAR(6),
COL551 CHAR(6), COL552 CHAR(6), COL553 CHAR(6), COL554 CHAR(6), COL555 CHAR(6),
COL556 CHAR(6), COL557 CHAR(6), COL558 CHAR(6), COL559 CHAR(6), COL560 CHAR(6),
COL561 CHAR(6), COL562 CHAR(6), COL563 CHAR(6), COL564 CHAR(6), COL565 CHAR(6),
COL566 CHAR(6), COL567 CHAR(6), COL568 CHAR(6), COL569 CHAR(6), COL570 CHAR(6),
COL571 CHAR(6), COL572 CHAR(6), COL573 CHAR(6), COL574 CHAR(6), COL575 CHAR(6),
COL576 CHAR(6), COL577 CHAR(6), COL578 CHAR(6), COL579 CHAR(6), COL580 CHAR(6),
COL581 CHAR(6), COL582 CHAR(6), COL583 CHAR(6), COL584 CHAR(6), COL585 CHAR(6),

COL586 CHAR(6), COL587 CHAR(6), COL588 CHAR(6), COL589 CHAR(6), COL590 CHAR(6),
COL591 CHAR(6), COL592 CHAR(6), COL593 CHAR(6), COL594 CHAR(6), COL595 CHAR(6),
COL596 CHAR(6), COL597 CHAR(6), COL598 CHAR(6), COL599 CHAR(6), COL600 CHAR(6),
COL601 CHAR(6), COL602 CHAR(6), COL603 CHAR(6), COL604 CHAR(6), COL605 CHAR(6),
COL606 CHAR(6), COL607 CHAR(6), COL608 CHAR(6), COL609 CHAR(6), COL610 CHAR(6),
COL611 CHAR(6), COL612 CHAR(6), COL613 CHAR(6), COL614 CHAR(6), COL615 CHAR(6),
COL616 CHAR(6), COL617 CHAR(6), COL618 CHAR(6), COL619 CHAR(6), COL620 CHAR(6),
COL621 CHAR(6), COL622 CHAR(6), COL623 CHAR(6), COL624 CHAR(6), COL625 CHAR(6),
COL626 CHAR(6), COL627 CHAR(6), COL628 CHAR(6), COL629 CHAR(6), COL630 CHAR(6),
COL631 CHAR(6), COL632 CHAR(6), COL633 CHAR(6), COL634 CHAR(6), COL635 CHAR(6),
COL636 CHAR(6), COL637 CHAR(6), COL638 CHAR(6), COL639 CHAR(6), COL640 CHAR(6),
COL641 CHAR(6), COL642 CHAR(6), COL643 CHAR(6), COL644 CHAR(6), COL645 CHAR(6),
COL646 CHAR(6), COL647 CHAR(6), COL648 CHAR(6), COL649 CHAR(6), COL650 CHAR(6),
COL651 CHAR(6), COL652 CHAR(6), COL653 CHAR(6), COL654 CHAR(6), COL655 CHAR(6),
COL656 CHAR(6), COL657 CHAR(6), COL658 CHAR(6), COL659 CHAR(6), COL660 CHAR(6),
COL661 CHAR(6), COL662 CHAR(6), COL663 CHAR(6), COL664 CHAR(6), COL665 CHAR(6),
COL666 CHAR(6), COL667 CHAR(6), COL668 CHAR(6), COL669 CHAR(6), COL670 CHAR(6),
COL671 CHAR(6), COL672 CHAR(6), COL673 CHAR(6), COL674 CHAR(6), COL675 CHAR(6),
COL676 CHAR(6), COL677 CHAR(6), COL678 CHAR(6), COL679 CHAR(6), COL680 CHAR(6),
COL681 CHAR(6), COL682 CHAR(6), COL683 CHAR(6), COL684 CHAR(6), COL685 CHAR(6),
COL686 CHAR(6), COL687 CHAR(6), COL688 CHAR(6), COL689 CHAR(6), COL690 CHAR(6),
COL691 CHAR(6), COL692 CHAR(6), COL693 CHAR(6), COL694 CHAR(6), COL695 CHAR(6),
COL696 CHAR(6), COL697 CHAR(6), COL698 CHAR(6), COL699 CHAR(6), COL700 CHAR(6),
COL701 CHAR(6), COL702 CHAR(6), COL703 CHAR(6), COL704 CHAR(6), COL705 CHAR(6),
COL706 CHAR(6), COL707 CHAR(6), COL708 CHAR(6), COL709 CHAR(6), COL710 CHAR(6),
COL711 CHAR(6), COL712 CHAR(6), COL713 CHAR(6), COL714 CHAR(6), COL715 CHAR(6),
COL716 CHAR(6), COL717 CHAR(6), COL718 CHAR(6), COL719 CHAR(6), COL720 CHAR(6),
COL721 CHAR(6), COL722 CHAR(6), COL723 CHAR(6), COL724 CHAR(6), COL725 CHAR(6),
COL726 CHAR(6), COL727 CHAR(6), COL728 CHAR(6), COL729 CHAR(6), COL730 CHAR(6),
COL731 CHAR(6), COL732 CHAR(6), COL733 CHAR(6), COL734 CHAR(6), COL735 CHAR(6),
COL736 CHAR(6), COL737 CHAR(6), COL738 CHAR(6), COL739 CHAR(6), COL740 CHAR(6),
COL741 CHAR(6), COL742 CHAR(6), COL743 CHAR(6), COL744 CHAR(6), COL745 CHAR(6),
COL746 CHAR(6), COL747 CHAR(6), COL748 CHAR(6), COL749 CHAR(6), COL750 CHAR(6),
COL751 CHAR(6), COL752 CHAR(6), COL753 CHAR(6), COL754 CHAR(6), COL755 CHAR(6),
COL756 CHAR(6), COL757 CHAR(6), COL758 CHAR(6), COL759 CHAR(6), COL760 CHAR(6),
COL761 CHAR(6), COL762 CHAR(6), COL763 CHAR(6), COL764 CHAR(6), COL765 CHAR(6),
COL766 CHAR(6), COL767 CHAR(6), COL768 CHAR(6), COL769 CHAR(6), COL770 CHAR(6),
COL771 CHAR(6), COL772 CHAR(6), COL773 CHAR(6), COL774 CHAR(6), COL775 CHAR(6),
COL776 CHAR(6), COL777 CHAR(6), COL778 CHAR(6), COL779 CHAR(6), COL780 CHAR(6),
COL781 CHAR(6), COL782 CHAR(6), COL783 CHAR(6), COL784 CHAR(6), COL785 CHAR(6),
COL786 CHAR(6), COL787 CHAR(6), COL788 CHAR(6), COL789 CHAR(6), COL790 CHAR(6),
COL791 CHAR(6), COL792 CHAR(6), COL793 CHAR(6), COL794 CHAR(6), COL795 CHAR(6),
COL796 CHAR(6), COL797 CHAR(6), COL798 CHAR(6), COL799 CHAR(6), COL800 CHAR(6),
COL801 CHAR(6), COL802 CHAR(6), COL803 CHAR(6), COL804 CHAR(6), COL805 CHAR(6),
COL806 CHAR(6), COL807 CHAR(6), COL808 CHAR(6), COL809 CHAR(6), COL810 CHAR(6),
COL811 CHAR(6), COL812 CHAR(6), COL813 CHAR(6), COL814 CHAR(6), COL815 CHAR(6),
COL816 CHAR(6), COL817 CHAR(6), COL818 CHAR(6), COL819 CHAR(6), COL820 CHAR(6),
COL821 CHAR(6), COL822 CHAR(6), COL823 CHAR(6), COL824 CHAR(6), COL825 CHAR(6),
COL826 CHAR(6), COL827 CHAR(6), COL828 CHAR(6), COL829 CHAR(6), COL830 CHAR(6),
COL831 CHAR(6), COL832 CHAR(6), COL833 CHAR(6), COL834 CHAR(6), COL835 CHAR(6),
COL836 CHAR(6), COL837 CHAR(6), COL838 CHAR(6), COL839 CHAR(6), COL840 CHAR(6),
COL841 CHAR(6), COL842 CHAR(6), COL843 CHAR(6), COL844 CHAR(6), COL845 CHAR(6),
COL846 CHAR(6), COL847 CHAR(6), COL848 CHAR(6), COL849 CHAR(6), COL850 CHAR(6),
COL851 CHAR(6), COL852 CHAR(6), COL853 CHAR(6), COL854 CHAR(6), COL855 CHAR(6),
COL856 CHAR(6), COL857 CHAR(6), COL858 CHAR(6), COL859 CHAR(6), COL860 CHAR(6),
COL861 CHAR(6), COL862 CHAR(6), COL863 CHAR(6), COL864 CHAR(6), COL865 CHAR(6),
COL866 CHAR(6), COL867 CHAR(6), COL868 CHAR(6), COL869 CHAR(6), COL870 CHAR(6),
COL871 CHAR(6), COL872 CHAR(6), COL873 CHAR(6), COL874 CHAR(6), COL875 CHAR(6),
COL876 CHAR(6), COL877 CHAR(6), COL878 CHAR(6), COL879 CHAR(6), COL880 CHAR(6),
COL881 CHAR(6), COL882 CHAR(6), COL883 CHAR(6), COL884 CHAR(6), COL885 CHAR(6),
COL886 CHAR(6), COL887 CHAR(6), COL888 CHAR(6), COL889 CHAR(6), COL890 CHAR(6),
COL891 CHAR(6), COL892 CHAR(6), COL893 CHAR(6), COL894 CHAR(6), COL895 CHAR(6),
COL896 CHAR(6), COL897 CHAR(6), COL898 CHAR(6), COL899 CHAR(6), COL900 CHAR(6),
COL901 CHAR(6), COL902 CHAR(6), COL903 CHAR(6), COL904 CHAR(6), COL905 CHAR(6),
COL906 CHAR(6), COL907 CHAR(6), COL908 CHAR(6), COL909 CHAR(6), COL910 CHAR(6),
COL911 CHAR(6), COL912 CHAR(6), COL913 CHAR(6), COL914 CHAR(6), COL915 CHAR(6),
COL916 CHAR(6), COL917 CHAR(6), COL918 CHAR(6), COL919 CHAR(6), COL920 CHAR(6),
COL921 CHAR(6), COL922 CHAR(6), COL923 CHAR(6), COL924 CHAR(6), COL925 CHAR(6),
COL926 CHAR(6), COL927 CHAR(6), COL928 CHAR(6), COL929 CHAR(6), COL930 CHAR(6),
COL931 CHAR(6), COL932 CHAR(6), COL933 CHAR(6), COL934 CHAR(6), COL935 CHAR(6),
COL936 CHAR(6), COL937 CHAR(6), COL938 CHAR(6), COL939 CHAR(6), COL940 CHAR(6),
COL941 CHAR(6), COL942 CHAR(6), COL943 CHAR(6), COL944 CHAR(6), COL945 CHAR(6),
COL946 CHAR(6), COL947 CHAR(6), COL948 CHAR(6), COL949 CHAR(6), COL950 CHAR(6),
COL951 CHAR(6), COL952 CHAR(6), COL953 CHAR(6), COL954 CHAR(6), COL955 CHAR(6),
COL956 CHAR(6), COL957 CHAR(6), COL958 CHAR(6), COL959 CHAR(6), COL960 CHAR(6),
COL961 CHAR(6), COL962 CHAR(6), COL963 CHAR(6), COL964 CHAR(6), COL965 CHAR(6),
COL966 CHAR(6), COL967 CHAR(6), COL968 CHAR(6), COL969 CHAR(6), COL970 CHAR(6),
COL971 CHAR(6), COL972 CHAR(6), COL973 CHAR(6), COL974 CHAR(6), COL975 CHAR(6),
COL976 CHAR(6), COL977 CHAR(6), COL978 CHAR(6), COL979 CHAR(6), COL980 CHAR(6),
COL981 CHAR(6), COL982 CHAR(6), COL983 CHAR(6), COL984 CHAR(6), COL985 CHAR(6),
COL986 CHAR(6), COL987 CHAR(6), COL988 CHAR(6), COL989 CHAR(6), COL990 CHAR(6),
COL991 CHAR(6), COL992 CHAR(6), COL993 CHAR(6), COL994 CHAR(6), COL995 CHAR(6),
COL996 CHAR(6), COL997 CHAR(6), COL998 CHAR(6), COL999 CHAR(6), COL1000 CHAR(6),
COL1001 CHAR(6), COL1002 CHAR(6), COL1003 CHAR(6), COL1004 CHAR(6), COL1005 CHAR(6),
COL1006 CHAR(6), COL1007 CHAR(6), COL1008 CHAR(6), COL1009 CHAR(6), COL1010 CHAR(6),
COL1011 CHAR(6), COL1012 CHAR(6), COL1013 CHAR(6), COL1014 CHAR(6), COL1015 CHAR(6),
COL1016 CHAR(6), COL1017 CHAR(6), COL1018 CHAR(6), COL1019 CHAR(6), COL1020 CHAR(6),
COL1021 CHAR(6), COL1022 CHAR(6), COL1023 CHAR(6));
end;
</CallString>
<Error>
<ErrorCode>-1114</ErrorCode>
<ErrorMessage>[-1114] (at 75): Communication packet too small</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc3 (out  cur_dat date) as
begin
    cur_dat = date;
    create table temp.tab3 (col1 int check col1 in ('a', 'b'), primary key (col1));
end;
</CallString>
<Error>
<ErrorCode>-3016</ErrorCode>
<ErrorMessage>[-3016] (at 124): Invalid numeric constant</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc4 (out  cur_dat date) as
begin
    cur_dat = date;
    create table temp.tab4 (col1 int, col2 int default 'a');
end;
</CallString>
<Error>
<ErrorCode>-3016</ErrorCode>
<ErrorMessage>[-3016] (at 127): Invalid numeric constant</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc5 (out  cur_dat date) as
begin
    cur_dat = date;
    create table temp.tab5 (col1 int, col2 int default 4, col3 numeric default 4003
                                              CHECK (COL3 &gt; 5000));
end;
</CallString>
<Error>
<ErrorCode>-8009</ErrorCode>
<ErrorMessage>[-8009] (at 219): DEFAULT value must be in constraint specification:COL3</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc6 (out  cur_dat date) as
begin
    cur_dat = date;
    create table temp.tab6 (col1 int, col2 int default 4, col3 numeric default 4003
                                              CHECK (COL3 &lt; 5000), col4 int unique);
end;
</CallString>
<Error>
<ErrorCode>-7064</ErrorCode>
<ErrorMessage>[-7064] (at 231): Feature not allowed in temp table definition</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc7 (out  cur_dat date) as
begin
    cur_dat = date;
    create table temp.tab7 (col1 int, col2 int default 4, col3 numeric default 4003
                                              CHECK (COL3 &lt; 5000), col4 int not null null);
end;
</CallString>
<Error>
<ErrorCode>-3008</ErrorCode>
<ErrorMessage>[-3008] (at 240): Invalid keyword or missing delimiter</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc8 (out  cur_dat date) as
begin
    cur_dat = date;
    create table temp.tab8 (COL1 CHARACTER(1024) PRIMARY KEY, col2 int default 4, col3 numeric default 4003
                                              CHECK (COL3 &lt; 5000), col4 int not null);
end;
</CallString>
<Error>
<ErrorCode>-2001</ErrorCode>
<ErrorMessage>[-2001] (at 99): Key too long:COL1</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc9 (out  cur_dat date) as
begin
    cur_dat = date;
    create table temp.tab9 (COL1 long PRIMARY KEY, col2 int default 4, col3 numeric default 4003
                                              CHECK (COL3 &lt; 5000), col4 int not null);
end;
</CallString>
<Error>
<ErrorCode>-7032</ErrorCode>
<ErrorMessage>[-7032] (at 109): SQL statement not allowed for column of data type LONG</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc10 (out  cur_dat date) as
begin
    cur_dat = date;
    create table temp.tab10 (COL1 numeric(39), col2 int default 4, col3 numeric default 4003
                                              CHECK (COL3 &lt; 5000), col4 int not null);
end;
</CallString>
<Error>
<ErrorCode>-3020</ErrorCode>
<ErrorMessage>[-3020] (at 114): Invalid length for this data type:COL1</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>
select owner, dbprocname, definition, comment from dbprocedures where dbprocname like 'PROC%'</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>OWNER</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DBPROCNAME</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DEFINITION</ColumnName>
<ColumnType>LONG</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>COMMENT</ColumnName>
<ColumnType>LONG</ColumnType>
</ColumnDefinition>
</ResultSet>
</Statement>
</Run>
</Test>
<Test Exclude="(;;oracle)" Number="12" Responsible="Daub, Jan Michael" TestType="positive">
<Comment>* call_statements *

creating 10 procedures
each of them has an inout parameter and receives a value when it is called

the first calls the second, the second the third, ... 
and the ninth calls the tenth which adds 660 days to the received date and gives it back
</Comment>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc10 (inout  curr_dat date) as
    curr_dat = adddate(curr_dat, 660);
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc9 (inout  curr_dat date) as
    call proc10 (:curr_dat);
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc8 (inout  curr_dat date) as
    call proc9 (:curr_dat);
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc7 (inout  curr_dat date) as
    call proc8 (:curr_dat);
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc6 (inout  curr_dat date) as
    call proc7 (:curr_dat);
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc5 (inout  curr_dat date) as
    call proc6 (:curr_dat);
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc4 (inout  curr_dat date) as
    call proc5 (:curr_dat);
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc3 (inout  curr_dat date) as
    call proc4 (:curr_dat);
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc2 (inout  curr_dat date) as
    call proc3 (:curr_dat);
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc1 (out diff int)
as 
    var curr_dat date;
    dat date;
	curr_dat = date;
	dat = curr_dat;
        call proc2 (:dat);
            if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
                diff = datediff(dat, curr_dat);
                    if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call proc1 (?)
</CallString>
<Parameter DataType="INT" InValue="" OutValue="660" ParamType="OUT"/>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc proc10
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc proc9
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc proc8
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc proc7
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc proc6
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc proc5
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc proc4
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc proc3
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc proc2
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc proc1

</CallString>
</Statement>
</CleanUp>
</Test>
<Test Exclude="(;;oracle)" Number="13" Responsible="Daub, Jan Michael" TestType="positive">
<Comment>* drop_table_temp *

creating a table which is going to be deleted by one of the dbprocs;
proc1 is called at first, evaluates the in-parameters and maybe calls another dbproc to perform the drop</Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create table temp.tab1 (col1 int, col2 char(100), col3 boolean)
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
insert into temp.tab1 values (234, 'a', false)
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
insert into temp.tab1 values (043, 'j', true)
</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc2 (in nr int) as
    drop table temp.tab1;
    create table temp.tab1 (col1 int, col2 char(100), col3 boolean);
    insert into temp.tab1 (col2) values ('the last one was dropped by proc2');
    insert into temp.tab1 values (234, 'a', false);
    insert into temp.tab1 values (043, 'j', true);
    if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);

    </CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc3 (in nr int) as
    drop table temp.tab1;
    create table temp.tab1 (col1 int, col2 char(100), col3 boolean);
    insert into temp.tab1 (col2) values ('the last one was dropped by proc3');
    insert into temp.tab1 values (234, 'a', false);
    insert into temp.tab1 values (043, 'j', true);
    if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);


</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc4 (in nr int) as
    drop table temp.tab1;
    create table temp.tab1 (col1 int, col2 char(100), col3 boolean);
    insert into temp.tab1 (col2) values ('the last one was dropped by proc4');
    insert into temp.tab1 values (234, 'a', false);
    insert into temp.tab1 values (043, 'j', true);
    if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
create dbproc proc1 (in nr int, in dr boolean) as
    case
        when dr = true then
                begin
                    case nr
                        when 1 then begin
                                                    drop table temp.tab1;
                                                        create table temp.tab1 (col1 int, col2 char(100), col3 boolean);
                                                        insert into temp.tab1 (col2) values ('the last one was dropped by proc1');
                                                        insert into temp.tab1 values (234, 'a', false);
                                                        insert into temp.tab1 values (043, 'j', true);
                                                        if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
                                               end;
                        when 2 then call proc2 (:nr);
                        when 3 then call proc3 (:nr);
                        when 4 then call proc4 (:nr);
                        else stop (-30303, 'invalid number specified, proc does not exist');
                    end case;
                end;
        when dr = false then stop (-30303, 'OK, we will not drop anything');
        else stop ($RC, $ERRMSG);
     end case;
    
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call proc1 (0, true)
</CallString>
<Error>
<ErrorCode>-30303</ErrorCode>
<ErrorMessage>[-30303]: invalid number specified, proc does not exist</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>
select col1, col2 from temp.tab1
</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>COL1</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>COL2</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>234</Value>
<Value>'a'</Value>
</Row>
<Row>
<Value>43</Value>
<Value>'j'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="true" ignore="false" verify="true">
<CallString>
call proc1 (5, true)
</CallString>
<Error>
<ErrorCode>-30303</ErrorCode>
<ErrorMessage>[-30303]: invalid number specified, proc does not exist</ErrorMessage>
</Error>
</Statement>
<Statement callable="true" ignore="false" verify="true">
<CallString>
call proc1 (99999999999999999999999999999999999999999999999,true)
</CallString>
<Error>
<ErrorCode>-3019</ErrorCode>
<ErrorMessage>[-3019] (at 14): Invalid exponent:99999999999999999999999999999999999999999999999</ErrorMessage>
</Error>
</Statement>
<Statement callable="true" ignore="false" verify="true">
<CallString>
call proc1 (3, trues)
</CallString>
<Error>
<ErrorCode>-8004</ErrorCode>
<ErrorMessage>[-8004] (at 17): Constant must be compatible with column type and length</ErrorMessage>
</Error>
</Statement>
<Statement callable="true" ignore="false" verify="true">
<CallString>
call proc1 (1, false)
</CallString>
<Error>
<ErrorCode>-30303</ErrorCode>
<ErrorMessage>[-30303]: OK, we will not drop anything</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>
select col1, col2 from temp.tab1
</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>COL1</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>COL2</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>234</Value>
<Value>'a'</Value>
</Row>
<Row>
<Value>43</Value>
<Value>'j'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call proc1 (1, true)
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>
select col1, col2 from temp.tab1
</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>COL1</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>COL2</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>NULL</Value>
<Value>'the last one was dropped by proc1'</Value>
</Row>
<Row>
<Value>234</Value>
<Value>'a'</Value>
</Row>
<Row>
<Value>43</Value>
<Value>'j'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call proc1 (2, true)
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>
select col1, col2 from temp.tab1
</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>COL1</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>COL2</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>NULL</Value>
<Value>'the last one was dropped by proc2'</Value>
</Row>
<Row>
<Value>234</Value>
<Value>'a'</Value>
</Row>
<Row>
<Value>43</Value>
<Value>'j'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call proc1 (3, true)
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>
select col1, col2 from temp.tab1
</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>COL1</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>COL2</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>NULL</Value>
<Value>'the last one was dropped by proc3'</Value>
</Row>
<Row>
<Value>234</Value>
<Value>'a'</Value>
</Row>
<Row>
<Value>43</Value>
<Value>'j'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>
call proc1 (4, true)
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>
select col1, col2 from temp.tab1
</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>COL1</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>COL2</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>NULL</Value>
<Value>'the last one was dropped by proc4'</Value>
</Row>
<Row>
<Value>234</Value>
<Value>'a'</Value>
</Row>
<Row>
<Value>43</Value>
<Value>'j'</Value>
</Row>
</ResultSet>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc proc1
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc proc2
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc proc3
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop dbproc proc4
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>
drop table temp.tab1</CallString>
</Statement>
</CleanUp>
</Test>
<Test Exclude="(;;oracle)" Number="14" Responsible="Daub, Jan Michael" TestType="positive">
<Comment>* fetch_statement *

it´s a little encryption tool for character_strings
	fetch is often used in dbproc 'string_builder' 
	and a few times in dbproc 'encrypt'

</Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE TABLE ARC (ENC CHAR)</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc filltab as
INSERT INTO user.ARC VALUES ('a');
INSERT INTO user.arc VALUES ('b');
INSERT INTO user.arc VALUES ('c');
 INSERT INTO user.arc VALUES ('d');
 INSERT INTO user.arc VALUES ('e');
 INSERT INTO user.arc VALUES ('f');
 INSERT INTO user.arc VALUES ('g');
 INSERT INTO user.arc VALUES ('h');
 INSERT INTO user.arc VALUES ('i');
 INSERT INTO user.arc VALUES ('j');
 INSERT INTO user.arc VALUES ('k');
 INSERT INTO user.arc VALUES ('l');
 INSERT INTO user.arc VALUES ('m');
 INSERT INTO user.arc VALUES ('n');
 INSERT INTO user.arc VALUES ('o');
 INSERT INTO user.arc VALUES ('p');
 INSERT INTO user.arc VALUES ('q');
 INSERT INTO user.arc VALUES ('r');
 INSERT INTO user.arc VALUES ('s');
 INSERT INTO user.arc VALUES ('t');
 INSERT INTO user.arc VALUES ('u');
 INSERT INTO user.arc VALUES ('v');
 INSERT INTO user.arc VALUES ('w');
 INSERT INTO user.arc VALUES ('x');
 INSERT INTO user.arc VALUES ('y');
 INSERT INTO user.arc VALUES ('z');</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call filltab</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create table evaltab (inserted char (50), code int, result char (50))</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC string_builder (OUT STRINGB CHAR(50), IN CODE INT)  
AS      
VAR       COUNTER INT;      
COUNTED INT;      
STRINGA CHAR;       
COUNTER = 0;      
STRINGB = '';  
if code &lt; 0 then set code = code + 26;
SELECT * FROM user.ARC;  
WHILE COUNTER &lt; 26 DO BEGIN      
COUNTED = CODE + COUNTER + 1;          
CASE               
WHEN COUNTED &gt;= 0 and counted &lt;= 26 THEN FETCH POS (:COUNTED) INTO :STRINGA;             
WHEN COUNTED = 27 THEN FETCH FIRST INTO :STRINGA;              
WHEN COUNTED &gt; 27 THEN FETCH INTO :STRINGA;          
END CASE;      
STRINGB = STRINGB &amp; STRINGA;      
COUNTER = COUNTER + 1;  
END;</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc encrypt (in stringo char (50), in code int, out stringtra char(50) ) 
as
    var a char(50);    
        b char(50);
    if code not between -26 and 26 then stop (-30303, 'please specify a code between -26 and +26');    
    
    call string_builder (:a, 0); 
    call string_builder (:b, :code);
    
        
    select translate(:stringo, :a, :b) from sysdba.dual;
        fetch into :stringtra;
        
    
    select upper (:a) from sysdba.dual;
        fetch into :a;
    select upper (:b) from sysdba.dual;
        fetch into :b;
        
    
    select translate(:stringtra, :a, :b) from sysdba.dual;
        fetch into :stringtra;</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call encrypt ('n E a P e L ', 4, ?)</CallString>
<Parameter DataType="CHAR(50)" InValue="" OutValue="r I e T i P" ParamType="OUT"/>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call encrypt ('hallO', -1, ?)</CallString>
<Parameter DataType="CHAR(50)" InValue="" OutValue="gzkkN" ParamType="OUT"/>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc eval (in testa char (50), in a int, in b int, in c int, in d int)
   as
   var testb char (50);
call encrypt (:testa, :a, :testb);
if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
    insert into user.evaltab values (:testa, :a, :testb);
call encrypt (:testb, :b, :testa);
if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
    insert into user.evaltab values (:testb, :b, :testa);
call encrypt (:testa, :c, :testb);
if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
    insert into user.evaltab values (:testa, :c, :testb);
call encrypt (:testb, :d, :testa);
if $RC &lt;&gt; 0 then stop ($RC, $ERRMSG);
    insert into user.evaltab values (:testb, :d, :testa);</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call eval ('SaP AG', -15, 8, 23, -16)</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>select * from evaltab</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>INSERTED</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>CODE</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>RESULT</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>'SaP AG'</Value>
<Value>-15</Value>
<Value>'DlA LR'</Value>
</Row>
<Row>
<Value>'DlA LR'</Value>
<Value>8</Value>
<Value>'LtI TZ'</Value>
</Row>
<Row>
<Value>'LtI TZ'</Value>
<Value>23</Value>
<Value>'IqF QW'</Value>
</Row>
<Row>
<Value>'IqF QW'</Value>
<Value>-16</Value>
<Value>'SaP AG'</Value>
</Row>
</ResultSet>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop table evaltab</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop table arc</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc filltab</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc eval</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc encrypt</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc string_builder</CallString>
</Statement>
</CleanUp>
</Test>
<Test Exclude="(;;oracle)" Number="15" Responsible="Daub, Jan Michael" TestType="positive">
<Comment>a test due to PTS 1117963

a drop_table_temp and a create_table_temp statement
are included together in a dbproc but not in a sequence of 'begin ... end'</Comment>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc proc_dat as
	
      VAR curr_dat date;
	Drop table temp.t1;
	  create table temp.t1 (s1 char(255), dat date);
	    insert into temp.t1 values ('Once there was ...', '2002-09-27');</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call proc_dat</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>select * from temp.t1</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>S1</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DAT</ColumnName>
<ColumnType>DATE</ColumnType>
</ColumnDefinition>
<Row>
<Value>'Once there was ...'</Value>
<Value>'2002-09-27'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop table temp.t1</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create table temp.t1 (a varchar, b int, c numeric, d char (1024))</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>insert into temp.t1 values ('a', 2134, 0349, 'Who has an imagination ...')</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>insert into temp.t1 values ('b', 267346, 769, '... how things will be?')</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>select * from temp.t1</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>A</ColumnName>
<ColumnType>VARCHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>B</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>C</ColumnName>
<ColumnType>INT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>D</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>'a'</Value>
<Value>2134</Value>
<Value>349</Value>
<Value>'Who has an imagination ...'</Value>
</Row>
<Row>
<Value>'b'</Value>
<Value>267346</Value>
<Value>769</Value>
<Value>'... how things will be?'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call proc_dat</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>select * from temp.t1</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>S1</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DAT</ColumnName>
<ColumnType>DATE</ColumnType>
</ColumnDefinition>
<Row>
<Value>'Once there was ...'</Value>
<Value>'2002-09-27'</Value>
</Row>
</ResultSet>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop table temp.t1</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc proc_dat</CallString>
</Statement>
</CleanUp>
</Test>
<Test Exclude="" Number="16" Responsible="Daub, Jan Michael" TestType="positive">
<Comment>verifying that fields are initialized completely
this test has been written due to a known and fixed bug</Comment>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc testproc1 (in a int)
as 
   stop (-30001, a);</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc testproc1</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc testproc1 (in a int)
as 
   stop (-30001, a);</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="true">
<CallString>call testproc1 (-3)</CallString>
<Error>
<ErrorCode>-30001</ErrorCode>
<ErrorMessage>[-30001]: -3</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc testproc1 (in a int)
as 
   stop (-30001, a);</CallString>
<Error>
<ErrorCode>-6006</ErrorCode>
<ErrorMessage>[-6006]: Duplicate name:TESTPROC1</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc testproc1</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc testproc1 (in a int)
as 
   stop (-30001, a);</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="true">
<CallString>call testproc1 (-3)</CallString>
<Error>
<ErrorCode>-30001</ErrorCode>
<ErrorMessage>[-30001]: -3</ErrorMessage>
</Error>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc testproc1</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc testproc1 (in a int)
as 
   stop (-30001, a);</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="true">
<CallString>call testproc1 (-3)</CallString>
<Error>
<ErrorCode>-30001</ErrorCode>
<ErrorMessage>[-30001]: -3</ErrorMessage>
</Error>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc testproc1</CallString>
</Statement>
</CleanUp>
</Test>
<Test Exclude="(;;oracle)" Number="17" Responsible="Daub, Jan Michael" TestType="positive">
<Comment>two levels in a case statement;
variants contained in the run_statements (see 'create dbproc prio_cases'):

level 1 &gt; level 2 ::  cs - case_statement  ::  scs - searched_case_statement

 cs &gt;  cs 
scs &gt;  cs 
scs &gt; scs 
 cs &gt; scs 

</Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>create table meetings (nr int unique, dat date, prio1 smallint, prio2 smallint, prio3 smallint, prio char (10), descr char (40))</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc insert_meeting (in dat date, in prio1 smallint, in prio2 smallint, in prio3 smallint, in descr char(40)) as 
var l_nr int;
nr int;
nr = 0;
l_nr = 0;
select nr from user.meetings;
   WHILE $RC = 0 DO BEGIN
      FETCH INTO :nr;
      if  ($RC &lt;&gt; 100) and (nr &gt; l_nr) then  l_nr = nr;
      if  $RC = 100 then break;
   end;
nr = nr + 1;
insert into user.meetings (nr, dat, prio1, prio2, prio3, descr) values (:nr, :dat, :prio1, :prio2, :prio3, :descr);
 if $RC = 250 THEN STOP ($RC, 'problem in generating numbers');
  if $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG);</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call insert_meeting('2002-02-02',1,3,5,'interview')</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call insert_meeting('2002-04-12',2,1,4,'sports')</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call insert_meeting('2002-03-30',3,3,2,'breakfast at ...')</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call insert_meeting('2002-06-25',5,4,5,'learning hour')</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call insert_meeting('2002-12-05',1,1,1,'camp')</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call insert_meeting('2002-06-07',3,4,5,'new project')</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call insert_meeting('2002-03-08',6,3,5,'meeting with Smith')</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc prio_cases1 as
	var p1 smallint ;
	p2 smallint ;
	p3 smallint ; 
	prio_descr char (10);
	set p1 = 0;                
	select prio1, prio2, prio3 from user.meetings;
	
	   while $RC &lt;&gt; 100 DO BEGIN
		fetch into :p1,:p2,:p3;
		if $RC = 100 THEN BREAK;

		if $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG);
		
		case p1
		    when 3 then 
			begin
			  case p2
			      when 3 then set prio_descr = 'extra';
			      else set prio_descr = 'low';
			  end case;
			end;
		    when 2 then set prio_descr = 'middle';
		    else set prio_descr = 'lowest';
	        end case;
	    	update user.meetings set prio = :prio_descr where prio1 = :p1 and prio2 = :p2 and prio3 = :p3; 
	   end;</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call prio_cases1</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>select * from meetings</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>NR</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DAT</ColumnName>
<ColumnType>DATE</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO1</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO2</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO3</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DESCR</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>1</Value>
<Value>'2002-02-02'</Value>
<Value>1</Value>
<Value>3</Value>
<Value>5</Value>
<Value>'lowest'</Value>
<Value>'interview'</Value>
</Row>
<Row>
<Value>2</Value>
<Value>'2002-04-12'</Value>
<Value>2</Value>
<Value>1</Value>
<Value>4</Value>
<Value>'middle'</Value>
<Value>'sports'</Value>
</Row>
<Row>
<Value>3</Value>
<Value>'2002-03-30'</Value>
<Value>3</Value>
<Value>3</Value>
<Value>2</Value>
<Value>'extra'</Value>
<Value>'breakfast at ...'</Value>
</Row>
<Row>
<Value>4</Value>
<Value>'2002-06-25'</Value>
<Value>5</Value>
<Value>4</Value>
<Value>5</Value>
<Value>'lowest'</Value>
<Value>'learning hour'</Value>
</Row>
<Row>
<Value>5</Value>
<Value>'2002-12-05'</Value>
<Value>1</Value>
<Value>1</Value>
<Value>1</Value>
<Value>'lowest'</Value>
<Value>'camp'</Value>
</Row>
<Row>
<Value>6</Value>
<Value>'2002-06-07'</Value>
<Value>3</Value>
<Value>4</Value>
<Value>5</Value>
<Value>'low'</Value>
<Value>'new project'</Value>
</Row>
<Row>
<Value>7</Value>
<Value>'2002-03-08'</Value>
<Value>6</Value>
<Value>3</Value>
<Value>5</Value>
<Value>'lowest'</Value>
<Value>'meeting with Smith'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>update meetings set prio = null</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc prio_cases2 as
	var p1 smallint ;
	p2 smallint ;
	p3 smallint ; 
	prio_descr char (10);
	set p1 = 0;                
	select prio1, prio2, prio3 from user.meetings;
	   while $RC &lt;&gt; 100 DO BEGIN
		fetch into :p1,:p2,:p3;
		 if $RC = 100 THEN BREAK;

		if $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG);
		case 
		    when p1 = 3 then begin
			case  p2
			    when 3 then set prio_descr = 'extra';
			    else set prio_descr = 'low';
			end case;
			end;
		    when p1 = 2 then set prio_descr = 'middle';
		    else set prio_descr = 'lowest';
		end case;
		update user.meetings set prio = :prio_descr where prio1 = :p1 and prio2 = :p2 and prio3 = :p3; 
	    end;</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call prio_cases2</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>select * from meetings</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>NR</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DAT</ColumnName>
<ColumnType>DATE</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO1</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO2</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO3</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DESCR</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>1</Value>
<Value>'2002-02-02'</Value>
<Value>1</Value>
<Value>3</Value>
<Value>5</Value>
<Value>'lowest'</Value>
<Value>'interview'</Value>
</Row>
<Row>
<Value>2</Value>
<Value>'2002-04-12'</Value>
<Value>2</Value>
<Value>1</Value>
<Value>4</Value>
<Value>'middle'</Value>
<Value>'sports'</Value>
</Row>
<Row>
<Value>3</Value>
<Value>'2002-03-30'</Value>
<Value>3</Value>
<Value>3</Value>
<Value>2</Value>
<Value>'extra'</Value>
<Value>'breakfast at ...'</Value>
</Row>
<Row>
<Value>4</Value>
<Value>'2002-06-25'</Value>
<Value>5</Value>
<Value>4</Value>
<Value>5</Value>
<Value>'lowest'</Value>
<Value>'learning hour'</Value>
</Row>
<Row>
<Value>5</Value>
<Value>'2002-12-05'</Value>
<Value>1</Value>
<Value>1</Value>
<Value>1</Value>
<Value>'lowest'</Value>
<Value>'camp'</Value>
</Row>
<Row>
<Value>6</Value>
<Value>'2002-06-07'</Value>
<Value>3</Value>
<Value>4</Value>
<Value>5</Value>
<Value>'low'</Value>
<Value>'new project'</Value>
</Row>
<Row>
<Value>7</Value>
<Value>'2002-03-08'</Value>
<Value>6</Value>
<Value>3</Value>
<Value>5</Value>
<Value>'lowest'</Value>
<Value>'meeting with Smith'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>update meetings set prio = null</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc prio_cases3 as
	var p1 smallint ;
	p2 smallint ;
	p3 smallint ; 
	prio_descr char (10);
	set p1 = 0;                
	select prio1, prio2, prio3 from user.meetings;
	   while $RC &lt;&gt; 100 DO BEGIN
		fetch into :p1,:p2,:p3;
		 if $RC = 100 THEN BREAK;

		if $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG);
		case 
		    when p1 = 3 then begin
			case  
			    when p2 = 3 then set prio_descr = 'extra';
			    else set prio_descr = 'low';
			end case;
			end;
		    when p1 = 2 then set prio_descr = 'middle';
		    else set prio_descr = 'lowest';
		end case;
		update user.meetings set prio = :prio_descr where prio1 = :p1 and prio2 = :p2 and prio3 = :p3; 
	    end;</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call prio_cases3</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>select * from meetings</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>NR</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DAT</ColumnName>
<ColumnType>DATE</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO1</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO2</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO3</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DESCR</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>1</Value>
<Value>'2002-02-02'</Value>
<Value>1</Value>
<Value>3</Value>
<Value>5</Value>
<Value>'lowest'</Value>
<Value>'interview'</Value>
</Row>
<Row>
<Value>2</Value>
<Value>'2002-04-12'</Value>
<Value>2</Value>
<Value>1</Value>
<Value>4</Value>
<Value>'middle'</Value>
<Value>'sports'</Value>
</Row>
<Row>
<Value>3</Value>
<Value>'2002-03-30'</Value>
<Value>3</Value>
<Value>3</Value>
<Value>2</Value>
<Value>'extra'</Value>
<Value>'breakfast at ...'</Value>
</Row>
<Row>
<Value>4</Value>
<Value>'2002-06-25'</Value>
<Value>5</Value>
<Value>4</Value>
<Value>5</Value>
<Value>'lowest'</Value>
<Value>'learning hour'</Value>
</Row>
<Row>
<Value>5</Value>
<Value>'2002-12-05'</Value>
<Value>1</Value>
<Value>1</Value>
<Value>1</Value>
<Value>'lowest'</Value>
<Value>'camp'</Value>
</Row>
<Row>
<Value>6</Value>
<Value>'2002-06-07'</Value>
<Value>3</Value>
<Value>4</Value>
<Value>5</Value>
<Value>'low'</Value>
<Value>'new project'</Value>
</Row>
<Row>
<Value>7</Value>
<Value>'2002-03-08'</Value>
<Value>6</Value>
<Value>3</Value>
<Value>5</Value>
<Value>'lowest'</Value>
<Value>'meeting with Smith'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>update meetings set prio = null</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc prio_cases4 as
	var p1 smallint ;
	p2 smallint ;
	p3 smallint ; 
	prio_descr char (10);
	set p1 = 0;                
	select prio1, prio2, prio3 from user.meetings;
	   while $RC &lt;&gt; 100 DO BEGIN
		fetch into :p1,:p2,:p3;
		 if $RC = 100 THEN BREAK;

		if $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG);
		case p1
		    when 3 then begin
			case  
			    when p2 = 3 then set prio_descr = 'extra';
			    else set prio_descr = 'low';
			end case;
			end;
		    when 2 then set prio_descr = 'middle';
		    else set prio_descr = 'lowest';
		end case;
		update user.meetings set prio = :prio_descr where prio1 = :p1 and prio2 = :p2 and prio3 = :p3; 
	    end;</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call prio_cases4</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>select * from meetings</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>NR</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DAT</ColumnName>
<ColumnType>DATE</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO1</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO2</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO3</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PRIO</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DESCR</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>1</Value>
<Value>'2002-02-02'</Value>
<Value>1</Value>
<Value>3</Value>
<Value>5</Value>
<Value>'lowest'</Value>
<Value>'interview'</Value>
</Row>
<Row>
<Value>2</Value>
<Value>'2002-04-12'</Value>
<Value>2</Value>
<Value>1</Value>
<Value>4</Value>
<Value>'middle'</Value>
<Value>'sports'</Value>
</Row>
<Row>
<Value>3</Value>
<Value>'2002-03-30'</Value>
<Value>3</Value>
<Value>3</Value>
<Value>2</Value>
<Value>'extra'</Value>
<Value>'breakfast at ...'</Value>
</Row>
<Row>
<Value>4</Value>
<Value>'2002-06-25'</Value>
<Value>5</Value>
<Value>4</Value>
<Value>5</Value>
<Value>'lowest'</Value>
<Value>'learning hour'</Value>
</Row>
<Row>
<Value>5</Value>
<Value>'2002-12-05'</Value>
<Value>1</Value>
<Value>1</Value>
<Value>1</Value>
<Value>'lowest'</Value>
<Value>'camp'</Value>
</Row>
<Row>
<Value>6</Value>
<Value>'2002-06-07'</Value>
<Value>3</Value>
<Value>4</Value>
<Value>5</Value>
<Value>'low'</Value>
<Value>'new project'</Value>
</Row>
<Row>
<Value>7</Value>
<Value>'2002-03-08'</Value>
<Value>6</Value>
<Value>3</Value>
<Value>5</Value>
<Value>'lowest'</Value>
<Value>'meeting with Smith'</Value>
</Row>
</ResultSet>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc prio_cases1</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc prio_cases2</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc prio_cases3</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc prio_cases4</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop table meetings</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc insert_meeting</CallString>
</Statement>
</CleanUp>
</Test>
<Test Exclude="(;;oracle)" Number="18" Responsible="Daub, Jan Michael" TestType="positive">
<Comment>verifying that dbproc_parameters are initialized with NULL
</Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE TABLE TAB
(
	TODAY               Boolean,
	NAME               Char (40) ,
	LOCATION               Varchar (40) unique,
	STAND               Date,
	STAND_T               Time,
	AREA      Fixed (5,1),
	EMPLOYEES               Float (16),
	PASSENGERS               Integer,
	CARGO               numeric (7),
	FLIGHTS               real,
	PER_DAY               Smallint,
	ARRIVAL             Timestamp,
            DEPARTURE               Timestamp
)</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC testproc1 (out TODAY BOOLEAN,                             
	OUT NAME CHAR (40),                         
	OUT LOCATION VARCHAR(40),                         
	OUT STAND DATE,                         
	OUT STAND_T TIME,                         
	OUT AREA FIXED(5,1),                         
	OUT EMPLOYEES FLOAT,                         
	OUT PASSENGERS INT,                         
	OUT CARGO NUMERIC(7),                          
	OUT FLIGHTS REAL,                         
	OUT PER_DAY SMALLINT,                         
	OUT ARRIVAL TIMESTAMP,                         
	OUT DEPARTURE TIMESTAMP)                         
AS   
SELECT * FROM USER.TAB;</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC testproc2 (inout TODAY BOOLEAN,                             
	INOUT NAME CHAR (40),                         
	INOUT LOCATION VARCHAR(40),                         
	INOUT STAND DATE,                         
	INOUT STAND_T TIME,                         
	INOUT AREA FIXED(5,1),                         
	INOUT EMPLOYEES FLOAT,                         
	INOUT PASSENGERS INT,                         
	INOUT CARGO NUMERIC(7),                          
	INOUT FLIGHTS REAL,                         
	INOUT PER_DAY SMALLINT,                         
	INOUT ARRIVAL TIMESTAMP,                         
	INOUT DEPARTURE TIMESTAMP)                         
AS   
SELECT * FROM USER.TAB;
   insert into user.tab values (:today, :name, :location, :stand, :stand_t, :area, :employees, :passengers, :cargo, :flights, :per_day, :arrival, :departure);
            if $RC &lt;&gt; 0 then stop (-30002, $ERRMSG);</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc testproc3
as var a boolean;
        b CHAR (40);                         
	c VARCHAR(40);                         
	d DATE;                         
        e TIME;                
	f FIXED(5,1);                         
	g FLOAT;                         
	h INT;                         
	i int;                          
	j REAL;                         
	k SMALLINT;                         
	l TIMESTAMP;                         
	m TIMESTAMP;
            call testproc1 ( :a, :b, :c, :d, :e, :f, :g, :h, :i, :j, :k, :l, :m);
            if $RC &lt;&gt; 0 then stop (-30001, $ERRMSG);
            insert into user.tab values (:a, :b, :c, :d, :e, :f, :g, :h, :i, :j, :k, :l, :m);
            if $RC &lt;&gt; 0 then stop (-30002, $ERRMSG);
            call testproc2 ( :a, :b, :c, :d, :e, :f, :g, :h, :i, :j, :k, :l, :m);
            if $RC &lt;&gt; 0 then stop (-30003, $ERRMSG);
            insert into user.tab values (:a, :b, :c, :d, :e, :f, :g, :h, :i, :j, :k, :l, :m);
            if $RC &lt;&gt; 0 then stop (-30004, $ERRMSG);</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC testproc4 (                          
	OUT NAME CHAR (40),                         
	OUT LOCATION VARCHAR(40),                         
	OUT STAND DATE,                         
	OUT STAND_T TIME,                         
	OUT AREA FIXED(5,1),                         
	OUT EMPLOYEES FLOAT,                         
	OUT PASSENGERS INT,                         
	OUT CARGO NUMERIC(7),                          
	OUT FLIGHTS REAL,                         
	OUT PER_DAY SMALLINT,                         
	OUT ARRIVAL TIMESTAMP,                         
	OUT DEPARTURE TIMESTAMP)                         
AS   
	SELECT * FROM USER.TAB;
</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call testproc3</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>select NAME, LOCATION, STAND, STAND_T, AREA,
	EMPLOYEES, PASSENGERS, CARGO, FLIGHTS,
	PER_DAY, ARRIVAL, DEPARTURE FROM TAB</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>NAME</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>LOCATION</ColumnName>
<ColumnType>VARCHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>STAND</ColumnName>
<ColumnType>DATE</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>STAND_T</ColumnName>
<ColumnType>TIME</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>AREA</ColumnName>
<ColumnType>FIXED</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>EMPLOYEES</ColumnName>
<ColumnType>FLOAT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PASSENGERS</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>CARGO</ColumnName>
<ColumnType>FIXED</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>FLIGHTS</ColumnName>
<ColumnType>FLOAT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>PER_DAY</ColumnName>
<ColumnType>SMALLINT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>ARRIVAL</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DEPARTURE</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<Row>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
</Row>
<Row>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
</Row>
<Row>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
<Value>NULL</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>select count (*) from tab where today is null</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>EXPRESSION1</ColumnName>
<ColumnType>FIXED</ColumnType>
</ColumnDefinition>
<Row>
<Value>3</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="true" ignore="false" verify="true">
<CallString>call testproc4  (?,?,?,?,?,?,?,?,?,?,?,?)</CallString>
<Parameter DataType="CHAR(40)" InValue="" OutValue="NULL" ParamType="OUT"/>
<Parameter DataType="VARCHAR(40)" InValue="" OutValue="NULL" ParamType="OUT"/>
<Parameter DataType="DATE" InValue="" OutValue="NULL" ParamType="OUT"/>
<Parameter DataType="TIME " InValue="" OutValue="NULL" ParamType="OUT"/>
<Parameter DataType="INT" InValue="" OutValue="NULL" ParamType="OUT"/>
<Parameter DataType="FLOAT" InValue="" OutValue="NULL" ParamType="OUT"/>
<Parameter DataType="INT" InValue="" OutValue="NULL" ParamType="OUT"/>
<Parameter DataType="INT" InValue="" OutValue="NULL" ParamType="OUT"/>
<Parameter DataType="FLOAT" InValue="" OutValue="NULL" ParamType="OUT"/>
<Parameter DataType="SMALLINT" InValue="" OutValue="NULL" ParamType="OUT"/>
<Parameter DataType="TIME" InValue="" OutValue="NULL" ParamType="OUT"/>
<Parameter DataType="TIME" InValue="" OutValue="NULL" ParamType="OUT"/>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc testproc4</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc testproc3</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc testproc2</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc testproc1</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop table tab</CallString>
</Statement>
</CleanUp>
</Test>
<Test ErrorType="syntax" Exclude="(;;oracle)" Number="19" Responsible="Daub, Jan Michael" TestType="negative">
<Comment>* call_statement with expression *

a test due to a known a fixed bug 
(call_statement with expression ':some_var - 1' caused a kernel loop)

</Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>create table table1 (a fixed(5), b char (200))</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC  test2 (IN SOME_VAR FIXED(5)) 
AS SUBTRANS BEGIN;
INSERT INTO USER.TABLE1 VALUES (:SOME_VAR, 'added by test2'); 
SUBTRANS END;</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC TEST1 
AS
   VAR SOME_VAR FIXED (5); 
   SUBTRANS BEGIN; 
     INSERT INTO USER.TABLE1 VALUES (:SOME_VAR, 'added by part1 - #1'); 
	IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
     SET SOME_VAR = 4; 
	IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG);  
     INSERT INTO USER.TABLE1 VALUES (:SOME_VAR, 'added by part1 - #2'); 
	IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
     CALL TEST2 (:SOME_VAR - 1); 
	IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
     INSERT INTO USER.TABLE1 VALUES (:SOME_VAR, 'added by part1 - #3'); 
	IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
SUBTRANS END;</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call test1</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>select * from table1</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>A</ColumnName>
<ColumnType>INT</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>B</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>NULL</Value>
<Value>'added by part1 - #1'</Value>
</Row>
<Row>
<Value>4</Value>
<Value>'added by part1 - #2'</Value>
</Row>
<Row>
<Value>3</Value>
<Value>'added by test2'</Value>
</Row>
<Row>
<Value>4</Value>
<Value>'added by part1 - #3'</Value>
</Row>
</ResultSet>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc test2</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc test1</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop table table1</CallString>
</Statement>
</CleanUp>
</Test>
<Test ErrorType="syntax" Exclude="(;;oracle)" Number="20" Responsible="Daub, Jan Michael" TestType="negative">
<Comment>* call_statement with expression *

call_statements like 'call &lt;dbproc_name&gt; (expression)' are executed within a dbproc;
expressions  +  -  *  /  DIV  MOD  are tested   


</Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>create table table1 (a FIXED(7,2), b char (200))</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC  test2 (IN q FIXED(7,2)) 
AS SUBTRANS BEGIN;
INSERT INTO USER.TABLE1 VALUES (:q, 'result &lt;-- added by test2'); 
    IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
SUBTRANS END;</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC TEST11 (IN a FIXED(7,2))
AS   
INSERT INTO USER.TABLE1 VALUES (:a, 'a - 43 &lt;-- added by test11  #1 '); 
    IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
CALL TEST2 (:a - 43); 
    IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
INSERT INTO USER.TABLE1 VALUES (:a, 'a - 73.78 &lt;-- added by test11 #2'); 
    IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
 CALL TEST2 (:a - 73.78);
     IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
INSERT INTO USER.TABLE1 VALUES (:a, 'a + 26.22 &lt;-- added by test11 #3'); 
    IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
 CALL TEST2 (:a + 26.22);
     IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG);</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call test11 (93.78)</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC TEST12 (IN a FIXED(7,2))
AS   
INSERT INTO USER.TABLE1 VALUES (:a, 'a * 5 &lt;-- added by test12  #1 '); 
    IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
CALL TEST2 (:a * 5); 
    IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
INSERT INTO USER.TABLE1 VALUES (:a, 'a * 0.5 &lt;-- added by test12  #2'); 
    IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
 CALL TEST2 (:a * 0.5);
     IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
INSERT INTO USER.TABLE1 VALUES (:a, 'a / 2.4 &lt;-- added by test12  #3'); 
    IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
 CALL TEST2 (:a / 2.4);
     IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
INSERT INTO USER.TABLE1 VALUES (:a, 'a / 3 &lt;-- added by test12  #4'); 
    IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
 CALL TEST2 (:a / 3);
     IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG);</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>call test12 (4.8)</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC TEST13 (IN a FIXED(7,2))
AS   
INSERT INTO USER.TABLE1 VALUES (:a, 'a DIV 3 &lt;-- added by test13  #1 '); 
    IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
CALL TEST2 (:a DIV 3); 
    IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
INSERT INTO USER.TABLE1 VALUES (:a, 'a MOD 4 &lt;-- added by test13  #2'); 
    IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG); 
 CALL TEST2 (:a MOD 4);
     IF $RC &lt;&gt; 0 THEN STOP ($RC, $ERRMSG);</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>call test13 (10.00)</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="true">
<CallString>select * from table1</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>A</ColumnName>
<ColumnType>FIXED</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>B</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>93.78</Value>
<Value>'a - 43 &lt;-- added by test11  #1'</Value>
</Row>
<Row>
<Value>50.78</Value>
<Value>'result &lt;-- added by test2'</Value>
</Row>
<Row>
<Value>93.78</Value>
<Value>'a - 73.78 &lt;-- added by test11 #2'</Value>
</Row>
<Row>
<Value>20.00</Value>
<Value>'result &lt;-- added by test2'</Value>
</Row>
<Row>
<Value>93.78</Value>
<Value>'a + 26.22 &lt;-- added by test11 #3'</Value>
</Row>
<Row>
<Value>120.00</Value>
<Value>'result &lt;-- added by test2'</Value>
</Row>
<Row>
<Value>4.80</Value>
<Value>'a * 5 &lt;-- added by test12  #1'</Value>
</Row>
<Row>
<Value>24.00</Value>
<Value>'result &lt;-- added by test2'</Value>
</Row>
<Row>
<Value>4.80</Value>
<Value>'a * 0.5 &lt;-- added by test12  #2'</Value>
</Row>
<Row>
<Value>2.40</Value>
<Value>'result &lt;-- added by test2'</Value>
</Row>
<Row>
<Value>4.80</Value>
<Value>'a / 2.4 &lt;-- added by test12  #3'</Value>
</Row>
<Row>
<Value>2.00</Value>
<Value>'result &lt;-- added by test2'</Value>
</Row>
<Row>
<Value>4.80</Value>
<Value>'a / 3 &lt;-- added by test12  #4'</Value>
</Row>
<Row>
<Value>1.60</Value>
<Value>'result &lt;-- added by test2'</Value>
</Row>
<Row>
<Value>10.00</Value>
<Value>'a DIV 3 &lt;-- added by test13  #1'</Value>
</Row>
<Row>
<Value>3.00</Value>
<Value>'result &lt;-- added by test2'</Value>
</Row>
<Row>
<Value>10.00</Value>
<Value>'a MOD 4 &lt;-- added by test13  #2'</Value>
</Row>
<Row>
<Value>2.00</Value>
<Value>'result &lt;-- added by test2'</Value>
</Row>
</ResultSet>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc test2</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc test11</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc test12</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc test13</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop table table1</CallString>
</Statement>
</CleanUp>
</Test>
<Test Exclude="" Number="243" Responsible="FerdiF" TestType="positive">
<Comment>Check initialization of local variables</Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc vars_initialized( out res int)  as
VAR
       str1 varchar(4000);
       cArr char(100);
       i        int;
       si      smallint;
       ts     timestamp;
       d      date;
       t        time;
       r        real;
       n       fixed(38,3);
       f        float;
       if (str1 is not null) then
          stop(29001,'vars_initialized: str1 not initialized');
       if (cArr is not null) then
          stop(29001,'vars_initialized: cArr not initialized');
       if (i is not null) then
          stop(29001,'vars_initialized: i not initialized');
       if (si is not null) then
          stop(29001,'vars_initialized: si not initialized');
       if (ts is not null) then
          stop(29001,'vars_initialized: ts not initialized');
       if (d is not null) then
          stop(29001,'vars_initialized: d not initialized');
       if (t is not null) then
          stop(29001,'vars_initialized: t not initialized');
       if (r is not null) then
          stop(29001,'vars_initialized: r not initialized');
       if (n is not null) then
          stop(29001,'vars_initialized: n not initialized');
       if (f is not null) then
          stop(29001,'vars_initialized: f not initialized');
       res = 1;   
 return;      
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc check_continue_execute returns cursor  as 
    VAR ix int;
    try
       ix = -30000;
       declare :$cursor cursor for
           select msgno from sysdba.messages where msgno = :ix;
       while ( $RC = 100 ) do
       begin
	    declare :$cursor cursor for
            select msgno from sysdba.messages where msgno = :ix;
            ix = ix + 1;
        end;    
    catch
        if ( $rc = 100) then continue execute
        else stop ($rc, 'not expected error');
return;


</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create or replace view DualUnionDual as  select * from dual union select * from dual
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc checkViewTabOwner returns cursor as
    declare :$cursor cursor for  select * from user.DualUnionDual;
return; 
</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="true" ignore="false" verify="false">
<CallString>  call vars_initialized(?)</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call check_continue_execute</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call checkViewTabOwner</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>DUMMY</ColumnName>
<ColumnType>CHAR</ColumnType>
</ColumnDefinition>
<Row>
<Value>'a'</Value>
</Row>
</ResultSet>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc vars_initialized
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc check_continue_execute</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc checkViewTabOwner</CallString>
</Statement>
</CleanUp>
</Test>
<Test Exclude="(;;internal)" Number="277" Responsible="Wittstadt, Marius" TestType="positive">
<Comment>Checks if a cursor, returned by a DBProcedure, returns correct values for Date and Time values</Comment>
<Prepare>
<Statement callable="false" ignore="true" verify="false">
<CallString>drop table tab1</CallString>
</Statement>
<Statement callable="false" ignore="true" verify="false">
<CallString>drop dbproc Zeit</CallString>
</Statement>
<Statement callable="false" ignore="true" verify="false">
<CallString>drop dbproc Datum</CallString>
</Statement>
<Statement callable="false" ignore="true" verify="false">
<CallString>drop dbproc Zeitstempel</CallString>
</Statement>
<Statement callable="false" ignore="true" verify="false">
<CallString>drop dbproc dt</CallString>
</Statement>
<Statement callable="false" ignore="true" verify="false">
<CallString>drop dbproc dtts</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create table tab1(Datum date, Zeit date, Zeitstempel date)</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>insert into tab1 values('2004-06-18 13:45:00', '2004-06-18 13:45:00','2004-06-18 13:45:00')</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>insert into tab1 values('2004-12-24 17:30:00', '2004-12-24 17:30:00','2004-12-24 17:30:00')</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>insert  into tab1 values('1981-12-11 07:30:00', '1981-12-11 07:30:00','1981-12-11 07:30:00')</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>select * from tab1</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>DATUM</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>ZEIT</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>ZEITSTEMPEL</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<Row>
<Value>'2004-06-18 13:45:00.000000'</Value>
<Value>'2004-06-18 13:45:00.000000'</Value>
<Value>'2004-06-18 13:45:00.000000'</Value>
</Row>
<Row>
<Value>'2004-12-24 17:30:00.000000'</Value>
<Value>'2004-12-24 17:30:00.000000'</Value>
<Value>'2004-12-24 17:30:00.000000'</Value>
</Row>
<Row>
<Value>'1981-12-11 07:30:00.000000'</Value>
<Value>'1981-12-11 07:30:00.000000'</Value>
<Value>'1981-12-11 07:30:00.000000'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>Declare cursor1 cursor for select * from tab1</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>DATUM</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>ZEIT</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>ZEITSTEMPEL</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<Row>
<Value>'2004-06-18 13:45:00.000000'</Value>
<Value>'2004-06-18 13:45:00.000000'</Value>
<Value>'2004-06-18 13:45:00.000000'</Value>
</Row>
<Row>
<Value>'2004-12-24 17:30:00.000000'</Value>
<Value>'2004-12-24 17:30:00.000000'</Value>
<Value>'2004-12-24 17:30:00.000000'</Value>
</Row>
<Row>
<Value>'1981-12-11 07:30:00.000000'</Value>
<Value>'1981-12-11 07:30:00.000000'</Value>
<Value>'1981-12-11 07:30:00.000000'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC ZEIT  RETURNS CURSOR AS
    $CURSOR = 'ZEIT';
     DECLARE :$CURSOR CURSOR FOR
           SELECT ZEIT FROM user.tab1;</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC DATUM  RETURNS CURSOR AS
    $CURSOR = 'DATUM';
     DECLARE :$CURSOR CURSOR FOR
           SELECT DATUM FROM user.tab1;</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC ZEITSTEMPEL  RETURNS CURSOR AS
    $CURSOR = 'ZEITSTEMPEL';
     DECLARE :$CURSOR CURSOR FOR
           SELECT ZEITSTEMPEL FROM user.tab1;</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC DT  RETURNS CURSOR AS
    $CURSOR = 'DT';
     DECLARE :$CURSOR CURSOR FOR
           SELECT ZEIT,Datum FROM user.tab1;</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC DTTS  RETURNS CURSOR AS
    $CURSOR = 'DTTS';
     DECLARE :$CURSOR CURSOR FOR
           SELECT * FROM user.tab1;</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>call ZEIT</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>ZEIT</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<Row>
<Value>'2004-06-18 13:45:00.000000'</Value>
</Row>
<Row>
<Value>'2004-12-24 17:30:00.000000'</Value>
</Row>
<Row>
<Value>'1981-12-11 07:30:00.000000'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>call Datum</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>DATUM</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<Row>
<Value>'2004-06-18 13:45:00.000000'</Value>
</Row>
<Row>
<Value>'2004-12-24 17:30:00.000000'</Value>
</Row>
<Row>
<Value>'1981-12-11 07:30:00.000000'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>call ZEITSTEMPEL</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>ZEITSTEMPEL</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<Row>
<Value>'2004-06-18 13:45:00.000000'</Value>
</Row>
<Row>
<Value>'2004-12-24 17:30:00.000000'</Value>
</Row>
<Row>
<Value>'1981-12-11 07:30:00.000000'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>call dt</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>ZEIT</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DATUM</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<Row>
<Value>'2004-06-18 13:45:00.000000'</Value>
<Value>'2004-06-18 13:45:00.000000'</Value>
</Row>
<Row>
<Value>'2004-12-24 17:30:00.000000'</Value>
<Value>'2004-12-24 17:30:00.000000'</Value>
</Row>
<Row>
<Value>'1981-12-11 07:30:00.000000'</Value>
<Value>'1981-12-11 07:30:00.000000'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>call dtts</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>DATUM</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>ZEIT</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>ZEITSTEMPEL</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<Row>
<Value>'2004-06-18 13:45:00.000000'</Value>
<Value>'2004-06-18 13:45:00.000000'</Value>
<Value>'2004-06-18 13:45:00.000000'</Value>
</Row>
<Row>
<Value>'2004-12-24 17:30:00.000000'</Value>
<Value>'2004-12-24 17:30:00.000000'</Value>
<Value>'2004-12-24 17:30:00.000000'</Value>
</Row>
<Row>
<Value>'1981-12-11 07:30:00.000000'</Value>
<Value>'1981-12-11 07:30:00.000000'</Value>
<Value>'1981-12-11 07:30:00.000000'</Value>
</Row>
</ResultSet>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop table tab1</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc Zeit</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc Datum</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc Zeitstempel</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc dt</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc dtts</CallString>
</Statement>
</CleanUp>
</Test>
<Test ErrorType="syntax" Exclude="" Number="324" Responsible="" TestType="negative">
<Comment/>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString/>
</Statement>
</Run>
</Test>
<Test ErrorType="syntax" Exclude="(;;oracle)" Number="357" Responsible="FerdiF" TestType="negative">
<Comment>negative testing for db-procedures</Comment>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString/>
</Statement>
</Run>
</Test>
<Test ErrorType="syntax" Exclude="(;;oracle)" Number="552" Responsible="FerdiF" TestType="negative">
<Comment>create a part list and use "cursor with recursive" to run queries </Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>create table parts ( part_id int primary key, 
		     part_desc varchar(64) not null, 
                     part_level int not null default 0)
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create table partlist ( part_id1 int, part_id2 int, part_num int not null, primary key (part_id1, part_id2))
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create table article ( art_id int key, art_desc varchar(64) not NULL, part_id int not null)
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create function rand( lastrand int) returns int as return (((lastrand * 214013 + 2531011) * 65536) MOD 32767);
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROCEDURE  createparts1( inout key int, in cnt int, in level int) as
VAR
        partnum_lower_level int;
        number                      int;
        position                    int;
        part_key2                   int;
        part_num                    int;
        randNum                     int;
        
        randNum = rand(cnt + key);        
        if ( level &gt;= 10 ) then return;
        select count(*) into :partnum_lower_level from user.parts where part_level = :level - 1;
        if ( $RC &lt;&gt; 0) THEN STOP ($RC,'Error in: select count(*) into :partnum_lower_level from stl.parts where part_level = level-1;');
        randNum = rand(randNum) ;
        number = 0;
        if ( 0 &lt; (10 div level )) then
            number = 10 div level;
        if ( number = 0) then number = 1;
        number = randNum  MOD ( number );
        if ( number = 0) then number = 1;
  
        declare curs cursor for select part_id from user.parts where part_level = :level -1;
        
        while (number &gt; 0)  DO  BEGIN
            randNum = rand(randNum) ;
            position = ( randNum mod partnum_lower_level ) + 1;
            fetch  pos (:position) curs INTO :part_key2;           
            if ( $RC &lt;&gt; 0) THEN 
                STOP ($RC, 'Error in: fetch pos :position INTO part_key2;');
            part_num = ( rand(randNum) mod 3 + 1) * ( rand(randNum) mod (11 - level)) + 1;
            insert into user.partlist values (:key, :part_key2, :part_num);
            number = number - 1;
        END;
return;
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROCEDURE createparts( IN cnt INT ) AS
VAR
        randNum    int;    
        p_key      int;     
        ix         int;
        pname      varchar(64);
        l_level    int;
        l_max      int;
                
        p_key = 1;
        set randNum = rand(111 * ( cnt mod 11));
        select max(part_id) into :p_key from user.parts;
        if ( $RC &lt;&gt; 0) THEN
                STOP ($RC, 'Error in: select max(part_id) into :key from parts;');

        IF (p_key is NULL) THEN p_key = 0;
        p_key = p_key + 1; ix = 1; l_level = 0;
        
        while ( ix &lt;= cnt ) DO 
        BEGIN
            pname = 'part' || chr(p_key);
            insert into user.parts values ( :p_key, :pname, :l_level ); 
            if ( $RC &lt;&gt; 0) THEN
                STOP ($RC, 'insert into stl.parts values (' || p_key || ',' || pname || ', 0 )');
            p_key = p_key + 1;  ix = ix + 1;
        END;
                
        l_level = l_level + 1;
        randNum = rand(randNum);   
        ix = cnt div ( (L_Level + 1) * 50 );
        if (ix  = 0 ) then
             ix = 1
        else 
             ix = randNum mod ix; 
 
        l_max = 5;
        while ((l_max &gt; 0) and ($RC = 0)) DO
        BEGIN
            while (( ix &gt; 0) and ($RC = 0)) DO 
            BEGIN
                set pname = 'part' || chr(p_key);
                insert into user.parts values ( :p_key, :pname, :l_level ); 
                call createparts1( :p_key, :cnt, :l_level);  
                if (( $RC &lt;&gt; 0) and ( $RC &lt;&gt; 100)) THEN 
                    STOP ($RC, 'call createparts1(' || p_key || ',' || randNum || ',' || l_level );
                p_key = p_key + 1; ix = ix - 1;
            END;
            l_max = l_max - 1;
            l_level = l_level + 1;
            ix = cnt div ((L_Level + 1) * 50 );
            if (ix  = 0 ) then
                 ix = 1
            else 
                 ix = randNum mod ix; 
        END;
        
        declare curs1 cursor for select part_id1 from 
                    user.partlist where part_id1 not in  (select part_id2 from user.partlist);
        
        select max(art_id) into :ix from user.article;
        if ( ix IS NULL) THEN ix = 1;                                                                            
        fetch curs1 INTO :p_key;           
        
        while ( $RC = 0 ) DO
        BEGIN
            pname = 'article' || chr(ix);
            insert into user.article values ( :ix, :pname, :p_Key ); 
            fetch  curs1 INTO :p_key;
            ix = ix + 1;
        END;
return;</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc RecursiveCursor returns cursor as
VAR 
 	stmt varchar(1024);

	$CURSOR = 'MyRecursiveCursor';
	set stmt = 'declare "' || $CURSOR  || 
'" cursor for with recursive px (major, minor, number, mainmajor) as
( select part_id1, part_id2, part_num, part_id1 from user.partlist , user.article 
        	where part_id1 = part_id 
  union all
  select part_id1, part_id2, (px.number*part_num), mainmajor from user.partlist, px where minor = part_id1 )
  select a.art_id, a.art_desc, x1.major, x1.minor, x1.number, p.part_desc,p.part_level 
  from px x1, user.parts p, user.article a 
  where x1.minor = p.part_id and a.part_id = x1.mainmajor and p.part_level &gt; 0 
  group by a.art_id, a.art_desc, x1.major, x1.minor, x1.number, p.part_desc,p.part_level 
  order by a.art_id, a.art_desc, x1.major, x1.minor, x1.number, p.part_desc,p.part_level';

	execute stmt;
	if ( 0 &lt;&gt; $RC ) then
	stop ($RC, 'execution of declare cursor with recursive failed');
return; 
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create dbproc RecursiveCursorStat returns cursor as
    $CURSOR = 'MyRecursiveCursorStat';
    declare :$Cursor cursor for with recursive px (major, minor, number, mainmajor) as
	( select part_id1, part_id2, part_num, part_id1 from user.partlist , user.article 
        	where part_id1 = part_id 
  	union all
            select part_id1, part_id2, (px.number*part_num), mainmajor from user.partlist, px where minor = part_id1 )
          select a.art_id, a.art_desc, x1.major, x1.minor, x1.number, p.part_desc,p.part_level 
          from px x1, user.parts p, user.article a 
          where x1.minor = p.part_id and a.part_id = x1.mainmajor and p.part_level &gt; 0 
          group by a.art_id, a.art_desc, x1.major, x1.minor, x1.number, p.part_desc,p.part_level 
          order by a.art_id, a.art_desc, x1.major, x1.minor, x1.number, p.part_desc,p.part_level;
return; 
</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="true" ignore="false" verify="false">
<CallString>call createParts(3000)</CallString>
</Statement>
<Statement callable="true" ignore="false" verify="false">
<CallString>call RecursiveCursorStat
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>call RecursiveCursor
</CallString>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc RecursiveCursorStat</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc RecursiveCursor</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop table parts</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop table partlist
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop table article</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop function rand</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbprocedure createparts1
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbprocedure createparts
</CallString>
</Statement>
</CleanUp>
</Test>
<Test ErrorType="syntax" Exclude="(;;oracle)" Number="555" Responsible="FerdiF" TestType="negative">
<Comment>db-procedure returning a cursor</Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>-- 2 different way to implement a theta operator introduced by Codd
-- (out of joe Celko's "SQL for Smarties") 
CREATE DBPROC "Codd T-Join" ( in switch int) RETURNS CURSOR as

SET $CURSOR = 'Codd T-Join result';

Drop table temp.Rooms;
Drop table temp.Classes;

Create table temp.Rooms (     
    roomno char(2) primary key, 
    bldg   char(10) NOT NULL, 
    roomsize Int NOT NULL );

Create Table temp.Classes (
	classno char(2) primary key,
	classsize int not null);

insert into temp.classes values( 'c6', 40 );
insert into temp.classes values( 'c5', 50 );
insert into temp.classes values( 'c4', 55 );
insert into temp.classes values( 'c3', 65 );
insert into temp.classes values( 'c2', 70 );
insert into temp.classes values( 'c1', 80 );

insert into temp.rooms values( 'r5', 'class', 30 );
insert into temp.rooms values( 'r2', 'lab', 40 );
insert into temp.rooms values( 'r3', 'lab', 50 );
insert into temp.rooms values( 'r7', 'class', 55 );
insert into temp.rooms values( 'r6', 'class', 65 );
insert into temp.rooms values( 'r1', 'lab', 70 );
insert into temp.rooms values( 'r4', 'class', 85 );

CASE
WHEN switch = 1 THEN 
	BEGIN
		DECLARE :$CURSOR CURSOR FOR select * from 
		( select roomno, roomsize, max(classsize) expr
			from temp.rooms rooms,temp.classes classes
			where classes.classsize &lt; rooms.roomsize
			group by roomno, roomsize ) as fs1,

		( select classno, classsize, min(roomsize) expr
			from temp.rooms rooms,temp.classes classes
			where classes.classsize &lt; rooms.roomsize
			group by classno, classsize ) as fs2
		where fs1.expr = fs2.classsize 
		and fs1. roomsize = fs2.expr 
		order by fs2.classsize;
    END;
WHEN switch = 2 THEN
    BEGIN
		DECLARE :$CURSOR CURSOR FOR 
			select cr1.classno, cr1.classsize, rm1.roomno, rm1.roomsize
				from temp.classes cr1, temp.rooms as rm1
				where rm1.roomsize = ( select min(rm2.roomsize)
					from temp.rooms as rm2
					where rm2.roomsize &gt; cr1.classsize
					and not exists
						( select * from temp.classes as cr2
							where rm2.roomsize &gt; cr2.classsize
							and
							cr2.classno &lt; cr1.classno )) ;
    END;
ELSE STOP(-29001, 'wrong switch specified');
END CASE

RETURN;
</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="true" ignore="false" verify="true">
<CallString>call "Codd T-Join"(1)</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>ROOMNO</ColumnName>
<ColumnType>VARCHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>ROOMSIZE</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>EXPR</ColumnName>
<ColumnType>FIXED</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>CLASSNO</ColumnName>
<ColumnType>VARCHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>CLASSSIZE</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>EXPRESSION1</ColumnName>
<ColumnType>FIXED</ColumnType>
</ColumnDefinition>
<Row>
<Value>'r3'</Value>
<Value>50</Value>
<Value>40</Value>
<Value>'c6'</Value>
<Value>40</Value>
<Value>50</Value>
</Row>
<Row>
<Value>'r7'</Value>
<Value>55</Value>
<Value>50</Value>
<Value>'c5'</Value>
<Value>50</Value>
<Value>55</Value>
</Row>
<Row>
<Value>'r6'</Value>
<Value>65</Value>
<Value>55</Value>
<Value>'c4'</Value>
<Value>55</Value>
<Value>65</Value>
</Row>
<Row>
<Value>'r1'</Value>
<Value>70</Value>
<Value>65</Value>
<Value>'c3'</Value>
<Value>65</Value>
<Value>70</Value>
</Row>
<Row>
<Value>'r4'</Value>
<Value>85</Value>
<Value>80</Value>
<Value>'c1'</Value>
<Value>80</Value>
<Value>85</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="true" ignore="false" verify="true">
<CallString>call "Codd T-Join"(2)</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>CLASSNO</ColumnName>
<ColumnType>VARCHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>CLASSSIZE</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>ROOMNO</ColumnName>
<ColumnType>VARCHAR</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>ROOMSIZE</ColumnName>
<ColumnType>INTEGER</ColumnType>
</ColumnDefinition>
<Row>
<Value>'c6'</Value>
<Value>40</Value>
<Value>'r3'</Value>
<Value>50</Value>
</Row>
<Row>
<Value>'c5'</Value>
<Value>50</Value>
<Value>'r7'</Value>
<Value>55</Value>
</Row>
<Row>
<Value>'c4'</Value>
<Value>55</Value>
<Value>'r6'</Value>
<Value>65</Value>
</Row>
<Row>
<Value>'c3'</Value>
<Value>65</Value>
<Value>'r1'</Value>
<Value>70</Value>
</Row>
<Row>
<Value>'c1'</Value>
<Value>80</Value>
<Value>'r4'</Value>
<Value>85</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="true" ignore="false" verify="true">
<CallString>call "Codd T-Join"(119)</CallString>
<Error>
<ErrorCode>-29001</ErrorCode>
<ErrorMessage>[-29001]: wrong switch specified</ErrorMessage>
</Error>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>Drop table temp.Rooms
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>Drop table temp.Classes
</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>DROP DBPROC "Codd T-Join"</CallString>
</Statement>
</CleanUp>
</Test>
<Test Exclude="" Number="557" Responsible="ThomasA" TestType="positive">
<Comment>Checks for corrections of bugs sent by the open source community </Comment>
<Prepare>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC THIS_CRASHED_THE_KERNEL (IN X INTEGER) RETURNS CURSOR AS
  DECLARE :$CURSOR CURSOR FOR SELECT * FROM DOMAIN.TABLES; 
BEGIN
  SELECT 1 FROM DOMAIN.TABLES;
END;
</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="true" ignore="false" verify="false">
<CallString>CALL THIS_CRASHED_THE_KERNEL(1)</CallString>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>DROP DBPROC THIS_CRASHED_THE_KERNEL</CallString>
</Statement>
</CleanUp>
</Test>
<Test ErrorType="syntax" Exclude="" Number="921" Responsible="" TestType="negative">
<Comment/>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString/>
</Statement>
</Run>
</Test>
<Test Exclude="(;;oracle)" Number="1350" Responsible="Wittstadt, Marius" TestType="positive">
<Comment>Checks if a cursor, returned by a DBProcedure, returns correct values for Date and Time values</Comment>
<Prepare>
<Statement callable="false" ignore="true" verify="false">
<CallString>drop table tab1</CallString>
</Statement>
<Statement callable="false" ignore="true" verify="false">
<CallString>drop dbproc Zeit</CallString>
</Statement>
<Statement callable="false" ignore="true" verify="false">
<CallString>drop dbproc Datum</CallString>
</Statement>
<Statement callable="false" ignore="true" verify="false">
<CallString>drop dbproc Zeitstempel</CallString>
</Statement>
<Statement callable="false" ignore="true" verify="false">
<CallString>drop dbproc dt</CallString>
</Statement>
<Statement callable="false" ignore="true" verify="false">
<CallString>drop dbproc dtts</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>create table tab1(Datum date, Zeit time, Zeitstempel timestamp)</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>insert  tab1 values('2004-06-18', '13:45:00','2004-06-18 13:45:00')</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>insert  tab1 values('2004-12-24', '17:30:00','2004-12-24 17:30:00')</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>insert  tab1 values('1981-12-11', '07:30:00','1981-12-11 07:30:00')</CallString>
</Statement>
</Prepare>
<Run>
<Statement callable="false" ignore="false" verify="false">
<CallString>select * from tab1</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>DATUM</ColumnName>
<ColumnType>DATE</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>ZEIT</ColumnName>
<ColumnType>TIME</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>ZEITSTEMPEL</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<Row>
<Value>'2004-06-18'</Value>
<Value>'13:45:00'</Value>
<Value>'2004-06-18 13:45:00.000000'</Value>
</Row>
<Row>
<Value>'2004-12-24'</Value>
<Value>'17:30:00'</Value>
<Value>'2004-12-24 17:30:00.000000'</Value>
</Row>
<Row>
<Value>'1981-12-11'</Value>
<Value>'07:30:00'</Value>
<Value>'1981-12-11 07:30:00.000000'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>Declare cursor1 cursor for select * from tab1</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>DATUM</ColumnName>
<ColumnType>DATE</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>ZEIT</ColumnName>
<ColumnType>TIME</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>ZEITSTEMPEL</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<Row>
<Value>'2004-06-18'</Value>
<Value>'13:45:00'</Value>
<Value>'2004-06-18 13:45:00.000000'</Value>
</Row>
<Row>
<Value>'2004-12-24'</Value>
<Value>'17:30:00'</Value>
<Value>'2004-12-24 17:30:00.000000'</Value>
</Row>
<Row>
<Value>'1981-12-11'</Value>
<Value>'07:30:00'</Value>
<Value>'1981-12-11 07:30:00.000000'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC ZEIT  RETURNS CURSOR AS
    $CURSOR = 'ZEIT';
     DECLARE :$CURSOR CURSOR FOR
           SELECT ZEIT FROM user.tab1;</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC DATUM  RETURNS CURSOR AS
    $CURSOR = 'DATUM';
     DECLARE :$CURSOR CURSOR FOR
           SELECT DATUM FROM user.tab1;</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC ZEITSTEMPEL  RETURNS CURSOR AS
    $CURSOR = 'ZEITSTEMPEL';
     DECLARE :$CURSOR CURSOR FOR
           SELECT ZEITSTEMPEL FROM user.tab1;</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC DT  RETURNS CURSOR AS
    $CURSOR = 'DT';
     DECLARE :$CURSOR CURSOR FOR
           SELECT ZEIT,Datum FROM user.tab1;</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>CREATE DBPROC DTTS  RETURNS CURSOR AS
    $CURSOR = 'DTTS';
     DECLARE :$CURSOR CURSOR FOR
           SELECT * FROM user.tab1;</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>call ZEIT</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>ZEIT</ColumnName>
<ColumnType>TIME</ColumnType>
</ColumnDefinition>
<Row>
<Value>'13:45:00'</Value>
</Row>
<Row>
<Value>'17:30:00'</Value>
</Row>
<Row>
<Value>'07:30:00'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>call Datum</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>DATUM</ColumnName>
<ColumnType>DATE</ColumnType>
</ColumnDefinition>
<Row>
<Value>'2004-06-18'</Value>
</Row>
<Row>
<Value>'2004-12-24'</Value>
</Row>
<Row>
<Value>'1981-12-11'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>call ZEITSTEMPEL</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>ZEITSTEMPEL</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<Row>
<Value>'2004-06-18 13:45:00.000000'</Value>
</Row>
<Row>
<Value>'2004-12-24 17:30:00.000000'</Value>
</Row>
<Row>
<Value>'1981-12-11 07:30:00.000000'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>call dt</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>ZEIT</ColumnName>
<ColumnType>TIME</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>DATUM</ColumnName>
<ColumnType>DATE</ColumnType>
</ColumnDefinition>
<Row>
<Value>'13:45:00'</Value>
<Value>'2004-06-18'</Value>
</Row>
<Row>
<Value>'17:30:00'</Value>
<Value>'2004-12-24'</Value>
</Row>
<Row>
<Value>'07:30:00'</Value>
<Value>'1981-12-11'</Value>
</Row>
</ResultSet>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>call dtts</CallString>
<ResultSet Verification="Complete">
<ColumnDefinition>
<ColumnName>DATUM</ColumnName>
<ColumnType>DATE</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>ZEIT</ColumnName>
<ColumnType>TIME</ColumnType>
</ColumnDefinition>
<ColumnDefinition>
<ColumnName>ZEITSTEMPEL</ColumnName>
<ColumnType>TIMESTAMP</ColumnType>
</ColumnDefinition>
<Row>
<Value>'2004-06-18'</Value>
<Value>'13:45:00'</Value>
<Value>'2004-06-18 13:45:00.000000'</Value>
</Row>
<Row>
<Value>'2004-12-24'</Value>
<Value>'17:30:00'</Value>
<Value>'2004-12-24 17:30:00.000000'</Value>
</Row>
<Row>
<Value>'1981-12-11'</Value>
<Value>'07:30:00'</Value>
<Value>'1981-12-11 07:30:00.000000'</Value>
</Row>
</ResultSet>
</Statement>
</Run>
<CleanUp>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop table tab1</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc Zeit</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc Datum</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc Zeitstempel</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc dt</CallString>
</Statement>
<Statement callable="false" ignore="false" verify="false">
<CallString>drop dbproc dtts</CallString>
</Statement>
</CleanUp>
</Test>
</Tests>
