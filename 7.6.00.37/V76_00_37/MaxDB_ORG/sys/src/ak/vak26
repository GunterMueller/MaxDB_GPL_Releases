.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK26$
.tt 2 $$$
.TT 3 $ThomasA$AK_COMMENT$2000-11-16$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : AK_Comment
=========
.sp
Purpose :
Inserts comments into the catalog
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a26add_comment (
                    VAR acv       : tak_all_command_glob;
                    VAR long_desc : tak_long_descriptor);
 
        PROCEDURE
              a26comment_on  (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a26drop_comment (
                    VAR acv      : tak_all_command_glob;
                    comment_type : tak_comment_type;
                    VAR id1      : tgg00_Surrogate;
                    VAR id2      : tgg00_Surrogate;
                    colno        : integer);
 
        PROCEDURE
              a26execute_comment (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a26get_comment_prefix (
                    VAR acv       : tak_all_command_glob;
                    VAR long_desc : tak_long_descriptor;
                    VAR buf       : tsp00_Buf;
                    pos           : integer;
                    required_len  : integer);
 
        PROCEDURE
              a26getval (
                    VAR acv           : tak_all_command_glob;
                    VAR long_desc     : tak_long_descriptor;
                    VAR ret_long_qual : tgg00_LongQual);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01char_size         : integer;
              a01defaultkey        : tgg00_SysInfoKey;
              a01_il_b_identifier  : tsp00_KnlIdentifier;
 
        PROCEDURE
              a01_call_put (
                    VAR acv  : tak_all_command_glob;
                    proc     : tak_procs;
                    subproc  : tsp00_Int2;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_init_command (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_syntax_tools : VAK02;
 
        PROCEDURE
              a02comment_spec (
                    VAR acv         : tak_all_command_glob;
                    put_node        : tsp00_Int2;
                    VAR last_node   : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05_identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
        PROCEDURE
              a05string_literal_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    datatyp     : tsp00_DataType;
                    VAR moveobj : tsp00_MoveObj;
                    obj_pos     : integer;
                    obj_len     : integer);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        FUNCTION
              a06exist_user (
                    VAR acv          : tak_all_command_glob;
                    VAR user_name    : tsp00_KnlIdentifier;
                    dstate           : tak_directory_state;
                    VAR user_rec_ptr : tak_sysbufferaddress) : boolean;
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06get_username (
                    VAR acv        : tak_all_command_glob;
                    VAR tree_index : integer;
                    VAR username   : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06reset_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06_get_priv  (
                    VAR acv     : tak_all_command_glob;
                    VAR brec    : tak_sysbufferaddress;
                    VAR priv    : tak_privilege);
 
        PROCEDURE
              a06a_mblock_init (
                    VAR acv         : tak_all_command_glob;
                    mtype           : tgg00_MessType;
                    m2type          : tgg00_MessType2;
                    VAR tree        : tgg00_FileId);
 
        FUNCTION
              a06_table_exist (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR authname : tsp00_KnlIdentifier;
                    VAR tablen   : tsp00_KnlIdentifier;
                    VAR sparr    : tak_syspointerarr;
                    get_all      : boolean) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        FUNCTION
              a061exist_columnname (
                    VAR base_rec    : tak_baserecord;
                    VAR column      : tsp00_KnlIdentifier;
                    VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
        FUNCTION
              a061identifier_len (VAR id : tsp00_KnlIdentifier) : integer;
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_uni_error (
                    VAR acv  : tak_all_command_glob;
                    uni_err  : tsp8_uni_error;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_kw_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    kw       : integer);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10_cache_delete (
                    VAR acv     : tak_all_command_glob;
                    is_rollback : boolean);
 
        PROCEDURE
              a10del_sysinfo (
                    VAR acv     : tak_all_command_glob;
                    VAR syskey  : tgg00_SysInfoKey;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_add_repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    add_sysinfo  : boolean;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_fix_len_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    required_len : integer;
                    plus         : integer;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              AK_Domain : VAK12;
 
        FUNCTION
              a12dbfunc_exist (
                    VAR acv         : tak_all_command_glob;
                    VAR owner       : tsp00_KnlIdentifier;
                    VAR dbfunc_name : tsp00_KnlIdentifier;
                    dstate          : tak_directory_state;
                    VAR method_buf  : tak_sysbufferaddress) : boolean;
 
        FUNCTION
              a12dbproc_exist (
                    VAR acv        : tak_all_command_glob;
                    VAR owner      : tsp00_KnlIdentifier;
                    VAR dbproc     : tsp00_KnlIdentifier;
                    dstate         : tak_directory_state;
                    VAR method_buf : tak_sysbufferaddress) : boolean;
 
        PROCEDURE
              a12get_domain (
                    VAR acv         : tak_all_command_glob;
                    VAR owner       : tsp00_KnlIdentifier;
                    VAR domain_name : tsp00_KnlIdentifier;
                    ti              : integer;
                    VAR domain_ref  : tak_sysbufferaddress;
                    VAR domain_def  : tak_sysbufferaddress);
 
        FUNCTION
              a12SystemTriggerExists (VAR acv : tak_all_command_glob;
                    VAR schema     : tsp00_KnlIdentifier;
                    VAR dbproc     : tsp00_KnlIdentifier;
                    dstate         : tak_directory_state;
                    VAR method_buf : tak_sysbufferaddress) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_User_Password : VAK21;
 
        FUNCTION
              a21is_owner (
                    VAR acv     : tak_all_command_glob;
                    VAR userrec : tak_userrecord) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Synonym : VAK23;
 
        FUNCTION
              a23exist_sequence (
                    VAR acv         : tak_all_command_glob;
                    tree_index      : integer;
                    inclusiveSerial : boolean;
                    VAR seq_buf     : tak_sysbufferaddress;
                    VAR seq_owner   : tsp00_KnlIdentifier;
                    VAR seq_name    : tsp00_KnlIdentifier) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Index : VAK24;
 
        PROCEDURE
              a24find_indexname (
                    VAR acv            : tak_all_command_glob;
                    VAR tabid          : tgg00_Surrogate;
                    VAR indexname      : tsp00_KnlIdentifier;
                    VAR index_scan_rec : tak_index_scan_record);
 
      ------------------------------ 
 
        FROM
              AK_Link : VAK25;
 
        PROCEDURE
              a25get_linkname (
                    VAR acv        : tak_all_command_glob;
                    linkbuf        : tak_sysbufferaddress;
                    index          : integer;
                    VAR link_name  : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_dialog_tools : VAK260;
 
        PROCEDURE
              a260get_proc (
                    VAR acv        : tak_all_command_glob;
                    VAR authname   : tsp00_KnlIdentifier;
                    VAR proc       : tsp00_KnlIdentifier;
                    VAR tree_index : integer);
 
      ------------------------------ 
 
        FROM
              AK_Trigger : VAK262;
 
        PROCEDURE
              a262exist_trigger (
                    VAR acv             : tak_all_command_glob;
                    VAR trigger_name    : tsp00_KnlIdentifier;
                    VAR trigger_ptr_arr : tak_syspointerarr;
                    VAR trigger_kind    : tgg00_Linkset);
 
      ------------------------------ 
 
        FROM
              Pseudo_fieldmap : VAK509;
 
        FUNCTION
              a509get_one_value (map_ptr : tsp00_MoveObjPtr;
                    value_no       : tsp00_Int2;
                    VAR value_ptr  : tsp00_MoveObjPtr;
                    VAR value_len  : tsp00_Int4;
                    VAR is_null    : boolean;
                    VAR is_default : boolean) : boolean;
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK54;
 
        PROCEDURE
              a54_dml_init (
                    VAR acv   : tak_all_command_glob;
                    VAR dmli  : tak_dml_info;
                    in_union  : boolean);
 
        PROCEDURE
              a54_dml_finalize (
                    VAR dmli         : tak_dml_info;
                    VAR TransContext : tgg00_TransContext);
 
        PROCEDURE
              a54_get_pparsp_pinfop (
                    VAR acv   : tak_all_command_glob;
                    VAR sparr : tak_syspointerarr;
                    mtype     : tgg00_MessType);
 
        PROCEDURE
              a54_fixedpos (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a54_last_part (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    last_pars_part : boolean);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542internal_packet (
                    VAR acv                 : tak_all_command_glob;
                    release_internal_packet : boolean;
                    required_len            : tsp00_Int4);
 
        PROCEDURE
              a542reset_packet (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              DML_Parts : VAK55;
 
        PROCEDURE
              a55_describe_value (
                    VAR acv       : tak_all_command_glob;
                    VAR dmli      : tak_dml_info;
                    VAR colinfo   : tak00_columninfo;
                    nodeno        : integer;
                    res_buf_index : integer;
                    in_datapart   : boolean);
 
      ------------------------------ 
 
        FROM
              Deal-With-User-Commands : VAK92;
 
        PROCEDURE
              a92_map_into_upper (
                    VAR acv  : tak_all_command_glob;
                    VAR buf  : tsp00_MoveObj;
                    startpos : tsp00_Int4;
                    endpos   : tsp00_Int4;
                    uni_map  : boolean);
 
      ------------------------------ 
 
        FROM
              KB_Logging : vkb560
                    PROCEDURE
                    kb560GetSys1CatalogTabId(
                    VAR tabId : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code           : tgg04_CodeGlobals;
              g01nil_long_qual  : tgg00_LongQual;
              g01unicode        : boolean;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedUnicodeFill (
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2 );
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20int4_to_buf_swap (
                    val        : tsp00_Int4;
                    sourceswap : tsp00_SwapKind;
                    VAR dest   : tak_systembuffer;
                    di         : tsp00_Int4;
                    destswap   : tsp00_SwapKind);
 
        FUNCTION
              s20buf_to_int4_swap (
                    VAR source     : tak_systembuffer;
                    si             : tsp00_Int4;
                    sourceswap     : tsp00_SwapKind;
                    destswap       : tsp00_SwapKind) : tsp00_Int4;
&       ifdef trace
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01int4 (
                    layer : tgg00_Debug;
                    nam : tsp00_Sname;
                    int : tsp00_Int4);
 
        PROCEDURE
              t01moveobj (
                    layer       : tgg00_Debug;
                    VAR buf     : tsp00_MoveObj;
                    startpos    : tsp00_Int4;
                    endpos      : tsp00_Int4);
&       endif
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80: VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_data_dictionary: VAK38;
 
        PROCEDURE
              a38comment_parameters (
                    VAR acv         : tak_all_command_glob;
                    VAR object_type : tak_keyword;
                    VAR object_id1  : tsp00_KnlIdentifier;
                    VAR object_id2  : tsp00_KnlIdentifier;
                    VAR object_id3  : tsp00_KnlIdentifier;
                    VAR object_id4  : tsp00_KnlIdentifier);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              a05_identifier_get;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              s20int4_to_buf_swap;
 
              tsp00_MoveObj tak_systembuffer
 
        FUNCTION
              s20buf_to_int4_swap;
 
              tsp00_MoveObj tak_systembuffer
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ThomasA
.sp
.cp 3
Created : 1985-04-09
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-11-16
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.sp
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_comment_param_len = 120;
      c_put_descriptor    = true;
      c_uni_map           = true (* a92_map_into_upper *);
      c_buf_offset        = 32;
      c_is_rollback       = true;
      c_in_datapart       = true (* a55_describe_value *);
 
 
(*------------------------------*) 
 
PROCEDURE
      ak26any_object_comment (
            VAR acv    : tak_all_command_glob;
            tree_index : integer);
 
CONST
      max_obj_id = 4;
 
VAR
      len         : integer;
      err_char_no : tsp00_Int4;
      uni_err     : tsp8_uni_error;
      ix          : integer;
      objtype_ptr : ^tak_keyword;
      object_type : tsp00_KnlIdentifier;
      objtype     : tak_keyword;
      object_id   : ARRAY[1..max_obj_id] OF tsp00_KnlIdentifier;
 
BEGIN
a05_identifier_get (acv, tree_index, sizeof (object_type), object_type);
IF  a061identifier_len (object_type) > sizeof (objtype) * a01char_size
THEN
    a07_nb_put_error (acv, e_identifier_too_long,
          acv.a_ap_tree^[tree_index].n_pos, object_type)
ELSE
    IF  g01unicode
    THEN
        BEGIN
        len := sizeof (objtype);
        s80uni_trans (@object_type, sizeof (objtype) * a01char_size, csp_unicode,
              @objtype, len, csp_ascii, [ ], uni_err, err_char_no);
        IF  uni_err <> uni_ok
        THEN
            a07_uni_error (acv, uni_err, err_char_no)
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        objtype_ptr := @object_type;
        objtype     := objtype_ptr^
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    tree_index := acv.a_ap_tree^[tree_index].n_lo_level;
    FOR ix := 1 TO max_obj_id DO
        object_id[ix] := a01_il_b_identifier;
    (*ENDFOR*) 
    ix := 1;
    WHILE tree_index <> 0 DO
        BEGIN
        a05_identifier_get (acv, tree_index,
              sizeof(object_id[ix]), object_id[ix]);
        ix         := ix + 1;
        tree_index := acv.a_ap_tree^[tree_index].n_sa_level
        END;
    (*ENDWHILE*) 
    a38comment_parameters (acv, objtype,
          object_id[1], object_id[2], object_id[3], object_id[4])
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26build_comment_key (
            VAR long_desc : tak_long_descriptor;
            VAR syskey : tgg00_SysInfoKey);
 
BEGIN
WITH long_desc DO
    BEGIN
    syskey              := a01defaultkey;
    syskey.sauthid      := lds_descriptor;
    syskey.sentrytyp    := cak_ecomment;
    syskey.stablen  [1] := chr(ord(ldc_comment_type));
    syskey.stablen  [2] := chr (lds_colno DIV 256);
    syskey.stablen  [3] := chr (lds_colno MOD 256);
    syskey.skeylen      := syskey.skeylen + 3
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26obuild_comment_key (
            VAR long_desc : tak_long_descriptor;
            VAR syskey : tgg00_SysInfoKey);
 
BEGIN
WITH long_desc DO
    BEGIN
    syskey              := a01defaultkey;
    syskey.sauthid      := lds_descriptor;
    syskey.sentrytyp    := cak_ecomment;
    syskey.stablen  [1] := chr(ord(ldc_comment_type));
    syskey.stablen  [2] := chr (lds_colno DIV 256);
    syskey.stablen  [3] := chr (lds_colno MOD 256);
    syskey.skeylen      := syskey.skeylen + 3;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26column_comment (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            first_node     : integer;
            drop_comment   : boolean;
            put_descriptor : boolean;
            VAR long_desc  : tak_long_descriptor);
 
VAR
      b_err     : tgg00_BasisError;
      col_ptr   : tak00_colinfo_ptr;
      base_ptr  : tak_sysbufferaddress;
      priv      : tak_privilege;
      columnn   : tsp00_KnlIdentifier;
 
BEGIN
WITH acv DO
    BEGIN
    ak26get_name_table_priv (acv,
          first_node, base_ptr, priv, columnn);
    IF  a_returncode = 0
    THEN
        IF  r_owner in priv.priv_all_set
        THEN
            IF  a061exist_columnname (base_ptr^.sbase, columnn, col_ptr)
            THEN
                BEGIN
                IF  put_descriptor
                THEN
                    ak26put_descriptor (acv, dmli, cm_column,
                          base_ptr^.sbase.bsurrogate,
                          col_ptr^.cextcolno, long_desc);
                (*ENDIF*) 
                WITH base_ptr^.sbase, col_ptr^ DO
                    IF  ((ctcomment in ccolpropset) <> NOT drop_comment)
                        AND
                        put_descriptor
                    THEN
                        BEGIN
                        IF  drop_comment
                        THEN
                            ccolpropset := ccolpropset - [ctcomment]
                        ELSE
                            ccolpropset := ccolpropset + [ctcomment];
                        (*ENDIF*) 
                        a10repl_sysinfo (acv, base_ptr, b_err);
                        IF  b_err <> e_ok
                        THEN
                            a07_b_put_error (acv, b_err, 1)
                        ELSE
                            IF  drop_comment
                            THEN
                                a26drop_comment (acv, cm_column,
                                      bsurrogate, bsurrogate,
                                      cextcolno);
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDWITH*) 
                END
            ELSE
                a07_nb_put_error (acv, e_unknown_columnname,
                      a_ap_tree^[first_node].n_pos, columnn)
            (*ENDIF*) 
        ELSE
            a07_kw_put_error (acv, e_missing_privilege,
                  a_ap_tree^[first_node].n_pos, cak_i_userid)
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26comment (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            comment_kind   : integer;
            is_public      : boolean;
            tree_index     : integer;
            drop_comment   : boolean;
            put_descriptor : boolean;
            VAR long_desc  : tak_long_descriptor);
 
BEGIN
CASE comment_kind OF
    cak_i_column :
        ak26column_comment (acv, dmli,
              tree_index, drop_comment, put_descriptor, long_desc);
    cak_i_function :
        ak26dbfunc_comment (acv, dmli,
              tree_index, drop_comment, put_descriptor, long_desc);
    cak_i_dbproc, cak_i_dbprocedure, cak_i_system :
        ak26dbproc_comment (acv, dmli, tree_index,
              comment_kind = cak_i_system, drop_comment, put_descriptor, long_desc);
    cak_i_domain :
        ak26domain_comment (acv, dmli,
              tree_index, drop_comment, put_descriptor, long_desc);
    cak_i_foreign :
        ak26foreign_key_comment (acv, dmli,
              tree_index, drop_comment, put_descriptor, long_desc);
    cak_i_index :
        ak26index_comment (acv, dmli,
              tree_index, drop_comment, put_descriptor, long_desc);
    cak_i_object :
        ak26any_object_comment (acv, tree_index);
    cak_i_sequence :
        ak26sequence_comment (acv, dmli,
              tree_index, drop_comment, put_descriptor, long_desc);
    cak_i_synonym :
        ak26synonym_comment (acv, dmli, is_public,
              tree_index, drop_comment, put_descriptor, long_desc);
    (* PTS 1111576 E.Z. *)
    cak_i_table :
        ak26table_comment (acv, dmli,
              tree_index, drop_comment, put_descriptor, long_desc);
    cak_i_trigger :
        ak26trigger_comment (acv, dmli,
              tree_index, drop_comment, put_descriptor, long_desc);
    cak_i_user, cak_i_usergroup :
        ak26user_comment (acv, dmli, comment_kind,
              tree_index, drop_comment, put_descriptor, long_desc);
    OTHERWISE
        a07_b_put_error (acv, e_not_implemented, 1);
    END;
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26dbfunc_comment (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            tree_index     : integer;
            drop_comment   : boolean;
            put_descriptor : boolean;
            VAR long_desc  : tak_long_descriptor);
 
VAR
      b_err          : tgg00_BasisError;
      function_name  : tsp00_KnlIdentifier;
      method_buf     : tak_sysbufferaddress;
      methodinfo_buf : tak_sysbufferaddress;
      sysk           : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
    a05_identifier_get (acv, tree_index,
          sizeof(function_name), function_name);
    IF   a12dbfunc_exist (acv, acv.a_curr_user_name, function_name,
        d_release, method_buf)
    THEN
        BEGIN
        sysk           := method_buf^.syskey;
        sysk.sentrytyp := cak_emethodinfo;
        a10get_sysinfo (acv,
              sysk, d_release, methodinfo_buf, b_err);
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1)
        ELSE
            IF  methodinfo_buf^.smethodinfo.mei_owner <> a_curr_user_id
            THEN
                a07_kw_put_error (acv, e_missing_privilege, 1,
                      cak_i_userid)
            ELSE
                BEGIN
                IF  put_descriptor
                THEN
                    ak26put_descriptor (acv, dmli, cm_dbproc,
                          method_buf^.smethod.me_surrogate,
                          1, long_desc);
                (*ENDIF*) 
                WITH methodinfo_buf^.smethodinfo DO
                    IF  ((mei_comment) <> NOT drop_comment)
                        AND
                        put_descriptor
                    THEN
                        BEGIN
                        mei_comment := NOT drop_comment;
                        a10repl_sysinfo (acv,
                              methodinfo_buf, b_err);
                        IF  b_err <> e_ok
                        THEN
                            a07_b_put_error (acv, b_err, 1)
                        ELSE
                            IF  drop_comment
                            THEN
                                a26drop_comment (acv,
                                      cm_dbproc, mei_surrogate, mei_surrogate, 1)
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                (*ENDWITH*) 
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        a07_nb_put_error (acv, e_unknown_functionname,
              a_ap_tree^[tree_index].n_pos, function_name)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26dbproc_comment (
            VAR acv         : tak_all_command_glob;
            VAR dmli        : tak_dml_info;
            tree_index      : integer;
            isSystemTrigger : boolean;
            drop_comment    : boolean;
            put_descriptor  : boolean;
            VAR long_desc   : tak_long_descriptor);
 
VAR
      ok             : boolean;
      b_err          : tgg00_BasisError;
      errornode      : integer;
      method_buf     : tak_sysbufferaddress;
      methodinfo_buf : tak_sysbufferaddress;
      owner          : tsp00_KnlIdentifier;
      proc           : tsp00_KnlIdentifier;
      sysk           : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
    errornode := tree_index;
    a260get_proc (acv, owner, proc, tree_index);
    IF  isSystemTrigger
    THEN
        ok := a12SystemTriggerExists (acv, owner, proc, d_release, method_buf)
    ELSE
        ok := a12dbproc_exist (acv, owner, proc, d_release, method_buf);
    (*ENDIF*) 
    IF  ok
    THEN
        BEGIN
        sysk           := method_buf^.syskey;
        sysk.sentrytyp := cak_emethodinfo;
        a10get_sysinfo (acv,
              sysk, d_release, methodinfo_buf, b_err);
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1)
        ELSE
            WITH methodinfo_buf^.smethodinfo DO
                IF  mei_owner <> a_curr_user_id
                THEN
                    a07_kw_put_error (acv, e_missing_privilege, 1,
                          cak_i_userid)
                ELSE
                    BEGIN
                    IF  put_descriptor
                    THEN
                        ak26put_descriptor (acv, dmli, cm_dbproc,
                              mei_surrogate, 1, long_desc);
                    (*ENDIF*) 
                    IF  ((mei_comment) <> NOT drop_comment)
                        AND
                        put_descriptor
                    THEN
                        BEGIN
                        mei_comment := NOT drop_comment;
                        a10repl_sysinfo (acv, methodinfo_buf, b_err);
                        IF  b_err <> e_ok
                        THEN
                            a07_b_put_error (acv, b_err, 1)
                        ELSE
                            IF  drop_comment
                            THEN
                                a26drop_comment (acv,
                                      cm_dbproc, mei_surrogate, mei_surrogate, 1)
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
        END
    ELSE
        a07_nb_put_error (acv, e_unknown_procedure_name,
              a_ap_tree^[errornode].n_pos, proc)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26domain_comment (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            tree_index     : integer;
            drop_comment   : boolean;
            put_descriptor : boolean;
            VAR long_desc  : tak_long_descriptor);
 
VAR
      b_err       : tgg00_BasisError;
      dom_def     : tak_sysbufferaddress;
      dom_ref     : tak_sysbufferaddress;
      dom_name    : tsp00_KnlIdentifier;
      dom_owner   : tsp00_KnlIdentifier;
 
BEGIN
WITH acv DO
    BEGIN
    a12get_domain (acv, dom_owner, dom_name, tree_index,
          dom_ref, dom_def);
    IF  a_returncode = 0
    THEN
        IF  a_current_user_kind in [usysdba, udba]
        THEN
            BEGIN
            IF  put_descriptor
            THEN
                ak26put_descriptor (acv, dmli, cm_domain,
                      dom_ref^.sdomainref.dsurrogate,
                      1, long_desc);
            (*ENDIF*) 
            WITH dom_def^.sdomain.dom_colinfo DO
                IF  ((ctcomment in ccolpropset) <> NOT drop_comment)
                    AND
                    put_descriptor
                THEN
                    BEGIN
                    IF  drop_comment
                    THEN
                        ccolpropset := ccolpropset - [ctcomment]
                    ELSE
                        ccolpropset := ccolpropset + [ctcomment];
                    (*ENDIF*) 
                    a10repl_sysinfo (acv, dom_def, b_err);
                    IF  b_err <> e_ok
                    THEN
                        a07_b_put_error (acv, b_err, 1)
                    ELSE
                        IF  drop_comment
                        THEN
                            a26drop_comment (acv, cm_domain,
                                  dom_ref^.sdomainref.dsurrogate,
                                  dom_ref^.sdomainref.dsurrogate, 1);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
            END
        ELSE
            a07_kw_put_error (acv, e_missing_privilege, 1,
                  cak_i_userid)
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26foreign_key_comment (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            tree_index     : integer;
            drop_comment   : boolean;
            put_descriptor : boolean;
            VAR long_desc  : tak_long_descriptor);
 
VAR
      b_err    : tgg00_BasisError;
      index    : integer;
      ix       : integer;
      cnt      : integer;
      fk_buf   : tak_sysbufferaddress;
      fk_name   : tsp00_KnlIdentifier;
      curr_name : tsp00_KnlIdentifier;
      base_ptr  : tak_sysbufferaddress;
      priv      : tak_privilege;
      sysk      : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
    ak26get_name_table_priv (acv,
          tree_index, base_ptr, priv, fk_name);
    IF  a_returncode = 0
    THEN
        IF  NOT (r_owner in priv.priv_all_set)
        THEN
            a07_kw_put_error (acv, e_missing_privilege, 1,
                  cak_i_userid);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        sysk           := base_ptr^.syskey;
        sysk.sentrytyp := cak_eforeignkey;
        cnt            := cak_is_undefined;
        index          := 0;
        REPEAT
            a10get_sysinfo (acv, sysk, d_release, fk_buf, b_err);
            IF  b_err = e_ok
            THEN
                WITH fk_buf^.slink DO
                    BEGIN
                    IF  cnt = cak_is_undefined
                    THEN
                        cnt := linkcount;
                    (*ENDIF*) 
                    ix := 1;
                    WHILE (index < cnt) AND (ix <= cak_maxlinkdef) DO
                        BEGIN
                        index := index + 1;
                        a25get_linkname (acv, fk_buf, ix, curr_name);
                        IF  curr_name = fk_name
                        THEN
                            BEGIN
                            IF  (linkdef[ix].lcomment <> NOT drop_comment)
                                AND
                                put_descriptor
                            THEN
                                BEGIN
                                linkdef[ix].lcomment :=
                                      NOT drop_comment;
                                a10repl_sysinfo (acv, fk_buf, b_err);
                                IF  b_err <> e_ok
                                THEN
                                    a07_b_put_error (acv, b_err, 1)
                                ELSE
                                    IF  drop_comment
                                    THEN
                                        a26drop_comment (acv,
                                              cm_foreign_key,
                                              sysk.stableid,
                                              sysk.stableid, index)
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            ix := csp_maxint2
                            END
                        ELSE
                            ix := ix + 1;
                        (*ENDIF*) 
                        END;
                    (*ENDWHILE*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            a06inc_linkage (sysk.slinkage);
        UNTIL
            (ix = csp_maxint2) OR (index > cnt) OR (b_err <> e_ok);
        (*ENDREPEAT*) 
        IF  ix = csp_maxint2
        THEN
            BEGIN
            IF  put_descriptor
            THEN
                ak26put_descriptor (acv, dmli, cm_foreign_key,
                      base_ptr^.syskey.stableid,
                      index, long_desc)
            (*ENDIF*) 
            END
        ELSE
            a07_nb_put_error (acv, e_unknown_linkname,
                  a_ap_tree^[tree_index].n_pos, fk_name)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26get_name_table_priv (
            VAR acv        : tak_all_command_glob;
            VAR tree_index : integer;
            VAR base_ptr   : tak_sysbufferaddress;
            VAR priv       : tak_privilege;
            VAR name       : tsp00_KnlIdentifier);
 
BEGIN
ak26get_table_priv (acv, tree_index, base_ptr, priv);
IF  acv.a_returncode = 0
THEN
    BEGIN
    tree_index := acv.a_ap_tree^[tree_index].n_sa_level;
    a05_identifier_get (acv, tree_index, sizeof (name), name)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26get_table_priv (
            VAR acv        : tak_all_command_glob;
            VAR tree_index : integer;
            VAR base_ptr   : tak_sysbufferaddress;
            VAR priv       : tak_privilege);
 
VAR
      error       : tgg00_BasisError;
      error_pos   : integer;
      schema      : tsp00_KnlIdentifier;
      tablen      : tsp00_KnlIdentifier;
      p_arr       : tak_syspointerarr;
 
BEGIN
WITH acv DO
    BEGIN
    error := e_ok;
    IF  a_ap_tree^[tree_index].n_symb = s_authid
    THEN
        a06get_username (acv, tree_index, schema)
    ELSE
        schema := a_curr_schema;
    (*ENDIF*) 
    a05_identifier_get (acv, tree_index, sizeof (tablen), tablen);
    error_pos   := a_ap_tree^[tree_index].n_pos;
    IF  a06_table_exist (acv, d_release, schema, tablen, p_arr, true)
    THEN
        BEGIN
        base_ptr := p_arr.pbasep;
        a06_get_priv (acv, base_ptr, priv);
        IF  (priv.priv_all_set   = []) AND
            (priv.priv_col_exist = [])
        THEN
            error := e_unknown_tablename
        (*ENDIF*) 
        END
    ELSE
        error := e_unknown_tablename;
    (*ENDIF*) 
    IF  error <> e_ok
    THEN
        a07_nb_put_error (acv, error,
              a_ap_tree^[tree_index].n_pos, tablen)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26index_comment (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            tree_index     : integer;
            drop_comment   : boolean;
            put_descriptor : boolean;
            VAR long_desc  : tak_long_descriptor);
 
VAR
      comment_type   : tak_comment_type;
      replace        : boolean;
      b_err          : tgg00_BasisError;
      error_pos      : integer;
      id             : integer;
      indexbuf       : tak_sysbufferaddress;
      index_name     : tsp00_KnlIdentifier;
      base_ptr       : tak_sysbufferaddress;
      priv           : tak_privilege;
      index_scan_rec : tak_index_scan_record;
 
BEGIN
WITH acv DO
    BEGIN
    replace := false;
    b_err   := e_ok;
    WITH a_ap_tree^[tree_index] DO
        IF  n_symb = s_identifier
        THEN
            BEGIN
            comment_type := cm_index;
            error_pos    := n_pos;
            a05_identifier_get (acv, tree_index,
                  sizeof(index_name), index_name);
            tree_index := n_lo_level;
            ak26get_table_priv (acv,
                  tree_index, base_ptr, priv);
            END
        ELSE
            a07_b_put_error (acv, e_not_implemented, 1);
        (*ENDIF*) 
    (*ENDWITH*) 
    IF  a_returncode = 0
    THEN
        IF  NOT (r_owner in priv.priv_all_set)
        THEN
            a07_kw_put_error (acv, e_missing_privilege, 1,
                  cak_i_userid)
        ELSE
            IF  NOT (base_ptr^.sbase.btablekind in
                [twithkey, twithoutkey])
            THEN
                a07_b_put_error (acv, e_missing_basetable,
                      a_ap_tree^[tree_index].n_pos);
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  base_ptr^.sbase.bindexexist
        THEN
            a24find_indexname (acv, base_ptr^.sbase.bsurrogate,
                  index_name, index_scan_rec)
        ELSE
            index_scan_rec.isr_buf := NIL;
        (*ENDIF*) 
        IF  index_scan_rec.isr_buf = NIL
        THEN
            a07_b_put_error (acv,
                  e_unknown_indexname, error_pos)
        ELSE
            WITH index_scan_rec DO
                BEGIN
                WITH isr_buf^.smindex.indexdef[isr_index] DO
                    BEGIN (* index found *)
                    id := indexno;
                    IF  (icomment <> NOT drop_comment)
                        AND
                        put_descriptor
                    THEN
                        BEGIN
                        indexbuf := isr_buf;
                        icomment := NOT drop_comment;
                        replace  := true
                        END
                    (*ENDIF*) 
                    END
                (*ENDWITH*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  replace
    THEN
        BEGIN
        a10repl_sysinfo (acv, indexbuf, b_err);
        IF  drop_comment AND (b_err = e_ok)
        THEN
            a26drop_comment (acv, comment_type,
                  base_ptr^.syskey.stableid,
                  base_ptr^.syskey.stableid, id);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    IF  (a_returncode = 0) AND put_descriptor
    THEN
        BEGIN
        ak26put_descriptor (acv, dmli, comment_type,
              base_ptr^.syskey.stableid, id, long_desc)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26put_dbproc_param (
            VAR acv     : tak_all_command_glob;
            comment_pos : integer;
            comment_len : integer);
 
CONST
      c_max_comment_len = 4000;
 
BEGIN
IF  comment_len > c_max_comment_len
THEN
    comment_len := c_max_comment_len;
(*ENDIF*) 
WITH acv.a_mblock, mb_qual^ DO
    BEGIN
    mcol_pos  := cak_is_undefined;
    mqual_pos := 1;
    mqual_cnt := 1;
    WITH mb_st^[1] DO
        BEGIN
        etype    := st_value;
        epos     := comment_pos;
        elen_var := comment_len;
        ecol_tab := cgg_zero_c2
        END;
    (*ENDWITH*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26put_descriptor (
            VAR acv       : tak_all_command_glob;
            VAR dmli      : tak_dml_info;
            comment_type  : tak_comment_type;
            VAR id        : tgg00_Surrogate;
            colno         : integer;
            VAR long_desc : tak_long_descriptor);
 
VAR
      desc_len         : integer;
      value_ptr        : tsp00_MoveObjPtr;
      value_len        : tsp00_Int4;
      is_null          : boolean;
      is_default       : boolean;
 
BEGIN
WITH acv DO
    BEGIN
    (* PTS 1116801 E.Z. *)
    desc_len := mxsp_long_desc;
    IF  a_data_part <> NIL
    THEN
        BEGIN
        IF  a_variable_input
        THEN
            BEGIN
            IF  a509get_one_value (a_input_data_map, 1,
                value_ptr, value_len, is_null, is_default)
            THEN
                BEGIN
&               ifdef trace
                t01moveobj (ak_sem, value_ptr^, 1, sizeof (long_desc));
&               endif
                SAPDB_PascalMove ('VAK26 ',   1,    
                      a_data_part^.sp1p_buf_size, sizeof (long_desc),
                      @value_ptr^, 1, @long_desc, 1, value_len, a_returncode);
                END
            (*ENDIF*) 
            END
        ELSE
            BEGIN
&           ifdef trace
            t01moveobj (ak_sem, a_data_part^.sp1p_buf,
                  dmli.d_first_longdesc_pos + 1,
                  dmli.d_first_longdesc_pos + sizeof (long_desc) - 1);
&           endif
            SAPDB_PascalMove ('VAK26 ',   2,    
                  a_data_part^.sp1p_buf_size, sizeof (long_desc),
                  @a_data_part^.sp1p_buf, dmli.d_first_longdesc_pos + 1,
                  @long_desc, 1, desc_len, a_returncode);
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    WITH long_desc DO
        BEGIN
        lds_descriptor   := id;
        (* PTS 1105838 E.Z. *)
        lds_maxlen       := 0;
        lds_intern_pos   := 1;
        ldc_comment_type := comment_type;
        lds_colno        := colno;
        lds_infoset      := [ld_is_comment];
        lds_state        := [ ld_short_scol ];
        IF  g01unicode
        THEN
            BEGIN
            (* comment has datatyp unicode *)
            IF  (a_out_packet^.sp1_header.sp1h_mess_swap <>
                sw_normal)
            THEN
                lds_state := lds_state + [ ld_use_ucs_2_swap ];
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    IF  a_data_part <> NIL
    THEN
        IF  a_variable_input
        THEN
            SAPDB_PascalMove ('VAK26 ',   3,    
                  sizeof (long_desc), a_data_part^.sp1p_buf_size,
                  @long_desc, 1, @value_ptr^, 1, desc_len,
                  a_returncode)
        ELSE
            SAPDB_PascalMove ('VAK26 ',   4,    
                  sizeof (long_desc), a_data_part^.sp1p_buf_size,
                  @long_desc, 1, @a_data_part^.sp1p_buf,
                  dmli.d_first_longdesc_pos + 1, desc_len,
                  a_returncode);
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26sequence_comment (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            first_node     : integer;
            drop_comment   : boolean;
            put_descriptor : boolean;
            VAR long_desc  : tak_long_descriptor);
 
CONST
      c_inclusiveSerial = true;
 
VAR
      b_err     : tgg00_BasisError;
      seq_buf   : tak_sysbufferaddress;
      seq_owner : tsp00_KnlIdentifier;
      seq_name  : tsp00_KnlIdentifier;
 
BEGIN
WITH acv DO
    BEGIN
    IF  a23exist_sequence (acv, first_node, NOT c_inclusiveSerial, seq_buf,
        seq_owner, seq_name)
    THEN
        IF  seq_owner <> a_curr_user_name
        THEN
            a07_kw_put_error (acv, e_missing_privilege,
                  a_ap_tree^[first_node].n_pos, cak_i_userid);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        WITH seq_buf^.ssequence DO
            IF  (seq_comment <> NOT drop_comment) AND
                put_descriptor
            THEN
                BEGIN
                seq_comment := NOT drop_comment;
                a10repl_sysinfo (acv, seq_buf, b_err);
                IF  b_err <> e_ok
                THEN
                    a07_b_put_error (acv, b_err, 1)
                ELSE
                    IF  drop_comment
                    THEN
                        a26drop_comment (acv, cm_sequence,
                              seq_surrogate, seq_surrogate, 1);
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        IF  put_descriptor
        THEN
            WITH seq_buf^.ssequence DO
                ak26put_descriptor (acv, dmli, cm_sequence,
                      seq_surrogate, 1, long_desc)
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26synonym_comment (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            is_public      : boolean;
            tree_index     : integer;
            drop_comment   : boolean;
            put_descriptor : boolean;
            VAR long_desc  : tak_long_descriptor);
 
VAR
      b_err   : tgg00_BasisError;
      err_kw  : integer;
      ref_buf : tak_sysbufferaddress;
      syn_buf : tak_sysbufferaddress;
      owner   : tsp00_KnlIdentifier;
      sysk    : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
    err_kw := cak_i_no_keyword;
    sysk   := a01defaultkey;
    IF  is_public
    THEN
        sysk.sauthid := cak_public_id
    ELSE
        sysk.sauthid := a_curr_user_id;
    (*ENDIF*) 
    sysk.sentrytyp := cak_etableref;
    sysk.skeylen   := sysk.skeylen + sizeof (sysk.sidentifier);
    IF  a_ap_tree^[tree_index].n_symb = s_authid
    THEN
        a06get_username (acv, tree_index, owner)
    ELSE
        owner := a_curr_user_name;
    (*ENDIF*) 
    a05_identifier_get (acv, tree_index,
          sizeof(sysk.sidentifier), sysk.sidentifier);
    IF  owner <> a_curr_user_name
    THEN
        a07_kw_put_error (acv, e_missing_privilege, 1,
              cak_i_userid)
    ELSE
        BEGIN
        a10get_sysinfo (acv, sysk, d_release, ref_buf, b_err);
        IF  b_err = e_ok
        THEN
            BEGIN
            sysk          := a01defaultkey;
            sysk.stableid := ref_buf^.stableref.rsynid;
            a10get_sysinfo (acv, sysk, d_release, syn_buf, b_err);
            END;
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            IF  ref_buf^.stableref.rtablekind = tsynonym
            THEN
                BEGIN
                IF  is_public
                THEN
                    IF  syn_buf^.ssynonym.syn_owner <> a_curr_user_id
                    THEN
                        BEGIN
                        b_err  := e_missing_privilege;
                        err_kw := cak_i_userid
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  put_descriptor AND (b_err = e_ok)
                THEN
                    ak26put_descriptor (acv, dmli, cm_synonym,
                          ref_buf^.stableref.rsynid,
                          1, long_desc);
                (*ENDIF*) 
                IF  (syn_buf^.ssynonym.syncomment <> NOT drop_comment)
                    AND
                    put_descriptor
                    AND
                    (b_err = e_ok)
                THEN
                    BEGIN
                    syn_buf^.ssynonym.syncomment := NOT drop_comment;
                    a10repl_sysinfo (acv, syn_buf, b_err);
                    IF  drop_comment AND (b_err = e_ok)
                    THEN
                        a26drop_comment (acv, cm_synonym,
                              sysk.stableid, sysk.stableid, 1);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                b_err := e_unknown_synonymname
            (*ENDIF*) 
        ELSE
            IF  b_err = e_sysinfo_not_found
            THEN
                b_err := e_unknown_synonymname;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  b_err <> e_ok
        THEN
            a07_kw_put_error (acv, b_err, 1, err_kw)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26table_comment (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            first_node     : integer;
            drop_comment   : boolean;
            put_descriptor : boolean;
            VAR long_desc  : tak_long_descriptor);
 
VAR
      b_err    : tgg00_BasisError;
      priv     : tak_privilege;
      base_ptr : tak_sysbufferaddress;
 
BEGIN
WITH acv DO
    BEGIN
    ak26get_table_priv (acv, first_node, base_ptr, priv);
    IF  a_returncode = 0
    THEN
        WITH base_ptr^.sbase DO
            IF  (bcomment <> NOT drop_comment) AND put_descriptor
            THEN
                BEGIN
                bcomment := NOT drop_comment;
                a10repl_sysinfo (acv, base_ptr, b_err);
                IF  b_err <> e_ok
                THEN
                    a07_b_put_error (acv, b_err, 1)
                ELSE
                    IF  drop_comment
                    THEN
                        a26drop_comment (acv, cm_table,
                              bsurrogate, bsurrogate, 1);
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        IF  r_owner in priv.priv_all_set
        THEN
            BEGIN
            WITH base_ptr^.sbase DO
                IF  put_descriptor
                THEN
                    ak26put_descriptor (acv, dmli, cm_table,
                          bsurrogate, 1, long_desc)
                (*ENDIF*) 
            (*ENDWITH*) 
            END
        ELSE
            a07_kw_put_error (acv, e_missing_privilege,
                  a_ap_tree^[first_node].n_pos, cak_i_userid)
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26trigger_comment (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            tree_index     : integer;
            drop_comment   : boolean;
            put_descriptor : boolean;
            VAR long_desc  : tak_long_descriptor);
 
VAR
      b_err        : tgg00_BasisError;
      trigger_kind : tgg00_Linkset;
      id           : integer;
      trigger_name : tsp00_KnlIdentifier;
      priv         : tak_privilege;
      trigger_arr  : tak_syspointerarr;
 
BEGIN
WITH acv DO
    BEGIN
    ak26get_name_table_priv (acv, tree_index,
          a_p_arr1.pbasep, priv, trigger_name);
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  NOT (r_owner in priv.priv_all_set)
        THEN
            a07_kw_put_error (acv, e_missing_privilege, 1,
                  cak_i_userid)
        ELSE
            BEGIN
            a262exist_trigger (acv, trigger_name,
                  trigger_arr, trigger_kind);
            IF  trigger_kind = []
            THEN
                a07_b_put_error (acv, e_unknown_trigger,
                      a_ap_tree^[tree_index].n_pos)
            ELSE
                BEGIN
                IF  ins_trigger in trigger_kind
                THEN
                    id := 1
                ELSE
                    IF  upd_trigger in trigger_kind
                    THEN
                        id := 2
                    ELSE
                        id := 3;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  (trigger_arr.px[1]^.strigger.tr_comment <>
                    NOT drop_comment)
                    AND
                    put_descriptor
                THEN
                    BEGIN
                    trigger_arr.px[1]^.strigger.tr_comment :=
                          NOT drop_comment;
                    WITH a_p_arr1.pbasep^.sbase DO
                        BEGIN
                        a10repl_sysinfo (acv,
                              trigger_arr.px[1], b_err);
                        IF  b_err <> e_ok
                        THEN
                            a07_b_put_error (acv, b_err, 1)
                        ELSE
                            IF  drop_comment
                            THEN
                                a26drop_comment (acv, cm_trigger,
                                      bsurrogate, bsurrogate, id);
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                    END;
                (*ENDIF*) 
                IF  put_descriptor
                THEN
                    WITH a_p_arr1.pbasep^.sbase DO
                        ak26put_descriptor (acv, dmli, cm_trigger,
                              bsurrogate, id, long_desc)
                    (*ENDWITH*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak26user_comment (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            kw_index       : integer;
            first_node     : integer;
            drop_comment   : boolean;
            put_descriptor : boolean;
            VAR long_desc  : tak_long_descriptor);
 
VAR
      error    : tgg00_BasisError;
      err_kw   : integer;
      userbuf  : tak_sysbufferaddress;
      username : tsp00_KnlIdentifier;
 
BEGIN
WITH acv DO
    BEGIN
    err_kw := cak_i_no_keyword;
    error  := e_ok;
    a05_identifier_get (acv, first_node,
          sizeof (username), username);
    IF  a06exist_user (acv, username, d_release, userbuf)
    THEN
        BEGIN
        IF  (kw_index = cak_i_user) AND
            NOT (is_user_rec in userbuf^.suser.urecordtyp)
        THEN
            error  := e_unknown_user
        ELSE
            IF  (kw_index = cak_i_usergroup) AND
                (is_user_rec in userbuf^.suser.urecordtyp)
            THEN
                error := e_unknown_groupname
            ELSE
                IF  a21is_owner (acv, userbuf^.suser)
                THEN
                    WITH userbuf^.suser DO
                        BEGIN
                        IF  put_descriptor
                        THEN
                            ak26put_descriptor (acv, dmli, cm_user,
                                  usurrogate, 1, long_desc);
                        (*ENDIF*) 
                        IF  (ucomment <> NOT drop_comment) AND
                            put_descriptor
                        THEN
                            BEGIN
                            ucomment := NOT drop_comment;
                            a10repl_sysinfo (acv,
                                  userbuf, error);
                            IF  drop_comment AND (error = e_ok)
                            THEN
                                a26drop_comment (acv, cm_user,
                                      usurrogate, usurrogate, 1);
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END
                    (*ENDWITH*) 
                ELSE
                    BEGIN
                    err_kw := cak_i_userid;
                    error  := e_missing_privilege
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        IF  kw_index = cak_i_user
        THEN
            error := e_unknown_user
        ELSE
            error := e_unknown_groupname;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  error <> e_ok
    THEN
        a07_kw_put_error (acv, error,
              a_ap_tree^[first_node].n_pos, err_kw)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a26add_comment (
            VAR acv       : tak_all_command_glob;
            VAR long_desc : tak_long_descriptor);
 
CONST
      c_use     = true;
      c_not_use = false;
 
VAR
      add_record   : boolean;
      b_err        : tgg00_BasisError;
      comment_buf  : tak_sysbufferaddress;
      first_buf    : tak_sysbufferaddress;
      segmentid    : tsp00_C2;
      comment_pos  : integer;
      move_len     : integer;
      offset       : integer;
      old_len      : integer;
      required_len : integer;
      space_in_rec : integer;
      syskey       : tgg00_SysInfoKey;
      firstkey     : tgg00_SysInfoKey;
      uni_hbuf     : tsp00_Buf8K;
      err_char_no  : tsp00_Int4;
      uni_err      : tsp8_uni_error;
      long_dlen    : tsp00_Int4;
      long_dpos    : tsp00_Int4;
      use_uni_hbuf : boolean;
 
BEGIN
WITH acv, long_desc DO
    BEGIN
    use_uni_hbuf := c_not_use;
    (* PTS 1105838 E.Z. *)
    IF  ld_use_ucs_2_swap in lds_state
    THEN
        BEGIN
        use_uni_hbuf := c_use;
        long_dlen := sizeof (uni_hbuf);
        long_dpos := 1;
        s80uni_trans (@(a_data_part^.sp1p_buf[lds_valpos]), lds_vallen,
              csp_unicode_swap, @uni_hbuf, long_dlen, csp_unicode,
              [ ], uni_err, err_char_no);
        IF  uni_err <> uni_ok
        THEN
            a07_uni_error (acv, uni_err, err_char_no);
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        long_dlen := lds_vallen;
        long_dpos := lds_valpos;
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        ak26obuild_comment_key (long_desc, syskey);
        space_in_rec := MAX_RECLEN_GG00 - cgg_rec_key_offset -
              syskey.skeylen - sizeof (tsp00_C2);
        IF  g01unicode AND ((space_in_rec MOD 2) = 1)
        THEN
            space_in_rec := pred (space_in_rec);
        (*ENDIF*) 
        syskey.slinkage [2] := chr((lds_intern_pos+4) DIV space_in_rec + 1);
        IF  syskey.slinkage <> cak_init_linkage
        THEN
            BEGIN
            firstkey          := syskey;
            firstkey.slinkage := cak_init_linkage;
            a10get_sysinfo (acv, firstkey, d_fix, first_buf, b_err);
            IF  b_err <> e_ok
            THEN
                a07_b_put_error (acv, b_err, 1)
            (*ENDIF*) 
            END;
&       ifdef trace
        (*ENDIF*) 
        t01int4 (ak_sem, 'lds_intern_p', lds_intern_pos);
&       endif
        comment_pos         := (lds_intern_pos + 4) MOD space_in_rec;
        lds_intern_pos      := lds_intern_pos + long_dlen;
        old_len             := cak_is_undefined;
        segmentid := cak00_local_segment_id;
&       ifdef trace
        t01int4 (ak_sem, 'long_dlen   ', long_dlen);
&       endif
        WHILE (long_dlen > 0) AND (a_returncode = 0) DO
            BEGIN
            IF  syskey.slinkage = cak_init_linkage
            THEN
                offset := sizeof (tsp00_Int4)
            ELSE
                offset := 0;
            (*ENDIF*) 
            IF  offset + comment_pos + long_dlen - 1 > space_in_rec
            THEN
                move_len := space_in_rec - comment_pos + 1
            ELSE
                move_len := long_dlen;
            (*ENDIF*) 
            required_len := cgg_rec_key_offset + syskey.skeylen +
                  sizeof (tsp00_C2) + offset + move_len;
&           ifdef trace
            t01int4 (ak_sem, 'offset      ', offset);
            t01int4 (ak_sem, 'space_in_rec', space_in_rec);
            t01int4 (ak_sem, 'comment_pos ', comment_pos);
            t01int4 (ak_sem, 'move_len    ', move_len);
            t01int4 (ak_sem, 'required_len', required_len);
&           endif
            IF  (ld_new_rec in lds_infoset) AND (comment_pos = 1)
            THEN
                BEGIN
                a10_nil_get_sysinfo (acv, syskey, d_release,
                      required_len, comment_buf, b_err);
                IF  b_err <> e_ok
                THEN
                    a07_b_put_error (acv, b_err, 1)
                ELSE
                    b_err := e_sysinfo_not_found
                (*ENDIF*) 
                END
            ELSE
                a10_fix_len_get_sysinfo (acv,
                      syskey, d_release,
                      required_len, move_len, comment_buf, b_err);
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                WITH comment_buf^ DO
                    BEGIN
                    IF  b_err = e_ok
                    THEN
                        BEGIN
                        old_len := b_sl;
                        b_sl    := cgg_rec_key_offset + syskey.skeylen +
                              2 + comment_pos + move_len - 1
                        END
                    ELSE
                        BEGIN
                        lds_infoset := lds_infoset + [ld_new_rec];
                        b_sl        :=  required_len
                        END;
                    (*ENDIF*) 
                    ssysbuf[cgg_rec_key_offset+syskey.skeylen+1] :=
                          segmentid[1];
                    ssysbuf[cgg_rec_key_offset+syskey.skeylen+2] :=
                          segmentid[2];
                    IF  use_uni_hbuf
                    THEN
                        BEGIN
                        SAPDB_PascalMove ('VAK26 ',   5,    
                              sizeof (uni_hbuf), sizeof (comment_buf^),
                              @uni_hbuf, long_dpos,  @comment_buf^,
                              cgg_rec_key_offset + syskey.skeylen +
                              sizeof (tsp00_C2) + comment_pos,
                              move_len, a_returncode);
                        END
                    ELSE
                        SAPDB_PascalMove ('VAK26 ',   6,    
                              a_data_part^.sp1p_buf_size,
                              sizeof (comment_buf^),
                              @a_data_part^.sp1p_buf, long_dpos, @comment_buf^,
                              cgg_rec_key_offset + syskey.skeylen +
                              sizeof (tsp00_C2) + comment_pos,
                              move_len, a_returncode);
                    (*ENDIF*) 
                    IF  syskey.slinkage = cak_init_linkage
                    THEN
                        BEGIN
                        s20int4_to_buf_swap (b_err, g01code.kernel_swap,
                              comment_buf^,
                              cgg_rec_key_offset + syskey.skeylen +
                              sizeof(tsp00_C2) + 1, sw_normal);
                        b_err      := e_ok;
                        first_buf  := comment_buf
                        END
                    ELSE
                        a10_add_repl_sysinfo (acv, comment_buf,
                              b_err = e_sysinfo_not_found, b_err)
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            IF  b_err <> e_ok
            THEN
                a07_b_put_error (acv, b_err, 1)
            ELSE
                a06inc_linkage (syskey.slinkage);
            (*ENDIF*) 
            long_dpos   := long_dpos + move_len;
            long_dlen   := long_dlen - move_len;
            comment_pos := 1
            END;
        (*ENDWHILE*) 
&       ifdef trace
        t01int4 (ak_sem, 'old_len     ', old_len);
        t01int4 (ak_sem, 'valmode     ', ord (lds_valmode));
        t01int4 (ak_sem, 'sizeof      ', sizeof (tak_comment_record));
&       endif
        IF  (a_returncode = 0) AND
            (lds_valmode in [vm_alldata, vm_lastdata])
        THEN
            BEGIN
            (* store first comment record with correct comment length *)
            add_record := s20buf_to_int4_swap (first_buf^, cgg_rec_key_offset +
                  syskey.skeylen + sizeof (tsp00_C2) + 1,
                  sw_normal, g01code.kernel_swap) =
                  e_sysinfo_not_found;
            s20int4_to_buf_swap (lds_intern_pos - 1, g01code.kernel_swap,
                  first_buf^, cgg_rec_key_offset + syskey.skeylen +
                  sizeof(tsp00_C2) + 1, sw_normal);
            a10_add_repl_sysinfo (acv,
                  first_buf, add_record, b_err);
            IF  (b_err = e_ok) AND (old_len = MAX_RECLEN_GG00)
            THEN
                BEGIN
                REPEAT
                    a10del_sysinfo (acv, syskey, b_err);
                    a06inc_linkage (syskey.slinkage);
                UNTIL
                    b_err <> e_ok;
                (*ENDREPEAT*) 
                IF  b_err = e_sysinfo_not_found
                THEN
                    b_err := e_ok
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  b_err <> e_ok
            THEN
                a07_b_put_error (acv, b_err, 1)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a_mblock.mb_qual_len  := 0;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a26comment_on  (VAR acv : tak_all_command_glob);
 
CONST
      c_in_union = true;
      c_last_pars_part = true;
 
VAR
      is_public    : boolean;
      ti           : integer;
      comment_ti   : integer;
      comment_kind : integer;
      start_pos    : integer;
      end_pos      : integer;
      col_info     : tak00_columninfo;
      dmli         : tak_dml_info;
      long_desc    : tak_long_descriptor;
 
BEGIN
a54_dml_init (acv, dmli, NOT c_in_union);
WITH acv DO
    IF  a_ex_kind = only_parsing
    THEN
        BEGIN
        a06a_mblock_init (acv,
              m_shutdown, mm_nil, b01niltree_id);
        a54_get_pparsp_pinfop (acv, dmli.d_sparr, m_shutdown);
        IF  a_returncode = 0
        THEN
            BEGIN
            WITH dmli.d_sparr.pparsp^.sparsinfo DO
                BEGIN
                kb560GetSys1CatalogTabId (p_tabid)
                END;
            (*ENDWITH*) 
            ti := a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_lo_level;
            WITH a_ap_tree^[a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_sa_level] DO
                BEGIN
                start_pos  := n_pos;
                comment_ti := n_sa_level
                END;
            (*ENDWITH*) 
            a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_proc  := a56;
            (* PTS 1116801 E.Z. *)
            a_input_data_pos := 1;
            IF  a_ap_tree^[comment_ti].n_symb = s_parameter_name
            THEN
                BEGIN
                WITH col_info DO
                    BEGIN
                    cextcolno := 1;
                    creccolno := 1;
                    IF  g01unicode
                    THEN
                        cdatatyp := dstruni
                    ELSE
                        cdatatyp := dstra;
                    (*ENDIF*) 
                    cdatalen              := cgg04_str_col_entry_size;
                    cinoutlen             := cgg04_str_col_entry_size + 1;
                    cdatafrac             := cak_frac_offset;
                    ccolpropset           := [];
                    ccolstack.etype       := st_fixcol;
                    ccolstack.epos        := 1;
                    ccolstack.elen_var    := cinoutlen;
                    ccolstack.ecol_tab[1] := chr(1);
                    END;
                (*ENDWITH*) 
                a55_describe_value (acv, dmli, col_info,
                      comment_ti, 0, c_in_datapart);
                END;
            (*ENDIF*) 
            IF  (a_ap_tree^[ti].n_subproc = 0) AND
                (a_returncode = 0)
            THEN
                BEGIN
                (* objecttype is given as parameter *)
                WITH col_info DO
                    BEGIN
                    IF  g01unicode
                    THEN
                        cdatatyp := dunicode
                    ELSE
                        cdatatyp := dcha;
                    (*ENDIF*) 
                    cdatalen              := c_comment_param_len * a01char_size; (* PTS 1108072 *)
                    cdatafrac             := cak_frac_offset;
                    cinoutlen             := c_comment_param_len * a01char_size + 1; (* PTS 1108072 *)
                    ccolstack.elen_var    := cinoutlen;
                    cextcolno             := 2;
                    creccolno             := 2;
                    ccolpropset           := [];
                    ccolstack.etype       := st_fixcol;
                    ccolstack.epos        := 1;
                    ccolstack.elen_var    := cinoutlen;
                    ccolstack.ecol_tab[1] := chr(1)
                    END;
                (*ENDWITH*) 
                dmli.d_movebefore := c_buf_offset + cgg_rec_key_offset -
                      a_mblock.mb_data_len;
                a_mblock.mb_data_len := dmli.d_movebefore;
                IF  a_ap_tree^[comment_ti].n_symb = s_parameter_name
                THEN
                    BEGIN
                    dmli.d_movebefore := dmli.d_movebefore
                          - cgg_rec_key_offset - cgg04_str_col_entry_size - 1;
                    a_mblock.mb_data_len := dmli.d_movebefore+cgg_rec_key_offset;
                    END;
                (*ENDIF*) 
                a55_describe_value (acv, dmli, col_info,
                      a_ap_tree^[ti].n_lo_level, 0, c_in_datapart);
                IF  (a_ap_tree^[comment_ti].n_symb <>
                    s_parameter_name)
                    AND
                    (a_returncode = 0)
                THEN
                    BEGIN
                    SAPDB_PascalMove ('VAK26 ',   7,    
                          a_cmd_part^.sp1p_buf_size,
                          a_mblock.mb_data_size,
                          @a_cmd_part^.sp1p_buf, start_pos,
                          @a_mblock.mb_data^.mbp_buf,
                          a_mblock.mb_data_len+1,
                          a_cmd_part^.sp1p_buf_len - start_pos + 1,
                          a_returncode);
                    a_mblock.mb_data_len  := a_mblock.mb_data_len +
                          a_cmd_part^.sp1p_buf_len - start_pos + 1;
                    END
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                start_pos    := a_ap_tree^[ti].n_pos;
                comment_kind := a_ap_tree^[ti].n_subproc;
                is_public    := a_ap_tree^[ti].n_length = cak_i_public;
                ti           := a_ap_tree^[ti].n_lo_level;
                ak26comment (acv, dmli, comment_kind, is_public, ti,
                      NOT c_put_descriptor, false, long_desc);
                IF  a_returncode = 0
                THEN
                    BEGIN
                    end_pos       := a_cmd_part^.sp1p_buf_len;
                    dmli.d_maxlen := c_buf_offset -
                          a_mblock.mb_data_len;
                    a54_fixedpos (acv, dmli);
                    SAPDB_PascalMove ('VAK26 ',   8,    
                          a_cmd_part^.sp1p_buf_size,
                          a_mblock.mb_data_size, @a_cmd_part^.sp1p_buf,
                          start_pos, @a_mblock.mb_data^.mbp_buf,
                          a_mblock.mb_data_len + 1,
                          end_pos - start_pos+1,
                          a_returncode);
                    a_mblock.mb_data_len  := a_mblock.mb_data_len +
                          end_pos - start_pos + 1;
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            a54_last_part (acv, dmli.d_sparr, c_last_pars_part);
        (*ENDIF*) 
        a_is_ddl   := no_ddl;
        a_init_ddl := no_ddl
        END
    ELSE
        a26execute_comment (acv, dmli);
    (*ENDIF*) 
(*ENDWITH*) 
a54_dml_finalize( dmli, acv.a_transinf.tri_trans );
END;
 
(*------------------------------*) 
 
PROCEDURE
      a26drop_comment (
            VAR acv      : tak_all_command_glob;
            comment_type : tak_comment_type;
            VAR id1      : tgg00_Surrogate;
            VAR id2      : tgg00_Surrogate;
            colno        : integer);
 
VAR
      b_err         : tgg00_BasisError;
      syskey        : tgg00_SysInfoKey;
      surrogate_ptr : ^tgg00_Surrogate;
 
BEGIN
WITH acv DO
    BEGIN
    syskey            := a01defaultkey;
    syskey.stableid   := id1;
    syskey.sentrytyp  := cak_ecomment;
    syskey.stablen[1] := chr (ord(comment_type));
    syskey.stablen  [2] := chr (colno DIV 256);
    syskey.stablen  [3] := chr (colno MOD 256);
    syskey.skeylen      := syskey.skeylen + 3;
    IF  comment_type in
        [cm_priv_column, cm_priv_dbproc, cm_priv_table]
    THEN
        BEGIN
        surrogate_ptr  := @syskey.sidentifier[ 4 ];
        surrogate_ptr^ := id2;
        syskey.skeylen := syskey.skeylen + SURROGATE_MXGG00
        END;
    (*ENDIF*) 
    REPEAT
        a10del_sysinfo (acv, syskey, b_err);
        a06inc_linkage  (syskey.slinkage);
    UNTIL
        (b_err <> e_ok);
    (*ENDREPEAT*) 
    IF  b_err <> e_sysinfo_not_found
    THEN
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a26execute_comment  (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info);
 
CONST
      c_release_packet = true;
 
VAR
      drop_comment  : boolean;
      comment_added : boolean;
      reset_packet  : boolean;
      error         : tgg00_BasisError;
      b_err         : tgg00_BasisError;
      first_node    : tsp00_Int2;
      last_node     : tsp00_Int2;
      node          : integer;
      comment_pos   : integer;
      comment_len   : integer;
      comment_node  : integer;
      table_node    : integer;
      data_part_ptr : tsp1_part_ptr;
      col_ptr       : tak00_colinfo_ptr;
      columnn       : tsp00_KnlIdentifier;
      base_ptr      : tak_sysbufferaddress;
      sysk          : tgg00_SysInfoKey;
      long_desc     : tak_long_descriptor;
      dtyp          : tsp00_DataType;
      priv          : tak_privilege;
      offset        : integer;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  dmli.d_sparr.px[1] <> NIL
    THEN
        sysk := dmli.d_sparr.px[1]^.syskey;
    (*ENDIF*) 
    a10_cache_delete (acv, NOT c_is_rollback);
    acv.a_is_ddl  := ddl_comment_on;
    error         := e_ok;
    comment_added := false;
    reset_packet  := false;
    IF  a_ex_kind = only_executing
    THEN
        BEGIN
&       ifdef trace
        t01moveobj (ak_sem, a_mblock.mb_data^.mbp_buf, 1,
              a_mblock.mb_data_len);
&       endif
        data_part_ptr := a_data_part;
        a542internal_packet (acv, c_release_packet,
              a_mblock.mb_data_len - c_buf_offset);
        IF  a_returncode  = 0
        THEN
            BEGIN
            a_data_part  := data_part_ptr;
            reset_packet := true;
            (* h.b. 21.11.95
                  this is nescesary because 506fieldvalues
                  copies the DEFINEDBYTE !!! *)
            IF  (a_mblock.mb_data^.mbp_buf [c_buf_offset + 1]
                = csp_unicode_def_byte) AND g01unicode
            THEN
                offset := c_buf_offset + 1
            ELSE
                offset := c_buf_offset;
            (*ENDIF*) 
            a_cmd_part^.sp1p_buf_len :=
                  a_mblock.mb_data_len - offset;
            SAPDB_PascalMove ('VAK26 ',   9,    
                  a_mblock.mb_data_size,
                  a_cmd_part^.sp1p_buf_size,
                  @a_mblock.mb_data^.mbp_buf, offset + 1,
                  @a_cmd_part^.sp1p_buf, 1, a_cmd_part^.sp1p_buf_len,
                  a_returncode);
            a92_map_into_upper (acv, a_cmd_part^.sp1p_buf,
                  1, a_cmd_part^.sp1p_buf_len, NOT c_uni_map);
&           ifdef trace
            t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, 1, a_cmd_part^.sp1p_buf_len);
&           endif
            a_ex_kind := only_parsing;
            a01_init_command (acv);
            a01_call_put (acv, a26, 0, first_node);
            a_ap_tree^[ 0 ].n_lo_level := first_node;
            a02comment_spec (acv, first_node, last_node)
            END;
        (*ENDIF*) 
        comment_node := a_ap_tree^[first_node].n_sa_level;
        first_node   := a_ap_tree^[first_node].n_lo_level;
        END
    ELSE
        BEGIN
        first_node   := a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_lo_level;
        comment_node := a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_sa_level
        END;
    (*ENDIF*) 
    drop_comment := false;
    IF  comment_node <> 0
    THEN
        BEGIN
        node := a_ap_tree^[comment_node].n_sa_level;
        WITH a_ap_tree^[node] DO
            drop_comment := n_length = 0
        (*ENDWITH*) 
        END
    ELSE
        IF  a_data_ptr <> NIL
        THEN
            drop_comment := (comment_node = 0) AND
                  (a_data_ptr^[1] = csp_undef_byte);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        ak26comment (acv, dmli, a_ap_tree^[first_node].n_subproc,
              a_ap_tree^[first_node].n_length = cak_i_public,
              a_ap_tree^[first_node].n_lo_level,
              drop_comment, c_put_descriptor, long_desc);
    (*ENDIF*) 
    IF  (comment_node <> 0)                  AND
        (a_returncode = 0) AND
        NOT drop_comment
    THEN
        BEGIN
        comment_node := a_ap_tree^[comment_node].n_sa_level;
        IF  a_ap_tree^ [first_node].n_subproc = cak_i_list
        THEN
            BEGIN
            table_node := a_ap_tree^[first_node].n_lo_level;
            ak26get_table_priv (acv, table_node, base_ptr, priv)
            END;
        (*ENDIF*) 
        IF  (a_ap_tree^[comment_node].n_symb <> s_parameter_name) AND
            (a_returncode = 0)
        THEN
            BEGIN
            a06reset_retpart (acv);
            last_node   := a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_sa_level;
            a_data_part := a_cmd_part;
            IF  g01unicode
            THEN
                dtyp := dunicode
            ELSE
                dtyp := dcha;
            (*ENDIF*) 
            REPEAT
&               ifdef trace
                t01int4 (ak_sem, 'comment_node', comment_node);
&               endif
                IF  a_ap_tree^ [first_node].n_subproc = cak_i_list
                THEN
                    BEGIN
                    a05_identifier_get (acv, comment_node,
                          sizeof (columnn), columnn);
                    comment_node :=
                          a_ap_tree^[comment_node].n_sa_level;
                    IF  a061exist_columnname (base_ptr^.sbase,
                        columnn, col_ptr)
                    THEN
                        WITH col_ptr^, a_ap_tree^[comment_node] DO
                            BEGIN
                            WITH long_desc DO
                                BEGIN
                                lds_intern_pos   := 1;
                                ldc_comment_type := cm_column;
                                lds_colno        := cextcolno;
                                lds_infoset      := [ld_is_comment]
                                END;
                            (*ENDWITH*) 
                            comment_pos  := n_pos;
                            comment_len  := n_length;
                            a05string_literal_get (acv, comment_node,
                                  dtyp, a_cmd_part^.sp1p_buf,
                                  n_pos, n_length);
                            comment_node := n_sa_level
                            END
                        (*ENDWITH*) 
                    ELSE
                        a07_b_put_error (acv, e_unknown_columnname,
                              a_ap_tree^[last_node].n_pos)
                    (*ENDIF*) 
                    END
                ELSE
                    WITH a_ap_tree^[comment_node] DO
                        BEGIN
                        comment_pos  := n_pos;
                        comment_len  := n_length;
                        a05string_literal_get (acv, comment_node,
                              dtyp, a_cmd_part^.sp1p_buf, n_pos, n_length);
                        comment_node := n_sa_level
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
                WITH long_desc DO
                    BEGIN
                    lds_valpos  := comment_pos;
                    lds_vallen  := comment_len;
                    lds_valmode := vm_lastdata;
                    (* PTS 1105838 E.Z. *)
                    lds_state   := [ ld_short_scol ];
                    END;
                (*ENDWITH*) 
                comment_added := true;
                a26add_comment (acv, long_desc);
            UNTIL
                (comment_node = 0) OR
                (a_returncode <> 0)
            (*ENDREPEAT*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  dmli.d_sparr.px[1] <> NIL
    THEN
        BEGIN
        a10get_sysinfo (acv, sysk, d_fix, dmli.d_sparr.px[1], b_err);
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  reset_packet
    THEN
        a542reset_packet (acv);
    (*ENDIF*) 
    IF  a_returncode <> 0
    THEN
        a_part_rollback := true
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a26get_comment_prefix (
            VAR acv       : tak_all_command_glob;
            VAR long_desc : tak_long_descriptor;
            VAR buf       : tsp00_Buf;
            pos           : integer;
            required_len  : integer);
      (* PTS 1110034 E.Z. *)
 
CONST
      c_unicode_dot = '\00\2E';
 
VAR
      b_err       : tgg00_BasisError;
      full_len    : tsp00_Int4;
      comment_buf : tak_sysbufferaddress;
      syskey      : tgg00_SysInfoKey;
 
BEGIN
ak26obuild_comment_key (long_desc, syskey);
a10get_sysinfo (acv, syskey, d_release, comment_buf, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    full_len := s20buf_to_int4_swap (comment_buf^,
          cgg_rec_key_offset + syskey.skeylen + sizeof (tsp00_C2) + 1,
          sw_normal, g01code.kernel_swap);
    IF  full_len <= required_len
    THEN
        BEGIN
        SAPDB_PascalMove ('VAK26 ',  10,    
              sizeof (comment_buf^), sizeof (buf), @comment_buf^,
              cgg_rec_key_offset + comment_buf^.syskey.skeylen +
              sizeof(tsp00_C2) + 4 + 1, @buf, pos, full_len,
              acv.a_returncode);
        IF  full_len < required_len
        THEN
            IF  g01unicode
            THEN
                SAPDB_PascalForcedUnicodeFill (sizeof (buf), @buf, pos + full_len,
                      required_len - full_len, csp_unicode_blank)
            ELSE
                SAPDB_PascalFill ('VAK26 ',  11,    
                      sizeof (buf), @buf, pos + full_len,
                      required_len - full_len, bsp_c1,
                      acv.a_returncode)
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (* PTS 1110034 E.Z. *)
    ELSE
        BEGIN
        SAPDB_PascalMove ('VAK26 ',  12,    
              sizeof (comment_buf^), sizeof (buf), @comment_buf^,
              cgg_rec_key_offset + comment_buf^.syskey.skeylen +
              sizeof(tsp00_C2) + 4 + 1, @buf, pos, required_len - 3*a01char_size,
              acv.a_returncode);
        IF  g01unicode
        THEN
            (* PTS 1113786 E.Z. *)
            SAPDB_PascalForcedUnicodeFill (sizeof (buf), @buf, pos + required_len - 3*a01char_size,
                  3*a01char_size, c_unicode_dot)
        ELSE
            SAPDB_PascalFill ('VAK26 ',  13,    
                  sizeof (buf), @buf, pos + required_len - 3*a01char_size,
                  3, '.', acv.a_returncode);
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
ELSE
    a07_b_put_error (acv, b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a26getval (
            VAR acv           : tak_all_command_glob;
            VAR long_desc     : tak_long_descriptor;
            VAR ret_long_qual : tgg00_LongQual);
 
VAR
      exit_loop     : boolean;
      b_err         : tgg00_BasisError;
      required_len  : tsp00_Int4;
      rec_len       : tsp00_Int4;
      move_len      : tsp00_Int4;
      comment_len   : tsp00_Int4;
      comment_pos   : tsp00_Int4;
      space_in_rec  : tsp00_Int4;
      rest_buf_size : tsp00_Int4;
      curr_data_ptr : tsp00_MoveObjPtr;
      comment_buf   : tak_sysbufferaddress;
      syskey        : tgg00_SysInfoKey;
      err_char_no   : tsp00_Int4;
      uni_err       : tsp8_uni_error;
 
BEGIN
ret_long_qual := g01nil_long_qual;
WITH acv, long_desc, ret_long_qual DO
    BEGIN
    curr_data_ptr := @a_curr_retpart^.sp1p_buf [lds_valpos];
    rest_buf_size := a_curr_retpart^.sp1p_buf_size - lds_valpos + 1;
    required_len  := lds_vallen;
    lds_vallen    := 0;
    ak26build_comment_key (long_desc, syskey);
    space_in_rec := MAX_RECLEN_GG00 - cgg_rec_key_offset -
          syskey.skeylen - sizeof (tsp00_C2);
    IF  g01unicode AND ((space_in_rec MOD 2) = 1)
    THEN
        space_in_rec := pred (space_in_rec);
    (*ENDIF*) 
    syskey.slinkage [2] := chr((lds_intern_pos+4) DIV space_in_rec + 1);
    comment_pos         := (lds_intern_pos + 4) MOD space_in_rec;
    exit_loop           := false;
    REPEAT
        a10get_sysinfo (acv, syskey, d_release, comment_buf, b_err);
        IF  b_err = e_ok
        THEN
            BEGIN
            rec_len     := comment_buf^.b_sl;
            comment_len := rec_len - cgg_rec_key_offset - syskey.skeylen
                  - sizeof (tsp00_C2) - comment_pos + 1;
            (* PTS 1105838 E.Z. *)
            IF  (g01unicode) AND
                (ld_use_ucs_2_swap in lds_state)
            THEN
                BEGIN
                IF  rest_buf_size + lds_vallen > required_len
                THEN
                    move_len := required_len - lds_vallen
                ELSE
                    move_len := rest_buf_size;
                (*ENDIF*) 
                s80uni_trans (@(comment_buf^.ssysbuf[cgg_rec_key_offset +
                      comment_buf^.syskey.skeylen + sizeof (tsp00_C2) +
                      comment_pos]), comment_len, csp_unicode,
                      @(curr_data_ptr^[lds_vallen+1]), move_len,
                      csp_unicode_swap, [ ], uni_err, err_char_no);
                IF  (move_len = required_len - lds_vallen) OR
                    (uni_err <> uni_ok)
                THEN
                    BEGIN
                    exit_loop := true;
                    IF  uni_err = uni_dest_too_short
                    THEN
                        comment_len := move_len; (* h.b. PTS 1107587 *)
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  NOT (uni_err in [ uni_ok, uni_dest_too_short ])
                THEN
                    a07_uni_error (acv, uni_err, err_char_no);
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  lds_vallen + comment_len >= required_len
                THEN
                    BEGIN
                    comment_len := required_len - lds_vallen;
                    exit_loop   := true
                    END;
&               ifdef trace
                (*ENDIF*) 
                t01int4 (ak_sem, 'comment_len ', comment_len);
                t01int4 (ak_sem, 'lds_vallen  ', lds_vallen);
&               endif
                IF  comment_len > rest_buf_size - lds_vallen
                THEN
                    comment_len := rest_buf_size - lds_vallen;
                (*ENDIF*) 
                move_len := comment_len;
                SAPDB_PascalMove ('VAK26 ',  14,    
                      sizeof (comment_buf^), rest_buf_size, @comment_buf^,
                      cgg_rec_key_offset + comment_buf^.syskey.skeylen +
                      sizeof (tsp00_C2) + comment_pos,
                      @curr_data_ptr^, lds_vallen + 1, move_len,
                      a_returncode);
                END;
            (*ENDIF*) 
            lds_vallen     := lds_vallen + move_len;
            lds_intern_pos := lds_intern_pos + comment_len;
&           ifdef trace
            t01int4 (ak_sem, 'intern_pos  ', long_desc.lds_intern_pos);
&           endif
            rest_buf_size := rest_buf_size - move_len;
            IF  rest_buf_size = 0
            THEN
                exit_loop := true;
            (*ENDIF*) 
            a06inc_linkage (syskey.slinkage);
            comment_pos := 1
            END
        ELSE
            exit_loop := true;
        (*ENDIF*) 
    UNTIL
        exit_loop OR
        (rec_len < sizeof (tak_comment_record));
    (*ENDREPEAT*) 
    IF  (b_err = e_ok) AND (a_returncode = 0)
    THEN
        BEGIN
        IF  comment_buf^.syskey.slinkage <> cak_init_linkage
        THEN
            BEGIN
            syskey.slinkage := cak_init_linkage;
            a10get_sysinfo (acv, syskey, d_release, comment_buf, b_err)
            END;
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            BEGIN
            comment_len := s20buf_to_int4_swap (comment_buf^, cgg_rec_key_offset +
                  syskey.skeylen + sizeof (tsp00_C2) + 1,
                  sw_normal, g01code.kernel_swap);
&           ifdef trace
            t01int4 (ak_sem, 'comment_len ', comment_len);
&           endif
            lq_pos       := lds_intern_pos;
            lq_long_size := comment_len;
            (* PTS 1105838 E.Z. *)
            lds_maxlen   := comment_len;
            IF  lds_intern_pos > comment_len
            THEN
                lds_valmode := vm_lastdata
            ELSE
                lds_valmode := vm_datapart
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
