.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 2000-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-22
*****************************************************
modname : VAK45
changed : 2000-11-22
module  : AK_Show_index_link
 
Author  : ThomasA
Created : 1987-09-22
*****************************************************
 
Purpose : Show Index und Link semantische Routinen.
 
Define  :
 
        PROCEDURE
              a45_call_semantic (
                    VAR acv           : tak_all_command_glob;
                    VAR a41v          : tak40_show_glob;
                    onlyUpdStatWanted : boolean;
                    sample_rows       : tsp00_Int4;
                    sample_pct        : integer);
 
        PROCEDURE
              a45bad_index_show (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a45show_execute (
                    VAR acv    : tak_all_command_glob;
                    VAR   a41v : tak40_show_glob;
                    kw_index   : integer);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
&       ifdef trace
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01int4 (
                    layer   : tgg00_Debug;
                    nam     : tsp00_Sname;
                    int     : tsp00_Int4);
 
        PROCEDURE
              t01lidentifier (
                    layer      : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier);
&       endif
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01_il_b_identifier  : tsp00_KnlIdentifier;
 
        PROCEDURE
              a01sets_identifier (
                    VAR id         : tsp00_KnlIdentifier;
                    set_identifier : tak_oldidentifier);
 
      ------------------------------ 
 
        FROM
              AK_Index : VAK24;
 
        PROCEDURE
              a24get_indexname (
                    VAR acv        : tak_all_command_glob;
                    indexbuf       : tak_sysbufferaddress;
                    index          : integer;
                    VAR index_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a24init_index_scan (
                    VAR acv            : tak_all_command_glob;
                    VAR tabid          : tgg00_Surrogate;
                    VAR index_scan_rec : tak_index_scan_record);
 
        PROCEDURE
              a24finish_index_scan (
                    VAR acv            : tak_all_command_glob;
                    VAR index_scan_rec : tak_index_scan_record);
 
        FUNCTION
              a24next_named_index (
                    VAR acv            : tak_all_command_glob;
                    VAR index_scan_rec : tak_index_scan_record) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Link : VAK25;
 
        PROCEDURE
              a25FindForeignKeyInfo (
                    VAR acv             : tak_all_command_glob;
                    VAR PrimaryKeyBuf   : tak_sysbufferaddress;
                    PrimaryKeyIndex     : integer;
                    VAR ForeignKeyBuf   : tak_sysbufferaddress;
                    VAR ForeignKeyIndex : integer);
 
        PROCEDURE
              a25get_linkname (
                    VAR acv        : tak_all_command_glob;
                    linkbuf        : tak_sysbufferaddress;
                    index          : integer;
                    VAR link_name  : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_update_statistics : VAK28;
 
        PROCEDURE
              a28add_table_upd_statistics (
                    VAR acv       : tak_all_command_glob;
                    updStatObj    : tsp00_Addr;
                    bForceUpdStat : boolean;
                    sample_rows   : tsp00_Int4;
                    sample_pct    : integer);
 
        PROCEDURE
              a28table_upd_statistics (
                    VAR acv       : tak_all_command_glob;
                    bForceUpdStat : boolean;
                    sample_rows   : tsp00_Int4;
                    sample_pct    : integer;
                    page_cnt      : tsp00_Int4;
                    rec_cnt       : tsp00_Int4;
                    sec_cnt       : tsp00_Int4;
                    colno         : integer;
                    add           : boolean;
                    commit        : boolean);
 
        FUNCTION
              a28nextUpdStatWantedEntry(
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob;
                    VAR key  : tgg00_Lkey) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_universal_show_tools : VAK40;
 
        VAR
              a40yes_no : ARRAY[boolean] OF tsp00_C3;
 
        PROCEDURE
              a40get_catalog_table (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a40comment_descriptor (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    comment_exist : boolean;
                    VAR tabid     : tgg00_Surrogate;
                    column_no     : integer;
                    comment_kind  : tak_comment_type);
 
        PROCEDURE
              a40datatype_code (
                    VAR col_info : tak00_columninfo;
                    is_oracle    : boolean;
                    comp_type    : tak_appl_type;
                    VAR datatype : tsp00_Sname;
                    VAR code     : tsp00_C10;
                    VAR datalen  : integer);
 
        PROCEDURE
              a40FinishTableScan (
                    VAR acv          : tak_all_command_glob;
                    VAR a41v         : tak40_show_glob);
 
        PROCEDURE
              a40move (
                    VAR acv     : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : integer);
 
        PROCEDURE
              a40move_const (
                    VAR acv     : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : integer);
 
        PROCEDURE
              a40move_i4 (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    i4_val        : tsp00_Int4;
                    is_null       : boolean;
                    frac          : integer;
                    zero_to_undef : boolean);
 
        PROCEDURE
              a40put_date_time (
                    VAR acv      : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    VAR datetime : tsp00_Int4;
                    date         : boolean;
                    is_undef     : boolean);
 
        PROCEDURE
              a40init_table_scan (
                    VAR acv          : tak_all_command_glob;
                    VAR a41v         : tak40_show_glob;
                    scan_temp        : boolean;
                    scan_private     : boolean;
                    scan_non_private : boolean;
                    scan_public      : boolean;
                    use_synonyms     : boolean;
                    all_base         : boolean);
 
        FUNCTION
              a40next_table (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob) : boolean;
 
        PROCEDURE
              a40table_column_to_shbuf (
                    VAR acv      : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    base_ptr     : tak_sysbufferaddress;
                    colindex     : integer;
                    with_owner   : boolean);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache  : VAK10;
 
        PROCEDURE
              a10_cache_delete  (
                    VAR acv     : tak_all_command_glob;
                    is_rollback : boolean);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey;
                    dstate     : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10next_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    stop_prefix  : integer;
                    dstate       : tak_directory_state;
                    rec_kind     : tsp00_C2;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10table_cache_delete (
                    VAR acv     : tak_all_command_glob;
                    VAR tableid : tgg00_Surrogate);
 
        PROCEDURE
              a10_rel_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        PROCEDURE
              a101_CreateUpdStatObject (
                    VAR acv          : tak_all_command_glob;
                    VAR updStatObj   : tsp00_Addr;
                    sampleRows       : tsp00_Int4;
                    samplePercentage : tsp00_Int4);
 
        PROCEDURE
              a101_DestroyUpdStatObject (
                    VAR acv        : tak_all_command_glob;
                    VAR updStatObj : tsp00_Addr);
 
        PROCEDURE
              a101_UpdStatProcessRequests (
                    VAR acv    : tak_all_command_glob;
                    updStatObj : tsp00_Addr);
 
        FUNCTION
              a101_ParallelUpdStatEnabled : boolean;
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate (* ptocConst *);
                    VAR schemaName : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06extcolno (
                    VAR baserec  : tak_baserecord;
                    extcolno     : integer;
                    VAR col_ptr  : tak00_colinfo_ptr);
 
        PROCEDURE
              a06get_username (
                    VAR acv        : tak_all_command_glob;
                    VAR tree_index : integer;
                    VAR username   : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06_systable_get (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR tableid  : tgg00_Surrogate;
                    VAR base_ptr : tak_sysbufferaddress;
                    get_all      : boolean;
                    VAR ok       : boolean);
 
        FUNCTION
              a06_table_exist (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR authname : tsp00_KnlIdentifier;
                    VAR tablen   : tsp00_KnlIdentifier;
                    VAR d_sparr  : tak_syspointerarr;
                    get_all      : boolean) : boolean;
 
        PROCEDURE
              a06_get_priv  (
                    VAR acv  : tak_all_command_glob;
                    VAR brec : tak_sysbufferaddress;
                    VAR priv : tak_privilege);
 
        PROCEDURE
              a06det_user_id (
                    VAR acv      : tak_all_command_glob;
                    VAR authname : tsp00_KnlIdentifier;
                    VAR authid   : tgg00_Surrogate);
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        FUNCTION
              a061identifier_len (VAR id : tsp00_KnlIdentifier) : integer;
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1  : VBD01;
 
        VAR
              b01niltree_id      : tgg00_FileId;
 
        PROCEDURE
              b01filestate (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              FileDir_Wrapper : vbd998;
 
        PROCEDURE
              bd998NewBadIndexIterator (
                    VAR trans          : tgg00_TransContext;
                    VAR iteratorPtr    : tsp00_Addr);
 
        PROCEDURE
              bd998DestroyBadIndexIterator (
                    VAR trans          : tgg00_TransContext;
                    VAR iteratorPtr    : tsp00_Addr);
 
        PROCEDURE
              bd998AdvanceBadIndexIterator (
                    VAR trans          : tgg00_TransContext;
                    VAR iteratorPtr    : tsp00_Addr;
                    VAR fileId         : tgg00_FileId);
 
        FUNCTION
              bd998GetIndexUsageCount(
                    VAR trans         : tgg00_TransContext;
                    VAR indexFileSurr : tgg00_Surrogate) : tsp00_Int4;
 
        PROCEDURE
              bd998GetTableFileNoForIndex (
                    VAR trans            : tgg00_TransContext;
                    VAR indexSurrogate   : tgg00_Surrogate;
                    VAR tableSurrogate   : tgg00_Surrogate;
                    VAR b_err            : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04index_tree_build (
                    VAR file_id    : tgg00_FileId (*ptocConst*);
                    VAR index_tree : tgg00_FileId;
                    index_no       : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30eq (
                    VAR a  : tsp00_KnlIdentifier;
                    VAR b  : tsp00_KnlIdentifier;
                    bi,cnt : tsp00_Int4) : boolean;
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              s30eq;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
.CM *-END-* synonym -------------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      c6unique        = 'UNIQUE';
      c8asc           = 'ASC     ';
      c8desc          = 'DESC    ';
      c_null          = true;
      c_to_undef      = true;
      c_with_owner    = true;
      c_forceUpdStat  = true;
      x_references    = 1;
      x_to            = 2;
      c_is_key        = TRUE;
 
TYPE
      (* PTS 1132536 M.Ki. *)
      tak45_index_state = (a45is_ok, a45is_bad, a45is_missing);
 
 
(*------------------------------*) 
 
PROCEDURE
      a45_call_semantic (
            VAR acv           : tak_all_command_glob;
            VAR   a41v        : tak40_show_glob;
            onlyUpdStatWanted : boolean;
            sample_rows       : tsp00_Int4;
            sample_pct        : integer);
 
CONST
      c_is_rollback = true;
 
VAR
      localCacheUsageOnly : boolean;
      first_table         : boolean;
      curr_ti             : integer;
      tab_len             : integer;
      tab_len2            : integer;
      tab_count           : integer;
      updStatObj          : tsp00_Addr;
 
BEGIN
a41v.a4sh_kind := sh_no_kind;
curr_ti := acv.a_ap_tree^[ a41v.a4ti ].n_sa_level;
first_table := true;
tab_len := 0;
curr_ti  := acv.a_ap_tree^[ a41v.a4ti ].n_lo_level;
tab_len2 := 0;
IF  curr_ti <> 0
THEN
    BEGIN
    WITH acv.a_ap_tree^[ curr_ti ] DO
        IF  n_symb = s_authid
        THEN
            IF  first_table
            THEN
                a06get_username (acv, curr_ti, a41v.a4authname)
            ELSE
                a06get_username (acv, curr_ti, a41v.a4user);
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDWITH*) 
    IF  (a41v.a4authname = a01_il_b_identifier) AND (* PTS 1110926 *)
        (NOT (acv.a_current_user_kind in [usysdba, ucontroluser]))
    THEN
        a41v.a4authname := acv.a_curr_user_name;
    (*ENDIF*) 
    WITH acv.a_ap_tree^[ curr_ti ] DO
        IF  (n_symb = s_tablename) OR (n_symb = s_like)
        THEN
            BEGIN
            IF  first_table
            THEN
                a05identifier_get (acv, curr_ti,
                      sizeof (a41v.a4tablen), a41v.a4tablen)
            ELSE
                a05identifier_get (acv, curr_ti,
                      sizeof (a41v.a4coln), a41v.a4coln);
            (*ENDIF*) 
            IF  n_symb = s_like
            THEN
                IF  first_table
                THEN
                    tab_len := n_length
                ELSE
                    tab_len2 := n_length
                (*ENDIF*) 
            ELSE
                IF  NOT first_table
                THEN
                    tab_len2 := sizeof (a41v.a4tablen)
                ELSE
                    tab_len := sizeof (a41v.a4tablen);
                (*ENDIF*) 
            (*ENDIF*) 
            curr_ti := n_sa_level;
            END;
        (*ENDIF*) 
    (*ENDWITH*) 
    END;
&ifdef trace
(*ENDIF*) 
t01int4 (ak_sem, 'tab_len     ', tab_len);
t01int4 (ak_sem, 'tab_len2    ', tab_len2);
&endif
a41v.a4synname := a41v.a4tablen;
localCacheUsageOnly := acv.a_localCacheUsageOnly;
IF  acv.a_ap_tree^[a41v.a4ti].n_subproc = cak_i_statistics
THEN
    BEGIN
    (* in case of update statistics the shared cache must not be used *)
    acv.a_localCacheUsageOnly := true;
    a10_cache_delete (acv, NOT c_is_rollback);
    END;
(*ENDIF*) 
updStatObj := NIL;
IF  a101_ParallelUpdStatEnabled
THEN
    a101_CreateUpdStatObject (acv, updStatObj, sample_rows, sample_pct);
(*ENDIF*) 
IF  updStatObj <> NIL
THEN
    (* don't lock catalog records while we are only collecting which tables *)
    (* to process                                                           *)
    acv.a_is_ddl := no_ddl;
(*ENDIF*) 
IF  onlyUpdStatWanted
THEN
    BEGIN
    IF  acv.a_current_user_kind in [usysdba, ucontroluser]
    THEN
        ak45process_upd_stat_wanted (acv, a41v, updStatObj, sample_rows, sample_pct)
    ELSE
        a07_b_put_error (acv, e_missing_privilege, 1);
    (*ENDIF*) 
    END
ELSE
    BEGIN
    IF  NOT ( acv.a_current_user_kind in [usysdba, ucontroluser] )
    THEN (* Update Statistics by user *)
        BEGIN
        tab_count := 0;
        ak45user_table_scan( acv, a41v, updStatObj, tab_len, tab_len2, tab_count,
              sample_rows, sample_pct );
        IF  tab_count = 0
        THEN
            IF  tab_len = sizeof (a41v.a4tablen)
            THEN
                a07_b_put_error (acv, e_unknown_tablename, 1)
            ELSE
                a07_b_put_error (acv, e_row_not_found, 1);
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE (* Update Statistics by System User *)
        ak45all_table_scan( acv, a41v, updStatObj, tab_len,
              sample_rows, sample_pct );
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  updStatObj <> NIL
THEN
    BEGIN
    IF  acv.a_returncode = 0
    THEN
        a101_UpdStatProcessRequests (acv, updStatObj);
    (*ENDIF*) 
    a101_DestroyUpdStatObject (acv, updStatObj);
    END;
(*ENDIF*) 
acv.a_localCacheUsageOnly := localCacheUsageOnly
END;
 
(*------------------------------*) 
 
PROCEDURE
      a45show_execute (
            VAR acv    : tak_all_command_glob;
            VAR   a41v : tak40_show_glob;
            kw_index   : integer);
 
VAR
      tab_count  : integer;
      aux_owner  : tsp00_KnlIdentifier;
      aux_tablen : tsp00_KnlIdentifier;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    IF  kw_index = cak_i_foreign
    THEN
        BEGIN
        a_ap_tree^[a4ti].n_subproc := cak_i_foreign + x_references;
        IF  (a4user <> a01_il_b_identifier) AND
            (a4coln <> a01_il_b_identifier)
        THEN
            BEGIN
            (* foreign key table specified *)
            aux_owner  := a4authname;
            aux_tablen := a4tablen;
            a4authname := a4user;
            a4tablen   := a4coln;
            a4user     := aux_owner;
            a4coln     := aux_tablen;
            a4col_len  := a4tab_len;
            a4tab_len  := sizeof (a4tablen);
            END
        ELSE
            IF  (a4authname <> a01_il_b_identifier) AND
                (a4tablen   <> a01_il_b_identifier)
            THEN
                a_ap_tree^[a4ti].n_subproc := cak_i_foreign + x_to;
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        a_ap_tree^[a4ti].n_subproc := kw_index;
    (*ENDIF*) 
&   ifdef trace
    t01lidentifier (ak_sem, a4authname);
    t01lidentifier (ak_sem, a4tablen);
    t01lidentifier (ak_sem, a4user);
    t01lidentifier (ak_sem, a4coln);
    t01int4 (ak_sem, 'n_pos       ', a_ap_tree^[a4ti].n_pos);
&   endif
    a40get_catalog_table (acv, a41v);
    tab_count := 0;
    ak45user_table_scan (acv, a41v, NIL, a4tab_len, a4col_len, tab_count, 0, 0)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak45add_index (
            VAR acv        : tak_all_command_glob;
            VAR a41v       : tak40_show_glob;
            VAR colinfo    : tak00_columninfo;
            colno          : integer;
            comment_type   : tak_comment_type;
            index_used     : tsp00_Int4;
            resetDate      : tsp00_Int4;
            resetTime      : tsp00_Int4;
            index_state    : tak45_index_state;
            index_disabled : boolean;
            comment_exist  : boolean;
            comment_id     : integer);
 
CONST
      c_stateOk          = 'OK';
      c_okStateLen       = 2;
      c_stateBad         = 'BAD';
      c_badStateLen      = 3;
      c_stateMissing     = 'MISSING';
      c_missingStateLen  = 7;
 
VAR
      datalen  : integer;
      code     : tsp00_C10;
      datatype : tsp00_Sname;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    a40move_i4 (acv, a41v, colno, NOT c_null, 0, NOT c_to_undef);
    a40datatype_code (colinfo, a_sqlmode = sqlm_oracle,
          a_comp_type, datatype, code, datalen);
    a40move_const (acv, a41v, @datatype, sizeof (datatype));
    a40move_i4    (acv, a41v, colinfo.cdatalen,
          NOT c_null, 0, NOT c_to_undef);
    (* PTS 1114498 E.Z. *)
    a40move_i4 (acv, a41v, index_used,
          NOT c_null, 0, NOT c_to_undef);
    a40put_date_time (acv, a41v, resetDate, true, false);
    a40put_date_time (acv, a41v, resetTime, false, false);
    CASE index_state OF
        a45is_ok:
            a40move_const (acv, a41v, @c_stateOk, c_okStateLen);
        a45is_bad:
            a40move_const (acv, a41v, @c_stateBad, c_badStateLen);
        a45is_missing:
            a40move_const (acv, a41v, @c_stateMissing, c_missingStateLen);
        END;
    (*ENDCASE*) 
    a40move_const (acv, a41v, @a40yes_no [index_disabled],
          sizeof (a40yes_no[true]));
    a40comment_descriptor (acv, a41v, comment_exist AND (colno = 1),
          a4p_arr.pbasep^.sbase.bsurrogate,
          comment_id, comment_type)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a45bad_index_show (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      ok             : boolean;
      found          : boolean;
      index_id       : integer;
      b_err          : tgg00_BasisError;
      base_ptr       : tak_sysbufferaddress;
      iterator_ptr   : tsp00_Addr;
      table_surr     : tgg00_Surrogate;
      schema         : tsp00_KnlIdentifier;
      indexn         : tsp00_KnlIdentifier;
      file_id        : tgg00_FileId;
      index_scan_rec : tak_index_scan_record;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    a40get_catalog_table (acv, a41v);
    file_id := b01niltree_id;
    bd998NewBadIndexIterator (acv.a_transinf.tri_trans, iterator_ptr);
    REPEAT
        bd998AdvanceBadIndexIterator (
              acv.a_transinf.tri_trans, iterator_ptr, file_id);
        IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
        THEN
            BEGIN
            bd998GetTableFileNoForIndex (
                  acv.a_transinf.tri_trans,
                  file_id.fileTabId_gg00,
                  table_surr,
                  b_err);
            IF  b_err = e_ok
            THEN
                a06_systable_get (acv, d_fix, table_surr,
                      base_ptr, true, ok)
            ELSE
                BEGIN
                acv.a_transinf.tri_trans.trError_gg00 := b_err;
                ok := false;
                END;
            (*ENDIF*) 
            IF  ok
            THEN
                BEGIN
                a103GetSchemaName (acv, base_ptr^.sbase.bschema, schema);
                a40move (acv, a41v, @schema, sizeof (schema));
                a40move (acv, a41v, @schema, sizeof (schema));
                a40move (acv, a41v, @base_ptr^.sbase.btablen^,
                      sizeof(base_ptr^.sbase.btablen^));
                (* PTS 1115043 E.Z. *)
                indexn := a01_il_b_identifier;
                index_id := ord(file_id.fileTfnNo_gg00[1]);
                IF  base_ptr^.sbase.bindexexist
                THEN
                    WITH index_scan_rec DO
                        BEGIN
                        found := false;
                        a24init_index_scan (acv,
                              base_ptr^.sbase.bsurrogate,
                              index_scan_rec);
                        WHILE a24next_named_index (acv, index_scan_rec)
                              AND NOT found DO
                            WITH isr_buf^.smindex.indexdef[isr_index] DO
                                IF  indexno = index_id
                                THEN
                                    BEGIN
                                    found  := true;
                                    a24get_indexname (acv, isr_buf,
                                          isr_index, indexn)
                                    END;
                                (*ENDIF*) 
                            (*ENDWITH*) 
                        (*ENDWHILE*) 
                        a24finish_index_scan (acv, index_scan_rec)
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
                a40move (acv, a41v, @indexn, sizeof (indexn));
                a10rel_sysinfo (base_ptr)
                END
            ELSE
                BEGIN
                a_transinf.tri_trans.trError_gg00 := e_no_next_record;
                a07_b_put_error (acv, e_unknown_tablename, 1)
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    UNTIL
        a_transinf.tri_trans.trError_gg00 <> e_ok;
    (*ENDREPEAT*) 
    bd998DestroyBadIndexIterator (acv.a_transinf.tri_trans, iterator_ptr);
    IF  a_transinf.tri_trans.trError_gg00 <> e_file_not_found
    THEN
        a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak45index_show (
            VAR acv     : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            VAR priv    : tak_privilege);
 
VAR
      keypos           : integer;
 
BEGIN
WITH acv, a41v  DO
    IF  (a_returncode = 0) AND
        (a_ex_kind <> only_parsing)
    THEN
        WITH a_p_arr1, pbasep^, syskey, sbase DO
            BEGIN
            a4pos  := 1;
            keypos := 1;
            a40table_column_to_shbuf (acv, a41v, a_p_arr1.pbasep, -1, c_with_owner);
            IF  bindexexist
            THEN
                BEGIN
                ak45multiindex_put (acv, a41v, priv);
                END;
            (*ENDIF*) 
            IF  a4sh_kind = sh_odbc_index (* PTS 1114119 *)
            THEN
                ak45key_as_index (acv, a41v, priv)
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak45key_as_index (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            VAR priv : tak_privilege);
 
VAR
      ci       : integer;
      ix       : integer;
      colno    : integer;
      offset   : integer;
      indexrec : tak_mindexrecord;
 
BEGIN
WITH acv, indexrec.indexdef[1] DO
    BEGIN
    WITH a_p_arr1.pbasep^.sbase DO
        BEGIN
        (* PTS 1110481 E.Z. *)
        indexn_prefix := 'SYSPRIMARYKEYINDEX';
        indexno       := 1;
        (* icount see below *)
        ifill         := false;
        (* icolseq see below *)
        iunique       := true;
        icomment      := false;
        idatecre      := bdatecreate;
        itimecre      := btimecreate;
        ifiller2      := 0;
        iinitdate     := bdatecreate;
        iinittime     := btimecreate;
        ifiller       := false;
        idisabled     := false;
        ifiller1      := false; (* PTS 1114312 *)
        isuffixlen    := 0;
        ci            := bfirstcolind
        END;
    (*ENDWITH*) 
    ix     := 1;
    offset := 0;
    FOR colno := 1 TO a_p_arr1.pbasep^.sbase.bkeycolcount DO
        WITH a103GetColumn (a_p_arr1.pbasep^.sbase, ci)^ DO
            BEGIN
            icolseq  [ix]       := cextcolno;
            icolstack[ix].etype := ccolstack.etype;
            icolstack[ix].eop   := op_unique;
            ix                  := ix + 1;
            IF  (ix > MAX_COL_SEQUENCE_GG00) OR
                (ccolstack.etype = st_varkey)
            THEN
                BEGIN
                icount := ix - 1;
                IF  icount < MAX_COL_SEQUENCE_GG00
                THEN
                    icolseq[icount+1] := 0;
                (*ENDIF*) 
                ix  := 1;
                ak45one_named_index (acv, a41v,
                      c_is_key, @indexrec, 1, offset, priv);
                offset := offset + MAX_COL_SEQUENCE_GG00
                END;
            (*ENDIF*) 
            ci := cnextind
            END;
        (*ENDWITH*) 
    (*ENDFOR*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak45multiindex_put (
            VAR acv              : tak_all_command_glob;
            VAR a41v             : tak40_show_glob;
            VAR priv             : tak_privilege);
 
VAR
      colno          : integer;
      index_scan_rec : tak_index_scan_record;
 
BEGIN
WITH acv, a41v, index_scan_rec DO
    BEGIN
    a24init_index_scan (acv, a_p_arr1.pbasep^.sbase.bsurrogate,
          index_scan_rec);
    colno := a4pos;
    WHILE a24next_named_index (acv, index_scan_rec) DO
        WITH isr_buf^.smindex.indexdef[isr_index] DO
            BEGIN
            a4pos := colno;
            ak45one_named_index (acv, a41v,
                  NOT c_is_key, isr_buf, isr_index, 0, priv)
            END;
        (*ENDWITH*) 
    (*ENDWHILE*) 
    a4pos := colno;
    a24finish_index_scan (acv, index_scan_rec)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak45one_named_index (
            VAR acv              : tak_all_command_glob;
            VAR a41v             : tak40_show_glob;
            is_key               : boolean;
            indexbuf             : tak_sysbufferaddress;
            index                : integer;
            offset               : integer;
            VAR priv             : tak_privilege);
 
VAR
      show          : boolean;
      col_cnt       : integer;
      exit_loop     : boolean;
      ecolno        : integer;
      i             : integer;
      j1            : integer;
      curr_col      : integer;
      index_state   : tak45_index_state;
      inv_usage_cnt : tsp00_Int4;
      col_ptr       : tak00_colinfo_ptr;
      unique        : tsp00_C6;
      ityp          : tsp00_C8;
      indexname     : tsp00_KnlIdentifier;
      index_tree    : tgg00_FileId;
 
BEGIN
WITH acv, a41v, a_p_arr1, indexbuf^.smindex.indexdef[index] DO
    BEGIN
    IF  indexno <> 0
    THEN
        BEGIN
        IF  iunique
        THEN
            unique := c6unique
        ELSE
            unique := bsp_c6;
        (*ENDIF*) 
        IF  is_key
        THEN
            a01sets_identifier (indexname, 'SYSPRIMARYKEYINDEX')
        ELSE
            a24get_indexname (acv, indexbuf, index, indexname);
        (*ENDIF*) 
        show      := true;
        col_cnt   := 0;
        exit_loop := false;
        REPEAT
&           ifdef trace
            IF  col_cnt < MAX_COL_SEQUENCE_GG00
            THEN
                t01int4 (ak_sem, 'icolseq     ',
                      icolseq[col_cnt+1]);
&           endif
            (*ENDIF*) 
            IF  col_cnt = MAX_COL_SEQUENCE_GG00
            THEN
                exit_loop := true
            ELSE
                IF  icolseq[col_cnt + 1] <> 0
                THEN
                    col_cnt := col_cnt + 1
                ELSE
                    exit_loop := true;
                (*ENDIF*) 
            (*ENDIF*) 
        UNTIL
            exit_loop;
        (*ENDREPEAT*) 
&       ifdef trace
        t01int4 (ak_sem, 'col_cnt     ', col_cnt);
&       endif
        IF  NOT (r_owner in priv.priv_all_set) AND
            NOT (r_index in priv.priv_all_set) AND
            NOT (r_sel in priv.priv_all_set)
        THEN
            FOR i := 1 TO col_cnt DO
                IF  NOT (icolseq[i] in priv.priv_sel_set)
                THEN
                    show := false;
                (*ENDIF*) 
            (*ENDFOR*) 
        (*ENDIF*) 
        IF  show
        THEN
            BEGIN
            IF  NOT is_key
            THEN
                g04index_tree_build (
                      a_p_arr1.pbasep^.sbase.btreeid,
                      index_tree,
                      indexno)
            ELSE
                index_tree.fileTabId_gg00 := cgg_zero_id;
            (*ENDIF*) 
            (* PTS 1114312 *)
            a40move (acv, a41v, @indexname, sizeof (indexname));
            IF  index_tree.fileTabId_gg00 <> cgg_zero_id
            THEN
                a40move (acv, a41v, @index_tree.fileTabId_gg00,
                      sizeof (index_tree.fileTabId_gg00))
            ELSE
                a40move (acv, a41v, NIL, 0);
            (*ENDIF*) 
            a40move_const (acv, a41v, @unique, sizeof (unique));
            curr_col := a4pos;
            FOR j1 := 1 TO col_cnt DO
                BEGIN
                ecolno           := icolseq [j1];
                a06extcolno (a_p_arr1.pbasep^.sbase, ecolno, col_ptr);
                a4pos := curr_col;
                a40move (acv, a41v, @col_ptr^.ccolumnn,
                      ord (col_ptr^.ccolumnn_len));
                IF  icolstack[ j1 ].eop in
                    [ op_order_desc, op_unique_desc ]
                THEN
                    ityp := c8desc
                ELSE
                    ityp := c8asc;
                (*ENDIF*) 
                a40move_const (acv, a41v, @ityp, sizeof (ityp));
                (* createdate, time  *)
                a40put_date_time (acv, a41v, idatecre,
                      true, false);
                a40put_date_time (acv, a41v, itimecre,
                      false, false);
                (* PTS 1114498 E.Z. *)
                (* PTS 1110481 E.Z. *)
                inv_usage_cnt := 0;
                index_state   := a45is_ok;
                IF  NOT is_key
                THEN
                    BEGIN
                    inv_usage_cnt := bd998GetIndexUsageCount (
                          acv.a_transinf.tri_trans, index_tree.fileTabId_gg00 );
                    b01filestate (acv.a_transinf.tri_trans, index_tree);
                    IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
                    THEN (* PTS 1132536 M.Ki. *)
                        BEGIN
                        IF  (acv.a_transinf.tri_trans.trError_gg00 = e_bad_file) OR
                            (acv.a_transinf.tri_trans.trError_gg00 = e_file_not_accessible)
                        THEN
                            index_state := a45is_bad
                        ELSE
                            index_state := a45is_missing;
                        (*ENDIF*) 
                        IF  inv_usage_cnt = -1
                        THEN
                            inv_usage_cnt := 0;
                        (*ENDIF*) 
                        acv.a_transinf.tri_trans.trError_gg00 := e_ok;
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                ak45add_index (acv, a41v,
                      col_ptr^, offset + j1, cm_index,
                      inv_usage_cnt, iinitdate, iinittime, index_state, idisabled, icomment, indexno)
                END;
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak45all_table_scan (
            VAR acv     : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            updStatObj  : tsp00_Addr; (* non-nil for update statistics only *)
            tab_len     : integer;
            sample_rows : tsp00_Int4;
            sample_pct  : integer);
 
CONST
      c_commit      = true;
 
VAR
      ok            : boolean;
      user_spec     : boolean;
      bForceUpdStat : boolean;
      b_err         : tgg00_BasisError;
      userid        : tgg00_Surrogate;
      i             : integer;
      j             : integer;
      tab_cnt       : tsp00_Int4;
      ref_ptr       : tak_sysbufferaddress;
      tabkey        : tgg00_SysInfoKey;
 
BEGIN
WITH a41v.a4p_arr DO
    BEGIN
    WITH tabkey DO
        BEGIN
        user_spec := ( a41v.a4authname <> a01_il_b_identifier );
        IF  user_spec
        THEN
            a06det_user_id (acv, a41v.a4authname, userid)
        ELSE
            IF  tab_len > 0
            THEN
                BEGIN
                user_spec := true;
                userid    := acv.a_curr_user_id;
                END
            ELSE
                userid := cgg_zero_id;
            (*ENDIF*) 
        (*ENDIF*) 
        sauthid     := userid;
        sidentifier := a41v.a4tablen;
        sentrytyp   := cak_etableref;
        slinkage    := cak_init_linkage;
        i           := a061identifier_len (a41v.a4tablen);
        IF  i > 0
        THEN
            WHILE sidentifier[ i ] = chr(0) DO
                i := pred(i);
            (*ENDWHILE*) 
        (*ENDIF*) 
        IF  i > 0
        THEN
            BEGIN
            sidentifier[ i ] := pred(sidentifier[ i ]);
            FOR j := i + 1 TO sizeof (sidentifier) DO
                sidentifier[ j ] := chr(255);
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        skeylen := mxak_standard_sysk + sizeof (sidentifier);
        END;
    (*ENDWITH*) 
    IF  a41v.a4tablen = a01_il_b_identifier
    THEN
        tab_len := 0;
    (*ENDIF*) 
    FOR i := tab_len + 1 TO sizeof (a41v.a4tablen) DO
        a41v.a4tablen[ i ] := chr(255);
    (*ENDFOR*) 
    tab_cnt := 0;
    REPEAT
        a10next_sysinfo (acv, tabkey, 0, d_release,
              cak_etableref, ref_ptr, b_err);
        IF  b_err = e_ok
        THEN
            IF  (user_spec AND ((tabkey.sauthid > userid) OR
                (tabkey.sidentifier > a41v.a4tablen)))
            THEN
                b_err := e_no_next_record
            ELSE
                IF  (s30eq (a41v.a4tablen, tabkey.sidentifier, 1, tab_len))
                    OR (tab_len = 0)
                THEN
                    WITH ref_ptr^, syskey, stableref DO
                        IF  (rtablekind in
                            [twithkey, twithoutkey])
                        THEN
                            BEGIN
                            tab_cnt := tab_cnt + 1;
                            a06_systable_get (acv, d_fix,
                                  rtableid, acv.a_p_arr1.pbasep, true, ok);
                            IF  ok AND
                                NOT (ftsArchive_egg00 in acv.a_p_arr1.pbasep^.sbase.btreeid.fileType_gg00)
                            THEN
                                BEGIN
                                bForceUpdStat :=
                                      (user_spec AND
                                      (userid = acv.a_p_arr1.pbasep^.sbase.bschema) )
                                      AND (acv.a_p_arr1.pbasep^.sbase.btablen^
                                      = a41v.a4tablen);
                                IF  updStatObj <> NIL
                                THEN
                                    a28add_table_upd_statistics (acv,
                                          updStatObj, bForceUpdStat,
                                          sample_rows, sample_pct)
                                ELSE
                                    a28table_upd_statistics (acv,
                                          bForceUpdStat,
                                          sample_rows, sample_pct,
                                          0, 0, cak_is_undefined, cak_is_undefined,
                                          false, c_commit);
                                (*ENDIF*) 
                                a10table_cache_delete (acv,
                                      acv.a_p_arr1.pbasep^.syskey.stableid);
                                END
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    UNTIL
        (b_err <> e_ok) OR (acv.a_returncode <> 0);
    (*ENDREPEAT*) 
    IF  b_err <> e_no_next_record
    THEN
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        IF  tab_cnt = 0
        THEN
            IF  tab_len = sizeof (a41v.a4tablen)
            THEN
                a07_b_put_error (acv, e_unknown_tablename, 1)
            ELSE
                a07_b_put_error (acv, e_row_not_found, 1);
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak45user_table_scan (
            VAR acv       : tak_all_command_glob;
            VAR a41v      : tak40_show_glob;
            updStatObj    : tsp00_Addr;(* non-nil for update statistics only *)
            tab_len       : integer;
            tab_len2      : integer;
            VAR tab_count : integer;
            sample_rows   : tsp00_Int4;
            sample_pct    : integer);
 
CONST
      no_temp         = false;
      scan_private    = true;
      scan_nonprivate = true;
      not_all_base    = false;
 
VAR
      is_upd_statistics : boolean;
      check_priv        : boolean;
 
BEGIN
WITH acv, a41v, a4p_arr DO
    BEGIN
    is_upd_statistics := a_ap_tree^[a4ti].n_subproc = cak_i_statistics;
    tab_count         := 0;
    IF  (a_returncode = 0)
        AND
        ((a_ex_kind <> only_parsing) OR is_upd_statistics)
    THEN
        BEGIN
        IF  ((a_ap_tree^[a4ti].n_subproc = cak_i_index)
            AND (acv.a_current_user_kind = usysdba))
            OR (is_upd_statistics
            AND (acv.a_current_user_kind in [ usysdba, ucontroluser ]))
        THEN
            check_priv := false
        ELSE
            check_priv := true;
        (*ENDIF*) 
        IF  (a4authname <> a01_il_b_identifier) AND
            (tab_len = sizeof (a4tablen))
        THEN (* first table specified completely *)
            BEGIN
            IF  a06_table_exist (acv, d_fix, a4authname, a4tablen,
                a4p_arr, false)
            THEN
                WITH a4p_arr.pbasep^.sbase DO
                    IF  (is_upd_statistics AND
                        (ftsArchive_egg00 in btreeid.fileType_gg00))
                    THEN
                        a07_b_put_error (acv, e_invalid_tabletype, 1)
                    ELSE
                        BEGIN
                        a4is_synonym := a4p_arr.psynfound;
                        ak45check_one_table (acv, a41v, updStatObj,
                              tab_len2, check_priv,
                              c_forceUpdStat,
                              sample_rows, sample_pct, tab_count);
                        END
                    (*ENDIF*) 
                (*ENDWITH*) 
            (*ENDIF*) 
            END
        ELSE
            BEGIN (* table prefix *)
            a40init_table_scan (acv, a41v,
                  no_temp, scan_private, scan_nonprivate,
                  a4sh_kind = sh_index, NOT is_upd_statistics AND
                  (a_cmd_segment_header.sp1c_producer = sp1pr_user_cmd),
                  not_all_base);
            a4tab_len := tab_len;
            WHILE a40next_table (acv, a41v) DO
                IF  NOT (is_upd_statistics AND
                    (ftsArchive_egg00 in a4p_arr.pbasep^.sbase.btreeid.fileType_gg00))
                THEN
                    ak45check_one_table (acv, a41v, updStatObj,
                          tab_len2, check_priv, NOT c_forceUpdStat,
                          sample_rows, sample_pct,
                          tab_count);
                (*ENDIF*) 
            (*ENDWHILE*) 
            a40FinishTableScan (acv, a41v);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak45process_upd_stat_wanted (
            VAR acv     : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            updStatObj  : tsp00_Addr;
            sample_rows : tsp00_Int4;
            sample_pct  : integer);
 
CONST
      c_checkPrivs = true;
 
VAR
      key         : tgg00_Lkey;
      tableCount  : integer;
      (* PTS 1131825 M.Ki. *)
 
BEGIN
tableCount      := 0;
key.keyLen_gg00 := 0;
WHILE a28nextUpdStatWantedEntry (acv, a41v, key) DO
    ak45check_one_table (acv, a41v, updStatObj, 0, NOT c_checkPrivs,
          NOT c_forceUpdStat, sample_rows, sample_pct, tableCount);
(*ENDWHILE*) 
IF  (acv.a_returncode = 0)
    AND (acv.a_transinf.tri_trans.trError_gg00 <> e_ok)
THEN
    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
(* *)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak45check_one_table (
            VAR acv         : tak_all_command_glob;
            VAR a41v        : tak40_show_glob;
            VAR updStatObj  : tsp00_Addr;
            tab_len2        : integer;
            check_priv      : boolean;
            bForceUpdStat   : boolean;
            sample_rows     : tsp00_Int4;
            sample_pct      : integer;
            VAR tab_count   : tsp00_Int4);
 
CONST
      commit = true;
 
VAR
      ok       : boolean;
      priv     : tak_privilege;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    a_p_arr1.psynfound := a4is_synonym;
    a06_systable_get (acv, d_fix, a4p_arr.pbasep^.sbase.bsurrogate,
          a_p_arr1.pbasep, true, ok);
    IF  ok
    THEN
        BEGIN
        a4p_arr.pbasep := a_p_arr1.pbasep;
        IF  check_priv
        THEN
            a06_get_priv (acv, a_p_arr1.pbasep, priv)
        ELSE
            priv.priv_all_set := [r_index];
        (*ENDIF*) 
        IF  (((r_index in priv.priv_all_set) OR
            (r_owner in priv.priv_all_set)   OR
            (r_sel   in priv.priv_all_set)   OR
            (priv.priv_sel_set <> [  ]))
            AND
            ((a_ap_tree^[ a4ti ].n_subproc = cak_i_index) OR
            (a_ap_tree^[ a4ti ].n_subproc = cak_i_statistics)))
            OR
            (((r_owner in priv.priv_all_set)         OR
            (r_link in priv.priv_all_set)            OR
            (a_cmd_segment_header.sp1c_producer = sp1pr_internal_cmd))
            AND
            (a_ap_tree^[ a4ti ].n_subproc <> cak_i_index)   AND
            (a_ap_tree^[ a4ti ].n_subproc <> cak_i_statistics))
        THEN
            WITH a_p_arr1.pbasep^.sbase DO
                IF  (btablekind in [ twithkey, twithoutkey] )
                THEN
                    BEGIN
                    tab_count := tab_count + 1;
                    CASE a_ap_tree^[ a4ti ].n_subproc OF
                        cak_i_statistics :
                            IF  updStatObj <> NIL
                            THEN
                                a28add_table_upd_statistics (acv,
                                      updStatObj, bForceUpdStat,
                                      sample_rows, sample_pct)
                            ELSE
                                a28table_upd_statistics (acv,
                                      bForceUpdStat,
                                      sample_rows, sample_pct,
                                      0, 0, cak_is_undefined, cak_is_undefined,
                                      false, commit);
                            (*ENDIF*) 
                        cak_i_index :
                            ak45index_show (acv,
                                  a41v, priv);
                        OTHERWISE
                            ak45link_show (acv, a41v, tab_len2);
                        END;
                    (*ENDCASE*) 
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak45link_show (
            VAR acv     : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            tab_len2    : integer);
 
VAR
      b_err     : tgg00_BasisError;
      use_table : boolean;
      index     : integer;
      linkcnt   : integer;
      linkbuf   : tak_sysbufferaddress;
      tabid     : tgg00_Surrogate;
      linkkey   : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    a_p_arr2.psynfound := false;
    tabid              := cgg_zero_id;
    IF  (tab_len2 = sizeof (a4tablen)) AND
        (a4user <> a01_il_b_identifier)
    THEN
        IF  NOT a06_table_exist (acv, d_fix, a4user, a4coln,
            a_p_arr2, false)
        THEN
            a07_b_put_error (acv, e_unknown_tablename, 1)
        ELSE
            tabid := a_p_arr2.pbasep^.syskey.stableid;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        linkkey := a_p_arr1.pbasep^.syskey;
        WITH linkkey DO
            IF  a_ap_tree^[ a4ti ].n_subproc - cak_i_foreign = x_references
            THEN (* no foreign key table specified *)
                sentrytyp := cak_eprimarykey
            ELSE
                sentrytyp := cak_eforeignkey;
            (*ENDIF*) 
        (*ENDWITH*) 
        index := 0;
        REPEAT
            index := succ(index);
            a10get_sysinfo (acv,
                  linkkey, d_fix, linkbuf, b_err);
            IF  b_err = e_ok
            THEN
                WITH linkbuf^.slink,
                     linkdef[ succ(pred(index) MOD cak_maxlinkdef) ] DO
                    BEGIN
                    IF  linkkey.slinkage = cak_init_linkage
                    THEN
                        linkcnt := linkcount;
                    (*ENDIF*) 
                    use_table := true;
                    IF  tabid <> cgg_zero_id
                    THEN
                        IF  tabid <> ltableid
                        THEN
                            use_table := false;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  use_table
                    THEN
                        ak45one_link_show (acv, a41v, linkbuf,
                              succ(pred(index) MOD cak_maxlinkdef),
                              tab_len2);
                    (*ENDIF*) 
                    a10_rel_sysinfo (acv, linkkey);
                    IF  (index MOD cak_maxlinkdef) = 0
                    THEN
                        a06inc_linkage (linkkey.slinkage)
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
        UNTIL
            (b_err <> e_ok) OR (linkcnt = index);
        (*ENDREPEAT*) 
        IF  (b_err <> e_ok) AND (b_err <> e_sysinfo_not_found)
        THEN
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak45one_link_show (
            VAR acv     : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            VAR linkbuf : tak_sysbufferaddress;
            index       : integer;
            tab_len2    : integer);
 
VAR
      ok             : boolean;
      found          : boolean;
      keypos         : integer;
      i              : integer;
      j              : integer;
      ci             : integer;
      extno          : integer;
      colind         : integer;
      fkBuf          : tak_sysbufferaddress;
      fkIndex        : integer;
      usageindex     : integer;
      keycolno       : integer;
      priv           : tak_privilege;
      owner          : tsp00_KnlIdentifier;
      cmp_name       : tsp00_KnlIdentifier;
      linkrule       : tsp00_C18;
      syn_from       : tsp00_KnlIdentifier;
      syn_to         : tsp00_KnlIdentifier;
      link_name      : tsp00_KnlIdentifier;
      from_arr       : tak_syspointerarr;
      to_arr         : tak_syspointerarr;
      usagekey       : tgg00_SysInfoKey;
      index_scan_rec : tak_index_scan_record;
 
BEGIN
ok := false;
WITH acv, a41v DO
    BEGIN
    a_p_arr2.pbasep := NIL;
&   ifdef trace
    t01lidentifier (ak_sem, a4user);
    t01lidentifier (ak_sem, a4coln);
    t01lidentifier (ak_sem, a4synname);
    t01int4       (ak_sem, 'tab_len2    ', tab_len2);
&   endif
    IF  a_returncode = 0
    THEN
        BEGIN
        WITH linkbuf^.slink.linkdef[ index ] DO
            a06_systable_get (acv, d_fix, ltableid,
                  a_p_arr2.pbasep, true, ok);
        (*ENDWITH*) 
        IF  ok
        THEN
            WITH a_p_arr2.pbasep^.sbase DO
                BEGIN
                a06_get_priv (acv, a_p_arr2.pbasep, priv);
                IF  (priv.priv_all_set   <> [  ]) OR
                    (priv.priv_col_exist <> [  ])
                THEN
                    ok := true
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  ok
        THEN
            BEGIN
            IF  a_ap_tree^[a4ti].n_subproc - cak_i_foreign = x_references
            THEN
                BEGIN
                from_arr := a_p_arr1;
                to_arr   := a_p_arr2;
                syn_from := a4synname;
                syn_to   := a4coln
                END
            ELSE
                BEGIN
                from_arr := a_p_arr2;
                to_arr   := a_p_arr1;
                syn_from := a4coln;
                syn_to   := a4synname
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  ok
THEN
    WITH linkbuf^.slink.linkdef[ index ], a41v  DO
        BEGIN
        usageindex         := 0;
        usagekey           := acv.a_p_arr2.pbasep^.syskey;
        usagekey.sentrytyp := cak_eusage;
        usagekey.slinkage  := cak_zero_linkage;
        REPEAT
            IF  acv.a_ap_tree^[ a4ti ].n_subproc - cak_i_foreign = x_references
            THEN
                IF  to_arr.psynfound
                THEN
                    BEGIN
                    owner    := acv.a_curr_user_name;
                    cmp_name := syn_to
                    END
                ELSE
                    WITH to_arr.pbasep^.sbase DO
                        BEGIN
                        a06determine_username (acv, bauthid, owner);
                        cmp_name := btablen^
                        END
                    (*ENDWITH*) 
                (*ENDIF*) 
            ELSE
                IF  from_arr.psynfound
                THEN
                    BEGIN
                    owner    := acv.a_curr_user_name;
                    cmp_name := syn_from
                    END
                ELSE
                    WITH from_arr.pbasep^.sbase DO
                        BEGIN
                        a06determine_username (acv, bauthid, owner);
                        cmp_name := btablen^
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
            (*ENDIF*) 
&           ifdef trace
            t01lidentifier (ak_sem, a4user);
            t01lidentifier (ak_sem, a4coln);
            t01lidentifier (ak_sem, cmp_name);
            t01int4       (ak_sem, 'tab_len2    ', tab_len2);
&           endif
            IF  ((a4user = owner) OR
                (a4user = a01_il_b_identifier))
                AND
                s30eq (a4coln, cmp_name, 1, tab_len2)
            THEN
                BEGIN
                a4is_synonym := to_arr.psynfound;
                a4synname    := syn_to;
&               ifdef trace
                t01int4(ak_sem, 'to_synonym  ', ord (to_arr.psynfound));
                t01lidentifier (ak_sem, syn_to);
&               endif
                keypos := 1;
                a25get_linkname (acv, linkbuf, index, link_name);
                a4is_synonym := from_arr.psynfound;
                a4synname    := syn_from;
                found := false;
                IF  (ord(lindexid[ 1 ]) > 0) AND
                    (from_arr.pbasep^.sbase.bindexexist)
                THEN
                    BEGIN
                    a24init_index_scan (acv,
                          from_arr.pbasep^.sbase.bsurrogate,
                          index_scan_rec);
                    WITH index_scan_rec DO
                        REPEAT
                            IF  a24next_named_index (acv,
                                index_scan_rec)
                            THEN
                                BEGIN
                                WITH isr_buf^.smindex.indexdef[isr_index] DO
                                    IF  indexno = ord(lindexid[ 1 ])
                                    THEN
                                        found := true
                                    (*ENDIF*) 
                                (*ENDWITH*) 
                                END
                            ELSE
                                ok := false;
                            (*ENDIF*) 
                        UNTIL
                            found OR NOT ok;
                        (*ENDREPEAT*) 
                    (*ENDWITH*) 
                    a24finish_index_scan (acv, index_scan_rec);
                    IF  (NOT found) AND (lcolcount > 1)
                    THEN
                        a07ak_system_error (acv, 45, 2)
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  acv.a_returncode = 0
                THEN
                    FOR i := 1 TO lcolcount DO
                        BEGIN
                        WITH to_arr.pbasep^.sbase DO
                            colind := bextcolindex[lseccolseq[i]] +
                                  bfirstindex;
                        (*ENDWITH*) 
                        a4is_synonym := to_arr.psynfound;
                        a4synname    := syn_to;
                        a40table_column_to_shbuf (acv, a41v, to_arr.pbasep,
                              colind, c_with_owner);
                        a40move (acv, a41v, @link_name,
                              sizeof (link_name));
                        keycolno := 0;
                        IF  ord(lindexid[1]) > 0
                        THEN
                            IF  found
                            THEN
                                WITH index_scan_rec, isr_buf^.smindex DO
                                    extno := indexdef[isr_index].icolseq[ i ]
                                (*ENDWITH*) 
                            ELSE
                                BEGIN
                                IF  linkbuf^.syskey.sentrytyp =
                                    cak_eprimarykey
                                THEN
                                    j := 1
                                ELSE
                                    j := 2;
                                (*ENDIF*) 
                                extno := ord (lstack[j].ecol_tab[1])
                                END
                            (*ENDIF*) 
                        ELSE
                            BEGIN
                            ci := from_arr.pbasep^.sbase.bfirstcolind;
                            REPEAT
                                keycolno := keycolno + 1;
                                WITH a103GetColumn (from_arr.pbasep^.sbase, ci)^DO
                                    BEGIN
                                    ci    := cnextind;
                                    extno := cextcolno
                                    END;
                                (*ENDWITH*) 
                            UNTIL
                                (keycolno = i);
                            (*ENDREPEAT*) 
                            END;
                        (*ENDIF*) 
                        WITH from_arr.pbasep^.sbase DO
                            colind := bextcolindex[extno] +
                                  bfirstindex;
                        (*ENDWITH*) 
                        a4is_synonym := from_arr.psynfound;
                        a4synname    := syn_from;
&                       ifdef trace
                        t01int4 (ak_sem, 'from_synonym',
                              ord (from_arr.psynfound));
                        t01lidentifier (ak_sem, syn_from);
&                       endif
                        a40table_column_to_shbuf (acv, a41v, from_arr.pbasep,
                              colind, c_with_owner);
                        CASE laction OF
                            cak_x_restrict :
                                linkrule := 'DELETE RESTRICT   ';
                            cak_x_cascade  :
                                linkrule := 'DELETE CASCADE    ';
                            cak_x_set_null  :
                                linkrule := 'DELETE SET NULL   ';
                            cak_x_set_default  :
                                linkrule := 'DELETE SET DEFAULT';
                            END;
                        (*ENDCASE*) 
                        a40move_const (acv, a41v,
                              @linkrule, sizeof (linkrule));
                        a40put_date_time (acv, a41v,
                              ldatecre, true, false);
                        a40put_date_time (acv, a41v,
                              ltimecre, false, false);
                        IF  linkbuf^.syskey.sentrytyp = cak_eprimarykey
                        THEN
                            BEGIN
                            a25FindForeignKeyInfo (acv, linkbuf, index, fkBuf, fkIndex);
                            IF  fkIndex = 0
                            THEN
                                BEGIN (* not found, set comment = NULL *)
                                fkBuf   := linkbuf;
                                fkIndex := index
                                END;
                            (*ENDIF*) 
                            END
                        ELSE
                            BEGIN
                            fkBuf   := linkbuf;
                            fkIndex := index
                            END;
                        (*ENDIF*) 
                        a40comment_descriptor (acv, a41v, fkBuf^.slink.linkdef[fkIndex].lcomment,
                              fkBuf^.syskey.stableid,
                              (ord (fkBuf^.syskey.slinkage[2]) - 1) *
                              cak_maxlinkdef+fkIndex, cm_foreign_key);
                        a40move_i4 (acv, a41v, keycolno,
                              keycolno <= 0, 0, c_to_undef);
                        END;
                    (*ENDFOR*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            (usageindex = 0) OR (acv.a_returncode <> 0);
        (*ENDREPEAT*) 
        a10_rel_sysinfo (acv, usagekey);
        a10rel_sysinfo  (acv.a_p_arr2.pbasep)
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
