.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :  7.3    Date : 2001-08-10
*****************************************************
modname : VAK262
changed : 2001-08-10
module  : AK_Trigger
 
Author  : ThomasA
Created : 1987-09-22
*****************************************************
 
Purpose : Create and Drop Trigger
 
Define  :
 
        PROCEDURE
              a262add_trigger_info (
                    VAR acv           : tak_all_command_glob;
                    VAR dmli          : tak_dml_info;
                    ignoreUserTrigger : boolean);
 
        PROCEDURE
              a262CalcOutputLen (
                    VAR acv         : tak_all_command_glob;
                    VAR methodRec   : tak_methodrecord;
                    pParamTable     : tak_sysbufferaddress;
                    VAR constParams : tak_colinteger;
                    VAR dataLength  : tsp00_Int2;
                    VAR ioLength    : tsp00_Int2;
                    VAR fraction    : tsp00_Int2);
 
        PROCEDURE
              a262Call (
                    VAR acv : tak_all_command_glob;
                    p      : tak_sysbufferaddress;
                    data_p : tsp00_MoveObjPtr);
 
        PROCEDURE
              a262compile (
                    VAR acv    : tak_all_command_glob;
                    tree_index : integer);
 
        PROCEDURE
              a262CreateDBProc (VAR acv : tak_all_command_glob;
                    isSystemTrigger : boolean);
 
        PROCEDURE
              a262DBFuncCreate (VAR acv : tak_all_command_glob;
                    isPublic : boolean);
 
        PROCEDURE
              a262Debug (VAR acv : tak_all_command_glob;
                    debugListen : boolean);
 
        PROCEDURE
              a262DebugSyntax (
                    VAR acv      : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a262DeleteTriggerParsinfo (
                    VAR acv         : tak_all_command_glob;
                    VAR BaseRec     : tak_baserecord);
 
        PROCEDURE
              a262DropInternalTriggers (
                    VAR acv  : tak_all_command_glob);
 
        FUNCTION
              a262EvalOutputLenProlog (
                    VAR  acv        : tak_all_command_glob;
                    VAR  functionId : tgg00_Surrogate) : tak_sysbufferaddress;
 
        PROCEDURE
              a262drop_tab_col_trigger (
                    VAR acv         : tak_all_command_glob;
                    VAR viewscanpar : tak_viewscan_par;
                    VAR new_stack   : tgg00_StackEntry);
 
        PROCEDURE
              a262DynamicSQL (
                    acv_addr     : tak_acv_address;
                    VAR sel      : tgg00_SelectFieldsParam;
                    pStmt        : tsp00_MoveObjPtr;
                    stmtLength   : integer;
                    retcode_addr : tsp00_MoveObjPtr;
                    VAR e        : tgg00_BasisError);
 
        PROCEDURE
              a262DropParseIds (
                    VAR acv    : tak_all_command_glob;
                    VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              a262execute_trigger (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a262execute (
                    acv_addr        : tak_acv_address;
                    VAR sel         : tgg00_SelectFieldsParam;
                    retcode_addr    : tsp00_MoveObjPtr;
                    VAR StackList   : tgg00_StackList;
                    VAR qual_ptr    : tsp00_Int4;
                    VAR e           : tgg00_BasisError);
 
        PROCEDURE
              a262exist_trigger (
                    VAR acv             : tak_all_command_glob;
                    VAR trigger_name    : tsp00_KnlIdentifier;
                    VAR trigger_ptr_arr : tak_syspointerarr;
                    VAR trigger_kind    : tgg00_Linkset);
 
        PROCEDURE
              a262get_trigger_name (
                    VAR trigger_rec  : tak_triggerrecord;
                    VAR trigger_name : tsp00_KnlIdentifier;
                    VAR b_err        : tgg00_BasisError);
 
        PROCEDURE
              a262GetDBProcDefinition (
                    VAR acv      : tak_all_command_glob;
                    VAR DBProcId : tgg00_Surrogate;
                    VAR def_len  : tsp00_Int4;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4);
 
        PROCEDURE
              a262GetObjectName (
                    VAR acv         : tak_all_command_glob;
                    VAR methodId    : tgg00_Surrogate;
                    procKind        : integer;
                    linkage         : integer;
                    VAR objKind     : tsp00_C8;
                    VAR schema      : tsp00_KnlIdentifier;
                    VAR objName     : tsp00_KnlIdentifier;
                    VAR triggerName : tsp00_KnlIdentifier);
 
        PROCEDURE
              a262GetValDBProcDefinition (
                    VAR acv           : tak_all_command_glob;
                    VAR long_desc     : tak_long_descriptor;
                    VAR ret_long_qual : tgg00_LongQual);
 
        PROCEDURE
              a262InternalFunction(
                    VAR StackEntry       : tgg00_StackEntry;
                    VAR Buf              : tsp00_MoveObj;
                    BufSize              : integer;
                    BufPos               : integer;
                    VAR e                : tgg00_BasisError);
 
        PROCEDURE
              a262LoadCode (
                    VAR acv     : tak_all_command_glob;
                    VAR CodeId  : tgg00_Surrogate (* ptocConst *);
                    Linkage     : tsp00_C2        (* ptocConst *);
                    VAR p       : tak_sysbufferaddress);
 
        PROCEDURE
              a262reset_statistics;
 
        PROCEDURE
              a262ReturnCursor (
                    acv_addr   : tak_acv_address;
                    param_addr : tsp00_MoveObjPtr;
                    param_len  : tsp00_Int4;
                    VAR e      : tgg00_BasisError);
 
        PROCEDURE
              a262ReturnParam (
                    acv_addr      : tak_acv_address;
                    paramDataType : tsp00_DataType;
                    param_addr    : tsp00_MoveObjPtr (* ptocConst *);
                    param_len     : tsp00_Int4;
                    VAR e         : tgg00_BasisError);
 
        PROCEDURE
              a262SetParameterProperties (
                    VAR acv       : tak_all_command_glob;
                    pParamTable   : tak_sysbufferaddress;
                    paramNo       : integer;
                    paramDataType : tsp00_DataType;
                    dataLength    : integer;
                    inOutLength   : integer;
                    fraction      : integer);
 
        FUNCTION
              a262StatementBeginStackEntry(
                    acv_addr       : tak_acv_address;
                    VAR sel        : tgg00_SelectFieldsParam;
                    stackIndex     : integer;
                    VAR codePos    : integer;
                    VAR codeLength : integer) : boolean;
 
        PROCEDURE
              a262statistics (
                    VAR external_trigger_cnt : tsp00_8ByteCounter;
                    VAR internal_trigger_cnt : tsp00_8ByteCounter);
 
        PROCEDURE
              a262stop (
                    acv_addr          : tak_acv_address;
                    rc                : tsp00_Int2;
                    msgtext_len       : integer;
                    msgtext           : tsp00_MoveObjPtr;
                    isFunctionStopMsg : boolean;
                    isUserDefined     : boolean);
 
        PROCEDURE
              a262copy_result_part (
                    acv_addr          : tak_acv_address;
                    VAR part          : tsp1_part (*ptocConst*));
 
        PROCEDURE
              a262trigger_semantic (VAR acv : tak_all_command_glob);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01char_size        : integer;
              a01defaultkey       : tgg00_SysInfoKey;
              a01_il_b_identifier : tsp00_KnlIdentifier;
              a01_i_count         : tsp00_KnlIdentifier;
              a01_i_cursor        : tsp00_KnlIdentifier;
              a01_i_errmsg        : tsp00_KnlIdentifier;
              a01_i_java          : tsp00_KnlIdentifier;
              a01_i_new           : tsp00_KnlIdentifier;
              a01_i_old           : tsp00_KnlIdentifier;
              a01_i_rc            : tsp00_KnlIdentifier;
              a01_i_system        : tsp00_KnlIdentifier;
              a01_i_temp          : tsp00_KnlIdentifier;
 
        PROCEDURE
              a01_call_put (
                    VAR acv    : tak_all_command_glob;
                    proc       : tak_procs;
                    subproc    : tsp00_Int2;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_get_keyword (
                    VAR acv      : tak_all_command_glob;
                    VAR index    : integer;
                    VAR reserved : boolean);
 
        PROCEDURE
              a01_force_symbol (
                    VAR acv         : tak_all_command_glob;
                    expected_symbol : tak_sc_symbol;
                    VAR node1       : tsp00_Int2;
                    VAR node2       : tsp00_Int2);
 
        FUNCTION
              a01mandatory_keyword (
                    VAR acv          : tak_all_command_glob;
                    required_keyword : integer) : boolean;
 
        FUNCTION
              a01node_get_ptr (
                    VAR acv    : tak_all_command_glob;
                    tree_index : integer) : tsp00_MoveObjPtr;
 
        PROCEDURE
              a01_next_symbol (VAR acv : tak_all_command_glob);
 
        FUNCTION
              a01swap_int2 (old : tsp00_Int2) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              AK_syntax_tools : VAK02;
 
        PROCEDURE
              a02_atablename (VAR acv : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a02_put_identifier (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a02procedure (VAR acv : tak_all_command_glob;
                    VAR put_node   : tsp00_Int2;
                    VAR last_node  : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_syntax_values_tools : VAK03;
 
        PROCEDURE
              a03_aunsigned_integer (
                    VAR acv            : tak_all_command_glob;
                    VAR put_node       : tsp00_Int2;
                    VAR last_node      : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
        PROCEDURE
              a05_string_literal_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    datatyp     : tsp00_DataType;
                    obj_len     : integer;
                    VAR moveobj : tsp00_Buf);
 
        PROCEDURE
              a05_int4_unsigned_get (
                    VAR acv            : tak_all_command_glob;
                    pos                : integer;
                    l                  : tsp00_Int2;
                    VAR val            : tsp00_Int4);
 
        PROCEDURE
              a05surrogate_get (
                    VAR acv        : tak_all_command_glob;
                    VAR surrogate  : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06a_mblock_init (
                    VAR acv      : tak_all_command_glob;
                    mtype        : tgg00_MessType;
                    m2type       : tgg00_MessType2;
                    VAR tree     : tgg00_FileId);
 
        PROCEDURE
              a06colname_retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4;
                    src_codeset : tsp00_Int2);
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06extcolno (
                    VAR baserec     : tak_baserecord;
                    extcolno        : integer;
                    VAR colinfo_ptr : tak00_colinfo_ptr);
 
        PROCEDURE
              a06get_priv  (
                    VAR acv       : tak_all_command_glob;
                    VAR brec      : tak_sysbufferaddress;
                    required_priv : tak00_PrivilegeSet;
                    VAR priv      : tak_privilege);
 
        PROCEDURE
              a06get_username (
                    VAR acv        : tak_all_command_glob;
                    VAR tree_index : integer;
                    VAR username   : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06_systable_get (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR tableid  : tgg00_Surrogate;
                    VAR base_ptr : tak_sysbufferaddress;
                    get_all      : boolean;
                    VAR ok       : boolean);
 
        PROCEDURE
              a06find_colinfo (
                    base_ptr        : tak_sysbufferaddress;
                    VAR stack_entry : tgg00_StackEntry;
                    VAR colinfo_ptr : tak00_colinfo_ptr);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06init_curr_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06finish_curr_retpart (
                    VAR acv   : tak_all_command_glob;
                    part_kind : tsp1_part_kind;
                    arg_count : tsp00_Int2);
 
        PROCEDURE
              a06reset_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
        FUNCTION
              a06_table_exist (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR authname : tsp00_KnlIdentifier;
                    VAR tablen   : tsp00_KnlIdentifier;
                    VAR sparr    : tak_syspointerarr;
                    get_all      : boolean) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061app_columnname (
                    VAR acv               : tak_all_command_glob;
                    VAR base_rec          : tak_baserecord;
                    VAR column            : tsp00_KnlIdentifier;
                    VAR index             : integer);
 
        FUNCTION
              a061exist_columnname (
                    VAR base_rec    : tak_baserecord;
                    VAR column      : tsp00_KnlIdentifier;
                    VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
        FUNCTION
              a061identifier_len (VAR id : tsp00_KnlIdentifier) : integer;
&       ifdef trace
 
        PROCEDURE
              a061td_colinfo (VAR colinfo : tak00_columninfo;
                    index : integer);
&       endif
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07put_param (
                    VAR acv   : tak_all_command_glob;
                    param_no  : integer;
                    param_ptr : tsp00_MoveObjPtr;
                    param_len : integer);
 
        PROCEDURE
              a07_const_b_put_error (
                    VAR acv    : tak_all_command_glob;
                    b_err      : tgg00_BasisError;
                    err_code   : tsp00_Int4;
                    param_addr : tsp00_MoveObjPtr;
                    const_len  : integer);
 
        PROCEDURE
              a07_error (
                    VAR acv   : tak_all_command_glob;
                    err      : tgg00_BasisError;
                    VAR nod1 : tsp00_Int2;
                    VAR nod2 : tsp00_Int2);
 
        PROCEDURE
              a07_kw_put_error (VAR acv : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    kw       : integer);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
        PROCEDURE
              a07_uni_error (
                    VAR acv  : tak_all_command_glob;
                    uni_err  : tsp8_uni_error;
                    err_code : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache :  VAK10;
 
        PROCEDURE
              a10_add_repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    add_sysinfo  : boolean;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_copy_catalog_rec (
                    VAR acv         : tak_all_command_glob;
                    VAR old_key     : tgg00_SysInfoKey;
                    del_old_rec     : boolean;
                    VAR new_key     : tgg00_SysInfoKey;
                    new_segment_id  : tsp00_C2;
                    add_new_rec     : boolean;
                    VAR b_err       : tgg00_BasisError);
 
        PROCEDURE (* PTS 1109670 *)
              a10DeallocTemp(VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10del_sysinfo (
                    VAR acv     : tak_all_command_glob;
                    VAR syskey  : tgg00_SysInfoKey;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a10dispose (
                    VAR acv : tak_all_command_glob;
                    VAR p   : tsp00_MoveObjPtr);
 
        PROCEDURE
              a10_fix_len_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    required_len : integer;
                    plus         : integer;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    state       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10add_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_cache_delete  (
                    VAR acv     : tak_all_command_glob;
                    is_rollback : boolean);
 
        PROCEDURE
              a10key_del  (
                    VAR acv         : tak_all_command_glob;
                    VAR  syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10lock_fixed (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10Lock (
                    VAR acv : tak_all_command_glob;
                    p       : tak_sysbufferaddress);
 
        PROCEDURE
              a10Unlock (
                    VAR acv : tak_all_command_glob;
                    p       : tak_sysbufferaddress);
 
        PROCEDURE
              a10mblock_into_cache (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    VAR mblock   : tgg00_MessBlock;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10next_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    stop_prefix  : integer;
                    dstate       : tak_directory_state;
                    rec_kind     : tsp00_C2;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10new (
                    VAR acv  : tak_all_command_glob;
                    obj_size : tsp00_Int4;
                    VAR p    : tak_param_info_ptr);
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_rel_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10StoreAs (
                    VAR acv         : tak_all_command_glob;
                    syskey          : tgg00_SysInfoKey; (* must not be var *)
                    VAR storeSyskey : tgg00_SysInfoKey;
                    VAR e           : tgg00_BasisError);
 
        PROCEDURE
              a10unlock_fixed (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10_version (
                    VAR acv        : tak_all_command_glob;
                    VAR base_rec   : tak_baserecord;
                    m_type         : tgg00_MessType;
                    view_scan      : boolean);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        FUNCTION
              a101_AnySchemaMapped (
                    VAR acv : tak_all_command_glob) : boolean;
 
        PROCEDURE
              a101_MapSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier;
                    pos            : integer);
 
        PROCEDURE
              a101_RenameSchemaNames (
                    VAR acv  : tak_all_command_glob);
 
        PROCEDURE
              a101_SetMappingOffset (
                    VAR acv : tak_all_command_glob;
                    offset  : integer);
 
        PROCEDURE
              a101_DebuggerListen(
                    VAR acv        : tak_all_command_glob;
                    VAR methodId   : tgg00_Surrogate;
                    VAR procKind   : integer;
                    VAR linkage    : integer;
                    VAR pos        : integer;
                    VAR length     : integer);
 
        PROCEDURE
              a101_DebuggerGetMethodInfo (
                    VAR acv             : tak_all_command_glob;
                    VAR methodId        : tgg00_Surrogate;
                    VAR methodKind      : integer;
                    VAR linkage         : integer;
                    VAR pTriggerColumns : tsp00_MoveObjPtr;
                    VAR pVariables : tsp00_MoveObjPtr);
 
        PROCEDURE
              a101_DebuggerGetFunctionParameter (
                    VAR acv       : tak_all_command_glob;
                    VAR stackCode : tgg00_StackEntry;
                    VAR pParam    : tsp00_MoveObjPtr;
                    VAR length    : integer);
 
        PROCEDURE
              a101_DebuggerAddRemoveBreakPoint (
                    VAR acv        : tak_all_command_glob;
                    VAR procId     : tgg00_Surrogate;
                    procKind       : integer;
                    procType       : integer;
                    pos            : integer;
                    doRemove       : boolean);
 
        PROCEDURE
              a101_DebuggerStep (
                    VAR acv : tak_all_command_glob;
                    count   : integer);
 
        PROCEDURE
              a101_DebuggerStoreExecuteInfo (
                    pInfo : tsp00_MoveObjPtr;
                    size  : integer);
 
        PROCEDURE
              a101_DebuggerGetExecuteInfo (
                    pInfo : tsp00_MoveObjPtr;
                    size  : integer);
 
        PROCEDURE
              a101_SetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId;
                    sublevel       : tsp00_Int4(*ptocConst*));
 
        PROCEDURE
              a101_DestroyGroupedTempFile(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
        PROCEDURE
              a101_GetLogicalFilename(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
        PROCEDURE
              a101_GetTempFileInstance(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
        PROCEDURE
              a101_IncrementProcLevel(
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a101_DecrementProcLevel(
                    VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103CatalogSchemaId (
                    VAR catalogSchemaId : tgg00_Surrogate);
 
        PROCEDURE
              a103CheckCreateInPrivilege (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier (* ptocConst *);
                    errorPos       : integer);
 
        PROCEDURE
              a103GetSchemaId (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier (* ptocConst *);
                    errorPos       : integer;
                    VAR schemaId   : tgg00_Surrogate);
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate (* ptocConst *);
                    VAR schemaName : tsp00_KnlIdentifier);
 
        FUNCTION
              a103GetTriggerId (VAR TableName : tsp00_KnlIdentifier) : integer;
 
      ------------------------------ 
 
        FROM
              AK_Table : VAK11;
 
        PROCEDURE
              a11condition (
                    VAR acv       : tak_all_command_glob;
                    VAR a11v      : tak_a11_glob;
                    constraint_id : integer;
                    end_pos       : tsp00_Int4);
 
        PROCEDURE
              a11drop_table  (
                    VAR acv       : tak_all_command_glob;
                    VAR tableid   : tgg00_Surrogate;
                    tablkind      : tgg00_TableKind;
                    succ_filevers : boolean);
 
        PROCEDURE
              a11end_create_table (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
        PROCEDURE
              a11get_check_table (
                    VAR acv          : tak_all_command_glob;
                    new_table        : boolean;
                    basetable        : boolean;
                    unload_allowed   : boolean;
                    required_priv    : tak00_PrivilegeSet;
                    any_priv         : boolean;
                    all_base_rec     : boolean;
                    d_state          : tak_directory_state;
                    VAR act_tree_ind : tsp00_Int4;
                    VAR auth         : tsp00_KnlIdentifier;
                    VAR tablen       : tsp00_KnlIdentifier;
                    VAR d_sparr      : tak_syspointerarr);
 
        PROCEDURE
              a11glob_init (VAR acv : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
        PROCEDURE
              a11OneFixedLengthColumnDef  (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
        PROCEDURE
              a11init_baserecord (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
        PROCEDURE
              a11put_date_time (
                    VAR date : tsp00_Int4;
                    VAR time : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_Domain : VAK12;
 
        PROCEDURE
              a12create_dbproc (
                    VAR acv       : tak_all_command_glob;
                    start_node    : integer;
                    VAR dbproc_id : tgg00_Surrogate);
 
        PROCEDURE
              a12CreateFileInfoRecord (
                    VAR acv               : tak_all_command_glob;
                    VAR dbproc_id         : tgg00_Surrogate;
                    VAR libraryPathBuffer : tak_method_filename;
                    VAR MD5_footprint     : tsp00_C32);
 
        FUNCTION
              a12dbproc_exist (VAR acv : tak_all_command_glob;
                    VAR owner      : tsp00_KnlIdentifier;
                    VAR dbproc     : tsp00_KnlIdentifier;
                    dstate         : tak_directory_state;
                    VAR method_buf : tak_sysbufferaddress) : boolean;
 
        FUNCTION
              a12dbfunc_exist (VAR acv : tak_all_command_glob;
                    VAR owner       : tsp00_KnlIdentifier;
                    VAR dbfunc_name : tsp00_KnlIdentifier;
                    dstate          : tak_directory_state;
                    VAR method_buf  : tak_sysbufferaddress) : boolean;
 
        PROCEDURE
              a12NewMethod (
                    VAR acv         : tak_all_command_glob;
                    VAR SchemaId    : tgg00_Surrogate;
                    VAR DBFuncName  : tsp00_KnlIdentifier;
                    VAR MethodName  : tsp00_KnlIdentifier;
                    ErrorPos        : tsp00_Int4;
                    VAR IsReplace   : boolean;
                    MethodType      : tsp00_DbObjectType;
                    ProgId          : tsp00_C64;
                    VAR language    : tsp00_KnlIdentifier;
                    VAR methodbuf   : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              AK_usertab_tools : VAK19;
 
        PROCEDURE
              a19AddSystemTab  (VAR acv : tak_all_command_glob;
                    VAR surrogate  : tgg00_Surrogate;
                    surrogate_desc : tak_usertab_descriptor);
 
        PROCEDURE
              a19add_usertab  (VAR acv : tak_all_command_glob;
                    VAR user       : tgg00_Surrogate;
                    VAR surrogate  : tgg00_Surrogate;
                    surrogate_desc : tak_usertab_descriptor);
 
        PROCEDURE
              a19del_usertab  (VAR acv : tak_all_command_glob;
                    VAR user      : tgg00_Surrogate;
                    VAR surrogate : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              DBProc_DDL_Syntax : VAK201;
 
        PROCEDURE
              a201ReleaseInternalPackets (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Comment : VAK26;
 
        PROCEDURE
              a26drop_comment (
                    VAR acv      : tak_all_command_glob;
                    comment_type : tak_comment_type;
                    VAR id1      : tgg00_Surrogate;
                    VAR id2      : tgg00_Surrogate;
                    colno        : integer);
 
      ------------------------------ 
 
        FROM
              AK_dialog_tools : VAK260;
 
        PROCEDURE
              a260check_priv (VAR acv : tak_all_command_glob;
                    proc_id     : tgg00_Surrogate;
                    VAR user_id : tgg00_Surrogate);
 
        PROCEDURE
              a260get_proc (VAR acv : tak_all_command_glob;
                    VAR authname   : tsp00_KnlIdentifier;
                    VAR proc       : tsp00_KnlIdentifier;
                    VAR tree_index : integer);
 
        PROCEDURE
              a260ParseIdDrop (VAR acv : tak_all_command_glob;
                    VAR parsid : tak_parsid);
 
        PROCEDURE
              a260DropParseIds (VAR acv : tak_all_command_glob;
                    VAR p : tak_parskey);
 
        PROCEDURE
              a260trigger_call (
                    VAR acv          : tak_all_command_glob;
                    trigger_parsinfo : tak_sysbufferaddress);
 
        PROCEDURE
              a260trigger_parsinfo (
                    VAR acv         : tak_all_command_glob;
                    VAR parsinfokey : tgg00_SysInfoKey;
                    VAR proc_id     : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              Kernel_Sink: VAK34;
 
        PROCEDURE
              a34AllocPacket (
                    VAR acv        : tak_all_command_glob;
                    VAR packet_ptr : tsp1_packet_ptr;
                    VAR size       : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_data_dictionary : VAK38;
 
        PROCEDURE
              a38create_parameter_file (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_universal_show_tools : VAK40;
 
        PROCEDURE
              a40datatype_code (
                    VAR col_info : tak00_columninfo;
                    is_oracle    : boolean;
                    comp_type    : tak_appl_type;
                    VAR datatype : tsp00_Sname;
                    VAR code     : tsp00_C10;
                    VAR datalen  : integer);
 
      ------------------------------ 
 
        FROM
              Executing_dispatcher : VAK501;
 
        PROCEDURE
              a501GetResultName (
                    VAR acv : tak_all_command_glob;
                    VAR resultName : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51SetDebugSession (
                    VAR acv  : tak_all_command_glob;
                    session  : tgg91_SessionNo;
                    listener : tgg91_SessionNo);
 
        PROCEDURE
              a51RestoreUserContext (
                    VAR acv          : tak_all_command_glob;
                    VAR pOldContext  : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              AK_Lock_Commit_Rollback : VAK52;
 
        PROCEDURE
              a52end_rollback_subtrans (
                    VAR acv           : tak_all_command_glob;
                    VAR subtrans_name : tsp00_KnlIdentifier;
                    m_type            : tgg00_MessType);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK54;
 
        PROCEDURE
              a54_fixedpos (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a54_dml_init (
                    VAR acv   : tak_all_command_glob;
                    VAR dmli  : tak_dml_info;
                    in_union  : boolean);
 
        PROCEDURE
              a54_dml_finalize (
                    VAR dmli         : tak_dml_info;
                    VAR TransContext : tgg00_TransContext);
 
        PROCEDURE
              a54_internal_function (
                    VAR acv : tak_all_command_glob;
                    VAR m   : tgg00_MessBlock;
                    st_no   : integer);
 
        PROCEDURE
              a54InternalFunction (
                    VAR acv           : tak_all_command_glob;
                    VAR StackEntry    : tgg00_StackEntry;
                    VAR dataBuf       : tsp00_MoveObj;
                    dataBufSize       : integer;
                    dataBufPos        : integer;
                    use_acv_timestamp : boolean);
 
        PROCEDURE
              a54datetime_parsinfo (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    stackpos : integer);
 
        PROCEDURE
              a54expand_tabarr_ex(
                    VAR acv      : tak_all_command_glob;
                    VAR dmli     : tak_dml_info;
                    new_capacity : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542copy_into_packet (
                    VAR acv    : tak_all_command_glob;
                    const_addr : tsp00_MoveObjPtr;
                    const_len  : tsp00_Int4);
 
        PROCEDURE
              a542internal_packet (
                    VAR acv                 : tak_all_command_glob;
                    release_internal_packet : boolean;
                    required_len            : tsp00_Int4);
 
        PROCEDURE
              a542pop_packet (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a542push_packet (
                    VAR acv : tak_all_command_glob;
                    pPacket : tsp00_MoveObjPtr);
 
        PROCEDURE
              a542reset_packet (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a542SubstituteInPacket (
                    VAR acv         : tak_all_command_glob;
                    packetPos       : integer;
                    oldLength       : integer;
                    pNewValue       : tsp00_MoveObjPtr;
                    newLength       : integer);
 
      ------------------------------ 
 
        FROM
              AK_Update : VAK57;
 
        PROCEDURE
              a57update_with_value_expr (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR dfa  : tak_dfarr);
 
      ------------------------------ 
 
        FROM
              Select_Syntax : VAK60;
 
        PROCEDURE
              a60resnum (
                    VAR acv     : tak_all_command_glob;
                    VAR moveobj : tsp00_ResNum;
                    startpos    : integer);
 
        PROCEDURE
              a60rescount (VAR acv : tak_all_command_glob;
                    rescount : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Select_List : VAK61;
 
        PROCEDURE
              a61_search_table (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
      ------------------------------ 
 
        FROM
              Where_Part : VAK63;
 
        PROCEDURE
              a63_avalue_expression (VAR acv : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Execute_Where_Part : VAK65;
 
        PROCEDURE
              a65_search_condition (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    VAR first_node : integer);
 
        PROCEDURE
              a65_val_expr (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    VAR colin  : tak00_scolinf;
                    first_node : integer);
 
      ------------------------------ 
 
        FROM
              Resultname_handling : VAK663;
 
        PROCEDURE
              a663restable_get (VAR acv : tak_all_command_glob;
                    dstate     : tak_directory_state;
                    VAR tablen : tsp00_KnlIdentifier;
                    VAR sparr  : tak_syspointerarr;
                    VAR ok     : boolean);
 
      ------------------------------ 
 
        FROM
              Deal-With-User-Commands : VAK92;
 
        PROCEDURE
              a92find_return_part (
                    VAR acv      : tak_all_command_glob;
                    part_kind    : tsp1_part_kind;
                    VAR part_ptr : tsp1_part_ptr);
 
        PROCEDURE
              a92_resname_to_varpart(VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              DBS_Commands : VAK93;
 
        PROCEDURE
              a93packet_vtrace (
                    VAR t             : tgg00_TransContext;
                    trace_object      : tgg00_VtraceType;
                    packet_ptr        : tsp1_packet_ptr);
 
        PROCEDURE
              a93request (
                    acv_addr        : tak_acv_address;
                    sql_packet_ptr  : tsp1_packet_ptr);
 
      ------------------------------ 
 
        FROM
              KB_get : VKB71;
 
        PROCEDURE
              k71get_operand (VAR sel   : tgg00_SelectFieldsParam;
                    check_spec_null     : boolean;
                    VAR operand_addr    : tsp00_MoveObjPtr;
                    VAR len             : integer;
                    VAR e               : tgg00_BasisError);
 
        PROCEDURE
              k71sel_qualification_test (
                    VAR m          : tgg00_MessBlock;
                    VAR sel        : tgg00_SelectFieldsParam;
                    check_new_rec  : boolean;
                    VAR rec        : tgg00_Rec);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
        PROCEDURE
              b01destroy_file (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              b01tcreate_file (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD07;
 
        PROCEDURE
              b07cnext_record (
                    VAR t            : tgg00_TransContext;
                    VAR curr         : tgg00_FileId;
                    VAR rk           : tgg00_Lkey;
                    VAR set_result   : tgg00_BdSetResultRecord;
                    VAR tree_pos     : tgg00_FilePos;
                    VAR b            : tsp00_Buf);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code          : tgg04_CodeGlobals;
              g01glob          : tgg00_KernelGlobals;
              g01nil_long_qual : tgg00_LongQual;
              g01unicode       : boolean;
 
        PROCEDURE
              g01abort (
                    msg_no     : tsp00_Int4;
                    msg_label  : tsp00_C8;
                    msg_text   : tsp00_C24;
                    bad_value  : tsp00_Int4);
 
        FUNCTION
              g01packet_size : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Check-Date-Time : VGG03;
 
        PROCEDURE
              g03fdcheck_date (VAR sbuf   : tsp00_MoveObj;
                    VAR dbuf   : tsp00_MoveObj;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              g03ftcheck_time (VAR sbuf   : tsp00_MoveObj;
                    VAR dbuf   : tsp00_MoveObj;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              g03ftscheck_timestamp (VAR sbuf   : tsp00_MoveObj;
                    VAR dbuf   : tsp00_MoveObj;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    language   : tsp00_C3;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              g03dchange_format_date (VAR sbuf : tsp00_MoveObj;
                    VAR dbuf : tsp00_C64;
                    spos     : tsp00_Int4;
                    dpos     : tsp00_Int4;
                    format   : tgg00_DateTimeFormat;
                    VAR e    : tgg00_BasisError);
 
        PROCEDURE
              g03tchange_format_time (VAR sbuf : tsp00_MoveObj;
                    VAR dbuf : tsp00_C64;
                    spos     : tsp00_Int4;
                    dpos     : tsp00_Int4;
                    format   : tgg00_DateTimeFormat;
                    VAR e    : tgg00_BasisError);
 
        PROCEDURE
              g03tschange_format_timestamp (VAR sbuf : tsp00_MoveObj;
                    VAR dbuf : tsp00_C64;
                    spos     : tsp00_Int4;
                    dpos     : tsp00_Int4;
                    format   : tgg00_DateTimeFormat;
                    language : tsp00_C3;
                    VAR e    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04init_select_fields (
                    VAR sel       : tgg00_SelectFieldsParam;
                    data_addr     : tsp00_MoveObjPtr;
                    data_size     : tsp00_Int4;
                    work_st_addr  : tgg00_StackListPtr;
                    work_st_max   : tsp00_Int2;
                    work_buf_addr : tsp00_MoveObjPtr;
                    work_buf_size : tsp00_Int4;
                    curr_sqlmode  : tsp00_SqlMode;
                    fieldlistptr  : tgg00_FieldListsPtr);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        PROCEDURE
              gg06SessionBecomes (VAR SessionNo : tgg91_SessionNo; IntValue : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17int4to_line (
                    intval    : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_Line (*ptocSynonym char**));
 
      ------------------------------ 
 
        FROM
              GG_allocator_interface : vgg941;
 
        FUNCTION
              gg941Allocate(VAR TransContext : tgg00_TransContext;
                    wantedBytes : integer) : tsp00_BufAddr;
 
        PROCEDURE
              gg941Deallocate(VAR TransContext : tgg00_TransContext;
                    VAR p : tsp00_BufAddr);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20swap_int4 (
                    VAR val        : tsp00_Int4;
                    source_swap    : tsp00_SwapKind;
                    destin_swap    : tsp00_SwapKind);
 
      ------------------------------ 
 
        FROM
              Pointer-Arithmetik : VSP35;
 
        FUNCTION
              s35add_moveobj_ptr_ptocm (
                    addr : tsp00_MoveObjPtr;
                    pos : tsp00_Int4): tsp00_MoveObjPtr;
 
        FUNCTION
              s35inc_st_ptocm (addr : tgg00_StEntryAddr;
                    pos : tsp00_Int4) : tgg00_StEntryAddr;
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26init_cmd_packet (
                    packet_ptr               : tsp1_packet_ptr;
                    VAR first_segm_ptr       : tsp1_segment_ptr);
 
        PROCEDURE
              s26finish_part (
                    packet_ptr           : tsp1_packet_ptr;
                    VAR finish_part      : tsp1_part);
 
        PROCEDURE
              s26new_part_init (
                    packet_ptr             : tsp1_packet_ptr;
                    VAR segm               : tsp1_segment;
                    VAR new_part_ptr       : tsp1_part_ptr);
 
        PROCEDURE
              s26find_part (VAR segm : tsp1_segment;
                    part_kind        : tsp1_part_kind;
                    VAR part_ptr     : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              Version : VSP100;
 
        PROCEDURE
              sp100_GetSenderIDVersionP  (VAR SenderIDP  : tsp00_C5 );
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30lnr_defbyte (
                    str       : tsp00_MoveObjPtr;
                    defbyte   : char;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              GET-Conversions : VSP40;
 
        PROCEDURE
              s40gbyte (
                    VAR buf        : tsp00_MoveObj;
                    pos            : tsp00_Int4;
                    len            : integer;
                    VAR dest       : tsp00_Buf;
                    dpos           : tsp00_Int4;
                    dlen           : integer;
                    VAR truncated  : boolean);
 
      ------------------------------ 
 
        FROM
              PUT-Conversions : VSP41;
 
        PROCEDURE
              s41plint (
                    VAR buf : tsp00_MoveObj;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              GETSTRING-Conversions : VSP42;
 
        PROCEDURE
              s42gstr (
                    VAR buf  : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    len      : integer;
                    frac     : integer;
                    origlen  : integer;
                    VAR dest : tsp00_Buf;
                    dpos     : tsp00_Int4;
                    VAR dlen : integer;
                    VAR res  : tsp00_NumError);
 
        PROCEDURE
              s42gchr (
                    VAR buf  : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    len      : integer;
                    frac     : integer;
                    origlen  : integer;
                    VAR dest : tsp00_Buf;
                    dpos     : tsp00_Int4;
                    VAR dlen : integer;
                    VAR res  : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80 : VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id   : tsp00_C6;
                    mod_num  : tsp00_Int4;
                    src_upb  : tsp00_Int4;
                    dest_upb : tsp00_Int4;
                    src      : tsp00_MoveObjPtr;
                    src_pos  : tsp00_Int4;
                    dest     : tsp00_MoveObjPtr;
                    dest_pos : tsp00_Int4;
                    length   : tsp00_Int4;
                    VAR err  : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalUnicodeFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2;
                    VAR e       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        FUNCTION
              vGetAcvPtrFromCurrentTask : tak_acv_address;
&       ifdef trace
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01stackentry (
                    debug          : tgg00_Debug;
                    VAR st         : tgg00_StackEntry;
                    entry_index    : integer);
 
        PROCEDURE
              t01name (debug : tgg00_Debug; nam  : tsp00_Name);
 
        PROCEDURE
              t01lidentifier (debug : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR m         : tgg00_MessBlock);
 
        PROCEDURE
              t01moveobj (
                    layer    : tgg00_Debug;
                    VAR buf  : tsp00_MoveObj;
                    startpos : tsp00_Int4;
                    endpos   : tsp00_Int4);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01surrogate (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR tabid : tgg00_Surrogate);
 
        PROCEDURE
              t01packet (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname (*ptocSynonym const char**);
                    packet_ptr : tsp1_packet_ptr);
 
        PROCEDURE
              t01longdescriptor (
                    debug     : tgg00_Debug;
                    long_desc : tsp00_LongDescriptor);
&       endif
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        FUNCTION
              gg941Allocate;
 
              tsp00_Addr tsp00_BufAddr
 
        PROCEDURE
              gg941Deallocate;
 
              tsp00_Addr  tsp00_BufAddr
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              a05_string_literal_get;
 
              tsp00_MoveObj tsp00_Buf
 
        PROCEDURE
              a10new;
 
              tak_sysbufferaddress tak_param_info_ptr
 
        PROCEDURE
              a10dispose;
 
              tak_sysbufferaddress  tsp00_MoveObjPtr
 
        PROCEDURE
              a60resnum;
 
              tsp00_MoveObj tsp00_ResNum
 
        PROCEDURE
              g03dchange_format_date;
 
              tsp00_MoveObj  tsp00_C64
 
        PROCEDURE
              g03tchange_format_time;
 
              tsp00_MoveObj tsp00_C64
 
        PROCEDURE
              g03tschange_format_timestamp;
 
              tsp00_MoveObj tsp00_C64
 
        PROCEDURE
              b07cnext_record;
 
              tsp00_MoveObj tsp00_Buf
 
        FUNCTION
              s35add_moveobj_ptr_ptocm;
 
              tsp00_Int4 tsp00_MoveObjPtr;
 
        PROCEDURE
              s40gbyte;
 
              tsp00_MoveObj tsp00_Buf
 
        PROCEDURE
              s42gstr;
 
              tsp00_MoveObj tsp00_Buf
 
        PROCEDURE
              s42gchr;
 
              tsp00_MoveObj tsp00_Buf
 
.CM *-END-* synonym -------------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      cak262_all_base              = true;
      cak262_is_column_map         = true;
      cak262_old_flag              = 1000;
      cak262_max_pos_info          = 2 * MAX_COL_PER_TAB_GG00;
      cak262is_create_trigger      = true;
      cak262_rc_digits             = 5;
      cak262_count_digits          = 10;
      cak262_max_errormsg          = 80;
      cak262_internalTriggerOffset = 10;
      c_is_rollback                = true;
      c_IsTrigger                  = true;
      c_IsDBFunc                   = true;
      c_localVariables             = true;
 
TYPE
      tak262_SelectFieldsParamPtr = ^tgg00_SelectFieldsParam;
      tak262_dmli_ptr  = ^tak_dml_info;
      tak262_dfarr_ptr = ^tak_dfarr;
      tak262_SurrogatePtr = ^tgg00_Surrogate;
 
      tak262CharMapDatatype = RECORD
            CASE boolean OF
                true :
                    (dt : tsp00_DataType);
                false :
                    (c : tsp00_C1);
                END;
            (*ENDCASE*) 
 
 
      tak262compile_glob = RECORD
            cp_stmt_no        : tsp00_Int4;
            cp_first_var_pos  : tsp00_Int4;
            cp_first_param_idx: tsp00_Int4;
            cp_rec_pos        : tsp00_Int4;
            cp_cnt_tables     : tsp00_Int4;
            cp_cursor_pos     : tsp00_Int4;
            cp_returnPos      : tsp00_Int4;
            cp_returnLen      : tsp00_Int4;
            cp_returnColin    : tak00_scolinf;
            cp_returnCol      : tak00_colinfo_ptr;
            cp_pDebugInfo     : ^tak_method_debuginfo;
            cp_pDebugColMap   : ^tak_method_debuginfo;
            cp_trig_ptr       : tak_sysbufferaddress;
            cp_trig_kind      : tsp00_C2;
            cp_ins_trigger    : boolean;
            cp_upd_trigger    : boolean;
            cp_del_trigger    : boolean;
            cp_isCursorDBProc : boolean;
            cp_unknownOutLen  : boolean;
            cp_containsSQL    : boolean;
            cp_returnFound    : boolean;
            cp_deterministic  : boolean;
            cp_procType       : tsp00_DbObjectType;
            cp_trigTabid      : tgg00_Surrogate;
            cp_varTabId       : tgg00_Surrogate;
            cp_procId         : tgg00_Surrogate;
            cp_tablen         : tsp00_KnlIdentifier;
            cp_colname        : tsp00_KnlIdentifier;
            cp_node           : tak_ap_node;
            cp_base_table     : tak_sysbufferaddress;
            cp_out_params     : tak_columnset;
            cp_modified_cols  : tak_columnset;
            cp_const_params   : SET OF 1 .. cak_max_param_index;
            cp_pos_info       : ARRAY[1..cak262_max_pos_info] OF tsp00_Int2;
      END;
 
 
      tak262LoopInfo = RECORD
            lp_ConditionStackEntry : tsp00_Int4;
            lp_BreakStackEntry     : tsp00_Int4;
            lp_TryCatchLevel       : tsp00_Int4;
            lp_InLoop              : boolean;
      END;
 
 
      tak262DebugExecuteInfo = RECORD
            dei_type        : integer;
            dei_position    : tsp00_Int4;
            dei_breakPos    : tsp00_Int4;
            dei_identifier1 : tsp00_KnlIdentifier;
            dei_identifier2 : tsp00_KnlIdentifier;
      END;
 
 
      tak262trigger_lkey = RECORD
            CASE integer OF
                1 :
                    (r_len   : tsp00_Int2;
                    k_len    : tsp00_Int2;
                    k_f1     : tsp00_Int2;
                    k_f2     : tsp00_Int2;
                    tg_c4    : tsp00_C4;
                    tg_tabid : tgg00_Surrogate;
                    tg_link  : tsp00_C2);
                2 :
                    (r1_len : tsp00_Int2;
                    k1_len  : tsp00_Int2;
                    k1_f1   : tsp00_Int2;
                    k1_f2   : tsp00_Int2;
                    c14     : tsp00_C14);
                END;
            (*ENDCASE*) 
 
      tak262TriggerParamBuffer = ARRAY[1..3] OF tsp00_Buf;
 
      tak262LongDescriptor  = RECORD
            CASE boolean OF
                true :
                    (filler : tsp00_C3;
                    defByte : char);
                false :
                    (filler1 : tsp00_Int4;
                    ld       : tak_long_descriptor);
                END;
            (*ENDCASE*) 
 
 
VAR
      ak262int_trigger_cnt : tsp00_Int4;
      ak262ext_trigger_cnt : tsp00_Int4;
 
 
(*------------------------------*) 
 
PROCEDURE
      a262add_trigger_info (
            VAR acv           : tak_all_command_glob;
            VAR dmli          : tak_dml_info;
            ignoreUserTrigger : boolean);
 
CONST
      c_is_internal = true;
 
VAR
      qual_cnt        : integer;
      addInfo         : boolean;
      catalogSchemaId : tgg00_Surrogate;
 
BEGIN
&ifdef trace
t01int4 (ak_sem, 'ReplicationS', ord(acv.a_isReplicationSession));
&endif
IF  acv.a_returncode = 0
THEN
    BEGIN
    a103CatalogSchemaId (catalogSchemaId);
    IF  dmli.d_sparr.pbasep^.sbase.bschema = catalogSchemaId
    THEN
        acv.a_mblock.mb_qual^.mcachetrigger := a103GetTriggerId (dmli.d_sparr.pbasep^.sbase.btablen^);
    (*ENDIF*) 
    IF  internal_trigger in dmli.d_sparr.pbasep^.sbase.blinkexist
    THEN
        IF  NOT acv.a_isReplicationSession
            OR
            acv.a_withInternalTriggers
        THEN
            ak262add_trigger_info (acv, dmli, c_is_internal);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  NOT acv.a_isReplicationSession AND NOT ignoreUserTrigger AND (acv.a_returncode = 0)
    THEN
        BEGIN
        CASE acv.a_mblock.mb_type OF
            m_insert, m_insert_select :
                addInfo := ins_trigger in dmli.d_sparr.pbasep^.sbase.blinkexist;
            m_delete :
                addInfo := del_trigger in dmli.d_sparr.pbasep^.sbase.blinkexist;
            m_update :
                addInfo := upd_trigger in dmli.d_sparr.pbasep^.sbase.blinkexist;
            OTHERWISE
                addInfo := false;
            END;
        (*ENDCASE*) 
        IF  addInfo
        THEN
            ak262add_trigger_info (acv, dmli, NOT c_is_internal);
        (*ENDIF*) 
        IF  (acv.a_mblock.mb_qual^.mtrigger_pos > 0) AND
            (acv.a_mblock.mb_qual^.mtrigger_cnt = 0)
        THEN
            BEGIN
            (* insert a dummy stack entry, otherwise no trigger will be called from kb *)
            acv.a_mblock.mb_qual^.mtrigger_cnt := 1;
            qual_cnt := acv.a_mblock.mb_qual^.mqual_cnt;
            ak262emit (acv, st_dummy, 0, 0);
            acv.a_mblock.mb_qual^.mqual_cnt := qual_cnt;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262add_trigger_info (
            VAR acv         : tak_all_command_glob;
            VAR dmli        : tak_dml_info;
            internalTrigger : boolean);
 
VAR
      b_err            : tgg00_BasisError;
      init_linkage     : tsp00_C2;
      add_trigger_info : boolean;
      i                : integer;
      j                : integer;
      val_pos          : integer;
      colind           : integer;
      move_len         : integer;
      toCopy           : integer;
      copyCnt          : integer;
      tr_st_idx        : integer;
      tr_st_pos        : integer;
      first            : tak_sysbufferaddress;
      last             : tak_sysbufferaddress;
      trigger_key      : tgg00_SysInfoKey;
      trigger_info     : tgg00_TriggerInfo;
 
BEGIN
WITH acv, dmli DO
    BEGIN
    trigger_key := d_sparr.pbasep^.syskey;
    WITH d_sparr.pbasep^.sbase DO
        BEGIN
        IF  btablekind = tonebase
        THEN
            trigger_key.stableid := btreeid.fileTabId_gg00;
        (*ENDIF*) 
        trigger_key.sentrytyp := cak_etrigger;
        END;
    (*ENDWITH*) 
    trigger_info.tg_messType := a_mblock.mb_type;
    CASE a_mblock.mb_type OF
        m_insert, m_insert_select :
            BEGIN
            trigger_info.tg_messType := m_insert;
            trigger_key.slinkage     := cak_ins_trigger_linkage;
            END;
        m_delete :
            trigger_key.slinkage := cak_del_trigger_linkage;
        m_update :
            trigger_key.slinkage := cak_upd_trigger_linkage;
        END;
    (*ENDCASE*) 
    IF  internalTrigger
    THEN
        trigger_key.slinkage[2] := chr(ord(trigger_key.slinkage[2]) + cak262_internalTriggerOffset);
    (*ENDIF*) 
    init_linkage := trigger_key.slinkage;
    a10get_sysinfo (acv, trigger_key, d_fix, first, b_err);
    IF  b_err = e_ok
    THEN
        WITH first^.strigger, a_mblock DO
            IF  (tr_condition_cnt < 0) OR
                (tr_condition_cnt = csp_maxint2)
            THEN
                b_err := e_procedure_must_be_recompiled;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        WITH a_mblock DO
            BEGIN
            last             := first;
            add_trigger_info := true;
            IF  internalTrigger
            THEN
                trigger_info.tg_misc := [mi_internal]
            ELSE
                trigger_info.tg_misc := [];
            (*ENDIF*) 
            IF  mb_type = m_update
            THEN
                BEGIN
                IF  (first^.strigger.tr_upd_set * d_upd_set <> [  ])
                THEN
                    BEGIN
                    (* at least one trigger column has been updated *)
&                   ifdef trace
                    t01int4 (ak_sem, 'upd columns ', 1);
&                   endif
                    trigger_info.tg_upd_set := [  ];
                    trigger_info.tg_misc    :=
                          trigger_info.tg_misc + [ mi_upd_cols ];
                    colind := d_sparr.pbasep^.sbase.bfirstcolind;
                    REPEAT
                        WITH d_sparr.pbasep^.sbase.bcolumn[colind]^ DO
                            BEGIN
                            IF  (creccolno in d_upd_set ) AND
                                (creccolno in first^.strigger.tr_upd_set)
                            THEN
                                BEGIN
                                j := mb_qual^.mcol_pos;
                                WHILE j < mb_qual^.mcol_pos +
                                      mb_qual^.mcol_cnt DO
                                    WITH mb_st^ [j] DO
                                        IF  (etype    = ccolstack.etype) AND
                                            (epos     = ccolstack.epos)  AND
                                            (elen_var = ccolstack.elen_var)
                                        THEN
                                            BEGIN
                                            trigger_info.tg_upd_set:=
                                                  trigger_info.tg_upd_set +
                                                  [ j-mb_qual^.mcol_pos+1  ];
                                            j := csp_maxint2
                                            END
                                        ELSE
                                            j := j + 1;
                                        (*ENDIF*) 
                                    (*ENDWITH*) 
                                (*ENDWHILE*) 
                                END;
                            (*ENDIF*) 
                            colind := cnextind
                            END;
                        (*ENDWITH*) 
                    UNTIL
                        colind = 0;
                    (*ENDREPEAT*) 
                    END
                ELSE (* none of the trigger upd columns has been updated *)
                    IF  first^.strigger.tr_upd_set <> []
                    THEN
                        add_trigger_info := false;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  first^.strigger.tr_maxUpdatedColno > 0
                THEN
                    BEGIN
                    trigger_info.tg_updated_set_size :=
                          (first^.strigger.tr_maxUpdatedColno + 7) DIV 8;
                    trigger_info.tg_updated_set := d_upd_set
                    END
                ELSE
                    BEGIN
                    trigger_info.tg_updated_set_size := 0;
                    trigger_info.tg_updated_set := [];
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  add_trigger_info
            THEN
                BEGIN (* store trigger info into message buffer *)
                IF  mb_qual^.mfirst_free
                    +
                    first^.strigger.tr_param_cnt + first^.strigger.tr_condition_cnt
                    >
                    mb_st_max + 1
                THEN
                    a07_b_put_error (acv, e_too_complex_trigger_cond, 1)
                ELSE
                    IF  mb_qual_len + sizeof(mb_qual^.mtrigger_info) > mb_qual_size
                    THEN
                        a07_b_put_error (acv, e_too_small_mb_qual_part, 1)
                    ELSE
                        BEGIN
                        trigger_info.tg_param_pos  := mb_qual^.mfirst_free;
                        trigger_info.tg_param_cnt  := first^.strigger.tr_param_cnt;
                        trigger_info.tg_qual_pos   := trigger_info.tg_param_pos + trigger_info.tg_param_cnt;
                        trigger_info.tg_qual_cnt   := first^.strigger.tr_condition_cnt;
                        IF  mb_qual^.mtrigger_pos = 0
                        THEN
                            BEGIN
                            mb_qual^.mtrigger_pos := mb_qual^.mfirst_free;
                            mb_qual^.mtrigger_info.tiqb_tree_id       := acv.a_trigger_tree;
                            mb_qual^.mtrigger_info.tiqb_trigger_count := 0;
                            END;
                        (*ENDIF*) 
                        mb_qual^.mtrigger_info.tiqb_trigger_count :=
                              mb_qual^.mtrigger_info.tiqb_trigger_count + 1;
                        mb_qual^.mtrigger_info.tiqb_trigger_info[
                              mb_qual^.mtrigger_info.tiqb_trigger_count] := trigger_info;
                        mb_qual_len := sizeof(mb_qual^.mtrigger_info);
                        (* trigger_info into message-buffer *)
                        i := (mb_qual^.mfirst_free - 1) * STACK_ENTRY_MXGG00 + 1;
                        (* parameter and whenever condition stack *)
                        (* entries into message buffer            *)
                        tr_st_idx :=  ((first^.strigger.tr_name_len - 1) DIV
                              sizeof (first^.strigger.tr_stack[1]) + 1) + 1;
                        toCopy := first^.strigger.tr_param_cnt + first^.strigger.tr_condition_cnt;
                        REPEAT
                            IF  tr_st_idx + toCopy - 1 > cak_max_trigger_stack
                            THEN
                                copyCnt := cak_max_trigger_stack - tr_st_idx + 1
                            ELSE
                                copyCnt := toCopy;
                            (*ENDIF*) 
                            move_len := copyCnt * sizeof(last^.strigger.tr_stack[1]);
&                           ifdef trace
                            t01int4 (ak_sem, 'copyCnt     ', copyCnt);
                            t01int4 (ak_sem, 'move_len    ', move_len);
&                           endif
                            tr_st_pos :=  (tr_st_idx - 1) * sizeof(last^.strigger.tr_stack[1]) + 1;
                            SAPDB_PascalMove ('VAK262',   1,    
                                  sizeof(last^.strigger.tr_stack), mb_st_size,
                                  @last^.strigger.tr_stack, tr_st_pos,
                                  @mb_st^, i, move_len,
                                  a_returncode);
                            i      := i + move_len;
                            toCopy := toCopy - copyCnt;
                            IF  toCopy > 0
                            THEN
                                BEGIN
                                IF  first <> last
                                THEN
                                    a10rel_sysinfo (last);
                                (*ENDIF*) 
                                a06inc_linkage (trigger_key.slinkage);
                                a10get_sysinfo (acv, trigger_key, d_fix, last, b_err);
                                IF  b_err <> e_ok
                                THEN
                                    BEGIN
                                    toCopy := 0;
                                    a07_b_put_error (acv, b_err, 1)
                                    END
                                ELSE
                                    tr_st_idx := 1;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                        UNTIL
                            toCopy <= 0;
                        (*ENDREPEAT*) 
                        mb_qual^.mtrigger_cnt := mb_qual^.mtrigger_cnt +
                              first^.strigger.tr_param_cnt + first^.strigger.tr_condition_cnt;
                        mb_qual^.mfirst_free := mb_qual^.mtrigger_pos + mb_qual^.mtrigger_cnt;
                        IF  a_returncode = 0
                        THEN
                            IF  NOT last^.strigger.tr_succ_exists
                            THEN
                                BEGIN
                                val_pos  := sizeof (last^.strigger) -
                                      sizeof (last^.strigger.tr_stack) +
                                      tr_st_pos + move_len;
                                move_len := last^.b_sl - val_pos + 1
                                END
                            ELSE
                                BEGIN
                                a06inc_linkage (trigger_key.slinkage);
                                a10get_sysinfo (acv, trigger_key,
                                      d_release, last, b_err);
                                IF  b_err <> e_ok
                                THEN
                                    a07_b_put_error (acv, b_err, 1)
                                ELSE
                                    BEGIN
                                    val_pos  := cak_sysbufferoffset + 1;
                                    move_len := last^.b_sl - cak_sysbufferoffset
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        IF  a_returncode = 0
                        THEN
                            BEGIN
&                           ifdef trace
                            t01int4 (ak_sem, 'mb_type     ', ord(mb_type));
                            t01int4 (ak_sem, 'val_pos     ', val_pos);
                            t01int4 (ak_sem, 'move_len    ', move_len);
&                           endif
                            IF  (a_ex_kind = only_parsing) AND
                                (dmli.d_sparr.pparsp <> NIL) (* PTS 1113215 *)
                            THEN
                                a54_fixedpos (acv, dmli);
                            (*ENDIF*) 
                            ak262in_buf (acv, dmli, last,
                                  move_len, trigger_info.tg_qual_pos,
                                  trigger_info.tg_qual_cnt, val_pos);
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  a_returncode = 0
                THEN
                    BEGIN (* create trigger parsinfo *)
                    trigger_key.slinkage  := init_linkage;
                    trigger_key.sentrytyp := cak_etriggerparsinfo;
                    IF  first^.strigger.tr_language = lang_pl
                    THEN
                        ak262build_trigger_parsinfo (acv, trigger_key,
                              d_sparr.pbasep^.sbase.btreeid.fileVersion_gg00)
                    ELSE
                        a260trigger_parsinfo (acv, trigger_key, first^.strigger.tr_proc_id)
                    (*ENDIF*) 
                    END;
&               ifdef trace
                (*ENDIF*) 
                t01messblock (sproc_call, 'a_mblock    ', a_mblock );
&               endif
                END;
            (*ENDIF*) 
            a10rel_sysinfo (first);
            a10rel_sysinfo (last)
            END
        (*ENDWITH*) 
    ELSE
        IF  NOT internalTrigger
        THEN
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262build_trigger_parsinfo (
            VAR acv          : tak_all_command_glob;
            VAR trigger_key  : tgg00_SysInfoKey;
            tableFileVersion : tgg91_FileVersion);
 
VAR
      e          : tgg00_BasisError;
      p          : tak_sysbufferaddress;
      mblock_ptr : tak_sysbufferaddress;
 
BEGIN
a10get_sysinfo (acv, trigger_key, d_release, p, e);
IF  e = e_ok
THEN (* trigger parsinfo already exists, look if up to date *)
    IF  p^.smessblock.mbr_mess_block.mb_qual^.mtree.fileVersion_gg00 <>
        tableFileVersion
    THEN
        BEGIN (* parsinfo may be out of date *)
        a262DropParseIds (acv, p^.smessblock.mbr_mess_block); (* PTS 1109670 *)
        a10del_sysinfo (acv, trigger_key, e);
        e := e_sysinfo_not_found
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  e = e_sysinfo_not_found
THEN
    BEGIN
    a262LoadCode (acv, trigger_key.stableid, trigger_key.slinkage, p);
    IF  p <> NIL
    THEN
        BEGIN
        a10mblock_into_cache (acv, trigger_key,
              p^.smessblock.mbr_mess_block, d_release, mblock_ptr, e);
        a10rel_sysinfo (mblock_ptr);
        IF  e = e_ok
        THEN
            BEGIN
            mblock_ptr^.smessblock.mbr_mess_block.mb_qual^.mtree.fileVersion_gg00 :=
                  tableFileVersion; (* PTS 1109670 *)
            a10add_sysinfo (acv, mblock_ptr, e)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262compile (
            VAR acv    : tak_all_command_glob;
            tree_index : integer);
 
VAR
      LoopInfo     : tak262LoopInfo;
      compile_glob : tak262compile_glob;
 
BEGIN
ak262InitCompileGlob (compile_glob, dbo_dbproc);
ak262InitLoopInfo    (LoopInfo);
a06a_mblock_init     (acv, m_procedure, mm_trigger, acv.a_p_arr1.pbasep^.sbase.btreeid);
acv.a_mblock.mb_data_len := cgg_rec_key_offset + acv.a_p_arr1.pbasep^.sbase.blenfixedcol - 1;
acv.a_mblock.mb_data^.mbp_rec.recLen_gg00 := acv.a_mblock.mb_data_len;
ak262compile (acv, tree_index, 0, 0, LoopInfo, compile_glob)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262CreateDBProc (VAR acv : tak_all_command_glob;
            isSystemTrigger : boolean);
 
CONST
      c_public = true;
 
BEGIN
ak262Create (acv, dbo_dbproc, NOT c_public, isSystemTrigger);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262Create (VAR acv : tak_all_command_glob;
            dbprocType      : tsp00_DbObjectType;
            isPublic        : boolean;
            isSystemTrigger : boolean);
 
CONST
      c_release_packet = true;
 
VAR
      ex_kind            : tak_execution_kind;
      e                  : tgg00_BasisError;
      IsReplace          : boolean;
      ix                 : integer;
      tree_index         : integer;
      name_index         : integer;
      param_index        : integer;
      var_index          : integer;
      javaExtNameNode    : integer;
      pos                : integer;
      VariablesStackSize : tsp00_Int4;
      p                  : tsp00_KnlIdentifierPtr;
      MethodBuf          : tak_sysbufferaddress;
      schemaId           : tgg00_Surrogate;
      schemaName         : tsp00_KnlIdentifier;
      DBProcName         : tsp00_KnlIdentifier;
      Language           : tsp00_KnlIdentifier;
      compile_glob       : tak262compile_glob;
      BlankC64           : tsp00_C64;
      Syskey             : tgg00_SysInfoKey;
 
BEGIN
var_index   := 0;
param_index := 0;
ak262InitCompileGlob (compile_glob, dbprocType);
compile_glob.cp_isCursorDBProc := false;
tree_index := acv.a_ap_tree^[0].n_lo_level;
name_index := acv.a_ap_tree^[tree_index].n_lo_level;
schemaId   := acv.a_curr_schema_id;
IF  acv.a_ap_tree^[name_index].n_symb = s_authid
THEN
    BEGIN
    pos := acv.a_ap_tree^[name_index].n_pos;
    a06get_username (acv, name_index, schemaName);
    a101_MapSchemaName (acv, schemaName, pos);
    IF  schemaName <> acv.a_curr_user_name
    THEN
        IF  schemaName = a01_i_temp
        THEN
            a07_b_put_error (acv, e_missing_privilege, acv.a_ap_tree^[name_index].n_pos)
        ELSE
            BEGIN
            a103GetSchemaId (acv, schemaName, acv.a_ap_tree^[name_index].n_pos, schemaId);
            IF  acv.a_returncode = 0
            THEN
                a103CheckCreateInPrivilege (acv, schemaName, acv.a_ap_tree^[name_index].n_pos);
            (*ENDIF*) 
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END
ELSE
    IF  isPublic
    THEN
        IF  NOT (acv.a_current_user_kind in [udba, usysdba])
        THEN
            a07_kw_put_error (acv, e_missing_privilege, 1, cak_i_dba)
        ELSE
            schemaId := cak_public_id;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
a05identifier_get (acv, name_index,
      sizeof (DBProcName), DBProcName);
tree_index                     := acv.a_ap_tree^[tree_index].n_sa_level;
compile_glob.cp_isCursorDBProc := acv.a_ap_tree^[tree_index].n_subproc = cak_i_cursor;
compile_glob.cp_deterministic  := acv.a_ap_tree^[tree_index].n_subproc = cak_i_deterministic;
param_index  := acv.a_ap_tree^[tree_index].n_lo_level;
tree_index   := acv.a_ap_tree^[tree_index].n_sa_level;
&ifdef trace
t01int4 (ak_sem, 'tree_index  ', tree_index);
&endif
IF  (acv.a_ap_tree^[tree_index].n_proc = a262         ) AND
    (acv.a_ap_tree^[tree_index].n_subproc = cak_i_language)
THEN
    BEGIN
    tree_index := acv.a_ap_tree^[tree_index].n_sa_level;
    a05identifier_get (acv, tree_index, sizeof(Language), Language);
    javaExtNameNode := acv.a_ap_tree^[tree_index].n_sa_level;
    tree_index      := 0;
    END
ELSE
    BEGIN
    javaExtNameNode := 0;
    Language        := a01_il_b_identifier;
    tree_index      := acv.a_ap_tree^[tree_index].n_lo_level;
    tree_index      := acv.a_ap_tree^[tree_index].n_lo_level;
    END;
(*ENDIF*) 
ak262createVarTable  (acv, compile_glob, param_index, tree_index);
IF  acv.a_returncode = 0
THEN
    BEGIN
    VariablesStackSize := acv.a_p_arr1.pbasep^.sbase.blenfixedcol - 1;
    IsReplace          := false;
    BlankC64           := bsp_c64;
    acv.a_is_ddl       := ddl_create_procedure;
    a12NewMethod (acv, schemaId, DBProcName, DBProcName,
          1, IsReplace, dbprocType, BlankC64, Language, MethodBuf);
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        compile_glob.cp_procId := MethodBuf^.smethod.me_surrogate;
        ak262DescribeDBProcParameters (acv, compile_glob, MethodBuf^.smethod, param_index);
        END;
    (* IF  (compile_glob.cp_unknownOutLen) AND *)
    (*ENDIF*) 
    IF    (acv.a_returncode = 0)
    THEN
        ak262StoreVarTable (acv, MethodBuf^.smethod.me_surrogate);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    Syskey := MethodBuf^.syskey;
    MethodBuf^.smethod.me_cursor := compile_glob.cp_isCursorDBProc;
    IF  isSystemTrigger
    THEN
        MethodBuf^.smethod.me_type := dbo_system_trigger;
    (*ENDIF*) 
    IF  javaExtNameNode <> 0
    THEN
        BEGIN
        IF  Language = a01_i_java
        THEN
            MethodBuf^.smethod.me_language := lang_java
        ELSE
            IF  Language = a01_i_system
            THEN
                MethodBuf^.smethod.me_language := lang_system
            ELSE
                MethodBuf^.smethod.me_language := lang_other
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        MethodBuf^.smethod.me_language := lang_pl;
    (*ENDIF*) 
    MethodBuf^.smethod.me_owner := acv.a_curr_user_id;
    a10_add_repl_sysinfo (acv, MethodBuf, NOT IsReplace, e);
    IF  e =  e_ok
    THEN
        BEGIN
        compile_glob.cp_trig_ptr := MethodBuf;
        (*        IF  javaExtNameNode <> 0 *)
        (*        THEN                     *)
        IF  javaExtNameNode <> 0
        THEN
            ak262StoreJavaString (acv, MethodBuf^.smethod.me_surrogate, javaExtNameNode);
        (*ak262store_create_stmt (acv, compile_glob);*)
        (*ENDIF*) 
        ak262StoreStmtAndComplile (acv, compile_glob,
              tree_index, VariablesStackSize, NOT c_IsTrigger, dbprocType = dbo_dbfunc);
        ak262describeParameterVariables (acv,  compile_glob);
        ak262FinishCompilation (acv, compile_glob,
              MethodBuf^.syskey.stableid, MethodBuf^.syskey.slinkage);
        ak262ddl_parse_sql_statements (acv, MethodBuf^.syskey.stableid,
              NOT cak262is_create_trigger, [chr(1)]);
        END;
    (*ENDIF*) 
    IF  (dbprocType = dbo_dbfunc) AND (acv.a_returncode = 0)
    THEN
        IF  NOT compile_glob.cp_returnFound
        THEN
            a07_nb_put_error (acv, e_missing_return, 1, DBProcName)
        ELSE
            BEGIN
            a10get_sysinfo (acv, Syskey, d_release, MethodBuf, e);
            IF  e = e_ok
            THEN
                BEGIN
                MethodBuf^.smethod.me_sql           := compile_glob.cp_containsSQL;
                MethodBuf^.smethod.me_deterministic := compile_glob.cp_deterministic;
                MethodBuf^.smethod.me_return_pos    := compile_glob.cp_returnPos;
                MethodBuf^.smethod.me_return_len    := compile_glob.cp_returnLen;
                FOR ix := 1 TO MethodBuf^.smethod.me_param_cnt DO
                    IF  ix in compile_glob.cp_const_params
                    THEN
                        MethodBuf^.smethod.me_param_list[ix]^.param_state := param_const
                    ELSE
                        MethodBuf^.smethod.me_param_list[ix]^.param_state := param_undef;
                    (*ENDIF*) 
                (*ENDFOR*) 
                a10_add_repl_sysinfo (acv, MethodBuf, IsReplace, e);
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  isSystemTrigger
    THEN
        a19AddSystemTab  (acv, compile_glob.cp_procId, ut_procedure);
    (*ENDIF*) 
    IF  e <> e_ok
    THEN
        a07_b_put_error (acv, e, 1)
    (*ENDIF*) 
    END;
(*ENDIF*) 
acv.a_is_ddl   := ddl_create_procedure;
acv.a_init_ddl := ddl_create_procedure
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262DBFuncCreate (VAR acv : tak_all_command_glob;
            isPublic : boolean);
 
CONST
      c_isSystemTrigger = true;
 
BEGIN
ak262Create (acv, dbo_dbfunc, isPublic, NOT c_isSystemTrigger);
END;
 
(* PTS 1109670 *)
(*------------------------------*) 
 
PROCEDURE
      a262DebugSyntax (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      reserved  : boolean;
      pos       : integer;
      last_node : tsp00_Int2;
      kw        : integer;
 
BEGIN
a01_next_symbol (acv);
a01_get_keyword (acv, kw, reserved);
acv.a_is_ddl := ddl_create_table;
CASE kw OF
    cak_i_break :
        BEGIN
        acv.a_is_ddl := no_ddl;
        a01_next_symbol (acv);
        IF  a01mandatory_keyword (acv, cak_i_at)
        THEN
            BEGIN
            a01_call_put (acv, a262, cak_i_break, put_node);
            a01_get_keyword (acv, kw, reserved);
            CASE kw OF
                cak_i_function, cak_i_dbproc, cak_i_dbprocedure :
                    BEGIN (* break at db-procedure *)
                    a01_next_symbol (acv);
                    a01_call_put (acv, a262, kw, last_node);
                    acv.a_ap_tree^[put_node].n_sa_level := last_node;
                    a02procedure (acv, acv.a_ap_tree^[last_node].n_sa_level, last_node);
                    END;
                cak_i_trigger :
                    BEGIN (* break at trigger *)
                    a01_next_symbol (acv);
                    a01_call_put (acv, a262, cak_i_trigger, last_node);
                    acv.a_ap_tree^[put_node].n_sa_level := last_node;
                    a02_put_identifier (acv, acv.a_ap_tree^[last_node].n_sa_level, last_node);
                    IF  a01mandatory_keyword (acv, cak_i_of)
                    THEN
                        a02_atablename (acv, acv.a_ap_tree^[last_node].n_sa_level, last_node);
                    (*ENDIF*) 
                    END;
                OTHERWISE
                    a07_error (acv, e_wanted_keyword, put_node, put_node);
                END;
            (*ENDCASE*) 
            IF  acv.a_scv.sc_symb <> s_eof
            THEN
                BEGIN
                a03_aunsigned_integer (acv, acv.a_ap_tree^[put_node].n_lo_level, last_node);
                IF  acv.a_scv.sc_symb <> s_eof
                THEN
                    IF  a01mandatory_keyword (acv, cak_i_delete)
                    THEN
                        BEGIN
                        acv.a_is_ddl := ddl_create_table;
                        acv.a_ap_tree^[put_node].n_subproc := cak_i_delete;
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    cak_i_cancel, cak_i_continue, cak_i_stop :
        BEGIN
        a01_next_symbol (acv);
        a01_call_put (acv, a262, kw, put_node);
        END;
    cak_i_next :
        BEGIN
        a01_next_symbol (acv);
        a01_call_put (acv, a262, cak_i_next, put_node);
        IF  acv.a_scv.sc_symb <> s_eof
        THEN
            BEGIN
            a01_get_keyword (acv, kw, reserved);
            CASE kw OF
                cak_i_into, cak_i_out :
                    BEGIN
                    a01_call_put (acv, a262, kw, acv.a_ap_tree^[put_node].n_sa_level);
                    a01_next_symbol (acv);
                    END
                OTHERWISE
                    a03_aunsigned_integer (acv, acv.a_ap_tree^[put_node].n_sa_level, last_node);
                END;
            (*ENDCASE*) 
            END;
        (*ENDIF*) 
        END;
    cak_i_show :
        BEGIN
        acv.a_is_ddl := no_ddl;
        a01_next_symbol (acv);
        a01_call_put (acv, a262, cak_i_show, put_node);
        a02_put_identifier (acv, acv.a_ap_tree^[put_node].n_sa_level, last_node);
        IF  acv.a_scv.sc_symb <> s_eof
        THEN
            BEGIN
            a01_force_symbol (acv, s_point, put_node, last_node);
            a02_put_identifier (acv, acv.a_ap_tree^[last_node].n_sa_level, last_node);
            END;
        (*ENDIF*) 
        END;
    cak_i_session :
        BEGIN
        a01_next_symbol (acv);
        a01_call_put (acv, a262, cak_i_session, put_node);
        a03_aunsigned_integer (acv, acv.a_ap_tree^[put_node].n_sa_level, last_node);
        a03_aunsigned_integer (acv, acv.a_ap_tree^[last_node].n_sa_level, last_node);
        END;
    cak_i_wait :
        BEGIN
        acv.a_is_ddl := no_ddl;
        a01_next_symbol (acv);
        a01_call_put (acv, a262, cak_i_wait, put_node);
        END;
    OTHERWISE
        a07_error (acv, e_wanted_keyword, put_node, put_node);
    END;
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262DeleteTriggerParsinfo (
            VAR acv         : tak_all_command_glob;
            VAR BaseRec     : tak_baserecord);
 
VAR
      dummyError : tgg00_BasisError;
      Syskey     : tgg00_SysInfoKey;
 
BEGIN
Syskey           := a01defaultkey;
Syskey.stableid  := BaseRec.bsurrogate;
Syskey.sentrytyp := cak_etriggerparsinfo;
IF  del_trigger in BaseRec.blinkexist
THEN
    BEGIN
    Syskey.slinkage := cak_del_trigger_linkage;
    a10del_sysinfo (acv, Syskey, dummyError);
    END;
(*ENDIF*) 
IF  ins_trigger in BaseRec.blinkexist
THEN
    BEGIN
    Syskey.slinkage := cak_ins_trigger_linkage;
    a10del_sysinfo (acv, Syskey, dummyError);
    END;
(*ENDIF*) 
IF  upd_trigger in BaseRec.blinkexist
THEN
    BEGIN
    Syskey.slinkage := cak_upd_trigger_linkage;
    a10del_sysinfo (acv, Syskey, dummyError);
    END;
(*ENDIF*) 
IF  internal_trigger in BaseRec.blinkexist
THEN
    BEGIN
    Syskey.slinkage    := cak_del_trigger_linkage;
    Syskey.slinkage[2] := chr(ord(Syskey.slinkage[2]) + cak262_internalTriggerOffset);
    a10del_sysinfo (acv, Syskey, dummyError);
    Syskey.slinkage    := cak_ins_trigger_linkage;
    Syskey.slinkage[2] := chr(ord(Syskey.slinkage[2]) + cak262_internalTriggerOffset);
    a10del_sysinfo (acv, Syskey, dummyError);
    Syskey.slinkage    := cak_upd_trigger_linkage;
    Syskey.slinkage[2] := chr(ord(Syskey.slinkage[2]) + cak262_internalTriggerOffset);
    a10del_sysinfo (acv, Syskey, dummyError);
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262createVarTable (
            VAR acv          : tak_all_command_glob;
            VAR compile_glob : tak262compile_glob;
            param_tree_index : integer;
            VAR tree_index   : integer);
 
VAR
      varNode       : tsp00_Int2;
      stackSize     : integer;
      a11v          : tak_a11_glob;
 
BEGIN
&ifdef trace
t01int4 (ak_sem, 'param_index ', param_tree_index);
t01int4 (ak_sem, 'tree_index  ', tree_index);
&endif
a11glob_init (acv, a11v);
a11v.a1authname   := a01_i_temp;
a11v.a1authid     := cak_temp_user_id;
a11v.a1tablen     := a01_i_temp;
a11v.a1coln       := a01_i_rc;
a11v.a1temp_table := true;
acv.a_pars_curr.fileHandling_gg00 := acv.a_pars_curr.fileHandling_gg00 - [ hsNoLog_egg00 ];
a11init_baserecord (acv, a11v);
IF  acv.a_returncode = 0
THEN
    BEGIN
    compile_glob.cp_varTabId := acv.a_p_arr1.pbasep^.sbase.bsurrogate;
    ak262SystemVariable   (acv, a01_i_rc,     dfixed, cak262_rc_digits);
    ak262SystemVariable   (acv, a01_i_errmsg, dcha,   cak262_max_errormsg);
    ak262SystemVariable   (acv, a01_i_count,  dfixed, cak262_count_digits);
    IF  compile_glob.cp_isCursorDBProc
    THEN
        BEGIN
        ak262SystemVariable   (acv, a01_i_cursor, dcha, sizeof(tsp00_KnlIdentifier) DIV a01char_size);
        compile_glob.cp_out_params :=
              compile_glob.cp_out_params + [acv.a_p_arr1.pbasep^.sbase.bmaxcol];
        compile_glob.cp_cursor_pos := acv.a_p_arr1.pbasep^.sbase.bcolumn[
              acv.a_p_arr1.pbasep^.sbase.blastindex]^.ccolstack.epos;
        END;
    (*ENDIF*) 
    stackSize := acv.a_p_arr1.pbasep^.sbase.blenfixedcol;
    ak262DBProcParameters (acv, compile_glob, a11v, param_tree_index);
    IF  compile_glob.cp_procType = dbo_dbfunc
    THEN (* parameters are not transferred as variables ==> don't reserve space *)
        acv.a_p_arr1.pbasep^.sbase.blenfixedcol := stackSize;
    (*ENDIF*) 
    IF  tree_index <> 0
    THEN (* local variables *)
        IF  acv.a_ap_tree^[tree_index].n_subproc = cak_i_char
        THEN
            BEGIN
            varNode    := acv.a_ap_tree^[tree_index].n_sa_level;
            varNode    := acv.a_ap_tree^[varNode].n_lo_level;
            ak262LocalVariables (acv, compile_glob, a11v, varNode);
            tree_index := acv.a_ap_tree^[tree_index].n_lo_level;
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    a11v.a1sort      := true;
    a11v.a1createtab := true;
    acv.a_p_arr1.pbasep^.sbase.btablekind := tdb2view; (* avoid file creation, PTS 1109670 *)
    a11end_create_table (acv, a11v);
    acv.a_p_arr1.pbasep^.sbase.btablekind := twithoutkey
    END;
(*ENDIF*) 
acv.a_pars_curr.fileHandling_gg00 := acv.a_pars_curr.fileHandling_gg00 + [ hsNoLog_egg00 ];
ak262MapErrorCode(acv);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262DescribeDBProcParameters (
            VAR acv          : tak_all_command_glob;
            VAR compile_glob : tak262compile_glob;
            VAR MethodRec    : tak_methodrecord;
            ParamIndex       : tsp00_Int4);
 
VAR
      ix        : integer;
      pCol      : tak00_colinfo_ptr;
      ParamName : tsp00_KnlIdentifier;
 
BEGIN
WHILE (ParamIndex <> 0) AND
      (acv.a_returncode = 0) DO
    BEGIN
    a05identifier_get (acv, acv.a_ap_tree^[ParamIndex].n_sa_level,
          sizeof (ParamName), ParamName);
    IF  a061exist_columnname (acv.a_p_arr1.pbasep^.sbase,
        ParamName, pCol)
    THEN
        BEGIN
        MethodRec.me_param_cnt := MethodRec.me_param_cnt + 1;
        a10new (acv,
              sizeof (tak_param_info) - sizeof (tsp00_C256) + ord(pCol^.ccolumnn_len),
              MethodRec.me_param_list[MethodRec.me_param_cnt]);
        IF  MethodRec.me_param_list[MethodRec.me_param_cnt]  = NIL
        THEN
            a07_b_put_error (acv, e_no_more_memory, 1)
        ELSE
            WITH MethodRec.me_param_list[MethodRec.me_param_cnt]^ DO
                BEGIN
                SAPDB_PascalForcedFill (sizeof (tak_param_info) - sizeof (tsp00_C256),
                      @MethodRec.me_param_list[MethodRec.me_param_cnt]^, 1,
                      sizeof (tak_param_info) - sizeof (tsp00_C256), chr(0));
                IF  (pCol^.cdatatyp = dfixed) AND pCol^.cbinary (* PTS 1136815 *)
                THEN
                    IF  pCol^.cdatalen = 5
                    THEN
                        param_datatype := dsmallint
                    ELSE
                        param_datatype := dinteger
                    (*ENDIF*) 
                ELSE
                    param_datatype := pCol^.cdatatyp;
                (*ENDIF*) 
                param_datafrac     := pCol^.cdatafrac;
                IF  ctaltered in pCol^.ccolpropset (* DBFUNC *)
                THEN
                    BEGIN
                    param_datalength  := 0;
                    param_inoutlength := 0;
                    IF  acv.a_ap_tree^[ParamIndex].n_subproc = cak_i_out
                    THEN
                        compile_glob.cp_unknownOutLen := true;
                    (*ENDIF*) 
                    END
                ELSE
                    CASE param_datatype OF
                        ddate :
                            BEGIN
                            param_datalength  := EXT_DATE_MXSP00;
                            param_inoutlength := 1 + EXT_DATE_MXSP00
                            END;
                        dtime :
                            BEGIN
                            param_datalength  := EXT_TIME_MXSP00;
                            param_inoutlength := 1 + EXT_TIME_MXSP00
                            END;
                        dtimestamp :
                            BEGIN
                            param_datalength  := EXT_TIMESTAMP_MXSP00;
                            param_inoutlength := 1 + EXT_TIMESTAMP_MXSP00
                            END;
                        OTHERWISE
                            BEGIN
                            param_datalength   := pCol^.cdatalen;
                            param_inoutlength  := pCol^.cinoutlen;
                            END;
                        END;
                    (*ENDCASE*) 
                (*ENDIF*) 
                param_in_out[1]    := csp_info_optional;
                CASE acv.a_ap_tree^[ParamIndex].n_subproc OF
                    cak_i_in :
                        param_in_out[2] := chr(sp1io_input);
                    cak_i_out :
                        BEGIN
                        param_in_out[2] := chr(sp1io_output);
                        IF  compile_glob.cp_procType = dbo_dbfunc
                        THEN
                            BEGIN
                            pCol^.ccolpropset := pCol^.ccolpropset + [ctinvisible];
                            compile_glob.cp_returnCol := pCol;
                            END;
                        (*ENDIF*) 
                        END;
                    OTHERWISE
                        param_in_out[2] := chr(sp1io_inout);
                    END;
                (*ENDCASE*) 
                param_com_datatype   := 0;
                param_type_id        := cgg_zero_c2;
                param_cpp_offset     := cgg_rec_key_offset + pCol^.ccolstack.epos - 1;
                param_state          := param_undef;
                param_ascii_offset   := 0;
                param_unicode_offset := 0;
                param_name_len     := pCol^.ccolumnn_len;
                FOR ix := 1 TO ord(param_name_len) DO
                    param_name[ix] := pCol^.ccolumnn[ix];
                (*ENDFOR*) 
                END
            (*ENDWITH*) 
        (*ENDIF*) 
        END
    ELSE
        a07ak_system_error (acv, 262, 1);
    (*ENDIF*) 
    ParamIndex := acv.a_ap_tree^[ParamIndex].n_lo_level
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262drop_tab_col_trigger (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par;
            VAR new_stack   : tgg00_StackEntry);
 
VAR
      replace      : boolean;
      drop_trigger : boolean;
      b_err        : tgg00_BasisError;
      aux_set      : tgg00_Linkset;
      curr_set     : tgg00_Linkset;
      i, j         : integer;
      st_i         : integer;
      pTrigger     : tak_sysbufferaddress;
      trigger_key  : tgg00_SysInfoKey;
      nextKey      : tgg00_SysInfoKey;
      a11v         : tak_a11_glob;
 
BEGIN
WITH acv DO
    BEGIN
    a11glob_init (acv, a11v);
    trigger_key := a_p_arr1.pbasep^.syskey;
    trigger_key.sentrytyp := cak_etrigger;
    WITH a_p_arr1.pbasep^.sbase DO
        BEGIN
        aux_set := blinkexist * [del_trigger, ins_trigger, upd_trigger];
        END;
    (*ENDWITH*) 
    REPEAT
        replace := false;
        IF  del_trigger in aux_set
        THEN
            BEGIN
            trigger_key.slinkage := cak_del_trigger_linkage;
            curr_set := [ del_trigger ]
            END
        ELSE
            IF  ins_trigger in aux_set
            THEN
                BEGIN
                trigger_key.slinkage := cak_ins_trigger_linkage;
                curr_set := [ ins_trigger ]
                END
            ELSE
                IF  upd_trigger in aux_set
                THEN
                    BEGIN
                    trigger_key.slinkage := cak_upd_trigger_linkage;
                    curr_set := [ upd_trigger ]
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        aux_set := aux_set - curr_set;
        a10get_sysinfo (acv, trigger_key, d_fix,
              a_p_arr2.px[1], b_err);
        IF  b_err = e_ok
        THEN
            BEGIN
            a_p_arr2.pcount := 1;
            drop_trigger    := false;
            nextKey         := trigger_key;
            pTrigger        := a_p_arr2.px[1];
            IF  (a_init_ddl = ddl_drop_table) OR
                (a_init_ddl = ddl_drop_user )
            THEN (* call from drop table *)
                drop_trigger := true
            ELSE
                WITH a_p_arr2.px[1]^.strigger,
                     viewscanpar, vsc_dr_col DO
                    BEGIN
                    st_i := (tr_name_len - 1) DIV sizeof (tr_stack[1]) + 2;
                    i    := 1;
                    WHILE (i <= tr_param_cnt + tr_condition_cnt) AND (b_err = e_ok) DO
                        BEGIN
                        IF  st_i > cak_max_trigger_stack
                        THEN
                            BEGIN
                            IF  replace AND (nextKey.slinkage > cak_init_linkage)
                            THEN
                                a10repl_sysinfo (acv, pTrigger, b_err);
                            (*ENDIF*) 
                            IF  b_err = e_ok
                            THEN
                                BEGIN
                                a06inc_linkage(nextKey.slinkage);
                                a10get_sysinfo (acv, trigger_key, d_release,
                                      pTrigger, b_err);
                                st_i := 1
                                END
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  b_err = e_ok
                        THEN
                            WITH pTrigger^.strigger.tr_stack[st_i] DO
                                BEGIN
                                j := 1;
                                WHILE j <= dcount DO
                                    WITH dcol[j].dcolptr^ DO
                                        BEGIN
&                                       ifdef trace
                                        t01stackentry (ak_sem,
                                              ccolstack, j);
                                        t01stackentry (ak_sem,
                                              tr_stack[st_i], st_i);
&                                       endif
                                        IF  (etype    = ccolstack.etype) AND
                                            (epos     = ccolstack.epos ) AND
                                            (elen_var = ccolstack.elen_var)
                                        THEN
                                            BEGIN
                                            (* column affected by alter   *)
                                            (* table is parameter or      *)
                                            (* whenever column of trigger *)
                                            IF  (a_is_ddl =
                                                ddl_alter_tab_alter)
                                                AND (i > tr_param_cnt)
                                            THEN
                                                BEGIN (* change stack entry*)
                                                j       := j + 1;
                                                replace := true;
&                                               ifdef trace
                                                t01stackentry (ak_sem,
                                                      tr_stack[ st_i ], st_i);
                                                t01stackentry (ak_sem,
                                                      new_stack, i);
&                                               endif
                                                tr_stack[st_i] := new_stack
                                                END
                                            ELSE
                                                BEGIN
                                                (* exit loop, drop trigger *)
                                                drop_trigger := true;
                                                j            := csp_maxint2
                                                END
                                            (*ENDIF*) 
                                            END
                                        ELSE
                                            j := j + 1;
                                        (*ENDIF*) 
                                        st_i := st_i + 1;
                                        i    := i + 1
                                        END;
                                    (*ENDWITH*) 
                                (*ENDWHILE*) 
                                END;
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        END;
                    (*ENDWHILE*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            IF  drop_trigger
            THEN
                BEGIN
                ak262drop_one_trigger (acv, a_p_arr2.px[1]);
                IF  a_returncode = 0
                THEN
                    WITH a_p_arr1.pbasep^.sbase DO
                        blinkexist := blinkexist - curr_set;
                    (*ENDWITH*) 
                (*ENDIF*) 
                END
            ELSE
                IF  replace
                THEN
                    BEGIN
                    a10repl_sysinfo (acv, a_p_arr2.px[1], b_err)
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            a10_rel_sysinfo (acv, trigger_key)
            END;
        (*ENDIF*) 
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
    UNTIL
        (aux_set = [  ]) OR (a_returncode <> 0);
    (*ENDREPEAT*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262DropInternalTriggers (
            VAR acv  : tak_all_command_glob);
 
VAR
      b_err        : tgg00_BasisError;
      ix           : integer;
      pTrigger     : tak_sysbufferaddress;
      trigger_key  : tgg00_SysInfoKey;
 
BEGIN
IF  internal_trigger in acv.a_p_arr1.pbasep^.sbase.blinkexist
THEN
    BEGIN
    trigger_key           := acv.a_p_arr1.pbasep^.syskey;
    trigger_key.sentrytyp := cak_etrigger;
    FOR ix := 1 TO 3 DO
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            CASE ix OF
                1 :
                    trigger_key.slinkage := cak_del_trigger_linkage;
                2 :
                    trigger_key.slinkage := cak_ins_trigger_linkage;
                3 :
                    trigger_key.slinkage := cak_upd_trigger_linkage;
                END;
            (*ENDCASE*) 
            trigger_key.slinkage[2] := chr(ord(trigger_key.slinkage[2]) + cak262_internalTriggerOffset);
            a10get_sysinfo (acv, trigger_key, d_fix, pTrigger, b_err);
            IF  b_err = e_ok
            THEN
                ak262drop_one_trigger (acv, pTrigger);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDFOR*) 
    acv.a_p_arr1.pbasep^.sbase.blinkexist :=
          acv.a_p_arr1.pbasep^.sbase.blinkexist - [internal_trigger];
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262DropParseIds (
            VAR acv    : tak_all_command_glob;
            VAR mblock : tgg00_MessBlock);
 
VAR
      retCode  : integer;
      jx       : tsp00_Int4;
      DataSize : tsp00_Int4;
      DataLen  : tsp00_Int4;
      parskey  : tak_parsid;
      pData    : tgg00_DataPartPtr;
      Rec      : tgg00_Rec;
 
BEGIN
(* PTS 1109670 *)
(* avoid overwriting of mb_data by a663_drop_parsid *)
DataSize := acv.a_mblock.mb_data_size;
DataLen  := acv.a_mblock.mb_data_len;
pData    := acv.a_mblock.mb_data;
acv.a_mblock.mb_data      := @Rec;
acv.a_mblock.mb_data_size := sizeof(Rec);
acv.a_mblock.mb_data_len  := 0;
;
retCode := acv.a_returncode;
&ifdef trace
t01messblock (ak_sem, 'mblock      ', mblock );
&endif
jx := mblock.mb_qual^.mqual_pos;
WHILE jx <= mblock.mb_qual^.mqual_pos +
      mblock.mb_qual^.mqual_cnt - 1 DO
    BEGIN
    IF  (mblock.mb_st^[jx].etype = st_parseid)
        AND
        (mblock.mb_st^[jx].ecol_tab[2] = chr(1)) (* PTS 1109247 *)
    THEN
        BEGIN
        acv.a_returncode := 0;
        SAPDB_PascalForcedMove (2 * sizeof (mblock.mb_st^[jx]), sizeof (parskey),
              @mblock.mb_st^[jx+1], 1, @parskey, 1, sizeof (parskey));
        IF  (parskey.pid_appl_info[1] = chr(csp1_p_dialog_call)) AND
            (parskey.pid_parsk.p_kind = m_delete)
        THEN (* drop parseid of sql statements of internal stored procedure *)
            a260DropParseIds (acv, parskey.pid_parsk);
        (*ENDIF*) 
        acv.a_returncode := 0;
        a260ParseIdDrop (acv, parskey); (* PTS 1110980 *)
        acv.a_returncode := 0;
        jx := jx + 2;
        END;
    (*ENDIF*) 
    jx := jx + 1;
    END;
(*ENDWHILE*) 
;
(* restore mb_data *)
acv.a_mblock.mb_data      := pData;
acv.a_mblock.mb_data_size := DataSize;
acv.a_mblock.mb_data_len  := DataLen;
IF  retCode <> 0
THEN
    acv.a_returncode := retCode;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262DynamicSQL (
            acv_addr     : tak_acv_address;
            VAR sel      : tgg00_SelectFieldsParam;
            pStmt        : tsp00_MoveObjPtr;
            stmtLength   : integer;
            retcode_addr : tsp00_MoveObjPtr;
            VAR e        : tgg00_BasisError);
 
VAR
      dynSQL          : boolean;
      res             : tsp00_NumError;
      dtFormat        : tgg00_DateTimeFormat;
      buf_size        : tsp00_Int4;
      part_ptr        : tsp1_part_ptr;
      packet_ptr      : tsp1_packet_ptr;
      segm_ptr        : tsp1_segment_ptr;
      acv_data_p      : tsp00_MoveObjPtr;
 
BEGIN
dtFormat   := acv_addr^.a_dt_format;
acv_data_p := acv_addr^.a_data_ptr;
a34AllocPacket (acv_addr^, packet_ptr, buf_size);
IF  acv_addr^.a_returncode = 0
THEN
    BEGIN
    acv_addr^.a_dt_format := sel.sfp_dateTimeFormat;
    packet_ptr^.sp1_header.sp1h_varpart_size :=
          buf_size - sizeof (packet_ptr^.sp1_header);
    s26init_cmd_packet (packet_ptr, segm_ptr);
    IF  g01unicode
    THEN
        packet_ptr^.sp1_header.sp1h_mess_code := csp_unicode;
    (*ENDIF*) 
    sp100_GetSenderIDVersionP (packet_ptr^.sp1_header.sp1h_appl_version);
    CASE sel.sfp_sqlmode OF
        sqlm_internal :
            segm_ptr^.sp1s_segm_header.sp1c_sqlmode := sp1sm_internal;
        sqlm_ansi :
            segm_ptr^.sp1s_segm_header.sp1c_sqlmode := sp1sm_ansi;
        sqlm_db2 :
            segm_ptr^.sp1s_segm_header.sp1c_sqlmode := sp1sm_db2;
        sqlm_oracle :
            segm_ptr^.sp1s_segm_header.sp1c_sqlmode := sp1sm_oracle;
        END;
    (*ENDCASE*) 
    segm_ptr^.sp1s_segm_header.sp1c_parsing_again   := false;
    segm_ptr^.sp1s_segm_header.sp1c_mess_type       := sp1m_dbs;
    IF  acv_addr^.a_initial_segment_header.sp1c_producer = sp1pr_installation
    THEN
        segm_ptr^.sp1s_segm_header.sp1c_producer := sp1pr_installation
    ELSE
        segm_ptr^.sp1s_segm_header.sp1c_producer := sp1pr_user_cmd;
    (*ENDIF*) 
    segm_ptr^.sp1s_segm_header.sp1c_command_options :=
          segm_ptr^.sp1s_segm_header.sp1c_command_options + [sp1co_scrollable_cursor_on];
    segm_ptr^.sp1p_buf_size                       :=
          buf_size - sizeof (tsp1_segment_header);
    s26new_part_init (packet_ptr, segm_ptr^, part_ptr);
    part_ptr^.sp1p_part_kind := sp1pk_command;
    SAPDB_PascalMove ('VAK262',   2,    
          stmtLength, part_ptr^.sp1p_buf_size,
          @pStmt^, 2, @part_ptr^.sp1p_buf, 1,
          stmtLength - 1, acv_addr^.a_returncode);
    part_ptr^.sp1p_buf_len := stmtLength - 1;
    s26finish_part   (packet_ptr, part_ptr^);
    END;
(*ENDIF*) 
IF  acv_addr^.a_returncode = 0
THEN
    BEGIN
    dynSQL                  := acv_addr^.a_dynamic_sql;
    acv_addr^.a_dynamic_sql := true;
    ak262SqlRequest (acv_addr, packet_ptr);
    acv_addr^.a_dynamic_sql := dynSQL;
    (* put SQL return code into variable $rc *)
    s41plint (retcode_addr^, cgg_rec_key_offset + 2, cak262_rc_digits, 0,
          packet_ptr^.sp1_segm.sp1r_returncode, res);
    ak262GetErrorMsg (acv_addr^, packet_ptr, retcode_addr);
    ak262GetCount    (acv_addr^, packet_ptr, retcode_addr);
    END;
(*ENDIF*) 
acv_addr^.a_dt_format := dtFormat;
acv_addr^.a_data_ptr  := acv_data_p;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262execute (
            acv_addr        : tak_acv_address;
            VAR sel         : tgg00_SelectFieldsParam;
            retcode_addr    : tsp00_MoveObjPtr;
            VAR StackList   : tgg00_StackList;
            VAR qual_ptr    : tsp00_Int4;
            VAR e           : tgg00_BasisError);
 
VAR
      qualPtr    : integer;
      data_p     : tsp00_MoveObjPtr;
      parsid     : tak_parsid;
 
BEGIN
qualPtr := qual_ptr;
ak262execute (acv_addr, sel, @retcode_addr^, StackList, qual_ptr, e);
IF  e = csp_old_fileversion
THEN
    BEGIN
    qual_ptr               := qualPtr;
    e                      := e_ok;
    acv_addr^.a_returncode := 0;
    data_p := acv_addr^.a_data_ptr;
    SAPDB_PascalForcedMove (2 * sizeof (StackList[1]), sizeof (parsid),
          @StackList[qual_ptr+1], 1, @parsid, 1, mxak_parsid);
    a260ParseIdDrop (acv_addr^, parsid);  (* PTS 1110980 *)
    acv_addr^.a_returncode := 0; (* ignore errors *)
    StackList[qual_ptr].ecol_tab[2] := chr(0); (* force reparsing *)
    ak262execute (acv_addr, sel, @retcode_addr^, StackList, qual_ptr, e);
    IF  e = csp_old_fileversion
    THEN
        e := e_ok; (* error is stored in $rc *)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262BuildLongDescriptor (
            VAR LongDescriptor : tak262LongDescriptor;
            pData              : tsp00_MoveObjPtr;
            pCopyTabid         : tak262_SurrogatePtr
            );
 
VAR
      SourceLongDescriptor : tak_long_descriptor;
 
BEGIN
&ifdef trace
t01moveobj (ak_sem, pData^, 1, 1 + sizeof(LongDescriptor.ld));
&endif
LongDescriptor.defByte := pData^[1];
IF  pData^[1] = csp_undef_byte
THEN
    SAPDB_PascalForcedFill (sizeof(LongDescriptor.ld), @LongDescriptor.ld, 1,
          sizeof(LongDescriptor.ld), chr(0))
ELSE
    BEGIN
    SAPDB_PascalForcedMove (sizeof(SourceLongDescriptor), sizeof(SourceLongDescriptor),
          @pData^[2], 1, @SourceLongDescriptor, 1, sizeof(SourceLongDescriptor));
    IF  ld_stream in SourceLongDescriptor.lds_state
    THEN
        LongDescriptor.ld := SourceLongDescriptor
    ELSE
        BEGIN
        LongDescriptor.ld.lds_descriptor := cgg_zero_id;
        LongDescriptor.ld.lds_tabid      := cgg_zero_id;
        LongDescriptor.ld.lds_infoset    := SourceLongDescriptor.lds_infoset;
        LongDescriptor.ld.lds_state      := SourceLongDescriptor.lds_state + [ld_copy];
        LongDescriptor.ld.lds_copyLongId := SourceLongDescriptor.lds_descriptor;
        LongDescriptor.ld.lds_copyTabid  := pCopyTabid^;
        END;
    (*ENDIF*) 
    LongDescriptor.ld.lds_valmode := vm_alldata;
    END;
(*ENDIF*) 
&ifdef trace
t01longdescriptor (ak_sem, LongDescriptor.ld.desc);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262execute (
            acv_addr        : tak_acv_address;
            VAR sel         : tgg00_SelectFieldsParam;
            retcode_addr    : tsp00_MoveObjPtr;
            VAR StackList   : tgg00_StackList;
            VAR qual_ptr    : tsp00_Int4;
            VAR e           : tgg00_BasisError);
 
VAR
      isVariable      : boolean;
      SetNull         : boolean;
      dummy           : tsp1_comm_error;
      def_byte        : char;
      fill_char       : char;
      charMapDt       : tak262CharMapDatatype;
      dtFormat        : tgg00_DateTimeFormat;
      res             : tsp00_NumError;
      ix              : integer;
      jx              : integer;
      pos             : integer;
      buf_size        : tsp00_Int4;
      srcPos          : tsp00_Int4;
      srcLen          : tsp00_Int4;
      dstPos          : tsp00_Int4;
      dstLen          : tsp00_Int4;
      dataSize        : tsp00_Int4;
      moveLen         : integer;
      paramCnt        : integer;
      outParams       : integer;
      longOutPutCnt   : integer;
      p               : tak_sysbufferaddress;
      mblock_p        : tgg00_MessBlockPtr;
      part_ptr        : tsp1_part_ptr;
      packet_ptr      : tsp1_packet_ptr;
      segm_ptr        : tsp1_segment_ptr;
      data_p          : tsp00_MoveObjPtr;
      acv_data_p      : tsp00_MoveObjPtr;
      dateTimeBuffer  : tsp00_C64;
      pParam          : tgg00_StEntryAddr;
      longDescriptor  : tak262LongDescriptor;
&     ifdef trace
      out_packet_ptr  : tsp1_packet_ptr;
&     endif
 
LABEL
      999;
 
BEGIN
paramCnt := StackList[qual_ptr].epos; (* PTS 1122976 *)
&ifdef trace
t01stackentry (sproc_call, StackList[qual_ptr], qual_ptr);
FOR ix := 1 TO paramCnt DO
    t01stackentry (sproc_call, StackList[qual_ptr+ix+2], qual_ptr+ix+2);
(*ENDFOR*) 
&endif
e                     := e_ok;
longOutPutCnt         := 0;
acv_data_p            := acv_addr^.a_data_ptr; (* PTS 1110685 *)
dtFormat              := acv_addr^.a_dt_format;
acv_addr^.a_dt_format := sel.sfp_dateTimeFormat;
IF  StackList[qual_ptr].ecol_tab[2] = chr(0) (* PTS 1109247 *)
THEN
    BEGIN
    p        := @sel.sfp_pl_ptr^;
    mblock_p := @p^.smessblock.mbr_mess_block;
    ak262parse_stmt (acv_addr^, @sel,
          mblock_p^.mb_qual^.mtree.fileTabId_gg00,
          mblock_p^, NOT cak262is_create_trigger, qual_ptr, retcode_addr);
    StackList[qual_ptr].ecol_tab[2] := chr(1);
    acv_addr^.a_data_ptr            := acv_data_p; (* PTS 1110685 *)
    IF  acv_addr^.a_returncode = 0
    THEN
        BEGIN
        IF  p^.syskey.sentrytyp > cak_etemp
        THEN
            a10repl_sysinfo (acv_addr^, p, e);
        (* replacing temporary record cannot produce an error ! *)
        (*ENDIF*) 
        END
    ELSE
        goto 999;
    (*ENDIF*) 
    END;
&ifdef trace
(*ENDIF*) 
t01stackentry (sproc_call, StackList[qual_ptr], qual_ptr);
out_packet_ptr := acv_addr^.a_out_packet;
&endif
a34AllocPacket (acv_addr^, packet_ptr, buf_size);
IF  acv_addr^.a_returncode = 0
THEN
    BEGIN
    packet_ptr^.sp1_header.sp1h_varpart_size :=
          buf_size - sizeof (packet_ptr^.sp1_header);
    s26init_cmd_packet (packet_ptr, segm_ptr);
    IF  g01unicode
    THEN
        packet_ptr^.sp1_header.sp1h_mess_code := csp_unicode;
    (*ENDIF*) 
    sp100_GetSenderIDVersionP (packet_ptr^.sp1_header.sp1h_appl_version);
    segm_ptr^.sp1s_segm_header.sp1c_sqlmode       := sp1sm_session_sqlmode;
    segm_ptr^.sp1s_segm_header.sp1c_parsing_again := false;
    segm_ptr^.sp1s_segm_header.sp1c_mess_type     := sp1m_execute;
    IF  acv_addr^.a_initial_segment_header.sp1c_producer = sp1pr_installation
    THEN
        segm_ptr^.sp1s_segm_header.sp1c_producer := sp1pr_installation
    ELSE
        segm_ptr^.sp1s_segm_header.sp1c_producer := sp1pr_user_cmd;
    (*ENDIF*) 
    segm_ptr^.sp1s_segm_header.sp1c_command_options :=
          segm_ptr^.sp1s_segm_header.sp1c_command_options + [sp1co_scrollable_cursor_on];
    segm_ptr^.sp1p_buf_size                       :=
          buf_size - sizeof (tsp1_segment_header);
    s26new_part_init (packet_ptr, segm_ptr^, part_ptr);
    part_ptr^.sp1p_part_kind := sp1pk_parsid;
    SAPDB_PascalMove ('VAK262',   3,    
          2 * sizeof (StackList[1]), part_ptr^.sp1p_buf_size,
          @StackList[qual_ptr+1], 1, @part_ptr^.sp1p_buf, 1,
          sizeof (tak_parsid),
          acv_addr^.a_returncode);
    part_ptr^.sp1p_buf_len := sizeof (tak_parsid);
    s26finish_part   (packet_ptr, part_ptr^);
    s26new_part_init (packet_ptr, segm_ptr^, part_ptr);
    IF  part_ptr <> NIL
    THEN
        BEGIN
        part_ptr^.sp1p_part_kind := sp1pk_data;
        part_ptr^.sp1p_buf_len   := 0;
        (* put parameter values into data part *)
        outParams := 0;
        FOR ix := 1 TO paramCnt DO
            BEGIN
&           ifdef trace
            t01stackentry (sproc_call, StackList[qual_ptr+ix+2], qual_ptr+ix+2);
&           endif
            IF  StackList[qual_ptr+ix+2].etype = st_output
            THEN
                BEGIN
                outParams := outParams + 1;
                charMapDt.c[1] := StackList[StackList[qual_ptr+ix+2].eindex].ecol_tab[1];
                IF  charMapDt.dt in [dstra, dstrb, dstruni, dlonga, dlongb, dstruni]
                THEN
                    longOutPutCnt := longOutPutCnt + 1;
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  StackList[qual_ptr+ix+2].etype = st_output_join (* inout parameter *)
                THEN
                    outParams := outParams + 1;
                (*ENDIF*) 
                srcLen     := StackList[StackList[qual_ptr+ix+2].eindex].elen_var;
                isVariable := StackList[StackList[qual_ptr+ix+2].eindex].eop <> op_none;
                charMapDt.c[1] := StackList[StackList[qual_ptr+ix+2].eindex].ecol_tab[1];
                IF  isVariable
                THEN
                    BEGIN
                    IF  StackList[StackList[qual_ptr+ix+2].eindex].eop = op_fixed
                    THEN
                        BEGIN (* dbfunction parameter *)
                        pParam := s35inc_st_ptocm (sel.sfp_work_st_frame,
                              StackList[StackList[qual_ptr+ix+2].eindex].epos);
&                       ifdef trace
                        t01int4       (sproc_call, 'function par', pParam^.epos);
                        t01stackentry (sproc_call, pParam^, 0);
&                       endif
                        srcPos := 1;
                        srcLen := pParam^.elen_var;
                        data_p :=
                              s35add_moveobj_ptr_ptocm (sel.sfp_param_buf_addr, pParam^.epos - 1);
                        dataSize := srcLen;
                        END
                    ELSE
                        BEGIN
                        srcPos := cgg_rec_key_offset +
                              StackList[StackList[qual_ptr+ix+2].eindex].epos;
                        data_p   := @sel.sfp_oldrec_addr^;
                        IF  (charMapDt.dt in [dstra, dstrb, dstruni, dlonga, dlongb, dlonguni])
                        THEN
                            BEGIN
                            ak262BuildLongDescriptor (longDescriptor, @data_p^[srcPos],
                                  @data_p^[srcPos+sizeof(tgg00_Surrogate)+1]);
                            IF  (acv_addr^.a_client_out_packet^.sp1_header.sp1h_mess_code in
                                [csp_unicode, csp_unicode_swap])
                                AND
                                NOT acv_addr^.a_ascii_in_and_output
                            THEN
                                longDescriptor.ld.lds_state := longDescriptor.ld.lds_state + [ld_use_toascii];
                            (*ENDIF*) 
                            data_p   := @longDescriptor.defByte;
                            srcPos   := 1;
                            srcLen   := 1 + sizeof(longDescriptor.ld);
                            dataSize := srcLen;
                            END
                        ELSE
                            dataSize := sel.sfp_oldrec_len
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    srcPos := StackList[StackList[qual_ptr+ix+2].eindex].epos +
                          cgg_rec_key_offset +  TriggerKeyLen_cgg04;
                    data_p   := acv_data_p; (* PTS 1110685 *)
                    dataSize := sizeof(tak262TriggerParamBuffer);
                    IF  (charMapDt.dt in [dstra, dstrb, dstruni])
                    THEN
                        BEGIN
                        longDescriptor.defByte := data_p^[srcPos];
                        IF  longDescriptor.defByte = csp_undef_byte
                        THEN
                            SAPDB_PascalForcedFill (sizeof(longDescriptor.ld), @longDescriptor.ld, 1,
                                  sizeof(longDescriptor.ld), chr(0))
                        ELSE
                            BEGIN
                            longDescriptor.ld.lds_descriptor := cgg_zero_id;
                            longDescriptor.ld.lds_tabid      := cgg_zero_id;
                            longDescriptor.ld.lds_infoset    := [];
                            longDescriptor.ld.lds_state      := [ld_copy];
                            longDescriptor.ld.lds_valmode    := vm_alldata;
&                           ifdef trace
                            t01moveobj (ak_sem, data_p^, srcPos, srcPos + 8);
&                           endif
                            SAPDB_PascalMove ('VAK262',   4,    
                                  dataSize, sizeof(longDescriptor.ld.lds_copyLongId),
                                  @data_p^, srcPos + 1,
                                  @longDescriptor.ld.lds_copyLongId, 1,
                                  sizeof(longDescriptor.ld.lds_copyLongId),
                                  e);
                            SAPDB_PascalMove ('VAK262',   5,    
                                  dataSize, sizeof(longDescriptor.ld.lds_copyTabid),
                                  @data_p^, cgg_rec_key_offset + 5,
                                  @longDescriptor.ld.lds_copyTabid, 1,
                                  sizeof(longDescriptor.ld.lds_copyTabid),
                                  e);
                            END;
                        (*ENDIF*) 
                        data_p := @longDescriptor.defByte;
                        srcPos := 1;
                        srcLen := 1 + sizeof(longDescriptor.ld);
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                dstPos         := StackList[qual_ptr+ix+2].epos;
                dstLen         := StackList[qual_ptr+ix+2].elen_var;
&               ifdef trace
                t01int4 (sproc_call, 'isVariable  ', ord (isVariable));
                t01int4 (sproc_call, 'srcPos      ', srcPos);
                t01int4 (sproc_call, 'srcLen      ', srcLen);
                t01int4 (sproc_call, 'dstPos      ', dstPos);
                t01int4 (sproc_call, 'dstLen      ', dstLen);
                t01int4 (sproc_call, 'datatype    ', ord(charMapDt.c[1]));
&               endif
                def_byte := data_p^[srcPos];
                IF  def_byte <> csp_undef_byte
                THEN
                    BEGIN
                    IF  (g01unicode OR (acv_addr^.a_dt_format <> dtf_normal))
                    THEN
                        BEGIN
                        CASE charMapDt.dt OF
                            ddate :
                                BEGIN
                                dateTimeBuffer    := bsp_c64;
                                g03dchange_format_date (data_p^, dateTimeBuffer,
                                      srcPos + 1, 2, acv_addr^.a_dt_format, e);
                                data_p   := @dateTimeBuffer;
                                dataSize := sizeof(dateTimeBuffer);
                                srcPos   := 1;
                                IF  g01unicode
                                THEN
                                    BEGIN
                                    dateTimeBuffer[1] := csp_unicode_def_byte;
                                    srcLen            := 1 + 2 * EXT_DATE_MXSP00;
                                    pos               := srcLen;
                                    FOR jx := EXT_DATE_MXSP00 + 1 DOWNTO 2 DO
                                        BEGIN
                                        dateTimeBuffer[pos  ] := dateTimeBuffer[jx];
                                        dateTimeBuffer[pos-1] := chr(0);
                                        pos                   := pos - 2;
                                        END;
                                    (*ENDFOR*) 
                                    END
                                ELSE
                                    srcLen := 1 + EXT_DATE_MXSP00
                                (*ENDIF*) 
                                END;
                            dtime :
                                BEGIN
                                dateTimeBuffer := bsp_c64;
                                g03tchange_format_time (data_p^, dateTimeBuffer,
                                      srcPos + 1, 2, acv_addr^.a_dt_format, e);
                                data_p   := @dateTimeBuffer;
                                dataSize := sizeof(dateTimeBuffer);
                                srcPos   := 1;
                                IF  g01unicode
                                THEN
                                    BEGIN
                                    dateTimeBuffer[1] := csp_unicode_def_byte;
                                    srcLen            := 1 + 2 * EXT_TIME_MXSP00;
                                    pos               := srcLen;
                                    FOR jx := EXT_TIME_MXSP00 + 1 DOWNTO 2 DO
                                        BEGIN
                                        dateTimeBuffer[pos  ] := dateTimeBuffer[jx];
                                        dateTimeBuffer[pos-1] := chr(0);
                                        pos                   := pos - 2;
                                        END;
                                    (*ENDFOR*) 
                                    END
                                ELSE
                                    srcLen := 1 + EXT_TIME_MXSP00;
                                (*ENDIF*) 
                                END;
                            dtimestamp :
                                BEGIN
                                dateTimeBuffer := bsp_c64;
                                g03tschange_format_timestamp (data_p^, dateTimeBuffer,
                                      srcPos + 1, 2, acv_addr^.a_dt_format, acv_addr^.a_ak_language, e);
                                data_p   := @dateTimeBuffer;
                                dataSize := sizeof(dateTimeBuffer);
                                srcPos   := 1;
                                IF  g01unicode
                                THEN
                                    BEGIN
                                    dateTimeBuffer[1] := csp_unicode_def_byte;
                                    srcLen            := 1 + 2 * EXT_TIMESTAMP_MXSP00;
                                    pos               := srcLen;
                                    FOR jx := EXT_TIMESTAMP_MXSP00 + 1 DOWNTO 2 DO
                                        BEGIN
                                        dateTimeBuffer[pos  ] := dateTimeBuffer[jx];
                                        dateTimeBuffer[pos-1] := chr(0);
                                        pos                   := pos - 2;
                                        END;
                                    (*ENDFOR*) 
                                    END
                                ELSE
                                    srcLen := 1 + EXT_TIMESTAMP_MXSP00
                                (*ENDIF*) 
                                END;
                            OTHERWISE ;
                            END;
                        (*ENDCASE*) 
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    IF  g01unicode AND (charMapDt.dt in [ddate, dtime, dtimestamp])
                    THEN
                        BEGIN
                        data_p            := @dateTimeBuffer;
                        dateTimeBuffer[1] := csp_undef_byte;
                        dataSize          := sizeof(dateTimeBuffer);
                        srcPos := 1;
                        CASE charMapDt.dt OF
                            ddate :
                                srcLen := 1 + 2 * EXT_DATE_MXSP00;
                            dtime :
                                srcLen := 1 + 2 * EXT_TIME_MXSP00;
                            dtimestamp :
                                srcLen := 1 + 2 * EXT_TIMESTAMP_MXSP00
                            END;
                        (*ENDCASE*) 
                        SAPDB_PascalFill ('VAK262',   6,    
                              sizeof(dateTimeBuffer), @data_p^, 2, srcLen - 1, chr(0), e);
                        IF  e <> e_ok
                        THEN
                            goto 999;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  srcLen > dstLen
                THEN
                    BEGIN
                    IF  def_byte = csp_undef_byte
                    THEN
                        srcLen := 1
                    ELSE
                        srcLen := s30lnr_defbyte (data_p,
                              def_byte, srcPos + 1, srcLen-1) + 1;
                    (*ENDIF*) 
                    IF  srcLen > dstLen
                    THEN
                        BEGIN
                        e := e_column_trunc;
                        goto 999;
                        END
                    ELSE
                        srcLen := dstLen;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                SAPDB_PascalMove ('VAK262',   7,    
                      dataSize, part_ptr^.sp1p_buf_size,
                      @data_p^, srcPos, @part_ptr^.sp1p_buf, dstPos, srcLen, e);
                IF  e <> e_ok
                THEN
                    goto 999;
                (*ENDIF*) 
                IF  srcLen < dstLen
                THEN
                    BEGIN
                    IF  def_byte = csp_unicode_def_byte
                    THEN
                        BEGIN
                        SAPDB_PascalUnicodeFill ('VAK262',   8,    
                              part_ptr^.sp1p_buf_size, @part_ptr^.sp1p_buf,
                              dstPos + srcLen, dstLen - srcLen,
                              csp_unicode_blank, e)
                        END
                    ELSE
                        BEGIN
                        IF  def_byte = csp_undef_byte
                        THEN
                            fill_char := csp_defined_byte
                        ELSE
                            fill_char := def_byte;
                        (*ENDIF*) 
                        SAPDB_PascalFill ('VAK262',   9,    
                              part_ptr^.sp1p_buf_size, @part_ptr^.sp1p_buf,
                              dstPos + srcLen, dstLen - srcLen,
                              fill_char, e);
                        END;
                    (*ENDIF*) 
                    IF  e <> e_ok
                    THEN
                        goto 999;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  dstPos + dstLen - 1 > part_ptr^.sp1p_buf_len
                THEN
                    part_ptr^.sp1p_buf_len := dstPos + dstLen - 1;
&               ifdef trace
                (*ENDIF*) 
                t01moveobj (sproc_call, data_p^, srcPos, srcPos + srcLen - 1);
                t01moveobj (sproc_call, part_ptr^.sp1p_buf, dstPos, dstPos + dstLen - 1);
&               endif
                END
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        s26finish_part (packet_ptr, part_ptr^);
        IF  longOutPutCnt > 0
        THEN
            ak262PutLongDemandPart (acv_addr^, packet_ptr, segm_ptr, longOutPutCnt);
        (*ENDIF*) 
        ak262SqlRequest     (acv_addr, packet_ptr);
        IF  acv_addr^.a_returncode = csp_old_fileversion
        THEN
            e := csp_old_fileversion;
        (* put SQL return code into variable $rc *)
        (*ENDIF*) 
        s41plint (retcode_addr^, cgg_rec_key_offset + 2, cak262_rc_digits, 0,
              acv_addr^.a_returncode, res);
        IF  acv_addr^.a_returncode <> 0
        THEN
            BEGIN (* put SQL ErrorText into variable $errmsg*)
            ak262GetErrorMsg (acv_addr^, packet_ptr, retcode_addr);
            END
        ELSE
            BEGIN
            (* put result count into variable $count *)
            ak262GetCount (acv_addr^, packet_ptr, retcode_addr);
            IF  outParams > 0
            THEN
                BEGIN
                s26find_part (packet_ptr^.sp1_segm, sp1pk_data, part_ptr);
                IF  part_ptr <> NIL
                THEN
                    BEGIN
                    (* Handle output parameters *)
                    FOR ix := 1 TO paramCnt DO
                        IF  StackList[qual_ptr+ix+2].etype in [st_output, st_output_join]
                        THEN
                            BEGIN (* out or inout parameter *)
                            isVariable := StackList[StackList[qual_ptr+ix+2].eindex].eop <> op_none;
                            IF  isVariable
                            THEN
                                BEGIN
                                dstPos := cgg_rec_key_offset +
                                      StackList[StackList[qual_ptr+ix+2].eindex].epos;
                                data_p   := @sel.sfp_oldrec_addr^;
                                dataSize := sel.sfp_oldrec_len
                                END
                            ELSE
                                BEGIN
                                dstPos := StackList[StackList[qual_ptr+ix+2].eindex].epos +
                                      cgg_rec_key_offset +  TriggerKeyLen_cgg04;
                                data_p   := acv_data_p; (* PTS 1110685 *)
                                dataSize := sizeof(tsp00_Buf)
                                END;
                            (*ENDIF*) 
                            charMapDt.c[1] :=
                                  StackList[StackList[qual_ptr+ix+2].eindex].ecol_tab[1];
                            dstLen := StackList[StackList[qual_ptr+ix+2].eindex].elen_var;
                            srcPos := StackList[qual_ptr+ix+2].epos;
                            srcLen := StackList[qual_ptr+ix+2].elen_var;
&                           ifdef trace
                            t01int4 (sproc_call, 'isVariable  ', ord (isVariable));
                            t01int4 (sproc_call, 'srcPos      ', srcPos);
                            t01int4 (sproc_call, 'srcLen      ', srcLen);
                            t01int4 (sproc_call, 'dstPos      ', dstPos);
                            t01int4 (sproc_call, 'dstLen      ', dstLen);
&                           endif
                            def_byte := part_ptr^.sp1p_buf[srcPos];
                            IF  g01unicode                   AND
                                (def_byte <> csp_undef_byte) AND
                                (charMapDt.dt in [ddate, dtime, dtimestamp])
                            THEN
                                BEGIN
                                def_byte                   := csp_ascii_blank;
                                part_ptr^.sp1p_buf[srcPos] := csp_ascii_blank;
                                FOR jx := 1 TO (srcLen - 1) DIV 2 DO
                                    part_ptr^.sp1p_buf[srcPos + jx] :=
                                          part_ptr^.sp1p_buf[srcPos + 2 * jx];
                                (*ENDFOR*) 
                                srcLen := 1 + srcLen DIV 2
                                END;
                            (*ENDIF*) 
                            IF  (def_byte <> csp_undef_byte)                 AND
                                (charMapDt.dt in [ddate, dtime, dtimestamp]) AND
                                (acv_addr^.a_dt_format <> dtf_normal)
                            THEN
                                BEGIN (* translate into internal format *)
&                               ifdef trace
                                t01moveobj(sproc_call, part_ptr^.sp1p_buf, srcPos, srcPos + srcLen - 1);
&                               endif
                                data_p^[dstPos] := def_byte;
                                CASE charMapDt.dt OF
                                    ddate :
                                        BEGIN
                                        g03fdcheck_date (part_ptr^.sp1p_buf, data_p^,
                                              srcPos + 1, dstPos + 1, srcLen - 1,
                                              acv_addr^.a_dt_format, e);
                                        srcLen := 1 + mxsp_date
                                        END;
                                    dtime :
                                        BEGIN
                                        g03ftcheck_time (part_ptr^.sp1p_buf, data_p^,
                                              srcPos + 1, dstPos + 1, srcLen - 1,
                                              acv_addr^.a_dt_format, e);
                                        srcLen := 1 + mxsp_time
                                        END;
                                    dtimestamp :
                                        BEGIN
                                        g03ftscheck_timestamp (part_ptr^.sp1p_buf, data_p^,
                                              srcPos + 1, dstPos + 1, srcLen - 1,
                                              acv_addr^.a_dt_format,
                                              acv_addr^.a_ak_language, e);
                                        srcLen := 1 + mxsp_timestamp
                                        END;
                                    END
                                (*ENDCASE*) 
                                END
                            ELSE
                                BEGIN
                                IF  srcLen > dstLen
                                THEN
                                    BEGIN
                                    IF  def_byte = csp_undef_byte
                                    THEN
                                        srcLen := 1
                                    ELSE
                                        srcLen := s30lnr_defbyte (@part_ptr^.sp1p_buf,
                                              def_byte, srcPos + 1, srcLen-1) + 1;
                                    (*ENDIF*) 
                                    IF  srcLen > dstLen
                                    THEN
                                        BEGIN
                                        e := e_column_trunc;
                                        goto 999;
                                        END
                                    ELSE
                                        srcLen := dstLen;
                                    (*ENDIF*) 
                                    END;
                                (*ENDIF*) 
                                SAPDB_PascalMove ('VAK262',  10,    
                                      part_ptr^.sp1p_buf_size, dataSize,
                                      @part_ptr^.sp1p_buf, srcPos, @data_p^, dstPos, srcLen, e);
                                END;
                            (*ENDIF*) 
                            IF  e <> e_ok
                            THEN
                                goto 999;
                            (*ENDIF*) 
                            IF  srcLen < dstLen
                            THEN
                                BEGIN
                                IF  def_byte = csp_unicode_def_byte
                                THEN
                                    BEGIN
                                    SAPDB_PascalUnicodeFill ('VAK262',  11,    
                                          dataSize, data_p,
                                          dstPos + srcLen, dstLen - srcLen,
                                          csp_unicode_blank, e)
                                    END
                                ELSE
                                    BEGIN
                                    IF  def_byte = csp_undef_byte
                                    THEN
                                        fill_char := csp_defined_byte
                                    ELSE
                                        fill_char := def_byte;
                                    (*ENDIF*) 
                                    SAPDB_PascalFill ('VAK262',  12,    
                                          dataSize, data_p,
                                          dstPos + srcLen, dstLen - srcLen,
                                          fill_char, e);
                                    END;
                                (*ENDIF*) 
                                IF  e <> e_ok
                                THEN
                                    goto 999;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    (*ENDFOR*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        acv_addr^.a_data_ptr                     := acv_data_p; (* PTS 1110685 *)
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
999 : ;
qual_ptr := qual_ptr + 2 + paramCnt; (* PTS 1122976 *)
acv_addr^.a_returncode := 0;
IF  e <> e_ok
THEN
    a06reset_retpart (acv_addr^);
(*ENDIF*) 
acv_addr^.a_dt_format := dtFormat;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262ExpandLongParameter (
            VAR acv        : tak_all_command_glob;
            VAR treeid     : tgg00_FileId;
            VAR set_result : tgg00_BdSetResultRecord;
            VAR tree_pos   : tgg00_FilePos;
            VAR pParamBuf  : tsp00_BufAddr;
            VAR bufPos     : tsp00_Int2;
            VAR readFile   : boolean);
 
VAR
      b_err   : tgg00_BasisError;
      pRec    : ^tgg00_Rec;
      pKey    : ^tak262trigger_lkey;
      moveLen : integer;
      key     : tgg00_Lkey;
 
      longRec : RECORD
            CASE integer OF
                1 :
                    (buf : tak262TriggerParamBuffer);
                2 :
                    (rec : tgg00_Rec);
                3 :
                    (triggerKey : tak262trigger_lkey);
                END;
            (*ENDCASE*) 
&           ifdef trace
 
      pMoveObj : tsp00_MoveObjPtr;
&     endif
 
BEGIN
pRec := @pParamBuf^[bufPos];
SAPDB_PascalMove ('VAK262',  13,    
      sizeof(pParamBuf^), sizeof(longRec),
      @pParamBuf^, bufPos, @longRec.buf[1], 1, pRec^.recLen_gg00, acv.a_returncode);
bufPos := bufPos + pRec^.recLen_gg00;
b_err := e_ok;
REPEAT
    IF  bufPos > set_result.bd_fill_len
    THEN
        BEGIN
        bufPos := 1;
        b07cnext_record (acv.a_transinf.tri_trans, treeid,
              key, set_result, tree_pos,
              pParamBuf^);
        b_err := acv.a_transinf.tri_trans.trError_gg00;
        IF  b_err = e_buffer_limit
        THEN
            b_err := e_ok
        ELSE
            BEGIN
            readFile := false;
            IF  b_err = e_key_not_found
            THEN
                b_err := e_ok;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        BEGIN
        pRec    := @pParamBuf^[bufPos];
        pKey    := @pRec^;
        moveLen := pRec^.recLen_gg00 - cgg_rec_key_offset - TriggerKeyLen_cgg04;
        SAPDB_PascalMove ('VAK262',  14,    
              sizeof(pParamBuf^), sizeof(longRec),
              @pParamBuf^, bufPos + cgg_rec_key_offset + TriggerKeyLen_cgg04,
              @longRec.buf[1], longRec.rec.recLen_gg00 + 1,
              moveLen, acv.a_returncode);
        longRec.rec.recLen_gg00 := longRec.rec.recLen_gg00 + moveLen;
        bufPos                  := bufPos + pRec^.recLen_gg00;
        IF  pKey^.tg_link <> cgg_zero_c2
        THEN
            longRec.triggerKey.tg_link := pKey^.tg_link;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
UNTIL
    (longRec.triggerKey.tg_link <> cgg_zero_c2) OR (b_err <> e_ok);
(*ENDREPEAT*) 
IF  b_err = e_ok
THEN
    BEGIN
    pParamBuf := gg941Allocate(acv.a_transinf.tri_trans, longRec.rec.recLen_gg00);
    IF  pParamBuf <> NIL
    THEN
        BEGIN
        SAPDB_PascalMove ('VAK262',  15,    
              sizeof(longRec), longRec.rec.recLen_gg00,
              @longRec.buf[1], 1, @pParamBuf^, 1, longRec.rec.recLen_gg00, acv.a_returncode);
&       ifdef trace
        pMoveObj := @pParamBuf^;
        t01moveobj (ak_sem,  pMoveObj^, 1, longRec.rec.recLen_gg00);
&       endif
        END
    ELSE
        a07_b_put_error (acv, e_no_more_memory, 1)
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262execute_trigger (VAR acv : tak_all_command_glob);
 
TYPE
      (* PTS 1111460 E.Z. *)
 
      trigger_lkey = RECORD
            CASE integer OF
                1 :
                    (r_len   : tsp00_Int2;
                    k_len    : tsp00_Int2;
                    k_f1     : tsp00_Int2;
                    k_f2     : tsp00_Int2;
                    tg_c4    : tsp00_C4;
                    tg_tabid : tgg00_Surrogate;
                    tg_link  : tsp00_C2);
                2 :
                    (r1_len : tsp00_Int2;
                    k1_len  : tsp00_Int2;
                    k1_f1   : tsp00_Int2;
                    k1_f2   : tsp00_Int2;
                    c14     : tsp00_C14);
                END;
            (*ENDCASE*) 
 
 
VAR
      ok                  : boolean;
      read_file           : boolean;
      in_int_sub          : boolean;
      isReplicationSession: boolean;
      isLong              : boolean;
      b_err               : tgg00_BasisError;
      ret_code            : tsp00_Int2;
      error_pos           : tsp00_Int4;
      data_length         : tsp00_Int4;
      precompByte         : tsp00_Uint1;
      init_subtrans       : tgg00_SubtransNo;
      known_part_count    : integer;  (* PTS 1121143 E.Z. *)
      fc_code             : tsp00_Int2;
      buf_pos             : tsp00_Int2;
      rec_len             : tsp_int_map_c2;
      set_result          : tgg00_BdSetResultRecord;
      tree_pos            : tgg00_FilePos;
      res_num             : tsp00_ResNum;
      tree_id             : tgg00_FileId;
      lkey_ptr            : ^tgg00_Lkey;
      pBase               : tak_sysbufferaddress;
      key_ptr             : ^tak262trigger_lkey;
      t_key               : tak262trigger_lkey;
      param_buf           : tsp00_BufAddr;
      buf                 : tsp00_Buf;
      data_part           : tsp1_part_ptr;
      data_p              : tsp00_MoveObjPtr;
      part_ptr            : tsp1_part_ptr;
      cmd_part            : tsp1_part_ptr;
      sysk                : tgg00_SysInfoKey;
      out_packet_ptr      : tsp1_packet_ptr;
      packet_header       : tsp1_packet_header;
      segm_header         : tsp1_segment_header;
      cmd_segm_header     : tsp1_segment_header;
      return_segm         : tsp1_segment_ptr;
      serial_store        : tsp00_C42; (* PTS 1121143 E.Z. *)
 
BEGIN
WITH acv DO
    BEGIN
    in_int_sub := a_in_internal_subtr;
    IF  a_returncode = 0
    THEN
        BEGIN
        precompByte := a_precomp_info_byte;
        data_p      := a_data_ptr;
        data_part   := a_data_part;
        data_length := a_data_length;
        cmd_part    := a_cmd_part;
        fc_code := a_return_segm^.sp1r_function_code;
        (* PTS 1121143 E.Z. *)
        known_part_count := 0;
        serial_store := bsp_c42;
        a92find_return_part (acv, sp1pk_serial, part_ptr);
        IF  part_ptr <> NIL
        THEN
            BEGIN
            SAPDB_PascalMove ('VAK262',  16,    
                  part_ptr^.sp1p_buf_size, sizeof(tsp00_C42), @part_ptr^.sp1p_buf, 1,
                  @serial_store, 1, part_ptr^.sp1p_buf_len, b_err);
            known_part_count := succ(known_part_count);
            END;
        (*ENDIF*) 
        a92find_return_part (acv, sp1pk_resultcount, part_ptr);
        IF  part_ptr <> NIL
        THEN
            BEGIN
            res_num := part_ptr^.sp1p_resnum;
            known_part_count := succ(known_part_count);
            END;
        (*ENDIF*) 
        packet_header   := a_out_packet^.sp1_header;
        out_packet_ptr  := a_out_packet;
        segm_header     := a_out_packet^.sp1_segm.sp1s_segm_header;
        cmd_segm_header := a_cmd_segment_header;
        return_segm     := a_return_segm;
&       ifdef trace
        t01packet (td_always, 'exec trigger', out_packet_ptr);
        IF  (a_return_segm^.sp1s_no_of_parts > known_part_count)
        THEN
            g01abort (csp3_a262_invalid_part_ptr, csp3_n_trigger,
                  'invalid part_ptr found  ',
                  a_return_segm^.sp1s_no_of_parts);
&       endif
        (*ENDIF*) 
        init_subtrans       := a_transinf.tri_trans.trSubtransId_gg00;
&       ifdef trace
        t01int4 (ak_sem, 'init_subtran', init_subtrans);
&       endif
        a_in_internal_subtr := false;
        sysk                := a01defaultkey;
        sysk.sentrytyp      := cak_etriggerparsinfo;
        lkey_ptr            := @t_key;
        buf_pos             := 1;
        read_file           := true;
        set_result.bd_fill_len := 0;
        param_buf              := @buf;
        tree_id        := a_trigger_tree;
        a101_GetLogicalFilename (acv.a_transinf.tri_trans, tree_id);
        a101_SetTempFileIndex (acv, tree_id, a_trigger_level);
        a101_GetTempFileInstance (acv.a_transinf.tri_trans, tree_id);
        tree_id.fileRoot_gg00     := NIL_PAGE_NO_GG00;
        tree_pos.tpsPno_gg00      := NIL_PAGE_NO_GG00;
        (* PTS 1111460 E.Z. *)
        lkey_ptr^.len := 0;
        WITH set_result DO
            BEGIN
            bd_key_check_len := 0;
            bd_max_rec_cnt   := csp_maxint2;
            bd_max_fill_len  := sizeof (param_buf^);
            bd_next          := false;
            bd_drop_page     := false
            END;
        (*ENDWITH*) 
        a_trigger_level := a_trigger_level + 1;
        a101_IncrementProcLevel (acv);
        b_err           := e_ok;
        REPEAT
            IF  buf_pos > set_result.bd_fill_len
            THEN
                IF  read_file
                THEN
                    BEGIN
                    buf_pos := 1;
                    b07cnext_record (a_transinf.tri_trans, tree_id,
                          lkey_ptr^, set_result, tree_pos,
                          param_buf^);
                    b_err             := a_transinf.tri_trans.trError_gg00;
                    rec_len.map_c2[1] := param_buf^[1];
                    rec_len.map_c2[2] := param_buf^[2];
                    IF  b_err = e_buffer_limit
                    THEN
                        b_err := e_ok
                    ELSE
                        BEGIN
                        read_file := false;
                        IF  b_err = e_key_not_found
                        THEN
                            b_err := e_ok;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    b_err := e_no_next_record;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  b_err = e_ok
            THEN
                BEGIN (*======== parameter list found =========*)
                (* PTS 1111460 E.Z. *)
                key_ptr       := @param_buf^[ buf_pos ];
                IF  key_ptr^.tg_link = cgg_zero_c2
                THEN
                    BEGIN
                    isLong := true;
                    ak262ExpandLongParameter (acv, tree_id,
                          set_result, tree_pos, param_buf, buf_pos, read_file);
                    key_ptr := @param_buf^[1];
                    END
                ELSE
                    isLong := false;
                (*ENDIF*) 
                sysk.stableid := key_ptr^.tg_tabid;
                sysk.slinkage := key_ptr^.tg_link;
                (* execute trigger, parameters are stored *)
                (* a_data_ptr                            *)
                a10get_sysinfo (acv, sysk, d_fix, a_ptr1, b_err);
                IF  b_err = e_sysinfo_not_found
                THEN
                    BEGIN (* may be true in case of shared sql *)
                    a06_systable_get (acv, d_release, sysk.stableid, pBase, true, ok);
                    IF  ok
                    THEN
                        BEGIN
                        ak262build_trigger_parsinfo (acv, sysk,
                              pBase^.sbase.btreeid.fileVersion_gg00);
                        a10get_sysinfo (acv, sysk, d_fix, a_ptr1, b_err);
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  b_err = e_ok
                THEN (*====== execute trigger ======*)
                    IF  a_ptr1^.smessblock.mbr_mess_block.mb_type2 = mm_trigger
                    THEN
                        BEGIN
                        ak262int_trigger_cnt := ak262int_trigger_cnt + 1;
                        isReplicationSession := acv.a_isReplicationSession;
                        IF  sysk.slinkage[2] > chr(cak262_internalTriggerOffset)
                        THEN
                            acv.a_isReplicationSession := true;
                        (*ENDIF*) 
                        a262Call (acv, a_ptr1, @key_ptr^);
                        acv.a_isReplicationSession := isReplicationSession
                        END
                    ELSE
                        BEGIN
                        IF  isLong
                        THEN
                            a_data_ptr := @param_buf^[1 +
                                  cgg_rec_key_offset +  TriggerKeyLen_cgg04]
                        ELSE
                            a_data_ptr := @param_buf^[buf_pos +
                                  cgg_rec_key_offset +  TriggerKeyLen_cgg04];
                        (*ENDIF*) 
                        ak262ext_trigger_cnt := ak262ext_trigger_cnt + 1;
                        a260trigger_call (acv, a_ptr1);
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  isLong
                THEN
                    BEGIN
                    gg941Deallocate(acv.a_transinf.tri_trans, param_buf);
                    param_buf := @buf;
                    END;
                (*ENDIF*) 
                rec_len.map_c2[1] := param_buf^[buf_pos  ];
                rec_len.map_c2[2] := param_buf^[buf_pos+1];
                buf_pos           := buf_pos + rec_len.map_int;
                END;
            (*ENDIF*) 
        UNTIL
            (b_err <> e_ok) OR (a_returncode <> 0);
        (*ENDREPEAT*) 
        a_trigger_level := a_trigger_level - 1;
        a101_DecrementProcLevel (acv);
        IF  b_err <> e_no_next_record
        THEN
            a07_b_put_error (acv, b_err, 1);
&       ifdef trace
        (*ENDIF*) 
        t01int4 (ak_sem, 'curr_subtran', a_transinf.tri_trans.trSubtransId_gg00);
&       endif
        IF  init_subtrans <> a_transinf.tri_trans.trSubtransId_gg00
        THEN
            a07_b_put_error (acv, e_invalid_subtrans_structure, 1);
        (*ENDIF*) 
        IF  a_returncode <> 0
        THEN
            BEGIN
            ret_code    := a_returncode;
            error_pos   := a_errorpos;
            a_returncode := 0;
            WHILE (init_subtrans <> a_transinf.tri_trans.trSubtransId_gg00) AND
                  (a_returncode = 0) DO
                a52end_rollback_subtrans (acv,
                      a01_il_b_identifier, m_rollback);
            (*ENDWHILE*) 
            a_returncode := ret_code;
            a_errorpos   := error_pos;
            a_part_rollback := true
            END
        ELSE
            BEGIN
&           ifdef trace
            t01packet (td_always, 'after trigge', out_packet_ptr);
&           endif
            a_out_packet                            := out_packet_ptr;
            a_out_packet^.sp1_header                := packet_header;
            a_out_packet^.sp1_segm.sp1s_segm_header := segm_header;
            a_return_segm                           := return_segm;
            a_cmd_segment_header                    := cmd_segm_header;
            a06reset_retpart (acv);
            (* PTS 1121143 E.Z. *)
            IF  serial_store <> bsp_c42
            THEN
                BEGIN
                a06retpart_move (acv, @serial_store, sizeof(serial_store));
                a06finish_curr_retpart (acv, sp1pk_serial, 1)
                END;
            (*ENDIF*) 
            IF  part_ptr <> NIL
            THEN (* restore result count *)
                a60resnum (acv, res_num, 1);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a_data_ptr                        := data_p;
        a_data_part                       := data_part;
        a_cmd_part                        := cmd_part;
        a_data_length                     := data_length;
        a_return_segm^.sp1r_function_code := fc_code;
        a_precomp_info_byte               := precompByte;
        END;
    (*ENDIF*) 
    ;
    (* destroy file containing trigger parameters, error *)
    (* will be ignored !                                 *)
    a101_DestroyGroupedTempFile (a_transinf.tri_trans, tree_id);
    a_in_internal_subtr   := in_int_sub;
    acv.a_execute_trigger := false;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262CalcOutputLen (
            VAR acv         : tak_all_command_glob;
            VAR methodRec   : tak_methodrecord;
            pParamTable     : tak_sysbufferaddress;
            VAR constParams : tak_colinteger;
            VAR dataLength  : tsp00_Int2;
            VAR ioLength    : tsp00_Int2;
            VAR fraction    : tsp00_Int2);
 
CONST
      c_release_packet = true;
 
VAR
      rownoAllowed : boolean;
      substParams  : boolean;
      res          : tsp00_NumError;
      e            : tgg00_BasisError;
      dummyNode    : tsp00_Int2;
      exprNode     : tsp00_Int2;
      paramNo      : integer;
      ix           : integer;
      jx           : integer;
      restLen      : integer;
      moveLen      : integer;
      firstFree    : integer;
      qualCnt      : integer;
      returnIdx    : integer;
      valuePos     : integer;
      valueLength  : integer;
      delta        : integer;
      packetLength : integer;
      offset       : integer;
      pValue       : tsp00_MoveObjPtr;
      pBuf         : tak_sysbufferaddress;
      pViewDesc    : tak_sysbufferaddress;
      pos          : integer;
      value        : tsp00_C20;
      syskey       : tgg00_SysInfoKey;
      colin        : tak00_scolinf;
      dmli         : tak_dml_info;
      valueBuffer  : tsp00_Buf;
 
      constValues  : ARRAY[1..cak_max_param_index] OF RECORD
            m_pValue : tsp00_MoveObjPtr;
            m_length : integer;
      END;
 
 
BEGIN
&ifdef trace
FOR ix := 1 TO methodRec.me_param_cnt DO
    IF  constParams[ix] <> cak_is_undefined
    THEN
        BEGIN
        t01int4 (ak_sem, 'const param ', ix);
        pValue := @methodRec.me_param_list[ix]^.param_name;
        t01moveobj (ak_sem, pValue^, 1,  ord(methodRec.me_param_list[ix]^.param_name_len));
        t01int4 (ak_sem, 'param_state ', ord(methodRec.me_param_list[ix]^.param_state));
        END;
&   endif
    (*ENDIF*) 
(*ENDFOR*) 
rownoAllowed := acv.a_rowno_allowed;
pViewDesc    := NIL;
syskey       := pParamTable^.syskey;
packetLength := methodRec.me_return_len;
substParams  := false;
ix := 1;
WHILE ix <= methodRec.me_param_cnt DO
    BEGIN
    (* look for parameters in return statement that can be substituted by a constant *)
    (* This is true, if                                                              *)
    (* 1. the parameter is not modified inside the db-function and                   *)
    (* 2. a value is given for the parameter                   and                   *)
    (* 3. the parameter is an integer parameter                                      *)
    constValues[ix].m_pValue := NIL;
    IF  (methodRec.me_param_list[ix]^.param_state    = param_const) AND
        ak262IsIntegerDatatype (methodRec.me_param_list[ix]^      ) AND
        (constParams[ix] <> cak_is_undefined                      )
    THEN
        ix := MAX_INT2_SP00
    ELSE
        ix := ix + 1;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  ix = MAX_INT2_SP00
THEN
    BEGIN
    (* there is at least one parameter that can be substituted by a constant, *)
    (* calculate required space for substituation                             *)
    syskey.sentrytyp := cak_eviewdesc;
    a10get_sysinfo (acv, syskey, d_fix, pViewDesc, e);
    IF  e = e_ok
    THEN
        BEGIN
        substParams   := true;
        valuePos      := 1;
        FOR ix := 1 TO pViewDesc^.sviewdesc.vdesc_cnt DO
            BEGIN
            paramNo := pViewDesc^.sviewdesc.vdescription[ix].vfromextcolno;
            IF  (paramNo <= methodRec.me_param_cnt                                 ) AND
                (methodRec.me_param_list[paramNo]^.param_state    = param_const    ) AND
                ak262IsIntegerDatatype (methodRec.me_param_list[ix]^)                AND
                (constParams[paramNo] <> cak_is_undefined                          ) AND
                (constValues[paramNo].m_pValue = NIL                               ) AND
                substParams
            THEN
                BEGIN
                WITH acv.a_mblock.mb_st^[constParams[paramNo]] DO
                    BEGIN
                    pValue := @acv.a_mblock.mb_data^.mbp_buf[epos];
                    s42gstr (pValue^, 2, (elen_var - 2) * 2, 0, (elen_var - 2) * 2,
                          valueBuffer, valuePos, valueLength, res);
                    IF  res = num_ok
                    THEN
                        BEGIN
&                       ifdef trace
                        pValue := @valueBuffer[valuePos];
                        t01moveobj (ak_sem, pValue^, 1, valueLength);
&                       endif
                        constValues[paramNo].m_pValue := @valueBuffer[valuePos];
                        constValues[paramNo].m_length := valueLength;
                        valuePos                      := valuePos + valueLength;
                        delta := valueLength * a01char_size - ord (methodRec.me_param_list[paramNo]^.param_name_len);
                        FOR jx := ix TO pViewDesc^.sviewdesc.vdesc_cnt DO
                            IF  pViewDesc^.sviewdesc.vdescription[ix].vfromextcolno = paramNo
                            THEN
                                packetLength := packetLength + delta;
                            (*ENDIF*) 
                        (*ENDFOR*) 
                        END
                    ELSE
                        BEGIN
&                       ifdef trace
                        t01int4    (ak_sem, 'num_error   ', ord(res));
                        t01moveobj (ak_sem, pValue^, 1, elen_var);
&                       endif
                        substParams := false;
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        IF  NOT substParams OR (packetLength < methodRec.me_return_len)
        THEN
            packetLength := methodRec.me_return_len;
        (*ENDIF*) 
        END;
    (* if catalog information does not exist, do not substitute constants *)
    (* this may result in a to long output length                         *)
    (*ENDIF*) 
    END;
(*ENDIF*) 
a542internal_packet (acv, NOT c_release_packet, packetLength);
IF  acv.a_returncode = 0
THEN
    BEGIN
    syskey             := pParamTable^.syskey;
    syskey.sentrytyp   := cak_eviewtext;
    syskey.slinkage[1] := chr(254);
    syskey.slinkage[2] := chr(methodRec.me_return_pos DIV sizeof (tak_viewtext) + 1);
    pos                := methodRec.me_return_pos MOD sizeof (tak_viewtext);
    restLen            := methodRec.me_return_len;
    REPEAT
        a10get_sysinfo (acv, syskey, d_release, pBuf, e);
        IF  e = e_ok
        THEN
            BEGIN
            moveLen := pBuf^.b_sl
                  - (sizeof(tak_viewtextrecord) - sizeof(tak_viewtext))
                  - pos + 1;
            IF  moveLen > restLen
            THEN
                moveLen := restLen;
            (*ENDIF*) 
            SAPDB_PascalMove ('VAK262',  17,    
                  sizeof (tak_viewtext), acv.a_cmd_part^.sp1p_buf_size,
                  @pBuf^.sviewtext.vttbuf, pos,
                  @acv.a_cmd_part^.sp1p_buf, acv.a_cmd_part^.sp1p_buf_len + 1, moveLen,
                  acv.a_returncode);
            acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len + moveLen;
            restLen := restLen - moveLen;
            pos     := 1;
            END
        ELSE
            a07_b_put_error (acv, e, 1);
        (*ENDIF*) 
    UNTIL
        (restLen <= 0) OR (acv.a_returncode <> 0);
    (*ENDREPEAT*) 
    IF  substParams AND (acv.a_returncode = 0)
    THEN
        BEGIN
        offset := 0;
        FOR ix := 1 TO pViewDesc^.sviewdesc.vdesc_cnt DO
            BEGIN
            paramNo := pViewDesc^.sviewdesc.vdescription[ix].vfromextcolno;
            IF  (paramNo <= methodRec.me_param_cnt) AND (constValues[paramNo].m_pValue <> NIL)
            THEN
                BEGIN
                (* substitute parameter name by parameter value *)
                a542SubstituteInPacket (acv,
                      pViewDesc^.sviewdesc.vdescription[ix].vn_pos + offset,
                      ord(methodRec.me_param_list[paramNo]^.param_name_len),
                      constValues[paramNo].m_pValue,
                      constValues[paramNo].m_length);
                offset := offset + constValues[paramNo].m_length -
                      ord(methodRec.me_param_list[paramNo]^.param_name_len);
                END;
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
&       ifdef trace
        t01moveobj (ak_sem, acv.a_cmd_part^.sp1p_buf, 1, acv.a_cmd_part^.sp1p_buf_len);
&       endif
        acv.a_scv.sc_symb             := s_unknown;
        acv.a_scv.sc_eof_symb         := s_unknown;
        acv.a_scv.sc_eof_kw           := cak_i_no_keyword;
        acv.a_scv.sc_newpos           := 1;
        acv.a_scv.sc_sypos            := 1;
        acv.a_scv.sc_states           := acv.a_scv.sc_states - [ scs_reserved_check ];
        acv.a_scv.sc_double_quote     := 0;
        a01_call_put (acv, a262, 0, exprNode);
        (* DT QueryRewrite *)
        acv.a_ap_tree^[exprNode].n_querycheck := acv.a_ap_tree^[exprNode].n_querycheck + [qcn_FixedPos];
        (* *)
        a01_next_symbol (acv);
        a63_avalue_expression (acv,
              acv.a_ap_tree^[exprNode].n_sa_level, dummyNode);
        END;
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        exprNode := acv.a_ap_tree^[exprNode].n_sa_level;
        a54_dml_init (acv, dmli, false);
        WITH dmli DO
            BEGIN
            d_sparr.pbasep := pParamTable;
            d_cntfromtab   := 1;
            d_acttabindex  := 1;
            ak262InitOneTable(d_tabarr^[1]);
            WITH d_tabarr^[d_cntfromtab] DO
                BEGIN
                ofromtableid  := pParamTable^.sbase.bsurrogate;
                ouser         := a01_i_temp;
                otable        := a01_i_temp;
                ocounttabs    := 1
                END;
            (*ENDWITH*) 
            acv.a_rowno_allowed     := false;
            dmli.d_fieldno          := 1;
            dmli.d_pars_kind        := fp_val_all_without_l;
            dmli.d_wherepart        := true;
            WITH pParamTable^.sbase DO
                BEGIN
                returnIdx       := bfirstindex + bextcolindex[3 + methodRec.me_param_cnt];
                IF  bcolumn[returnIdx]^.cdatatyp in [dinteger, dfixed, dfloat, dsmallint]
                THEN
                    dmli.d_datatype := dnumber
                ELSE
                    dmli.d_datatype := bcolumn[returnIdx]^.cdatatyp;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
            dmli.d_colptr           := NIL;
            colin.sci_len           := 0;
            dmli.d_first_tab        := 0;
            dmli.d_allowed          := may_more_tabs;
            dmli.d_change_date_time := false;
            dmli.d_const_value_expr := true;
            dmli.d_param_st_begin   := 0;
            dmli.d_param_st_index   := 0;
            firstFree               := acv.a_mblock.mb_qual^.mfirst_free;
            qualCnt                 := acv.a_mblock.mb_qual^.mqual_cnt;
            WITH acv.a_ap_tree^[exprNode] DO
                IF  (n_proc = a64) AND (n_subproc = cak_x_value_expression)
                THEN
                    a65_val_expr (acv, dmli, colin, n_lo_level)
                ELSE
                    a65_val_expr (acv, dmli, colin, exprNode);
                (*ENDIF*) 
            (*ENDWITH*) 
            acv.a_mblock.mb_qual^.mfirst_free := firstFree;
            acv.a_mblock.mb_qual^.mqual_cnt   := qualCnt;
            dataLength := colin.sci_len;
            ioLength   := colin.sci_iolen;
            fraction   := colin.sci_frac;
            END;
        (*ENDWITH*) 
        a54_dml_finalize( dmli, acv.a_transinf.tri_trans );
        END;
    (*ENDIF*) 
    a542pop_packet (acv);
    a10key_del     (acv, pParamTable);
    END;
&ifdef trace
(*ENDIF*) 
t01int4 (ak_sem, 'dataLength  ', dataLength);
t01int4 (ak_sem, 'ioLength    ', ioLength);
t01int4 (ak_sem, 'fraction    ', fraction);
&endif
IF  pViewDesc <> NIL
THEN
    a10rel_sysinfo (pViewDesc);
(*ENDIF*) 
acv.a_rowno_allowed := rownoAllowed;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262Call (
            VAR acv : tak_all_command_glob;
            p      : tak_sysbufferaddress;
            data_p : tsp00_MoveObjPtr);
 
CONST
      c_check_new_rec = true;
 
VAR
      cursorPos    : integer;
      moveLen      : integer;
      varBufferLen : integer;
      rec_p        : ^tgg00_Rec;
      mblock_p     : tgg00_MessBlockPtr;
      sel          : tgg00_SelectFieldsParam;
      appl_version : tsp00_C5;
      application  : tsp00_C3;
      pCursor      : ^tsp00_KnlIdentifier;
 
      pVarBuffer   : RECORD
            CASE integer OF
                1 :
                    (pIP  : tak_param_info_ptr);
                2 :
                    (pMObj : tsp00_MoveObjPtr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
appl_version := acv.a_out_packet^.sp1_header.sp1h_appl_version; (* PTS 1104033 *)
application  := acv.a_out_packet^.sp1_header.sp1h_application;  (* PTS 1104033 *)
a10Lock (acv, p);
mblock_p := @p^.smessblock.mbr_mess_block;
&ifdef trace
t01messblock (sproc_call, 'mblock call ', mblock_p^);
&endif
IF  acv.a_returncode = 0
THEN
    BEGIN
    rec_p                     := @data_p^;
    mblock_p^.mb_work_st      := acv.a_work_st_addr;
    mblock_p^.mb_work_st_max  := acv.a_work_st_max;
    mblock_p^.mb_workbuf      := acv.a_work_buf_addr;
    mblock_p^.mb_workbuf_size := acv.a_work_buf_size;
    mblock_p^.mb_trns         := @acv.a_transinf.tri_trans;
    g04init_select_fields (sel,
          @mblock_p^.mb_data^.mbp_buf, mblock_p^.mb_data_size,
          mblock_p^.mb_work_st, mblock_p^.mb_work_st_max,
          mblock_p^.mb_workbuf, mblock_p^.mb_workbuf_size,
          acv.a_sqlmode, @mblock_p^.mb_fieldlists);
    WITH sel DO
        BEGIN
        sfp_pl_ptr          := @p^;
        sfp_bd_mess_type    := mblock_p^.mb_type;
        sfp_bd_mess2_type   := mblock_p^.mb_type2;
        sfp_result_wanted   := false;
        sfp_m_result_addr   := NIL;
        sfp_m_result_size   := 0;
        sfp_first_qual      := true;
        sfp_filler2         := false;
        IF  mblock_p^.mb_qual^.mbool
        THEN
            BEGIN (* code already contains date/time info, true since 7.3.0.22 *)
            sfp_sqlmode         := mblock_p^.mb_qual^.msqlmode;
            sfp_dateTimeFormat  := mblock_p^.mb_qual^.mdatetimeformat;
            END
        ELSE
            BEGIN (* don't know anything about date/time format *)
            sfp_sqlmode         := acv.a_sqlmode;
            sfp_dateTimeFormat  := acv.a_dt_format;
            END;
        (*ENDIF*) 
        cursorPos           := mblock_p^.mb_qual^.mcol_pos;
        (* create buffer for dbproc variables *)
        IF  mblock_p^.mb_qual^.mstring_cnt > 0
        THEN
            BEGIN
            IF  mblock_p^.mb_st^[mblock_p^.mb_qual^.mstring_pos].epos = 1
            THEN
                BEGIN
                moveLen      := 0;
                varBufferLen := mblock_p^.mb_st^[mblock_p^.mb_qual^.mstring_pos].elen_var;
                END
            ELSE
                BEGIN
                varBufferLen := mblock_p^.mb_data^.mbp_rec.recLen_gg00;
                moveLen      := varBufferLen
                END
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            moveLen      := mblock_p^.mb_data^.mbp_rec.recLen_gg00;
            varBufferLen := moveLen
            END;
        (*ENDIF*) 
&       ifdef trace
        t01int4(ak_sem, 'cursorPos   ', cursorPos);
        t01int4(ak_sem, 'mem for vars', varBufferLen);
&       endif
        a10new (acv, varBufferLen, pVarBuffer.pIP);
        sfp_oldrec_addr     := pVarBuffer.pMObj;
        sfp_oldrec_pos      := 1;
        sfp_oldrec_len      := varBufferLen;
        sfp_oldkey_len      := 0;
        sfp_acv_addr        := @acv;
        END;
    (*ENDWITH*) 
    acv.a_data_ptr := data_p;
&   ifdef trace
    t01name (sproc_call, '-> trigger execute');
    t01messblock (sproc_call, 'mblock call ', mblock_p^);
&   endif
    IF  pVarBuffer.pMObj = NIL
    THEN
        a07_b_put_error (acv, e_no_more_memory, 1)
    ELSE
        BEGIN
        SAPDB_PascalForcedMove (moveLen, moveLen,
              @mblock_p^.mb_data^, 1,
              pVarBuffer.pMObj, 1,
              moveLen);
        (* $rc := 0 *)
        SAPDB_PascalMove ('VAK262',  18,    
              sizeof(g01glob.rescnt_0), varBufferLen,
              @g01glob.rescnt_0, 1, @pVarBuffer.pMObj^, cgg_rec_key_offset + 1,
              (cak262_rc_digits + 1) DIV 2 + 2, acv.a_returncode);
        (* $errmsg = null *)
        pVarBuffer.pMObj^[cgg_rec_key_offset + (cak262_rc_digits + 1) DIV 2 + 2 + 1] := csp_undef_byte;
        (* $count = null *)
        pVarBuffer.pMObj^[cgg_rec_key_offset +
              (cak262_rc_digits + 1) DIV 2 + 2 + 1 + cak262_max_errormsg * a01char_size + 1] := csp_undef_byte;
        IF  cursorPos > 0
        THEN
            BEGIN (* move current cursor name into $cursor *)
            pVarBuffer.pMObj^[cgg_rec_key_offset+cursorPos] := csp_ascii_blank;
            pCursor  := @pVarBuffer.pMObj^[cgg_rec_key_offset+cursorPos+1];
            IF  acv.a_resname_part <> NIL
            THEN
                a501GetResultName (acv, pCursor^)
            ELSE
                pCursor^ := acv.a_result_name;
            (*ENDIF*) 
&           ifdef trace
            t01lidentifier (sproc_call, pCursor^);
&           endif
            END;
        (*ENDIF*) 
        k71sel_qualification_test (mblock_p^, sel, NOT c_check_new_rec, rec_p^);
        IF  mblock_p^.mb_trns^.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, mblock_p^.mb_trns^.trError_gg00, 1);
        (*ENDIF*) 
        a10dispose (acv, pVarBuffer.pMObj);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
a10Unlock (acv, p);
IF  acv.a_dbproc_level + acv.a_trigger_level = 1
THEN (* finish stepping via debugger *)
    a101_DebuggerStep (acv, -1);
(*ENDIF*) 
acv.a_out_packet^.sp1_header.sp1h_appl_version := appl_version;  (* PTS 1104033 *)
acv.a_out_packet^.sp1_header.sp1h_application  := application;   (* PTS 1104033 *)
END;
 
(*------------------------------*) 
 
FUNCTION
      a262EvalOutputLenProlog (
            VAR  acv        : tak_all_command_glob;
            VAR  functionId : tgg00_Surrogate) : tak_sysbufferaddress;
 
VAR
      e    : tgg00_BasisError;
      pBuf : tak_sysbufferaddress;
      syskey : tgg00_SysInfoKey;
 
BEGIN
syskey           := a01defaultkey;
syskey.stableid  := functionId;
syskey.sentrytyp := cak_etable;
a10get_sysinfo (acv, syskey, d_fix, pBuf, e);
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1);
(*ENDIF*) 
a262EvalOutputLenProlog := pBuf;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262get_trigger_name (
            VAR trigger_rec  : tak_triggerrecord;
            VAR trigger_name : tsp00_KnlIdentifier;
            VAR b_err        : tgg00_BasisError);
 
BEGIN
SAPDB_PascalMove ('VAK262',  19,    
      sizeof (trigger_rec.tr_name), sizeof (trigger_name),
      @trigger_rec.tr_name, 1, @trigger_name, 1, trigger_rec.tr_name_len,
      b_err);
SAPDB_PascalMove ('VAK262',  20,    
      sizeof (a01_il_b_identifier), sizeof (trigger_name),
      @a01_il_b_identifier, 1, @trigger_name, trigger_rec.tr_name_len + 1,
      sizeof (trigger_name) - trigger_rec.tr_name_len,
      b_err)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262GetDBProcDefinition (
            VAR acv      : tak_all_command_glob;
            VAR DBProcId : tgg00_Surrogate;
            VAR def_len  : tsp00_Int4;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4);
 
VAR
      b_err         : tgg00_BasisError;
      move_len      : tsp00_Int4;
      pos           : tsp00_Int4;
      StmtLen       : tsp00_Int4;
      pBuf          : tak_sysbufferaddress;
      syskey        : tgg00_SysInfoKey;
 
BEGIN
syskey.sauthid     := DBProcId;
syskey.sentrytyp   := cak_eviewtext;
syskey.slinkage[1] := chr(254);
syskey.slinkage[2] := chr(1);
syskey.skeylen     := mxak_standard_sysk;
pos                := 1;
def_len            := 0;
REPEAT
    a10get_sysinfo (acv, syskey, d_release, pBuf, b_err);
    IF  b_err = e_ok
    THEN
        BEGIN
        StmtLen := pBuf^.sviewtext.vtfromtabcnt * csp_maxint2 +
              pBuf^.sviewtext.vttabcount;
        move_len := pBuf^.b_sl - (sizeof(tak_viewtextrecord) - sizeof(tak_viewtext));
        IF  def_len + move_len > buf_size
        THEN
            move_len := buf_size - def_len;
        (*ENDIF*) 
        SAPDB_PascalMove ('VAK262',  21,    
              sizeof (tak_viewtext), buf_size, @pBuf^.sviewtext.vttbuf, 1,
              @buf, pos, move_len, acv.a_returncode);
        pos     := pos + move_len;
        def_len := def_len + move_len;
        END;
    (*ENDIF*) 
UNTIL
    (pos > buf_size) OR (pos > StmtLen) OR (b_err <> e_ok);
(*ENDREPEAT*) 
IF  b_err <> e_ok
THEN
    a07_b_put_error (acv, b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262GetValDBProcDefinition (
            VAR acv           : tak_all_command_glob;
            VAR long_desc     : tak_long_descriptor;
            VAR ret_long_qual : tgg00_LongQual);
 
VAR
      exit_loop     : boolean;
      b_err         : tgg00_BasisError;
      required_len  : tsp00_Int4;
      rec_len       : tsp00_Int4;
      move_len      : tsp00_Int4;
      len           : tsp00_Int4;
      pos           : tsp00_Int4;
      rest_buf_size : tsp00_Int4;
      StmtLen       : tsp00_Int4;
      curr_data_ptr : tsp00_MoveObjPtr;
      pBuf          : tak_sysbufferaddress;
      syskey        : tgg00_SysInfoKey;
      err_char_no   : tsp00_Int4;
      uni_err       : tsp8_uni_error;
 
BEGIN
ret_long_qual := g01nil_long_qual;
WITH acv, long_desc, ret_long_qual DO
    BEGIN
    curr_data_ptr      := @a_curr_retpart^.sp1p_buf [lds_valpos];
    rest_buf_size      := a_curr_retpart^.sp1p_buf_size - lds_valpos + 1;
    required_len       := lds_vallen;
    lds_vallen         := 0;
    syskey.sauthid     := lds_descriptor;
    syskey.sentrytyp   := cak_eviewtext;
    syskey.slinkage[1] := chr(254);
    syskey.slinkage[2] := chr(lds_intern_pos DIV sizeof (tak_viewtext) + 1);
    syskey.skeylen     := mxak_standard_sysk;
    pos                := lds_intern_pos MOD sizeof (tak_viewtext);
    exit_loop          := false;
    REPEAT
        a10get_sysinfo (acv, syskey, d_release, pBuf, b_err);
        IF  b_err = e_ok
        THEN
            BEGIN
            StmtLen := pBuf^.sviewtext.vtfromtabcnt * csp_maxint2 +
                  pBuf^.sviewtext.vttabcount;
            rec_len     := pBuf^.b_sl;
            len         := rec_len
                  - (sizeof(tak_viewtextrecord) - sizeof(tak_viewtext))
                  - pos + 1;
            (* PTS 1105838 E.Z. *)
            IF  (g01unicode) AND
                (ld_use_ucs_2_swap in lds_state)
            THEN
                BEGIN
                IF  rest_buf_size + lds_vallen > required_len
                THEN
                    move_len := required_len - lds_vallen
                ELSE
                    move_len := rest_buf_size;
                (*ENDIF*) 
                s80uni_trans (@pBuf^.sviewtext.vttbuf[pos], len, csp_unicode,
                      @(curr_data_ptr^[lds_vallen+1]), move_len,
                      csp_unicode_swap, [ ], uni_err, err_char_no);
                IF  (move_len = required_len - lds_vallen) OR
                    (uni_err <> uni_ok)
                THEN
                    BEGIN
                    exit_loop := true;
                    IF  uni_err = uni_dest_too_short
                    THEN
                        len := err_char_no;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  NOT (uni_err in [ uni_ok, uni_dest_too_short ])
                THEN
                    a07_uni_error (acv, uni_err, err_char_no);
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  lds_vallen + len >= required_len
                THEN
                    BEGIN
                    len       := required_len - lds_vallen;
                    exit_loop := true
                    END;
&               ifdef trace
                (*ENDIF*) 
                t01int4 (ak_sem, 'len         ', len);
                t01int4 (ak_sem, 'lds_vallen  ', lds_vallen);
&               endif
                IF  len > rest_buf_size
                THEN
                    len := rest_buf_size;
                (*ENDIF*) 
                move_len := len;
                SAPDB_PascalMove ('VAK262',  22,    
                      sizeof (tak_viewtext), a_curr_retpart^.sp1p_buf_size, @pBuf^.sviewtext.vttbuf, pos,
                      @curr_data_ptr^, lds_vallen + 1, move_len,
                      a_returncode);
                END;
            (*ENDIF*) 
            lds_vallen     := lds_vallen     + move_len;
            lds_intern_pos := lds_intern_pos + move_len;
&           ifdef trace
            t01int4 (ak_sem, 'intern_pos  ', long_desc.lds_intern_pos);
&           endif
            rest_buf_size := rest_buf_size - move_len;
            IF  rest_buf_size = 0
            THEN
                exit_loop := true;
            (*ENDIF*) 
            a06inc_linkage (syskey.slinkage);
            pos := 1
            END
        ELSE
            exit_loop := true;
        (*ENDIF*) 
    UNTIL
        exit_loop OR
        (rec_len < sizeof (tak_viewtextrecord));
    (*ENDREPEAT*) 
    IF  (b_err = e_ok) AND (a_returncode = 0)
    THEN
        BEGIN
&       ifdef trace
        t01int4 (ak_sem, 'StmtLen     ', StmtLen);
&       endif
        lq_pos       := lds_intern_pos;
        lq_long_size := StmtLen;
        (* PTS 1105838 E.Z. *)
        lds_maxlen   := StmtLen;
        IF  lds_intern_pos > StmtLen
        THEN
            lds_valmode := vm_lastdata
        ELSE
            lds_valmode := vm_datapart
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1112383 *)
(*------------------------------*) 
 
PROCEDURE
      a262InternalFunction(
            VAR StackEntry       : tgg00_StackEntry;
            VAR Buf              : tsp00_MoveObj;
            BufSize              : integer;
            BufPos               : integer;
            VAR e                : tgg00_BasisError);
 
CONST
      c_use_acv_timestamp = true;
 
VAR
      pAcv : tak_acv_address;
 
BEGIN (* PTS 1113215 *)
e    := e_ok;
pAcv := vGetAcvPtrFromCurrentTask;
a54InternalFunction (pAcv^, StackEntry, Buf, BufSize, BufPos, NOT c_use_acv_timestamp);
IF  pAcv^.a_returncode <> 0
THEN
    e := e_invalid
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262stop (
            acv_addr          : tak_acv_address;
            rc                : tsp00_Int2;
            msgtext_len       : integer;
            msgtext           : tsp00_MoveObjPtr;
            isFunctionStopMsg : boolean;
            isUserDefined     : boolean);
 
VAR
      e           : tsp8_uni_error;
      err_char_no : tsp00_Int4;
      src_codeset : integer;
 
BEGIN
&ifdef trace
t01moveobj (sproc_call, msgtext^, 1, msgtext_len);
&endif
IF  isFunctionStopMsg
THEN
    BEGIN
    IF  acv_addr^.a_returncode = 0
    THEN
        BEGIN
        acv_addr^.a_returncode := rc;
        a07put_param (acv_addr^, 1, @msgtext^[2], msgtext_len - 1);
        END;
    (*ENDIF*) 
    END
ELSE
    BEGIN
    IF  rc <> e_stop_0
    THEN
        BEGIN
        a06reset_retpart     (acv_addr^);
        msgtext_len := msgtext_len - 1;
        IF  msgtext_len > 0
        THEN
            BEGIN
            a06init_curr_retpart (acv_addr^);
            IF  msgtext_len > cak262_max_errormsg * a01char_size
            THEN
                msgtext_len := cak262_max_errormsg * a01char_size;
            (*ENDIF*) 
            IF  g01unicode
            THEN
                BEGIN
                IF  msgtext^[1] = csp_unicode_def_byte
                THEN
                    src_codeset := csp_unicode
                ELSE
                    src_codeset := csp_ascii;
                (*ENDIF*) 
                acv_addr^.a_curr_retpart^.sp1p_buf_len :=
                      acv_addr^.a_curr_retpart^.sp1p_buf_size;
                s80uni_trans (@msgtext^[ 2 ], msgtext_len,
                      src_codeset, @acv_addr^.a_curr_retpart^.sp1p_buf,
                      acv_addr^.a_curr_retpart^.sp1p_buf_len,
                      acv_addr^.a_out_packet^.sp1_header.sp1h_mess_code, [ ],
                      e, err_char_no);
&               ifdef trace
                t01int4 (sproc_call, 'out messcode',
                      acv_addr^.a_out_packet^.sp1_header.sp1h_mess_code);
                t01int4 (sproc_call, 'uni_trans e ', ord(e));
&               endif
                END
            ELSE
                a06retpart_move (acv_addr^, @msgtext^[2], msgtext_len)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a06finish_curr_retpart (acv_addr^, sp1pk_errortext, 1);
        acv_addr^.a_user_defined_error := true;
        END;
    (*ENDIF*) 
    acv_addr^.a_returncode := rc;
    IF    isUserDefined
    THEN
        WITH acv_addr^.a_return_segm^ DO
            sp1r_extern_warning := sp1r_extern_warning + [warn0_exist] + [warn15_user_defined_code];
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262copy_result_part (
            acv_addr          : tak_acv_address;
            VAR part          : tsp1_part);
 
BEGIN
a06init_curr_retpart (acv_addr^);
a06retpart_move (acv_addr^, @part.sp1p_buf [1], part.sp1p_buf_len);
a06finish_curr_retpart (acv_addr^, part.sp1p_part_kind, 1);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262reset_statistics;
 
BEGIN
ak262int_trigger_cnt := 0;
ak262ext_trigger_cnt := 0
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262ReturnCursor (
            acv_addr   : tak_acv_address;
            param_addr : tsp00_MoveObjPtr;
            param_len  : tsp00_Int4;
            VAR e      : tgg00_BasisError);
 
VAR
      ok   : boolean;
      pRes : tak_syspointerarr;
 
BEGIN
SAPDB_PascalMove ('VAK262',  23,    
      param_len, sizeof(acv_addr^.a_result_name), param_addr, 2,
      @acv_addr^.a_result_name, 1, param_len - 1, e);
IF  e = e_ok
THEN
    BEGIN
    a663restable_get (acv_addr^, d_release, acv_addr^.a_result_name, pRes, ok);
    IF  ok
    THEN
        BEGIN
        IF  NOT (rs_result in pRes.presnp^.sresname.resstate)
        THEN
            a60rescount (acv_addr^, -1)
        ELSE
            a60rescount (acv_addr^, pRes.pbasep^.sresult.brows);
        (*ENDIF*) 
        acv_addr^.a_return_segm^.sp1r_function_code := csp1_select_fc;
        a92_resname_to_varpart (acv_addr^);
        acv_addr^.a_return_segm^.sp1r_function_code := csp1_cursor_pl_sql_execute_fc;
        END
    ELSE
        e := e_unknown_name;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262ReturnParam (
            acv_addr      : tak_acv_address;
            paramDataType : tsp00_DataType;
            param_addr    : tsp00_MoveObjPtr;
            param_len     : tsp00_Int4;
            VAR e         : tgg00_BasisError);
 
VAR
      uni_e          : tsp8_uni_error;
      handleDateTime : boolean;
      ix             : integer;
      err_char_no    : tsp00_Int4;
      BufLen         : tsp00_Int4;
      BufSize        : tsp00_Int4;
      dateTimeBuffer : tsp00_C64;
 
      longDesc       : RECORD
            CASE boolean OF
                true :
                    (align : tsp00_Int4);
                false :
                    (fill1   : tsp00_C2;
                    fill2    : tsp00_C1;
                    defByte  : char;
                    desc     : tsp00_LongDescriptor);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  param_addr = NIL
THEN
    a06reset_retpart (acv_addr^)
ELSE
    BEGIN
    IF  (param_addr^[1] = csp_unicode_def_byte)
        AND
        ((acv_addr^.a_cmd_packet_header.sp1h_mess_code = csp_unicode_swap) (* PTS 1115984 *)
        OR
        ((acv_addr^.a_cmd_packet_header.sp1h_mess_code = csp_ascii) AND
        ( acv_addr^.a_cmd_packet_header.sp1h_mess_swap <> sw_normal)))
    THEN
        BEGIN
        IF  acv_addr^.a_curr_retpart = NIL (* PTS 1108539 *)
        THEN
            a06init_curr_retpart (acv_addr^);
        (*ENDIF*) 
        BufLen  :=  acv_addr^.a_curr_retpart^.sp1p_buf_len;
        BufSize :=  acv_addr^.a_curr_retpart^.sp1p_buf_size - BufLen - 1;
        acv_addr^.a_curr_retpart^.sp1p_buf[BufLen+1] := csp_unicode_def_byte;
        s80uni_trans (@param_addr^[2], param_len - 1,
              csp_unicode, @acv_addr^.a_curr_retpart^.sp1p_buf[BufLen+2],
              BufSize, csp_unicode_swap, [ ],
              uni_e, err_char_no);
        IF  uni_e <> uni_ok
        THEN
            e := e_not_translatable
        ELSE
            acv_addr^.a_curr_retpart^.sp1p_buf_len := 1 +
                  acv_addr^.a_curr_retpart^.sp1p_buf_len + BufSize
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        handleDateTime := false;
        IF  (paramDataType in [ddate, dtime, dtimestamp])
        THEN
            IF  param_addr^[1] <> csp_undef_byte
            THEN
                BEGIN
                handleDateTime := true;
                CASE paramDataType OF
                    ddate :
                        BEGIN
                        dateTimeBuffer := bsp_c64;
                        g03dchange_format_date (param_addr^, dateTimeBuffer,
                              2, 2, acv_addr^.a_dt_format, e);
                        param_addr := @dateTimeBuffer;
                        param_len  := 1 + EXT_DATE_MXSP00;
                        END;
                    dtime :
                        BEGIN
                        dateTimeBuffer := bsp_c64;
                        g03tchange_format_time (param_addr^, dateTimeBuffer,
                              2, 2, acv_addr^.a_dt_format, e);
                        param_addr := @dateTimeBuffer;
                        param_len  := 1 + EXT_TIME_MXSP00;
                        END;
                    dtimestamp :
                        BEGIN
                        dateTimeBuffer := bsp_c64;
                        g03tschange_format_timestamp (param_addr^, dateTimeBuffer,
                              2, 2, acv_addr^.a_dt_format, acv_addr^.a_ak_language, e);
                        param_addr := @dateTimeBuffer;
                        param_len  := 1 + EXT_TIMESTAMP_MXSP00;
                        END;
                    OTHERWISE ;
                    END
                (*ENDCASE*) 
                END
            ELSE
                BEGIN
                param_addr        := @dateTimeBuffer;
                dateTimeBuffer[1] := csp_undef_byte;
                CASE paramDataType OF
                    ddate :
                        param_len  := 1 + EXT_DATE_MXSP00;
                    dtime :
                        param_len  := 1 + EXT_TIME_MXSP00;
                    dtimestamp :
                        param_len  := 1 + EXT_TIMESTAMP_MXSP00;
                    END;
                (*ENDCASE*) 
                IF  (acv_addr^.a_cmd_packet_header.sp1h_mess_code in [csp_unicode, csp_unicode_swap]) AND
                    NOT acv_addr^.a_ascii_in_and_output
                THEN
                    param_len := param_len * 2 - 1;
                (*ENDIF*) 
                FOR ix := 2 TO param_len DO
                    dateTimeBuffer[ix] := chr(0);
                (*ENDFOR*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  NOT acv_addr^.a_ascii_in_and_output
            AND
            handleDateTime
            AND
            (acv_addr^.a_cmd_packet_header.sp1h_mess_code in [csp_unicode, csp_unicode_swap])
        THEN
            BEGIN
            IF  acv_addr^.a_curr_retpart = NIL
            THEN
                a06init_curr_retpart (acv_addr^);
            (*ENDIF*) 
            BufLen  :=  acv_addr^.a_curr_retpart^.sp1p_buf_len;
            BufSize :=  acv_addr^.a_curr_retpart^.sp1p_buf_size - BufLen - 1;
            acv_addr^.a_curr_retpart^.sp1p_buf[BufLen+1] := csp_unicode_def_byte;
            s80uni_trans (@param_addr^[2], param_len - 1,
                  csp_ascii, @acv_addr^.a_curr_retpart^.sp1p_buf[BufLen+2],
                  BufSize, acv_addr^.a_cmd_packet_header.sp1h_mess_code, [ ],
                  uni_e, err_char_no);
            IF  uni_e <> uni_ok
            THEN
                e := e_not_translatable
            ELSE
                acv_addr^.a_curr_retpart^.sp1p_buf_len := 1 +
                      acv_addr^.a_curr_retpart^.sp1p_buf_len + BufSize
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            IF  (acv_addr^.a_out_packet^.sp1_header.sp1h_mess_swap <> g01code.kernel_swap)
                AND
                (paramDataType in [dstra, dstrb, dstruni, dlonga, dlongb, dlonguni])
            THEN
                BEGIN
                (* swap integers of long descriptor *)
                SAPDB_PascalMove ('VAK262',  24,    
                      param_len, sizeof (longDesc.desc),
                      param_addr, 2, @longDesc.desc, 1, sizeof(longDesc.desc), e);
                s20swap_int4 (longDesc.desc.ld_maxlen,
                      g01code.kernel_swap, acv_addr^.a_out_packet^.sp1_header.sp1h_mess_swap);
                s20swap_int4 (longDesc.desc.ld_intern_pos,
                      g01code.kernel_swap, acv_addr^.a_out_packet^.sp1_header.sp1h_mess_swap);
                longDesc.desc.ld_valind   := a01swap_int2(longDesc.desc.ld_valind);
                longDesc.desc.ld_unused_2 := a01swap_int2(longDesc.desc.ld_unused_2);
                s20swap_int4 (longDesc.desc.ld_valpos,
                      g01code.kernel_swap, acv_addr^.a_out_packet^.sp1_header.sp1h_mess_swap);
                s20swap_int4 (longDesc.desc.ld_vallen,
                      g01code.kernel_swap, acv_addr^.a_out_packet^.sp1_header.sp1h_mess_swap);
                longDesc.defByte := param_addr^[1];
                param_addr       := @longDesc.defByte;
                param_len        := 1 + sizeof(longDesc.desc);
                END;
            (*ENDIF*) 
            IF  (paramDataType in [dstruni, dlonguni]) AND
                (acv_addr^.a_out_packet^.sp1_header.sp1h_mess_swap = sw_normal)
            THEN
                BEGIN (* PTS 1136086 *)
                IF  param_addr <> @longDesc.defByte
                THEN
                    BEGIN
                    SAPDB_PascalMove ('VAK262',  25,    
                          param_len, sizeof (longDesc.desc),
                          param_addr, 2, @longDesc.desc, 1, sizeof(longDesc.desc), e);
                    param_addr := @longDesc.defByte;
                    param_len  := 1 + sizeof(longDesc.desc);
                    END;
                (*ENDIF*) 
                longDesc.desc.ld_state := longDesc.desc.ld_state - [ld_use_ucs_2_swap];
                END;
            (*ENDIF*) 
            a06retpart_move (acv_addr^, param_addr, param_len)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262SetParameterProperties (
            VAR acv       : tak_all_command_glob;
            pParamTable   : tak_sysbufferaddress;
            paramNo       : integer;
            paramDataType : tsp00_DataType;
            dataLength    : integer;
            inOutLength   : integer;
            fraction      : integer);
 
VAR
      idx : integer;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    WITH pParamTable^.sbase DO
        BEGIN
        idx := bfirstindex + bextcolindex[3 + paramNo];
        bcolumn[idx]^.cdatatyp  := paramDataType;
        bcolumn[idx]^.cdatalen  := dataLength;
        bcolumn[idx]^.cinoutlen := inOutLength;
        IF  paramDataType = dfloat
        THEN
            bcolumn[idx]^.cdatafrac := csp_float_frac
        ELSE
            bcolumn[idx]^.cdatafrac := cak_frac_offset + fraction;
        (*ENDIF*) 
&       ifdef trace
        a061td_colinfo (bcolumn[idx]^, idx);
&       endif
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a262StatementBeginStackEntry(
            acv_addr       : tak_acv_address;
            VAR sel        : tgg00_SelectFieldsParam;
            stackIndex     : integer;
            VAR codePos    : integer;
            VAR codeLength : integer) : boolean;
 
VAR
      e        : tgg00_BasisError;
      ix       : integer;
      p        : tak_sysbufferaddress;
      mblock_p : tgg00_MessBlockPtr;
      sysk     : tgg00_SysInfoKey;
 
BEGIN
codePos        := -1;
p              := @sel.sfp_pl_ptr^;
mblock_p       := @p^.smessblock.mbr_mess_block;
sysk           := a01defaultkey;
sysk.stableid  := mblock_p^.mb_qual^.mtree.fileTabId_gg00;
sysk.sentrytyp := cak_emethoddebuginfo;
IF  mblock_p^.mb_type2 = mm_trigger
THEN
    sysk.slinkage := p^.syskey.slinkage;
(*ENDIF*) 
a10get_sysinfo (acv_addr^, sysk, d_release, p, e);
IF  e = e_ok
THEN
    WITH p^.smethoddebuginfo DO
        BEGIN
        ix := 1;
        WHILE ix <= med_count DO
            IF  med_info[ix].dbg_stack_entry_index = stackIndex
            THEN
                BEGIN
                codePos    := med_info[ix].dbg_code_pos;
                codeLength := med_info[ix].dbg_code_length;
                ix         := med_count + 1;
                END
            ELSE
                ix := ix + 1;
            (*ENDIF*) 
        (*ENDWHILE*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
a262StatementBeginStackEntry := codePos > 0;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262statistics (
            VAR external_trigger_cnt : tsp00_8ByteCounter;
            VAR internal_trigger_cnt : tsp00_8ByteCounter);
 
BEGIN
external_trigger_cnt := ak262ext_trigger_cnt;
internal_trigger_cnt := ak262int_trigger_cnt
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262trigger_semantic (VAR acv : tak_all_command_glob);
 
CONST
      c_any_priv = true;
 
VAR
      isReplace    : boolean;
      requiredPriv : tak00_PrivilegeSet;
      b_err        : tgg00_BasisError;
      kind         : tgg00_Linkset;
      trigger_name : tsp00_KnlIdentifier;
      a11v         : tak_a11_glob;
 
BEGIN
IF  acv.a_ap_tree^[acv.a_ap_tree^[0].n_lo_level].n_subproc in
    [cak_i_break, cak_i_cancel, cak_i_continue, cak_i_delete, cak_i_next,
    cak_i_show, cak_i_session, cak_i_stop, cak_i_wait]
THEN
    ak262DebugStatement(acv)
ELSE
    WITH acv, a11v DO
        BEGIN
        isReplace := (acv.a_cmd_segment_header.sp1c_producer = sp1pr_kernel) AND
              (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc <> cak_i_drop); (* PTS 1112134 *)
        acv.a_p_arr2.pcount := 0;
        IF  NOT isReplace
        THEN
            a10_cache_delete (acv, NOT c_is_rollback);
        (*ENDIF*) 
        a11glob_init (acv, a11v);
        a1ti := a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
        a05identifier_get (acv, a1ti,
              sizeof (trigger_name), trigger_name);
        WITH a_ap_tree^[ a1ti ] DO
            BEGIN
            a1ci := n_pos;
            a1ti := n_lo_level
            END;
        (*ENDWITH*) 
        IF  acv.a_isReplicationUser
        THEN
            requiredPriv := []
        ELSE
            requiredPriv := [ r_owner ];
        (*ENDIF*) 
        a11get_check_table (acv, false, true, true, requiredPriv,
              NOT c_any_priv, cak262_all_base, d_fix, a1ti,
              a1authname, a1tablen, a_p_arr1);
        IF  NOT isReplace AND (a_returncode = 0)
        THEN
            BEGIN
            a262exist_trigger (acv, trigger_name, a_p_arr2, kind);
            IF  (kind = [])
                AND
                (a_ap_tree^[a_ap_tree^[0].n_lo_level].n_subproc in
                [cak_i_alter, cak_i_drop])
            THEN
                a07_nb_put_error (acv, e_unknown_trigger,
                      a1ci, trigger_name)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            CASE a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc OF
                cak_i_alter :
                    ak262alter_trigger (acv, a1ci);
                cak_i_create :
                    ak262create_trigger (acv, a11v, trigger_name);
                cak_i_drop :
                    ak262drop_trigger   (acv, trigger_name);
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        IF  NOT isReplace AND (a_returncode = 0)
        THEN
            a10_version (acv,
                  a_p_arr1.pbasep^.sbase, m_succ_file_version, true);
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            a10repl_sysinfo (acv,
                  a_p_arr1.pbasep, b_err);
            IF  b_err <> e_ok
            THEN
                a07_b_put_error (acv, b_err, 1)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  a_returncode <> 0
        THEN
            BEGIN
            a10_cache_delete (acv, c_is_rollback);
            a_part_rollback := true
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262DebugStatement(VAR acv : tak_all_command_glob);
 
VAR
      exists        : boolean;
      e             : tgg00_BasisError;
      pos           : integer;
      ix            : integer;
      jx            : integer;
      ti            : integer;
      pos_ti        : integer;
      paramNo       : integer;
      step          : integer;
      subproc       : integer;
      mainSubproc   : integer;
      session       : tsp00_Int4;
      codePos       : tsp00_Int4;
      bestPos       : tsp00_Int4;
      breakPos      : integer;
      sessionC4     : tgg91_SessionNo;
      listenerC4    : tgg91_SessionNo;
      pMethod       : tak_sysbufferaddress;
      pDebugInfo    : tak_sysbufferaddress;
      parsid        : tak_parsid;
      triggerPtrArr : tak_syspointerarr;
      triggerKind   : tgg00_Linkset;
      owner         : tsp00_KnlIdentifier;
      dbproc        : tsp00_KnlIdentifier;
      new_old       : tsp00_KnlIdentifier;
      variable      : tsp00_KnlIdentifier;
      tableName     : tsp00_KnlIdentifier;
      triggerName   : tsp00_KnlIdentifier;
      sysk          : tgg00_SysInfoKey;
      shortinfo     : tak_shortinforecord;
      executeInfo   : tak262DebugExecuteInfo;
 
BEGIN
ti          := acv.a_ap_tree^[0].n_lo_level;
mainSubproc := acv.a_ap_tree^[ ti ].n_subproc;
CASE mainSubproc OF
    cak_i_session :
        BEGIN
        ti := acv.a_ap_tree^[ti].n_sa_level;
        a05_int4_unsigned_get (acv,
              acv.a_ap_tree^[ti].n_pos,
              acv.a_ap_tree^[ti].n_length,
              session);
        gg06SessionBecomes (sessionC4, session);
        ti := acv.a_ap_tree^[ti].n_sa_level;
        a05_int4_unsigned_get (acv,
              acv.a_ap_tree^[ti].n_pos,
              acv.a_ap_tree^[ti].n_length,
              session);
        gg06SessionBecomes (listenerC4, session);
        a51SetDebugSession (acv, sessionC4, listenerC4);
        END;
    cak_i_break, cak_i_delete :
        BEGIN
        codePos  := -1;
        pos_ti   := acv.a_ap_tree^[ti].n_lo_level;
        IF  pos_ti <> 0
        THEN
            BEGIN
            a05_int4_unsigned_get (acv,
                  acv.a_ap_tree^[pos_ti].n_pos,
                  acv.a_ap_tree^[pos_ti].n_length,
                  codePos);
            IF  (mainSubproc <> cak_i_delete) AND
                g01unicode AND (acv.a_out_packet^.sp1_header.sp1h_mess_code = csp_ascii)
            THEN
                codePos := (codePos - 1) * 2 + 1;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        ti      := acv.a_ap_tree^[ti].n_sa_level;
        subproc := acv.a_ap_tree^[ ti ].n_subproc;
        CASE subproc OF
            cak_i_function, cak_i_dbproc, cak_i_dbprocedure : (* breakpoint at db-procedure or db-function *)
                BEGIN
                ti := acv.a_ap_tree^[ti].n_sa_level;
                a260get_proc (acv, owner, dbproc, ti);
                IF  subproc = cak_i_function
                THEN
                    exists := a12dbfunc_exist (acv, owner, dbproc, d_fix, pMethod)
                ELSE
                    exists := a12dbproc_exist (acv, owner, dbproc, d_fix, pMethod);
                (*ENDIF*) 
                IF  exists
                THEN
                    IF  mainSubproc = cak_i_delete
                    THEN (* delete a breakpoint *)
                        a101_DebuggerAddRemoveBreakPoint (acv, pMethod^.smethod.me_surrogate, subproc, 1, codePos, true)
                    ELSE
                        BEGIN
                        IF  pMethod^.smethod.me_owner <> acv.a_curr_user_id
                        THEN (* Check call privilege of current user *)
                            a260check_priv (acv,
                                  pMethod^.smethod.me_surrogate, acv.a_curr_user_id);
                        (*ENDIF*) 
                        IF  acv.a_returncode = 0
                        THEN
                            BEGIN
                            sysk           := a01defaultkey;
                            sysk.stableid  := pMethod^.smethod.me_surrogate;
                            sysk.sentrytyp := cak_emethoddebuginfo;
                            a10get_sysinfo (acv, sysk, d_release, pDebugInfo, e);
                            IF  e = e_ok
                            THEN
                                IF  codePos = -1
                                THEN
                                    pos := pDebugInfo^.smethoddebuginfo.med_info[1].dbg_stack_entry_index
                                ELSE
                                    BEGIN
                                    bestPos := csp_maxint4;
                                    FOR ix := 1 TO pDebugInfo^.smethoddebuginfo.med_count DO
                                        WITH pDebugInfo^.smethoddebuginfo.med_info[ix] DO
                                            IF  (dbg_code_pos >= codePos) AND (dbg_code_pos < bestPos)
                                            THEN
                                                BEGIN
                                                bestPos := dbg_code_pos;
                                                breakPos:= dbg_stack_entry_index;
                                                END;
                                            (*ENDIF*) 
                                        (*ENDWITH*) 
                                    (*ENDFOR*) 
                                    END
                                (*ENDIF*) 
                            ELSE
                                a07_b_put_error (acv, e, 1)
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  acv.a_returncode = 0
                        THEN
                            BEGIN
                            a101_DebuggerAddRemoveBreakPoint (acv, pMethod^.smethod.me_surrogate, subproc, 1, breakPos, false);
                            END
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                ELSE
                    a07_b_put_error (acv, e_unknown_procedure_name, 1)
                (*ENDIF*) 
                END;
            cak_i_trigger :
                BEGIN
                ti := acv.a_ap_tree^[ti].n_sa_level;
                a05identifier_get (acv, ti, sizeof(triggerName), triggerName);
                ti    := acv.a_ap_tree^[ti].n_sa_level;
                owner := a01_il_b_identifier;
                a06get_username (acv, ti, owner);
                a05identifier_get (acv, ti, sizeof(tableName), tableName);
                IF  a06_table_exist (acv, d_fix, owner, tableName, acv.a_p_arr1, true)
                THEN
                    BEGIN
                    a262exist_trigger (acv, triggerName, triggerPtrArr, triggerKind);
                    IF  triggerKind <> []
                    THEN
                        BEGIN
                        FOR ix := 1 TO triggerPtrArr.pcount DO
                            BEGIN
                            sysk           := triggerPtrArr.px[ix]^.syskey;
                            sysk.sentrytyp := cak_emethoddebuginfo;
                            a10get_sysinfo (acv, sysk, d_release, pDebugInfo, e);
                            IF  e = e_ok
                            THEN
                                BEGIN
                                IF  mainSubproc = cak_i_delete
                                THEN (* delete a breakpoint *)
                                    breakPos := codePos
                                ELSE
                                    IF  codePos = -1
                                    THEN
                                        pos := pDebugInfo^.smethoddebuginfo.med_info[1].dbg_stack_entry_index
                                    ELSE
                                        BEGIN
                                        bestPos := csp_maxint4;
                                        FOR jx := 1 TO pDebugInfo^.smethoddebuginfo.med_count DO
                                            WITH pDebugInfo^.smethoddebuginfo.med_info[jx] DO
                                                IF  (dbg_code_pos >= codePos) AND (dbg_code_pos < bestPos)
                                                THEN
                                                    BEGIN
                                                    bestPos  := dbg_code_pos;
                                                    breakPos := dbg_stack_entry_index;
                                                    END;
                                                (*ENDIF*) 
                                            (*ENDWITH*) 
                                        (*ENDFOR*) 
                                        END;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                a101_DebuggerAddRemoveBreakPoint (acv, triggerPtrArr.px[ix]^.strigger.tr_surrogate,
                                      cak_i_trigger, ord(sysk.slinkage[2]), breakPos, mainSubproc = cak_i_delete);
                                END
                            ELSE
                                a07_b_put_error (acv, e, 1)
                            (*ENDIF*) 
                            END;
                        (*ENDFOR*) 
                        END
                    ELSE
                        a07_nb_put_error (acv, e_unknown_trigger, 1, triggerName)
                    (*ENDIF*) 
                    END
                ELSE
                    a07_nb_put_error (acv, e_unknown_tablename, 1, tableName)
                (*ENDIF*) 
                END;
            END;
        (*ENDCASE*) 
        IF  (acv.a_returncode = 0) AND (mainSubproc = cak_i_break)
        THEN
            BEGIN
            executeInfo.dei_type     := cak_i_break;
            executeInfo.dei_position := bestPos;
            executeInfo.dei_breakPos := breakPos;
            a101_DebuggerStoreExecuteInfo (@executeInfo, sizeof(executeInfo));
            parsid.pid_session       := acv.a_transinf.tri_trans.trSessionId_gg00;
            parsid.pid_parsk         := acv.a_pars_last_key;
            parsid.pid_parsk.p_kind  := m_get_object;
            parsid.pid_appl_info [1] := chr(ord(acv.a_precomp_info_byte));
            parsid.pid_dtime_info[1] := chr(ord(dtf_none));
            a06retpart_move        (acv, @parsid, sizeof (parsid));
            a06finish_curr_retpart (acv, sp1pk_parsid, 1);
            pos     := 1;
            paramNo := 1;
            WITH shortinfo.siinfo[paramNo] DO
                BEGIN
                sp1i_mode       := [ sp1ot_mandatory ];
                sp1i_io_type    := sp1io_output;
                sp1i_data_type  := dfixed;
                sp1i_frac       := 0;
                sp1i_length     := 10;
                sp1i_in_out_len := 7;
                sp1i_bufpos     := pos;
                pos             := pos + sp1i_in_out_len
                END;
            (*ENDWITH*) 
            paramNo := paramNo + 1;
            WITH shortinfo.siinfo[paramNo] DO
                BEGIN
                sp1i_mode       := [ sp1ot_mandatory ];
                sp1i_io_type    := sp1io_output;
                sp1i_data_type  := dfixed;
                sp1i_frac       := 0;
                sp1i_length     := 10;
                sp1i_in_out_len := 7;
                sp1i_bufpos     := pos;
                pos             := pos + sp1i_in_out_len
                END;
            (*ENDWITH*) 
            shortinfo.sicount := paramNo;
            a06retpart_move (acv, @shortinfo.siinfo,
                  shortinfo.sicount * sizeof (shortinfo.siinfo[1]));
            a06finish_curr_retpart (acv, sp1pk_shortinfo, paramNo);
            END;
        (*ENDIF*) 
        END;
    cak_i_cancel :
        a101_DebuggerStep (acv, -10);
    cak_i_continue :
        a101_DebuggerStep (acv, -1);
    cak_i_next :
        BEGIN
        ti := acv.a_ap_tree^[ti].n_sa_level;
        IF  ti = 0
        THEN
            step := 1
        ELSE
            IF  acv.a_ap_tree^[ti].n_symb = s_unknown
            THEN
                IF  acv.a_ap_tree^[ti].n_subproc = cak_i_into
                THEN
                    step := 0
                ELSE
                    step := -3
                (*ENDIF*) 
            ELSE
                BEGIN
                a05_int4_unsigned_get (acv,
                      acv.a_ap_tree^[ti].n_pos,
                      acv.a_ap_tree^[ti].n_length,
                      step);
                IF  step <= 0
                THEN
                    a07_b_put_error (acv, e_invalid, 1)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        a101_DebuggerStep (acv, step);
        END;
    cak_i_show :
        BEGIN
        ti      := acv.a_ap_tree^[ti].n_sa_level;
        new_old := a01_il_b_identifier;
        IF  acv.a_ap_tree^[ti].n_sa_level <> 0
        THEN
            BEGIN
            a05identifier_get (acv, ti, sizeof(new_old), new_old);
            IF  (new_old <> a01_i_new) AND (new_old <> a01_i_old)
            THEN
                a07_b_put_error (acv, e_unknown_name, 1);
            (*ENDIF*) 
            ti := acv.a_ap_tree^[ti].n_sa_level;
            END;
        (*ENDIF*) 
        a05identifier_get (acv, ti, sizeof(variable), variable);
        IF  (acv.a_ex_kind = only_parsing) AND (acv.a_returncode = 0)
        THEN
            BEGIN
            executeInfo.dei_type        := cak_i_show;
            executeInfo.dei_identifier1 := new_old;
            executeInfo.dei_identifier2 := variable;
            a101_DebuggerStoreExecuteInfo (@executeInfo, sizeof(executeInfo));
            parsid.pid_session       := acv.a_transinf.tri_trans.trSessionId_gg00;
            parsid.pid_parsk         := acv.a_pars_last_key;
            parsid.pid_parsk.p_kind  := m_get_object;
            parsid.pid_appl_info [1] := chr(ord(acv.a_precomp_info_byte));
            parsid.pid_dtime_info[1] := chr(ord(dtf_none));
            a06retpart_move        (acv, @parsid, sizeof (parsid));
            a06finish_curr_retpart (acv, sp1pk_parsid, 1);
            pos     := 1;
            paramNo := 1;
            WITH shortinfo.siinfo[paramNo] DO
                BEGIN
                sp1i_mode       := [ sp1ot_mandatory ];
                sp1i_io_type    := sp1io_output;
                sp1i_length     := 4000;
                IF  acv.a_out_packet^.sp1_header.sp1h_mess_code = csp_ascii
                THEN
                    BEGIN
                    sp1i_data_type  := dcha;
                    sp1i_in_out_len := sp1i_length + 1;
                    END
                ELSE
                    BEGIN
                    sp1i_data_type  := dunicode;
                    sp1i_in_out_len := 2* sp1i_length + 1;
                    END;
                (*ENDIF*) 
                sp1i_frac       := 0;
                sp1i_bufpos     := pos;
                pos             := pos + sp1i_in_out_len
                END;
            (*ENDWITH*) 
            shortinfo.sicount := paramNo;
            a06retpart_move (acv, @shortinfo.siinfo,
                  shortinfo.sicount * sizeof (shortinfo.siinfo[1]));
            a06finish_curr_retpart (acv, sp1pk_shortinfo, paramNo);
            END
        ELSE
            a07_b_put_error (acv, e_invalid, 1)
        (*ENDIF*) 
        END;
    cak_i_stop :
        a101_DebuggerStep (acv, -2);
    cak_i_wait :
        IF  acv.a_ex_kind = only_parsing
        THEN
            BEGIN
            parsid.pid_session       := acv.a_transinf.tri_trans.trSessionId_gg00;
            parsid.pid_parsk         := acv.a_pars_last_key;
            parsid.pid_parsk.p_kind  := m_debug;
            parsid.pid_appl_info [1] := chr(ord(acv.a_precomp_info_byte));
            parsid.pid_dtime_info[1] := chr(ord(dtf_none));
            a06retpart_move        (acv, @parsid, sizeof (parsid));
            a06finish_curr_retpart (acv, sp1pk_parsid, 1);
            pos     := 1;
            paramNo := 1;
            WITH shortinfo.siinfo[paramNo] DO
                BEGIN
                sp1i_mode       := [ sp1ot_mandatory ];
                sp1i_io_type    := sp1io_output;
                sp1i_data_type  := dcha;
                sp1i_frac       := 0;
                sp1i_length     := 8;
                sp1i_in_out_len := 9;
                sp1i_bufpos     := pos;
                pos             := pos + sp1i_in_out_len
                END;
            (*ENDWITH*) 
            paramNo := paramNo + 1;
            WITH shortinfo.siinfo[paramNo] DO
                BEGIN
                sp1i_mode       := [ sp1ot_mandatory ];
                sp1i_io_type    := sp1io_output;
                sp1i_data_type  := dcha;
                sp1i_frac       := 0;
                sp1i_length     := 32;
                sp1i_in_out_len := 33;
                sp1i_bufpos     := pos;
                pos             := pos + sp1i_in_out_len
                END;
            (*ENDWITH*) 
            paramNo := paramNo + 1;
            WITH shortinfo.siinfo[paramNo] DO
                BEGIN
                sp1i_mode       := [ sp1ot_mandatory ];
                sp1i_io_type    := sp1io_output;
                sp1i_data_type  := dcha;
                sp1i_frac       := 0;
                sp1i_length     := 32;
                sp1i_in_out_len := 33;
                sp1i_bufpos     := pos;
                pos             := pos + sp1i_in_out_len
                END;
            (*ENDWITH*) 
            paramNo := paramNo + 1;
            WITH shortinfo.siinfo[paramNo] DO
                BEGIN
                sp1i_mode       := [ sp1ot_mandatory ];
                sp1i_io_type    := sp1io_output;
                sp1i_data_type  := dcha;
                sp1i_frac       := 0;
                sp1i_length     := 32;
                sp1i_in_out_len := 33;
                sp1i_bufpos     := pos;
                pos             := pos + sp1i_in_out_len
                END;
            (*ENDWITH*) 
            paramNo := paramNo + 1;
            WITH shortinfo.siinfo[paramNo] DO
                BEGIN
                sp1i_mode       := [ sp1ot_mandatory ];
                sp1i_io_type    := sp1io_output;
                sp1i_data_type  := dfixed;
                sp1i_frac       := 0;
                sp1i_length     := 10;
                sp1i_in_out_len := 7;
                sp1i_bufpos     := pos;
                pos             := pos + sp1i_in_out_len
                END;
            (*ENDWITH*) 
            paramNo := paramNo + 1;
            WITH shortinfo.siinfo[paramNo] DO
                BEGIN
                sp1i_mode       := [ sp1ot_mandatory ];
                sp1i_io_type    := sp1io_output;
                sp1i_data_type  := dfixed;
                sp1i_frac       := 0;
                sp1i_length     := 10;
                sp1i_in_out_len := 7;
                sp1i_bufpos     := pos;
                pos             := pos + sp1i_in_out_len
                END;
            (*ENDWITH*) 
            shortinfo.sicount := paramNo;
            a06retpart_move (acv, @shortinfo.siinfo,
                  shortinfo.sicount * sizeof (shortinfo.siinfo[1]));
            a06finish_curr_retpart (acv, sp1pk_shortinfo, paramNo);
            END
        ELSE
            a07_b_put_error (acv, e_invalid, 1)
        (*ENDIF*) 
    END;
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262Debug (VAR acv : tak_all_command_glob;
            debugListen : boolean);
 
VAR
      ok             : boolean;
      truncated      : boolean;
      e              : tgg00_BasisError;
      ix             : integer;
      pos            : integer;
      codePos        : integer;
      length         : integer;
      procKind       : integer;
      linkage        : integer;
      size           : integer;
      idLength       : integer;
      outLength      : integer;
      err_char_no    : tsp00_Int4;
      destLength     : tsp00_Int4;
      uni_err        : tsp8_uni_error;
      pC8            : ^tsp00_C8;
      pId            : ^tsp00_KnlIdentifier;
      methodId       : tgg00_Surrogate;
      res            : tsp00_NumError;
      pMethodInfo    : tak_sysbufferaddress;
      pBase          : tak_sysbufferaddress;
      pDebugInfo     : tak_sysbufferaddress;
      pTrigger       : tak_sysbufferaddress;
      sysk           : tgg00_SysInfoKey;
      triggerKey     : tgg00_SysInfoKey;
      retBuf         : tsp00_Buf;
      pMoveObj       : tsp00_MoveObjPtr;
      pVariable      : tsp00_MoveObjPtr;
      pTriggerValues : tsp00_MoveObjPtr;
      name           : tsp00_C8;
      objKind        : tsp00_C8;
      new_old        : tsp00_KnlIdentifier;
      variable       : tsp00_KnlIdentifier;
      owner          : tsp00_KnlIdentifier;
      objName        : tsp00_KnlIdentifier;
      triggerName    : tsp00_KnlIdentifier;
      pCol           : tak00_colinfo_ptr;
      msg            : tsp00_C30;
      executeInfo    : tak262DebugExecuteInfo;
 
BEGIN
sysk := a01defaultkey;
IF  debugListen
THEN
    BEGIN
    a101_DebuggerListen(acv, methodId, procKind, linkage, codePos, length);
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        a262GetObjectName (acv, methodId, procKind, linkage, objKind, owner, objName, triggerName);
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            name := 'TYPE    ';
            a06colname_retpart_move (acv, @name, 4, csp_ascii);
            name := 'SCHEMA  ';
            a06colname_retpart_move (acv, @name, 5, csp_ascii);
            name := 'NAME    ';
            a06colname_retpart_move (acv, @name, 4, csp_ascii);
            name := 'TRIGGER ';
            a06colname_retpart_move (acv, @name, 7, csp_ascii);
            name := 'POS     ';
            a06colname_retpart_move (acv, @name, 3, csp_ascii);
            name := 'LENGTH  ';
            a06colname_retpart_move (acv, @name, 6, csp_ascii);
            a06finish_curr_retpart (acv, sp1pk_columnnames, 6);
            pos         := 1;
            retBuf[pos] := csp_ascii_blank;
            pC8         := @retBuf[pos+1];
            pC8^        := objKind;
            pos         := pos + 1 + sizeof(pC8^);
            retBuf[pos] := csp_ascii_blank;
            pId         := @retBuf[pos+1];
            idLength    := sizeof(owner);
            IF  g01unicode
            THEN
                s80uni_trans (@owner, sizeof(owner),
                      csp_unicode, @pId^, idLength,
                      acv.a_out_packet^.sp1_header.sp1h_mess_code, [ ],
                      uni_err, err_char_no)
            ELSE
                pId^ := owner;
            (*ENDIF*) 
            pos         := pos + 1 + 32;
            retBuf[pos] := csp_ascii_blank;
            pId         := @retBuf[pos+1];
            idLength    := sizeof(objName);
            IF  g01unicode
            THEN
                s80uni_trans (@objName, sizeof(objName),
                      csp_unicode, @pId^, idLength,
                      acv.a_out_packet^.sp1_header.sp1h_mess_code, [ ],
                      uni_err, err_char_no)
            ELSE
                pId^ := objName;
            (*ENDIF*) 
            pos         := pos + 1 + 32;
            retBuf[pos] := csp_ascii_blank;
            pId         := @retBuf[pos+1];
            IF  g01unicode
            THEN
                s80uni_trans (@triggerName, sizeof(triggerName),
                      csp_unicode, @pId^, idLength,
                      acv.a_out_packet^.sp1_header.sp1h_mess_code, [ ],
                      uni_err, err_char_no)
            ELSE
                pId^ := triggerName;
            (*ENDIF*) 
            pos         := pos + 1 + 32;
            retBuf[pos] := chr(0);
            pMoveObj    := @retBuf[pos+1];
            IF  g01unicode AND (acv.a_cmd_packet_header.sp1h_mess_code = csp_ascii) AND (codePos > 1)
            THEN
                codePos := (codePos - 1) DIV 2 + 1;
            (*ENDIF*) 
            s41plint (pMoveObj^, 1, 10, 0, codePos, res);
            pos         := pos + 7;
            retBuf[pos] := chr(0);
            pMoveObj    := @retBuf[pos+1];
            s41plint (pMoveObj^, 1, 10, 0, length, res);
            a06retpart_move (acv, @retBuf, pos + 7 - 1);
            a06finish_curr_retpart (acv, sp1pk_data, 1);
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
ELSE
    BEGIN
    a101_DebuggerGetExecuteInfo (@executeInfo, sizeof(executeInfo));
    IF  executeInfo.dei_type = cak_i_break
    THEN
        BEGIN
        name := 'POS     ';
        a06colname_retpart_move (acv, @name, 3, csp_ascii);
        name := 'BREAKID ';
        a06colname_retpart_move (acv, @name, 7, csp_ascii);
        a06finish_curr_retpart (acv, sp1pk_columnnames, 2);
        pos         := 1;
        retBuf[pos] := csp_defined_byte;
        pMoveObj    := @retBuf[pos+1];
        IF  g01unicode AND
            (acv.a_cmd_packet_header.sp1h_mess_code = csp_ascii) AND
            (executeInfo.dei_position > 1)
        THEN
            codePos := (executeInfo.dei_position - 1) DIV 2 + 1
        ELSE
            codePos := executeInfo.dei_position;
        (*ENDIF*) 
        s41plint (pMoveObj^, 1, 10, 0,  codePos, res);
        pos := pos + 7;
        retBuf[pos] := csp_defined_byte;
        pMoveObj    := @retBuf[pos+1];
        s41plint (pMoveObj^, 1, 10, 0, executeInfo.dei_breakPos, res);
        a06retpart_move (acv, @retBuf, pos + 7 - 1);
        a06finish_curr_retpart (acv, sp1pk_data, 1);
        END
    ELSE
        BEGIN
        a101_DebuggerGetMethodInfo (acv, sysk.stableid, procKind, linkage, pTriggerValues, pMoveObj);
        IF  procKind = cak_i_trigger
        THEN
            BEGIN
            triggerKey := a01defaultkey;
            triggerKey.stableid     := sysk.stableid;
            triggerKey.sentrytyp    := cak_etrigger;
            triggerKey.slinkage[2]  := chr(linkage);
            a10get_sysinfo (acv, triggerKey, d_release, pTrigger, e);
            IF  e = e_ok
            THEN
                BEGIN
                sysk.stableid := pTrigger^.strigger.tr_proc_id;
                a10get_sysinfo (acv, sysk, d_release, pMethodInfo, e);
                END
            (*ENDIF*) 
            END
        ELSE
            a10get_sysinfo (acv, sysk, d_release, pMethodInfo, e);
        (*ENDIF*) 
        IF  e = e_ok
        THEN
            BEGIN
            new_old  := executeInfo.dei_identifier1;
            variable := executeInfo.dei_identifier2;
            IF  acv.a_out_packet^.sp1_header.sp1h_mess_code = csp_ascii
            THEN
                BEGIN
                outLength := 4000;
                FOR pos := 1 TO outLength + 1 DO
                    retBuf[pos] := bsp_c1;
                (*ENDFOR*) 
                END
            ELSE
                BEGIN
                outLength := 8000;
                END;
            (*ENDIF*) 
            IF  a061exist_columnname (pMethodInfo^.sbase, variable, pCol)
            THEN
                BEGIN
                length := pCol^.cdatalen;
                IF  (procKind = cak_i_trigger) AND false (* TODO *)
                THEN
                    BEGIN
                    sysk.sentrytyp   := cak_emethoddebuginfo;
                    sysk.slinkage[1] := chr(1);
                    sysk.slinkage[2] := chr(linkage);
                    a10get_sysinfo (acv, sysk, d_release, pDebugInfo, e);
                    IF  e = e_ok
                    THEN
                        BEGIN
                        ix        := 1;
                        pVariable := NIL;
                        WHILE ix <= pDebugInfo^.smethoddebuginfo.med_count DO
                            WITH pDebugInfo^.smethoddebuginfo.med_mapping[ix] DO
                                BEGIN
                                IF  (pCol^.creccolno = dmi_extcolno MOD cak262_old_flag)
                                    AND
                                    (
                                    ((dmi_extcolno > cak262_old_flag) AND (new_old = a01_i_old)) OR
                                    ((dmi_extcolno < cak262_old_flag) AND (new_old = a01_i_new))
                                    )
                                THEN
                                    BEGIN
                                    ix        := pDebugInfo^.smethoddebuginfo.med_count + 1;
                                    pVariable := @pTriggerValues^[cgg_rec_key_offset + TriggerKeyLen_cgg04 + dmi_rec_pos];
                                    END
                                ELSE
                                    ix := ix + 1;
                                (*ENDIF*) 
                                END;
                            (*ENDWITH*) 
                        (*ENDWHILE*) 
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    IF  pCol^.ccolstack.etype = st_param
                    THEN
                        a101_DebuggerGetFunctionParameter (acv, pCol^.ccolstack,
                              pVariable, length)
                    ELSE
                        pVariable := @pMoveObj^[cgg_rec_key_offset + pCol^.ccolstack.epos];
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  pVariable = NIL
                THEN
                    a07_b_put_error (acv, e_unknown_name, 1)
                ELSE
                    IF  pVariable^[1] = csp_undef_byte
                    THEN
                        retBuf[1] := csp_undef_byte
                    ELSE
                        BEGIN
                        retBuf[1] := csp_defined_byte;
                        CASE pCol^.cdatatyp OF
                            dboolean :
                                BEGIN
                                retBuf[1] := csp_ascii_blank;
                                IF  pVariable^[2] = chr(0)
                                THEN
                                    retBuf[2] := 'T'
                                ELSE
                                    retBuf[2] := 'F';
                                (*ENDIF*) 
                                END;
                            dinteger, dfixed, dfloat, dsmallint :
                                BEGIN
                                s42gchr (pVariable^, 2, length,
                                      pCol^.cdatafrac - cak_frac_offset, pCol^.cdatalen,
                                      retBuf, 2, length, res);
                                IF  res <> num_ok
                                THEN
                                    retBuf[1] := csp_undef_byte;
                                (*ENDIF*) 
                                END;
                            dcha, ddate, dtime, dtimestamp :
                                SAPDB_PascalMove ('VAK262',  26,    
                                      sizeof(tsp00_MoveObj), sizeof(retBuf),
                                      pVariable, 2, @retBuf, 2, length, acv.a_returncode);
                            dchb :
                                BEGIN
                                size := 2 * length;
                                IF  size > sizeof (retBuf) - 1
                                THEN
                                    size := sizeof (retBuf) - 1;
                                (*ENDIF*) 
                                s40gbyte (pVariable^, 2, length,
                                      retBuf, 2, size, truncated);
                                END;
                            dunicode :
                                BEGIN
                                IF  acv.a_out_packet^.sp1_header.sp1h_mess_code = csp_ascii
                                THEN
                                    retBuf[1]  := csp_ascii_blank
                                ELSE
                                    retBuf[1]  := csp_unicode_def_byte;
                                (*ENDIF*) 
                                destLength := outLength;
                                s80uni_trans (@pVariable^[2], pCol^.cinoutlen - 1,
                                      csp_unicode,
                                      @retBuf[2], destLength, acv.a_out_packet^.sp1_header.sp1h_mess_code, [uni_fillup_field],
                                      uni_err, err_char_no);
                                IF  uni_err <> uni_ok
                                THEN
                                    a07_uni_error (acv, uni_err, err_char_no);
                                (*ENDIF*) 
                                END;
                            OTHERWISE
                                BEGIN
                                msg := 'cannot display this type      ';
                                a07_const_b_put_error (acv, e_not_implemented, 1,
                                      @msg, sizeof(msg));
                                END;
                            END;
                        (*ENDCASE*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  acv.a_returncode = 0
                THEN
                    BEGIN
                    name := 'VALUE   ';
                    a06colname_retpart_move (acv, @name, 5, csp_ascii);
                    a06finish_curr_retpart (acv, sp1pk_columnnames, 1);
                    a06retpart_move (acv, @retBuf, 1 + outLength);
                    a06finish_curr_retpart (acv, sp1pk_data, 1);
                    END;
                (*ENDIF*) 
                END
            ELSE
                a07_b_put_error (acv, e_unknown_name, 1);
            (*ENDIF*) 
            END
        ELSE
            a07_b_put_error (acv, e, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262GetObjectName (
            VAR acv         : tak_all_command_glob;
            VAR methodId    : tgg00_Surrogate;
            procKind        : integer;
            linkage         : integer;
            VAR objKind     : tsp00_C8;
            VAR schema      : tsp00_KnlIdentifier;
            VAR objName     : tsp00_KnlIdentifier;
            VAR triggerName : tsp00_KnlIdentifier);
 
VAR
      ok          : boolean;
      e           : tgg00_BasisError;
      pMethodInfo : tak_sysbufferaddress;
      pBase       : tak_sysbufferaddress;
      sysk        : tgg00_SysInfoKey;
 
BEGIN
e := e_ok;
CASE procKind OF
    cak_i_function, cak_i_dbproc, cak_i_dbprocedure :
        BEGIN
        sysk           := a01defaultkey;
        sysk.stableid  := methodId;
        sysk.sentrytyp := cak_emethodinfo;
        a10get_sysinfo (acv, sysk, d_release, pMethodInfo, e);
        IF  e = e_ok
        THEN
            BEGIN
            IF  procKind = cak_i_function
            THEN
                objKind := 'DBFUNC  '
            ELSE
                objKind := 'DBPROC  ';
            (*ENDIF*) 
            a103GetSchemaName (acv,
                  pMethodInfo^.smethodinfo.mei_schema, schema);
            objName     := pMethodInfo^.smethodinfo.mei_name;
            triggerName := a01_il_b_identifier;
            END;
        (*ENDIF*) 
        END;
    cak_i_trigger :
        BEGIN
        a06_systable_get (acv, d_release, methodId, pBase, true, ok);
        IF  ok
        THEN
            BEGIN
            objKind := 'TRIGGER ';
            a103GetSchemaName (acv,
                  pBase^.sbase.bschema, schema);
            objName          := pBase^.sbase.btablen^;
            sysk.skeylen     := mxak_standard_sysk;
            sysk.stableid    := methodId;
            sysk.sentrytyp   := cak_etrigger;
            sysk.slinkage[1] := chr(0);
            sysk.slinkage[2] := chr(linkage);
            a10get_sysinfo (acv, sysk, d_release, pMethodInfo, e);
            IF  e = e_ok
            THEN
                a262get_trigger_name (pMethodInfo^.strigger, triggerName, e);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    END;
(*ENDCASE*) 
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262check_parameters (
            VAR acv      : tak_all_command_glob;
            trig_ptr     : tak_sysbufferaddress;
            VAR proc_buf : tak_sysbufferaddress);
 
VAR
      datatype          : tsp00_DataType;
      error             : tgg00_BasisError;
      is_old            : integer;
      param_index       : integer;
      param_count       : integer;
      param_io_len      : integer;
      trigger_param_cnt : integer;
      row_len           : integer;
      pi                : integer;
      tr_offset         : integer;
      name_pos          : integer;
      name_len          : integer;
      ioLength          : integer;
      col_ptr           : tak00_colinfo_ptr;
      parameter_name    : tsp00_KnlIdentifier;
      old_new_set       : ARRAY [ 0..1 ] OF tak_columnset;
 
BEGIN
WITH acv DO
    BEGIN
    trigger_param_cnt := 0;
    param_count       := proc_buf^.smethod.me_param_cnt;
    param_index       := 1;
    old_new_set[ 0 ]  := [  ];
    old_new_set[ 1 ]  := [  ];
    row_len           := cgg_rec_key_offset +  TriggerKeyLen_cgg04;
    tr_offset         := (trig_ptr^.strigger.tr_name_len - 1) DIV
          sizeof (trig_ptr^.strigger.tr_stack[1]) + 1;
    pi                := 1;
    WHILE (param_count > 0) AND (a_returncode = 0) DO
        BEGIN
        IF  trig_ptr^.syskey.slinkage <> cak_ins_trigger_linkage
        THEN
            is_old := 1
        ELSE
            is_old := 0;
        (*ENDIF*) 
        error  := e_ok;
        WITH proc_buf^.smethod.me_param_list[param_index]^ DO
            BEGIN
            param_state := param_undef;
            name_pos := 1;
            name_len := ord (param_name_len);
            IF  name_len >= 3
            THEN
                BEGIN
                IF  (param_name[1] = 'O') AND
                    (param_name[2] = 'L') AND
                    (param_name[3] = 'D')
                THEN
                    BEGIN
                    name_pos      := 4;
                    name_len      := name_len - 3;
                    param_state := param_old
                    END
                ELSE
                    IF  (param_name[1] = 'N') AND
                        (param_name[2] = 'E') AND
                        (param_name[3] = 'W')
                    THEN
                        BEGIN
                        name_pos      := 4;
                        name_len      := name_len - 3;
                        param_state := param_new
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  name_len <= sizeof (parameter_name)
            THEN
                BEGIN
                parameter_name := a01_il_b_identifier;
                SAPDB_PascalMove ('VAK262',  27,    
                      ord (param_name_len), sizeof (parameter_name),
                      @param_name, name_pos, @parameter_name, 1, name_len,
                      a_returncode);
                IF  param_state = param_old
                THEN
                    BEGIN
                    IF  is_old = 0
                    THEN
                        error := e_invalid_parameter
                    (*ENDIF*) 
                    END
                ELSE
                    IF  param_state = param_new
                    THEN
                        IF  trig_ptr^.syskey.slinkage =
                            cak_del_trigger_linkage
                        THEN
                            error := e_invalid_parameter
                        ELSE
                            is_old := 0;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                error := e_unknown_columnname;
            (*ENDIF*) 
            IF  error <> e_ok
            THEN
                a07_nb_put_error (acv, error, trigger_param_cnt + 1,
                      parameter_name);
            (*ENDIF*) 
            IF  a061exist_columnname (a_p_arr1.pbasep^.sbase,
                parameter_name, col_ptr)
            THEN
                WITH col_ptr^ DO
                    BEGIN
&                   ifdef trace
                    t01int4 (ak_sem, 'paramdatatyp', ord(param_datatype));
                    t01int4 (ak_sem, 'cdatatyp    ', ord(cdatatyp));
                    t01int4 (ak_sem, 'param_inout ', param_inoutlength);
                    t01int4 (ak_sem, 'cinoutlen   ', cinoutlen);
                    t01int4 (ak_sem, 'param_frac  ', param_datafrac);
                    t01int4 (ak_sem, 'cdatafrac   ', cdatafrac);
&                   endif
                    datatype := cdatatyp;
                    IF  (param_datatype = dunicode) AND
                        (datatype      <> dunicode)
                    THEN
                        param_io_len := param_inoutlength DIV 2 + 1
                    ELSE
                        param_io_len := param_inoutlength;
                    (*ENDIF*) 
                    IF  (cdatatyp = dfixed) AND
                        cbinary
                    THEN
                        IF  cdatalen = 5
                        THEN
                            datatype := dsmallint
                        ELSE
                            datatype := dinteger;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  ((param_datatype <> datatype)  AND
                        ((NOT (param_datatype in [dcha, dunicode])) OR
                        ( NOT (datatype       in [dcha, dunicode]))))
                        OR
                        ((param_io_len <> cinoutlen) AND
                        ( NOT (datatype in [ ddate, dtime, dtimestamp ])))
                        OR
                        ((param_datafrac <> cdatafrac)
                        AND (datatype <> dfloat))
                    THEN
                        a07_b_put_error (acv,
                              e_incompatible_datatypes,
                              trigger_param_cnt + 1)
                    ELSE
                        IF  cextcolno in old_new_set[ is_old ]
                        THEN
                            a07_b_put_error (acv,
                                  e_duplicate_columnname,
                                  trigger_param_cnt + 1);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  a_returncode = 0
                    THEN
                        WITH trig_ptr^.strigger DO
                            BEGIN
                            trigger_param_cnt     := trigger_param_cnt+1;
                            old_new_set[ is_old ] :=
                                  old_new_set[ is_old ] +
                                  [ cextcolno ];
                            tr_param_cnt := tr_param_cnt + 1;
                            CASE cdatatyp OF
                                ddate :
                                    ioLength := 1 + mxsp_date;
                                dtime :
                                    ioLength := 1 + mxsp_time;
                                dtimestamp :
                                    ioLength := 1 + mxsp_timestamp;
                                OTHERWISE
                                    ioLength := cinoutlen;
                                END;
                            (*ENDCASE*) 
                            tr_stack[tr_offset + tr_param_cnt ] := ccolstack;
                            WITH tr_stack[tr_offset + tr_param_cnt] DO
                                BEGIN
                                IF  (cdatatyp = dcha) AND
                                    g01unicode
                                THEN
                                    eop := op_translate
                                ELSE
                                    eop := op_none;
                                (*ENDIF*) 
                                elen_var    := ioLength;
                                ecol_tab[1] := chr(is_old)
                                END;
                            (*ENDWITH*) 
&                           ifdef trace
                            t01stackentry (sproc_call,
                                  tr_stack[tr_offset + tr_param_cnt], tr_offset + tr_param_cnt);
&                           endif
                            row_len := row_len + ioLength;
                            IF  row_len > sizeof (tak262TriggerParamBuffer)
                            THEN
                                a07_b_put_error (acv,
                                      e_too_long_trigger_params, 1)
                            (*ENDIF*) 
                            END;
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    END
                (*ENDWITH*) 
            ELSE
                a07_b_put_error (acv,
                      e_unknown_columnname, trigger_param_cnt);
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        param_index := param_index + 1;
        param_count := param_count - 1
        END;
    (*ENDWHILE*) 
    IF  trigger_param_cnt < param_count
    THEN
        a07_b_put_error (acv, e_too_few_columns, 1)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262create_trigger (
            VAR acv          : tak_all_command_glob;
            VAR a11v         : tak_a11_glob;
            VAR trigger_name : tsp00_KnlIdentifier);
 
VAR
      firstReplicationTrigger : boolean;
      ok                      : boolean;
      do_replace              : boolean;
      is_trigger_code         : boolean;
      is_internal             : boolean;
      compileInfo             : tak_proc_compile_type;
      linkSet                 : tgg00_Linkset;
      is_ddl                  : tak_ddl_descriptor;
      b_err                   : tgg00_BasisError;
      error                   : tgg00_BasisError;
      i                       : integer;
      param_cnt               : integer;
      col_ti                  : integer;
      kind_index              : integer;
      trigger_kind            : tak_charset;
      pUserContext            : tsp00_Addr;
      replicationUserTabId    : tgg00_Surrogate;
      col_ptr                 : tak00_colinfo_ptr;
      priv                    : tak_privilege;
      trig_ptr                : tak_sysbufferaddress;
      last_trig_ptr           : tak_sysbufferaddress;
      proc_buf                : tak_sysbufferaddress;
      col_name                : tsp00_KnlIdentifier;
      found_trigger_name      : tsp00_KnlIdentifier;
      trigger_key             : tgg00_SysInfoKey;
      sysk                    : tgg00_SysInfoKey;
      msg                     : tsp00_C32;
      ownerName               : tsp00_KnlIdentifier;
 
BEGIN
WITH acv, a11v DO
    BEGIN
    firstReplicationTrigger := false;
    is_trigger_code         := false;
    do_replace  :=
          a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_pos MOD 2048  = cak_i_replace;
    is_internal := a_ap_tree^[a_ap_tree^[0].n_lo_level].n_length = cak_i_internal;
&   ifdef trace
    t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, 1,
          a_cmd_part^.sp1p_buf_len);
&   endif
    pUserContext := NIL;
    IF  (a_p_arr2.pcount <> 0) AND NOT do_replace
    THEN
        a07_b_put_error (acv, e_duplicate_name, a1ci)
    ELSE
        IF  acv.a_isReplicationUser
        THEN
            IF  (acv.a_p_arr1.pbasep^.sbase.bauthid = acv.a_curr_user_id) OR NOT is_internal
            THEN
                BEGIN
                msg := 'NO TRIGGERS FOR REPLICATION USER';
                a07_const_b_put_error (acv, e_missing_privilege, 1, @msg, sizeof(msg));
                END
            ELSE
                BEGIN
                a06determine_username (acv, acv.a_p_arr1.pbasep^.sbase.bauthid, ownerName);
                a06get_priv  (acv, acv.a_p_arr1.pbasep, [r_sel], priv); (* PTS 1133319 *)
                IF  NOT (r_sel in priv.priv_all_set)
                THEN
                    a07_kw_put_error (acv, e_missing_privilege, 1, cak_i_select)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        trigger_key            := a_p_arr1.pbasep^.syskey;
        trigger_key.sentrytyp  := cak_etrigger;
        kind_index             := a_ap_tree^[ a1ti ].n_lo_level;
        proc_buf               := NIL;
        trigger_kind           := [];
        is_ddl                 := acv.a_is_ddl;
        linkSet                := acv.a_p_arr1.pbasep^.sbase.blinkexist;
        WHILE (kind_index <> 0) AND (a_returncode = 0) DO
            BEGIN
            acv.a_is_ddl := is_ddl; (* PTS 1102766 *)
            a1ti         := kind_index;
            CASE a_ap_tree^[ a1ti ].n_subproc OF
                cak_i_delete :
                    BEGIN
                    IF  NOT is_internal
                    THEN
                        linkSet := linkSet + [ del_trigger ];
                    (*ENDIF*) 
                    compileInfo          := pct_delete_trigger;
                    trigger_key.slinkage := cak_del_trigger_linkage;
                    END;
                cak_i_insert :
                    BEGIN
                    IF  NOT is_internal
                    THEN
                        linkSet := linkSet + [ ins_trigger ];
                    (*ENDIF*) 
                    compileInfo          := pct_insert_trigger;
                    trigger_key.slinkage := cak_ins_trigger_linkage
                    END;
                cak_i_update :
                    BEGIN
                    IF  NOT is_internal
                    THEN
                        linkSet := linkSet + [ upd_trigger ];
                    (*ENDIF*) 
                    compileInfo          := pct_update_trigger;
                    trigger_key.slinkage := cak_upd_trigger_linkage
                    END;
                END;
            (*ENDCASE*) 
            IF  is_internal
            THEN
                BEGIN
                IF  NOT (internal_trigger in linkSet)
                THEN
                    firstReplicationTrigger := true;
                (*ENDIF*) 
                linkSet := linkSet + [internal_trigger];
                trigger_key.slinkage[2] := chr(ord(trigger_key.slinkage[2]) + cak262_internalTriggerOffset);
                END;
            (*ENDIF*) 
            trigger_kind := trigger_kind + [ trigger_key.slinkage[2] ];
&           ifdef trace
            t01int4 (ak_sem, 'a1ti        ', a1ti);
&           endif
            i := a_ap_tree^[ a1ti ].n_lo_level;
            WHILE (a_ap_tree^[ i ].n_proc = a262) AND
                  (a_ap_tree^[ i ].n_subproc in
                  [ cak_i_insert, cak_i_update, cak_i_delete]) DO
                BEGIN
                a1ti := i;
                i    := a_ap_tree^[ i ].n_lo_level
                END;
            (*ENDWHILE*) 
&           ifdef trace
            t01int4 (ak_sem, 'a1ti        ', a1ti);
&           endif
            IF  a1ti <> kind_index
            THEN
                kind_index := a_ap_tree^[ kind_index ].n_lo_level
            ELSE
                kind_index := 0;
            (*ENDIF*) 
&           ifdef trace
            t01int4 (ak_sem, 'kind_index  ', kind_index);
&           endif
            a10_fix_len_get_sysinfo (acv, trigger_key, d_fix,
                  sizeof (tak_triggerrecord),
                  0, trig_ptr, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                a262get_trigger_name (trig_ptr^.strigger,
                      found_trigger_name, b_err);
                IF  b_err = e_ok
                THEN
                    BEGIN
                    IF  (found_trigger_name <> trigger_name) OR NOT do_replace
                    THEN
                        a07_b_put_error (acv, e_duplicate_trigger_def, 1)
                    ELSE
                        BEGIN
                        IF  trig_ptr^.strigger.tr_condition_cnt > 0
                        THEN
                            BEGIN
                            (* delete existing whenever clause *)
                            sysk             := trigger_key;
                            sysk.sentrytyp   := cak_eviewdesc;
                            sysk.slinkage[1] := chr(255);
                            a10del_sysinfo (acv, sysk, b_err);
                            IF  b_err = e_ok
                            THEN
                                BEGIN
                                sysk.sentrytyp   := cak_econstraint;
                                a10del_sysinfo (acv, sysk, b_err);
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  trig_ptr^.strigger.tr_succ_exists
                        THEN
                            BEGIN
                            a06inc_linkage  (trigger_key.slinkage);
                            a10del_sysinfo (acv, trigger_key, b_err)
                            END
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  (b_err <> e_ok) AND
                    (b_err <> e_sysinfo_not_found)
                THEN
                    a07_b_put_error (acv, b_err, 1)
                (*ENDIF*) 
                END
            ELSE
                do_replace := false;
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                WITH trig_ptr^.strigger DO
                    BEGIN
                    tr_segmentid := a_p_arr1.pbasep^.sbase.bsegmentid;
                    tr_param_cnt := 0;
                    tr_name_len  := a061identifier_len (trigger_name);
                    SAPDB_PascalMove ('VAK262',  28,    
                          sizeof (trigger_name), sizeof (tr_name),
                          @trigger_name, 1, @tr_name, 1, tr_name_len,
                          a_returncode);
                    IF  a_returncode = 0
                    THEN
                        BEGIN
                        a11put_date_time (tr_date, tr_time);
                        tr_condition_cnt   := 0;
                        tr_upd_set         := [  ];
                        tr_succ_exists     := false;
                        tr_comment         := false;
                        tr_maxUpdatedColno := 0;
                        tr_language        := lang_pl;
                        col_ti           := a_ap_tree^[ a1ti ].n_sa_level;
                        WHILE (col_ti <> 0) AND (a_ap_tree^[col_ti].n_symb = s_identifier) DO
                            WITH a_ap_tree^[ col_ti ] DO
                                BEGIN (* update columns *)
                                a05identifier_get (acv, col_ti,
                                      sizeof(col_name), col_name);
                                IF  a061exist_columnname (a_p_arr1.pbasep^.sbase,
                                    col_name, col_ptr)
                                THEN
                                    tr_upd_set := tr_upd_set +
                                          [ col_ptr^.cextcolno ]
                                ELSE
                                    a07_b_put_error (acv,
                                          e_unknown_columnname, n_pos);
                                (*ENDIF*) 
                                col_ti := n_sa_level
                                END
                            (*ENDWITH*) 
                        (*ENDWHILE*) 
                        END;
                    (*ENDIF*) 
                    IF  a_returncode = 0
                    THEN
                        BEGIN
                        error := e_ok;
&                       ifdef trace
                        t01int4 (ak_sem, 'a1ti        ', a1ti);
&                       endif
                        a1ti  := a_ap_tree^[a1ti].n_lo_level;
                        IF  (a_ap_tree^[a_ap_tree^[a1ti].n_sa_level].n_proc = a262) AND
                            (a_ap_tree^[a_ap_tree^[a1ti].n_sa_level].n_subproc = cak_i_trigger)
                        THEN
                            BEGIN
                            is_trigger_code := true;
                            ak262trigger_code (acv, a11v, a_ap_tree^[a1ti].n_sa_level,
                                  trig_ptr, last_trig_ptr);
                            a1ti := a_ap_tree^[a1ti].n_lo_level;
                            END
                        ELSE
                            IF  proc_buf = NIL
                            THEN
                                BEGIN
                                a_is_ddl    := ddl_create_trigger;
                                tr_language := lang_cpp;
                                a12create_dbproc (acv, a_ap_tree^[a1ti].n_sa_level, trig_ptr^.strigger.tr_proc_id);
                                last_trig_ptr := trig_ptr;
                                a06_systable_get (acv, d_fix,
                                      trigger_key.stableid, a_p_arr1.pbasep, cak262_all_base, ok);
                                IF  NOT ok
                                THEN
                                    a07ak_system_error (acv, 262, 5);
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  (a_returncode = 0) AND NOT is_trigger_code
                    THEN
                        BEGIN
                        sysk           := a01defaultkey;
                        sysk.stableid  := trig_ptr^.strigger.tr_proc_id;
                        sysk.sentrytyp := cak_emethod;
                        a10get_sysinfo (acv, sysk,
                              d_release, proc_buf, b_err);
                        IF  b_err = e_ok
                        THEN
                            ak262check_parameters (acv, trig_ptr, proc_buf);
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  a_returncode = 0
                    THEN
                        BEGIN
                        IF  tr_param_cnt > cak_max_trigger_stack
                        THEN
                            param_cnt := cak_max_trigger_stack
                        ELSE
                            param_cnt := tr_param_cnt;
                        (*ENDIF*) 
                        trig_ptr^.b_sl := sizeof (trig_ptr^.strigger) -
                              sizeof (trig_ptr^.strigger.tr_stack) +
                              ((trig_ptr^.strigger.tr_name_len - 1) DIV
                              STACK_ENTRY_MXGG00 + 1 + param_cnt) *
                              STACK_ENTRY_MXGG00;
                        IF  trig_ptr <> last_trig_ptr
                        THEN
                            BEGIN
                            a10_add_repl_sysinfo (acv,
                                  trig_ptr, NOT do_replace, b_err);
                            last_trig_ptr^.b_sl := sizeof (last_trig_ptr^.strigger) -
                                  sizeof (last_trig_ptr^.strigger.tr_stack) +
                                  last_trig_ptr^.strigger.tr_param_cnt *
                                  STACK_ENTRY_MXGG00;
                            END;
                        (*ENDIF*) 
                        END;
&                   ifdef trace
                    (*ENDIF*) 
                    t01int4 (ak_sem, 'a1ti wheneve', a1ti);
&                   endif
                    IF  (a_returncode = 0)
                        AND (a1ti <> 0)
                        AND (a_ap_tree^[a1ti].n_subproc = cak_i_whenever)
                    THEN
                        ak262whenever_clause (acv, a11v, compileInfo, last_trig_ptr);
                    (*ENDIF*) 
                    IF  a_returncode = 0
                    THEN
                        a10_add_repl_sysinfo (acv,
                              last_trig_ptr, NOT do_replace, b_err)
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            IF  b_err <> e_ok
            THEN
                IF  b_err = e_duplicate_sysinfo
                THEN
                    a07_b_put_error (acv, e_duplicate_trigger_def, 1)
                ELSE
                    a07_b_put_error (acv, b_err, 1)
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        IF  is_trigger_code
        THEN
            BEGIN
            ak262ddl_parse_sql_statements (acv, trigger_key.stableid,
                  cak262is_create_trigger, trigger_kind);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    a51RestoreUserContext (acv, pUserContext);
    IF  firstReplicationTrigger AND (acv.a_returncode = 0)
    THEN
        BEGIN
        replicationUserTabId := cak_replication_usertab_id;
        a19add_usertab  (acv, replicationUserTabId, trigger_key.stableid, ut_base_table);
        END;
    (*ENDIF*) 
    IF  acv.a_returncode <> 0
    THEN
        a201ReleaseInternalPackets (acv)
    ELSE
        acv.a_p_arr1.pbasep^.sbase.blinkexist := linkSet;
    (*ENDIF*) 
    acv.a_is_ddl   := ddl_create_trigger;
    acv.a_init_ddl := ddl_create_trigger
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262ddl_parse_sql_statements (
            VAR acv         : tak_all_command_glob;
            VAR CodeId      : tgg00_Surrogate;
            IsCreateTrigger : boolean;
            trigger_kind    : tak_charset);
 
CONST
      c_release_packet = true;
 
VAR
      dropUsageFile     : boolean;
      createSharedSQL   : boolean;
      localCacheUsage   : boolean;
      ix                : integer;
      Linkage           : tsp00_C2;
      cmd_segm          : tsp1_segment_ptr;
      p                 : tak_sysbufferaddress;
      pCmd              : tsp1_part_ptr;
      header            : tsp1_packet_header;
      segment_header    : tsp1_segment_header;
      initParsFile      : tgg00_FileId;
 
BEGIN
(* disable shared sql for statements in db-procedure *)
pCmd                      := acv.a_cmd_part;
createSharedSQL           := acv.a_createSharedSQL;
acv.a_createSharedSQL     := false;
localCacheUsage           := acv.a_localCacheUsageOnly;
acv.a_localCacheUsageOnly := true;
(* if <create dbproc statement> is located in an internal packet, *)
(* release it now, because it will not be needed any more         *)
(* Otherwise a reference to the packed would be stored by the     *)
(* sql statements in the dbprocedure, which would make several    *)
(* problems                                                       *)
a542reset_packet (acv);
(* PTS 1109670 *)
dropUsageFile                    := false;
initParsFile                     := acv.a_pars_curr;
acv.a_pars_curr.fileTfnTemp_gg00 := ttfnTrigger_egg00;
acv.a_pars_curr.fileRoot_gg00    := NIL_PAGE_NO_GG00;
(* create a new parsfile that takes in all pars infos of the *)
(* sql statements of the dbproc. Thismakes it easy to delete *)
(* them after the dbproc/trigger has been created            *)
b01tcreate_file (acv.a_transinf.tri_trans, acv.a_pars_curr);
IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
THEN
    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
ELSE
    BEGIN
    (* PTS 1113166 E.Z. *)
    cmd_segm       := acv.a_cmd_segm;
    header         := acv.a_out_packet^.sp1_header;
    segment_header := acv.a_out_packet^.sp1_segm.sp1s_segm_header;
    a38create_parameter_file (acv);
    dropUsageFile := acv.a_returncode = 0
    END;
(*ENDIF*) 
acv.a_progusage_add := acv.a_returncode = 0;
ix := 1;
WHILE (trigger_kind <> []) AND (acv.a_returncode = 0) DO
    BEGIN
    IF  IsCreateTrigger
    THEN
        BEGIN
        Linkage := cgg_zero_c2;
        REPEAT
            Linkage[2] := succ(Linkage[2]);
        UNTIL
            (Linkage[2] in trigger_kind);
        (*ENDREPEAT*) 
        trigger_kind := trigger_kind - [ Linkage[2] ];
        END
    ELSE
        BEGIN
        Linkage      := cak_init_linkage;
        trigger_kind := [];
        END;
    (*ENDIF*) 
    IF  Linkage <> cgg_zero_c2
    THEN
        BEGIN
        a262LoadCode (acv, CodeId, Linkage, p);
        IF  p <> NIL
        THEN
            ak262parse_sql_statements (acv, CodeId, p)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    ix := ix + 1
    END;
(*ENDWHILE*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    acv.a_out_packet^.sp1_header                := header;
    acv.a_out_packet^.sp1_segm.sp1s_segm_header := segment_header;
    acv.a_cmd_segm      := cmd_segm
    END
ELSE
    BEGIN
    (* PTS 1113166 E.Z. *)
    acv.a_out_packet^.sp1_header.sp1h_mess_code    := header.sp1h_mess_code;
    acv.a_out_packet^.sp1_header.sp1h_mess_swap    := header.sp1h_mess_swap;
    acv.a_out_packet^.sp1_header.sp1h_appl_version := header.sp1h_appl_version;
    acv.a_out_packet^.sp1_header.sp1h_application  := header.sp1h_application;
    END;
(*ENDIF*) 
acv.a_progusage_add := false;
(* PTS 1109670 *)
(* remove all temp records from cache *)
a10DeallocTemp(acv);
(* delete aux pars file *)
b01destroy_file (acv.a_transinf.tri_trans, acv.a_pars_curr);
IF  dropUsageFile
THEN
    b01destroy_file (acv.a_transinf.tri_trans, acv.a_usage_curr);
(* return to original pars file *)
(*ENDIF*) 
acv.a_pars_curr           := initParsFile;
acv.a_createSharedSQL     := createSharedSQL;
acv.a_localCacheUsageOnly := localCacheUsage;
IF  (acv.a_returncode = 0) AND a101_AnySchemaMapped(acv)
THEN
    BEGIN
    a52end_rollback_subtrans (acv, a01_il_b_identifier, m_rollback);
    a542internal_packet (acv, c_release_packet, g01packet_size);
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        acv.a_cmd_segm^.sp1c_mess_type := sp1m_dbs;
        a542copy_into_packet (acv, @pCmd^.sp1p_buf, pCmd^.sp1p_buf_len);
        a101_RenameSchemaNames (acv);
&       ifdef trace
        t01packet (ak_sem, 'aftermapping', acv.a_in_packet);
&       endif
        acv.a_cmd_segment_header := acv.a_cmd_segm^.sp1s_segm_header;
        acv.a_returncode         := cak_e_schema_mapped;
        acv.a_ex_kind            := parsing_executing;
        acv.a_try_again          := true;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262GetCount (
            VAR acv      : tak_all_command_glob;
            pPacket      : tsp1_packet_ptr;
            retcode_addr : tsp00_MoveObjPtr);
 
VAR
      SetNull  : boolean;
      part_ptr : tsp1_part_ptr;
      moveLen  : integer;
      dstPos   : integer;
 
BEGIN
(* put result count into variable $count *)
dstPos := cgg_rec_key_offset +
      (cak262_rc_digits + 1) DIV 2 + 2 + 1 + cak262_max_errormsg * a01char_size + 1;
s26find_part (pPacket^.sp1_segm, sp1pk_resultcount, part_ptr);
IF  part_ptr = NIL
THEN
    SetNull := true
ELSE
    SetNull := part_ptr^.sp1p_buf[2] < csp_zero_exponent;
(*ENDIF*) 
IF  SetNull
THEN
    retcode_addr^[dstPos] := csp_undef_byte
ELSE
    SAPDB_PascalMove ('VAK262',  29,    
          part_ptr^.sp1p_buf_size, sizeof(tsp00_Buf),
          @part_ptr^.sp1p_buf, 1, retcode_addr, dstPos,
          part_ptr^.sp1p_buf_len, acv.a_returncode);
(*ENDIF*) 
&ifdef trace
t01moveobj (sproc_call, retcode_addr^, dstPos,
      dstPos + (cak262_count_digits + 1) DIV 2 + 2 - 1);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262GetErrorMsg (
            VAR acv      : tak_all_command_glob;
            pPacket      : tsp1_packet_ptr;
            retcode_addr : tsp00_MoveObjPtr);
 
VAR
      part_ptr : tsp1_part_ptr;
      moveLen  : integer;
      dstPos   : integer;
 
BEGIN
IF  acv.a_returncode <> 0
THEN
    BEGIN (* put SQL ErrorText into variable $errmsg*)
    s26find_part (pPacket^.sp1_segm, sp1pk_errortext, part_ptr);
    IF  part_ptr <> NIL
    THEN
        BEGIN
        IF  part_ptr^.sp1p_buf_len > cak262_max_errormsg * a01char_size
        THEN
            moveLen := cak262_max_errormsg * a01char_size
        ELSE
            moveLen := part_ptr^.sp1p_buf_len;
        (*ENDIF*) 
        dstPos := cgg_rec_key_offset + (cak262_rc_digits + 1) DIV 2 + 2 + 1;
        IF  g01unicode
        THEN
            retcode_addr^[dstPos] := csp_unicode_def_byte
        ELSE
            retcode_addr^[dstPos] := csp_ascii_blank;
        (*ENDIF*) 
        SAPDB_PascalMove ('VAK262',  30,    
              part_ptr^.sp1p_buf_size, sizeof(tsp00_Buf),
              @part_ptr^.sp1p_buf, 1, retcode_addr, dstPos + 1, moveLen,
              acv.a_returncode);
        IF  moveLen < cak262_max_errormsg * a01char_size
        THEN
            BEGIN
            IF  g01unicode
            THEN
                SAPDB_PascalUnicodeFill ('VAK262',  31,    
                      sizeof(tsp00_Buf), retcode_addr,
                      dstPos + 1 + moveLen, cak262_max_errormsg * a01char_size - moveLen,
                      csp_unicode_blank, acv.a_returncode)
            ELSE
                SAPDB_PascalFill ('VAK262',  32,    
                      sizeof(tsp00_Buf), retcode_addr,
                      dstPos + 1 + moveLen, cak262_max_errormsg - moveLen,
                      csp_ascii_blank, acv.a_returncode);
            (*ENDIF*) 
            END;
&       ifdef trace
        (*ENDIF*) 
        t01moveobj (sproc_call, part_ptr^.sp1p_buf, 1, part_ptr^.sp1p_buf_len);
        t01moveobj (sproc_call, retcode_addr^, 1, cgg_rec_key_offset +
              (cak262_rc_digits + 1) DIV 2 + 2 + 1 + cak262_max_errormsg * a01char_size);
&       endif
        END;
    (*ENDIF*) 
    acv.a_returncode := 0;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262parse_sql_statements (
            VAR acv           : tak_all_command_glob;
            VAR tabid         : tgg00_Surrogate;
            p                 : tak_sysbufferaddress);
 
VAR
      e          : tgg00_BasisError;
      jx         : integer;
      mblock_p   : tgg00_MessBlockPtr;
 
BEGIN
a10lock_fixed (acv);
mblock_p := @p^.smessblock.mbr_mess_block;
jx       := mblock_p^.mb_qual^.mqual_pos;
WHILE (acv.a_returncode = 0) AND
      (jx <= mblock_p^.mb_qual^.mqual_pos +
      mblock_p^.mb_qual^.mqual_cnt - 1) DO
    BEGIN
    IF  (mblock_p^.mb_st^[jx].etype = st_parseid) AND
        (mblock_p^.mb_st^[jx].eop   <> op_not   )
    THEN
        ak262parse_stmt (acv, NIL, tabid,
              mblock_p^, cak262is_create_trigger, jx, NIL);
    (*ENDIF*) 
    jx := jx + 1
    END;
(*ENDWHILE*) 
a10unlock_fixed (acv);
IF  acv.a_returncode = 0
THEN
    BEGIN
&   ifdef trace
    t01messblock (sproc_call, 'mblock      ', mblock_p^);
&   endif
    a10repl_sysinfo (acv, p, e);
    IF  e <> e_ok
    THEN
        a07_b_put_error (acv, e, 1)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262LoadCode (
            VAR acv     : tak_all_command_glob;
            VAR CodeId  : tgg00_Surrogate;
            Linkage     : tsp00_C2;
            VAR p       : tak_sysbufferaddress);
 
VAR
      e    : tgg00_BasisError;
      sysk : tgg00_SysInfoKey;
 
BEGIN
sysk.stableid  := CodeId;
sysk.sentrytyp := cak_epermmessblock;
sysk.slinkage  := Linkage;
sysk.skeylen   := mxak_standard_sysk;
a10get_sysinfo (acv, sysk, d_fix, p, e);
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262MapErrorCode (VAR acv : tak_all_command_glob);
 
BEGIN
IF  acv.a_returncode <> 0
THEN
    IF  acv.a_returncode =
        a071_return_code (e_unknown_columnname, acv.a_sqlmode)
    THEN
        acv.a_returncode :=
              a071_return_code (e_unknown_name, acv.a_sqlmode);
    (*ENDIF*) 
(*ENDIF*) 
IF  acv.a_returncode =
    a071_return_code (e_duplicate_columnname, acv.a_sqlmode)
THEN
    acv.a_returncode :=
          a071_return_code (e_duplicate_name, acv.a_sqlmode);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262parse_stmt (
            VAR acv           : tak_all_command_glob;
            pSel              : tak262_SelectFieldsParamPtr;
            VAR  tabid        : tgg00_Surrogate;
            VAR  mblock       : tgg00_MessBlock;
            is_create_trigger : boolean;
            qual_ix           : integer;
            retcode_addr      : tsp00_MoveObjPtr);
 
TYPE
      tparam_info = ARRAY[1..csp_maxint2] OF tsp1_param_info;
 
      CharMapDatatype = RECORD
            CASE boolean OF
                true :
                    (dt : tsp00_DataType);
                false :
                    (c : tsp00_C1);
                END;
            (*ENDCASE*) 
 
 
VAR
      ok            : boolean;
      inSubtrans    : boolean;
      isTrigger     : boolean;
      funcParamFound: boolean;
      res           : tsp00_NumError;
      charMapDt     : CharMapDatatype;
      paramCnt      : integer;
      dummy         : tsp1_comm_error;
      level         : integer;
      ix            : integer;
      jx            : integer;
      stackPtr      : integer;
      paramIdx      : integer;
      length        : integer;
      returnCode    : integer;
      moveLen       : integer;
      cnt           : integer;
      pParamDesc    : ^tsp1_param_spec_list;
      ex_kind       : tak_execution_kind;
      size          : tsp00_Int4;
      errPosOffset  : tsp00_Int4;
      e             : tgg00_BasisError;
      packet_ptr    : tsp1_packet_ptr;
      pParam        : tgg00_StEntryAddr;
      p             : tak_sysbufferaddress;
      sysk          : tgg00_SysInfoKey;
      param_ptr     : ^tparam_info;
      part_ptr      : tsp1_part_ptr;
      segm_ptr      : tsp1_segment_ptr;
      parsid        : tak_parsid;
&     ifdef trace
      out_packet_ptr : tsp1_packet_ptr;
&     endif
 
BEGIN
funcParamFound := false;
&ifdef trace
t01stackentry (sproc_call, mblock.mb_st^[qual_ix], qual_ix);
&endif
sysk             := a01defaultkey;
sysk.stableid    := tabid;
sysk.sentrytyp   := cak_eviewtext;
sysk.slinkage[1] := chr(mblock.mb_st^[qual_ix].elen_var DIV 256);
sysk.slinkage[2] := chr(mblock.mb_st^[qual_ix].elen_var MOD 256);
a10get_sysinfo (acv, sysk, d_release, p, e);
IF  e = e_ok
THEN
    BEGIN
    errPosOffset  := p^.sviewtext.vtselect_pos;
    a101_SetMappingOffset (acv, errPosOffset + a01char_size - 1);
    (* ensure privilege checking under account of dbproc owner *)
    acv.a_proc_userid := mblock.mb_qual^.mlinktree.fileTabId_gg00;
&   ifdef trace
    t01surrogate (ak_sem, 'proc_user_id', acv.a_proc_userid);
&   endif
    a34AllocPacket (acv, packet_ptr, size);
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        sysk.skeylen := sysk.skeylen + 1;
        packet_ptr^.sp1_header.sp1h_varpart_size :=
              size - sizeof (packet_ptr^.sp1_header);
        s26init_cmd_packet (packet_ptr, segm_ptr);
        IF  g01unicode
        THEN
            packet_ptr^.sp1_header.sp1h_mess_code := csp_unicode;
        (*ENDIF*) 
        sp100_GetSenderIDVersionP (packet_ptr^.sp1_header.sp1h_appl_version);
        CASE p^.sviewtext.vtcontext DIV 10 OF
            1 :
                segm_ptr^.sp1s_segm_header.sp1c_sqlmode := sp1sm_ansi;
            2 :
                segm_ptr^.sp1s_segm_header.sp1c_sqlmode := sp1sm_db2;
            3 :
                segm_ptr^.sp1s_segm_header.sp1c_sqlmode := sp1sm_oracle;
            OTHERWISE
                segm_ptr^.sp1s_segm_header.sp1c_sqlmode :=  sp1sm_internal;
            END;
        (*ENDCASE*) 
        segm_ptr^.sp1s_segm_header.sp1c_parsing_again := false;
        segm_ptr^.sp1s_segm_header.sp1c_mess_type     := sp1m_parse;
        IF  acv.a_initial_segment_header.sp1c_producer = sp1pr_installation
        THEN
            segm_ptr^.sp1s_segm_header.sp1c_producer := sp1pr_installation
        ELSE
            segm_ptr^.sp1s_segm_header.sp1c_producer := sp1pr_user_cmd;
        (*ENDIF*) 
        segm_ptr^.sp1s_segm_header.sp1c_command_options :=
              segm_ptr^.sp1s_segm_header.sp1c_command_options + [sp1co_scrollable_cursor_on];
        segm_ptr^.sp1p_buf_size                       :=
              size - sizeof (tsp1_segment_header);
        s26new_part_init (packet_ptr, segm_ptr^, part_ptr);
        length := p^.sviewtext.vttextlength;
        IF  length > part_ptr^.sp1p_buf_size
        THEN
            a07_b_put_error (acv, e_too_small_packet_size, 1)
        ELSE
            BEGIN
            cnt    := 0;
            REPEAT
                moveLen :=  p^.b_sl + sizeof (tak_viewtext) - sizeof (tak_viewtextrecord);
                SAPDB_PascalMove ('VAK262',  33,    
                      sizeof(p^.sviewtext.vttbuf),
                      part_ptr^.sp1p_buf_size,
                      @p^.sviewtext.vttbuf, 1,
                      @part_ptr^.sp1p_buf, part_ptr^.sp1p_buf_len + 1, moveLen,
                      acv.a_returncode);
                part_ptr^.sp1p_buf_len := part_ptr^.sp1p_buf_len + moveLen;
                length := length - moveLen;
                IF  length > 0
                THEN
                    BEGIN
                    cnt := cnt + 1;
                    sysk.all[sysk.skeylen] := chr(cnt);
                    a10get_sysinfo (acv, sysk, d_release, p, e);
                    IF  e <> e_ok
                    THEN
                        a07_b_put_error (acv, e , 1);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            UNTIL
                (length <= 0) OR (acv.a_returncode <> 0);
            (*ENDREPEAT*) 
            END;
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            part_ptr^.sp1p_part_kind := sp1pk_command;
            s26finish_part (packet_ptr, part_ptr^);
            paramCnt := mblock.mb_st^[qual_ix].epos;
            IF  paramCnt > 0 (* PTS 1109260 *)
            THEN
                BEGIN (* describe parameters *)
                s26new_part_init (packet_ptr, segm_ptr^, part_ptr);
                IF  part_ptr^.sp1p_buf_size > paramCnt * sizeof(tsp1_param_spec)
                THEN
                    BEGIN
                    stackPtr   := qual_ix + 3;
                    pParamDesc := @part_ptr^.sp1p_buf;
                    FOR ix := 1 TO paramCnt DO
                        BEGIN
                        paramIdx := mblock.mb_st^[stackPtr].eindex;
                        charMapDt.c[1] := mblock.mb_st^[paramIdx].ecol_tab[1];
&                       ifdef trace
                        t01stackentry (ak_sem, mblock.mb_st^[paramIdx], paramIdx);
&                       endif
                        pParamDesc^[ix].para_type   := charMapDt.dt;
                        IF  mblock.mb_st^[paramIdx].ecol_tab[2] > chr(0)
                        THEN
                            pParamDesc^[ix].para_frac := pred(mblock.mb_st^[paramIdx].ecol_tab[2])
                        ELSE
                            pParamDesc^[ix].para_frac := chr(0);
                        (*ENDIF*) 
                        length := mblock.mb_st^[paramIdx].elen_var;
                        IF  (length = -1) AND (pSel <> NIL)
                        THEN
                            BEGIN (* dbfunction parameter *)
                            funcParamFound := true;
                            pParam         := s35inc_st_ptocm (pSel^.sfp_work_st_frame, mblock.mb_st^[paramIdx].epos);
                            length         := pParam^.elen_var;
                            END;
                        (*ENDIF*) 
                        CASE charMapDt.dt OF
                            dfixed, dfloat, dinteger, dsmallint :
                                pParamDesc^[ix].para_length := (length - 2) * 2;
                            dunicode :
                                pParamDesc^[ix].para_length := length DIV 2;
                            OTHERWISE
                                pParamDesc^[ix].para_length := length - 1;
                            END;
                        (*ENDCASE*) 
                        stackPtr := stackPtr + 1;
                        END;
                    (*ENDFOR*) 
                    part_ptr^.sp1p_part_kind := sp1pk_appl_parameter_description;
                    part_ptr^.sp1p_arg_count := paramCnt;
                    part_ptr^.sp1p_buf_len   := paramCnt * sizeof(tsp1_param_spec);
                    END;
                (*ENDIF*) 
                s26finish_part (packet_ptr, part_ptr^)
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        a93packet_vtrace (acv.a_transinf.tri_trans,
              ak_send, packet_ptr);
        IF  mblock.mb_type2 = mm_trigger
        THEN
            BEGIN
            isTrigger := true;
            level := acv.a_trigger_level;
            IF  level = 0
            THEN (* disable privilege checking, disable reply to application *)
                acv.a_trigger_level := 1;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            isTrigger := false;
            level     := acv.a_dbproc_level;
            IF  level = 0
            THEN (* disable reply to application (see a93_sending) *)
                acv.a_dbproc_level := 1
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        inSubtrans              := acv.a_in_internal_subtr;
        acv.a_in_internal_subtr := false;
        ex_kind                 := acv.a_ex_kind;
        acv.a_proc_compile      := pct_dbproc;
        ak262SqlRequest (@acv, packet_ptr);
        acv.a_returncode := packet_ptr^.sp1_segm.sp1r_returncode;
        acv.a_proc_compile      := pct_none;
        acv.a_in_internal_subtr := inSubtrans;
        acv.a_ex_kind           := ex_kind;
        IF  level = 0
        THEN
            IF  isTrigger
            THEN
                acv.a_trigger_level := 0
            ELSE
                acv.a_dbproc_level  := 0;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  retcode_addr <> NIL
        THEN
            s41plint (retcode_addr^, cgg_rec_key_offset + 2, cak262_rc_digits, 0,
                  acv.a_returncode, res);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        IF  NOT is_create_trigger
        THEN
            BEGIN
            s26find_part (packet_ptr^.sp1_segm, sp1pk_parsid, part_ptr);
            IF  part_ptr <> NIL
            THEN
                BEGIN
                SAPDB_PascalMove ('VAK262',  34,    
                      part_ptr^.sp1p_buf_size,
                      2 * sizeof (tgg00_StackEntry),
                      @part_ptr^.sp1p_buf, 1, @mblock.mb_st^[qual_ix + 1], 1,
                      part_ptr^.sp1p_buf_len,
                      acv.a_returncode);
                END;
            (*ENDIF*) 
            IF  funcParamFound
            THEN
                BEGIN
                s26find_part (packet_ptr^.sp1_segm, sp1pk_shortinfo, part_ptr);
                IF  part_ptr <> NIL
                THEN
                    BEGIN
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            s26find_part (packet_ptr^.sp1_segm, sp1pk_parsid, part_ptr);
            IF  part_ptr <> NIL
            THEN
                BEGIN
                SAPDB_PascalMove ('VAK262',  35,    
                      part_ptr^.sp1p_buf_size,
                      sizeof (parsid),
                      @part_ptr^.sp1p_buf, 1, @parsid, 1,
                      part_ptr^.sp1p_buf_len,
                      acv.a_returncode);
                END;
            (*ENDIF*) 
            a06_systable_get (acv, d_fix, tabid,
                  acv.a_p_arr1.pbasep, cak262_all_base, ok);
            s26find_part (packet_ptr^.sp1_segm, sp1pk_shortinfo, part_ptr);
            IF  part_ptr <> NIL
            THEN
                BEGIN
                param_ptr := @part_ptr^.sp1p_buf;
                jx        := qual_ix + 3;
                FOR ix := 1 TO mblock.mb_st^[qual_ix].epos DO
                    BEGIN
                    ak262check_compatibility (acv, mblock, ix, param_ptr^[ix], jx, errPosOffset);
                    jx := jx + 1;
                    END;
                (*ENDFOR*) 
                END;
            (*ENDIF*) 
            a06reset_retpart (acv);
            END
        (*ENDIF*) 
    ELSE
        BEGIN
&       ifdef trace
        t01int4 (ak_sem, 'errorpos    ',  acv.a_errorpos);
        t01int4 (ak_sem, 'errPosOffset', errPosOffset);
&       endif
        IF  retcode_addr <> NIL
        THEN
            BEGIN (* put SQL ErrorText into variable $errmsg*)
            returnCode := acv.a_returncode;
            ak262GetErrorMsg (acv, packet_ptr, retcode_addr);
            acv.a_returncode := returnCode
            END;
        (* PTS 1113166 E.Z. *)
        (*ENDIF*) 
        IF  g01unicode
        THEN
            acv.a_errorpos := acv.a_errorpos + (errPosOffset + 1) DIV 2
        ELSE
            acv.a_errorpos := acv.a_errorpos + errPosOffset;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END
ELSE
    BEGIN
    IF  e = e_sysinfo_not_found
    THEN
        e := e_old_fileversion;
    (*ENDIF*) 
    a07_b_put_error (acv, e, 1)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262check_compatibility (
            VAR acv        : tak_all_command_glob;
            VAR  mblock    : tgg00_MessBlock;
            paramNo        : integer;
            VAR param_info : tsp1_param_info;
            st_ix          : integer;
            ErrorPosOffset : integer);
 
VAR
      incompatible : boolean;
      ix           : integer;
      colno        : integer;
      lineLength   : integer;
      length       : integer;
 
      dt           : RECORD
            CASE boolean OF
                true :
                    (c : char);
                false :
                    (d : tsp00_DataType);
                END;
            (*ENDCASE*) 
 
      col_ptr      : tak00_colinfo_ptr;
      line         : tsp00_Line;
 
BEGIN
incompatible := false;
IF  param_info.sp1i_io_type = sp1io_output
THEN
    mblock.mb_st^[st_ix].etype := st_output
ELSE
    IF  param_info.sp1i_io_type = sp1io_inout
    THEN
        mblock.mb_st^[st_ix].etype := st_output_join; (* inout parameter *)
    (*ENDIF*) 
(*ENDIF*) 
colno := mblock.mb_st^[st_ix].epos;
&ifdef trace
t01int4 (ak_sem, 'colno       ', colno);
IF  colno < 0
THEN
    t01stackentry (ak_sem, mblock.mb_st^[st_ix], st_ix);
&endif
(* PTS 1103734 E.Z. *)
(*ENDIF*) 
IF  colno > 0
THEN
    BEGIN
    IF  colno > MAX_COL_PER_TAB_GG00
    THEN
        colno := colno - MAX_COL_PER_TAB_GG00;
    (*ENDIF*) 
    a06extcolno (acv.a_p_arr1.pbasep^.sbase, colno, col_ptr);
    IF  col_ptr = NIL
    THEN
        a07ak_system_error (acv, 262, 3)
    ELSE
        BEGIN
        dt.d := col_ptr^.cdatatyp;
        IF  param_info.sp1i_data_type <> col_ptr^.cdatatyp
        THEN
            BEGIN
            CASE param_info.sp1i_data_type OF
                dfixed, dsmallint, dinteger, dfloat, dvfloat :
                    IF  NOT (col_ptr^.cdatatyp in  [dfixed, dsmallint, dinteger, dfloat])
                    THEN
                        incompatible := true;
                    (*ENDIF*) 
                dcha, dvarchara :
                    IF  NOT (col_ptr^.cdatatyp in  [dcha, dvarchara])
                    THEN
                        incompatible := true;
                    (*ENDIF*) 
                dchb, dvarcharb :
                    IF  NOT (col_ptr^.cdatatyp in  [dchb, dvarcharb])
                    THEN
                        incompatible := true;
                    (*ENDIF*) 
                dunicode, dvarcharuni :
                    IF  NOT (col_ptr^.cdatatyp in  [dcha, dunicode, dvarcharuni])
                    THEN
                        incompatible := true;
                    (*ENDIF*) 
                OTHERWISE
                    incompatible := true;
                END;
            (*ENDCASE*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END
ELSE
    BEGIN (* local variable *)
    ix := mblock.mb_st^[st_ix].eindex;
&   ifdef trace
    t01int4 (ak_sem, 'param dt    ', ord(param_info.sp1i_data_type));
    t01int4 (ak_sem, 'var dt      ', ord (mblock.mb_st^[ix].ecol_tab[1]));
&   endif
    dt.c := mblock.mb_st^[ix].ecol_tab[1];
    IF  ord(param_info.sp1i_data_type) <> ord (mblock.mb_st^[ix].ecol_tab[1])
    THEN
        CASE param_info.sp1i_data_type OF
            dfixed, dsmallint, dinteger, dfloat, dvfloat :
                IF  (dt.d <> dfixed) AND
                    (dt.d <> dsmallint) AND
                    (dt.d <> dinteger) AND
                    (dt.d <> dfloat)
                THEN
                    incompatible := true;
                (*ENDIF*) 
            dcha, dvarchara :
                IF  (dt.d <> dcha) AND
                    (dt.d <> dvarchara) AND
                    (dt.d <> dunicode) AND
                    (dt.d <> dvarcharuni)
                THEN
                    incompatible := true;
                (*ENDIF*) 
            dchb, dvarcharb :
                IF  (dt.d <> dchb) AND
                    (dt.d <> dvarcharb)
                THEN
                    incompatible := true;
                (*ENDIF*) 
            dunicode, dvarcharuni :
                IF  (dt.d <> dunicode) AND
                    (dt.d <> dvarcharuni)
                THEN
                    incompatible := true;
                (*ENDIF*) 
            OTHERWISE
                incompatible := true;
            END;
        (*ENDCASE*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  incompatible
THEN
    BEGIN
    lineLength := 0;
    line[1]    := 'P';
    IF  paramNo < 10
    THEN
        length := 1
    ELSE
        IF  paramNo < 100
        THEN
            length := 2
        ELSE
            IF  paramNo < 1000
            THEN
                length := 3
            ELSE
                length := 4;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    g17int4to_line (paramNo, false, length, 2, line);
    lineLength       := 1 + length + 1;
    line[lineLength] := ',';
    ak262DataTypeToLine (acv, param_info.sp1i_data_type, lineLength, line);
    lineLength       := lineLength + 1;
    line[lineLength] := ',';
    ak262DataTypeToLine (acv, dt.d, lineLength, line);
    a07_const_b_put_error (acv,
          e_incompatible_datatypes, ErrorPosOffset + 1, @line, lineLength);
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    mblock.mb_st^[st_ix].epos     := param_info.sp1i_bufpos;
    mblock.mb_st^[st_ix].elen_var := param_info. sp1i_in_out_len
    END
ELSE (* no parse again, see vak35 *)
    acv.a_is_ddl := ddl_create_trigger
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262DataTypeToLine (
            VAR acv        : tak_all_command_glob;
            DataType       : tsp00_DataType;
            VAR LineLength : integer;
            VAR Line       : tsp00_Line);
 
VAR
      dummy    : integer;
      length   : integer;
      colInfo  : tak00_columninfo;
      dataType : tsp00_Sname;
      code     : tsp00_C10;
      p1       : ^tsp00_Sname;
      p2       : ^tsp00_C10;
 
BEGIN
colInfo.cdatatyp := DataType;
colInfo.cbinary  := false;
a40datatype_code (colInfo, false, acv.a_comp_type,
      dataType, code, dummy);
length := sizeof(dataType);
WHILE (length > 0) AND (dataType[length] = bsp_c1) DO
    length := length - 1;
(*ENDWHILE*) 
IF  length > 0
THEN
    BEGIN
    p1  := @Line[LineLength+1];
    p1^ := dataType;
    LineLength := LineLength + length;
    END;
(*ENDIF*) 
length := sizeof(code);
WHILE (length > 0) AND (code[length] = bsp_c1) DO
    length := length - 1;
(*ENDWHILE*) 
IF  length > 0
THEN
    BEGIN
    LineLength       := LineLength + 1;
    Line[LineLength] := bsp_c1;
    p2  := @Line[LineLength+1];
    p2^ := code;
    LineLength := LineLength + length;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262PutLongDemandPart (
            VAR acv           : tak_all_command_glob;
            packet_ptr        : tsp1_packet_ptr;
            segm_ptr          : tsp1_segment_ptr;
            LongOutPutCnt     : integer);
 
VAR
      res    : tsp00_NumError;
      ix     : integer;
      pPart  : tsp1_part_ptr;
 
BEGIN
s26new_part_init (packet_ptr, segm_ptr^, pPart);
IF  pPart <> NIL
THEN
    BEGIN
    pPart^.sp1p_part_kind := sp1pk_long_demand;
    pPart^.sp1p_buf_len   := 0;
    pPart^.sp1p_arg_count := LongOutPutCnt;
    FOR ix := 1 TO LongOutPutCnt DO
        BEGIN
        pPart^.sp1p_buf[pPart^.sp1p_buf_len+1] := chr(0);
        pPart^.sp1p_buf[pPart^.sp1p_buf_len+2] := chr(0);
        pPart^.sp1p_buf[pPart^.sp1p_buf_len+3] := chr(0);
        s41plint (pPart^.sp1p_buf, pPart^.sp1p_buf_len + 4, 10, 0, 0, res);
        pPart^.sp1p_buf[pPart^.sp1p_buf_len+10] := chr(0);
        s41plint (pPart^.sp1p_buf, pPart^.sp1p_buf_len + 11, 10, 0, 0, res);
        pPart^.sp1p_buf_len := pPart^.sp1p_buf_len + 16;
        END;
    (*ENDFOR*) 
    s26finish_part (packet_ptr, pPart^);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262SqlRequest (
            acv_addr        : tak_acv_address;
            sql_packet_ptr  : tsp1_packet_ptr);
 
VAR
      initVariableInput : boolean;
      initAsciiOutput   : boolean;
 
BEGIN
initVariableInput  := acv_addr^.a_variable_input;
acv_addr^.a_variable_input := false;
initAsciiOutput    := acv_addr^.a_ascii_in_and_output;
acv_addr^.a_ascii_in_and_output   := false;
a93request     (acv_addr, sql_packet_ptr);
acv_addr^.a_variable_input := initVariableInput;
acv_addr^.a_ascii_in_and_output   := initAsciiOutput
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262trigger_code (
            VAR acv           : tak_all_command_glob;
            VAR a11v          : tak_a11_glob;
            tree_index        : integer;
            trig_ptr          : tak_sysbufferaddress;
            VAR last_trig_ptr : tak_sysbufferaddress);
 
VAR
      e                  : tgg00_BasisError;
      is_old             : boolean;
      stmt_cnt           : integer;
      ix                 : integer;
      jx                 : integer;
      kx                 : integer;
      min_jx             : integer;
      col_no             : integer;
      tr_offset          : integer;
      variablesStackSize : integer;
      inOutLength        : integer;
      min                : tsp00_Int4;
      del_trigger_linkage: tsp00_C2;
      ins_trigger_linkage: tsp00_C2;
      upd_trigger_linkage: tsp00_C2;
      col_ptr            : tak00_colinfo_ptr;
      compile_glob       : tak262compile_glob;
      sysk               : tgg00_SysInfoKey;
 
BEGIN
&ifdef trace
t01int4 (ak_sem, 'tree_index  ', tree_index);
&endif
tree_index := acv.a_ap_tree^[tree_index].n_lo_level;
&ifdef trace
t01int4 (ak_sem, 'tree_index  ', tree_index);
&endif
stmt_cnt := 0;
ak262InitCompileGlob(compile_glob, dbo_dbproc);
compile_glob.cp_base_table := acv.a_p_arr1.pbasep;
(* create table for local variables *)
ak262createVarTable (acv, compile_glob, 0, tree_index);
IF  acv.a_returncode = 0
THEN
    BEGIN
    a05surrogate_get (acv, trig_ptr^.strigger.tr_proc_id);
    ak262StoreVarTable (acv, trig_ptr^.strigger.tr_proc_id);
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    variablesStackSize          := acv.a_p_arr1.pbasep^.sbase.blenfixedcol - 1;
    acv.a_p_arr1.pbasep         := compile_glob.cp_base_table;
    compile_glob.cp_cnt_tables  := 2;
    compile_glob.cp_trigTabid   := acv.a_p_arr1.pbasep^.sbase.bsurrogate;
    compile_glob.cp_trig_kind   := trig_ptr^.syskey.slinkage;
    del_trigger_linkage         := cak_del_trigger_linkage;
    ins_trigger_linkage         := cak_ins_trigger_linkage;
    upd_trigger_linkage         := cak_upd_trigger_linkage;
    compile_glob.cp_ins_trigger :=
          ord(compile_glob.cp_trig_kind[2]) MOD cak262_internalTriggerOffset = ord(ins_trigger_linkage[2]);
    compile_glob.cp_upd_trigger :=
          ord(compile_glob.cp_trig_kind[2]) MOD cak262_internalTriggerOffset = ord(upd_trigger_linkage[2]);
    compile_glob.cp_del_trigger :=
          ord(compile_glob.cp_trig_kind[2]) MOD cak262_internalTriggerOffset = ord(del_trigger_linkage[2]);
    compile_glob.cp_trig_ptr    := trig_ptr;
    compile_glob.cp_tablen      := a11v.a1tablen;
    (* store create trigger statement and compile *)
    ak262StoreStmtAndComplile (acv, compile_glob,
          tree_index, variablesStackSize, c_IsTrigger, NOT c_IsDBFunc);
    END;
(*ENDIF*) 
IF  (cgg_rec_key_offset +  TriggerKeyLen_cgg04 + compile_glob.cp_rec_pos - 1 >
    sizeof (tak262TriggerParamBuffer))
    OR
    (acv.a_returncode <> 0)
THEN
    a07_b_put_error (acv,
          e_too_long_trigger_params, 1)
ELSE
    ak262CreateDebugInfo (acv, compile_glob,
          c_IsTrigger, acv.a_p_arr1.pbasep^.sbase.bmaxcol * 2);
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    (* use mspecial to store trigger kind. Needed to return table and *)
    (* trigger name in error cases at execution time                  *)
    acv.a_mblock.mb_qual^.mspecial := ord(trig_ptr^.syskey.slinkage[1]) * 256 +
          ord(trig_ptr^.syskey.slinkage[2]);
    tr_offset := (trig_ptr^.strigger.tr_name_len - 1) DIV
          sizeof (trig_ptr^.strigger.tr_stack[1]) + 1;
    last_trig_ptr := trig_ptr;
    e             := e_ok;
    REPEAT
        BEGIN
        min := csp_maxint2;
        FOR jx := 1 TO cak262_max_pos_info DO
            BEGIN
            IF  (compile_glob.cp_pos_info[jx] <> cak_is_undefined) AND
                (compile_glob.cp_pos_info[jx] < min)
            THEN
                BEGIN
                min_jx := jx;
                min    := compile_glob.cp_pos_info[jx];
                END;
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        IF  min <> csp_maxint2
        THEN
            BEGIN
            is_old := min_jx > MAX_COL_PER_TAB_GG00;
            IF  is_old
            THEN
                col_no := min_jx - MAX_COL_PER_TAB_GG00
            ELSE
                col_no := min_jx;
            (*ENDIF*) 
            a06extcolno (acv.a_p_arr1.pbasep^.sbase, col_no, col_ptr);
            IF  col_ptr = NIL
            THEN
                a07ak_system_error (acv, 262, 2)
            ELSE
                BEGIN
                trig_ptr^.strigger.tr_param_cnt :=
                      trig_ptr^.strigger.tr_param_cnt + 1;
                IF  trig_ptr <> last_trig_ptr
                THEN
                    last_trig_ptr^.strigger.tr_param_cnt :=
                          last_trig_ptr^.strigger.tr_param_cnt + 1;
                (*ENDIF*) 
                IF  tr_offset + last_trig_ptr^.strigger.tr_param_cnt > cak_max_trigger_stack
                THEN
                    BEGIN
                    IF  trig_ptr <> last_trig_ptr
                    THEN
                        BEGIN
                        a10rel_sysinfo (last_trig_ptr);
                        a10add_sysinfo (acv, last_trig_ptr, e)
                        END;
                    (*ENDIF*) 
                    IF  e = e_ok
                    THEN
                        BEGIN
                        sysk := last_trig_ptr^.syskey;
                        a06inc_linkage (sysk.slinkage);
                        a10_nil_get_sysinfo (acv, sysk, d_fix,
                              sizeof(tak_triggerrecord), last_trig_ptr, e);
                        END;
                    (*ENDIF*) 
                    IF  e = e_ok
                    THEN
                        BEGIN
                        tr_offset                              := 0;
                        last_trig_ptr^.strigger.tr_param_cnt   := 1;
                        last_trig_ptr^.strigger.tr_succ_exists := false;
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  e = e_ok
                THEN
                    WITH last_trig_ptr^.strigger DO
                        BEGIN
                        tr_stack[tr_offset + tr_param_cnt] := col_ptr^.ccolstack;
&                       ifdef trace
                        t01int4 (ak_sem, 'colno       ', col_no);
                        t01stackentry (ak_sem, tr_stack[tr_offset + tr_param_cnt], tr_param_cnt);
&                       endif
                        WITH tr_stack[tr_offset + tr_param_cnt] DO
                            BEGIN
                            IF  col_ptr^.cdatatyp = ddate
                            THEN
                                elen_var := 1 + mxsp_date
                            ELSE
                                IF  col_ptr^.cdatatyp = dtime
                                THEN
                                    elen_var := 1 + mxsp_time
                                ELSE
                                    IF  col_ptr^.cdatatyp = dtimestamp
                                    THEN
                                        elen_var := 1 + mxsp_timestamp
                                    ELSE
                                        IF  (col_ptr^.cdatatyp = dcha) AND
                                            g01unicode
                                        THEN
                                            eop := op_translate
                                        ELSE
                                            eop := op_none;
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                (*ENDIF*) 
                            (*ENDIF*) 
                            ecol_tab[1] := chr(ord(is_old))
                            END;
                        (*ENDWITH*) 
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
                ix := acv.a_mblock.mb_qual^.mqual_pos;
                WHILE ix < acv.a_mblock.mb_qual^.mqual_pos +
                      acv.a_mblock.mb_qual^.mqual_cnt - 1 DO
                    BEGIN
                    IF  acv.a_mblock.mb_st^[ix].etype = st_parseid
                    THEN
                        BEGIN (* sql stmt found, build parameter description *)
                        FOR kx := 1 TO acv.a_mblock.mb_st^[ix].epos DO
                            BEGIN
                            IF  acv.a_mblock.mb_st^[ix + 2 + kx].epos = min_jx
                            THEN
                                acv.a_mblock.mb_st^[ix + 2 + kx].eindex := acv.a_mblock.mb_qual^.mfirst_free;
                            (*ENDIF*) 
                            END;
                        (*ENDFOR*) 
                        ix := ix + 2 + acv.a_mblock.mb_st^[ix].epos
                        END;
                    (*ENDIF*) 
                    ix := ix + 1
                    END;
                (*ENDWHILE*) 
                IF  (col_ptr^.cdatatyp = dcha) AND g01unicode
                THEN
                    inOutLength := 1 + col_ptr^.cdatalen * 2
                ELSE
                    inOutLength := col_ptr^.cinoutlen;
                (*ENDIF*) 
                (* create debug info, i.e. mapping of old and new columns *)
                (* this enables debugging of new and OLD values           *)
                IF  compile_glob.cp_pDebugColMap^.med_count < cak_max_debug_mapping
                THEN
                    BEGIN
                    compile_glob.cp_pDebugColMap^.med_count :=
                          compile_glob.cp_pDebugColMap^.med_count + 1;
                    WITH  compile_glob.cp_pDebugColMap^.med_mapping[
                         compile_glob.cp_pDebugColMap^.med_count] DO
                        BEGIN
                        IF  is_old
                        THEN
                            dmi_extcolno   := col_ptr^.creccolno + cak262_old_flag
                        ELSE
                            dmi_extcolno   := col_ptr^.creccolno;
                        (*ENDIF*) 
                        dmi_rec_pos    := compile_glob.cp_pos_info[min_jx];
                        END;
                    (*ENDWITH*) 
                    END;
                (*ENDIF*) 
                ak262emit (acv, st_dummy,
                      compile_glob.cp_pos_info[min_jx], inOutLength);
                WITH acv.a_mblock.mb_st^[acv.a_mblock.mb_qual^.mfirst_free-1] DO
                    BEGIN
                    IF  g01unicode AND (col_ptr^.cdatatyp = dcha)
                    THEN
                        ecol_tab[1] := chr(dunicode)
                    ELSE
                        ecol_tab[1] := chr(col_ptr^.cdatatyp);
                    (*ENDIF*) 
                    ecol_tab[2] := chr(col_ptr^.cdatafrac)
                    END;
                (*ENDWITH*) 
                compile_glob.cp_pos_info[min_jx] := cak_is_undefined;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    UNTIL
        (min = csp_maxint2) OR (acv.a_returncode <> 0) OR (e <> e_ok);
    (*ENDREPEAT*) 
    ak262StoreDebugInfo (acv, compile_glob, cak262_is_column_map);
    (* Describe local variables used as parameters *)
    ak262describeParameterVariables (acv, compile_glob);
    END;
(*ENDIF*) 
ak262FinishCompilation (acv, compile_glob,
      trig_ptr^.syskey.stableid, trig_ptr^.syskey.slinkage)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262AdjustStackEntries (
            VAR acv          : tak_all_command_glob;
            VAR compile_glob : tak262compile_glob);
 
CONST
      c_is_trigger      = true;
 
VAR
      is_old               : boolean;
      updatedFunctionFound : boolean;
      col_ix               : integer;
      ix                   : integer;
      inOutLength          : integer;
      col_ptr              : tak00_colinfo_ptr;
 
BEGIN
acv.a_mblock.mb_qual^.mqual_cnt := (* PTS 1107990 *)
      acv.a_mblock.mb_qual^.mfirst_free - acv.a_mblock.mb_qual^.mqual_pos;
&ifdef trace
t01messblock (sproc_call, 'a_mblock 1  ', acv.a_mblock);
&endif
updatedFunctionFound := false;
FOR ix := acv.a_mblock.mb_qual^.mqual_pos TO
      acv.a_mblock.mb_qual^.mqual_pos +
      acv.a_mblock.mb_qual^.mqual_cnt - 1 DO
    BEGIN
    IF  (acv.a_mblock.mb_st^[ix].etype = st_op) AND
        (acv.a_mblock.mb_st^[ix].eop   = op_updated)
    THEN
        BEGIN
        IF  acv.a_mblock.mb_st^[ix].ecol_pos > compile_glob.cp_trig_ptr^.strigger.tr_maxUpdatedColno
        THEN
            compile_glob.cp_trig_ptr^.strigger.tr_maxUpdatedColno := acv.a_mblock.mb_st^[ix].ecol_pos;
        (*ENDIF*) 
        updatedFunctionFound := true;
        END;
    (*ENDIF*) 
    is_old := true;
    CASE acv.a_mblock.mb_st^[ix].etype OF
        st_old_fixkey :
            acv.a_mblock.mb_st^[ix].etype := st_fixkey;
        st_old_varkey :
            acv.a_mblock.mb_st^[ix].etype := st_varkey;
        st_old_fixcol :
            acv.a_mblock.mb_st^[ix].etype := st_fixcol;
        st_old_varcol :
            acv.a_mblock.mb_st^[ix].etype := st_varcol;
        st_old_varlongchar :
            acv.a_mblock.mb_st^[ix].etype := st_varlongchar;
        OTHERWISE
            is_old := false;
        END;
    (*ENDCASE*) 
    col_ptr := NIL;
    IF  acv.a_mblock.mb_st^[ix].etype in
        [st_fixkey, st_varkey, st_fixcol, st_varcol, st_varlongchar]
    THEN
        BEGIN
        IF  acv.a_mblock.mb_st^[ix].ecol_tab[1] = chr(cak00_col_with_inv)
        THEN (* PTS 1107374 *)
            acv.a_mblock.mb_st^[ix].ecol_tab[1] := chr(0);
        (*ENDIF*) 
        IF  acv.a_mblock.mb_st^[ix].ecol_tab[2] > chr(1) (* tabno > 1 ==> local variable *)
        THEN
            BEGIN
            (* stack entry describes a local variable of the trigger code *)
            (* which is located as 'OLD' column in VKB71                  *)
            CASE acv.a_mblock.mb_st^[ix].etype OF
                st_fixkey :
                    acv.a_mblock.mb_st^[ix].etype := st_old_fixkey;
                st_fixcol :
                    acv.a_mblock.mb_st^[ix].etype := st_old_fixcol;
                END;
            (*ENDCASE*) 
            acv.a_mblock.mb_st^[ix].ecol_tab[2] := chr(1)
            END
        ELSE
            BEGIN
            IF  acv.a_returncode = 0
            THEN
                a06find_colinfo (acv.a_p_arr1.pbasep,
                      acv.a_mblock.mb_st^[ix], col_ptr)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        IF  (acv.a_mblock.mb_st^[ix].etype = st_assign) AND (acv.a_mblock.mb_st^[ix].epos < 0)
        THEN
            BEGIN (* assignment to trigger column *)
            a06extcolno (acv.a_p_arr1.pbasep^.sbase, -acv.a_mblock.mb_st^[ix].epos, col_ptr);
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  col_ptr <> NIL
    THEN
        BEGIN
        IF  is_old
        THEN
            col_ix := MAX_COL_PER_TAB_GG00 + col_ptr^.creccolno
        ELSE
            col_ix := col_ptr^.creccolno;
        (*ENDIF*) 
        IF  (col_ptr^.cdatatyp = dcha) AND g01unicode
        THEN
            inOutLength := 1 + col_ptr^.cdatalen * 2
        ELSE
            inOutLength := col_ptr^.cinoutlen;
        (*ENDIF*) 
        IF  compile_glob.cp_pos_info[col_ix] = cak_is_undefined
        THEN
            BEGIN
            compile_glob.cp_pos_info[col_ix] :=
                  compile_glob.cp_rec_pos;
            compile_glob.cp_rec_pos :=
                  compile_glob.cp_rec_pos + inOutLength
            END;
        (*ENDIF*) 
        IF  acv.a_mblock.mb_st^[ix].etype <> st_assign
        THEN
            acv.a_mblock.mb_st^[ix].etype := st_fixcol;
        (*ENDIF*) 
        acv.a_mblock.mb_st^[ix].epos     := compile_glob.cp_pos_info[col_ix];
        acv.a_mblock.mb_st^[ix].elen_var := inOutLength;
        END;
    (*ENDIF*) 
    END;
(*ENDFOR*) 
IF  updatedFunctionFound
THEN
    BEGIN
&   ifdef trace
    t01int4 (sproc_call, 'updatedfound', 1);
    t01int4 (sproc_call, 'cp_rec_pos  ', compile_glob.cp_rec_pos);
&   endif
    FOR ix := acv.a_mblock.mb_qual^.mqual_pos TO
          acv.a_mblock.mb_qual^.mqual_pos +
          acv.a_mblock.mb_qual^.mqual_cnt - 1 DO
        BEGIN
        IF  (acv.a_mblock.mb_st^[ix].etype = st_op     ) AND
            (acv.a_mblock.mb_st^[ix].eop   = op_updated)
        THEN
            BEGIN
            acv.a_mblock.mb_st^[ix].epos     := compile_glob.cp_rec_pos;
            acv.a_mblock.mb_st^[ix].elen_var :=
                  compile_glob.cp_trig_ptr^.strigger.tr_maxUpdatedColno;
            END;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    compile_glob.cp_rec_pos := compile_glob.cp_rec_pos +
          (compile_glob.cp_trig_ptr^.strigger.tr_maxUpdatedColno + 7) DIV 8;
    END;
&ifdef trace
(*ENDIF*) 
t01messblock (sproc_call, 'a_mblock 2  ', acv.a_mblock);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262AddDebugInfo (
            VAR acv            : tak_all_command_glob;
            VAR compile_glob   : tak262compile_glob;
            stackIndex         : integer;
            codePos            : integer;
            codeLength         : integer);
 
VAR
      count : integer;
 
BEGIN
count := compile_glob.cp_pDebugInfo^.med_count;
IF  count > 0
THEN
    compile_glob.cp_pDebugInfo^.med_info[count].dbg_code_length :=
          codePos - compile_glob.cp_pDebugInfo^.med_info[count].dbg_code_pos;
(*ENDIF*) 
count := count + 1;
compile_glob.cp_pDebugInfo^.med_count := count;
WITH compile_glob.cp_pDebugInfo^.med_info[count] DO
    BEGIN
    dbg_stack_entry_index := stackIndex;
    dbg_code_length       := codeLength;
    dbg_code_pos          := codePos;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262CreateDebugInfo (
            VAR acv            : tak_all_command_glob;
            VAR compile_glob   : tak262compile_glob;
            IsTrigger          : boolean;
            ColumnMapSize      : integer);
 
VAR
      required   : integer;
      e          : tgg00_BasisError;
      pDebugInfo : tak_sysbufferaddress;
      sysk       : tgg00_SysInfoKey;
 
BEGIN
sysk := a01defaultkey;
IF  IsTrigger
THEN
    BEGIN
    sysk.stableid  := compile_glob.cp_trigTabid;
    sysk.slinkage  := compile_glob.cp_trig_kind;
    END
ELSE
    sysk.stableid  := compile_glob.cp_procId;
(*ENDIF*) 
sysk.sentrytyp := cak_emethoddebuginfo;
IF  ColumnMapSize > 0
THEN
    BEGIN
    IF  ColumnMapSize > cak_max_debug_mapping
    THEN
        ColumnMapSize := cak_max_debug_mapping;
    (*ENDIF*) 
    sysk.slinkage[1] := chr(1);
    required         := cak_sysbufferoffset + 4 +
          ColumnMapSize * sizeof (tak_debug_mapping_info);
    END
ELSE
    required := sizeof (tak_method_debuginfo);
(*ENDIF*) 
a10_nil_get_sysinfo (acv, sysk, d_fix, required, pDebugInfo, e);
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1)
ELSE
    BEGIN
    IF  ColumnMapSize > 0
    THEN
        compile_glob.cp_pDebugColMap := @pDebugInfo^
    ELSE
        compile_glob.cp_pDebugInfo := @pDebugInfo^;
    (*ENDIF*) 
    pDebugInfo^.smethoddebuginfo.med_segmentid := cgg_zero_c2;
    pDebugInfo^.smethoddebuginfo.med_count     := 0;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262StoreDebugInfo (
            VAR acv            : tak_all_command_glob;
            VAR compile_glob   : tak262compile_glob;
            isColumnMap        : boolean);
 
VAR
      e           : tgg00_BasisError;
      ix          : integer;
      jx          : integer;
      minPos      : integer;
      currPos     : integer;
      elementSize : integer;
      pDebugInfo  : tak_sysbufferaddress;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  isColumnMap
    THEN
        BEGIN
        pDebugInfo  := @compile_glob.cp_pDebugColMap^;
        elementSize := sizeof(tak_debug_mapping_info);
        END
    ELSE
        BEGIN
        FOR ix := 1 TO compile_glob.cp_pDebugInfo^.med_count DO
            BEGIN
            currPos := compile_glob.cp_pDebugInfo^.med_info[ix].dbg_code_pos;
            minPos  := acv.a_cmd_part^.sp1p_buf_len + 1;
            FOR jx := 1 TO compile_glob.cp_pDebugInfo^.med_count DO
                IF  compile_glob.cp_pDebugInfo^.med_info[jx].dbg_code_pos > currPos
                THEN
                    IF  compile_glob.cp_pDebugInfo^.med_info[jx].dbg_code_pos < minPos
                    THEN
                        minPos := compile_glob.cp_pDebugInfo^.med_info[jx].dbg_code_pos;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDFOR*) 
            compile_glob.cp_pDebugInfo^.med_info[ix].dbg_code_length :=
                  minPos - compile_glob.cp_pDebugInfo^.med_info[ix].dbg_code_pos;
            END;
        (*ENDFOR*) 
        pDebugInfo  := @compile_glob.cp_pDebugInfo^;
        elementSize := sizeof(tak_debug_info);
        END;
    (*ENDIF*) 
    IF  pDebugInfo^.smethoddebuginfo.med_count > 0
    THEN
        BEGIN
        pDebugInfo^.smethoddebuginfo.med_reclen :=
              sizeof (pDebugInfo^.smethoddebuginfo) -
              sizeof (pDebugInfo^.smethoddebuginfo.med_info) +
              pDebugInfo^.smethoddebuginfo.med_count * elementSize;
        a10add_sysinfo (acv, pDebugInfo, e);
        IF  e <> e_ok
        THEN
            a07_b_put_error (acv, e, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262StoreStmtAndComplile (
            VAR acv            : tak_all_command_glob;
            VAR compile_glob   : tak262compile_glob;
            tree_index         : integer;
            VariablesStackSize : tsp00_Int4;
            IsTrigger          : boolean;
            IsDBFunction       : boolean);
 
VAR
      defByte     : char;
      ColIdx      : integer;
      ParamNo     : integer;
      maxParamPos : tsp00_Int4;
      paramIdx    : integer;
      LoopInfo    : tak262LoopInfo;
      mb_type2    : tgg00_MessType2;
 
BEGIN
ak262InitLoopInfo (LoopInfo);
(* store create trigger or dbproc statement *)
ak262store_create_stmt (acv, compile_glob);
(* compile into kb stack code *)
IF  IsDBFunction
THEN
    mb_type2 := mm_ignore
ELSE
    IF  IsTrigger
    THEN
        mb_type2 := mm_trigger
    ELSE
        mb_type2 := mm_nil;
    (*ENDIF*) 
(*ENDIF*) 
a06a_mblock_init (acv, m_nil, mb_type2, acv.a_p_arr1.pbasep^.sbase.btreeid);
IF  cgg_rec_key_offset + VariablesStackSize > acv.a_mblock.mb_data_size
THEN
    a07_b_put_error (acv, e_too_many_mb_data, 1)
ELSE
    ak262CreateDebugInfo (acv, compile_glob, IsTrigger, 0);
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    acv.a_mblock.mb_qual^.mbool           := true;
    acv.a_mblock.mb_qual^.msqlmode        := acv.a_sqlmode;
    acv.a_mblock.mb_qual^.mdatetimeformat := acv.a_dt_format;
    IF  IsDBFunction
    THEN
        BEGIN
        (* set all variables to null *)
        SAPDB_PascalFill ('VAK262',  36,    
              acv.a_mblock.mb_data_size, @acv.a_mblock.mb_data^.mbp_buf,
              cgg_rec_key_offset + 1, VariablesStackSize,
              csp_undef_byte, acv.a_returncode);
        (* set $rc := 0 *)
        SAPDB_PascalMove ('VAK262',  37,    
              sizeof(g01glob.rescnt_0), VariablesStackSize,
              @g01glob.rescnt_0, 1, @acv.a_mblock.mb_data^.mbp_buf, cgg_rec_key_offset + 1,
              (cak262_rc_digits + 1) DIV 2 + 2, acv.a_returncode);
        END
    ELSE
        IF  NOT IsTrigger
        THEN
            WITH acv.a_mblock, mb_qual^ DO
                BEGIN
                (* initialize space for dbproc parameters *)
                IF  compile_glob.cp_first_var_pos > 0
                THEN
                    maxParamPos := compile_glob.cp_first_var_pos
                ELSE
                    maxParamPos := csp_maxint4;
                (*ENDIF*) 
                paramIdx  := acv.a_p_arr1.pbasep^.sbase.bfirstcolind;
                WHILE paramIdx <> 0 DO
                    WITH acv.a_p_arr1.pbasep^.sbase.bcolumn[paramIdx]^ DO
                        BEGIN
                        IF  ccolstack.epos < maxParamPos
                        THEN
                            BEGIN
                            CASE cdatatyp OF
                                ddate, dtime, dtimestamp :
                                    defByte := csp_ascii_blank;
                                OTHERWISE
                                    defByte := csp_defined_byte;
                                END;
                            (*ENDCASE*) 
                            SAPDB_PascalFill ('VAK262',  38,    
                                  acv.a_mblock.mb_data_size, @acv.a_mblock.mb_data^.mbp_buf,
                                  cgg_rec_key_offset + ccolstack.epos, ccolstack.elen_var,
                                  defByte, acv.a_returncode);
&                           ifdef trace
                            t01moveobj (ak_sem, acv.a_mblock.mb_data^.mbp_buf,
                                  cgg_rec_key_offset + ccolstack.epos,
                                  cgg_rec_key_offset + ccolstack.epos + ccolstack.elen_var - 1);
&                           endif
                            END;
                        (*ENDIF*) 
                        paramIdx := cnextind
                        END;
                    (*ENDWITH*) 
                (*ENDWHILE*) 
                mcol_pos := compile_glob.cp_cursor_pos;
                (* create stack entry used to initialize local variables *)
                (* see vak260                                            *)
                IF  compile_glob.cp_first_var_pos > 0
                THEN
                    BEGIN
                    mstring_pos                  := mfirst_free;
                    mstring_cnt                  := 1;
                    mb_st^[mstring_pos].etype    := st_value;
                    mb_st^[mstring_pos].eop      := op_none;
                    mb_st^[mstring_pos].epos     := compile_glob.cp_first_var_pos;
                    mb_st^[mstring_pos].elen_var := VariablesStackSize -
                          compile_glob.cp_first_var_pos + 1;
                    mb_st^[mstring_pos].ecol_tab := cgg_zero_c2;
                    mfirst_free                  := mfirst_free + 1;
                    END;
                (* reserve stack entry for st_jump_output *)
                (*ENDIF*) 
                mqual_pos := mfirst_free;
                (* reserve stack entry for st_jump_output *)
                mfirst_free               := mfirst_free + 1;
                (* create stack code to reset retpart *)
                ak262emit (acv, st_output_param, -1, 0);
                IF  compile_glob.cp_out_params <> []
                THEN
                    BEGIN (* create stack code for output parameters *)
                    ParamNo := 0;
                    ColIdx  := acv.a_p_arr1.pbasep^.sbase.bfirstcolind;
                    WHILE ColIdx <> 0 DO
                        WITH acv.a_p_arr1.pbasep^.sbase.bcolumn[ColIdx]^ DO
                            BEGIN
                            IF  cextcolno in compile_glob.cp_out_params
                            THEN
                                BEGIN
                                mb_st^[mfirst_free] := ccolstack;
                                mb_st^[mfirst_free].ecol_tab[2] := chr(2);
                                mfirst_free                     := mfirst_free + 1;
                                mb_st^[mfirst_free].etype       := st_output_param;
                                ParamNo                         := ParamNo + 1;
                                mb_st^[mfirst_free].epos        := ParamNo;
                                mb_st^[mfirst_free].ecol_tab[1] := chr(compile_glob.cp_isCursorDBProc);
                                mb_st^[mfirst_free].ecol_tab[2] := chr(ord(cdatatyp));
                                mfirst_free := mfirst_free + 1
                                END;
                            (*ENDIF*) 
                            ColIdx := cnextind
                            END;
                        (*ENDWITH*) 
                    (*ENDWHILE*) 
                    END;
                (*ENDIF*) 
                mb_st^[mqual_pos].etype := st_jump_output;
                mb_st^[mqual_pos].epos  := mfirst_free - mqual_pos + 1;
                mqual_cnt := mfirst_free - mqual_pos;
                END
            (*ENDWITH*) 
        ELSE
            WITH acv.a_mblock, mb_qual^ DO
                BEGIN
                mstring_pos                  := mfirst_free;
                mstring_cnt                  := 1;
                mb_st^[mstring_pos].etype    := st_value;
                mb_st^[mstring_pos].eop      := op_none;
                mb_st^[mstring_pos].epos     := 1;
                mb_st^[mstring_pos].elen_var := cgg_rec_key_offset + VariablesStackSize;
                mb_st^[mstring_pos].ecol_pos := 0;
                mfirst_free                  := mfirst_free + 1;
                VariablesStackSize           := 0;
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
    (* reserve space for variables *)
    acv.a_mblock.mb_data_len                  := cgg_rec_key_offset + VariablesStackSize;
    acv.a_mblock.mb_data^.mbp_rec.recLen_gg00 := cgg_rec_key_offset + VariablesStackSize;
    ak262compile            (acv, tree_index, 0, 0, LoopInfo, compile_glob);
    ak262AdjustStackEntries (acv, compile_glob);
    ak262emit (acv, st_stop, 0, 0);
    acv.a_mblock.mb_type := m_procedure;
    IF  IsDBFunction
    THEN
        acv.a_mblock.mb_st^[acv.a_mblock.mb_qual^.mfirst_free-1].eop := op_null;
    (*ENDIF*) 
    ak262StoreDebugInfo (acv, compile_glob, NOT cak262_is_column_map);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262StoreVarTable (
            VAR acv          : tak_all_command_glob;
            VAR surrogate    : tgg00_Surrogate);
 
VAR
      e          : tgg00_BasisError;
      PermSyskey : tgg00_SysInfoKey;
 
BEGIN
PermSyskey                            := a01defaultkey;
PermSyskey.stableid                   := surrogate;
PermSyskey.sentrytyp                  := cak_etable;
acv.a_p_arr1.pbasep^.sbase.btablekind := tempty; (* signal that there's no underlying data file *)
a10StoreAs (acv, acv.a_p_arr1.pbasep^.syskey, PermSyskey, e);
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e , 1)
ELSE
    acv.a_p_arr1.pbasep^.sbase.btablekind := twithoutkey; (* parser requires base table flag *)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262FinishCompilation (
            VAR acv          : tak_all_command_glob;
            VAR compile_glob : tak262compile_glob;
            VAR tabid        : tgg00_Surrogate;
            linkage          : tsp00_C2);
 
VAR
      ok         : boolean;
      e          : tgg00_BasisError;
      sysk       : tgg00_SysInfoKey;
      mblock_ptr : tak_sysbufferaddress;
      pBase      : tak_sysbufferaddress;
 
BEGIN
acv.a_mblock.mb_qual^.mqual_cnt := acv.a_mblock.mb_qual^.mfirst_free -
      acv.a_mblock.mb_qual^.mqual_pos;
acv.a_mblock.mb_qual^.mst_max   := acv.a_mblock.mb_qual^.mfirst_free - 1;
acv.a_mblock.mb_qual^.mtree.fileTabId_gg00 := tabid;
(* store owner id of dbproc owner in mlinktree *)
acv.a_mblock.mb_qual^.mlinktree.fileTabId_gg00 := acv.a_curr_user_id;
acv.a_mblock.mb_qual_len := acv.a_mblock.mb_qual_len +
      sizeof (acv.a_mblock.mb_qual^.mlinktree);
&ifdef trace
t01messblock (sproc_call, '--> compiled', acv.a_mblock);
&endif
sysk.stableid  := tabid;
sysk.sentrytyp := cak_epermmessblock;
sysk.slinkage  := linkage;
sysk.skeylen   := mxak_standard_sysk;
a10mblock_into_cache (acv, sysk, acv.a_mblock, d_release, mblock_ptr, e);
IF  e = e_ok
THEN
    a10add_sysinfo (acv, mblock_ptr, e);
(*ENDIF*) 
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1)
ELSE
    BEGIN
    a06_systable_get (acv, d_release, compile_glob.cp_varTabId, pBase, cak262_all_base, ok);
    IF  ok
    THEN
        pBase^.sbase.btablekind := tdb2view;
    (*ENDIF*) 
    a11drop_table  (acv, compile_glob.cp_varTabId,
          twithoutkey, false);
    acv.a_p_arr1.pbasep := compile_glob.cp_base_table
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262emit (
            VAR acv : tak_all_command_glob;
            etype : tgg00_StackEntryType;
            pos   : tsp00_Int2;
            len   : tsp00_Int2);
 
BEGIN
WITH acv.a_mblock, mb_qual^ DO
    IF  mfirst_free <= mb_st_max
    THEN
        BEGIN
        mb_st^[mfirst_free].etype    := etype;
        mb_st^[mfirst_free].eop      := op_none;
        mb_st^[mfirst_free].epos     := pos;
        mb_st^[mfirst_free].elen_var := len;
        mb_st^[mfirst_free].eindex   := 0;
        IF  etype = st_jump_false
        THEN
            mb_st^[mfirst_free].ecol_tab[1] := chr(1);
&       ifdef trace
        (*ENDIF*) 
        t01stackentry (ak_sem, mb_st^[mfirst_free], mfirst_free);
&       endif
        (* PTS 1107754 *)
        IF  mfirst_free - mqual_pos + 1 > mqual_cnt
        THEN
            mqual_cnt := mfirst_free - mqual_pos + 1;
        (*ENDIF*) 
        mfirst_free := mfirst_free + 1
        END
    ELSE
        a07_b_put_error (acv,
              e_too_many_mb_stackentries, -mb_st_max);
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262describeParameterVariables (
            VAR acv           :  tak_all_command_glob;
            VAR compile_glob  : tak262compile_glob);
 
VAR
      ok      : boolean;
      ix      : integer;
      jx      : integer;
      colno   : integer;
      basep   : tak_sysbufferaddress;
      col_ptr : tak00_colinfo_ptr;
      msg     : tsp00_C30;
 
BEGIN
a06_systable_get (acv, d_release, compile_glob.cp_varTabId, basep, cak262_all_base, ok);
IF  ok
THEN
    BEGIN
    FOR ix := acv.a_mblock.mb_qual^.mqual_pos TO
          acv.a_mblock.mb_qual^.mqual_pos +
          acv.a_mblock.mb_qual^.mqual_cnt - 1 DO
        IF  (acv.a_mblock.mb_st^[ix].etype = st_dummy) AND
            (acv.a_mblock.mb_st^[ix].epos  < 0)
        THEN
            BEGIN
            colno := -acv.a_mblock.mb_st^[ix].epos;
            a06extcolno (basep^.sbase, colno, col_ptr);
            IF  col_ptr = NIL
            THEN
                a07ak_system_error (acv, 262, 2)
            ELSE
                BEGIN
                FOR jx := ix TO acv.a_mblock.mb_qual^.mqual_pos +
                      acv.a_mblock.mb_qual^.mqual_cnt - 1 DO
                    IF  (acv.a_mblock.mb_st^[jx].etype = st_dummy) AND
                        (acv.a_mblock.mb_st^[jx].epos  = -colno)
                    THEN
                        BEGIN
                        acv.a_mblock.mb_st^[jx].eindex := acv.a_mblock.mb_qual^.mfirst_free;
                        END;
                    (*ENDIF*) 
                (*ENDFOR*) 
                ak262emit (acv, st_dummy, col_ptr^.ccolstack.epos, col_ptr^.cinoutlen);
                WITH acv.a_mblock.mb_st^[acv.a_mblock.mb_qual^.mfirst_free-1] DO
                    BEGIN
                    IF  col_ptr^.ccolstack.etype = st_param
                    THEN
                        IF  ctaltered in col_ptr^.ccolpropset
                        THEN
                            BEGIN
                            msg := 'parameter of unknown size     ';
                            a07_const_b_put_error (acv, e_not_implemented, 1,
                                  @msg, sizeof(msg))
                            END
                        ELSE
                            eop := op_fixed
                        (*ENDIF*) 
                    ELSE
                        eop := op_true;
                    (*ENDIF*) 
                    ecol_tab[1] := chr(col_ptr^.cdatatyp);
                    ecol_tab[2] := chr(col_ptr^.cdatafrac)
                    END
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDFOR*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262compile  (
            VAR acv              : tak_all_command_glob;
            tree_index           : integer;
            CatchBlockStackEntry : tsp00_Int4;
            CaseStackEntry       : tsp00_Int4;
            LoopInfo             : tak262LoopInfo;
            VAR compile_glob     : tak262compile_glob);
 
VAR
      prevDebugInfoIdx : integer;
      stmt_kind        : integer;
      ti               : integer;
      qual_pos         : integer;
      pPacket          : tsp00_MoveObjPtr;
 
BEGIN
&ifdef trace
t01int4 (ak_sem, 'tree_index  ', tree_index);
&endif
prevDebugInfoIdx := 0;
IF  acv.a_mblock.mb_qual^.mqual_pos = 0
THEN
    acv.a_mblock.mb_qual^.mqual_pos := acv.a_mblock.mb_qual^.mfirst_free;
(*ENDIF*) 
qual_pos := acv.a_mblock.mb_qual^.mqual_pos;
WHILE (tree_index <> 0) AND (acv.a_returncode = 0) DO
    BEGIN
&   ifdef trace
    t01messblock (ak_sem, 'a_mblockloop', acv.a_mblock );
&   endif
    ak262AddDebugInfo (acv, compile_glob, acv.a_mblock.mb_qual^.mfirst_free,
          acv.a_ap_tree^[tree_index].n_pos, acv.a_cmd_part^.sp1p_buf_len);
    stmt_kind := acv.a_ap_tree^[tree_index].n_subproc;
    CASE stmt_kind OF
        cak_i_break :
            ak262Break (acv, LoopInfo.lp_BreakStackEntry, LoopInfo.lp_InLoop);
        cak_i_continue :
            ak262Continue (acv, acv.a_ap_tree^[tree_index].n_pos = cak_i_execute,
                  LoopInfo);
        cak_i_do :
            ak262DoWhileLoopStatement(acv,
                  acv.a_ap_tree^[tree_index].n_sa_level, CatchBlockStackEntry,
                  LoopInfo, compile_glob);
        cak_i_if, cak_i_while :
            BEGIN
            ak262IforWhileStatement (acv, stmt_kind = cak_i_if,
                  acv.a_ap_tree^[tree_index].n_sa_level,  CatchBlockStackEntry,
                  LoopInfo, compile_glob);
            END;
        cak_i_execute, cak_i_close, cak_i_drop :
            BEGIN
            ti := acv.a_ap_tree^[tree_index].n_sa_level;
            IF  acv.a_ap_tree^[ti].n_proc = a999ptr_node
            THEN
                BEGIN (* internal packet containing an expression insert *)
                pPacket := a01node_get_ptr (acv, ti);
                a542push_packet (acv, pPacket);
                ti := acv.a_ap_tree^[ti].n_lo_level
                END
            ELSE
                pPacket := NIL;
            (*ENDIF*) 
            ak262sql_stmt (acv, ti, CatchBlockStackEntry, LoopInfo.lp_TryCatchLevel,
                  stmt_kind= cak_i_execute, compile_glob);
            ak262store_sql_stmt (acv, tree_index, compile_glob);
            IF  pPacket <> NIL
            THEN
                a542pop_packet (acv);
            (*ENDIF*) 
            END;
        cak_i_return :
            ak262ReturnStatement(acv, tree_index, compile_glob);
        cak_i_set :
            ak262assign_stmt    (acv, acv.a_ap_tree^[tree_index].n_sa_level, compile_glob);
        cak_i_dynamic :
            ak262DynamicSqlStatement (acv, acv.a_ap_tree^[tree_index].n_sa_level,
                  CatchBlockStackEntry, compile_glob);
        cak_i_stop :
            ak262stop_stmt (acv, acv.a_ap_tree^[tree_index].n_sa_level, compile_glob);
        cak_i_case :
            ak262CaseStatement (acv, tree_index, CatchBlockStackEntry,
                  LoopInfo, compile_glob);
        cak_i_try :
            ak262TryCatchBlock (acv, acv.a_ap_tree^[tree_index].n_sa_level, LoopInfo, compile_glob);
        cak_i_when :
            ak262WhenStatement (acv, acv.a_ap_tree^[tree_index].n_sa_level,
                  CatchBlockStackEntry, CaseStackEntry, LoopInfo, compile_glob);
        OTHERWISE
            a07ak_system_error (acv, 262, 1);
        END;
    (*ENDCASE*) 
    tree_index := acv.a_ap_tree^[tree_index].n_lo_level;
    acv.a_mblock.mb_qual^.mqual_pos := qual_pos
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262Break (
            VAR acv         : tak_all_command_glob;
            BreakStackEntry : tsp00_Int4;
            emitBool        : boolean);
 
BEGIN
IF  emitBool
THEN
    ak262emit (acv, st_bool, cgg04_is_false, 0);
(*ENDIF*) 
ak262emit (acv, st_jump_absolute,
      BreakStackEntry - acv.a_mblock.mb_qual^.mfirst_free - 1, 0)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262Continue (
            VAR acv            : tak_all_command_glob;
            ContinueExecution  : boolean;
            VAR LoopInfo       : tak262LoopInfo);
 
BEGIN
IF  ContinueExecution
THEN
    ak262emit (acv, st_continue_execute, LoopInfo.lp_TryCatchLevel, 0)
ELSE
    ak262emit (acv, st_jump_absolute,
          LoopInfo.lp_ConditionStackEntry - acv.a_mblock.mb_qual^.mfirst_free - 1, 0)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262TryCatchBlock (
            VAR acv              : tak_all_command_glob;
            tree_index           : integer;
            LoopInfo             : tak262LoopInfo;
            VAR compile_glob     : tak262compile_glob);
 
VAR
      catch_node    : tsp00_Int4;
      st_skip_catch : tsp00_Int4;
      st_skip_body  : tsp00_Int4;
 
BEGIN
LoopInfo.lp_TryCatchLevel := LoopInfo.lp_TryCatchLevel + 1;
IF  LoopInfo.lp_TryCatchLevel >= MAX_CATCH_LEVEL_GG04
THEN
    a07_b_put_error (acv, e_too_many_catch_levels,
          acv.a_ap_tree^[tree_index].n_pos)
ELSE
    BEGIN
    (* jump absolute call to skip catch block *)
    st_skip_catch := ak262ReserveJumpAbsolute(acv);
    (* compile catch block first *)
    catch_node := acv.a_ap_tree^[tree_index].n_sa_level;
    ak262compile (acv, acv.a_ap_tree^[catch_node].n_lo_level, 0, 0, LoopInfo, compile_glob);
    st_skip_body := ak262ReserveJumpAbsolute (acv);
    ak262SetJumpAbsolute (acv, st_skip_catch);
    (* compile try/catch body *)
    ak262compile (acv, acv.a_ap_tree^[tree_index].n_lo_level,
          st_skip_catch + 1, 0, LoopInfo, compile_glob);
    ak262SetJumpAbsolute (acv, st_skip_body);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262SetJumpAbsolute (
            VAR acv        : tak_all_command_glob;
            StJumpAbsolute : tsp00_Int4);
 
BEGIN
acv.a_mblock.mb_st^[StJumpAbsolute].epos :=
      acv.a_mblock.mb_qual^.mfirst_free - StJumpAbsolute - 1;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262assign_stmt (
            VAR acv              : tak_all_command_glob;
            tree_index           : integer;
            VAR compile_glob     : tak262compile_glob);
 
VAR
      is_ddl          : tak_ddl_descriptor;
      initProcCompile : tak_proc_compile_type;
      st              : tgg00_StackEntry;
      pDfa            : tak262_dfarr_ptr;
      pDmli           : tak262_dmli_ptr;
 
BEGIN
pDmli := ak262NewDmli  (acv, compile_glob);
pDfa  := ak262NewDfarr (acv);
IF  acv.a_returncode = 0
THEN
    BEGIN
    a05identifier_get (acv, tree_index, sizeof (pDmli^.d_column), pDmli^.d_column);
    pDmli^.d_vppos := acv.a_ap_tree^[tree_index].n_pos;
    a61_search_table  (acv, pDmli^);
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        st.etype           := st_assign;
        st.eop             := op_none;
        st.epos            := pDmli^.d_colbuf^.ccolstack.epos;
        st.elen_var        := pDmli^.d_colbuf^.ccolstack.elen_var;
        IF  pDmli^.d_colbuf^.ccolstack.etype = st_param
        THEN
            BEGIN
            compile_glob.cp_const_params := compile_glob.cp_const_params - [st.epos];
            st.ecol_tab[1] := chr(2)
            END
        ELSE
            IF  pDmli^.d_sparr.pbasep^.sbase.bsurrogate = compile_glob.cp_varTabId
            THEN
                st.ecol_tab[1] := chr(1)
            ELSE
                BEGIN
                st.ecol_tab[1] := chr(0);
                st.epos        := -pDmli^.d_colbuf^.creccolno;
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        st.ecol_tab[2]             := chr(ord(pDmli^.d_colbuf^.cdatatyp));
        pDmli^.d_fieldno           := 1;
        pDmli^.d_foundset          := [1];
        pDfa^[1].dml_col_ptr       := pDmli^.d_colbuf;
        pDfa^[1].dml_node          := acv.a_ap_tree^[tree_index].n_sa_level;
        is_ddl                     := acv.a_is_ddl; (* PTS 1112383 *)
        acv.a_is_ddl               := ddl_create_trigger;
        initProcCompile            := ak262SetProcCompileType (acv, compile_glob);
        ak262ModifyTriggerTable (acv, compile_glob);
        a57update_with_value_expr (acv, pDmli^, pDfa^);
        ak262RestoreTriggerTable (acv, compile_glob);
        acv.a_is_ddl       := is_ddl; (* PTS 1112383 *)
        acv.a_proc_compile := initProcCompile;
        IF  acv.a_returncode = 0
        THEN
            acv.a_mblock.mb_st^[acv.a_mblock.mb_qual^.mfirst_free - 1] := st
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
ak262FreeDmli  (acv, pDmli);
ak262FreeDfarr (acv, pDfa);
ak262MapErrorCode (acv);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262ModifyTriggerTable (
            VAR acv              : tak_all_command_glob;
            VAR compile_glob     : tak262compile_glob);
 
VAR
      ix : integer;
 
BEGIN
IF  g01unicode AND (compile_glob.cp_cnt_tables > 1)
THEN
    BEGIN
    WITH acv.a_p_arr1.pbasep^.sbase DO
        FOR ix := bfirstindex TO blastindex DO
            IF  bcolumn[ix]^.cdatatyp = dcha
            THEN
                BEGIN
                bcolumn[ix]^.cdatatyp         := dunicode;
                compile_glob.cp_modified_cols := compile_glob.cp_modified_cols
                      + [bcolumn[ix]^.creccolno];
                bcolumn[ix]^.cinoutlen          := succ(2 * bcolumn[ix]^.cdatalen);
                bcolumn[ix]^.ccolstack.elen_var := bcolumn[ix]^.cinoutlen;
                END;
            (*ENDIF*) 
        (*ENDFOR*) 
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262RestoreTriggerTable (
            VAR acv              : tak_all_command_glob;
            VAR compile_glob     : tak262compile_glob);
 
VAR
      ix : integer;
 
BEGIN
IF  compile_glob.cp_modified_cols <> []
THEN
    BEGIN
    WITH acv.a_p_arr1.pbasep^.sbase DO
        FOR ix := bfirstindex TO blastindex DO
            IF  bcolumn[ix]^.creccolno in compile_glob.cp_modified_cols
            THEN
                BEGIN
                bcolumn[ix]^.cdatatyp           := dcha;
                bcolumn[ix]^.cinoutlen          := bcolumn[ix]^.cdatalen + 1;
                bcolumn[ix]^.ccolstack.elen_var := bcolumn[ix]^.cinoutlen;
                END;
            (*ENDIF*) 
        (*ENDFOR*) 
    (*ENDWITH*) 
    compile_glob.cp_modified_cols := [];
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262DoWhileLoopStatement (
            VAR acv              : tak_all_command_glob;
            tree_index           : integer;
            CatchBlockStackEntry : tsp00_Int4;
            LoopInfo             : tak262LoopInfo;
            VAR compile_glob     : tak262compile_glob);
 
VAR
      st_loop_idx    : tsp00_Int4;
      st_break_idx   : tsp00_Int4;
 
BEGIN
ak262emit (acv, st_jump_absolute, 1, 0);
st_break_idx := ak262ReserveJumpAbsolute(acv);
st_loop_idx  := acv.a_mblock.mb_qual^.mfirst_free;
LoopInfo.lp_ConditionStackEntry := st_loop_idx - acv.a_mblock.mb_qual^.mfirst_free - 1;
LoopInfo.lp_InLoop              := true;
LoopInfo.lp_BreakStackEntry     := st_break_idx;
ak262compile (acv, acv.a_ap_tree^[tree_index].n_lo_level,
      CatchBlockStackEntry, 0, LoopInfo, compile_glob);
ak262compile_condition (acv, acv.a_ap_tree^[tree_index].n_sa_level, compile_glob);
ak262SetJumpAbsolute   (acv, st_break_idx);
ak262emit              (acv, st_jump_false, 2, 0);
ak262emit              (acv, st_jump_absolute,
      st_loop_idx - acv.a_mblock.mb_qual^.mfirst_free - 1, 0);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262IforWhileStatement (
            VAR acv              : tak_all_command_glob;
            isIf                 : boolean;
            tree_index           : integer;
            CatchBlockStackEntry : tsp00_Int4;
            LoopInfo             : tak262LoopInfo;
            VAR compile_glob     : tak262compile_glob);
 
VAR
      first_free     : integer;
      st_jmp_ix      : tsp00_Int4;
      then_n         : integer;
      else_n         : integer;
 
BEGIN
then_n     := tree_index;
else_n     := acv.a_ap_tree^[tree_index].n_sa_level;
first_free := acv.a_mblock.mb_qual^.mfirst_free;
ak262compile_condition (acv, acv.a_ap_tree^[else_n].n_sa_level, compile_glob);
ak262MapErrorCode(acv);
st_jmp_ix := acv.a_mblock.mb_qual^.mfirst_free;
ak262emit    (acv, st_jump_false, 0, 0);
IF  NOT isIf
THEN
    BEGIN
    LoopInfo.lp_ConditionStackEntry := first_free;
    LoopInfo.lp_InLoop              := true;
    LoopInfo.lp_BreakStackEntry     := st_jmp_ix;
    END;
(*ENDIF*) 
ak262compile (acv, acv.a_ap_tree^[tree_index].n_lo_level,
      CatchBlockStackEntry, 0, LoopInfo, compile_glob);
else_n := acv.a_ap_tree^[else_n].n_lo_level;
WITH acv.a_mblock, mb_qual^ DO
    IF  isIf AND (else_n = 0)
    THEN
        mb_st^[st_jmp_ix].epos := mfirst_free - st_jmp_ix
    ELSE (* st_jump_absolute will be emited into code *)
        mb_st^[st_jmp_ix].epos := mfirst_free - st_jmp_ix + 1;
    (*ENDIF*) 
(*ENDWITH*) 
IF  else_n <> 0
THEN
    BEGIN
    st_jmp_ix := ak262ReserveJumpAbsolute (acv);
    ak262compile (acv, else_n, CatchBlockStackEntry, 0, LoopInfo, compile_glob);
    ak262SetJumpAbsolute (acv, st_jmp_ix);
    END;
(*ENDIF*) 
IF  NOT isIf (*while*)
THEN
    ak262emit (acv, st_jump_absolute,
          first_free - acv.a_mblock.mb_qual^.mfirst_free - 1, 0)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262WhenStatement (
            VAR acv              : tak_all_command_glob;
            tree_index           : integer;
            CatchBlockStackEntry : tsp00_Int4;
            CaseStackEntry       : tsp00_Int4;
            LoopInfo             : tak262LoopInfo;
            VAR compile_glob     : tak262compile_glob);
 
VAR
      first_free     : integer;
      st_jmp_ix      : tsp00_Int4;
      cond_n         : integer;
 
BEGIN
cond_n     := acv.a_ap_tree^[tree_index].n_sa_level;
first_free := acv.a_mblock.mb_qual^.mfirst_free;
ak262compile_condition (acv, acv.a_ap_tree^[cond_n].n_sa_level, compile_glob);
ak262MapErrorCode(acv);
st_jmp_ix := acv.a_mblock.mb_qual^.mfirst_free;
ak262emit    (acv, st_jump_false, 0, 0);
ak262compile (acv, acv.a_ap_tree^[tree_index].n_lo_level,
      CatchBlockStackEntry, 0, LoopInfo, compile_glob);
ak262emit (acv, st_jump_absolute,
      CaseStackEntry - acv.a_mblock.mb_qual^.mfirst_free - 1, 0);
WITH acv.a_mblock, mb_qual^ DO
    BEGIN
    mb_st^[st_jmp_ix].epos := mfirst_free - st_jmp_ix;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262sql_stmt (
            VAR acv               : tak_all_command_glob;
            tree_index            : integer;
            CatchBlockStackEntry  : tsp00_Int4;
            TryCatchLevel         : tsp00_Int4;
            checkSqlAtCompileTime : boolean;
            VAR compile_glob      : tak262compile_glob);
 
VAR
      pCol       : tak00_colinfo_ptr;
      first_free : integer;
 
BEGIN
WITH acv.a_mblock, mb_qual^ DO
    BEGIN
    compile_glob.cp_stmt_no := compile_glob.cp_stmt_no + 1;
    IF  compile_glob.cp_stmt_no > 255
    THEN
        a07_b_put_error (acv, e_too_many_statements_in_trigger, 1)
    ELSE
        BEGIN
        compile_glob.cp_containsSQL := true;
        first_free                  := mfirst_free;
        ak262emit (acv, st_parseid, 0,
              ord(compile_glob.cp_trig_ptr^.syskey.slinkage[2]) * 256 + compile_glob.cp_stmt_no);
        acv.a_mblock.mb_st^[mfirst_free-1].ecol_tab[1] := chr (TryCatchLevel);
        IF  NOT checkSqlAtCompileTime
        THEN
            acv.a_mblock.mb_st^[mfirst_free-1].eop := op_not;
        (*ENDIF*) 
        ak262emit (acv, st_dummy,   0, 0);
        ak262emit (acv, st_dummy,   0, 0);
        mfirst_free := first_free;
        ak262analyze_parameters (acv, tree_index, compile_glob);
        mfirst_free := mfirst_free + 1 + 2 + mb_st^[mfirst_free].epos;
        IF  CatchBlockStackEntry > 0
        THEN
            BEGIN (* create code for exception handling *)
            IF  ak262findVariable (acv, a01_i_rc, compile_glob, true, pCol)
            THEN
                BEGIN
                ak262emit (acv, st_dummy,   0, 0);
                IF  acv.a_returncode = 0
                THEN
                    BEGIN (* if $rc <> 0 then jump to exception handler *)
                    acv.a_mblock.mb_st^[mfirst_free-1]     := pCol^.ccolstack;
                    acv.a_mblock.mb_st^[mfirst_free-1].eop := op_test_zero;
                    acv.a_mblock.mb_st^[mfirst_free-1].ecol_tab[2] := chr(2); (* PTS 1112678 *)
                    ak262emit (acv, st_jump_false,
                          CatchBlockStackEntry - acv.a_mblock.mb_qual^.mfirst_free, 0)
                    END
                (*ENDIF*) 
                END
            ELSE
                a07ak_system_error (acv, 262, 4)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        mqual_cnt := mfirst_free - mqual_pos
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1123391 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak262one_parameter (
            VAR acv           : tak_all_command_glob;
            tree_index        : integer;
            VAR compile_glob  : tak262compile_glob);
 
VAR
      e             : tgg00_BasisError;
      maybeLocalVar : boolean;
      localVariable : boolean;
      is_old        : boolean;
      dummy_n       : tsp00_Int2;
      colname_n     : tsp00_Int2;
      scv_index     : integer;
      inOutLength   : integer;
      colptr        : tak00_colinfo_ptr;
      col_no        : tsp00_Int2;
      param_no      : tsp00_Int2;
      msg           : tsp00_C20;
      msg30         : tsp00_C30;
 
BEGIN
is_old              := false;
maybeLocalVar       := true;
IF  g01unicode
THEN
    acv.a_scv.sc_newpos := acv.a_ap_tree^[tree_index].n_pos + 2
ELSE
    acv.a_scv.sc_newpos := acv.a_ap_tree^[tree_index].n_pos + 1;
(*ENDIF*) 
a01_next_symbol (acv);
scv_index            := acv.a_scv_index; (* PTS 1107968 *)
acv.a_scv_index      := tree_index - 1;
compile_glob.cp_node := acv.a_ap_tree^[tree_index];
a02_put_identifier (acv, dummy_n, colname_n);
(* PTS 1117426 E.Z. *)
IF  acv.a_returncode = 0
THEN
    BEGIN
    a05identifier_get (acv, colname_n,
          sizeof  (compile_glob.cp_colname), compile_glob.cp_colname);
    IF  acv.a_scv.sc_symb = s_point
    THEN
        BEGIN
        maybeLocalVar := false;
        e             := e_ok;
        IF  compile_glob.cp_colname = a01_i_new
        THEN
            BEGIN
            IF  compile_glob.cp_del_trigger
            THEN
                e := e_invalid_parameter;
            (*ENDIF*) 
            END
        ELSE
            IF  compile_glob.cp_colname = a01_i_old
            THEN
                IF  compile_glob.cp_ins_trigger
                THEN
                    e := e_invalid_parameter
                ELSE
                    is_old := true;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  e <> e_ok
        THEN
            a07_b_put_error (acv, e, acv.a_ap_tree^[tree_index].n_pos)
        ELSE
            BEGIN
            a01_next_symbol (acv);
            acv.a_scv_index := tree_index - 1;
            a02_put_identifier (acv, dummy_n, colname_n);
            a05identifier_get (acv, colname_n,
                  sizeof  (compile_glob.cp_colname), compile_glob.cp_colname)
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
acv.a_ap_tree^[tree_index] :=  compile_glob.cp_node;
IF  acv.a_returncode = 0
THEN
    IF  maybeLocalVar AND ak262findVariable (acv, compile_glob.cp_colname,
        compile_glob, c_localVariables, colptr)
    THEN
        localVariable := true
    ELSE
        IF  ak262findVariable (acv, compile_glob.cp_colname,
            compile_glob, NOT c_localVariables, colptr)
        THEN
            localVariable := false
        ELSE
            a07_nb_put_error (acv, e_unknown_columnname,
                  acv.a_ap_tree^[tree_index].n_pos + a01char_size,
                  compile_glob.cp_colname);
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    param_no := acv.a_ap_tree^[tree_index].n_length;
    WITH acv.a_mblock, mb_qual^ DO
        BEGIN
        IF  param_no > mb_st^[mfirst_free].epos
        THEN (* store no of parameters *)
            mb_st^[mfirst_free].epos := param_no;
        (*ENDIF*) 
        col_no := colptr^.creccolno;
        IF  (colptr^.ccolstack.etype = st_param) AND
            (ctaltered in colptr^.ccolpropset  )
        THEN
            BEGIN
            (* data length not known yet, cannot be used as parameter inside dbfunction *)
            msg30 := 'parameter of unknown size     ';
            a07_const_b_put_error (acv, e_not_implemented,
                  acv.a_ap_tree^[tree_index].n_pos,
                  @msg30, sizeof(msg30))
            END
        ELSE
            IF  localVariable
            THEN
                col_no := -col_no
            ELSE
                IF  is_old
                THEN
                    IF  colptr^.cdatatyp in [dstra, dstrb, dstruni]
                    THEN
                        BEGIN
                        msg := 'OLD of datatype LONG';
                        a07_const_b_put_error (acv, e_not_implemented,
                              acv.a_ap_tree^[tree_index].n_pos, @msg, sizeof(msg));
                        END
                    ELSE
                        col_no := MAX_COL_PER_TAB_GG00 + col_no;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        mb_st^[mfirst_free + 2 + param_no].etype    := st_dummy;
        mb_st^[mfirst_free + 2 + param_no].epos     := col_no;
        IF  col_no > 0
        THEN
            IF  compile_glob.cp_pos_info[col_no] = cak_is_undefined
            THEN
                BEGIN
                compile_glob.cp_pos_info[col_no] :=
                      compile_glob.cp_rec_pos;
                IF  (colptr^.cdatatyp = dcha) AND g01unicode
                THEN
                    inOutLength := 1 + colptr^.cdatalen * 2
                ELSE
                    inOutLength := colptr^.cinoutlen;
                (*ENDIF*) 
                compile_glob.cp_rec_pos :=
                      compile_glob.cp_rec_pos + inOutLength
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
acv.a_scv_index := scv_index
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262analyze_parameters (
            VAR acv           : tak_all_command_glob;
            tree_index        : integer;
            VAR compile_glob  : tak262compile_glob);
 
BEGIN
IF  (tree_index <> 0)  AND (acv.a_returncode = 0)
THEN
    BEGIN
    (* PTS 1123391 E.Z. *)
    IF  acv.a_ap_tree^[tree_index].n_symb = s_parameter_name
    THEN
        ak262one_parameter (acv, tree_index, compile_glob);
    (*ENDIF*) 
    ak262analyze_parameters (acv, acv.a_ap_tree^[tree_index].n_sa_level, compile_glob);
    ak262analyze_parameters (acv, acv.a_ap_tree^[tree_index].n_lo_level, compile_glob);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262compile_condition (
            VAR acv            : tak_all_command_glob;
            tree_index         : integer;
            VAR compile_glob   : tak262compile_glob);
 
VAR
      initProcCompile : tak_proc_compile_type;
      ok              : boolean;
      st_ptr          : integer;
      pDmli           : tak262_dmli_ptr;
 
BEGIN
pDmli := ak262NewDmli (acv, compile_glob);
IF  acv.a_returncode = 0
THEN
    BEGIN
    initProcCompile := ak262SetProcCompileType (acv, compile_glob);
    st_ptr          := acv.a_mblock.mb_qual^.mfirst_free;
    (* PTS 1106376 E.Z. *)
    IF  acv.a_proc_compile <> pct_none
    THEN (* allow old/new specification *)
        acv.a_is_ddl := ddl_create_trigger
    ELSE (* don't inline functions like user, usergroup, date, time ... *)
        acv.a_is_ddl := ddl_create_procedure;
    (*ENDIF*) 
    a65_search_condition (acv, pDmli^, tree_index);
    WHILE st_ptr < acv.a_mblock.mb_qual^.mfirst_free DO
        BEGIN
        IF  acv.a_mblock.mb_st^[st_ptr].etype = st_jump_false
        THEN
            acv.a_mblock.mb_st^[st_ptr].ecol_tab[1] := chr(0);
        (*ENDIF*) 
        st_ptr := st_ptr + 1
        END;
    (*ENDWHILE*) 
    IF  compile_glob.cp_trigTabid <> cgg_zero_id
    THEN
        a06_systable_get (acv, d_fix, compile_glob.cp_trigTabid,
              acv.a_p_arr1.pbasep, cak262_all_base, ok);
    (*ENDIF*) 
    ak262FreeDmli (acv, pDmli);
    acv.a_proc_compile := initProcCompile;
    acv.a_is_ddl       := no_ddl
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak262SetProcCompileType (
            VAR acv            : tak_all_command_glob;
            VAR compile_glob   : tak262compile_glob) : tak_proc_compile_type;
 
BEGIN
ak262SetProcCompileType := acv.a_proc_compile;
IF  compile_glob.cp_upd_trigger
THEN
    acv.a_proc_compile := pct_update_trigger
ELSE
    IF  compile_glob.cp_ins_trigger
    THEN
        acv.a_proc_compile := pct_insert_trigger
    ELSE
        IF  compile_glob.cp_del_trigger
        THEN
            acv.a_proc_compile := pct_delete_trigger
        ELSE
            acv.a_proc_compile := pct_none;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262SystemVariable (
            VAR acv        : tak_all_command_glob;
            VAR ColumnName : tsp00_KnlIdentifier;
            DataType       : tsp00_DataType;
            DataLength     : integer);
 
VAR
      index : integer;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    a061app_columnname (acv, acv.a_p_arr1.pbasep^.sbase, ColumnName, index);
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    WITH acv.a_p_arr1.pbasep^.sbase.bcolumn[index]^, ccolstack DO
        BEGIN
        cextcolno     := acv.a_p_arr1.pbasep^.sbase.bmaxcol;
        creccolno     := cextcolno;
        ctabno        := 1;
        ccolpropset   := [  ];
        cdatafrac     := cak_frac_offset;
        IF  (DataType = dcha) AND g01unicode
        THEN
            cdatatyp := dunicode
        ELSE
            cdatatyp := DataType;
        (*ENDIF*) 
        cdatalen      := DataLength;
        CASE cdatatyp OF
            dfixed :
                cinoutlen := (DataLength + 1) DIV 2 + 2;
            dunicode :
                cinoutlen := 1 + 2 * DataLength;
            OTHERWISE
                cinoutlen := 1 + DataLength;
            END;
        (*ENDCASE*) 
        etype         := st_fixcol;
        eop           := op_none;
        epos          := acv.a_p_arr1.pbasep^.sbase.blenfixedcol;
        elen_var      := cinoutlen;
        ecol_tab[ 1 ] := chr(0);
        ecol_tab[ 2 ] := chr(1);
        cbinary       := false;
        acv.a_p_arr1.pbasep^.sbase.blenfixedcol :=
              acv.a_p_arr1.pbasep^.sbase.blenfixedcol + cinoutlen;
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262DBProcParameters (
            VAR acv          : tak_all_command_glob;
            VAR compile_glob : tak262compile_glob;
            VAR a11v         : tak_a11_glob;
            param_tree_index : tsp00_Int4);
 
TYPE
      tparam_inout = (p_inout, p_in, p_out);
 
VAR
      phase         : tparam_inout;
      use_param     : boolean;
      ti            : integer;
      ix            : integer;
      paramNo       : integer;
 
BEGIN
FOR phase := p_inout TO p_out DO
    BEGIN
    paramNo := 0;
    ti      := param_tree_index;
    WHILE (ti <> 0)                  AND
          (acv.a_returncode = 0) AND
          (acv.a_p_arr1.pbasep^.sbase.bmaxcol < MAX_COL_PER_TAB_GG00) DO
        BEGIN (* parameters of stored procedure, sort them by inout, in, out parameters *)
        CASE acv.a_ap_tree^[ti].n_subproc OF
            cak_i_in :
                use_param := phase = p_in;
            cak_i_out :
                use_param := phase = p_out;
            cak_i_inout :
                use_param := phase = p_inout;
            END;
        (*ENDCASE*) 
        IF  use_param
        THEN
            BEGIN
            paramNo   := paramNo + 1;
            a11v.a1ti := acv.a_ap_tree^[ti].n_sa_level;
            a11OneFixedLengthColumnDef (acv, a11v);
            IF  phase <> p_in
            THEN
                compile_glob.cp_out_params :=
                      compile_glob.cp_out_params + [acv.a_p_arr1.pbasep^.sbase.bmaxcol];
            (*ENDIF*) 
            IF  compile_glob.cp_first_param_idx = cak_is_undefined
            THEN
                compile_glob.cp_first_param_idx := acv.a_p_arr1.pbasep^.sbase.bmaxcol;
            (*ENDIF*) 
            IF  compile_glob.cp_procType = dbo_dbfunc
            THEN
                WITH acv.a_p_arr1.pbasep^.sbase DO
                    WITH bcolumn[blastindex]^ DO
                        BEGIN
&                       ifdef trace
                        a061td_colinfo (bcolumn[blastindex]^, blastindex);
&                       endif
                        IF  cdatalen < 0
                        THEN
                            BEGIN (* no user defined length *)
                            ccolpropset := ccolpropset + [ctaltered];
                            CASE cdatatyp OF
                                dcha, dchb : (* TODO Konstanten + weitere Unterscheidungen *)
                                    BEGIN
                                    cdatalen  := 2000;
                                    cinoutlen := 2001;
                                    END;
                                OTHERWISE
                                    BEGIN
                                    cdatalen  := 38;
                                    cinoutlen := 21;
                                    END;
                                END;
                            (*ENDCASE*) 
                            END;
                        (*ENDIF*) 
                        ccolstack.etype := st_param;
                        ccolstack.epos  := paramNo;
                        END;
                    (*ENDWITH*) 
                (*ENDWITH*) 
            (*ENDIF*) 
            IF  acv.a_p_arr1.pbasep^.sbase.blenfixedcol - 1 >
                acv.a_mblock.mb_data_size
            THEN
                a07_b_put_error (acv, e_too_short_datapart, 1)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        ti := acv.a_ap_tree^[ti].n_lo_level
        END;
    (*ENDWHILE*) 
    END;
(*ENDFOR*) 
IF  (acv.a_returncode = 0) AND
    (compile_glob.cp_procType = dbo_dbfunc )
THEN
    WITH acv.a_p_arr1.pbasep^.sbase DO
        FOR ix := bfirstindex TO blastindex DO
            IF  bcolumn[ix]^.ccolstack.etype = st_param
            THEN
                bcolumn[blastindex]^.ccolstack.epos  :=
                      paramNo - bcolumn[blastindex]^.ccolstack.epos;
            (*ENDIF*) 
        (*ENDFOR*) 
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262LocalVariables (
            VAR acv          : tak_all_command_glob;
            VAR compile_glob : tak262compile_glob;
            VAR a11v         : tak_a11_glob;
            varNode          : tsp00_Int4);
 
VAR
      StackLength   : tsp00_Int4;
      dummy_col_ptr : tak00_colinfo_ptr;
 
BEGIN
WHILE (varNode <> 0)                           AND
      (acv.a_returncode = 0) AND
      (acv.a_p_arr1.pbasep^.sbase.bmaxcol < MAX_COL_PER_TAB_GG00) DO
    BEGIN
    a11v.a1ti := varNode;
    IF  acv.a_ap_tree^[acv.a_ap_tree^[a11v.a1ti].n_sa_level].n_subproc = cak_i_like
    THEN
        ak262VariableLikeColumn (acv, a11v)
    ELSE
        a11OneFixedLengthColumnDef (acv, a11v);
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        WITH acv.a_p_arr1.pbasep^.sbase, bcolumn[blastindex]^ DO
            BEGIN
            IF  compile_glob.cp_first_var_pos = 0
            THEN
                compile_glob.cp_first_var_pos := ccolstack.epos;
            (*ENDIF*) 
            StackLength := ccolstack.epos + cinoutlen - 1
            END;
        (*ENDWITH*) 
        IF  StackLength > acv.a_mblock.mb_data_size
        THEN
            a07_b_put_error (acv, e_too_short_datapart, 1)
        ELSE
            IF  compile_glob.cp_base_table <> NIL
            THEN
                IF  a061exist_columnname (compile_glob.cp_base_table^.sbase,
                    a11v.a1coln, dummy_col_ptr)
                THEN
                    a07_nb_put_error (acv, e_duplicate_name, acv.a_ap_tree^[varNode].n_pos,
                          a11v.a1coln);
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    varNode := acv.a_ap_tree^[varNode].n_lo_level;
    END;
(*ENDWHILE*) 
IF  varNode <> 0
THEN
    a07_b_put_error (acv, e_too_many_variables,
          acv.a_ap_tree^[varNode].n_pos);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262VariableLikeColumn (
            VAR acv  : tak_all_command_glob;
            VAR a11v : tak_a11_glob);
 
VAR
      pCol     : tak00_colinfo_ptr;
      ColIndex : integer;
      p_arr    : tak_syspointerarr;
      Owner    : tsp00_KnlIdentifier;
      Tablen   : tsp00_KnlIdentifier;
      ColName  : tsp00_KnlIdentifier;
 
BEGIN
a05identifier_get (acv, a11v.a1ti,
      sizeof (a11v.a1coln), a11v.a1coln);
a11v.a1ti := acv.a_ap_tree^[a11v.a1ti].n_sa_level;
a11v.a1ti := acv.a_ap_tree^[a11v.a1ti].n_lo_level;
a11get_check_table (acv, false, false, true, [], true, true,
      d_release, a11v.a1ti, Owner, Tablen, p_arr);
IF  acv.a_returncode = 0
THEN
    BEGIN
    a11v.a1ti := acv.a_ap_tree^[a11v.a1ti].n_sa_level;
    a05identifier_get (acv, a11v.a1ti, sizeof (ColName), ColName);
    IF  NOT a061exist_columnname (p_arr.pbasep^.sbase, ColName, pCol)
    THEN
        a07_nb_put_error (acv, e_unknown_columnname, acv.a_ap_tree^[a11v.a1ti].n_pos,
              ColName)
    ELSE
        IF  acv.a_p_arr1.pbasep^.sbase.bmaxcol < MAX_COL_PER_TAB_GG00
        THEN
            a061app_columnname (acv, acv.a_p_arr1.pbasep^.sbase, a11v.a1coln, ColIndex)
        ELSE
            a07_b_put_error (acv, e_too_many_variables,
                  acv.a_ap_tree^[a11v.a1ti].n_pos);
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    WITH acv.a_p_arr1.pbasep^.sbase.bcolumn[ColIndex]^, ccolstack DO
        BEGIN
        cextcolno     := acv.a_p_arr1.pbasep^.sbase.bmaxcol;
        creccolno     := cextcolno;
        ctabno        := 1;
        ccolpropset   := [  ];
        cdatafrac     := cak_frac_offset;
        cdatatyp      := pCol^.cdatatyp;
        cdatalen      := pCol^.cdatalen;
        cinoutlen     := pCol^.cinoutlen;
        IF  g01unicode AND (cdatatyp = dcha)
        THEN
            BEGIN
            cdatatyp  := dunicode;
            cdatalen  := cdatalen * 2;
            cinoutlen := 1 + cdatalen
            END;
        (*ENDIF*) 
        etype         := st_fixcol;
        eop           := op_none;
        epos          := acv.a_p_arr1.pbasep^.sbase.blenfixedcol;
        elen_var      := cinoutlen;
        ecol_tab[ 1 ] := chr(0);
        ecol_tab[ 2 ] := chr(1);
        cbinary       := pCol^.cbinary;
        acv.a_p_arr1.pbasep^.sbase.blenfixedcol :=
              acv.a_p_arr1.pbasep^.sbase.blenfixedcol + cinoutlen;
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262CreateDescRecord (
            VAR acv          : tak_all_command_glob;
            VAR dmli         : tak_dml_info);
 
VAR
      e      : tgg00_BasisError;
      syskey : tgg00_SysInfoKey;
 
BEGIN
syskey           := a01defaultkey;
syskey.sentrytyp := cak_etempviewdesc;
a10_nil_get_sysinfo (acv, syskey, d_fix,
      sizeof (tak_viewdescrecord), dmli.d_viewdescbuf, e);
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1)
ELSE
    BEGIN
    dmli.d_viewdescbuf^.sviewdesc.vdesc_cnt := 0;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak262findVariable (
            VAR acv          : tak_all_command_glob;
            VAR variableName : tsp00_KnlIdentifier;
            VAR compile_glob : tak262compile_glob;
            localVariables   : boolean;
            VAR colinfo_ptr  : tak00_colinfo_ptr) : boolean;
 
VAR
      ok    : boolean;
      basep : tak_sysbufferaddress;
      tabid : tgg00_Surrogate;
 
BEGIN
IF  localVariables
THEN
    tabid := compile_glob.cp_varTabId
ELSE
    tabid := compile_glob.cp_trigTabid;
(*ENDIF*) 
IF  tabid = cgg_zero_id
THEN
    ak262findVariable := false
ELSE
    BEGIN
    a06_systable_get (acv, d_release, tabid, basep, cak262_all_base, ok);
    IF  ok
    THEN
        ak262findVariable := a061exist_columnname (basep^.sbase, variableName, colinfo_ptr)
    ELSE
        a07ak_system_error (acv, 262, 6);
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262InitCompileGlob(VAR compile_glob : tak262compile_glob;
            dbprocType : tsp00_DbObjectType);
 
VAR
      ix : integer;
 
BEGIN
compile_glob.cp_procType            := dbprocType;
compile_glob.cp_stmt_no             := 0;
compile_glob.cp_first_var_pos       := 0;
compile_glob.cp_first_param_idx     := cak_is_undefined;
compile_glob.cp_rec_pos             := 1;
compile_glob.cp_cnt_tables          := 1;
compile_glob.cp_cursor_pos          := 0;
compile_glob.cp_returnLen           := cak_is_undefined;
compile_glob.cp_returnColin.sci_typ := dunknown;
compile_glob.cp_returnColin.sci_len := -1;
compile_glob.cp_trigTabid           := cgg_zero_id;
compile_glob.cp_trig_ptr            := NIL;
compile_glob.cp_returnCol           := NIL;
compile_glob.cp_pDebugInfo          := NIL;
compile_glob.cp_pDebugColMap        := NIL;
compile_glob.cp_trig_kind           := cgg_zero_c2;
compile_glob.cp_ins_trigger         := false;
compile_glob.cp_upd_trigger         := false;
compile_glob.cp_del_trigger         := false;
compile_glob.cp_isCursorDBProc      := false;
compile_glob.cp_deterministic       := false;
compile_glob.cp_unknownOutLen       := false;
compile_glob.cp_containsSQL         := false;
compile_glob.cp_returnFound         := false;
compile_glob.cp_trigTabid           := cgg_zero_id;
compile_glob.cp_varTabId            := cgg_zero_id;
compile_glob.cp_tablen              := a01_il_b_identifier;
compile_glob.cp_colname             := a01_il_b_identifier;
compile_glob.cp_base_table          := NIL;
compile_glob.cp_out_params          := [];
compile_glob.cp_modified_cols       := [];
compile_glob.cp_const_params        := [];
FOR ix := 1 TO cak_max_param_index DO
    compile_glob.cp_const_params := compile_glob.cp_const_params + [ix];
(*ENDFOR*) 
FOR ix := 1 TO cak262_max_pos_info DO
    compile_glob.cp_pos_info[ix] := cak_is_undefined;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262InitLoopInfo (VAR LoopInfo : tak262LoopInfo);
 
BEGIN
LoopInfo.lp_ConditionStackEntry := 0;
LoopInfo.lp_BreakStackEntry     := 0;
LoopInfo.lp_TryCatchLevel       := 0;
LoopInfo.lp_InLoop              := false;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262InitOneTable (VAR oneTable : tak_one_table);
 
BEGIN
oneTable.ouser         := a01_il_b_identifier;
oneTable.otable        := a01_il_b_identifier;
oneTable.oreference    := a01_il_b_identifier;
oneTable.ofromtableid  := cgg_zero_id;
oneTable.otreeid       := b01niltree_id;
oneTable.opages        := 1;
oneTable.oall_priv     := true;
oneTable.ospecialname  := [];
oneTable.oview         := false;
oneTable.oviewqual     := false;
oneTable.oviewcheck    := false;
oneTable.ocomplex_view := false;
oneTable.otab_node     := 0;
oneTable.ospecs_needed := ons_only_tablename;
oneTable.ocounttabs    := 0;
oneTable.oattributes   := [];
oneTable.ounused0      := 0;
oneTable.ounused1      := 0;
oneTable.ounused2      := 0;
oneTable.oprivset      := [];
oneTable.osetallpriv   := []
END;
 
(*------------------------------*) 
 
FUNCTION
      ak262IsIntegerDatatype (VAR ParamInfo : tak_param_info) : boolean;
 
BEGIN
ak262IsIntegerDatatype := (ParamInfo.param_datatype in [dinteger, dsmallint])
      OR
      ((ParamInfo.param_datatype = dfixed         ) AND
      (ParamInfo.param_datafrac = cak_frac_offset))
END;
 
(*------------------------------*) 
 
FUNCTION
      ak262NewDfarr (
            VAR acv : tak_all_command_glob) : tak262_dfarr_ptr;
 
VAR
 
      p : RECORD
            CASE boolean OF
                true :
                    (pDfarr : tak262_dfarr_ptr);
                false :
                    (pBuf   : tsp00_BufAddr);
                END;
            (*ENDCASE*) 
 
      msg : tsp00_C30;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    p.pBuf := gg941Allocate(acv.a_transinf.tri_trans, sizeof(tak_dfarr));
    IF  p.pBuf = NIL
    THEN
        BEGIN
        msg := 'ak262NewDfarr                 ';
        a07_const_b_put_error (acv, e_no_more_memory, 1,
              @msg, sizeof(msg));
        END;
    (*ENDIF*) 
    ak262NewDfarr := p.pDfarr
    END
ELSE
    ak262NewDfarr := NIL;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262FreeDfarr (
            VAR acv : tak_all_command_glob;
            VAR p   : tak262_dfarr_ptr);
 
VAR
      pBuf : tsp00_BufAddr;
 
BEGIN
IF  p <> NIL
THEN
    BEGIN
    pBuf := @p^;
    gg941Deallocate(acv.a_transinf.tri_trans, pBuf);
    p := NIL;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak262NewDmli (
            VAR acv            : tak_all_command_glob;
            VAR compile_glob   : tak262compile_glob) : tak262_dmli_ptr;
 
VAR
 
      p : RECORD
            CASE boolean OF
                true :
                    (pDmli : tak262_dmli_ptr);
                false :
                    (pBuf : tsp00_BufAddr);
                END;
            (*ENDCASE*) 
 
      msg : tsp00_C30;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    p.pBuf := gg941Allocate(acv.a_transinf.tri_trans, sizeof(tak_dml_info));
    IF  p.pBuf <> NIL
    THEN
        ak262init_dmli (acv, compile_glob, p.pDmli^)
    ELSE
        BEGIN
        msg := 'ak262NewDmli                  ';
        a07_const_b_put_error (acv, e_no_more_memory, 1,
              @msg, sizeof(msg));
        END;
    (*ENDIF*) 
    ak262NewDmli := p.pDmli;
    END
ELSE
    ak262NewDmli := NIL;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262FreeDmli (
            VAR acv : tak_all_command_glob;
            VAR p   : tak262_dmli_ptr);
 
VAR
      pBuf : tsp00_BufAddr;
 
BEGIN
IF  p <> NIL
THEN
    BEGIN
    ak262finalize_dmli( p^, acv.a_transinf.tri_trans );
    pBuf := @p^;
    gg941Deallocate(acv.a_transinf.tri_trans, pBuf);
    p := NIL;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262init_dmli (
            VAR acv            : tak_all_command_glob;
            VAR compile_glob   : tak262compile_glob;
            VAR dmli           : tak_dml_info);
 
BEGIN
a54_dml_init (acv, dmli, false);
WITH dmli DO
    BEGIN
    d_sparr       := acv.a_p_arr1;
    d_cntfromtab  := compile_glob.cp_cnt_tables;
    a54expand_tabarr_ex( acv, dmli, dmli.d_cntfromtab );
    d_acttabindex := 1;
    acv.a_is_ddl  := no_ddl;
    ak262InitOneTable(d_tabarr^[1]);
    IF  compile_glob.cp_cnt_tables > 1
    THEN
        BEGIN
        WITH d_tabarr^[ 1 ] DO
            BEGIN
            otreeid       := acv.a_p_arr1.pbasep^.sbase.btreeid;
            ouser         := acv.a_curr_user_name;
            otable        := compile_glob.cp_tablen;
            END;
        (*ENDWITH*) 
        ak262InitOneTable(d_tabarr^[2])
        END;
    (*ENDIF*) 
    WITH d_tabarr^[d_cntfromtab] DO
        BEGIN
        ofromtableid  := compile_glob.cp_varTabId;
        ouser         := a01_i_temp;
        otable        := a01_i_temp;
        ocounttabs    := 1
        END;
    (*ENDWITH*) 
    acv.a_rowno_allowed := false;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262ReturnStatement (
            VAR acv           : tak_all_command_glob;
            tree_index        : integer;
            VAR compile_glob  : tak262compile_glob);
 
VAR
      isWorst   : boolean;
      e         : tgg00_BasisError;
      ix        : integer;
      jx        : integer;
      returnPos : integer;
      returnLen : integer;
      countDesc : integer;
      pCol      : tak00_colinfo_ptr;
      is_ddl    : tak_ddl_descriptor;
      pOptInfo  : tak_sysbufferaddress;
      segmentid : tsp00_C2;
      aux       : tak_vcolumndescription;
      syskey    : tgg00_SysInfoKey;
      colin     : tak00_scolinf;
      pDfa      : tak262_dfarr_ptr;
      pDmli     : tak262_dmli_ptr;
 
BEGIN
tree_index := acv.a_ap_tree^[tree_index].n_sa_level;
IF  tree_index <> 0
THEN
    BEGIN
    compile_glob.cp_returnFound := true;
    returnPos  := acv.a_ap_tree^[tree_index].n_pos;   (* DBFUNC *)
    returnLen  := acv.a_ap_tree^[tree_index].n_length;
    tree_index := acv.a_ap_tree^[tree_index].n_sa_level;
    pDmli := ak262NewDmli (acv, compile_glob);
    pDfa  := ak262NewDfarr(acv);
    IF  acv.a_returncode = 0
    THEN
        IF  ctaltered in compile_glob.cp_returnCol^.ccolpropset
        THEN
            BEGIN
            ak262CreateDescRecord (acv, pDmli^);
            pOptInfo           := acv.a_opt_info_ptr;
            acv.a_opt_info_ptr := NIL;
            IF  compile_glob.cp_returnCol^.cdatatyp in [dinteger, dfixed, dfloat, dsmallint]
            THEN
                pDmli^.d_datatype := dnumber
            ELSE
                pDmli^.d_datatype := compile_glob.cp_returnCol^.cdatatyp;
            (*ENDIF*) 
            WITH acv.a_ap_tree^[tree_index] DO
                IF  (n_proc = a64) AND (n_subproc = cak_x_value_expression)
                THEN
                    a65_val_expr (acv, pDmli^, colin, n_lo_level)
                ELSE
                    a65_val_expr (acv, pDmli^, colin, tree_index);
                (*ENDIF*) 
            (*ENDWITH*) 
            acv.a_opt_info_ptr := pOptInfo;
&           ifdef trace
            FOR ix := 1 TO pDmli^.d_viewdescbuf^.sviewdesc.vdesc_cnt DO
                WITH pDmli^.d_viewdescbuf^.sviewdesc.vdescription[ix] DO
                    BEGIN
                    t01int4 (ak_sem, 'parameter no', vfromextcolno - compile_glob.cp_first_param_idx + 1);
                    t01int4 (ak_sem, 'vn_pos      ', vn_pos);
                    END;
                (*ENDWITH*) 
            (*ENDFOR*) 
&           endif
            isWorst := false;
            IF  compile_glob.cp_returnColin.sci_typ = dunknown
            THEN (* first return statement in function, is first 'worst' return statement *)
                isWorst := true
            ELSE
                IF  (compile_glob.cp_returnColin.sci_typ in [dinteger, dfixed, dsmallint]) AND
                    (colin.sci_typ = dfloat)
                THEN (* new 'worst' return statement *)
                    isWorst := true
                ELSE (* new 'worst' return statement *)
                    isWorst := compile_glob.cp_returnColin.sci_len < colin.sci_len;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  isWorst
            THEN
                BEGIN
                (* 'worst' return statement will be used to calculate *)
                (* return type and length when function is called     *)
                compile_glob.cp_returnPos   := returnPos;
                compile_glob.cp_returnLen   := returnLen;
                (* check, if there exists any const numerical parameters used in return expression  *)
                (* These may be substituted by the parameter value at call time, if parameter value *)
                (* is known at prepare time. Example                                                *)
                (*                                                                                  *)
                (* create dbproc left(s varchar, count integer) returns varchar as                  *)
                (*   return substr (s, 1, count);                                                   *)
                (*                                                                                  *)
                (* select left(s, 10) from table                                                    *)
                (*                                                                                  *)
                (* In this case 10 can be placed into the return statement (for count) which allows *)
                (* the parser to evaluate the correct output column length                          *)
                countDesc := pDmli^.d_viewdescbuf^.sviewdesc.vdesc_cnt;
                pDmli^.d_viewdescbuf^.sviewdesc.vdesc_cnt := 0;
                FOR ix := 1 TO countDesc DO
                    WITH pDmli^.d_viewdescbuf^.sviewdesc.vdescription[ix] DO
                        BEGIN
                        a06extcolno (acv.a_p_arr1.pbasep^.sbase,  vfromextcolno, pCol);
                        IF  pCol <> NIL
                        THEN
                            BEGIN
&                           ifdef trace
                            a061td_colinfo (pCol^, vfromextcolno);
&                           endif
                            IF  pCol^.cdatatyp in [dinteger, dfixed, dsmallint]
                            THEN
                                BEGIN
                                pDmli^.d_viewdescbuf^.sviewdesc.vdesc_cnt := pDmli^.d_viewdescbuf^.sviewdesc.vdesc_cnt + 1;
                                vfromextcolno := vfromextcolno - compile_glob.cp_first_param_idx + 1;
                                pDmli^.d_viewdescbuf^.sviewdesc.vdescription[pDmli^.d_viewdescbuf^.sviewdesc.vdesc_cnt] :=
                                      pDmli^.d_viewdescbuf^.sviewdesc.vdescription[ix];
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDFOR*) 
                IF  pDmli^.d_viewdescbuf^.sviewdesc.vdesc_cnt > 0
                THEN
                    BEGIN
                    FOR ix := 1 TO pDmli^.d_viewdescbuf^.sviewdesc.vdesc_cnt DO
                        BEGIN
                        (* correct positions relative to start of return statement and sort by vn_pos *)
                        pDmli^.d_viewdescbuf^.sviewdesc.vdescription[ix].vn_pos :=
                              pDmli^.d_viewdescbuf^.sviewdesc.vdescription[ix].vn_pos - returnPos + 1;
                        jx := 1;
                        WHILE pDmli^.d_viewdescbuf^.sviewdesc.vdescription[jx].vn_pos <
                              pDmli^.d_viewdescbuf^.sviewdesc.vdescription[ix].vn_pos DO
                            jx := jx + 1;
                        (*ENDWHILE*) 
                        aux := pDmli^.d_viewdescbuf^.sviewdesc.vdescription[ix];
                        pDmli^.d_viewdescbuf^.sviewdesc.vdescription[ix] :=
                              pDmli^.d_viewdescbuf^.sviewdesc.vdescription[jx];
                        pDmli^.d_viewdescbuf^.sviewdesc.vdescription[jx] := aux;
                        END;
                    (*ENDFOR*) 
                    pDmli^.d_viewdescbuf^.b_sl := sizeof(tak_viewdescrecord) -
                          sizeof(pDmli^.d_viewdescbuf^.sviewdesc.vdescription) +
                          pDmli^.d_viewdescbuf^.sviewdesc.vdesc_cnt *
                          sizeof(pDmli^.d_viewdescbuf^.sviewdesc.vdescription[1]);
                    syskey           := a01defaultkey;
                    syskey.stableid  := compile_glob.cp_procId;
                    syskey.sentrytyp := cak_eviewdesc;
                    IF  compile_glob.cp_returnColin.sci_typ <> dunknown
                    THEN
                        a10del_sysinfo (acv, syskey, e);
                    (*ENDIF*) 
                    a10_copy_catalog_rec (acv, pDmli^.d_viewdescbuf^.syskey, true, syskey,
                          segmentid, true, e);
                    IF  e <> e_ok
                    THEN
                        a07_b_put_error (acv, e, 1);
                    (*ENDIF*) 
                    pDmli^.d_viewdescbuf := NIL;
                    END;
                (*ENDIF*) 
                compile_glob.cp_returnColin := colin;
                END;
            (*ENDIF*) 
            IF  pDmli^.d_viewdescbuf <> NIL
            THEN
                a10del_sysinfo (acv, pDmli^.d_viewdescbuf ^.syskey, e);
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            pDmli^.d_colbuf      := compile_glob.cp_returnCol;
            pDmli^.d_foundset    := [1];
            pDfa^[1].dml_col_ptr := pDmli^.d_colbuf;
            pDfa^[1].dml_node    := tree_index;
            is_ddl               := acv.a_is_ddl; (* PTS 1112383 *)
            acv.a_is_ddl         := ddl_create_trigger;
            a57update_with_value_expr (acv, pDmli^, pDfa^);
            acv.a_is_ddl       := is_ddl; (* PTS 1112383 *)
            acv.a_mblock.mb_qual^.mfirst_free := acv.a_mblock.mb_qual^.mfirst_free - 1;
            acv.a_mblock.mb_qual^.mqual_cnt   := acv.a_mblock.mb_qual^.mqual_cnt - 1;
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    ak262MapErrorCode (acv);
    ak262emit (acv, st_result, 0, 0);
    acv.a_mblock.mb_st^[acv.a_mblock.mb_qual^.mfirst_free-1].eop := op_copy;
    ak262FreeDmli  (acv, pDmli);
    ak262FreeDfarr (acv, pDfa);
    END;
(*ENDIF*) 
ak262emit (acv, st_stop, 0, 0);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262LookUp (
            VAR acv           : tak_all_command_glob;
            tree_index        : integer;
            VAR compile_glob  : tak262compile_glob;
            VAR pCol          : tak00_colinfo_ptr);
 
VAR
      localVariable : boolean;
      param         : tsp00_KnlIdentifier;
 
BEGIN
a05identifier_get (acv, tree_index, sizeof(param), param);
IF  ak262findVariable (acv, param,
    compile_glob, c_localVariables, pCol)
THEN
    localVariable := true
ELSE
    IF  ak262findVariable (acv, param,
        compile_glob, NOT c_localVariables, pCol)
    THEN
        localVariable := false
    ELSE
        a07_nb_put_error (acv, e_unknown_name,
              acv.a_ap_tree^[tree_index].n_pos,
              param);
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262DynamicSqlStatement (
            VAR acv              : tak_all_command_glob;
            tree_index           : integer;
            CatchBlockStackEntry : tsp00_Int4;
            VAR compile_glob     : tak262compile_glob);
 
VAR
      is_ddl    : tak_ddl_descriptor;
      expr_node : integer;
      stackIndex: integer;
      pCol      : tak00_colinfo_ptr;
      colinfo   : tak00_columninfo;
      colin     : tak00_scolinf;
      paramCnt  : integer;
      pDmli     : tak262_dmli_ptr;
      pDfa      : tak262_dfarr_ptr;
 
BEGIN
compile_glob.cp_containsSQL := true;
pDmli := ak262NewDmli (acv, compile_glob);
pDfa  := ak262NewDfarr(acv);
IF  acv.a_returncode = 0
THEN
    BEGIN
    pDmli^.d_fieldno := 1;
    pDfa^[1].dml_col_ptr := @colinfo;
    WITH pDfa^[1].dml_col_ptr^ DO
        BEGIN
        ccolumnn_len := chr(0);
        ccolpropset  := [ctopt];
        cextcolno    := 1;
        creccolno    := 1;
        ctabno       := 1;
        cbinary      := false;
        IF  g01unicode
        THEN
            cdatatyp := dunicode
        ELSE
            cdatatyp := dcha;
        (*ENDIF*) 
        cdatalen     := 32000;
        cinoutlen    := 1 + cdatalen;
        cdatafrac    := cak_frac_offset;
        WITH ccolstack DO
            BEGIN
            etype    := st_fixcol;
            eop      := op_none;
            epos     := 1;
            elen_var := cinoutlen;
            ecol_tab := cgg_zero_c2
            END;
        (*ENDWITH*) 
        pDmli^.d_pars_kind        := fp_val_all_without_l;
        pDmli^.d_wherepart        := true;
        pDmli^.d_datatype         := cdatatyp;
        pDmli^.d_colptr           := pDfa^[1].dml_col_ptr;
        colin.sci_len             := 0;
        pDmli^.d_first_tab        := 0;
        pDmli^.d_allowed          := may_more_tabs;
        pDmli^.d_change_date_time := false;
        pDmli^.d_const_value_expr := true;
        pDmli^.d_param_st_begin   := 0;
        pDmli^.d_param_st_index   := 0;
        expr_node               := acv.a_ap_tree^[tree_index].n_sa_level;
        is_ddl                    := acv.a_is_ddl;
        (* don't inline functions like user, usergroup, date, time ... *)
        acv.a_is_ddl            := ddl_create_procedure;
        WITH acv.a_ap_tree^[expr_node] DO
            IF  (n_proc = a64) AND (n_subproc = cak_x_value_expression)
            THEN
                a65_val_expr (acv, pDmli^, colin, n_lo_level)
            ELSE
                a65_val_expr (acv, pDmli^, colin, expr_node);
            (*ENDIF*) 
        (*ENDWITH*) 
        acv.a_is_ddl := is_ddl;
        ak262emit (acv, st_dyn_sql, 0, 0);
&       ifdef dynsql
        paramCnt   := 0;
        tree_index :=  acv.a_ap_tree^[tree_index].n_lo_level;
        WITH acv.a_mblock, mb_qual^ DO
            BEGIN
            stackIndex := mfirst_free - 1;
            WHILE tree_index <> 0 DO
                BEGIN
                ak262LookUp (acv, tree_index, compile_glob, pCol);
                IF  pCol <> NIL
                THEN
                    BEGIN
                    paramCnt := paramCnt + 1;
                    ak262emit (acv, st_dummy,   0, 0);
                    IF  acv.a_return_segm^.sp1r_returncode = 0
                    THEN
                        acv.a_mblock.mb_st^[mfirst_free-1] := pCol^.ccolstack;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                tree_index :=  acv.a_ap_tree^[tree_index].n_sa_level;
                END;
            (*ENDWHILE*) 
            acv.a_mblock.mb_st^[stackIndex].epos := paramCnt;
            END;
        (*ENDWITH*) 
&       endif
        IF  CatchBlockStackEntry > 0
        THEN
            WITH acv.a_mblock, mb_qual^ DO
                BEGIN (* create code for exception handling *)
                IF  ak262findVariable (acv, a01_i_rc, compile_glob, true, pCol)
                THEN
                    BEGIN
                    ak262emit (acv, st_dummy,   0, 0);
                    IF  acv.a_return_segm^.sp1r_returncode = 0
                    THEN
                        BEGIN (* if $rc <> 0 then jump to exception handler *)
                        acv.a_mblock.mb_st^[mfirst_free-1]     := pCol^.ccolstack;
                        acv.a_mblock.mb_st^[mfirst_free-1].eop := op_test_zero;
                        acv.a_mblock.mb_st^[mfirst_free-1].ecol_tab[2] := chr(2); (* PTS 1112678 *)
                        ak262emit (acv, st_jump_false,
                              CatchBlockStackEntry - acv.a_mblock.mb_qual^.mfirst_free, 0)
                        END
                    (*ENDIF*) 
                    END
                ELSE
                    a07ak_system_error (acv, 262, 5);
                (*ENDIF*) 
                mqual_cnt := mfirst_free - mqual_pos
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
ak262FreeDmli  (acv, pDmli);
ak262FreeDfarr (acv, pDfa);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262stop_stmt (
            VAR acv           : tak_all_command_glob;
            tree_index        : integer;
            VAR compile_glob  : tak262compile_glob);
 
VAR
      is_ddl    : tak_ddl_descriptor;
      param_cnt : integer;
      expr_node : integer;
      colinfo   : tak00_columninfo;
      colin     : tak00_scolinf;
      pDfa      : tak262_dfarr_ptr;
      pDmli     : tak262_dmli_ptr;
 
BEGIN
pDmli := ak262NewDmli  (acv, compile_glob);
pDfa  := ak262NewDfarr (acv);
IF  acv.a_returncode = 0
THEN
    BEGIN
    pDmli^.d_fieldno := 1;
    pDfa^[1].dml_col_ptr := @colinfo;
    WITH pDfa^[1].dml_col_ptr^ DO
        BEGIN
        param_cnt    := 1;
        ccolumnn_len := chr(0);
        ccolpropset  := [ctopt];
        cextcolno    := 1;
        creccolno    := 1;
        ctabno       := 1;
        cbinary      := false;
        cdatatyp     := dfixed;
        cdatalen     := cak262_rc_digits;
        cinoutlen    := (cak262_rc_digits + 1) DIV 2 + 2;
        cdatafrac    := cak_frac_offset;
        WITH ccolstack DO
            BEGIN
            etype    := st_fixcol;
            eop      := op_none;
            epos     := 1;
            elen_var := cinoutlen;
            ecol_tab := cgg_zero_c2
            END;
        (*ENDWITH*) 
        pDmli^.d_pars_kind        := fp_val_all_without_l;
        pDmli^.d_wherepart        := true;
        pDmli^.d_datatype         := dnumber;
        pDmli^.d_colptr           := pDfa^[1].dml_col_ptr;
        colin.sci_len             := 0;
        pDmli^.d_first_tab        := 0;
        pDmli^.d_allowed          := may_more_tabs;
        pDmli^.d_change_date_time := false;
        pDmli^.d_const_value_expr := true;
        pDmli^.d_param_st_begin   := 0;
        pDmli^.d_param_st_index   := 0;
        expr_node                 := acv.a_ap_tree^[tree_index].n_sa_level;
        is_ddl                    := acv.a_is_ddl;
        (* don't inline functions like user, usergroup, date, time ... *)
        acv.a_is_ddl            := ddl_create_procedure;
        WITH acv.a_ap_tree^[expr_node] DO
            IF  (n_proc = a64) AND (n_subproc = cak_x_value_expression)
            THEN
                a65_val_expr (acv, pDmli^, colin, n_lo_level)
            ELSE
                a65_val_expr (acv, pDmli^, colin, expr_node);
            (*ENDIF*) 
        (*ENDWITH*) 
        acv.a_is_ddl := is_ddl;
        expr_node    := acv.a_ap_tree^[tree_index].n_lo_level;
        IF  expr_node <> 0
        THEN
            BEGIN
            param_cnt := param_cnt + 1;
            IF  g01unicode
            THEN
                cdatatyp := dunicode
            ELSE
                cdatatyp := dcha;
            (*ENDIF*) 
            cdatalen                  := 70;
            cinoutlen                 := 1 + cdatalen * a01char_size;
            pDmli^.d_datatype         := cdatatyp;
            pDmli^.d_param_st_begin   := 0;
            pDmli^.d_param_st_index   := 0;
            WITH acv.a_ap_tree^[expr_node] DO
                IF  (n_proc = a64) AND (n_subproc = cak_x_value_expression)
                THEN
                    a65_val_expr (acv, pDmli^, colin, n_lo_level)
                ELSE
                    a65_val_expr (acv, pDmli^, colin, expr_node);
                (*ENDIF*) 
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
        ak262emit (acv, st_stop, param_cnt, 0);
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
ak262FreeDmli  (acv, pDmli);
ak262FreeDfarr (acv, pDfa);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262store_sql_stmt (
            VAR acv            : tak_all_command_glob;
            tree_index         : integer;
            VAR compile_glob   : tak262compile_glob);
 
VAR
      e        : tgg00_BasisError;
      bufCount : integer;
      src_pos  : tsp00_Int4;
      buf_pos  : tsp00_Int4;
      stmt_len : tsp00_Int4;
      move_len : tsp00_Int4;
      required : tsp00_Int4;
      stmtLen  : integer;
      stmt_ptr : tak_sysbufferaddress;
      firstPtr : tak_sysbufferaddress;
      sysk     : tgg00_SysInfoKey;
 
BEGIN
stmt_len         := ord(acv.a_ap_tree^[tree_index].n_datatype) * MAX_INT2_SP00 +
      acv.a_ap_tree^[tree_index].n_length;
sysk             := compile_glob.cp_trig_ptr^.syskey;
sysk.sentrytyp   := cak_eviewtext;
sysk.slinkage[1] := sysk.slinkage[2];
sysk.slinkage[2] := chr(compile_glob.cp_stmt_no);
IF  stmt_len > sizeof (tak_viewtext)
THEN
    required := sizeof (tak_viewtextrecord)
ELSE
    required := sizeof (tak_viewtextrecord) - sizeof (tak_viewtext) + stmt_len;
(*ENDIF*) 
a10_nil_get_sysinfo (acv, sysk, d_fix, required, stmt_ptr, e);
IF  e = e_ok
THEN
    BEGIN
    sysk.skeylen                      := sysk.skeylen + 1;
    firstPtr                          := stmt_ptr;
    stmt_ptr^.sviewtext.vtsegmentid   := cak00_local_segment_id;
    stmt_ptr^.sviewtext.vtfromtabcnt  := 0;
    stmt_ptr^.sviewtext.vttabcount    := 0;
    stmt_ptr^.sviewtext.vtnextexist   := false;
    CASE acv.a_sqlmode OF
        sqlm_ansi   :
            stmt_ptr^.sviewtext.vtcontext := 10;
        sqlm_db2    :
            stmt_ptr^.sviewtext.vtcontext := 20;
        sqlm_oracle :
            stmt_ptr^.sviewtext.vtcontext := 30;
        sqlm_internal :
            stmt_ptr^.sviewtext.vtcontext :=  0;
        END;
    (*ENDCASE*) 
    (* PTS 1113166 E.Z. *)
    stmt_ptr^.sviewtext.vtcontext     :=
          stmt_ptr^.sviewtext.vtcontext + ord (acv.a_dt_format);
    acv.a_scv.sc_newpos := acv.a_ap_tree^[tree_index].n_pos;
    src_pos             := acv.a_scv.sc_newpos;
    IF  src_pos = 1
    THEN
        IF  acv.a_ap_tree^[acv.a_ap_tree^[tree_index].n_sa_level].n_proc = a999ptr_node
        THEN
            BEGIN
            (* the insert which was made to insert with value expr *)
            src_pos := acv.a_ap_tree^[acv.a_ap_tree^[acv.a_ap_tree^
                  [tree_index].n_sa_level].n_lo_level].n_pos;
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  g01unicode
    THEN
        stmt_ptr^.sviewtext.vtselect_pos  := src_pos - 2
    ELSE
        stmt_ptr^.sviewtext.vtselect_pos  := src_pos - 1;
    (*ENDIF*) 
    src_pos             := acv.a_scv.sc_newpos;
    buf_pos             := 1;
    bufCount            := 0;
    stmtLen             := 0;
    acv.a_is_ddl        := ddl_create_trigger;
    a01_next_symbol(acv);
    (* copy sql statement, substitute parameters by '?' *)
    REPEAT
        a01_next_symbol (acv);
        move_len := acv.a_scv.sc_sypos - src_pos;
        IF  src_pos + move_len > acv.a_ap_tree^[tree_index].n_pos + stmt_len
        THEN
            move_len := acv.a_ap_tree^[tree_index].n_pos + stmt_len - src_pos;
        (*ENDIF*) 
        IF  buf_pos + move_len - 1 > sizeof (stmt_ptr^.sviewtext.vttbuf)
        THEN
            BEGIN
            stmt_ptr^.b_sl := sizeof (tak_viewtextrecord) - sizeof (tak_viewtext) + buf_pos - 1;
            IF  stmt_ptr <> firstPtr
            THEN
                a10add_sysinfo (acv, stmt_ptr, e);
            (*ENDIF*) 
            IF  e = e_ok
            THEN
                BEGIN
                bufCount := bufCount + 1;
                sysk.all[sysk.skeylen] := chr(bufCount);
                a10_nil_get_sysinfo (acv, sysk, d_release,
                      sizeof (tak_viewtextrecord), stmt_ptr, e);
                buf_pos := 1;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  e = e_ok
        THEN
            BEGIN
            SAPDB_PascalMove ('VAK262',  39,    
                  acv.a_cmd_part^.sp1p_buf_size, stmt_len,
                  @acv.a_cmd_part^.sp1p_buf, src_pos,
                  @stmt_ptr^.sviewtext.vttbuf, buf_pos, move_len,
                  acv.a_returncode);
            buf_pos := buf_pos + move_len;
            src_pos := src_pos + move_len;
            stmtLen := stmtLen + move_len;
            END;
        (*ENDIF*) 
        IF  (acv.a_scv.sc_symb = s_parameter_name) AND (e = e_ok)
        THEN
            BEGIN
            IF  buf_pos + a01char_size - 1 > sizeof (stmt_ptr^.sviewtext.vttbuf)
            THEN
                BEGIN
                stmt_ptr^.b_sl := sizeof (tak_viewtextrecord) - sizeof (tak_viewtext) + buf_pos - 1;
                IF  stmt_ptr <> firstPtr
                THEN
                    a10add_sysinfo (acv, stmt_ptr, e);
                (*ENDIF*) 
                IF  e = e_ok
                THEN
                    BEGIN
                    bufCount := bufCount + 1;
                    sysk.all[sysk.skeylen] := chr(bufCount);
                    a10_nil_get_sysinfo (acv, sysk, d_release,
                          sizeof (tak_viewtextrecord), stmt_ptr, e);
                    buf_pos := 1;
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  e = e_ok
            THEN
                IF  g01unicode
                THEN
                    BEGIN
                    stmt_ptr^.sviewtext.vttbuf[buf_pos  ] := csp_unicode_mark;
                    stmt_ptr^.sviewtext.vttbuf[buf_pos+1] := '?';
                    END
                ELSE
                    stmt_ptr^.sviewtext.vttbuf[buf_pos] := '?';
                (*ENDIF*) 
            (*ENDIF*) 
            buf_pos := buf_pos + a01char_size;
            stmtLen := stmtLen + a01char_size;
            src_pos := acv.a_scv.sc_newpos;
            END;
        (*ENDIF*) 
    UNTIL
        (e <> e_ok) OR
        (acv.a_scv.sc_sypos > acv.a_ap_tree^[tree_index].n_pos + stmt_len - 1);
    (*ENDREPEAT*) 
    IF  e = e_ok
    THEN
        BEGIN
&       ifdef trace
        t01int4 (ak_sem, 'statementlen', stmtLen);
&       endif
        stmt_ptr^.sviewtext.vttextlength := stmtLen;
        stmt_ptr^.b_sl                   :=
              sizeof (tak_viewtextrecord) - sizeof (tak_viewtext) + buf_pos - 1;
        a10add_sysinfo (acv, stmt_ptr, e);
        IF  (e = e_ok) AND (firstPtr <> stmt_ptr)
        THEN
            BEGIN
            firstPtr^.sviewtext.vttextlength := stmtLen;
            a10add_sysinfo (acv, firstPtr, e);
            END;
        (*ENDIF*) 
        a10rel_sysinfo (firstPtr);
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262StoreJavaString (
            VAR acv         : tak_all_command_glob;
            VAR procId      : tgg00_Surrogate;
            javaExtNameNode : integer);
 
VAR
      dummyMD5    : tsp00_C32;
      idx         : integer;
      buf         : tsp00_Buf;
      pFile       : ^tak_method_filename;
 
BEGIN
FOR idx := 1 TO sizeof(buf) DO
    buf[idx] := bsp_c1;
(*ENDFOR*) 
a05_string_literal_get (acv, javaExtNameNode, dcha, sizeof(buf), buf);
idx := sizeof(buf);
WHILE (idx > 1) AND (buf[idx] = bsp_c1) DO
    idx := idx - 1;
(*ENDWHILE*) 
pFile := @buf;
IF  idx > sizeof (pFile^) - 1
THEN
    a07_b_put_error (acv, e_illegal_filename, 1)
ELSE
    BEGIN
    dummyMD5     := bsp_c32;
    buf[idx + 1] := chr(0); (* filename is store as null terminated string *)
    a12CreateFileInfoRecord (acv, procId, pFile^, dummyMD5);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262store_create_stmt (
            VAR acv            : tak_all_command_glob;
            VAR compile_glob   : tak262compile_glob);
 
VAR
      e        : tgg00_BasisError;
      src_pos  : tsp00_Int4;
      rest_len : tsp00_Int4;
      move_len : tsp00_Int4;
      seqno    : integer;
      stmt_ptr : tak_sysbufferaddress;
      sysk     : tgg00_SysInfoKey;
 
BEGIN
sysk             := compile_glob.cp_trig_ptr^.syskey;
sysk.sentrytyp   := cak_eviewtext;
sysk.slinkage[1] := chr(255 - ord (sysk.slinkage[2]));
seqno            := 0;
src_pos          := 1;
rest_len         := acv.a_cmd_part^.sp1p_buf_len;
REPEAT
    seqno := seqno + 1;
    sysk.slinkage[2] := chr(seqno);
    IF  rest_len > sizeof (tak_viewtext)
    THEN
        move_len := sizeof (tak_viewtext)
    ELSE
        move_len := rest_len;
    (*ENDIF*) 
&   ifdef trace
    t01int4 (ak_sem, 'rest_len    ', rest_len);
    t01int4 (ak_sem, 'move_len    ', move_len);
&   endif
    a10_nil_get_sysinfo (acv, sysk, d_release,
          sizeof (tak_viewtextrecord) - sizeof (tak_viewtext) + move_len, stmt_ptr, e);
    IF  e = e_ok
    THEN
        BEGIN
        stmt_ptr^.sviewtext.vtsegmentid   := cak00_local_segment_id;
        stmt_ptr^.sviewtext.vtfromtabcnt  := acv.a_cmd_part^.sp1p_buf_len DIV csp_maxint2;
        stmt_ptr^.sviewtext.vttabcount    := acv.a_cmd_part^.sp1p_buf_len MOD csp_maxint2;
        stmt_ptr^.sviewtext.vtnextexist   := rest_len > move_len;
        stmt_ptr^.sviewtext.vttextlength  := move_len;
        SAPDB_PascalMove ('VAK262',  40,    
              acv.a_cmd_part^.sp1p_buf_size, sizeof(stmt_ptr^.sviewtext.vttbuf),
              @acv.a_cmd_part^.sp1p_buf, src_pos,
              @stmt_ptr^.sviewtext.vttbuf, 1, move_len,
              acv.a_returncode);
        rest_len := rest_len - move_len;
        src_pos  := src_pos  + move_len;
        a10add_sysinfo (acv, stmt_ptr, e)
        END;
    (*ENDIF*) 
UNTIL
    (rest_len <= 0) OR (e <> e_ok);
(*ENDREPEAT*) 
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262CaseStatement (
            VAR acv              : tak_all_command_glob;
            tree_index           : integer;
            CatchBlockStackEntry : tsp00_Int4;
            LoopInfo             : tak262LoopInfo;
            VAR compile_glob     : tak262compile_glob);
 
VAR
      hasElseLabel   : boolean;
      ix             : integer;
      st_break_idx   : integer;
      st_default_idx : integer;
      stmt_idx       : integer;
      case_idx       : integer;
      cntCaseLabels  : integer;
      switchNode     : integer;
      prevCaseNode   : integer;
      prevStmtNode   : integer;
      currNode       : integer;
      stmtNode       : integer;
      pDmli          : tak262_dmli_ptr;
 
BEGIN
pDmli := ak262NewDmli (acv, compile_glob);
IF  acv.a_returncode = 0
THEN
    BEGIN
    hasElseLabel    := false;
    switchNode      := acv.a_ap_tree^[tree_index].n_length;
&   ifdef trace
    t01int4 (ak_sem, 'tree_index  ', tree_index);
    t01int4 (ak_sem, 'switchNode  ', switchNode);
&   endif
    tree_index := acv.a_ap_tree^[tree_index].n_sa_level;
    IF  acv.a_ap_tree^[tree_index].n_proc = a262
    THEN
        BEGIN (* searched case statement *)
        case_idx     := ak262ReserveJumpAbsolute(acv);
        st_break_idx := ak262ReserveJumpAbsolute(acv);
        ak262SetJumpAbsolute (acv, case_idx);
        ak262compile  (acv, acv.a_ap_tree^[tree_index].n_lo_level,
              CatchBlockStackEntry, st_break_idx, LoopInfo, compile_glob);
        IF  acv.a_ap_tree^[tree_index].n_subproc <> cak_i_else
        THEN
            ak262emit (acv, st_stop, 0, e_case_not_found);
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        prevCaseNode  := 0;
        prevStmtNode  := 0;
        cntCaseLabels := 0;
        WHILE switchNode <> 0 DO
            BEGIN
            currNode   := switchNode;
            switchNode := acv.a_ap_tree^[switchNode].n_sa_level;
            acv.a_ap_tree^[currNode].n_sa_level := 0;
            IF  acv.a_ap_tree^[currNode].n_proc  = a64
            THEN
                BEGIN
                cntCaseLabels := cntCaseLabels + 1;
                IF  prevCaseNode <> 0
                THEN
                    acv.a_ap_tree^[prevCaseNode].n_sa_level := currNode;
                (*ENDIF*) 
                prevCaseNode := currNode;
                END
            ELSE
                BEGIN
                IF  acv.a_ap_tree^[currNode].n_subproc = 0
                THEN
                    hasElseLabel := true;
                (*ENDIF*) 
                IF  prevStmtNode = 0
                THEN
                    stmtNode := currNode
                ELSE
                    acv.a_ap_tree^[prevStmtNode].n_sa_level := currNode;
                (*ENDIF*) 
                IF  stmtNode = 0
                THEN
                    stmtNode := currNode;
                (*ENDIF*) 
                prevStmtNode := currNode;
                END;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        a65_search_condition (acv, pDmli^, tree_index);
        ak262MapErrorCode(acv);
        case_idx := acv.a_mblock.mb_qual^.mfirst_free - cntCaseLabels - 1;
        acv.a_mblock.mb_st^[acv.a_mblock.mb_qual^.mfirst_free-1].eop := op_none;
        IF  cntCaseLabels = 1
        THEN (* no st_op, op_in stack entry has been produced, emit st_case *)
            BEGIN
            case_idx := case_idx + 1; (* PTS 1118851 *)
            ak262emit (acv, st_case, 1, 1)
            END
        ELSE (* change st_op, op_in to st_case stack entry *)
            acv.a_mblock.mb_st^[acv.a_mblock.mb_qual^.mfirst_free-1].etype := st_case;
        (*ENDIF*) 
        IF  hasElseLabel
        THEN
            st_default_idx := ak262ReserveJumpAbsolute(acv)
        ELSE
            ak262emit (acv, st_stop, 0, e_case_not_found);
        (*ENDIF*) 
        st_break_idx := ak262ReserveJumpAbsolute(acv);
        WHILE (stmtNode <> 0) AND
              (acv.a_returncode = 0) DO
            BEGIN
            IF  acv.a_ap_tree^[stmtNode].n_subproc = 0
            THEN
                BEGIN (* compiling default label *)
                ak262SetJumpAbsolute (acv, st_default_idx);
                END
            ELSE
                BEGIN
                (* subproc contains number of case labels pointing to *)
                (* following statement compiled by ak262compile       *)
                FOR ix := 1 TO acv.a_ap_tree^[stmtNode].n_subproc DO
                    BEGIN
                    acv.a_mblock.mb_st^[case_idx].ecol_pos :=
                          acv.a_mblock.mb_qual^.mfirst_free;
                    case_idx := case_idx + 1;
                    END;
                (*ENDFOR*) 
                END;
            (*ENDIF*) 
            ak262compile (acv, acv.a_ap_tree^[stmtNode].n_lo_level,
                  CatchBlockStackEntry, 0, LoopInfo, compile_glob);
            ak262emit (acv, st_jump_absolute,
                  st_break_idx - acv.a_mblock.mb_qual^.mfirst_free - 1, 0);
            stmtNode := acv.a_ap_tree^[stmtNode].n_sa_level;
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    ak262SetJumpAbsolute (acv, st_break_idx);
    ak262FreeDmli (acv, pDmli);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262drop_one_trigger (
            VAR acv          : tak_all_command_glob;
            triggerp         : tak_sysbufferaddress);
 
VAR
      exit_loop           : boolean;
      e                   : tgg00_BasisError;
      loopCnt             : integer;
      commentId           : integer;
      nextp               : tak_sysbufferaddress;
      del_sysk            : tgg00_SysInfoKey;
      next_sysk           : tgg00_SysInfoKey;
 
BEGIN
e := e_ok;
IF  triggerp^.strigger.tr_succ_exists OR
    (triggerp^.strigger.tr_param_cnt + triggerp^.strigger.tr_condition_cnt > cak_max_trigger_stack)
THEN
    BEGIN (* delete successor record *)
    del_sysk := triggerp^.syskey;
    a06inc_linkage (del_sysk.slinkage);
    a10del_sysinfo (acv, del_sysk, e)
    END;
(*ENDIF*) 
IF  (e = e_ok) AND (triggerp^.strigger.tr_condition_cnt > 0)
THEN
    BEGIN (* delete tak_viewdesc catalog record *)
    del_sysk               := triggerp^.syskey;
    del_sysk.sentrytyp     := cak_eviewdesc;
    del_sysk.slinkage[ 1 ] := chr(255);
    a10del_sysinfo (acv, del_sysk, e)
    END;
(*ENDIF*) 
IF  triggerp^.strigger.tr_language <> lang_pl
THEN
    BEGIN (* external trigger implemented in package *)
    IF  e = e_ok
    THEN
        BEGIN (* delete tak_methodinfo catalog record *)
        del_sysk           := a01defaultkey;
        del_sysk.stableid  := triggerp^.strigger.tr_proc_id;
        del_sysk.sentrytyp := cak_emethodinfo;
        a10del_sysinfo (acv, del_sysk, e)
        END;
    (*ENDIF*) 
    IF  e = e_ok
    THEN
        BEGIN (* delete tak_method catalog record(s) *)
        del_sysk.sentrytyp := cak_emethod;
        REPEAT
            a10del_sysinfo (acv, del_sysk, e);
            a06inc_linkage  (del_sysk.sentrytyp);
        UNTIL
            e <> e_ok;
        (*ENDREPEAT*) 
        IF  e = e_sysinfo_not_found
        THEN
            e := e_ok;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END
ELSE
    BEGIN
    IF  (e = e_ok)
    THEN
        BEGIN
        del_sysk               := a01defaultkey;
        del_sysk.stableid      := triggerp^.strigger.tr_proc_id;
        a10del_sysinfo (acv, del_sysk, e);
        IF  e = e_sysinfo_not_found
        THEN (* older releases did not create this information *)
            e := e_ok;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  e = e_ok
    THEN
        BEGIN
        next_sysk             := triggerp^.syskey;
        next_sysk.sentrytyp   := cak_eviewtext;
        next_sysk.slinkage[1] := next_sysk.slinkage[2];
        next_sysk.skeylen     := sizeof (next_sysk.stableid) +
              sizeof (next_sysk.sentrytyp) + sizeof (next_sysk.slinkage[1]);
        exit_loop := false;
        loopCnt   := 0;
        REPEAT
            loopCnt := loopCnt + 1;
            REPEAT
                a10next_sysinfo (acv, next_sysk,
                      sizeof (next_sysk.stableid ) +
                      sizeof (next_sysk.sentrytyp) + sizeof (next_sysk.slinkage[1]),
                      d_release, next_sysk.sentrytyp, nextp, e);
                IF  e = e_ok
                THEN
                    a10del_sysinfo (acv, next_sysk, e);
                (*ENDIF*) 
            UNTIL
                e <> e_ok;
            (*ENDREPEAT*) 
            IF  (e = e_no_next_record) AND (loopCnt = 1)
            THEN
                BEGIN (* delete create trigger statement from catalog *)
                next_sysk.slinkage[1] := chr(255 - ord(next_sysk.slinkage[1]));
                next_sysk.slinkage[2] := chr(0);
                next_sysk.skeylen     := sizeof (next_sysk.stableid) +
                      sizeof (next_sysk.sentrytyp) + sizeof (next_sysk.slinkage[1]);
                e := e_ok;
                END
            ELSE
                exit_loop := true;
            (*ENDIF*) 
        UNTIL
            exit_loop;
        (*ENDREPEAT*) 
        IF  e = e_no_next_record
        THEN
            BEGIN;
            del_sysk           := triggerp^.syskey;
            del_sysk.sentrytyp := cak_epermmessblock;
            a10del_sysinfo (acv, del_sysk, e);
            IF  e = e_ok
            THEN
                BEGIN (* delete debug info *)
                del_sysk.sentrytyp := cak_emethoddebuginfo;
                a10del_sysinfo (acv, del_sysk, e);
                del_sysk.slinkage[1] := chr(1);
                a10del_sysinfo (acv, del_sysk, e);
                IF  e = e_sysinfo_not_found
                THEN (* debug info may not exist, ignore error *)
                    e := e_ok;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (acv.a_returncode = 0) AND (e = e_ok)
THEN
    BEGIN
    IF  triggerp^.syskey.slinkage = cak_del_trigger_linkage
    THEN
        commentId := 3
    ELSE
        IF  triggerp^.syskey.slinkage = cak_upd_trigger_linkage
        THEN
            commentId := 2
        ELSE
            IF  triggerp^.syskey.slinkage = cak_ins_trigger_linkage
            THEN
                commentId := 1
            ELSE
                commentId := 0;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  commentId > 0
    THEN
        a26drop_comment (acv, cm_trigger,
              triggerp^.syskey.stableid, triggerp^.syskey.stableid, commentId);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  e = e_ok
THEN
    a10del_sysinfo (acv, triggerp^.syskey, e);
(*ENDIF*) 
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262drop_trigger (
            VAR acv          : tak_all_command_glob;
            VAR trigger_name : tsp00_KnlIdentifier);
 
VAR
      drop_trigger         : boolean;
      dropped              : integer;
      internalTriggers     : integer;
      replicationUserTabId : tgg00_Surrogate;
      e                    : tgg00_BasisError;
      triggerp             : tak_sysbufferaddress;
      curr_triggername     : tsp00_KnlIdentifier;
      sysk                 : tgg00_SysInfoKey;
 
BEGIN
dropped          := 0;
internalTriggers := 0;
sysk             := acv.a_p_arr1.pbasep^.syskey;
sysk.sentrytyp   := cak_etrigger;
sysk.slinkage    := cak_zero_linkage;
REPEAT
    drop_trigger := false;
    a10next_sysinfo (acv, sysk, sizeof (sysk.stableid), d_fix,
          sysk.sentrytyp, triggerp, e);
    IF  e = e_ok
    THEN
        a262get_trigger_name (triggerp^.strigger, curr_triggername, e);
    (*ENDIF*) 
    IF  e = e_ok
    THEN
        BEGIN
        drop_trigger := curr_triggername = trigger_name;
        IF  drop_trigger
        THEN
            BEGIN
            dropped := dropped + 1;
            WITH acv.a_p_arr1.pbasep^.sbase DO
                IF  triggerp^.syskey.slinkage = cak_del_trigger_linkage
                THEN
                    blinkexist := blinkexist - [ del_trigger ]
                ELSE
                    IF  triggerp^.syskey.slinkage = cak_ins_trigger_linkage
                    THEN
                        blinkexist := blinkexist - [ ins_trigger ]
                    ELSE
                        blinkexist := blinkexist - [ upd_trigger ];
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDWITH*) 
            IF  (acv.a_isReplicationUser AND
                (sysk.slinkage[2] < chr(cak262_internalTriggerOffset)))
                OR
                (NOT acv.a_isReplicationUser AND
                (sysk.slinkage[2] > chr(cak262_internalTriggerOffset)))
            THEN
                a07_b_put_error (acv, e_missing_privilege, 1)
            ELSE
                ak262drop_one_trigger (acv, triggerp)
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            IF  sysk.slinkage[2] > chr(cak262_internalTriggerOffset)
            THEN
                internalTriggers := internalTriggers + 1;
            (*ENDIF*) 
            sysk.slinkage[2] := succ(sysk.slinkage[2]);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
UNTIL
    e <> e_ok;
(*ENDREPEAT*) 
&ifdef trace
t01int4 (ak_sem, 'internal_tri', internalTriggers);
&endif
IF  e <> e_no_next_record
THEN
    a07_b_put_error (acv, e, 1)
ELSE
    IF  dropped = 0
    THEN
        a07_nb_put_error (acv, e_unknown_trigger, 1, trigger_name)
    ELSE
        IF  internalTriggers = 0
        THEN
            BEGIN
            acv.a_p_arr1.pbasep^.sbase.blinkexist :=
                  acv.a_p_arr1.pbasep^.sbase.blinkexist - [internal_trigger];
            replicationUserTabId := cak_replication_usertab_id;
            a19del_usertab  (acv, replicationUserTabId, acv.a_p_arr1.pbasep^.sbase.bsurrogate);
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262alter_trigger (
            VAR acv  : tak_all_command_glob;
            errorpos : integer);
 
BEGIN
a07_b_put_error (acv, e_not_implemented, errorpos)
END;
 
(*------------------------------*) 
 
FUNCTION
      ak262ReserveJumpAbsolute (VAR acv : tak_all_command_glob) : tsp00_Int4;
 
BEGIN
ak262ReserveJumpAbsolute := acv.a_mblock.mb_qual^.mfirst_free;
ak262emit (acv, st_jump_absolute, 0, 0)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262whenever_clause (
            VAR acv     : tak_all_command_glob;
            VAR a11v    : tak_a11_glob;
            compileInfo : tak_proc_compile_type;
            trig_ptr    : tak_sysbufferaddress);
 
VAR
      initProcCompile : tak_proc_compile_type;
      b_err           : tgg00_BasisError;
      tr_stack_ptr    : integer;
      st_pointer      : integer;
      sysk            : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
    a11v.a1ti := a_ap_tree^[a11v.a1ti].n_sa_level;
&   ifdef trace
    t01int4 (ak_sem, 'a1ti        ', a11v.a1ti);
&   endif
    a_ptr1 := trig_ptr;
    (*=========================================================*)
    (* create tak_viewdesc record describing the qualification *)
    (* as required by show trigger statement                   *)
    (*=========================================================*)
    ;
    initProcCompile := a_proc_compile;
    a_is_ddl        := ddl_create_trigger; (* allow OLD/NEW *)
    a_proc_compile  := compileInfo;
    a11condition (acv, a11v, ord (a_ptr1^.syskey.slinkage[ 1 ]) * 256 +
          ord (a_ptr1^.syskey.slinkage[ 2 ]), cak_is_undefined);
    ;
    a_proc_compile  := initProcCompile;
    (*========================================================*)
    (* store whenever qualification stored in a_mblock into   *)
    (* tak_triggerrecord allocated at address a_ptr1          *)
    (*========================================================*)
    ;
    WITH a_mblock, mb_qual^, a_ptr1^.strigger DO
        BEGIN
        tr_stack_ptr := (tr_name_len - 1) DIV sizeof (tr_stack[1]) + 1 +
              tr_param_cnt;
        st_pointer   := mqual_pos;
        WHILE (st_pointer < mqual_pos + mqual_cnt) AND
              (a_returncode = 0) DO
            IF  tr_stack_ptr < cak_max_trigger_stack
            THEN
                BEGIN
                tr_stack_ptr := tr_stack_ptr + 1;
                tr_stack[ tr_stack_ptr ] := mb_st^ [st_pointer];
                st_pointer := st_pointer + 1
                END
            ELSE
                a07_b_put_error (acv, e_too_complex_trigger_cond, 1);
            (*ENDIF*) 
        (*ENDWHILE*) 
        tr_condition_cnt := mqual_cnt;
        a_ptr1^.b_sl     := a_ptr1^.b_sl + mqual_cnt * STACK_ENTRY_MXGG00;
        IF  a_ptr1^.b_sl + a_mblock.mb_data_len  -
            cgg_rec_key_offset <= MAX_RECLEN_GG00
        THEN
            BEGIN (* qual values fit into cak_trigger record *)
            SAPDB_PascalForcedMove (mb_data_size, sizeof(a_ptr1^),
                  @mb_data^.mbp_buf, cgg_rec_key_offset + 1,
                  @a_ptr1^, a_ptr1^.b_sl + 1,
                  mb_data_len  - cgg_rec_key_offset);
            a_ptr1^.b_sl := a_ptr1^.b_sl +
                  mb_data_len  - cgg_rec_key_offset
            END
        ELSE
            BEGIN (* successor tak_triggerrecord needed *)
            tr_succ_exists := true;
            sysk           := a_ptr1^.syskey;
            a06inc_linkage (sysk.slinkage);
            a10_nil_get_sysinfo (acv, sysk, d_release,
                  mxak_standard_sysk + mb_data_len , a_ptr2, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                SAPDB_PascalForcedMove (mb_data_size, sizeof(a_ptr2^),
                      @mb_data^.mbp_buf, cgg_rec_key_offset + 1,
                      @a_ptr2^, cak_sysbufferoffset + 1,
                      mb_data_len  - cgg_rec_key_offset);
                a_ptr2^.b_sl := cak_sysbufferoffset +
                      mb_data_len  - cgg_rec_key_offset;
                a10add_sysinfo (acv, a_ptr2, b_err)
                END;
            (*ENDIF*) 
            IF  b_err <> e_ok
            THEN
                a07_b_put_error (acv, b_err, 1)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a262exist_trigger (
            VAR acv             : tak_all_command_glob;
            VAR trigger_name    : tsp00_KnlIdentifier;
            VAR trigger_ptr_arr : tak_syspointerarr;
            VAR trigger_kind    : tgg00_Linkset);
      (*========================================================*)
      (* IN a_p_arr1 : must contain pointers to tak_baserecords *)
      (*               of a base table                          *)
      (*========================================================*)
 
VAR
      b_err       : tgg00_BasisError;
      test_name   : boolean;
      aux_set     : tgg00_Linkset;
      tr_name     : tsp00_KnlIdentifier;
      trigger_key : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a_p_arr1.pbasep^.sbase DO
    BEGIN
    test_name   := trigger_name <> a01_il_b_identifier;
    aux_set     := blinkexist * [del_trigger, ins_trigger, upd_trigger];
    trigger_kind:= [  ];
    trigger_key := a_p_arr1.pbasep^.syskey;
    trigger_key.sentrytyp  := cak_etrigger;
    REPEAT
        trigger_ptr_arr.pcount := 0;
        REPEAT
            b_err := e_ok;
            IF  del_trigger in aux_set
            THEN
                BEGIN
                trigger_key.slinkage := cak_del_trigger_linkage;
                aux_set := aux_set - [ del_trigger ]
                END
            ELSE
                IF  ins_trigger in aux_set
                THEN
                    BEGIN
                    trigger_key.slinkage := cak_ins_trigger_linkage;
                    aux_set := aux_set - [ ins_trigger ]
                    END
                ELSE
                    IF  upd_trigger in aux_set
                    THEN
                        BEGIN
                        trigger_key.slinkage := cak_upd_trigger_linkage;
                        aux_set := aux_set - [ upd_trigger ]
                        END
                    ELSE
                        b_err := e_key_not_found;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            IF  internal_trigger in trigger_kind
            THEN
                trigger_key.slinkage[2] := chr(ord(trigger_key.slinkage[2]) + cak262_internalTriggerOffset);
            (*ENDIF*) 
            IF  b_err = e_ok
            THEN
                a10get_sysinfo (acv, trigger_key, d_fix,
                      trigger_ptr_arr.px[trigger_ptr_arr.pcount+1], b_err);
            (*ENDIF*) 
            IF  b_err = e_ok
            THEN
                a262get_trigger_name (
                      trigger_ptr_arr.px[ trigger_ptr_arr.pcount+1 ]^.strigger,
                      tr_name, b_err);
            (*ENDIF*) 
            IF  b_err = e_ok
            THEN
                BEGIN
                IF  NOT test_name OR (tr_name = trigger_name)
                THEN
                    BEGIN
                    trigger_ptr_arr.pcount :=
                          trigger_ptr_arr.pcount + 1;
                    IF  internal_trigger in trigger_kind
                    THEN
                        BEGIN
                        aux_set                 := [];
                        trigger_key.slinkage[2] := chr(ord(trigger_key.slinkage[2]) - cak262_internalTriggerOffset);
                        END;
                    (*ENDIF*) 
                    IF  trigger_key.slinkage = cak_del_trigger_linkage
                    THEN
                        trigger_kind := trigger_kind + [del_trigger]
                    ELSE
                        IF  trigger_key.slinkage = cak_ins_trigger_linkage
                        THEN
                            trigger_kind := trigger_kind + [ins_trigger]
                        ELSE
                            trigger_kind := trigger_kind + [upd_trigger]
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  (b_err = e_sysinfo_not_found) AND
                (internal_trigger in trigger_kind)
            THEN
                b_err := e_ok;
            (*ENDIF*) 
        UNTIL
            (aux_set = [  ]);
        (*ENDREPEAT*) 
        IF  test_name AND (trigger_kind = []) AND (internal_trigger in blinkexist)
        THEN
            BEGIN
            trigger_kind := [internal_trigger];
            aux_set      := [del_trigger, ins_trigger, upd_trigger];
            END;
        (*ENDIF*) 
    UNTIL
        (aux_set = []);
    (*ENDREPEAT*) 
    IF  b_err <> e_ok
    THEN
        BEGIN
        IF  b_err <> e_key_not_found
        THEN
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        END;
&   ifdef trace
    (*ENDIF*) 
    IF  del_trigger in trigger_kind
    THEN
        t01name (ak_sem, 'DEL TRIGGER       ');
    (*ENDIF*) 
    IF  ins_trigger in trigger_kind
    THEN
        t01name (ak_sem, 'INS TRIGGER       ');
    (*ENDIF*) 
    IF  upd_trigger in trigger_kind
    THEN
        t01name (ak_sem, 'UPD TRIGGER       ');
    (*ENDIF*) 
    IF  internal_trigger in trigger_kind
    THEN
        t01name (ak_sem, 'INTERNAL TRIGGER  ');
&   endif
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262in_buf (
            VAR acv         : tak_all_command_glob;
            VAR dmli        : tak_dml_info;
            VAR catalog_ptr : tak_sysbufferaddress;
            data_len        : integer;
            qual_pos        : integer;
            qual_len        : integer;
            dataqualpos     : integer);
 
VAR
      e           : tgg00_BasisError;
      firstpos    : integer;
      aux_len     : integer;
      move_len    : integer;
      moved_len   : integer;
      j           : integer;
      mb_data_pos : tsp00_Int4;
      sysk        : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a_mblock DO
    BEGIN
&   IFDEF TRACE
    t01int4 (ak_sem, 'data_len    ', data_len);
    t01int4 (ak_sem, 'dataqualpos ', dataqualpos);
    t01messblock (ak_sem, 'in_buf am 1 ', a_mblock);
&   ENDIF
    moved_len    := data_len;
    mb_data_pos  := mb_data_len + 1;
    REPEAT
        IF  dataqualpos + data_len - 1 > catalog_ptr^.b_sl
        THEN
            move_len := catalog_ptr^.b_sl - dataqualpos + 1
        ELSE
            move_len := data_len;
        (*ENDIF*) 
        SAPDB_PascalMove ('VAK262',  41,    
              sizeof(catalog_ptr^), mb_data_size, @catalog_ptr^, dataqualpos,
              @mb_data^.mbp_buf, mb_data_pos, move_len,
              a_returncode);
        data_len := data_len - move_len;
        IF  data_len > 0
        THEN
            BEGIN
            mb_data_pos := mb_data_pos + move_len;
            sysk        := catalog_ptr^.syskey;
            a06inc_linkage (sysk.slinkage);
            a10get_sysinfo (acv, sysk, d_release, catalog_ptr, e);
            IF  e <> e_ok
            THEN
                BEGIN
                data_len := 0;
                a07_b_put_error (acv, e, 1)
                END
            ELSE
                dataqualpos := sizeof (catalog_ptr^.strigger) -
                      ( sizeof (catalog_ptr^.strigger.tr_stack) +
                      sizeof (catalog_ptr^.strigger.tr_upd_set) +
                      sizeof (catalog_ptr^.strigger.tr_maxUpdatedColno) +
                      sizeof (catalog_ptr^.strigger.tr_language) +
                      sizeof (catalog_ptr^.strigger.tr_name_len) ) + 1
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    UNTIL
        data_len <= 0;
    (*ENDREPEAT*) 
    firstpos := 0;
    FOR j := qual_pos TO qual_pos + qual_len - 1 DO
        WITH mb_st^ [j] DO
            IF  (etype in [ st_value, st_date, st_time, st_timestamp,
                (* PTS 1116175 E.Z. *)
                st_utcdate,
                (* PTS 1109925 E.Z. *)
                st_utcdiff,
                st_uid, st_user, st_usergroup, st_current_schema, st_localsysdba,
                st_sysdba, st_language, st_format, st_transaction,
                st_timezone (* PTS 1122262 E.Z. *)
                ])
                OR
                ((etype = st_build_in_func) AND
                (eop_build_in = op_b_user_def_func))
            THEN
                BEGIN
                IF  firstpos = 0
                THEN
                    firstpos := epos;
                (*ENDIF*) 
                epos          := epos - firstpos + mb_data_len + 1;
                IF  ((etype <> st_value) AND NOT dmli.d_view)
                THEN
                    IF  ((a_ex_kind = only_parsing) AND
                        (
                        (* PTS 1122262 E.Z. *)
                        ( etype = st_date )       OR
                        ( etype = st_time )       OR
                        ( etype = st_timestamp)   OR
                        ( etype = st_utcdate )    OR
                        ( etype = st_utcdiff )    OR
                        ( etype = st_transaction) OR
                        ( etype = st_timezone)    OR
                        ( etype = st_current_schema)
                        ))
                    THEN
                        BEGIN
                        IF  dmli.d_sparr.pparsp <> NIL (* PTS 1113215 *)
                        THEN
                            BEGIN
                            aux_len     := mb_data_len;
                            mb_data_len := epos - 1;
                            a54_fixedpos (acv, dmli);
                            mb_data_len := aux_len;
                            a54datetime_parsinfo (acv, dmli, j)
                            END
                        (*ENDIF*) 
                        END
                    ELSE
                        a54_internal_function (acv, a_mblock, j);
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDFOR*) 
    a_mblock.mb_data_len := a_mblock.mb_data_len + moved_len;
&   ifdef TRACE
    t01messblock (ak_sem, 'in_buf am 2 ', a_mblock);
&   endif
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak262finalize_dmli (
            VAR dmli         : tak_dml_info;
            VAR TransContext : tgg00_TransContext);
 
BEGIN
a54_dml_finalize( dmli, TransContext );
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
