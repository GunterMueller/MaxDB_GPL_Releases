.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 2000-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-22
*****************************************************
modname : VAK501
changed : 2000-11-22
module  : Executing_dispatcher
 
Author  : ElkeZ
Created : 1985-04-15
*****************************************************
 
Purpose : Main module and distributor for commands that are
          already parsed and only need to be executed
 
Define  :
 
        PROCEDURE
              a501exec_with_change_rec (
                    VAR acv                 : tak_all_command_glob;
                    VAR dmli                : tak_dml_info;
                    VAR parsk               : tak_parskey;
                    VAR change_rec          : tak_changerecord;
                    output_during_execution : boolean);
 
        PROCEDURE
              a501do_execute (
                    VAR acv                 : tak_all_command_glob;
                    VAR dmli                : tak_dml_info;
                    VAR parsk               : tak_parskey;
                    output_during_execution : boolean);
 
        PROCEDURE
              a501execute (
                    VAR acv    : tak_all_command_glob;
                    VAR parsid : tak_parsid);
 
        PROCEDURE
              a501get_resname (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a501GetResultName (
                    VAR acv : tak_all_command_glob;
                    VAR resultName : tsp00_KnlIdentifier);
 
.CM *-END-* define --------------------------------------
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01sysnullkey       : tgg00_SysInfoKey;
              a01diag_monitor_on  : boolean;
              a01diag_analyze_on  : boolean;
              a01_il_b_identifier : tsp00_KnlIdentifier;
              a01_i_syscursorname : tsp00_KnlIdentifier;
              a01identifier_size  : integer;
 
        PROCEDURE
              a01_init_command (VAR acv : tak_all_command_glob);
 
        FUNCTION
              a01aligned_cmd_len (len : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05_stamp_get (
                    VAR acv    : tak_all_command_glob;
                    VAR dest   : tgg00_Surrogate;
                    destpos    : integer;
                    mv_dest    : integer);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06drop_fieldlist_references (VAR fieldlists : tgg00_FieldLists);
 
        PROCEDURE
              a06reset_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06finish_curr_retpart (
                    VAR acv   : tak_all_command_glob;
                    part_kind : tsp1_part_kind;
                    arg_count : tsp00_Int2);
 
        PROCEDURE
              a06retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10repl_sysinfo (
                    VAR acv       : tak_all_command_glob;
                    VAR syspoint  : tak_sysbufferaddress;
                    VAR b_err     : tgg00_BasisError);
 
        PROCEDURE
              a10key_del  (
                    VAR acv        : tak_all_command_glob;
                    VAR syspointer : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              SQLManager : vak101;
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
        FUNCTION
              a101_GetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tsp00_Int4;
 
        PROCEDURE
              a101_DestroyGroupedTempFiles(
                    VAR trans      : tgg00_TransContext;
                    fileType       : tgg00_TfnTemp(*ptocConst*);
                    level          : tsp00_Int4(*ptocConst*);
                    subLevel       : tsp00_Int2(*ptocConst*);
                    VAR fileName   : tgg00_Filename);
 
        PROCEDURE
              a101_SetTempFileLevel(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId;
                    level          : tsp00_Int2(*ptocConst*));
 
        PROCEDURE
              a101_GetTempFileInstance(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              AK_Trigger : VAK262;
 
        PROCEDURE
              a262execute_trigger (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a262Debug (VAR acv : tak_all_command_glob;
                    debugListen : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Show_statistics : VAK42;
 
        PROCEDURE
              a42_check_database (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a42put_running_cmds (
                    VAR acv    : tak_all_command_glob;
                    VAR parsid : tak_parsid);
 
        PROCEDURE
              a42reset_running_cmds (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              Executing_complex : VAK502;
 
        PROCEDURE
              a502complex_execution (
                    VAR acv                 : tak_all_command_glob;
                    VAR dmli                : tak_dml_info;
                    VAR change_rec          : tak_changerecord;
                    VAR parsk               : tak_parskey;
                    output_during_execution : boolean );
 
      ------------------------------ 
 
        FROM
              Executing_union : VAK503;
 
        PROCEDURE
              a503union_execution (
                    VAR acv                 : tak_all_command_glob;
                    VAR dmli                : tak_dml_info;
                    VAR change_rec          : tak_changerecord;
                    VAR parsk               : tak_parskey;
                    output_during_execution : boolean );
 
      ------------------------------ 
 
        FROM
              Executing_loop_most : VAK505;
 
        PROCEDURE
              a505fill_mess_buf (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    VAR erec   : tak_exec_rec;
                    VAR frec   : tak_fill_rec;
                    full_part2 : boolean);
 
        PROCEDURE
              a505loop_most_execute (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    VAR change_rec : tak_changerecord;
                    VAR erec       : tak_exec_rec;
                    VAR parsk      : tak_parskey;
                    viewkeybuf     : tak_sysbufferaddress;
                    VAR series     : tak68_sequence;
                    VAR cinfo      : tak_corr_infos;
                    VAR old_cinfo  : tak_corr_infos;
                    inner_loop     : boolean);
 
        PROCEDURE
              a505most_execute (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    VAR change_rec : tak_changerecord;
                    VAR parsk      : tak_parskey;
                    VAR erec       : tak_exec_rec;
                    VAR cinfo      : tak_corr_infos;
                    VAR old_cinfo  : tak_corr_infos;
                    viewkeybuf     : tak_sysbufferaddress;
                    inner_loop     : boolean);
 
        PROCEDURE
              a505next_command (
                    VAR acv       : tak_all_command_glob;
                    VAR sparr     : tak_syspointerarr;
                    VAR old_parsk : tak_parskey;
                    ex_plus       : integer);
 
      ------------------------------ 
 
        FROM
              Executing_values : VAK506;
 
        PROCEDURE
              a506fieldvalues (
                    VAR acv       : tak_all_command_glob;
                    VAR dmli      : tak_dml_info;
                    VAR frec      : tak_fill_rec;
                    viewkeybuf    : tak_sysbufferaddress;
                    VAR result    : tsp00_MoveObj;
                    resultBufSize : tsp00_Int4); (* PTS 1115085 *)
 
      ------------------------------ 
 
        FROM
              Pseudo_fieldmap : VAK509;
 
        FUNCTION
              a509build_map_from_databuffer (databuffer_ptr : tsp00_MoveObjPtr;
                    map_ptr                  : tsp00_MoveObjPtr;
                    VAR length_in_databuffer : tsp00_Int4) : boolean;
 
        FUNCTION
              a509get_one_value (map_ptr : tsp00_MoveObjPtr;
                    value_no       : tsp00_Int2;
                    VAR value_ptr  : tsp00_MoveObjPtr;
                    VAR value_len  : tsp00_Int4;
                    VAR is_null    : boolean;
                    VAR is_default : boolean) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51set_degree (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a51SetSessionReplicationProlog (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Lock_Commit_Rollback : VAK52;
 
        PROCEDURE
              a52end_rollback_subtrans (
                    VAR acv           : tak_all_command_glob;
                    VAR subtrans_name : tsp00_KnlIdentifier;
                    m_type : tgg00_MessType);
 
        PROCEDURE
              a52InnerTransaction (
                    VAR acv : tak_all_command_glob;
                    subproc : integer);
 
        PROCEDURE
              a52internal_subtrans (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a52new_subtrans (
                    VAR acv           : tak_all_command_glob;
                    VAR subtrans_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a52commit_rollback (
                    VAR acv        : tak_all_command_glob;
                    m_type         : tgg00_MessType;
                    n_rel          : boolean;
                    normal_release : boolean);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK54;
 
        PROCEDURE
              a54_dml_init (
                    VAR acv   : tak_all_command_glob;
                    VAR dmli  : tak_dml_info;
                    in_union  : boolean);
 
        PROCEDURE
              a54_dml_finalize (
                    VAR dmli         : tak_dml_info;
                    VAR TransContext : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              diagnose monitor : VAK545;
 
        PROCEDURE
              a545sm_insert (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              diagnose analyze : VAK544;
 
        PROCEDURE
              a544get_cmdid(
                    VAR acv     : tak_all_command_glob;
                    VAR parskey : tak_parskey;
                    VAR cmdid   : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              Select_Syntax : VAK60;
 
        PROCEDURE
              a60rescount (
                    VAR acv  : tak_all_command_glob;
                    rescount : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Subquery_handling : VAK661;
 
        PROCEDURE
              a661_build_t_fromsel_tableid (
                    VAR syskey_tableid  : tgg00_Surrogate;
                    VAR fn_tableid      : tgg00_Surrogate;
                    VAR curr_ex_parskey : tak_parskey;
                    site                : tgg00_ServerdbNo;
                    from_select_no      : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Resultname_handling : VAK663;
 
        PROCEDURE
              a663_del_result (
                    VAR acv          : tak_all_command_glob;
                    VAR resname_rec  : tak_resname_record;
                    do_cdel          : boolean;
                    del_resname_rec  : boolean);
 
        PROCEDURE
              a663_resname (
                    VAR acv          : tak_all_command_glob;
                    VAR res_name     : tsp00_KnlIdentifier;
                    VAR modul_name   : tsp00_KnlIdentifier;
                    VAR resname_addr : tak_sysbufferaddress;
                    dstate           : tak_directory_state;
                    errorpos         : integer);
 
      ------------------------------ 
 
        FROM
              Resulttable : VAK73;
 
        PROCEDURE
              a73_one_fetch (
                    VAR acv      : tak_all_command_glob;
                    VAR sparr    : tak_syspointerarr;
                    mtype        : tgg00_MessType2;
                    position     : tsp00_Int4);
 
        PROCEDURE
              a73_more_fetch (
                    VAR acv      : tak_all_command_glob;
                    VAR sparr    : tak_syspointerarr;
                    mtype        : tgg00_MessType2;
                    pos          : tsp00_Int4;
                    mfetch_count : tsp00_Int4);
 
        PROCEDURE
              a73_close_execute (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    VAR resn       : tsp00_KnlIdentifier;
                    VAR modul_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a73_describe_execute (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    VAR resn       : tsp00_KnlIdentifier;
                    VAR modul_name : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              Fetch_Without_Resulttable : VAK74;
 
        PROCEDURE
              a74_search_fetch (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    mtype          : tgg00_MessType2;
                    pos            : tsp00_Int4;
                    VAR resnamerec : tak_sysbufferaddress;
                    single_fetch   : boolean;
                    mfetch_count   : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Deal-With-User-Commands : VAK92;
 
        PROCEDURE
              a92_map_into_upper (
                    VAR acv  : tak_all_command_glob;
                    VAR buf  : tsp00_MoveObj;
                    startpos : tsp00_Int4;
                    endpos   : tsp00_Int4;
                    uni_map  : boolean);
 
        PROCEDURE
              a92find_return_part (
                    VAR acv      : tak_all_command_glob;
                    part_kind    : tsp1_part_kind;
                    VAR part_ptr : tsp1_part_ptr);
 
        PROCEDURE
              a92parse_again (
                    VAR acv       : tak_all_command_glob;
                    VAR parsid    : tak_parsid;
                    dropStoredCmd : boolean); (* PTS 1106286 *)
 
      ------------------------------ 
 
        FROM
              KB_Logging : VKB560;
 
        PROCEDURE
              kb560StartSavepointAndWait (
                    VAR Trans : tgg00_TransContext;
                    MessType2 : tgg00_MessType2);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              task_temp_data_cache : VBD21;
 
        PROCEDURE
              b21m_reset_monitor (
                    temp_cache_ptr : tgg00_TempDataCachePtr;
                    reset_sum : boolean);
 
        PROCEDURE
              b21m_parseid (temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR parseid       : tak_parsid;
                    VAR masterparseid : tak_parsid);
 
        PROCEDURE
              b21mp_parseid_put (temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR parseid       : tak_parsid;
                    VAR masterparseid : tak_parsid);
 
        PROCEDURE
              b21mp_cmdid_put (
                    temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR cmdid : tgg00_Surrogate);
 
        PROCEDURE
              b21m_parse_again (
                    temp_cache_ptr  : tgg00_TempDataCachePtr;
                    VAR parse_again : tsp00_C3);
 
        PROCEDURE
              b21mp_fetch_calls_put (temp_cache_ptr : tgg00_TempDataCachePtr);
 
        PROCEDURE
              b21mp_rows_fetched_put (
                    temp_cache_ptr : tgg00_TempDataCachePtr;
                    rows_fetched : tsp00_Int4);
 
        PROCEDURE
              b21mp_value_put (
                    temp_cache_ptr  : tgg00_TempDataCachePtr;
                    curr_value_addr : tsp00_MoveObjPtr;
                    curr_value_len  : tsp00_Int4);
 
        PROCEDURE
              b21mp_is_select (
                    temp_cache_ptr : tgg00_TempDataCachePtr;
                    is_select : boolean);
 
      ------------------------------ 
 
        FROM
              object_garbage_collection : VBD91;
 
        PROCEDURE
              bd91StartOMSGarbageCollection (
                    VAR Trans                   : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01unicode             : boolean;
              g01diag_moni_parse_on  : boolean;
 
        PROCEDURE
              g01opmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C24;
                    msg_value : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04build_temp_tree_id (
                    VAR curr : tgg00_FileId;
                    VAR t : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalUnicodeFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedUnicodeFill (
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2 );
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedOverlappingMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              GG_allocator_interface : VGG941;
 
        PROCEDURE
              gg941Deallocate(
                    VAR TransContext : tgg00_TransContext;
                    VAR p : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              Packet_handling: VSP26;
 
        PROCEDURE
              s26find_part (
                    VAR segm         : tsp1_segment;
                    part_kind        : tsp1_part_kind;
                    VAR part_ptr     : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              GET-Conversions : VSP40;
 
        PROCEDURE
              s40g4int (
                    VAR buf  : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    VAR dest : tsp00_Int4;
                    VAR res  : tsp00_NumError);
 
        PROCEDURE
              s40glint (
                    VAR buf  : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    len      : integer;
                    VAR dest : tsp00_Int4;
                    VAR res  : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80 : VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01messtype (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    mess_type    : tgg00_MessType);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01addr (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    bufaddr  : tsp00_MoveObjPtr);
 
        PROCEDURE
              t01buf (
                    level     : tgg00_Debug;
                    VAR buf   : tak_parskey;
                    pos_start : integer;
                    pos_end   : integer);
&       ENDIF
 
.CM *-END-* use -----------------------------------------
Synonym :
 
        PROCEDURE
              a05_stamp_get;
 
              tsp00_MoveObj tgg00_Surrogate
 
        PROCEDURE
              a42put_running_cmds;
 
              tsp00_C12 tak_parsid
 
        PROCEDURE
              b21mp_parseid_put;
 
              tsp00_C12 tak_parsid
              tsp00_C12 tak_parsid
 
        PROCEDURE
              b21m_parseid;
 
              tsp00_C12 tak_parsid
              tsp00_C12 tak_parsid
 
        PROCEDURE
              t01buf;
 
              tsp00_Buf tak_parskey
 
.CM *-END-* synonym -------------------------------------
***********************************************************
Specification:
 
Together with VAK502 - VAK507,
this module is responsible for processing commands
that are only to be executed, i.e. the parse information that must be
used is already present.
 
A501EXECUTE
 
This procedure is called directly by VAK92 if the user (precompiler)
sends only the parse id and the data for a command in the
SQL_PACKET to the kernel.
 
A501DO_EXECUTE
 
This procedure is called if the user has requested a normal command
execution but the kernel has made an internal separation between parsing
and execution.  This is the case for subqueries/unions.  In order to prevent
individual parts of the subquery from already being executed before the
semantic check has been run for other parts of the command, all parts
are first parsed, the parse information is stored and then the command
is executed.
 
Output_during_execution indicates that the result count and a result
(SELECT..INTO) within VAK50/53 are to be transferred to the SQL_PACKET.
If the value is false, it is an internal call of
A501DO_EXECUTE (internal separation into parsing and execution, no call
of A501EXECUTE) and the calling routine must still write long infos
before the result, if applicable.  Exception: VAK54 A54_SUBQUERY.
In that case, the value = true so that the result count is output.
 
A501EXEC_WITH_CHANGE_REC
 
The same applies as for A501DO_EXECUTE.  The only difference is that,
in the case of A501EXEC_WITH_CHANGE_REC, atch is passed upwards.  It contains
information which fields are to be converted,
the starting position of the conversion and the length.  This is, of
course, relevant for SELECT .. INTO only.  Since, in the case of
correlated subqueries, the outermost SELECT is not analyzed last,
the correct atch for the final result is not available to the caller. It
must again be fetched from the parse information
during the processing and passed outward.
 
.CM *-END-* specification -------------------------------
***********************************************************
Description:
 
The parse id that is always used within VAK50x has the following layout:
 
       p_id      : int4;  (* number of intern commands *)
       p_kind    : message_type;
       p_no      : int1;  (* highest parse-information number *)
 
The individual parts have the following meanings:
p_session The last 2 bytes of the 4-bytes session id
are stored here to make it possible to check whether the user
(precompiler) and the kernel associate the same command with this
parse id.  Otherwise it would be a critical case when a user parsed
some commands and had also already executed them and then came to an
implicit (command timeout) or explicit session end, was reconnected,
again parsed some commands (again receiving the command numbers
beginning with 1) and then sent an old parse id (before the session end) to
the kernel.  If the session number did not exist, the kernel might
recognize the command number and, if possible, perform an update/delete
or the like on a table that the user had not addressed with this
old parse id.
 
p_id
This is a current number that begins at 1 for each session and,
therefore, is unambiguous and differs from all commands within
this session.
 
p_kind
The message type of the command (update, select,
fetch, commit, etc ] is designated here, so that some commands can be
separated from others in good time because they are simpler/more complicated.
p_kind = m_nil (0) means that an attempt is made to execute a command
that must not be executed (DDL command or SHOW).  For these commands,
there is a parse id consisting of 0 only or filled with '00'h and 1
'01'h.
 
p_no
The highest number of a parse-information record that belongs
to this command is stored here.  Currently, there can be values from
0 (1 information record) to 127.  However, P_NO = 8 does not necessarily
mean that there must be 9 parse-information records.  Several message
buffers can be sent to KB within one command.  For each message buffer to
be built, there can be a maximum of 4 parse-information records.  In
order to simplify processing, the first parse-information record for each
message buffer receives a number evenly divisible by 4.  If there is only
this one information record for the message buffer, three numbers remain
free.
 
A501EXECUTE
 
The parse id only is retrieved from the SQL_PACKET and a check is
run to determine whether a session is in progress.  The execution itself
is performed via A501EXEC_WITH_CHANGE_REC.
 
A501DO_EXECUTE
 
Only the parameter atch required for A501EXEC_WITH_CHANGE_REC
is allocated as a local variable and A501EXEC_WITH_CHANGE_REC is called.
 
A501EXEC_WITH_CHANGE_REC
 
All_rescnt indicates how many results have already been found for
the current select (if one is pending).  The value is passed to the
message buffer again and again in, for example, correlated subqueries.
 
Cinfo is a record that is relevant for correlated subqueries only due
to the recursiveness of LOOP_MOST_EXECUTE but that must at this point
already be created and initialized (no correlation found).
 
A check is run to determine whether it is an executable command
(p_kind <> m_nil, session number is correct).
 
For COMMIT and ROLLBACK, under normal circumstances (no KEEP LOCK),
there is no parse information.  P_NO = maxint1 indicates RELEASE;
maxint1-1 shows that no RELEASE was specified. P_NO = maxint1-2
indicates that adbsparse was done with another sqlmode than
the session sqlmode. VAK52, which executes
the command, can be called directly.  If P_NO is neither
maxint1 nor maxint1-1 not maxint1-2,
KEEP LOCK was specified and 1-4 parse-information
records exist that must be processed normally.
 
The message types m_check_database (CHECK DATABASE) and
m_outcopy (LOAD requests the description of the range conditions of
a column for the quick load) represent special commands that do not need
to hold to the conventions for the parse information and are processed
directly in VAK42 or VAK11 (see the particular section).
 
Nor does the message type m_stamp (NEXT STAMP)
need any parse information;
instead, it must simply use A05_STAMP_GET to fetch the next system key
from VKB and transfer it to part2 of the SQL_PACKET or
construct the next long_desc_block for those LONG columns
which are inserted before the record they belong to is inserted.
 
In all other cases, NEXT_COMMAND is used to fetch the maximum of 4
parse-information records in SPARR required to build a
message buffer (array of pointers to the cache).
PLUS specifies the
number of the first parse-information record to be fetched (0 at the
start). Maxbufs designates the highest parse-information number that
can belong to this (sub)command (normally = old_parsk.p_no).
 
All the following procedures assume that the parse information is
contained in sparr.
 
No message-buffer needs to be built for CLOSE or DESCRIBE; the
parse information contains data on the result-table names, etc.
For FETCH and MFETCH, there is a message-buffer layout that is
different from the one for the other commands.
Column commands have practically nothing in common with DML commands.
For this reason, they must all branch to special procedures (see
that section).
 
Inserts, updates, deletes and selects can require several message
buffers due to subqueries, inserts applied to a join view, etc.  Therefore
a loop is initiated (LOOP_MOST_EXECUTE) that processes all message
buffers one after the other.
 
The message type m_key is for change operations applied to join views for
which the key values for the individual base tables must first be determined
and then the series of insert/update/deletes must be applied to the
base tables.  This occurs in KEY_EXECUTE.
 
Other commands (LOCK, COMMIT KEEP LOCK, UNLOCK, etc ] are handled via
a simple A53_MOST_EXECUTE.
 
AK501FETCH_EXECUTE
 
This procedure is called if a FETCH is to be performed for an individual
record.
 
FETCH_PART is used to identify the information records (result-set name,
'POS' value and parse buffer containing the key values up to which the
fetch has already been performed).
 
If the result set has already been built, A73_ONE_FETCH can be used to
fetch the record; if it has not been built, the record must first be
identified via A74_SEARCH_FETCH.
 
AK501MFETCH_EXECUTE
 
The number of results to be fetched (specified as int2) must be
retrieved from the SQL_PACKET from the first 2 bytes of part2.
Since int2 is specified as low byte, high byte for some computers and
as high byte, low byte for others, it might be necessary for a byte
swap to take place.
 
AK501FETCH_PART is used to again assemble some information records as in
AK501FETCH_EXECUTE.
 
If the result set has been built, A73_MORE_FETCH is used to fetch
the desired number of result records.  If the result set has not been
built, A74_SEARCH_FETCH is called with single_fetch = false.
 
AK501FETCH_PART
 
P_RESN contains the name of the result set from which the next
result records are to be fetched.
P_MODUL_NAME contains the name of the modul.
 
In the case of the unnamed result set, cntbuf = -1 indicates either
that the select has not yet been executed or a close has again been
performed, i.e. the result set is unknown.
 
In the case of the other special result set (SHOW), this is indicated via
'executed/closed'.
 
For all other names, a check must be run via A66_RESNAME_SEARCH to
determine whether the result set exists
and whether the SELECT has already been
executed.
 
In the case of a set fetch (fetch of more than one result record)
that is to be executed, the parse id of
the associated SELECT is stored in a part with
part~kind parsid_of_select in the SQL_PACKET in
order to allow the precompiler to identify the result buffer responsible
for the MFETCH.  If the SELECT was not separately parsed and then
executed, binary zeros are returned.
 
There is never more than one parse-information record for a FETCH.
For this reason, the system-information record that specifies for the
result set the point to which fetch has already been performed in it
(entrytyp = ereskey) can be fetched to sparr[ 2 ].
 
P_POSNO contains the position information for (M)FETCH POS [  ]. If
P_POSNO = -1, this means that the command has contained a parameter
as a position.  Its value must now be read from part2 of the SQL_PACKET.
In the case of FETCH, plus contains the value 2; in the
case of MFETCH, it contains the value 4, i.e. for MFETCHs, the position
is located (as a number) after the MFETCH number (2 bytes long).
 
AK501KEY_EXECUTE
 
This procedure is called if a modification is to take place for a
join view. The key values must be determined for the individual base
tables and, afterwards, the change operations are performed on the
base tables.
 
The variable 'series' is used to ensure (in LOOP_MOST_EXECUTE,
in the join part) that the message-buffer information records created
for the join is processed in the sequence in which they were built (in the
sequence of the FROM clause in the case of create view).  On the other
hand, in the case of a join select, the sequence in which they must
be processed can have been changed (via the strategic decision for the
processing sequence).
 
Viewkeybuf contains the keys of all base tables participating in the
join view (one record per table since join-view modifications are allowed
only for such unambiguous records).  Space is supplied in the cache
for this purpose.
 
One message-buffer information record is processed in a loop for each of
the tables involved.  This information record contains only the parts of
the particular key value that are already known from parsing
(A53_FILL_MESS_BUF).  The parameter values are also added via
A53_FIELDVALUES.  The rest of the key is appended on the end.  Afterwards,
the key that is thus built is moved to viewkeybuf.  The passage via the
message buffer is taken because the procedures used to fetch data from
the SQL_PACKET all operate on the message buffer.
 
For each loop run, one message-buffer information record (one
system-information record) is processed.
 
Via LOOP_MOST_EXECUTE, the actual command (with join for qualification
before and/or after the change operations) is then executed.
 
After the join condition has been checked following the change operation,
the number of view records for which the change operation was performed
(always 1 since unambiguous keys are specified)
must still be recorded in the
SQL_PACKET.
 
.CM *-END-* description ---------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      c_output_during_execution = true  (* a501do_execute *);
      c_single                  = true  (* ak501fetch_rest*);
      c_full_part2              = true  (* a505fill_mess_buf *);
      c_inner_loop              = true  (* a505loop_most_execute *);
      (*                                  a505_most_execute     *)
      c_n_rel                   = true  (* a52commit_rollback *);
      c_normal_release          = true  (* a52commit_rollback *);
      c_in_union                = true  (* a54_dml_init *);
      c_do_cdel                 = true  (* a663_del_result *);
      c_del_resname_rec         = true  (* a663_del_result *);
      c_single_fetch            = true  (* a74_search_fetch *);
      c_uni_map                 = true  (* a92_map_into_upper *);
      c_reset_sum               = true  (* b21m_reset_monitor *);
      c_is_select               = true  (* b21mp_is_select *);
 
 
(*------------------------------*) 
 
PROCEDURE
      a501exec_with_change_rec (
            VAR acv                 : tak_all_command_glob;
            VAR dmli                : tak_dml_info;
            VAR parsk               : tak_parskey;
            VAR change_rec          : tak_changerecord;
            output_during_execution : boolean);
 
VAR
      _cinfo        : tak_corr_infos;
      _old_cinfo    : tak_corr_infos;
      _erec         : tak_exec_rec;
      _defined_byte : tsp00_C1;
      _next_stamp   : tgg00_Surrogate;
      _dummyser     : tak68_sequence;
      _dummybuf     : tak_sysbufferaddress;
      _p            : tsp00_Addr;
 
BEGIN
(* PTS 1000985/1001162 E.Z. *)
IF  NOT (csa_subq_datatype_problem in acv.a_sql_cmd_state)
THEN
    BEGIN
&   IFDEF TRACE
    t01messtype (ak_sem,  'parsk.p_kind', parsk.p_kind);
    t01int4 (ak_sem, 'parsk.p_no  ', parsk.p_no);
    t01buf (ak_sem, parsk, 1, sizeof(parsk));
&   ENDIF
    _erec.ex_output_wanted       := output_during_execution AND
          (acv.a_qualified_jv_upd = no_jv_upd);
    _erec.ex_with_link           := false;
    _erec.ex_command_needed      := true;
    _erec.ex_maxbufs             := parsk.p_no;
    _erec.ex_all_rescnt          := 0;
    _erec.ex_act_treeid          := b01niltree_id;
    _erec.ex_updjv_ptr           := NIL;
    _erec.ex_mb_data             := NIL; (* PTS 1112612 *)
    _erec.ex_parameter_fieldlist := NIL;
    _erec.ex_result_fieldlist    := NIL;
    _cinfo.co_use_cinfo     := false;
    _cinfo.co_corr_buf      := NIL;
    _old_cinfo.co_corr_buf  := NIL;
    _dummybuf               := NIL;
    IF  parsk.p_kind = m_nil
    THEN
        a07_b_put_error (acv, e_invalid_command, 1);
    (* PTS 1111510 E.Z. *)
    (*ENDIF*) 
    acv.a_curr_ex_parskey  := parsk;
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        IF  ((parsk.p_kind = m_commit) OR (parsk.p_kind =  m_rollback))
            AND
            ((parsk.p_no = csp_maxint1)   OR
            ( parsk.p_no = csp_maxint1-1) OR
            ( parsk.p_no = csp_maxint1-2))
        THEN
            BEGIN
            IF  acv.a_statement_kind = isql_commands
            THEN
                IF  parsk.p_kind = m_commit
                THEN
                    acv.a_statement_kind := icommits
                ELSE
                    acv.a_statement_kind := irollbacks;
                (*ENDIF*) 
            (* PTS 1102895 E.Z. *)
            (*ENDIF*) 
            IF  parsk.p_kind = m_commit
            THEN
                IF  parsk.p_no = csp_maxint1
                THEN
                    acv.a_return_segm^.sp1r_function_code := csp1_commit_release_fc
                ELSE
                    acv.a_return_segm^.sp1r_function_code := csp1_commit_fc
                (*ENDIF*) 
            ELSE
                IF  parsk.p_no = csp_maxint1
                THEN
                    acv.a_return_segm^.sp1r_function_code := csp1_rollback_release_fc
                ELSE
                    acv.a_return_segm^.sp1r_function_code := csp1_rollback_fc;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  parsk.p_no = csp_maxint1-2
            THEN
                BEGIN
                a505next_command (acv, dmli.d_sparr, parsk, 0);
                IF  acv.a_returncode = 0
                THEN
                    acv.a_sqlmode := dmli.d_sparr.px[ 1 ]^.sparsinfo.p_sqlmode;
                (*ENDIF*) 
                parsk.p_no := csp_maxint1-1;
                END;
            (*ENDIF*) 
            IF  acv.a_returncode = 0
            THEN
                IF  parsk.p_no = csp_maxint1
                THEN
                    a52commit_rollback (acv, parsk.p_kind, c_n_rel,
                          c_normal_release)
                ELSE
                    IF  parsk.p_no = csp_maxint1-1
                    THEN
                        a52commit_rollback (acv, parsk.p_kind,
                              NOT c_n_rel, c_normal_release);
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            CASE parsk.p_kind OF
                m_begin, m_end, m_partial_rollback :
                    ak501subtrans (acv, parsk);
                m_innerTransBegin :
                    a52InnerTransaction (acv, cak_x_inner_trans_begin);
                m_innerTransCommit :
                    a52InnerTransaction (acv, cak_x_inner_trans_commit);
                m_innerTransRollback :
                    a52InnerTransaction (acv, cak_x_inner_trans_rollback);
                m_check_database :
                    BEGIN
                    a42_check_database (acv);
                    acv.a_return_segm^.sp1r_function_code := csp1_select_fc;
                    END;
                m_create_table :
                    a92parse_again (acv, acv.a_statement_parsid, false); (* PTS 1106286 *)
                (* CR 1000134 E.Z. *)
                m_destroy_temp :
                    bd91StartOMSGarbageCollection (acv.a_transinf.tri_trans);
                (* PTS 1102256 E.Z. *)
                (* PTS 1110053 E.Z. *)
                m_flush :
                    BEGIN
                    a505next_command (acv, dmli.d_sparr, parsk, 0);
                    IF  acv.a_returncode = 0
                    THEN
                        BEGIN
                        acv.a_transinf.tri_trans.trError_gg00 := e_ok;
                        kb560StartSavepointAndWait (acv.a_transinf.tri_trans, mm_user);
                        IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
                        THEN
                            a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                m_set :
                    a51set_degree (acv);
                m_set_replication :
                    a51SetSessionReplicationProlog (acv);
                m_stamp :
                    BEGIN
                    a505next_command (acv, dmli.d_sparr, parsk, 0);
                    IF  acv.a_returncode = 0
                    THEN
                        BEGIN
                        _defined_byte := csp_defined_byte;
                        a05_stamp_get (acv, _next_stamp, 1, sizeof (_next_stamp));
                        a06retpart_move (acv, @_defined_byte, 1);
                        a06retpart_move (acv, @_next_stamp,
                              sizeof (_next_stamp));
                        a06finish_curr_retpart (acv, sp1pk_data, 1)
                        END
                    (*ENDIF*) 
                    END;
                m_union :
                    BEGIN
                    a52internal_subtrans (acv);
                    a503union_execution (acv, dmli, change_rec, parsk,
                          output_during_execution)
                    END;
                m_complex :
                    BEGIN
                    a52internal_subtrans (acv);
                    a502complex_execution (acv, dmli, change_rec, parsk,
                          output_during_execution)
                    END;
                m_debug, m_get_object :
                    a262Debug (acv, parsk.p_kind = m_debug);
                OTHERWISE
                    BEGIN
                    _erec.ex_plus := 0;
                    a505next_command (acv, dmli.d_sparr, parsk, _erec.ex_plus);
                    IF  acv.a_returncode = 0
                    THEN
                        BEGIN
                        CASE parsk.p_kind OF
                            m_close :
                                BEGIN
                                a52internal_subtrans (acv);
                                WITH dmli.d_sparr.px[ 1 ]^.sparsinfo DO
                                    a73_close_execute (acv, dmli.d_sparr,
                                          p_resn, p_modul_name);
                                (*ENDWITH*) 
                                END;
                            m_describe :
                                WITH dmli.d_sparr.px[ 1 ]^.sparsinfo DO
                                    a73_describe_execute (acv, dmli.d_sparr,
                                          p_resn, p_modul_name);
                                (*ENDWITH*) 
                            m_fetch :
                                ak501fetch_execute (acv, dmli.d_sparr);
                            m_mfetch :
                                ak501mfetch_execute (acv, dmli.d_sparr);
                            (* PTS 1120287 E.Z. *)
                            m_insert, m_insert_select,
                            m_select, m_select_row,
                            m_update, m_delete :
                                BEGIN
                                IF  NOT acv.a_stored_proc_call
                                THEN
                                    a52internal_subtrans (acv);
                                (*ENDIF*) 
                                _erec.ex_command_needed := false;
                                _erec.ex_plus := _erec.ex_plus - 1;
                                a505loop_most_execute (acv, dmli,
                                      change_rec, _erec, parsk,
                                      _dummybuf, _dummyser,
                                      _cinfo, _old_cinfo,
                                      NOT c_inner_loop);
                                END;
                            m_key :
                                BEGIN
                                a52internal_subtrans (acv);
                                ak501key_execute (acv, dmli, change_rec,
                                      parsk, _cinfo, _old_cinfo, _erec)
                                END;
                            OTHERWISE
                                BEGIN
                                a52internal_subtrans (acv);
                                a505most_execute (acv, dmli,
                                      change_rec, parsk, _erec, _cinfo,
                                      _old_cinfo, _dummybuf,
                                      NOT c_inner_loop);
                                END
                            END;
                        (*ENDCASE*) 
                        END
                    (*ENDIF*) 
                    END
                END;
            (*ENDCASE*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  acv.a_returncode <> 0 (* PTS 1112612 *)
    THEN
        IF  acv.a_returncode = cak_e_dbproc_call
        THEN
            acv.a_returncode := 0
        ELSE
            IF  _erec.ex_mb_data <> NIL
            THEN
                BEGIN
                _p := @_erec.ex_mb_data^;
                gg941Deallocate (acv.a_transinf.tri_trans, _p);
                acv.a_mblock.mb_data      := acv.a_mb_data_addr;
                acv.a_mblock.mb_data_size := acv.a_mb_data_size
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a501do_execute (
            VAR acv                 : tak_all_command_glob;
            VAR dmli                : tak_dml_info;
            VAR parsk               : tak_parskey;
            output_during_execution : boolean);
 
VAR
      _change_rec : tak_changerecord;
 
BEGIN
_change_rec.cr_colcount := 0;
_change_rec.cr_was_opt  := false;
acv.a_union_cnt        := 0;
acv.a_command_kind     := single_command;
acv.a_input_data_pos   := 1;
a501exec_with_change_rec (acv, dmli, parsk, _change_rec, output_during_execution);
acv.a_command_kind     := single_command;
END;
 
(* PTS 1114109, T.A. *)
(*------------------------------*) 
 
PROCEDURE
      a501GetResultName (
            VAR acv : tak_all_command_glob;
            VAR resultName : tsp00_KnlIdentifier);
 
VAR
      _movelen    : integer;
      _err_char_no: tsp00_Int4;
      _uni_err    : tsp8_uni_error;
 
BEGIN
WITH acv.a_resname_part^ DO
    IF  sp1p_buf_len = 0
    THEN
        resultName := a01_i_syscursorname
    ELSE
        BEGIN
        resultName := a01_il_b_identifier;
        IF  g01unicode
        THEN
            BEGIN
            _movelen := sizeof (resultName);
            s80uni_trans (@sp1p_buf[ 1 ], sp1p_buf_len,
                  acv.a_initial_packet_header.sp1h_mess_code,  (* PTS 1119568 E.Z. *)
                  @resultName, _movelen, csp_unicode, [ ],
                  _uni_err, _err_char_no);
            IF  (_uni_err <> uni_ok) AND
                (_uni_err <> uni_dest_too_short)
            THEN
                a07_b_put_error (acv, e_invalid_tablename, 1)
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            IF  (acv.a_comp_type = at_unknown)
            THEN
                a92_map_into_upper (acv, sp1p_buf, 1,
                      sp1p_buf_len, NOT c_uni_map);
            (*ENDIF*) 
            IF  sp1p_buf_len > a01identifier_size
            THEN
                _movelen := a01identifier_size
            ELSE
                _movelen := sp1p_buf_len;
            (*ENDIF*) 
            SAPDB_PascalMove ('VAK501',   1,    
                  sp1p_buf_size, sizeof (resultName),
                  @sp1p_buf, 1, @resultName, 1, _movelen,
                  acv.a_returncode)
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a501get_resname (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info);
 
BEGIN
dmli.d_resname_found := true;
(* PTS 1114109, T.A. *)
a501GetResultName (acv, dmli.d_resname)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a501execute (
            VAR acv    : tak_all_command_glob;
            VAR parsid : tak_parsid);
 
VAR
      _i                  : integer;
      _appl_info          : integer;
      _aux_return         : tsp00_Int2;
      _aux_errorpos       : tsp00_Int4;
      _pp                 : tak_parsid;
      _fs_tree            : tgg00_FileId;
      _dmli               : tak_dml_info;
      _change_rec         : tak_changerecord;
      _cmdid              : tgg00_Surrogate;
      _reset_running_cmds : boolean;
 
BEGIN
_reset_running_cmds := g01diag_moni_parse_on;
IF  _reset_running_cmds
THEN
    a42put_running_cmds(acv, parsid);
(*ENDIF*) 
a01_init_command (acv);
acv.a_part_rollback  := false;
acv.a_rowno_allowed  := true;
acv.a_union_cnt      := 0;
acv.a_input_data_pos := 1;
acv.a_recursive_state := rs_no_recursive_select;
(* There are two or three parts in a cmd segment:             *)
(* 1.: sp1pk_parseid                                          *)
(* 2.: sp1pk_data                                             *)
(* 3.: sp1pk_resulttablename (optional; note that there is    *)
(*                            no! map into upper name         *)
(*                            (exclusive for 3.1.2. Programs) *)
(*                            because of special identifier)  *)
IF  (acv.a_curr_user_name = a01_il_b_identifier) AND NOT (acv.a_in_ddl_trigger)
THEN
    a07_b_put_error (acv, e_user_not_connected, 1)
ELSE
    BEGIN
    a54_dml_init (acv, _dmli, NOT c_in_union);
    _dmli.d_initial_ex_parskey := parsid.pid_parsk;
    IF  acv.a_resname_part <> NIL
    THEN
        a501get_resname (acv, _dmli);
    (*ENDIF*) 
    IF  (parsid.pid_dtime_info[ 1 ] <> chr(ord(dtf_none))) AND
        (parsid.pid_dtime_info[ 1 ] <> chr(ord(acv.a_dt_format)))
    THEN
        a07_b_put_error (acv, e_old_fileversion, 1)
    ELSE
        BEGIN
        acv.a_precomp_info_byte := ord (acv.a_statement_parsid.pid_appl_info[ 1 ]);
        IF  acv.a_precomp_info_byte >= csp1_p_mass_command
        THEN
            _appl_info := acv.a_precomp_info_byte - csp1_p_mass_command
        ELSE
            _appl_info := acv.a_precomp_info_byte;
        (*ENDIF*) 
        IF  a01diag_monitor_on OR a01diag_analyze_on
        THEN
            BEGIN
            b21m_parse_again (acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                  _pp.pid_parsk.p_count);
            IF  acv.a_statement_parsid.pid_parsk.p_count < _pp.pid_parsk.p_count
            THEN
                (* parsid was parsed before sys_monitor was installed   *)
                (* therefore the command was NOT stored in parseid-file *)
                (* therefore we have to parse again (see vak92)         *)
                a07_b_put_error (acv, e_old_parsid, 1)
            ELSE
                IF  ( _appl_info <> csp1_p_fetch_found ) AND
                    ( _appl_info <> csp1_p_describe_found )
                THEN
                    BEGIN
                    b21m_parseid (acv.a_transinf.tri_trans.trBdTcachePtr_gg00, _pp, _pp);
                    IF  (_pp.pid_session.ci4_gg00 <> '    ') AND
                        (ord(_pp.pid_parsk.p_kind) <> ord(bsp_c1))
                        (* not counted values stored in b21 *)
                    THEN
                        a545sm_insert(acv);
                    (*ENDIF*) 
                    IF  (_appl_info <> csp1_p_dialog_call)
                    THEN
                        BEGIN
                        b21m_reset_monitor (acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                              c_reset_sum);
                        b21mp_parseid_put (acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                              acv.a_statement_parsid, parsid);
                        a544get_cmdid (acv, parsid.pid_parsk, _cmdid);
                        b21mp_cmdid_put (acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                              _cmdid);
                        IF  acv.a_data_length > 0
                        THEN
                            b21mp_value_put (acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                                  acv.a_data_ptr, acv.a_data_length);
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            IF  acv.a_precomp_info_byte >= csp1_p_mass_command
            THEN
                ak501mass_do_execute (acv, _dmli,
                      parsid.pid_parsk, _change_rec,
                      (acv.a_precomp_info_byte >= csp1_p_mselect_found))
            ELSE
                BEGIN
                (* PTS 1114426 E.Z.*)
                acv.a_mass_all_rescount := 0;
                IF  _appl_info = csp1_p_fetch_found
                THEN
                    BEGIN
                    IF  parsid.pid_parsk.p_kind = m_mfetch
                    THEN (* precompiler changed it PREPARE MFETCH --> EXECUTE FETCH *)
                        parsid.pid_parsk.p_kind := m_fetch;
                    (*ENDIF*) 
                    END
                ELSE
                    IF  _appl_info = csp1_p_dialog_call
                    THEN (* Stored Procedure execute, call in VAK93 *)
                        acv.a_stored_proc_call := true;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  acv.a_variable_input
                THEN
                    BEGIN
                    acv.a_input_data_pos := acv.a_data_length;
                    IF  NOT a509build_map_from_databuffer (acv.a_data_ptr,
                        acv.a_input_data_map, acv.a_input_data_pos)
                    THEN
                        BEGIN
                        g01opmsg (sp3p_console, sp3m_error,
                              csp3_a92_incorrect_partbuf_len,
                              csp3_n_order, 'PART KIND VARDATA       ', 1);
                        a07_b_put_error (acv, e_invalid_segment_construction, 21);
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  acv.a_returncode = 0
                THEN
                    a501exec_with_change_rec (acv, _dmli,
                          parsid.pid_parsk, _change_rec,
                          c_output_during_execution)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  a01diag_monitor_on OR a01diag_analyze_on
        THEN
            BEGIN
            IF  ((_appl_info = csp1_p_mass_select_found)        OR
                ( _appl_info = csp1_p_select_for_update_found))
            THEN
                b21mp_is_select (
                      acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                      c_is_select)
            ELSE
                IF  (acv.a_returncode <>
                    a071_return_code (e_old_fileversion, acv.a_sqlmode)) AND
                    (_appl_info <> csp1_p_fetch_found)
                    OR
                    (acv.a_returncode =
                    a071_return_code (e_row_not_found, acv.a_sqlmode))
                THEN
                    BEGIN
                    b21m_parseid (acv.a_transinf.tri_trans.trBdTcachePtr_gg00, _pp, _pp);
                    IF  (_pp.pid_session.ci4_gg00 <> '    ') AND
                        (ord(_pp.pid_parsk.p_kind) <> ord(bsp_c1))
                        (* not counted values stored in b21 *)
                    THEN
                        a545sm_insert(acv);
                    (*ENDIF*) 
                    b21m_reset_monitor (
                          acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                          c_reset_sum)
                    END
                (*ENDIF*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    a54_dml_finalize( _dmli, acv.a_transinf.tri_trans );
    END;
(*ENDIF*) 
IF  acv.a_returncode <> 0
THEN
    IF  acv.a_returncode <>
        a071_return_code (e_row_not_found, acv.a_sqlmode)
    THEN
        acv.a_part_rollback := acv.a_part_rollback OR
              (acv.a_long_desc_pos = 0);
    (*ENDIF*) 
(*ENDIF*) 
IF  acv.a_from_select
THEN
    BEGIN
    g04build_temp_tree_id (_fs_tree, acv.a_transinf.tri_trans);
    (* PTS 1111510 E.Z. *)
    a661_build_t_fromsel_tableid (_cmdid, _fs_tree.fileTabId_gg00,
          acv.a_curr_ex_parskey, cak_fromseltab_site, 0);
    a101_SetTempFileLevel (acv, _fs_tree, 0);
    _aux_return   := acv.a_returncode;
    _aux_errorpos := acv.a_errorpos;
    acv.a_returncode := 0;
    _fs_tree.fileZeroSite_gg00 := 0; (* FIXME: can be removed once file dir is active *)
    a101_DestroyGroupedTempFiles (acv.a_transinf.tri_trans,
          ttfnFromSelect_egg00,
          -1,
          -1,
          _fs_tree.fileName_gg00);
    acv.a_returncode := _aux_return;
    acv.a_errorpos   := _aux_errorpos;
    END;
(*ENDIF*) 
IF  _reset_running_cmds
THEN
    a42reset_running_cmds(acv);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak501fetch_execute (
            VAR acv   : tak_all_command_glob;
            VAR sparr : tak_syspointerarr);
 
VAR
      _position      : tsp00_Int4;
      _fill_ret_segm : boolean;
      _sel_parsid    : tak_parsid;
      _mtype         : tgg00_MessType2;

 
BEGIN
ak501fetch_part (acv, sparr, _position, _mtype, _fill_ret_segm, _sel_parsid);
IF  acv.a_returncode = 0
THEN
    BEGIN
    WITH sparr.px[ 1 ]^.sparsinfo DO
        IF  sparr.px[ 2 ]^.sreskey.res_build
        THEN
            BEGIN
            IF  a101_IsExtendedTempFile (acv,
                sparr.px[ 2 ]^.sreskey.res_restree)
            THEN
                a101_GetTempFileInstance (
                      acv.a_transinf.tri_trans,
                      sparr.px[ 2 ]^.sreskey.res_restree);
            (*ENDIF*) 
            a73_one_fetch (acv, sparr, _mtype, _position);
            END
        ELSE
            (* PTS 1111576 E.Z. *)
            a74_search_fetch (acv, sparr, _mtype, _position,
                  acv.a_resname_addr[ cak_extern_pos ],
                  c_single_fetch, 0);
        (*ENDIF*) 
    (*ENDWITH*) 
    ak501fetch_rest (acv, sparr, c_single, _fill_ret_segm, _sel_parsid)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak501fetch_part (
            VAR acv           : tak_all_command_glob;
            VAR sparr         : tak_syspointerarr;
            VAR position      : tsp00_Int4;
            VAR mtype         : tgg00_MessType2;
            VAR fill_ret_segm : boolean;
            VAR sel_parsid    : tak_parsid);
 
VAR
      _e             : tgg00_BasisError;
      _res           : tsp00_NumError;
      _func_code     : integer;
      _p             : tak_parskey;
      _pp            : tak_parsid;
      _ke            : tgg00_SysInfoKey;
      _cmdid         : tgg00_Surrogate;
      _value_ptr     : tsp00_MoveObjPtr;
      _value_len     : tsp00_Int4;
      _is_null       : boolean;
      _is_default    : boolean;
 
BEGIN
_func_code := csp1_nil_fc;
IF  acv.a_statement_kind = isql_commands
THEN
    acv.a_statement_kind := iselects;
(*ENDIF*) 
WITH sparr.px[ 1 ]^.sparsinfo DO
    a663_resname (acv, p_resn, p_modul_name,
          acv.a_resname_addr[ cak_extern_pos ], d_fix, 1);
(*ENDWITH*) 
&ifdef TRACE
t01int4 (ak_sem, 'returncode  ', acv.a_returncode);
&endif
IF  acv.a_returncode = 0
THEN
    BEGIN
    WITH acv.a_resname_addr[ cak_extern_pos ]^.sresname DO
        IF  resselect_fetch = sft_select_all_results
        THEN
            a07_b_put_error (acv, e_invalid_command, 1)
        ELSE
            BEGIN
            fill_ret_segm := true;
            WITH sparr.px[ 1 ]^.sparsinfo DO
                BEGIN
                acv.a_return_segm^.sp1r_function_code := p_function_code;
                IF  p_function_code > csp1_min_masscmd_fc
                THEN
                    _func_code := p_function_code - csp1_min_masscmd_fc
                ELSE
                    _func_code := p_function_code;
                (*ENDIF*) 
                IF  (_func_code <> csp1_fetch_relative_fc) AND
                    ((_func_code < csp1_fetch_first_fc) OR
                    ( _func_code > csp1_fetch_same_fc))
                THEN (* where pos of *)
                    fill_ret_segm := false;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
            IF  ((_func_code <> csp1_fetch_next_fc) AND
                NOT resscrollable)
            THEN
                a07_b_put_error (acv, e_scrolling_fetch_not_allowed, 1)
            ELSE
                IF  reseparsk.p_kind <> m_nil
                THEN
                    BEGIN
                    (* SELECT was parsed *)
                    SAPDB_PascalForcedMove (sizeof(sparr.px[1]^.sparsinfo.p_pars_infos[1]),
                          sizeof(_p), @sparr.px[1]^.sparsinfo.p_pars_infos[1],
                          sizeof(tsp00_C4)+1, @_p, 1, mxak_parskey);
&                   ifdef TRACE
                    t01buf (ak_sem, reseparsk, 1, sizeof(reseparsk));
                    t01buf (ak_sem, _p, 1, sizeof(_p));
&                   endif
                    IF  ((reseparsk.p_count  <> _p.p_count)   OR
                        (reseparsk.p_id[ 1 ] <> _p.p_id[ 1 ]) OR
                        (reseparsk.p_kind    <> _p.p_kind)    OR
                        (reseparsk.p_no      <> _p.p_no))
                    THEN
                        a07_b_put_error (acv, e_old_fileversion, 1)
                    ELSE
                        BEGIN
                        IF  a01diag_monitor_on OR a01diag_analyze_on
                        THEN
                            BEGIN
                            b21m_parseid (acv.a_transinf.tri_trans.trBdTcachePtr_gg00, _pp, _pp);
                            IF  ((_pp.pid_parsk.p_count  <> reseparsk.p_count)   OR
                                (_pp.pid_parsk.p_id[ 1 ] <> reseparsk.p_id[ 1 ]) OR
                                (_pp.pid_parsk.p_kind    <> reseparsk.p_kind)    OR
                                (_pp.pid_parsk.p_no      <> reseparsk.p_no))
                            THEN
                                BEGIN
                                (* other FETCH than that belonging to last executed SELECT *)
                                IF  (_pp.pid_session.ci4_gg00 <> '    ') AND
                                    (ord(_pp.pid_parsk.p_kind) <> ord(bsp_c1))
                                    (* not counted values stored in b21 *)
                                THEN
                                    a545sm_insert(acv);
                                (*ENDIF*) 
                                b21m_reset_monitor (acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                                      c_reset_sum);
                                _pp.pid_parsk := reseparsk;
                                (* try to build real SELECT parsid this FETCH belongs to *)
                                b21mp_parseid_put (acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                                      _pp, _pp);
                                a544get_cmdid (acv, reseparsk, _cmdid);
                                b21mp_cmdid_put (acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                                      _cmdid);
                                END;
                            (*ENDIF*) 
                            b21mp_fetch_calls_put (acv.a_transinf.tri_trans.trBdTcachePtr_gg00)
                            END;
                        (*ENDIF*) 
                        IF  fill_ret_segm
                        THEN
                            SAPDB_PascalForcedMove (sizeof(sparr.px[1]^.sparsinfo.p_pars_infos[1]),
                                  sizeof(sel_parsid), @sparr.px[1]^.sparsinfo.p_pars_infos[1],
                                  1, @sel_parsid, 1, sizeof(sel_parsid));
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END
                ELSE
                    IF  fill_ret_segm
                    THEN
                        SAPDB_PascalForcedFill (sizeof(sel_parsid), @sel_parsid, 1,
                              sizeof(sel_parsid), chr(0));
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
    (*ENDWITH*) 
    END;
&ifdef TRACE
(*ENDIF*) 
t01int4 (ak_sem, 'nach kritisc', 1);
&endif
IF  acv.a_returncode = 0
THEN
    BEGIN
    _ke := a01sysnullkey;
    WITH _ke DO
        BEGIN
        stempid   := a101_GetTempFileIndex (acv,
              acv.a_resname_addr[ cak_extern_pos ]^.sresname.restreeid);
        sentrytyp := cak_ereskey;
        END;
    (*ENDWITH*) 
    a10get_sysinfo (acv, _ke, d_fix, sparr.px[ 2 ], _e);
    IF  _e <> e_ok
    THEN
        a07_b_put_error (acv, _e, 1)
    ELSE
        WITH sparr.px[ 2 ]^.sreskey DO
            BEGIN
            WITH sparr.px[ 1 ]^.sparsinfo DO
                BEGIN
                position := p_posno;
                mtype    := p_mtyp2;
                IF  (res_limit_offset <> cgg04_no_rowno_predicate) AND
                    ((_func_code in [csp1_fetch_last_fc,
                    csp1_fetch_prev_fc, csp1_fetch_relative_fc]) OR
                    ((_func_code = csp1_fetch_pos_fc) AND (position < 0)))
                THEN
                    a07_b_put_error (acv, e_scrolling_fetch_not_allowed, 1)
                ELSE
                    IF  position = csp_maxint2
                    THEN
                        (* PTS 1103929 E.Z. *)
                        IF  acv.a_data_ptr = NIL
                        THEN
                            a07_b_put_error (acv,
                                  e_num_invalid, 1)
                        ELSE
                            BEGIN
                            IF  acv.a_variable_input
                            THEN
                                BEGIN
                                IF  NOT a509get_one_value (acv.a_input_data_map, p_p_no,
                                    _value_ptr, _value_len, _is_null, _is_default)
                                THEN
                                    BEGIN
                                    a07ak_system_error (acv, 501, 1);
                                    _res := num_invalid;
                                    END
                                ELSE
                                    s40glint (_value_ptr^, 1, _value_len, position, _res)
                                (*ENDIF*) 
                                END
                            ELSE
                                s40g4int (acv.a_data_ptr^, p_p_no+1, position, _res);
                            (*ENDIF*) 
                            IF  _res <> num_ok
                            THEN
                                CASE _res OF
                                    num_invalid :
                                        a07_b_put_error (acv,
                                              e_num_invalid, 1);
                                    num_trunc :
                                        a07_b_put_error (acv,
                                              e_num_truncated, 1);
                                    num_overflow :
                                        a07_b_put_error (acv,
                                              e_num_overflow, 1);
                                    END
                                (*ENDCASE*) 
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  (res_limit_offset <> cgg04_no_rowno_predicate)
                THEN
                    IF  (mtype = mm_first) OR
                        ((mtype = mm_next) AND res_bof)
                    THEN
                        BEGIN
                        mtype  := mm_direct;
                        position := succ(res_limit_offset);
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            (*ENDWITH*) 
            END
        (*ENDWITH*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak501fetch_rest (
            VAR acv        : tak_all_command_glob;
            VAR sparr      : tak_syspointerarr;
            single         : boolean;
            fill_ret_segm  : boolean;
            VAR sel_parsid : tak_parsid);
 
VAR
      _e       : tgg00_BasisError;
      _merror  : tsp00_Int4;
      _mreturn : integer;
      _part_ptr: tsp1_part_ptr;
      _deleted : boolean;
 
BEGIN
IF  a01diag_monitor_on OR a01diag_analyze_on
THEN
    b21mp_rows_fetched_put (acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
          sparr.px[ 2 ]^.sreskey.res_nextpos);
(*ENDIF*) 
_mreturn     := acv.a_returncode;
_merror      := acv.a_errorpos;
_deleted     := false;
acv.a_returncode := 0;
IF  (acv.a_sqlmode = sqlm_oracle)
    OR
    ((NOT acv.a_resname_addr[ cak_extern_pos ]^.sresname.resscrollable) AND
    NOT (acv.a_resname_addr[ cak_extern_pos ]^.sresname.resparsinfobyte in
    [csp1_p_reuse_mass_select_found,
    csp1_p_reuse_update_sel_found,
    csp1_p_reuse_mselect_found,
    csp1_p_reuse_upd_mselect_found]))
THEN
    BEGIN
    IF  _mreturn = a071_return_code (e_row_not_found, acv.a_sqlmode)
    THEN
        BEGIN
        a663_del_result (acv, acv.a_resname_addr[ cak_extern_pos ]^.sresname,
              c_do_cdel, c_del_resname_rec);
        acv.a_resname_addr[ cak_extern_pos ] := NIL;
        acv.a_intern_warnings :=
              acv.a_intern_warnings + [sp1iw_warn0_resultset_closed];
        _deleted := true;
        END
    ELSE
        IF  (NOT single)
            (* PTS 1116801 E.Z. *)
        THEN
            WITH acv DO
                BEGIN
                s26find_part (a_return_segm^, sp1pk_data, _part_ptr);
                IF  _part_ptr <> NIL
                THEN
                    IF  sp1pa_last_packet in _part_ptr^.sp1p_attributes
                    THEN
                        BEGIN
                        a663_del_result (acv,
                              acv.a_resname_addr[ cak_extern_pos ]^.sresname,
                              c_do_cdel, c_del_resname_rec);
                        acv.a_resname_addr[ cak_extern_pos ] := NIL;
                        acv.a_intern_warnings :=
                              acv.a_intern_warnings + [sp1iw_warn0_resultset_closed];
                        _deleted := true;
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  NOT _deleted
THEN
    BEGIN
    a10repl_sysinfo (acv, sparr.px[ 2 ], _e);
    IF  _e <> e_ok
    THEN
        a07_b_put_error (acv, _e, 1)
    ELSE
        acv.a_resname_addr[cak_extern_pos] := NIL;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  _mreturn <> 0
THEN
    BEGIN
    acv.a_returncode := _mreturn;
    acv.a_errorpos   := _merror
    END;
(*ENDIF*) 
IF  fill_ret_segm AND
    (acv.a_returncode = 0)
THEN
    BEGIN
    a06retpart_move (acv, @sel_parsid, mxak_parsid);
    a06finish_curr_retpart (acv, sp1pk_parsid_of_select, 1)
    END
(*ENDIF*) 
END;
 
(* PTS 1102256 E.Z. *)
(* PTS 1110053 E.Z. *)
(* PTS 1110021 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak501key_execute (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            VAR change_rec : tak_changerecord;
            VAR parsk      : tak_parskey;
            VAR cinfo      : tak_corr_infos;
            VAR old_cinfo  : tak_corr_infos;
            VAR erec       : tak_exec_rec);
 
VAR
      _e             : tgg00_BasisError;
      _old_erec      : tak_exec_rec;
      _frec          : tak_fill_rec;
      _i             : integer;
      _length        : integer;
      _series        : tak68_sequence;
      _viewkeybuf    : tak_sysbufferaddress;
      _ke            : tgg00_SysInfoKey;
      _result_buffer : tsp00_Buf;
      _pmbp          : tgg00_MessBlockPtr;
      _pdbp          : tgg00_DataPartPtr;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    erec.ex_updjv_ptr := @_result_buffer;
    IF  acv.a_qualified_jv_upd <> no_jv_upd
    THEN
        SAPDB_PascalMove ('VAK501',   2,    
              acv.a_mblock.mb_data_size, sizeof(_result_buffer),
              @acv.a_mblock.mb_data^.mbp_buf, 1, @_result_buffer, 1,
              acv.a_mblock.mb_data_len, acv.a_returncode);
    (*ENDIF*) 
    FOR _i := 1 TO cak00_maxsources DO
        BEGIN
        _series[ _i ].jos_joinstrat     := strat_join_viewkey;
        _series[ _i ].jos_source        := _i;
        _series[ _i ].jos_joinno        := IS_UNDEFINED_GG07;
        _series[ _i ].jos_predefined_buf:= false;
        _series[ _i ].jos_table_buffer  := 0;
        _series[ _i ].jos_expected_recs := 1;
        _series[ _i ].jos_invlen        := IS_UNDEFINED_GG07;
        _series[ _i ].jos_access_mod    := [];
        _series[ _i ].jos_expected_table_rec_reads := 0;
        END;
    (*ENDFOR*) 
    _series[ 1 ].jos_joinstrat := strat_viewkey;
    _viewkeybuf       := NIL;
    _ke               := dmli.d_sparr.px[ 1 ]^.syskey;
    _ke.sentrytyp     := cak_eviewkey;
    _ke.slinkage[ 2 ] := chr(1);
    a10_nil_get_sysinfo (acv, _ke, d_fix, cak_sysbufferoffset +
          4 + KEY_MXSP00, _viewkeybuf, _e);
    IF  _e <> e_ok
    THEN
        a07_b_put_error (acv, _e, 1)
    ELSE
        BEGIN
        erec.ex_with_link           := false;
        _old_erec               := erec;
        dmli.d_pos_in_parsbuf  := 1;
        change_rec.cr_colcount := 0;
        _frec.fr_f_no                      := 1;
        a505fill_mess_buf (acv, dmli, erec, _frec, NOT c_full_part2);
        _frec.fr_last_fno := dmli.d_sparr.px[ 1 ]^.sparsinfo.p_cnt_infos;
        a506fieldvalues (acv, dmli, _frec, _viewkeybuf,
              acv.a_mblock.mb_data^.mbp_buf, acv.a_mblock.mb_data_size (* PTS 1115085 *));
        IF  acv.a_returncode = 0
        THEN
            WITH acv.a_mblock, mb_data^ DO
                BEGIN
                _pmbp := @dmli.d_sparr.px[ dmli.d_sparr.pcount ]^.
                      smessblock.mbr_mess_block;
                _pdbp := _pmbp^.mb_data;
&               IFDEF TRACE
                t01int4 (ak_sem, 'pos_in_parsb', dmli.d_pos_in_parsbuf);
                t01int4 (ak_sem, 'len         ', mb_data_len);
                t01int4 (ak_sem, 'keylen      ', mbp_keylen);
&               ENDIF
                IF  _pmbp^.mb_data_len > dmli.d_pos_in_parsbuf
                THEN
                    BEGIN
                    _length := _pmbp^.mb_data_len - dmli.d_pos_in_parsbuf + 1;
&                   IFDEF TRACE
                    t01int4 (ak_sem, 'pos_in_parsb', dmli.d_pos_in_parsbuf);
                    t01int4 (ak_sem, 'length      ', _length);
                    t01int4 (ak_sem, 'len         ', mb_data_len);
                    t01int4 (ak_sem, 'keylen      ', mbp_keylen);
&                   ENDIF
                    SAPDB_PascalMove ('VAK501',   3,    
                          _pmbp^.mb_data_size, acv.a_mblock.mb_data_size,
                          @_pdbp^.mbp_buf, dmli.d_pos_in_parsbuf,
                          @acv.a_mblock.mb_data^.mbp_buf, mb_data_len+1,
                          _length, acv.a_returncode);
                    mb_data_len := mb_data_len + _length;
                    dmli.d_pos_in_parsbuf := dmli.d_pos_in_parsbuf +
                          _length;
                    END
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            WITH _viewkeybuf^.sviewkey DO
                BEGIN
                vkjvkeylen := acv.a_mblock.mb_data_len-cgg_rec_key_offset;
                SAPDB_PascalMove ('VAK501',   4,    
                      acv.a_mblock.mb_data_size, sizeof(vkjvkey),
                      @acv.a_mblock.mb_data^.mbp_buf, cgg_rec_key_offset + 1,
                      @vkjvkey, 1, acv.a_mblock.mb_data_len,
                      acv.a_returncode);
                END;
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
        a06drop_fieldlist_references (acv.a_mblock.mb_fieldlists);
        erec := _old_erec;
        a505loop_most_execute (acv, dmli, change_rec, erec, parsk,
              _viewkeybuf, _series, cinfo, old_cinfo,
              NOT c_inner_loop);
        IF  (acv.a_returncode = 0) AND
            (acv.a_qualified_jv_upd = no_jv_upd)
        THEN
            a60rescount (acv, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  _viewkeybuf <> NIL
    THEN
        a10key_del (acv, _viewkeybuf)
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak501mass_do_execute (
            VAR acv                 : tak_all_command_glob;
            VAR dmli                : tak_dml_info;
            VAR parsk               : tak_parskey;
            VAR change_rec          : tak_changerecord;
            is_mass_select          : boolean);
 
VAR
      _e                  : tgg00_BasisError;
      _last_data_packets  : boolean;
      _first_data_packets : boolean;
      _cmd_count          : tsp00_Int2;
      _command_no         : integer;
      _longdescpos        : integer;
      _cnt                : integer;
      _max_res_id         : tsp00_Int4;
      _save_input_pos     : tsp00_Int4;
      _max_trigger_res_id : tsp00_Int4;
      _save_all_rescnt    : tsp00_Int4;
      _part_desc_ptr      : tsp1_part_ptr;
      _one_rescount       : tsp00_Int4;
      _num_err            : tsp00_NumError;
      _m_parsk            : tak_parskey;
      _aux_data_length    : tsp00_Int4;
      _oldp               : tak_sysbufferaddress;
      _ke1                : tgg00_SysInfoKey;
      _p                  : tsp00_Addr;
      _planHandle         : tgg00_VoidPtr;
 
BEGIN
(* d_mselect_loop_cnt = cgg04_first_and_only_of_all  ==> 1. + only data-packet            *)
(* d_mselect_loop_cnt = cgg04_first_and_only_of_this ==> 1. + only data-packet of this msg*)
(* d_mselect_loop_cnt = cgg04_first_of_all           ==> 1.        data-packet            *)
(* d_mselect_loop_cnt = cgg04_last_of_all            ==> last data-packet                 *)
(* d_mselect_loop_cnt = cgg04_last_of_this           ==> last data-packet of this message *)
(* d_mselect_loop_cnt > cgg04_last_of_this           ==> any other data-packet            *)
IF  (acv.a_data_part = NIL) OR (acv.a_rescount_part = NIL)
THEN
    a07_b_put_error (acv, e_too_short_datapart, 1)
ELSE
    IF  (acv.a_rescount_part^.sp1p_buf_len < mxsp_resnum)
    THEN
        a07_b_put_error (acv, e_too_short_datapart, 1)
    ELSE
        BEGIN
        (* h.b. CR 1000072 *)
        _cmd_count         := acv.a_data_part^.sp1p_arg_count;
        _last_data_packets :=
              (sp1pa_last_packet in acv.a_data_part^.sp1p_attributes);
        _first_data_packets :=
              ((acv.a_comp_vers >= '62090') AND
              (sp1pa_first_packet in acv.a_data_part^.sp1p_attributes))
              OR
              ((acv.a_comp_vers < '62090') AND
              (acv.a_rescount_part^.sp1p_buf [ 1 ]  = csp_undef_byte));
        IF  _first_data_packets
        THEN
            BEGIN
            dmli.d_repl_reskey  := false;
            acv.a_mass_all_rescount := 0;
            END
        ELSE
            BEGIN
            dmli.d_repl_reskey  := true;
            dmli.d_mselect_rescnt := acv.a_mass_all_rescount;
            END;
        (*ENDIF*) 
        _command_no        := 0;
        IF  _cmd_count = 0
        THEN
            IF  _last_data_packets
            THEN
                BEGIN
                IF  (acv.a_precomp_info_byte in [
                    csp1_p_mselect_found,
                    csp1_p_for_upd_mselect_found,
                    csp1_p_reuse_mselect_found,
                    csp1_p_reuse_upd_mselect_found])
                    AND
                    (acv.a_mass_all_rescount <> 0)
                THEN
                    BEGIN
                    _ke1 := a01sysnullkey;
                    _ke1.stempid := a101_GetTempFileIndex (acv,
                          acv.a_resname_addr[ cak_extern_pos ]^.sresname
                          .restreeid);
                    _ke1.sentrytyp := cak_ereskey;
                    a10get_sysinfo (acv, _ke1, d_fix, _oldp, _e);
                    IF  _e <> e_ok
                    THEN
                        a07_b_put_error (acv, _e, 1);
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            ELSE
                a07_b_put_error (acv, e_too_short_datapart, 1)
            (*ENDIF*) 
        ELSE
            BEGIN
            acv.a_input_data_pos        := 1;
            (* PTS 1001078 E.Z. *)
            IF  acv.a_data_length = 0
            THEN
                _cmd_count := 1;
            (*ENDIF*) 
            _m_parsk                 := parsk;
            dmli.d_mselect_loop_cnt := cgg04_first_of_all;
            IF  _cmd_count = 1
            THEN
                IF  _last_data_packets
                THEN
                    IF  NOT dmli.d_repl_reskey
                    THEN
                        dmli.d_mselect_loop_cnt := cgg04_first_and_only_of_all
                    ELSE
                        dmli.d_mselect_loop_cnt := cgg04_last_of_all
                    (*ENDIF*) 
                ELSE
                    dmli.d_mselect_loop_cnt := cgg04_first_and_only_of_this;
                (*ENDIF*) 
            (*ENDIF*) 
            _max_res_id              := acv.a_max_res_id;
            _max_trigger_res_id      := -1;
            _longdescpos             := 1;
            _planHandle              := acv.a_planHandle;
            REPEAT
                acv.a_timestamp := bsp_c20;
                a52internal_subtrans (acv);
                acv.a_data_ptr       := @acv.a_data_ptr^[acv.a_input_data_pos];
                acv.a_data_length    := acv.a_data_length - acv.a_input_data_pos + 1;
                IF  acv.a_variable_input
                THEN
                    BEGIN
                    acv.a_input_data_pos := acv.a_data_length;
                    IF  NOT a509build_map_from_databuffer (acv.a_data_ptr,
                        acv.a_input_data_map, acv.a_input_data_pos)
                    THEN
                        BEGIN
                        g01opmsg (sp3p_console, sp3m_error,
                              csp3_a92_incorrect_partbuf_len,
                              csp3_n_order, 'PART KIND VARDATA       ',
                              succ(_command_no));
                        a07_b_put_error (acv, e_invalid_segment_construction, 22);
                        END
                    ELSE
                        acv.a_input_data_pos := succ(acv.a_input_data_pos);
                    (*ENDIF*) 
                    END
                ELSE
                    acv.a_input_data_pos := 1;
                (*ENDIF*) 
                IF  acv.a_returncode = 0
                THEN
                    BEGIN
                    _command_no       := succ(_command_no);
                    parsk            := _m_parsk;
                    acv.a_max_res_id     := _max_res_id;
                    (* same result id must be used for all select's *)
                    a501exec_with_change_rec (acv, dmli, parsk, change_rec,
                          c_output_during_execution);
                    IF  _command_no < _cmd_count
                    THEN
                        IF  dmli.d_mselect_loop_cnt = cgg04_first_of_all
                        THEN
                            BEGIN
                            dmli.d_mselect_loop_cnt := _cmd_count - 1;
                            IF  (acv.a_return_segm^.sp1r_function_code
                                = csp1_mselect_into_fc) AND
                                (acv.a_returncode = 0) AND
                                (acv.a_curr_retpart^.sp1p_part_kind = sp1pk_data)
                            THEN
                                BEGIN
                                (* cnt results of MSELECT INTO *)
                                (* plus resultcount have to fit *)
                                _cnt := (acv.a_curr_retpart^.sp1p_buf_size -
                                      sizeof(tsp1_part_header) -
                                      a01aligned_cmd_len (sizeof(tsp00_ResNum))) DIV
                                      acv.a_curr_retpart^.sp1p_buf_len;
                                IF  _cnt < _cmd_count
                                THEN
                                    dmli.d_mselect_loop_cnt := _cnt - 1;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END
                        ELSE
                            dmli.d_mselect_loop_cnt := pred(dmli.d_mselect_loop_cnt);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  dmli.d_mselect_loop_cnt = cgg04_last_of_this
                    THEN
                        IF  _last_data_packets
                        THEN
                            dmli.d_mselect_loop_cnt := cgg04_last_of_all;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  acv.a_returncode = 0
                    THEN
                        BEGIN
                        IF  dmli.d_mselect_rescnt = cak_is_undefined
                        THEN
                            BEGIN
                            (* although M-cmd only one data-packet *)
                            (* insert/update/delete *)
                            _part_desc_ptr := NIL;
                            a92find_return_part (acv, sp1pk_resultcount,
                                  _part_desc_ptr );
                            IF  _part_desc_ptr <> NIL
                            THEN
                                BEGIN
                                _one_rescount := 0;
                                s40g4int (_part_desc_ptr^.sp1p_buf, 2,
                                      _one_rescount, _num_err);
                                acv.a_mass_all_rescount :=
                                      acv.a_mass_all_rescount + _one_rescount;
                                END;
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  acv.a_returncode =
                            a071_return_code (e_row_not_found, acv.a_sqlmode)
                        THEN
                            BEGIN
                            acv.a_returncode := 0;
                            acv.a_part_rollback := false;
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    _part_desc_ptr := NIL;
                    IF  (acv.a_return_segm^.sp1r_function_code = csp1_insert_fc) OR
                        (acv.a_return_segm^.sp1r_function_code = csp1_minsert_fc) OR
                        (acv.a_return_segm^.sp1r_function_code = csp1_update_fc) OR
                        (acv.a_return_segm^.sp1r_function_code = csp1_mupdate_fc)
                    THEN
                        a92find_return_part (acv, sp1pk_longdata,
                              _part_desc_ptr );
                    (*ENDIF*) 
                    IF  _part_desc_ptr = NIL
                    THEN
                        BEGIN
                        IF  acv.a_execute_trigger
                        THEN
                            BEGIN
                            (* PTS 1117182 E.Z. *)
                            _save_all_rescnt  := acv.a_mass_all_rescount;
                            IF  _max_trigger_res_id <> -1
                            THEN
                                acv.a_max_res_id := _max_trigger_res_id;
                            (*ENDIF*) 
                            _save_input_pos   := acv.a_input_data_pos;
                            _aux_data_length  := acv.a_data_length;
                            acv.a_planHandle  := NIL; (* PTS 1130020 *)
                            IF  acv.a_returncode = 0
                            THEN
                                a262execute_trigger (acv);
                            (*ENDIF*) 
                            acv.a_input_data_pos := _save_input_pos;
                            acv.a_data_length    := _aux_data_length;
                            acv.a_execute_trigger := false;
                            acv.a_mass_all_rescount := _save_all_rescnt;
                            acv.a_planHandle        := _planHandle;
                            _max_trigger_res_id     := acv.a_max_res_id;
                            END
                        ELSE
                            a52end_rollback_subtrans (acv,
                                  a01_il_b_identifier, m_end);
                        (*ENDIF*) 
                        END
                    ELSE (* after a non finished long no additional rows are allowed *)
                        IF  (acv.a_returncode = 0) AND
                            (_command_no < _cmd_count) AND
                            (acv.a_input_data_pos < acv.a_data_length)
                        THEN
                            a07_b_put_error (acv, e_st_invalid_longhandling, 1);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
            UNTIL
                (_command_no = _cmd_count) OR
                (acv.a_input_data_pos >= acv.a_data_length) OR
                (acv.a_returncode <> 0);
            (*ENDREPEAT*) 
            IF  dmli.d_local_massdata_part
            THEN
                BEGIN
                _p := @dmli.d_massdata_ptr^;
                gg941Deallocate (acv.a_transinf.tri_trans, _p);
                dmli.d_local_massdata_part := false;
                END;
            (*ENDIF*) 
            acv.a_part_rollback := false;
            IF  ((dmli.d_mselect_loop_cnt = cgg04_last_of_all) OR
                ( dmli.d_mselect_loop_cnt = cgg04_first_and_only_of_all))
                AND
                ((dmli.d_mselect_rescnt = 0) OR
                ((dmli.d_mselect_rescnt = cak_is_undefined) AND
                (acv.a_mass_all_rescount = 0)))
            THEN
                a07_b_put_error (acv, e_row_not_found, -acv.a_input_data_pos);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        (* do it in any case to have acv.a_resnum filled correctly *)
        IF  ((acv.a_sqlmode = sqlm_oracle) AND is_mass_select)
        THEN
            a60rescount (acv, 0)
        ELSE
            IF  dmli.d_mselect_rescnt = cak_is_undefined
            THEN
                a60rescount (acv, acv.a_mass_all_rescount)
            ELSE
                a60rescount (acv, dmli.d_mselect_rescnt);
            (*ENDIF*) 
        (*ENDIF*) 
        IF  dmli.d_mselect_rescnt <> cak_is_undefined
        THEN
            acv.a_mass_all_rescount := dmli.d_mselect_rescnt;
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            IF  acv.a_execute_trigger
            THEN
                a52internal_subtrans (acv);
            (*ENDIF*) 
            IF  dmli.d_repl_reskey
            THEN
                acv.a_resname_addr[cak_extern_pos] := NIL;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            IF  NOT acv.a_user_defined_error
            THEN
                a06reset_retpart (acv);
            (*ENDIF*) 
            acv.a_errorpos := _command_no
            END;
        (*ENDIF*) 
        IF  _last_data_packets
        THEN
            acv.a_mass_all_rescount := 0;
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak501mfetch_execute (
            VAR acv   : tak_all_command_glob;
            VAR sparr : tak_syspointerarr);
 
VAR
      _position      : tsp00_Int4;
      _res           : tsp00_NumError;
      _mfetch_count  : tsp00_Int4;
      _fill_ret_segm : boolean;
      _sel_parsid    : tak_parsid;
      _mtype         : tgg00_MessType2;

 
BEGIN
ak501fetch_part (acv, sparr, _position, _mtype, _fill_ret_segm, _sel_parsid);
_mfetch_count := 0;
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  (acv.a_rescount_part = NIL)
    THEN
        a07_b_put_error (acv, e_too_short_datapart, 1)
    ELSE
        IF  (acv.a_rescount_part^.sp1p_buf_len < mxsp_resnum)
        THEN
            a07_b_put_error (acv, e_too_short_datapart, 1)
        ELSE
            BEGIN
            s40glint (acv.a_rescount_part^.sp1p_buf, 2, 10,
                  _mfetch_count, _res);
            IF  (_res <> num_ok) OR
                (acv.a_rescount_part^.sp1p_buf [ 1 ] <> csp_defined_byte)
            THEN
                a07_b_put_error (acv, e_too_short_datapart, 1)
            ELSE
                IF  _mfetch_count > MAX_INT2_SP00
                THEN
                    _mfetch_count := MAX_INT2_SP00;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        WITH sparr.px[ 1 ]^.sparsinfo DO
            BEGIN
            IF  a101_IsExtendedTempFile (acv, sparr.px[ 2 ]^.sreskey.res_restree)
            THEN
                a101_GetTempFileInstance (acv.a_transinf.tri_trans,
                      sparr.px[ 2 ]^.sreskey.res_restree);
            (*ENDIF*) 
            IF  sparr.px[ 2 ]^.sreskey.res_build
            THEN
                (* PTS 1111576 E.Z. *)
                a73_more_fetch (acv, sparr, _mtype,
                      _position, _mfetch_count)
            ELSE
                (* PTS 1111576 E.Z. *)
                a74_search_fetch (acv, sparr, _mtype, _position,
                      acv.a_resname_addr[ cak_extern_pos ],
                      NOT c_single_fetch, _mfetch_count);
            (*ENDIF*) 
            ak501fetch_rest (acv, sparr, NOT c_single, _fill_ret_segm, _sel_parsid)
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak501subtrans (
            VAR acv   : tak_all_command_glob;
            VAR parsk : tak_parskey);
 
VAR
      _dummy         : integer;
      _subtrans_name : tsp00_KnlIdentifier;
 
BEGIN
IF  parsk.p_no = csp_maxint1 - 1
THEN (* no named subtrans *)
    _subtrans_name := a01_il_b_identifier
ELSE
    BEGIN (* savepoint *)
    _dummy := 0;
    a505next_command (acv, acv.a_p_arr1, parsk, _dummy);
    IF  acv.a_returncode = 0
    THEN
        _subtrans_name := acv.a_p_arr1.pparsp^.sparsinfo.p_resn
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_statement_kind = isql_commands
THEN
    CASE parsk.p_kind OF
        m_begin :
            acv.a_statement_kind := ibegin_subtrans;
        m_end :
            acv.a_statement_kind := iend_subtrans;
        m_partial_rollback :
            acv.a_statement_kind := irollback_subtrans
        END;
    (*ENDCASE*) 
(*ENDIF*) 
CASE parsk.p_kind OF
    m_begin :
        a52new_subtrans (acv, _subtrans_name);
    m_end :
        a52end_rollback_subtrans (acv, _subtrans_name, m_end);
    m_partial_rollback :
        a52end_rollback_subtrans (acv, _subtrans_name, m_rollback);
    END;
(*ENDCASE*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
