.nf
 
 .nf

    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo

 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :      Date : 1999-11-19
*****************************************************
modname : VAK683
changed : 1999-11-19
module  : join_trace_routines
 
Author  : GertG
Created : 1999-09-15
*****************************************************
 
 
Define  :
 
        PROCEDURE
              a683trans_to_line (
                    VAR acv         : tak_all_command_glob;
                    VAR dmli        : tak_dml_info;
                    tableno         : tsp00_Int2;
                    colno           : tsp00_Int2;
                    VAR line        : tsp00_DataLine;
                    maxlen          : tsp00_Int2;
                    VAR res_state   : boolean);
&       ifdef TRACE
 
        PROCEDURE
              a683tabarr_output(
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a683output_joins(
                    debug       : tgg00_Debug;
                    VAR acv     : tak_all_command_glob;
                    VAR dmli    : tak_dml_info;
                    VAR joins   : tak_joinrec);
 
        PROCEDURE
              a683trace_jprops(
                    debug : tgg00_Debug;
                    jprop : tak_jcolpropset);
 
        PROCEDURE
              a683trace_jointype(
                    debug : tgg00_Debug;
                    desc  : tsp00_Sname (*ptocSynonym const char**);
                    jtype : tak68_one_jointype);
 
        PROCEDURE
              a683trace_kbjrec (
                    debug      : tgg00_Debug;
                    VAR kbjrec : tgg07_KbJoinRec);
 
        PROCEDURE
              a683_output (
                    debug    : tgg00_Debug;
                    VAR joins : tak_joinrec);
 
        PROCEDURE
              a683_one_join_entry(
                    debug    : tgg00_Debug;
                    VAR joins: tak_joinrec;
                    index    : integer;
                    trace_all: boolean);
 
        PROCEDURE
              a683_one_join_entry_ex(
                    debug    : tgg00_Debug;
                    VAR dmli : tak_dml_info;
                    index    : integer;
                    trace_all: boolean);
 
        PROCEDURE
              a683joinset_trace (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname(*ptocSynonym const char**);
                    VAR dmli     : tak_dml_info;
                    VAR join_set : tak_joinset);
 
        PROCEDURE
              a683out_equal_record(
                    debug       : tgg00_Debug;
                    VAR eq_rec  : tak68_eq_record);
 
        PROCEDURE
              a683join_transition_trace(
                    debug         : tgg00_Debug;
                    VAR dmli      : tak_dml_info;
                    jtrans        : tak68_join_transitions;
                    VAR table_cnt : tsp00_Int2);
 
        PROCEDURE
              a683multabs_trace (
                    debug        : tgg00_Debug;
                    VAR mul_tabs : tak68_mult_tabs;
                    size_multabs : integer;
                    position     : integer;
                    table_cnt    : integer);
 
        PROCEDURE
              a683tr_newsucc (
                    debug          : tgg00_Debug;
                    succession     : tak68_succession_ptr;
                    start          : integer;
                    stop           : integer;
                    dst_table      : boolean);
 
        PROCEDURE
              a683tr_tableset (
                    debug           : tgg00_Debug;
                    nam             : tsp00_Sname(*ptocSynonym const char**);
                    VAR dmli        : tak_dml_info;
                    VAR table_set   : tak_joinset);
 
        PROCEDURE
              a683tr_tablenames(
                    debug    : tgg00_Debug;
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    tablecnt : integer);
 
        PROCEDURE
              a683tr_sequence(
                    debug       : tgg00_Debug;
                    VAR dmli    : tak_dml_info;
                    VAR series  : tak68_sequence);
 
        PROCEDURE
              a683trace_joininfo (
                    debug       : tgg00_Debug;
                    VAR joins   : tak_joinrec;
                    VAR joininfo: tak68_join);
 
        PROCEDURE
              a683trace_outdesc (
                    debug       : tgg00_Debug;
                    VAR outdesc : tak68_output_desc);
&       endif
 
.CM *-END-* define --------------------------------------
Use     :
 
        FROM
              CatalogWrapper : VAK103;
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        FUNCTION
              a061identifier_len (VAR id : tsp00_KnlIdentifier) : integer;
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
      ------------------------------ 
 
        FROM
              Join2_Select : VAK684;
 
        PROCEDURE
              a684get_relation_info(
                    VAR acv         : tak_all_command_glob;
                    VAR tabledesc   : tak_one_table;
                    dstate          : tak_directory_state;
                    VAR pbasep      : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              Join2_Select_help_routines : VAK685;
 
        FUNCTION
              a685get_join_trans(
                    VAR dmli    : tak_dml_info;
                    jtrans      : tak68_join_transitions;
                    dim1        : tsp00_Int2;
                    dim2        : tsp00_Int2 ) : tak68_join_transition_ptr;
&       ifdef trace
 
      ------------------------------ 
 
        FROM
              Syntax-Tree-Printer : VAK99;
 
        VAR
              a99blankline : tsp00_Line;
 
        PROCEDURE
              a99putint  (
                    VAR lineinfo : tsp00_DataLine;
                    integervalue : integer;
                    fieldlength  : tsp00_FieldRange);
&       endif
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill: VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
&       ifdef trace
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size     : tsp00_Int4;
                    m        : tsp00_MoveObjPtr;
                    pos      : tsp00_Int4;
                    len      : tsp00_Int4;
                    fillchar : char);
&       endif
 
      ------------------------------ 
 
        FROM
              GG_edit_routines: VGG17;
 
        PROCEDURE
              g17st1op (
                    op      : tgg00_StackOpType;
                    VAR len : integer;
                    VAR msg : tsp00_Sname );
 
        PROCEDURE
              g17sname_to_line (
                    n             : tsp00_Sname;
                    VAR ln_len    : integer;
                    VAR ln        : tsp00_Line);
 
        PROCEDURE
              g17nameto_line (
                    n           : tsp00_Name;
                    VAR ln_len  : integer;
                    VAR ln      : tsp00_Line);
 
        PROCEDURE
              g17int4to_line (
                    int       : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_Line);
 
        PROCEDURE
              g17longreal_to_line (
                    r         : tsp00_Longreal;
                    digits    : integer;
                    pos       : integer;
                    VAR ln    : tsp00_Line);
&       ifdef trace
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01set_bool_debug_or_trace;
 
        PROCEDURE
              t01disable_debug_or_trace;
 
        PROCEDURE
              t01strat_access_mode (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    access   : tgg07_StratAccessModSet);
 
        PROCEDURE
              t01strat_enum (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname;
                    strat : tgg07_StratEnum);
 
        PROCEDURE
              t01knl_identifier (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01bool (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    curr_bool: boolean);
 
        PROCEDURE
              t01init_line (
                    VAR ln      : tsp00_Line;
                    VAR ln_len  : integer;
                    nam         : tsp00_Sname);
 
        PROCEDURE
              t01p2real (
                    debug  : tgg00_Debug;
                    nam_1  : tsp00_Sname;
                    real_1 : tsp00_Longreal;
                    nam_2  : tsp00_Sname;
                    real_2 : tsp00_Longreal;
                    digits : integer);
 
        FUNCTION
              t01trace (layer : tgg00_Debug) : boolean;
 
        PROCEDURE
              t01basis_error (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname ;
                    b_err : tgg00_BasisError);
 
        PROCEDURE
              t01line (
                    debug  : tgg00_Debug;
                    VAR ln : tsp00_Line );
 
        PROCEDURE
              t01sname (
                    debug : tgg00_Debug;
                    nam : tsp00_Sname );
 
        PROCEDURE
              t01lidentifier (
                    debug      : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier );
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname ;
                    int4     : tsp00_Int4);
 
        PROCEDURE
              t01p2int4 (
                    debug : tgg00_Debug;
                    nam_1 : tsp00_Sname;
                    int_1 : tsp00_Int4;
                    nam_2 : tsp00_Sname;
                    int_2 : tsp00_Int4);
 
        PROCEDURE
              t01name (
                    level : tgg00_Debug;
                    nam : tsp00_Name);
&       endif
 
.CM *-END-* use -----------------------------------------
***********************************************************
Synonym :
 
.CM *-END-* synonym -------------------------------------
***********************************************************
Description:
 
a683output_joins:
-----------------
 
Write join conditions in human readable format. We use 16 line
output cluster.
'tableno' is index in dmli.d_tabarr.
 
a683trans_to_line:
------------------
 
Write table name and column name (if column number > 0) to line
("tablename.columnname").
If output length (maxlen) smaller then names, names was shorten.
Column numbers are number of column record position. 'tableno'
is index in dmli.d_tabarr. If an error is occured, res_state is 'false'.
 
A683_OUTPUT
------------------
 
This procedure is there only for test outputs. It makes the jrc_jOINARR (directory
of all Join conditions specified by the user) 'readable'. One row is output for
each Join condition.
 
.CM *-END-* description -------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
(*------------------------------*) 
 
PROCEDURE
      a683trans_to_line(
            VAR acv         : tak_all_command_glob;
            VAR dmli        : tak_dml_info;
            tableno         : tsp00_Int2;
            colno           : tsp00_Int2;
            VAR line        : tsp00_DataLine;
            maxlen          : tsp00_Int2;
            VAR res_state   : boolean);
 
VAR
      _table_ptr      : tak_sysbufferaddress;
      _colbuf         : tak00_colinfo_ptr;
      _carryover      : integer;
      _table_name_len : tsp00_Int2;
      _column_name_len: tsp00_Int2;
      _ratio          : tsp00_Int2;
      _b_err          : tgg00_BasisError;
      _expr_col       : tsp00_C10;
      _col_found      : boolean;
 
BEGIN
_b_err    := e_ok;
res_state := false;
IF  (line.pos + maxlen <= sizeof(line)) OR ( maxlen > 5 )
THEN
    BEGIN
    _table_ptr := NIL;
    res_state  := true;
    IF  ( tableno <> cak68_join_value )
    THEN
        a684get_relation_info( acv, dmli.d_tabarr^[ tableno ], d_release, _table_ptr );
    (*ENDIF*) 
    IF  ( _table_ptr <> NIL )
    THEN
        BEGIN
        (* get name length *)
        (* what about unicode? *)
        IF  oisreference in dmli.d_tabarr^[ tableno ].ospecialname
        THEN
            BEGIN
            _table_name_len  :=
                  a061identifier_len( dmli.d_tabarr^[ tableno ].oreference );
&           ifdef trace
            t01knl_identifier( ak_join, 'oreference  ', dmli.d_tabarr^[ tableno ].oreference );
&           endif
            END
        ELSE
            BEGIN
            _table_name_len  :=
                  a061identifier_len(  _table_ptr^.sbase.btablen^ );
&           ifdef trace
            t01knl_identifier( ak_join, 'tablename   ', _table_ptr^.sbase.btablen^ );
&           endif
            END;
        (*ENDIF*) 
        _column_name_len := 0;
        _colbuf := a103GetColumn ( _table_ptr^.sbase, _table_ptr^.sbase.bfirstcolind );
&       ifdef trace
        t01int4(ak_join, 'colno       ', colno);
&       endif
        IF  colno > 0
        THEN
            BEGIN
            _col_found := false;
            WHILE ( _colbuf <> NIL ) AND ( NOT _col_found ) DO
                BEGIN
                IF  _colbuf^.creccolno = colno
                THEN
                    _col_found := true
                ELSE
                    BEGIN
                    IF  ( _colbuf^.cnextind <> 0 )
                    THEN
                        _colbuf := a103GetColumn ( _table_ptr^.sbase,  _colbuf^.cnextind )
                    ELSE
                        _colbuf := NIL;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            IF  NOT _col_found
            THEN
                BEGIN
                _column_name_len := 10; (*'EXPRESSION'*)
&               ifdef trace
                t01name (ak_join, 'expr col found    ');
&               endif
                END
            ELSE
                _column_name_len := ord(_colbuf^.ccolumnn_len);
            (*ENDIF*) 
            END
        ELSE
            _column_name_len := 0;
        (*ENDIF*) 
        IF  _table_name_len + _column_name_len + 1 <= maxlen
        THEN
            BEGIN
            (* there's enough space for complete names *)
            (* write table name *)
            IF  oisreference in dmli.d_tabarr^[ tableno ].ospecialname
            THEN
                SAPDB_PascalMove('VAK683',   1,    
                      _table_name_len, sizeof( line.text ),
                      @dmli.d_tabarr^[ tableno ].oreference, 1,
                      @line.text, line.pos,
                      _table_name_len, _b_err)
            ELSE
                SAPDB_PascalMove('VAK683',   2,    
                      _table_name_len, sizeof( line.text ),
                      @_table_ptr^.sbase.btablen^, 1,
                      @line.text, line.pos,
                      _table_name_len, _b_err);
            (*ENDIF*) 
            IF  _b_err <> e_ok
            THEN
                BEGIN
                res_state := false;
&               ifdef trace
                t01basis_error(ak_join, 'tabname move', _b_err);
&               endif
                END
            ELSE
                BEGIN
                line.pos    := line.pos + _table_name_len;
                line.length := line.length + _table_name_len;
                IF  _column_name_len <> 0
                THEN
                    BEGIN
                    line.text[ line.pos ] := '.';
                    line.pos    := succ( line.pos );
                    line.length := succ( line.length );
                    IF  ( _col_found )
                    THEN
                        (* write column name *)
                        SAPDB_PascalMove('VAK683',   3,    
                              _column_name_len, sizeof( line.text ),
                              @_colbuf^.ccolumnn, 1,
                              @line.text, line.pos,
                              _column_name_len, _b_err)
                    ELSE
                        BEGIN
                        _expr_col := 'EXPRESSION';
                        SAPDB_PascalMove ('VAK683',   4,    
                              _column_name_len, sizeof( line.text ),
                              @_expr_col, 1,
                              @line.text, line.pos,
                              _column_name_len, _b_err);
                        END;
                    (*ENDIF*) 
                    IF  _b_err <> e_ok
                    THEN
                        BEGIN
                        res_state := false;
&                       ifdef trace
                        t01basis_error(ak_join, 'colname move', _b_err);
&                       endif
                        END
                    ELSE
                        BEGIN
                        line.pos    := line.pos + _column_name_len;
                        line.length := line.length + _column_name_len;
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            (* there's not enough space for complete names *)
            _carryover      := _table_name_len + _column_name_len + 1 - maxlen ;
            _ratio          := ( _table_name_len * _carryover) DIV
                  (_table_name_len + _column_name_len + 1);
            IF  _column_name_len - (_carryover - _ratio) < 2
            THEN
                _ratio := _carryover + 2 - _column_name_len;
            (*ENDIF*) 
            _table_name_len := _table_name_len - _ratio;
            (* write table name *)
            IF  oisreference in dmli.d_tabarr^[ tableno ].ospecialname
            THEN
                SAPDB_PascalMove('VAK683',   5,    
                      _table_name_len, sizeof( line.text ),
                      @dmli.d_tabarr^[ tableno ].oreference, 1,
                      @line.text, line.pos,
                      _table_name_len, _b_err)
            ELSE
                SAPDB_PascalMove('VAK683',   6,    
                      _table_name_len, sizeof( line.text ),
                      @_table_ptr^.sbase.btablen^, 1,
                      @line.text, line.pos,
                      _table_name_len, _b_err);
            (*ENDIF*) 
            IF  _b_err <> e_ok
            THEN
                BEGIN
                res_state := false;
&               ifdef trace
                t01basis_error(ak_join, 'tabname move', _b_err);
&               endif
                END
            ELSE
                BEGIN
                line.pos    := line.pos + _table_name_len;
                line.length := line.length + _table_name_len;
                IF  _ratio > 0
                THEN
                    line.text[ line.pos - 1 ] := '~';
                (*ENDIF*) 
                IF  _column_name_len <> 0
                THEN
                    BEGIN
                    line.text[ line.pos ] := '.';
                    line.pos    := succ( line.pos );
                    line.length := succ( line.length );
                    (* write column name *)
                    IF  ( _col_found )
                    THEN
                        SAPDB_PascalMove('VAK683',   7,    
                              _column_name_len, sizeof( line.text ),
                              @_colbuf^.ccolumnn, 1,
                              @line.text, line.pos,
                              _column_name_len - (_carryover - _ratio), _b_err)
                    ELSE
                        BEGIN
                        _expr_col := 'EXPRESSION';
                        SAPDB_PascalMove ('VAK683',   8,    
                              _column_name_len, sizeof( line.text ),
                              @_expr_col, 1,
                              @line.text, line.pos,
                              _column_name_len - (_carryover - _ratio), _b_err);
                        END;
                    (*ENDIF*) 
                    IF  _b_err <> e_ok
                    THEN
                        BEGIN
                        res_state := false;
&                       ifdef trace
                        t01basis_error(ak_join, 'colname move', _b_err);
&                       endif
                        END
                    ELSE
                        BEGIN
                        line.pos    := line.pos + _column_name_len -
                              (_carryover - _ratio);
                        line.length := line.length + _column_name_len -
                              (_carryover - _ratio);
                        IF  (_carryover - _ratio) > 0
                        THEN
                            line.text[ line.pos - 1 ] := '~';
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        IF  ( tableno = cak68_join_value )
        THEN
            BEGIN
            line.text[ line.pos + 0 ] := 'C';
            line.text[ line.pos + 1 ] := 'O';
            line.text[ line.pos + 2 ] := 'N';
            line.text[ line.pos + 3 ] := 'S';
            line.text[ line.pos + 4 ] := 'T';
            line.pos    := line.pos + 5;
            line.length := line.pos - 1;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      a683tabarr_output(
            VAR dmli : tak_dml_info);
 
VAR
      _debug : tgg00_Debug;
      _i     : integer;
 
BEGIN
_debug := ak_join;
t01name (_debug, '---- D_TABARR ----');
t01int4 (_debug, 'd_cntfromtab', dmli.d_cntfromtab);
FOR _i := 1 TO dmli.d_cntfromtab DO
    BEGIN
    t01int4 (_debug, 'Table No.   ', _i);
    t01lidentifier (_debug, dmli.d_tabarr^[_i].ouser);
    t01lidentifier (_debug, dmli.d_tabarr^[_i].otable);
    t01lidentifier (_debug, dmli.d_tabarr^[_i].oreference);
    IF  ta_fact in dmli.d_tabarr^[_i].oattributes
    THEN
        t01name (_debug, 'FACT TABLE        ');
    (*ENDIF*) 
    IF  ta_dimension in dmli.d_tabarr^[_i].oattributes
    THEN
        t01name (_debug, 'DIMENSION TABLE   ');
    (*ENDIF*) 
    IF  ta_bwhierarchy in dmli.d_tabarr^[_i].oattributes
    THEN
        t01name (_debug, 'BWHIERARCHY TABLE ');
    (*ENDIF*) 
    END;
(*ENDFOR*) 
END;
 
&endif
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      a683output_joins(
            debug       : tgg00_Debug;
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info;
            VAR joins   : tak_joinrec);
 
CONST
      c_max_joinpart_name = 20;
      c_line_blocking     = 16;
 
VAR
      _i            : integer;
      _line         : ARRAY[ 1..c_line_blocking ] OF tsp00_DataLine;
      _lineno       : integer;
      _res_state    : boolean;
 
BEGIN
IF  t01trace(debug)
THEN
    BEGIN
    _lineno := 0;
    FOR _i := 0 TO joins.jrc_cnt - 1 DO
        BEGIN
        _lineno := succ( _lineno );
        _line[ _lineno ].text   := a99blankline;
        _line[ _lineno ].length := 0;
        _line[ _lineno ].pos    := 1;
        a683trans_to_line( acv, dmli,
              joins.jrc_joinarr^[ _i ].jo_recs[ 1 ].jop_tableno,
              joins.jrc_joinarr^[ _i ].jo_recs[ 1 ].jop_fieldno,
              _line[ _lineno ], c_max_joinpart_name, _res_state);
        _line[ _lineno ].pos    := _line[ _lineno ].pos + 1;
        _line[ _lineno ].length := _line[ _lineno ].length + 1;
        CASE joins.jrc_joinarr^[ _i ].jo_op OF
            op_eq:
                BEGIN
                _line[ _lineno ].text[ _line[ _lineno ].pos   ] := '=';
                _line[ _lineno ].pos := succ( _line[ _lineno ].pos );
                END;
            op_ge:
                BEGIN
                _line[ _lineno ].text[ _line[ _lineno ].pos   ] := '>';
                _line[ _lineno ].text[ _line[ _lineno ].pos+1 ] := '=';
                _line[ _lineno ].pos := _line[ _lineno ].pos + 2;
                END;
            op_gt:
                BEGIN
                _line[ _lineno ].text[ _line[ _lineno ].pos ] := '>';
                _line[ _lineno ].pos := succ( _line[ _lineno ].pos );
                END;
            op_le:
                BEGIN
                _line[ _lineno ].text[ _line[ _lineno ].pos   ] := '<';
                _line[ _lineno ].text[ _line[ _lineno ].pos+1 ] := '=';
                _line[ _lineno ].pos := _line[ _lineno ].pos + 2;
                END;
            op_lt:
                BEGIN
                _line[ _lineno ].text[ _line[ _lineno ].pos   ] := '<';
                _line[ _lineno ].pos := succ( _line[ _lineno ].pos );
                END;
            op_ne:
                BEGIN
                _line[ _lineno ].text[ _line[ _lineno ].pos   ] := '<';
                _line[ _lineno ].text[ _line[ _lineno ].pos+1 ] := '>';
                _line[ _lineno ].pos := _line[ _lineno ].pos + 2;
                END;
            op_like:
                BEGIN
                _line[ _lineno ].text[ _line[ _lineno ].pos   ] := 'L';
                _line[ _lineno ].pos := succ( _line[ _lineno ].pos );
                END;
            op_not_like:
                BEGIN
                _line[ _lineno ].text[ _line[ _lineno ].pos   ] := '!';
                _line[ _lineno ].text[ _line[ _lineno ].pos+1 ] := 'L';
                _line[ _lineno ].pos := _line[ _lineno ].pos + 2;
                END;
            op_in:
                BEGIN
                _line[ _lineno ].text[ _line[ _lineno ].pos   ] := 'I';
                _line[ _lineno ].pos := succ( _line[ _lineno ].pos );
                END;
            op_not_in:
                BEGIN
                _line[ _lineno ].text[ _line[ _lineno ].pos   ] := '!';
                _line[ _lineno ].text[ _line[ _lineno ].pos+1 ] := 'I';
                _line[ _lineno ].pos := _line[ _lineno ].pos + 2;
                END;
            op_sounds:
                BEGIN
                _line[ _lineno ].text[ _line[ _lineno ].pos   ] := 'S';
                _line[ _lineno ].pos := succ( _line[ _lineno ].pos );
                END;
            op_not_sounds:
                BEGIN
                _line[ _lineno ].text[ _line[ _lineno ].pos   ] := '!';
                _line[ _lineno ].text[ _line[ _lineno ].pos+1 ] := 'S';
                _line[ _lineno ].pos := _line[ _lineno ].pos + 2;
                END;
            op_null:
                BEGIN
                _line[ _lineno ].text[ _line[ _lineno ].pos   ] := 'N';
                _line[ _lineno ].pos := succ( _line[ _lineno ].pos );
                END;
            op_not_null:
                BEGIN
                _line[ _lineno ].text[ _line[ _lineno ].pos   ] := '!';
                _line[ _lineno ].text[ _line[ _lineno ].pos+1 ] := 'N';
                _line[ _lineno ].pos := _line[ _lineno ].pos + 2;
                END;
            OTHERWISE
                BEGIN
                _line[ _lineno ].text[ _line[ _lineno ].pos ] := '?';
                _line[ _lineno ].pos := succ( _line[ _lineno ].pos );
                END;
            END;
        (*ENDCASE*) 
        _line[ _lineno ].pos    := _line[ _lineno ].pos + 1;
        _line[ _lineno ].length := _line[ _lineno ].pos - 1;
        a683trans_to_line( acv, dmli,
              joins.jrc_joinarr^[ _i ].jo_recs[ 2 ].jop_tableno,
              joins.jrc_joinarr^[ _i ].jo_recs[ 2 ].jop_fieldno,
              _line[ _lineno ], c_max_joinpart_name, _res_state);
        IF  _lineno = c_line_blocking
        THEN
            BEGIN
            FOR _lineno := 1 TO c_line_blocking DO
                t01line( debug, _line[ _lineno ].text );
            (*ENDFOR*) 
            _lineno := 1;
            END;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    IF  _lineno < c_line_blocking
    THEN
        FOR _i := 1 TO _lineno DO
            t01line( debug, _line[ _i ].text );
        (*ENDFOR*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
&endif
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      a683trace_jointype(
            debug : tgg00_Debug;
            desc  : tsp00_Sname;
            jtype : tak68_one_jointype);
 
VAR
      _ln   : tsp00_Line;
      _type : tsp00_Name;
 
BEGIN
SAPDB_PascalForcedFill (sizeof (_ln), @_ln, 1, sizeof (_ln), bsp_c1);
SAPDB_PascalForcedMove (sizeof(desc), sizeof(_ln), @desc, 1, @_ln, 1, sizeof(desc));
_ln[ sizeof(desc) + 1] := ':';
CASE jtype OF
    to_single_keyfield:
        BEGIN
        _type := 'SINGLE KEY        ';
        SAPDB_PascalForcedMove (sizeof(_type), sizeof(_ln), @_type, 1, @_ln, sizeof(desc)+3,
              sizeof(_type));
        END;
    to_key:
        BEGIN
        _type := 'KEY               ';
        SAPDB_PascalForcedMove (sizeof(_type), sizeof(_ln), @_type, 1, @_ln, sizeof(desc)+3,
              sizeof(_type));
        END;
    to_unique_field:
        BEGIN
        _type := 'UNIQUE INDEX      ';
        SAPDB_PascalForcedMove (sizeof(_type), sizeof(_ln), @_type, 1, @_ln, sizeof(desc)+3,
              sizeof(_type));
        END;
    to_keypart:
        BEGIN
        _type := 'KEY PART          ';
        SAPDB_PascalForcedMove (sizeof(_type), sizeof(_ln), @_type, 1, @_ln, sizeof(desc)+3,
              sizeof(_type));
        END;
    to_first_keyfield:
        BEGIN
        _type := 'FIRST KEY         ';
        SAPDB_PascalForcedMove (sizeof(_type), sizeof(_ln), @_type, 1, @_ln, sizeof(desc)+3,
              sizeof(_type));
        END;
    to_all_invfields:
        BEGIN
        _type := 'ALL INDEX-COLUMNS ';
        SAPDB_PascalForcedMove (sizeof(_type), sizeof(_ln), @_type, 1, @_ln, sizeof(desc)+3,
              sizeof(_type));
        END;
    to_invpart:
        BEGIN
        _type := 'INDEX PART        ';
        SAPDB_PascalForcedMove (sizeof(_type), sizeof(_ln), @_type, 1, @_ln, sizeof(desc)+3,
              sizeof(_type));
        END;
    to_invfield:
        BEGIN
        _type := 'SINGLE INDEX      ';
        SAPDB_PascalForcedMove (sizeof(_type), sizeof(_ln), @_type, 1, @_ln, sizeof(desc)+3,
              sizeof(_type));
        END;
    to_mt_join:
        BEGIN
        _type := 'MT_JOIN           ';
        SAPDB_PascalForcedMove (sizeof(_type), sizeof(_ln), @_type, 1, @_ln, sizeof(desc)+3,
              sizeof(_type));
        END;
    to_eq_field:
        BEGIN
        _type := 'EQUAL COLUMN      ';
        SAPDB_PascalForcedMove (sizeof(_type), sizeof(_ln), @_type, 1, @_ln, sizeof(desc)+3,
              sizeof(_type));
        END;
    to_lt_gt_field:
        BEGIN
        _type := 'LT, GT, ......    ';
        SAPDB_PascalForcedMove (sizeof(_type), sizeof(_ln), @_type, 1, @_ln, sizeof(desc)+3,
              sizeof(_type));
        END;
    to_ne_field:
        BEGIN
        _type := 'NON EQUAL         ';
        SAPDB_PascalForcedMove (sizeof(_type), sizeof(_ln), @_type, 1, @_ln, sizeof(desc)+3,
              sizeof(_type));
        END;
    to_cartesian_prod:
        BEGIN
        _type := 'CARTESIAN PRODUCT ';
        SAPDB_PascalForcedMove (sizeof(_type), sizeof(_ln), @_type, 1, @_ln, sizeof(desc)+3,
              sizeof(_type));
        END;
    to_illegal:
        BEGIN
        _type := 'ILLEGAL           ';
        SAPDB_PascalForcedMove (sizeof(_type), sizeof(_ln), @_type, 1, @_ln, sizeof(desc)+3,
              sizeof(_type));
        END;
    END;
(*ENDCASE*) 
t01line(debug, _ln);
END;
 
&endif
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      a683trace_jprops(
            debug : tgg00_Debug;
            jprop : tak_jcolpropset);
 
BEGIN
IF  ( jprop = [] )
THEN
    t01name(debug, 'dst props: <empty>')
ELSE
    BEGIN
    t01sname(debug, 'dst props  :');
    IF  jtkey in jprop
    THEN
        t01sname (debug, 'jtkey       ');
    (*ENDIF*) 
    IF  jtfirstkey in jprop
    THEN
        t01sname (debug, 'jtfirstkey  ');
    (*ENDIF*) 
    IF  jtonlykey in jprop
    THEN
        t01sname (debug, 'jtonlykey   ');
    (*ENDIF*) 
    IF  jtmulti in jprop
    THEN
        t01sname (debug, 'jtmulti     ');
    (*ENDIF*) 
    IF  jtascii in jprop
    THEN
        t01sname (debug, 'jtascii     ');
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
&endif
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      a683trace_kbjrec (
            debug      : tgg00_Debug;
            VAR kbjrec : tgg07_KbJoinRec);
 
VAR
      dt : tsp00_DataLine;
      i,j: integer;
      x  : integer;
 
BEGIN
IF  t01trace (debug)
THEN
    BEGIN
    t01int4 (debug, '-- kbjrec --', kbjrec.kbjr_jointrans_cnt);
    t01int4 (debug, 'used path   ', kbjrec.kbjr_jpath);
    IF  kbjrec.kbjr_right_oj
    THEN
        t01bool (debug, 'R outer join', kbjrec.kbjr_right_oj);
    (*ENDIF*) 
    IF  kbjrec.kbjr_left_oj
    THEN
        t01bool (debug, 'L outer join', kbjrec.kbjr_left_oj);
    (*ENDIF*) 
    WITH kbjrec DO
        FOR i := 1 TO kbjr_jointrans_cnt DO
            BEGIN
            dt.text   := a99blankline;
            dt.pos    := 0;
            dt.length := 0;
            FOR j := 1 TO 2 DO
                WITH kbjr_jarr[ i ], kbji_parts[ j ] DO
                    BEGIN
                    dt.pos    := dt.pos + 4;
                    dt.length := dt.pos;
                    a99putint (dt, kboj_recpos, 4);
                    a99putint (dt, ord(kboj_len), 4);
                    dt.pos := dt.pos + 3;
                    IF  (j = 1)
                    THEN
                        CASE kboj_op OF
                            op_eq :
                                dt.text[ dt.pos ] := '=';
                            op_ge :
                                dt.text[ dt.pos ] := 'G';
                            op_gt :
                                dt.text[ dt.pos ] := '>';
                            op_le :
                                dt.text[ dt.pos ] := 'L';
                            op_lt :
                                dt.text[ dt.pos ] := '<';
                            op_ne :
                                dt.text[ dt.pos ] := 'U';
                            op_like :
                                dt.text[ dt.pos ] := 'I';
                            op_not_like :
                                dt.text[ dt.pos ] := 'K';
                            op_sounds :
                                dt.text[ dt.pos ] := 'S';
                            op_not_sounds :
                                dt.text[ dt.pos ] := 'O';
                            op_null :
                                dt.text[ dt.pos ] := 'N';
                            op_not_null :
                                dt.text[ dt.pos ] := 'R';
                            OTHERWISE ;
                            END
                        (*ENDCASE*) 
                    ELSE
                        CASE ord(kboj_op) OF
                            cgg07_left_len_eq_right_len :
                                BEGIN
                                x := dt.pos;
                                g17nameto_line( 'left = right      ', x, dt.text );
                                dt.pos := x;
                                END;
                            cgg07_left_len_le_right_len :
                                BEGIN
                                x := dt.pos;
                                g17nameto_line( 'left <= right     ', x, dt.text );
                                dt.pos := x;
                                END;
                            cgg07_left_len_gt_right_len :
                                BEGIN
                                x := dt.pos;
                                g17nameto_line( 'left >  right     ', x, dt.text );
                                dt.pos := x;
                                END;
                            OTHERWISE
                                dt.text[ dt.pos ] := '?';
                            END;
                        (*ENDCASE*) 
                    (*ENDIF*) 
                    dt.pos    := dt.pos + 4;
                    dt.length := dt.pos;
                    END;
                (*ENDWITH*) 
            (*ENDFOR*) 
            t01line (debug, dt.text)
            END;
        (*ENDFOR*) 
    (*ENDWITH*) 
    t01int4 (debug, '------------', kbjrec.kbjr_jointrans_cnt);
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a683trace_joininfo (
            debug       : tgg00_Debug;
            VAR joins   : tak_joinrec;
            VAR joininfo: tak68_join);
 
VAR
      _dt : tsp00_DataLine;
      _i  : integer;
 
BEGIN
IF  t01trace (debug)
THEN
    BEGIN
    t01int4 (debug, '--joininfo--', joininfo.jn_jarr_cnt);
    t01int4 (debug, 'used path   ', joininfo.jn_jarr_path);
    IF  joininfo.jn_rightoj
    THEN
        t01bool (debug, 'R outer join', joininfo.jn_rightoj);
    (*ENDIF*) 
    IF  joininfo.jn_leftoj
    THEN
        t01bool (debug, 'L outer join', joininfo.jn_leftoj);
    (*ENDIF*) 
    t01int4 (debug, 'res rec len ', joininfo.jn_res_rec_len);
    t01int4 (debug, 'res key len ', joininfo.jn_res_key_len);
    t01int4 (debug, 'rec len     ', joininfo.jn_rec_len);
    t01int4 (debug, 'key len     ', joininfo.jn_key_len);
    ;
    IF  ( joininfo.jn_jarr_cnt > 0 )
    THEN
        BEGIN
        _dt.text := a99blankline;
        _i       := 0;
        g17nameto_line( 'tabno fieldno     ', _i, _dt.text );
        _i  := _i + 1;
        g17nameto_line( 'startstck stckcnt ', _i, _dt.text );
        _i  := _i + 1;
        g17nameto_line( 'datatyp iolen     ', _i, _dt.text );
        _i  := _i + 1;
        g17nameto_line( 'outpos            ', _i, _dt.text );
        t01line (debug, _dt.text);
        END;
    (*ENDIF*) 
    FOR _i := 1 TO joininfo.jn_jarr_cnt DO
        BEGIN
        a683_one_join_entry( debug, joins, joininfo.jn_jarr[ _i ], false );
        END;
    (*ENDFOR*) 
    END
(*ENDIF*) 
END;
 
&endif
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      a683_output (
            debug    : tgg00_Debug;
            VAR joins : tak_joinrec);
 
VAR
      _dt : tsp00_DataLine;
      _i  : integer;
 
BEGIN
IF  t01trace (debug)
THEN
    BEGIN
    t01int4 (debug, 'JOIN CONDIT.', joins.jrc_cnt);
    IF  ( joins.jrc_cnt > 0 )
    THEN
        BEGIN
        _dt.text := a99blankline;
        _i       := 0;
        g17nameto_line( 'tabno fieldno     ', _i, _dt.text );
        _i  := _i + 1;
        g17nameto_line( 'startstck stckcnt ', _i, _dt.text );
        _i  := _i + 1;
        g17nameto_line( 'datatyp iolen     ', _i, _dt.text );
        _i  := _i + 1;
        g17nameto_line( 'outpos            ', _i, _dt.text );
        t01line (debug, _dt.text);
        FOR _i := 0 TO joins.jrc_cnt - 1 DO
            BEGIN
            a683_one_join_entry( debug, joins, _i, true );
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a683_one_join_entry(
            debug    : tgg00_Debug;
            VAR joins: tak_joinrec;
            index    : integer;
            trace_all: boolean);
 
VAR
      _dt   : tsp00_DataLine;
      _j, _i: integer;
      _len  : integer;
      _op   : tsp00_Sname;
 
BEGIN
_dt.text   := a99blankline;
_dt.pos    := 1;
_dt.length := 1;
IF  ( index >= joins.jrc_capacity ) OR ( index > joins.jrc_cnt )
    (* we have to allow index = jrc_cnt, because we prepare entries on this pos *)
THEN
    t01int4 (debug, 'WRONG INDEX!', index)
ELSE
    FOR _j := 1 TO 2 DO
    WITH joins.jrc_joinarr^[ index ].jo_recs[ _j ] DO
        BEGIN
        a99putint (_dt, jop_tableno, 4);
        IF  jop_outer_join
        THEN
            BEGIN
            _dt.text[ _dt.pos ] := '+';
            _dt.pos    := _dt.pos + 1;
            _dt.length := _dt.length + 1;
            END;
        (*ENDIF*) 
        a99putint (_dt, jop_fieldno, 4);
        a99putint (_dt, jop_startstack, 4);
        a99putint (_dt, jop_cntstack, 4);
        a99putint (_dt, ord(jop_datatyp), 3);
        a99putint (_dt, jop_inoutlen, 4);
        a99putint (_dt, jop_outpos, 4);
        _dt.pos    := _dt.pos + 1;
        _dt.length := _dt.length + 1;
        IF  ( jtkey in jop_propset )
        THEN
            BEGIN
            IF  (jtonlykey in jop_propset)
            THEN
                BEGIN
                _dt.text[ _dt.pos     ] := '1';
                _dt.text[ _dt.pos + 1 ] := 'k';
                _dt.pos    := _dt.pos + 2;
                _dt.length := _dt.length + 2;
                END
            ELSE
                BEGIN
                IF  (jtfirstkey in jop_propset)
                THEN
                    BEGIN
                    _dt.text[ _dt.pos     ] := 'k';
                    _dt.text[ _dt.pos + 1 ] := '+';
                    _dt.pos    := _dt.pos + 2;
                    _dt.length := _dt.length + 2;
                    END
                ELSE
                    BEGIN
                    _dt.text[ _dt.pos     ] := 'k';
                    _dt.pos    := _dt.pos + 1;
                    _dt.length := _dt.length + 1;
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  ( jtmulti in jop_propset )
        THEN
            BEGIN
            _dt.text[ _dt.pos     ] := 'm';
            _dt.pos    := _dt.pos + 1;
            _dt.length := _dt.length + 1;
            END;
        (*ENDIF*) 
        IF  ( jtascii in jop_propset )
        THEN
            BEGIN
            _dt.text[ _dt.pos     ] := 'm';
            _dt.pos    := _dt.pos + 1;
            _dt.length := _dt.length + 1;
            END;
        (*ENDIF*) 
        IF  ( _j = 1 )
        THEN
            BEGIN
            _dt.pos := _dt.pos + 2;
            g17st1op( joins.jrc_joinarr^[ index ].jo_op, _len, _op );
            _i := _dt.pos - 1;
            g17sname_to_line (_op, _i, _dt.text);
            _dt.pos := _dt.pos + _len;
            _dt.length := _dt.pos
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    (*ENDFOR*) 
(*ENDIF*) 
t01line (debug, _dt.text);
IF  ( trace_all )
THEN
    BEGIN
    t01p2real (debug, 'jmulti1     ',
          joins.jrc_joinarr^[ index ].jo_recs[ 1 ].jop_multiplier,
          'jmulti2     ',
          joins.jrc_joinarr^[ index ].jo_recs[ 2 ].jop_multiplier, 4);
    IF  joins.jrc_joinarr^[ index ].jo_no_join
    THEN
        t01sname (debug, '! no join ! ');
    (*ENDIF*) 
    IF  joins.jrc_col_upd
    THEN
        t01int4 (debug, 'col_upd_stat',
              joins.jrc_joinarr^[ index ].jo_col_upd_stat);
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a683_one_join_entry_ex (
            debug    : tgg00_Debug;
            VAR dmli : tak_dml_info;
            index    : integer;
            trace_all: boolean);
 
VAR
      _dt : tsp00_DataLine;
      _i  : integer;
 
BEGIN
IF  t01trace (debug)
THEN
    BEGIN
    _dt.text := a99blankline;
    _i       := 0;
    g17nameto_line( 'tabno fieldno     ', _i, _dt.text );
    _i  := _i + 1;
    g17nameto_line( 'startstck stckcnt ', _i, _dt.text );
    _i  := _i + 1;
    g17nameto_line( 'datatyp iolen     ', _i, _dt.text );
    _i  := _i + 1;
    g17nameto_line( 'outpos            ', _i, _dt.text );
    t01line (debug, _dt.text);
    a683_one_join_entry( debug, dmli.d_joins, index, trace_all );
    END
(*ENDIF*) 
END;
 
&endif
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      a683joinset_trace (
            debug        : tgg00_Debug;
            nam          : tsp00_Sname;
            VAR dmli     : tak_dml_info;
            VAR join_set : tak_joinset);
 
VAR
      dt      : tsp00_DataLine;
      i, j    : integer;
      written : boolean;
 
BEGIN
IF  t01trace (debug)
THEN
    BEGIN
    written := false;
    t01init_line(dt.text, j, nam);
    dt.pos    := j+1;
    dt.length := dt.pos;
    FOR i := 1 TO dmli.d_cntfromtab DO
        BEGIN
        IF  (i in join_set)
        THEN
            BEGIN
            written := true;
            a99putint (dt, i, 3);
            dt.pos    := dt.pos + 1;
            END;
        (*ENDIF*) 
        IF  dt.pos > ( sizeof(dt.text) - 5 )
        THEN
            BEGIN
            t01line (debug, dt.text);
            dt.text   := a99blankline;
            dt.pos    := sizeof(tsp00_Sname)+1;
            dt.length := dt.pos;
            END;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    IF  NOT written
    THEN
        g17sname_to_line ('<empty>     ', j, dt.text);
    (*ENDIF*) 
    t01line (debug, dt.text);
    END
(*ENDIF*) 
END;
 
&endif
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      a683out_equal_record(
            debug      : tgg00_Debug;
            VAR eq_rec : tak68_eq_record);
 
VAR
      _i      : integer;
      _line   : tsp00_Line;
 
BEGIN
WITH eq_rec DO
    BEGIN
    t01name(debug, '-- EQUAL RECORD --');
    t01int4(debug, 'eqr_cnt     ', eqr_cnt);
    IF  eqr_cnt > 0
    THEN
        FOR _i := 1 TO eqr_cnt DO
            BEGIN
            SAPDB_PascalForcedFill(sizeof(_line), @_line, 1, sizeof(_line), bsp_c1);
            _line[1] := 'L';
            _line[2] := 'E';
            _line[3] := 'F';
            _line[4] := 'T';
            _line[40] := 'R';
            _line[41] := 'I';
            _line[42] := 'G';
            _line[43] := 'H';
            _line[44] := 'T';
            g17int4to_line(_i, false, 4, 10, _line);
            g17int4to_line(_i, false, 4, 49, _line);
            t01line(debug, _line);
            t01p2int4(debug, 'eqi_stackpos', eqr_arr^[_i][ cak68_left ].eqi_stackpos,
                  'eqi_stackpos', eqr_arr^[_i][ cak68_right ].eqi_stackpos);
            t01p2int4(debug, 'eqi_joinno l', eqr_arr^[_i][ cak68_left ].eqi_joinno,
                  'eqi_joinno r', eqr_arr^[_i][ cak68_right ].eqi_joinno);
            t01p2int4(debug, 'eqi_codetype', eqr_arr^[_i][ cak68_left ].eqi_codetype,
                  'eqi_codetype', eqr_arr^[_i][ cak68_right ].eqi_codetype);
            t01p2int4(debug, 'field tabno ', eqr_arr^[_i][ cak68_left ].eqi_fieldid.eqt_tabno,
                  'field tabno ', eqr_arr^[_i][ cak68_right ].eqi_fieldid.eqt_tabno);
            t01p2int4(debug, 'field colno ', eqr_arr^[_i][ cak68_left ].eqi_fieldid.eqt_colno,
                  'field colno ', eqr_arr^[_i][ cak68_right ].eqi_fieldid.eqt_colno);
            END
        (*ENDFOR*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
&endif
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      a683join_transition_trace(
            debug         : tgg00_Debug;
            VAR dmli      : tak_dml_info;
            jtrans        : tak68_join_transitions;
            VAR table_cnt : tsp00_Int2);
 
VAR
      _i,_j         : tsp00_Int2;
      _ln           : tsp00_Line;
      _jtrans_ptr   : tak68_join_transition_ptr;
 
BEGIN
t01name (debug, 'jointransition    ');
t01int4 (debug, 'table count ', table_cnt);
_ln := a99blankline;
FOR _i (* *** fromrec *** *) := 1 TO table_cnt DO
    BEGIN
    g17int4to_line (_i, false, 3, ((_i - 1) MOD 16) * 4 + 1, _ln);
    IF  (_i MOD 16 = 0) OR (_i = table_cnt)
    THEN
        BEGIN
        t01line (debug, _ln);
        _ln := a99blankline;
        END
    (*ENDIF*) 
    END;
(*ENDFOR*) 
FOR _j (* *** torec *** *) := 1 TO table_cnt DO
    BEGIN
    _ln := a99blankline;
    FOR _i (* *** fromrec *** *) := 1 TO table_cnt DO
        BEGIN
        t01disable_debug_or_trace;
        _jtrans_ptr := a685get_join_trans( dmli, jtrans, _i, _j );
        t01set_bool_debug_or_trace;
        g17int4to_line (ord(_jtrans_ptr^.jt_jointype),
              false, 3, ((_i - 1) MOD 16) * 4 + 1, _ln);
        IF  (_i MOD 16 = 0) OR (_i = table_cnt)
        THEN
            BEGIN
            t01line (debug, _ln);
            _ln := a99blankline;
            END
        (*ENDIF*) 
        END
    (*ENDFOR*) 
    END;
(*ENDFOR*) 
END;
 
&endif
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      a683multabs_trace (
            debug        : tgg00_Debug;
            VAR mul_tabs : tak68_mult_tabs;
            size_multabs : integer;
            position     : integer;
            table_cnt    : integer);
 
VAR
      _i              : integer;
      _j              : integer;
      _pos            : integer;
      _oldpos         : integer;
      _start          : integer;
      _stop           : integer;
      _ln             : tsp00_Line;
      _nam            : tsp00_Sname;
      _dummy          : tsp00_Longreal;
 
BEGIN
t01name (debug, '------------------');
t01p2int4(debug, 'mt_cnt      ', mul_tabs.mt_cnt,
      'mt_pos      ', mul_tabs.mt_pos);
t01int4 (debug, 'mt_capacity ', mul_tabs.mt_capacity );
IF  ( position < 1 )
THEN
    (* trace whole array *)
    BEGIN
    _start := 1;
    _stop  := size_multabs;
    END
ELSE
    BEGIN
    t01int4(debug, 'trace pos   ', position);
    size_multabs  := 1;
    _start := position;
    _stop  := position;
    END;
(*ENDIF*) 
t01int4(debug, 'trace size  ', size_multabs);
SAPDB_PascalForcedFill (sizeof (_ln), @_ln, 1, sizeof (_ln), bsp_c1);
_pos     := 3;
_ln [ _pos ]     := 'T';
_ln [ _pos + 1 ] := 'O';
_pos    := _pos + 4;
_nam    := 'via         ';
SAPDB_PascalForcedMove (sizeof(_nam), sizeof(_ln), @_nam, 1, @_ln, _pos, sizeof(_nam));
_pos    := _pos + sizeof (_nam) + 2;
_nam    := 'multiplier  ';
SAPDB_PascalForcedMove (sizeof(_nam), sizeof(_ln), @_nam, 1, @_ln, _pos, sizeof(_nam));
_pos    := _pos + sizeof (_nam) + 1;
_ln [ _pos ]     := 'T'; (* tablecnt *)
_pos            := _pos + 3;
_ln [ _pos ]     := 'F'; (* fieldcnt *)
_pos            := _pos + 3;
_ln [ _pos ]     := 'J'; (* joinno *)
_pos            := _pos + 3;
_ln [ _pos ]     := 'I'; (* indexno *)
_pos            := _pos + 3;
_nam    := 'known tables';
SAPDB_PascalForcedMove (sizeof(_nam), sizeof(_ln), @_nam, 1, @_ln, _pos, sizeof(_nam));
_pos    := _pos + sizeof(_nam);
t01line (debug, _ln);
(* header line written *)
FOR _j := _start TO _stop DO
    WITH mul_tabs.mt_arr^[ _j ] DO
        BEGIN
        SAPDB_PascalForcedFill (sizeof (_ln), @_ln, 1, sizeof (_ln), bsp_c1);
        _pos     := 1;
        IF  (_j = mul_tabs.mt_pos) AND (_j = mul_tabs.mt_cnt)
        THEN
            _ln[ _pos ] := '#'
        ELSE
            BEGIN
            IF  _j = mul_tabs.mt_pos
            THEN
                _ln[ _pos ] := '*';
            (*ENDIF*) 
            IF  _j = mul_tabs.mt_cnt
            THEN
                _ln[ _pos ] := '-';
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        _pos     := 3;
        g17int4to_line (mtr_dst_table, false, 2, _pos, _ln);
        _pos    := _pos + 4;
        CASE mtr_jointype OF
            to_single_keyfield :
                _nam := 'SINGLE KEY  ';
            to_unique_field    :
                _nam := 'UNIQUE INDE ';
            to_keypart  :
                _nam := 'KEY PART    ';
            to_key      :
                _nam := 'KEY         ';
            to_first_keyfield  :
                _nam := 'FIRST KEY   ';
            to_invfield :
                _nam := 'SINGLE INDEX';
            to_all_invfields :
                _nam := 'MULTIP INDEX';
            to_invpart :
                _nam := 'INDEX PART  ';
            to_eq_field :
                _nam := 'EQUAL COLUMN';
            to_lt_gt_field :
                _nam := '>, <, ......';
            to_ne_field,
            to_cartesian_prod :
                _nam := '<>, none    ';
            to_illegal :
                _nam := 'ILLEGAL     ';
            OTHERWISE
                _nam := 'unknown cond';
            END;
        (*ENDCASE*) 
        SAPDB_PascalForcedMove (sizeof(_nam), sizeof(_ln), @_nam, 1, @_ln, _pos,
              sizeof(_nam));
        _pos    := _pos + sizeof (_nam) + 2;
        _dummy := mul_tabs.mt_arr^[ _j ].mtr_multipl;
        g17longreal_to_line (_dummy, 3, _pos, _ln);
        _pos    := _pos + 11;
        g17int4to_line (mtr_tablecnt, false, 3, _pos, _ln);
        _pos    := _pos + 3;
        g17int4to_line (mtr_fieldcnt, false, 3, _pos, _ln);
        _pos    := _pos + 3;
        g17int4to_line (mtr_joinno, false, 3, _pos, _ln);
        _pos    := _pos + 3;
        g17int4to_line (mtr_indexno, false, 3, _pos, _ln);
        _pos    := _pos + 5;
        _ln [ _pos ] := '[';
        _pos    := _pos + 1;
        _oldpos := _pos;
        FOR _i := 1 TO table_cnt DO
            BEGIN
            IF  _i in mtr_tab_seq
            THEN
                BEGIN
                g17int4to_line (_i, false, 3, _pos, _ln);
                _pos := _pos + 3;
                END;
            (*ENDIF*) 
            IF  (_pos >= 80) AND (_i < table_cnt)
            THEN
                BEGIN
                t01line (debug, _ln);
                SAPDB_PascalForcedFill (sizeof (_ln), @_ln, 1, sizeof (_ln), bsp_c1);
                _pos := _oldpos;
                END
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        _pos := succ (_pos);
        _ln [ _pos ] := ']';
        t01line (debug, _ln);
        END;
    (*ENDWITH*) 
(*ENDFOR*) 
t01name (debug, '------------------');
END;
 
&endif
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      a683tr_newsucc (
            debug          : tgg00_Debug;
            succession     : tak68_succession_ptr;
            start          : integer;
            stop           : integer;
            dst_table      : boolean);
 
VAR
      _i  : integer;
      _ln : tsp00_Line;
 
BEGIN
SAPDB_PascalForcedFill (sizeof (_ln), @_ln, 1, sizeof (_ln), bsp_c1);
_ln[ 2 ] := '<';
FOR _i := start TO stop DO
    BEGIN
    IF  dst_table
    THEN
        g17int4to_line (succession^[ _i ].s_tableno, false, 3,
              (_i - start) MOD 16 * 3 + 3, _ln)
    ELSE
        g17int4to_line (succession^[ _i ].s_backup, false, 3,
              (_i - start) MOD 16 * 3 + 3, _ln);
    (*ENDIF*) 
    IF  ((_i + 1 - start) MOD 16 = 0) OR (_i = stop)
    THEN
        BEGIN
        IF  _i = stop
        THEN
            _ln[ ((_i - start) MOD 16 * 3 + 3) + 4 ] := '>';
        (*ENDIF*) 
        t01line (debug, _ln);
        SAPDB_PascalForcedFill (sizeof (_ln), @_ln, 1, sizeof (_ln), bsp_c1);
        END
    (*ENDIF*) 
    END
(*ENDFOR*) 
END;
 
&endif
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      a683tr_tableset (
            debug           : tgg00_Debug;
            nam             : tsp00_Sname;
            VAR dmli        : tak_dml_info;
            VAR table_set   : tak_joinset);
 
VAR
      _i              : integer;
      _pos            : integer;
      _oldpos         : integer;
      _ln             : tsp00_Line;
 
BEGIN
SAPDB_PascalForcedFill (sizeof (_ln), @_ln, 1, sizeof (_ln), bsp_c1);
_pos := 1;
SAPDB_PascalForcedMove (sizeof(nam), sizeof(_ln), @nam, 1, @_ln, _pos, sizeof(nam));
_pos       := sizeof (nam) + 2;
_ln[ _pos ] := '[';
_pos       := _pos + 2;
_oldpos    := _pos;
FOR _i := 1 TO dmli.d_cntfromtab DO
    BEGIN
    IF  _i in table_set
    THEN
        BEGIN
        g17int4to_line (_i, false, 3, _pos, _ln);
        _pos := _pos + 3;
        END;
    (*ENDIF*) 
    IF  (_pos >= 90) AND (_i < dmli.d_cntfromtab)
    THEN
        BEGIN
        t01line (debug, _ln);
        SAPDB_PascalForcedFill (sizeof (_ln), @_ln, 1, sizeof (_ln), bsp_c1);
        _pos := _oldpos;
        END
    (*ENDIF*) 
    END;
(*ENDFOR*) 
_ln[ _pos ] := ']';
t01line (debug, _ln);
END;
 
&endif
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      a683tr_tablenames(
            debug    : tgg00_Debug;
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            tablecnt : integer);
 
CONST
      c_line_blocking = 16;
      c_no_column     = 0;
 
VAR
      _ln      : ARRAY[ 1..c_line_blocking ] OF tsp00_DataLine;
      _tableno : integer;
      _lineno  : integer;
      _i       : integer;
      _res     : boolean;
 
BEGIN
t01name (debug, '>>trace tablenames');
IF  t01trace( debug )
THEN
    BEGIN
    _lineno := 0;
    FOR _tableno := 1 TO tablecnt DO
        BEGIN
        _lineno := succ(_lineno);
        _ln[ _lineno ].text   := a99blankline;
        _ln[ _lineno ].length := 0;
        _ln[ _lineno ].pos    := 1;
        g17int4to_line (_tableno, true, 3, _ln[ _lineno ].pos,
              _ln[ _lineno ].text);
        _ln[ _lineno ].text[ 5 ] := ':';
        _ln[ _lineno ].pos := 7;
        a683trans_to_line( acv, dmli, _tableno, c_no_column, _ln[ _lineno ],
              sizeof(_ln[ _lineno ].text) - 7, _res );
        IF  _lineno = c_line_blocking
        THEN
            BEGIN
            t01sname( debug, 'table names:' );
            FOR _lineno := 1 TO c_line_blocking DO
                t01line( debug, _ln[ _lineno ].text );
            (*ENDFOR*) 
            _lineno := 1;
            END;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    IF  _lineno < c_line_blocking
    THEN
        BEGIN
        t01sname( debug, 'table names:' );
        FOR _i := 1 TO _lineno DO
            t01line( debug, _ln[ _i ].text );
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
t01name (debug, '<<trace tablenames');
END;
 
(*------------------------------*) 
 
PROCEDURE
      a683tr_sequence(
            debug       : tgg00_Debug;
            VAR dmli    : tak_dml_info;
            VAR series  : tak68_sequence);
 
VAR
      _i  : integer;
 
BEGIN
t01sname( ak_join, '--SEQUENCE--');
FOR _i := 1 TO dmli.d_cntfromtab DO
    BEGIN
    t01int4( debug, 'jos_source  ', series[ _i ].jos_source );
    t01strat_enum( debug, 'jos_joinstra', series[ _i ].jos_joinstrat );
    t01int4( debug, 'jos_indexno ', series[ _i ].jos_indexno );
    t01int4( debug, 'jos_invlen  ', series[ _i ].jos_invlen );
    t01int4( debug, 'jos_joinno  ', series[ _i ].jos_joinno );
    t01int4( debug, 'jos_fieldcnt', series[ _i ].jos_fieldcnt );
    t01bool( debug, 'jos_predef_b', series[ _i ].jos_predefined_buf );
    t01int4( debug, 'jos_tablebuf', series[ _i ].jos_table_buffer );
    t01int4( debug, 'jos_expected', series[ _i ].jos_expected_recs );
    t01int4( debug, 'jos_exp_trs ', series[ _i ].jos_expected_table_rec_reads );
    t01int4( debug, 'jos_parallel', series[ _i ].jos_parallel_server );
    t01strat_access_mode( debug, 'jos_accmod  ', series[ _i ].jos_access_mod );
    t01sname( ak_join, '------------');
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a683trace_outdesc (
            debug       : tgg00_Debug;
            VAR outdesc : tak68_output_desc);
 
VAR
      _i  : tsp00_Int2;
 
BEGIN
IF  ( t01trace (debug) )
THEN
    BEGIN
    t01int4( debug, 'capacity  oc', outdesc.od_capacity_oc );
    t01int4( debug, 'size      oc', outdesc.od_size_oc );
    t01sname( ak_join, '------------');
    FOR _i := 1 TO outdesc.od_size_oc DO
        BEGIN
        t01int4( debug, 'oc_srctab   ', outdesc.od_outcols^[ _i - 1 ].oc_srctab );
        t01int4( debug, 'oc_srcpos   ', outdesc.od_outcols^[ _i - 1 ].oc_srcpos );
        t01int4( debug, 'oc_dstpos   ', outdesc.od_outcols^[ _i - 1 ].oc_dstpos );
        t01int4( debug, 'oc_len      ', outdesc.od_outcols^[ _i - 1 ].oc_len );
        t01sname( ak_join, '-           ');
        END;
    (*ENDFOR*) 
    t01int4( debug, 'capacity row', outdesc.od_capacity_rowno );
    t01int4( debug, 'size     row', outdesc.od_size_rowno );
    t01sname( ak_join, '------------');
    FOR _i := 1 TO outdesc.od_size_rowno DO
        BEGIN
        t01int4( debug, 'rowno pos   ', outdesc.od_rownumbers^[ _i - 1 ] );
        END;
    (*ENDFOR*) 
    t01int4( debug, 'capacity ocr', outdesc.od_capacity_ocr );
    t01int4( debug, 'size     ocr', outdesc.od_size_ocr );
    t01sname( ak_join, '------------');
    FOR _i := 1 TO outdesc.od_size_ocr DO
        BEGIN
        t01p2int4( debug, 'epos        ', outdesc.od_outcols_result^[ _i - 1 ].fd_epos
              ,           'elen_var    ', outdesc.od_outcols_result^[ _i - 1 ].fd_elen_var );
        END;
    (*ENDFOR*) 
    t01int4( debug, 'od_outreclen', outdesc.od_outreclen );
    t01bool( debug, 'od_aggregati', outdesc.od_aggregation );
    t01bool( debug, 'od_one_aggr_', outdesc.od_one_aggr_group );
    END;
(*ENDIF*) 
END;
 
&endif
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
