.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK49$
.tt 2 $$$
.TT 3 $ThomasA$Show_Procedure$$2000-09-19$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : AK_Show_Procedure
=========
.sp
Purpose :
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a49execute (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a49get_trigger_def (VAR acv : tak_all_command_glob;
                    VAR tabid    : tgg00_Surrogate;
                    trigger_kind : tgg00_Linkset;
                    VAR def_len  : tsp00_Int2;
                    VAR buf      : tsp00_MoveObj;
                    buf_size     : tsp00_Int4);
 
        PROCEDURE
              a49one_table_trigger (VAR acv : tak_all_command_glob;
                    VAR a41v        : tak40_show_glob;
                    trigger_len     : integer);
 
        PROCEDURE
              a49trigger_param (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01lidentifier (debug : tgg00_Debug;
                    identifier  : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01int4 (debug : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01moveobj (debug : tgg00_Debug;
                    VAR buf  : tsp00_MoveObj;
                    startpos : tsp00_Int4;
                    endpos   : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01char_size         : integer;
              a01defaultkey        : tgg00_SysInfoKey;
              a01kw                : tak_keywordtab;
              a01_i_rc             : tsp00_KnlIdentifier;
              a01_i_count          : tsp00_KnlIdentifier;
              a01_i_cursor         : tsp00_KnlIdentifier;
              a01_i_errmsg         : tsp00_KnlIdentifier;
              a01_i_tablekey       : tsp00_KnlIdentifier;
              a01_il_b_identifier  : tsp00_KnlIdentifier;
 
        FUNCTION
              a01equal_char (VAR m : tsp00_KnlIdentifier;
                    pos      : tsp00_Int4;
                    cmp_char : char) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07ak_system_error (VAR acv : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
        PROCEDURE
              a07_b_put_error (VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06determine_username (VAR acv : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06extcolno (
                    VAR baserec     : tak_baserecord;
                    extcolno        : integer;
                    VAR colinfo_ptr : tak00_colinfo_ptr);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06_systable_get (VAR acv : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR tableid  : tgg00_Surrogate;
                    VAR base_ptr : tak_sysbufferaddress;
                    get_all      : boolean;
                    VAR ok       : boolean);
 
        FUNCTION
              a06_table_exist (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR schema   : tsp00_KnlIdentifier;
                    VAR tablen   : tsp00_KnlIdentifier;
                    VAR sparr    : tak_syspointerarr;
                    get_all      : boolean) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061assign_colname (value : tsp00_C18;
                    VAR id : tsp00_KnlIdentifier);
 
        FUNCTION
              a061exist_columnname (VAR base_rec : tak_baserecord;
                    VAR column      : tsp00_KnlIdentifier;
                    VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
        PROCEDURE
              a061get_colname (VAR col_info : tak00_columninfo;
                    VAR colname  : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10get_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10next_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    stop_prefix  : integer;
                    dstate       : tak_directory_state;
                    rec_kind     : tsp00_C2;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              SQLManager : vak101;
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
        FUNCTION
              a101_GetExtendedTempFileType(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tgg00_TfnTemp;
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate (* ptocConst *);
                    VAR schemaName : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_Domain : VAK12;
 
        FUNCTION
              a12dbproc_exist (VAR acv : tak_all_command_glob;
                    VAR owner      : tsp00_KnlIdentifier;
                    VAR dbproc     : tsp00_KnlIdentifier;
                    dstate         : tak_directory_state;
                    VAR method_buf : tak_sysbufferaddress) : boolean;
 
        FUNCTION
              a12dbfunc_exist (VAR acv : tak_all_command_glob;
                    VAR owner       : tsp00_KnlIdentifier;
                    VAR dbfunc_name : tsp00_KnlIdentifier;
                    dstate          : tak_directory_state;
                    VAR method_buf  : tak_sysbufferaddress) : boolean;
 
        PROCEDURE
              a12LoadFileInfo (
                    VAR acv               : tak_all_command_glob;
                    VAR dbproc_id         : tgg00_Surrogate;
                    VAR pFileName         : tsp00_MoveObjPtr;
                    VAR MD5_footprint     : tsp00_C32);
 
      ------------------------------ 
 
        FROM
              AK_dialog_tools : VAK260;
 
        PROCEDURE
              a260check_priv (VAR acv : tak_all_command_glob;
                    proc_id     : tgg00_Surrogate;
                    VAR user_id : tgg00_Surrogate);
 
        PROCEDURE
              a260GetDBProcOwner (
                    VAR acv          : tak_all_command_glob;
                    VAR MethodRecord : tak_methodrecord;
                    VAR OwnerId      : tgg00_Surrogate);
 
        FUNCTION
              a260IsInternalDBProc(VAR MethodRec : tak_methodrecord) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Trigger : VAK262;
 
        PROCEDURE
              a262exist_trigger (VAR acv : tak_all_command_glob;
                    VAR trigger_name    : tsp00_KnlIdentifier;
                    VAR trigger_ptr_arr : tak_syspointerarr;
                    VAR trigger_kind    : tgg00_Linkset);
 
        PROCEDURE
              a262get_trigger_name (VAR trigger_rec : tak_triggerrecord;
                    VAR trigger_name : tsp00_KnlIdentifier;
                    VAR b_err        : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              AK_universal_show_tools : VAK40;
 
        VAR
              a40yes_no : ARRAY[boolean] OF tsp00_C3;
 
        PROCEDURE
              a40datatype_code (
                    VAR col_info : tak00_columninfo;
                    is_oracle    : boolean;
                    comp_type    : tak_appl_type;
                    VAR datatype : tsp00_Sname;
                    VAR code     : tsp00_C10;
                    VAR datalen  : integer);
 
        PROCEDURE
              a40get_catalog_table (VAR acv : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a40comment_descriptor (VAR acv : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    comment_exist : boolean;
                    VAR tabid     : tgg00_Surrogate;
                    column_no     : integer;
                    comment_kind  : tak_comment_type);
 
        PROCEDURE
              a40ignore_down_error (VAR acv : tak_all_command_glob);
 
        FUNCTION (* PTS 1109280 *)
              a40is_unique (VAR acv  : tak_all_command_glob;
                    VAR distinct_tree : tgg00_FileId;
                    VAR tabid         : tgg00_Surrogate;
                    check_only        : boolean) : boolean;
 
        PROCEDURE
              a40move (VAR acv  : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : integer);
 
        PROCEDURE
              a40move_const (VAR acv  : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : integer);
 
        PROCEDURE
              a40move_guid (VAR acv : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    VAR guid    : tsp00_C16);
 
        PROCEDURE
              a40move_i4 (VAR acv : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    i4_val        : tsp00_Int4;
                    is_null       : boolean;
                    frac          : integer;
                    zero_to_undef : boolean);
 
        PROCEDURE
              a40long_descriptor (VAR acv : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    VAR tabid    : tgg00_Surrogate;
                    column_no    : integer);
 
        PROCEDURE
              a40put_date_time (VAR acv : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    VAR datetime : tsp00_Int4;
                    date         : boolean;
                    is_undef     : boolean);
 
        PROCEDURE
              a40table_column_to_shbuf (VAR acv : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    base_ptr     : tak_sysbufferaddress;
                    colindex     : integer;
                    with_owner   : boolean);
 
      ------------------------------ 
 
        FROM
              AK_show_syntax : VAK41;
 
        PROCEDURE
              a41init_show_glob (VAR a41v : tak40_show_glob;
                    mess_code : tsp00_CodeType);
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51build_userkey (VAR user_name : tsp00_KnlIdentifier;
                    VAR userkey : tgg00_SysInfoKey);
 
      ------------------------------ 
 
        FROM
              Catalog_Select_Optimizer : VAK722;
 
        FUNCTION
              a722test_col_qual (
                    VAR acv   : tak_all_command_glob;
                    VAR a41v  : tak40_show_glob;
                    colname   : tak_oldidentifier;
                    def_byte  : char;
                    value_ptr : tsp00_MoveObjPtr;
                    value_len : integer;
                    work_buf  : tak40_int2_arr_ptr) : boolean;
 
        PROCEDURE
              a722init_epos_reccol_relation(
                    VAR acv       : tak_all_command_glob;
                    VAR pos_info  : tak40_int2_arr_ptr);
 
        PROCEDURE
              a722finalize_epos_reccol_relation(
                    VAR acv       : tak_all_command_glob;
                    VAR pos_info  : tak40_int2_arr_ptr);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        PROCEDURE
              b01tcreate_file (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01unicode        : boolean;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30eq (VAR a,b : tsp00_KnlIdentifier;
                    bi,cnt : tsp00_Int4) : boolean;
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              a12LoadFileInfo;
 
              tsp00_Addr tsp00_MoveObjPtr;
 
        FUNCTION
              a01equal_char;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        FUNCTION
              s30eq;
 
              tsp00_MoveObj   tsp00_KnlIdentifier
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ThomasA
.sp
.cp 3
Created : 1985-03-01
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-09-19
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.sp 3
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
.sp 2
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_null          = true;
      c_to_undef      = true;
      c_with_owner    = true;
 
TYPE
      tak49col_header = (no_header, new_header, old_header);
 
 
(*------------------------------*) 
 
PROCEDURE
      a49execute (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
BEGIN
a40get_catalog_table (acv, a41v);
CASE a41v.a4sh_kind OF
    sh_all_procedures :
        a07_b_put_error (acv, e_not_implemented, 1);
    sh_dbfunctions, sh_dbfunc_parameters :
        ak49dbfunctions (acv, a41v);
    sh_param_dbproc, sh_procedure :
        ak49all_user_procedures (acv, a41v, a41v.a4authname, 0,
              a41v.a4tablen, 0);
    sh_trigger :
        a49one_table_trigger (acv, a41v, 0);
    sh_methods :
        ak49methods (acv, a41v);
    sh_variables :
        ak49variables (acv, a41v);
    OTHERWISE
        a07_b_put_error (acv, e_not_implemented, 1)
    END;
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a49trigger_param (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
CONST
      c_found = csp_maxint2;
 
VAR
      b_err         : tgg00_BasisError;
      ix            : integer;
      jx            : integer;
      trigger_cnt   : integer;
      methodbuf     : tak_sysbufferaddress;
      methodinfobuf : tak_sysbufferaddress;
      trigger_arr   : tak_syspointerarr;
      trigger_kind  : tgg00_Linkset;
      blankname     : tsp00_KnlIdentifier;
      curr_trig_name: tsp00_KnlIdentifier;
      trigger_names : ARRAY[1..3] OF tsp00_KnlIdentifier;
      methodkey     : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a41v DO
    IF  a4p_arr.pbasep^.sbase.blinkexist *
        [del_trigger, ins_trigger, upd_trigger] <> []
    THEN
        BEGIN
        a_p_arr1  := a4p_arr;
        blankname := a01_il_b_identifier;
        a262exist_trigger (acv, blankname, trigger_arr, trigger_kind);
        ix          := 1;
        trigger_cnt := 0;
        WHILE (ix <= trigger_arr.pcount) AND
              (a_returncode = 0) DO
            BEGIN
            WITH trigger_arr.px[ix]^.strigger DO
                BEGIN
                a262get_trigger_name (trigger_arr.px[ix]^.strigger,
                      curr_trig_name,
                      a_returncode);
                jx := 1;
                WHILE jx <= trigger_cnt DO
                    BEGIN
                    IF  curr_trig_name = trigger_names[jx]
                    THEN
                        jx := c_found
                    ELSE
                        jx := jx + 1;
                    (*ENDIF*) 
                    END;
                (*ENDWHILE*) 
                IF  (jx < c_found) AND
                    (a_returncode = 0)
                THEN
                    BEGIN
                    trigger_cnt                := trigger_cnt + 1;
                    trigger_names[trigger_cnt] := curr_trig_name;
                    methodkey                  := a01defaultkey;
                    methodkey.stableid         := trigger_arr.px[jx]^.strigger.tr_proc_id;
                    methodkey.sentrytyp        := cak_emethod;
                    a10get_sysinfo (acv, methodkey, d_release,
                          methodbuf, b_err);
                    IF  b_err = e_ok
                    THEN
                        BEGIN
                        methodkey.sentrytyp := cak_emethodinfo;
                        a10get_sysinfo (acv, methodkey, d_release,
                              methodinfobuf, b_err)
                        END;
                    (*ENDIF*) 
                    IF  b_err = e_ok
                    THEN
                        ak49one_proc_params (acv, a41v,
                              curr_trig_name, methodbuf, methodinfobuf);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
            ix := ix + 1
            END;
        (*ENDWHILE*) 
        FOR ix := 1 TO trigger_arr.pcount DO
            a10rel_sysinfo (trigger_arr.px[ix])
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a49get_trigger_def (VAR acv : tak_all_command_glob;
            VAR tabid    : tgg00_Surrogate;
            trigger_kind : tgg00_Linkset;
            VAR def_len  : tsp00_Int2;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4);
 
VAR
      ok    : boolean;
      b_err : tgg00_BasisError;
      sysk  : tgg00_SysInfoKey;
      a41v  : tak40_show_glob;
 
BEGIN
a06_systable_get (acv, d_release, tabid,
      acv.a_p_arr1.pbasep, true, ok);
IF  ok
THEN
    BEGIN
    a41init_show_glob (a41v,
          acv.a_out_packet^.sp1_header.sp1h_mess_code);
    sysk           := acv.a_p_arr1.pbasep^.syskey;
    sysk.sentrytyp := cak_etrigger;
    IF  ins_trigger in trigger_kind
    THEN
        sysk.slinkage := cak_ins_trigger_linkage
    ELSE
        IF  upd_trigger in trigger_kind
        THEN
            sysk.slinkage := cak_upd_trigger_linkage
        ELSE
            sysk.slinkage := cak_del_trigger_linkage;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  internal_trigger in trigger_kind
    THEN
        sysk.slinkage[2] := chr(ord(sysk.slinkage[2]) + 10);
    (*ENDIF*) 
    a10get_sysinfo (acv, sysk, d_release, acv.a_p_arr2.px[1], b_err);
    IF  b_err = e_ok
    THEN
        BEGIN
        a06determine_username (acv, acv.a_p_arr1.pbasep^.sbase.bauthid,
              a41v.a4authname);
        a41v.a4tablen := acv.a_p_arr1.pbasep^.sbase.btablen^;
        IF  acv.a_p_arr2.px[1]^.strigger.tr_language <> lang_pl
        THEN
            BEGIN
            ak49build_trigger_def (acv, a41v, trigger_kind, buf, buf_size);
            def_len := a41v.a4col_len
            END
        ELSE
            ak49get_create_trigger_stmt (acv, a41v, buf, buf_size, def_len);
        (*ENDIF*) 
        END
    ELSE
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
    END
ELSE
    a07ak_system_error (acv, 49, 2)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak49dbfunctions (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      full_spec   : boolean;
      func_exist  : boolean;
      b_err       : tgg00_BasisError;
      methodbuf   : tak_sysbufferaddress;
      sysbuf      : tak_sysbufferaddress;
      sysk        : tgg00_SysInfoKey;
      method_sysk : tgg00_SysInfoKey;
 
BEGIN
IF  a41v.a4authname <> a01_il_b_identifier
THEN
    BEGIN
    full_spec := true;
    func_exist := a12dbfunc_exist (acv, acv.a_curr_user_name, a41v.a4authname, d_release, sysbuf);
    IF  func_exist
    THEN
        BEGIN
        sysk := sysbuf^.syskey;
        sysk.sauthid[sizeof(sysk.sauthid)] := chr (
              ord (sysk.sauthid[sizeof(sysk.sauthid)]) - 1)
        END
    (*ENDIF*) 
    END
ELSE
    BEGIN
    full_spec      := false;
    func_exist     := true;
    sysk           := a01defaultkey;
    sysk.ssite     := cak_dbfunc_site
    END;
(*ENDIF*) 
IF  func_exist
THEN
    BEGIN
    sysk.sentrytyp := cak_emethodinfo;
    REPEAT
        a10next_sysinfo (acv, sysk, sizeof (sysk.ssite), d_fix,
              cak_emethodinfo, sysbuf, b_err);
        IF  b_err = e_ok
        THEN
            BEGIN
            IF  a41v.a4sh_kind = sh_dbfunctions
            THEN
                ak49one_dbfunction (acv, a41v, sysbuf)
            ELSE
                BEGIN
                SAPDB_PascalForcedMove (sizeof (sysk), sizeof (method_sysk),
                      @sysk, 1, @method_sysk, 1, cak_sysbufferoffset);
                method_sysk.sentrytyp := cak_emethod;
                a10get_sysinfo (acv, method_sysk,
                      d_release, methodbuf, b_err);
                IF  b_err = e_ok
                THEN
                    ak49one_proc_params (acv, a41v, a01_il_b_identifier, methodbuf, sysbuf)
                ELSE
                    a07_b_put_error (acv, b_err, 1)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            a10rel_sysinfo (sysbuf)
            END;
        (*ENDIF*) 
    UNTIL
        (b_err <> e_ok) OR full_spec OR
        (acv.a_returncode <> 0);
    (*ENDREPEAT*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak49all_user_procedures (VAR acv : tak_all_command_glob;
            VAR a41v      : tak40_show_glob;
            VAR auth_spec : tsp00_KnlIdentifier;
            auth_len      : integer;
            VAR proc_spec : tsp00_KnlIdentifier;
            proc_len      : integer);
 
VAR
      exists      : boolean;
      b_err       : tgg00_BasisError;
      i           : integer;
      usertab_ptr : tak_sysbufferaddress;
      procbuf     : tak_sysbufferaddress;
      methodrefbuf: tak_sysbufferaddress;
      owner       : tgg00_Surrogate;
      sysk        : tgg00_SysInfoKey;
      dbproc_sysk : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
    IF  ((auth_spec <> a01_il_b_identifier) AND
        (proc_spec <> a01_il_b_identifier))
        OR
        ((auth_len = sizeof (tsp00_KnlIdentifier)) AND
        ( proc_len = sizeof (tsp00_KnlIdentifier)))
    THEN (*== full DB_procedure specification =================*)
        BEGIN
        exists := a12dbproc_exist (acv,
              auth_spec, proc_spec, d_release, procbuf);
        IF  NOT exists
        THEN
            exists := a12dbfunc_exist (acv,
                  auth_spec, proc_spec, d_release, procbuf);
        (*ENDIF*) 
        IF  exists
        THEN
            BEGIN
            (*== check privileges =========================*)
            a260GetDBProcOwner (acv, procbuf^.smethod, owner);
            IF  owner <> a_curr_user_id
            THEN
                BEGIN
                (*== check call privilege of current user ==*)
                a260check_priv (acv,
                      procbuf^.smethod.me_surrogate, a_curr_user_id);
                END;
            (*=============================================*)
            (* insert procedure information into the       *)
            (* show file                                   *)
            (*=============================================*)
            (*ENDIF*) 
            IF  acv.a_returncode = 0
            THEN
                ak49one_procedure (acv, a41v, procbuf)
            (*ENDIF*) 
            END;
        (* PTS 1117453 E.Z. *)
        (*ENDIF*) 
        IF  a_returncode <> 0
        THEN
            BEGIN
            IF  (acv.a_returncode = a071_return_code (e_unknown_procedure_name, acv.a_sqlmode)) OR
                (acv.a_returncode = a071_return_code (e_unknown_sql_schema,     acv.a_sqlmode))
            THEN
                acv.a_returncode := 0
            ELSE
                a40ignore_down_error (acv);
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    ELSE (*== incomplete DB_procedure specification ===========*)
        IF  a_ex_kind <> only_parsing
        THEN
            BEGIN
            (* PTS 1109280 *)
            a41v.a4unique := true;
            a41v.a4treeid := a_into_tree;
            IF  a101_IsExtendedTempFile (acv, a41v.a4strategy.str_result_id)
                AND
                (a101_GetExtendedTempFileType (acv,
                a41v.a4strategy.str_result_id) = ttfnInto_egg00)
            THEN
                BEGIN
                (* cannot use a_into_tree as distinct file *)
                (* TODO: a101_SetTempFileIndex can be removed -unless it turns out *)
                (* that it needs to be grouped- since the file will be destroyed   *)
                (* later on (it will be destroyed in vak41)                        *)
                (* a101_SetTempFileIndex (acv, a41v.a4treeid,
                      a101_GetTempFileIndex (acv, a41v.a4treeid) + 1);
                      *)
                b01tcreate_file (a_transinf.tri_trans, a41v.a4treeid);
                IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
                THEN
                    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
                (*ENDIF*) 
                END;
            (* END PTS 1109280 *)
            (*ENDIF*) 
            dbproc_sysk           := a01defaultkey;
            dbproc_sysk.sentrytyp := cak_emethod;
            sysk                  := a01defaultkey;
            sysk.sauthid          := a_curr_user_id;
            sysk.sentrytyp        := cak_emethodref;
            REPEAT
                a10next_sysinfo (acv, sysk, 10,
                      d_release, cak_emethodref, methodrefbuf, b_err);
                IF  b_err = e_ok
                THEN
                    BEGIN
                    dbproc_sysk.stableid :=
                          methodrefbuf^.smethodref.mrf_method_id;
                    (*
                          IF  methodrefbuf^.smethodref.mrf_type = dbo_dbproc
                          THEN
                          BEGIN
                          *)
                    a10get_sysinfo (acv, dbproc_sysk,
                          d_release, procbuf, b_err);
                    IF  b_err = e_ok
                    THEN
                        ak49one_procedure (acv, a41v, procbuf);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            UNTIL
                b_err <> e_ok;
            (*ENDREPEAT*) 
            sysk                  := a01defaultkey;
            sysk.sauthid          := a_curr_user_id;
            sysk.sentrytyp        := cak_eusertab;
            (*=======================================================*)
            (* Scan usertab records of curr user and PUBLIC to find  *)
            (* out all stored dbprocs visible for the current user   *)
            (*=======================================================*)
            REPEAT
                a10get_sysinfo (acv, sysk, d_fix, usertab_ptr, b_err);
                IF  b_err = e_ok
                THEN
                    WITH usertab_ptr^.susertab DO
                        BEGIN
                        i := 1;
                        WHILE (i <= usertabcount) AND
                              (a_returncode = 0) DO
                            WITH usertabdef[i] DO
                                BEGIN
                                IF  NOT ut_empty AND
                                    (ut_kind = ut_procedure)
                                THEN
                                    BEGIN
                                    (*============================*)
                                    (* usertab entry contains the *)
                                    (* surrogate of a dbprocedure *)
                                    (*============================*)
                                    dbproc_sysk.stableid := ut_surrogate;
                                    a10get_sysinfo (acv, dbproc_sysk,
                                          d_release, procbuf, b_err);
                                    IF  b_err = e_ok
                                    THEN
                                        (*============================*)
                                        (* insert dbproc information  *)
                                        (* into the show file         *)
                                        (*============================*)
                                        ak49one_procedure (acv,
                                              a41v, procbuf)
                                    (*ENDIF*) 
                                    END;
                                (*ENDIF*) 
                                i := succ(i);
                                END;
                            (*ENDWITH*) 
                        (*ENDWHILE*) 
                        (* release usertab record *)
                        a10rel_sysinfo (usertab_ptr);
                        IF  usertabnext_exist
                        THEN (* current record has a successor record *)
                            a06inc_linkage (sysk.slinkage)
                        ELSE
                            b_err := e_no_next_record;
                        (*ENDIF*) 
                        END
                    (*ENDWITH*) 
                ELSE
                    IF  b_err = e_sysinfo_not_found
                    THEN
                        b_err := e_no_next_record;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  (b_err = e_no_next_record) AND
                    (sysk.sauthid <> cak_public_id)
                THEN
                    BEGIN (* scan PUBLIC tusertab records *)
                    b_err         := e_ok;
                    sysk.sauthid  := cak_public_id;
                    sysk.slinkage := cak_init_linkage
                    END;
                (*ENDIF*) 
            UNTIL
                b_err <> e_ok;
            (*ENDREPEAT*) 
            IF  b_err <> e_no_next_record
            THEN
                a07_b_put_error (acv, b_err, 1);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak49one_dbfunction (VAR acv : tak_all_command_glob;
            VAR a41v         : tak40_show_glob;
            procbuf          : tak_sysbufferaddress);
 
VAR
      owner : tsp00_KnlIdentifier;
 
BEGIN
WITH procbuf^.smethodinfo DO
    BEGIN
    a40move          (acv, a41v, @mei_name, sizeof (mei_name));
    a40put_date_time (acv, a41v, mei_date, true,  false);
    a40put_date_time (acv, a41v, mei_time, false, false);
    a06determine_username (acv, mei_owner, owner);
    a40move          (acv, a41v, @owner, sizeof (owner));
    a40move          (acv, a41v, @mei_prog_id, sizeof (mei_prog_id));
    a40comment_descriptor (acv, a41v, mei_comment,
          mei_surrogate, 1, cm_dbproc)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak49methods (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      b_err  : tgg00_BasisError;
      sysbuf : tak_sysbufferaddress;
      sysk   : tgg00_SysInfoKey;
 
BEGIN
sysk       := a01defaultkey;
sysk.ssite := cak_type_site;
REPEAT
    a10next_sysinfo (acv, sysk, sizeof (sysk.ssite), d_fix,
          cak_edomain, sysbuf, b_err);
    IF  b_err = e_ok
    THEN
        ak49type_methods (acv, a41v, sysbuf);
    (*ENDIF*) 
UNTIL
    b_err <> e_ok;
(*ENDREPEAT*) 
IF  b_err <> e_no_next_record
THEN
    a07_b_put_error (acv, b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak49type_methods (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            type_buf : tak_sysbufferaddress);
 
VAR
      b_err         : tgg00_BasisError;
      sysbuf        : tak_sysbufferaddress;
      methodinfobuf : tak_sysbufferaddress;
      next_sysk     : tgg00_SysInfoKey;
      methodkey     : tgg00_SysInfoKey;
      method_owner  : tsp00_KnlIdentifier;
 
BEGIN
a07_b_put_error (acv, e_not_implemented, 1);
&ifdef UDT
(* Describes all methods of type identified by type_buf *)
next_sysk           := type_buf^.syskey;
next_sysk.sentrytyp := cak_emethodref;
REPEAT
    a10next_sysinfo (acv, next_sysk,
          mxak_standard_sysk, d_fix,
          cak_emethodref, sysbuf, b_err);
    IF  b_err = e_ok
    THEN
        BEGIN
        methodkey           := a01defaultkey;
        methodkey.stableid  := sysbuf^.smethodref.mrf_method_id;
        methodkey.sentrytyp := cak_emethod;
        a10get_sysinfo (acv, methodkey, d_release, sysbuf, b_err);
        IF  b_err = e_ok
        THEN
            BEGIN
            methodkey.sentrytyp := cak_emethodinfo;
            a10get_sysinfo (acv, methodkey, d_release, methodinfobuf, b_err)
            END;
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            BEGIN
            a06determine_username (acv,
                  methodinfobuf^.smethodinfo.mei_owner, method_owner);
            a40move (acv, a41v, @method_owner, sizeof (method_owner));
            a40move (acv, a41v,
                  @type_buf^.sdomain.dom_colinfo.ccolumnn,
                  sizeof (type_buf^.sdomain.dom_colinfo.ccolumnn));
            a40move (acv, a41v, @next_sysk.sappl, sizeof (next_sysk.sappl));
            a40move (acv, a41v, @methodinfobuf^.smethodinfo.mei_prog_id,
                  sizeof (methodinfobuf^.smethodinfo.mei_prog_id));
            a40move_i4 (acv, a41v, sysbuf^.smethod.me_dispid,
                  NOT c_null, 0, NOT c_to_undef);
            a40move (acv, a41v, @sysbuf^.smethod.me_coclsid,
                  sizeof (sysbuf^.smethod.me_coclsid));
            a40move (acv, a41v, @sysbuf^.smethod.me_iid,
                  sizeof (sysbuf^.smethod.me_iid))
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
UNTIL
    b_err <> e_ok;
(*ENDREPEAT*) 
IF  b_err <> e_no_next_record
THEN
    a07_b_put_error (acv, b_err, 1)
&         endif
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak49one_proc_params (VAR acv : tak_all_command_glob;
            VAR a41v         : tak40_show_glob;
            VAR trigger_name : tsp00_KnlIdentifier;
            procbuf          : tak_sysbufferaddress;
            procinfobuf      : tak_sysbufferaddress);
 
VAR
      is_old        : boolean;
      is_new        : boolean;
      colno         : integer;
      param_no      : integer;
      param_index   : integer;
      fraction      : integer;
      code          : tsp00_C8;
      move_text     : tsp00_C10;
      null_length   : boolean;
 
BEGIN
(*=================================================*)
(* SHOW PARAM                                      *)
(*=================================================*)
null_length := false;
WITH acv, a41v DO
    BEGIN
    IF  a_returncode = 0
    THEN
        WITH procbuf^.smethod, procinfobuf^.smethodinfo DO
            IF  me_param_cnt > 0
            THEN
                BEGIN
                CASE a4sh_kind OF
                    sh_param_trigger :
                        BEGIN
                        (* OWNER, TABLENAME into result row *)
                        a40table_column_to_shbuf (acv,
                              a41v, a4p_arr.pbasep, -1, c_with_owner);
                        (* TRIGGERNAME into result row  *)
                        a40move (acv, a41v, @trigger_name,
                              sizeof (trigger_name))
                        END;
                    sh_param_dbproc, sh_dbfunc_parameters  :
                        ak49put_dbproc (acv, a41v, procinfobuf);
                    END;
                (*ENDCASE*) 
                a40put_date_time (acv, a41v, mei_date, true,  false);
                a40put_date_time (acv, a41v, mei_time, false, false)
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    colno    := a4pos;
    param_no := 0;
    IF  a_returncode = 0
    THEN
        BEGIN
        WITH procbuf^.smethod DO
            FOR param_index := 1 TO me_param_cnt DO
                BEGIN
                WITH me_param_list[ param_index ]^ DO
                    BEGIN
                    a4pos    := colno;
                    IF  ord (param_name_len) > 0
                    THEN (* PTS 1108487 *)
                        param_no := param_no + 1;
                    (*ENDIF*) 
                    a40move_i4 (acv, a41v, param_no,
                          NOT c_null, 0, NOT c_to_undef);
                    (*= PARAMETERNAME ========================*)
                    IF  a41v.a4sh_kind = sh_param_trigger
                    THEN
                        BEGIN
                        IF  ord (param_name_len) > 3
                        THEN
                            BEGIN
                            is_old :=
                                  (param_name[1] = 'O') AND
                                  (param_name[2] = 'L') AND
                                  (param_name[3] = 'D');
                            is_new :=
                                  (param_name[1] = 'N') AND
                                  (param_name[2] = 'E') AND
                                  (param_name[3] = 'W');
                            END
                        ELSE
                            BEGIN
                            is_old := false;
                            is_new := false
                            END;
                        (*ENDIF*) 
                        (*= NEW/OLD-TYPE =========================*)
                        IF  is_old OR is_new
                        THEN
                            a40move (acv, a41v, @param_name[4],
                                  ord (param_name_len) - 3)
                        ELSE
                            a40move (acv, a41v, @param_name,
                                  ord (param_name_len));
                        (*ENDIF*) 
                        IF  is_new
                        THEN
                            move_text := 'NEW       '
                        ELSE
                            IF  is_old
                            THEN
                                move_text := 'OLD       '
                            ELSE
                                move_text := '          ';
                            (*ENDIF*) 
                        (*ENDIF*) 
                        a40move_const (acv, a41v, @move_text,
                              sizeof (move_text))
                        END
                    ELSE
                        BEGIN
                        a40move (acv, a41v, @param_name,
                              ord (param_name_len));
                        (*= IN/OUT-TYPE ==========================*)
                        CASE param_in_out[2] OF
                            csp_info_input :
                                move_text := 'IN        ';
                            csp_info_output :
                                move_text := '   OUT    ';
                            csp_info_inout :
                                move_text := 'IN/OUT    ';
                            OTHERWISE
                                move_text := '          ';
                            END;
                        (*ENDCASE*) 
                        a40move_const (acv, a41v, @move_text,
                              sizeof (move_text))
                        END;
                    (*ENDIF*) 
                    (*= DATATYPE =============================*)
                    IF  param_com_datatype = csp1_vt_userdefined (* PTS 1108487 *)
                    THEN
                        BEGIN
                        move_text := 'STRUCTURE ';
                        fraction  := param_datafrac;
                        END
                    ELSE
                        BEGIN
                        fraction      := param_datafrac - cak_frac_offset;
                        CASE param_datatype OF
                            dboolean :
                                move_text := 'BOOLEAN   ';
                            dfixed :
                                move_text := 'FIXED     ';
                            dfloat :
                                move_text := 'FLOAT     ';
                            dinteger :
                                move_text := 'INTEGER   ';
                            dcha, dchb, dunicode :
                                move_text := 'CHAR      ';
                            ddate :
                                move_text := 'DATE      ';
                            dsmallint :
                                move_text := 'SMALLINT  ';
                            dtime :
                                move_text := 'TIME      ';
                            dtimestamp :
                                move_text := 'TIMESTAMP ';
                            dudt :
                                move_text := 'UDT       ';
                            dwyde :
                                move_text := 'WYDE      ';
                            dstra,dstrb,dstruni:
                                BEGIN
                                move_text := 'LONG      ';
                                null_length := true
                                END;
                            dlonga,dlongb,dlonguni:
                                BEGIN
                                move_text := 'LONG      ';
                                null_length := true
                                END;
                            dabaptabhandle :
                                BEGIN
                                move_text     := 'ABAPTABLE ';
                                fraction      := 0
                                END;
                            OTHERWISE
                                move_text := '          ';
                            END;
                        (*ENDCASE*) 
                        END;
                    (*ENDIF*) 
                    a40move_const (acv, a41v, @move_text,
                          sizeof (move_text));
                    (*= LEN ==================================*)
                    a40move_i4 (acv, a41v, param_datalength,
                          null_length, 0, NOT c_to_undef);
                    (*= DEC ==================================*)
                    a40move_i4 (acv, a41v, fraction,
                          NOT c_null, 0, NOT c_to_undef);
                    a40move_i4 (acv, a41v, param_cpp_offset,
                          NOT c_null, 0, NOT c_to_undef);
                    IF  a41v.a4sh_kind = sh_param_dbproc
                    THEN
                        BEGIN
                        IF  a260IsInternalDBProc (procbuf^.smethod)
                        THEN
                            BEGIN
                            a40move (acv, a41v, NIL, 0);
                            a40move (acv, a41v, NIL, 0);
                            END
                        ELSE
                            BEGIN
                            a40move_i4 (acv, a41v, param_ascii_offset,
                                  NOT c_null, 0, NOT c_to_undef);
                            a40move_i4 (acv, a41v, param_unicode_offset,
                                  NOT c_null, 0, NOT c_to_undef);
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    CASE param_datatype OF
                        dcha,dlonga,dstra:
                            code := 'ASCII   ';
                        dchb,dlongb,dstrb :
                            code := 'BYTE    ';
                        dunicode,dlonguni,dstruni :
                            code := 'UNICODE ';
                        OTHERWISE
                            code := bsp_c8;
                        END;
                    (*ENDCASE*) 
                    a40move_const (acv, a41v, @code,
                          sizeof (code));
                    END;
                (*ENDWITH*) 
                END;
            (*ENDFOR*) 
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak49move_package (VAR acv : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            VAR id   : tgg00_Surrogate);
 
VAR
      b_err       : tgg00_BasisError;
      methodp     : tak_sysbufferaddress;
      methodinfop : tak_sysbufferaddress;
      sysk        : tgg00_SysInfoKey;
 
BEGIN
sysk.stableid  := id;
sysk.sentrytyp := cak_emethod;
sysk.slinkage  := cak_init_linkage;
sysk.skeylen   := a01defaultkey.skeylen;
a10get_sysinfo (acv, sysk, d_release, methodp, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    sysk.sentrytyp := cak_emethodinfo;
    a10get_sysinfo (acv, sysk, d_release, methodinfop, b_err);
    END;
(*ENDIF*) 
IF  b_err = e_ok
THEN
    a40move (acv, a41v, @methodinfop^.smethodinfo.mei_name,
          sizeof (methodinfop^.smethodinfo.mei_name))
ELSE
    a07_b_put_error (acv, b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak49one_procedure (VAR acv : tak_all_command_glob;
            VAR a41v         : tak40_show_glob;
            procbuf          : tak_sysbufferaddress);
 
VAR
      skipProcedure    : boolean;
      b_err            : tgg00_BasisError;
      isInternalDBProc : boolean;
      paramCnt         : integer;
      paramIndex       : integer;
      fileNameLength   : integer;
      dbprocinfop      : tak_sysbufferaddress;
      sysk             : tgg00_SysInfoKey;
      c6               : tsp00_C6;
      c8               : tsp00_C8;
      pFileName        : tsp00_MoveObjPtr;
      MD5_footprint    : tsp00_C32;
 
BEGIN
IF  a41v.a4unique
THEN
    skipProcedure := NOT a40is_unique (acv, a41v.a4treeid, procbuf^.syskey.stableid, false)
ELSE
    skipProcedure := false;
(*ENDIF*) 
IF  NOT skipProcedure
THEN
    BEGIN  (* PTS 1109280 *)
    sysk           := procbuf^.syskey;
    sysk.sentrytyp := cak_emethodinfo;
    a10get_sysinfo (acv, sysk, d_release, dbprocinfop, b_err);
    IF  b_err = e_ok
    THEN
        IF  a41v.a4sh_kind = sh_procedure
        THEN
            WITH acv, a41v, procbuf^.smethod, dbprocinfop^.smethodinfo DO
                BEGIN
                ak49put_dbproc (acv, a41v, dbprocinfop);
                isInternalDBProc := a260IsInternalDBProc (procbuf^.smethod);
                IF  NOT isInternalDBProc
                THEN
                    ak49move_package (acv, a41v, me_package_id)
                ELSE
                    a40move (acv, a41v, NIL, 0);
                (*ENDIF*) 
                IF  NOT isInternalDBProc AND (me_param_cnt > 0)
                THEN
                    BEGIN (* PTS 1113358, eval user defined number of parameters *)
                    paramCnt := 0;
                    FOR paramIndex := 1 TO me_param_cnt DO
                        IF  ord (me_param_list[paramIndex]^.param_name_len) > 0
                        THEN
                            paramCnt := paramCnt + 1;
                        (*ENDIF*) 
                    (*ENDFOR*) 
                    END
                ELSE
                    paramCnt := me_param_cnt;
                (*ENDIF*) 
                a40move_i4 (acv, a41v, paramCnt,
                      NOT c_null, 0, NOT c_to_undef);
                a40put_date_time (acv, a41v, mei_date, true,  false);
                a40put_date_time (acv, a41v, mei_time, false, false);
                IF  isInternalDBProc
                THEN
                    BEGIN
                    a40move (acv, a41v, NIL, 0);
                    CASE me_type OF
                        dbo_dbproc :
                            c8 := 'DBPROC  ';
                        dbo_dbfunc :
                            c8 := 'DBFUNC  ';
                        dbo_package :
                            c8 := 'PACKAGE ';
                        dbo_system_trigger :
                            c8 := 'SYSTEM  ';
                        END;
                    (*ENDCASE*) 
                    a40move_const (acv, a41v, @c8, sizeof (c8));
                    IF  me_language = lang_other
                    THEN
                        a40move (acv, a41v, @mei_language, sizeof(mei_language))
                    ELSE
                        BEGIN
                        CASE me_language OF
                            lang_cpp  :
                                c8 := 'C++     ';
                            lang_pl   :
                                c8 := 'SPL     ';
                            lang_java :
                                c8 := 'JAVA    ';
                            lang_system :
                                c8 := 'SYSTEM  ';
                            OTHERWISE :
                                c8 := 'OTHER   ';
                            END;
                        (*ENDCASE*) 
                        a40move_const (acv, a41v, @c8, sizeof (c8));
                        END;
                    (*ENDIF*) 
                    a40move_const (acv, a41v,
                          @a40yes_no[me_sql OR (me_type <> dbo_dbfunc)], sizeof (a40yes_no[me_sql]));
                    a40move_const (acv, a41v,
                          @a40yes_no[me_cursor AND (me_type = dbo_dbproc)], sizeof (a40yes_no[me_cursor]));
                    IF  me_type = dbo_dbfunc
                    THEN
                        a40move_const (acv, a41v,
                              @a40yes_no[me_deterministic], sizeof (a40yes_no[me_deterministic]))
                    ELSE
                        a40move (acv, a41v, NIL, 0);
                    (*ENDIF*) 
                    a40move (acv, a41v, NIL, 0);
                    a40move (acv, a41v, NIL, 0);
                    a40move (acv, a41v, NIL, 0);
                    a40move (acv, a41v, NIL, 0);
                    a40move (acv, a41v, NIL, 0);
                    a40move_const (acv, a41v, @a40yes_no[false], (* PTS 1107889 *)
                          sizeof (a40yes_no[false]));
                    a40long_descriptor (acv, a41v, me_surrogate, 1)
                    END
                ELSE
                    BEGIN
                    CASE me_debug OF
                        dbg_inproc :
                            c6 := 'INPROC';
                        dbg_local :
                            c6 := 'LOCAL ';
                        END;
                    (*ENDCASE*) 
                    a40move_const (acv, a41v, @c6, sizeof (c6));
                    CASE me_type OF
                        dbo_dbproc :
                            c8 := 'DBPROC  ';
                        dbo_dbfunc :
                            c8 := 'DBFUNC  ';
                        dbo_package :
                            c8 := 'PACKAGE ';
                        END;
                    (*ENDCASE*) 
                    a40move_const (acv, a41v, @c8, sizeof (c8));
                    c8 := 'C++     ';
                    a40move_const (acv, a41v, @c8, sizeof (c8));
                    a40move_const (acv, a41v, @a40yes_no[me_sql], sizeof (a40yes_no[me_sql]));
                    a40move (acv, a41v, NIL, 0); (* cursor column          *)
                    a40move (acv, a41v, NIL, 0); (* deterministic column   *)
                    a40move (acv, a41v, NIL, 0); (* former remote location *)
                    (* library name + path *)
                    pFileName := NIL;
                    IF  me_type = dbo_package
                    THEN
                        BEGIN
                        a12LoadFileInfo (acv, procbuf^.smethod.me_surrogate,
                              pFileName, MD5_footprint);
                        IF  pFileName <> NIL
                        THEN
                            BEGIN
                            fileNameLength := 0;
                            WHILE (fileNameLength <= sizeof(tsp00_Path)) AND
                                  (pFileName^[fileNameLength+1] <> chr(0)) DO
                                fileNameLength := fileNameLength + 1;
                            (*ENDWHILE*) 
                            a40move_const (acv, a41v, pFileName, fileNameLength);
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  pFileName = NIL
                    THEN
                        a40move (acv, a41v, NIL, 0);
                    (*ENDIF*) 
                    a40move_i4 (acv, a41v, me_dispid, NOT c_null, 0, NOT c_to_undef);
                    a40move_guid (acv, a41v, me_coclsid);
                    a40move_guid (acv, a41v, me_iid);
                    a40move_const (acv, a41v, @a40yes_no[false],
                          sizeof (a40yes_no[false]));
                    a40move (acv, a41v, NIL, 0);
                    a40move (acv, a41v, NIL, 0)
                    END;
                (*ENDIF*) 
                a40comment_descriptor (acv, a41v, mei_comment,
                      me_surrogate, 1, cm_dbproc);
                END
            (*ENDWITH*) 
        ELSE
            ak49one_proc_params (acv,
                  a41v, a01_il_b_identifier, procbuf, dbprocinfop)
        (*ENDIF*) 
    ELSE
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a49one_table_trigger (VAR acv : tak_all_command_glob;
            VAR a41v        : tak40_show_glob;
            trigger_len     : integer);
 
VAR
      found       : boolean;
      b_err       : tgg00_BasisError;
      aux_set     : tgg00_Linkset;
      ix          : integer;
      tr_count    : integer;
      trigger_ptr : tak_sysbufferaddress;
      trigger_key : tgg00_SysInfoKey;
      trigger_n   : tsp00_KnlIdentifier;
      tr_names    : ARRAY[1..3] OF tsp00_KnlIdentifier;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    tr_count              := 0;
    trigger_key           := a4p_arr.pbasep^.syskey;
    trigger_key.sentrytyp := cak_etrigger;
    IF  acv.a_isReplicationUser
    THEN
        BEGIN
        IF  internal_trigger in a4p_arr.pbasep^.sbase.blinkexist
        THEN
            BEGIN
            FOR ix := 1 TO 3 DO
                IF  acv.a_returncode = 0
                THEN
                    BEGIN
                    CASE ix OF
                        1 :
                            trigger_key.slinkage := cak_del_trigger_linkage;
                        2 :
                            trigger_key.slinkage := cak_ins_trigger_linkage;
                        3 :
                            trigger_key.slinkage := cak_upd_trigger_linkage;
                        END;
                    (*ENDCASE*) 
                    trigger_key.slinkage[2] := chr(ord(trigger_key.slinkage[2]) + 10);
                    a10get_sysinfo (acv, trigger_key, d_release, trigger_ptr, b_err);
                    IF  b_err = e_ok
                    THEN
                        ak49one_trigger (acv, a41v, trigger_ptr^.strigger)
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        WITH a4p_arr.pbasep^.sbase DO
            BEGIN
            aux_set := blinkexist * [del_trigger, ins_trigger, upd_trigger];
            END;
        (*ENDWITH*) 
        WHILE (aux_set <> [  ]) AND (a_returncode = 0) DO
            BEGIN
            IF  del_trigger in aux_set
            THEN
                BEGIN
                trigger_key.slinkage := cak_del_trigger_linkage;
                aux_set := aux_set - [ del_trigger ]
                END
            ELSE
                IF  ins_trigger in aux_set
                THEN
                    BEGIN
                    trigger_key.slinkage := cak_ins_trigger_linkage;
                    aux_set := aux_set - [ ins_trigger ]
                    END
                ELSE
                    IF  upd_trigger in aux_set
                    THEN
                        BEGIN
                        trigger_key.slinkage := cak_upd_trigger_linkage;
                        aux_set := aux_set - [ upd_trigger ]
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            a10get_sysinfo (acv, trigger_key, d_release, trigger_ptr, b_err);
            IF  b_err = e_ok
            THEN
                a262get_trigger_name (trigger_ptr^.strigger,
                      trigger_n, b_err);
            (*ENDIF*) 
            IF  b_err = e_ok
            THEN
                BEGIN
                IF  s30eq (trigger_n, a4coln, 1, trigger_len)
                THEN
                    IF  a_ex_kind <> only_parsing
                    THEN
                        BEGIN
                        found := false;
                        FOR ix := 1 TO tr_count DO
                            IF  tr_names[ix] = trigger_n
                            THEN
                                found := true;
                            (*ENDIF*) 
                        (*ENDFOR*) 
                        IF  NOT found
                        THEN
                            BEGIN
                            tr_count := tr_count + 1;
                            tr_names[tr_count] := trigger_n
                            END;
                        (*ENDIF*) 
                        IF  NOT found
                        THEN
                            ak49one_trigger (acv,
                                  a41v, trigger_ptr^.strigger)
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                a07_b_put_error (acv, b_err, 1)
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak49one_trigger (VAR acv : tak_all_command_glob;
            VAR a41v        : tak40_show_glob;
            VAR trigger_rec : tak_triggerrecord);
 
CONST
      c_yes = true;
      c_no  = false;
 
VAR
 
      trigger_kind : RECORD
            CASE boolean OF
                true :
                    (lset : tgg00_Linkset);
                false :
                    (i2 : tsp00_Int2);
                END;
            (*ENDCASE*) 
 
      b_err          : tgg00_BasisError;
      curr_kind      : ARRAY[1..3] OF tgg00_Linkset;
      ix             : integer;
      comment_id     : integer;
      methodinfo_buf : tak_sysbufferaddress;
      trigger_arr    : tak_syspointerarr;
      trigger_name   : tsp00_KnlIdentifier;
      sysk           : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a41v, a4p_arr.pbasep^.sbase  DO
    BEGIN
    WITH  trigger_rec DO
        BEGIN
        a40table_column_to_shbuf (acv, a41v, a4p_arr.pbasep, -1, c_with_owner);
        a262get_trigger_name (trigger_rec,
              trigger_name, a_returncode);
        IF  a_returncode = 0
        THEN
            BEGIN
            a40move (acv, a41v, @trigger_name, sizeof (trigger_name));
            a_p_arr1 := a4p_arr;
            a262exist_trigger (acv, trigger_name,
                  trigger_arr, trigger_kind.lset);
            IF  a_returncode = 0
            THEN
                BEGIN
                comment_id   := cak_is_undefined;
                curr_kind[1] := [ins_trigger];
                curr_kind[2] := [upd_trigger];
                curr_kind[3] := [del_trigger];
                FOR ix := 1 TO 3 DO
                    BEGIN
                    IF  curr_kind[ix] * trigger_kind.lset <> []
                    THEN
                        BEGIN
                        IF  comment_id = cak_is_undefined
                        THEN
                            comment_id := ix;
                        (*ENDIF*) 
                        a40move_const (acv, a41v, @a40yes_no[c_yes], 3)
                        END
                    ELSE
                        a40move_const (acv, a41v, @a40yes_no[c_no], 3)
                    (*ENDIF*) 
                    END;
                (*ENDFOR*) 
                END;
            (*ENDIF*) 
            IF  tr_language <> lang_pl
            THEN
                BEGIN
                sysk           := a01defaultkey;
                sysk.sauthid   := tr_proc_id;
                sysk.sentrytyp := cak_emethodinfo;
                a10get_sysinfo (acv, sysk, d_release, methodinfo_buf, b_err);
                IF  b_err = e_ok
                THEN
                    WITH methodinfo_buf^.smethodinfo DO
                        BEGIN
                        a40move (acv, a41v, @mei_name,    sizeof (mei_name));
                        a40move (acv, a41v, @mei_prog_id, sizeof (mei_prog_id))
                        END
                    (*ENDWITH*) 
                ELSE
                    a07_b_put_error (acv, b_err, 1);
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                a40move (acv, a41v, NIL, 0);
                a40move (acv, a41v, NIL, 0)
                END;
            (*ENDIF*) 
            a40put_date_time (acv, a41v, tr_date, true,  false);
            a40put_date_time (acv, a41v, tr_time, false, false);
            a40long_descriptor (acv, a41v, bsurrogate,
                  trigger_kind.i2);
            a40comment_descriptor (acv, a41v, tr_comment, bsurrogate,
                  comment_id, cm_trigger)
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak49put_dbproc (VAR acv : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            procinfobuf : tak_sysbufferaddress);
 
VAR
      proc_owner : tsp00_KnlIdentifier;
      schemaName : tsp00_KnlIdentifier;
 
BEGIN
WITH procinfobuf^.smethodinfo DO
    BEGIN
    a103GetSchemaName (acv, mei_schema, schemaName);
    a40move (acv, a41v, @schemaName, sizeof (schemaName));
    a40move (acv, a41v, @mei_name, sizeof (mei_name));
    a06determine_username (acv, mei_owner, proc_owner);
    a40move (acv, a41v, @proc_owner, sizeof (proc_owner));
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak49build_trigger_def ( VAR acv : tak_all_command_glob;
            VAR a41v     : tak40_show_glob;
            trigger_kind : tgg00_Linkset;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4);
 
CONST
      no_add   = false;
      do_add   = true;
      c_to_uni = true;
 
VAR
      concat_st_entry : boolean;
      header          : tak49col_header;
      i               : integer;
      colindex        : integer;
      tr_name_offset  : integer;
      col_ptr         : tak00_colinfo_ptr;
      aux_upd_set     : tak_columnset;
      st_entry        : tgg00_StackEntry;
      move_name       : tsp00_KnlIdentifier;
 
BEGIN
WITH acv, a41v, a_p_arr2.px[ 1 ]^.strigger DO
    BEGIN
    a4col_len := 0;
    a061assign_colname ('TRIGGER           ', move_name);
    ak49move_name (acv, a41v, c_to_uni, move_name,
          no_header, bsp_c1, no_add, buf);
    a262get_trigger_name (a_p_arr2.px[1]^.strigger,
          move_name, a_returncode);
    IF  a_returncode = 0
    THEN
        ak49move_name (acv, a41v, NOT c_to_uni, move_name,
              no_header, '(', tr_param_cnt = 0, buf);
    (* procedure parameter into show result now *)
    (*ENDIF*) 
    i               := 1;
    tr_name_offset  := (tr_name_len - 1) DIV sizeof (tr_stack[1]) + 1;
    concat_st_entry := false;
    WHILE (i <= tr_param_cnt) AND (a_returncode = 0) DO
        BEGIN
        IF  upd_trigger in trigger_kind
        THEN
            IF  tr_stack[ tr_name_offset + i ].ecol_tab[ 1 ] = chr(1)
            THEN
                header := old_header
            ELSE
                header := new_header
            (*ENDIF*) 
        ELSE
            header := no_header;
        (*ENDIF*) 
        IF  NOT concat_st_entry
        THEN
            st_entry := tr_stack[ tr_name_offset + i ];
        (*ENDIF*) 
        ak49find_column (acv,
              st_entry, move_name, concat_st_entry);
        IF  (i < tr_param_cnt) OR concat_st_entry
        THEN
            ak49move_name (acv, a41v, NOT c_to_uni,
                  move_name, header, ',', no_add, buf)
        ELSE
            ak49move_name (acv, a41v, NOT c_to_uni,
                  move_name, header, ')', do_add, buf);
        (*ENDIF*) 
        IF  NOT concat_st_entry
        THEN
            i := i + 1
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    a061assign_colname ('FOR               ', move_name);
    ak49move_name (acv, a41v, c_to_uni, move_name,
          no_header, bsp_c1, no_add, buf);
    ak49move_name (acv, a41v, NOT c_to_uni, a4authname,
          no_header, '.',  no_add, buf);
    ak49move_name (acv, a41v, NOT c_to_uni, a4tablen,
          no_header, bsp_c1, do_add, buf);
    a061assign_colname ('EXECUTE           ', move_name);
    ak49move_name (acv, a41v, c_to_uni,
          move_name, no_header, bsp_c1, no_add, buf);
    IF  del_trigger in trigger_kind
    THEN
        BEGIN
        trigger_kind := trigger_kind - [ del_trigger ];
        a061assign_colname ('AFTER DELETE      ', move_name)
        END
    ELSE
        IF  ins_trigger in trigger_kind
        THEN
            BEGIN
            trigger_kind :=
                  trigger_kind - [ ins_trigger ];
            a061assign_colname ('AFTER INSERT      ', move_name)
            END
        ELSE
            BEGIN
            trigger_kind :=
                  trigger_kind - [ upd_trigger ];
            a061assign_colname ('AFTER UPDATE      ', move_name)
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  trigger_kind <> [  ]
    THEN
        BEGIN
        ak49move_name (acv, a41v, c_to_uni,
              move_name, no_header, ',', no_add, buf);
        IF  trigger_kind = [ ins_trigger ]
        THEN
            a061assign_colname ('INSERT            ', move_name)
        ELSE
            IF  trigger_kind = [ upd_trigger ]
            THEN
                a061assign_colname ('UPDATE            ', move_name)
            ELSE
                a061assign_colname ('INSERT, UPDATE    ', move_name);
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    ak49move_name (acv, a41v, c_to_uni,
          move_name, no_header, '(', tr_upd_set = [  ], buf);
    IF  tr_upd_set <> [  ]
    THEN
        BEGIN
        (* update columns into show result *)
        colindex := 1;
        aux_upd_set := tr_upd_set;
        WITH a_p_arr1.pbasep^.sbase DO
            WHILE (colindex <= bmaxcol) AND
                  (aux_upd_set <> []) AND
                  (a_returncode = 0) DO
                BEGIN
                a06extcolno (a_p_arr1.pbasep^.sbase,
                      colindex, col_ptr);
                WITH col_ptr^ DO
                    IF  NOT (ctdropped in ccolpropset)   AND
                        NOT (ctinvisible in ccolpropset) AND
                        (ccolumnn <> a01_i_tablekey )
                    THEN
                        BEGIN
                        IF  cextcolno in aux_upd_set
                        THEN
                            BEGIN
                            aux_upd_set := aux_upd_set -
                                  [ cextcolno ];
                            a061get_colname (col_ptr^, move_name);
                            IF  aux_upd_set = []
                            THEN
                                ak49move_name (acv, a41v, NOT c_to_uni,
                                      move_name, no_header,
                                      ')',  do_add, buf)
                            ELSE
                                ak49move_name (acv, a41v, NOT c_to_uni,
                                      move_name, no_header,
                                      ',',  no_add, buf);
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDWITH*) 
                colindex := succ(colindex);
                END;
            (*ENDWHILE*) 
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    IF  (tr_condition_cnt > 0) AND (a_returncode = 0)
    THEN
        SAPDB_PascalMove ('VAK49 ',   1,    
              sizeof(a01kw[ cak_i_whenever ]), buf_size,
              @a01kw[ cak_i_whenever ], 1, @buf, a4col_len + 1, 9,
              a_returncode);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak49get_create_trigger_stmt  ( VAR acv : tak_all_command_glob;
            VAR a41v     : tak40_show_glob;
            VAR buf      : tsp00_MoveObj;
            buf_size     : tsp00_Int4;
            VAR buf_len  : tsp00_Int2);
 
VAR
      exit_loop : boolean;
      e         : tgg00_BasisError;
      move_len  : integer;
      seqno     : integer;
      ptr       : tak_sysbufferaddress;
      sysk      : tgg00_SysInfoKey;
 
BEGIN
sysk             := acv.a_p_arr2.px[1]^.syskey;
sysk.sentrytyp   := cak_eviewtext;
sysk.slinkage[1] := chr(255 - ord (sysk.slinkage[2]));
seqno            := 0;
buf_len          := 0;
exit_loop        := false;
REPEAT
    seqno            := seqno + 1;
    sysk.slinkage[2] := chr(seqno);
    a10get_sysinfo (acv, sysk, d_release, ptr, e);
    IF  e = e_ok
    THEN
        BEGIN
        IF  buf_len + ptr^.sviewtext.vttextlength > buf_size
        THEN
            BEGIN
            exit_loop := true;
            move_len  := buf_size - buf_len
            END
        ELSE
            move_len := ptr^.sviewtext.vttextlength;
        (*ENDIF*) 
        SAPDB_PascalMove ('VAK49 ',   2,    
              sizeof (ptr^.sviewtext.vttbuf), buf_size,
              @ptr^.sviewtext.vttbuf, 1, @buf, buf_len + 1, move_len, e);
        buf_len  := buf_len  + move_len;
        IF  NOT ptr^.sviewtext.vtnextexist
        THEN
            exit_loop := true
        ELSE
            a06inc_linkage (sysk.slinkage)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
UNTIL
    (e <> e_ok) OR (exit_loop);
(*ENDREPEAT*) 
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak49find_column (VAR acv : tak_all_command_glob;
            VAR st              : tgg00_StackEntry;
            VAR col_name        : tsp00_KnlIdentifier;
            VAR concat_st_entry : boolean);
 
CONST
      c_exit_loop = csp_maxint2;
 
VAR
      j : integer;
 
BEGIN
WITH acv DO
    BEGIN
    j := a_p_arr1.pbasep^.sbase.bfirstindex;
    WHILE j <= a_p_arr1.pbasep^.sbase.blastindex DO
        WITH a_p_arr1.pbasep^.sbase.bcolumn[ j ]^ DO
            IF  (ccolstack.etype = st.etype)        AND
                (ccolstack.epos  = st.epos)         AND
                ((ccolstack.elen_var = st.elen_var) OR
                (ccolstack.etype in [ st_fixkey, st_fixcol ]))
            THEN
                BEGIN
                concat_st_entry :=
                      ccolstack.elen_var <> st.elen_var;
                st.elen_var := st.elen_var -
                      ccolstack.elen_var;
                st.epos := st.epos +
                      ccolstack.elen_var;
                a061get_colname (a_p_arr1.pbasep^.sbase.bcolumn[j]^,
                      col_name);
                j := c_exit_loop;
                END
            ELSE
                j := j + 1;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDWHILE*) 
    IF  j <> c_exit_loop
    THEN
        a07ak_system_error (acv, 49, 1)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak49move_name (VAR acv : tak_all_command_glob;
            VAR a41v   : tak40_show_glob;
            to_unicode : boolean;
            VAR n      : tsp00_KnlIdentifier;
            col_header : tak49col_header;
            next_char  : char;
            add_row    : boolean;
            VAR buf    : tsp00_MoveObj);
 
VAR
      ix          : integer;
      move_len    : integer;
      plus_len    : integer;
      old_new_len : integer;
      plus_char   : tsp00_C2;
      c4          : tsp00_C4;
 
BEGIN
WITH a41v DO
    BEGIN
    to_unicode := to_unicode AND g01unicode;
&   ifdef trace
    t01lidentifier (ak_sem, n);
    t01int4 (ak_sem, 'add_row     ', ord(add_row));
    t01int4 (ak_sem, 'next_char   ', ord(next_char));
    t01int4 (ak_sem, 'to_unicode  ', ord(to_unicode));
&   endif
    move_len := sizeof (n);
    IF  to_unicode
    THEN
        WHILE n[move_len] = bsp_c1 DO
            move_len := move_len - 1
        (*ENDWHILE*) 
    ELSE
        WHILE a01equal_char (n, move_len - a01char_size + 1, bsp_c1) DO
            move_len := move_len - a01char_size;
        (*ENDWHILE*) 
    (*ENDIF*) 
&   ifdef trace
    t01int4 (ak_sem, 'move_len    ', move_len);
&   endif
    IF  col_header <> no_header
    THEN
        old_new_len := mxsp_c4 * a01char_size
    ELSE
        old_new_len := 0;
    (*ENDIF*) 
    plus_char[ 1 ] := next_char;
    plus_char[ 2 ] := bsp_c1;
    plus_len       := 1;
    CASE next_char OF
        '(' :
            IF  add_row
            THEN
                BEGIN
                plus_len     := 1;
                plus_char[1] := bsp_c1
                END
            ELSE
                BEGIN
                plus_len       := 2;
                plus_char[ 1 ] := bsp_c1;
                plus_char[ 2 ] := '('
                END;
            (*ENDIF*) 
        ',' :
            plus_len := 2;
        bsp_c1 :
            plus_len := 1;
        ')' :
            plus_len := 2;
        OTHERWISE ;
        END;
    (*ENDCASE*) 
    IF  col_header <> no_header
    THEN
        BEGIN
        IF  col_header = new_header
        THEN
            c4 := 'NEW.'
        ELSE
            c4 := 'OLD.';
        (*ENDIF*) 
        FOR ix := 1 TO sizeof (c4) DO
            BEGIN
            IF  g01unicode
            THEN
                BEGIN
                a4col_len      := a4col_len + 1;
                buf[a4col_len] := csp_unicode_mark;
                END;
            (*ENDIF*) 
            a4col_len      := a4col_len + 1;
            buf[a4col_len] := c4[ix]
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    FOR ix := 1 TO move_len DO
        BEGIN
        IF  to_unicode
        THEN
            BEGIN
            a4col_len      := a4col_len + 1;
            buf[a4col_len] := csp_unicode_mark;
            END;
        (*ENDIF*) 
        a4col_len      := a4col_len + 1;
        buf[a4col_len] := n[ix]
        END;
    (*ENDFOR*) 
    IF  plus_len > 0
    THEN
        BEGIN
        IF  g01unicode
        THEN
            BEGIN
            a4col_len      := a4col_len + 1;
            buf[a4col_len] := csp_unicode_mark;
            END;
        (*ENDIF*) 
        a4col_len      := a4col_len + 1;
        buf[a4col_len] := plus_char[1];
        END;
    (*ENDIF*) 
    IF  plus_len = 2
    THEN
        BEGIN
        IF  g01unicode
        THEN
            BEGIN
            a4col_len      := a4col_len + 1;
            buf[a4col_len] := csp_unicode_mark;
            END;
        (*ENDIF*) 
        a4col_len      := a4col_len + 1;
        buf[a4col_len] := plus_char[2]
        END;
&   ifdef trace
    (*ENDIF*) 
    t01moveobj (ak_sem, buf, 1, a4col_len);
&   endif
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak49variables (
            VAR acv : tak_all_command_glob;
            VAR a41v   : tak40_show_glob);
 
VAR
      _isDBProc      : boolean;
      _isTrigger     : boolean;
      _isFunction    : boolean;
      _isSysVariable : boolean;
      _skipVariable  : boolean;
      _e             : tgg00_BasisError;
      _ix            : integer;
      _jx            : integer;
      _datalen       : integer;
      _newOld        : tsp00_C6;
      _currentParam  : integer;
      _paramCount    : integer;
      _work_buf      : tak40_int2_arr_ptr;
      _p             : tak_sysbufferaddress;
      _pMethod       : tak_sysbufferaddress;
      _pCol          : tak00_colinfo_ptr;
      _type          : tsp00_C8;
      _datatype      : tsp00_Sname;
      _procId        : tgg00_Surrogate;
      _code          : tsp00_C10;
      _p_arr         : tak_syspointerarr;
      _pTrigger      : tak_syspointerarr;
      _triggerKind   : tgg00_Linkset;
      _sysk          : tgg00_SysInfoKey;
      _variable      : tsp00_KnlIdentifier;
 
BEGIN
IF  (a41v.a4authname = a01_il_b_identifier) OR
    (a41v.a4coln     = a01_il_b_identifier)
THEN
    a07_b_put_error (acv, e_not_implemented, 1)
ELSE
    BEGIN
    a722init_epos_reccol_relation( acv, _work_buf );
    _type := 'DBPROC  ';
    _isDBProc := a722test_col_qual (acv,
          a41v, 'TYPE              ',
          csp_ascii_blank, @_type, sizeof (_type), _work_buf);
    _type     := 'TRIGGER ';
    _isTrigger := a722test_col_qual (acv,
          a41v, 'TYPE              ',
          csp_ascii_blank, @_type, sizeof (_type), _work_buf);
    _type       := 'FUNCTION';
    _isFunction := a722test_col_qual (acv,
          a41v, 'TYPE              ',
          csp_ascii_blank, @_type, sizeof (_type), _work_buf);
    IF  ord (_isDBProc) + ord (_isTrigger) + ord (_isFunction) <> 1
    THEN
        a07_b_put_error (acv, e_not_implemented, 1)
    ELSE
        BEGIN
        _pMethod    := NIL;
        _p          := NIL;
        _paramCount := 0;
        IF  _isDBProc
        THEN
            BEGIN
            IF  a12dbproc_exist (acv, a41v.a4authname, a41v.a4coln, d_fix, _pMethod)
            THEN
                BEGIN
                _type       := 'DBPROC  ';
                _procId     := _pMethod^.syskey.stableid;
                _paramCount := _pMethod^.smethod.me_param_cnt;
                END;
            (*ENDIF*) 
            END
        ELSE
            IF  _isFunction
            THEN
                BEGIN
                IF  a12dbfunc_exist (acv, a41v.a4authname, a41v.a4coln, d_fix, _pMethod)
                THEN
                    BEGIN
                    _type       := 'FUNCTION';
                    _procId     := _pMethod^.syskey.stableid;
                    _paramCount := _pMethod^.smethod.me_param_cnt;
                    END;
                (*ENDIF*) 
                END
            ELSE
                IF  _isTrigger
                THEN
                    IF  a06_table_exist (acv, d_fix, a41v.a4authname, a41v.a4tablen,
                        acv.a_p_arr1, true)
                    THEN
                        BEGIN
                        a262exist_trigger (acv, a41v.a4coln, _pTrigger, _triggerKind);
                        IF  _pTrigger.pcount > 0
                        THEN
                            BEGIN
                            _p      := _pTrigger.px[1];
                            _type   := 'TRIGGER ';
                            _procId := _pTrigger.px[1]^.strigger.tr_proc_id;
                            END
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  (_p <> NIL) OR (_pMethod <> NIL)
        THEN
            BEGIN
            _currentParam  := 1;
            _sysk          := a01defaultkey;
            _sysk.stableid := _procId;
            a10get_sysinfo (acv, _sysk, d_release, _p, _e);
            IF  _e = e_ok
            THEN
                FOR _ix := 1 TO _p^.sbase.bmaxcol DO
                    BEGIN
                    a06extcolno (_p^.sbase, _ix, _pCol);
                    _isSysVariable := false;
                    IF  _pCol^.ccolumnn[a01char_size] = a01_i_rc[a01char_size]
                    THEN
                        BEGIN
                        a061get_colname ( _pCol^, _variable);
                        IF  (_variable = a01_i_rc    ) OR
                            (_variable = a01_i_count ) OR
                            (_variable = a01_i_cursor) OR
                            (_variable = a01_i_errmsg)
                        THEN
                            _isSysVariable := true;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    _skipVariable := false;
                    IF  _isSysVariable
                    THEN
                        _newOld := 'SYSTEM'
                    ELSE
                        IF  _currentParam <= _paramCount
                        THEN
                            BEGIN
                            IF  _isFunction AND (_currentParam = _paramCount)
                            THEN
                                _skipVariable := true
                            ELSE
                                BEGIN
                                _variable   := a01_il_b_identifier;
                                WITH _pMethod^.smethod.me_param_list[_currentParam]^ DO
                                    BEGIN
                                    SAPDB_PascalMove ('VAK49 ',   3,    
                                          sizeof(param_name), sizeof(_variable),
                                          @param_name, 1, @_variable, 1, ord(param_name_len), acv.a_returncode);
                                    IF  NOT a061exist_columnname (_p^.sbase, _variable, _pCol)
                                    THEN
                                        a07ak_system_error (acv, 49, 3)
                                    ELSE
                                        IF  param_in_out[2] = chr(sp1io_output)
                                        THEN
                                            _newOld := 'OUT   '
                                        ELSE
                                            IF  param_in_out[2] =  chr(sp1io_inout)
                                            THEN
                                                _newOld := 'INOUT '
                                            ELSE
                                                IF  param_in_out[2] = chr(sp1io_input)
                                                THEN
                                                    _newOld := 'IN    ';
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                    END;
                                (*ENDWITH*) 
                                END;
                            (*ENDIF*) 
                            _currentParam := _currentParam + 1;
                            END
                        ELSE
                            _newOld := '      ';
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  NOT _skipVariable
                    THEN
                        BEGIN
                        a40move          (acv, a41v, @a41v.a4authname, sizeof(a41v.a4authname));
                        a40move          (acv, a41v, @a41v.a4tablen, sizeof(a41v.a4tablen));
                        a40move          (acv, a41v, @a41v.a4coln, sizeof(a41v.a4coln));
                        a40move_const    (acv, a41v, @_type, sizeof(_type));
                        a40move          (acv, a41v, @_pCol^.ccolumnn, ord(_pCol^.ccolumnn_len));
                        a40move_const    (acv, a41v, @_newOld, sizeof(_newOld));
                        a40datatype_code (_pCol^, false, acv.a_comp_type,
                              _datatype, _code, _datalen);
                        a40move_const    (acv, a41v, @_datatype, sizeof(_datatype));
                        a40move_i4       (acv, a41v, _datalen, NOT c_null, 0, NOT c_to_undef);
                        a40move_i4       (acv, a41v, ord(_pCol^.cdatafrac - 1), NOT c_null, 0, NOT c_to_undef);
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDFOR*) 
            (*ENDIF*) 
            IF  (_e = e_ok) AND _isTrigger
            THEN
                BEGIN
                _sysk             := _pTrigger.px[1]^.syskey;
                _sysk.sentrytyp   := cak_emethoddebuginfo;
                a10get_sysinfo (acv, _sysk, d_release, _p, _e);
                IF  _e = e_ok
                THEN
                    WITH acv.a_p_arr1.pbasep^.sbase DO
                        FOR _ix := bfirstindex TO blastindex DO
                            BEGIN
                            _jx := 1;
                            WHILE _jx <= _p^.smethoddebuginfo.med_count DO
                                WITH _p^.smethoddebuginfo.med_mapping[_jx] DO
                                    BEGIN
                                    IF  (bcolumn[_ix]^.creccolno = dmi_extcolno MOD 1000)
                                    THEN
                                        BEGIN
                                        a40move          (acv, a41v, @a41v.a4authname, sizeof(a41v.a4authname));
                                        a40move          (acv, a41v, @a41v.a4tablen, sizeof(a41v.a4tablen));
                                        a40move          (acv, a41v, @a41v.a4coln, sizeof(a41v.a4coln));
                                        a40move_const    (acv, a41v, @_type, sizeof(_type));
                                        a40move          (acv, a41v, @bcolumn[_ix]^.ccolumnn, ord(bcolumn[_ix]^.ccolumnn_len));
                                        IF  dmi_extcolno > 1000
                                        THEN
                                            _newOld := 'OLD   '
                                        ELSE
                                            _newOld := 'NEW   ';
                                        (*ENDIF*) 
                                        a40move_const    (acv, a41v, @_newOld, sizeof(_newOld));
                                        a40datatype_code (bcolumn[_ix]^, false, acv.a_comp_type,
                                              _datatype, _code, _datalen);
                                        a40move_const    (acv, a41v, @_datatype, sizeof(_datatype));
                                        a40move_i4       (acv, a41v, _datalen, NOT c_null, 0, NOT c_to_undef);
                                        a40move_i4       (acv, a41v, ord(bcolumn[_ix]^.cdatafrac), NOT c_null, 0, NOT c_to_undef);
                                        _jx := _p^.smethoddebuginfo.med_count + 1
                                        END
                                    ELSE
                                        _jx := _jx + 1;
                                    (*ENDIF*) 
                                    END;
                                (*ENDWITH*) 
                            (*ENDWHILE*) 
                            END;
                        (*ENDFOR*) 
                    (*ENDWITH*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    a722finalize_epos_reccol_relation( acv, _work_buf );
    END;
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
