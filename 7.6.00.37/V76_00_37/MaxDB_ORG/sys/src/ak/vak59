.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-01-11
*****************************************************
modname : VAK59
changed : 2000-01-11
module  : DML-Join-View-Procedures
 
Author  : ThomasA
Created : 1987-09-04
*****************************************************
 
Purpose : INSERT, UPDATE, DELETE of join-views
 
Define  :
 
        PROCEDURE
              a59_join_view (
                    VAR acv     : tak_all_command_glob;
                    VAR dmli    : tak_dml_info;
                    VAR viewdfa : tak_dfarr;
                    start_node  : integer;
                    mtype       : tgg00_MessType);
 
        PROCEDURE
              a59_prepare_join_check (
                    VAR acv         : tak_all_command_glob;
                    VAR dmli        : tak_dml_info;
                    maxkeyl         : integer);
 
        PROCEDURE
              a59qualified_dml (
                    VAR acv   : tak_all_command_glob;
                    VAR parsk : tak_parskey);
 
        PROCEDURE
              a59handle_qualification (
                    VAR acv        : tak_all_command_glob;
                    VAR res_buffer : tgg00_Rec;
                    VAR e          : tgg00_BasisError);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01char_size              : integer;
              a01sysnullkey             : tgg00_SysInfoKey;
              a01fullset                : tak_columnset;
              a01_il_b_identifier       : tsp00_KnlIdentifier;
              a01_zero_res_name         : tsp00_KnlIdentifier;
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05qualification_test (
                    VAR acv        : tak_all_command_glob;
                    VAR m          : tgg00_MessBlock;
                    result_wanted  : boolean;
                    check_new_rec  : boolean;
                    error_pos      : integer;
                    VAR rec        : tgg00_Rec;
                    VAR result_buf : tsp00_Buf;
                    resultBufSize  : tsp00_Int4;
                    VAR result_len : integer);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06extcolno (
                    VAR baserec  : tak_baserecord;
                    extcolno     : integer;
                    VAR col_ptr  : tak00_colinfo_ptr);
 
        PROCEDURE
              a06put_errtext (
                    VAR acv       : tak_all_command_glob;
                    b_err_in      : tgg00_BasisError;
                    err_type      : tgg04_ErrorText;
                    errtext_len   : integer;
                    VAR errtext   : tsp00_C256;
                    VAR b_err_out : tgg00_BasisError);
 
        PROCEDURE
              a06_systable_get (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR tableid  : tgg00_Surrogate;
                    VAR base_ptr : tak_sysbufferaddress;
                    get_all      : boolean;
                    VAR ok       : boolean);
 
        PROCEDURE
              a06a_mblock_init (
                    VAR acv      : tak_all_command_glob;
                    mtype        : tgg00_MessType;
                    m2type       : tgg00_MessType2;
                    VAR tree     : tgg00_FileId);
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06drop_fieldlist_references (VAR fieldlists : tgg00_FieldLists);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061get_colname (
                    VAR col_info : tak00_columninfo;
                    VAR colname  : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10add_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_fix_len_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    required_len : integer;
                    plus         : integer;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_key_del  (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10new (
                    VAR acv  : tak_all_command_glob;
                    obj_size : tsp00_Int4;
                    VAR p    : tak_eop_arr_ptr);
 
        PROCEDURE
              a10dispose (
                    VAR acv : tak_all_command_glob;
                    VAR p : tsp00_Addr);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              SQLManager : vak101;
 
        FUNCTION
              a101_GetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate (* ptocConst *);
                    VAR schemaName : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_Trigger : VAK262;
 
        PROCEDURE
              a262add_trigger_info (
                    VAR acv           : tak_all_command_glob;
                    VAR dmli          : tak_dml_info;
                    ignoreUserTrigger : boolean);
 
      ------------------------------ 
 
        FROM
              Executing_dispatcher : VAK501;
 
        PROCEDURE
              a501do_execute (
                    VAR acv                 : tak_all_command_glob;
                    VAR dmli                : tak_dml_info;
                    VAR parsk               : tak_parskey;
                    output_during_execution : boolean);
 
      ------------------------------ 
 
        FROM
              Executing_finish : VAK507;
 
        PROCEDURE
              a507_literal (
                    VAR acv             : tak_all_command_glob;
                    VAR longliteralrec  : tak_longliteral_rec;
                    useliteralbuf       : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Lock_Commit_Rollback : VAK52;
 
        PROCEDURE
              a52internal_subtrans (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK54;
 
        PROCEDURE
              a54_dml_init (
                    VAR acv   : tak_all_command_glob;
                    VAR dmli  : tak_dml_info;
                    in_union  : boolean);
 
        PROCEDURE
              a54_dml_finalize (
                    VAR dmli         : tak_dml_info;
                    VAR TransContext : tgg00_TransContext);
 
        PROCEDURE
              a54_loc_temp_locks (
                    VAR acv   : tak_all_command_glob;
                    globstate : tgg00_HandlingSet;
                    VAR sparr : tak_syspointerarr);
 
        PROCEDURE
              a54add_next_temp_lock (
                    VAR acv   : tak_all_command_glob;
                    VAR tabid : tgg00_Surrogate;
                    globstate : tgg00_HandlingSet);
 
        PROCEDURE
              a54_in_buf (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    VAR viewp  : tak_sysbufferaddress;
                    move_len   : integer;
                    qual_pos   : integer;
                    qual_len   : integer;
                    v1len      : integer;
                    plustabpos : integer);
 
        PROCEDURE
              a54_store_parsinfo (
                    VAR acv   : tak_all_command_glob;
                    VAR sparr : tak_syspointerarr);
 
        PROCEDURE
              a54_get_pparsp_pinfop (
                    VAR acv   : tak_all_command_glob;
                    VAR sparr : tak_syspointerarr;
                    mtype     : tgg00_MessType);
 
        PROCEDURE
              a54set_complex_entry (
                    VAR acv     : tak_all_command_glob;
                    call_reason : tak_complex_call_reason);
 
        PROCEDURE
              a54_last_part (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    last_pars_part : boolean);
 
        PROCEDURE
              a54_shortinfo_to_varpart (
                    VAR acv   : tak_all_command_glob;
                    store_cmd : boolean;
                    VAR infop : tak_sysbufferaddress);
 
        PROCEDURE
              a54_view_put_into (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
        PROCEDURE
              a54_fixedpos (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542char_to_packet (
                    VAR acv : tak_all_command_glob;
                    c : char);
 
        PROCEDURE
              a542identifier_to_packet (
                    VAR acv        : tak_all_command_glob;
                    VAR identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              a542internal_packet (
                    VAR acv                 : tak_all_command_glob;
                    release_internal_packet : boolean;
                    required_len            : tsp00_Int4);
 
        PROCEDURE
              a542move_to_packet (
                    VAR acv    : tak_all_command_glob;
                    const_addr : tsp00_MoveObjPtr;
                    const_len  : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              DML_Parts : VAK55;
 
        PROCEDURE
              a55_named_values (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR dfa  : tak_dfarr;
                    curr_n   : integer);
 
        PROCEDURE
              a55_found_one_value (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR dfa  : tak_dfarr);
 
      ------------------------------ 
 
        FROM
              AK_Insert : VAK56;
 
        PROCEDURE
              a56_enumerated_values (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    VAR dfa    : tak_dfarr;
                    VAR curr_n : integer);
 
        PROCEDURE
              a56_normal_insert (
                    VAR acv            : tak_all_command_glob;
                    VAR dmli           : tak_dml_info;
                    VAR dfa            : tak_dfarr;
                    join_view_insert   : boolean;
                    VAR not_used_links : tak_charset);
 
        PROCEDURE
              a56alloc_linkpos_info (
                    VAR acv        : tak_all_command_glob;
                    VAR p_arr      : tak_syspointerarr;
                    mess_type      : tgg00_MessType;
                    VAR linkposbuf : tak_sysbufferaddress);
 
        PROCEDURE
              a56insert_upd_with_link (
                    VAR acv        : tak_all_command_glob;
                    VAR linkbuf     : tak_sysbufferaddress);
 
        PROCEDURE
              a56put_link_info (
                    VAR acv            : tak_all_command_glob;
                    base_ptr           : tak_sysbufferaddress;
                    not_used_links     : tak_charset;
                    viewqualbuf        : tak_sysbufferaddress;
                    VAR linkposbuf     : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              AK_Update : VAK57;
 
        PROCEDURE
              a57_set_clause (
                    VAR acv           : tak_all_command_glob;
                    VAR dmli          : tak_dml_info;
                    VAR dfa           : tak_dfarr;
                    start_node        : tsp00_Int2;
                    VAR upd_col_set   : tak_columnset;
                    VAR sel_upd_set   : tak_columnset;
                    named_values_done : boolean);
 
        PROCEDURE
              a57_range_not_null (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    VAR dfa  : tak_dfarr);
 
      ------------------------------ 
 
        FROM
              AK_Delete : VAK58;
 
        PROCEDURE
              a58_current_of (
                    VAR acv  : tak_all_command_glob;
                    VAR dmli : tak_dml_info;
                    curr_n   : integer);
 
        PROCEDURE
              a58delete_with_link (
                    VAR acv     : tak_all_command_glob;
                    VAR tabid   : tgg00_Surrogate;
                    linkindex   : integer;
                    parsno      : integer;
                    use_file_id : integer);
 
        PROCEDURE
              a58describe_long_columns (
                    VAR acv     : tak_all_command_glob;
                    VAR d_sparr : tak_syspointerarr);
 
        PROCEDURE
              a58_indices (
                    VAR acv      : tak_all_command_glob;
                    VAR base_rec : tak_baserecord;
                    VAR dfa      : tak_dfarr);
 
        PROCEDURE
              a58_put_link_inf_into_mess_buf (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    VAR colset : tak_columnset;
                    file_id    : integer);
 
      ------------------------------ 
 
        FROM
              Select_Syntax : VAK60;
 
        PROCEDURE
              a60rescount (
                    VAR acv  : tak_all_command_glob;
                    rescount : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Select_List : VAK61;
 
        PROCEDURE
              a61_set_jump (
                    VAR mblock : tgg00_MessBlock;
                    stentrynr : integer;
                    operator  : tgg00_StackEntryType);
 
      ------------------------------ 
 
        FROM
              Execute_Where_Part : VAK65;
 
        PROCEDURE
              a65_set_operator (
                    VAR acv  : tak_all_command_glob;
                    operator : tgg00_StackOpType);
 
      ------------------------------ 
 
        FROM
              Execute_Select_Expression : VAK660;
 
        PROCEDURE
              a660_new_pparsp (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    first_parsinfo : boolean;
                    complicate     : boolean);
 
        PROCEDURE
              a660_prefix_delete (
                    VAR acv       : tak_all_command_glob;
                    VAR parsk     : tak_parskey;
                    VAR del_cnt   : integer;
                    prefix_length : integer);
 
      ------------------------------ 
 
        FROM
              Resultname_handling : VAK663;
 
        PROCEDURE
              a663_del_result (
                    VAR acv          : tak_all_command_glob;
                    VAR resname_rec  : tak_resname_record;
                    do_cdel          : boolean;
                    del_resname_rec  : boolean);
 
        PROCEDURE
              a663_put_result_info (
                    VAR acv          : tak_all_command_glob;
                    VAR resname_addr : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              Join_Select : VAK680;
 
        PROCEDURE
              a680_join (
                    VAR acv                 : tak_all_command_glob;
                    VAR dmli                : tak_dml_info;
                    VAR res_tree            : tgg00_FileId;
                    VAR ak_strat_interface  : tak71_strat_rec;
                    last_pars_part          : boolean;
                    VAR jvrec               : tak68_joinview_rec);
 
      ------------------------------ 
 
        FROM
              Join_Select_execution : VAK682;
 
        PROCEDURE
              a682_execute_join (
                    VAR acv       : tak_all_command_glob;
                    VAR dmli      : tak_dml_info;
                    VAR series    : tak68_sequence;
                    VAR res_tree  : tgg00_FileId;
                    VAR parsk     : tak_parskey;
                    VAR jvrec     : tak68_joinview_rec;
                    use_old_rescnt: boolean;
                    del_parsinfos : boolean);
 
        PROCEDURE
              a682join_MBlock_key (
                    VAR acv         : tak_all_command_glob;
                    VAR dmli        : tak_dml_info;
                    VAR parsk       : tak_parskey;
                    VAR jv_tabid    : tgg00_Surrogate;
                    seqno           : tsp00_Int2;
                    VAR syskey      : tgg00_SysInfoKey;
                    use_stmt_parsk  : boolean);
 
        PROCEDURE
              a682_execute_join_operator (
                    VAR acv             : tak_all_command_glob;
                    VAR dmli            : tak_dml_info;
                    VAR series          : tak68_sequence;
                    VAR res_tree        : tgg00_FileId;
                    VAR parsk           : tak_parskey;
                    VAR jvrec           : tak68_joinview_rec;
                    use_old_rescnt      : boolean;
                    del_parsinfos       : boolean);
 
      ------------------------------ 
 
        FROM
              Resulttable : VAK73;
 
        PROCEDURE
              a73_one_fetch (
                    VAR acv      : tak_all_command_glob;
                    VAR sparr    : tak_syspointerarr;
                    mtype        : tgg00_MessType2;
                    pos          : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        PROCEDURE
              g01abort (
                    msg_no     : tsp00_Int4;
                    msg_label  : tsp00_C8;
                    msg_text   : tsp00_C24;
                    bad_value  : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04build_temp_tree_id (
                    VAR curr : tgg00_FileId;
                    VAR t    : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              GG_allocator_interface : VGG941;
 
        FUNCTION
              gg941Allocate(
                    VAR TransContext : tgg00_TransContext;
                    wantedBytes      : integer) : tsp00_Addr;
 
        PROCEDURE
              gg941Deallocate(
                    VAR TransContext : tgg00_TransContext;
                    VAR p            : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalUnicodeFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedUnicodeFill (
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2 );
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedOverlappingMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30lnr_defbyte (
                    str       : tsp00_MoveObjPtr;
                    defbyte   : char;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Pointer-Arithmetik : VSP35;
 
        FUNCTION
              s35add_moveobj_ptr_ptocm (
                    moveobj_ptr : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4) : tsp00_MoveObjPtr;
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01mess2type (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    mess2_type    : tgg00_MessType2);
 
        PROCEDURE
              t01bool (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    curr_bool: boolean);
 
        PROCEDURE
              t01knl_identifier (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01command_kind (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    command_kind : tak_commandkind);
 
        PROCEDURE
              t01p4int4 (
                    layer : tgg00_Debug;
                    nam   : tsp00_Sname;
                    int_1 : tsp00_Int4;
                    int_2 : tsp00_Int4;
                    int_3 : tsp00_Int4;
                    int_4 : tsp00_Int4);
 
        PROCEDURE
              t01stackentry (
                    layer       : tgg00_Debug;
                    VAR st      : tgg00_StackEntry;
                    entry_index : integer);
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR m         : tgg00_MessBlock);
 
        PROCEDURE
              t01lidentifier (layer : tgg00_Debug; nam  : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01buf  (
                    level     : tgg00_Debug;
                    VAR buf   : tsp00_Buf;
                    pos_start : integer;
                    pos_end   : integer);
 
        PROCEDURE
              t01moveobj (
                    debug       : tgg00_Debug;
                    VAR moveobj : tsp00_MoveObj;
                    startpos    : tsp00_Int4;
                    endpos      : tsp00_Int4);
&       ENDIF
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              a10new;
 
              tak_sysbufferaddress tak_eop_arr_ptr
 
        PROCEDURE
              a10dispose;
 
              tak_sysbufferaddress tsp00_Addr
 
        FUNCTION
              s35add_moveobj_ptr_ptocm;
 
              tsp00_Int4 tsp00_MoveObjPtr;
 
.CM *-END-* synonym -------------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      c_get_key          = 0;
      c_no_qualification = 0;
      c_no_where_node    = csp_maxint2;
      c_get_all          = true (* a06_systable_get *);
      c_output_during_execution= true (* a501do_execute *);
      c_in_union         = true (* a54_dml_init *);
      c_last_pars_part   = true (* a54_last_part *);
      (*                           ak59check_join_view *)
      (*                           a680_join *)
      c_join_view_insert = true (* a56_normal_insert *);
      c_named_values_done= true (* a57_set_clause *);
      c_check_view       = true (* ak59check_join_view *);
      c_enum_values      = true (* ak59fill_dfa *);
      c_first_parsinfo   = true (* a660_new_pparsp *);
      c_complicate       = true (* a660_new_pparsp *);
      c_do_cdel          = true (* a663_del_result *);
      c_del_resname_rec  = true (* a663_del_result *);
      c_use_old_rescnt   = true (* a682_execute_join *);
      c_seqsearch_for_exec = false (* a682_execute_join *);
      c_result_wanted    = true (* a05qualification_test *);
      c_check_new_rec    = true (* a05qualification_test *);
      c_no_error_pos     = 0    (* a05qualification_test *);
      c_release_internal = true (* a542internal_packet   *);
      c_ignore_trigger   = true;
 
TYPE
      tak59_boolptr = ^boolean;
      tak59_usedtables = ARRAY[ 1..cak00_maxsources ] OF boolean;
 
      tak59_jv_parameter = RECORD
            j_v_qualified          : tsp00_Int4;
            j_v_keylen             : tsp00_Int4;
            j_v_tableno            : tsp00_Int4;
            j_v_resname_node       : tsp00_Int4;
            j_v_viewkeybuf         : tak_sysbufferaddress;
            j_v_qual_basis         : tak_sysbufferaddress;
            j_v_qual_derived       : tak_sysbufferaddress;
            j_v_qual_stack         : tak_sysbufferaddress;
            j_v_column_updated     : boolean;
            j_v_check_after_update : boolean;
            j_v_phase_ins_after_upd: boolean;
            j_v_join_upd           : boolean;
            j_v_key_update         : boolean;
            j_v_filler1            : boolean;
            j_v_start_node         : tsp00_Int2;
            j_v_schema             : tsp00_KnlIdentifier;
            j_v_name               : tsp00_KnlIdentifier;
            j_v_tabid              : tgg00_Surrogate;
            j_v_reference          : tsp00_KnlIdentifier;
            j_v_tabset             : tak59_usedtables;
            j_v_syskey             : tgg00_SysInfoKey;
            j_v_mtype              : tgg00_MessType;
            j_v_ins_after_upd      : boolean;
            j_v_viewptr            : tak_sysbufferaddress;
            j_v_field_used         : ARRAY[ 1..MAX_COL_PER_TAB_GG00 ] OF boolean;
            j_v_res_buf            : tsp00_Buf;
      END;
 
 
 
(*------------------------------*) 
 
PROCEDURE
      ak59add_projection_qual (
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info;
            VAR j_v_par : tak59_jv_parameter);
 
VAR
      _b_err            : tgg00_BasisError;
      _j                : integer;
      _l                : integer;
      _stcount          : integer;
      _qual_pos         : integer;
      _stpos            : integer;
      _jump_stentry_pos : integer;
      _and_count        : integer;
      _move_len         : integer;
      _messbuf_addr     : tak_sysbufferaddress;
      _skey             : tgg00_SysInfoKey;
 
      _and_arr          : RECORD
            CASE boolean OF
                true :
                    (eop_arr : tak_eop_arr_ptr);
                false :
                    (any_ptr : tsp00_Addr);
                END;
            (*ENDCASE*) 
 
      _jmblock_ptr      : tgg00_MessBlockPtr;
      _jmblock_qual_ptr : tgg00_QualBufPtr;
 
BEGIN
&IFDEF TRACE
t01messblock( ak_sem, 'MBLOCK 59add', acv.a_mblock );
&ENDIF
_move_len           := 0;
_skey               := j_v_par.j_v_qual_basis^.syskey;
_skey.sentrytyp     := cak_epermmessblock;
_skey.slinkage[ 1 ] := chr( 1 );
_skey.slinkage[ 2 ] := chr( j_v_par.j_v_tableno );
_messbuf_addr       := NIL;
a10get_sysinfo( acv, _skey, d_release, _messbuf_addr, _b_err );
IF  _b_err = e_ok
THEN
    BEGIN
    _jmblock_ptr      := @_messbuf_addr^.smessblock.mbr_mess_block;
    _jmblock_qual_ptr := _jmblock_ptr^.mb_qual;
&   IFDEF TRACE
    FOR _j := _jmblock_qual_ptr^.mqual_pos TO
          _jmblock_qual_ptr^.mqual_pos + _jmblock_qual_ptr^.mqual_cnt - 1 DO
        t01stackentry( ak_sem, _jmblock_ptr^.mb_st^[ _j ], _j );
    (*ENDFOR*) 
&   ENDIF
    _jump_stentry_pos := 0;
    _qual_pos         := acv.a_mblock.mb_qual^.mfirst_free;
    _and_count        := 0;
    IF  acv.a_mblock.mb_qual^.mqual_pos = 0
    THEN
        acv.a_mblock.mb_qual^.mqual_pos :=
              acv.a_mblock.mb_qual^.mfirst_free;
    (*ENDIF*) 
    _stpos   := _jmblock_ptr^.mb_st^[ _jmblock_qual_ptr^.mqual_pos ].epos;
    _stcount := _jmblock_qual_ptr^.mqual_cnt - _stpos + 1;
    IF  acv.a_mblock.mb_qual^.mfirst_free + _stcount + 1 >
        acv.a_mblock.mb_st_max
    THEN
        a07_b_put_error( acv, e_too_many_mb_stackentries, 1 )
    ELSE
        IF  _stcount > 0
        THEN
            BEGIN
            IF  acv.a_mblock.mb_qual^.mqual_cnt > 0
            THEN
                IF  NOT (( acv.a_mblock.
                    mb_st^[ acv.a_mblock.mb_qual^.mqual_pos ].etype = st_jump_output )
                    AND ( acv.a_mblock.
                    mb_st^[ acv.a_mblock.mb_qual^.mqual_pos ].epos =
                    acv.a_mblock.mb_qual^.mqual_cnt + 1 ))
                THEN
                    BEGIN
                    (* IF a View_qualification is inserted *)
                    (* into the stack, it will be connected*)
                    (* with an and_operator to the existing*)
                    (* stack. This leads to an illegal     *)
                    (* stackstructure ( not postfix ). So  *)
                    (* the existing operators (AND) must be*)
                    (* colected and inserted after the view*)
                    (* qualification afterwards and the    *)
                    (* jump_positions must be changed      *)
                    _j := _qual_pos - 1;
                    WHILE acv.a_mblock.mb_st^[ _j ].eop in [ op_and, op_upd_view_and ] DO
                        (* skip over 'AND' stack entries *)
                        _j := pred( _j );
                    (*ENDWHILE*) 
                    _and_count := 0;
                    IF  _qual_pos - 1 - _j > 0
                    THEN
                        (* there are AND stack entries *)
                        BEGIN
                        a10new( acv, ( _qual_pos - 1 - _j ) *
                              sizeof( tgg00_StackOpType ), _and_arr.eop_arr );
                        IF  _and_arr.eop_arr = NIL
                        THEN
                            a07_b_put_error( acv, e_no_more_memory, 1 )
                        ELSE
                            (* 'hide' AND stack entries *)
                            WHILE _qual_pos - 1 > _j DO
                                BEGIN
                                _qual_pos   := _qual_pos - 1;
                                acv.a_mblock.mb_qual^.mqual_cnt   :=
                                      acv.a_mblock.mb_qual^.mqual_cnt - 1;
                                acv.a_mblock.mb_qual^.mfirst_free :=
                                      acv.a_mblock.mb_qual^.mfirst_free - 1;
                                _and_count  := _and_count + 1;
                                _and_arr.eop_arr^[ _and_count ] :=
                                      acv.a_mblock.mb_st^[ _qual_pos ].eop
                                END;
                            (*ENDWHILE*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    _jump_stentry_pos := acv.a_mblock.mb_qual^.mfirst_free;
                    (* create space for st_jump_false *)
                    acv.a_mblock.mb_qual^.mqual_cnt         :=
                          acv.a_mblock.mb_qual^.mqual_cnt   + 1;
                    acv.a_mblock.mb_qual^.mfirst_free       :=
                          acv.a_mblock.mb_qual^.mfirst_free + 1;
                    IF  acv.a_mblock.mb_qual^.mview_cnt > 0
                    THEN
                        acv.a_mblock.mb_qual^.mview_cnt :=
                              acv.a_mblock.mb_qual^.mview_cnt + 1;
                    (*ENDIF*) 
                    _qual_pos := _qual_pos + 1;
                    END;
&               IFDEF TRACE
                (*ENDIF*) 
            (*ENDIF*) 
            t01int4( ak_sem, 'jump_stentry', _jump_stentry_pos );
            t01int4( ak_sem, 'qual_pos    ', _qual_pos );
            t01int4( ak_sem, 'j_v_keylen  ', j_v_par.j_v_keylen );
            t01int4( ak_sem, 'vdatalen    ',
                  j_v_par.j_v_qual_stack^.sviewqual_stack.vdatalen );
&           ENDIF
            (* insert stack entries *)
            SAPDB_PascalMove ('VAK59 ',   1,    
                  _jmblock_ptr^.mb_st_size, acv.a_mblock.mb_st_size,
                  @_jmblock_ptr^.mb_st^[ _stpos ], 1,
                  @acv.a_mblock.mb_st^ [ _qual_pos ],
                  1, _stcount * STACK_ENTRY_MXGG00,
                  acv.a_returncode );
            _j :=  _qual_pos;
&           ifdef trace
            t01messblock( ak_sem, '59add after ', acv.a_mblock );
&           endif
            (* scan over new stack entries *)
            WHILE _j <= _qual_pos + _stcount DO
                IF  acv.a_mblock.mb_st^[ _j ].etype in [ st_value,st_date, st_time,
                    st_timestamp,
                    (* PTS 1116175 E.Z. *)
                    st_utcdate,
                    (* PTS 1109925 E.Z. *)
                    st_utcdiff, st_user, st_usergroup, st_current_schema,
                    st_transaction,
                    st_timezone (* PTS 1122262 E.Z. *)
                    ]
                THEN
                    BEGIN
                    _move_len :=
                          j_v_par.j_v_qual_stack^.sviewqual_stack.vdatalen;
                    _j        := csp_maxint2; (* exit while *)
                    END
                ELSE
                    _j := succ( _j );
                (*ENDIF*) 
            (*ENDWHILE*) 
            acv.a_mblock.mb_qual^.mfirst_free :=
                  acv.a_mblock.mb_qual^.mfirst_free + _stcount;
            acv.a_mblock.mb_qual^.mqual_cnt   :=
                  acv.a_mblock.mb_qual^.mqual_cnt + _stcount;
            acv.a_mblock.mb_qual^.mview_pos   :=
                  acv.a_mblock.mb_qual^.mqual_pos;
            acv.a_mblock.mb_qual^.mview_cnt   :=
                  acv.a_mblock.mb_qual^.mqual_cnt;
            IF  _jump_stentry_pos > 0
            THEN
                BEGIN
                (* create AND *)
                _l := acv.a_mblock.mb_qual^.mqual_cnt;
                a65_set_operator( acv, op_and );
                IF  ( _l < acv.a_mblock.mb_qual^.mqual_cnt ) AND
                    ( acv.a_mblock.mb_qual^.mview_cnt > 0 )
                THEN
                    acv.a_mblock.mb_qual^.mview_cnt :=
                          acv.a_mblock.mb_qual^.mview_cnt + 1;
                (*ENDIF*) 
                ;
                (* create st_jump_false*)
                a61_set_jump( acv.a_mblock, _jump_stentry_pos, st_jump_false );
                IF  _and_count > 0
                THEN
                    (* The collected operators are inserted *)
                    (* and Jumps to the old end of Stack    *)
                    (* (before view_put_into) are changed   *)
                    BEGIN
                    FOR _j := _and_count DOWNTO 1 DO
                        a65_set_operator( acv, _and_arr.eop_arr^[ _j ] );
                    (*ENDFOR*) 
                    a10dispose( acv, _and_arr.any_ptr );
                    FOR _j := 1 TO _qual_pos - 2 DO
                        IF  acv.a_mblock.mb_st^[ _j ].etype = st_jump_false
                        THEN
                            IF  ( ( _j + acv.a_mblock.mb_st^ [ _j ].epos ) >
                                _jump_stentry_pos )
                            THEN
                                acv.a_mblock.mb_st^[ _j ].epos :=
                                      acv.a_mblock.mb_st^[ _j ].epos + _stcount + 2;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDFOR*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  acv.a_ex_kind = only_parsing
            THEN
                a54_fixedpos( acv, dmli );
            (*ENDIF*) 
            a54_in_buf( acv, dmli, j_v_par.j_v_qual_stack,
                  _move_len, _qual_pos, _stcount,
                  j_v_par.j_v_qual_stack^.sviewqual_stack.vdatapos, 0 );
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak59analyze_foreign_key_upd (
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info;
            updcol_cnt  : integer;
            VAR setdfa  : tak_dfarr;
            VAR j_v_par : tak59_jv_parameter);
 
VAR
      _i            : integer;
      _j            : integer;
      _read_idx     : integer;
      _catalog_key  : tgg00_SysInfoKey;
      _catalog_ptr  : tak_sysbufferaddress;
      (*_analyzed     : ARRAY[ 1..cak00_maxsources, 1..cak00_maxsources ]
      OF boolean; *)
      _analyzed     : tak59_boolptr;
      _bptr         : tak59_boolptr;
      _b_err        : tgg00_BasisError;
&     ifdef trace
      _colname : tsp00_KnlIdentifier;
&     endif
 
      _cast                : RECORD
            CASE boolean OF
                true :
                    (addr: tsp00_Addr);
                false :
                    (bptr : tak59_boolptr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
_cast.addr := gg941Allocate( acv.a_transinf.tri_trans,
      j_v_par.j_v_qual_basis^.sviewqual_basis.vbasetabcnt *
      j_v_par.j_v_qual_basis^.sviewqual_basis.vbasetabcnt * sizeof(boolean) );
_analyzed := _cast.bptr;
IF  ( _analyzed <> NIL )
THEN
    BEGIN
    FOR _i := 1 TO j_v_par.j_v_qual_basis^.sviewqual_basis.vbasetabcnt DO
        FOR _j := 1 TO j_v_par.j_v_qual_basis^.sviewqual_basis.vbasetabcnt DO
            BEGIN
            (* _analyzed [ _i, _j ] := false; *)
            _bptr  := ak59get_analyzed( _analyzed,
                  j_v_par.j_v_qual_basis^.sviewqual_basis.vbasetabcnt, _i, _j  );
            _bptr^ := false;
            END;
        (*ENDFOR*) 
    (*ENDFOR*) 
    _b_err := e_ok;
    FOR _i := 1 TO dmli.d_sparr.pbasep^.sbase.bmaxcol DO
        IF  setdfa[ _i ].dml_node <> 0
        THEN
            WITH setdfa[ _i ] DO
                IF  ctlink in dml_col_ptr^.ccolpropset
                THEN
                    BEGIN (* Foreign Key column update *)
&                   IFDEF TRACE
                    a061get_colname( dml_col_ptr^, _colname );
                    t01lidentifier( ak_sem, _colname );
&                   ENDIF
                    IF  j_v_par.j_v_qual_derived = NIL
                    THEN
                        _b_err := e_sysinfo_not_found;
                    (*ENDIF*) 
                    _catalog_ptr := j_v_par.j_v_qual_derived;
                    _catalog_key := j_v_par.j_v_qual_derived^.syskey;
                    _j        := 1;
                    _read_idx := 1;
                    WHILE ( _b_err = e_ok ) AND
                          ( _j <= _catalog_ptr^.sviewqual_derivedcol.vderivedcnt )
                          DO
                        BEGIN
                        IF  _read_idx > cak_max_viewqual_derivedcol
                        THEN
                            (* record overflow handling *)
                            BEGIN
                            IF  _catalog_ptr^.syskey.slinkage <>
                                cak_init_linkage
                            THEN
                                a10rel_sysinfo( _catalog_ptr );
                            (*ENDIF*) 
                            a06inc_linkage( _catalog_key.slinkage );
                            a10get_sysinfo( acv, _catalog_key, d_fix,
                                  _catalog_ptr, _b_err );
                            _read_idx := 1;
                            END;
                        (*ENDIF*) 
                        WITH dml_col_ptr^, _catalog_ptr^.sviewqual_derivedcol.
                             vderived_cols[ _read_idx ] DO
                            BEGIN
                            IF  _b_err = e_ok
                            THEN
                                BEGIN
&                               IFDEF TRACE
                                t01int4( ak_sem, 'dtabno      ', dtabno );
                                t01int4( ak_sem, 'ctabno      ', ctabno );
                                t01int4( ak_sem, 'dexttabno   ', dexttabno );
                                t01int4( ak_sem, 'dextno      ', dextno );
                                t01int4( ak_sem, 'drecno      ', drecno );
                                t01int4( ak_sem, 'creccolno   ', creccolno );
                                t01int4( ak_sem, 'cextcolno   ', cextcolno );
&                               ENDIF
                                IF  dextno = cextcolno
                                THEN
                                    IF  NOT ( j_v_par.j_v_qual_basis^.sviewqual_basis.
                                        vtable[ dexttabno ].vtone_to_one )
                                        OR
                                        NOT ( j_v_par.j_v_qual_basis^.sviewqual_basis.
                                        vtable[ dtabno ].vtone_to_one )
                                    THEN
                                        BEGIN
&                                       ifdef trace
                                        IF  (( dexttabno >
                                            j_v_par.j_v_qual_basis^.sviewqual_basis.
                                            vbasetabcnt ) OR
                                            ( dtabno > j_v_par.j_v_qual_basis^.
                                            sviewqual_basis.vbasetabcnt ))
                                        THEN
                                            BEGIN
                                            g01abort( ord(e_move_error),
                                                  csp3_n_view,
                                                  'TABLE CNT RANGE CHECK   ', 0)
                                            END
                                        ELSE
&                                           endif
                                            BEGIN
                                            _bptr := ak59get_analyzed(
                                                  _analyzed,
                                                  j_v_par.j_v_qual_basis^.
                                                  sviewqual_basis.vbasetabcnt,
                                                  dexttabno, dtabno );
                                            (* IF  NOT _analyzed[ dexttabno, dtabno ] *)
                                            IF  ( NOT _bptr^ )
                                            THEN
                                                BEGIN
                                                (*
                                                      _analyzed [ dexttabno, dtabno ] := true;
                                                      _analyzed [ dtabno, dexttabno ] := true;
                                                      *)
                                                _bptr^ := true;
                                                _bptr  := ak59get_analyzed(
                                                      _analyzed,
                                                      j_v_par.j_v_qual_basis^.sviewqual_basis.
                                                      vbasetabcnt,
                                                      dtabno, dexttabno );
                                                _bptr^ := true;
                                                ak59partial_fk_upd( acv, dmli,
                                                      _read_idx, _catalog_ptr,
                                                      updcol_cnt, setdfa, j_v_par );
                                                END;
                                            (*ENDIF*) 
                                            END;
                                        (*ENDIF*) 
                                        END;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                _j        := succ( _j );
                                _read_idx := succ( _read_idx );
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDWITH*) 
                        END;
                    (*ENDWHILE*) 
                    IF  _catalog_ptr^.syskey.slinkage <> cak_init_linkage
                    THEN
                        a10rel_sysinfo( _catalog_ptr );
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDFOR*) 
    END
ELSE
    _b_err := e_no_more_memory;
(*ENDIF*) 
IF  ( _b_err <> e_ok )
THEN
    a07_b_put_error( acv, _b_err, 1 );
(*ENDIF*) 
IF  ( _analyzed <> NIL )
THEN
    BEGIN
    _cast.bptr := _analyzed;
    gg941Deallocate( acv.a_transinf.tri_trans, _cast.addr );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak59build_select_cmd (
            VAR acv     : tak_all_command_glob;
            VAR j_v_par : tak59_jv_parameter);
 
VAR
      _request_len : tsp00_Int4;
      _qual_len    : tsp00_Int4;
      _declare_txt : tsp00_C20;
      _select_txt  : tsp00_C20;
      _for_upd_txt : tsp00_C20;
      _org_len     : tsp00_Int4;
      _moveLen     : integer;
      _org_cmd     : tsp00_MoveObjPtr;
      (* This procedure creates a new command in a_cmd_part in the form: *)
      (* SELECT RES (x) FROM <user>.<name> [<ref>] [<qual>] FOR UPDATE OF   *)
 
BEGIN
_declare_txt := 'DECLARE RES CURSOR  ';
_select_txt  := 'FOR SELECT  * FROM  '; (* PTS 1111062 *)
_for_upd_txt := ' FOR UPDATE OF      ';
IF  j_v_par.j_v_mtype = m_delete
THEN (* replace the asterisk. *)
    _select_txt[ 13 ] := '.';
(* How long the new cmd string will become? *)
(*ENDIF*) 
IF  j_v_par.j_v_qualified <> c_no_where_node
THEN
    _qual_len := acv.a_cmd_part^.sp1p_buf_len - j_v_par.j_v_qualified + 1
ELSE
    _qual_len := 0;
(*ENDIF*) 
_request_len :=
      a01char_size * sizeof( _declare_txt ) +
      a01char_size * sizeof( _select_txt ) +
      2 * ( sizeof( tsp00_KnlIdentifier ) + 2 )  +
      a01char_size * 2                   + (* dot + blank *)
      _qual_len                           +
      a01char_size * sizeof( _for_upd_txt );
IF  j_v_par.j_v_reference <> a01_il_b_identifier
THEN
    _request_len := _request_len +
          sizeof( tsp00_KnlIdentifier ) + 3 * a01char_size;
(* Now we get a new command part after remember the old one. *)
(*ENDIF*) 
_org_len := acv.a_cmd_part^.sp1p_buf_len;
_org_cmd := @acv.a_cmd_part^.sp1p_buf;
a542internal_packet( acv, NOT c_release_internal, _request_len );
IF  acv.a_returncode = 0
THEN
    BEGIN
    a542move_to_packet( acv, @_declare_txt, sizeof( _declare_txt ));
    a542move_to_packet( acv, @_select_txt, sizeof( _select_txt ));
    a542identifier_to_packet( acv, j_v_par.j_v_schema );
    a542char_to_packet( acv, '.');
    a542identifier_to_packet( acv, j_v_par.j_v_name );
    a542char_to_packet( acv, bsp_c1 );
    IF  j_v_par.j_v_reference <> a01_il_b_identifier
    THEN
        BEGIN
        a542identifier_to_packet( acv, j_v_par.j_v_reference );
        a542char_to_packet( acv, bsp_c1 )
        END;
    (*ENDIF*) 
    IF  _qual_len > 0
    THEN
        BEGIN
        acv.a_errpos_offset :=
              j_v_par.j_v_qualified - acv.a_cmd_part^.sp1p_buf_len - 1;
        SAPDB_PascalMove ('VAK59 ',   2,    
              _org_len, _request_len, @_org_cmd^, j_v_par.j_v_qualified,
              @acv.a_cmd_part^.sp1p_buf, acv.a_cmd_part^.sp1p_buf_len+1,
              _qual_len, acv.a_returncode );
        acv.a_cmd_part^.sp1p_buf_len :=
              acv.a_cmd_part^.sp1p_buf_len + _qual_len
        END;
    (*ENDIF*) 
    IF  (acv.a_comp_type = at_odbc) OR (acv.a_comp_type = at_jdbc) (* PTS 1111062 *)
    THEN
        _moveLen := 14
    ELSE
        _moveLen := 11;
    (*ENDIF*) 
    a542move_to_packet( acv, @_for_upd_txt, _moveLen );
&   ifdef trace
    t01moveobj( ak_sem,
          acv.a_cmd_part^.sp1p_buf, 1, acv.a_cmd_part^.sp1p_buf_len );
&   endif
    END;
(*ENDIF*) 
IF  ( j_v_par.j_v_mtype = m_delete ) OR
    ( hsPermLock_egg00 in acv.a_transinf.tri_global_state )
THEN (* release temp locks after command execution. *)
    acv.a_qualified_jv_upd := jv_upd_end_release
ELSE (* release temp locks before update phase. *)
    acv.a_qualified_jv_upd := jv_upd_release_locks;
(*ENDIF*) 
IF  acv.a_ex_kind = only_parsing
THEN
    acv.a_command_kind := complex_view_command;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak59check_join_view (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            VAR j_v_par    : tak59_jv_parameter;
            check_view     : boolean;
            last_pars_part : boolean);
 
VAR
      _i        : integer;
      _jvrec    : tak68_joinview_rec;
      _dummy    : tak_parskey;
      _res_tree : tgg00_FileId;
      _series   : tak68_sequence;
      _syskey       : tgg00_SysInfoKey;
      _catalog_ptr  : tak_sysbufferaddress;
      _b_err        : tgg00_BasisError;
 
BEGIN
IF  acv.a_ex_kind = only_parsing
THEN
    BEGIN
    a06a_mblock_init( acv, m_key, mm_nokey, b01niltree_id );
    a660_new_pparsp( acv, dmli.d_sparr,
          NOT c_first_parsinfo, NOT c_complicate );
    IF  acv.a_returncode = 0
    THEN
        WITH dmli.d_sparr.pparsp^.sparsinfo  DO
            BEGIN
            p_treeid        := b01niltree_id;
            p_treeid.fileTabId_gg00  := dmli.d_sparr.pbasep^.syskey.stableid;
            p_tabid         := j_v_par.j_v_tabid;
            p_j_v_keylen    := j_v_par.j_v_keylen;
            p_joinviewtabcnt := dmli.d_sparr.pbasep^.sbase.bv_tabcount;
            p_mtyp          := m_key;
            p_mtyp2         := mm_nokey;
            p_reuse         := dmli.d_checkview;
            p_select        := NOT( check_view );
            a54_last_part( acv, dmli.d_sparr, last_pars_part );
            END
        (*ENDWITH*) 
    (*ENDIF*) 
    END
ELSE
    BEGIN
    a06a_mblock_init( acv, m_select, mm_nil, b01niltree_id );
    acv.a_mblock.mb_data_len := cgg_rec_key_offset+j_v_par.j_v_keylen;
    acv.a_mblock.mb_data^.mbp_keylen  := j_v_par.j_v_keylen;
    dmli.d_tabarr^[ 1 ].ofromtableid := dmli.d_sparr.pbasep^.syskey.stableid;
    dmli.d_tabarr^[ 1 ].oview        := true;
    _jvrec.jv_tabid     := j_v_par.j_v_syskey.stableid;
    _jvrec.jv_keybuf    := j_v_par.j_v_viewkeybuf;
    _jvrec.jv_maxkeyl   := j_v_par.j_v_keylen;
    a54_view_put_into( acv, dmli );
    dmli.d_view       := true;
    dmli.d_cntfromtab := dmli.d_sparr.pbasep^.sbase.bv_tabcount;
    dmli.d_single     := true;
    dmli.d_globstate  := acv.a_transinf.tri_global_state;
    IF  hsWithoutLock_egg00 in dmli.d_globstate
    THEN
        dmli.d_globstate := dmli.d_globstate - [ hsWithoutLock_egg00 ] +
              [ hsConsistentLock_egg00 ];
    (*ENDIF*) 
    FOR _i := 1 TO dmli.d_cntfromtab DO
        BEGIN
        _series[ _i ].jos_joinstrat        := strat_join_viewkey;
        _series[ _i ].jos_source           := _i;
        _series[ _i ].jos_joinno           := IS_UNDEFINED_GG07;
        _series[ _i ].jos_predefined_buf   := false;
        _series[ _i ].jos_table_buffer     := 0;
        _series[ _i ].jos_expected_recs    := 1;
        _series[ _i ].jos_invlen           := IS_UNDEFINED_GG07;
        _series[ _i ].jos_access_mod       := [];
        _series[ _i ].jos_expected_table_rec_reads := 0;
        END;
    (*ENDFOR*) 
    _series[ 1 ].jos_joinstrat := strat_viewkey;
    (* _res_tree is just a dummy and will never be used but needs to be *)
    (* initialized properly nevertheless                                *)
    g04build_temp_tree_id (_res_tree, acv.a_transinf.tri_trans);
    _res_tree.fileTfnTemp_gg00 := ttfnUserResult_egg00;
    ;
    (* test for join implementation *)
    _b_err := e_ok;
    a682join_MBlock_key( acv, dmli, _dummy, _jvrec.jv_tabid, 1,
          _syskey, c_seqsearch_for_exec );
    a10get_sysinfo( acv, _syskey, d_release, _catalog_ptr, _b_err );
    IF  ( _b_err <> e_ok )
    THEN
        a07ak_system_error( acv, 59, 4 )
    ELSE
        BEGIN
&       ifdef trace
        t01mess2type( ak_sem, 'm2type MBLOC',
              _catalog_ptr^.smessblock.mbr_mess_block.mb_type2 );
&       endif
        IF  ( _catalog_ptr^.smessblock.mbr_mess_block.mb_type2 in
            [ mm_operator_join, mm_last_operator_join, mm_first_operator_join ])
        THEN
            BEGIN
            a682_execute_join_operator( acv, dmli, _series, _res_tree,
                  _dummy, _jvrec, NOT c_use_old_rescnt, c_seqsearch_for_exec );
            END
        ELSE
            BEGIN
            a682_execute_join( acv, dmli, _series, _res_tree,
                  _dummy, _jvrec, NOT c_use_old_rescnt, c_seqsearch_for_exec );
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    dmli.d_view := false;
    dmli.d_cntfromtab  := 1
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak59check_key_update (
            VAR acv       : tak_all_command_glob;
            VAR j_v_par   : tak59_jv_parameter;
            VAR viewdfa   : tak_dfarr;
            VAR globstate : tgg00_HandlingSet);
 
VAR
      _ok        : boolean;
      _col_ind   : integer;
      _base_ptr  : tak_sysbufferaddress;
 
BEGIN
_col_ind := j_v_par.j_v_viewptr^.sbase.bfirstcolind;
WHILE _col_ind <> 0 DO
    WITH a103GetColumn (j_v_par.j_v_viewptr^.sbase, _col_ind )^ DO
        IF  NOT ( ctjoinviewkey in ccolpropset )
        THEN
            _col_ind := 0
        ELSE
            BEGIN
            IF  viewdfa[cextcolno].dml_node <> 0
            THEN
                BEGIN
&               ifdef trace
                t01int4( ak_sem, 'key update  ', 1 );
&               endif
                _col_ind        := 0;
                j_v_par.j_v_key_update := true;
                END
            ELSE
                _col_ind := cnextind
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDWHILE*) 
IF  j_v_par.j_v_key_update
THEN
    BEGIN
    WITH j_v_par.j_v_qual_basis^.sviewqual_basis.vtable[ 1 ] DO
        a06_systable_get( acv, d_release, vttableid,
              _base_ptr, NOT c_get_all, _ok );
    (*ENDWITH*) 
    IF  _ok
    THEN
        IF  (is_primary_table in _base_ptr^.sbase.blinkexist) AND
            NOT acv.a_isReplicationSession
        THEN
            globstate := globstate + [ hsTempLock_egg00 ]
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak59check_links (
            VAR acv       : tak_all_command_glob;
            VAR j_v_par   : tak59_jv_parameter;
            VAR globstate : tgg00_HandlingSet);
 
VAR
      _loop     : boolean;
      _i        : integer;
      _base_ptr : tak_sysbufferaddress;
 
BEGIN
(* check for neccessary locks *)
_i        := 1;
_loop     := true;
_base_ptr := NIL;
WHILE _loop AND ( acv.a_returncode = 0 ) DO
    BEGIN
    IF  _i > j_v_par.j_v_qual_basis^.sviewqual_basis.vbasetabcnt
    THEN
        _loop := false
    ELSE
        BEGIN
        IF  j_v_par.j_v_qual_basis^.sviewqual_basis.vtable[ _i ].vtone_to_one
        THEN
            BEGIN
            a06_systable_get( acv, d_release,
                  j_v_par.j_v_qual_basis^.sviewqual_basis.vtable[ _i ].vttableid,
                  _base_ptr, NOT c_get_all, _loop );
            IF  NOT ( _loop )
            THEN
                a07ak_system_error( acv, 59, 1 )
            ELSE
                BEGIN
                IF  (is_primary_table in _base_ptr^.sbase.blinkexist) AND
                    NOT acv.a_isReplicationSession
                THEN
                    BEGIN
                    _loop := false;
                    IF  j_v_par.j_v_qualified = c_no_qualification
                    THEN
                        (* current table is primary table   *)
                        (* of a referential constraint =>   *)
                        (* temp locks are required          *)
                        globstate := globstate + [ hsTempLock_egg00 ];
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        _i := succ( _i );
        END;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak59dependant_tables (
            VAR acv     : tak_all_command_glob;
            VAR j_v_par : tak59_jv_parameter;
            tabno       : integer);
 
VAR
      _i            : integer;
      _read_idx     : integer;
      _catalog_ptr  : tak_sysbufferaddress;
      _catalog_key  : tgg00_SysInfoKey;
      _b_err        : tgg00_BasisError;
 
BEGIN
&IFDEF TRACE
t01int4( ak_sem , 'deptables of', tabno );
&ENDIF
_b_err := e_ok;
IF  tabno > 0
THEN
    BEGIN
    IF  j_v_par.j_v_qual_derived = NIL
    THEN
        _b_err := e_sysinfo_not_found;
    (*ENDIF*) 
    _catalog_key := j_v_par.j_v_qual_derived^.syskey;
    _catalog_ptr := j_v_par.j_v_qual_derived;
    _i        := 1;
    _read_idx := 1;
    WHILE ( _b_err = e_ok ) AND
          ( _i <= j_v_par.j_v_qual_derived^.sviewqual_derivedcol.vderivedcnt ) DO
        BEGIN
        IF  _read_idx > cak_max_viewqual_derivedcol
        THEN
            (* record overflow handling *)
            BEGIN
            IF  _catalog_ptr^.syskey.slinkage <> cak_init_linkage
            THEN
                a10rel_sysinfo( _catalog_ptr );
            (*ENDIF*) 
            a06inc_linkage( _catalog_key.slinkage );
            a10get_sysinfo( acv, _catalog_key, d_fix, _catalog_ptr, _b_err );
            _read_idx := 1;
            END;
        (*ENDIF*) 
        IF  _b_err = e_ok
        THEN
            WITH j_v_par.j_v_qual_derived^.sviewqual_derivedcol.
                 vderived_cols [ _read_idx ] DO
                IF  dtabno = tabno
                THEN
                    BEGIN
                    IF  ord( dexttabno ) > tabno
                    THEN
                        BEGIN
                        j_v_par.j_v_tabset[ ord( dexttabno ) ] := true;
                        ak59dependant_tables( acv, j_v_par, ord( dexttabno ))
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    IF  dtabno > tabno
                    THEN
                        BEGIN
                        IF  ord( dexttabno ) = tabno
                        THEN
                            BEGIN
                            j_v_par.j_v_tabset[ dtabno ] := true;
&                           IFDEF TRACE
                            t01int4( ak_sem , 'dependant is', dtabno );
&                           ENDIF
                            ak59dependant_tables( acv, j_v_par, dtabno );
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
        _i        := succ( _i );
        _read_idx := succ( _read_idx );
        END;
    (*ENDWHILE*) 
    IF  _catalog_ptr^.syskey.slinkage <> cak_init_linkage
    THEN
        a10rel_sysinfo( _catalog_ptr );
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  _b_err <> e_ok
THEN
    a07_b_put_error( acv, _b_err, 1 );
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak59determine_prim_tab (
            VAR acv     : tak_all_command_glob;
            VAR col_info  : tak00_columninfo;
            VAR j_v_par   : tak59_jv_parameter;
            VAR primtabno : integer);
 
VAR
      _i            : integer;
      _read_idx     : integer;
      _catalog_ptr  : tak_sysbufferaddress;
      _catalog_key  : tgg00_SysInfoKey;
      _b_err        : tgg00_BasisError;
 
BEGIN
WITH col_info DO
    BEGIN
    primtabno := 0;
    IF  ctkey in ccolpropset
    THEN
        primtabno := ctabno
    ELSE
        BEGIN
        IF  j_v_par.j_v_qual_derived = NIL
        THEN
            _b_err := e_sysinfo_not_found
        ELSE
            _b_err := e_ok;
        (*ENDIF*) 
        _catalog_key := j_v_par.j_v_qual_derived^.syskey;
        _catalog_ptr := j_v_par.j_v_qual_derived;
        _i        := 1;
        _read_idx := 1;
        WHILE ( _b_err = e_ok ) AND
              ( _i <= _catalog_ptr^.sviewqual_derivedcol.vderivedcnt ) DO
            BEGIN
            IF  _read_idx > cak_max_viewqual_derivedcol
            THEN
                (* record overflow handling *)
                BEGIN
                a06inc_linkage( _catalog_key.slinkage );
                a10get_sysinfo( acv, _catalog_key, d_release,
                      _catalog_ptr, _b_err );
                _read_idx := 1;
                END;
            (*ENDIF*) 
            IF  _b_err = e_ok
            THEN
                IF  _catalog_ptr^.sviewqual_derivedcol.
                    vderived_cols[ _read_idx ].dextno = cextcolno
                THEN
                    BEGIN
                    primtabno  := _catalog_ptr^.sviewqual_derivedcol.
                          vderived_cols[ _read_idx ].dtabno;
                    _i         := csp_maxint2 (* exit while *)
                    END
                ELSE
                    BEGIN
                    _i        := succ( _i );
                    _read_idx := succ( _read_idx );
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        IF  _b_err <> e_ok
        THEN
            a07_b_put_error( acv, _b_err, 1 );
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  primtabno <> 0
    THEN
        IF  j_v_par.j_v_qual_basis^.sviewqual_basis.vtable[ primtabno ].vtone_to_one
        THEN
            primtabno := 0;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  primtabno <> 0
    THEN
        BEGIN
&       ifdef trace
        t01int4( ak_sem , 'dependant is', primtabno );
&       endif
        IF  NOT ( j_v_par.j_v_ins_after_upd )
        THEN
            FOR _i := 1 TO cak00_maxsources DO
                j_v_par.j_v_tabset[ _i ] := false;
            (*ENDFOR*) 
        (*ENDIF*) 
        j_v_par.j_v_tabset[ primtabno ] := true;
        j_v_par.j_v_ins_after_upd       := true
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak59dml_join_view (
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info;
            VAR viewdfa : tak_dfarr;
            VAR j_v_par : tak59_jv_parameter);
 
CONST
      c_useLiteralBuf = true;
 
VAR
      _f_ok       : boolean;
      _ascending  : boolean;
      _exit_loop  : boolean;
      _init_mtype : tgg00_MessType;
      _i          : integer;
      _tab_cnt    : integer;
      _use_tab    : tak59_usedtables;
 
      _literalrec : RECORD
            CASE boolean OF
                true :
                    (sysbuf : tak_sysbufferaddress);
                false :
                    (any_ptr : tsp00_Addr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
_literalrec.sysbuf := NIL;
_init_mtype := j_v_par.j_v_mtype;
CASE j_v_par.j_v_mtype OF
    m_update :
        BEGIN
        _ascending := false;
        ak59upd_new_view_rec( acv, dmli, viewdfa, j_v_par );
        END;
    m_delete :
        _ascending := true;
    m_insert :
        _ascending := false;
    END;
(*ENDCASE*) 
FOR _i := 1 TO j_v_par.j_v_qual_basis^.sviewqual_basis.vbasetabcnt DO
    WITH j_v_par.j_v_qual_basis^.sviewqual_basis.vtable[ _i ] DO
        _use_tab[ _i ] := vtone_to_one OR ( j_v_par.j_v_mtype = m_insert );
    (*ENDWITH*) 
(*ENDFOR*) 
&IFDEF TRACE
FOR _i := 1 TO j_v_par.j_v_qual_basis^.sviewqual_basis.vbasetabcnt DO
    IF  _use_tab[ _i ]
    THEN
        t01int4( ak_sem, 'use_tab     ', _i );
&   ENDIF
    (*ENDIF*) 
(*ENDFOR*) 
dmli.d_sparr.pcount := 0;
_tab_cnt        := 1;
_exit_loop      := false;
dmli.d_join_dml := j_v_par.j_v_join_upd;
WHILE NOT ( _exit_loop ) AND ( acv.a_returncode = 0 ) DO
    BEGIN
    IF  _ascending
    THEN
        j_v_par.j_v_tableno := _tab_cnt
    ELSE (* start with last table stored in viewqualrecord *)
        j_v_par.j_v_tableno := j_v_par.j_v_qual_basis^.sviewqual_basis.vbasetabcnt -
              _tab_cnt + 1;
    (*ENDIF*) 
    IF  _use_tab[ j_v_par.j_v_tableno ]
    THEN
        BEGIN
        dmli.d_linkbuf := NIL;
        WITH j_v_par.j_v_qual_basis^.sviewqual_basis.vtable[ j_v_par.j_v_tableno ] DO
            a06_systable_get( acv, d_fix, vttableid,
                  dmli.d_sparr.pbasep, c_get_all, _f_ok );
        (*ENDWITH*) 
        IF  NOT _f_ok
        THEN
            a07ak_system_error( acv, 59, 2 )
        ELSE
            BEGIN
            WITH j_v_par.j_v_qual_basis^.sviewqual_basis.vtable[ j_v_par.j_v_tableno ],
                 dmli.d_tabarr^[ 1 ] DO
                BEGIN
                otreeid := dmli.d_sparr.pbasep^.sbase.btreeid;
                oview   := false
                END;
            (*ENDWITH*) 
&           IFDEF TRACE
            t01int4( ak_sem,'tableno     ',j_v_par.j_v_tableno );
            t01int4( ak_sem,'vbasetabcnt ',
                  j_v_par.j_v_qual_basis^.sviewqual_basis.vbasetabcnt );
&           ENDIF
            ak59one_tab_join_dml( acv, dmli, viewdfa, viewdfa, j_v_par );
            IF  (( j_v_par.j_v_mtype = m_insert ) OR
                (( j_v_par.j_v_mtype = m_update ) AND j_v_par.j_v_column_updated ))
                AND ( acv.a_returncode = 0 )
            THEN
                BEGIN
                IF  ( j_v_par.j_v_mtype = m_update ) AND ( dmli.d_linkbuf <> NIL )
                THEN
                    WITH j_v_par.j_v_qual_basis^.sviewqual_basis.
                         vtable[ j_v_par.j_v_tableno ] DO
                        a56put_link_info( acv, dmli.d_sparr.pbasep,
                              vtnot_used_links, j_v_par.j_v_qual_basis,
                              dmli.d_linkbuf );
                    (*ENDWITH*) 
                (*ENDIF*) 
                a54_last_part( acv, dmli.d_sparr, NOT c_last_pars_part );
                END;
            (* PTS 1123727 E.Z. *)
            (*ENDIF*) 
            IF  dmli.d_literalrec <> NIL
            THEN
                _literalrec.sysbuf := dmli.d_literalrec;
            (*ENDIF*) 
            a10rel_sysinfo( dmli.d_sparr.pbasep );
            END;
        (*ENDIF*) 
        IF  dmli.d_linkbuf <> NIL
        THEN
            a56insert_upd_with_link( acv, dmli.d_linkbuf );
        (* PTS 1123727 E.Z. *)
        (*ENDIF*) 
        IF  (_init_mtype = m_insert) AND
            (_literalrec.sysbuf <> NIL)      AND
            (acv.a_init_ex_kind <> only_parsing)
        THEN
            BEGIN
            IF  (acv.a_returncode = 0)
            THEN
                a507_literal (acv, _literalrec.sysbuf^.slongliteral,
                      NOT c_useLiteralBuf);
            (*ENDIF*) 
            a10dispose (acv, _literalrec.any_ptr);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    _tab_cnt := succ( _tab_cnt );
    IF  _tab_cnt > j_v_par.j_v_qual_basis^.sviewqual_basis.vbasetabcnt
    THEN
        IF  ( j_v_par.j_v_ins_after_upd ) AND NOT ( j_v_par.j_v_phase_ins_after_upd )
        THEN
            BEGIN
            (* start insert phase after update                    *)
            (* update will fail, if a mandatory column of a table *)
            (* executed during the insert phase is missing        *)
            j_v_par.j_v_phase_ins_after_upd := true;
            j_v_par.j_v_mtype := m_insert;
            _use_tab  := j_v_par.j_v_tabset;
            _tab_cnt  := 1
            END
        ELSE
            _exit_loop := true;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  _init_mtype = m_update
THEN
    FOR _i := 1 TO j_v_par.j_v_viewptr^.sbase.bmaxcol DO
        IF  ( viewdfa[ _i ].dml_node > 0 ) AND NOT ( j_v_par.j_v_field_used[ _i ] )
        THEN
            (* a column of a secondary table should have been  *)
            (* updated, that only can be updated together with *)
            (* the corresponding foreign key column. This      *)
            (* foreign key update was missing                  *)
            a07_b_put_error( acv, e_missing_update_column, 1 );
        (*ENDIF*) 
    (*ENDFOR*) 
(*ENDIF*) 
dmli.d_sparr.pbasep := j_v_par.j_v_viewptr;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak59fill_dfa (
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info;
            VAR dfa     : tak_dfarr;
            enum_values : boolean;
            curr_n      : integer);
 
VAR
      _i       : integer;
&     ifdef trace
      _colname : tsp00_KnlIdentifier;
&     endif
 
BEGIN
FOR _i := 1 TO dmli.d_sparr.pbasep^.sbase.bmaxcol DO
    BEGIN
    dfa[ _i ].dml_node              := 0;
    dfa[ _i ].dml_colno_in_subquery := 0;
    dfa[ _i ].dml_res_index         := 0
    END;
(*ENDFOR*) 
IF  enum_values
THEN
    a56_enumerated_values( acv, dmli, dfa, curr_n )
ELSE
    BEGIN
    dmli.d_key := false;
    a55_named_values( acv, dmli, dfa, curr_n )
    END;
(*ENDIF*) 
&IFDEF TRACE
FOR _i := 1 TO dmli.d_sparr.pbasep^.sbase.bmaxcol DO
    WITH dfa[ _i ] DO
        IF  dml_node <> 0
        THEN
            BEGIN
            a061get_colname( dml_col_ptr^, _colname );
            t01int4( ak_sem, 'dm_node     ', dml_node );
            t01int4( ak_sem, 'dm_colno_sub', dml_colno_in_subquery );
            END;
&       ENDIF
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak59get_describe_key (
            VAR acv      : tak_all_command_glob;
            VAR dmli     : tak_dml_info;
            VAR j_v_par  : tak59_jv_parameter;
            init_ex_kind : tak_execution_kind);
 
VAR
      _key_into_part2 : boolean;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  acv.a_ex_kind = only_parsing
    THEN
        BEGIN
        _key_into_part2 := false;
        IF  init_ex_kind <> acv.a_ex_kind
        THEN
            (* execution kind has been changed for link execution *)
            a54_get_pparsp_pinfop( acv, dmli.d_sparr, m_delete )
        ELSE
            IF  dmli.d_sparr.pparsp = NIL
            THEN
                a660_new_pparsp( acv, dmli.d_sparr,
                      NOT c_first_parsinfo, NOT c_complicate );
            (*ENDIF*) 
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            dmli.d_sparr.pparsp^.sparsinfo.p_treeid :=
                  dmli.d_sparr.pbasep^.sbase.btreeid;
            dmli.d_sparr.pparsp^.sparsinfo.p_tabid  := j_v_par.j_v_tabid;
            IF  j_v_par.j_v_resname_node <> 0
            THEN
                a58_current_of( acv, dmli, j_v_par.j_v_resname_node )
            ELSE
                IF  acv.a_ex_kind = init_ex_kind
                THEN
                    WITH dmli.d_sparr.pparsp^.sparsinfo,
                         p_pars_infos[ p_cnt_infos+1 ] DO
                        BEGIN
                        fp_kind    := fp_viewkey_to_mess_buf;
                        fp_etype   := st_dummy;
                        fp_datatyp := dunknown;
                        WITH a103GetColumn (dmli.d_sparr.pbasep^.sbase,
                             dmli.d_sparr.pbasep^.sbase.blastkeyind)^ DO
                            fp_curr_keylen := ccolstack.epos +
                                  cinoutlen - 1;
                        (*ENDWITH*) 
                        dmli.d_maxlen    := fp_curr_keylen;
                        fp_startpos := 0;
                        fp_fill_51  := csp_maxint2;
                        fp_pos_no   := 0;
                        p_cnt_infos := succ( p_cnt_infos )
                        END
                    (*ENDWITH*) 
                ELSE
                    _key_into_part2 := true
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        _key_into_part2 := true;
    (*ENDIF*) 
    IF  _key_into_part2
    THEN
        BEGIN
        acv.a_mblock.mb_data^.mbp_keylen  :=
              j_v_par.j_v_viewkeybuf^.sviewkey.vkjvkeylen;
        acv.a_mblock.mb_data_len :=
              acv.a_mblock.mb_data^.mbp_keylen+cgg_rec_key_offset;
        SAPDB_PascalMove ('VAK59 ',   3,    
              sizeof( j_v_par.j_v_viewkeybuf^.sviewkey.vkjvkey ),
              acv.a_mblock.mb_data_size,
              @j_v_par.j_v_viewkeybuf^.sviewkey.vkjvkey, 1,
              @acv.a_mblock.mb_data^.mbp_buf, cgg_rec_key_offset + 1,
              j_v_par.j_v_viewkeybuf^.sviewkey.vkjvkeylen,
              acv.a_returncode )
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak59get_dfa_from_viewdfa (
            VAR acv     : tak_all_command_glob;
            VAR j_v_par : tak59_jv_parameter;
            VAR viewdfa : tak_dfarr;
            VAR sparr   : tak_syspointerarr;
            VAR dfa     : tak_dfarr;
            tableno     : integer;
            mtype       : tgg00_MessType);
 
VAR
      _describe_column  : boolean;
      _column_specified : boolean;
      _colind           : integer;
      _primtabno        : integer;
      _i                : integer;
      _reccolno         : integer;
      _read_idx         : integer;
      _col_ptr          : tak00_colinfo_ptr;
      _col_name         : tsp00_KnlIdentifier;
      _catalog_ptr      : tak_sysbufferaddress;
      _catalog_key      : tgg00_SysInfoKey;
      _b_err            : tgg00_BasisError;
 
BEGIN
j_v_par.j_v_column_updated := false;
FOR _i := 1 TO sparr.pbasep^.sbase.bmaxcol DO
    dfa[ _i ].dml_node := 0;
(*ENDFOR*) 
_colind := j_v_par.j_v_viewptr^.sbase.bfirstcolind;
WHILE ( _colind <> 0 ) AND ( acv.a_returncode = 0 ) DO
    WITH a103GetColumn (j_v_par.j_v_viewptr^.sbase, _colind)^ DO
        BEGIN
        _column_specified := false;
        _describe_column  := false;
        _reccolno         := creccolno;
        IF  viewdfa[ cextcolno ].dml_node = 0
        THEN
            BEGIN
            a061get_colname( a103GetColumn(j_v_par.j_v_viewptr^.sbase, _colind)^, _col_name );
            IF  ( ctjoinviewkey in ccolpropset ) AND
                ( tableno = c_get_key )
            THEN
                a07_nb_put_error( acv, e_missing_keyfield, 1, _col_name )
            ELSE
                IF  mtype = m_insert
                THEN
                    IF  NOT ( ctopt in ccolpropset ) AND
                        NOT ( j_v_par.j_v_phase_ins_after_upd )
                    THEN
                        a07_nb_put_error( acv,
                              e_mandatory_field_is_null, 1, _col_name )
                    ELSE
                        IF  ctabno = tableno
                        THEN
                            IF  j_v_par.j_v_phase_ins_after_upd
                            THEN
                                a07_nb_put_error( acv,
                                      e_missing_update_column, 1, _col_name )
                            ELSE
                                IF  NOT ( j_v_par.j_v_qual_basis^.sviewqual_basis.
                                    vtable[ tableno ].vtone_to_one )
                                THEN
                                    _describe_column := true
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            IF  tableno = c_get_key
            THEN
                BEGIN
&               IFDEF TRACE
                t01int4( ak_sem, 'ctabno      ', ctabno );
&               ENDIF
                IF  mtype <> m_insert
                THEN
                    IF  NOT ( ctjoinviewkey in ccolpropset )
                    THEN
                        BEGIN
                        a061get_colname( a103GetColumn (j_v_par.j_v_viewptr^.sbase, _colind )^, _col_name );
                        a07_nb_put_error( acv,
                              e_column_must_be_keycolumn,
                              acv.a_ap_tree^[ viewdfa[ cextcolno ].
                              dml_node ].n_pos, _col_name );
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  ctjoinviewkey in ccolpropset
                THEN
                    BEGIN
                    _column_specified := true;
                    IF  ctabno <> 1
                    THEN
                        BEGIN
                        IF  j_v_par.j_v_qual_derived = NIL
                        THEN
                            _b_err := e_sysinfo_not_found
                        ELSE
                            _b_err := e_ok;
                        (*ENDIF*) 
                        _catalog_key := j_v_par.j_v_qual_derived^.syskey;
                        _catalog_ptr := j_v_par.j_v_qual_derived;
                        _i        := 1;
                        _read_idx := 1;
                        WHILE ( _b_err = e_ok ) AND
                              ( _i <= _catalog_ptr^.sviewqual_derivedcol.
                              vderivedcnt ) DO
                            BEGIN
                            IF  _read_idx > cak_max_viewqual_derivedcol
                            THEN
                                (* record overflow handling *)
                                BEGIN
                                a06inc_linkage( _catalog_key.slinkage );
                                a10get_sysinfo( acv, _catalog_key,
                                      d_release, _catalog_ptr, _b_err );
                                _read_idx := 1;
                                END;
                            (*ENDIF*) 
                            IF  _b_err = e_ok
                            THEN
                                WITH _catalog_ptr^.sviewqual_derivedcol.
                                     vderived_cols[ _read_idx ] DO
                                    IF  ( dexttabno = ctabno )    AND
                                        ( dextno    = cextcolno ) AND
                                        ( dtabno    = 1 )
                                    THEN
                                        BEGIN
                                        _reccolno := drecno;
                                        _i        := csp_maxint2; (* exit *)
                                        END
                                    ELSE
                                        BEGIN
                                        _i        := succ( _i );
                                        _read_idx := succ( _read_idx );
                                        END;
                                    (*ENDIF*) 
                                (*ENDWITH*) 
                            (*ENDIF*) 
                            END;
                        (*ENDWHILE*) 
                        IF  _b_err <> e_ok
                        THEN
                            a07_b_put_error( acv, _b_err, 1 );
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                IF  ctabno = tableno
                THEN
                    BEGIN
                    _column_specified  := true;
                    j_v_par.j_v_column_updated := true;
                    IF  ( mtype = m_nil ) AND ( ctlink in ccolpropset )
                    THEN
                        BEGIN
                        ak59determine_prim_tab( acv,  a103GetColumn (j_v_par.j_v_viewptr^.sbase, _colind )^,
                              j_v_par, _primtabno );
                        ak59dependant_tables( acv, j_v_par, _primtabno );
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  _describe_column OR _column_specified
        THEN
            BEGIN
            WITH dfa[ _reccolno ] DO
                BEGIN
                IF  _column_specified
                THEN
                    BEGIN
                    j_v_par.j_v_field_used[ cextcolno ] := true;
                    dml_node := viewdfa[ cextcolno ].dml_node;
                    dml_colno_in_subquery :=
                          viewdfa[ cextcolno ].dml_colno_in_subquery;
                    dml_res_index :=
                          viewdfa[ cextcolno ].dml_res_index
                    END
                ELSE
                    dml_node := -1;
                (*ENDIF*) 
                a06extcolno( sparr.pbasep^.sbase, creccolno, dml_col_ptr );
&               IFDEF TRACE
                t01int4( ak_sem, 'dm_node     ', dml_node );
&               ENDIF
                END;
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
        _colind := cnextind
        END;
    (*ENDWITH*) 
(*ENDWHILE*) 
IF  ( acv.a_returncode = 0 ) AND ( tableno <> c_get_key )
THEN (* Determine derived columns *)
    BEGIN
    IF  j_v_par.j_v_qual_derived = NIL
    THEN
        _b_err := e_sysinfo_not_found;
    (*ENDIF*) 
    _b_err       := e_ok;
    _catalog_key := j_v_par.j_v_qual_derived^.syskey;
    _catalog_ptr := j_v_par.j_v_qual_derived;
    _i        := 1;
    _read_idx := 1;
&   ifdef trace
    t01int4( ak_sem, 'vderivedcnt ', j_v_par.j_v_qual_derived^.sviewqual_derivedcol.
          vderivedcnt );
&   endif
    WHILE ( _b_err = e_ok ) AND
          ( _i <= _catalog_ptr^.sviewqual_derivedcol.vderivedcnt )
          DO
        BEGIN
        IF  _read_idx > cak_max_viewqual_derivedcol
        THEN
            (* record overflow handling *)
            BEGIN
            IF  _catalog_ptr^.syskey.slinkage <> cak_init_linkage
            THEN
                a10rel_sysinfo( _catalog_ptr );
            (*ENDIF*) 
            a06inc_linkage( _catalog_key.slinkage );
            a10get_sysinfo( acv, _catalog_key, d_fix, _catalog_ptr, _b_err );
            _read_idx := 1;
            END;
        (*ENDIF*) 
        IF  _b_err = e_ok
        THEN
            BEGIN
&           IFDEF TRACE
            WITH _catalog_ptr^.sviewqual_derivedcol.
                 vderived_cols[ _read_idx ] DO
                t01p4int4( ak_sem, 'derived_info', dtabno,
                      drecno, dextno, dexttabno );
            (*ENDWITH*) 
&           ENDIF
            IF  ( _catalog_ptr^.sviewqual_derivedcol.
                vderived_cols[ _read_idx ].dtabno = tableno ) AND
                ( viewdfa[ _catalog_ptr^.sviewqual_derivedcol.
                vderived_cols[ _read_idx ].dextno ].dml_node <> 0 )
            THEN
                WITH dfa[ _catalog_ptr^.sviewqual_derivedcol.
                     vderived_cols[ _read_idx ].drecno ] DO
                    BEGIN
&                   IFDEF TRACE
                    WITH _catalog_ptr^.sviewqual_derivedcol.
                         vderived_cols[ _read_idx ] DO
                        t01p4int4( ak_sem, 'derived_used', dtabno,
                              drecno, dextno, dexttabno );
                    (*ENDWITH*) 
&                   ENDIF
                    dml_node      := viewdfa[ _catalog_ptr^.sviewqual_derivedcol.
                          vderived_cols[ _read_idx ].dextno ].dml_node;
                    dml_res_index := viewdfa[ _catalog_ptr^.sviewqual_derivedcol.
                          vderived_cols[ _read_idx ].dextno ].dml_res_index;
                    a06extcolno( sparr.pbasep^.sbase,
                          _catalog_ptr^.sviewqual_derivedcol.
                          vderived_cols[ _read_idx ].drecno, dml_col_ptr );
                    IF  mtype = m_nil
                    THEN
                        BEGIN
                        a06extcolno( j_v_par.j_v_viewptr^.sbase, _catalog_ptr^.
                              sviewqual_derivedcol.vderived_cols[ _read_idx ].
                              dextno, _col_ptr );
                        IF  ctlink in _col_ptr^.ccolpropset
                        THEN
                            BEGIN
                            j_v_par.j_v_column_updated := true;
                            ak59determine_prim_tab( acv, _col_ptr^,
                                  j_v_par, _primtabno );
                            ak59dependant_tables( acv, j_v_par, _primtabno );
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            _i        := succ( _i );
            _read_idx := succ( _read_idx );
            END;
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  _catalog_ptr^.syskey.slinkage <> cak_init_linkage
    THEN
        a10rel_sysinfo( _catalog_ptr );
    (*ENDIF*) 
    IF  _b_err <> e_ok
    THEN
        a07_b_put_error( acv, _b_err, 1 );
    (*ENDIF*) 
    END;
&IFDEF TRACE
(*ENDIF*) 
FOR _i := 1 TO sparr.pbasep^.sbase.bmaxcol DO
    WITH dfa[ _i ] DO
        IF  dml_node <> 0
        THEN
            BEGIN
            t01int4( ak_sem, 'setdfa index', _i );
            t01int4( ak_sem, 'dm_node     ', dml_node );
            t01int4( ak_sem, 'dm_res_index', dml_res_index );
            END;
&       ENDIF
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak59key_build_for_join_view (
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info;
            VAR viewdfa : tak_dfarr;
            VAR j_v_par : tak59_jv_parameter);
 
VAR
      _e          : tgg00_BasisError;
      _f_ok       : boolean;
      _i          : integer;
      _col_i      : integer;
      _varkey_pos : integer;
      _parsk      : tak_parskey;
      _sysk       : tgg00_SysInfoKey;
      _dfa        : tak_dfarr;
 
BEGIN
dmli.d_range := j_v_par.j_v_mtype = m_insert;
IF  acv.a_ex_kind = only_parsing
THEN
    BEGIN
    IF  j_v_par.j_v_start_node <> acv.a_ap_tree^[ 0 ].n_lo_level
    THEN
        BEGIN
        acv.a_pars_last_key.p_kind := m_key;
        a660_new_pparsp( acv, dmli.d_sparr,
              NOT c_first_parsinfo, c_complicate );
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            a54set_complex_entry( acv, c_set_last_pars );
            _sysk := a01sysnullkey;
            _sysk.sauthid[ 1 ] := cak_tempinfo_byte;
            _parsk.p_count   := acv.a_pars_last_key.p_count;
            _parsk.p_id[ 1 ] := acv.a_first_parsid;
            _parsk.p_kind    := m_fetch;
            _parsk.p_no      := 0;
            _sysk.sentrytyp := cak_eshortinfo;
            SAPDB_PascalForcedMove( sizeof( _parsk ), sizeof( _sysk.sauthid ),
                  @_parsk, 1, @_sysk.sauthid, 2, mxak_parskey );
            a10get_sysinfo( acv, _sysk, d_fix, dmli.d_sparr.pinfop, _e );
            IF  _e <> e_ok
            THEN
                a07_b_put_error( acv, _e, 1 );
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    ELSE
        a54_get_pparsp_pinfop( acv, dmli.d_sparr, m_key );
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        dmli.d_sparr.pparsp^.sparsinfo.p_tabid :=
              dmli.d_sparr.pbasep^.syskey.stableid;
        dmli.d_sparr.pparsp^.sparsinfo.p_joinviewtabcnt :=
              j_v_par.j_v_qual_basis^.sviewqual_basis.vbasetabcnt;
        END
    (*ENDIF*) 
    END
ELSE
    BEGIN
    j_v_par.j_v_syskey.sentrytyp := cak_eviewkey;
    a10_nil_get_sysinfo( acv, j_v_par.j_v_syskey, d_fix, cak_sysbufferoffset +
          4 + KEY_MXSP00, j_v_par.j_v_viewkeybuf, _e );
    IF  _e <> e_ok
    THEN
        a07_b_put_error( acv, _e, 1 );
    (*ENDIF*) 
    END;
(*ENDIF*) 
a06_systable_get( acv, d_fix,
      j_v_par.j_v_qual_basis^.sviewqual_basis.vtable[ 1 ].vttableid,
      dmli.d_sparr.pbasep, c_get_all, _f_ok );
IF  NOT _f_ok
THEN
    a07ak_system_error( acv, 59, 3 );
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    (* Viewdfa : columns specified in the command *)
    (* dfa     : columns of the current basetable *)
    (*           specified in the command         *)
    dmli.d_tabarr^[ 1 ].otreeid := dmli.d_sparr.pbasep^.sbase.btreeid;
    dmli.d_tabarr^[ 1 ].oview   := false;
    a06a_mblock_init( acv, m_key, mm_nil,
          dmli.d_sparr.pbasep^.sbase.btreeid );
    dmli.d_movebefore := cgg_rec_key_offset;
    IF  j_v_par.j_v_resname_node = 0
    THEN
        BEGIN
        ak59get_dfa_from_viewdfa( acv, j_v_par, viewdfa,
              dmli.d_sparr, _dfa, c_get_key, j_v_par.j_v_mtype );
        _col_i := dmli.d_sparr.pbasep^.sbase.bfirstcolind;
        _i     := 1;
        _varkey_pos := cgg_rec_key_offset + 1;
        WHILE (( _i <= dmli.d_sparr.pbasep^.sbase.bkeycolcount ) AND
              ( acv.a_returncode = 0 )) DO
            WITH a103GetColumn ( dmli.d_sparr.pbasep^.sbase, _col_i )^ DO
                BEGIN
                dmli.d_fieldno := creccolno;
                IF  _i = dmli.d_sparr.pbasep^.sbase.bkeycolcount - 1
                THEN
                    _varkey_pos := acv.a_mblock.mb_data_len + 1;
                (*ENDIF*) 
                a55_found_one_value( acv, dmli, _dfa );
                _col_i := cnextind;
                _i := succ ( _i );
                END;
            (*ENDWITH*) 
        (*ENDWHILE*) 
        IF  ( acv.a_returncode = 0 ) AND
            (( acv.a_ex_kind <> only_parsing ) OR
            ( _varkey_pos < acv.a_mblock.mb_data_len + 1 ))
            (* last keyfield was given during parsing *)
        THEN
            BEGIN
            (* trailing def_bytes must be truncated *)
            acv.a_mblock.mb_data_len := _varkey_pos +
                  s30lnr_defbyte( @acv.a_mblock.mb_data^.mbp_buf,
                  acv.a_mblock.mb_data^.mbp_buf [ _varkey_pos ],
                  _varkey_pos + 1, acv.a_mblock.mb_data_len - _varkey_pos );
            END
        (*ENDIF*) 
        END
    ELSE
        a58_current_of( acv, dmli, j_v_par.j_v_resname_node );
    (*ENDIF*) 
    IF  acv.a_ex_kind = only_parsing
    THEN
        BEGIN
        dmli.d_sparr.pparsp^.sparsinfo.p_select := false;
        a54_store_parsinfo( acv, dmli.d_sparr );
        END
    ELSE
        BEGIN
        j_v_par.j_v_viewkeybuf^.sviewkey.vkjvkeylen := acv.a_mblock.mb_data_len - cgg_rec_key_offset;
        SAPDB_PascalMove('VAK59 ',   4,    
              acv.a_mblock.mb_data_size,
              sizeof( j_v_par.j_v_viewkeybuf^.sviewkey.vkjvkey ),
              @acv.a_mblock.mb_data^.mbp_buf, cgg_rec_key_offset + 1,
              @j_v_par.j_v_viewkeybuf^.sviewkey.vkjvkey, 1,
              j_v_par.j_v_viewkeybuf^.sviewkey.vkjvkeylen,
              acv.a_returncode );
        END;
    (*ENDIF*) 
    a10rel_sysinfo( dmli.d_sparr.pbasep );
    END;
(*ENDIF*) 
dmli.d_sparr.pbasep := j_v_par.j_v_viewptr;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak59lock_tables (
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info;
            VAR j_v_par : tak59_jv_parameter);
 
VAR
      _i        : integer;
 
BEGIN
_i := 1;
WHILE ( _i <= j_v_par.j_v_qual_basis^.sviewqual_basis.vbasetabcnt ) AND
      ( acv.a_returncode = 0 ) DO
    BEGIN
    WITH j_v_par.j_v_qual_basis^.sviewqual_basis.vtable[ _i ] DO
        BEGIN
        a54add_next_temp_lock( acv, vttableid, dmli.d_globstate );
        _i := succ( _i );
        END;
    (*ENDWITH*) 
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak59one_tab_join_dml (
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info;
            VAR viewdfa : tak_dfarr;
            VAR setdfa  : tak_dfarr;
            VAR j_v_par : tak59_jv_parameter);
 
VAR
      _check_link   : boolean;
      _init_ex_kind : tak_execution_kind;
      _i            : integer;
      _sel_upd_set  : tak_columnset;
      upd_col_set  : tak_columnset;
      _dfa          : tak_dfarr;
 
BEGIN
dmli.d_movebefore := cgg_rec_key_offset;
CASE j_v_par.j_v_mtype OF
    m_insert :
        BEGIN
        ak59get_dfa_from_viewdfa( acv, j_v_par,
              viewdfa, dmli.d_sparr, _dfa, j_v_par.j_v_tableno, j_v_par.j_v_mtype );
        a06a_mblock_init( acv, m_insert, mm_nil,
              dmli.d_sparr.pbasep^.sbase.btreeid );
        (* PTS 1113190 E.Z. *)
        IF  (is_secondary_table in
            dmli.d_sparr.pbasep^.sbase.blinkexist)
            AND
            NOT acv.a_isReplicationSession
        THEN
            BEGIN
            (* reserve space for link tree_id *)
            _i := ( sizeof( tgg00_FileId ) - 1 + sizeof( tgg00_StackEntry ))
                  DIV sizeof( tgg00_StackEntry ) + 1;
            acv.a_mblock.mb_qual^.mfirst_free := _i
            END;
        (*ENDIF*) 
        WITH j_v_par.j_v_qual_basis^.sviewqual_basis.vtable[ j_v_par.j_v_tableno ] DO
            BEGIN
            IF  NOT vtone_to_one
            THEN
                BEGIN
                IF  j_v_par.j_v_phase_ins_after_upd AND NOT vtins_for_upd
                THEN
                    acv.a_mblock.mb_type2 := mm_ok_not_allowed
                ELSE
                    acv.a_mblock.mb_type2 := mm_compare_record;
                (*ENDIF*) 
                acv.a_mblock.mb_qual^.mupd_pos :=
                      acv.a_mblock.mb_qual^.mfirst_free;
                FOR _i := 1 TO dmli.d_sparr.pbasep^.sbase.bmaxcol DO
                    BEGIN
                    WITH _dfa[ _i ], acv.a_mblock, mb_qual^ DO
                        IF  dml_node <> 0
                        THEN
                            WITH dml_col_ptr^ DO
                                BEGIN
                                IF  NOT ( ctkey in ccolpropset )
                                THEN
                                    BEGIN
                                    mb_st^ [mfirst_free] := ccolstack;
                                    mfirst_free := succ( mfirst_free );
                                    mupd_cnt    := succ( mupd_cnt );
                                    END;
                                (*ENDIF*) 
                                IF  dml_node < 0
                                THEN
                                    dml_node := 0;
                                (*ENDIF*) 
                                END;
                            (*ENDWITH*) 
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    END;
                (*ENDFOR*) 
                END;
            (*ENDIF*) 
            a56_normal_insert( acv, dmli, _dfa, c_join_view_insert,
                  vtnot_used_links );
            IF  NOT ( j_v_par.j_v_check_after_update )
            THEN
                ak59add_projection_qual( acv, dmli, j_v_par );
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        IF  ( acv.a_ex_kind = only_parsing ) AND
            ( acv.a_returncode = 0 )
        THEN
            dmli.d_sparr.pparsp^.sparsinfo.p_j_v_keylen := j_v_par.j_v_tableno;
        (*ENDIF*) 
        END;
    m_update :
        BEGIN
        ak59get_dfa_from_viewdfa( acv, j_v_par, setdfa,
              dmli.d_sparr, _dfa, j_v_par.j_v_tableno, m_nil );
        IF  j_v_par.j_v_column_updated
        THEN
            BEGIN
            dmli.d_pars_kind := fp_val_varcol_with_len;
            dmli.d_linkbuf   := NIL;
            upd_col_set  := [  ];
            (* PTS 1122050 E.Z. *)
            IF  ftsArchive_egg00 in dmli.d_sparr.pbasep^.sbase.btreeid.fileType_gg00
            THEN
                a07_b_put_error (acv, e_invalid_tabletype, 1)
            ELSE
                BEGIN
                a06a_mblock_init( acv, m_update, mm_nil,
                      dmli.d_sparr.pbasep^.sbase.btreeid );
                (* PTS 1113190 E.Z. *)
                IF  (is_secondary_table in
                    dmli.d_sparr.pbasep^.sbase.blinkexist)
                    AND
                    NOT acv.a_isReplicationSession
                THEN
                    a56alloc_linkpos_info( acv,
                          dmli.d_sparr, m_update, dmli.d_linkbuf );
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  acv.a_returncode = 0
            THEN
                BEGIN
                ak59get_describe_key( acv, dmli, j_v_par, acv.a_ex_kind );
                dmli.d_movebefore := 0;
                WITH acv.a_mblock, mb_data^ DO
                    mbp_keylen := mb_data_len - cgg_rec_key_offset;
                (*ENDWITH*) 
                _sel_upd_set := a01fullset;
                dmli.d_upd_set  := [  ];
                a57_set_clause( acv, dmli, _dfa, j_v_par.j_v_start_node,
                      upd_col_set, _sel_upd_set, c_named_values_done );
                IF  NOT ( j_v_par.j_v_check_after_update )
                THEN
                    ak59add_projection_qual( acv, dmli, j_v_par );
                (*ENDIF*) 
                IF  acv.a_returncode = 0
                THEN
                    a57_range_not_null( acv, dmli, _dfa );
                (*ENDIF*) 
                WITH acv.a_mblock, mb_qual^ DO
                    IF  ( mview_cnt > 0 ) AND ( mupd_cnt > 0 )
                    THEN
                        a65_set_operator( acv, op_and );
                    (*ENDIF*) 
                (*ENDWITH*) 
                a262add_trigger_info( acv, dmli, NOT c_ignore_trigger )
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    m_delete :
        (* PTS 1122050 E.Z. *)
        IF  ftsArchive_egg00 in dmli.d_sparr.pbasep^.sbase.btreeid.fileType_gg00
        THEN
            a07_b_put_error (acv, e_invalid_tabletype, 1)
        ELSE
            BEGIN
            _check_link   := (is_primary_table in
                  dmli.d_sparr.pbasep^.sbase.blinkexist)
                  AND
                  NOT acv.a_isReplicationSession;
            _init_ex_kind := acv.a_ex_kind;
            IF  _check_link
            THEN
                acv.a_ex_kind := only_parsing;
            (*ENDIF*) 
            a06a_mblock_init( acv, m_delete, mm_nil,
                  dmli.d_sparr.pbasep^.sbase.btreeid );
            (* PTS 1113190 E.Z. *)
            IF  _check_link
            THEN
                BEGIN
                (* reserve space for link tree_id *)
                _i := ( sizeof( tgg00_FileId ) - 1 + sizeof( tgg00_StackEntry ))
                      DIV sizeof( tgg00_StackEntry ) + 1;
                acv.a_mblock.mb_qual^.mfirst_free := _i;
                END;
            (*ENDIF*) 
            ak59get_describe_key( acv, dmli, j_v_par, _init_ex_kind );
            a58_indices( acv, dmli.d_sparr.pbasep^.sbase, _dfa );
            a58describe_long_columns( acv, dmli.d_sparr );
            IF  _check_link
            THEN
                BEGIN
                upd_col_set := [  ];
                a58_put_link_inf_into_mess_buf( acv, dmli, upd_col_set, 0 );
                END;
            (*ENDIF*) 
            a262add_trigger_info( acv, dmli, NOT c_ignore_trigger );
            a54_last_part( acv, dmli.d_sparr, NOT c_last_pars_part );
            acv.a_ex_kind := _init_ex_kind;
            IF  _check_link AND ( acv.a_returncode = 0 )
            THEN
                WITH dmli.d_sparr.pbasep^, sbase DO
                    a58delete_with_link( acv,
                          syskey.stableid, 0, 1, 0 );
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    END;
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak59partial_fk_upd (
            VAR acv         : tak_all_command_glob;
            VAR dmli        : tak_dml_info;
            rel_derived_idx : integer;
            derived_ptr     : tak_sysbufferaddress;
            VAR updcol_cnt  : integer;
            VAR setdfa      : tak_dfarr;
            VAR j_v_par     : tak59_jv_parameter);
 
VAR
      _j           : integer;
      _read_idx    : integer;
      _catalog_ptr : tak_sysbufferaddress;
      _catalog_key : tgg00_SysInfoKey;
      _b_err       : tgg00_BasisError;
 
BEGIN
IF  j_v_par.j_v_qual_derived = NIL
THEN
    _b_err := e_sysinfo_not_found
ELSE
    _b_err := e_ok;
(*ENDIF*) 
_catalog_key := j_v_par.j_v_qual_derived^.syskey;
_catalog_ptr := j_v_par.j_v_qual_derived;
_j        := 1;
_read_idx := 1;
WHILE ( _b_err = e_ok ) AND
      ( _j <= _catalog_ptr^.sviewqual_derivedcol.vderivedcnt  ) DO
    BEGIN
    IF  _read_idx > cak_max_viewqual_derivedcol
    THEN
        (* record overflow handling *)
        BEGIN
        a06inc_linkage( _catalog_key.slinkage );
        a10get_sysinfo( acv, _catalog_key, d_release, _catalog_ptr, _b_err );
        _read_idx := 1;
        END;
    (*ENDIF*) 
    IF  _b_err = e_ok
    THEN
        WITH _catalog_ptr^.sviewqual_derivedcol, vderived_cols[ _read_idx ] DO
            BEGIN
&           IFDEF TRACE
            t01int4( ak_sem, 'dtabno      ', dtabno );
            t01int4( ak_sem, 'dexttabno   ', dexttabno );
            t01int4( ak_sem, 'drecno      ', drecno );
            t01int4( ak_sem, 'dextno      ', dextno );
            t01int4( ak_sem, 'setdfa      ',
                  setdfa[ dextno ].dml_node );
&           ENDIF
            IF  ( ( rel_derived_idx <> _j ) OR
                ( derived_ptr^.syskey.slinkage <>
                _catalog_ptr^.syskey.slinkage ) )
                AND
                ((( dtabno = derived_ptr^.sviewqual_derivedcol.
                vderived_cols[ rel_derived_idx ].dtabno ) AND
                ( dexttabno = derived_ptr^.sviewqual_derivedcol.
                vderived_cols[ rel_derived_idx ].dexttabno ))
                OR
                (( dtabno = derived_ptr^.sviewqual_derivedcol.
                vderived_cols[ rel_derived_idx ].dexttabno ) AND
                ( dexttabno = derived_ptr^.sviewqual_derivedcol.
                vderived_cols[ rel_derived_idx ].dtabno )))
                AND
                ( setdfa[ dextno ].dml_node = 0 )
            THEN
                BEGIN
                a06extcolno( dmli.d_sparr.pbasep^.sbase, dextno,
                      setdfa[ dextno ].dml_col_ptr );
                WITH setdfa[ dextno ].dml_col_ptr^ DO
                    BEGIN
                    acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mfirst_free ] :=
                          ccolstack;
                    WITH acv.a_mblock.mb_st^[ acv.a_mblock.mb_qual^.mfirst_free + 1 ] DO
                        BEGIN
                        etype         := st_output;
                        eop_out       := op_o_output_var;
                        epos          := 0;
                        elen_var      := cinoutlen;
                        ecol_tab[ 1 ] := chr( 0 );
                        ecol_tab[ 2 ] := chr( 0 );
                        END;
                    (*ENDWITH*) 
                    acv.a_mblock.
                          mb_st^[ acv.a_mblock.mb_qual^.mqual_pos ].epos :=
                          acv.a_mblock.
                          mb_st^[ acv.a_mblock.mb_qual^.mqual_pos ].epos + 2;
                    acv.a_mblock.mb_qual^.mfirst_free :=
                          acv.a_mblock.mb_qual^.mfirst_free + 2;
                    acv.a_mblock.mb_qual^.mqual_cnt   :=
                          acv.a_mblock.mb_qual^.mqual_cnt + 2;
                    updcol_cnt  := succ( updcol_cnt );
                    setdfa[ dextno ].dml_node      := 1;
                    setdfa[ dextno ].dml_res_index := updcol_cnt;
                    END;
                (*ENDWITH*) 
&               IFDEF TRACE
                t01messblock( ak_sem, 'MBLOCK 59par', acv.a_mblock );
&               ENDIF
                END;
            (*ENDIF*) 
            _j        := succ( _j );
            _read_idx := succ( _read_idx );
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  _b_err <> e_ok
THEN
    a07_b_put_error( acv, _b_err, 1 );
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak59upd_del_join_view (
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info;
            VAR dfa     : tak_dfarr;
            VAR j_v_par : tak59_jv_parameter;
            curr_n      : integer);
 
VAR
      _curr_n      : integer;
      _icurr_n     : integer;
 
BEGIN
&IFDEF TRACE
t01int4( ak_sem, 'curr_n      ', curr_n );
&ENDIF
IF  acv.a_ap_tree^[ curr_n ].n_sa_level = 0
THEN
    (* without key, without search-condition *)
    j_v_par.j_v_qualified := c_no_where_node
ELSE
    BEGIN
    _icurr_n := acv.a_ap_tree^[ curr_n ].n_sa_level;
    _curr_n  := acv.a_ap_tree^[ _icurr_n ].n_lo_level;
    IF  ( acv.a_ap_tree^[ _curr_n ].n_proc = a55 ) AND
        ( acv.a_ap_tree^[ _curr_n ].n_subproc = cak_x_keyspec_list )
    THEN
        IF  acv.a_ap_tree^[ _curr_n ].n_sa_level <> 0
        THEN
            a07_b_put_error( acv, e_not_implemented, 1 )
        ELSE
            BEGIN
            dmli.d_foundset := [  ];
            ak59fill_dfa( acv, dmli, dfa, NOT c_enum_values, _curr_n );
            END
        (*ENDIF*) 
    ELSE
        BEGIN
        IF  ( acv.a_ap_tree^[ _curr_n ].n_proc = a55 )
            AND
            (( acv.a_ap_tree^[ _curr_n ].n_subproc = cak_x_current_of ) OR
            ( acv.a_ap_tree^[ _curr_n ].n_subproc = cak_x_pos_of ))
        THEN
            j_v_par.j_v_resname_node := _curr_n
        ELSE
            IF  acv.a_ap_tree^[ _curr_n ].n_sa_level <> 0
            THEN
                a07_b_put_error( acv, e_not_implemented, 1 )
            ELSE
                BEGIN
                (* search-condition *)
                j_v_par.j_v_qualified := acv.a_ap_tree^[ _icurr_n ].n_pos;
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
&ifdef trace
t01int4( ak_sem, 'j_v_resname_', j_v_par.j_v_resname_node );
t01int4( ak_sem, 'j_v_qualifie', j_v_par.j_v_qualified );
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak59upd_new_view_rec (
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info;
            VAR setdfa  : tak_dfarr;
            VAR j_v_par : tak59_jv_parameter);
 
VAR
      _ok          : boolean;
      _i           : integer;
      _j           : integer;
      _pos         : integer;
      _res_len     : integer;
      _col_ptr     : tak00_colinfo_ptr;
      _sysk        : tgg00_SysInfoKey;
      _view_arr    : tak_syspointerarr;
      _sel_upd_set : tak_columnset;
      _upd_col_set : tak_columnset;
      _rec_buf     : tgg00_Rec;
      _aux_st      : ARRAY[1..MAX_COL_PER_TAB_GG00] OF tgg00_StackEntry;
&     ifdef trace
      _colname     : tsp00_KnlIdentifier;
&     endif
 
BEGIN
_sel_upd_set := dmli.d_tabarr^[ 1 ].oprivset;
dmli.d_tabarr^[ 1 ].oprivset := dmli.d_upd_set;
j_v_par.j_v_join_upd := true;
_view_arr    := dmli.d_sparr;
_sysk        := dmli.d_sparr.pbasep^.syskey;
_j           := 1;
WITH dmli.d_sparr.pbasep^.sbase DO
    FOR _i := bfirstindex TO blastindex DO
        BEGIN
        _aux_st[ _j ] := a103GetColumn (dmli.d_sparr.pbasep^.sbase, _i )^.ccolstack;
        _j := _j + 1
        END;
    (*ENDFOR*) 
(*ENDWITH*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    _pos := 1;
    FOR _i := 1 TO dmli.d_sparr.pbasep^.sbase.bmaxcol DO
        BEGIN
        a06extcolno( dmli.d_sparr.pbasep^.sbase, _i, _col_ptr );
        WITH _col_ptr^ DO
            BEGIN
            ccolstack.etype    := st_fixcol;
            ccolstack.eop      := op_none;
            ccolstack.epos     := _pos;
            ccolstack.elen_var := cinoutlen;
            ccolstack.ecol_tab[ 1 ] := chr( 0 );
            ccolstack.ecol_tab[ 2 ] := chr( 0 );
            _pos := _pos + cinoutlen;
            END;
        (*ENDWITH*) 
        END;
    (*ENDFOR*) 
    IF  acv.a_ex_kind = only_parsing
    THEN
        a660_new_pparsp( acv, dmli.d_sparr,
              NOT c_first_parsinfo, NOT c_complicate )
    ELSE
        WITH acv.a_mblock, mb_data^ DO
            BEGIN
            SAPDB_PascalMove ('VAK59 ',   5,    
                  mb_data_size, sizeof( _rec_buf ),
                  @mbp_buf, 1, @_rec_buf, 1, mb_data_len,
                  acv.a_returncode );
            dmli.d_resbuf_addr := @j_v_par.j_v_res_buf;
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    (* PTS 1122050 E.Z. *)
    _upd_col_set   := [  ];
    dmli.d_upd_set := [  ];
    IF  ftsArchive_egg00 in dmli.d_sparr.pbasep^.sbase.btreeid.fileType_gg00
    THEN
        a07_b_put_error (acv, e_invalid_tabletype, 1)
    ELSE
        BEGIN
        a06a_mblock_init( acv, m_update_rec, mm_nil,
              dmli.d_sparr.pbasep^.sbase.btreeid );
        (* PTS 1113190 E.Z. *)
        IF  acv.a_returncode = 0
        THEN
            a57_set_clause( acv, dmli, setdfa, j_v_par.j_v_start_node,
                  _upd_col_set, _sel_upd_set, NOT c_named_values_done );
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            BEGIN
&           IFDEF TRACE
            FOR _i := 1 TO dmli.d_sparr.pbasep^.sbase.bmaxcol DO
                WITH setdfa[ _i ] DO
                    WITH setdfa[ _i ] DO
                        IF  dml_node <> 0
                        THEN
                            BEGIN
                            t01int4( ak_sem, 'setdfa index', _i );
                            t01int4( ak_sem, 'dm_node     ', dml_node );
                            t01int4( ak_sem, 'dm_res_index', dml_res_index );
                            a061get_colname( dml_col_ptr^, _colname );
                            END;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (*ENDWITH*) 
            (*ENDFOR*) 
            t01messblock( ak_sem, 'MBLOCK 59upd', acv.a_mblock );
&           ENDIF
            ak59analyze_foreign_key_upd( acv,
                  dmli, acv.a_mblock.mb_qual^.mcol_cnt, setdfa, j_v_par );
&           IFDEF TRACE
            FOR _i := 1 TO dmli.d_sparr.pbasep^.sbase.bmaxcol DO
                WITH setdfa[ _i ] DO
                    IF  dml_node <> 0
                    THEN
                        BEGIN
                        t01int4( ak_sem, 'setdfa index', _i );
                        t01int4( ak_sem, 'dm_node     ', dml_node );
                        t01int4( ak_sem, 'dm_res_index', dml_res_index );
                        a061get_colname( dml_col_ptr^, _colname );
                        END;
                    (*ENDIF*) 
                (*ENDWITH*) 
            (*ENDFOR*) 
            t01messblock( ak_sem, 'MBLOCK 59upd', acv.a_mblock );
&           ENDIF
            IF  acv.a_mblock.mb_qual^.mqual_cnt > 1
            THEN
                IF  acv.a_ex_kind = only_parsing
                THEN
                    WITH dmli.d_sparr, pparsp^.sparsinfo, pbasep^.sbase,
                         acv.a_mblock, mb_data^ DO
                        BEGIN
                        p_mtyp := m_update_rec;
                        a54_last_part( acv, dmli.d_sparr, NOT c_last_pars_part );
                        END
                    (*ENDWITH*) 
                ELSE
                    BEGIN
                    acv.a_mblock.mb_work_st      := acv.a_work_st_addr;
                    acv.a_mblock.mb_work_st_max  := acv.a_work_st_max;
                    acv.a_mblock.mb_workbuf      := acv.a_work_buf_addr;
                    acv.a_mblock.mb_workbuf_size := acv.a_work_buf_size;
                    a05qualification_test( acv, acv.a_mblock,
                          c_result_wanted, c_check_new_rec, c_no_error_pos,
                          _rec_buf, j_v_par.j_v_res_buf, sizeof(j_v_par.j_v_res_buf), _res_len );
                    ;
&                   IFDEF TRACE
                    t01buf( ak_sem, j_v_par.j_v_res_buf, 1, _res_len );
&                   ENDIF
                    END
                (*ENDIF*) 
            ELSE
                IF  acv.a_ex_kind = only_parsing
                THEN
                    dmli.d_sparr.pparsp^.sparsinfo.p_cnt_infos := 0;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a06drop_fieldlist_references (acv.a_mblock.mb_fieldlists);
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
_j := 1;
WITH dmli.d_sparr.pbasep^.sbase DO
    FOR _i := bfirstindex TO blastindex DO
        BEGIN
        _col_ptr := a103GetColumn ( dmli.d_sparr.pbasep^.sbase, _i );
        _col_ptr^.ccolstack := _aux_st[_j];
        _j := succ( _j );
        END;
    (*ENDFOR*) 
(*ENDWITH*) 
a06_systable_get( acv, d_fix, _sysk.stableid, j_v_par.j_v_viewptr, c_get_all, _ok );
END;
 
(*------------------------------*) 
 
PROCEDURE
      a59_join_view (
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info;
            VAR viewdfa : tak_dfarr;
            start_node  : integer;
            mtype       : tgg00_MessType);
 
VAR
      _shortinfo_returned : boolean;
      _lock_tables        : boolean;
      _e                  : tgg00_BasisError;
      _init_ex_kind       : tak_execution_kind;
      _aux_mess_type      : tsp1_cmd_mess_type;
      _dif_before_after   : boolean;
      _err                : tgg04_Err;
      _curr_node          : integer;
      _i                  : integer;
      _del_cnt            : integer;
      _table_node         : integer;
      _h_count_literals   : tsp00_Int2;
      _parsk              : tak_parskey;
      _j_v_par            : tak59_jv_parameter;
 
BEGIN
dmli.d_globstate := acv.a_transinf.tri_global_state;
_init_ex_kind     := acv.a_ex_kind;
_aux_mess_type    := acv.a_cmd_segment_header.sp1c_mess_type;
(* foreign key condition don't fullfill all join conditions *)
_dif_before_after := dmli.d_sparr.pbasep^.sbase.bindexexist;
&IFDEF TRACE
t01command_kind( ak_sem, 'command_kind', acv.a_command_kind );
t01knl_identifier( ak_sem, 'btablen     ', dmli.d_sparr.pbasep^.sbase.btablen^);
t01bool( ak_sem , '_dif_before_', _dif_before_after );
&ENDIF
FOR _i := 1 TO dmli.d_sparr.pbasep^.sbase.bmaxcol DO
    _j_v_par.j_v_field_used[ _i ] := false;
(*ENDFOR*) 
dmli.d_group           := false;
dmli.d_subquery        := false;
acv.a_input_data_pos   := 1;
acv.a_info_output      := false;
acv.a_init_info_output := false;
_h_count_literals      := acv.a_count_literals;
acv.a_count_literals   := 0;
dmli.d_nullkey         := false;
dmli.d_movebefore      := cgg_rec_key_offset;
dmli.d_maxlen          := 0;
dmli.d_pars_kind       := fp_val_varcol_with_len;
dmli.d_pargeslen       := 0;
dmli.d_joins.jrc_cnt   := 0;
_j_v_par.j_v_resname_node       := 0;
_j_v_par.j_v_qualified          := c_no_qualification;
a103GetSchemaName ( acv, dmli.d_sparr.pbasep^.sbase.bschema, _j_v_par.j_v_schema );
_j_v_par.j_v_name                := dmli.d_sparr.pbasep^.sbase.btablen^;
_j_v_par.j_v_tabid               := dmli.d_sparr.pbasep^.syskey.stableid;
_j_v_par.j_v_reference           := dmli.d_tabarr^[ 1 ].oreference;
_j_v_par.j_v_keylen              := dmli.d_sparr.pbasep^.sbase.bmaxreclen;
_j_v_par.j_v_mtype               := mtype;
_j_v_par.j_v_viewptr             := dmli.d_sparr.pbasep;
_j_v_par.j_v_qual_basis          := NIL;
_j_v_par.j_v_qual_derived        := NIL;
_j_v_par.j_v_qual_stack          := NIL;
_j_v_par.j_v_ins_after_upd       := false;
_j_v_par.j_v_phase_ins_after_upd := false;
_j_v_par.j_v_key_update          := false;
_j_v_par.j_v_join_upd            := false;
_j_v_par.j_v_filler1             := false;
_j_v_par.j_v_start_node          := start_node;
_table_node             := acv.a_ap_tree^[ start_node ].n_lo_level;
_curr_node              := acv.a_ap_tree^[ _table_node ].n_sa_level;
_lock_tables            := false;
acv.a_tempinfo_key      := cgg_zero_id;
;
_j_v_par.j_v_syskey              := dmli.d_sparr.pbasep^.syskey;
_j_v_par.j_v_syskey.sentrytyp    := cak_eviewqual_basis;
a10get_sysinfo( acv, _j_v_par.j_v_syskey, d_fix, _j_v_par.j_v_qual_basis, _e );
;
IF  ( _e = e_ok ) AND _j_v_par.j_v_qual_basis^.sviewqual_basis.vderived_exists
THEN
    BEGIN
    _j_v_par.j_v_syskey.sentrytyp := cak_eviewqual_derivedcol;
    a10get_sysinfo( acv, _j_v_par.j_v_syskey, d_fix, _j_v_par.j_v_qual_derived, _e );
    END;
(*ENDIF*) 
IF  ( _e = e_ok ) AND _j_v_par.j_v_qual_basis^.sviewqual_basis.vstack_exists
THEN
    BEGIN
    _j_v_par.j_v_syskey.sentrytyp := cak_eviewqual_stack;
    a10get_sysinfo( acv, _j_v_par.j_v_syskey, d_fix, _j_v_par.j_v_qual_stack, _e );
    END;
(*ENDIF*) 
IF  _e <> e_ok
THEN
    a07_b_put_error( acv, _e, 1 )
ELSE
    BEGIN
    IF  mtype = m_insert
    THEN
        BEGIN
        dmli.d_foundset := [  ];
        WITH acv.a_ap_tree^[ _curr_node ] DO
            ak59fill_dfa( acv, dmli, viewdfa,
                  ( n_proc = a56 ) AND ( n_subproc = cak_x_enum_values ),
                  _curr_node )
        (*ENDWITH*) 
        END
    ELSE
        BEGIN
        IF  mtype = m_delete
        THEN
            _curr_node := _table_node;
        (*ENDIF*) 
        ak59upd_del_join_view( acv, dmli, viewdfa, _j_v_par, _curr_node );
        IF  _j_v_par.j_v_qualified = c_no_qualification
        THEN
            BEGIN
            IF  mtype = m_delete
            THEN
                BEGIN
                IF  NOT ( hsTempLock_egg00 in dmli.d_globstate ) AND
                    NOT ( hsPermLock_egg00 in dmli.d_globstate )
                THEN
                    ak59check_links( acv, _j_v_par, dmli.d_globstate );
                (*ENDIF*) 
                END
            ELSE
                IF  mtype = m_update
                THEN
                    ak59check_key_update( acv,
                          _j_v_par, viewdfa, dmli.d_globstate );
                (*ENDIF*) 
            (*ENDIF*) 
            IF  ( hsTempLock_egg00 in dmli.d_globstate ) OR
                ( hsPermLock_egg00 in dmli.d_globstate )
            THEN
                BEGIN
                (* isolation level >= 2 is specified *)
                _lock_tables := true;
                IF  acv.a_isolation_info <> temp_lock_rec_get
                THEN
                    acv.a_isolation_info := temp_lock_rec_needed;
                (*ENDIF*) 
                acv.a_command_kind := subquery_command
                END
            ELSE (* at leat isolation level 1 is required *)
                IF  hsWithoutLock_egg00 in dmli.d_globstate
                THEN
                    dmli.d_globstate := dmli.d_globstate -
                          [ hsWithoutLock_egg00 ] + [ hsConsistentLock_egg00 ];
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  _j_v_par.j_v_qualified <> c_no_qualification
THEN
    BEGIN
    ak59check_links( acv, _j_v_par, dmli.d_globstate );
    IF  acv.a_isolation_info <> temp_lock_rec_get
    THEN
        acv.a_isolation_info := temp_lock_rec_needed;
    (*ENDIF*) 
    acv.a_ex_kind := only_parsing;
    acv.a_cmd_segment_header.sp1c_mess_type  := sp1m_parse;
    _j_v_par.j_v_resname_node := -1
    END
ELSE
    IF  (( hsTempLock_egg00 in dmli.d_globstate ) OR
        ( hsPermLock_egg00 in dmli.d_globstate )) AND ( mtype <> m_insert )
    THEN
        acv.a_ex_kind := only_parsing;
    (*ENDIF*) 
(*ENDIF*) 
_j_v_par.j_v_viewkeybuf         := NIL;
_j_v_par.j_v_check_after_update := false;
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  ( mtype = m_insert ) OR ( mtype = m_update )
    THEN
        _j_v_par.j_v_check_after_update := _dif_before_after;
    (*ENDIF*) 
    ak59key_build_for_join_view( acv, dmli, viewdfa, _j_v_par );
    IF  ( acv.a_returncode = 0 ) AND
        ( mtype <> m_insert (* delete, update *)
        ) AND
        ( _j_v_par.j_v_qualified = c_no_qualification )
    THEN
        BEGIN
        dmli.d_checkview := false;
        IF  _lock_tables
        THEN
            ak59lock_tables( acv, dmli, _j_v_par );
        (*ENDIF*) 
        ak59check_join_view( acv, dmli, _j_v_par,
              NOT c_check_view, NOT c_last_pars_part )
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
acv.a_count_literals := _h_count_literals;
IF  acv.a_returncode = 0
THEN
    ak59dml_join_view( acv, dmli, viewdfa, _j_v_par );
(*ENDIF*) 
acv.a_count_literals := 0;
_shortinfo_returned := false;
IF  acv.a_returncode = 0
THEN
    IF  _j_v_par.j_v_check_after_update
    THEN
        BEGIN
        (* _dif_before_after has same value as j_v_check_after_update *)
        (* therefor d_checkview = true                                *)
        dmli.d_checkview    := _dif_before_after;
        _shortinfo_returned := ( _j_v_par.j_v_qualified = c_no_qualification );
        ak59check_join_view( acv, dmli, _j_v_par,
              c_check_view, _shortinfo_returned );
        IF  acv.a_ex_kind <> only_parsing
        THEN
            _j_v_par.j_v_qual_basis := NIL;
&       ifdef trace
        (*ENDIF*) 
        t01int4( ak_sem, 'a_returncode', acv.a_returncode );
&       endif
        IF  acv.a_returncode <> 0
        THEN
            IF  acv.a_returncode =
                a071_return_code( e_row_not_found, acv.a_sqlmode )
            THEN
                BEGIN
                acv.a_returncode := 0;
                _err.errtableid   := _j_v_par.j_v_tabid;
                a07_b_put_error( acv, e_range_violation, 1 );
                IF  mtype = m_insert
                THEN
                    a06put_errtext( acv, e_range_violation,
                          errtext_surrogate,
                          SURROGATE_MXGG00+STACK_ENTRY_MXGG00 + 2,
                          _err.errt, acv.a_ak_b_err )
                ELSE
                    a06put_errtext( acv, e_no_next_record,
                          errtext_surrogate,
                          SURROGATE_MXGG00+STACK_ENTRY_MXGG00 + 2,
                          _err.errt, acv.a_ak_b_err );
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  ( acv.a_returncode = 0 ) AND _lock_tables
THEN
    BEGIN
    acv.a_pars_last_key.p_kind := m_lock;
    a54_loc_temp_locks( acv, dmli.d_globstate, acv.a_p_arr2 )
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    IF  ( acv.a_ex_kind = only_parsing ) AND NOT ( _shortinfo_returned )
    THEN
        IF  _j_v_par.j_v_qualified = c_no_qualification
        THEN
            a54_shortinfo_to_varpart( acv, acv.a_initial_segment_header.sp1c_prepare,
                  dmli.d_sparr.pinfop )
        ELSE
            BEGIN
            acv.a_parameter_offset :=
                  dmli.d_sparr.pinfop^.sshortinfo.sicount;
            (* h.b. 07.11.97 because of sifullen this is wrong
                  dmli.d_sparr.pinfop^.b_sl := cak_sysbufferoffset +
                  4 + dmli.d_sparr.pinfop^.sshortinfo.sicount *
                  sizeof( tsp1_param_info);
                  *)
            dmli.d_sparr.pinfop^.b_sl :=
                  sizeof( tak_shortinforecord ) -
                  sizeof( tak_paraminfoarr )    +
                  ( dmli.d_sparr.pinfop^.sshortinfo.sicount
                  * sizeof( tsp1_param_info ));
            a10add_sysinfo( acv, dmli.d_sparr.pinfop, _e );
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
IF  _j_v_par.j_v_viewkeybuf <> NIL
THEN
    BEGIN
    a10_key_del( acv, _j_v_par.j_v_viewkeybuf^.syskey );
&   ifdef trace
    _j_v_par.j_v_viewkeybuf := NIL;
&   endif
    END;
(*ENDIF*) 
IF  ( _init_ex_kind <> only_parsing ) AND
    ( acv.a_ex_kind = only_parsing )       AND
    ( _j_v_par.j_v_qualified = c_no_qualification )
THEN
    BEGIN
    _parsk           := acv.a_pars_last_key;
    _parsk.p_id[ 1 ] := acv.a_first_parskey;
    _parsk.p_kind    := m_complex;
    _parsk.p_no      := 0;
    acv.a_ex_kind    := only_executing;
    a501do_execute( acv, dmli, _parsk, c_output_during_execution );
    a660_prefix_delete( acv, _parsk, _del_cnt, cak_complete_prefix );
    dmli.d_sparr.pbasep := _j_v_par.j_v_viewptr
    END;
(*ENDIF*) 
acv.a_ex_kind := _init_ex_kind;
acv.a_cmd_segment_header.sp1c_mess_type := _aux_mess_type;
IF  acv.a_returncode <> 0
THEN
    BEGIN
    IF  ( acv.a_ex_kind = only_parsing ) AND
        ( acv.a_returncode <>
        a071_return_code( e_row_not_found, acv.a_sqlmode ) )
    THEN
        a660_prefix_delete( acv, acv.a_pars_last_key, _del_cnt,
              cak_complete_prefix );
    (*ENDIF*) 
    acv.a_part_rollback := true
    END
ELSE
    IF  _j_v_par.j_v_qualified <> c_no_qualification
    THEN
        ak59build_select_cmd( acv, _j_v_par );
    (*ENDIF*) 
(*ENDIF*) 
a10rel_sysinfo( _j_v_par.j_v_qual_basis );
a10rel_sysinfo( _j_v_par.j_v_qual_derived );
acv.a_count_literals := _h_count_literals;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a59_prepare_join_check (
            VAR acv         : tak_all_command_glob;
            VAR dmli        : tak_dml_info;
            maxkeyl         : integer);
 
VAR
      _i        : integer;
      _start    : integer;
      _stop     : integer;
      _jvrec    : tak68_joinview_rec;
      _sr_rec   : tak71_strat_rec;
      _res_tree : tgg00_FileId;
 
BEGIN
IF  acv.a_mblock.mb_data_len + maxkeyl > acv.a_mblock.mb_data_size
THEN
    a07_b_put_error( acv, e_too_many_mb_data, 1 )
ELSE
    BEGIN
    (* move data to get place for key *)
    SAPDB_PascalOverlappingMove ('VAK59 ',   6,    
          acv.a_mblock.mb_data_size, acv.a_mblock.mb_data_size,
          @acv.a_mblock.mb_data^.mbp_buf, cgg_rec_key_offset + 1,
          @acv.a_mblock.mb_data^.mbp_buf, cgg_rec_key_offset + 1 + maxkeyl,
          acv.a_mblock.mb_data_len - cgg_rec_key_offset,
          acv.a_returncode );
    acv.a_mblock.mb_data_len := acv.a_mblock.mb_data_len + maxkeyl;
    acv.a_mblock.mb_data^.mbp_keylen  := maxkeyl;
    acv.a_mblock.mb_qual^.mcol_cnt := 0;
    _start := acv.a_mblock.mb_qual^.mqual_pos;
    _stop  := acv.a_mblock.mb_qual^.mqual_pos +
          acv.a_mblock.mb_qual^.mqual_cnt - 1;
    (* adjust pointers in stack entries to data *)
    FOR _i := _start TO _stop DO
        IF  acv.a_mblock.mb_st^[ _i ].etype = st_value
        THEN
            acv.a_mblock.mb_st^[ _i ].epos := acv.a_mblock.
                  mb_st^[ _i ].epos + maxkeyl;
        (*ENDIF*) 
    (*ENDFOR*) 
    dmli.d_single    := true;
    dmli.d_rowno     := cgg04_no_rowno_predicate;
    dmli.d_inoutpos  := cgg_rec_key_offset + RESCNT_MXGG04 + 1;
    dmli.d_keylen    := RESCNT_MXGG04;
    _res_tree        := acv.a_into_tree;
    _sr_rec.sr_strategy       := strat_key_range;
    _sr_rec.sr_use_rowno      := false;
    _sr_rec.sr_distinct_bytes := true;
    _sr_rec.sr_reverse_access := false;
    _jvrec.jv_tabid      := dmli.d_tableid;
    _jvrec.jv_maxkeyl    := maxkeyl;
    a680_join( acv, dmli, _res_tree, _sr_rec, NOT c_last_pars_part, _jvrec );
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a59handle_qualification (
            VAR acv        : tak_all_command_glob;
            VAR res_buffer : tgg00_Rec;
            VAR e          : tgg00_BasisError);
 
VAR
      _res_len : integer;
      _rec_buf : tgg00_Rec;
 
BEGIN
SAPDB_PascalMove ('VAK59 ',   7,    
      sizeof( res_buffer.buf ), sizeof( _rec_buf.buf ), @res_buffer.buf, 1,
      @_rec_buf.buf, 1, res_buffer.len + cgg_rec_key_offset,
      acv.a_returncode );
&IFDEF TRACE
t01buf( ak_sem, res_buffer.buf, 1, res_buffer.len + cgg_rec_key_offset );
t01messblock( ak_sem, 'MBLOCK 59han', acv.a_mblock );
&ENDIF
acv.a_mblock.mb_work_st      := acv.a_work_st_addr;
acv.a_mblock.mb_work_st_max  := acv.a_work_st_max;
acv.a_mblock.mb_workbuf      := acv.a_work_buf_addr;
acv.a_mblock.mb_workbuf_size := acv.a_work_buf_size;
acv.a_mblock.mb_trns         := @acv.a_transinf.tri_trans;
a05qualification_test( acv, acv.a_mblock,
      c_result_wanted, c_check_new_rec, c_no_error_pos,
      _rec_buf, res_buffer.buf, sizeof(res_buffer.buf), _res_len );
e := acv.a_mblock.mb_trns^.trError_gg00;
&IFDEF TRACE
t01buf( ak_sem, res_buffer.buf, 1, _res_len );
&ENDIF
END;
 
(*------------------------------*) 
 
PROCEDURE
      a59qualified_dml (
            VAR acv   : tak_all_command_glob;
            VAR parsk : tak_parskey);
 
VAR
      _b_err           : tgg00_BasisError;
      _i_handling      : tgg00_HandlingSet;
      _init_ex_kind    : tak_execution_kind;
      _p1_length       : integer;
      _p2_length       : integer;
      _aux_return      : tsp00_Int2;
      _aux_errorpos    : tsp00_Int4;
      _res_cnt         : tsp00_Int4;
      _del_cnt         : integer;
      _pars_key        : tak_parskey;
      _syskey          : tgg00_SysInfoKey;
      _res_name        : tsp00_KnlIdentifier;
      _sparr           : tak_syspointerarr;
      _dmli            : tak_dml_info;
 
BEGIN
a54_dml_init( acv, _dmli, NOT c_in_union );
_syskey := a01sysnullkey;
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  acv.a_ex_kind = only_executing
    THEN
        BEGIN (* call from VAK50 *)
        _res_cnt          := 0;
        _p1_length        := acv.a_cmd_part^.sp1p_buf_len;
        _p2_length        := acv.a_data_length;
        _res_name         := a01_zero_res_name;
        WITH acv.a_resname_addr[ cak_intern_pos ]^.sresname DO
            _syskey.stempid   := a101_GetTempFileIndex (acv, restreeid);
        (*ENDWITH*) 
        _syskey.sentrytyp := cak_ereskey;
        a10get_sysinfo( acv, _syskey, d_fix, _sparr.px[ 2 ], _b_err );
        IF  _b_err = e_ok
        THEN
            BEGIN
            WITH acv.a_resname_addr[ cak_intern_pos ]^.sresname DO
                resexecuted := true;
            (*ENDWITH*) 
            acv.a_qualified_jv_upd := jv_upd_end_release;
            a52internal_subtrans( acv );
            _sparr.px[ 1 ] := NIL;
            (* needed for a505get_change_rec *)
            REPEAT
                a73_one_fetch( acv, _sparr, mm_next, 0 );
&               IFDEF TRACE
                t01int4( ak_sem, 'returncode  ', acv.a_returncode );
&               ENDIF
                IF  acv.a_returncode = 0
                THEN
                    BEGIN
                    acv.a_cmd_part^.sp1p_buf_len  := _p1_length;
                    acv.a_data_length := _p2_length;
                    a501do_execute( acv, _dmli, parsk,
                          NOT c_output_during_execution );
                    _aux_return   := acv.a_returncode;
                    _aux_errorpos := acv.a_errorpos;
                    IF  acv.a_returncode = 0
                    THEN
                        _res_cnt := succ( _res_cnt );
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            UNTIL
                acv.a_returncode <> 0;
            (*ENDREPEAT*) 
&           IFDEF TRACE
            t01int4( ak_sem, 'returncode  ', acv.a_returncode );
            t01int4( ak_sem, 'res_cnt     ', _res_cnt );
            t01int4( ak_sem, 'aux_return  ', _aux_return );
&           ENDIF
            IF  ( acv.a_returncode =
                a071_return_code( e_row_not_found, acv.a_sqlmode )) AND
                ( _res_cnt > 0 ) AND ( _aux_return = 0 )
            THEN
                BEGIN
                acv.a_returncode   := 0;
                a60rescount( acv, _res_cnt );
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        _aux_return   := acv.a_returncode;
        _aux_errorpos := acv.a_errorpos;
        acv.a_returncode     := 0;
        a663_del_result( acv, acv.a_resname_addr[ cak_intern_pos ]^.sresname,
              c_do_cdel, c_del_resname_rec );
        acv.a_returncode := _aux_return;
        acv.a_errorpos   := _aux_errorpos;
        acv.a_qualified_jv_upd         := no_jv_upd
        END
    ELSE
        BEGIN (* call from VAK92 *)
        a663_put_result_info( acv, acv.a_resname_addr[ cak_intern_pos ]);
        _init_ex_kind       := acv.a_ex_kind;
        acv.a_ex_kind       := only_parsing;
        _pars_key           := acv.a_pars_last_key;
        _pars_key.p_no      := 0;
        _pars_key.p_id[ 1 ] := acv.a_first_parsid;
        _pars_key.p_kind    := m_complex;
        WITH _syskey DO
            BEGIN
            sauthid[ 1 ] := cak_tempinfo_byte;
            SAPDB_PascalForcedMove( sizeof( _pars_key ), sizeof( sauthid ), @_pars_key, 1,
                  @sauthid, 2, mxak_parskey );
            sentrytyp := cak_ecomplex;
            END;
        (*ENDWITH*) 
        a10get_sysinfo ( acv, _syskey, d_release, _sparr.px[ 1 ], _b_err );
        IF  _b_err = e_ok
        THEN
            WITH _sparr.px[ 1 ]^, scomplexrec DO
                BEGIN
                comparr[ compcnt ].centryinfo :=
                      comparr[ compcnt ].centryinfo + [ ci_lastpars ];
                acv.a_intern_select_cnt := acv.a_max_intern_select;
                _i_handling := acv.a_transinf.tri_global_state;
                IF  NOT ( hsPermLock_egg00 in _i_handling )
                THEN
                    _i_handling := _i_handling + [ hsTempLock_egg00 ];
                (*ENDIF*) 
                IF  acv.a_qualified_jv_upd = jv_upd_release_locks
                THEN
                    a54_loc_temp_locks( acv, _i_handling, acv.a_p_arr1 );
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  _b_err = e_ok
        THEN
            a10_fix_len_get_sysinfo ( acv, _syskey, d_release, cak_is_undefined,
                  mxak_complex_entry, _sparr.px[ 1 ], _b_err );
        (*ENDIF*) 
        IF  _b_err = e_ok
        THEN
            WITH _sparr.px[ 1 ]^, scomplexrec DO
                BEGIN
                compcnt := succ( compcnt );
                WITH comparr[ compcnt ] DO
                    BEGIN
                    cparsk       := parsk;
                    cnextpars    := compcnt + 1;
                    cqual_jv_upd := jv_upd_end_release;
                    centryinfo   := [ ci_lastpars ];
                    END;
                (*ENDWITH*) 
                b_sl := b_sl + mxak_complex_entry;
                IF  acv.a_qualified_jv_upd = jv_upd_end_release
                THEN
                    a54_loc_temp_locks( acv, _i_handling, acv.a_p_arr1 );
                (*ENDIF*) 
                IF  _init_ex_kind <> only_parsing
                THEN
                    BEGIN
                    acv.a_ex_kind := only_executing;
                    a501do_execute( acv, _dmli, _pars_key,
                          NOT c_output_during_execution );
                    _aux_return   := acv.a_returncode;
                    _aux_errorpos := acv.a_errorpos;
                    acv.a_returncode     := 0;
                    a660_prefix_delete( acv,
                          _pars_key, _del_cnt, cak_complete_prefix );
                    acv.a_returncode := _aux_return;
                    acv.a_errorpos   := _aux_errorpos;
                    END;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  _b_err <> e_ok
    THEN
        a07_b_put_error( acv, _b_err, 1 );
    (*ENDIF*) 
    END;
(*ENDIF*) 
a54_dml_finalize( _dmli, acv.a_transinf.tri_trans );
END;
 
(*------------------------------*) 
 
FUNCTION
      ak59get_analyzed(
            structure     : tak59_boolptr;
            max_dimension : tsp00_Int2;
            dim1          : tsp00_Int2;
            dim2          : tsp00_Int2 ) : tak59_boolptr;
 
VAR
 
      _cast : RECORD
            CASE boolean OF
                true :
                    (addr: tsp00_MoveObjPtr);
                false :
                    (bptr : tak59_boolptr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
_cast.addr := s35add_moveobj_ptr_ptocm( @(structure^),
      ((dim1 - 1) * max_dimension * sizeof( boolean ) +
      (dim2 - 1) * sizeof( boolean )));
ak59get_analyzed := _cast.bptr;
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
